1:2c4ac98: /*
1:07cdfd0:  *
1:2c4ac98:  * Licensed to the Apache Software Foundation (ASF) under one
1:2c4ac98:  * or more contributor license agreements.  See the NOTICE file
1:2c4ac98:  * distributed with this work for additional information
1:2c4ac98:  * regarding copyright ownership.  The ASF licenses this file
1:2c4ac98:  * to you under the Apache License, Version 2.0 (the
1:2c4ac98:  * "License"); you may not use this file except in compliance
1:2c4ac98:  * with the License.  You may obtain a copy of the License at
1:07cdfd0:  *
1:2c4ac98:  *   http://www.apache.org/licenses/LICENSE-2.0
1:07cdfd0:  *
1:2c4ac98:  * Unless required by applicable law or agreed to in writing,
1:2c4ac98:  * software distributed under the License is distributed on an
1:2c4ac98:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:2c4ac98:  * KIND, either express or implied.  See the License for the
1:2c4ac98:  * specific language governing permissions and limitations
1:2c4ac98:  * under the License.
1:07cdfd0:  *
2:2c4ac98:  */
1:2c4ac98: package org.apache.cassandra.db.context;
1:2fd3268: 
1:f3630a6: import java.nio.ByteBuffer;
1:07cdfd0: 
1:9797511: import org.junit.BeforeClass;
1:2c4ac98: import org.junit.Test;
1:07cdfd0: 
1:1a3b5db: import org.apache.cassandra.Util;
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:714c423: import org.apache.cassandra.db.ClockAndCount;
1:714c423: import org.apache.cassandra.db.context.CounterContext.Relationship;
1:1a3b5db: import org.apache.cassandra.utils.ByteBufferUtil;
1:1a3b5db: import org.apache.cassandra.utils.CounterId;
1:b95a49c: 
1:83cd80b: import static org.apache.cassandra.db.context.CounterContext.ContextState;
1:1a3b5db: import static org.junit.Assert.assertEquals;
1:1a3b5db: import static org.junit.Assert.assertFalse;
1:1a3b5db: import static org.junit.Assert.assertNotSame;
1:1a3b5db: import static org.junit.Assert.assertSame;
1:1a3b5db: import static org.junit.Assert.assertTrue;
1:2effc40: 
1:2c4ac98: public class CounterContextTest
1:b95a49c: {
1:2c4ac98:     private static final CounterContext cc = new CounterContext();
1:b95a49c: 
1:83cd80b:     private static final int headerSizeLength = 2;
1:83cd80b:     private static final int headerEltLength = 2;
1:83cd80b:     private static final int idLength = 16;
1:83cd80b:     private static final int clockLength = 8;
1:83cd80b:     private static final int countLength = 8;
1:83cd80b:     private static final int stepLength = idLength + clockLength + countLength;
1:1a3b5db: 
1:9797511:     @BeforeClass
1:9797511:     public static void setupDD()
1:9797511:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511:     }
1:9797511: 
1:4d8ae4d:     @Test
1:83cd80b:     public void testAllocate()
1:1a3b5db:     {
1:8a2a0c3:         ContextState allGlobal = ContextState.allocate(3, 0, 0);
1:83cd80b:         assertEquals(headerSizeLength + 3 * headerEltLength + 3 * stepLength, allGlobal.context.remaining());
1:1a3b5db: 
1:8a2a0c3:         ContextState allLocal = ContextState.allocate(0, 3, 0);
1:83cd80b:         assertEquals(headerSizeLength + 3 * headerEltLength + 3 * stepLength, allLocal.context.remaining());
1:83cd80b: 
1:8a2a0c3:         ContextState allRemote = ContextState.allocate(0, 0, 3);
1:83cd80b:         assertEquals(headerSizeLength + 3 * stepLength, allRemote.context.remaining());
1:83cd80b: 
1:8a2a0c3:         ContextState mixed = ContextState.allocate(1, 1, 1);
1:83cd80b:         assertEquals(headerSizeLength + 2 * headerEltLength + 3 * stepLength, mixed.context.remaining());
1:1a3b5db:     }
1:83cd80b: 
1:4d8ae4d:     @Test
1:2c4ac98:     public void testDiff()
1:b95a49c:     {
1:83cd80b:         ContextState left;
1:ab5a8c7:         ContextState right;
1:4b54b8a: 
1:2c4ac98:         // equality: equal nodes, all counts same
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:83cd80b:         right = ContextState.wrap(ByteBufferUtil.clone(left.context));
1:b95a49c: 
1:714c423:         assertEquals(Relationship.EQUAL, cc.diff(left.context, right.context));
1:b95a49c: 
1:2c4ac98:         // greater than: left has superset of nodes (counts equal)
1:8a2a0c3:         left = ContextState.allocate(0, 0, 4);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3),  3L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6),  2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9),  1L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(12), 0L, 0L);
1:b95a49c: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 3);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:b95a49c: 
1:714c423:         assertEquals(Relationship.GREATER_THAN, cc.diff(left.context, right.context));
1:b95a49c: 
1:2c4ac98:         // less than: left has subset of nodes (counts equal)
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:2fd3268: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 4);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3),  3L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6),  2L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9),  1L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(12), 0L, 0L);
1:4d8ae4d: 
1:714c423:         assertEquals(Relationship.LESS_THAN, cc.diff(left.context, right.context));
1:4d8ae4d: 
1:2c4ac98:         // greater than: equal nodes, but left has higher counts
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 3L, 0L);
1:4d8ae4d: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 3);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:4d8ae4d: 
1:714c423:         assertEquals(Relationship.GREATER_THAN, cc.diff(left.context, right.context));
1:4d8ae4d: 
1:2c4ac98:         // less than: equal nodes, but right has higher counts
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 3L, 0L);
1:4d8ae4d: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 3);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6), 9L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9), 3L, 0L);
1:4d8ae4d: 
1:714c423:         assertEquals(Relationship.LESS_THAN, cc.diff(left.context, right.context));
1:4d8ae4d: 
1:2c4ac98:         // disjoint: right and left have disjoint node sets
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(4), 1L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:4d8ae4d: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 3);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6), 1L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:4d8ae4d: 
1:714c423:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
1:4d8ae4d: 
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(4), 1L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:4d8ae4d: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 3);
1:83cd80b:         right.writeRemote(CounterId.fromInt(2),  1L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6),  1L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(12), 1L, 0L);
1:4d8ae4d: 
1:714c423:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
1:17ad4cc: 
1:2c4ac98:         // disjoint: equal nodes, but right and left have higher counts in differing nodes
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6), 3L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:ab5a8c7: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 3);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6), 1L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9), 5L, 0L);
1:ab5a8c7: 
1:714c423:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
1:ab5a8c7: 
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6), 3L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:ab5a8c7: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 3);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6), 9L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9), 5L, 0L);
1:ab5a8c7: 
1:714c423:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
1:ab5a8c7: 
1:2c4ac98:         // disjoint: left has more nodes, but lower counts
1:8a2a0c3:         left = ContextState.allocate(0, 0, 4);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3),  2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6),  3L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9),  1L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(12), 1L, 0L);
1:ab5a8c7: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 3);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3), 4L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6), 9L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9), 5L, 0L);
1:ab5a8c7: 
1:714c423:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
1:ab5a8c7: 
1:2c4ac98:         // disjoint: left has less nodes, but higher counts
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 5L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6), 3L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 2L, 0L);
1:ab5a8c7: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 4);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3),  4L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6),  3L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9),  2L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(12), 1L, 0L);
56:2c4ac98: 
1:714c423:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
1:2c4ac98: 
1:2c4ac98:         // disjoint: mixed nodes and counts
1:8a2a0c3:         left = ContextState.allocate(0, 0, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 5L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 2L, 0L);
1:2c4ac98: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 4);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3),  4L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6),  3L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9),  2L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(12), 1L, 0L);
1:2c4ac98: 
1:714c423:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
1:2c4ac98: 
1:8a2a0c3:         left = ContextState.allocate(0, 0, 4);
1:83cd80b:         left.writeRemote(CounterId.fromInt(3), 5L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(7), 2L, 0L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(9), 2L, 0L);
1:2c4ac98: 
1:8a2a0c3:         right = ContextState.allocate(0, 0, 3);
1:83cd80b:         right.writeRemote(CounterId.fromInt(3), 4L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(6), 3L, 0L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(9), 2L, 0L);
1:2c4ac98: 
1:714c423:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
1:b95a49c:     }
1:2c4ac98: 
1:ab5a8c7:     @Test
1:2c4ac98:     public void testMerge()
1:b95a49c:     {
1:2c4ac98:         // note: local counts aggregated; remote counts are reconciled (i.e. take max)
1:8a2a0c3:         ContextState left = ContextState.allocate(0, 1, 3);
1:83cd80b:         left.writeRemote(CounterId.fromInt(1), 1L, 1L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(2), 2L, 2L);
1:83cd80b:         left.writeRemote(CounterId.fromInt(4), 6L, 3L);
1:83cd80b:         left.writeLocal(CounterId.getLocalId(), 7L, 3L);
1:2c4ac98: 
1:8a2a0c3:         ContextState right = ContextState.allocate(0, 1, 2);
1:83cd80b:         right.writeRemote(CounterId.fromInt(4), 4L, 4L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(5), 5L, 5L);
1:83cd80b:         right.writeLocal(CounterId.getLocalId(), 2L, 9L);
1:2c4ac98: 
1:8a2a0c3:         ByteBuffer merged = cc.merge(left.context, right.context);
1:ab5a8c7:         int hd = 4;
1:2c4ac98: 
1:ab5a8c7:         assertEquals(hd + 5 * stepLength, merged.remaining());
1:2c4ac98:         // local node id's counts are aggregated
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.getLocalId(), merged, hd + 4 * stepLength));
1:83cd80b:         assertEquals(9L, merged.getLong(merged.position() + hd + 4 * stepLength + idLength));
1:b95a49c:         assertEquals(12L,  merged.getLong(merged.position() + hd + 4*stepLength + idLength + clockLength));
1:2c4ac98: 
1:2c4ac98:         // remote node id counts are reconciled (i.e. take max)
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(4), merged, hd + 2 * stepLength));
1:83cd80b:         assertEquals(6L, merged.getLong(merged.position() + hd + 2 * stepLength + idLength));
1:b95a49c:         assertEquals( 3L,  merged.getLong(merged.position() + hd + 2*stepLength + idLength + clockLength));
1:2c4ac98: 
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(5), merged, hd + 3 * stepLength));
1:83cd80b:         assertEquals(5L, merged.getLong(merged.position() + hd + 3 * stepLength + idLength));
1:b95a49c:         assertEquals( 5L,  merged.getLong(merged.position() + hd + 3*stepLength + idLength + clockLength));
1:2c4ac98: 
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), merged, hd + stepLength));
1:83cd80b:         assertEquals(2L, merged.getLong(merged.position() + hd + stepLength + idLength));
1:83cd80b:         assertEquals( 2L,  merged.getLong(merged.position() + hd + stepLength + idLength + clockLength));
1:2c4ac98: 
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), merged, hd));
1:83cd80b:         assertEquals( 1L,  merged.getLong(merged.position() + hd + idLength));
1:83cd80b:         assertEquals( 1L,  merged.getLong(merged.position() + hd + idLength + clockLength));
1:83cd80b: 
1:83cd80b:         //
1:83cd80b:         // Test merging two exclusively global contexts
1:83cd80b:         //
1:8a2a0c3:         left = ContextState.allocate(3, 0, 0);
1:83cd80b:         left.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:83cd80b:         left.writeGlobal(CounterId.fromInt(2), 2L, 2L);
1:83cd80b:         left.writeGlobal(CounterId.fromInt(3), 3L, 3L);
1:83cd80b: 
1:8a2a0c3:         right = ContextState.allocate(3, 0, 0);
1:83cd80b:         right.writeGlobal(CounterId.fromInt(3), 6L, 6L);
1:83cd80b:         right.writeGlobal(CounterId.fromInt(4), 4L, 4L);
1:83cd80b:         right.writeGlobal(CounterId.fromInt(5), 5L, 5L);
1:83cd80b: 
1:8a2a0c3:         merged = cc.merge(left.context, right.context);
1:83cd80b:         assertEquals(headerSizeLength + 5 * headerEltLength + 5 * stepLength, merged.remaining());
1:83cd80b:         assertEquals(18L, cc.total(merged));
1:83cd80b:         assertEquals(5, merged.getShort(merged.position()));
1:83cd80b: 
1:83cd80b:         int headerLength = headerSizeLength + 5 * headerEltLength;
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), merged, headerLength));
1:83cd80b:         assertEquals(1L, merged.getLong(merged.position() + headerLength + idLength));
1:83cd80b:         assertEquals(1L, merged.getLong(merged.position() + headerLength + idLength + clockLength));
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), merged, headerLength + stepLength));
1:83cd80b:         assertEquals(2L, merged.getLong(merged.position() + headerLength + stepLength + idLength));
1:83cd80b:         assertEquals(2L, merged.getLong(merged.position() + headerLength + stepLength + idLength + clockLength));
1:83cd80b:         // pick the global shard with the largest clock
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(3), merged, headerLength + 2 * stepLength));
1:83cd80b:         assertEquals(6L, merged.getLong(merged.position() + headerLength + 2 * stepLength + idLength));
1:83cd80b:         assertEquals(6L, merged.getLong(merged.position() + headerLength + 2 * stepLength + idLength + clockLength));
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(4), merged, headerLength + 3 * stepLength));
1:83cd80b:         assertEquals(4L, merged.getLong(merged.position() + headerLength + 3 * stepLength + idLength));
1:83cd80b:         assertEquals(4L, merged.getLong(merged.position() + headerLength + 3 * stepLength + idLength + clockLength));
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(5), merged, headerLength + 4 * stepLength));
1:83cd80b:         assertEquals(5L, merged.getLong(merged.position() + headerLength + 4 * stepLength + idLength));
1:83cd80b:         assertEquals(5L, merged.getLong(merged.position() + headerLength + 4 * stepLength + idLength + clockLength));
1:83cd80b: 
1:83cd80b:         //
1:83cd80b:         // Test merging two global contexts w/ 'invalid shards'
1:83cd80b:         //
1:8a2a0c3:         left = ContextState.allocate(1, 0, 0);
1:83cd80b:         left.writeGlobal(CounterId.fromInt(1), 10L, 20L);
1:83cd80b: 
1:8a2a0c3:         right = ContextState.allocate(1, 0, 0);
1:83cd80b:         right.writeGlobal(CounterId.fromInt(1), 10L, 30L);
1:83cd80b: 
1:8a2a0c3:         merged = cc.merge(left.context, right.context);
1:83cd80b:         headerLength = headerSizeLength + headerEltLength;
1:83cd80b:         assertEquals(headerLength + stepLength, merged.remaining());
1:83cd80b:         assertEquals(30L, cc.total(merged));
1:83cd80b:         assertEquals(1, merged.getShort(merged.position()));
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), merged, headerLength));
1:83cd80b:         assertEquals(10L, merged.getLong(merged.position() + headerLength + idLength));
1:83cd80b:         // with equal clock, we should pick the largest value
1:83cd80b:         assertEquals(30L, merged.getLong(merged.position() + headerLength + idLength + clockLength));
1:83cd80b: 
1:83cd80b:         //
1:83cd80b:         // Test merging global w/ mixed contexts
1:83cd80b:         //
1:8a2a0c3:         left = ContextState.allocate(2, 0, 0);
1:83cd80b:         left.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:83cd80b:         left.writeGlobal(CounterId.fromInt(2), 1L, 1L);
1:83cd80b: 
1:8a2a0c3:         right = ContextState.allocate(0, 1, 1);
1:83cd80b:         right.writeLocal(CounterId.fromInt(1), 100L, 100L);
1:83cd80b:         right.writeRemote(CounterId.fromInt(2), 100L, 100L);
1:83cd80b: 
1:83cd80b:         // global shards should dominate local/remote, even with lower clock and value
1:8a2a0c3:         merged = cc.merge(left.context, right.context);
1:83cd80b:         headerLength = headerSizeLength + 2 * headerEltLength;
1:83cd80b:         assertEquals(headerLength + 2 * stepLength, merged.remaining());
1:83cd80b:         assertEquals(2L, cc.total(merged));
1:83cd80b:         assertEquals(2, merged.getShort(merged.position()));
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), merged, headerLength));
1:83cd80b:         assertEquals(1L, merged.getLong(merged.position() + headerLength + idLength));
1:83cd80b:         assertEquals(1L, merged.getLong(merged.position() + headerLength + idLength + clockLength));
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), merged, headerLength + stepLength));
1:83cd80b:         assertEquals(1L, merged.getLong(merged.position() + headerLength + stepLength + idLength));
1:83cd80b:         assertEquals(1L, merged.getLong(merged.position() + headerLength + stepLength + idLength + clockLength));
1:b95a49c:     }
1:2c4ac98: 
9:2c4ac98:     @Test
1:2c4ac98:     public void testTotal()
1:b95a49c:     {
1:8a2a0c3:         ContextState mixed = ContextState.allocate(0, 1, 4);
1:83cd80b:         mixed.writeRemote(CounterId.fromInt(1), 1L, 1L);
1:83cd80b:         mixed.writeRemote(CounterId.fromInt(2), 2L, 2L);
1:83cd80b:         mixed.writeRemote(CounterId.fromInt(4), 4L, 4L);
1:83cd80b:         mixed.writeRemote(CounterId.fromInt(5), 5L, 5L);
1:83cd80b:         mixed.writeLocal(CounterId.getLocalId(), 12L, 12L);
1:83cd80b:         assertEquals(24L, cc.total(mixed.context));
1:b95a49c: 
1:8a2a0c3:         ContextState global = ContextState.allocate(3, 0, 0);
1:83cd80b:         global.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:83cd80b:         global.writeGlobal(CounterId.fromInt(2), 2L, 2L);
1:83cd80b:         global.writeGlobal(CounterId.fromInt(3), 3L, 3L);
1:83cd80b:         assertEquals(6L, cc.total(global.context));
1:b95a49c:     }
1:2c4ac98: 
1:2c4ac98:     @Test
1:83cd80b:     public void testClearLocal()
1:b95a49c:     {
1:83cd80b:         ContextState state;
1:83cd80b:         ByteBuffer marked;
1:83cd80b:         ByteBuffer cleared;
1:2c4ac98: 
1:83cd80b:         // mark/clear for remote-only contexts is a no-op
1:8a2a0c3:         state = ContextState.allocate(0, 0, 1);
1:83cd80b:         state.writeRemote(CounterId.fromInt(1), 1L, 1L);
1:2c4ac98: 
1:83cd80b:         assertFalse(cc.shouldClearLocal(state.context));
1:83cd80b:         marked = cc.markLocalToBeCleared(state.context);
1:83cd80b:         assertEquals(0, marked.getShort(marked.position()));
1:83cd80b:         assertSame(state.context, marked); // should return the original context
1:2c4ac98: 
1:83cd80b:         cleared = cc.clearAllLocal(marked);
1:83cd80b:         assertSame(cleared, marked); // shouldn't alter anything either
1:2c4ac98: 
1:83cd80b:         // a single local shard
1:8a2a0c3:         state = ContextState.allocate(0, 1, 0);
1:83cd80b:         state.writeLocal(CounterId.fromInt(1), 1L, 1L);
1:2c4ac98: 
1:83cd80b:         assertFalse(cc.shouldClearLocal(state.context));
1:83cd80b:         marked = cc.markLocalToBeCleared(state.context);
1:83cd80b:         assertTrue(cc.shouldClearLocal(marked));
1:83cd80b:         assertEquals(-1, marked.getShort(marked.position()));
1:83cd80b:         assertNotSame(state.context, marked); // shouldn't alter in place, as it used to do
1:2c4ac98: 
1:83cd80b:         cleared = cc.clearAllLocal(marked);
1:83cd80b:         assertFalse(cc.shouldClearLocal(cleared));
1:83cd80b:         assertEquals(0, cleared.getShort(cleared.position()));
1:2c4ac98: 
1:83cd80b:         // 2 global + 1 local shard
1:8a2a0c3:         state = ContextState.allocate(2, 1, 0);
1:83cd80b:         state.writeLocal(CounterId.fromInt(1), 1L, 1L);
1:83cd80b:         state.writeGlobal(CounterId.fromInt(2), 2L, 2L);
1:83cd80b:         state.writeGlobal(CounterId.fromInt(3), 3L, 3L);
1:2c4ac98: 
1:83cd80b:         assertFalse(cc.shouldClearLocal(state.context));
1:83cd80b:         marked = cc.markLocalToBeCleared(state.context);
1:83cd80b:         assertTrue(cc.shouldClearLocal(marked));
1:2c4ac98: 
1:83cd80b:         assertEquals(-3, marked.getShort(marked.position()));
1:83cd80b:         assertEquals(0, marked.getShort(marked.position() + headerSizeLength));
1:83cd80b:         assertEquals(Short.MIN_VALUE + 1, marked.getShort(marked.position() + headerSizeLength + headerEltLength));
1:83cd80b:         assertEquals(Short.MIN_VALUE + 2, marked.getShort(marked.position() + headerSizeLength + 2 * headerEltLength));
1:2c4ac98: 
1:83cd80b:         int headerLength = headerSizeLength + 3 * headerEltLength;
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), marked, headerLength));
1:83cd80b:         assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength));
1:83cd80b:         assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength + clockLength));
1:2c4ac98: 
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), marked, headerLength + stepLength));
1:83cd80b:         assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength));
1:83cd80b:         assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength + clockLength));
1:2c4ac98: 
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(3), marked, headerLength + 2 * stepLength));
1:83cd80b:         assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength));
1:83cd80b:         assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength + clockLength));
1:2c4ac98: 
1:83cd80b:         cleared = cc.clearAllLocal(marked);
1:83cd80b:         assertFalse(cc.shouldClearLocal(cleared));
1:2c4ac98: 
1:83cd80b:         assertEquals(2, cleared.getShort(cleared.position())); // 2 global shards
1:83cd80b:         assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength));
1:83cd80b:         assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength));
1:2c4ac98: 
1:83cd80b:         headerLength = headerSizeLength + 2 * headerEltLength;
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), cleared, headerLength));
1:83cd80b:         assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength));
1:83cd80b:         assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength + clockLength));
1:2c4ac98: 
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), cleared, headerLength + stepLength));
1:83cd80b:         assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength));
1:83cd80b:         assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength + clockLength));
1:2c4ac98: 
1:83cd80b:         assertTrue(Util.equalsCounterId(CounterId.fromInt(3), cleared, headerLength + 2 * stepLength));
1:83cd80b:         assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength));
1:83cd80b:         assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength + clockLength));
1:2c4ac98: 
1:83cd80b:         // a single global shard - no-op
1:8a2a0c3:         state = ContextState.allocate(1, 0, 0);
1:83cd80b:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:2c4ac98: 
1:83cd80b:         assertFalse(cc.shouldClearLocal(state.context));
1:83cd80b:         marked = cc.markLocalToBeCleared(state.context);
1:83cd80b:         assertEquals(1, marked.getShort(marked.position()));
1:83cd80b:         assertSame(state.context, marked);
1:2c4ac98: 
1:83cd80b:         cleared = cc.clearAllLocal(marked);
1:83cd80b:         assertSame(cleared, marked);
1:b95a49c:     }
1:714c423: 
1:714c423:     @Test
1:714c423:     public void testFindPositionOf()
1:714c423:     {
1:8a2a0c3:         ContextState state = ContextState.allocate(3, 3, 3);
1:714c423: 
1:714c423:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:714c423:         state.writeRemote(CounterId.fromInt(2), 2L, 2L);
1:714c423:         state.writeLocal( CounterId.fromInt(3), 3L, 3L);
1:714c423:         state.writeGlobal(CounterId.fromInt(4), 4L, 4L);
1:714c423:         state.writeRemote(CounterId.fromInt(5), 5L, 5L);
1:714c423:         state.writeLocal( CounterId.fromInt(6), 6L, 6L);
1:714c423:         state.writeGlobal(CounterId.fromInt(7), 7L, 7L);
1:714c423:         state.writeRemote(CounterId.fromInt(8), 8L, 8L);
1:714c423:         state.writeLocal(CounterId.fromInt(9), 9L, 9L);
1:714c423: 
1:714c423:         int headerLength = headerSizeLength + 6 * headerEltLength;
1:714c423:         assertEquals(headerLength, cc.findPositionOf(state.context, CounterId.fromInt(1)));
1:714c423:         assertEquals(headerLength + stepLength, cc.findPositionOf(state.context, CounterId.fromInt(2)));
1:714c423:         assertEquals(headerLength + 2 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(3)));
1:714c423:         assertEquals(headerLength + 3 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(4)));
1:714c423:         assertEquals(headerLength + 4 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(5)));
1:714c423:         assertEquals(headerLength + 5 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(6)));
1:714c423:         assertEquals(headerLength + 6 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(7)));
1:714c423:         assertEquals(headerLength + 7 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(8)));
1:714c423:         assertEquals(headerLength + 8 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(9)));
1:714c423: 
1:714c423:         assertEquals(-1, cc.findPositionOf(state.context, CounterId.fromInt(0)));
1:714c423:         assertEquals(-1, cc.findPositionOf(state.context, CounterId.fromInt(10)));
1:714c423:         assertEquals(-1, cc.findPositionOf(state.context, CounterId.fromInt(15)));
1:714c423:         assertEquals(-1, cc.findPositionOf(state.context, CounterId.fromInt(20)));
1:714c423:     }
1:714c423: 
1:714c423:     @Test
1:714c423:     public void testGetGlockAndCountOf()
1:714c423:     {
1:8a2a0c3:         ContextState state = ContextState.allocate(3, 3, 3);
1:714c423: 
1:714c423:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:714c423:         state.writeRemote(CounterId.fromInt(2), 2L, 2L);
1:714c423:         state.writeLocal( CounterId.fromInt(3), 3L, 3L);
1:714c423:         state.writeGlobal(CounterId.fromInt(4), 4L, 4L);
1:714c423:         state.writeRemote(CounterId.fromInt(5), 5L, 5L);
1:714c423:         state.writeLocal( CounterId.fromInt(6), 6L, 6L);
1:714c423:         state.writeGlobal(CounterId.fromInt(7), 7L, 7L);
1:714c423:         state.writeRemote(CounterId.fromInt(8), 8L, 8L);
1:714c423:         state.writeLocal(CounterId.fromInt(9), 9L, 9L);
1:714c423: 
1:714c423:         assertEquals(ClockAndCount.create(1L, 1L), cc.getClockAndCountOf(state.context, CounterId.fromInt(1)));
1:714c423:         assertEquals(ClockAndCount.create(2L, 2L), cc.getClockAndCountOf(state.context, CounterId.fromInt(2)));
1:714c423:         assertEquals(ClockAndCount.create(3L, 3L), cc.getClockAndCountOf(state.context, CounterId.fromInt(3)));
1:714c423:         assertEquals(ClockAndCount.create(4L, 4L), cc.getClockAndCountOf(state.context, CounterId.fromInt(4)));
1:714c423:         assertEquals(ClockAndCount.create(5L, 5L), cc.getClockAndCountOf(state.context, CounterId.fromInt(5)));
1:714c423:         assertEquals(ClockAndCount.create(6L, 6L), cc.getClockAndCountOf(state.context, CounterId.fromInt(6)));
1:714c423:         assertEquals(ClockAndCount.create(7L, 7L), cc.getClockAndCountOf(state.context, CounterId.fromInt(7)));
1:714c423:         assertEquals(ClockAndCount.create(8L, 8L), cc.getClockAndCountOf(state.context, CounterId.fromInt(8)));
1:714c423:         assertEquals(ClockAndCount.create(9L, 9L), cc.getClockAndCountOf(state.context, CounterId.fromInt(9)));
1:714c423: 
1:714c423:         assertEquals(ClockAndCount.create(0L, 0L), cc.getClockAndCountOf(state.context, CounterId.fromInt(0)));
1:714c423:         assertEquals(ClockAndCount.create(0L, 0L), cc.getClockAndCountOf(state.context, CounterId.fromInt(10)));
1:714c423:         assertEquals(ClockAndCount.create(0L, 0L), cc.getClockAndCountOf(state.context, CounterId.fromInt(15)));
1:714c423:         assertEquals(ClockAndCount.create(0L, 0L), cc.getClockAndCountOf(state.context, CounterId.fromInt(20)));
1:714c423:     }
1:b95a49c: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setupDD()
1:     {
1:         DatabaseDescriptor.daemonInitialization();
1:     }
1: 
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:1a3b5db
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.cassandra.utils.CounterId;
0: import org.apache.cassandra.utils.memory.AbstractAllocator;
0: import org.apache.cassandra.utils.memory.Pool;
0: import org.apache.cassandra.utils.memory.SlabPool;
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNotSame;
1: import static org.junit.Assert.assertSame;
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
0:     private static final Pool POOL = new SlabPool(Integer.MAX_VALUE, 0, 1f, null);
1: 
0:     /** Allocates 1 byte from a new SlabAllocator and returns it. */
0:     private AbstractAllocator bumpedSlab()
1:     {
0:         AbstractAllocator allocator = POOL.newAllocator();
0:         allocator.allocate(1);
0:         return allocator;
1:     }
1: 
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:8a2a0c3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ContextState allGlobal = ContextState.allocate(3, 0, 0);
1:         ContextState allLocal = ContextState.allocate(0, 3, 0);
1:         ContextState allRemote = ContextState.allocate(0, 0, 3);
1:         ContextState mixed = ContextState.allocate(1, 1, 1);
1:         left = ContextState.allocate(0, 0, 3);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 4);
1:         right = ContextState.allocate(0, 0, 3);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 3);
1:         right = ContextState.allocate(0, 0, 4);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 3);
1:         right = ContextState.allocate(0, 0, 3);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 3);
1:         right = ContextState.allocate(0, 0, 3);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 3);
1:         right = ContextState.allocate(0, 0, 3);
1:         left = ContextState.allocate(0, 0, 3);
1:         right = ContextState.allocate(0, 0, 3);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 3);
1:         right = ContextState.allocate(0, 0, 3);
1:         left = ContextState.allocate(0, 0, 3);
1:         right = ContextState.allocate(0, 0, 3);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 4);
1:         right = ContextState.allocate(0, 0, 3);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 3);
1:         right = ContextState.allocate(0, 0, 4);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 3);
1:         right = ContextState.allocate(0, 0, 4);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(0, 0, 4);
1:         right = ContextState.allocate(0, 0, 3);
/////////////////////////////////////////////////////////////////////////
1:         ContextState left = ContextState.allocate(0, 1, 3);
1:         ContextState right = ContextState.allocate(0, 1, 2);
1:         ByteBuffer merged = cc.merge(left.context, right.context);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(3, 0, 0);
1:         right = ContextState.allocate(3, 0, 0);
1:         merged = cc.merge(left.context, right.context);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(1, 0, 0);
1:         right = ContextState.allocate(1, 0, 0);
1:         merged = cc.merge(left.context, right.context);
/////////////////////////////////////////////////////////////////////////
1:         left = ContextState.allocate(2, 0, 0);
1:         right = ContextState.allocate(0, 1, 1);
1:         merged = cc.merge(left.context, right.context);
/////////////////////////////////////////////////////////////////////////
1:         ContextState mixed = ContextState.allocate(0, 1, 4);
/////////////////////////////////////////////////////////////////////////
1:         ContextState global = ContextState.allocate(3, 0, 0);
/////////////////////////////////////////////////////////////////////////
1:         state = ContextState.allocate(0, 0, 1);
/////////////////////////////////////////////////////////////////////////
1:         state = ContextState.allocate(0, 1, 0);
/////////////////////////////////////////////////////////////////////////
1:         state = ContextState.allocate(2, 1, 0);
/////////////////////////////////////////////////////////////////////////
1:         state = ContextState.allocate(1, 0, 0);
/////////////////////////////////////////////////////////////////////////
1:         ContextState state = ContextState.allocate(3, 3, 3);
/////////////////////////////////////////////////////////////////////////
1:         ContextState state = ContextState.allocate(3, 3, 3);
commit:714c423
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.ClockAndCount;
1: import org.apache.cassandra.db.context.CounterContext.Relationship;
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.EQUAL, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.GREATER_THAN, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.LESS_THAN, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.GREATER_THAN, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.LESS_THAN, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Relationship.DISJOINT, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testFindPositionOf()
1:     {
0:         ContextState state = ContextState.allocate(3, 3, 3, HeapAllocator.instance);
1: 
1:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:         state.writeRemote(CounterId.fromInt(2), 2L, 2L);
1:         state.writeLocal( CounterId.fromInt(3), 3L, 3L);
1:         state.writeGlobal(CounterId.fromInt(4), 4L, 4L);
1:         state.writeRemote(CounterId.fromInt(5), 5L, 5L);
1:         state.writeLocal( CounterId.fromInt(6), 6L, 6L);
1:         state.writeGlobal(CounterId.fromInt(7), 7L, 7L);
1:         state.writeRemote(CounterId.fromInt(8), 8L, 8L);
1:         state.writeLocal(CounterId.fromInt(9), 9L, 9L);
1: 
1:         int headerLength = headerSizeLength + 6 * headerEltLength;
1:         assertEquals(headerLength, cc.findPositionOf(state.context, CounterId.fromInt(1)));
1:         assertEquals(headerLength + stepLength, cc.findPositionOf(state.context, CounterId.fromInt(2)));
1:         assertEquals(headerLength + 2 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(3)));
1:         assertEquals(headerLength + 3 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(4)));
1:         assertEquals(headerLength + 4 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(5)));
1:         assertEquals(headerLength + 5 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(6)));
1:         assertEquals(headerLength + 6 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(7)));
1:         assertEquals(headerLength + 7 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(8)));
1:         assertEquals(headerLength + 8 * stepLength, cc.findPositionOf(state.context, CounterId.fromInt(9)));
1: 
1:         assertEquals(-1, cc.findPositionOf(state.context, CounterId.fromInt(0)));
1:         assertEquals(-1, cc.findPositionOf(state.context, CounterId.fromInt(10)));
1:         assertEquals(-1, cc.findPositionOf(state.context, CounterId.fromInt(15)));
1:         assertEquals(-1, cc.findPositionOf(state.context, CounterId.fromInt(20)));
1:     }
1: 
1:     @Test
1:     public void testGetGlockAndCountOf()
1:     {
0:         ContextState state = ContextState.allocate(3, 3, 3, HeapAllocator.instance);
1: 
1:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:         state.writeRemote(CounterId.fromInt(2), 2L, 2L);
1:         state.writeLocal( CounterId.fromInt(3), 3L, 3L);
1:         state.writeGlobal(CounterId.fromInt(4), 4L, 4L);
1:         state.writeRemote(CounterId.fromInt(5), 5L, 5L);
1:         state.writeLocal( CounterId.fromInt(6), 6L, 6L);
1:         state.writeGlobal(CounterId.fromInt(7), 7L, 7L);
1:         state.writeRemote(CounterId.fromInt(8), 8L, 8L);
1:         state.writeLocal(CounterId.fromInt(9), 9L, 9L);
1: 
1:         assertEquals(ClockAndCount.create(1L, 1L), cc.getClockAndCountOf(state.context, CounterId.fromInt(1)));
1:         assertEquals(ClockAndCount.create(2L, 2L), cc.getClockAndCountOf(state.context, CounterId.fromInt(2)));
1:         assertEquals(ClockAndCount.create(3L, 3L), cc.getClockAndCountOf(state.context, CounterId.fromInt(3)));
1:         assertEquals(ClockAndCount.create(4L, 4L), cc.getClockAndCountOf(state.context, CounterId.fromInt(4)));
1:         assertEquals(ClockAndCount.create(5L, 5L), cc.getClockAndCountOf(state.context, CounterId.fromInt(5)));
1:         assertEquals(ClockAndCount.create(6L, 6L), cc.getClockAndCountOf(state.context, CounterId.fromInt(6)));
1:         assertEquals(ClockAndCount.create(7L, 7L), cc.getClockAndCountOf(state.context, CounterId.fromInt(7)));
1:         assertEquals(ClockAndCount.create(8L, 8L), cc.getClockAndCountOf(state.context, CounterId.fromInt(8)));
1:         assertEquals(ClockAndCount.create(9L, 9L), cc.getClockAndCountOf(state.context, CounterId.fromInt(9)));
1: 
1:         assertEquals(ClockAndCount.create(0L, 0L), cc.getClockAndCountOf(state.context, CounterId.fromInt(0)));
1:         assertEquals(ClockAndCount.create(0L, 0L), cc.getClockAndCountOf(state.context, CounterId.fromInt(10)));
1:         assertEquals(ClockAndCount.create(0L, 0L), cc.getClockAndCountOf(state.context, CounterId.fromInt(15)));
1:         assertEquals(ClockAndCount.create(0L, 0L), cc.getClockAndCountOf(state.context, CounterId.fromInt(20)));
1:     }
commit:83cd80b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.Util;
1: import static org.apache.cassandra.db.context.CounterContext.ContextState;
1:     private static final int headerSizeLength = 2;
1:     private static final int headerEltLength = 2;
1:     private static final int idLength = 16;
1:     private static final int clockLength = 8;
1:     private static final int countLength = 8;
1:     private static final int stepLength = idLength + clockLength + countLength;
/////////////////////////////////////////////////////////////////////////
1:     public void testAllocate()
0:         runAllocate(HeapAllocator.instance);
0:         runAllocate(bumpedSlab());
0:     private void runAllocate(Allocator allocator)
0:         ContextState allGlobal = ContextState.allocate(3, 0, 0, allocator);
1:         assertEquals(headerSizeLength + 3 * headerEltLength + 3 * stepLength, allGlobal.context.remaining());
1: 
0:         ContextState allLocal = ContextState.allocate(0, 3, 0, allocator);
1:         assertEquals(headerSizeLength + 3 * headerEltLength + 3 * stepLength, allLocal.context.remaining());
1: 
0:         ContextState allRemote = ContextState.allocate(0, 0, 3, allocator);
1:         assertEquals(headerSizeLength + 3 * stepLength, allRemote.context.remaining());
1: 
0:         ContextState mixed = ContextState.allocate(1, 1, 1, allocator);
1:         assertEquals(headerSizeLength + 2 * headerEltLength + 3 * stepLength, mixed.context.remaining());
/////////////////////////////////////////////////////////////////////////
1:         ContextState left;
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
1:         right = ContextState.wrap(ByteBufferUtil.clone(left.context));
0:         assertEquals(ContextRelationship.EQUAL, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 4, allocator);
1:         left.writeRemote(CounterId.fromInt(3),  3L, 0L);
1:         left.writeRemote(CounterId.fromInt(6),  2L, 0L);
1:         left.writeRemote(CounterId.fromInt(9),  1L, 0L);
1:         left.writeRemote(CounterId.fromInt(12), 0L, 0L);
0:         right = ContextState.allocate(0, 0, 3, allocator);
1:         right.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:         right.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:         right.writeRemote(CounterId.fromInt(9), 1L, 0L);
0:         assertEquals(ContextRelationship.GREATER_THAN, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(0, 0, 4, allocator);
1:         right.writeRemote(CounterId.fromInt(3),  3L, 0L);
1:         right.writeRemote(CounterId.fromInt(6),  2L, 0L);
1:         right.writeRemote(CounterId.fromInt(9),  1L, 0L);
1:         right.writeRemote(CounterId.fromInt(12), 0L, 0L);
0:         assertEquals(ContextRelationship.LESS_THAN, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 3L, 0L);
0:         right = ContextState.allocate(0, 0, 3, allocator);
1:         right.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:         right.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:         right.writeRemote(CounterId.fromInt(9), 1L, 0L);
0:         assertEquals(ContextRelationship.GREATER_THAN, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 3L, 0L);
0:         right = ContextState.allocate(0, 0, 3, allocator);
1:         right.writeRemote(CounterId.fromInt(3), 3L, 0L);
1:         right.writeRemote(CounterId.fromInt(6), 9L, 0L);
1:         right.writeRemote(CounterId.fromInt(9), 3L, 0L);
0:         assertEquals(ContextRelationship.LESS_THAN, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:         left.writeRemote(CounterId.fromInt(4), 1L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(0, 0, 3, allocator);
1:         right.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:         right.writeRemote(CounterId.fromInt(6), 1L, 0L);
1:         right.writeRemote(CounterId.fromInt(9), 1L, 0L);
0:         assertEquals(ContextRelationship.DISJOINT, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:         left.writeRemote(CounterId.fromInt(4), 1L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(0, 0, 3, allocator);
1:         right.writeRemote(CounterId.fromInt(2),  1L, 0L);
1:         right.writeRemote(CounterId.fromInt(6),  1L, 0L);
1:         right.writeRemote(CounterId.fromInt(12), 1L, 0L);
0:         assertEquals(ContextRelationship.DISJOINT, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:         left.writeRemote(CounterId.fromInt(6), 3L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(0, 0, 3, allocator);
1:         right.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:         right.writeRemote(CounterId.fromInt(6), 1L, 0L);
1:         right.writeRemote(CounterId.fromInt(9), 5L, 0L);
0:         assertEquals(ContextRelationship.DISJOINT, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 2L, 0L);
1:         left.writeRemote(CounterId.fromInt(6), 3L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(0, 0, 3, allocator);
1:         right.writeRemote(CounterId.fromInt(3), 1L, 0L);
1:         right.writeRemote(CounterId.fromInt(6), 9L, 0L);
1:         right.writeRemote(CounterId.fromInt(9), 5L, 0L);
0:         assertEquals(ContextRelationship.DISJOINT, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 4, allocator);
1:         left.writeRemote(CounterId.fromInt(3),  2L, 0L);
1:         left.writeRemote(CounterId.fromInt(6),  3L, 0L);
1:         left.writeRemote(CounterId.fromInt(9),  1L, 0L);
1:         left.writeRemote(CounterId.fromInt(12), 1L, 0L);
0:         right = ContextState.allocate(0, 0, 3, allocator);
1:         right.writeRemote(CounterId.fromInt(3), 4L, 0L);
1:         right.writeRemote(CounterId.fromInt(6), 9L, 0L);
1:         right.writeRemote(CounterId.fromInt(9), 5L, 0L);
0:         assertEquals(ContextRelationship.DISJOINT, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 5L, 0L);
1:         left.writeRemote(CounterId.fromInt(6), 3L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 2L, 0L);
0:         right = ContextState.allocate(0, 0, 4, allocator);
1:         right.writeRemote(CounterId.fromInt(3),  4L, 0L);
1:         right.writeRemote(CounterId.fromInt(6),  3L, 0L);
1:         right.writeRemote(CounterId.fromInt(9),  2L, 0L);
1:         right.writeRemote(CounterId.fromInt(12), 1L, 0L);
0:         assertEquals(ContextRelationship.DISJOINT, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 5L, 0L);
1:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 2L, 0L);
0:         right = ContextState.allocate(0, 0, 4, allocator);
1:         right.writeRemote(CounterId.fromInt(3),  4L, 0L);
1:         right.writeRemote(CounterId.fromInt(6),  3L, 0L);
1:         right.writeRemote(CounterId.fromInt(9),  2L, 0L);
1:         right.writeRemote(CounterId.fromInt(12), 1L, 0L);
0:         assertEquals(ContextRelationship.DISJOINT, cc.diff(left.context, right.context));
0:         left = ContextState.allocate(0, 0, 4, allocator);
1:         left.writeRemote(CounterId.fromInt(3), 5L, 0L);
1:         left.writeRemote(CounterId.fromInt(6), 2L, 0L);
1:         left.writeRemote(CounterId.fromInt(7), 2L, 0L);
1:         left.writeRemote(CounterId.fromInt(9), 2L, 0L);
0:         right = ContextState.allocate(0, 0, 3, allocator);
1:         right.writeRemote(CounterId.fromInt(3), 4L, 0L);
1:         right.writeRemote(CounterId.fromInt(6), 3L, 0L);
1:         right.writeRemote(CounterId.fromInt(9), 2L, 0L);
0:         assertEquals(ContextRelationship.DISJOINT, cc.diff(left.context, right.context));
/////////////////////////////////////////////////////////////////////////
0:         ContextState left = ContextState.allocate(0, 1, 3, allocator);
1:         left.writeRemote(CounterId.fromInt(1), 1L, 1L);
1:         left.writeRemote(CounterId.fromInt(2), 2L, 2L);
1:         left.writeRemote(CounterId.fromInt(4), 6L, 3L);
1:         left.writeLocal(CounterId.getLocalId(), 7L, 3L);
0:         ContextState right = ContextState.allocate(0, 1, 2, allocator);
1:         right.writeRemote(CounterId.fromInt(4), 4L, 4L);
1:         right.writeRemote(CounterId.fromInt(5), 5L, 5L);
1:         right.writeLocal(CounterId.getLocalId(), 2L, 9L);
1:         assertTrue(Util.equalsCounterId(CounterId.getLocalId(), merged, hd + 4 * stepLength));
1:         assertEquals(9L, merged.getLong(merged.position() + hd + 4 * stepLength + idLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(4), merged, hd + 2 * stepLength));
1:         assertEquals(6L, merged.getLong(merged.position() + hd + 2 * stepLength + idLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(5), merged, hd + 3 * stepLength));
1:         assertEquals(5L, merged.getLong(merged.position() + hd + 3 * stepLength + idLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), merged, hd + stepLength));
1:         assertEquals(2L, merged.getLong(merged.position() + hd + stepLength + idLength));
1:         assertEquals( 2L,  merged.getLong(merged.position() + hd + stepLength + idLength + clockLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), merged, hd));
1:         assertEquals( 1L,  merged.getLong(merged.position() + hd + idLength));
1:         assertEquals( 1L,  merged.getLong(merged.position() + hd + idLength + clockLength));
1: 
1:         //
1:         // Test merging two exclusively global contexts
1:         //
0:         left = ContextState.allocate(3, 0, 0, allocator);
1:         left.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:         left.writeGlobal(CounterId.fromInt(2), 2L, 2L);
1:         left.writeGlobal(CounterId.fromInt(3), 3L, 3L);
1: 
0:         right = ContextState.allocate(3, 0, 0, allocator);
1:         right.writeGlobal(CounterId.fromInt(3), 6L, 6L);
1:         right.writeGlobal(CounterId.fromInt(4), 4L, 4L);
1:         right.writeGlobal(CounterId.fromInt(5), 5L, 5L);
1: 
0:         merged = cc.merge(left.context, right.context, allocator);
1:         assertEquals(headerSizeLength + 5 * headerEltLength + 5 * stepLength, merged.remaining());
1:         assertEquals(18L, cc.total(merged));
1:         assertEquals(5, merged.getShort(merged.position()));
1: 
1:         int headerLength = headerSizeLength + 5 * headerEltLength;
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), merged, headerLength));
1:         assertEquals(1L, merged.getLong(merged.position() + headerLength + idLength));
1:         assertEquals(1L, merged.getLong(merged.position() + headerLength + idLength + clockLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), merged, headerLength + stepLength));
1:         assertEquals(2L, merged.getLong(merged.position() + headerLength + stepLength + idLength));
1:         assertEquals(2L, merged.getLong(merged.position() + headerLength + stepLength + idLength + clockLength));
1:         // pick the global shard with the largest clock
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(3), merged, headerLength + 2 * stepLength));
1:         assertEquals(6L, merged.getLong(merged.position() + headerLength + 2 * stepLength + idLength));
1:         assertEquals(6L, merged.getLong(merged.position() + headerLength + 2 * stepLength + idLength + clockLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(4), merged, headerLength + 3 * stepLength));
1:         assertEquals(4L, merged.getLong(merged.position() + headerLength + 3 * stepLength + idLength));
1:         assertEquals(4L, merged.getLong(merged.position() + headerLength + 3 * stepLength + idLength + clockLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(5), merged, headerLength + 4 * stepLength));
1:         assertEquals(5L, merged.getLong(merged.position() + headerLength + 4 * stepLength + idLength));
1:         assertEquals(5L, merged.getLong(merged.position() + headerLength + 4 * stepLength + idLength + clockLength));
1: 
1:         //
1:         // Test merging two global contexts w/ 'invalid shards'
1:         //
0:         left = ContextState.allocate(1, 0, 0, allocator);
1:         left.writeGlobal(CounterId.fromInt(1), 10L, 20L);
1: 
0:         right = ContextState.allocate(1, 0, 0, allocator);
1:         right.writeGlobal(CounterId.fromInt(1), 10L, 30L);
1: 
0:         merged = cc.merge(left.context, right.context, allocator);
1:         headerLength = headerSizeLength + headerEltLength;
1:         assertEquals(headerLength + stepLength, merged.remaining());
1:         assertEquals(30L, cc.total(merged));
1:         assertEquals(1, merged.getShort(merged.position()));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), merged, headerLength));
1:         assertEquals(10L, merged.getLong(merged.position() + headerLength + idLength));
1:         // with equal clock, we should pick the largest value
1:         assertEquals(30L, merged.getLong(merged.position() + headerLength + idLength + clockLength));
1: 
1:         //
1:         // Test merging global w/ mixed contexts
1:         //
0:         left = ContextState.allocate(2, 0, 0, allocator);
1:         left.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:         left.writeGlobal(CounterId.fromInt(2), 1L, 1L);
1: 
0:         right = ContextState.allocate(0, 1, 1, allocator);
1:         right.writeLocal(CounterId.fromInt(1), 100L, 100L);
1:         right.writeRemote(CounterId.fromInt(2), 100L, 100L);
1: 
1:         // global shards should dominate local/remote, even with lower clock and value
0:         merged = cc.merge(left.context, right.context, allocator);
1:         headerLength = headerSizeLength + 2 * headerEltLength;
1:         assertEquals(headerLength + 2 * stepLength, merged.remaining());
1:         assertEquals(2L, cc.total(merged));
1:         assertEquals(2, merged.getShort(merged.position()));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), merged, headerLength));
1:         assertEquals(1L, merged.getLong(merged.position() + headerLength + idLength));
1:         assertEquals(1L, merged.getLong(merged.position() + headerLength + idLength + clockLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), merged, headerLength + stepLength));
1:         assertEquals(1L, merged.getLong(merged.position() + headerLength + stepLength + idLength));
1:         assertEquals(1L, merged.getLong(merged.position() + headerLength + stepLength + idLength + clockLength));
/////////////////////////////////////////////////////////////////////////
0:         ContextState mixed = ContextState.allocate(0, 1, 4, allocator);
1:         mixed.writeRemote(CounterId.fromInt(1), 1L, 1L);
1:         mixed.writeRemote(CounterId.fromInt(2), 2L, 2L);
1:         mixed.writeRemote(CounterId.fromInt(4), 4L, 4L);
1:         mixed.writeRemote(CounterId.fromInt(5), 5L, 5L);
1:         mixed.writeLocal(CounterId.getLocalId(), 12L, 12L);
1:         assertEquals(24L, cc.total(mixed.context));
0:         ContextState global = ContextState.allocate(3, 0, 0, allocator);
1:         global.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:         global.writeGlobal(CounterId.fromInt(2), 2L, 2L);
1:         global.writeGlobal(CounterId.fromInt(3), 3L, 3L);
1:         assertEquals(6L, cc.total(global.context));
1:     public void testClearLocal()
1:         ContextState state;
1:         ByteBuffer marked;
1:         ByteBuffer cleared;
0:         Allocator allocator = HeapAllocator.instance;
1:         // mark/clear for remote-only contexts is a no-op
0:         state = ContextState.allocate(0, 0, 1, allocator);
1:         state.writeRemote(CounterId.fromInt(1), 1L, 1L);
1:         assertFalse(cc.shouldClearLocal(state.context));
1:         marked = cc.markLocalToBeCleared(state.context);
1:         assertEquals(0, marked.getShort(marked.position()));
1:         assertSame(state.context, marked); // should return the original context
1:         cleared = cc.clearAllLocal(marked);
1:         assertSame(cleared, marked); // shouldn't alter anything either
1:         // a single local shard
0:         state = ContextState.allocate(0, 1, 0, allocator);
1:         state.writeLocal(CounterId.fromInt(1), 1L, 1L);
1:         assertFalse(cc.shouldClearLocal(state.context));
1:         marked = cc.markLocalToBeCleared(state.context);
1:         assertTrue(cc.shouldClearLocal(marked));
1:         assertEquals(-1, marked.getShort(marked.position()));
1:         assertNotSame(state.context, marked); // shouldn't alter in place, as it used to do
1:         cleared = cc.clearAllLocal(marked);
1:         assertFalse(cc.shouldClearLocal(cleared));
1:         assertEquals(0, cleared.getShort(cleared.position()));
1:         // 2 global + 1 local shard
0:         state = ContextState.allocate(2, 1, 0, allocator);
1:         state.writeLocal(CounterId.fromInt(1), 1L, 1L);
1:         state.writeGlobal(CounterId.fromInt(2), 2L, 2L);
1:         state.writeGlobal(CounterId.fromInt(3), 3L, 3L);
1:         assertFalse(cc.shouldClearLocal(state.context));
1:         marked = cc.markLocalToBeCleared(state.context);
1:         assertTrue(cc.shouldClearLocal(marked));
1:         assertEquals(-3, marked.getShort(marked.position()));
1:         assertEquals(0, marked.getShort(marked.position() + headerSizeLength));
1:         assertEquals(Short.MIN_VALUE + 1, marked.getShort(marked.position() + headerSizeLength + headerEltLength));
1:         assertEquals(Short.MIN_VALUE + 2, marked.getShort(marked.position() + headerSizeLength + 2 * headerEltLength));
1:         int headerLength = headerSizeLength + 3 * headerEltLength;
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), marked, headerLength));
1:         assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength));
1:         assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength + clockLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), marked, headerLength + stepLength));
1:         assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength));
1:         assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength + clockLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(3), marked, headerLength + 2 * stepLength));
1:         assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength));
1:         assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength + clockLength));
1:         cleared = cc.clearAllLocal(marked);
1:         assertFalse(cc.shouldClearLocal(cleared));
1:         assertEquals(2, cleared.getShort(cleared.position())); // 2 global shards
1:         assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength));
1:         assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength));
1:         headerLength = headerSizeLength + 2 * headerEltLength;
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(1), cleared, headerLength));
1:         assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength));
1:         assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength + clockLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(2), cleared, headerLength + stepLength));
1:         assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength));
1:         assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength + clockLength));
1:         assertTrue(Util.equalsCounterId(CounterId.fromInt(3), cleared, headerLength + 2 * stepLength));
1:         assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength));
1:         assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength + clockLength));
1:         // a single global shard - no-op
0:         state = ContextState.allocate(1, 0, 0, allocator);
1:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:         assertFalse(cc.shouldClearLocal(state.context));
1:         marked = cc.markLocalToBeCleared(state.context);
1:         assertEquals(1, marked.getShort(marked.position()));
1:         assertSame(state.context, marked);
1:         cleared = cc.clearAllLocal(marked);
1:         assertSame(cleared, marked);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.concurrent.OpOrder;
0: import org.apache.cassandra.utils.memory.AbstractAllocator;
0: import org.apache.cassandra.utils.memory.HeapAllocator;
0: import org.apache.cassandra.utils.memory.HeapPool;
0: import org.apache.cassandra.utils.memory.Pool;
/////////////////////////////////////////////////////////////////////////
0:     private static final Pool POOL = new HeapPool(Integer.MAX_VALUE, 1f, null);
1: 
0:     private AbstractAllocator bumpedSlab()
0:         AbstractAllocator allocator = POOL.newAllocator(new OpOrder());
/////////////////////////////////////////////////////////////////////////
0:     private void runAllocate(AbstractAllocator allocator)
/////////////////////////////////////////////////////////////////////////
0:     private void runDiff(AbstractAllocator allocator)
/////////////////////////////////////////////////////////////////////////
0:     private void runMerge(AbstractAllocator allocator)
/////////////////////////////////////////////////////////////////////////
0:     private void runTotal(AbstractAllocator allocator)
/////////////////////////////////////////////////////////////////////////
0:         AbstractAllocator allocator = HeapAllocator.instance;
commit:2effc40
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.util.concurrent.Uninterruptibles;
1: 
/////////////////////////////////////////////////////////////////////////
0:         Uninterruptibles.sleepUninterruptibly(2, TimeUnit.SECONDS);
commit:b95a49c
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
1: 
0: import org.apache.cassandra.utils.*;
/////////////////////////////////////////////////////////////////////////
0:     /** Allocates 1 byte from a new SlabAllocator and returns it. */
0:     private Allocator bumpedSlab()
1:     {
0:         SlabAllocator allocator = new SlabAllocator();
0:         allocator.allocate(1);
0:         return allocator;
1:     }
1: 
0:         runCreate(HeapAllocator.instance);
0:         runCreate(bumpedSlab());
1:     }
1: 
0:     private void runCreate(Allocator allocator)
1:     {
0:         ByteBuffer bytes = cc.create(4, allocator);
0:         assertEquals(stepLength + 4, bytes.remaining());
0:         runDiff(HeapAllocator.instance);
0:         runDiff(bumpedSlab());
1:     }
1: 
0:     private void runDiff(Allocator allocator)
1:     {
0:         ContextState left = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(4, 0, allocator);
0:         right = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(3, 0, allocator);
0:         right = ContextState.allocate(4, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(3, 0, allocator);
0:         right = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(3, 0, allocator);
0:         right = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(3, 0, allocator);
0:         right = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(3, 0, allocator);
0:         right = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(3, 0, allocator);
0:         right = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(3, 0, allocator);
0:         right = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(4, 0, allocator);
0:         right = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(3, 0, allocator);
0:         right = ContextState.allocate(4, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(3, 0, allocator);
0:         right = ContextState.allocate(4, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         left = ContextState.allocate(4, 0, allocator);
0:         right = ContextState.allocate(3, 0, allocator);
/////////////////////////////////////////////////////////////////////////
0:         runMerge(HeapAllocator.instance);
0:         runMerge(bumpedSlab());
1:     }
1: 
0:     private void runMerge(Allocator allocator)
1:     {
0:         ContextState left = ContextState.allocate(4, 1, allocator);
0:         ContextState right = ContextState.allocate(3, 1, allocator);
0:         ByteBuffer merged = cc.merge(left.context, right.context, allocator);
0:         assertEquals(  9L, merged.getLong(merged.position() + hd + 4*stepLength + idLength));
1:         assertEquals(12L,  merged.getLong(merged.position() + hd + 4*stepLength + idLength + clockLength));
0:         assertEquals( 6L,  merged.getLong(merged.position() + hd + 2*stepLength + idLength));
1:         assertEquals( 3L,  merged.getLong(merged.position() + hd + 2*stepLength + idLength + clockLength));
0:         assertEquals( 5L,  merged.getLong(merged.position() + hd + 3*stepLength + idLength));
1:         assertEquals( 5L,  merged.getLong(merged.position() + hd + 3*stepLength + idLength + clockLength));
0:         assertEquals( 2L,  merged.getLong(merged.position() + hd + 1*stepLength + idLength));
0:         assertEquals( 2L,  merged.getLong(merged.position() + hd + 1*stepLength + idLength + clockLength));
0:         assertEquals( 1L,  merged.getLong(merged.position() + hd + 0*stepLength + idLength));
0:         assertEquals( 1L,  merged.getLong(merged.position() + hd + 0*stepLength + idLength + clockLength));
0:         runTotal(HeapAllocator.instance);
0:         runTotal(bumpedSlab());
1:     }
1: 
0:     private void runTotal(Allocator allocator)
1:     {
0:         ContextState left = ContextState.allocate(4, 1, allocator);
0:         ContextState right = ContextState.allocate(3, 1, allocator);
0:         ByteBuffer merged = cc.merge(left.context, right.context, allocator);
/////////////////////////////////////////////////////////////////////////
0:         runMergeOldShards(HeapAllocator.instance);
0:         runMergeOldShards(bumpedSlab());
0:     }
1: 
0:     private void runMergeOldShards(Allocator allocator)
0:     {
/////////////////////////////////////////////////////////////////////////
0:         ContextState ctx = ContextState.allocate(5, 2, allocator);
/////////////////////////////////////////////////////////////////////////
0:         assert cc.total(ctx.context) == cc.total(cc.merge(ctx.context, merger, allocator));
0:         ctx = ContextState.allocate(4, 1, allocator);
0:         assert cc.total(ctx.context) == cc.total(cc.merge(ctx.context, merger, allocator));
0:         ctx = ContextState.allocate(4, 2, allocator);
0:         assert cc.total(ctx.context) == cc.total(cc.merge(ctx.context, merger, allocator));
0:         ctx = ContextState.allocate(4, 0, allocator);
0:         assert cc.total(ctx.context) == cc.total(cc.merge(ctx.context, merger, allocator));
0:         runRemoveOldShards(HeapAllocator.instance);
0:         runRemoveOldShards(bumpedSlab());
0:     }
1: 
0:     private void runRemoveOldShards(Allocator allocator)
0:     {
/////////////////////////////////////////////////////////////////////////
0:         ContextState ctx = ContextState.allocate(6, 2, allocator);
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer merged = cc.merge(ctx.context, merger, allocator);
/////////////////////////////////////////////////////////////////////////
0:         merged = cc.merge(cleaned, merger, allocator);
commit:f3630a6
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer context = cc.create(4);
0:         assert context.remaining() == stepLength;
0:         ByteBuffer left = ByteBuffer.allocate(3 * stepLength);
0:         ByteBuffer right;
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 1L, 0L);
0:         right = ByteBufferUtil.clone(left);
0:         left = ByteBuffer.allocate(4 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3),  3L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6),  2L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9),  1L, 0L);
0:         cc.writeElementAtOffset(left, 3 * stepLength, FBUtilities.toByteArray(12), 0L, 0L);
0:         right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9), 1L, 0L);
0:         left = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 1L, 0L);
0:         right = ByteBuffer.allocate(4 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3),  3L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6),  2L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9),  1L, 0L);
0:         cc.writeElementAtOffset(right, 3 * stepLength, FBUtilities.toByteArray(12), 0L, 0L);
0:         left = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 3L, 0L);
0:         right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9), 1L, 0L);
0:         left = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 3L, 0L);
0:         right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6), 9L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9), 3L, 0L);
0:         left = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(4), 1L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 1L, 0L);
0:         right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6), 1L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9), 1L, 0L);
0:         left = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(4), 1L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 1L, 0L);
0:         right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(2),  1L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6),  1L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(12), 1L, 0L);
0:         left = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6), 3L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 1L, 0L);
0:         right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6), 1L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9), 5L, 0L);
0:         left = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 2L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6), 3L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 1L, 0L);
0:         right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6), 9L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9), 5L, 0L);
0:         left = ByteBuffer.allocate(4 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3),  2L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6),  3L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9),  1L, 0L);
0:         cc.writeElementAtOffset(left, 3 * stepLength, FBUtilities.toByteArray(12), 1L, 0L);
0:         right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3), 4L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6), 9L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9), 5L, 0L);
0:         left = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 5L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6), 3L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 2L, 0L);
0:         right = ByteBuffer.allocate(4 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3),  4L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6),  3L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9),  2L, 0L);
0:         cc.writeElementAtOffset(right, 3 * stepLength, FBUtilities.toByteArray(12), 1L, 0L);
0:         left = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 5L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(9), 2L, 0L);
0:         right = ByteBuffer.allocate(4 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3),  4L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6),  3L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9),  2L, 0L);
0:         cc.writeElementAtOffset(right, 3 * stepLength, FBUtilities.toByteArray(12), 1L, 0L);
0:         left = ByteBuffer.allocate(4 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(3), 5L, 0L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(7), 2L, 0L);
0:         cc.writeElementAtOffset(left, 3 * stepLength, FBUtilities.toByteArray(9), 2L, 0L);
0:         right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(3), 4L, 0L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(6), 3L, 0L);
0:         cc.writeElementAtOffset(right, 2 * stepLength, FBUtilities.toByteArray(9), 2L, 0L);
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer left = ByteBuffer.allocate(4 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(1), 1L, 1L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(2), 2L, 2L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(4), 6L, 3L);
0:         cc.writeElementAtOffset(
0:             3 * stepLength,
0:         ByteBuffer right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(4), 4L, 4L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(5), 5L, 5L);
0:         cc.writeElementAtOffset(
0:             2 * stepLength,
0:         ByteBuffer merged = cc.merge(left, right);
0:         assertEquals(5 * stepLength, merged.remaining());
0:         assertEquals(0, ByteBufferUtil.compareSubArrays(
0:             ByteBuffer.wrap(FBUtilities.getLocalAddress().getAddress()),
0:         assertEquals(  9L, merged.getLong(4*stepLength + idLength));
0:         assertEquals(12L,  merged.getLong(4*stepLength + idLength + clockLength));
0:         assertEquals( 4,   merged.getInt( 2*stepLength));
0:         assertEquals( 6L,  merged.getLong(2*stepLength + idLength));
0:         assertEquals( 3L,  merged.getLong(2*stepLength + idLength + clockLength));
0:         assertEquals( 5,   merged.getInt( 3*stepLength));
0:         assertEquals( 5L,  merged.getLong(3*stepLength + idLength));
0:         assertEquals( 5L,  merged.getLong(3*stepLength + idLength + clockLength));
0:         assertEquals( 2,   merged.getInt( 1*stepLength));
0:         assertEquals( 2L,  merged.getLong(1*stepLength + idLength));
0:         assertEquals( 2L,  merged.getLong(1*stepLength + idLength + clockLength));
0:         assertEquals( 1,   merged.getInt( 0*stepLength));
0:         assertEquals( 1L,  merged.getLong(0*stepLength + idLength));
0:         assertEquals( 1L,  merged.getLong(0*stepLength + idLength + clockLength));
0:         ByteBuffer left = ByteBuffer.allocate(4 * stepLength);
0:         cc.writeElementAtOffset(left, 0 * stepLength, FBUtilities.toByteArray(1), 1L, 1L);
0:         cc.writeElementAtOffset(left, 1 * stepLength, FBUtilities.toByteArray(2), 2L, 2L);
0:         cc.writeElementAtOffset(left, 2 * stepLength, FBUtilities.toByteArray(4), 3L, 3L);
0:         cc.writeElementAtOffset(
0:             3 * stepLength,
0:         ByteBuffer right = ByteBuffer.allocate(3 * stepLength);
0:         cc.writeElementAtOffset(right, 0 * stepLength, FBUtilities.toByteArray(4), 4L, 4L);
0:         cc.writeElementAtOffset(right, 1 * stepLength, FBUtilities.toByteArray(5), 5L, 5L);
0:         cc.writeElementAtOffset(
0:             2 * stepLength,
0:         ByteBuffer merged = cc.merge(left, right);
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(24L, cc.total(merged));
0:         ByteBuffer bytes = ByteBuffer.allocate(4 * stepLength);
0:         cc.writeElementAtOffset(bytes, 0 * stepLength, FBUtilities.toByteArray(1), 1L, 1L);
0:         cc.writeElementAtOffset(bytes, 1 * stepLength, FBUtilities.toByteArray(2), 2L, 2L);
0:         cc.writeElementAtOffset(bytes, 2 * stepLength, FBUtilities.toByteArray(4), 3L, 3L);
0:         cc.writeElementAtOffset(bytes, 3 * stepLength, FBUtilities.toByteArray(8), 4L, 4L);
0:         assertEquals(4, bytes.getInt( 2*stepLength));
0:         assertEquals(3L, bytes.getLong(2*stepLength + idLength));
0:         assertEquals(3 * stepLength, bytes.remaining());
0:         assertEquals(1, bytes.getInt( 0*stepLength));
0:         assertEquals(1L, bytes.getLong(0*stepLength + idLength));
0:         assertEquals(2, bytes.getInt( 1*stepLength));
0:         assertEquals(2L, bytes.getLong(1*stepLength + idLength));
0:         assertEquals(8, bytes.getInt( 2*stepLength));
0:         assertEquals(4L, bytes.getLong(2*stepLength + idLength));
commit:9ef94eb
/////////////////////////////////////////////////////////////////////////
0:     public void testUpdatePresent() throws UnknownHostException
0:         for (int i = 0; i < defaultEntries; i++)
/////////////////////////////////////////////////////////////////////////
0:         context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(defaultEntries - 1)), 10L);
0:         int offset = (defaultEntries - 1) * stepLength;
0:         assertEquals(  2L, FBUtilities.byteArrayToLong(context, offset + idLength));
0:         assertEquals( 11L, FBUtilities.byteArrayToLong(context, offset + idLength + clockLength));
0:         for (int i = 0; i < defaultEntries - 1; i++)
0:             offset = i * stepLength;
0:             assertEquals( i, FBUtilities.byteArrayToInt(context,  offset));
0:     public void testUpdateNotPresent() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:                 FBUtilities.toByteArray(i * 2),
0:         context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(3)), 328L);
0:         assert context.length == stepLength * 4;
0:         int offset = 2 * stepLength;
0:         assert   1L == FBUtilities.byteArrayToLong(context, offset + idLength);
0:         assert 328L == FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);
0:         for (int i = 1; i < 2; i++)
0:         {
0:             offset = i * stepLength;
0:             assert 2 * i == FBUtilities.byteArrayToInt(context,  offset);
0:             assert    1L == FBUtilities.byteArrayToLong(context, offset + idLength);
0:             assert    1L == FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);
0:         }
0:         offset = 3 * stepLength;
0:         assert  4 == FBUtilities.byteArrayToInt(context,  offset);
0:         assert 1L == FBUtilities.byteArrayToLong(context, offset + idLength);
0:         assert 1L == FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);
/////////////////////////////////////////////////////////////////////////
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(4), 4L, 4L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(5), 5L, 5L);
0:             2,
0:         assertEquals(5 * stepLength, merged.length);
0:         assertEquals(0, FBUtilities.compareByteSubArrays(
0:             merged,
0:             4*stepLength,
0:         assertEquals(  9L, FBUtilities.byteArrayToLong(merged, 4*stepLength + idLength));
0:         assertEquals(12L,  FBUtilities.byteArrayToLong(merged, 4*stepLength + idLength + clockLength));
0:         assertEquals( 4,   FBUtilities.byteArrayToInt(merged,  2*stepLength));
0:         assertEquals( 6L,  FBUtilities.byteArrayToLong(merged, 2*stepLength + idLength));
0:         assertEquals( 3L,  FBUtilities.byteArrayToLong(merged, 2*stepLength + idLength + clockLength));
0:         assertEquals( 5,   FBUtilities.byteArrayToInt(merged,  3*stepLength));
0:         assertEquals( 5L,  FBUtilities.byteArrayToLong(merged, 3*stepLength + idLength));
0:         assertEquals( 5L,  FBUtilities.byteArrayToLong(merged, 3*stepLength + idLength + clockLength));
0:         assertEquals( 2,   FBUtilities.byteArrayToInt(merged,  1*stepLength));
0:         assertEquals( 2L,  FBUtilities.byteArrayToLong(merged, 1*stepLength + idLength));
0:         assertEquals( 2L,  FBUtilities.byteArrayToLong(merged, 1*stepLength + idLength + clockLength));
0:         assertEquals( 1,   FBUtilities.byteArrayToInt(merged,  0*stepLength));
0:         assertEquals( 1L,  FBUtilities.byteArrayToLong(merged, 0*stepLength + idLength));
0:         assertEquals( 1L,  FBUtilities.byteArrayToLong(merged, 0*stepLength + idLength + clockLength));
/////////////////////////////////////////////////////////////////////////
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(4), 4L, 4L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(5), 5L, 5L);
0:             2,
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:3b13457
/////////////////////////////////////////////////////////////////////////
0:         idLength       = CounterId.LENGTH; // size of int
/////////////////////////////////////////////////////////////////////////
0:         left.writeElement(CounterId.fromInt(3), 3L, 0L);
0:         left.writeElement(CounterId.fromInt(6), 2L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 1L, 0L);
/////////////////////////////////////////////////////////////////////////
0:         left.writeElement(CounterId.fromInt(3),  3L, 0L);
0:         left.writeElement(CounterId.fromInt(6),  2L, 0L);
0:         left.writeElement(CounterId.fromInt(9),  1L, 0L);
0:         left.writeElement(CounterId.fromInt(12), 0L, 0L);
0:         right.writeElement(CounterId.fromInt(3), 3L, 0L);
0:         right.writeElement(CounterId.fromInt(6), 2L, 0L);
0:         right.writeElement(CounterId.fromInt(9), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 3L, 0L);
0:         left.writeElement(CounterId.fromInt(6), 2L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(3),  3L, 0L);
0:         right.writeElement(CounterId.fromInt(6),  2L, 0L);
0:         right.writeElement(CounterId.fromInt(9),  1L, 0L);
0:         right.writeElement(CounterId.fromInt(12), 0L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 3L, 0L);
0:         left.writeElement(CounterId.fromInt(6), 2L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 3L, 0L);
0:         right.writeElement(CounterId.fromInt(3), 3L, 0L);
0:         right.writeElement(CounterId.fromInt(6), 2L, 0L);
0:         right.writeElement(CounterId.fromInt(9), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 3L, 0L);
0:         left.writeElement(CounterId.fromInt(6), 2L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 3L, 0L);
0:         right.writeElement(CounterId.fromInt(3), 3L, 0L);
0:         right.writeElement(CounterId.fromInt(6), 9L, 0L);
0:         right.writeElement(CounterId.fromInt(9), 3L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(4), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(3), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(6), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(9), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(4), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(2),  1L, 0L);
0:         right.writeElement(CounterId.fromInt(6),  1L, 0L);
0:         right.writeElement(CounterId.fromInt(12), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(6), 3L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(3), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(6), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(9), 5L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 2L, 0L);
0:         left.writeElement(CounterId.fromInt(6), 3L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(3), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(6), 9L, 0L);
0:         right.writeElement(CounterId.fromInt(9), 5L, 0L);
0:         left.writeElement(CounterId.fromInt(3),  2L, 0L);
0:         left.writeElement(CounterId.fromInt(6),  3L, 0L);
0:         left.writeElement(CounterId.fromInt(9),  1L, 0L);
0:         left.writeElement(CounterId.fromInt(12), 1L, 0L);
0:         right.writeElement(CounterId.fromInt(3), 4L, 0L);
0:         right.writeElement(CounterId.fromInt(6), 9L, 0L);
0:         right.writeElement(CounterId.fromInt(9), 5L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 5L, 0L);
0:         left.writeElement(CounterId.fromInt(6), 3L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 2L, 0L);
0:         right.writeElement(CounterId.fromInt(3),  4L, 0L);
0:         right.writeElement(CounterId.fromInt(6),  3L, 0L);
0:         right.writeElement(CounterId.fromInt(9),  2L, 0L);
0:         right.writeElement(CounterId.fromInt(12), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 5L, 0L);
0:         left.writeElement(CounterId.fromInt(6), 2L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 2L, 0L);
0:         right.writeElement(CounterId.fromInt(3),  4L, 0L);
0:         right.writeElement(CounterId.fromInt(6),  3L, 0L);
0:         right.writeElement(CounterId.fromInt(9),  2L, 0L);
0:         right.writeElement(CounterId.fromInt(12), 1L, 0L);
0:         left.writeElement(CounterId.fromInt(3), 5L, 0L);
0:         left.writeElement(CounterId.fromInt(6), 2L, 0L);
0:         left.writeElement(CounterId.fromInt(7), 2L, 0L);
0:         left.writeElement(CounterId.fromInt(9), 2L, 0L);
0:         right.writeElement(CounterId.fromInt(3), 4L, 0L);
0:         right.writeElement(CounterId.fromInt(6), 3L, 0L);
0:         right.writeElement(CounterId.fromInt(9), 2L, 0L);
/////////////////////////////////////////////////////////////////////////
0:         left.writeElement(CounterId.fromInt(1), 1L, 1L);
0:         left.writeElement(CounterId.fromInt(2), 2L, 2L);
0:         left.writeElement(CounterId.fromInt(4), 6L, 3L);
0:         left.writeElement(CounterId.getLocalId(), 7L, 3L, true);
0:         right.writeElement(CounterId.fromInt(4), 4L, 4L);
0:         right.writeElement(CounterId.fromInt(5), 5L, 5L);
0:         right.writeElement(CounterId.getLocalId(), 2L, 9L, true);
0:         assert Util.equalsCounterId(CounterId.getLocalId(), merged, hd + 4 * stepLength);
0:         assert Util.equalsCounterId(CounterId.fromInt(4), merged, hd + 2 * stepLength);
0:         assert Util.equalsCounterId(CounterId.fromInt(5), merged, hd + 3 * stepLength);
0:         assert Util.equalsCounterId(CounterId.fromInt(2), merged, hd + 1 * stepLength);
0:         assert Util.equalsCounterId(CounterId.fromInt(1), merged, hd + 0 * stepLength);
/////////////////////////////////////////////////////////////////////////
0:         left.writeElement(CounterId.fromInt(1), 1L, 1L);
0:         left.writeElement(CounterId.fromInt(2), 2L, 2L);
0:         left.writeElement(CounterId.fromInt(4), 3L, 3L);
0:         left.writeElement(CounterId.getLocalId(), 3L, 3L, true);
0:         right.writeElement(CounterId.fromInt(4), 4L, 4L);
0:         right.writeElement(CounterId.fromInt(5), 5L, 5L);
0:         right.writeElement(CounterId.getLocalId(), 9L, 9L, true);
/////////////////////////////////////////////////////////////////////////
0:         CounterId id1 = CounterId.fromInt(1);
0:         CounterId id3 = CounterId.fromInt(3);
0:         List<CounterId.CounterIdRecord> records = new ArrayList<CounterId.CounterIdRecord>();
0:         records.add(new CounterId.CounterIdRecord(id1, 2L));
0:         records.add(new CounterId.CounterIdRecord(id3, 4L));
0:         ctx.writeElement(CounterId.fromInt(2), 2L, 2L);
0:         ctx.writeElement(CounterId.fromInt(4), 6L, 3L);
0:         ctx.writeElement(CounterId.fromInt(5), 7L, 3L, true);
0:         assert m.getCounterId().equals(id1);
0:         assert m.getCounterId().equals(id3);
0:         assert m.getCounterId().equals(CounterId.getLocalId());
/////////////////////////////////////////////////////////////////////////
0:         CounterId id1 = CounterId.fromInt(1);
0:         CounterId id3 = CounterId.fromInt(3);
0:         CounterId id6 = CounterId.fromInt(6);
0:         List<CounterId.CounterIdRecord> records = new ArrayList<CounterId.CounterIdRecord>();
0:         records.add(new CounterId.CounterIdRecord(id1, 2L));
0:         records.add(new CounterId.CounterIdRecord(id3, 4L));
0:         records.add(new CounterId.CounterIdRecord(id6, 10L));
0:         ctx.writeElement(CounterId.fromInt(2), 2L, 2L);
0:         ctx.writeElement(CounterId.fromInt(4), 6L, 3L);
0:         ctx.writeElement(CounterId.fromInt(5), 7L, 3L, true);
/////////////////////////////////////////////////////////////////////////
0:         CounterId id1 = CounterId.fromInt(1);
0:         CounterId id3 = CounterId.fromInt(3);
0:         CounterId id6 = CounterId.fromInt(6);
0:         List<CounterId.CounterIdRecord> records = new ArrayList<CounterId.CounterIdRecord>();
0:         records.add(new CounterId.CounterIdRecord(id1, 2L));
0:         records.add(new CounterId.CounterIdRecord(id3, 4L));
0:         records.add(new CounterId.CounterIdRecord(id6, 10L));
0:         ctx.writeElement(CounterId.fromInt(2), 0L, 2L);
0:         ctx.writeElement(CounterId.fromInt(4), 0L, 3L);
0:         ctx.writeElement(CounterId.fromInt(5), 0L, 3L, true);
/////////////////////////////////////////////////////////////////////////
0:         assert m.getCounterId().equals(id3);
/////////////////////////////////////////////////////////////////////////
0:         ctx.writeElement(CounterId.fromInt(1), 1L, 1L, true);
0:         ctx.writeElement(CounterId.fromInt(2), -System.currentTimeMillis(), 0L);
0:         ctx.writeElement(CounterId.fromInt(3), -System.currentTimeMillis(), 0L);
0:         ctx.writeElement(CounterId.fromInt(4), -System.currentTimeMillis(), 0L);
commit:a15c35b
/////////////////////////////////////////////////////////////////////////
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:37f6a9f
/////////////////////////////////////////////////////////////////////////
commit:4d8ae4d
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
0:     public void testRemoveOldShardsNotAllExpiring()
0:     {
0:         runRemoveOldShardsNotAllExpiring(HeapAllocator.instance);
0:         runRemoveOldShardsNotAllExpiring(bumpedSlab());
0:     }
1: 
0:     private void runRemoveOldShardsNotAllExpiring(Allocator allocator)
0:     {
0:         NodeId id1 = NodeId.fromInt(1);
0:         NodeId id3 = NodeId.fromInt(3);
0:         NodeId id6 = NodeId.fromInt(6);
0:         List<NodeId.NodeIdRecord> records = new ArrayList<NodeId.NodeIdRecord>();
0:         records.add(new NodeId.NodeIdRecord(id1, 2L));
0:         records.add(new NodeId.NodeIdRecord(id3, 4L));
0:         records.add(new NodeId.NodeIdRecord(id6, 10L));
1: 
0:         ContextState ctx = ContextState.allocate(6, 3, allocator);
0:         ctx.writeElement(id1, 0L, 1L, true);
0:         ctx.writeElement(NodeId.fromInt(2), 0L, 2L);
0:         ctx.writeElement(id3, 0L, 3L, true);
0:         ctx.writeElement(NodeId.fromInt(4), 0L, 3L);
0:         ctx.writeElement(NodeId.fromInt(5), 0L, 3L, true);
0:         ctx.writeElement(id6, 0L, 6L);
1: 
0:         int timeFirstMerge = (int)(System.currentTimeMillis() / 1000);
1: 
0:         // First, only merge the first id
0:         ByteBuffer merger = cc.computeOldShardMerger(ctx.context, records, 3L);
0:         ByteBuffer merged = cc.merge(ctx.context, merger, allocator);
0:         assert cc.total(ctx.context) == cc.total(merged);
1: 
0:         try
0:         {
0:             Thread.sleep(2000);
0:         }
0:         catch (InterruptedException e)
0:         {
0:             throw new AssertionError();
0:         }
1: 
0:         // merge the second one
0:         ByteBuffer merger2 = cc.computeOldShardMerger(merged, records, 7L);
0:         ByteBuffer merged2 = cc.merge(merged, merger2, allocator);
0:         assert cc.total(ctx.context) == cc.total(merged2);
1: 
0:         ByteBuffer cleaned = cc.removeOldShards(merged2, timeFirstMerge + 1);
0:         assert cc.total(ctx.context) == cc.total(cleaned);
0:         assert cleaned.remaining() == ctx.context.remaining();
1: 
0:         // We should have cleaned id1 but not id3
0:         ContextState m = new ContextState(cleaned);
0:         m.moveToNext();
0:         assert m.getNodeId().equals(id3);
1: 
0:     }
1: 
1:     @Test
0:     public void testRemoveNotDeltaOldShards()
0:     {
0:         runRemoveNotDeltaOldShards(HeapAllocator.instance);
0:         runRemoveNotDeltaOldShards(bumpedSlab());
0:     }
1: 
0:     private void runRemoveNotDeltaOldShards(Allocator allocator)
0:     {
0:         ContextState ctx = ContextState.allocate(4, 1, allocator);
0:         ctx.writeElement(NodeId.fromInt(1), 1L, 1L, true);
0:         ctx.writeElement(NodeId.fromInt(2), -System.currentTimeMillis(), 0L);
0:         ctx.writeElement(NodeId.fromInt(3), -System.currentTimeMillis(), 0L);
0:         ctx.writeElement(NodeId.fromInt(4), -System.currentTimeMillis(), 0L);
1: 
0:         ByteBuffer cleaned = cc.removeOldShards(ctx.context, (int)(System.currentTimeMillis() / 1000) + 1);
0:         assert cc.total(ctx.context) == cc.total(cleaned);
0:         assert cleaned.remaining() == ctx.context.remaining() - 3 * stepLength;
0:     }
commit:17ad4cc
/////////////////////////////////////////////////////////////////////////
0:         ContextState ctx = ContextState.allocate(5, 3, allocator);
0:         ctx.writeElement(id1, 1L, 1L, true);
0:         ByteBuffer merger = cc.computeOldShardMerger(ctx.context, records, Integer.MAX_VALUE);
1: 
0:         assert m.getCount() == -1L;
0:         assert m.isDelta();
0:         assert m.getClock() <= -now;
0:         assert m.getCount() == -3L;
0:         assert m.isDelta();
0:         m.moveToNext();
0:         assert m.getNodeId().equals(NodeId.getLocalId());
0:         assert m.getClock() == 1L;
0:         assert m.getCount() == 4L;
0:         assert m.isDelta();
/////////////////////////////////////////////////////////////////////////
0:         ContextState ctx = ContextState.allocate(6, 3, allocator);
0:         ctx.writeElement(id1, 1L, 1L, true);
0:         ByteBuffer merger = cc.computeOldShardMerger(ctx.context, records, Integer.MAX_VALUE);
0:         assert cleaned.remaining() == ctx.context.remaining() - stepLength - 2;
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:ab5a8c7
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.db.context.CounterContext.ContextState;
0: import org.apache.cassandra.utils.NodeId;
0:         idLength       = NodeId.LENGTH; // size of int
0:         assert context.remaining() == stepLength + 4;
0:         ContextState left = ContextState.allocate(3, 0);
1:         ContextState right;
0:         left.writeElement(NodeId.fromInt(3), 3L, 0L);
0:         left.writeElement(NodeId.fromInt(6), 2L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 1L, 0L);
0:         right = new ContextState(ByteBufferUtil.clone(left.context), left.headerLength);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(4, 0);
0:         left.writeElement(NodeId.fromInt(3),  3L, 0L);
0:         left.writeElement(NodeId.fromInt(6),  2L, 0L);
0:         left.writeElement(NodeId.fromInt(9),  1L, 0L);
0:         left.writeElement(NodeId.fromInt(12), 0L, 0L);
0:         right = ContextState.allocate(3, 0);
0:         right.writeElement(NodeId.fromInt(3), 3L, 0L);
0:         right.writeElement(NodeId.fromInt(6), 2L, 0L);
0:         right.writeElement(NodeId.fromInt(9), 1L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(3, 0);
0:         left.writeElement(NodeId.fromInt(3), 3L, 0L);
0:         left.writeElement(NodeId.fromInt(6), 2L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(4, 0);
0:         right.writeElement(NodeId.fromInt(3),  3L, 0L);
0:         right.writeElement(NodeId.fromInt(6),  2L, 0L);
0:         right.writeElement(NodeId.fromInt(9),  1L, 0L);
0:         right.writeElement(NodeId.fromInt(12), 0L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(3, 0);
0:         left.writeElement(NodeId.fromInt(3), 3L, 0L);
0:         left.writeElement(NodeId.fromInt(6), 2L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 3L, 0L);
0:         right = ContextState.allocate(3, 0);
0:         right.writeElement(NodeId.fromInt(3), 3L, 0L);
0:         right.writeElement(NodeId.fromInt(6), 2L, 0L);
0:         right.writeElement(NodeId.fromInt(9), 1L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(3, 0);
0:         left.writeElement(NodeId.fromInt(3), 3L, 0L);
0:         left.writeElement(NodeId.fromInt(6), 2L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 3L, 0L);
0:         right = ContextState.allocate(3, 0);
0:         right.writeElement(NodeId.fromInt(3), 3L, 0L);
0:         right.writeElement(NodeId.fromInt(6), 9L, 0L);
0:         right.writeElement(NodeId.fromInt(9), 3L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(3, 0);
0:         left.writeElement(NodeId.fromInt(3), 1L, 0L);
0:         left.writeElement(NodeId.fromInt(4), 1L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(3, 0);
0:         right.writeElement(NodeId.fromInt(3), 1L, 0L);
0:         right.writeElement(NodeId.fromInt(6), 1L, 0L);
0:         right.writeElement(NodeId.fromInt(9), 1L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(3, 0);
0:         left.writeElement(NodeId.fromInt(3), 1L, 0L);
0:         left.writeElement(NodeId.fromInt(4), 1L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(3, 0);
0:         right.writeElement(NodeId.fromInt(2),  1L, 0L);
0:         right.writeElement(NodeId.fromInt(6),  1L, 0L);
0:         right.writeElement(NodeId.fromInt(12), 1L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(3, 0);
0:         left.writeElement(NodeId.fromInt(3), 1L, 0L);
0:         left.writeElement(NodeId.fromInt(6), 3L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(3, 0);
0:         right.writeElement(NodeId.fromInt(3), 1L, 0L);
0:         right.writeElement(NodeId.fromInt(6), 1L, 0L);
0:         right.writeElement(NodeId.fromInt(9), 5L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(3, 0);
0:         left.writeElement(NodeId.fromInt(3), 2L, 0L);
0:         left.writeElement(NodeId.fromInt(6), 3L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 1L, 0L);
0:         right = ContextState.allocate(3, 0);
0:         right.writeElement(NodeId.fromInt(3), 1L, 0L);
0:         right.writeElement(NodeId.fromInt(6), 9L, 0L);
0:         right.writeElement(NodeId.fromInt(9), 5L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(4, 0);
0:         left.writeElement(NodeId.fromInt(3),  2L, 0L);
0:         left.writeElement(NodeId.fromInt(6),  3L, 0L);
0:         left.writeElement(NodeId.fromInt(9),  1L, 0L);
0:         left.writeElement(NodeId.fromInt(12), 1L, 0L);
0:         right = ContextState.allocate(3, 0);
0:         right.writeElement(NodeId.fromInt(3), 4L, 0L);
0:         right.writeElement(NodeId.fromInt(6), 9L, 0L);
0:         right.writeElement(NodeId.fromInt(9), 5L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(3, 0);
0:         left.writeElement(NodeId.fromInt(3), 5L, 0L);
0:         left.writeElement(NodeId.fromInt(6), 3L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 2L, 0L);
0:         right = ContextState.allocate(4, 0);
0:         right.writeElement(NodeId.fromInt(3),  4L, 0L);
0:         right.writeElement(NodeId.fromInt(6),  3L, 0L);
0:         right.writeElement(NodeId.fromInt(9),  2L, 0L);
0:         right.writeElement(NodeId.fromInt(12), 1L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(3, 0);
0:         left.writeElement(NodeId.fromInt(3), 5L, 0L);
0:         left.writeElement(NodeId.fromInt(6), 2L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 2L, 0L);
0:         right = ContextState.allocate(4, 0);
0:         right.writeElement(NodeId.fromInt(3),  4L, 0L);
0:         right.writeElement(NodeId.fromInt(6),  3L, 0L);
0:         right.writeElement(NodeId.fromInt(9),  2L, 0L);
0:         right.writeElement(NodeId.fromInt(12), 1L, 0L);
0:             cc.diff(left.context, right.context);
0:         left = ContextState.allocate(4, 0);
0:         left.writeElement(NodeId.fromInt(3), 5L, 0L);
0:         left.writeElement(NodeId.fromInt(6), 2L, 0L);
0:         left.writeElement(NodeId.fromInt(7), 2L, 0L);
0:         left.writeElement(NodeId.fromInt(9), 2L, 0L);
0:         right = ContextState.allocate(3, 0);
0:         right.writeElement(NodeId.fromInt(3), 4L, 0L);
0:         right.writeElement(NodeId.fromInt(6), 3L, 0L);
0:         right.writeElement(NodeId.fromInt(9), 2L, 0L);
0:             cc.diff(left.context, right.context);
0:         ContextState left = ContextState.allocate(4, 1);
0:         left.writeElement(NodeId.fromInt(1), 1L, 1L);
0:         left.writeElement(NodeId.fromInt(2), 2L, 2L);
0:         left.writeElement(NodeId.fromInt(4), 6L, 3L);
0:         left.writeElement(NodeId.getLocalId(), 7L, 3L, true);
0:         ContextState right = ContextState.allocate(3, 1);
0:         right.writeElement(NodeId.fromInt(4), 4L, 4L);
0:         right.writeElement(NodeId.fromInt(5), 5L, 5L);
0:         right.writeElement(NodeId.getLocalId(), 2L, 9L, true);
0:         ByteBuffer merged = cc.merge(left.context, right.context);
1:         int hd = 4;
1:         assertEquals(hd + 5 * stepLength, merged.remaining());
0:         assert Util.equalsNodeId(NodeId.getLocalId(), merged, hd + 4*stepLength);
0:         assertEquals(  9L, merged.getLong(hd + 4*stepLength + idLength));
0:         assertEquals(12L,  merged.getLong(hd + 4*stepLength + idLength + clockLength));
0:         assert Util.equalsNodeId(NodeId.fromInt(4), merged, hd + 2*stepLength);
0:         assertEquals( 6L,  merged.getLong(hd + 2*stepLength + idLength));
0:         assertEquals( 3L,  merged.getLong(hd + 2*stepLength + idLength + clockLength));
0:         assert Util.equalsNodeId(NodeId.fromInt(5), merged, hd + 3*stepLength);
0:         assertEquals( 5L,  merged.getLong(hd + 3*stepLength + idLength));
0:         assertEquals( 5L,  merged.getLong(hd + 3*stepLength + idLength + clockLength));
0:         assert Util.equalsNodeId(NodeId.fromInt(2), merged, hd + 1*stepLength);
0:         assertEquals( 2L,  merged.getLong(hd + 1*stepLength + idLength));
0:         assertEquals( 2L,  merged.getLong(hd + 1*stepLength + idLength + clockLength));
0:         assert Util.equalsNodeId(NodeId.fromInt(1), merged, hd + 0*stepLength);
0:         assertEquals( 1L,  merged.getLong(hd + 0*stepLength + idLength));
0:         assertEquals( 1L,  merged.getLong(hd + 0*stepLength + idLength + clockLength));
0:         ContextState left = ContextState.allocate(4, 1);
0:         left.writeElement(NodeId.fromInt(1), 1L, 1L);
0:         left.writeElement(NodeId.fromInt(2), 2L, 2L);
0:         left.writeElement(NodeId.fromInt(4), 3L, 3L);
0:         left.writeElement(NodeId.getLocalId(), 3L, 3L, true);
0:         ContextState right = ContextState.allocate(3, 1);
0:         right.writeElement(NodeId.fromInt(4), 4L, 4L);
0:         right.writeElement(NodeId.fromInt(5), 5L, 5L);
0:         right.writeElement(NodeId.getLocalId(), 9L, 9L, true);
0:         ByteBuffer merged = cc.merge(left.context, right.context);
/////////////////////////////////////////////////////////////////////////
0:     public void testMergeOldShards()
0:         long now = System.currentTimeMillis();
0:         NodeId id1 = NodeId.fromInt(1);
0:         NodeId id3 = NodeId.fromInt(3);
0:         List<NodeId.NodeIdRecord> records = new ArrayList<NodeId.NodeIdRecord>();
0:         records.add(new NodeId.NodeIdRecord(id1, 2L));
0:         records.add(new NodeId.NodeIdRecord(id3, 4L));
0:         // Destination of merge is a delta
0:         ContextState ctx = ContextState.allocate(5, 2);
0:         ctx.writeElement(id1, 1L, 1L);
0:         ctx.writeElement(NodeId.fromInt(2), 2L, 2L);
0:         ctx.writeElement(id3, 3L, 3L, true);
0:         ctx.writeElement(NodeId.fromInt(4), 6L, 3L);
0:         ctx.writeElement(NodeId.fromInt(5), 7L, 3L, true);
0:         ByteBuffer merger = cc.computeOldShardMerger(ctx.context, records);
0:         ContextState m = new ContextState(merger);
0:         assert m.getNodeId().equals(id1);
0:         assert m.getClock() <= -now;
0:         assert m.getCount() == 0;
0:         m.moveToNext();
0:         assert m.getNodeId().equals(id3);
0:         assert m.getClock() == 4L;
0:         assert m.getCount() == 1L;
0:         assert cc.total(ctx.context) == cc.total(cc.merge(ctx.context, merger));
0:         // Source of merge is a delta
0:         ctx = ContextState.allocate(4, 1);
0:         ctx.writeElement(id1, 1L, 1L, true);
0:         ctx.writeElement(NodeId.fromInt(2), 2L, 2L);
0:         ctx.writeElement(id3, 3L, 3L);
0:         ctx.writeElement(NodeId.fromInt(4), 6L, 3L);
0:         merger = cc.computeOldShardMerger(ctx.context, records);
0:         assert cc.total(ctx.context) == cc.total(cc.merge(ctx.context, merger));
0:         // source and destination of merge are deltas
0:         ctx = ContextState.allocate(4, 2);
0:         ctx.writeElement(id1, 1L, 1L, true);
0:         ctx.writeElement(NodeId.fromInt(2), 2L, 2L);
0:         ctx.writeElement(id3, 3L, 3L, true);
0:         ctx.writeElement(NodeId.fromInt(4), 6L, 3L);
1: 
0:         merger = cc.computeOldShardMerger(ctx.context, records);
0:         assert cc.total(ctx.context) == cc.total(cc.merge(ctx.context, merger));
1: 
0:         // none of source and destination of merge are deltas
0:         ctx = ContextState.allocate(4, 0);
0:         ctx.writeElement(id1, 1L, 1L);
0:         ctx.writeElement(NodeId.fromInt(2), 2L, 2L);
0:         ctx.writeElement(id3, 3L, 3L);
0:         ctx.writeElement(NodeId.fromInt(4), 6L, 3L);
1: 
0:         merger = cc.computeOldShardMerger(ctx.context, records);
0:         assert cc.total(ctx.context) == cc.total(cc.merge(ctx.context, merger));
0:     }
1: 
1:     @Test
0:     public void testRemoveOldShards()
0:     {
0:         NodeId id1 = NodeId.fromInt(1);
0:         NodeId id3 = NodeId.fromInt(3);
0:         NodeId id6 = NodeId.fromInt(6);
0:         List<NodeId.NodeIdRecord> records = new ArrayList<NodeId.NodeIdRecord>();
0:         records.add(new NodeId.NodeIdRecord(id1, 2L));
0:         records.add(new NodeId.NodeIdRecord(id3, 4L));
0:         records.add(new NodeId.NodeIdRecord(id6, 10L));
1: 
0:         ContextState ctx = ContextState.allocate(6, 2);
0:         ctx.writeElement(id1, 1L, 1L);
0:         ctx.writeElement(NodeId.fromInt(2), 2L, 2L);
0:         ctx.writeElement(id3, 3L, 3L, true);
0:         ctx.writeElement(NodeId.fromInt(4), 6L, 3L);
0:         ctx.writeElement(NodeId.fromInt(5), 7L, 3L, true);
0:         ctx.writeElement(id6, 5L, 6L);
1: 
0:         ByteBuffer merger = cc.computeOldShardMerger(ctx.context, records);
0:         ByteBuffer merged = cc.merge(ctx.context, merger);
0:         assert cc.total(ctx.context) == cc.total(merged);
1: 
0:         ByteBuffer cleaned = cc.removeOldShards(merged, (int)(System.currentTimeMillis() / 1000) + 1);
0:         assert cc.total(ctx.context) == cc.total(cleaned);
0:         assert cleaned.remaining() == ctx.context.remaining() - stepLength;
1: 
0:         merger = cc.computeOldShardMerger(cleaned, records);
0:         merged = cc.merge(cleaned, merger);
0:         assert cc.total(ctx.context) == cc.total(merged);
1: 
0:         cleaned = cc.removeOldShards(merged, (int)(System.currentTimeMillis() / 1000) + 1);
0:         assert cc.total(ctx.context) == cc.total(cleaned);
0:         assert cleaned.remaining() == ctx.context.remaining() - 2 * stepLength - 2;
1: 
author:Johan Oskarsson
-------------------------------------------------------------------------------
commit:2c4ac98
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
1:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  * 
1:  */
1: package org.apache.cassandra.db.context;
1: 
0: import static org.junit.Assert.*;
1: 
0: import java.net.InetAddress;
0: import java.net.UnknownHostException;
0: import java.util.*;
1: 
0: import org.apache.commons.lang.ArrayUtils;
1: 
1: import org.junit.Test;
1: 
0: import org.apache.cassandra.Util;
0: import org.apache.cassandra.db.context.IContext.ContextRelationship;
0: import org.apache.cassandra.utils.FBUtilities;
1: 
0: /**
0:  * Note: these tests assume IPv4 (4 bytes) is used for id.
0:  *       if IPv6 (16 bytes) is used, tests will fail (but the code will work).
0:  *       however, it might be pragmatic to modify the code to just use
0:  *       the IPv4 portion of the IPv6 address-space.
1:  */
1: public class CounterContextTest
0: {
1:     private static final CounterContext cc = new CounterContext();
1: 
0:     private static final InetAddress idAddress;
0:     private static final byte[] id;
0:     private static final int idLength;
0:     private static final int clockLength;
0:     private static final int countLength;
1: 
0:     private static final int stepLength;
0:     private static final int defaultEntries;
1: 
0:     static
0:     {
0:         idAddress      = FBUtilities.getLocalAddress();
0:         id             = idAddress.getAddress();
0:         idLength       = 4; // size of int
0:         clockLength    = 8; // size of long
0:         countLength    = 8; // size of long
0:         stepLength     = idLength + clockLength + countLength;
1: 
0:         defaultEntries = 10;
0:     }
1: 
1:     @Test
0:     public void testCreate()
0:     {
0:         byte[] context = cc.create();
0:         assert context.length == 0;
0:     }
1: 
1:     @Test
0:     public void testUpdatePresentReorder() throws UnknownHostException
0:     {
0:         byte[] context;
1: 
0:         context = new byte[stepLength * defaultEntries];
1: 
0:         for (int i = 0; i < defaultEntries - 1; i++)
0:         {
0:             cc.writeElementAtStepOffset(
0:                 context,
0:                 i,
0:                 FBUtilities.toByteArray(i),
0:                 1L,
0:                 1L);
0:         }
0:         cc.writeElementAtStepOffset(
0:             context,
0:             (defaultEntries - 1),
0:             id,
0:             2L,
0:             3L);
1: 
0:         context = cc.update(context, idAddress, 10L);
1: 
0:         assertEquals(context.length, stepLength * defaultEntries);
0:         assertEquals(  3L, FBUtilities.byteArrayToLong(context, idLength));
0:         assertEquals( 13L, FBUtilities.byteArrayToLong(context, idLength + clockLength));
0:         for (int i = 1; i < defaultEntries; i++)
0:         {
0:             int offset = i * stepLength;
0:             assertEquals( i-1, FBUtilities.byteArrayToInt(context,  offset));
0:             assertEquals(1L, FBUtilities.byteArrayToLong(context, offset + idLength));
0:             assertEquals(1L, FBUtilities.byteArrayToLong(context, offset + idLength + clockLength));
0:         }
0:     }
1: 
1:     @Test
0:     public void testUpdateNotPresent()
0:     {
0:         byte[] context = new byte[stepLength * 2];
1: 
0:         for (int i = 0; i < 2; i++)
0:         {
0:             cc.writeElementAtStepOffset(
0:                 context,
0:                 i,
0:                 FBUtilities.toByteArray(i),
0:                 1L,
0:                 1L);
0:         }
1: 
0:         context = cc.update(context, idAddress, 328L);
1: 
0:         assert context.length == stepLength * 3;
0:         assert   1L == FBUtilities.byteArrayToLong(context, idLength);
0:         assert 328L == FBUtilities.byteArrayToLong(context, idLength + clockLength);
0:         for (int i = 1; i < 3; i++)
0:         {
0:             int offset = i * stepLength;
0:             assert i-1 == FBUtilities.byteArrayToInt(context,  offset);
0:             assert  1L == FBUtilities.byteArrayToLong(context, offset + idLength);
0:             assert  1L == FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);
0:         }
0:     }
1: 
1:     @Test
0:     public void testSwapElement()
0:     {
0:         byte[] context = new byte[stepLength * 3];
1: 
0:         for (int i = 0; i < 3; i++)
0:         {
0:             cc.writeElementAtStepOffset(
0:                 context,
0:                 i,
0:                 FBUtilities.toByteArray(i),
0:                 1L,
0:                 1L);
0:         }
0:         cc.swapElement(context, 0, 2*stepLength);
1: 
0:         assert 2 == FBUtilities.byteArrayToInt(context, 0);
0:         assert 0 == FBUtilities.byteArrayToInt(context, 2*stepLength);
1: 
0:         cc.swapElement(context, 0, 1*stepLength);
1: 
0:         assert 1 == FBUtilities.byteArrayToInt(context, 0);
0:         assert 2 == FBUtilities.byteArrayToInt(context, 1*stepLength);
0:     }
1: 
1:     @Test
0:     public void testPartitionElements()
0:     {
0:         byte[] context = new byte[stepLength * 10];
1: 
0:         cc.writeElementAtStepOffset(context, 0, FBUtilities.toByteArray(5), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 1, FBUtilities.toByteArray(3), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 2, FBUtilities.toByteArray(6), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 3, FBUtilities.toByteArray(7), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 4, FBUtilities.toByteArray(8), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 5, FBUtilities.toByteArray(9), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 6, FBUtilities.toByteArray(2), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 7, FBUtilities.toByteArray(4), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 8, FBUtilities.toByteArray(1), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 9, FBUtilities.toByteArray(3), 1L, 1L);
1: 
0:         cc.partitionElements(
0:             context,
0:             0, // left
0:             9, // right (inclusive)
0:             2  // pivot
0:             );
1: 
0:         assert 5 == FBUtilities.byteArrayToInt(context, 0*stepLength);
0:         assert 3 == FBUtilities.byteArrayToInt(context, 1*stepLength);
0:         assert 3 == FBUtilities.byteArrayToInt(context, 2*stepLength);
0:         assert 2 == FBUtilities.byteArrayToInt(context, 3*stepLength);
0:         assert 4 == FBUtilities.byteArrayToInt(context, 4*stepLength);
0:         assert 1 == FBUtilities.byteArrayToInt(context, 5*stepLength);
0:         assert 6 == FBUtilities.byteArrayToInt(context, 6*stepLength);
0:         assert 8 == FBUtilities.byteArrayToInt(context, 7*stepLength);
0:         assert 9 == FBUtilities.byteArrayToInt(context, 8*stepLength);
0:         assert 7 == FBUtilities.byteArrayToInt(context, 9*stepLength);
0:     }
1: 
1:     @Test
0:     public void testSortElementsById()
0:     {
0:         byte[] context = new byte[stepLength * 10];
1: 
0:         cc.writeElementAtStepOffset(context, 0, FBUtilities.toByteArray(5), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 1, FBUtilities.toByteArray(3), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 2, FBUtilities.toByteArray(6), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 3, FBUtilities.toByteArray(7), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 4, FBUtilities.toByteArray(8), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 5, FBUtilities.toByteArray(9), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 6, FBUtilities.toByteArray(2), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 7, FBUtilities.toByteArray(4), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 8, FBUtilities.toByteArray(1), 1L, 1L);
0:         cc.writeElementAtStepOffset(context, 9, FBUtilities.toByteArray(3), 1L, 1L);
1:         
0:         byte[] sorted = cc.sortElementsById(context);
1: 
0:         assertEquals( 1, FBUtilities.byteArrayToInt(sorted, 0*stepLength));
0:         assertEquals( 2, FBUtilities.byteArrayToInt(sorted, 1*stepLength));
0:         assertEquals( 3, FBUtilities.byteArrayToInt(sorted, 2*stepLength));
0:         assertEquals( 3, FBUtilities.byteArrayToInt(sorted, 3*stepLength));
0:         assertEquals( 4, FBUtilities.byteArrayToInt(sorted, 4*stepLength));
0:         assertEquals( 5, FBUtilities.byteArrayToInt(sorted, 5*stepLength));
0:         assertEquals( 6, FBUtilities.byteArrayToInt(sorted, 6*stepLength));
0:         assertEquals( 7, FBUtilities.byteArrayToInt(sorted, 7*stepLength));
0:         assertEquals( 8, FBUtilities.byteArrayToInt(sorted, 8*stepLength));
0:         assertEquals( 9, FBUtilities.byteArrayToInt(sorted, 9*stepLength));
0:     }
1: 
1:     @Test
1:     public void testDiff()
0:     {
0:         byte[] left = new byte[3 * stepLength];
0:         byte[] right;
1: 
1:         // equality: equal nodes, all counts same
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 1L, 0L);
0:         right = ArrayUtils.clone(left);
1: 
0:         assert ContextRelationship.EQUAL ==
0:             cc.diff(left, right);
1: 
1:         // greater than: left has superset of nodes (counts equal)
0:         left = new byte[4 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3),  3L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6),  2L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9),  1L, 0L);
0:         cc.writeElementAtStepOffset(left, 3, FBUtilities.toByteArray(12), 0L, 0L);
1: 
0:         right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9), 1L, 0L);
1: 
0:         assert ContextRelationship.GREATER_THAN ==
0:             cc.diff(left, right);
1:         
1:         // less than: left has subset of nodes (counts equal)
0:         left = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 1L, 0L);
1: 
0:         right = new byte[4 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3),  3L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6),  2L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9),  1L, 0L);
0:         cc.writeElementAtStepOffset(right, 3, FBUtilities.toByteArray(12), 0L, 0L);
1: 
0:         assert ContextRelationship.LESS_THAN ==
0:             cc.diff(left, right);
1: 
1:         // greater than: equal nodes, but left has higher counts
0:         left = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 3L, 0L);
1: 
0:         right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9), 1L, 0L);
1: 
0:         assert ContextRelationship.GREATER_THAN ==
0:             cc.diff(left, right);
1: 
1:         // less than: equal nodes, but right has higher counts
0:         left = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 3L, 0L);
1: 
0:         right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3), 3L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6), 9L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9), 3L, 0L);
1: 
0:         assert ContextRelationship.LESS_THAN ==
0:             cc.diff(left, right);
1: 
1:         // disjoint: right and left have disjoint node sets
0:         left = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(4), 1L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 1L, 0L);
1: 
0:         right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6), 1L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9), 1L, 0L);
1: 
0:         assert ContextRelationship.DISJOINT ==
0:             cc.diff(left, right);
1: 
0:         left = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(4), 1L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 1L, 0L);
1: 
0:         right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(2),  1L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6),  1L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(12), 1L, 0L);
1: 
0:         assert ContextRelationship.DISJOINT ==
0:             cc.diff(left, right);
1: 
1:         // disjoint: equal nodes, but right and left have higher counts in differing nodes
0:         left = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6), 3L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 1L, 0L);
1: 
0:         right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6), 1L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9), 5L, 0L);
1: 
0:         assert ContextRelationship.DISJOINT ==
0:             cc.diff(left, right);
1: 
0:         left = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 2L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6), 3L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 1L, 0L);
1: 
0:         right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3), 1L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6), 9L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9), 5L, 0L);
1: 
0:         assert ContextRelationship.DISJOINT ==
0:             cc.diff(left, right);
1: 
1:         // disjoint: left has more nodes, but lower counts
0:         left = new byte[4 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3),  2L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6),  3L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9),  1L, 0L);
0:         cc.writeElementAtStepOffset(left, 3, FBUtilities.toByteArray(12), 1L, 0L);
1: 
0:         right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3), 4L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6), 9L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9), 5L, 0L);
1: 
0:         assert ContextRelationship.DISJOINT ==
0:             cc.diff(left, right);
1:         
1:         // disjoint: left has less nodes, but higher counts
0:         left = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 5L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6), 3L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 2L, 0L);
1: 
0:         right = new byte[4 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3),  4L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6),  3L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9),  2L, 0L);
0:         cc.writeElementAtStepOffset(right, 3, FBUtilities.toByteArray(12), 1L, 0L);
1: 
0:         assert ContextRelationship.DISJOINT ==
0:             cc.diff(left, right);
1: 
1:         // disjoint: mixed nodes and counts
0:         left = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 5L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(9), 2L, 0L);
1: 
0:         right = new byte[4 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3),  4L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6),  3L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9),  2L, 0L);
0:         cc.writeElementAtStepOffset(right, 3, FBUtilities.toByteArray(12), 1L, 0L);
1: 
0:         assert ContextRelationship.DISJOINT ==
0:             cc.diff(left, right);
1: 
0:         left = new byte[4 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(3), 5L, 0L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(6), 2L, 0L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(7), 2L, 0L);
0:         cc.writeElementAtStepOffset(left, 3, FBUtilities.toByteArray(9), 2L, 0L);
1: 
0:         right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(3), 4L, 0L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(6), 3L, 0L);
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(9), 2L, 0L);
1: 
0:         assert ContextRelationship.DISJOINT ==
0:             cc.diff(left, right);
0:     }
1: 
1:     @Test
1:     public void testMerge()
0:     {
1:         // note: local counts aggregated; remote counts are reconciled (i.e. take max)
0:         byte[] left = new byte[4 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(1), 1L, 1L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(2), 2L, 2L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(4), 6L, 3L);
0:         cc.writeElementAtStepOffset(
0:             left,
0:             3,
0:             FBUtilities.getLocalAddress().getAddress(),
0:             7L,
0:             3L);
1: 
0:         byte[] right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(5), 5L, 5L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(4), 4L, 4L);
0:         cc.writeElementAtStepOffset(
0:             right,
0:             0,
0:             FBUtilities.getLocalAddress().getAddress(),
0:             2L,
0:             9L);
1: 
0:         byte[] merged = cc.merge(left, right);
1: 
1:         // local node id's counts are aggregated
0:         assertEquals(0, FBUtilities.compareUnsigned(
0:             FBUtilities.getLocalAddress().getAddress(),
0:             merged, 
0:             0,
0:             0*stepLength,
0:             4,
0:             4));
0:         assertEquals(  9L, FBUtilities.byteArrayToLong(merged, 0*stepLength + idLength));
0:         assertEquals(12L,  FBUtilities.byteArrayToLong(merged, 0*stepLength + idLength + clockLength));
1: 
1:         // remote node id counts are reconciled (i.e. take max)
0:         assertEquals( 4,   FBUtilities.byteArrayToInt(merged,  1*stepLength));
0:         assertEquals( 6L,  FBUtilities.byteArrayToLong(merged, 1*stepLength + idLength));
0:         assertEquals( 3L,  FBUtilities.byteArrayToLong(merged, 1*stepLength + idLength + clockLength));
1: 
0:         assertEquals( 5,   FBUtilities.byteArrayToInt(merged,  2*stepLength));
0:         assertEquals( 5L,  FBUtilities.byteArrayToLong(merged, 2*stepLength + idLength));
0:         assertEquals( 5L,  FBUtilities.byteArrayToLong(merged, 2*stepLength + idLength + clockLength));
1: 
0:         assertEquals( 2,   FBUtilities.byteArrayToInt(merged,  3*stepLength));
0:         assertEquals( 2L,  FBUtilities.byteArrayToLong(merged, 3*stepLength + idLength));
0:         assertEquals( 2L,  FBUtilities.byteArrayToLong(merged, 3*stepLength + idLength + clockLength));
1: 
0:         assertEquals( 1,   FBUtilities.byteArrayToInt(merged,  4*stepLength));
0:         assertEquals( 1L,  FBUtilities.byteArrayToLong(merged, 4*stepLength + idLength));
0:         assertEquals( 1L,  FBUtilities.byteArrayToLong(merged, 4*stepLength + idLength + clockLength));
0:     }
1: 
1:     @Test
1:     public void testTotal()
0:     {
0:         byte[] left = new byte[4 * stepLength];
0:         cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(1), 1L, 1L);
0:         cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(2), 2L, 2L);
0:         cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(4), 3L, 3L);
0:         cc.writeElementAtStepOffset(
0:             left,
0:             3,
0:             FBUtilities.getLocalAddress().getAddress(),
0:             3L,
0:             3L);
1: 
0:         byte[] right = new byte[3 * stepLength];
0:         cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(5), 5L, 5L);
0:         cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(4), 4L, 4L);
0:         cc.writeElementAtStepOffset(
0:             right,
0:             0,
0:             FBUtilities.getLocalAddress().getAddress(),
0:             9L,
0:             9L);
1: 
0:         byte[] merged = cc.merge(left, right);
1: 
0:         // 127.0.0.1: 12 (3+9)
0:         // 0.0.0.1:    1
0:         // 0.0.0.2:    2
0:         // 0.0.0.4:    4
0:         // 0.0.0.5:    5
1: 
0:         assertEquals(24L, FBUtilities.byteArrayToLong(cc.total(merged)));
0:     }
1: 
1:     @Test
0:     public void testCleanNodeCounts() throws UnknownHostException
0:     {
0:         byte[] bytes = new byte[4 * stepLength];
0:         cc.writeElementAtStepOffset(bytes, 0, FBUtilities.toByteArray(1), 1L, 1L);
0:         cc.writeElementAtStepOffset(bytes, 1, FBUtilities.toByteArray(2), 2L, 2L);
0:         cc.writeElementAtStepOffset(bytes, 2, FBUtilities.toByteArray(4), 3L, 3L);
0:         cc.writeElementAtStepOffset(bytes, 3, FBUtilities.toByteArray(8), 4L, 4L);
1: 
0:         assertEquals(4, FBUtilities.byteArrayToInt(bytes,  2*stepLength));
0:         assertEquals(3L, FBUtilities.byteArrayToLong(bytes, 2*stepLength + idLength));
1: 
0:         bytes = cc.cleanNodeCounts(bytes, InetAddress.getByAddress(FBUtilities.toByteArray(4)));
1: 
0:         // node: 0.0.0.4 should be removed
0:         assertEquals(3 * stepLength, bytes.length);
1: 
0:         // other nodes should be unaffected
0:         assertEquals(1, FBUtilities.byteArrayToInt(bytes,  0*stepLength));
0:         assertEquals(1L, FBUtilities.byteArrayToLong(bytes, 0*stepLength + idLength));
1: 
0:         assertEquals(2, FBUtilities.byteArrayToInt(bytes,  1*stepLength));
0:         assertEquals(2L, FBUtilities.byteArrayToLong(bytes, 1*stepLength + idLength));
1: 
0:         assertEquals(8, FBUtilities.byteArrayToInt(bytes,  2*stepLength));
0:         assertEquals(4L, FBUtilities.byteArrayToLong(bytes, 2*stepLength + idLength));
0:     }
0: }
============================================================================