1:91bdf7f: /*
1:91bdf7f:  * Licensed to the Apache Software Foundation (ASF) under one
1:91bdf7f:  * or more contributor license agreements.  See the NOTICE file
1:91bdf7f:  * distributed with this work for additional information
1:91bdf7f:  * regarding copyright ownership.  The ASF licenses this file
1:91bdf7f:  * to you under the Apache License, Version 2.0 (the
1:91bdf7f:  * "License"); you may not use this file except in compliance
1:91bdf7f:  * with the License.  You may obtain a copy of the License at
1:c6ed2e0:  *
1:91bdf7f:  *     http://www.apache.org/licenses/LICENSE-2.0
2:91bdf7f:  *
1:91bdf7f:  * Unless required by applicable law or agreed to in writing, software
1:91bdf7f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:91bdf7f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:91bdf7f:  * See the License for the specific language governing permissions and
1:91bdf7f:  * limitations under the License.
1:e94032a:  */
1:91bdf7f: package org.apache.cassandra.cql3;
1:b72af48: 
1:e94032a: import java.nio.ByteBuffer;
1:0932ed6: import java.util.ArrayList;
1:0932ed6: import java.util.List;
1:0932ed6: 
1:ee55f36: import org.slf4j.Logger;
1:ee55f36: import org.slf4j.LoggerFactory;
1:a552b30: 
1:a552b30: import org.apache.cassandra.config.Schema;
1:91bdf7f: import org.apache.cassandra.db.marshal.*;
1:ecf05b8: import org.apache.cassandra.db.marshal.CollectionType.Kind;
1:3a2faf9: import org.apache.cassandra.exceptions.InvalidRequestException;
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:3a2faf9: import org.apache.cassandra.exceptions.SyntaxException;
1:a89597d: import org.apache.cassandra.schema.KeyspaceMetadata;
1:340df43: import org.apache.cassandra.schema.Types;
1:e94032a: import org.apache.cassandra.serializers.CollectionSerializer;
1:e94032a: import org.apache.cassandra.serializers.MarshalException;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:e94032a: import org.apache.cassandra.utils.ByteBufferUtil;
1:a552b30: 
1:a67f779: public interface CQL3Type
1:b72af48: {
1:ee55f36:     static final Logger logger = LoggerFactory.getLogger(CQL3Type.class);
1:ee55f36: 
1:677230d:     default boolean isCollection()
1:677230d:     {
1:677230d:         return false;
1:677230d:     }
1:677230d: 
1:677230d:     default boolean isUDT()
1:677230d:     {
1:677230d:         return false;
1:677230d:     }
1:677230d: 
1:91bdf7f:     public AbstractType<?> getType();
1:02be0de: 
1:e94032a:     /**
1:c6ed2e0:      * Generates CQL literal from a binary value of this type.
1:e0adc16:      *  @param buffer the value to convert to a CQL literal. This value must be
1:c6ed2e0:      * serialized with {@code version} of the native protocol.
1:c6ed2e0:      * @param version the native protocol version in which {@code buffer} is encoded.
1:e94032a:      */
1:e0adc16:     public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version);
1:e94032a: 
1:a67f779:     public enum Native implements CQL3Type
1:e94032a:     {
1:107545b:         ASCII       (AsciiType.instance),
1:107545b:         BIGINT      (LongType.instance),
1:107545b:         BLOB        (BytesType.instance),
1:107545b:         BOOLEAN     (BooleanType.instance),
1:107545b:         COUNTER     (CounterColumnType.instance),
1:340df43:         DATE        (SimpleDateType.instance),
1:107545b:         DECIMAL     (DecimalType.instance),
1:107545b:         DOUBLE      (DoubleType.instance),
1:ecf05b8:         DURATION    (DurationType.instance),
1:340df43:         EMPTY       (EmptyType.instance),
1:107545b:         FLOAT       (FloatType.instance),
1:107545b:         INET        (InetAddressType.instance),
1:107545b:         INT         (Int32Type.instance),
1:35a945e:         SMALLINT    (ShortType.instance),
1:107545b:         TEXT        (UTF8Type.instance),
1:340df43:         TIME        (TimeType.instance),
1:107545b:         TIMESTAMP   (TimestampType.instance),
1:340df43:         TIMEUUID    (TimeUUIDType.instance),
1:35a945e:         TINYINT     (ByteType.instance),
1:107545b:         UUID        (UUIDType.instance),
1:107545b:         VARCHAR     (UTF8Type.instance),
1:340df43:         VARINT      (IntegerType.instance);
1:0932ed6: 
1:91bdf7f:         private final AbstractType<?> type;
1:0932ed6: 
1:91bdf7f:         private Native(AbstractType<?> type)
1:e94032a:         {
1:91bdf7f:             this.type = type;
1:e94032a:         }
1:0932ed6: 
1:91bdf7f:         public AbstractType<?> getType()
1:e94032a:         {
1:91bdf7f:             return type;
1:ee55f36:         }
1:ee55f36: 
1:e94032a:         /**
1:e94032a:          * Delegate to
1:c6ed2e0:          * {@link org.apache.cassandra.serializers.TypeSerializer#toCQLLiteral(ByteBuffer)}
1:e94032a:          * for native types as most CQL literal representations work fine with the default
1:e94032a:          * {@link org.apache.cassandra.serializers.TypeSerializer#toString(Object)}
1:e94032a:          * {@link org.apache.cassandra.serializers.TypeSerializer#deserialize(ByteBuffer)} implementations.
1:e94032a:          */
1:e0adc16:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
1:ee55f36:         {
1:c6ed2e0:             return type.getSerializer().toCQLLiteral(buffer);
1:e94032a:         }
1:e94032a: 
1:a67f779:         @Override
1:a67f779:         public String toString()
1:e94032a:         {
1:a67f779:             return super.toString().toLowerCase();
1:e94032a:         }
1:e94032a:     }
1:0932ed6: 
1:a67f779:     public static class Custom implements CQL3Type
1:e94032a:     {
1:91bdf7f:         private final AbstractType<?> type;
1:0932ed6: 
1:a67f779:         public Custom(AbstractType<?> type)
1:e94032a:         {
1:a67f779:             this.type = type;
1:e94032a:         }
1:d63d07b: 
1:3a2faf9:         public Custom(String className) throws SyntaxException, ConfigurationException
1:e94032a:         {
1:a67f779:             this(TypeParser.parse(className));
1:02be0de:         }
1:a552b30: 
1:91bdf7f:         public AbstractType<?> getType()
1:e94032a:         {
1:91bdf7f:             return type;
1:0932ed6:         }
1:a552b30: 
1:e0adc16:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
1:e94032a:         {
1:c6ed2e0:             // *always* use the 'blob' syntax to express custom types in CQL
1:c6ed2e0:             return Native.BLOB.toCQLLiteral(buffer, version);
1:0932ed6:         }
1:a552b30: 
1:a67f779:         @Override
1:b72af48:         public final boolean equals(Object o)
1:e94032a:         {
1:b72af48:             if(!(o instanceof Custom))
1:ee55f36:                 return false;
1:a552b30: 
1:b72af48:             Custom that = (Custom)o;
1:b72af48:             return type.equals(that.type);
1:a552b30:         }
1:a552b30: 
1:b72af48:         @Override
1:b72af48:         public final int hashCode()
1:e94032a:         {
1:b72af48:             return type.hashCode();
1:a552b30:         }
1:a552b30: 
1:b72af48:         @Override
1:a67f779:         public String toString()
1:02be0de:         {
1:e94032a:             return "'" + type + '\'';
1:a552b30:         }
1:b72af48:     }
1:a552b30: 
1:a67f779:     public static class Collection implements CQL3Type
1:02be0de:     {
1:d63d07b:         private final CollectionType type;
1:a552b30: 
1:a67f779:         public Collection(CollectionType type)
1:0932ed6:         {
1:91bdf7f:             this.type = type;
1:b72af48:         }
1:a552b30: 
1:91bdf7f:         public AbstractType<?> getType()
1:0932ed6:         {
1:91bdf7f:             return type;
1:b72af48:         }
1:a552b30: 
1:0932ed6:         public boolean isCollection()
1:0932ed6:         {
1:ee55f36:             return true;
1:e94032a:         }
1:e94032a: 
1:e0adc16:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
1:e94032a:         {
1:c6ed2e0:             if (buffer == null)
1:c6ed2e0:                 return "null";
1:c6ed2e0: 
1:c6ed2e0:             StringBuilder target = new StringBuilder();
1:c6ed2e0:             buffer = buffer.duplicate();
1:c6ed2e0:             int size = CollectionSerializer.readCollectionSize(buffer, version);
1:c6ed2e0: 
1:c6ed2e0:             switch (type.kind)
1:c6ed2e0:             {
1:c6ed2e0:                 case LIST:
1:c6ed2e0:                     CQL3Type elements = ((ListType) type).getElementsType().asCQL3Type();
1:c6ed2e0:                     target.append('[');
1:c6ed2e0:                     generateSetOrListCQLLiteral(buffer, version, target, size, elements);
1:c6ed2e0:                     target.append(']');
1:c6ed2e0:                     break;
1:c6ed2e0:                 case SET:
1:c6ed2e0:                     elements = ((SetType) type).getElementsType().asCQL3Type();
1:c6ed2e0:                     target.append('{');
1:c6ed2e0:                     generateSetOrListCQLLiteral(buffer, version, target, size, elements);
1:c6ed2e0:                     target.append('}');
1:c6ed2e0:                     break;
1:c6ed2e0:                 case MAP:
1:c6ed2e0:                     target.append('{');
1:c6ed2e0:                     generateMapCQLLiteral(buffer, version, target, size);
1:c6ed2e0:                     target.append('}');
1:c6ed2e0:                     break;
1:e94032a:             }
1:c6ed2e0:             return target.toString();
1:e94032a:         }
1:c6ed2e0: 
1:e0adc16:         private void generateMapCQLLiteral(ByteBuffer buffer, ProtocolVersion version, StringBuilder target, int size)
1:e94032a:         {
1:e94032a:             CQL3Type keys = ((MapType) type).getKeysType().asCQL3Type();
1:e94032a:             CQL3Type values = ((MapType) type).getValuesType().asCQL3Type();
1:e94032a:             for (int i = 0; i < size; i++)
1:e94032a:             {
1:e94032a:                 if (i > 0)
1:e94032a:                     target.append(", ");
1:e94032a:                 ByteBuffer element = CollectionSerializer.readValue(buffer, version);
1:c6ed2e0:                 target.append(keys.toCQLLiteral(element, version));
1:e94032a:                 target.append(": ");
1:e94032a:                 element = CollectionSerializer.readValue(buffer, version);
1:c6ed2e0:                 target.append(values.toCQLLiteral(element, version));
1:e94032a:             }
1:e94032a:         }
1:c6ed2e0: 
1:e0adc16:         private static void generateSetOrListCQLLiteral(ByteBuffer buffer, ProtocolVersion version, StringBuilder target, int size, CQL3Type elements)
1:e94032a:         {
1:e94032a:             for (int i = 0; i < size; i++)
1:e94032a:             {
1:e94032a:                 if (i > 0)
1:e94032a:                     target.append(", ");
1:e94032a:                 ByteBuffer element = CollectionSerializer.readValue(buffer, version);
1:c6ed2e0:                 target.append(elements.toCQLLiteral(element, version));
1:0932ed6:             }
1:0932ed6:         }
1:e94032a: 
1:a67f779:         @Override
1:b72af48:         public final boolean equals(Object o)
1:e94032a:         {
1:b72af48:             if(!(o instanceof Collection))
1:0932ed6:                 return false;
1:e94032a: 
1:b72af48:             Collection that = (Collection)o;
1:b72af48:             return type.equals(that.type);
1:0932ed6:         }
1:e94032a: 
1:b72af48:         @Override
1:b72af48:         public final int hashCode()
1:0932ed6:         {
1:b72af48:             return type.hashCode();
1:b72af48:         }
1:e94032a: 
1:b72af48:         @Override
1:a67f779:         public String toString()
1:c045690:         {
1:ee55f36:             boolean isFrozen = !this.type.isMultiCell();
1:ee55f36:             StringBuilder sb = new StringBuilder(isFrozen ? "frozen<" : "");
2:e94032a:             switch (type.kind)
1:a552b30:             {
2:e94032a:                 case LIST:
1:ee55f36:                     AbstractType<?> listType = ((ListType)type).getElementsType();
1:ee55f36:                     sb.append("list<").append(listType.asCQL3Type());
1:ee55f36:                     break;
2:e94032a:                 case SET:
1:ee55f36:                     AbstractType<?> setType = ((SetType)type).getElementsType();
1:ee55f36:                     sb.append("set<").append(setType.asCQL3Type());
1:ee55f36:                     break;
2:e94032a:                 case MAP:
1:ee55f36:                     AbstractType<?> keysType = ((MapType)type).getKeysType();
1:ee55f36:                     AbstractType<?> valuesType = ((MapType)type).getValuesType();
1:ee55f36:                     sb.append("map<").append(keysType.asCQL3Type()).append(", ").append(valuesType.asCQL3Type());
1:ee55f36:                     break;
1:ee55f36:                 default:
1:ee55f36:                     throw new AssertionError();
1:a552b30:             }
1:e94032a:             sb.append('>');
1:ee55f36:             if (isFrozen)
1:e94032a:                 sb.append('>');
1:ee55f36:             return sb.toString();
1:a552b30:         }
1:a552b30:     }
1:0932ed6: 
1:a552b30:     public static class UserDefined implements CQL3Type
1:a552b30:     {
1:a552b30:         // Keeping this separatly from type just to simplify toString()
1:d63d07b:         private final String name;
1:d63d07b:         private final UserType type;
1:0932ed6: 
1:d63d07b:         private UserDefined(String name, UserType type)
1:a552b30:         {
1:a552b30:             this.name = name;
1:a552b30:             this.type = type;
1:a552b30:         }
1:0932ed6: 
1:d63d07b:         public static UserDefined create(UserType type)
1:a552b30:         {
1:d63d07b:             return new UserDefined(UTF8Type.instance.compose(type.name), type);
1:a552b30:         }
1:0932ed6: 
1:677230d:         public boolean isUDT()
1:677230d:         {
1:677230d:             return true;
1:677230d:         }
1:677230d: 
1:a552b30:         public AbstractType<?> getType()
1:a552b30:         {
1:a552b30:             return type;
1:a552b30:         }
1:d63d07b: 
1:e0adc16:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
1:a552b30:         {
1:e94032a:             if (buffer == null)
1:c6ed2e0:                 return "null";
1:a552b30: 
1:a552b30: 
1:c6ed2e0:             StringBuilder target = new StringBuilder();
1:c6ed2e0:             buffer = buffer.duplicate();
1:c6ed2e0:             target.append('{');
1:c6ed2e0:             for (int i = 0; i < type.size(); i++)
1:e94032a:             {
1:c6ed2e0:                 // we allow the input to have less fields than declared so as to support field addition.
1:c6ed2e0:                 if (!buffer.hasRemaining())
1:c6ed2e0:                     break;
1:c6ed2e0: 
1:c6ed2e0:                 if (buffer.remaining() < 4)
1:c6ed2e0:                     throw new MarshalException(String.format("Not enough bytes to read size of %dth field %s", i, type.fieldName(i)));
1:c6ed2e0: 
1:c6ed2e0:                 int size = buffer.getInt();
1:c6ed2e0: 
1:c6ed2e0:                 if (i > 0)
1:c6ed2e0:                     target.append(", ");
1:c6ed2e0: 
1:c6ed2e0:                 target.append(ColumnIdentifier.maybeQuote(type.fieldNameAsString(i)));
1:c6ed2e0:                 target.append(": ");
1:c6ed2e0: 
1:c6ed2e0:                 // size < 0 means null value
1:c6ed2e0:                 if (size < 0)
1:e94032a:                 {
1:c6ed2e0:                     target.append("null");
1:c6ed2e0:                     continue;
1:e94032a:                 }
1:c6ed2e0: 
1:c6ed2e0:                 if (buffer.remaining() < size)
1:c6ed2e0:                     throw new MarshalException(String.format("Not enough bytes to read %dth field %s", i, type.fieldName(i)));
1:c6ed2e0: 
1:c6ed2e0:                 ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);
1:c6ed2e0:                 target.append(type.fieldType(i).asCQL3Type().toCQLLiteral(field, version));
1:e94032a:             }
1:c6ed2e0:             target.append('}');
1:c6ed2e0:             return target.toString();
1:e94032a:         }
1:e94032a: 
1:a552b30:         @Override
1:a552b30:         public final boolean equals(Object o)
1:a552b30:         {
1:a552b30:             if(!(o instanceof UserDefined))
1:677230d:                 return false;
1:e94032a: 
1:a552b30:             UserDefined that = (UserDefined)o;
1:a552b30:             return type.equals(that.type);
1:a552b30:         }
1:e94032a: 
1:a552b30:         @Override
1:a552b30:         public final int hashCode()
1:a552b30:         {
1:a552b30:             return type.hashCode();
1:a552b30:         }
1:e94032a: 
1:a552b30:         @Override
1:a552b30:         public String toString()
1:a552b30:         {
1:677230d:             if (type.isMultiCell())
1:677230d:                 return ColumnIdentifier.maybeQuote(name);
1:677230d:             else
1:677230d:                 return "frozen<" + ColumnIdentifier.maybeQuote(name) + '>';
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:0932ed6:     public static class Tuple implements CQL3Type
1:e94032a:     {
1:0932ed6:         private final TupleType type;
1:e94032a: 
1:0932ed6:         private Tuple(TupleType type)
1:e94032a:         {
1:0932ed6:             this.type = type;
1:e94032a:         }
1:e94032a: 
1:0932ed6:         public static Tuple create(TupleType type)
1:e94032a:         {
1:0932ed6:             return new Tuple(type);
1:e94032a:         }
1:e94032a: 
1:0932ed6:         public AbstractType<?> getType()
1:0932ed6:         {
1:0932ed6:             return type;
1:e94032a:         }
1:e94032a: 
1:e0adc16:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
1:0932ed6:         {
1:e94032a:             if (buffer == null)
1:c6ed2e0:                 return "null";
1:e94032a: 
1:c6ed2e0:             StringBuilder target = new StringBuilder();
1:c6ed2e0:             buffer = buffer.duplicate();
1:c6ed2e0:             target.append('(');
1:c6ed2e0:             boolean first = true;
1:c6ed2e0:             for (int i = 0; i < type.size(); i++)
1:e94032a:             {
1:c6ed2e0:                 // we allow the input to have less fields than declared so as to support field addition.
1:c6ed2e0:                 if (!buffer.hasRemaining())
1:c6ed2e0:                     break;
1:c6ed2e0: 
1:c6ed2e0:                 if (buffer.remaining() < 4)
1:c6ed2e0:                     throw new MarshalException(String.format("Not enough bytes to read size of %dth component", i));
1:c6ed2e0: 
1:c6ed2e0:                 int size = buffer.getInt();
1:c6ed2e0: 
1:c6ed2e0:                 if (first)
1:c6ed2e0:                     first = false;
1:c6ed2e0:                 else
1:c6ed2e0:                     target.append(", ");
1:c6ed2e0: 
1:c6ed2e0:                 // size < 0 means null value
1:c6ed2e0:                 if (size < 0)
1:e94032a:                 {
1:c6ed2e0:                     target.append("null");
1:c6ed2e0:                     continue;
1:e94032a:                 }
1:c6ed2e0: 
1:c6ed2e0:                 if (buffer.remaining() < size)
1:c6ed2e0:                     throw new MarshalException(String.format("Not enough bytes to read %dth component", i));
1:c6ed2e0: 
1:c6ed2e0:                 ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);
1:c6ed2e0:                 target.append(type.type(i).asCQL3Type().toCQLLiteral(field, version));
1:e94032a:             }
1:c6ed2e0:             target.append(')');
1:c6ed2e0:             return target.toString();
1:e94032a:         }
1:e94032a: 
1:0932ed6:         @Override
1:0932ed6:         public final boolean equals(Object o)
1:0932ed6:         {
1:0932ed6:             if(!(o instanceof Tuple))
1:0932ed6:                 return false;
1:e94032a: 
1:0932ed6:             Tuple that = (Tuple)o;
1:0932ed6:             return type.equals(that.type);
1:e94032a:         }
1:e94032a: 
1:0932ed6:         @Override
1:0932ed6:         public final int hashCode()
1:0932ed6:         {
1:0932ed6:             return type.hashCode();
1:e94032a:         }
1:e94032a: 
1:0932ed6:         @Override
1:0932ed6:         public String toString()
1:0932ed6:         {
1:e94032a:             StringBuilder sb = new StringBuilder();
1:340df43:             sb.append("frozen<tuple<");
1:e94032a:             for (int i = 0; i < type.size(); i++)
1:0932ed6:             {
1:e94032a:                 if (i > 0)
1:0932ed6:                     sb.append(", ");
1:0932ed6:                 sb.append(type.type(i).asCQL3Type());
1:e94032a:             }
1:340df43:             sb.append(">>");
1:e94032a:             return sb.toString();
1:0932ed6:         }
1:0932ed6:     }
1:e94032a: 
1:d63d07b:     // For UserTypes, we need to know the current keyspace to resolve the
1:d63d07b:     // actual type used, so Raw is a "not yet prepared" CQL3Type.
1:d63d07b:     public abstract class Raw
1:d63d07b:     {
1:ee55f36:         protected boolean frozen = false;
1:ee55f36: 
1:677230d:         public abstract boolean supportsFreezing();
1:e94032a: 
1:1de8e39:         public boolean isFrozen()
1:d63d07b:         {
1:1de8e39:             return this.frozen;
1:0932ed6:         }
1:02be0de: 
1:1de8e39:         public boolean canBeNonFrozen()
1:a552b30:         {
1:677230d:             return true;
1:0932ed6:         }
1:0932ed6: 
1:ecf05b8:         public boolean isDuration()
1:ecf05b8:         {
1:ecf05b8:             return false;
1:ecf05b8:         }
1:ecf05b8: 
1:d63d07b:         public boolean isCounter()
1:d63d07b:         {
1:0932ed6:             return false;
1:d63d07b:         }
1:0932ed6: 
1:677230d:         public boolean isUDT()
1:d63d07b:         {
1:d63d07b:             return false;
1:d63d07b:         }
1:d63d07b: 
1:794d68b:         public String keyspace()
1:794d68b:         {
1:794d68b:             return null;
1:794d68b:         }
1:794d68b: 
1:ee55f36:         public void freeze() throws InvalidRequestException
1:ee55f36:         {
1:ee55f36:             String message = String.format("frozen<> is only allowed on collections, tuples, and user-defined types (got %s)", this);
1:ee55f36:             throw new InvalidRequestException(message);
1:d63d07b:         }
1:d63d07b: 
1:340df43:         public CQL3Type prepare(String keyspace)
1:ee55f36:         {
1:340df43:             KeyspaceMetadata ksm = Schema.instance.getKSMetaData(keyspace);
1:d63d07b:             if (ksm == null)
1:340df43:                 throw new ConfigurationException(String.format("Keyspace %s doesn't exist", keyspace));
1:340df43:             return prepare(keyspace, ksm.types);
1:a552b30:         }
1:d63d07b: 
1:340df43:         public abstract CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException;
1:d63d07b: 
1:18e2fca:         public CQL3Type prepareInternal(String keyspace, Types udts) throws InvalidRequestException
1:794d68b:         {
1:18e2fca:             return prepare(keyspace, udts);
1:a67f779:         }
1:d63d07b: 
1:340df43:         public boolean referencesUserType(String name)
1:a552b30:         {
1:d63d07b:             return false;
1:a67f779:         }
1:d63d07b: 
1:d63d07b:         public static Raw from(CQL3Type type)
1:a552b30:         {
1:d63d07b:             return new RawType(type);
1:d63d07b:         }
1:d63d07b: 
1:d63d07b:         public static Raw userType(UTName name)
1:d63d07b:         {
1:d63d07b:             return new RawUT(name);
1:d63d07b:         }
1:d63d07b: 
1:ee55f36:         public static Raw map(CQL3Type.Raw t1, CQL3Type.Raw t2)
1:d63d07b:         {
1:d63d07b:             return new RawCollection(CollectionType.Kind.MAP, t1, t2);
1:d63d07b:         }
1:d63d07b: 
1:ee55f36:         public static Raw list(CQL3Type.Raw t)
1:d63d07b:         {
1:d63d07b:             return new RawCollection(CollectionType.Kind.LIST, null, t);
1:d63d07b:         }
1:d63d07b: 
1:ee55f36:         public static Raw set(CQL3Type.Raw t)
1:d63d07b:         {
1:d63d07b:             return new RawCollection(CollectionType.Kind.SET, null, t);
1:0932ed6:         }
1:0932ed6: 
1:ee55f36:         public static Raw tuple(List<CQL3Type.Raw> ts)
1:0932ed6:         {
1:0932ed6:             return new RawTuple(ts);
1:02be0de:         }
1:02be0de: 
1:02be0de:         public static Raw frozen(CQL3Type.Raw t) throws InvalidRequestException
1:02be0de:         {
1:ee55f36:             t.freeze();
1:ee55f36:             return t;
1:ee55f36:         }
1:02be0de: 
1:d63d07b:         private static class RawType extends Raw
1:d63d07b:         {
1:340df43:             private final CQL3Type type;
1:02be0de: 
1:d63d07b:             private RawType(CQL3Type type)
1:d63d07b:             {
1:d63d07b:                 this.type = type;
1:02be0de:             }
1:0932ed6: 
1:340df43:             public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
1:d63d07b:             {
1:d63d07b:                 return type;
1:d63d07b:             }
1:d63d07b: 
1:677230d:             public boolean supportsFreezing()
1:d63d07b:             {
1:a552b30:                 return false;
1:d63d07b:             }
1:d63d07b: 
1:d63d07b:             public boolean isCounter()
1:b72af48:             {
1:d63d07b:                 return type == Native.COUNTER;
1:d63d07b:             }
1:d63d07b: 
1:ecf05b8:             public boolean isDuration()
1:ecf05b8:             {
1:ecf05b8:                 return type == Native.DURATION;
1:ecf05b8:             }
1:ecf05b8: 
1:d63d07b:             @Override
1:d63d07b:             public String toString()
1:d63d07b:             {
1:d63d07b:                 return type.toString();
1:d63d07b:             }
1:d63d07b:         }
1:d63d07b: 
1:d63d07b:         private static class RawCollection extends Raw
1:d63d07b:         {
1:d63d07b:             private final CollectionType.Kind kind;
1:d63d07b:             private final CQL3Type.Raw keys;
1:d63d07b:             private final CQL3Type.Raw values;
1:d63d07b: 
1:d63d07b:             private RawCollection(CollectionType.Kind kind, CQL3Type.Raw keys, CQL3Type.Raw values)
1:d63d07b:             {
1:d63d07b:                 this.kind = kind;
1:d63d07b:                 this.keys = keys;
1:d63d07b:                 this.values = values;
1:d63d07b:             }
1:d63d07b: 
1:ee55f36:             public void freeze() throws InvalidRequestException
1:02be0de:             {
1:ee55f36:                 if (keys != null && keys.supportsFreezing())
1:932b5eb:                     keys.freeze();
1:ee55f36:                 if (values != null && values.supportsFreezing())
1:ee55f36:                     values.freeze();
1:ee55f36:                 frozen = true;
1:ee55f36:             }
1:ee55f36: 
1:677230d:             public boolean supportsFreezing()
1:ee55f36:             {
1:ee55f36:                 return true;
1:02be0de:             }
1:02be0de: 
1:0932ed6:             public boolean isCollection()
1:d63d07b:             {
1:d63d07b:                 return true;
1:d63d07b:             }
1:d63d07b: 
1:340df43:             public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
1:d63d07b:             {
1:18e2fca:                 return prepare(keyspace, udts, false);
1:d63d07b:             }
1:d63d07b: 
1:18e2fca:             public CQL3Type prepareInternal(String keyspace, Types udts)
1:b72af48:             {
1:18e2fca:                 return prepare(keyspace, udts, true);
1:a67f779:             }
1:d63d07b: 
1:18e2fca:             public CQL3Type prepare(String keyspace, Types udts, boolean isInternal) throws InvalidRequestException
1:b72af48:             {
1:ee55f36:                 assert values != null : "Got null values type for a collection";
1:ee55f36: 
1:ee55f36:                 if (!frozen && values.supportsFreezing() && !values.frozen)
1:677230d:                     throwNestedNonFrozenError(values);
1:a552b30: 
1:18e2fca:                 // we represent Thrift supercolumns as maps, internally, and we do allow counters in supercolumns. Thus,
1:18e2fca:                 // for internal type parsing (think schema) we have to make an exception and allow counters as (map) values
1:18e2fca:                 if (values.isCounter() && !isInternal)
1:ee55f36:                     throw new InvalidRequestException("Counters are not allowed inside collections: " + this);
1:ee55f36: 
1:ecf05b8:                 if (values.isDuration() && kind == Kind.SET)
1:ecf05b8:                     throw new InvalidRequestException("Durations are not allowed inside sets: " + this);
1:ecf05b8: 
1:ee55f36:                 if (keys != null)
1:ee55f36:                 {
1:cdf0485:                     if (keys.isCounter())
1:cdf0485:                         throw new InvalidRequestException("Counters are not allowed inside collections: " + this);
1:ecf05b8:                     if (keys.isDuration())
1:ecf05b8:                         throw new InvalidRequestException("Durations are not allowed as map keys: " + this);
1:ee55f36:                     if (!frozen && keys.supportsFreezing() && !keys.frozen)
1:677230d:                         throwNestedNonFrozenError(keys);
1:ee55f36:                 }
1:ee55f36: 
1:677230d:                 AbstractType<?> valueType = values.prepare(keyspace, udts).getType();
1:d63d07b:                 switch (kind)
1:d63d07b:                 {
1:ee55f36:                     case LIST:
1:677230d:                         return new Collection(ListType.getInstance(valueType, !frozen));
1:ee55f36:                     case SET:
1:677230d:                         return new Collection(SetType.getInstance(valueType, !frozen));
1:ee55f36:                     case MAP:
1:ee55f36:                         assert keys != null : "Got null keys type for a collection";
1:677230d:                         return new Collection(MapType.getInstance(keys.prepare(keyspace, udts).getType(), valueType, !frozen));
1:d63d07b:                 }
1:d63d07b:                 throw new AssertionError();
1:d63d07b:             }
1:d63d07b: 
1:677230d:             private void throwNestedNonFrozenError(Raw innerType)
1:677230d:             {
1:677230d:                 if (innerType instanceof RawCollection)
1:677230d:                     throw new InvalidRequestException("Non-frozen collections are not allowed inside collections: " + this);
1:677230d:                 else
1:677230d:                     throw new InvalidRequestException("Non-frozen UDTs are not allowed inside collections: " + this);
1:677230d:             }
1:677230d: 
1:340df43:             public boolean referencesUserType(String name)
1:d63d07b:             {
1:340df43:                 return (keys != null && keys.referencesUserType(name)) || values.referencesUserType(name);
1:d63d07b:             }
1:d63d07b: 
1:d63d07b:             @Override
1:d63d07b:             public String toString()
1:d63d07b:             {
1:ee55f36:                 String start = frozen? "frozen<" : "";
1:ee55f36:                 String end = frozen ? ">" : "";
1:d63d07b:                 switch (kind)
1:a67f779:                 {
1:e94032a:                     case LIST: return start + "list<" + values + '>' + end;
1:e94032a:                     case SET:  return start + "set<" + values + '>' + end;
1:e94032a:                     case MAP:  return start + "map<" + keys + ", " + values + '>' + end;
1:d63d07b:                 }
1:d63d07b:                 throw new AssertionError();
1:a67f779:             }
1:a67f779:         }
1:b72af48: 
1:d63d07b:         private static class RawUT extends Raw
1:d63d07b:         {
1:d63d07b:             private final UTName name;
1:d63d07b: 
1:d63d07b:             private RawUT(UTName name)
1:d63d07b:             {
1:d63d07b:                 this.name = name;
1:d63d07b:             }
1:d63d07b: 
1:794d68b:             public String keyspace()
1:d63d07b:             {
1:794d68b:                 return name.getKeyspace();
1:794d68b:             }
1:794d68b: 
1:ee55f36:             public void freeze()
1:ee55f36:             {
1:ee55f36:                 frozen = true;
1:ee55f36:             }
1:ee55f36: 
1:1de8e39:             public boolean canBeNonFrozen()
1:a67f779:             {
1:d63d07b:                 return true;
1:986893e:             }
1:b72af48: 
1:340df43:             public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
1:a67f779:             {
1:c045690:                 if (name.hasKeyspace())
1:a67f779:                 {
1:c045690:                     // The provided keyspace is the one of the current statement this is part of. If it's different from the keyspace of
1:c045690:                     // the UTName, we reject since we want to limit user types to their own keyspace (see #6643)
1:c045690:                     if (!keyspace.equals(name.getKeyspace()))
1:c045690:                         throw new InvalidRequestException(String.format("Statement on keyspace %s cannot refer to a user type in keyspace %s; "
1:c045690:                                                                         + "user types can only be used in the keyspace they are defined in",
1:c045690:                                                                         keyspace, name.getKeyspace()));
1:c045690:                 }
1:e94032a:                 else
1:c045690:                 {
1:c045690:                     name.setKeyspace(keyspace);
1:c045690:                 }
1:d63d07b: 
1:340df43:                 UserType type = udts.getNullable(name.getUserTypeName());
1:d63d07b:                 if (type == null)
1:d63d07b:                     throw new InvalidRequestException("Unknown type " + name);
1:02be0de: 
1:cc90d04:                 if (frozen)
1:677230d:                     type = type.freeze();
1:d63d07b:                 return new UserDefined(name.toString(), type);
1:d63d07b:             }
1:d63d07b: 
1:340df43:             public boolean referencesUserType(String name)
1:02be0de:             {
1:340df43:                 return this.name.getStringTypeName().equals(name);
1:677230d:             }
1:677230d: 
1:677230d:             public boolean supportsFreezing()
1:677230d:             {
1:677230d:                 return true;
1:d63d07b:             }
1:d63d07b: 
1:677230d:             public boolean isUDT()
1:a552b30:             {
1:02be0de:                 return true;
1:a552b30:             }
1:a552b30: 
1:d63d07b:             @Override
1:d63d07b:             public String toString()
1:a552b30:             {
1:677230d:                 if (frozen)
1:cc90d04:                     return "frozen<" + name.toString() + '>';
1:cc90d04:                 else
1:cc90d04:                     return name.toString();
1:c045690:             }
1:d63d07b:         }
1:a552b30: 
1:0932ed6:         private static class RawTuple extends Raw
1:a67f779:         {
1:0932ed6:             private final List<CQL3Type.Raw> types;
1:0932ed6: 
1:0932ed6:             private RawTuple(List<CQL3Type.Raw> types)
1:0932ed6:             {
1:0932ed6:                 this.types = types;
1:0932ed6:             }
1:0932ed6: 
1:677230d:             public boolean supportsFreezing()
1:0932ed6:             {
1:a552b30:                 return true;
1:0932ed6:             }
1:0932ed6: 
1:ee55f36:             public void freeze() throws InvalidRequestException
1:0932ed6:             {
1:ee55f36:                 for (CQL3Type.Raw t : types)
1:ee55f36:                     if (t.supportsFreezing())
1:ee55f36:                         t.freeze();
1:ee55f36: 
1:ee55f36:                 frozen = true;
1:ee55f36:             }
1:02be0de: 
1:340df43:             public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
1:986893e:             {
1:ee55f36:                 if (!frozen)
1:ee55f36:                     freeze();
1:ee55f36: 
1:0932ed6:                 List<AbstractType<?>> ts = new ArrayList<>(types.size());
1:02be0de:                 for (CQL3Type.Raw t : types)
1:ee55f36:                 {
1:ee55f36:                     if (t.isCounter())
1:ee55f36:                         throw new InvalidRequestException("Counters are not allowed inside tuples");
1:ee55f36: 
1:340df43:                     ts.add(t.prepare(keyspace, udts).getType());
1:ee55f36:                 }
1:0932ed6:                 return new Tuple(new TupleType(ts));
1:02be0de:             }
1:02be0de: 
1:340df43:             public boolean referencesUserType(String name)
1:0932ed6:             {
1:340df43:                 return types.stream().anyMatch(t -> t.referencesUserType(name));
1:0932ed6:             }
1:02be0de: 
1:0932ed6:             @Override
1:0932ed6:             public String toString()
1:d63d07b:             {
1:0932ed6:                 StringBuilder sb = new StringBuilder();
1:0932ed6:                 sb.append("tuple<");
1:0932ed6:                 for (int i = 0; i < types.size(); i++)
1:0932ed6:                 {
1:0932ed6:                     if (i > 0)
1:0932ed6:                         sb.append(", ");
1:0932ed6:                     sb.append(types.get(i));
1:0932ed6:                 }
1:e94032a:                 sb.append('>');
1:0932ed6:                 return sb.toString();
1:0932ed6:             }
1:0932ed6:         }
1:d63d07b:     }
1:a552b30: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:      *  @param buffer the value to convert to a CQL literal. This value must be
1:     public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version);
/////////////////////////////////////////////////////////////////////////
1:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:         private void generateMapCQLLiteral(ByteBuffer buffer, ProtocolVersion version, StringBuilder target, int size)
/////////////////////////////////////////////////////////////////////////
1:         private static void generateSetOrListCQLLiteral(ByteBuffer buffer, ProtocolVersion version, StringBuilder target, int size, CQL3Type elements)
/////////////////////////////////////////////////////////////////////////
1:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:         public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:ecf05b8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.CollectionType.Kind;
/////////////////////////////////////////////////////////////////////////
1:         DURATION    (DurationType.instance),
/////////////////////////////////////////////////////////////////////////
1:         public boolean isDuration()
1:         {
1:             return false;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             public boolean isDuration()
1:             {
1:                 return type == Native.DURATION;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (values.isDuration() && kind == Kind.SET)
1:                     throw new InvalidRequestException("Durations are not allowed inside sets: " + this);
1: 
1:                     if (keys.isDuration())
1:                         throw new InvalidRequestException("Durations are not allowed as map keys: " + this);
commit:35a945e
/////////////////////////////////////////////////////////////////////////
1:         SMALLINT    (ShortType.instance),
1:         TINYINT     (ByteType.instance),
author:Alex Petrov
-------------------------------------------------------------------------------
commit:cc90d04
/////////////////////////////////////////////////////////////////////////
1:                 if (frozen)
1:                     return "frozen<" + name.toString() + '>';
1:                 else
1:                     return name.toString();
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:677230d
/////////////////////////////////////////////////////////////////////////
1:     default boolean isCollection()
1:     {
1:         return false;
1:     }
1: 
1:     default boolean isUDT()
1:     {
1:         return false;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public boolean isUDT()
1:             return true;
/////////////////////////////////////////////////////////////////////////
1:             if (type.isMultiCell())
1:                 return ColumnIdentifier.maybeQuote(name);
1:             else
1:                 return "frozen<" + ColumnIdentifier.maybeQuote(name) + '>';
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public abstract boolean supportsFreezing();
/////////////////////////////////////////////////////////////////////////
1:         public boolean isUDT()
1:         {
1:             return false;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             public boolean supportsFreezing()
/////////////////////////////////////////////////////////////////////////
1:             public boolean supportsFreezing()
/////////////////////////////////////////////////////////////////////////
1:                     throwNestedNonFrozenError(values);
/////////////////////////////////////////////////////////////////////////
1:                         throwNestedNonFrozenError(keys);
1:                 AbstractType<?> valueType = values.prepare(keyspace, udts).getType();
1:                         return new Collection(ListType.getInstance(valueType, !frozen));
1:                         return new Collection(SetType.getInstance(valueType, !frozen));
1:                         return new Collection(MapType.getInstance(keys.prepare(keyspace, udts).getType(), valueType, !frozen));
1:             private void throwNestedNonFrozenError(Raw innerType)
1:             {
1:                 if (innerType instanceof RawCollection)
1:                     throw new InvalidRequestException("Non-frozen collections are not allowed inside collections: " + this);
1:                 else
1:                     throw new InvalidRequestException("Non-frozen UDTs are not allowed inside collections: " + this);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 return true;
/////////////////////////////////////////////////////////////////////////
1:                 if (frozen)
1:                     type = type.freeze();
/////////////////////////////////////////////////////////////////////////
1:             public boolean supportsFreezing()
1:             {
1:                 return true;
1:             }
1: 
1:             public boolean isUDT()
/////////////////////////////////////////////////////////////////////////
1:             public boolean supportsFreezing()
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     static final Logger logger = LoggerFactory.getLogger(CQL3Type.class);
1: 
/////////////////////////////////////////////////////////////////////////
1:             boolean isFrozen = !this.type.isMultiCell();
1:             StringBuilder sb = new StringBuilder(isFrozen ? "frozen<" : "");
1:                     AbstractType<?> listType = ((ListType)type).getElementsType();
1:                     sb.append("list<").append(listType.asCQL3Type());
1:                     break;
1:                     AbstractType<?> setType = ((SetType)type).getElementsType();
1:                     sb.append("set<").append(setType.asCQL3Type());
1:                     break;
1:                     AbstractType<?> keysType = ((MapType)type).getKeysType();
1:                     AbstractType<?> valuesType = ((MapType)type).getValuesType();
1:                     sb.append("map<").append(keysType.asCQL3Type()).append(", ").append(valuesType.asCQL3Type());
1:                     break;
1:                 default:
1:                     throw new AssertionError();
0:             sb.append(">");
1:             if (isFrozen)
0:                 sb.append(">");
1:             return sb.toString();
/////////////////////////////////////////////////////////////////////////
1:         protected boolean frozen = false;
1: 
0:         protected abstract boolean supportsFreezing();
/////////////////////////////////////////////////////////////////////////
1:         public void freeze() throws InvalidRequestException
1:             String message = String.format("frozen<> is only allowed on collections, tuples, and user-defined types (got %s)", this);
1:             throw new InvalidRequestException(message);
/////////////////////////////////////////////////////////////////////////
1:         public static Raw map(CQL3Type.Raw t1, CQL3Type.Raw t2)
1:         public static Raw list(CQL3Type.Raw t)
1:         public static Raw set(CQL3Type.Raw t)
1:         public static Raw tuple(List<CQL3Type.Raw> ts)
1:             t.freeze();
1:             return t;
/////////////////////////////////////////////////////////////////////////
0:             protected boolean supportsFreezing()
1:             {
1:                 return false;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:             public void freeze() throws InvalidRequestException
1:                 if (keys != null && keys.supportsFreezing())
1:                 if (values != null && values.supportsFreezing())
1:                     values.freeze();
1:                 frozen = true;
1:             }
1: 
0:             protected boolean supportsFreezing()
1:             {
1:                 return true;
/////////////////////////////////////////////////////////////////////////
1:                 assert values != null : "Got null values type for a collection";
1: 
1:                 if (!frozen && values.supportsFreezing() && !values.frozen)
0:                     throw new InvalidRequestException("Non-frozen collections are not allowed inside collections: " + this);
0:                 if (values.isCounter())
1:                     throw new InvalidRequestException("Counters are not allowed inside collections: " + this);
1: 
1:                 if (keys != null)
1:                 {
1:                     if (!frozen && keys.supportsFreezing() && !keys.frozen)
0:                         throw new InvalidRequestException("Non-frozen collections are not allowed inside collections: " + this);
1:                 }
1: 
1:                     case LIST:
0:                         return new Collection(ListType.getInstance(values.prepare(keyspace).getType(), !frozen));
1:                     case SET:
0:                         return new Collection(SetType.getInstance(values.prepare(keyspace).getType(), !frozen));
1:                     case MAP:
1:                         assert keys != null : "Got null keys type for a collection";
0:                         return new Collection(MapType.getInstance(keys.prepare(keyspace).getType(), values.prepare(keyspace).getType(), !frozen));
/////////////////////////////////////////////////////////////////////////
1:                 String start = frozen? "frozen<" : "";
1:                 String end = frozen ? ">" : "";
0:                     case LIST: return start + "list<" + values + ">" + end;
0:                     case SET:  return start + "set<" + values + ">" + end;
0:                     case MAP:  return start + "map<" + keys + ", " + values + ">" + end;
/////////////////////////////////////////////////////////////////////////
1:             public void freeze()
1:             {
1:                 frozen = true;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:             protected boolean supportsFreezing()
/////////////////////////////////////////////////////////////////////////
0:             protected boolean supportsFreezing()
1:                 return true;
/////////////////////////////////////////////////////////////////////////
1:             public void freeze() throws InvalidRequestException
1:             {
1:                 for (CQL3Type.Raw t : types)
1:                 {
1:                     if (t.supportsFreezing())
1:                         t.freeze();
1:                 }
1:                 frozen = true;
1:             }
1: 
1:                 if (!frozen)
1:                     freeze();
1: 
1:                 {
1:                     if (t.isCounter())
1:                         throw new InvalidRequestException("Counters are not allowed inside tuples");
1: 
1:                 }
author:Robert Stupp
-------------------------------------------------------------------------------
commit:6237022
commit:c6ed2e0
/////////////////////////////////////////////////////////////////////////
1:      * Generates CQL literal from a binary value of this type.
1:      *
0:      * @param buffer the value to convert to a CQL literal. This value must be
1:      * serialized with {@code version} of the native protocol.
1:      * @param version the native protocol version in which {@code buffer} is encoded.
0:     public String toCQLLiteral(ByteBuffer buffer, int version);
/////////////////////////////////////////////////////////////////////////
1:          * {@link org.apache.cassandra.serializers.TypeSerializer#toCQLLiteral(ByteBuffer)}
0:         public String toCQLLiteral(ByteBuffer buffer, int version)
1:             return type.getSerializer().toCQLLiteral(buffer);
/////////////////////////////////////////////////////////////////////////
0:         public String toCQLLiteral(ByteBuffer buffer, int version)
1:             // *always* use the 'blob' syntax to express custom types in CQL
1:             return Native.BLOB.toCQLLiteral(buffer, version);
/////////////////////////////////////////////////////////////////////////
0:         public String toCQLLiteral(ByteBuffer buffer, int version)
1:             if (buffer == null)
1:                 return "null";
1:             StringBuilder target = new StringBuilder();
1:             buffer = buffer.duplicate();
1:             int size = CollectionSerializer.readCollectionSize(buffer, version);
1: 
1:             switch (type.kind)
1:             {
1:                 case LIST:
1:                     CQL3Type elements = ((ListType) type).getElementsType().asCQL3Type();
1:                     target.append('[');
1:                     generateSetOrListCQLLiteral(buffer, version, target, size, elements);
1:                     target.append(']');
1:                     break;
1:                 case SET:
1:                     elements = ((SetType) type).getElementsType().asCQL3Type();
1:                     target.append('{');
1:                     generateSetOrListCQLLiteral(buffer, version, target, size, elements);
1:                     target.append('}');
1:                     break;
1:                 case MAP:
1:                     target.append('{');
1:                     generateMapCQLLiteral(buffer, version, target, size);
1:                     target.append('}');
1:                     break;
1:             return target.toString();
/////////////////////////////////////////////////////////////////////////
1:                 target.append(keys.toCQLLiteral(element, version));
1:                 target.append(values.toCQLLiteral(element, version));
/////////////////////////////////////////////////////////////////////////
1:                 target.append(elements.toCQLLiteral(element, version));
/////////////////////////////////////////////////////////////////////////
0:         public String toCQLLiteral(ByteBuffer buffer, int version)
1:                 return "null";
1: 
1: 
1:             StringBuilder target = new StringBuilder();
1:             buffer = buffer.duplicate();
1:             target.append('{');
1:             for (int i = 0; i < type.size(); i++)
1:                 // we allow the input to have less fields than declared so as to support field addition.
1:                 if (!buffer.hasRemaining())
1:                     break;
1: 
1:                 if (buffer.remaining() < 4)
1:                     throw new MarshalException(String.format("Not enough bytes to read size of %dth field %s", i, type.fieldName(i)));
1: 
1:                 int size = buffer.getInt();
1: 
1:                 if (i > 0)
1:                     target.append(", ");
1: 
1:                 target.append(ColumnIdentifier.maybeQuote(type.fieldNameAsString(i)));
1:                 target.append(": ");
1: 
1:                 // size < 0 means null value
1:                 if (size < 0)
1:                     target.append("null");
1:                     continue;
1: 
1:                 if (buffer.remaining() < size)
1:                     throw new MarshalException(String.format("Not enough bytes to read %dth field %s", i, type.fieldName(i)));
1: 
1:                 ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);
1:                 target.append(type.fieldType(i).asCQL3Type().toCQLLiteral(field, version));
1:             target.append('}');
1:             return target.toString();
/////////////////////////////////////////////////////////////////////////
0:         public String toCQLLiteral(ByteBuffer buffer, int version)
1:                 return "null";
1: 
1:             StringBuilder target = new StringBuilder();
1:             buffer = buffer.duplicate();
1:             target.append('(');
1:             boolean first = true;
1:             for (int i = 0; i < type.size(); i++)
1:                 // we allow the input to have less fields than declared so as to support field addition.
1:                 if (!buffer.hasRemaining())
1:                     break;
1: 
1:                 if (buffer.remaining() < 4)
1:                     throw new MarshalException(String.format("Not enough bytes to read size of %dth component", i));
1: 
1:                 int size = buffer.getInt();
1: 
1:                 if (first)
1:                     first = false;
1:                 else
1:                     target.append(", ");
1: 
1:                 // size < 0 means null value
1:                 if (size < 0)
1:                     target.append("null");
1:                     continue;
1: 
1:                 if (buffer.remaining() < size)
1:                     throw new MarshalException(String.format("Not enough bytes to read %dth component", i));
1: 
1:                 ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);
1:                 target.append(type.type(i).asCQL3Type().toCQLLiteral(field, version));
1:             target.append(')');
1:             return target.toString();
commit:0f5e780
/////////////////////////////////////////////////////////////////////////
commit:e94032a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.CollectionSerializer;
1: import org.apache.cassandra.serializers.MarshalException;
1: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Generate CQL literal from this type's serialized representation using the specified protocol version.
0:      * Convinience method for {@link #toCQLLiteral(ByteBuffer, int, StringBuilder)} that just returns a {@code String}.
1:      */
0:     public default String asCQLLiteral(ByteBuffer buffer, int version)
1:     {
1:         StringBuilder sb = new StringBuilder();
0:         toCQLLiteral(buffer, version, sb);
1:         return sb.toString();
1:     }
1: 
1:     /**
0:      * Generate CQL literal from this type's serialized representation using the specified protocol version.
0:      * Some work is delegated to {@link org.apache.cassandra.serializers.TypeSerializer#toCQLLiteral(ByteBuffer, StringBuilder)}.
1:      */
0:     public void toCQLLiteral(ByteBuffer buffer, int version, StringBuilder target);
1: 
/////////////////////////////////////////////////////////////////////////
0:         /**
1:          * Delegate to
0:          * {@link org.apache.cassandra.serializers.TypeSerializer#toCQLLiteral(ByteBuffer, StringBuilder)}
1:          * for native types as most CQL literal representations work fine with the default
1:          * {@link org.apache.cassandra.serializers.TypeSerializer#toString(Object)}
1:          * {@link org.apache.cassandra.serializers.TypeSerializer#deserialize(ByteBuffer)} implementations.
1:          */
0:         public void toCQLLiteral(ByteBuffer buffer, int version, StringBuilder target)
1:         {
0:             type.getSerializer().toCQLLiteral(buffer, target);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         public void toCQLLiteral(ByteBuffer buffer, int version, StringBuilder target)
1:         {
1:             if (buffer == null)
0:                 target.append("null");
1:             else
0:                 target.append(type.getString(buffer));
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             return "'" + type + '\'';
/////////////////////////////////////////////////////////////////////////
0:         public void toCQLLiteral(ByteBuffer buffer, int version, StringBuilder target)
1:         {
0:             // Not sure whether the !buffer.hasRemaining() check is correct here or whether an empty
0:             // BB should be returned as "[]" resp "{}" or whether it is not valid at all.
0:             //
0:             // Currently, all empty collections return '[]' or '{}'. Except frozen collections with
0:             // a null BB return 'null'.
0:             //
0:             if (buffer == null || !buffer.hasRemaining())
1:             {
0:                 if (buffer == null && type.isFrozenCollection())
1:                 {
0:                     target.append("null");
1:                 }
0:                 else
1:                 {
1:                     switch (type.kind)
1:                     {
1:                         case LIST:
0:                             target.append("[]");
0:                             break;
1:                         case SET:
1:                         case MAP:
0:                             target.append("{}");
0:                             break;
1:                     }
1:                 }
1:             }
0:             else
1:             {
0:                 int size = CollectionSerializer.readCollectionSize(buffer, version);
1: 
1:                 switch (type.kind)
1:                 {
1:                     case LIST:
0:                         CQL3Type elements = ((ListType) type).getElementsType().asCQL3Type();
0:                         target.append('[');
0:                         generateSetOrListCQLLiteral(buffer, version, target, size, elements);
0:                         target.append(']');
0:                         break;
1:                     case SET:
0:                         elements = ((SetType) type).getElementsType().asCQL3Type();
0:                         target.append('{');
0:                         generateSetOrListCQLLiteral(buffer, version, target, size, elements);
0:                         target.append('}');
0:                         break;
1:                     case MAP:
0:                         target.append('{');
0:                         generateMapCQLLiteral(buffer, version, target, size);
0:                         target.append('}');
0:                         break;
1:                 }
1:             }
1:         }
1: 
0:         private void generateMapCQLLiteral(ByteBuffer buffer, int version, StringBuilder target, int size)
1:         {
1:             CQL3Type keys = ((MapType) type).getKeysType().asCQL3Type();
1:             CQL3Type values = ((MapType) type).getValuesType().asCQL3Type();
1:             for (int i = 0; i < size; i++)
1:             {
1:                 if (i > 0)
1:                     target.append(", ");
1:                 ByteBuffer element = CollectionSerializer.readValue(buffer, version);
0:                 keys.toCQLLiteral(element, version, target);
1:                 target.append(": ");
1:                 element = CollectionSerializer.readValue(buffer, version);
0:                 values.toCQLLiteral(element, version, target);
1:             }
1:         }
1: 
0:         private static void generateSetOrListCQLLiteral(ByteBuffer buffer, int version, StringBuilder target, int size, CQL3Type elements)
1:         {
1:             for (int i = 0; i < size; i++)
1:             {
1:                 if (i > 0)
1:                     target.append(", ");
1:                 ByteBuffer element = CollectionSerializer.readValue(buffer, version);
0:                 elements.toCQLLiteral(element, version, target);
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             sb.append('>');
1:                 sb.append('>');
/////////////////////////////////////////////////////////////////////////
0:         public void toCQLLiteral(ByteBuffer buffer, int version, StringBuilder target)
1:         {
1:             if (buffer == null)
1:             {
0:                 target.append("null");
1:             }
0:             else
1:             {
0:                 target.append('{');
1:                 for (int i = 0; i < type.size(); i++)
1:                 {
0:                     // we allow the input to have less fields than declared so as to support field addition.
0:                     if (!buffer.hasRemaining())
0:                         break;
1: 
0:                     if (buffer.remaining() < 4)
0:                         throw new MarshalException(String.format("Not enough bytes to read size of %dth field %s", i, type.fieldName(i)));
1: 
0:                     int size = buffer.getInt();
1: 
1:                     if (i > 0)
0:                         target.append(", ");
1: 
0:                     target.append(ColumnIdentifier.maybeQuote(type.fieldNameAsString(i)));
0:                     target.append(": ");
1: 
0:                     // size < 0 means null value
0:                     if (size < 0)
1:                     {
0:                         target.append("null");
0:                         continue;
1:                     }
1: 
0:                     if (buffer.remaining() < size)
0:                         throw new MarshalException(String.format("Not enough bytes to read %dth field %s", i, type.fieldName(i)));
1: 
0:                     ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);
0:                     type.fieldType(i).asCQL3Type().toCQLLiteral(field, version, target);
1:                 }
0:                 target.append('}');
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         public void toCQLLiteral(ByteBuffer buffer, int version, StringBuilder target)
1:         {
0:             if (buffer == null)
1:             {
0:                 target.append("null");
1:             }
0:             else
1:             {
0:                 target.append('(');
0:                 boolean first = true;
0:                 for (int i = 0; i < type.size(); i++)
1:                 {
0:                     // we allow the input to have less fields than declared so as to support field addition.
0:                     if (!buffer.hasRemaining())
0:                         break;
1: 
0:                     if (buffer.remaining() < 4)
0:                         throw new MarshalException(String.format("Not enough bytes to read size of %dth component", i));
1: 
0:                     int size = buffer.getInt();
1: 
0:                     if (first)
0:                         first = false;
0:                     else
0:                         target.append(", ");
1: 
0:                     // size < 0 means null value
0:                     if (size < 0)
1:                     {
0:                         target.append("null");
0:                         continue;
1:                     }
1: 
0:                     if (buffer.remaining() < size)
0:                         throw new MarshalException(String.format("Not enough bytes to read %dth component", i));
1: 
0:                     ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);
0:                     type.type(i).asCQL3Type().toCQLLiteral(field, version, target);
1:                 }
0:                 target.append(')');
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     case LIST: return start + "list<" + values + '>' + end;
1:                     case SET:  return start + "set<" + values + '>' + end;
1:                     case MAP:  return start + "map<" + keys + ", " + values + '>' + end;
/////////////////////////////////////////////////////////////////////////
1:                 sb.append('>');
commit:6eea3ea
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SystemKeyspace;
/////////////////////////////////////////////////////////////////////////
0:                     if (keyspace != null && !SystemKeyspace.NAME.equals(name.getKeyspace()) && !keyspace.equals(name.getKeyspace()))
commit:794d68b
/////////////////////////////////////////////////////////////////////////
1:         public String keyspace()
1:         {
1:             return null;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             public String keyspace()
1:             {
1:                 return name.getKeyspace();
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:                     if (keyspace != null && !keyspace.equals(name.getKeyspace()))
commit:932b5eb
/////////////////////////////////////////////////////////////////////////
0:                 if (ts.get(i) != null && ts.get(i).isCounter())
/////////////////////////////////////////////////////////////////////////
0:                 if (keys != null)
1:                     keys.freeze();
/////////////////////////////////////////////////////////////////////////
0:                     if (t != null)
0:                         t.freeze();
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:64a3bfd
commit:8bfdd65
commit:cf76ac6
/////////////////////////////////////////////////////////////////////////
0:                 if (keys != null)
0:                     keys.freeze();
commit:02be0de
/////////////////////////////////////////////////////////////////////////
0:         protected boolean frozen;
1: 
/////////////////////////////////////////////////////////////////////////
0:         public Raw freeze()
1:         {
0:             frozen = true;
0:             return this;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         public static Raw frozen(CQL3Type.Raw t) throws InvalidRequestException
1:         {
0:             if (t instanceof RawUT)
0:                 return ((RawUT)t).freeze();
0:             if (t instanceof RawTuple)
0:                 return ((RawTuple)t).freeze();
1: 
0:             throw new InvalidRequestException("frozen<> is only currently only allowed on User-Defined and tuple types");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:             public Raw freeze()
1:             {
0:                 keys.freeze();
0:                 values.freeze();
0:                 return super.freeze();
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 if (!frozen)
0:                     throw new InvalidRequestException("Non-frozen User-Defined types are not supported, please use frozen<>");
1: 
0:             public boolean isUDT()
1:             {
1:                 return true;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:             public Raw freeze()
1:             {
1:                 for (CQL3Type.Raw t : types)
0:                     t.freeze();
0:                 return super.freeze();
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:                 if (!frozen)
0:                     throw new InvalidRequestException("Non-frozen tuples are not supported, please use frozen<>");
1: 
commit:0932ed6
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static class Tuple implements CQL3Type
1:     {
1:         private final TupleType type;
1: 
1:         private Tuple(TupleType type)
1:         {
1:             this.type = type;
1:         }
1: 
1:         public static Tuple create(TupleType type)
1:         {
1:             return new Tuple(type);
1:         }
1: 
1:         public boolean isCollection()
1:         {
1:             return false;
1:         }
1: 
1:         public AbstractType<?> getType()
1:         {
1:             return type;
1:         }
1: 
1:         @Override
1:         public final boolean equals(Object o)
1:         {
1:             if(!(o instanceof Tuple))
1:                 return false;
1: 
1:             Tuple that = (Tuple)o;
1:             return type.equals(that.type);
1:         }
1: 
1:         @Override
1:         public final int hashCode()
1:         {
1:             return type.hashCode();
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             StringBuilder sb = new StringBuilder();
1:             sb.append("tuple<");
0:             for (int i = 0; i < type.size(); i++)
1:             {
1:                 if (i > 0)
1:                     sb.append(", ");
1:                 sb.append(type.type(i).asCQL3Type());
1:             }
0:             sb.append(">");
1:             return sb.toString();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         public static Raw tuple(List<CQL3Type.Raw> ts) throws InvalidRequestException
1:         {
0:             for (int i = 0; i < ts.size(); i++)
0:                 if (ts.get(i).isCounter())
0:                     throw new InvalidRequestException("counters are not allowed inside tuples");
1: 
1:             return new RawTuple(ts);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         private static class RawTuple extends Raw
1:         {
1:             private final List<CQL3Type.Raw> types;
1: 
1:             private RawTuple(List<CQL3Type.Raw> types)
1:             {
1:                 this.types = types;
1:             }
1: 
1:             public boolean isCollection()
1:             {
1:                 return false;
1:             }
1: 
0:             public CQL3Type prepare(String keyspace) throws InvalidRequestException
1:             {
1:                 List<AbstractType<?>> ts = new ArrayList<>(types.size());
0:                 for (CQL3Type.Raw t : types)
0:                     ts.add(t.prepare(keyspace).getType());
1:                 return new Tuple(new TupleType(ts));
1:             }
1: 
1:             @Override
1:             public String toString()
1:             {
0:                 StringBuilder sb = new StringBuilder();
0:                 sb.append("tuple<");
1:                 for (int i = 0; i < types.size(); i++)
1:                 {
0:                     if (i > 0)
1:                         sb.append(", ");
1:                     sb.append(types.get(i));
1:                 }
0:                 sb.append(">");
0:                 return sb.toString();
1:             }
1:         }
commit:c045690
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (name.hasKeyspace())
1:                 {
1:                     // The provided keyspace is the one of the current statement this is part of. If it's different from the keyspace of
1:                     // the UTName, we reject since we want to limit user types to their own keyspace (see #6643)
1:                     if (!keyspace.equals(name.getKeyspace()))
1:                         throw new InvalidRequestException(String.format("Statement on keyspace %s cannot refer to a user type in keyspace %s; "
1:                                                                         + "user types can only be used in the keyspace they are defined in",
1:                                                                         keyspace, name.getKeyspace()));
1:                 }
0:                 else
1:                 {
1:                     name.setKeyspace(keyspace);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         }
commit:d63d07b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.KSMetaData;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         private final CollectionType type;
0:         public boolean isCollection()
1:             return true;
/////////////////////////////////////////////////////////////////////////
1:         private final String name;
1:         private final UserType type;
1:         private UserDefined(String name, UserType type)
1:         public static UserDefined create(UserType type)
1:             return new UserDefined(UTF8Type.instance.compose(type.name), type);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             return name;
1: 
1:     // For UserTypes, we need to know the current keyspace to resolve the
1:     // actual type used, so Raw is a "not yet prepared" CQL3Type.
1:     public abstract class Raw
1:     {
0:         public boolean isCollection()
1:         {
1:             return false;
1:         }
1: 
1:         public boolean isCounter()
1:         {
1:             return false;
1:         }
1: 
0:         public abstract CQL3Type prepare(String keyspace) throws InvalidRequestException;
1: 
1:         public static Raw from(CQL3Type type)
1:         {
1:             return new RawType(type);
1:         }
1: 
1:         public static Raw userType(UTName name)
1:         {
1:             return new RawUT(name);
1:         }
1: 
0:         public static Raw map(CQL3Type.Raw t1, CQL3Type.Raw t2) throws InvalidRequestException
1:         {
0:             if (t1.isCollection() || t2.isCollection())
0:                 throw new InvalidRequestException("map type cannot contain another collection");
0:             if (t1.isCounter() || t2.isCounter())
0:                 throw new InvalidRequestException("counters are not allowed inside a collection");
1: 
1:             return new RawCollection(CollectionType.Kind.MAP, t1, t2);
1:         }
1: 
0:         public static Raw list(CQL3Type.Raw t) throws InvalidRequestException
1:         {
0:             if (t.isCollection())
0:                 throw new InvalidRequestException("list type cannot contain another collection");
0:             if (t.isCounter())
0:                 throw new InvalidRequestException("counters are not allowed inside a collection");
1: 
1:             return new RawCollection(CollectionType.Kind.LIST, null, t);
1:         }
1: 
0:         public static Raw set(CQL3Type.Raw t) throws InvalidRequestException
1:         {
0:             if (t.isCollection())
0:                 throw new InvalidRequestException("set type cannot contain another collection");
0:             if (t.isCounter())
0:                 throw new InvalidRequestException("counters are not allowed inside a collection");
1: 
1:             return new RawCollection(CollectionType.Kind.SET, null, t);
1:         }
1: 
1:         private static class RawType extends Raw
1:         {
0:             private CQL3Type type;
1: 
1:             private RawType(CQL3Type type)
1:             {
1:                 this.type = type;
1:             }
1: 
0:             public CQL3Type prepare(String keyspace) throws InvalidRequestException
1:             {
1:                 return type;
1:             }
1: 
1:             public boolean isCounter()
1:             {
1:                 return type == Native.COUNTER;
1:             }
1: 
1:             @Override
1:             public String toString()
1:             {
1:                 return type.toString();
1:             }
1:         }
1: 
1:         private static class RawCollection extends Raw
1:         {
1:             private final CollectionType.Kind kind;
1:             private final CQL3Type.Raw keys;
1:             private final CQL3Type.Raw values;
1: 
1:             private RawCollection(CollectionType.Kind kind, CQL3Type.Raw keys, CQL3Type.Raw values)
1:             {
1:                 this.kind = kind;
1:                 this.keys = keys;
1:                 this.values = values;
1:             }
1: 
0:             public boolean isCollection()
1:             {
1:                 return true;
1:             }
1: 
0:             public CQL3Type prepare(String keyspace) throws InvalidRequestException
1:             {
1:                 switch (kind)
1:                 {
0:                     case LIST: return new Collection(ListType.getInstance(values.prepare(keyspace).getType()));
0:                     case SET:  return new Collection(SetType.getInstance(values.prepare(keyspace).getType()));
0:                     case MAP:  return new Collection(MapType.getInstance(keys.prepare(keyspace).getType(), values.prepare(keyspace).getType()));
1:                 }
1:                 throw new AssertionError();
1:             }
1: 
1:             @Override
1:             public String toString()
1:             {
1:                 switch (kind)
1:                 {
0:                     case LIST: return "list<" + values + ">";
0:                     case SET:  return "set<" + values + ">";
0:                     case MAP:  return "map<" + keys + ", " + values + ">";
1:                 }
1:                 throw new AssertionError();
1:             }
1:         }
1: 
1:         private static class RawUT extends Raw
1:         {
1: 
1:             private final UTName name;
1: 
1:             private RawUT(UTName name)
1:             {
1:                 this.name = name;
1:             }
1: 
0:             public CQL3Type prepare(String keyspace) throws InvalidRequestException
1:             {
0:                 name.setKeyspace(keyspace);
1: 
0:                 KSMetaData ksm = Schema.instance.getKSMetaData(name.getKeyspace());
1:                 if (ksm == null)
0:                     throw new InvalidRequestException("Unknown keyspace " + name.getKeyspace());
0:                 UserType type = ksm.userTypes.getType(name.getUserTypeName());
1:                 if (type == null)
1:                     throw new InvalidRequestException("Unknown type " + name);
1: 
1:                 return new UserDefined(name.toString(), type);
1:             }
1: 
1:             @Override
1:             public String toString()
1:             {
0:                 return name.toString();
1:             }
1:     }
1:     }
commit:a552b30
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
1: 
1: import org.apache.cassandra.config.Schema;
/////////////////////////////////////////////////////////////////////////
0:     public boolean isUserType();
/////////////////////////////////////////////////////////////////////////
0:         public boolean isUserType()
1:         {
1:             return false;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         public boolean isUserType()
1:         {
0:             return false;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         public boolean isUserType()
1:         {
0:             return false;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static class UserDefined implements CQL3Type
1:     {
1:         // Keeping this separatly from type just to simplify toString()
0:         ColumnIdentifier name;
0:         UserType type;
1: 
0:         private UserDefined(ColumnIdentifier name, UserType type)
1:         {
1:             this.name = name;
1:             this.type = type;
1:         }
1: 
0:         public static UserDefined create(ByteBuffer name, UserType type)
1:         {
0:             return new UserDefined(new ColumnIdentifier(name, UTF8Type.instance), type);
1:         }
1: 
0:         public static UserDefined create(ColumnIdentifier name) throws InvalidRequestException
1:         {
0:             UserType type = Schema.instance.userTypes.getType(name);
0:             if (type == null)
0:                 throw new InvalidRequestException("Unknown type " + name);
1: 
0:             return new UserDefined(name, type);
1:         }
1: 
0:         public boolean isUserType()
1:         {
1:             return true;
1:         }
1: 
0:         public boolean isCollection()
1:         {
0:             return false;
1:         }
1: 
0:         public boolean isCounter()
1:         {
0:             return false;
1:         }
1: 
1:         public AbstractType<?> getType()
1:         {
1:             return type;
1:         }
1: 
1:         @Override
1:         public final boolean equals(Object o)
1:         {
1:             if(!(o instanceof UserDefined))
0:                 return false;
1: 
1:             UserDefined that = (UserDefined)o;
1:             return type.equals(that.type);
1:         }
1: 
1:         @Override
1:         public final int hashCode()
1:         {
1:             return type.hashCode();
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
0:             return name.toString();
1:         }
1:     }
commit:a7b32de
commit:fc9b3a7
/////////////////////////////////////////////////////////////////////////
0:                     return "map<" + mt.keys.asCQL3Type() + ", " + mt.values.asCQL3Type() + ">";
commit:9ec7b80
/////////////////////////////////////////////////////////////////////////
0:         TIMESTAMP(TimestampType.instance),
commit:b72af48
/////////////////////////////////////////////////////////////////////////
1:         public final boolean equals(Object o)
1:         {
1:             if(!(o instanceof Custom))
0:                 return false;
1: 
1:             Custom that = (Custom)o;
1:             return type.equals(that.type);
1:         }
1: 
1:         @Override
1:         public final int hashCode()
1:         {
1:             return type.hashCode();
1:         }
1: 
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         public final boolean equals(Object o)
1:         {
1:             if(!(o instanceof Collection))
0:                 return false;
0: 
1:             Collection that = (Collection)o;
1:             return type.equals(that.type);
1:         }
0: 
1:         @Override
1:         public final int hashCode()
1:         {
1:             return type.hashCode();
1:         }
0: 
1:         @Override
commit:a67f779
/////////////////////////////////////////////////////////////////////////
1: public interface CQL3Type
1:     public enum Native implements CQL3Type
/////////////////////////////////////////////////////////////////////////
0: 
1:         @Override
1:         public String toString()
1:         {
1:             return super.toString().toLowerCase();
1:         }
1:     public static class Custom implements CQL3Type
1:         public Custom(AbstractType<?> type)
1:         {
1:             this.type = type;
1:         }
0: 
1:             this(TypeParser.parse(className));
/////////////////////////////////////////////////////////////////////////
0: 
1:         @Override
1:         public String toString()
1:         {
0:             return "'" + type + "'";
1:         }
1:     public static class Collection implements CQL3Type
1:         public Collection(CollectionType type)
0:         public static Collection map(CQL3Type t1, CQL3Type t2) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:         public static Collection list(CQL3Type t) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:         public static Collection set(CQL3Type t) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0: 
1:         @Override
1:         public String toString()
1:         {
0:             switch (type.kind)
1:             {
0:                 case LIST:
0:                     return "list<" + ((ListType)type).elements.asCQL3Type() + ">";
0:                 case SET:
0:                     return "set<" + ((SetType)type).elements.asCQL3Type() + ">";
0:                 case MAP:
0:                     MapType mt = (MapType)type;
0:                     return "set<" + mt.keys.asCQL3Type() + ", " + mt.values.asCQL3Type() + ">";
1:             }
0:             throw new AssertionError();
1:         }
commit:986893e
/////////////////////////////////////////////////////////////////////////
0:     public boolean isCounter();
/////////////////////////////////////////////////////////////////////////
0: 
0:         public boolean isCounter()
1:         {
0:             return this == COUNTER;
1:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:         public boolean isCounter()
0:         {
0:             return false;
0:         }
/////////////////////////////////////////////////////////////////////////
0:             if (t1.isCounter() || t2.isCounter())
0:                 throw new InvalidRequestException("counters are not allowed inside a collection");
/////////////////////////////////////////////////////////////////////////
0:             if (t.isCounter())
0:                 throw new InvalidRequestException("counters are not allowed inside a collection");
/////////////////////////////////////////////////////////////////////////
0:             if (t.isCounter())
0:                 throw new InvalidRequestException("counters are not allowed inside a collection");
/////////////////////////////////////////////////////////////////////////
0: 
0:         public boolean isCounter()
0:         {
0:             return false;
0:         }
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.InvalidRequestException;
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.exceptions.SyntaxException;
/////////////////////////////////////////////////////////////////////////
1:         public Custom(String className) throws SyntaxException, ConfigurationException
0:             this.type = TypeParser.parse(className);
commit:91bdf7f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.cassandra.cql3;
0: 
0: import org.apache.cassandra.config.ConfigurationException;
1: import org.apache.cassandra.db.marshal.*;
0: import org.apache.cassandra.thrift.InvalidRequestException;
0: 
0: public interface ParsedType
0: {
0:     public boolean isCollection();
1:     public AbstractType<?> getType();
0: 
0:     public enum Native implements ParsedType
0:     {
0:         ASCII    (AsciiType.instance),
0:         BIGINT   (LongType.instance),
0:         BLOB     (BytesType.instance),
0:         BOOLEAN  (BooleanType.instance),
0:         COUNTER  (CounterColumnType.instance),
0:         DECIMAL  (DecimalType.instance),
0:         DOUBLE   (DoubleType.instance),
0:         FLOAT    (FloatType.instance),
0:         INET     (InetAddressType.instance),
0:         INT      (Int32Type.instance),
0:         TEXT     (UTF8Type.instance),
0:         TIMESTAMP(DateType.instance),
0:         UUID     (UUIDType.instance),
0:         VARCHAR  (UTF8Type.instance),
0:         VARINT   (IntegerType.instance),
0:         TIMEUUID (TimeUUIDType.instance);
0: 
1:         private final AbstractType<?> type;
0: 
1:         private Native(AbstractType<?> type)
0:         {
1:             this.type = type;
0:         }
0: 
0:         public boolean isCollection()
0:         {
0:             return false;
0:         }
0: 
1:         public AbstractType<?> getType()
0:         {
1:             return type;
0:         }
0:     }
0: 
0:     public static class Custom implements ParsedType
0:     {
1:         private final AbstractType<?> type;
0: 
0:         public Custom(String className) throws ConfigurationException
0:         {
0:             this.type =  TypeParser.parse(className);
0:         }
0: 
0:         public boolean isCollection()
0:         {
0:             return false;
0:         }
0: 
1:         public AbstractType<?> getType()
0:         {
1:             return type;
0:         }
0:     }
0: 
0:     public static class Collection implements ParsedType
0:     {
0:         CollectionType type;
0: 
0:         private Collection(CollectionType type)
0:         {
1:             this.type = type;
0:         }
0: 
0:         public static Collection map(ParsedType t1, ParsedType t2) throws InvalidRequestException
0:         {
0:             if (t1.isCollection() || t2.isCollection())
0:                 throw new InvalidRequestException("map type cannot contain another collection");
0: 
0:             return new Collection(MapType.getInstance(t1.getType(), t2.getType()));
0:         }
0: 
0:         public static Collection list(ParsedType t) throws InvalidRequestException
0:         {
0:             if (t.isCollection())
0:                 throw new InvalidRequestException("list type cannot contain another collection");
0: 
0:             return new Collection(ListType.getInstance(t.getType()));
0:         }
0: 
0:         public static Collection set(ParsedType t) throws InvalidRequestException
0:         {
0:             if (t.isCollection())
0:                 throw new InvalidRequestException("set type cannot contain another collection");
0: 
0:             return new Collection(SetType.getInstance(t.getType()));
0:         }
0: 
0:         public boolean isCollection()
0:         {
0:             return true;
0:         }
0: 
1:         public AbstractType<?> getType()
0:         {
1:             return type;
0:         }
0:     }
0: }
author:Michael Edge
-------------------------------------------------------------------------------
commit:cdf0485
/////////////////////////////////////////////////////////////////////////
1:                     if (keys.isCounter())
1:                         throw new InvalidRequestException("Counters are not allowed inside collections: " + this);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:18e2fca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public CQL3Type prepareInternal(String keyspace, Types udts) throws InvalidRequestException
0:         {
1:             return prepare(keyspace, udts);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
1:                 return prepare(keyspace, udts, false);
0:             }
0: 
1:             public CQL3Type prepareInternal(String keyspace, Types udts)
0:             {
1:                 return prepare(keyspace, udts, true);
0:             }
0: 
1:             public CQL3Type prepare(String keyspace, Types udts, boolean isInternal) throws InvalidRequestException
0:             {
0: 
1:                 // we represent Thrift supercolumns as maps, internally, and we do allow counters in supercolumns. Thus,
1:                 // for internal type parsing (think schema) we have to make an exception and allow counters as (map) values
1:                 if (values.isCounter() && !isInternal)
commit:340df43
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: import java.util.Set;
1: import org.apache.cassandra.schema.Types;
/////////////////////////////////////////////////////////////////////////
1:         DATE        (SimpleDateType.instance),
1:         EMPTY       (EmptyType.instance),
1:         TIME        (TimeType.instance),
1:         TIMEUUID    (TimeUUIDType.instance),
1:         VARINT      (IntegerType.instance);
/////////////////////////////////////////////////////////////////////////
0:             return "frozen<" + ColumnIdentifier.maybeQuote(name) + '>';
/////////////////////////////////////////////////////////////////////////
1:             sb.append("frozen<tuple<");
1:             sb.append(">>");
/////////////////////////////////////////////////////////////////////////
1:         public CQL3Type prepare(String keyspace)
0:         {
1:             KeyspaceMetadata ksm = Schema.instance.getKSMetaData(keyspace);
0:             if (ksm == null)
1:                 throw new ConfigurationException(String.format("Keyspace %s doesn't exist", keyspace));
1:             return prepare(keyspace, ksm.types);
0:         }
0: 
1:         public abstract CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException;
0: 
1:         public boolean referencesUserType(String name)
0:         {
0:             return false;
0:         }
/////////////////////////////////////////////////////////////////////////
1:             private final CQL3Type type;
1:             public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
1:             public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:                         return new Collection(ListType.getInstance(values.prepare(keyspace, udts).getType(), !frozen));
0:                         return new Collection(SetType.getInstance(values.prepare(keyspace, udts).getType(), !frozen));
0:                         return new Collection(MapType.getInstance(keys.prepare(keyspace, udts).getType(), values.prepare(keyspace, udts).getType(), !frozen));
1:             public boolean referencesUserType(String name)
0:             {
1:                 return (keys != null && keys.referencesUserType(name)) || values.referencesUserType(name);
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
1:             public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
0:                     if (!keyspace.equals(name.getKeyspace()))
/////////////////////////////////////////////////////////////////////////
1:                 UserType type = udts.getNullable(name.getUserTypeName());
/////////////////////////////////////////////////////////////////////////
1:             public boolean referencesUserType(String name)
0:             {
1:                 return this.name.getStringTypeName().equals(name);
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:             public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
1:                     ts.add(t.prepare(keyspace, udts).getType());
1:             public boolean referencesUserType(String name)
0:             {
1:                 return types.stream().anyMatch(t -> t.referencesUserType(name));
0:             }
0: 
commit:a89597d
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
1: import org.apache.cassandra.schema.KeyspaceMetadata;
/////////////////////////////////////////////////////////////////////////
0:                 KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
commit:2f2b58d
/////////////////////////////////////////////////////////////////////////
0:                 UserType type = ksm.types.getNullable(name.getUserTypeName());
author:blerer
-------------------------------------------------------------------------------
commit:1de8e39
/////////////////////////////////////////////////////////////////////////
1:         public boolean isFrozen()
0:         {
1:             return this.frozen;
0:         }
0: 
1:         public boolean canBeNonFrozen()
0:         {
0:             return true;
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
1:             public boolean canBeNonFrozen()
0:             {
0:                 return false;
0:             }
0: 
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:7f29201
/////////////////////////////////////////////////////////////////////////
0:         ASCII    (AsciiType.instance),
0:         BIGINT   (LongType.instance),
0:         BLOB     (BytesType.instance),
0:         BOOLEAN  (BooleanType.instance),
0:         COUNTER  (CounterColumnType.instance),
0:         DECIMAL  (DecimalType.instance),
0:         DOUBLE   (DoubleType.instance),
0:         FLOAT    (FloatType.instance),
0:         INET     (InetAddressType.instance),
0:         INT      (Int32Type.instance),
0:         TEXT     (UTF8Type.instance),
0:         TIMESTAMP(TimestampType.instance),
0:         UUID     (UUIDType.instance),
0:         VARCHAR  (UTF8Type.instance),
0:         VARINT   (IntegerType.instance),
0:         TIMEUUID (TimeUUIDType.instance);
commit:3d11ec5
commit:107545b
/////////////////////////////////////////////////////////////////////////
1:         ASCII       (AsciiType.instance),
1:         BIGINT      (LongType.instance),
1:         BLOB        (BytesType.instance),
1:         BOOLEAN     (BooleanType.instance),
1:         COUNTER     (CounterColumnType.instance),
1:         DECIMAL     (DecimalType.instance),
1:         DOUBLE      (DoubleType.instance),
1:         FLOAT       (FloatType.instance),
1:         INET        (InetAddressType.instance),
1:         INT         (Int32Type.instance),
1:         TEXT        (UTF8Type.instance),
1:         TIMESTAMP   (TimestampType.instance),
1:         UUID        (UUIDType.instance),
1:         VARCHAR     (UTF8Type.instance),
0:         VARINT      (IntegerType.instance),
0:         TIMEUUID    (TimeUUIDType.instance),
0:         DATE        (SimpleDateType.instance),
0:         TIME        (TimeType.instance);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:02fb218
/////////////////////////////////////////////////////////////////////////
============================================================================