1:c270904: /*
1:07cf56f:  * Licensed to the Apache Software Foundation (ASF) under one
1:07cf56f:  * or more contributor license agreements.  See the NOTICE file
1:07cf56f:  * distributed with this work for additional information
1:07cf56f:  * regarding copyright ownership.  The ASF licenses this file
1:07cf56f:  * to you under the Apache License, Version 2.0 (the
1:07cf56f:  * "License"); you may not use this file except in compliance
1:07cf56f:  * with the License.  You may obtain a copy of the License at
1:07cf56f:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:07cf56f:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:07cf56f:  */
1:c270904: package org.apache.cassandra.utils;
1:07cdfd0: 
1:5a6f0b8: import java.io.DataInput;
1:5a6f0b8: import java.io.IOException;
1:5a6f0b8: import java.io.Serializable;
1:e98eb1c: import java.util.*;
1:e98eb1c: 
1:eb4fa4a: import com.google.common.base.Preconditions;
1:e98eb1c: import com.google.common.collect.PeekingIterator;
1:e7a385a: 
1:2ae5272: import org.apache.cassandra.db.TypeSizes;
1:e7a385a: import org.apache.cassandra.dht.IPartitioner;
1:806facc: import org.apache.cassandra.dht.IPartitionerDependentSerializer;
1:e7a385a: import org.apache.cassandra.dht.Range;
1:e7a385a: import org.apache.cassandra.dht.Token;
1:eb4fa4a: import org.apache.cassandra.exceptions.ConfigurationException;
1:84eeb28: import org.apache.cassandra.io.IVersionedSerializer;
1:03f72ac: import org.apache.cassandra.io.util.DataInputPlus;
1:75508ec: import org.apache.cassandra.io.util.DataOutputPlus;
1:90e0013: import org.apache.cassandra.net.MessagingService;
1:07cdfd0: 
1:dc89826: /**
1:c270904:  * A MerkleTree implemented as a binary tree.
9:c270904:  *
1:f2413f7:  * A MerkleTree is a full binary tree that represents a perfect binary tree of
1:c270904:  * depth 'hashdepth'. In a perfect binary tree, each leaf contains a
1:c270904:  * sequentially hashed range, and each inner node contains the binary hash of
1:c270904:  * its two children. In the MerkleTree, many ranges will not be split to the
1:c270904:  * full depth of the perfect binary tree: the leaves of this tree are Leaf objects,
1:c270904:  * which contain the computed values of the nodes that would be below them if
1:c270904:  * the tree were perfect.
1:07cdfd0:  *
1:f2413f7:  * The hash values of the inner nodes of the MerkleTree are calculated lazily based
1:f2413f7:  * on their children when the hash of a range is requested with hash(range).
1:2fd3268:  *
1:c52be53:  * Inputs passed to TreeRange.validate should be calculated using a very secure hash,
1:07cdfd0:  * because all hashing internal to the tree is accomplished using XOR.
1:f2413f7:  *
1:c270904:  * If two MerkleTrees have the same hashdepth, they represent a perfect tree
1:c270904:  * of the same depth, and can always be compared, regardless of size or splits.
1:dc89826:  */
1:c270904: public class MerkleTree implements Serializable
1:b1ed2d1: {
1:b1ed2d1:     public static final MerkleTreeSerializer serializer = new MerkleTreeSerializer();
1:c52be53:     private static final long serialVersionUID = 2L;
1:07cdfd0: 
1:746be67:     public static final byte RECOMMENDED_DEPTH = Byte.MAX_VALUE - 1;
1:2fd3268: 
1:c270904:     public static final int CONSISTENT = 0;
1:c270904:     public static final int FULLY_INCONSISTENT = 1;
1:c270904:     public static final int PARTIALLY_INCONSISTENT = 2;
1:18f0234:     private static final byte[] EMPTY_HASH = new byte[0];
1:2fd3268: 
1:c270904:     public final byte hashdepth;
1:2fd3268: 
1:eb4fa4a:     /** The top level range that this MerkleTree covers. */
1:eb4fa4a:     public final Range<Token> fullRange;
1:eb4fa4a:     private final IPartitioner partitioner;
1:dc89826: 
1:c52be53:     private long maxsize;
1:c52be53:     private long size;
1:c270904:     private Hashable root;
1:07cdfd0: 
1:5a6f0b8:     public static class MerkleTreeSerializer implements IVersionedSerializer<MerkleTree>
1:b1ed2d1:     {
1:75508ec:         public void serialize(MerkleTree mt, DataOutputPlus out, int version) throws IOException
1:b1ed2d1:         {
1:60d9c7f:             out.writeByte(mt.hashdepth);
1:60d9c7f:             out.writeLong(mt.maxsize);
1:60d9c7f:             out.writeLong(mt.size);
1:eb4fa4a:             out.writeUTF(mt.partitioner.getClass().getCanonicalName());
1:eb4fa4a:             // full range
1:806facc:             Token.serializer.serialize(mt.fullRange.left, out, version);
1:806facc:             Token.serializer.serialize(mt.fullRange.right, out, version);
1:60d9c7f:             Hashable.serializer.serialize(mt.root, out, version);
1:b1ed2d1:         }
1:07cdfd0: 
1:03f72ac:         public MerkleTree deserialize(DataInputPlus in, int version) throws IOException
1:b1ed2d1:         {
1:60d9c7f:             byte hashdepth = in.readByte();
1:60d9c7f:             long maxsize = in.readLong();
1:60d9c7f:             long size = in.readLong();
1:eb4fa4a:             IPartitioner partitioner;
1:eb4fa4a:             try
1:eb4fa4a:             {
1:eb4fa4a:                 partitioner = FBUtilities.newPartitioner(in.readUTF());
1:eb4fa4a:             }
1:eb4fa4a:             catch (ConfigurationException e)
1:eb4fa4a:             {
1:eb4fa4a:                 throw new IOException(e);
1:eb4fa4a:             }
1:eb4fa4a: 
1:eb4fa4a:             // full range
1:806facc:             Token left = Token.serializer.deserialize(in, partitioner, version);
1:806facc:             Token right = Token.serializer.deserialize(in, partitioner, version);
1:07893d7:             Range<Token> fullRange = new Range<>(left, right);
1:eb4fa4a: 
1:eb4fa4a:             MerkleTree mt = new MerkleTree(partitioner, fullRange, hashdepth, maxsize);
1:5a6f0b8:             mt.size = size;
1:806facc:             mt.root = Hashable.serializer.deserialize(in, partitioner, version);
1:5a6f0b8:             return mt;
1:5a6f0b8:         }
1:5a6f0b8: 
1:5b9fc26:         public long serializedSize(MerkleTree mt, int version)
1:5a6f0b8:         {
1:eb4fa4a:             long size = 1 // mt.hashdepth
1:03f72ac:                  + TypeSizes.sizeof(mt.maxsize)
1:03f72ac:                  + TypeSizes.sizeof(mt.size)
1:03f72ac:                  + TypeSizes.sizeof(mt.partitioner.getClass().getCanonicalName());
1:eb4fa4a: 
1:eb4fa4a:             // full range
1:806facc:             size += Token.serializer.serializedSize(mt.fullRange.left, version);
1:806facc:             size += Token.serializer.serializedSize(mt.fullRange.right, version);
1:eb4fa4a: 
1:eb4fa4a:             size += Hashable.serializer.serializedSize(mt.root, version);
1:eb4fa4a:             return size;
1:b1ed2d1:         }
1:b1ed2d1:     }
1:2fd3268: 
7:c270904:     /**
1:c270904:      * @param partitioner The partitioner in use.
1:dc89826:      * @param range the range this tree covers
1:c270904:      * @param hashdepth The maximum depth of the tree. 100/(2^depth) is the %
1:c270904:      *        of the key space covered by each subrange of a fully populated tree.
1:c270904:      * @param maxsize The maximum number of subranges in the tree.
8:c270904:      */
1:554223b:     public MerkleTree(IPartitioner partitioner, Range<Token> range, byte hashdepth, long maxsize)
24:c270904:     {
1:746be67:         assert hashdepth < Byte.MAX_VALUE;
1:eb4fa4a:         this.fullRange = Preconditions.checkNotNull(range);
1:eb4fa4a:         this.partitioner = Preconditions.checkNotNull(partitioner);
1:c270904:         this.hashdepth = hashdepth;
1:c270904:         this.maxsize = maxsize;
1:2fd3268: 
1:c270904:         size = 1;
1:c270904:         root = new Leaf(null);
24:c270904:     }
1:2fd3268: 
1:2fd3268: 
1:c270904:     static byte inc(byte in)
1:c270904:     {
1:c270904:         assert in < Byte.MAX_VALUE;
1:c270904:         return (byte)(in + 1);
1:c270904:     }
1:dc89826: 
1:c270904:     /**
1:c52be53:      * Initializes this tree by splitting it until hashdepth is reached,
1:c52be53:      * or until an additional level of splits would violate maxsize.
1:c270904:      *
1:c52be53:      * NB: Replaces all nodes in the tree.
1:c270904:      */
1:c270904:     public void init()
1:c270904:     {
1:c52be53:         // determine the depth to which we can safely split the tree
1:c52be53:         byte sizedepth = (byte)(Math.log10(maxsize) / Math.log10(2));
1:c52be53:         byte depth = (byte)Math.min(sizedepth, hashdepth);
1:b1ed2d1: 
1:dc89826:         root = initHelper(fullRange.left, fullRange.right, (byte)0, depth);
1:c52be53:         size = (long)Math.pow(2, depth);
1:c52be53:     }
1:b1ed2d1: 
1:c52be53:     private Hashable initHelper(Token left, Token right, byte depth, byte max)
1:c52be53:     {
1:c52be53:         if (depth == max)
1:c52be53:             // we've reached the leaves
1:c52be53:             return new Leaf();
1:c52be53:         Token midpoint = partitioner.midpoint(left, right);
1:dc89826: 
1:21bc3c2:         if (midpoint.equals(left) || midpoint.equals(right))
1:21bc3c2:             return new Leaf();
1:21bc3c2: 
1:21bc3c2:         Hashable lchild =  initHelper(left, midpoint, inc(depth), max);
1:21bc3c2:         Hashable rchild =  initHelper(midpoint, right, inc(depth), max);
1:c52be53:         return new Inner(midpoint, lchild, rchild);
1:c270904:     }
1:b1ed2d1: 
1:c270904:     Hashable root()
1:c270904:     {
1:c270904:         return root;
1:c270904:     }
1:b1ed2d1: 
1:c270904:     public IPartitioner partitioner()
1:c270904:     {
1:c270904:         return partitioner;
1:c270904:     }
60:c270904: 
1:c270904:     /**
1:c270904:      * The number of distinct ranges contained in this tree. This is a reasonable
1:c270904:      * measure of the memory usage of the tree (assuming 'this.order' is significant).
1:c270904:      */
1:c52be53:     public long size()
1:c270904:     {
1:c270904:         return size;
1:c270904:     }
1:c270904: 
1:c52be53:     public long maxsize()
1:c270904:     {
1:c270904:         return maxsize;
1:c270904:     }
1:c270904: 
1:c52be53:     public void maxsize(long maxsize)
1:c270904:     {
1:c270904:         this.maxsize = maxsize;
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * @param ltree First tree.
1:c270904:      * @param rtree Second tree.
1:c270904:      * @return A list of the largest contiguous ranges where the given trees disagree.
1:c270904:      */
1:71084e3:     public static List<TreeRange> difference(MerkleTree ltree, MerkleTree rtree)
1:c270904:     {
1:dc89826:         if (!ltree.fullRange.equals(rtree.fullRange))
1:dc89826:             throw new IllegalArgumentException("Difference only make sense on tree covering the same range (but " + ltree.fullRange + " != " + rtree.fullRange + ")");
1:dc89826: 
1:18f0234:         List<TreeRange> diff = new ArrayList<>();
1:18f0234:         TreeDifference active = new TreeDifference(ltree.fullRange.left, ltree.fullRange.right, (byte)0);
1:c270904: 
1:18f0234:         Hashable lnode = ltree.find(active);
1:18f0234:         Hashable rnode = rtree.find(active);
1:18f0234:         byte[] lhash = lnode.hash();
1:18f0234:         byte[] rhash = rnode.hash();
1:18f0234:         active.setSize(lnode.sizeOfRange(), rnode.sizeOfRange());
1:c270904: 
1:c270904:         if (lhash != null && rhash != null && !Arrays.equals(lhash, rhash))
1:c270904:         {
1:c270904:             if (FULLY_INCONSISTENT == differenceHelper(ltree, rtree, diff, active))
1:c270904:                 diff.add(active);
1:c270904:         }
1:c270904:         else if (lhash == null || rhash == null)
1:c270904:             diff.add(active);
1:c270904:         return diff;
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * TODO: This function could be optimized into a depth first traversal of
1:c270904:      * the two trees in parallel.
1:c270904:      *
1:c270904:      * Takes two trees and a range for which they have hashes, but are inconsistent.
1:c270904:      * @return FULLY_INCONSISTENT if active is inconsistent, PARTIALLY_INCONSISTENT if only a subrange is inconsistent.
1:c270904:      */
1:71084e3:     static int differenceHelper(MerkleTree ltree, MerkleTree rtree, List<TreeRange> diff, TreeRange active)
1:c270904:     {
1:e4b3d40:         if (active.depth == Byte.MAX_VALUE)
1:e4b3d40:             return CONSISTENT;
1:e4b3d40: 
1:30f0216:         Token midpoint = ltree.partitioner().midpoint(active.left, active.right);
1:18f0234:         TreeDifference left = new TreeDifference(active.left, midpoint, inc(active.depth));
1:18f0234:         TreeDifference right = new TreeDifference(midpoint, active.right, inc(active.depth));
1:18f0234:         byte[] lhash, rhash;
1:18f0234:         Hashable lnode, rnode;
1:c270904: 
1:c270904:         // see if we should recurse left
1:18f0234:         lnode = ltree.find(left);
1:18f0234:         rnode = rtree.find(left);
1:18f0234:         lhash = lnode.hash();
1:18f0234:         rhash = rnode.hash();
1:18f0234:         left.setSize(lnode.sizeOfRange(), rnode.sizeOfRange());
1:18f0234:         left.setRows(lnode.rowsInRange(), rnode.rowsInRange());
1:18f0234: 
1:c270904:         int ldiff = CONSISTENT;
1:c270904:         boolean lreso = lhash != null && rhash != null;
1:c270904:         if (lreso && !Arrays.equals(lhash, rhash))
1:c270904:             ldiff = differenceHelper(ltree, rtree, diff, left);
1:c270904:         else if (!lreso)
1:c270904:             ldiff = FULLY_INCONSISTENT;
1:c270904: 
1:c270904:         // see if we should recurse right
1:18f0234:         lnode = ltree.find(right);
1:18f0234:         rnode = rtree.find(right);
1:18f0234:         lhash = lnode.hash();
1:18f0234:         rhash = rnode.hash();
1:18f0234:         right.setSize(lnode.sizeOfRange(), rnode.sizeOfRange());
1:18f0234:         right.setRows(lnode.rowsInRange(), rnode.rowsInRange());
1:18f0234: 
1:c270904:         int rdiff = CONSISTENT;
1:c270904:         boolean rreso = lhash != null && rhash != null;
1:c270904:         if (rreso && !Arrays.equals(lhash, rhash))
1:c270904:             rdiff = differenceHelper(ltree, rtree, diff, right);
1:c270904:         else if (!rreso)
1:c270904:             rdiff = FULLY_INCONSISTENT;
1:c270904: 
1:c270904:         if (ldiff == FULLY_INCONSISTENT && rdiff == FULLY_INCONSISTENT)
1:c270904:         {
1:c270904:             // both children are fully inconsistent
1:c270904:             return FULLY_INCONSISTENT;
1:c270904:         }
1:c270904:         else if (ldiff == FULLY_INCONSISTENT)
1:c270904:         {
1:c270904:             diff.add(left);
1:c270904:             return PARTIALLY_INCONSISTENT;
1:c270904:         }
1:c270904:         else if (rdiff == FULLY_INCONSISTENT)
1:c270904:         {
1:c270904:             diff.add(right);
1:c270904:             return PARTIALLY_INCONSISTENT;
1:c270904:         }
1:c270904:         return PARTIALLY_INCONSISTENT;
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * For testing purposes.
1:c270904:      * Gets the smallest range containing the token.
1:c270904:      */
1:dc89826:     public TreeRange get(Token t)
1:c270904:     {
1:dc89826:         return getHelper(root, fullRange.left, fullRange.right, (byte)0, t);
1:c270904:     }
1:c270904: 
1:c270904:     TreeRange getHelper(Hashable hashable, Token pleft, Token pright, byte depth, Token t)
1:c270904:     {
1:0f5e780:         while (true)
1:c270904:         {
1:0f5e780:             if (hashable instanceof Leaf)
1:0f5e780:             {
1:0f5e780:                 // we've reached a hash: wrap it up and deliver it
1:0f5e780:                 return new TreeRange(this, pleft, pright, depth, hashable);
1:0f5e780:             }
1:0f5e780:             // else: node.
1:07cdfd0: 
1:0f5e780:             Inner node = (Inner) hashable;
1:0f5e780:             depth = inc(depth);
1:0f5e780:             if (Range.contains(pleft, node.token, t))
1:0f5e780:             { // left child contains token
1:0f5e780:                 hashable = node.lchild;
1:0f5e780:                 pright = node.token;
1:0f5e780:             }
1:0f5e780:             else
1:0f5e780:             { // else: right child contains token
1:0f5e780:                 hashable = node.rchild;
1:0f5e780:                 pleft = node.token;
1:0f5e780:             }
1:0f5e780:         }
1:b1ed2d1:     }
1:07cdfd0: 
1:c270904:     /**
1:c270904:      * Invalidates the ranges containing the given token.
1:dc89826:      * Useful for testing.
1:c270904:      */
1:c270904:     public void invalidate(Token t)
1:b1ed2d1:     {
1:dc89826:         invalidateHelper(root, fullRange.left, t);
1:b1ed2d1:     }
1:2fd3268: 
1:616ab64:     private void invalidateHelper(Hashable hashable, Token pleft, Token t)
1:b1ed2d1:     {
1:c270904:         hashable.hash(null);
3:c270904:         if (hashable instanceof Leaf)
2:c270904:             return;
3:c270904:         // else: node.
1:2fd3268: 
4:c270904:         Inner node = (Inner)hashable;
2:c270904:         if (Range.contains(pleft, node.token, t))
2:c270904:             // left child contains token
1:616ab64:             invalidateHelper(node.lchild, pleft, t);
1:b1ed2d1:         else
1:c270904:             // right child contains token
1:616ab64:             invalidateHelper(node.rchild, node.token, t);
1:b1ed2d1:     }
1:dc89826: 
1:c270904:     /**
1:c270904:      * Hash the given range in the tree. The range must have been generated
1:c270904:      * with recursive applications of partitioner.midpoint().
1:c270904:      *
1:c270904:      * NB: Currently does not support wrapping ranges that do not end with
1:c270904:      * partitioner.getMinimumToken().
1:c270904:      *
1:c270904:      * @return Null if any subrange of the range is invalid, or if the exact
1:c270904:      *         range cannot be calculated using this tree.
1:c270904:      */
1:554223b:     public byte[] hash(Range<Token> range)
1:b1ed2d1:     {
1:18f0234:         return find(range).hash();
1:18f0234:     }
1:18f0234: 
1:18f0234:     /**
1:18f0234:      * Find the {@link Hashable} node that matches the given {@code range}.
1:18f0234:      *
1:18f0234:      * @param range Range to find
1:18f0234:      * @return {@link Hashable} found. If nothing found, return {@link Leaf} with null hash.
1:18f0234:      */
1:18f0234:     private Hashable find(Range<Token> range)
1:18f0234:     {
1:b1ed2d1:         try
1:b1ed2d1:         {
1:18f0234:             return findHelper(root, new Range<Token>(fullRange.left, fullRange.right), range);
1:b1ed2d1:         }
2:c270904:         catch (StopRecursion e)
1:b1ed2d1:         {
1:18f0234:             return new Leaf();
1:b1ed2d1:         }
1:b1ed2d1:     }
1:dc89826: 
1:c270904:     /**
1:c270904:      * @throws StopRecursion If no match could be found for the range.
1:c270904:      */
1:18f0234:     private Hashable findHelper(Hashable current, Range<Token> activeRange, Range<Token> find) throws StopRecursion
1:c270904:     {
1:0f5e780:         while (true)
1:c270904:         {
1:0f5e780:             if (current instanceof Leaf)
1:0f5e780:             {
1:0f5e780:                 if (!find.contains(activeRange))
1:0f5e780:                     // we are not fully contained in this range!
1:0f5e780:                     throw new StopRecursion.BadRange();
1:0f5e780:                 return current;
1:0f5e780:             }
1:0f5e780:             // else: node.
1:0f5e780: 
1:0f5e780:             Inner node = (Inner) current;
1:0f5e780:             Range<Token> leftRange = new Range<>(activeRange.left, node.token);
1:0f5e780:             Range<Token> rightRange = new Range<>(node.token, activeRange.right);
1:0f5e780: 
1:0f5e780:             if (find.contains(activeRange))
1:0f5e780:                 // this node is fully contained in the range
1:0f5e780:                 return node.calc();
1:0f5e780: 
1:0f5e780:             // else: one of our children contains the range
1:0f5e780: 
1:0f5e780:             if (leftRange.contains(find))
1:0f5e780:             { // left child contains/matches the range
1:0f5e780:                 current = node.lchild;
1:0f5e780:                 activeRange = leftRange;
1:0f5e780:             }
1:0f5e780:             else if (rightRange.contains(find))
1:0f5e780:             { // right child contains/matches the range
1:0f5e780:                 current = node.rchild;
1:0f5e780:                 activeRange = rightRange;
1:0f5e780:             }
1:0f5e780:             else
1:0f5e780:             {
2:c270904:                 throw new StopRecursion.BadRange();
1:0f5e780:             }
1:c270904:         }
1:c270904:     }
1:18f0234: 
1:c270904:     /**
1:c270904:      * Splits the range containing the given token, if no tree limits would be
1:c270904:      * violated. If the range would be split to a depth below hashdepth, or if
1:c270904:      * the tree already contains maxsize subranges, this operation will fail.
1:c270904:      *
1:c270904:      * @return True if the range was successfully split.
1:c270904:      */
1:c270904:     public boolean split(Token t)
1:c270904:     {
1:c270904:         if (!(size < maxsize))
1:c270904:             return false;
1:b1ed2d1: 
3:c270904:         try
1:c270904:         {
1:dc89826:             root = splitHelper(root, fullRange.left, fullRange.right, (byte)0, t);
1:c270904:         }
1:c270904:         catch (StopRecursion.TooDeep e)
1:c270904:         {
1:c270904:             return false;
1:c270904:         }
1:c270904:         return true;
1:c270904:     }
1:e7a385a: 
1:616ab64:     private Hashable splitHelper(Hashable hashable, Token pleft, Token pright, byte depth, Token t) throws StopRecursion.TooDeep
1:c270904:     {
1:c270904:         if (depth >= hashdepth)
1:dc89826:             throw new StopRecursion.TooDeep();
1:b1ed2d1: 
1:c270904:         if (hashable instanceof Leaf)
1:c270904:         {
1:972ec74:             Token midpoint = partitioner.midpoint(pleft, pright);
1:972ec74: 
1:972ec74:             // We should not create a non-sensical range where start and end are the same token (this is non-sensical because range are
1:972ec74:             // start exclusive). Note that we shouldn't hit that unless the full range is very small or we are fairly deep
1:972ec74:             if (midpoint.equals(pleft) || midpoint.equals(pright))
1:972ec74:                 throw new StopRecursion.TooDeep();
1:972ec74: 
1:c270904:             // split
1:c270904:             size++;
1:c270904:             return new Inner(midpoint, new Leaf(), new Leaf());
1:c270904:         }
1:c270904:         // else: node.
1:c270904: 
1:c270904:         // recurse on the matching child
1:c270904:         Inner node = (Inner)hashable;
1:dc89826: 
1:c270904:         if (Range.contains(pleft, node.token, t))
1:c270904:             // left child contains token
1:c270904:             node.lchild(splitHelper(node.lchild, pleft, node.token, inc(depth), t));
1:b1ed2d1:         else
2:c270904:             // else: right child contains token
1:c270904:             node.rchild(splitHelper(node.rchild, node.token, pright, inc(depth), t));
2:c270904:         return node;
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * Returns a lazy iterator of invalid TreeRanges that need to be filled
1:c270904:      * in order to make the given Range valid.
1:c270904:      */
1:dc89826:     public TreeRangeIterator invalids()
1:c270904:     {
1:dc89826:         return new TreeRangeIterator(this);
1:c270904:     }
1:c270904: 
1:18f0234:     public EstimatedHistogram histogramOfRowSizePerLeaf()
1:18f0234:     {
1:18f0234:         HistogramBuilder histbuild = new HistogramBuilder();
1:18f0234:         for (TreeRange range : new TreeRangeIterator(this))
1:18f0234:         {
1:18f0234:             histbuild.add(range.hashable.sizeOfRange);
1:18f0234:         }
1:18f0234:         return histbuild.buildWithStdevRangesAroundMean();
1:18f0234:     }
1:18f0234: 
1:18f0234:     public EstimatedHistogram histogramOfRowCountPerLeaf()
1:18f0234:     {
1:18f0234:         HistogramBuilder histbuild = new HistogramBuilder();
1:18f0234:         for (TreeRange range : new TreeRangeIterator(this))
1:18f0234:         {
1:18f0234:             histbuild.add(range.hashable.rowsInRange);
1:18f0234:         }
1:18f0234:         return histbuild.buildWithStdevRangesAroundMean();
1:18f0234:     }
1:18f0234: 
1:c70ce63:     public long rowCount()
1:c70ce63:     {
1:c70ce63:         long count = 0;
1:c70ce63:         for (TreeRange range : new TreeRangeIterator(this))
1:c70ce63:         {
1:c70ce63:             count += range.hashable.rowsInRange;
1:c70ce63:         }
1:c70ce63:         return count;
1:c70ce63:     }
1:c70ce63: 
4:c270904:     @Override
1:c270904:     public String toString()
1:c270904:     {
1:c270904:         StringBuilder buff = new StringBuilder();
1:c270904:         buff.append("#<MerkleTree root=");
1:c270904:         root.toString(buff, 8);
1:c270904:         buff.append(">");
1:c270904:         return buff.toString();
1:c270904:     }
1:b1ed2d1: 
1:18f0234:     public static class TreeDifference extends TreeRange
1:18f0234:     {
1:18f0234:         private static final long serialVersionUID = 6363654174549968183L;
1:18f0234: 
1:18f0234:         private long sizeOnLeft;
1:18f0234:         private long sizeOnRight;
1:18f0234:         private long rowsOnLeft;
1:18f0234:         private long rowsOnRight;
1:18f0234: 
1:18f0234:         void setSize(long sizeOnLeft, long sizeOnRight)
1:18f0234:         {
1:18f0234:             this.sizeOnLeft = sizeOnLeft;
1:18f0234:             this.sizeOnRight = sizeOnRight;
1:18f0234:         }
1:18f0234: 
1:18f0234:         void setRows(long rowsOnLeft, long rowsOnRight)
1:18f0234:         {
1:18f0234:             this.rowsOnLeft = rowsOnLeft;
1:18f0234:             this.rowsOnRight = rowsOnRight;
1:18f0234:         }
1:18f0234: 
1:18f0234:         public long sizeOnLeft()
1:18f0234:         {
1:18f0234:             return sizeOnLeft;
1:18f0234:         }
1:18f0234: 
1:18f0234:         public long sizeOnRight()
1:18f0234:         {
1:18f0234:             return sizeOnRight;
1:18f0234:         }
1:18f0234: 
1:18f0234:         public long rowsOnLeft()
1:18f0234:         {
1:18f0234:             return rowsOnLeft;
1:18f0234:         }
1:18f0234: 
1:18f0234:         public long rowsOnRight()
1:18f0234:         {
1:18f0234:             return rowsOnRight;
1:18f0234:         }
1:18f0234: 
1:18f0234:         public TreeDifference(Token left, Token right, byte depth)
1:18f0234:         {
1:18f0234:             super(null, left, right, depth, null);
1:18f0234:         }
1:18f0234: 
1:18f0234:         public long totalRows()
1:18f0234:         {
1:18f0234:             return rowsOnLeft + rowsOnRight;
1:18f0234:         }
1:18f0234: 
1:18f0234:     }
1:18f0234: 
1:c270904:     /**
1:c270904:      * The public interface to a range in the tree.
1:c270904:      *
1:c270904:      * NB: A TreeRange should not be returned by a public method unless the
1:c270904:      * parents of the range it represents are already invalidated, since it
1:71084e3:      * will allow someone to modify the hash. Alternatively, a TreeRange
1:71084e3:      * may be created with a null tree, indicating that it is read only.
1:c270904:      */
1:554223b:     public static class TreeRange extends Range<Token>
1:c270904:     {
1:616ab64:         public static final long serialVersionUID = 1L;
1:c270904:         private final MerkleTree tree;
1:c270904:         public final byte depth;
1:c52be53:         private final Hashable hashable;
1:b1ed2d1: 
1:c270904:         TreeRange(MerkleTree tree, Token left, Token right, byte depth, Hashable hashable)
1:c270904:         {
1:c270904:             super(left, right);
1:c270904:             this.tree = tree;
1:c270904:             this.depth = depth;
1:c270904:             this.hashable = hashable;
1:c270904:         }
1:2fd3268: 
1:c270904:         public void hash(byte[] hash)
1:c270904:         {
1:71084e3:             assert tree != null : "Not intended for modification!";
1:c270904:             hashable.hash(hash);
1:c270904:         }
1:c270904: 
1:c270904:         public byte[] hash()
1:c270904:         {
2:c270904:             return hashable.hash();
1:c270904:         }
1:c270904: 
1:c270904:         /**
1:c52be53:          * @param entry Row to mix into the hash for this range.
1:c270904:          */
1:c52be53:         public void addHash(RowHash entry)
1:c270904:         {
1:71084e3:             assert tree != null : "Not intended for modification!";
1:c270904:             assert hashable instanceof Leaf;
1:c270904: 
1:18f0234:             hashable.addHash(entry.hash, entry.size);
1:18f0234:         }
1:18f0234: 
1:18f0234:         public void ensureHashInitialised()
1:18f0234:         {
1:18f0234:             assert tree != null : "Not intended for modification!";
1:18f0234:             assert hashable instanceof Leaf;
1:18f0234: 
1:18f0234:             if (hashable.hash == null)
1:18f0234:                 hashable.hash = EMPTY_HASH;
1:c270904:         }
1:c270904: 
1:c52be53:         public void addAll(Iterator<RowHash> entries)
1:c270904:         {
1:c52be53:             while (entries.hasNext())
1:c52be53:                 addHash(entries.next());
1:c270904:         }
1:c270904: 
1:c270904:         @Override
1:c270904:         public String toString()
1:c270904:         {
1:c270904:             StringBuilder buff = new StringBuilder("#<TreeRange ");
1:c270904:             buff.append(super.toString()).append(" depth=").append(depth);
1:71084e3:             return buff.append(">").toString();
1:c270904:         }
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:dc89826:      * Returns the leaf (range) of a given tree in increasing order.
1:dc89826:      * If the full range covered by the tree don't wrap, then it will return the
1:dc89826:      * ranges in increasing order.
1:dc89826:      * If the full range wrap, the first *and* last range returned by the
1:dc89826:      * iterator will be the wrapping range. It is the only case where the same
1:dc89826:      * leaf will be returned twice.
1:c270904:      */
1:c270904:     public static class TreeRangeIterator extends AbstractIterator<TreeRange> implements Iterable<TreeRange>, PeekingIterator<TreeRange>
1:c270904:     {
1:c270904:         // stack of ranges to visit
1:c270904:         private final ArrayDeque<TreeRange> tovisit;
1:c270904:         // interesting range
1:c270904:         private final MerkleTree tree;
1:c270904: 
1:dc89826:         TreeRangeIterator(MerkleTree tree)
1:dc89826:         {
1:dc89826:             tovisit = new ArrayDeque<TreeRange>();
1:dc89826:             tovisit.add(new TreeRange(tree, tree.fullRange.left, tree.fullRange.right, (byte)0, tree.root));
1:c270904:             this.tree = tree;
1:c270904:         }
1:07cdfd0: 
1:c270904:         /**
1:c270904:          * Find the next TreeRange.
1:c270904:          *
1:c270904:          * @return The next TreeRange.
1:c270904:          */
1:c270904:         public TreeRange computeNext()
1:c270904:         {
1:c270904:             while (!tovisit.isEmpty())
1:c270904:             {
1:c270904:                 TreeRange active = tovisit.pop();
1:c270904: 
1:c270904:                 if (active.hashable instanceof Leaf)
1:dc89826:                 {
1:c270904:                     // found a leaf invalid range
1:dc89826:                     if (active.isWrapAround() && !tovisit.isEmpty())
1:dc89826:                         // put to be taken again last
1:dc89826:                         tovisit.addLast(active);
1:c270904:                     return active;
1:dc89826:                 }
1:c270904: 
1:c270904:                 Inner node = (Inner)active.hashable;
1:30f0216:                 TreeRange left = new TreeRange(tree, active.left, node.token, inc(active.depth), node.lchild);
1:30f0216:                 TreeRange right = new TreeRange(tree, node.token, active.right, inc(active.depth), node.rchild);
1:dc89826: 
1:dc89826:                 if (right.isWrapAround())
1:dc89826:                 {
1:dc89826:                     // whatever is on the left is 'after' everything we have seen so far (it has greater tokens)
1:dc89826:                     tovisit.addLast(left);
1:dc89826:                     tovisit.addFirst(right);
1:dc89826:                 }
1:dc89826:                 else
1:dc89826:                 {
1:dc89826:                     // do left first then right
1:dc89826:                     tovisit.addFirst(right);
1:dc89826:                     tovisit.addFirst(left);
1:dc89826:                 }
1:c270904:             }
1:c270904:             return endOfData();
1:c270904:         }
1:07cdfd0: 
1:c270904:         public Iterator<TreeRange> iterator()
1:c270904:         {
1:c270904:             return this;
1:c270904:         }
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * An inner node in the MerkleTree. Inners can contain cached hash values, which
1:c270904:      * are the binary hash of their two children.
1:c270904:      */
1:c270904:     static class Inner extends Hashable
1:c270904:     {
1:616ab64:         public static final long serialVersionUID = 1L;
1:b1ed2d1:         static final byte IDENT = 2;
1:c270904:         public final Token token;
1:c270904:         private Hashable lchild;
1:c270904:         private Hashable rchild;
1:07cdfd0: 
1:5a6e2b0:         private static final InnerSerializer serializer = new InnerSerializer();
1:2fd3268: 
1:c270904:         /**
1:c270904:          * Constructs an Inner with the given token and children, and a null hash.
1:c270904:          */
1:c270904:         public Inner(Token token, Hashable lchild, Hashable rchild)
1:c270904:         {
1:c270904:             super(null);
1:07cdfd0:             this.token = token;
1:c270904:             this.lchild = lchild;
1:c270904:             this.rchild = rchild;
1:c270904:         }
1:07cdfd0: 
1:c270904:         public Hashable lchild()
1:c270904:         {
1:c270904:             return lchild;
1:c270904:         }
1:2fd3268: 
1:c270904:         public Hashable rchild()
1:c270904:         {
1:c270904:             return rchild;
1:c270904:         }
1:b1ed2d1: 
1:c270904:         public void lchild(Hashable child)
1:c270904:         {
1:c270904:             lchild = child;
1:c270904:         }
1:c270904: 
1:c270904:         public void rchild(Hashable child)
1:c270904:         {
1:c270904:             rchild = child;
1:c270904:         }
1:c270904: 
1:18f0234:         Hashable calc()
1:18f0234:         {
1:18f0234:             if (hash == null)
1:18f0234:             {
1:18f0234:                 // hash and size haven't been calculated; calc children then compute
1:18f0234:                 Hashable lnode = lchild.calc();
1:18f0234:                 Hashable rnode = rchild.calc();
1:18f0234:                 // cache the computed value
1:18f0234:                 hash(lnode.hash, rnode.hash);
1:18f0234:                 sizeOfRange = lnode.sizeOfRange + rnode.sizeOfRange;
1:18f0234:                 rowsInRange = lnode.rowsInRange + rnode.rowsInRange;
1:18f0234:             }
1:18f0234:             return this;
1:18f0234:         }
1:18f0234: 
1:c270904:         /**
1:c270904:          * Recursive toString.
1:c270904:          */
1:c270904:         public void toString(StringBuilder buff, int maxdepth)
1:c270904:         {
1:c270904:             buff.append("#<").append(getClass().getSimpleName());
1:c270904:             buff.append(" ").append(token);
1:c270904:             buff.append(" hash=").append(Hashable.toString(hash()));
1:c270904:             buff.append(" children=[");
1:c270904:             if (maxdepth < 1)
1:c270904:             {
1:c270904:                 buff.append("#");
1:c270904:             }
1:b1ed2d1:             else
1:c270904:             {
1:c270904:                 if (lchild == null)
1:c270904:                     buff.append("null");
8:c270904:                 else
1:c270904:                     lchild.toString(buff, maxdepth-1);
1:c270904:                 buff.append(" ");
1:c270904:                 if (rchild == null)
1:c270904:                     buff.append("null");
1:c270904:                 else
1:c270904:                     rchild.toString(buff, maxdepth-1);
1:c270904:             }
1:c270904:             buff.append("]>");
1:c270904:         }
1:c270904: 
1:c270904:         @Override
1:c270904:         public String toString()
1:c270904:         {
1:c270904:             StringBuilder buff = new StringBuilder();
1:c270904:             toString(buff, 1);
1:c270904:             return buff.toString();
1:c270904:         }
1:07cdfd0: 
1:806facc:         private static class InnerSerializer implements IPartitionerDependentSerializer<Inner>
1:b1ed2d1:         {
1:75508ec:             public void serialize(Inner inner, DataOutputPlus out, int version) throws IOException
1:b1ed2d1:             {
1:90e0013:                 if (version < MessagingService.VERSION_30)
1:b1ed2d1:                 {
1:90e0013:                     if (inner.hash == null)
1:90e0013:                         out.writeInt(-1);
1:90e0013:                     else
1:90e0013:                     {
1:90e0013:                         out.writeInt(inner.hash.length);
1:90e0013:                         out.write(inner.hash);
1:90e0013:                     }
1:b1ed2d1:                 }
1:806facc:                 Token.serializer.serialize(inner.token, out, version);
1:60d9c7f:                 Hashable.serializer.serialize(inner.lchild, out, version);
1:60d9c7f:                 Hashable.serializer.serialize(inner.rchild, out, version);
1:b1ed2d1:             }
1:2fd3268: 
1:806facc:             public Inner deserialize(DataInput in, IPartitioner p, int version) throws IOException
1:90e0013:             {
1:90e0013:                 if (version < MessagingService.VERSION_30)
1:b1ed2d1:                 {
1:90e0013:                     int hashLen = in.readInt();
1:90e0013:                     byte[] hash = hashLen >= 0 ? new byte[hashLen] : null;
1:90e0013:                     if (hash != null)
1:90e0013:                         in.readFully(hash);
1:90e0013:                 }
1:806facc:                 Token token = Token.serializer.deserialize(in, p, version);
1:806facc:                 Hashable lchild = Hashable.serializer.deserialize(in, p, version);
1:806facc:                 Hashable rchild = Hashable.serializer.deserialize(in, p, version);
1:b1ed2d1:                 return new Inner(token, lchild, rchild);
1:b1ed2d1:             }
1:5a6f0b8: 
1:5a6f0b8:             public long serializedSize(Inner inner, int version)
1:5a6f0b8:             {
1:90e0013:                 long size = 0;
1:90e0013:                 if (version < MessagingService.VERSION_30)
1:90e0013:                 {
1:90e0013:                     size += inner.hash == null
1:90e0013:                                        ? TypeSizes.sizeof(-1)
1:90e0013:                                        : TypeSizes.sizeof(inner.hash().length) + inner.hash().length;
1:90e0013:                 }
1:5b9fc26: 
1:806facc:                 size += Token.serializer.serializedSize(inner.token, version)
1:18f0234:                 + Hashable.serializer.serializedSize(inner.lchild, version)
1:18f0234:                 + Hashable.serializer.serializedSize(inner.rchild, version);
1:5a6f0b8:                 return size;
1:5a6f0b8:             }
1:b1ed2d1:         }
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * A leaf node in the MerkleTree. Because the MerkleTree represents a much
1:c270904:      * larger perfect binary tree of depth hashdepth, a Leaf object contains
1:c270904:      * the value that would be contained in the perfect tree at its position.
1:c270904:      *
1:c270904:      * When rows are added to the MerkleTree using TreeRange.validate(), the
1:c270904:      * tree extending below the Leaf is generated in memory, but only the root
1:c270904:      * is stored in the Leaf.
1:c270904:      */
1:c270904:     static class Leaf extends Hashable
1:c270904:     {
1:616ab64:         public static final long serialVersionUID = 1L;
1:b1ed2d1:         static final byte IDENT = 1;
1:5a6e2b0:         private static final LeafSerializer serializer = new LeafSerializer();
1:07cdfd0: 
1:c270904:         /**
1:c270904:          * Constructs a null hash.
1:c270904:          */
1:c270904:         public Leaf()
1:c270904:         {
1:c270904:             super(null);
1:c270904:         }
1:2fd3268: 
1:c270904:         public Leaf(byte[] hash)
1:c270904:         {
1:c270904:             super(hash);
1:c270904:         }
1:b1ed2d1: 
1:c270904:         public void toString(StringBuilder buff, int maxdepth)
1:c270904:         {
1:c270904:             buff.append(toString());
1:c270904:         }
1:07cdfd0: 
1:c270904:         @Override
1:c270904:         public String toString()
1:c270904:         {
1:c270904:             return "#<Leaf " + Hashable.toString(hash()) + ">";
1:c270904:         }
1:2fd3268: 
1:806facc:         private static class LeafSerializer implements IPartitionerDependentSerializer<Leaf>
1:b1ed2d1:         {
1:75508ec:             public void serialize(Leaf leaf, DataOutputPlus out, int version) throws IOException
1:b1ed2d1:             {
1:b1ed2d1:                 if (leaf.hash == null)
1:5a6f0b8:                 {
1:90e0013:                     if (version < MessagingService.VERSION_30)
1:90e0013:                         out.writeInt(-1);
1:90e0013:                     else
1:90e0013:                         out.writeByte(-1);
1:5a6f0b8:                 }
1:b1ed2d1:                 else
1:b1ed2d1:                 {
1:90e0013:                     if (version < MessagingService.VERSION_30)
1:90e0013:                         out.writeInt(leaf.hash.length);
1:90e0013:                     else
1:90e0013:                         out.writeByte(leaf.hash.length);
1:60d9c7f:                     out.write(leaf.hash);
1:b1ed2d1:                 }
1:b1ed2d1:             }
1:b1ed2d1: 
1:806facc:             public Leaf deserialize(DataInput in, IPartitioner p, int version) throws IOException
1:b1ed2d1:             {
1:90e0013:                 int hashLen = version < MessagingService.VERSION_30 ? in.readInt() : in.readByte();
1:b1ed2d1:                 byte[] hash = hashLen < 0 ? null : new byte[hashLen];
1:b1ed2d1:                 if (hash != null)
1:60d9c7f:                     in.readFully(hash);
1:b1ed2d1:                 return new Leaf(hash);
1:b1ed2d1:             }
1:5a6f0b8: 
1:5a6f0b8:             public long serializedSize(Leaf leaf, int version)
1:5a6f0b8:             {
1:90e0013:                 long size = version < MessagingService.VERSION_30 ? TypeSizes.sizeof(1) : 1;
1:90e0013:                 if (leaf.hash != null)
1:90e0013:                 {
1:90e0013:                     size += leaf.hash().length;
1:90e0013:                 }
1:90e0013:                 return size;
1:5a6f0b8:             }
1:b1ed2d1:         }
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * Hash value representing a row, to be used to pass hashes to the MerkleTree.
1:c52be53:      * The byte[] hash value should contain a digest of the key and value of the row
1:c52be53:      * created using a very strong hash function.
1:c270904:      */
1:c270904:     public static class RowHash
1:c270904:     {
1:c270904:         public final Token token;
1:c270904:         public final byte[] hash;
1:18f0234:         public final long size;
1:18f0234:         public RowHash(Token token, byte[] hash, long size)
1:c270904:         {
1:e7a385a:             this.token = token;
1:e7a385a:             this.hash  = hash;
1:18f0234:             this.size = size;
1:c270904:         }
1:07cdfd0: 
1:c270904:         @Override
1:c270904:         public String toString()
1:c270904:         {
1:18f0234:             return "#<RowHash " + token + " " + Hashable.toString(hash) + " @ " + size + " bytes>";
1:c270904:         }
1:c270904:     }
1:2fd3268: 
1:c270904:     /**
1:c270904:      * Abstract class containing hashing logic, and containing a single hash field.
1:c270904:      */
1:f81cc74:     static abstract class Hashable implements Serializable
1:c270904:     {
2:c270904:         private static final long serialVersionUID = 1L;
1:806facc:         private static final IPartitionerDependentSerializer<Hashable> serializer = new HashableSerializer();
1:c270904: 
1:c270904:         protected byte[] hash;
1:18f0234:         protected long sizeOfRange;
1:18f0234:         protected long rowsInRange;
1:c270904: 
1:c270904:         protected Hashable(byte[] hash)
1:c270904:         {
2:c270904:             this.hash = hash;
1:c270904:         }
1:c270904: 
1:c270904:         public byte[] hash()
1:c270904:         {
1:c270904:             return hash;
1:c270904:         }
1:c270904: 
1:18f0234:         public long sizeOfRange()
1:18f0234:         {
1:18f0234:             return sizeOfRange;
1:18f0234:         }
1:18f0234: 
1:18f0234:         public long rowsInRange()
1:18f0234:         {
1:18f0234:             return rowsInRange;
1:18f0234:         }
1:18f0234: 
1:c270904:         void hash(byte[] hash)
1:18f0234:         {
1:c270904:             this.hash = hash;
1:18f0234:         }
1:18f0234: 
1:18f0234:         Hashable calc()
1:c270904:         {
1:18f0234:             return this;
1:c270904:         }
1:c270904: 
1:c270904:         /**
1:c270904:          * Sets the value of this hash to binaryHash of its children.
1:c270904:          * @param lefthash Hash of left child.
1:c270904:          * @param righthash Hash of right child.
1:c270904:          */
1:c270904:         void hash(byte[] lefthash, byte[] righthash)
1:c270904:         {
1:c270904:             hash = binaryHash(lefthash, righthash);
1:c270904:         }
1:c270904: 
1:c270904:         /**
1:c52be53:          * Mixes the given value into our hash. If our hash is null,
1:c52be53:          * our hash will become the given value.
1:c52be53:          */
1:18f0234:         void addHash(byte[] righthash, long sizeOfRow)
1:c52be53:         {
1:c52be53:             if (hash == null)
1:c52be53:                 hash = righthash;
1:c52be53:             else
1:c52be53:                 hash = binaryHash(hash, righthash);
1:18f0234:             this.sizeOfRange += sizeOfRow;
1:18f0234:             this.rowsInRange += 1;
1:c52be53:         }
1:c52be53: 
1:c52be53:         /**
1:c270904:          * The primitive with which all hashing should be accomplished: hashes
1:c270904:          * a left and right value together.
1:c270904:          */
1:c270904:         static byte[] binaryHash(final byte[] left, final byte[] right)
1:c270904:         {
1:c52be53:             return FBUtilities.xor(left, right);
1:c270904:         }
1:c270904: 
1:c270904:         public abstract void toString(StringBuilder buff, int maxdepth);
1:07cdfd0: 
1:c270904:         public static String toString(byte[] hash)
1:c270904:         {
1:c270904:             if (hash == null)
1:c270904:                 return "null";
1:2ede7fc:             return "[" + Hex.bytesToHex(hash) + "]";
1:c270904:         }
1:07cdfd0: 
1:806facc:         private static class HashableSerializer implements IPartitionerDependentSerializer<Hashable>
1:b1ed2d1:         {
1:75508ec:             public void serialize(Hashable h, DataOutputPlus out, int version) throws IOException
1:b1ed2d1:             {
1:07cdfd0:                 if (h instanceof Inner)
1:b1ed2d1:                 {
1:60d9c7f:                     out.writeByte(Inner.IDENT);
1:60d9c7f:                     Inner.serializer.serialize((Inner)h, out, version);
1:b1ed2d1:                 }
1:b1ed2d1:                 else if (h instanceof Leaf)
1:b1ed2d1:                 {
1:60d9c7f:                     out.writeByte(Leaf.IDENT);
1:60d9c7f:                     Leaf.serializer.serialize((Leaf) h, out, version);
1:b1ed2d1:                 }
1:b1ed2d1:                 else
1:b1ed2d1:                     throw new IOException("Unexpected Hashable: " + h.getClass().getCanonicalName());
1:b1ed2d1:             }
1:2fd3268: 
1:806facc:             public Hashable deserialize(DataInput in, IPartitioner p, int version) throws IOException
1:b1ed2d1:             {
1:60d9c7f:                 byte ident = in.readByte();
1:b1ed2d1:                 if (Inner.IDENT == ident)
1:806facc:                     return Inner.serializer.deserialize(in, p, version);
1:b1ed2d1:                 else if (Leaf.IDENT == ident)
1:806facc:                     return Leaf.serializer.deserialize(in, p, version);
1:b1ed2d1:                 else
1:b1ed2d1:                     throw new IOException("Unexpected Hashable: " + ident);
1:84eeb28:             }
1:84eeb28: 
1:5a6f0b8:             public long serializedSize(Hashable h, int version)
1:84eeb28:             {
1:5a6f0b8:                 if (h instanceof Inner)
1:5a6f0b8:                     return 1 + Inner.serializer.serializedSize((Inner) h, version);
1:5a6f0b8:                 else if (h instanceof Leaf)
1:5a6f0b8:                     return 1 + Leaf.serializer.serializedSize((Leaf) h, version);
1:5a6f0b8:                 throw new AssertionError(h.getClass());
1:b1ed2d1:             }
1:b1ed2d1:         }
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * Exceptions that stop recursion early when we are sure that no answer
1:c270904:      * can be found.
1:c270904:      */
1:c270904:     static abstract class StopRecursion extends Exception
1:c270904:     {
1:c270904:         static class BadRange extends StopRecursion
1:c270904:         {
1:c270904:             public BadRange(){ super(); }
1:c270904:         }
1:c270904: 
1:c270904:         static class InvalidHash extends StopRecursion
1:c270904:         {
1:c270904:             public InvalidHash(){ super(); }
1:c270904:         }
1:c270904: 
1:c270904:         static class TooDeep extends StopRecursion
1:c270904:         {
1:c270904:             public TooDeep(){ super(); }
1:c270904:         }
1:c270904:     }
1:c270904: }
============================================================================
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:e3b34dc
commit:413e48e
commit:eb4fa4a
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.base.Preconditions;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
1:     /** The top level range that this MerkleTree covers. */
1:     public final Range<Token> fullRange;
1:     private final IPartitioner partitioner;
/////////////////////////////////////////////////////////////////////////
1:             out.writeUTF(mt.partitioner.getClass().getCanonicalName());
1:             // full range
0:             Token.serializer.serialize(mt.fullRange.left, out);
0:             Token.serializer.serialize(mt.fullRange.right, out);
/////////////////////////////////////////////////////////////////////////
1:             IPartitioner partitioner;
1:             try
1:             {
1:                 partitioner = FBUtilities.newPartitioner(in.readUTF());
1:             }
1:             catch (ConfigurationException e)
1:             {
1:                 throw new IOException(e);
1:             }
1: 
1:             // full range
0:             Token left = Token.serializer.deserialize(in);
0:             Token right = Token.serializer.deserialize(in);
0:             Range<Token> fullRange = new Range<>(left, right, partitioner);
1: 
1:             MerkleTree mt = new MerkleTree(partitioner, fullRange, hashdepth, maxsize);
/////////////////////////////////////////////////////////////////////////
1:             long size = 1 // mt.hashdepth
0:                  + TypeSizes.NATIVE.sizeof(mt.partitioner.getClass().getCanonicalName());
1: 
1:             // full range
0:             size += Token.serializer.serializedSize(mt.fullRange.left, TypeSizes.NATIVE);
0:             size += Token.serializer.serializedSize(mt.fullRange.right, TypeSizes.NATIVE);
1: 
1:             size += Hashable.serializer.serializedSize(mt.root, version);
1:             return size;
/////////////////////////////////////////////////////////////////////////
1:         this.fullRange = Preconditions.checkNotNull(range);
1:         this.partitioner = Preconditions.checkNotNull(partitioner);
/////////////////////////////////////////////////////////////////////////
commit:29d97dc
/////////////////////////////////////////////////////////////////////////
0:             return 1 // mt.hashdepth
commit:587cb58
/////////////////////////////////////////////////////////////////////////
0:                 Token.serializer.serialize(inner.token, dos);
/////////////////////////////////////////////////////////////////////////
0:                 Token token = Token.serializer.deserialize(dis);
/////////////////////////////////////////////////////////////////////////
0:                 size += Token.serializer.serializedSize(inner.token, DBTypeSizes.NATIVE)
commit:f81cc74
/////////////////////////////////////////////////////////////////////////
1:     static abstract class Hashable implements Serializable
author:Paulo Motta
-------------------------------------------------------------------------------
commit:c70ce63
/////////////////////////////////////////////////////////////////////////
1:     public long rowCount()
1:     {
1:         long count = 0;
1:         for (TreeRange range : new TreeRangeIterator(this))
1:         {
1:             count += range.hashable.rowsInRange;
1:         }
1:         return count;
1:     }
1: 
author:Robert Stupp
-------------------------------------------------------------------------------
commit:0f5e780
/////////////////////////////////////////////////////////////////////////
1:         while (true)
1:             if (hashable instanceof Leaf)
1:             {
1:                 // we've reached a hash: wrap it up and deliver it
1:                 return new TreeRange(this, pleft, pright, depth, hashable);
1:             }
1:             // else: node.
1:             Inner node = (Inner) hashable;
1:             depth = inc(depth);
1:             if (Range.contains(pleft, node.token, t))
1:             { // left child contains token
1:                 hashable = node.lchild;
1:                 pright = node.token;
1:             }
1:             else
1:             { // else: right child contains token
1:                 hashable = node.rchild;
1:                 pleft = node.token;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         while (true)
1:             if (current instanceof Leaf)
1:             {
1:                 if (!find.contains(activeRange))
1:                     // we are not fully contained in this range!
1:                     throw new StopRecursion.BadRange();
1:                 return current;
1:             }
1:             // else: node.
1: 
1:             Inner node = (Inner) current;
1:             Range<Token> leftRange = new Range<>(activeRange.left, node.token);
1:             Range<Token> rightRange = new Range<>(node.token, activeRange.right);
1: 
1:             if (find.contains(activeRange))
1:                 // this node is fully contained in the range
1:                 return node.calc();
1: 
1:             // else: one of our children contains the range
1: 
1:             if (leftRange.contains(find))
1:             { // left child contains/matches the range
1:                 current = node.lchild;
1:                 activeRange = leftRange;
1:             }
1:             else if (rightRange.contains(find))
1:             { // right child contains/matches the range
1:                 current = node.rchild;
1:                 activeRange = rightRange;
1:             }
1:             else
1:             {
1:             }
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:489a9e8
/////////////////////////////////////////////////////////////////////////
author:Bharatendra Boddu
-------------------------------------------------------------------------------
commit:90e0013
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.net.MessagingService;
/////////////////////////////////////////////////////////////////////////
1:                 if (version < MessagingService.VERSION_30)
1:                     if (inner.hash == null)
1:                         out.writeInt(-1);
1:                     else
1:                     {
1:                         out.writeInt(inner.hash.length);
1:                         out.write(inner.hash);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                 if (version < MessagingService.VERSION_30)
1:                 {
1:                     int hashLen = in.readInt();
1:                     byte[] hash = hashLen >= 0 ? new byte[hashLen] : null;
1:                     if (hash != null)
1:                         in.readFully(hash);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 long size = 0;
1:                 if (version < MessagingService.VERSION_30)
1:                 {
1:                     size += inner.hash == null
1:                                        ? TypeSizes.sizeof(-1)
1:                                        : TypeSizes.sizeof(inner.hash().length) + inner.hash().length;
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                     if (version < MessagingService.VERSION_30)
1:                         out.writeInt(-1);
1:                     else
1:                         out.writeByte(-1);
1:                     if (version < MessagingService.VERSION_30)
1:                         out.writeInt(leaf.hash.length);
1:                     else
1:                         out.writeByte(leaf.hash.length);
1:                 int hashLen = version < MessagingService.VERSION_30 ? in.readInt() : in.readByte();
/////////////////////////////////////////////////////////////////////////
1:                 long size = version < MessagingService.VERSION_30 ? TypeSizes.sizeof(1) : 1;
1:                 if (leaf.hash != null)
1:                 {
1:                     size += leaf.hash().length;
1:                 }
1:                 return size;
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
1:         public MerkleTree deserialize(DataInputPlus in, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1:                  + TypeSizes.sizeof(mt.maxsize)
1:                  + TypeSizes.sizeof(mt.size)
1:                  + TypeSizes.sizeof(mt.partitioner.getClass().getCanonicalName());
/////////////////////////////////////////////////////////////////////////
0:                 ? TypeSizes.sizeof(-1)
0:                         : TypeSizes.sizeof(inner.hash().length) + inner.hash().length;
/////////////////////////////////////////////////////////////////////////
0:                      ? TypeSizes.sizeof(-1)
0:                      : TypeSizes.sizeof(leaf.hash().length) + leaf.hash().length;
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:806facc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.IPartitionerDependentSerializer;
/////////////////////////////////////////////////////////////////////////
1:             Token.serializer.serialize(mt.fullRange.left, out, version);
1:             Token.serializer.serialize(mt.fullRange.right, out, version);
/////////////////////////////////////////////////////////////////////////
1:             Token left = Token.serializer.deserialize(in, partitioner, version);
1:             Token right = Token.serializer.deserialize(in, partitioner, version);
1:             mt.root = Hashable.serializer.deserialize(in, partitioner, version);
/////////////////////////////////////////////////////////////////////////
1:             size += Token.serializer.serializedSize(mt.fullRange.left, version);
1:             size += Token.serializer.serializedSize(mt.fullRange.right, version);
/////////////////////////////////////////////////////////////////////////
1:         private static class InnerSerializer implements IPartitionerDependentSerializer<Inner>
/////////////////////////////////////////////////////////////////////////
1:                 Token.serializer.serialize(inner.token, out, version);
1:             public Inner deserialize(DataInput in, IPartitioner p, int version) throws IOException
1:                 Token token = Token.serializer.deserialize(in, p, version);
1:                 Hashable lchild = Hashable.serializer.deserialize(in, p, version);
1:                 Hashable rchild = Hashable.serializer.deserialize(in, p, version);
/////////////////////////////////////////////////////////////////////////
1:                 size += Token.serializer.serializedSize(inner.token, version)
/////////////////////////////////////////////////////////////////////////
1:         private static class LeafSerializer implements IPartitionerDependentSerializer<Leaf>
/////////////////////////////////////////////////////////////////////////
1:             public Leaf deserialize(DataInput in, IPartitioner p, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1:         private static final IPartitionerDependentSerializer<Hashable> serializer = new HashableSerializer();
/////////////////////////////////////////////////////////////////////////
1:         private static class HashableSerializer implements IPartitionerDependentSerializer<Hashable>
/////////////////////////////////////////////////////////////////////////
1:             public Hashable deserialize(DataInput in, IPartitioner p, int version) throws IOException
1:                     return Inner.serializer.deserialize(in, p, version);
1:                     return Leaf.serializer.deserialize(in, p, version);
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1:             Range<Token> fullRange = new Range<>(left, right);
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputPlus;
/////////////////////////////////////////////////////////////////////////
1:         public void serialize(MerkleTree mt, DataOutputPlus out, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1:             public void serialize(Inner inner, DataOutputPlus out, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1:             public void serialize(Leaf leaf, DataOutputPlus out, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1:             public void serialize(Hashable h, DataOutputPlus out, int version) throws IOException
author:Benedict
-------------------------------------------------------------------------------
commit:18f0234
/////////////////////////////////////////////////////////////////////////
1:     private static final byte[] EMPTY_HASH = new byte[0];
/////////////////////////////////////////////////////////////////////////
1:         List<TreeRange> diff = new ArrayList<>();
1:         TreeDifference active = new TreeDifference(ltree.fullRange.left, ltree.fullRange.right, (byte)0);
1:         Hashable lnode = ltree.find(active);
1:         Hashable rnode = rtree.find(active);
1:         byte[] lhash = lnode.hash();
1:         byte[] rhash = rnode.hash();
1:         active.setSize(lnode.sizeOfRange(), rnode.sizeOfRange());
/////////////////////////////////////////////////////////////////////////
1:         TreeDifference left = new TreeDifference(active.left, midpoint, inc(active.depth));
1:         TreeDifference right = new TreeDifference(midpoint, active.right, inc(active.depth));
1:         byte[] lhash, rhash;
1:         Hashable lnode, rnode;
1:         lnode = ltree.find(left);
1:         rnode = rtree.find(left);
1:         lhash = lnode.hash();
1:         rhash = rnode.hash();
1:         left.setSize(lnode.sizeOfRange(), rnode.sizeOfRange());
1:         left.setRows(lnode.rowsInRange(), rnode.rowsInRange());
1: 
/////////////////////////////////////////////////////////////////////////
1:         lnode = ltree.find(right);
1:         rnode = rtree.find(right);
1:         lhash = lnode.hash();
1:         rhash = rnode.hash();
1:         right.setSize(lnode.sizeOfRange(), rnode.sizeOfRange());
1:         right.setRows(lnode.rowsInRange(), rnode.rowsInRange());
1: 
/////////////////////////////////////////////////////////////////////////
1:         return find(range).hash();
1:     }
1: 
1:     /**
1:      * Find the {@link Hashable} node that matches the given {@code range}.
1:      *
1:      * @param range Range to find
1:      * @return {@link Hashable} found. If nothing found, return {@link Leaf} with null hash.
1:      */
1:     private Hashable find(Range<Token> range)
1:     {
1:             return findHelper(root, new Range<Token>(fullRange.left, fullRange.right), range);
1:             return new Leaf();
1:     private Hashable findHelper(Hashable current, Range<Token> activeRange, Range<Token> find) throws StopRecursion
0:         if (current instanceof Leaf)
0:             if (!find.contains(activeRange))
0:             return current;
0:         Inner node = (Inner)current;
0:         Range<Token> leftRange = new Range<Token>(activeRange.left, node.token);
0:         Range<Token> rightRange = new Range<Token>(node.token, activeRange.right);
0:         if (find.contains(activeRange))
0:             return node.calc();
0:         // else: one of our children contains the range
1: 
0:         if (leftRange.contains(find))
0:             return findHelper(node.lchild, leftRange, find);
0:         else if (rightRange.contains(find))
0:             return findHelper(node.rchild, rightRange, find);
/////////////////////////////////////////////////////////////////////////
1:     public EstimatedHistogram histogramOfRowSizePerLeaf()
1:     {
1:         HistogramBuilder histbuild = new HistogramBuilder();
1:         for (TreeRange range : new TreeRangeIterator(this))
1:         {
1:             histbuild.add(range.hashable.sizeOfRange);
1:         }
1:         return histbuild.buildWithStdevRangesAroundMean();
1:     }
1: 
1:     public EstimatedHistogram histogramOfRowCountPerLeaf()
1:     {
1:         HistogramBuilder histbuild = new HistogramBuilder();
1:         for (TreeRange range : new TreeRangeIterator(this))
1:         {
1:             histbuild.add(range.hashable.rowsInRange);
1:         }
1:         return histbuild.buildWithStdevRangesAroundMean();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static class TreeDifference extends TreeRange
1:     {
1:         private static final long serialVersionUID = 6363654174549968183L;
1: 
1:         private long sizeOnLeft;
1:         private long sizeOnRight;
1:         private long rowsOnLeft;
1:         private long rowsOnRight;
1: 
1:         void setSize(long sizeOnLeft, long sizeOnRight)
1:         {
1:             this.sizeOnLeft = sizeOnLeft;
1:             this.sizeOnRight = sizeOnRight;
1:         }
1: 
1:         void setRows(long rowsOnLeft, long rowsOnRight)
1:         {
1:             this.rowsOnLeft = rowsOnLeft;
1:             this.rowsOnRight = rowsOnRight;
1:         }
1: 
1:         public long sizeOnLeft()
1:         {
1:             return sizeOnLeft;
1:         }
1: 
1:         public long sizeOnRight()
1:         {
1:             return sizeOnRight;
1:         }
1: 
1:         public long rowsOnLeft()
1:         {
1:             return rowsOnLeft;
1:         }
1: 
1:         public long rowsOnRight()
1:         {
1:             return rowsOnRight;
1:         }
1: 
1:         public TreeDifference(Token left, Token right, byte depth)
1:         {
1:             super(null, left, right, depth, null);
1:         }
1: 
1:         public long totalRows()
1:         {
1:             return rowsOnLeft + rowsOnRight;
1:         }
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             hashable.addHash(entry.hash, entry.size);
1:         }
1: 
1:         public void ensureHashInitialised()
1:         {
1:             assert tree != null : "Not intended for modification!";
1:             assert hashable instanceof Leaf;
1: 
1:             if (hashable.hash == null)
1:                 hashable.hash = EMPTY_HASH;
/////////////////////////////////////////////////////////////////////////
1:         Hashable calc()
1:         {
1:             if (hash == null)
1:             {
1:                 // hash and size haven't been calculated; calc children then compute
1:                 Hashable lnode = lchild.calc();
1:                 Hashable rnode = rchild.calc();
1:                 // cache the computed value
1:                 hash(lnode.hash, rnode.hash);
1:                 sizeOfRange = lnode.sizeOfRange + rnode.sizeOfRange;
1:                 rowsInRange = lnode.rowsInRange + rnode.rowsInRange;
1:             }
1:             return this;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 ? TypeSizes.NATIVE.sizeof(-1)
0:                         : TypeSizes.NATIVE.sizeof(inner.hash().length) + inner.hash().length;
1:                 + Hashable.serializer.serializedSize(inner.lchild, version)
1:                 + Hashable.serializer.serializedSize(inner.rchild, version);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public final long size;
1:         public RowHash(Token token, byte[] hash, long size)
1:             this.size = size;
1:             return "#<RowHash " + token + " " + Hashable.toString(hash) + " @ " + size + " bytes>";
/////////////////////////////////////////////////////////////////////////
1:         protected long sizeOfRange;
1:         protected long rowsInRange;
/////////////////////////////////////////////////////////////////////////
1:         public long sizeOfRange()
1:         {
1:             return sizeOfRange;
1:         }
1: 
1:         public long rowsInRange()
1:         {
1:             return rowsInRange;
1:         }
1: 
1:         Hashable calc()
1:         {
1:             return this;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         void addHash(byte[] righthash, long sizeOfRow)
1:             this.sizeOfRange += sizeOfRow;
1:             this.rowsInRange += 1;
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:60d9c7f
/////////////////////////////////////////////////////////////////////////
0:         public void serialize(MerkleTree mt, DataOutput out, int version) throws IOException
1:             out.writeByte(mt.hashdepth);
1:             out.writeLong(mt.maxsize);
1:             out.writeLong(mt.size);
1:             Hashable.serializer.serialize(mt.root, out, version);
0:         public MerkleTree deserialize(DataInput in, int version) throws IOException
1:             byte hashdepth = in.readByte();
1:             long maxsize = in.readLong();
1:             long size = in.readLong();
0:             mt.root = Hashable.serializer.deserialize(in, version);
/////////////////////////////////////////////////////////////////////////
0:             public void serialize(Inner inner, DataOutput out, int version) throws IOException
0:                     out.writeInt(-1);
0:                     out.writeInt(inner.hash.length);
0:                     out.write(inner.hash);
0:                 Token.serializer.serialize(inner.token, out);
1:                 Hashable.serializer.serialize(inner.lchild, out, version);
1:                 Hashable.serializer.serialize(inner.rchild, out, version);
0:             public Inner deserialize(DataInput in, int version) throws IOException
0:                 int hashLen = in.readInt();
1:                     in.readFully(hash);
0:                 Token token = Token.serializer.deserialize(in);
0:                 Hashable lchild = Hashable.serializer.deserialize(in, version);
0:                 Hashable rchild = Hashable.serializer.deserialize(in, version);
/////////////////////////////////////////////////////////////////////////
0:             public void serialize(Leaf leaf, DataOutput out, int version) throws IOException
0:                     out.writeInt(-1);
0:                     out.writeInt(leaf.hash.length);
1:                     out.write(leaf.hash);
0:             public Leaf deserialize(DataInput in, int version) throws IOException
0:                 int hashLen = in.readInt();
0:                     in.readFully(hash);
/////////////////////////////////////////////////////////////////////////
0:             public void serialize(Hashable h, DataOutput out, int version) throws IOException
1:                     out.writeByte(Inner.IDENT);
1:                     Inner.serializer.serialize((Inner)h, out, version);
1:                     out.writeByte(Leaf.IDENT);
1:                     Leaf.serializer.serialize((Leaf) h, out, version);
0:             public Hashable deserialize(DataInput in, int version) throws IOException
1:                 byte ident = in.readByte();
0:                     return Inner.serializer.deserialize(in, version);
0:                     return Leaf.serializer.deserialize(in, version);
commit:2ae5272
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.TypeSizes;
/////////////////////////////////////////////////////////////////////////
0:             return TypeSizes.NATIVE.sizeof(mt.hashdepth)
0:                  + TypeSizes.NATIVE.sizeof(mt.maxsize)
0:                  + TypeSizes.NATIVE.sizeof(mt.size)
/////////////////////////////////////////////////////////////////////////
0:                          ? TypeSizes.NATIVE.sizeof(-1)
0:                          : TypeSizes.NATIVE.sizeof(inner.hash().length) + inner.hash().length;
0:                 size += Token.serializer.serializedSize(inner.token, TypeSizes.NATIVE)
/////////////////////////////////////////////////////////////////////////
0:                      ? TypeSizes.NATIVE.sizeof(-1)
0:                      : TypeSizes.NATIVE.sizeof(leaf.hash().length) + leaf.hash().length;
commit:5b9fc26
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.DBTypeSizes;
/////////////////////////////////////////////////////////////////////////
1:         public long serializedSize(MerkleTree mt, int version)
0:             return DBTypeSizes.NATIVE.sizeof(mt.hashdepth)
0:                  + DBTypeSizes.NATIVE.sizeof(mt.maxsize)
0:                  + DBTypeSizes.NATIVE.sizeof(mt.size)
0:                  + Hashable.serializer.serializedSize(mt.root, version);
/////////////////////////////////////////////////////////////////////////
0:                 int size = inner.hash == null
0:                          ? DBTypeSizes.NATIVE.sizeof(-1)
0:                          : DBTypeSizes.NATIVE.sizeof(inner.hash().length) + inner.hash().length;
1: 
0:                 size += Token.serializer().serializedSize(inner.token, DBTypeSizes.NATIVE)
/////////////////////////////////////////////////////////////////////////
0:                 return leaf.hash == null
0:                      ? DBTypeSizes.NATIVE.sizeof(-1)
0:                      : DBTypeSizes.NATIVE.sizeof(leaf.hash().length) + leaf.hash().length;
commit:5a6f0b8
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataInput;
0: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.io.Serializable;
0: import org.apache.cassandra.db.DBConstants;
/////////////////////////////////////////////////////////////////////////
1:     public static class MerkleTreeSerializer implements IVersionedSerializer<MerkleTree>
0:         public void serialize(MerkleTree mt, DataOutput dos, int version) throws IOException
0:             dos.writeByte(mt.hashdepth);
0:             dos.writeLong(mt.maxsize);
0:             dos.writeLong(mt.size);
0:             Hashable.serializer.serialize(mt.root, dos, version);
0:         public MerkleTree deserialize(DataInput dis, int version) throws IOException
0:             byte hashdepth = dis.readByte();
0:             long maxsize = dis.readLong();
0:             long size = dis.readLong();
0:             MerkleTree mt = new MerkleTree(null, null, hashdepth, maxsize);
1:             mt.size = size;
0:             mt.root = Hashable.serializer.deserialize(dis, version);
1:             return mt;
1:         }
1: 
0:         public long serializedSize(MerkleTree merkleTree, int version)
1:         {
0:             return 1 + DBConstants.LONG_SIZE + DBConstants.LONG_SIZE + Hashable.serializer.serializedSize(merkleTree.root, version);
/////////////////////////////////////////////////////////////////////////
0:         private static class InnerSerializer implements IVersionedSerializer<Inner>
/////////////////////////////////////////////////////////////////////////
1: 
1:             public long serializedSize(Inner inner, int version)
1:             {
0:                 int size = inner.hash == null ? DBConstants.INT_SIZE : DBConstants.INT_SIZE + inner.hash.length;
0:                 size += Token.serializer().serializedSize(inner.token)
0:                         + Hashable.serializer.serializedSize(inner.lchild, version)
0:                         + Hashable.serializer.serializedSize(inner.rchild, version);
1:                 return size;
1:             }
/////////////////////////////////////////////////////////////////////////
0:         private static class LeafSerializer implements IVersionedSerializer<Leaf>
0:             public void serialize(Leaf leaf, DataOutput dos, int version) throws IOException
1:                 {
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             public Leaf deserialize(DataInput dis, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1: 
1:             public long serializedSize(Leaf leaf, int version)
1:             {
0:                 return leaf.hash == null ? DBConstants.INT_SIZE : DBConstants.INT_SIZE + leaf.hash.length;
1:             }
/////////////////////////////////////////////////////////////////////////
0:     static abstract class Hashable
/////////////////////////////////////////////////////////////////////////
0:                     Leaf.serializer.serialize((Leaf) h, dos, version);
/////////////////////////////////////////////////////////////////////////
0:                     return Leaf.serializer.deserialize(dis, version);
1:             public long serializedSize(Hashable h, int version)
1:                 if (h instanceof Inner)
1:                     return 1 + Inner.serializer.serializedSize((Inner) h, version);
1:                 else if (h instanceof Leaf)
1:                     return 1 + Leaf.serializer.serializedSize((Leaf) h, version);
1:                 throw new AssertionError(h.getClass());
commit:1c9637f
commit:d3c5dbd
commit:56302ce
/////////////////////////////////////////////////////////////////////////
0:     // TODO This is broken; Token serialization assumes system partitioner, so if this doesn't match all hell breaks loose
commit:84eeb28
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.IVersionedSerializer;
/////////////////////////////////////////////////////////////////////////
0:     public static class MerkleTreeSerializer
/////////////////////////////////////////////////////////////////////////
0:         private static InnerSerializer serializer = new InnerSerializer();
/////////////////////////////////////////////////////////////////////////
0:         private static class InnerSerializer
0:             public void serialize(Inner inner, DataOutput dos, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:             public Inner deserialize(DataInput dis, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         private static LeafSerializer serializer = new LeafSerializer();
/////////////////////////////////////////////////////////////////////////
0:         private static class LeafSerializer
0:             public void serialize(Leaf leaf, DataOutput dos) throws IOException
/////////////////////////////////////////////////////////////////////////
0:             public Leaf deserialize(DataInput dis) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         private static IVersionedSerializer<Hashable> serializer = new HashableSerializer();
/////////////////////////////////////////////////////////////////////////
0:         private static class HashableSerializer implements IVersionedSerializer<Hashable>
0:             public void serialize(Hashable h, DataOutput dos, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:                     Leaf.serializer.serialize((Leaf)h, dos);
0:             public Hashable deserialize(DataInput dis, int version) throws IOException
0:                     return Leaf.serializer.deserialize(dis);
1: 
0:             public long serializedSize(Hashable hashable, int version)
1:             {
0:                 throw new UnsupportedOperationException();
1:             }
commit:5001907
/////////////////////////////////////////////////////////////////////////
commit:5e75a7f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e98eb1c
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
1: 
0: import com.google.common.collect.AbstractIterator;
1: import com.google.common.collect.PeekingIterator;
commit:187761a
/////////////////////////////////////////////////////////////////////////
0:             return "[" + FBUtilities.bytesToHex(hash) + "]";
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: import java.util.ArrayDeque;
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.Iterator;
0: import java.util.List;
1: 
1: import org.apache.cassandra.dht.IPartitioner;
1: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.dht.Token;
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:             this.token = token;      
1:             this.hash  = hash;
/////////////////////////////////////////////////////////////////////////
0:             return "[" + FBUtilities.bytesToHex(ByteBuffer.wrap(hash)) + "]";
commit:30f0216
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Token midpoint = ltree.partitioner().midpoint(active.left, active.right);
0:         TreeRange left = new TreeRange(null, active.left, midpoint, inc(active.depth), null);
0:         TreeRange right = new TreeRange(null, midpoint, active.right, inc(active.depth), null);
/////////////////////////////////////////////////////////////////////////
0:         Range leftactive = new Range(active.left, node.token);
0:         Range rightactive = new Range(node.token, active.right);
/////////////////////////////////////////////////////////////////////////
1:                 TreeRange left = new TreeRange(tree, active.left, node.token, inc(active.depth), node.lchild);
1:                 TreeRange right = new TreeRange(tree, node.token, active.right, inc(active.depth), node.rchild);
commit:746be67
/////////////////////////////////////////////////////////////////////////
1:     public static final byte RECOMMENDED_DEPTH = Byte.MAX_VALUE - 1;
/////////////////////////////////////////////////////////////////////////
1:         assert hashdepth < Byte.MAX_VALUE;
commit:616ab64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         invalidateHelper(root, partitioner.getMinimumToken(), t);
1:     private void invalidateHelper(Hashable hashable, Token pleft, Token t)
/////////////////////////////////////////////////////////////////////////
1:             invalidateHelper(node.lchild, pleft, t);
1:             invalidateHelper(node.rchild, node.token, t);
/////////////////////////////////////////////////////////////////////////
0:     private byte[] hashHelper(Hashable hashable, Range active, Range range) throws StopRecursion
/////////////////////////////////////////////////////////////////////////
1:     private Hashable splitHelper(Hashable hashable, Token pleft, Token pright, byte depth, Token t) throws StopRecursion.TooDeep
/////////////////////////////////////////////////////////////////////////
0:         root = compactHelper(root, t);
0:     private Hashable compactHelper(Hashable hashable, Token t)
/////////////////////////////////////////////////////////////////////////
0:             node.lchild(compactHelper(node.lchild(), t));
0:             node.rchild(compactHelper(node.rchild(), t));
/////////////////////////////////////////////////////////////////////////
1:         public static final long serialVersionUID = 1L;
/////////////////////////////////////////////////////////////////////////
0:                 return consume(left, right, entries);
/////////////////////////////////////////////////////////////////////////
0:         private byte[] consume(Token left, Token right, PeekingIterator<RowHash> entries)
/////////////////////////////////////////////////////////////////////////
1:         public static final long serialVersionUID = 1L;
/////////////////////////////////////////////////////////////////////////
1:         public static final long serialVersionUID = 1L;
commit:71084e3
/////////////////////////////////////////////////////////////////////////
1:     public static List<TreeRange> difference(MerkleTree ltree, MerkleTree rtree)
0:         List<TreeRange> diff = new ArrayList<TreeRange>();
0:         TreeRange active = new TreeRange(null, mintoken, mintoken, (byte)0, null);
/////////////////////////////////////////////////////////////////////////
1:     static int differenceHelper(MerkleTree ltree, MerkleTree rtree, List<TreeRange> diff, TreeRange active)
0:         TreeRange left = new TreeRange(null, active.left(), midpoint, inc(active.depth), null);
0:         TreeRange right = new TreeRange(null, midpoint, active.right(), inc(active.depth), null);
/////////////////////////////////////////////////////////////////////////
1:      * will allow someone to modify the hash. Alternatively, a TreeRange
1:      * may be created with a null tree, indicating that it is read only.
/////////////////////////////////////////////////////////////////////////
1:             assert tree != null : "Not intended for modification!";
/////////////////////////////////////////////////////////////////////////
1:             assert tree != null : "Not intended for modification!";
/////////////////////////////////////////////////////////////////////////
1:             return buff.append(">").toString();
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:e4b3d40
/////////////////////////////////////////////////////////////////////////
1:         if (active.depth == Byte.MAX_VALUE)
1:             return CONSISTENT;
1: 
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * because all hashing internal to the tree is accomplished using XOR.
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             this.token = token;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:                 if (h instanceof Inner)
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
1:  *
0:  * because all hashing internal to the tree is accomplished using XOR.
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             this.token = token;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:                 if (h instanceof Inner)
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
1:         private static final InnerSerializer serializer = new InnerSerializer();
/////////////////////////////////////////////////////////////////////////
1:         private static final LeafSerializer serializer = new LeafSerializer();
/////////////////////////////////////////////////////////////////////////
0:         private static final IVersionedSerializer<Hashable> serializer = new HashableSerializer();
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
commit:554223b
/////////////////////////////////////////////////////////////////////////
0:     public transient Range<Token> fullRange;
/////////////////////////////////////////////////////////////////////////
1:     public MerkleTree(IPartitioner partitioner, Range<Token> range, byte hashdepth, long maxsize)
/////////////////////////////////////////////////////////////////////////
1:     public byte[] hash(Range<Token> range)
0:             return hashHelper(root, new Range<Token>(fullRange.left, fullRange.right), range);
/////////////////////////////////////////////////////////////////////////
0:     private byte[] hashHelper(Hashable hashable, Range<Token> active, Range<Token> range) throws StopRecursion
/////////////////////////////////////////////////////////////////////////
0:         Range<Token> leftactive = new Range<Token>(active.left, node.token);
0:         Range<Token> rightactive = new Range<Token>(node.token, active.right);
/////////////////////////////////////////////////////////////////////////
1:     public static class TreeRange extends Range<Token>
commit:21bc3c2
/////////////////////////////////////////////////////////////////////////
1:         if (midpoint.equals(left) || midpoint.equals(right))
1:             return new Leaf();
1: 
1:         Hashable lchild =  initHelper(left, midpoint, inc(depth), max);
1:         Hashable rchild =  initHelper(midpoint, right, inc(depth), max);
commit:972ec74
/////////////////////////////////////////////////////////////////////////
1:             Token midpoint = partitioner.midpoint(pleft, pright);
1: 
1:             // We should not create a non-sensical range where start and end are the same token (this is non-sensical because range are
1:             // start exclusive). Note that we shouldn't hit that unless the full range is very small or we are fairly deep
1:             if (midpoint.equals(pleft) || midpoint.equals(pright))
1:                 throw new StopRecursion.TooDeep();
1: 
/////////////////////////////////////////////////////////////////////////
commit:dc89826
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * The top level range that this MerkleTree covers.
0:      * In a perfect world, this should be final and *not* transient. However
0:      * this would break serialization with version &gte; 0.7 because it uses
0:      * java serialization. We are moreover always shipping the fullRange will
0:      * the request so we can add it back post-deserialization (as for the
0:      * partitioner).
1:      */
0:     public transient Range fullRange;
1: 
/////////////////////////////////////////////////////////////////////////
0:                 MerkleTree mt = new MerkleTree(null, null, hashdepth, maxsize);
/////////////////////////////////////////////////////////////////////////
1:      * @param range the range this tree covers
0:     public MerkleTree(IPartitioner partitioner, Range range, byte hashdepth, long maxsize)
0:         this.fullRange = range;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         root = initHelper(fullRange.left, fullRange.right, (byte)0, depth);
/////////////////////////////////////////////////////////////////////////
1: 
0:         Hashable lchild = midpoint.equals(left) ? new Leaf() : initHelper(left, midpoint, inc(depth), max);
0:         Hashable rchild =  midpoint.equals(right) ? new Leaf() : initHelper(midpoint, right, inc(depth), max);
/////////////////////////////////////////////////////////////////////////
1:         if (!ltree.fullRange.equals(rtree.fullRange))
1:             throw new IllegalArgumentException("Difference only make sense on tree covering the same range (but " + ltree.fullRange + " != " + rtree.fullRange + ")");
1: 
0:         TreeRange active = new TreeRange(null, ltree.fullRange.left, ltree.fullRange.right, (byte)0, null);
/////////////////////////////////////////////////////////////////////////
1:     public TreeRange get(Token t)
1:         return getHelper(root, fullRange.left, fullRange.right, (byte)0, t);
/////////////////////////////////////////////////////////////////////////
1:      * Useful for testing.
1:         invalidateHelper(root, fullRange.left, t);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             return hashHelper(root, new Range(fullRange.left, fullRange.right), range);
/////////////////////////////////////////////////////////////////////////
1:             root = splitHelper(root, fullRange.left, fullRange.right, (byte)0, t);
/////////////////////////////////////////////////////////////////////////
1: 
0:         // FIXME: we are not really 'TooDeep', however we cannot say that the
0:         // split was successfull otherwise we could have a chance of infinite
0:         // loop given how we split.
0:         if (t.equals(node.token) || t.equals(pright))
1:             throw new StopRecursion.TooDeep();
1: 
/////////////////////////////////////////////////////////////////////////
1:     public TreeRangeIterator invalids()
1:         return new TreeRangeIterator(this);
/////////////////////////////////////////////////////////////////////////
1:      * Returns the leaf (range) of a given tree in increasing order.
1:      * If the full range covered by the tree don't wrap, then it will return the
1:      * ranges in increasing order.
1:      * If the full range wrap, the first *and* last range returned by the
1:      * iterator will be the wrapping range. It is the only case where the same
1:      * leaf will be returned twice.
1:         TreeRangeIterator(MerkleTree tree)
1:         {
1:             tovisit = new ArrayDeque<TreeRange>();
1:             tovisit.add(new TreeRange(tree, tree.fullRange.left, tree.fullRange.right, (byte)0, tree.root));
/////////////////////////////////////////////////////////////////////////
1:                 {
1:                     if (active.isWrapAround() && !tovisit.isEmpty())
1:                         // put to be taken again last
1:                         tovisit.addLast(active);
1:                 }
1: 
1:                 if (right.isWrapAround())
1:                 {
1:                     // whatever is on the left is 'after' everything we have seen so far (it has greater tokens)
1:                     tovisit.addLast(left);
1:                     tovisit.addFirst(right);
1:                 }
1:                 else
1:                 {
1:                     // do left first then right
1:                     tovisit.addFirst(right);
1:                     tovisit.addFirst(left);
1:                 }
commit:b1ed2d1
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.io.ObjectInputStream;
0: import java.io.ObjectOutputStream;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.ICompactSerializer;
0: import org.apache.cassandra.net.MessagingService;
/////////////////////////////////////////////////////////////////////////
1:     public static final MerkleTreeSerializer serializer = new MerkleTreeSerializer();
/////////////////////////////////////////////////////////////////////////
1:     
0:     public static class MerkleTreeSerializer implements ICompactSerializer<MerkleTree>
1:     {
0:         public void serialize(MerkleTree mt, DataOutputStream dos, int version) throws IOException
1:         {
0:             if (version == MessagingService.VERSION_07)
1:             {
0:                 ObjectOutputStream out = new ObjectOutputStream(dos);
0:                 out.writeObject(mt);
1:             }
1:             else
1:             {
0:                 dos.writeByte(mt.hashdepth);
0:                 dos.writeLong(mt.maxsize);
0:                 dos.writeLong(mt.size);
0:                 Hashable.serializer.serialize(mt.root, dos, version);
1:             }
1:         }
1: 
0:         public MerkleTree deserialize(DataInputStream dis, int version) throws IOException
1:         {
0:             if (version == MessagingService.VERSION_07)
1:             {
0:                 ObjectInputStream in = new ObjectInputStream(dis);
1:                 try
1:                 {
0:                     return (MerkleTree)in.readObject();
1:                 }
0:                 catch (ClassNotFoundException ex)
1:                 {
0:                     throw new IOException(ex);
1:                 }
1:             }
1:             else
1:             {
0:                 byte hashdepth = dis.readByte();
0:                 long maxsize = dis.readLong();
0:                 long size = dis.readLong();
0:                 MerkleTree mt = new MerkleTree(null, hashdepth, maxsize);
0:                 mt.size = size;
0:                 mt.root = Hashable.serializer.deserialize(dis, version);
0:                 return mt;
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         static final byte IDENT = 2;
0:         private static ICompactSerializer<Inner> serializer = new InnerSerializer();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
0:         private static class InnerSerializer implements ICompactSerializer<Inner>
1:         {
0:             public void serialize(Inner inner, DataOutputStream dos, int version) throws IOException
1:             {
0:                 if (inner.hash == null)
0:                     dos.writeInt(-1);
1:                 else
1:                 {
0:                     dos.writeInt(inner.hash.length);
0:                     dos.write(inner.hash);
1:                 }
0:                 Token.serializer().serialize(inner.token, dos);
0:                 Hashable.serializer.serialize(inner.lchild, dos, version);
0:                 Hashable.serializer.serialize(inner.rchild, dos, version);
1:             }
1: 
0:             public Inner deserialize(DataInputStream dis, int version) throws IOException
1:             {
0:                 int hashLen = dis.readInt();
0:                 byte[] hash = hashLen >= 0 ? new byte[hashLen] : null;
1:                 if (hash != null)
0:                     dis.readFully(hash);
0:                 Token token = Token.serializer().deserialize(dis);
0:                 Hashable lchild = Hashable.serializer.deserialize(dis, version);
0:                 Hashable rchild = Hashable.serializer.deserialize(dis, version);
1:                 return new Inner(token, lchild, rchild);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         static final byte IDENT = 1;
0:         private static ICompactSerializer<Leaf> serializer = new LeafSerializer();
1:         
/////////////////////////////////////////////////////////////////////////
1: 
0:         private static class LeafSerializer implements ICompactSerializer<Leaf>
1:         {
0:             public void serialize(Leaf leaf, DataOutputStream dos, int version) throws IOException
1:             {
1:                 if (leaf.hash == null)
0:                     dos.writeInt(-1);
1:                 else
1:                 {
0:                     dos.writeInt(leaf.hash.length);
0:                     dos.write(leaf.hash);
1:                 }
1:             }
1: 
0:             public Leaf deserialize(DataInputStream dis, int version) throws IOException
1:             {
0:                 int hashLen = dis.readInt();
1:                 byte[] hash = hashLen < 0 ? null : new byte[hashLen];
0:                 if (hash != null)
0:                     dis.readFully(hash);
1:                 return new Leaf(hash);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
0:         private static ICompactSerializer<Hashable> serializer = new HashableSerializer();
/////////////////////////////////////////////////////////////////////////
1:         
0:         private static class HashableSerializer implements ICompactSerializer<Hashable>
1:         {
0:             public void serialize(Hashable h, DataOutputStream dos, int version) throws IOException
1:             {
0:                 if (h instanceof Inner) 
1:                 {
0:                     dos.writeByte(Inner.IDENT);
0:                     Inner.serializer.serialize((Inner)h, dos, version);
1:                 }
1:                 else if (h instanceof Leaf)
1:                 {
0:                     dos.writeByte(Leaf.IDENT);
0:                     Leaf.serializer.serialize((Leaf)h, dos, version);
1:                 }
1:                 else
1:                     throw new IOException("Unexpected Hashable: " + h.getClass().getCanonicalName());
1:             }
1: 
0:             public Hashable deserialize(DataInputStream dis, int version) throws IOException
1:             {
0:                 byte ident = dis.readByte();
1:                 if (Inner.IDENT == ident)
0:                     return Inner.serializer.deserialize(dis, version);
1:                 else if (Leaf.IDENT == ident)
0:                     return Leaf.serializer.deserialize(dis, version);
1:                 else
1:                     throw new IOException("Unexpected Hashable: " + ident);
1:             }
1:         }
author:Eric Evans
-------------------------------------------------------------------------------
commit:2ede7fc
/////////////////////////////////////////////////////////////////////////
1:             return "[" + Hex.bytesToHex(hash) + "]";
author:Jun Rao
-------------------------------------------------------------------------------
commit:f2413f7
/////////////////////////////////////////////////////////////////////////
1:  * A MerkleTree is a full binary tree that represents a perfect binary tree of
1:  * 
1:  * The hash values of the inner nodes of the MerkleTree are calculated lazily based
1:  * on their children when the hash of a range is requested with hash(range).
0:  * because all hashing internal to the tree is accomplished using XOR. 
commit:c52be53
/////////////////////////////////////////////////////////////////////////
1:  * Inputs passed to TreeRange.validate should be calculated using a very secure hash,
0:  * because all hashing internal to the tree is accomplished using XOR.
1:     private static final long serialVersionUID = 2L;
0:     public static final byte RECOMMENDED_DEPTH = Byte.MAX_VALUE;
1:     private long maxsize;
1:     private long size;
/////////////////////////////////////////////////////////////////////////
0:     public MerkleTree(IPartitioner partitioner, byte hashdepth, long maxsize)
/////////////////////////////////////////////////////////////////////////
1:      * Initializes this tree by splitting it until hashdepth is reached,
1:      * or until an additional level of splits would violate maxsize.
1:      * NB: Replaces all nodes in the tree.
1:         // determine the depth to which we can safely split the tree
1:         byte sizedepth = (byte)(Math.log10(maxsize) / Math.log10(2));
1:         byte depth = (byte)Math.min(sizedepth, hashdepth);
0:         Token mintoken = partitioner.getMinimumToken();
0:         root = initHelper(mintoken, mintoken, (byte)0, depth);
1:         size = (long)Math.pow(2, depth);
1:     }
1:     private Hashable initHelper(Token left, Token right, byte depth, byte max)
1:     {
1:         if (depth == max)
1:             // we've reached the leaves
1:             return new Leaf();
1:         Token midpoint = partitioner.midpoint(left, right);
0:         Hashable lchild = initHelper(left, midpoint, inc(depth), max);
0:         Hashable rchild = initHelper(midpoint, right, inc(depth), max);
1:         return new Inner(midpoint, lchild, rchild);
/////////////////////////////////////////////////////////////////////////
1:     public long size()
1:     public long maxsize()
1:     public void maxsize(long maxsize)
/////////////////////////////////////////////////////////////////////////
1:         private final Hashable hashable;
/////////////////////////////////////////////////////////////////////////
1:          * @param entry Row to mix into the hash for this range.
1:         public void addHash(RowHash entry)
0:             hashable.addHash(entry.hash);
1:         public void addAll(Iterator<RowHash> entries)
1:             while (entries.hasNext())
1:                 addHash(entries.next());
/////////////////////////////////////////////////////////////////////////
1:      * The byte[] hash value should contain a digest of the key and value of the row
1:      * created using a very strong hash function.
/////////////////////////////////////////////////////////////////////////
1:          * Mixes the given value into our hash. If our hash is null,
1:          * our hash will become the given value.
1:          */
0:         void addHash(byte[] righthash)
1:         {
1:             if (hash == null)
1:                 hash = righthash;
1:             else
1:                 hash = binaryHash(hash, righthash);
1:         }
1: 
1:         /**
1:             return FBUtilities.xor(left, right);
commit:c270904
/////////////////////////////////////////////////////////////////////////
1: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
1: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
1: */
1: package org.apache.cassandra.utils;
1: 
0: import java.io.Serializable;
0: import java.util.*;
0: import java.math.BigInteger;
1: 
0: import com.google.common.collect.AbstractIterator;
0: import com.google.common.collect.Iterators;
0: import com.google.common.collect.PeekingIterator;
1: 
0: import org.apache.cassandra.dht.*;
1: 
1: /**
1:  * A MerkleTree implemented as a binary tree.
1:  *
0:  * A MerkleTree is a full binary that represents a perfect binary tree of
1:  * depth 'hashdepth'. In a perfect binary tree, each leaf contains a
1:  * sequentially hashed range, and each inner node contains the binary hash of
1:  * its two children. In the MerkleTree, many ranges will not be split to the
1:  * full depth of the perfect binary tree: the leaves of this tree are Leaf objects,
1:  * which contain the computed values of the nodes that would be below them if
1:  * the tree were perfect.
1:  *
0:  * All nodes of the perfect tree are calculated using a MD5 hash: leaves are
0:  * sequential hashes of the rows that fall into the range they represent, and
0:  * inner nodes are a binary hash of their children.
1:  *
1:  * If two MerkleTrees have the same hashdepth, they represent a perfect tree
1:  * of the same depth, and can always be compared, regardless of size or splits.
1:  */
1: public class MerkleTree implements Serializable
1: {
1:     private static final long serialVersionUID = 1L;
1: 
0:     public static final byte RECOMMENDED_DEPTH = (byte)64;
1: 
1:     public static final int CONSISTENT = 0;
1:     public static final int FULLY_INCONSISTENT = 1;
1:     public static final int PARTIALLY_INCONSISTENT = 2;
1: 
0:     // cache of empty hash trees up to the maximum depth (0 to 127)
0:     public static final byte[][] EMPTIES = new byte[Byte.MAX_VALUE][];
0:     static {
0:         EMPTIES[0] = new byte[0];
0:         for (int i = 1; i < EMPTIES.length; i++)
1:         {
0:             EMPTIES[i] = Hashable.binaryHash(EMPTIES[i-1], EMPTIES[i-1]);
1:         }
1:     }
1: 
1:     public final byte hashdepth;
1: 
0:     private transient IPartitioner partitioner;
1: 
0:     private int maxsize;
0:     private int size;
1:     private Hashable root;
1: 
1:     /**
1:      * @param partitioner The partitioner in use.
1:      * @param hashdepth The maximum depth of the tree. 100/(2^depth) is the %
1:      *        of the key space covered by each subrange of a fully populated tree.
1:      * @param maxsize The maximum number of subranges in the tree.
1:      */
0:     public MerkleTree(IPartitioner partitioner, byte hashdepth, int maxsize)
1:     {
0:         this.partitioner = partitioner;
1:         this.hashdepth = hashdepth;
1:         this.maxsize = maxsize;
1: 
1:         size = 1;
1:         root = new Leaf(null);
1:     }
1: 
1:     static byte inc(byte in)
1:     {
1:         assert in < Byte.MAX_VALUE;
1:         return (byte)(in + 1);
1:     }
1: 
1:     /**
0:      * Initializes this tree by splitting it into maxsize ranges, or
0:      * until hashdepth is reached.
1:      *
0:      * TODO: could be optimized as breadth first generation of nodes.
1:      *
0:      * NB: asserts that the tree is of size 1.
1:      */
1:     public void init()
1:     {
0:         assert size() == 1;
1: 
0:         Queue<Range> ranges = new ArrayDeque<Range>();
0:         ranges.add(new Range(partitioner.getMinimumToken(),
0:                              partitioner.getMinimumToken()));
0:         while (true)
1:         {
0:             Range range = ranges.remove();
0:             Token mid = partitioner.midpoint(range.left(),
0:                                                    range.right());
0:             if (!split(mid))
0:                 // we've reached maxsize or hashdepth
1:                 return;
1: 
0:             ranges.add(new Range(range.left(), mid));
0:             ranges.add(new Range(mid, range.right()));
1:         }
1:     }
1: 
1:     Hashable root()
1:     {
1:         return root;
1:     }
1: 
1:     public IPartitioner partitioner()
1:     {
1:         return partitioner;
1:     }
1: 
1:     /**
1:      * The number of distinct ranges contained in this tree. This is a reasonable
1:      * measure of the memory usage of the tree (assuming 'this.order' is significant).
1:      */
0:     public int size()
1:     {
1:         return size;
1:     }
1: 
0:     public int maxsize()
1:     {
1:         return maxsize;
1:     }
1: 
0:     public void maxsize(int maxsize)
1:     {
1:         this.maxsize = maxsize;
1:     }
1: 
1:     /**
0:      * TODO: Find another way to use the local partitioner after serialization.
1:      */
0:     public void partitioner(IPartitioner partitioner)
1:     {
0:         this.partitioner = partitioner;
1:     }
1: 
1:     /**
1:      * @param ltree First tree.
1:      * @param rtree Second tree.
0:      * @param active Only ranges that intersect this range will be returned.
1:      * @return A list of the largest contiguous ranges where the given trees disagree.
1:      */
0:     public static List<Range> difference(MerkleTree ltree, MerkleTree rtree)
1:     {
0:         List<Range> diff = new ArrayList<Range>();
0:         Token mintoken = ltree.partitioner.getMinimumToken();
0:         Range active = new Range(mintoken, mintoken);
1:         
0:         byte[] lhash = ltree.hash(active);
0:         byte[] rhash = rtree.hash(active);
1: 
1:         if (lhash != null && rhash != null && !Arrays.equals(lhash, rhash))
1:         {
1:             if (FULLY_INCONSISTENT == differenceHelper(ltree, rtree, diff, active))
1:                 diff.add(active);
1:         }
1:         else if (lhash == null || rhash == null)
1:             diff.add(active);
1:         return diff;
1:     }
1: 
1:     /**
1:      * TODO: This function could be optimized into a depth first traversal of
1:      * the two trees in parallel.
1:      *
1:      * Takes two trees and a range for which they have hashes, but are inconsistent.
1:      * @return FULLY_INCONSISTENT if active is inconsistent, PARTIALLY_INCONSISTENT if only a subrange is inconsistent.
1:      */
0:     static int differenceHelper(MerkleTree ltree, MerkleTree rtree, List<Range> diff, Range active)
1:     {
0:         Token midpoint = ltree.partitioner().midpoint(active.left(), active.right());
0:         Range left = new Range(active.left(), midpoint);
0:         Range right = new Range(midpoint, active.right());
0:         byte[] lhash;
0:         byte[] rhash;
1:         
1:         // see if we should recurse left
0:         lhash = ltree.hash(left);
0:         rhash = rtree.hash(left);
1:         int ldiff = CONSISTENT;
1:         boolean lreso = lhash != null && rhash != null;
1:         if (lreso && !Arrays.equals(lhash, rhash))
1:             ldiff = differenceHelper(ltree, rtree, diff, left);
1:         else if (!lreso)
1:             ldiff = FULLY_INCONSISTENT;
1: 
1: 
1:         // see if we should recurse right
0:         lhash = ltree.hash(right);
0:         rhash = rtree.hash(right);
1:         int rdiff = CONSISTENT;
1:         boolean rreso = lhash != null && rhash != null;
1:         if (rreso && !Arrays.equals(lhash, rhash))
1:             rdiff = differenceHelper(ltree, rtree, diff, right);
1:         else if (!rreso)
1:             rdiff = FULLY_INCONSISTENT;
1: 
1:         if (ldiff == FULLY_INCONSISTENT && rdiff == FULLY_INCONSISTENT)
1:         {
1:             // both children are fully inconsistent
1:             return FULLY_INCONSISTENT;
1:         }
1:         else if (ldiff == FULLY_INCONSISTENT)
1:         {
1:             diff.add(left);
1:             return PARTIALLY_INCONSISTENT;
1:         }
1:         else if (rdiff == FULLY_INCONSISTENT)
1:         {
1:             diff.add(right);
1:             return PARTIALLY_INCONSISTENT;
1:         }
1:         return PARTIALLY_INCONSISTENT;
1:     }
1: 
1:     /**
1:      * For testing purposes.
1:      * Gets the smallest range containing the token.
1:      */
0:     TreeRange get(Token t)
1:     {
0:         Token mintoken = partitioner.getMinimumToken();
0:         return getHelper(root, mintoken, mintoken, (byte)0, t);
1:     }
1: 
1:     TreeRange getHelper(Hashable hashable, Token pleft, Token pright, byte depth, Token t)
1:     {
1:         if (hashable instanceof Leaf)
1:         {
0:             // we've reached a hash: wrap it up and deliver it
0:             return new TreeRange(this, pleft, pright, depth, hashable);
1:         }
1:         // else: node.
1:         
1:         Inner node = (Inner)hashable;
1:         if (Range.contains(pleft, node.token, t))
1:             // left child contains token
0:             return getHelper(node.lchild, pleft, node.token, inc(depth), t);
1:         // else: right child contains token
0:         return getHelper(node.rchild, node.token, pright, inc(depth), t);
1:     }
1: 
1:     /**
1:      * Invalidates the ranges containing the given token.
1:      */
1:     public void invalidate(Token t)
1:     {
0:         Token mintoken = partitioner.getMinimumToken();
0:         invalidateHelper(root, mintoken, mintoken, (byte)0, t);
1:     }
1: 
0:     public void invalidateHelper(Hashable hashable, Token pleft, Token pright, byte depth, Token t)
1:     {
1:         hashable.hash(null);
1:         if (hashable instanceof Leaf)
1:             return;
1:         // else: node.
1:         
1:         Inner node = (Inner)hashable;
1:         if (Range.contains(pleft, node.token, t))
1:             // left child contains token
0:             invalidateHelper(node.lchild, pleft, node.token, inc(depth), t);
1:         else
1:             // right child contains token
0:             invalidateHelper(node.rchild, node.token, pright, inc(depth), t);
1:     }
1: 
1:     /**
1:      * Hash the given range in the tree. The range must have been generated
1:      * with recursive applications of partitioner.midpoint().
1:      *
1:      * NB: Currently does not support wrapping ranges that do not end with
1:      * partitioner.getMinimumToken().
1:      *
1:      * @return Null if any subrange of the range is invalid, or if the exact
1:      *         range cannot be calculated using this tree.
1:      */
0:     public byte[] hash(Range range)
1:     {
0:         Token mintoken = partitioner.getMinimumToken();
1:         try
1:         {
0:             return hashHelper(root, new Range(mintoken, mintoken), range);
1:         }
1:         catch (StopRecursion e)
1:         {
0:             return null;
1:         }
1:     }
1: 
1:     /**
1:      * @throws StopRecursion If no match could be found for the range.
1:      */
0:     byte[] hashHelper(Hashable hashable, Range active, Range range) throws StopRecursion
1:     {
1:         if (hashable instanceof Leaf)
1:         {
0:             if (!range.contains(active))
0:                 // we are not fully contained in this range!
1:                 throw new StopRecursion.BadRange();
1:             return hashable.hash();
1:         }
1:         // else: node.
1:         
1:         Inner node = (Inner)hashable;
0:         Range leftactive = new Range(active.left(), node.token);
0:         Range rightactive = new Range(node.token, active.right());
1: 
0:         if (range.contains(active))
1:         {
0:             // this node is fully contained in the range
0:             if (node.hash() != null)
0:                 // we had a cached value
0:                 return node.hash();
0:             // continue recursing to hash our children
0:             byte[] lhash = hashHelper(node.lchild(), leftactive, range);
0:             byte[] rhash = hashHelper(node.rchild(), rightactive, range);
0:             // cache the computed value (even if it is null)
0:             node.hash(lhash, rhash);
0:             return node.hash();
0:         } // else: one of our children contains the range
1:         
0:         if (leftactive.contains(range))
0:             // left child contains/matches the range
0:             return hashHelper(node.lchild, leftactive, range);
0:         else if (rightactive.contains(range))
0:             // right child contains/matches the range
0:             return hashHelper(node.rchild, rightactive, range);
1:         else
1:             throw new StopRecursion.BadRange();
1:     }
1: 
1:     /**
1:      * Splits the range containing the given token, if no tree limits would be
1:      * violated. If the range would be split to a depth below hashdepth, or if
1:      * the tree already contains maxsize subranges, this operation will fail.
1:      *
1:      * @return True if the range was successfully split.
1:      */
1:     public boolean split(Token t)
1:     {
1:         if (!(size < maxsize))
1:             return false;
1: 
0:         Token mintoken = partitioner.getMinimumToken();
1:         try
1:         {
0:             root = splitHelper(root, mintoken, mintoken, (byte)0, t);
1:         }
1:         catch (StopRecursion.TooDeep e)
1:         {
1:             return false;
1:         }
1:         return true;
1:     }
1: 
0:     Hashable splitHelper(Hashable hashable, Token pleft, Token pright, byte depth, Token t) throws StopRecursion.TooDeep
1:     {
1:         if (depth >= hashdepth)
0:             throw new StopRecursion.TooDeep();
1: 
1:         if (hashable instanceof Leaf)
1:         {
1:             // split
1:             size++;
0:             Token midpoint = partitioner.midpoint(pleft, pright);
1:             return new Inner(midpoint, new Leaf(), new Leaf());
1:         }
1:         // else: node.
1: 
1:         // recurse on the matching child
1:         Inner node = (Inner)hashable;
1:         if (Range.contains(pleft, node.token, t))
1:             // left child contains token
1:             node.lchild(splitHelper(node.lchild, pleft, node.token, inc(depth), t));
1:         else
1:             // else: right child contains token
1:             node.rchild(splitHelper(node.rchild, node.token, pright, inc(depth), t));
1:         return node;
1:     }
1: 
1:     /**
0:      * Compacts the smallest subranges evenly split by the given token into a
0:      * single range.
1:      *
0:      * Asserts that the given Token falls between two compactable subranges.
1:      */
0:     public void compact(Token t)
1:     {
0:         Token mintoken = partitioner.getMinimumToken();
0:         root = compactHelper(root, mintoken, mintoken, t);
1:     }
1: 
0:     Hashable compactHelper(Hashable hashable, Token pleft, Token pright, Token t)
1:     {
0:         // we reached a Leaf without finding an Inner to compact
0:         assert !(hashable instanceof Leaf);
1: 
1:         Inner node = (Inner)hashable;
0:         int comp = t.compareTo(node.token);
0:         if (comp == 0)
1:         {
0:             // this is the node to compact
0:             assert node.lchild() instanceof Leaf && node.rchild() instanceof Leaf :
0:                 "Can only compact a subrange evenly split by the given token!";
1: 
0:             // hash our children together into a new value to replace ourself
0:             size--;
0:             return new Leaf(node.lchild().hash(), node.rchild().hash());
1:         }
0:         else if (comp < 0)
0:             // recurse to the left
0:             node.lchild(compactHelper(node.lchild(), pleft, node.token, t));
1:         else
0:             // recurse to the right
0:             node.rchild(compactHelper(node.rchild(), node.token, pright, t));
1:         return node;
1:     }
1: 
1:     /**
1:      * Returns a lazy iterator of invalid TreeRanges that need to be filled
1:      * in order to make the given Range valid.
1:      *
0:      * @param range The range to find invalid subranges for.
1:      */
0:     public TreeRangeIterator invalids(Range range)
1:     {
0:         return new TreeRangeIterator(this, range);
1:     }
1: 
1:     @Override
1:     public String toString()
1:     {
1:         StringBuilder buff = new StringBuilder();
1:         buff.append("#<MerkleTree root=");
1:         root.toString(buff, 8);
1:         buff.append(">");
1:         return buff.toString();
1:     }
1: 
1:     /**
1:      * The public interface to a range in the tree.
1:      *
1:      * NB: A TreeRange should not be returned by a public method unless the
1:      * parents of the range it represents are already invalidated, since it
0:      * will allow someone to modify the hash.
1:      */
0:     public static class TreeRange extends Range
1:     {
1:         private final MerkleTree tree;
1:         public final byte depth;
0:         public final Hashable hashable;
1: 
1:         TreeRange(MerkleTree tree, Token left, Token right, byte depth, Hashable hashable)
1:         {
1:             super(left, right);
1:             this.tree = tree;
1:             this.depth = depth;
1:             this.hashable = hashable;
1:         }
1: 
1:         public void hash(byte[] hash)
1:         {
1:             hashable.hash(hash);
1:         }
1: 
1:         public byte[] hash()
1:         {
1:             return hashable.hash();
1:         }
1: 
1:         /**
0:          * Consumes a collection of entries within this range.
1:          */
0:         public void validate(Collection<RowHash> entries)
1:         {
0:             PeekingIterator<RowHash> iter = Iterators.peekingIterator(entries.iterator());
0:             validate(iter);
1:         }
1: 
1:         /**
0:          * Consumes an iterator over entries within this range, setting the
0:          * value of this range's Leaf to the computed value.
1:          */
0:         public void validate(PeekingIterator<RowHash> entries)
1:         {
1:             assert hashable instanceof Leaf;
0:             byte[] roothash;
1:             try
1:             {
0:                 roothash = validateHelper(left(), right(), depth, entries);
1:             }
1:             catch (StopRecursion e)
1:             {
0:                 throw new RuntimeException("Iterator contained invalid entry!");
1:             }
1: 
0:             // check that all values were consumed from the iterator, and that
0:             // a valid hash could be generated 
0:             if (entries.hasNext() || roothash == null)
0:                 throw new RuntimeException("Bad iterator for " + this + "!");
0:             hashable.hash(roothash);
1:         }
1: 
1:         /**
0:          * Collects values from the given iterator that fall into the
0:          * range represented by left and right. Recurses until we reach
0:          * hashdepth, where hashes are added sequentially, and then binary
0:          * hashes the results back to the root.
1:          *
0:          * @param left The left token of the active range.
0:          * @param right The right token of the active range.
0:          * @param depth The depth of the active range.
0:          * @param entries A peek()able iterator.
1:          */
0:         private byte[] validateHelper(Token left, Token right, byte depth, PeekingIterator<RowHash> entries) throws StopRecursion.InvalidHash
1:         {
0:             if (entries.hasNext() && Range.contains(left, right, entries.peek().token))
1:             {
0:                 // see if we can recurse deeper
0:                 if (depth < tree.hashdepth)
1:                 {
0:                     Token midpoint = tree.partitioner().midpoint(left, right);
0:                     if (left.compareTo(midpoint) < 0 && midpoint.compareTo(right) < 0)
1:                     {
0:                         // we can recurse deeper
0:                         byte[] lhash = validateHelper(left, midpoint, inc(depth), entries);
0:                         byte[] rhash = validateHelper(midpoint, right, inc(depth), entries);
0:                         return Hashable.binaryHash(lhash, rhash);
1:                     }
0:                     // else: the Token impl. cannot provide more resolution for this range
1:                 }
1: 
0:                 // hash relevant values from the iterator, and add to the context
0:                 return consume(left, right, depth, entries);
1:             }
1:             else
1:             {
0:                 // this range is empty: return static hash value:
0:                 // the hash is the one generated by a binary tree of depth (tree.hashdepth-depth)
0:                 return EMPTIES[tree.hashdepth-depth];
1:             }
1:         }
1: 
1:         /**
0:          * Consumes and sequentially hashes values from the iterator that fall into the active
0:          * range. Should be called with an iterator that contains at least one matching entry.
1:          */
0:         private byte[] consume(Token left, Token right, byte depth, PeekingIterator<RowHash> entries)
1:         {
0:             byte[] sequentialHash = entries.next().hash;
0:             while (entries.hasNext() && Range.contains(left, right, entries.peek().token))
0:                 sequentialHash = Hashable.binaryHash(sequentialHash, entries.next().hash);
0:             return sequentialHash;
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             StringBuilder buff = new StringBuilder("#<TreeRange ");
1:             buff.append(super.toString()).append(" depth=").append(depth);
0:             return buff.append(" hash=").append(hashable.hash()).append(">").toString();
1:         }
1:     }
1: 
1:     /**
0:      * Performs a depth-first, inorder traversal of invalid nodes under the given root
0:      * and intersecting the given range.
1:      */
1:     public static class TreeRangeIterator extends AbstractIterator<TreeRange> implements Iterable<TreeRange>, PeekingIterator<TreeRange>
1:     {
1:         // stack of ranges to visit
1:         private final ArrayDeque<TreeRange> tovisit;
1:         // interesting range
0:         private final Range range;
1:         private final MerkleTree tree;
1:         
0:         TreeRangeIterator(MerkleTree tree, Range range)
1:         {
0:             Token mintoken = tree.partitioner().getMinimumToken();
0:             tovisit = new ArrayDeque<TreeRange>();
0:             tovisit.add(new TreeRange(tree, mintoken, mintoken, (byte)0, tree.root));
1: 
1:             this.tree = tree;
0:             this.range = range;
1:         }
1:         
1:         /**
1:          * Find the next TreeRange.
1:          *
1:          * @return The next TreeRange.
1:          */
1:         @Override
1:         public TreeRange computeNext()
1:         {
1:             while (!tovisit.isEmpty())
1:             {
1:                 TreeRange active = tovisit.pop();
1: 
0:                 if (active.hashable.hash() != null)
0:                     // skip valid ranges
0:                     continue;
1: 
1:                 if (active.hashable instanceof Leaf)
1:                     // found a leaf invalid range
1:                     return active;
1: 
1:                 Inner node = (Inner)active.hashable;
0:                 // push intersecting children onto the stack
0:                 TreeRange left = new TreeRange(tree, active.left(), node.token, inc(active.depth), node.lchild);
0:                 TreeRange right = new TreeRange(tree, node.token, active.right(), inc(active.depth), node.rchild);
0:                 if (right.intersects(range))
0:                     tovisit.push(right);
0:                 if (left.intersects(range))
0:                     tovisit.push(left);
1:                     
1:             }
1:             return endOfData();
1:         }
1:         
1:         public Iterator<TreeRange> iterator()
1:         {
1:             return this;
1:         }
1:     }
1: 
1:     /**
1:      * An inner node in the MerkleTree. Inners can contain cached hash values, which
1:      * are the binary hash of their two children.
1:      */
1:     static class Inner extends Hashable
1:     {
1:         public final Token token;
1:         private Hashable lchild;
1:         private Hashable rchild;
1: 
1:         /**
1:          * Constructs an Inner with the given token and children, and a null hash.
1:          */
1:         public Inner(Token token, Hashable lchild, Hashable rchild)
1:         {
1:             super(null);
0:             this.token = token;
1:             this.lchild = lchild;
1:             this.rchild = rchild;
1:         }
1: 
1:         public Hashable lchild()
1:         {
1:             return lchild;
1:         }
1: 
1:         public Hashable rchild()
1:         {
1:             return rchild;
1:         }
1: 
1:         public void lchild(Hashable child)
1:         {
1:             lchild = child;
1:         }
1: 
1:         public void rchild(Hashable child)
1:         {
1:             rchild = child;
1:         }
1: 
1:         /**
1:          * Recursive toString.
1:          */
1:         @Override
1:         public void toString(StringBuilder buff, int maxdepth)
1:         {
1:             buff.append("#<").append(getClass().getSimpleName());
1:             buff.append(" ").append(token);
1:             buff.append(" hash=").append(Hashable.toString(hash()));
1:             buff.append(" children=[");
1:             if (maxdepth < 1)
1:             {
1:                 buff.append("#");
1:             }
1:             else
1:             {
1:                 if (lchild == null)
1:                     buff.append("null");
1:                 else
1:                     lchild.toString(buff, maxdepth-1);
1:                 buff.append(" ");
1:                 if (rchild == null)
1:                     buff.append("null");
1:                 else
1:                     rchild.toString(buff, maxdepth-1);
1:             }
1:             buff.append("]>");
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             StringBuilder buff = new StringBuilder();
1:             toString(buff, 1);
1:             return buff.toString();
1:         }
1:     }
1: 
1:     /**
1:      * A leaf node in the MerkleTree. Because the MerkleTree represents a much
1:      * larger perfect binary tree of depth hashdepth, a Leaf object contains
1:      * the value that would be contained in the perfect tree at its position.
1:      *
1:      * When rows are added to the MerkleTree using TreeRange.validate(), the
1:      * tree extending below the Leaf is generated in memory, but only the root
1:      * is stored in the Leaf.
1:      */
1:     static class Leaf extends Hashable
1:     {
1:         /**
1:          * Constructs a null hash.
1:          */
1:         public Leaf()
1:         {
1:             super(null);
1:         }
1: 
1:         public Leaf(byte[] hash)
1:         {
1:             super(hash);
1:         }
1: 
0:         public Leaf(byte[] lefthash, byte[] righthash)
1:         {
0:             super(Hashable.binaryHash(lefthash, righthash));
1:         }
1: 
1:         @Override
1:         public void toString(StringBuilder buff, int maxdepth)
1:         {
1:             buff.append(toString());
1:         }
1:         
1:         @Override
1:         public String toString()
1:         {
1:             return "#<Leaf " + Hashable.toString(hash()) + ">";
1:         }
1:     }
1: 
1:     /**
1:      * Hash value representing a row, to be used to pass hashes to the MerkleTree.
0:      * The byte[] hash value should contain a digest of the key and value of the row.
1:      */
1:     public static class RowHash
1:     {
1:         public final Token token;
1:         public final byte[] hash;
0:         public RowHash(Token token, byte[] hash)
1:         {
0:             this.token = token;
1:             this.hash = hash;
1:         }
1:         
1:         @Override
1:         public String toString()
1:         {
0:             return "#<RowHash " + token + " " + Hashable.toString(hash) + ">";
1:         }
1:     }
1: 
1:     /**
1:      * Abstract class containing hashing logic, and containing a single hash field.
1:      */
0:     static abstract class Hashable implements Serializable
1:     {
1:         private static final long serialVersionUID = 1L;
1: 
1:         protected byte[] hash;
1: 
1:         protected Hashable(byte[] hash)
1:         {
1:             this.hash = hash;
1:         }
1: 
1:         public byte[] hash()
1:         {
1:             return hash;
1:         }
1: 
1:         void hash(byte[] hash)
1:         {
1:             this.hash = hash;
1:         }
1: 
1:         /**
1:          * Sets the value of this hash to binaryHash of its children.
1:          * @param lefthash Hash of left child.
1:          * @param righthash Hash of right child.
1:          */
1:         void hash(byte[] lefthash, byte[] righthash)
1:         {
1:             hash = binaryHash(lefthash, righthash);
1:         }
1: 
1:         /**
1:          * The primitive with which all hashing should be accomplished: hashes
1:          * a left and right value together.
1:          */
1:         static byte[] binaryHash(final byte[] left, final byte[] right)
1:         {
0:             if (left == null || right == null)
0:                 return null;
1:             else
0:                 return FBUtilities.hash("MD5", left, right);
1:         }
1: 
1:         public abstract void toString(StringBuilder buff, int maxdepth);
1:         
1:         public static String toString(byte[] hash)
1:         {
1:             if (hash == null)
1:                 return "null";
0:             return "[" + FBUtilities.bytesToHex(hash) + "]";
1:         }
1:     }
1: 
1:     /**
1:      * Exceptions that stop recursion early when we are sure that no answer
1:      * can be found.
1:      */
1:     static abstract class StopRecursion extends Exception
1:     {
1:         static class BadRange extends StopRecursion
1:         {
1:             public BadRange(){ super(); }
1:         }
1: 
1:         static class InvalidHash extends StopRecursion
1:         {
1:             public InvalidHash(){ super(); }
1:         }
1: 
1:         static class TooDeep extends StopRecursion
1:         {
1:             public TooDeep(){ super(); }
1:         }
1:     }
1: }
============================================================================