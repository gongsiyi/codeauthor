1:88edbed: /*
1:88edbed: * Licensed to the Apache Software Foundation (ASF) under one
1:88edbed: * or more contributor license agreements.  See the NOTICE file
1:88edbed: * distributed with this work for additional information
1:88edbed: * regarding copyright ownership.  The ASF licenses this file
1:88edbed: * to you under the Apache License, Version 2.0 (the
1:88edbed: * "License"); you may not use this file except in compliance
1:88edbed: * with the License.  You may obtain a copy of the License at
1:88edbed: *
1:88edbed: *    http://www.apache.org/licenses/LICENSE-2.0
1:88edbed: *
1:88edbed: * Unless required by applicable law or agreed to in writing,
1:88edbed: * software distributed under the License is distributed on an
1:88edbed: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:88edbed: * KIND, either express or implied.  See the License for the
1:88edbed: * specific language governing permissions and limitations
1:88edbed: * under the License.
1:88edbed: */
1:0c0c6e5: package org.apache.cassandra.utils;
13:0c0c6e5: 
1:a991b64: import java.io.*;
1:e7a385a: import java.nio.ByteBuffer;
1:6cb811b: import java.util.HashSet;
1:6cb811b: import java.util.Iterator;
1:18d8f26: import java.util.Random;
1:6cb811b: import java.util.Set;
1:9bb4d93: 
1:61384c5: import org.junit.*;
1:a991b64: 
1:18d8f26: import org.apache.cassandra.dht.IPartitioner;
1:18d8f26: import org.apache.cassandra.dht.Murmur3Partitioner;
1:a991b64: import org.apache.cassandra.io.util.BufferedDataOutputStreamPlus;
1:a15500e: import org.apache.cassandra.io.util.DataOutputBuffer;
1:16499ca: import org.apache.cassandra.io.util.DataOutputStreamPlus;
1:9bb4d93: import org.apache.cassandra.io.util.FileUtils;
1:18d8f26: import org.apache.cassandra.utils.IFilter.FilterKey;
1:18d8f26: import org.apache.cassandra.utils.KeyGenerator.RandomStringGenerator;
1:a15500e: 
1:0c0c6e5: public class BloomFilterTest
2:0c0c6e5: {
1:23fd75f:     public IFilter bfOldFormat;
1:23fd75f:     public IFilter bfInvHashes;
1:6cb811b: 
1:0c0c6e5:     public BloomFilterTest()
1:0c0c6e5:     {
1:61384c5: 
7:0c0c6e5:     }
1:18d8f26: 
1:23fd75f:     public static IFilter testSerialize(IFilter f, boolean oldBfHashOrder) throws IOException
1:6cb811b:     {
1:18d8f26:         f.add(FilterTestHelper.bytes("a"));
1:6cb811b:         DataOutputBuffer out = new DataOutputBuffer();
1:7f2c3a8:         FilterFactory.serialize(f, out);
1:9bb4d93: 
1:6cb811b:         ByteArrayInputStream in = new ByteArrayInputStream(out.getData(), 0, out.getLength());
1:23fd75f:         IFilter f2 = FilterFactory.deserialize(new DataInputStream(in), true, oldBfHashOrder);
1:6cb811b: 
1:18d8f26:         assert f2.isPresent(FilterTestHelper.bytes("a"));
1:18d8f26:         assert !f2.isPresent(FilterTestHelper.bytes("b"));
1:6cb811b:         return f2;
1:6cb811b:     }
1:6cb811b: 
1:6cb811b: 
1:97fc5cb:     @Before
1:61384c5:     public void setup()
1:0c0c6e5:     {
1:23fd75f:         bfOldFormat = FilterFactory.getFilter(10000L, FilterTestHelper.MAX_FAILURE_RATE, true, true);
1:23fd75f:         bfInvHashes = FilterFactory.getFilter(10000L, FilterTestHelper.MAX_FAILURE_RATE, true, false);
1:61384c5:     }
1:61384c5: 
1:61384c5:     @After
1:61384c5:     public void destroy()
1:61384c5:     {
1:23fd75f:         bfOldFormat.close();
1:23fd75f:         bfInvHashes.close();
1:0c0c6e5:     }
1:6cb811b: 
1:9bb4d93:     @Test(expected = UnsupportedOperationException.class)
1:5e4c5ce:     public void testBloomLimits1()
1:5e4c5ce:     {
1:5e4c5ce:         int maxBuckets = BloomCalculations.probs.length - 1;
1:5e4c5ce:         int maxK = BloomCalculations.probs[maxBuckets].length - 1;
1:5e4c5ce: 
1:5e4c5ce:         // possible
1:5e4c5ce:         BloomCalculations.computeBloomSpec(maxBuckets, BloomCalculations.probs[maxBuckets][maxK]);
1:5e4c5ce: 
1:5e4c5ce:         // impossible, throws
1:5e4c5ce:         BloomCalculations.computeBloomSpec(maxBuckets, BloomCalculations.probs[maxBuckets][maxK] / 2);
1:5e4c5ce:     }
1:5e4c5ce: 
5:0c0c6e5:     @Test
1:0c0c6e5:     public void testOne()
1:18d8f26:     {
1:23fd75f:         bfOldFormat.add(FilterTestHelper.bytes("a"));
1:23fd75f:         assert bfOldFormat.isPresent(FilterTestHelper.bytes("a"));
1:23fd75f:         assert !bfOldFormat.isPresent(FilterTestHelper.bytes("b"));
1:23fd75f: 
1:23fd75f:         bfInvHashes.add(FilterTestHelper.bytes("a"));
1:23fd75f:         assert bfInvHashes.isPresent(FilterTestHelper.bytes("a"));
1:23fd75f:         assert !bfInvHashes.isPresent(FilterTestHelper.bytes("b"));
1:0c0c6e5:     }
1:18d8f26: 
1:0c0c6e5:     @Test
1:0c0c6e5:     public void testFalsePositivesInt()
1:0c0c6e5:     {
1:23fd75f:         FilterTestHelper.testFalsePositives(bfOldFormat, FilterTestHelper.intKeys(), FilterTestHelper.randomKeys2());
1:23fd75f: 
1:23fd75f:         FilterTestHelper.testFalsePositives(bfInvHashes, FilterTestHelper.intKeys(), FilterTestHelper.randomKeys2());
1:0c0c6e5:     }
1:18d8f26: 
1:0c0c6e5:     @Test
1:0c0c6e5:     public void testFalsePositivesRandom()
1:0c0c6e5:     {
1:23fd75f:         FilterTestHelper.testFalsePositives(bfOldFormat, FilterTestHelper.randomKeys(), FilterTestHelper.randomKeys2());
1:23fd75f: 
1:23fd75f:         FilterTestHelper.testFalsePositives(bfInvHashes, FilterTestHelper.randomKeys(), FilterTestHelper.randomKeys2());
1:0c0c6e5:     }
1:18d8f26: 
1:0c0c6e5:     @Test
1:0c0c6e5:     public void testWords()
1:0c0c6e5:     {
1:0c0c6e5:         if (KeyGenerator.WordGenerator.WORDS == 0)
1:0c0c6e5:         {
1:0c0c6e5:             return;
1:0c0c6e5:         }
1:23fd75f:         IFilter bf2 = FilterFactory.getFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTestHelper.MAX_FAILURE_RATE, true, false);
1:0c0c6e5:         int skipEven = KeyGenerator.WordGenerator.WORDS % 2 == 0 ? 0 : 2;
1:6cb811b:         FilterTestHelper.testFalsePositives(bf2,
1:6cb811b:                                             new KeyGenerator.WordGenerator(skipEven, 2),
1:6cb811b:                                             new KeyGenerator.WordGenerator(1, 2));
1:61384c5:         bf2.close();
1:23fd75f: 
1:23fd75f:         // new, swapped hash values bloom filter
1:23fd75f:         bf2 = FilterFactory.getFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTestHelper.MAX_FAILURE_RATE, true, true);
1:23fd75f:         FilterTestHelper.testFalsePositives(bf2,
1:23fd75f:                                             new KeyGenerator.WordGenerator(skipEven, 2),
1:23fd75f:                                             new KeyGenerator.WordGenerator(1, 2));
1:23fd75f:         bf2.close();
1:0c0c6e5:     }
1:6cb811b: 
1:6cb811b:     @Test
1:0c0c6e5:     public void testSerialize() throws IOException
1:6cb811b:     {
1:23fd75f:         BloomFilterTest.testSerialize(bfOldFormat, true).close();
1:23fd75f: 
1:23fd75f:         BloomFilterTest.testSerialize(bfInvHashes, false).close();
1:6cb811b:     }
1:6cb811b: 
1:23fd75f:     @Test
1:23fd75f:     @Ignore
1:23fd75f:     public void testManyRandom()
1:23fd75f:     {
1:23fd75f:         testManyRandom(FilterTestHelper.randomKeys(), false);
1:23fd75f: 
1:23fd75f:         testManyRandom(FilterTestHelper.randomKeys(), true);
1:23fd75f:     }
1:23fd75f: 
1:23fd75f:     private static void testManyRandom(Iterator<ByteBuffer> keys, boolean oldBfHashOrder)
1:0c0c6e5:     {
1:6cb811b:         int MAX_HASH_COUNT = 128;
1:23fd75f:         Set<Long> hashes = new HashSet<>();
1:6cb811b:         long collisions = 0;
1:6cb811b:         while (keys.hasNext())
1:6cb811b:         {
1:6cb811b:             hashes.clear();
1:18d8f26:             FilterKey buf = FilterTestHelper.wrap(keys.next());
1:23fd75f:             BloomFilter bf = (BloomFilter) FilterFactory.getFilter(10, 1, false, oldBfHashOrder);
1:d765b24:             for (long hashIndex : bf.getHashBuckets(buf, MAX_HASH_COUNT, 1024 * 1024))
1:6cb811b:             {
1:6cb811b:                 hashes.add(hashIndex);
1:6cb811b:             }
1:6cb811b:             collisions += (MAX_HASH_COUNT - hashes.size());
1:61384c5:             bf.close();
1:6cb811b:         }
1:23fd75f:         Assert.assertTrue("collisions=" + collisions, collisions <= 100);
1:6cb811b:     }
1:9bb4d93: 
1:6cb811b:     @Test(expected = UnsupportedOperationException.class)
1:9bb4d93:     public void testOffHeapException()
1:9bb4d93:     {
1:23fd75f:         long numKeys = ((long)Integer.MAX_VALUE) * 64L + 1L; // approx 128 Billion
1:23fd75f:         FilterFactory.getFilter(numKeys, 0.01d, true, true).close();
1:9bb4d93:     }
1:9bb4d93: 
1:9bb4d93:     @Test
1:23fd75f:     public void compareCachedKeyOldHashOrder()
1:6cb811b:     {
1:23fd75f:         BloomFilter bf1 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, true);
1:23fd75f:         BloomFilter bf2 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, true);
1:23fd75f:         BloomFilter bf3 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, true);
1:23fd75f: 
1:23fd75f:         RandomStringGenerator gen1 = new KeyGenerator.RandomStringGenerator(new Random().nextInt(), FilterTestHelper.ELEMENTS);
1:23fd75f: 
1:23fd75f:         // make sure all bitsets are empty.
1:23fd75f:         BitSetTest.compare(bf1.bitset, bf2.bitset);
1:23fd75f:         BitSetTest.compare(bf1.bitset, bf3.bitset);
1:23fd75f: 
1:23fd75f:         while (gen1.hasNext())
1:23fd75f:         {
1:23fd75f:             ByteBuffer key = gen1.next();
1:23fd75f:             FilterKey cached = FilterTestHelper.wrapCached(key);
1:23fd75f:             bf1.add(FilterTestHelper.wrap(key));
1:23fd75f:             bf2.add(cached);
1:23fd75f:             bf3.add(cached);
1:23fd75f:         }
1:23fd75f: 
1:23fd75f:         BitSetTest.compare(bf1.bitset, bf2.bitset);
1:23fd75f:         BitSetTest.compare(bf1.bitset, bf3.bitset);
1:23fd75f:     }
1:23fd75f: 
1:23fd75f:     @Test
1:23fd75f:     public void compareCachedKeyNewHashOrder()
1:23fd75f:     {
1:23fd75f:         try (BloomFilter bf1 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, false);
1:23fd75f:              BloomFilter bf2 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, false);
1:23fd75f:              BloomFilter bf3 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, false))
1:a991b64:         {
1:a991b64:             RandomStringGenerator gen1 = new KeyGenerator.RandomStringGenerator(new Random().nextInt(), FilterTestHelper.ELEMENTS);
1:a991b64: 
1:a991b64:             // make sure all bitsets are empty.
1:a991b64:             BitSetTest.compare(bf1.bitset, bf2.bitset);
1:a991b64:             BitSetTest.compare(bf1.bitset, bf3.bitset);
1:a991b64: 
1:a991b64:             while (gen1.hasNext())
1:18d8f26:             {
1:a991b64:                 ByteBuffer key = gen1.next();
1:a991b64:                 FilterKey cached = FilterTestHelper.wrapCached(key);
1:a991b64:                 bf1.add(FilterTestHelper.wrap(key));
1:a991b64:                 bf2.add(cached);
1:a991b64:                 bf3.add(cached);
1:a991b64:             }
1:18d8f26: 
1:a991b64:             BitSetTest.compare(bf1.bitset, bf2.bitset);
1:a991b64:             BitSetTest.compare(bf1.bitset, bf3.bitset);
1:a991b64:         }
1:18d8f26:     }
1:18d8f26: 
1:18d8f26:     @Test
1:9bb4d93:     @Ignore
1:9bb4d93:     public void testHugeBFSerialization() throws IOException
1:9bb4d93:     {
1:23fd75f:         hugeBFSerialization(false);
1:23fd75f:         hugeBFSerialization(true);
1:23fd75f:     }
1:23fd75f: 
1:23fd75f:     static void hugeBFSerialization(boolean oldBfHashOrder) throws IOException
1:23fd75f:     {
1:9bb4d93:         ByteBuffer test = ByteBuffer.wrap(new byte[] {0, 1});
1:9bb4d93: 
1:9bb4d93:         File file = FileUtils.createTempFile("bloomFilterTest-", ".dat");
1:23fd75f:         BloomFilter filter = (BloomFilter) FilterFactory.getFilter(((long) Integer.MAX_VALUE / 8) + 1, 0.01d, true, oldBfHashOrder);
1:18d8f26:         filter.add(FilterTestHelper.wrap(test));
1:16499ca:         DataOutputStreamPlus out = new BufferedDataOutputStreamPlus(new FileOutputStream(file));
1:9bb4d93:         FilterFactory.serialize(filter, out);
1:9bb4d93:         filter.bitset.serialize(out);
1:9bb4d93:         out.close();
1:61384c5:         filter.close();
1:16499ca: 
1:9bb4d93:         DataInputStream in = new DataInputStream(new FileInputStream(file));
1:23fd75f:         BloomFilter filter2 = (BloomFilter) FilterFactory.deserialize(in, true, oldBfHashOrder);
1:18d8f26:         Assert.assertTrue(filter2.isPresent(FilterTestHelper.wrap(test)));
1:9bb4d93:         FileUtils.closeQuietly(in);
1:a991b64:         filter2.close();
1:18d8f26:     }
1:16499ca: 
1:18d8f26:     @Test
1:18d8f26:     public void testMurmur3FilterHash()
1:18d8f26:     {
1:18d8f26:         IPartitioner partitioner = new Murmur3Partitioner();
1:18d8f26:         Iterator<ByteBuffer> gen = new KeyGenerator.RandomStringGenerator(new Random().nextInt(), FilterTestHelper.ELEMENTS);
1:18d8f26:         long[] expected = new long[2];
1:18d8f26:         long[] actual = new long[2];
1:18d8f26:         while (gen.hasNext())
1:18d8f26:         {
1:18d8f26:             expected[0] = 1;
1:18d8f26:             expected[1] = 2;
1:18d8f26:             actual[0] = 3;
1:18d8f26:             actual[1] = 4;
1:18d8f26:             ByteBuffer key = gen.next();
1:18d8f26:             FilterKey expectedKey = FilterTestHelper.wrap(key);
1:18d8f26:             FilterKey actualKey = partitioner.decorateKey(key);
1:18d8f26:             actualKey.filterHash(actual);
1:18d8f26:             expectedKey.filterHash(expected);
1:18d8f26:             Assert.assertArrayEquals(expected, actual);
1:18d8f26:         }
1:18d8f26:     }
1:9bb4d93: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:b30cdd9
/////////////////////////////////////////////////////////////////////////
commit:83a43f1
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Assert;
author:Robert Stupp
-------------------------------------------------------------------------------
commit:23fd75f
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
0: import org.apache.cassandra.db.marshal.Int32Type;
/////////////////////////////////////////////////////////////////////////
1:     public IFilter bfOldFormat;
1:     public IFilter bfInvHashes;
1:     public static IFilter testSerialize(IFilter f, boolean oldBfHashOrder) throws IOException
1:         IFilter f2 = FilterFactory.deserialize(new DataInputStream(in), true, oldBfHashOrder);
/////////////////////////////////////////////////////////////////////////
1:         bfOldFormat = FilterFactory.getFilter(10000L, FilterTestHelper.MAX_FAILURE_RATE, true, true);
1:         bfInvHashes = FilterFactory.getFilter(10000L, FilterTestHelper.MAX_FAILURE_RATE, true, false);
1:         bfOldFormat.close();
1:         bfInvHashes.close();
/////////////////////////////////////////////////////////////////////////
1:         bfOldFormat.add(FilterTestHelper.bytes("a"));
1:         assert bfOldFormat.isPresent(FilterTestHelper.bytes("a"));
1:         assert !bfOldFormat.isPresent(FilterTestHelper.bytes("b"));
1: 
1:         bfInvHashes.add(FilterTestHelper.bytes("a"));
1:         assert bfInvHashes.isPresent(FilterTestHelper.bytes("a"));
1:         assert !bfInvHashes.isPresent(FilterTestHelper.bytes("b"));
1:         FilterTestHelper.testFalsePositives(bfOldFormat, FilterTestHelper.intKeys(), FilterTestHelper.randomKeys2());
1: 
1:         FilterTestHelper.testFalsePositives(bfInvHashes, FilterTestHelper.intKeys(), FilterTestHelper.randomKeys2());
1:         FilterTestHelper.testFalsePositives(bfOldFormat, FilterTestHelper.randomKeys(), FilterTestHelper.randomKeys2());
1: 
1:         FilterTestHelper.testFalsePositives(bfInvHashes, FilterTestHelper.randomKeys(), FilterTestHelper.randomKeys2());
/////////////////////////////////////////////////////////////////////////
1:         IFilter bf2 = FilterFactory.getFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTestHelper.MAX_FAILURE_RATE, true, false);
1: 
1:         // new, swapped hash values bloom filter
1:         bf2 = FilterFactory.getFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTestHelper.MAX_FAILURE_RATE, true, true);
1:         FilterTestHelper.testFalsePositives(bf2,
1:                                             new KeyGenerator.WordGenerator(skipEven, 2),
1:                                             new KeyGenerator.WordGenerator(1, 2));
1:         bf2.close();
1:         BloomFilterTest.testSerialize(bfOldFormat, true).close();
1: 
1:         BloomFilterTest.testSerialize(bfInvHashes, false).close();
1:     @Test
1:     @Ignore
1:     public void testManyRandom()
1:     {
1:         testManyRandom(FilterTestHelper.randomKeys(), false);
1: 
1:         testManyRandom(FilterTestHelper.randomKeys(), true);
1:     }
1: 
1:     private static void testManyRandom(Iterator<ByteBuffer> keys, boolean oldBfHashOrder)
1:         Set<Long> hashes = new HashSet<>();
1:             BloomFilter bf = (BloomFilter) FilterFactory.getFilter(10, 1, false, oldBfHashOrder);
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertTrue("collisions=" + collisions, collisions <= 100);
1:         long numKeys = ((long)Integer.MAX_VALUE) * 64L + 1L; // approx 128 Billion
1:         FilterFactory.getFilter(numKeys, 0.01d, true, true).close();
1:     public void compareCachedKeyOldHashOrder()
1:         BloomFilter bf1 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, true);
1:         BloomFilter bf2 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, true);
1:         BloomFilter bf3 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, true);
1: 
1:         RandomStringGenerator gen1 = new KeyGenerator.RandomStringGenerator(new Random().nextInt(), FilterTestHelper.ELEMENTS);
1: 
1:         // make sure all bitsets are empty.
1:         BitSetTest.compare(bf1.bitset, bf2.bitset);
1:         BitSetTest.compare(bf1.bitset, bf3.bitset);
1: 
1:         while (gen1.hasNext())
1:         {
1:             ByteBuffer key = gen1.next();
1:             FilterKey cached = FilterTestHelper.wrapCached(key);
1:             bf1.add(FilterTestHelper.wrap(key));
1:             bf2.add(cached);
1:             bf3.add(cached);
1:         }
1: 
1:         BitSetTest.compare(bf1.bitset, bf2.bitset);
1:         BitSetTest.compare(bf1.bitset, bf3.bitset);
1:     }
1: 
1:     @Test
1:     public void compareCachedKeyNewHashOrder()
1:     {
1:         try (BloomFilter bf1 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, false);
1:              BloomFilter bf2 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, false);
1:              BloomFilter bf3 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false, false))
/////////////////////////////////////////////////////////////////////////
1:         hugeBFSerialization(false);
1:         hugeBFSerialization(true);
1:     }
1: 
1:     static void hugeBFSerialization(boolean oldBfHashOrder) throws IOException
1:     {
1:         BloomFilter filter = (BloomFilter) FilterFactory.getFilter(((long) Integer.MAX_VALUE / 8) + 1, 0.01d, true, oldBfHashOrder);
/////////////////////////////////////////////////////////////////////////
1:         BloomFilter filter2 = (BloomFilter) FilterFactory.deserialize(in, true, oldBfHashOrder);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import java.io.*;
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.io.util.BufferedDataOutputStreamPlus;
/////////////////////////////////////////////////////////////////////////
0:         try (BloomFilter bf1 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false);
0:              BloomFilter bf2 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false);
0:              BloomFilter bf3 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false))
1:             RandomStringGenerator gen1 = new KeyGenerator.RandomStringGenerator(new Random().nextInt(), FilterTestHelper.ELEMENTS);
1:             // make sure all bitsets are empty.
1:             BitSetTest.compare(bf1.bitset, bf2.bitset);
1:             BitSetTest.compare(bf1.bitset, bf3.bitset);
1: 
1:             while (gen1.hasNext())
1:             {
1:                 ByteBuffer key = gen1.next();
1:                 FilterKey cached = FilterTestHelper.wrapCached(key);
1:                 bf1.add(FilterTestHelper.wrap(key));
1:                 bf2.add(cached);
1:                 bf3.add(cached);
1:             }
1: 
1:             BitSetTest.compare(bf1.bitset, bf2.bitset);
1:             BitSetTest.compare(bf1.bitset, bf3.bitset);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         BloomFilter filter = (BloomFilter) FilterFactory.getFilter(((long) Integer.MAX_VALUE / 8) + 1, 0.01d, true);
/////////////////////////////////////////////////////////////////////////
1:         filter2.close();
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:16499ca
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputStreamPlus;
0: import org.apache.cassandra.io.util.BufferedDataOutputStreamPlus;
/////////////////////////////////////////////////////////////////////////
1:         DataOutputStreamPlus out = new BufferedDataOutputStreamPlus(new FileOutputStream(file));
1: 
1: 
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:18d8f26
/////////////////////////////////////////////////////////////////////////
1: import java.util.Random;
1: import org.apache.cassandra.dht.IPartitioner;
1: import org.apache.cassandra.dht.Murmur3Partitioner;
1: import org.apache.cassandra.utils.IFilter.FilterKey;
1: import org.apache.cassandra.utils.KeyGenerator.RandomStringGenerator;
0: import org.apache.cassandra.utils.BloomFilter;
/////////////////////////////////////////////////////////////////////////
1:         f.add(FilterTestHelper.bytes("a"));
1:         assert f2.isPresent(FilterTestHelper.bytes("a"));
1:         assert !f2.isPresent(FilterTestHelper.bytes("b"));
/////////////////////////////////////////////////////////////////////////
0:         bf.add(FilterTestHelper.bytes("a"));
0:         assert bf.isPresent(FilterTestHelper.bytes("a"));
0:         assert !bf.isPresent(FilterTestHelper.bytes("b"));
/////////////////////////////////////////////////////////////////////////
1:             FilterKey buf = FilterTestHelper.wrap(keys.next());
/////////////////////////////////////////////////////////////////////////
0:     public void compareCachedKey()
1:     {
0:         BloomFilter bf1 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false);
0:         BloomFilter bf2 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false);
0:         BloomFilter bf3 = (BloomFilter) FilterFactory.getFilter(FilterTestHelper.ELEMENTS / 2, FilterTestHelper.MAX_FAILURE_RATE, false);
1: 
0:         RandomStringGenerator gen1 = new KeyGenerator.RandomStringGenerator(new Random().nextInt(), FilterTestHelper.ELEMENTS);
1: 
0:         // make sure all bitsets are empty.
0:         BitSetTest.compare(bf1.bitset, bf2.bitset);
0:         BitSetTest.compare(bf1.bitset, bf3.bitset);
1: 
0:         while (gen1.hasNext())
1:         {
0:             ByteBuffer key = gen1.next();
0:             FilterKey cached = FilterTestHelper.wrapCached(key);
0:             bf1.add(FilterTestHelper.wrap(key));
0:             bf2.add(cached);
0:             bf3.add(cached);
1:         }
1: 
0:         BitSetTest.compare(bf1.bitset, bf2.bitset);
0:         BitSetTest.compare(bf1.bitset, bf3.bitset);
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         filter.add(FilterTestHelper.wrap(test));
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertTrue(filter2.isPresent(FilterTestHelper.wrap(test)));
1:     
1:     @Test
1:     public void testMurmur3FilterHash()
1:     {
1:         IPartitioner partitioner = new Murmur3Partitioner();
1:         Iterator<ByteBuffer> gen = new KeyGenerator.RandomStringGenerator(new Random().nextInt(), FilterTestHelper.ELEMENTS);
1:         long[] expected = new long[2];
1:         long[] actual = new long[2];
1:         while (gen.hasNext())
1:         {
1:             expected[0] = 1;
1:             expected[1] = 2;
1:             actual[0] = 3;
1:             actual[1] = 4;
1:             ByteBuffer key = gen.next();
1:             FilterKey expectedKey = FilterTestHelper.wrap(key);
1:             FilterKey actualKey = partitioner.decorateKey(key);
1:             actualKey.filterHash(actual);
1:             expectedKey.filterHash(expected);
1:             Assert.assertArrayEquals(expected, actual);
1:         }
1:     }
commit:02c3489
commit:61384c5
/////////////////////////////////////////////////////////////////////////
1: import org.junit.*;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setup()
0:         bf = FilterFactory.getFilter(10000L, FilterTestHelper.MAX_FAILURE_RATE, true);
1:     }
1: 
1:     @After
1:     public void destroy()
1:     {
1:         bf.close();
/////////////////////////////////////////////////////////////////////////
1:         bf2.close();
0:         BloomFilterTest.testSerialize(bf).close();
/////////////////////////////////////////////////////////////////////////
0:             bf.close();
/////////////////////////////////////////////////////////////////////////
1:         filter.close();
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataOutputStreamAndChannel;
/////////////////////////////////////////////////////////////////////////
0:         DataOutputStreamAndChannel out = new DataOutputStreamAndChannel(new FileOutputStream(file));
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:5774ecb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         BloomFilter filter2 = (BloomFilter) FilterFactory.deserialize(in, true);
commit:ed6a5b9
commit:9bb4d93
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataOutputStream;
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.FileOutputStream;
0: import junit.framework.Assert;
1: 
0: import org.junit.Ignore;
1: import org.apache.cassandra.io.util.FileUtils;
0: import org.apache.cassandra.utils.FilterFactory.Type;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test(expected = UnsupportedOperationException.class)
1:     public void testOffHeapException()
1:     {
0:         long numKeys = (Integer.MAX_VALUE * 64) + 1; // approx 128 Billion
0:         FilterFactory.getFilter(numKeys, 0.01d, true);
1:     }
1: 
1:     @Test
1:     @Ignore
1:     public void testHugeBFSerialization() throws IOException
1:     {
1:         ByteBuffer test = ByteBuffer.wrap(new byte[] {0, 1});
1: 
1:         File file = FileUtils.createTempFile("bloomFilterTest-", ".dat");
0:         BloomFilter filter = (BloomFilter) FilterFactory.getFilter(((long)Integer.MAX_VALUE / 8) + 1, 0.01d, true);
0:         filter.add(test);
0:         DataOutputStream out = new DataOutputStream(new FileOutputStream(file));
1:         FilterFactory.serialize(filter, out);
1:         filter.bitset.serialize(out);
1:         out.close();
1:         
1:         DataInputStream in = new DataInputStream(new FileInputStream(file));
0:         BloomFilter filter2 = (BloomFilter) FilterFactory.deserialize(in, Type.MURMUR3, true);
0:         Assert.assertTrue(filter2.isPresent(test));
1:         FileUtils.closeQuietly(in);
1:     }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
1:         FilterFactory.serialize(f, out);
0:         IFilter f2 = FilterFactory.deserialize(new DataInputStream(in), true);
commit:a15500e
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
0: import java.io.DataInputStream;
1: import org.apache.cassandra.io.util.DataOutputBuffer;
1: 
0:     public IFilter bf;
0:     public static IFilter testSerialize(IFilter f) throws IOException
0:         IFilter f2 = FilterFactory.deserialize(new DataInputStream(in), FilterFactory.Type.MURMUR3, true);
/////////////////////////////////////////////////////////////////////////
0:         IFilter bf2 = FilterFactory.getFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTestHelper.MAX_FAILURE_RATE, true);
commit:dc37dea
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.KeyGenerator.WordGenerator;
/////////////////////////////////////////////////////////////////////////
0:         bf = FilterFactory.getFilter(10000L, FilterTestHelper.MAX_FAILURE_RATE, true);
/////////////////////////////////////////////////////////////////////////
0:         Filter f2 = FilterFactory.deserialize(new DataInputStream(in), FilterFactory.Type.MURMUR3, true);
/////////////////////////////////////////////////////////////////////////
0:         Filter bf2 = FilterFactory.getFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTestHelper.MAX_FAILURE_RATE, true);
/////////////////////////////////////////////////////////////////////////
0:             BloomFilter bf = (BloomFilter) FilterFactory.getFilter(10, 1, false);
commit:6cb811b
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.Set;
0: import java.io.ByteArrayInputStream;
0: import java.io.DataInputStream;
1: 
0: import org.apache.cassandra.io.util.DataOutputBuffer;
/////////////////////////////////////////////////////////////////////////
0:         bf = BloomFilter.getFilter(10000L, FilterTestHelper.MAX_FAILURE_RATE);
0:     public static BloomFilter testSerialize(BloomFilter f) throws IOException
1:     {
0:         f.add(ByteBufferUtil.bytes("a"));
1:         DataOutputBuffer out = new DataOutputBuffer();
0:         f.serializer().serialize(f, out);
1: 
1:         ByteArrayInputStream in = new ByteArrayInputStream(out.getData(), 0, out.getLength());
0:         BloomFilter f2 = f.serializer().deserialize(new DataInputStream(in));
1: 
0:         assert f2.isPresent(ByteBufferUtil.bytes("a"));
0:         assert !f2.isPresent(ByteBufferUtil.bytes("b"));
1:         return f2;
1:     }
1: 
1: 
1:     @Test(expected = UnsupportedOperationException.class)
/////////////////////////////////////////////////////////////////////////
0:         FilterTestHelper.testFalsePositives(bf, FilterTestHelper.intKeys(), FilterTestHelper.randomKeys2());
0:         FilterTestHelper.testFalsePositives(bf, FilterTestHelper.randomKeys(), FilterTestHelper.randomKeys2());
/////////////////////////////////////////////////////////////////////////
0:         BloomFilter bf2 = BloomFilter.getFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTestHelper.MAX_FAILURE_RATE);
1:         FilterTestHelper.testFalsePositives(bf2,
1:                                             new KeyGenerator.WordGenerator(skipEven, 2),
1:                                             new KeyGenerator.WordGenerator(1, 2));
0:         BloomFilterTest.testSerialize(bf);
1:     }
1: 
0:     public void testManyHashes(Iterator<ByteBuffer> keys)
1:     {
1:         int MAX_HASH_COUNT = 128;
0:         Set<Long> hashes = new HashSet<Long>();
1:         long collisions = 0;
1:         while (keys.hasNext())
1:         {
1:             hashes.clear();
0:             ByteBuffer buf = keys.next();
0:             for (long hashIndex : BloomFilter.getHashBuckets(buf, MAX_HASH_COUNT, 1024 * 1024))
1:             {
1:                 hashes.add(hashIndex);
1:             }
1:             collisions += (MAX_HASH_COUNT - hashes.size());
1:         }
0:         assert collisions <= 100;
1:     }
1: 
1:     @Test
0:     public void testManyRandom()
1:     {
0:         testManyHashes(FilterTestHelper.randomKeys());
commit:8358669
/////////////////////////////////////////////////////////////////////////
0:         bf.add(ByteBufferUtil.bytes("a"));
0:         assert bf.isPresent(ByteBufferUtil.bytes("a"));
0:         assert !bf.isPresent(ByteBufferUtil.bytes("b"));
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0:         bf.add(ByteBuffer.wrap("a".getBytes()));
0:         assert bf.isPresent(ByteBuffer.wrap("a".getBytes()));
0:         assert !bf.isPresent(ByteBuffer.wrap("b".getBytes()));
commit:0a9a17e
/////////////////////////////////////////////////////////////////////////
commit:5e4c5ce
/////////////////////////////////////////////////////////////////////////
0:         bf = BloomFilter.getFilter(FilterTest.ELEMENTS, FilterTest.MAX_FAILURE_RATE);
/////////////////////////////////////////////////////////////////////////
0:     @Test(expected=UnsupportedOperationException.class)
1:     public void testBloomLimits1()
1:     {
1:         int maxBuckets = BloomCalculations.probs.length - 1;
1:         int maxK = BloomCalculations.probs[maxBuckets].length - 1;
1: 
1:         // possible
1:         BloomCalculations.computeBloomSpec(maxBuckets, BloomCalculations.probs[maxBuckets][maxK]);
1: 
1:         // impossible, throws
1:         BloomCalculations.computeBloomSpec(maxBuckets, BloomCalculations.probs[maxBuckets][maxK] / 2);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         BloomFilter bf2 = BloomFilter.getFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTest.MAX_FAILURE_RATE);
commit:88edbed
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
commit:97fc5cb
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Before;
0: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
1:     @Before
commit:afd3c27
commit:0c0c6e5
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.utils;
1: 
0: import java.io.IOException;
1: 
0: import org.testng.annotations.BeforeMethod;
0: import org.testng.annotations.Test;
1: 
1: public class BloomFilterTest
1: {
0:     public BloomFilter bf;
0:     public BloomCalculations.BloomSpecification spec = BloomCalculations.computeBucketsAndK(0.0001);
0:     static final int ELEMENTS = 10000;
1: 
1:     public BloomFilterTest()
1:     {
0:         bf = new BloomFilter(ELEMENTS, spec.bucketsPerElement);
0:         assert bf != null;
1:     }
1: 
0:     @BeforeMethod
0:     public void clear()
1:     {
0:         bf.clear();
1:     }
1: 
1:     @Test
1:     public void testOne()
1:     {
0:         bf.add("a");
0:         assert bf.isPresent("a");
0:         assert !bf.isPresent("b");
1:     }
1: 
1:     @Test
1:     public void testFalsePositivesInt()
1:     {
0:         FilterTest.testFalsePositives(bf, FilterTest.intKeys(), FilterTest.randomKeys2());
1:     }
1: 
1:     @Test
1:     public void testFalsePositivesRandom()
1:     {
0:         FilterTest.testFalsePositives(bf, FilterTest.randomKeys(), FilterTest.randomKeys2());
1:     }
1: 
1:     @Test
1:     public void testWords()
1:     {
1:         if (KeyGenerator.WordGenerator.WORDS == 0)
1:         {
1:             return;
1:         }
0:         BloomFilter bf2 = new BloomFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTest.spec.bucketsPerElement);
1:         int skipEven = KeyGenerator.WordGenerator.WORDS % 2 == 0 ? 0 : 2;
0:         FilterTest.testFalsePositives(bf2,
0:                                       new KeyGenerator.WordGenerator(skipEven, 2),
0:                                       new KeyGenerator.WordGenerator(1, 2));
1:     }
1: 
1:     @Test
1:     public void testSerialize() throws IOException
1:     {
0:         FilterTest.testSerialize(bf);
1:     }
1: 
0:     /* TODO move these into a nightly suite (they take 5-10 minutes each)
1:     @Test
0:     // run with -mx1G
0:     public void testBigInt() {
0:         int size = 100 * 1000 * 1000;
0:         bf = new BloomFilter(size, FilterTest.spec.bucketsPerElement);
0:         FilterTest.testFalsePositives(bf,
0:                                       new KeyGenerator.IntGenerator(size),
0:                                       new KeyGenerator.IntGenerator(size, size * 2));
1:     }
1: 
1:     @Test
0:     public void testBigRandom() {
0:         int size = 100 * 1000 * 1000;
0:         bf = new BloomFilter(size, FilterTest.spec.bucketsPerElement);
0:         FilterTest.testFalsePositives(bf,
0:                                       new KeyGenerator.RandomStringGenerator(new Random().nextInt(), size),
0:                                       new KeyGenerator.RandomStringGenerator(new Random().nextInt(), size));
1:     }
1: 
1:     @Test
0:     public void timeit() {
0:         int size = 300 * FilterTest.ELEMENTS;
0:         bf = new BloomFilter(size, FilterTest.spec.bucketsPerElement);
0:         for (int i = 0; i < 10; i++) {
0:             FilterTest.testFalsePositives(bf,
0:                                           new KeyGenerator.RandomStringGenerator(new Random().nextInt(), size),
0:                                           new KeyGenerator.RandomStringGenerator(new Random().nextInt(), size));
0:             bf.clear();
1:         }
1:     }
0:     */
1: }
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:d765b24
/////////////////////////////////////////////////////////////////////////
0:     public Filter bf;
0:         bf = FilterFactory.getFilter(10000L, FilterTestHelper.MAX_FAILURE_RATE);
0:     public static Filter testSerialize(Filter f) throws IOException
0:         FilterFactory.serialize(f, out, FilterFactory.Type.MURMUR3);
0:         Filter f2 = FilterFactory.deserialize(new DataInputStream(in), FilterFactory.Type.MURMUR3);
/////////////////////////////////////////////////////////////////////////
0:         Filter bf2 = FilterFactory.getFilter(KeyGenerator.WordGenerator.WORDS / 2, FilterTestHelper.MAX_FAILURE_RATE);
/////////////////////////////////////////////////////////////////////////
0:             BloomFilter bf = (BloomFilter) FilterFactory.getFilter(10, 10);
1:             for (long hashIndex : bf.getHashBuckets(buf, MAX_HASH_COUNT, 1024 * 1024))
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:790cca1
/////////////////////////////////////////////////////////////////////////
0:         bf.add("a".getBytes());
0:         assert bf.isPresent("a".getBytes());
0:         assert !bf.isPresent("b".getBytes());
============================================================================