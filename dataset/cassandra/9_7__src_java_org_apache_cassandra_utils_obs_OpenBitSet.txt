3:6cb811b: /*
1:07cf56f:  * Licensed to the Apache Software Foundation (ASF) under one
1:07cf56f:  * or more contributor license agreements.  See the NOTICE file
1:07cf56f:  * distributed with this work for additional information
1:07cf56f:  * regarding copyright ownership.  The ASF licenses this file
1:07cf56f:  * to you under the Apache License, Version 2.0 (the
1:07cf56f:  * "License"); you may not use this file except in compliance
1:07cf56f:  * with the License.  You may obtain a copy of the License at
6:6cb811b:  *
1:6cb811b:  *     http://www.apache.org/licenses/LICENSE-2.0
1:6cb811b:  *
1:6cb811b:  * Unless required by applicable law or agreed to in writing, software
1:6cb811b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6cb811b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6cb811b:  * See the License for the specific language governing permissions and
1:6cb811b:  * limitations under the License.
26:6cb811b:  */
1:6cb811b: package org.apache.cassandra.utils.obs;
89:6cb811b: 
1:6cb811b: import java.util.Arrays;
1:dc37dea: import java.io.DataInput;
1:dc37dea: import java.io.DataOutput;
1:dc37dea: import java.io.IOException;
1:dc37dea: 
1:dc37dea: import org.apache.cassandra.db.TypeSizes;
1:a7f4134: import org.apache.cassandra.utils.concurrent.Ref;
1:6cb811b: 
1:00436c0: /**
1:222ea95:  * <p>
1:00436c0:  * An "open" BitSet implementation that allows direct access to the arrays of words
1:00436c0:  * storing the bits.  Derived from Lucene's OpenBitSet, but with a paged backing array
1:00436c0:  * (see bits delaration, below).
1:222ea95:  * </p>
1:222ea95:  * <p>
1:6cb811b:  * Unlike java.util.bitset, the fact that bits are packed into an array of longs
1:6cb811b:  * is part of the interface.  This allows efficient implementation of other algorithms
1:6cb811b:  * by someone other than the author.  It also allows one to efficiently implement
1:6cb811b:  * alternate serialization or interchange formats.
1:222ea95:  * </p>
1:222ea95:  * <p>
1:6cb811b:  * <code>OpenBitSet</code> is faster than <code>java.util.BitSet</code> in most operations
1:6cb811b:  * and *much* faster at calculating cardinality of sets and results of set operations.
1:6cb811b:  * It can also handle sets of larger cardinality (up to 64 * 2**32-1)
1:222ea95:  * </p>
1:222ea95:  * <p>
1:6cb811b:  * The goals of <code>OpenBitSet</code> are the fastest implementation possible, and
1:6cb811b:  * maximum code reuse.  Extra safety and encapsulation
1:6cb811b:  * may always be built on top, but if that's built in, the cost can never be removed (and
1:6cb811b:  * hence people re-implement their own version in order to get better performance).
1:6cb811b:  * If you want a "safe", totally encapsulated (and slower and limited) BitSet
1:6cb811b:  * class, use <code>java.util.BitSet</code>.
1:222ea95:  * </p>
1:c8b6763:  */
1:6cb811b: 
1:dc37dea: public class OpenBitSet implements IBitSet
1:dc37dea: {
2:c8b6763:   /**
1:00436c0:    * We break the bitset up into multiple arrays to avoid promotion failure caused by attempting to allocate
1:00436c0:    * large, contiguous arrays (CASSANDRA-2466).  All sub-arrays but the last are uniformly PAGE_SIZE words;
1:00436c0:    * to avoid waste in small bloom filters (of which Cassandra has many: one per row) the last sub-array
1:00436c0:    * is sized to exactly the remaining number of words required to achieve the desired set size (CASSANDRA-3618).
1:6cb811b:    */
1:00436c0:   private final long[][] bits;
1:00436c0:   private int wlen; // number of words (elements) used in the array
1:00436c0:   private final int pageCount;
1:00436c0:   private static final int PAGE_SIZE = 4096;
1:6cb811b: 
1:00436c0:   /**
1:00436c0:    * Constructs an OpenBitSet large enough to hold numBits.
1:6cb811b:    * @param numBits
1:6cb811b:    */
1:c8b6763:   public OpenBitSet(long numBits)
1:c8b6763:   {
1:fcc51ea:       wlen = (int) bits2words(numBits);
1:00436c0:       int lastPageSize = wlen % PAGE_SIZE;
1:00436c0:       int fullPageCount = wlen / PAGE_SIZE;
1:00436c0:       pageCount = fullPageCount + (lastPageSize == 0 ? 0 : 1);
1:c8b6763: 
1:00436c0:       bits = new long[pageCount][];
1:c8b6763: 
1:00436c0:       for (int i = 0; i < fullPageCount; ++i)
1:00436c0:           bits[i] = new long[PAGE_SIZE];
1:00436c0: 
1:00436c0:       if (lastPageSize != 0)
1:00436c0:           bits[bits.length - 1] = new long[lastPageSize];
1:c8b6763:   }
1:c8b6763: 
1:68d2526:   public OpenBitSet()
1:68d2526:   {
1:6cb811b:     this(64);
1:c8b6763:   }
1:6cb811b: 
1:00436c0:   /**
1:c8b6763:    * @return the pageSize
1:6cb811b:    */
1:c8b6763:   public int getPageSize()
1:c8b6763:   {
1:c8b6763:       return PAGE_SIZE;
1:c8b6763:   }
1:c8b6763: 
1:c8b6763:   public int getPageCount()
1:c8b6763:   {
1:e37bd7e:       return pageCount;
56:6cb811b:   }
1:6cb811b: 
1:c8b6763:   public long[] getPage(int pageIdx)
1:c8b6763:   {
1:c8b6763:       return bits[pageIdx];
1:c8b6763:   }
1:c8b6763: 
1:6cb811b:   /** Returns the current capacity in bits (1 greater than the index of the last bit) */
1:c8b6763:   public long capacity() { return ((long)wlen) << 6; }
1:6cb811b: 
1:7a14a77:   @Override
1:7a14a77:   public long offHeapSize()
1:7a14a77:   {
1:7a14a77:       return 0;
1:7a14a77:   }
1:7a14a77: 
1:a7f4134:     public void addTo(Ref.IdentityCollection identities)
1:a7f4134:     {
1:a7f4134:     }
1:a7f4134: 
1:a7f4134:     /**
1:6cb811b:   * Returns the current capacity of this set.  Included for
1:6cb811b:   * compatibility.  This is *not* equal to {@link #cardinality}
1:6cb811b:   */
1:68d2526:   public long size()
1:68d2526:   {
1:6cb811b:       return capacity();
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   // @Override -- not until Java 1.6
1:68d2526:   public long length()
1:68d2526:   {
1:c8b6763:     return capacity();
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** Returns true if there are no set bits */
1:6cb811b:   public boolean isEmpty() { return cardinality()==0; }
1:6cb811b: 
1:6cb811b: 
1:6cb811b:   /** Expert: gets the number of longs in the array that are in use */
1:6cb811b:   public int getNumWords() { return wlen; }
1:6cb811b: 
1:6cb811b: 
1:00436c0:   /**
1:00436c0:    * Returns true or false for the specified bit index.
1:00436c0:    * The index should be less than the OpenBitSet size
1:00436c0:    */
1:68d2526:   public boolean get(int index)
1:68d2526:   {
2:6cb811b:     int i = index >> 6;               // div 64
2:6cb811b:     // signed shift will keep a negative index and force an
2:6cb811b:     // array-index-out-of-bounds-exception, removing the need for an explicit check.
2:6cb811b:     int bit = index & 0x3f;           // mod 64
12:6cb811b:     long bitmask = 1L << bit;
1:c8b6763:     // TODO perfectionist one can implement this using bit operations
1:c8b6763:     return (bits[i / PAGE_SIZE][i % PAGE_SIZE ] & bitmask) != 0;
1:6cb811b:   }
1:6cb811b: 
1:00436c0:   /**
1:00436c0:    * Returns true or false for the specified bit index.
9:6cb811b:    * The index should be less than the OpenBitSet size.
1:6cb811b:    */
1:68d2526:   public boolean get(long index)
1:68d2526:   {
1:6cb811b:     int i = (int)(index >> 6);               // div 64
2:6cb811b:     int bit = (int)index & 0x3f;           // mod 64
1:6cb811b:     long bitmask = 1L << bit;
1:c8b6763:     // TODO perfectionist one can implement this using bit operations
1:c8b6763:     return (bits[i / PAGE_SIZE][i % PAGE_SIZE ] & bitmask) != 0;
1:6cb811b:   }
1:6cb811b: 
1:00436c0:   /**
1:00436c0:    * Sets the bit at the specified index.
1:00436c0:    * The index should be less than the OpenBitSet size.
1:00436c0:    */
1:68d2526:   public void set(long index)
1:68d2526:   {
1:00436c0:     int wordNum = (int)(index >> 6);
2:6cb811b:     int bit = (int)index & 0x3f;
1:6cb811b:     long bitmask = 1L << bit;
1:c8b6763:     bits[ wordNum / PAGE_SIZE ][ wordNum % PAGE_SIZE ] |= bitmask;
1:6cb811b:   }
1:6cb811b: 
1:00436c0:   /**
1:00436c0:    * Sets the bit at the specified index.
1:00436c0:    * The index should be less than the OpenBitSet size.
1:00436c0:    */
1:68d2526:   public void set(int index)
1:68d2526:   {
4:6cb811b:     int wordNum = index >> 6;      // div 64
4:6cb811b:     int bit = index & 0x3f;     // mod 64
1:6cb811b:     long bitmask = 1L << bit;
1:c8b6763:     bits[ wordNum / PAGE_SIZE ][ wordNum % PAGE_SIZE ] |= bitmask;
1:6cb811b:   }
1:6cb811b: 
1:00436c0:   /**
1:00436c0:    * clears a bit.
1:6cb811b:    * The index should be less than the OpenBitSet size.
1:6cb811b:    */
1:68d2526:   public void clear(int index)
1:68d2526:   {
1:6cb811b:     int wordNum = index >> 6;
1:6cb811b:     int bit = index & 0x03f;
1:6cb811b:     long bitmask = 1L << bit;
1:c8b6763:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] &= ~bitmask;
1:6cb811b:     // hmmm, it takes one more instruction to clear than it does to set... any
1:6cb811b:     // way to work around this?  If there were only 63 bits per word, we could
1:6cb811b:     // use a right shift of 10111111...111 in binary to position the 0 in the
1:6cb811b:     // correct place (using sign extension).
1:6cb811b:     // Could also use Long.rotateRight() or rotateLeft() *if* they were converted
1:6cb811b:     // by the JVM into a native instruction.
1:6cb811b:     // bits[word] &= Long.rotateLeft(0xfffffffe,bit);
1:6cb811b:   }
1:6cb811b: 
1:00436c0:   /**
1:00436c0:    * clears a bit.
1:6cb811b:    * The index should be less than the OpenBitSet size.
1:6cb811b:    */
1:68d2526:   public void clear(long index)
1:68d2526:   {
2:6cb811b:     int wordNum = (int)(index >> 6); // div 64
3:6cb811b:     int bit = (int)index & 0x3f;     // mod 64
1:6cb811b:     long bitmask = 1L << bit;
1:c8b6763:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] &= ~bitmask;
1:6cb811b:   }
1:6cb811b: 
1:00436c0:   /**
1:00436c0:    * Clears a range of bits.  Clearing past the end does not change the size of the set.
1:6cb811b:    *
3:6cb811b:    * @param startIndex lower index
1:6cb811b:    * @param endIndex one-past the last bit to clear
1:6cb811b:    */
1:68d2526:   public void clear(int startIndex, int endIndex)
1:68d2526:   {
3:6cb811b:     if (endIndex <= startIndex) return;
1:6cb811b: 
1:6cb811b:     int startWord = (startIndex>>6);
1:6cb811b:     if (startWord >= wlen) return;
1:6cb811b: 
3:6cb811b:     // since endIndex is one past the end, this is index of the last
3:6cb811b:     // word to be changed.
1:6cb811b:     int endWord   = ((endIndex-1)>>6);
1:6cb811b: 
3:6cb811b:     long startmask = -1L << startIndex;
3:6cb811b:     long endmask = -1L >>> -endIndex;  // 64-(endIndex&0x3f) is the same as -endIndex due to wrap
1:6cb811b: 
1:6cb811b:     // invert masks since we are clearing
1:6cb811b:     startmask = ~startmask;
1:6cb811b:     endmask = ~endmask;
1:6cb811b: 
1:68d2526:     if (startWord == endWord)
1:68d2526:     {
1:c8b6763:       bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] &= (startmask | endmask);
1:c8b6763:       return;
1:6cb811b:     }
1:c8b6763: 
1:c8b6763: 
1:c8b6763:     bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE]  &= startmask;
1:6cb811b: 
1:6cb811b:     int middle = Math.min(wlen, endWord);
1:c8b6763:     if (startWord / PAGE_SIZE == middle / PAGE_SIZE)
1:68d2526:     {
1:c8b6763:         Arrays.fill(bits[startWord/PAGE_SIZE], (startWord+1) % PAGE_SIZE, middle % PAGE_SIZE, 0L);
1:c8b6763:     } else
1:c8b6763:     {
1:c8b6763:         while (++startWord<middle)
1:c8b6763:             bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] = 0L;
1:c8b6763:     }
1:68d2526:     if (endWord < wlen)
1:68d2526:     {
1:c8b6763:       bits[endWord / PAGE_SIZE][endWord % PAGE_SIZE] &= endmask;
1:c8b6763:     }
1:6cb811b:   }
1:6cb811b: 
1:6cb811b: 
2:6cb811b:   /** Clears a range of bits.  Clearing past the end does not change the size of the set.
1:6cb811b:    *
1:6cb811b:    * @param startIndex lower index
1:6cb811b:    * @param endIndex one-past the last bit to clear
1:6cb811b:    */
1:68d2526:   public void clear(long startIndex, long endIndex)
1:68d2526:   {
1:6cb811b:     if (endIndex <= startIndex) return;
1:6cb811b: 
3:6cb811b:     int startWord = (int)(startIndex>>6);
1:6cb811b:     if (startWord >= wlen) return;
1:6cb811b: 
1:6cb811b:     // since endIndex is one past the end, this is index of the last
1:6cb811b:     // word to be changed.
1:6cb811b:     int endWord   = (int)((endIndex-1)>>6);
1:6cb811b: 
1:6cb811b:     long startmask = -1L << startIndex;
1:6cb811b:     long endmask = -1L >>> -endIndex;  // 64-(endIndex&0x3f) is the same as -endIndex due to wrap
1:6cb811b: 
1:6cb811b:     // invert masks since we are clearing
1:6cb811b:     startmask = ~startmask;
1:6cb811b:     endmask = ~endmask;
1:6cb811b: 
1:68d2526:     if (startWord == endWord)
1:68d2526: {
1:c8b6763:         bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] &= (startmask | endmask);
4:6cb811b:         return;
1:6cb811b:     }
1:6cb811b: 
1:c8b6763:     bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE]  &= startmask;
1:6cb811b: 
1:6cb811b:     int middle = Math.min(wlen, endWord);
1:c8b6763:     if (startWord / PAGE_SIZE == middle / PAGE_SIZE)
1:c8b6763:     {
1:c8b6763:         Arrays.fill(bits[startWord/PAGE_SIZE], (startWord+1) % PAGE_SIZE, middle % PAGE_SIZE, 0L);
1:c8b6763:     } else
1:c8b6763:     {
1:c8b6763:         while (++startWord<middle)
1:c8b6763:             bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] = 0L;
1:6cb811b:     }
1:68d2526:     if (endWord < wlen)
1:c8b6763:     {
1:c8b6763:         bits[endWord / PAGE_SIZE][endWord % PAGE_SIZE] &= endmask;
1:6cb811b:     }
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** @return the number of set bits */
1:c8b6763:   public long cardinality()
2:c8b6763:   {
1:c8b6763:     long bitCount = 0L;
1:c8b6763:     for (int i=getPageCount();i-->0;)
1:c8b6763:         bitCount+=BitUtil.pop_array(bits[i],0,wlen);
1:c8b6763: 
1:c8b6763:     return bitCount;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** this = this AND other */
1:68d2526:   public void intersect(OpenBitSet other)
1:68d2526:   {
1:6cb811b:     int newLen= Math.min(this.wlen,other.wlen);
1:c8b6763:     long[][] thisArr = this.bits;
1:c8b6763:     long[][] otherArr = other.bits;
1:dc37dea:     int thisPageSize = PAGE_SIZE;
1:02fb218:     int otherPageSize = OpenBitSet.PAGE_SIZE;
1:6cb811b:     // testing against zero can be more efficient
1:6cb811b:     int pos=newLen;
1:68d2526:     while(--pos>=0)
1:68d2526:     {
1:c8b6763:       thisArr[pos / thisPageSize][ pos % thisPageSize] &= otherArr[pos / otherPageSize][pos % otherPageSize];
1:6cb811b:     }
1:c8b6763: 
1:68d2526:     if (this.wlen > newLen)
1:68d2526:     {
1:6cb811b:       // fill zeros from the new shorter length to the old length
1:c8b6763:       for (pos=wlen;pos-->newLen;)
1:c8b6763:           thisArr[pos / thisPageSize][ pos % thisPageSize] =0;
1:6cb811b:     }
3:6cb811b:     this.wlen = newLen;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   // some BitSet compatability methods
1:6cb811b: 
1:6cb811b:   //** see {@link intersect} */
1:68d2526:   public void and(OpenBitSet other)
1:68d2526:   {
1:6cb811b:     intersect(other);
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** Lowers numWords, the number of words in use,
1:6cb811b:    * by checking for trailing zero words.
1:6cb811b:    */
1:68d2526:   public void trimTrailingZeros()
1:68d2526:   {
1:6cb811b:     int idx = wlen-1;
1:c8b6763:     while (idx>=0 && bits[idx / PAGE_SIZE][idx % PAGE_SIZE]==0) idx--;
1:6cb811b:     wlen = idx+1;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** returns the number of 64 bit words it would take to hold numBits */
1:68d2526:   public static long bits2words(long numBits)
1:68d2526:   {
1:fcc51ea:    return (((numBits-1)>>>6)+1);
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** returns true if both sets have the same bits set */
2:6cb811b:   @Override
1:68d2526:   public boolean equals(Object o)
1:68d2526:   {
1:6cb811b:     if (this == o) return true;
1:6cb811b:     if (!(o instanceof OpenBitSet)) return false;
1:6cb811b:     OpenBitSet a;
1:6cb811b:     OpenBitSet b = (OpenBitSet)o;
1:6cb811b:     // make a the larger set.
1:68d2526:     if (b.wlen > this.wlen)
1:68d2526:     {
1:6cb811b:       a = b; b=this;
1:68d2526:     }
1:68d2526:     else
1:68d2526:     {
1:6cb811b:       a=this;
1:6cb811b:     }
1:c8b6763: 
1:02fb218:     int aPageSize = OpenBitSet.PAGE_SIZE;
1:02fb218:     int bPageSize = OpenBitSet.PAGE_SIZE;
1:6cb811b: 
1:6cb811b:     // check for any set bits out of the range of b
1:68d2526:     for (int i=a.wlen-1; i>=b.wlen; i--)
1:68d2526:     {
1:c8b6763:       if (a.bits[i/aPageSize][i % aPageSize]!=0) return false;
1:6cb811b:     }
1:6cb811b: 
1:68d2526:     for (int i=b.wlen-1; i>=0; i--)
1:68d2526:     {
1:c8b6763:       if (a.bits[i/aPageSize][i % aPageSize] != b.bits[i/bPageSize][i % bPageSize]) return false;
1:6cb811b:     }
1:6cb811b: 
1:6cb811b:     return true;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b: 
1:6cb811b:   @Override
1:68d2526:   public int hashCode()
1:68d2526:   {
1:6cb811b:     // Start with a zero hash and use a mix that results in zero if the input is zero.
1:6cb811b:     // This effectively truncates trailing zeros without an explicit check.
1:6cb811b:     long h = 0;
1:68d2526:     for (int i = wlen; --i>=0;)
1:68d2526:     {
1:c8b6763:       h ^= bits[i / PAGE_SIZE][i % PAGE_SIZE];
1:6cb811b:       h = (h << 1) | (h >>> 63); // rotate left
1:6cb811b:     }
1:6cb811b:     // fold leftmost bits into right and add a constant to prevent
1:6cb811b:     // empty sets from returning 0, which is too common.
1:6cb811b:     return (int)((h>>32) ^ h) + 0x98761234;
1:6cb811b:   }
1:6cb811b: 
1:68d2526:   public void close()
1:68d2526:   {
1:dc37dea:     // noop, let GC do the cleanup.
1:dc37dea:   }
1:dc37dea: 
1:68d2526:   public void serialize(DataOutput out) throws IOException
1:68d2526:   {
1:dc37dea:     int bitLength = getNumWords();
1:dc37dea:     int pageSize = getPageSize();
1:dc37dea:     int pageCount = getPageCount();
1:dc37dea: 
1:60d9c7f:     out.writeInt(bitLength);
1:68d2526:     for (int p = 0; p < pageCount; p++)
1:68d2526:     {
1:dc37dea:       long[] bits = getPage(p);
1:68d2526:       for (int i = 0; i < pageSize && bitLength-- > 0; i++)
1:68d2526:       {
1:60d9c7f:         out.writeLong(bits[i]);
1:dc37dea:       }
1:dc37dea:     }
1:dc37dea: }
1:6cb811b: 
1:68d2526:   public long serializedSize()
1:68d2526:   {
1:dc37dea:     int bitLength = getNumWords();
1:dc37dea:     int pageSize = getPageSize();
1:dc37dea:     int pageCount = getPageCount();
1:6cb811b: 
1:03f72ac:     long size = TypeSizes.sizeof(bitLength); // length
1:68d2526:     for (int p = 0; p < pageCount; p++)
1:68d2526:     {
1:dc37dea:       long[] bits = getPage(p);
1:dc37dea:       for (int i = 0; i < pageSize && bitLength-- > 0; i++)
1:03f72ac:         size += TypeSizes.sizeof(bits[i]); // bucket
1:6cb811b:     }
1:dc37dea:     return size;
1:dc37dea:   }
1:dc37dea: 
1:68d2526:   public void clear()
1:68d2526:   {
1:dc37dea:     clear(0, capacity());
1:dc37dea:   }
1:dc37dea: 
1:68d2526:   public static OpenBitSet deserialize(DataInput in) throws IOException
1:68d2526:   {
1:60d9c7f:     long bitLength = in.readInt();
1:dc37dea: 
1:dc37dea:     OpenBitSet bs = new OpenBitSet(bitLength << 6);
1:dc37dea:     int pageSize = bs.getPageSize();
1:dc37dea:     int pageCount = bs.getPageCount();
1:dc37dea: 
1:68d2526:     for (int p = 0; p < pageCount; p++)
1:68d2526:     {
1:dc37dea:       long[] bits = bs.getPage(p);
1:dc37dea:       for (int i = 0; i < pageSize && bitLength-- > 0; i++)
1:60d9c7f:         bits[i] = in.readLong();
1:dc37dea:     }
1:dc37dea:     return bs;
1:dc37dea:   }
1:dc37dea: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:   public OpenBitSet()
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public long size()
1:   {
1:   public long length()
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public boolean get(int index)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public boolean get(long index)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public void set(long index)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public void set(int index)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public void clear(int index)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public void clear(long index)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public void clear(int startIndex, int endIndex)
1:   {
/////////////////////////////////////////////////////////////////////////
1:     if (startWord == endWord)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (endWord < wlen)
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public void clear(long startIndex, long endIndex)
1:   {
/////////////////////////////////////////////////////////////////////////
1:     if (startWord == endWord)
1: {
/////////////////////////////////////////////////////////////////////////
1:     if (endWord < wlen)
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public void intersect(OpenBitSet other)
1:   {
/////////////////////////////////////////////////////////////////////////
1:     while(--pos>=0)
1:     {
1:     if (this.wlen > newLen)
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public void and(OpenBitSet other)
1:   {
1:   public void trimTrailingZeros()
1:   {
1:   public static long bits2words(long numBits)
1:   {
1:   public boolean equals(Object o)
1:   {
1:     if (b.wlen > this.wlen)
1:     {
1:     }
1:     else
1:     {
/////////////////////////////////////////////////////////////////////////
1:     for (int i=a.wlen-1; i>=b.wlen; i--)
1:     {
1:     for (int i=b.wlen-1; i>=0; i--)
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public int hashCode()
1:   {
1:     for (int i = wlen; --i>=0;)
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public void close()
1:   {
1:   public void serialize(DataOutput out) throws IOException
1:   {
1:     for (int p = 0; p < pageCount; p++)
1:     {
1:       for (int i = 0; i < pageSize && bitLength-- > 0; i++)
1:       {
1:   public long serializedSize()
1:   {
1:     for (int p = 0; p < pageCount; p++)
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public void clear()
1:   {
1:   public static OpenBitSet deserialize(DataInput in) throws IOException
1:   {
1:     for (int p = 0; p < pageCount; p++)
1:     {
commit:222ea95
/////////////////////////////////////////////////////////////////////////
1:  * <p>
1:  * </p>
1:  * <p>
1:  * </p>
1:  * <p>
1:  * </p>
1:  * <p>
1:  * </p>
commit:02fb218
/////////////////////////////////////////////////////////////////////////
1:     int otherPageSize = OpenBitSet.PAGE_SIZE;
/////////////////////////////////////////////////////////////////////////
1:     int aPageSize = OpenBitSet.PAGE_SIZE;
1:     int bPageSize = OpenBitSet.PAGE_SIZE;
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:a7f4134
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.concurrent.Ref;
/////////////////////////////////////////////////////////////////////////
1:     public void addTo(Ref.IdentityCollection identities)
1:     {
1:     }
1: 
1:     /**
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
0:   public long serializedSize() {
1:     long size = TypeSizes.sizeof(bitLength); // length
1:         size += TypeSizes.sizeof(bits[i]); // bucket
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:9aaea24
author:blerer
-------------------------------------------------------------------------------
commit:7a14a77
/////////////////////////////////////////////////////////////////////////
1:   @Override
1:   public long offHeapSize()
1:   {
1:       return 0;
1:   }
1: 
author:belliottsmith
-------------------------------------------------------------------------------
commit:5ebadc1
/////////////////////////////////////////////////////////////////////////
0:   public void close() {
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:ea7bc14
commit:fcc51ea
/////////////////////////////////////////////////////////////////////////
1:       wlen = (int) bits2words(numBits);
/////////////////////////////////////////////////////////////////////////
0:   public static long bits2words(long numBits) {
1:    return (((numBits-1)>>>6)+1);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:60d9c7f
/////////////////////////////////////////////////////////////////////////
0:   public void serialize(DataOutput out) throws IOException {
1:     out.writeInt(bitLength);
1:         out.writeLong(bits[i]);
/////////////////////////////////////////////////////////////////////////
0:   public static OpenBitSet deserialize(DataInput in) throws IOException {
1:     long bitLength = in.readInt();
/////////////////////////////////////////////////////////////////////////
1:         bits[i] = in.readLong();
commit:dc37dea
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.IOException;
1: 
1: import org.apache.cassandra.db.TypeSizes;
/////////////////////////////////////////////////////////////////////////
1: public class OpenBitSet implements IBitSet
1: {
/////////////////////////////////////////////////////////////////////////
1:     int thisPageSize = PAGE_SIZE;
/////////////////////////////////////////////////////////////////////////
0:   public void close() throws IOException {
1:     // noop, let GC do the cleanup.
1:   }
1: 
0:   public void serialize(DataOutput dos) throws IOException {
1:     int bitLength = getNumWords();
1:     int pageSize = getPageSize();
1:     int pageCount = getPageCount();
1: 
0:     dos.writeInt(bitLength);
0:     for (int p = 0; p < pageCount; p++) {
1:       long[] bits = getPage(p);
0:       for (int i = 0; i < pageSize && bitLength-- > 0; i++) {
0:         dos.writeLong(bits[i]);
1:       }
1:     }
0:   public long serializedSize(TypeSizes type) {
1:     int bitLength = getNumWords();
1:     int pageSize = getPageSize();
1:     int pageCount = getPageCount();
0:     long size = type.sizeof(bitLength); // length
0:     for (int p = 0; p < pageCount; p++) {
1:       long[] bits = getPage(p);
1:       for (int i = 0; i < pageSize && bitLength-- > 0; i++)
0:         size += type.sizeof(bits[i]); // bucket
1:     }
1:     return size;
1:   }
1: 
0:   public void clear() {
1:     clear(0, capacity());
1:   }
1: 
0:   public static OpenBitSet deserialize(DataInput dis) throws IOException {
0:     long bitLength = dis.readInt();
1: 
1:     OpenBitSet bs = new OpenBitSet(bitLength << 6);
1:     int pageSize = bs.getPageSize();
1:     int pageCount = bs.getPageCount();
1: 
0:     for (int p = 0; p < pageCount; p++) {
1:       long[] bits = bs.getPage(p);
1:       for (int i = 0; i < pageSize && bitLength-- > 0; i++)
0:         bits[i] = dis.readLong();
1:     }
1:     return bs;
1:   }
1: }
commit:438e753
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:00436c0
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * An "open" BitSet implementation that allows direct access to the arrays of words
1:  * storing the bits.  Derived from Lucene's OpenBitSet, but with a paged backing array
1:  * (see bits delaration, below).
/////////////////////////////////////////////////////////////////////////
1:    * We break the bitset up into multiple arrays to avoid promotion failure caused by attempting to allocate
1:    * large, contiguous arrays (CASSANDRA-2466).  All sub-arrays but the last are uniformly PAGE_SIZE words;
1:    * to avoid waste in small bloom filters (of which Cassandra has many: one per row) the last sub-array
1:    * is sized to exactly the remaining number of words required to achieve the desired set size (CASSANDRA-3618).
1:   private final long[][] bits;
1:   private int wlen; // number of words (elements) used in the array
1:   private final int pageCount;
1:   private static final int PAGE_SIZE = 4096;
1:   /**
1:    * Constructs an OpenBitSet large enough to hold numBits.
0:       wlen = bits2words(numBits);
1:       int lastPageSize = wlen % PAGE_SIZE;
1:       int fullPageCount = wlen / PAGE_SIZE;
1:       pageCount = fullPageCount + (lastPageSize == 0 ? 0 : 1);
1:       bits = new long[pageCount][];
1:       for (int i = 0; i < fullPageCount; ++i)
1:           bits[i] = new long[PAGE_SIZE];
1: 
1:       if (lastPageSize != 0)
1:           bits[bits.length - 1] = new long[lastPageSize];
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Returns true or false for the specified bit index.
1:    * The index should be less than the OpenBitSet size
1:    */
1:   /**
1:    * Returns true or false for the specified bit index.
0:   public boolean get(long index) {
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Sets the bit at the specified index.
1:    * The index should be less than the OpenBitSet size.
1:    */
1:     int wordNum = (int)(index >> 6);
1:   /**
1:    * Sets the bit at the specified index.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public void set(int index) {
1:   /**
1:    * clears a bit.
0:   public void clear(int index) {
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * clears a bit.
1:   /**
1:    * Clears a range of bits.  Clearing past the end does not change the size of the set.
/////////////////////////////////////////////////////////////////////////
0:   public void flip(int index) {
1:   /**
0:    * flips a bit.
0:     int wordNum = (int)(index >> 6);   // div 64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c8b6763
/////////////////////////////////////////////////////////////////////////
0: public class OpenBitSet implements Serializable {
0:   protected long[][] bits;
1:   /**
0:    * length of bits[][] page in long[] elements. 
0:    * Choosing unform size for all sizes of bitsets fight fragmentation for very large
0:    * bloom filters.
1:    */
0:   protected static final int PAGE_SIZE= 4096; 
1:   public OpenBitSet(long numBits) 
1:   {
0:       this(numBits,true);
1:   }
1:   
0:   public OpenBitSet(long numBits, boolean allocatePages) 
1:   {
0:     wlen= bits2words(numBits);    
1:     
0:     bits = new long[getPageCount()][];
1:     
0:     if (allocatePages)
1:     {
0:         for (int allocated=0,i=0;allocated<wlen;allocated+=PAGE_SIZE,i++)
0:             bits[i]=new long[PAGE_SIZE];
1:     }
1:   /**
1:    * @return the pageSize
1:   public int getPageSize()
1:   {
1:       return PAGE_SIZE;
1:   }
1:   
1:   public int getPageCount()
1:   {
0:       return wlen / PAGE_SIZE + 1;
1:   public long[] getPage(int pageIdx)
1:   {
1:       return bits[pageIdx];
1:   }
1:   
/////////////////////////////////////////////////////////////////////////
1:   public long capacity() { return ((long)wlen) << 6; }
/////////////////////////////////////////////////////////////////////////
0:   public long length() {
1:     return capacity();
0:     if (i>=wlen) return false;
1:     // TODO perfectionist one can implement this using bit operations
0:     return (bits[i / PAGE_SIZE ][i % PAGE_SIZE] & bitmask) != 0;
/////////////////////////////////////////////////////////////////////////
1:     // TODO perfectionist one can implement this using bit operations
1:     return (bits[i / PAGE_SIZE][i % PAGE_SIZE ] & bitmask) != 0;
/////////////////////////////////////////////////////////////////////////
0:     if (i>=wlen) return false;
0:     // TODO perfectionist one can implement this using bit operations
1:     return (bits[i / PAGE_SIZE][i % PAGE_SIZE ] & bitmask) != 0;
/////////////////////////////////////////////////////////////////////////
0:     // TODO perfectionist one can implement this using bit operations
0:     return (bits[i / PAGE_SIZE][i % PAGE_SIZE ] & bitmask) != 0;
0:     return ((int)(bits[i / PAGE_SIZE][i % PAGE_SIZE ]>>>bit)) & 0x01;
1:     bits[ wordNum / PAGE_SIZE ][ wordNum % PAGE_SIZE ] |= bitmask;
/////////////////////////////////////////////////////////////////////////
1:     bits[ wordNum / PAGE_SIZE ][ wordNum % PAGE_SIZE ] |= bitmask;
/////////////////////////////////////////////////////////////////////////
0:     bits[ wordNum / PAGE_SIZE ][ wordNum % PAGE_SIZE ] |= bitmask;
/////////////////////////////////////////////////////////////////////////
0:       bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] |= (startmask & endmask);
0:     assert startWord / PAGE_SIZE == endWord / PAGE_SIZE : "cross page sets not suppotred at all - they are not used";
1: 
0:     bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] |= startmask;
0:     Arrays.fill(bits[ startWord / PAGE_SIZE], (startWord+1) % PAGE_SIZE , endWord % PAGE_SIZE , -1L);
0:     bits[endWord / PAGE_SIZE][endWord % PAGE_SIZE] |= endmask;
/////////////////////////////////////////////////////////////////////////
1:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] &= ~bitmask;
/////////////////////////////////////////////////////////////////////////
1:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] &= ~bitmask;
/////////////////////////////////////////////////////////////////////////
0:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] &= ~bitmask;
/////////////////////////////////////////////////////////////////////////
1:       bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] &= (startmask | endmask);
1:     
1:     bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE]  &= startmask;
1:     if (startWord / PAGE_SIZE == middle / PAGE_SIZE)
1:     {
1:         Arrays.fill(bits[startWord/PAGE_SIZE], (startWord+1) % PAGE_SIZE, middle % PAGE_SIZE, 0L);
1:     } else
1:     {
1:         while (++startWord<middle)
1:             bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] = 0L;
1:     }
1:       bits[endWord / PAGE_SIZE][endWord % PAGE_SIZE] &= endmask;
/////////////////////////////////////////////////////////////////////////
1:         bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] &= (startmask | endmask);
1:         return;
1:     bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE]  &= startmask;
1:     if (startWord / PAGE_SIZE == middle / PAGE_SIZE)
1:     {
1:         Arrays.fill(bits[startWord/PAGE_SIZE], (startWord+1) % PAGE_SIZE, middle % PAGE_SIZE, 0L);
1:     } else
1:     {
1:         while (++startWord<middle)
1:             bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] = 0L;
1:     }
1:         bits[endWord / PAGE_SIZE][endWord % PAGE_SIZE] &= endmask;
/////////////////////////////////////////////////////////////////////////
0:     boolean val = (bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] & bitmask) != 0;
0:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] |= bitmask;
/////////////////////////////////////////////////////////////////////////
0:     boolean val = (bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] & bitmask) != 0;
0:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] |= bitmask;
/////////////////////////////////////////////////////////////////////////
0:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] ^= bitmask;
/////////////////////////////////////////////////////////////////////////
0:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] ^= bitmask;
/////////////////////////////////////////////////////////////////////////
0:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] ^= bitmask;
/////////////////////////////////////////////////////////////////////////
0:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] ^= bitmask;
0:     return (bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] & bitmask) != 0;
/////////////////////////////////////////////////////////////////////////
0:     bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] ^= bitmask;
0:     return (bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] & bitmask) != 0;
/////////////////////////////////////////////////////////////////////////
0:       bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] ^= (startmask & endmask);
0:     bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] ^= startmask;
0:       bits[i / PAGE_SIZE][ i % PAGE_SIZE] = ~bits[i / PAGE_SIZE][ i % PAGE_SIZE];
0:     bits[endWord / PAGE_SIZE][endWord % PAGE_SIZE] ^= endmask;
1:   public long cardinality() 
0:   {
1:     long bitCount = 0L;
1:     for (int i=getPageCount();i-->0;)
1:         bitCount+=BitUtil.pop_array(bits[i],0,wlen);
1:     
1:     return bitCount;
/////////////////////////////////////////////////////////////////////////
0:     long word = bits[i / PAGE_SIZE][ i % PAGE_SIZE] >> subIndex;  // skip all the bits to the right of index
0:       word = bits[i / PAGE_SIZE][i % PAGE_SIZE];
/////////////////////////////////////////////////////////////////////////
0:     long word = bits[i / PAGE_SIZE][i % PAGE_SIZE] >>> subIndex;  // skip all the bits to the right of index
0:       word = bits[i / PAGE_SIZE][i % PAGE_SIZE];
1:     long[][] thisArr = this.bits;
1:     long[][] otherArr = other.bits;
0:     int thisPageSize = this.PAGE_SIZE;
0:     int otherPageSize = other.PAGE_SIZE;
1:       thisArr[pos / thisPageSize][ pos % thisPageSize] &= otherArr[pos / otherPageSize][pos % otherPageSize];
1:     
1:       for (pos=wlen;pos-->newLen;)
1:           thisArr[pos / thisPageSize][ pos % thisPageSize] =0;
/////////////////////////////////////////////////////////////////////////
0:   public void ensureCapacityWords(int numWords) 
0:   {
0:     assert numWords<=wlen : "Growing of paged bitset is not supported"; 
/////////////////////////////////////////////////////////////////////////
1:     while (idx>=0 && bits[idx / PAGE_SIZE][idx % PAGE_SIZE]==0) idx--;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
0:     int aPageSize = this.PAGE_SIZE;
0:     int bPageSize = b.PAGE_SIZE;
1:       if (a.bits[i/aPageSize][i % aPageSize]!=0) return false;
1:       if (a.bits[i/aPageSize][i % aPageSize] != b.bits[i/bPageSize][i % bPageSize]) return false;
/////////////////////////////////////////////////////////////////////////
0:     for (int i = wlen; --i>=0;) {
1:       h ^= bits[i / PAGE_SIZE][i % PAGE_SIZE];
commit:6cb811b
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.utils.obs;
1: 
1: import java.util.Arrays;
0: import java.io.Serializable;
0: import java.util.BitSet;
1: 
0: /** An "open" BitSet implementation that allows direct access to the array of words
0:  * storing the bits.
0:  * <p/>
1:  * Unlike java.util.bitset, the fact that bits are packed into an array of longs
1:  * is part of the interface.  This allows efficient implementation of other algorithms
1:  * by someone other than the author.  It also allows one to efficiently implement
1:  * alternate serialization or interchange formats.
0:  * <p/>
1:  * <code>OpenBitSet</code> is faster than <code>java.util.BitSet</code> in most operations
1:  * and *much* faster at calculating cardinality of sets and results of set operations.
1:  * It can also handle sets of larger cardinality (up to 64 * 2**32-1)
0:  * <p/>
1:  * The goals of <code>OpenBitSet</code> are the fastest implementation possible, and
1:  * maximum code reuse.  Extra safety and encapsulation
1:  * may always be built on top, but if that's built in, the cost can never be removed (and
1:  * hence people re-implement their own version in order to get better performance).
1:  * If you want a "safe", totally encapsulated (and slower and limited) BitSet
1:  * class, use <code>java.util.BitSet</code>.
0:  * <p/>
0:  * <h3>Performance Results</h3>
1:  *
0:  Test system: Pentium 4, Sun Java 1.5_06 -server -Xbatch -Xmx64M
0: <br/>BitSet size = 1,000,000
0: <br/>Results are java.util.BitSet time divided by OpenBitSet time.
0: <table border="1">
0:  <tr>
0:   <th></th> <th>cardinality</th> <th>intersect_count</th> <th>union</th> <th>nextSetBit</th> <th>get</th> <th>iterator</th>
0:  </tr>
0:  <tr>
0:   <th>50% full</th> <td>3.36</td> <td>3.96</td> <td>1.44</td> <td>1.46</td> <td>1.99</td> <td>1.58</td>
0:  </tr>
0:  <tr>
0:    <th>1% full</th> <td>3.31</td> <td>3.90</td> <td>&nbsp;</td> <td>1.04</td> <td>&nbsp;</td> <td>0.99</td>
0:  </tr>
0: </table>
0: <br/>
0: Test system: AMD Opteron, 64 bit linux, Sun Java 1.5_06 -server -Xbatch -Xmx64M
0: <br/>BitSet size = 1,000,000
0: <br/>Results are java.util.BitSet time divided by OpenBitSet time.
0: <table border="1">
0:  <tr>
0:   <th></th> <th>cardinality</th> <th>intersect_count</th> <th>union</th> <th>nextSetBit</th> <th>get</th> <th>iterator</th>
0:  </tr>
0:  <tr>
0:   <th>50% full</th> <td>2.50</td> <td>3.50</td> <td>1.00</td> <td>1.03</td> <td>1.12</td> <td>1.25</td>
0:  </tr>
0:  <tr>
0:    <th>1% full</th> <td>2.51</td> <td>3.49</td> <td>&nbsp;</td> <td>1.00</td> <td>&nbsp;</td> <td>1.02</td>
0:  </tr>
0: </table>
1:  */
1: 
0: public class OpenBitSet implements Cloneable, Serializable {
0:   protected long[] bits;
0:   protected int wlen;   // number of words (elements) used in the array
1: 
0:   /** Constructs an OpenBitSet large enough to hold numBits.
1:    *
1:    * @param numBits
1:    */
0:   public OpenBitSet(long numBits) {
0:     bits = new long[bits2words(numBits)];
0:     wlen = bits.length;
1:   }
1: 
0:   public OpenBitSet() {
1:     this(64);
1:   }
1: 
0:   /** Constructs an OpenBitSet from an existing long[].
0:    * <br/>
0:    * The first 64 bits are in long[0],
0:    * with bit index 0 at the least significant bit, and bit index 63 at the most significant.
0:    * Given a bit index,
0:    * the word containing it is long[index/64], and it is at bit number index%64 within that word.
0:    * <p>
0:    * numWords are the number of elements in the array that contain
0:    * set bits (non-zero longs).
0:    * numWords should be &lt= bits.length, and
0:    * any existing words in the array at position &gt= numWords should be zero.
1:    *
1:    */
0:   public OpenBitSet(long[] bits, int numWords) {
0:     this.bits = bits;
0:     this.wlen = numWords;
1:   }
1: 
1: 
0:   /** Contructs an OpenBitset from a BitSet
1:   */
0:   public OpenBitSet(BitSet bits) {
0:     this(bits.length());
1:   }
1: 
1:   /** Returns the current capacity in bits (1 greater than the index of the last bit) */
0:   public long capacity() { return bits.length << 6; }
1: 
0:  /**
1:   * Returns the current capacity of this set.  Included for
1:   * compatibility.  This is *not* equal to {@link #cardinality}
1:   */
0:   public long size() {
1:       return capacity();
1:   }
1: 
1:   // @Override -- not until Java 1.6
0:   public int length() {
0:     return bits.length << 6;
1:   }
1: 
1:   /** Returns true if there are no set bits */
1:   public boolean isEmpty() { return cardinality()==0; }
1: 
0:   /** Expert: returns the long[] storing the bits */
0:   public long[] getBits() { return bits; }
1: 
0:   /** Expert: sets a new long[] to use as the bit storage */
0:   public void setBits(long[] bits) { this.bits = bits; }
1: 
1:   /** Expert: gets the number of longs in the array that are in use */
1:   public int getNumWords() { return wlen; }
1: 
0:   /** Expert: sets the number of longs in the array that are in use */
0:   public void setNumWords(int nWords) { this.wlen=nWords; }
1: 
1: 
1: 
0:   /** Returns true or false for the specified bit index. */
0:   public boolean get(int index) {
1:     int i = index >> 6;               // div 64
1:     // signed shift will keep a negative index and force an
1:     // array-index-out-of-bounds-exception, removing the need for an explicit check.
0:     if (i>=bits.length) return false;
1: 
1:     int bit = index & 0x3f;           // mod 64
1:     long bitmask = 1L << bit;
0:     return (bits[i] & bitmask) != 0;
1:   }
1: 
1: 
0:  /** Returns true or false for the specified bit index.
0:    * The index should be less than the OpenBitSet size
1:    */
0:   public boolean fastGet(int index) {
1:     int i = index >> 6;               // div 64
1:     // signed shift will keep a negative index and force an
1:     // array-index-out-of-bounds-exception, removing the need for an explicit check.
1:     int bit = index & 0x3f;           // mod 64
1:     long bitmask = 1L << bit;
0:     return (bits[i] & bitmask) != 0;
1:   }
1: 
1: 
1: 
0:  /** Returns true or false for the specified bit index
1:   */
0:   public boolean get(long index) {
0:     int i = (int)(index >> 6);             // div 64
0:     if (i>=bits.length) return false;
1:     int bit = (int)index & 0x3f;           // mod 64
1:     long bitmask = 1L << bit;
0:     return (bits[i] & bitmask) != 0;
1:   }
1: 
0:   /** Returns true or false for the specified bit index.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public boolean fastGet(long index) {
1:     int i = (int)(index >> 6);               // div 64
1:     int bit = (int)index & 0x3f;           // mod 64
1:     long bitmask = 1L << bit;
0:     return (bits[i] & bitmask) != 0;
1:   }
1: 
1:   /*
0:   // alternate implementation of get()
0:   public boolean get1(int index) {
0:     int i = index >> 6;                // div 64
0:     int bit = index & 0x3f;            // mod 64
0:     return ((bits[i]>>>bit) & 0x01) != 0;
0:     // this does a long shift and a bittest (on x86) vs
0:     // a long shift, and a long AND, (the test for zero is prob a no-op)
0:     // testing on a P4 indicates this is slower than (bits[i] & bitmask) != 0;
1:   }
1:   */
1: 
1: 
0:   /** returns 1 if the bit is set, 0 if not.
0:    * The index should be less than the OpenBitSet size
1:    */
0:   public int getBit(int index) {
0:     int i = index >> 6;                // div 64
0:     int bit = index & 0x3f;            // mod 64
0:     return ((int)(bits[i]>>>bit)) & 0x01;
1:   }
1: 
1: 
1:   /*
0:   public boolean get2(int index) {
0:     int word = index >> 6;            // div 64
0:     int bit = index & 0x0000003f;     // mod 64
0:     return (bits[word] << bit) < 0;   // hmmm, this would work if bit order were reversed
0:     // we could right shift and check for parity bit, if it was available to us.
1:   }
1:   */
1: 
0:   /** sets a bit, expanding the set size if necessary */
0:   public void set(long index) {
0:     int wordNum = expandingWordNum(index);
1:     int bit = (int)index & 0x3f;
1:     long bitmask = 1L << bit;
0:     bits[wordNum] |= bitmask;
1:   }
1: 
1: 
0:  /** Sets the bit at the specified index.
1:   * The index should be less than the OpenBitSet size.
1:   */
0:   public void fastSet(int index) {
1:     int wordNum = index >> 6;      // div 64
1:     int bit = index & 0x3f;     // mod 64
1:     long bitmask = 1L << bit;
0:     bits[wordNum] |= bitmask;
1:   }
1: 
0:  /** Sets the bit at the specified index.
1:   * The index should be less than the OpenBitSet size.
1:   */
0:   public void fastSet(long index) {
0:     int wordNum = (int)(index >> 6);
1:     int bit = (int)index & 0x3f;
1:     long bitmask = 1L << bit;
0:     bits[wordNum] |= bitmask;
1:   }
1: 
0:   /** Sets a range of bits, expanding the set size if necessary
1:    *
1:    * @param startIndex lower index
0:    * @param endIndex one-past the last bit to set
1:    */
0:   public void set(long startIndex, long endIndex) {
1:     if (endIndex <= startIndex) return;
1: 
1:     int startWord = (int)(startIndex>>6);
1: 
1:     // since endIndex is one past the end, this is index of the last
1:     // word to be changed.
0:     int endWord   = expandingWordNum(endIndex-1);
1: 
1:     long startmask = -1L << startIndex;
1:     long endmask = -1L >>> -endIndex;  // 64-(endIndex&0x3f) is the same as -endIndex due to wrap
1: 
0:     if (startWord == endWord) {
0:       bits[startWord] |= (startmask & endmask);
1:       return;
1:     }
1: 
0:     bits[startWord] |= startmask;
0:     Arrays.fill(bits, startWord+1, endWord, -1L);
0:     bits[endWord] |= endmask;
1:   }
1: 
1: 
1: 
0:   protected int expandingWordNum(long index) {
0:     int wordNum = (int)(index >> 6);
0:     if (wordNum>=wlen) {
0:       ensureCapacity(index+1);
0:       wlen = wordNum+1;
1:     }
0:     return wordNum;
1:   }
1: 
1: 
0:   /** clears a bit.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public void fastClear(int index) {
1:     int wordNum = index >> 6;
1:     int bit = index & 0x03f;
1:     long bitmask = 1L << bit;
0:     bits[wordNum] &= ~bitmask;
1:     // hmmm, it takes one more instruction to clear than it does to set... any
1:     // way to work around this?  If there were only 63 bits per word, we could
1:     // use a right shift of 10111111...111 in binary to position the 0 in the
1:     // correct place (using sign extension).
1:     // Could also use Long.rotateRight() or rotateLeft() *if* they were converted
1:     // by the JVM into a native instruction.
1:     // bits[word] &= Long.rotateLeft(0xfffffffe,bit);
1:   }
1: 
0:   /** clears a bit.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public void fastClear(long index) {
1:     int wordNum = (int)(index >> 6); // div 64
1:     int bit = (int)index & 0x3f;     // mod 64
1:     long bitmask = 1L << bit;
0:     bits[wordNum] &= ~bitmask;
1:   }
1: 
0:   /** clears a bit, allowing access beyond the current set size without changing the size.*/
0:   public void clear(long index) {
1:     int wordNum = (int)(index >> 6); // div 64
0:     if (wordNum>=wlen) return;
1:     int bit = (int)index & 0x3f;     // mod 64
1:     long bitmask = 1L << bit;
0:     bits[wordNum] &= ~bitmask;
1:   }
1: 
1:   /** Clears a range of bits.  Clearing past the end does not change the size of the set.
1:    *
1:    * @param startIndex lower index
1:    * @param endIndex one-past the last bit to clear
1:    */
0:   public void clear(int startIndex, int endIndex) {
1:     if (endIndex <= startIndex) return;
1: 
1:     int startWord = (startIndex>>6);
1:     if (startWord >= wlen) return;
1: 
1:     // since endIndex is one past the end, this is index of the last
1:     // word to be changed.
1:     int endWord   = ((endIndex-1)>>6);
1: 
1:     long startmask = -1L << startIndex;
1:     long endmask = -1L >>> -endIndex;  // 64-(endIndex&0x3f) is the same as -endIndex due to wrap
1: 
1:     // invert masks since we are clearing
1:     startmask = ~startmask;
1:     endmask = ~endmask;
1: 
0:     if (startWord == endWord) {
0:       bits[startWord] &= (startmask | endmask);
1:       return;
1:     }
1: 
0:     bits[startWord] &= startmask;
1: 
1:     int middle = Math.min(wlen, endWord);
0:     Arrays.fill(bits, startWord+1, middle, 0L);
0:     if (endWord < wlen) {
0:       bits[endWord] &= endmask;
1:     }
1:   }
1: 
1: 
1:   /** Clears a range of bits.  Clearing past the end does not change the size of the set.
1:    *
1:    * @param startIndex lower index
1:    * @param endIndex one-past the last bit to clear
1:    */
0:   public void clear(long startIndex, long endIndex) {
1:     if (endIndex <= startIndex) return;
1: 
1:     int startWord = (int)(startIndex>>6);
1:     if (startWord >= wlen) return;
1: 
1:     // since endIndex is one past the end, this is index of the last
1:     // word to be changed.
1:     int endWord   = (int)((endIndex-1)>>6);
1: 
1:     long startmask = -1L << startIndex;
1:     long endmask = -1L >>> -endIndex;  // 64-(endIndex&0x3f) is the same as -endIndex due to wrap
1: 
1:     // invert masks since we are clearing
1:     startmask = ~startmask;
1:     endmask = ~endmask;
1: 
0:     if (startWord == endWord) {
0:       bits[startWord] &= (startmask | endmask);
1:       return;
1:     }
1: 
0:     bits[startWord] &= startmask;
1: 
1:     int middle = Math.min(wlen, endWord);
0:     Arrays.fill(bits, startWord+1, middle, 0L);
0:     if (endWord < wlen) {
0:       bits[endWord] &= endmask;
1:     }
1:   }
1: 
1: 
1: 
0:   /** Sets a bit and returns the previous value.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public boolean getAndSet(int index) {
1:     int wordNum = index >> 6;      // div 64
1:     int bit = index & 0x3f;     // mod 64
1:     long bitmask = 1L << bit;
0:     boolean val = (bits[wordNum] & bitmask) != 0;
0:     bits[wordNum] |= bitmask;
0:     return val;
1:   }
1: 
0:   /** Sets a bit and returns the previous value.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public boolean getAndSet(long index) {
0:     int wordNum = (int)(index >> 6);      // div 64
1:     int bit = (int)index & 0x3f;     // mod 64
1:     long bitmask = 1L << bit;
0:     boolean val = (bits[wordNum] & bitmask) != 0;
0:     bits[wordNum] |= bitmask;
0:     return val;
1:   }
1: 
0:   /** flips a bit.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public void fastFlip(int index) {
1:     int wordNum = index >> 6;      // div 64
1:     int bit = index & 0x3f;     // mod 64
1:     long bitmask = 1L << bit;
0:     bits[wordNum] ^= bitmask;
1:   }
1: 
0:   /** flips a bit.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public void fastFlip(long index) {
0:     int wordNum = (int)(index >> 6);   // div 64
0:     int bit = (int)index & 0x3f;       // mod 64
1:     long bitmask = 1L << bit;
0:     bits[wordNum] ^= bitmask;
1:   }
1: 
0:   /** flips a bit, expanding the set size if necessary */
0:   public void flip(long index) {
0:     int wordNum = expandingWordNum(index);
0:     int bit = (int)index & 0x3f;       // mod 64
1:     long bitmask = 1L << bit;
0:     bits[wordNum] ^= bitmask;
1:   }
1: 
0:   /** flips a bit and returns the resulting bit value.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public boolean flipAndGet(int index) {
1:     int wordNum = index >> 6;      // div 64
1:     int bit = index & 0x3f;     // mod 64
1:     long bitmask = 1L << bit;
0:     bits[wordNum] ^= bitmask;
0:     return (bits[wordNum] & bitmask) != 0;
1:   }
1: 
0:   /** flips a bit and returns the resulting bit value.
1:    * The index should be less than the OpenBitSet size.
1:    */
0:   public boolean flipAndGet(long index) {
0:     int wordNum = (int)(index >> 6);   // div 64
0:     int bit = (int)index & 0x3f;       // mod 64
1:     long bitmask = 1L << bit;
0:     bits[wordNum] ^= bitmask;
0:     return (bits[wordNum] & bitmask) != 0;
1:   }
1: 
0:   /** Flips a range of bits, expanding the set size if necessary
1:    *
1:    * @param startIndex lower index
0:    * @param endIndex one-past the last bit to flip
1:    */
0:   public void flip(long startIndex, long endIndex) {
1:     if (endIndex <= startIndex) return;
1:     int startWord = (int)(startIndex>>6);
1: 
1:     // since endIndex is one past the end, this is index of the last
1:     // word to be changed.
0:     int endWord   = expandingWordNum(endIndex-1);
1: 
0:     /*** Grrr, java shifting wraps around so -1L>>>64 == -1
0:      * for that reason, make sure not to use endmask if the bits to flip will
0:      * be zero in the last word (redefine endWord to be the last changed...)
0:     long startmask = -1L << (startIndex & 0x3f);     // example: 11111...111000
0:     long endmask = -1L >>> (64-(endIndex & 0x3f));   // example: 00111...111111
0:     ***/
1: 
1:     long startmask = -1L << startIndex;
1:     long endmask = -1L >>> -endIndex;  // 64-(endIndex&0x3f) is the same as -endIndex due to wrap
1: 
0:     if (startWord == endWord) {
0:       bits[startWord] ^= (startmask & endmask);
1:       return;
1:     }
1: 
0:     bits[startWord] ^= startmask;
1: 
0:     for (int i=startWord+1; i<endWord; i++) {
0:       bits[i] = ~bits[i];
1:     }
1: 
0:     bits[endWord] ^= endmask;
1:   }
1: 
1: 
1:   /*
0:   public static int pop(long v0, long v1, long v2, long v3) {
0:     // derived from pop_array by setting last four elems to 0.
0:     // exchanges one pop() call for 10 elementary operations
0:     // saving about 7 instructions... is there a better way?
0:       long twosA=v0 & v1;
0:       long ones=v0^v1;
1: 
0:       long u2=ones^v2;
0:       long twosB =(ones&v2)|(u2&v3);
0:       ones=u2^v3;
1: 
0:       long fours=(twosA&twosB);
0:       long twos=twosA^twosB;
1: 
0:       return (pop(fours)<<2)
0:              + (pop(twos)<<1)
0:              + pop(ones);
1: 
1:   }
1:   */
1: 
1: 
1:   /** @return the number of set bits */
0:   public long cardinality() {
0:     return BitUtil.pop_array(bits,0,wlen);
1:   }
1: 
0:  /** Returns the popcount or cardinality of the intersection of the two sets.
0:    * Neither set is modified.
1:    */
0:   public static long intersectionCount(OpenBitSet a, OpenBitSet b) {
0:     return BitUtil.pop_intersect(a.bits, b.bits, 0, Math.min(a.wlen, b.wlen));
1:  }
1: 
0:   /** Returns the popcount or cardinality of the union of the two sets.
0:     * Neither set is modified.
1:     */
0:   public static long unionCount(OpenBitSet a, OpenBitSet b) {
0:     long tot = BitUtil.pop_union(a.bits, b.bits, 0, Math.min(a.wlen, b.wlen));
0:     if (a.wlen < b.wlen) {
0:       tot += BitUtil.pop_array(b.bits, a.wlen, b.wlen-a.wlen);
0:     } else if (a.wlen > b.wlen) {
0:       tot += BitUtil.pop_array(a.bits, b.wlen, a.wlen-b.wlen);
1:     }
0:     return tot;
1:   }
1: 
0:   /** Returns the popcount or cardinality of "a and not b"
0:    * or "intersection(a, not(b))".
0:    * Neither set is modified.
1:    */
0:   public static long andNotCount(OpenBitSet a, OpenBitSet b) {
0:     long tot = BitUtil.pop_andnot(a.bits, b.bits, 0, Math.min(a.wlen, b.wlen));
0:     if (a.wlen > b.wlen) {
0:       tot += BitUtil.pop_array(a.bits, b.wlen, a.wlen-b.wlen);
1:     }
0:     return tot;
1:   }
1: 
0:  /** Returns the popcount or cardinality of the exclusive-or of the two sets.
0:   * Neither set is modified.
1:   */
0:   public static long xorCount(OpenBitSet a, OpenBitSet b) {
0:     long tot = BitUtil.pop_xor(a.bits, b.bits, 0, Math.min(a.wlen, b.wlen));
0:     if (a.wlen < b.wlen) {
0:       tot += BitUtil.pop_array(b.bits, a.wlen, b.wlen-a.wlen);
0:     } else if (a.wlen > b.wlen) {
0:       tot += BitUtil.pop_array(a.bits, b.wlen, a.wlen-b.wlen);
1:     }
0:     return tot;
1:   }
1: 
1: 
0:   /** Returns the index of the first set bit starting at the index specified.
0:    *  -1 is returned if there are no more set bits.
1:    */
0:   public int nextSetBit(int index) {
0:     int i = index>>6;
0:     if (i>=wlen) return -1;
0:     int subIndex = index & 0x3f;      // index within the word
0:     long word = bits[i] >> subIndex;  // skip all the bits to the right of index
1: 
0:     if (word!=0) {
0:       return (i<<6) + subIndex + BitUtil.ntz(word);
1:     }
1: 
0:     while(++i < wlen) {
0:       word = bits[i];
0:       if (word!=0) return (i<<6) + BitUtil.ntz(word);
1:     }
1: 
0:     return -1;
1:   }
1: 
0:   /** Returns the index of the first set bit starting at the index specified.
0:    *  -1 is returned if there are no more set bits.
1:    */
0:   public long nextSetBit(long index) {
0:     int i = (int)(index>>>6);
0:     if (i>=wlen) return -1;
0:     int subIndex = (int)index & 0x3f; // index within the word
0:     long word = bits[i] >>> subIndex;  // skip all the bits to the right of index
1: 
0:     if (word!=0) {
0:       return (((long)i)<<6) + (subIndex + BitUtil.ntz(word));
1:     }
1: 
0:     while(++i < wlen) {
0:       word = bits[i];
0:       if (word!=0) return (((long)i)<<6) + BitUtil.ntz(word);
1:     }
1: 
0:     return -1;
1:   }
1: 
1: 
1: 
1: 
1:   @Override
0:   public Object clone() {
0:     try {
0:       OpenBitSet obs = (OpenBitSet)super.clone();
0:       obs.bits = obs.bits.clone();  // hopefully an array clone is as fast(er) than arraycopy
0:       return obs;
0:     } catch (CloneNotSupportedException e) {
0:       throw new RuntimeException(e);
1:     }
1:   }
1: 
1:   /** this = this AND other */
0:   public void intersect(OpenBitSet other) {
1:     int newLen= Math.min(this.wlen,other.wlen);
0:     long[] thisArr = this.bits;
0:     long[] otherArr = other.bits;
1:     // testing against zero can be more efficient
1:     int pos=newLen;
0:     while(--pos>=0) {
0:       thisArr[pos] &= otherArr[pos];
1:     }
0:     if (this.wlen > newLen) {
1:       // fill zeros from the new shorter length to the old length
0:       Arrays.fill(bits,newLen,this.wlen,0);
1:     }
1:     this.wlen = newLen;
1:   }
1: 
0:   /** this = this OR other */
0:   public void union(OpenBitSet other) {
0:     int newLen = Math.max(wlen,other.wlen);
0:     ensureCapacityWords(newLen);
1: 
0:     long[] thisArr = this.bits;
0:     long[] otherArr = other.bits;
0:     int pos=Math.min(wlen,other.wlen);
0:     while(--pos>=0) {
0:       thisArr[pos] |= otherArr[pos];
1:     }
0:     if (this.wlen < newLen) {
0:       System.arraycopy(otherArr, this.wlen, thisArr, this.wlen, newLen-this.wlen);
1:     }
1:     this.wlen = newLen;
1:   }
1: 
1: 
0:   /** Remove all elements set in other. this = this AND_NOT other */
0:   public void remove(OpenBitSet other) {
0:     int idx = Math.min(wlen,other.wlen);
0:     long[] thisArr = this.bits;
0:     long[] otherArr = other.bits;
0:     while(--idx>=0) {
0:       thisArr[idx] &= ~otherArr[idx];
1:     }
1:   }
1: 
0:   /** this = this XOR other */
0:   public void xor(OpenBitSet other) {
0:     int newLen = Math.max(wlen,other.wlen);
0:     ensureCapacityWords(newLen);
1: 
0:     long[] thisArr = this.bits;
0:     long[] otherArr = other.bits;
0:     int pos=Math.min(wlen,other.wlen);
0:     while(--pos>=0) {
0:       thisArr[pos] ^= otherArr[pos];
1:     }
0:     if (this.wlen < newLen) {
0:       System.arraycopy(otherArr, this.wlen, thisArr, this.wlen, newLen-this.wlen);
1:     }
1:     this.wlen = newLen;
1:   }
1: 
1: 
1:   // some BitSet compatability methods
1: 
1:   //** see {@link intersect} */
0:   public void and(OpenBitSet other) {
1:     intersect(other);
1:   }
1: 
0:   //** see {@link union} */
0:   public void or(OpenBitSet other) {
0:     union(other);
1:   }
1: 
0:   //** see {@link andNot} */
0:   public void andNot(OpenBitSet other) {
0:     remove(other);
1:   }
1: 
0:   /** returns true if the sets have any elements in common */
0:   public boolean intersects(OpenBitSet other) {
0:     int pos = Math.min(this.wlen, other.wlen);
0:     long[] thisArr = this.bits;
0:     long[] otherArr = other.bits;
0:     while (--pos>=0) {
0:       if ((thisArr[pos] & otherArr[pos])!=0) return true;
1:     }
0:     return false;
1:   }
1: 
1: 
1: 
0:   /** Expand the long[] with the size given as a number of words (64 bit longs).
0:    * getNumWords() is unchanged by this call.
1:    */
0:   public void ensureCapacityWords(int numWords) {
0:     if (bits.length < numWords) {
0:       bits = ArrayUtil.grow(bits, numWords);
1:     }
1:   }
1: 
0:   /** Ensure that the long[] is big enough to hold numBits, expanding it if necessary.
0:    * getNumWords() is unchanged by this call.
1:    */
0:   public void ensureCapacity(long numBits) {
0:     ensureCapacityWords(bits2words(numBits));
1:   }
1: 
1:   /** Lowers numWords, the number of words in use,
1:    * by checking for trailing zero words.
1:    */
0:   public void trimTrailingZeros() {
1:     int idx = wlen-1;
0:     while (idx>=0 && bits[idx]==0) idx--;
1:     wlen = idx+1;
1:   }
1: 
1:   /** returns the number of 64 bit words it would take to hold numBits */
0:   public static int bits2words(long numBits) {
0:    return (int)(((numBits-1)>>>6)+1);
1:   }
1: 
1: 
1:   /** returns true if both sets have the same bits set */
1:   @Override
0:   public boolean equals(Object o) {
1:     if (this == o) return true;
1:     if (!(o instanceof OpenBitSet)) return false;
1:     OpenBitSet a;
1:     OpenBitSet b = (OpenBitSet)o;
1:     // make a the larger set.
0:     if (b.wlen > this.wlen) {
1:       a = b; b=this;
0:     } else {
1:       a=this;
1:     }
1: 
1:     // check for any set bits out of the range of b
0:     for (int i=a.wlen-1; i>=b.wlen; i--) {
0:       if (a.bits[i]!=0) return false;
1:     }
1: 
0:     for (int i=b.wlen-1; i>=0; i--) {
0:       if (a.bits[i] != b.bits[i]) return false;
1:     }
1: 
1:     return true;
1:   }
1: 
1: 
1:   @Override
0:   public int hashCode() {
1:     // Start with a zero hash and use a mix that results in zero if the input is zero.
1:     // This effectively truncates trailing zeros without an explicit check.
1:     long h = 0;
0:     for (int i = bits.length; --i>=0;) {
0:       h ^= bits[i];
1:       h = (h << 1) | (h >>> 63); // rotate left
1:     }
1:     // fold leftmost bits into right and add a constant to prevent
1:     // empty sets from returning 0, which is too common.
1:     return (int)((h>>32) ^ h) + 0x98761234;
1:   }
1: 
1: }
1: 
1: 
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0:   public OpenBitSet(long numBits)
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:   public long cardinality()
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0:   public OpenBitSet(long numBits)
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:   public long cardinality()
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
0: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
/////////////////////////////////////////////////////////////////////////
commit:e37bd7e
/////////////////////////////////////////////////////////////////////////
0:   private final int pageCount;
/////////////////////////////////////////////////////////////////////////
0:     int lastPageSize = wlen % PAGE_SIZE;
0:     int fullPageCount = wlen / PAGE_SIZE;
0:     pageCount = fullPageCount + (lastPageSize == 0 ? 0 : 1);
0:     bits = new long[pageCount][];
0: 
0:         for (int i = 0; i < fullPageCount; ++i)
0:             bits[i] = new long[PAGE_SIZE];
0: 
0:         if (lastPageSize != 0)
0:             bits[bits.length - 1] = new long[lastPageSize];
/////////////////////////////////////////////////////////////////////////
1:       return pageCount;
============================================================================