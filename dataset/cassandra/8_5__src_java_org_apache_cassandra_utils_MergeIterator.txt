1:35d9347: /*
1:07cf56f:  * Licensed to the Apache Software Foundation (ASF) under one
1:07cf56f:  * or more contributor license agreements.  See the NOTICE file
1:07cf56f:  * distributed with this work for additional information
1:07cf56f:  * regarding copyright ownership.  The ASF licenses this file
1:07cf56f:  * to you under the Apache License, Version 2.0 (the
1:07cf56f:  * "License"); you may not use this file except in compliance
1:07cf56f:  * with the License.  You may obtain a copy of the License at
1:07cf56f:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:07cf56f:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:07cf56f:  */
1:35d9347: package org.apache.cassandra.utils;
11:35d9347: 
1:a4f75e2: import java.util.*;
1:35d9347: 
1:35d9347: /** Merges sorted input iterators which individually contain unique items. */
1:a4f75e2: public abstract class MergeIterator<In,Out> extends AbstractIterator<Out> implements IMergeIterator<In, Out>
10:35d9347: {
1:a4f75e2:     protected final Reducer<In,Out> reducer;
1:177bf5f:     protected final List<? extends Iterator<In>> iterators;
1:35d9347: 
1:177bf5f:     protected MergeIterator(List<? extends Iterator<In>> iters, Reducer<In, Out> reducer)
1:35d9347:     {
1:35d9347:         this.iterators = iters;
1:a4f75e2:         this.reducer = reducer;
10:35d9347:     }
1:f64c17e: 
1:a991b64:     public static <In, Out> MergeIterator<In, Out> get(List<? extends Iterator<In>> sources,
1:a991b64:                                                        Comparator<? super In> comparator,
1:a991b64:                                                        Reducer<In, Out> reducer)
1:35d9347:     {
1:a4f75e2:         if (sources.size() == 1)
1:9881ea6:         {
1:2a585c0:             return reducer.trivialReduceIsTrivial()
1:9881ea6:                  ? new TrivialOneToOne<>(sources, reducer)
1:9881ea6:                  : new OneToOne<>(sources, reducer);
1:9881ea6:         }
1:9881ea6:         return new ManyToOne<>(sources, comparator, reducer);
1:35d9347:     }
1:35d9347: 
1:177bf5f:     public Iterable<? extends Iterator<In>> iterators()
1:35d9347:     {
1:35d9347:         return iterators;
1:35d9347:     }
1:35d9347: 
1:35d9347:     public void close()
1:35d9347:     {
1:177bf5f:         for (Iterator<In> iterator : this.iterators)
1:35d9347:         {
1:35d9347:             try
1:35d9347:             {
1:a991b64:                 if (iterator instanceof AutoCloseable)
1:a991b64:                     ((AutoCloseable)iterator).close();
1:35d9347:             }
1:a991b64:             catch (Exception e)
1:35d9347:             {
1:debb15e:                 throw new RuntimeException(e);
1:35d9347:             }
1:35d9347:         }
1:35d9347: 
1:f64c17e:         reducer.close();
1:35d9347:     }
1:35d9347: 
1:c29001b:     /**
1:c29001b:      * A MergeIterator that consumes multiple input values per output value.
1:c29001b:      *
1:c29001b:      * The most straightforward way to implement this is to use a {@code PriorityQueue} of iterators, {@code poll} it to
1:c29001b:      * find the next item to consume, then {@code add} the iterator back after advancing. This is not very efficient as
1:c29001b:      * {@code poll} and {@code add} in all cases require at least {@code log(size)} comparisons (usually more than
1:c29001b:      * {@code 2*log(size)}) per consumed item, even if the input is suitable for fast iteration.
1:c29001b:      *
1:c29001b:      * The implementation below makes use of the fact that replacing the top element in a binary heap can be done much
1:c29001b:      * more efficiently than separately removing it and placing it back, especially in the cases where the top iterator
1:c29001b:      * is to be used again very soon (e.g. when there are large sections of the output where only a limited number of
1:c29001b:      * input iterators overlap, which is normally the case in many practically useful situations, e.g. levelled
1:c29001b:      * compaction). To further improve this particular scenario, we also use a short sorted section at the start of the
1:c29001b:      * queue.
1:c29001b:      *
1:c29001b:      * The heap is laid out as this (for {@code SORTED_SECTION_SIZE == 2}):
1:c29001b:      *                 0
1:c29001b:      *                 |
1:c29001b:      *                 1
1:c29001b:      *                 |
1:c29001b:      *                 2
1:c29001b:      *               /   \
1:c29001b:      *              3     4
1:c29001b:      *             / \   / \
1:c29001b:      *             5 6   7 8
1:c29001b:      *            .. .. .. ..
1:c29001b:      * Where each line is a <= relationship.
1:c29001b:      *
1:c29001b:      * In the sorted section we can advance with a single comparison per level, while advancing a level within the heap
1:c29001b:      * requires two (so that we can find the lighter element to pop up).
1:c29001b:      * The sorted section adds a constant overhead when data is uniformly distributed among the iterators, but may up
1:c29001b:      * to halve the iteration time when one iterator is dominant over sections of the merged data (as is the case with
1:c29001b:      * non-overlapping iterators).
1:c29001b:      *
1:c29001b:      * The iterator is further complicated by the need to avoid advancing the input iterators until an output is
1:c29001b:      * actually requested. To achieve this {@code consume} walks the heap to find equal items without advancing the
1:c29001b:      * iterators, and {@code advance} moves them and restores the heap structure before any items can be consumed.
1:c29001b:      * 
1:c29001b:      * To avoid having to do additional comparisons in consume to identify the equal items, we keep track of equality
1:c29001b:      * between children and their parents in the heap. More precisely, the lines in the diagram above define the
1:c29001b:      * following relationship:
1:c29001b:      *   parent <= child && (parent == child) == child.equalParent
1:c29001b:      * We can track, make use of and update the equalParent field without any additional comparisons.
1:c29001b:      *
1:c29001b:      * For more formal definitions and proof of correctness, see CASSANDRA-8915.
1:c29001b:      */
1:c29001b:     static final class ManyToOne<In,Out> extends MergeIterator<In,Out>
1:35d9347:     {
1:c29001b:         protected final Candidate<In>[] heap;
1:c29001b: 
1:c29001b:         /** Number of non-exhausted iterators. */
1:c29001b:         int size;
1:c29001b: 
1:c29001b:         /**
1:c29001b:          * Position of the deepest, right-most child that needs advancing before we can start consuming.
1:c29001b:          * Because advancing changes the values of the items of each iterator, the parent-chain from any position
1:c29001b:          * in this range that needs advancing is not in correct order. The trees rooted at any position that does
1:c29001b:          * not need advancing, however, retain their prior-held binary heap property.
1:c29001b:          */
1:c29001b:         int needingAdvance;
1:c29001b: 
1:c29001b:         /**
1:c29001b:          * The number of elements to keep in order before the binary heap starts, exclusive of the top heap element.
1:c29001b:          */
1:c29001b:         static final int SORTED_SECTION_SIZE = 4;
1:c29001b: 
1:a991b64:         public ManyToOne(List<? extends Iterator<In>> iters, Comparator<? super In> comp, Reducer<In, Out> reducer)
1:35d9347:         {
1:a4f75e2:             super(iters, reducer);
1:c29001b: 
1:c29001b:             @SuppressWarnings("unchecked")
1:c29001b:             Candidate<In>[] heap = new Candidate[iters.size()];
1:c29001b:             this.heap = heap;
1:c29001b:             size = 0;
1:c29001b: 
1:a991b64:             for (int i = 0; i < iters.size(); i++)
1:a4f75e2:             {
1:a991b64:                 Candidate<In> candidate = new Candidate<>(i, iters.get(i), comp);
1:c29001b:                 heap[size++] = candidate;
1:a4f75e2:             }
1:c29001b:             needingAdvance = size;
1:35d9347:         }
1:35d9347: 
1:a4f75e2:         protected final Out computeNext()
1:a4f75e2:         {
1:a4f75e2:             advance();
1:a4f75e2:             return consume();
1:35d9347:         }
1:35d9347: 
1:c29001b:         /**
1:c29001b:          * Advance all iterators that need to be advanced and place them into suitable positions in the heap.
1:c29001b:          *
1:c29001b:          * By walking the iterators backwards we know that everything after the point being processed already forms
1:c29001b:          * correctly ordered subheaps, thus we can build a subheap rooted at the current position by only sinking down
1:c29001b:          * the newly advanced iterator. Because all parents of a consumed iterator are also consumed there is no way
1:c29001b:          * that we can process one consumed iterator but skip over its parent.
1:c29001b:          *
1:c29001b:          * The procedure is the same as the one used for the initial building of a heap in the heapsort algorithm and
1:c29001b:          * has a maximum number of comparisons {@code (2 * log(size) + SORTED_SECTION_SIZE / 2)} multiplied by the
1:c29001b:          * number of iterators whose items were consumed at the previous step, but is also at most linear in the size of
1:c29001b:          * the heap if the number of consumed elements is high (as it is in the initial heap construction). With non- or
1:c29001b:          * lightly-overlapping iterators the procedure finishes after just one (resp. a couple of) comparisons.
1:c29001b:          */
1:c29001b:         private void advance()
1:35d9347:         {
1:c29001b:             // Turn the set of candidates into a heap.
1:c29001b:             for (int i = needingAdvance - 1; i >= 0; --i)
1:35d9347:             {
1:c29001b:                 Candidate<In> candidate = heap[i];
1:c29001b:                 /**
1:c29001b:                  *  needingAdvance runs to the maximum index (and deepest-right node) that may need advancing;
1:c29001b:                  *  since the equal items that were consumed at-once may occur in sub-heap "veins" of equality,
1:c29001b:                  *  not all items above this deepest-right position may have been consumed; these already form
1:c29001b:                  *  valid sub-heaps and can be skipped-over entirely
1:c29001b:                  */
1:c29001b:                 if (candidate.needsAdvance())
1:c29001b:                     replaceAndSink(candidate.advance(), i);
1:c29001b:             }
1:35d9347:         }
1:c29001b: 
1:c29001b:         /**
1:c29001b:          * Consume all items that sort like the current top of the heap. As we cannot advance the iterators to let
1:c29001b:          * equivalent items pop up, we walk the heap to find them and mark them as needing advance.
1:c29001b:          *
1:c29001b:          * This relies on the equalParent flag to avoid doing any comparisons.
1:c29001b:          */
1:c29001b:         private Out consume()
1:c29001b:         {
1:c29001b:             if (size == 0)
1:c29001b:                 return endOfData();
1:c29001b: 
1:c29001b:             reducer.onKeyChange();
1:c29001b:             assert !heap[0].equalParent;
1:b11fba7:             heap[0].consume(reducer);
1:c29001b:             final int size = this.size;
1:c29001b:             final int sortedSectionSize = Math.min(size, SORTED_SECTION_SIZE);
1:c29001b:             int i;
1:c29001b:             consume: {
1:c29001b:                 for (i = 1; i < sortedSectionSize; ++i)
1:c29001b:                 {
1:c29001b:                     if (!heap[i].equalParent)
1:c29001b:                         break consume;
1:b11fba7:                     heap[i].consume(reducer);
1:c29001b:                 }
1:c29001b:                 i = Math.max(i, consumeHeap(i) + 1);
1:c29001b:             }
1:c29001b:             needingAdvance = i;
1:35d9347:             return reducer.getReduced();
1:35d9347:         }
1:2a585c0: 
1:c29001b:         /**
1:c29001b:          * Recursively consume all items equal to equalItem in the binary subheap rooted at position idx.
1:c29001b:          *
1:c29001b:          * @return the largest equal index found in this search.
1:c29001b:          */
1:c29001b:         private int consumeHeap(int idx)
1:2a585c0:         {
1:c29001b:             if (idx >= size || !heap[idx].equalParent)
1:c29001b:                 return -1;
1:c29001b: 
1:b11fba7:             heap[idx].consume(reducer);
1:c29001b:             int nextIdx = (idx << 1) - (SORTED_SECTION_SIZE - 1);
1:c29001b:             return Math.max(idx, Math.max(consumeHeap(nextIdx), consumeHeap(nextIdx + 1)));
1:c29001b:         }
1:c29001b: 
1:c29001b:         /**
1:c29001b:          * Replace an iterator in the heap with the given position and move it down the heap until it finds its proper
1:c29001b:          * position, pulling lighter elements up the heap.
1:c29001b:          *
1:c29001b:          * Whenever an equality is found between two elements that form a new parent-child relationship, the child's
1:c29001b:          * equalParent flag is set to true if the elements are equal.
1:c29001b:          */
1:c29001b:         private void replaceAndSink(Candidate<In> candidate, int currIdx)
1:c29001b:         {
1:c29001b:             if (candidate == null)
1:c29001b:             {
1:c29001b:                 // Drop iterator by replacing it with the last one in the heap.
1:c29001b:                 candidate = heap[--size];
1:c29001b:                 heap[size] = null; // not necessary but helpful for debugging
1:c29001b:             }
1:c29001b:             // The new element will be top of its heap, at this point there is no parent to be equal to.
1:c29001b:             candidate.equalParent = false;
1:c29001b: 
1:c29001b:             final int size = this.size;
1:c29001b:             final int sortedSectionSize = Math.min(size - 1, SORTED_SECTION_SIZE);
1:c29001b: 
1:c29001b:             int nextIdx;
1:c29001b: 
1:c29001b:             // Advance within the sorted section, pulling up items lighter than candidate.
1:c29001b:             while ((nextIdx = currIdx + 1) <= sortedSectionSize)
1:c29001b:             {
1:c29001b:                 if (!heap[nextIdx].equalParent) // if we were greater then an (or were the) equal parent, we are >= the child
1:c29001b:                 {
1:c29001b:                     int cmp = candidate.compareTo(heap[nextIdx]);
1:c29001b:                     if (cmp <= 0)
1:c29001b:                     {
1:c29001b:                         heap[nextIdx].equalParent = cmp == 0;
1:c29001b:                         heap[currIdx] = candidate;
1:c29001b:                         return;
1:c29001b:                     }
1:c29001b:                 }
1:c29001b: 
1:c29001b:                 heap[currIdx] = heap[nextIdx];
1:c29001b:                 currIdx = nextIdx;
1:c29001b:             }
1:c29001b:             // If size <= SORTED_SECTION_SIZE, nextIdx below will be no less than size,
1:c29001b:             // because currIdx == sortedSectionSize == size - 1 and nextIdx becomes
1:c29001b:             // (size - 1) * 2) - (size - 1 - 1) == size.
1:c29001b: 
1:c29001b:             // Advance in the binary heap, pulling up the lighter element from the two at each level.
1:c29001b:             while ((nextIdx = (currIdx * 2) - (sortedSectionSize - 1)) + 1 < size)
1:c29001b:             {
1:c29001b:                 if (!heap[nextIdx].equalParent)
1:c29001b:                 {
1:c29001b:                     if (!heap[nextIdx + 1].equalParent)
1:c29001b:                     {
1:c29001b:                         // pick the smallest of the two children
1:c29001b:                         int siblingCmp = heap[nextIdx + 1].compareTo(heap[nextIdx]);
1:c29001b:                         if (siblingCmp < 0)
1:c29001b:                             ++nextIdx;
1:c29001b: 
1:c29001b:                         // if we're smaller than this, we are done, and must only restore the heap and equalParent properties
1:c29001b:                         int cmp = candidate.compareTo(heap[nextIdx]);
1:c29001b:                         if (cmp <= 0)
1:c29001b:                         {
1:c29001b:                             if (cmp == 0)
1:c29001b:                             {
1:c29001b:                                 heap[nextIdx].equalParent = true;
1:c29001b:                                 if (siblingCmp == 0) // siblingCmp == 0 => nextIdx is the left child
1:c29001b:                                     heap[nextIdx + 1].equalParent = true;
1:c29001b:                             }
1:c29001b: 
1:c29001b:                             heap[currIdx] = candidate;
1:c29001b:                             return;
1:c29001b:                         }
1:c29001b: 
1:c29001b:                         if (siblingCmp == 0)
1:c29001b:                         {
1:c29001b:                             // siblingCmp == 0 => nextIdx is still the left child
1:c29001b:                             // if the two siblings were equal, and we are inserting something greater, we will
1:c29001b:                             // pull up the left one; this means the right gets an equalParent
1:c29001b:                             heap[nextIdx + 1].equalParent = true;
1:c29001b:                         }
1:c29001b:                     }
1:c29001b:                     else
1:c29001b:                         ++nextIdx;  // descend down the path where we found the equal child
1:c29001b:                 }
1:c29001b: 
1:c29001b:                 heap[currIdx] = heap[nextIdx];
1:c29001b:                 currIdx = nextIdx;
1:c29001b:             }
1:c29001b: 
1:c29001b:             // our loop guard ensures there are always two siblings to process; typically when we exit the loop we will
1:c29001b:             // be well past the end of the heap and this next condition will match...
1:c29001b:             if (nextIdx >= size)
1:c29001b:             {
1:c29001b:                 heap[currIdx] = candidate;
1:c29001b:                 return;
1:c29001b:             }
1:c29001b: 
1:c29001b:             // ... but sometimes we will have one last child to compare against, that has no siblings
1:c29001b:             if (!heap[nextIdx].equalParent)
1:c29001b:             {
1:c29001b:                 int cmp = candidate.compareTo(heap[nextIdx]);
1:c29001b:                 if (cmp <= 0)
1:c29001b:                 {
1:c29001b:                     heap[nextIdx].equalParent = cmp == 0;
1:c29001b:                     heap[currIdx] = candidate;
1:c29001b:                     return;
1:c29001b:                 }
1:c29001b:             }
1:c29001b: 
1:c29001b:             heap[currIdx] = heap[nextIdx];
1:c29001b:             heap[nextIdx] = candidate;
1:35d9347:         }
1:35d9347:     }
1:35d9347: 
1:35d9347:     // Holds and is comparable by the head item of an iterator it owns
1:35d9347:     protected static final class Candidate<In> implements Comparable<Candidate<In>>
1:35d9347:     {
1:a991b64:         private final Iterator<? extends In> iter;
1:a991b64:         private final Comparator<? super In> comp;
1:a991b64:         private final int idx;
1:35d9347:         private In item;
1:b11fba7:         private In lowerBound;
1:c29001b:         boolean equalParent;
1:a4f75e2: 
1:a991b64:         public Candidate(int idx, Iterator<? extends In> iter, Comparator<? super In> comp)
1:35d9347:         {
1:35d9347:             this.iter = iter;
1:a4f75e2:             this.comp = comp;
1:a991b64:             this.idx = idx;
1:b11fba7:             this.lowerBound = iter instanceof IteratorWithLowerBound ? ((IteratorWithLowerBound<In>)iter).lowerBound() : null;
1:a4f75e2:         }
1:a4f75e2: 
1:c29001b:         /** @return this if our iterator had an item, and it is now available, otherwise null */
1:c29001b:         protected Candidate<In> advance()
1:35d9347:         {
1:b11fba7:             if (lowerBound != null)
1:b11fba7:             {
1:b11fba7:                 item = lowerBound;
1:b11fba7:                 return this;
1:b11fba7:             }
1:b11fba7: 
1:35d9347:             if (!iter.hasNext())
1:c29001b:                 return null;
1:b11fba7: 
1:35d9347:             item = iter.next();
1:c29001b:             return this;
1:35d9347:         }
1:35d9347: 
1:35d9347:         public int compareTo(Candidate<In> that)
1:c29001b:         {
1:b11fba7:             assert this.item != null && that.item != null;
1:b11fba7:             int ret = comp.compare(this.item, that.item);
1:b11fba7:             if (ret == 0 && (this.isLowerBound() ^ that.isLowerBound()))
1:b11fba7:             {   // if the items are equal and one of them is a lower bound (but not the other one)
1:b11fba7:                 // then ensure the lower bound is less than the real item so we can safely
1:b11fba7:                 // skip lower bounds when consuming
1:b11fba7:                 return this.isLowerBound() ? -1 : 1;
1:b11fba7:             }
1:b11fba7:             return ret;
1:35d9347:         }
1:c29001b: 
1:b11fba7:         private boolean isLowerBound()
1:35d9347:         {
1:b11fba7:             return item == lowerBound;
1:b11fba7:         }
1:b11fba7: 
1:b11fba7:         public void consume(Reducer reducer)
1:b11fba7:         {
1:b11fba7:             if (isLowerBound())
1:b11fba7:             {
1:b11fba7:                 item = null;
1:b11fba7:                 lowerBound = null;
1:b11fba7:             }
1:b11fba7:             else
1:b11fba7:             {
1:b11fba7:                 reducer.reduce(idx, item);
1:b11fba7:                 item = null;
1:b11fba7:             }
1:c29001b:         }
1:c29001b: 
1:c29001b:         public boolean needsAdvance()
1:c29001b:         {
1:c29001b:             return item == null;
1:c29001b:         }
1:35d9347:     }
1:35d9347: 
1:35d9347:     /** Accumulator that collects values of type A, and outputs a value of type B. */
1:35d9347:     public static abstract class Reducer<In,Out>
1:35d9347:     {
3:35d9347:         /**
1:2a585c0:          * @return true if Out is the same as In for the case of a single source iterator
1:2a585c0:          */
1:ea82722:         public boolean trivialReduceIsTrivial()
1:ea82722:         {
1:ea82722:             return false;
1:ea82722:         }
1:2a585c0: 
1:2a585c0:         /**
1:35d9347:          * combine this object with the previous ones.
1:35d9347:          * intermediate state is up to your implementation.
4:35d9347:          */
1:a991b64:         public abstract void reduce(int idx, In current);
1:35d9347: 
1:35d9347:         /** @return The last object computed by reduce */
1:35d9347:         protected abstract Out getReduced();
1:35d9347: 
1:35d9347:         /**
1:9881ea6:          * Called at the beginning of each new key, before any reduce is called.
1:9881ea6:          * To be overridden by implementing classes.
1:35d9347:          */
1:35d9347:         protected void onKeyChange() {}
1:f64c17e: 
1:f64c17e:         /**
1:f64c17e:          * May be overridden by implementations that require cleaning up after use
1:f64c17e:          */
1:f64c17e:         public void close() {}
1:35d9347:     }
1:a4f75e2: 
1:a4f75e2:     private static class OneToOne<In, Out> extends MergeIterator<In, Out>
1:a4f75e2:     {
1:177bf5f:         private final Iterator<In> source;
1:a4f75e2: 
1:177bf5f:         public OneToOne(List<? extends Iterator<In>> sources, Reducer<In, Out> reducer)
1:a4f75e2:         {
1:a4f75e2:             super(sources, reducer);
1:a4f75e2:             source = sources.get(0);
1:a4f75e2:         }
1:a4f75e2: 
1:a4f75e2:         protected Out computeNext()
1:a4f75e2:         {
1:a4f75e2:             if (!source.hasNext())
1:a4f75e2:                 return endOfData();
1:a4f75e2:             reducer.onKeyChange();
1:a991b64:             reducer.reduce(0, source.next());
1:a4f75e2:             return reducer.getReduced();
1:a4f75e2:         }
1:a4f75e2:     }
1:35d9347: 
1:2a585c0:     private static class TrivialOneToOne<In, Out> extends MergeIterator<In, Out>
1:2a585c0:     {
1:177bf5f:         private final Iterator<In> source;
1:2a585c0: 
1:177bf5f:         public TrivialOneToOne(List<? extends Iterator<In>> sources, Reducer<In, Out> reducer)
1:2a585c0:         {
1:2a585c0:             super(sources, reducer);
1:2a585c0:             source = sources.get(0);
1:2a585c0:         }
1:2a585c0: 
1:9881ea6:         @SuppressWarnings("unchecked")
1:2a585c0:         protected Out computeNext()
1:35d9347:         {
1:2a585c0:             if (!source.hasNext())
1:2a585c0:                 return endOfData();
1:2a585c0:             return (Out) source.next();
1:2a585c0:         }
1:2a585c0:     }
1:35d9347: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:b11fba7
/////////////////////////////////////////////////////////////////////////
1:             heap[0].consume(reducer);
/////////////////////////////////////////////////////////////////////////
1:                     heap[i].consume(reducer);
/////////////////////////////////////////////////////////////////////////
1:             heap[idx].consume(reducer);
/////////////////////////////////////////////////////////////////////////
1:         private In lowerBound;
/////////////////////////////////////////////////////////////////////////
1:             this.lowerBound = iter instanceof IteratorWithLowerBound ? ((IteratorWithLowerBound<In>)iter).lowerBound() : null;
1:             if (lowerBound != null)
1:             {
1:                 item = lowerBound;
1:                 return this;
1:             }
1: 
1: 
1:             assert this.item != null && that.item != null;
1:             int ret = comp.compare(this.item, that.item);
1:             if (ret == 0 && (this.isLowerBound() ^ that.isLowerBound()))
1:             {   // if the items are equal and one of them is a lower bound (but not the other one)
1:                 // then ensure the lower bound is less than the real item so we can safely
1:                 // skip lower bounds when consuming
1:                 return this.isLowerBound() ? -1 : 1;
1:             }
1:             return ret;
1:         private boolean isLowerBound()
1:             return item == lowerBound;
1:         }
1: 
1:         public void consume(Reducer reducer)
1:         {
1:             if (isLowerBound())
1:             {
1:                 item = null;
1:                 lowerBound = null;
1:             }
1:             else
1:             {
1:                 reducer.reduce(idx, item);
1:                 item = null;
1:             }
author:Robert Stupp
-------------------------------------------------------------------------------
commit:0f5e780
/////////////////////////////////////////////////////////////////////////
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:489a9e8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.AbstractIterator;
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:c29001b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * A MergeIterator that consumes multiple input values per output value.
1:      *
1:      * The most straightforward way to implement this is to use a {@code PriorityQueue} of iterators, {@code poll} it to
1:      * find the next item to consume, then {@code add} the iterator back after advancing. This is not very efficient as
1:      * {@code poll} and {@code add} in all cases require at least {@code log(size)} comparisons (usually more than
1:      * {@code 2*log(size)}) per consumed item, even if the input is suitable for fast iteration.
1:      *
1:      * The implementation below makes use of the fact that replacing the top element in a binary heap can be done much
1:      * more efficiently than separately removing it and placing it back, especially in the cases where the top iterator
1:      * is to be used again very soon (e.g. when there are large sections of the output where only a limited number of
1:      * input iterators overlap, which is normally the case in many practically useful situations, e.g. levelled
1:      * compaction). To further improve this particular scenario, we also use a short sorted section at the start of the
1:      * queue.
1:      *
1:      * The heap is laid out as this (for {@code SORTED_SECTION_SIZE == 2}):
1:      *                 0
1:      *                 |
1:      *                 1
1:      *                 |
1:      *                 2
1:      *               /   \
1:      *              3     4
1:      *             / \   / \
1:      *             5 6   7 8
1:      *            .. .. .. ..
1:      * Where each line is a <= relationship.
1:      *
1:      * In the sorted section we can advance with a single comparison per level, while advancing a level within the heap
1:      * requires two (so that we can find the lighter element to pop up).
1:      * The sorted section adds a constant overhead when data is uniformly distributed among the iterators, but may up
1:      * to halve the iteration time when one iterator is dominant over sections of the merged data (as is the case with
1:      * non-overlapping iterators).
1:      *
1:      * The iterator is further complicated by the need to avoid advancing the input iterators until an output is
1:      * actually requested. To achieve this {@code consume} walks the heap to find equal items without advancing the
1:      * iterators, and {@code advance} moves them and restores the heap structure before any items can be consumed.
1:      * 
1:      * To avoid having to do additional comparisons in consume to identify the equal items, we keep track of equality
1:      * between children and their parents in the heap. More precisely, the lines in the diagram above define the
1:      * following relationship:
1:      *   parent <= child && (parent == child) == child.equalParent
1:      * We can track, make use of and update the equalParent field without any additional comparisons.
1:      *
1:      * For more formal definitions and proof of correctness, see CASSANDRA-8915.
1:      */
1:     static final class ManyToOne<In,Out> extends MergeIterator<In,Out>
1:         protected final Candidate<In>[] heap;
1: 
1:         /** Number of non-exhausted iterators. */
1:         int size;
1: 
1:         /**
1:          * Position of the deepest, right-most child that needs advancing before we can start consuming.
1:          * Because advancing changes the values of the items of each iterator, the parent-chain from any position
1:          * in this range that needs advancing is not in correct order. The trees rooted at any position that does
1:          * not need advancing, however, retain their prior-held binary heap property.
1:          */
1:         int needingAdvance;
1: 
1:         /**
1:          * The number of elements to keep in order before the binary heap starts, exclusive of the top heap element.
1:          */
1:         static final int SORTED_SECTION_SIZE = 4;
1: 
1: 
1:             @SuppressWarnings("unchecked")
1:             Candidate<In>[] heap = new Candidate[iters.size()];
1:             this.heap = heap;
1:             size = 0;
1: 
1:                 heap[size++] = candidate;
1:             needingAdvance = size;
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Advance all iterators that need to be advanced and place them into suitable positions in the heap.
1:          *
1:          * By walking the iterators backwards we know that everything after the point being processed already forms
1:          * correctly ordered subheaps, thus we can build a subheap rooted at the current position by only sinking down
1:          * the newly advanced iterator. Because all parents of a consumed iterator are also consumed there is no way
1:          * that we can process one consumed iterator but skip over its parent.
1:          *
1:          * The procedure is the same as the one used for the initial building of a heap in the heapsort algorithm and
1:          * has a maximum number of comparisons {@code (2 * log(size) + SORTED_SECTION_SIZE / 2)} multiplied by the
1:          * number of iterators whose items were consumed at the previous step, but is also at most linear in the size of
1:          * the heap if the number of consumed elements is high (as it is in the initial heap construction). With non- or
1:          * lightly-overlapping iterators the procedure finishes after just one (resp. a couple of) comparisons.
1:          */
1:         private void advance()
1:             // Turn the set of candidates into a heap.
1:             for (int i = needingAdvance - 1; i >= 0; --i)
1:                 Candidate<In> candidate = heap[i];
1:                 /**
1:                  *  needingAdvance runs to the maximum index (and deepest-right node) that may need advancing;
1:                  *  since the equal items that were consumed at-once may occur in sub-heap "veins" of equality,
1:                  *  not all items above this deepest-right position may have been consumed; these already form
1:                  *  valid sub-heaps and can be skipped-over entirely
1:                  */
1:                 if (candidate.needsAdvance())
1:                     replaceAndSink(candidate.advance(), i);
1:         }
1: 
1:         /**
1:          * Consume all items that sort like the current top of the heap. As we cannot advance the iterators to let
1:          * equivalent items pop up, we walk the heap to find them and mark them as needing advance.
1:          *
1:          * This relies on the equalParent flag to avoid doing any comparisons.
1:          */
1:         private Out consume()
1:         {
1:             if (size == 0)
1:                 return endOfData();
1: 
1:             reducer.onKeyChange();
1:             assert !heap[0].equalParent;
0:             reducer.reduce(heap[0].idx, heap[0].consume());
1:             final int size = this.size;
1:             final int sortedSectionSize = Math.min(size, SORTED_SECTION_SIZE);
1:             int i;
1:             consume: {
1:                 for (i = 1; i < sortedSectionSize; ++i)
1:                 {
1:                     if (!heap[i].equalParent)
1:                         break consume;
0:                     reducer.reduce(heap[i].idx, heap[i].consume());
1:                 }
1:                 i = Math.max(i, consumeHeap(i) + 1);
1:             }
1:             needingAdvance = i;
1:         /**
1:          * Recursively consume all items equal to equalItem in the binary subheap rooted at position idx.
1:          *
1:          * @return the largest equal index found in this search.
1:          */
1:         private int consumeHeap(int idx)
1:             if (idx >= size || !heap[idx].equalParent)
1:                 return -1;
1: 
0:             reducer.reduce(heap[idx].idx, heap[idx].consume());
1:             int nextIdx = (idx << 1) - (SORTED_SECTION_SIZE - 1);
1:             return Math.max(idx, Math.max(consumeHeap(nextIdx), consumeHeap(nextIdx + 1)));
1:         }
1: 
1:         /**
1:          * Replace an iterator in the heap with the given position and move it down the heap until it finds its proper
1:          * position, pulling lighter elements up the heap.
1:          *
1:          * Whenever an equality is found between two elements that form a new parent-child relationship, the child's
1:          * equalParent flag is set to true if the elements are equal.
1:          */
1:         private void replaceAndSink(Candidate<In> candidate, int currIdx)
1:         {
1:             if (candidate == null)
1:             {
1:                 // Drop iterator by replacing it with the last one in the heap.
1:                 candidate = heap[--size];
1:                 heap[size] = null; // not necessary but helpful for debugging
1:             }
1:             // The new element will be top of its heap, at this point there is no parent to be equal to.
1:             candidate.equalParent = false;
1: 
1:             final int size = this.size;
1:             final int sortedSectionSize = Math.min(size - 1, SORTED_SECTION_SIZE);
1: 
1:             int nextIdx;
1: 
1:             // Advance within the sorted section, pulling up items lighter than candidate.
1:             while ((nextIdx = currIdx + 1) <= sortedSectionSize)
1:             {
1:                 if (!heap[nextIdx].equalParent) // if we were greater then an (or were the) equal parent, we are >= the child
1:                 {
1:                     int cmp = candidate.compareTo(heap[nextIdx]);
1:                     if (cmp <= 0)
1:                     {
1:                         heap[nextIdx].equalParent = cmp == 0;
1:                         heap[currIdx] = candidate;
1:                         return;
1:                     }
1:                 }
1: 
1:                 heap[currIdx] = heap[nextIdx];
1:                 currIdx = nextIdx;
1:             }
1:             // If size <= SORTED_SECTION_SIZE, nextIdx below will be no less than size,
1:             // because currIdx == sortedSectionSize == size - 1 and nextIdx becomes
1:             // (size - 1) * 2) - (size - 1 - 1) == size.
1: 
1:             // Advance in the binary heap, pulling up the lighter element from the two at each level.
1:             while ((nextIdx = (currIdx * 2) - (sortedSectionSize - 1)) + 1 < size)
1:             {
1:                 if (!heap[nextIdx].equalParent)
1:                 {
1:                     if (!heap[nextIdx + 1].equalParent)
1:                     {
1:                         // pick the smallest of the two children
1:                         int siblingCmp = heap[nextIdx + 1].compareTo(heap[nextIdx]);
1:                         if (siblingCmp < 0)
1:                             ++nextIdx;
1: 
1:                         // if we're smaller than this, we are done, and must only restore the heap and equalParent properties
1:                         int cmp = candidate.compareTo(heap[nextIdx]);
1:                         if (cmp <= 0)
1:                         {
1:                             if (cmp == 0)
1:                             {
1:                                 heap[nextIdx].equalParent = true;
1:                                 if (siblingCmp == 0) // siblingCmp == 0 => nextIdx is the left child
1:                                     heap[nextIdx + 1].equalParent = true;
1:                             }
1: 
1:                             heap[currIdx] = candidate;
1:                             return;
1:                         }
1: 
1:                         if (siblingCmp == 0)
1:                         {
1:                             // siblingCmp == 0 => nextIdx is still the left child
1:                             // if the two siblings were equal, and we are inserting something greater, we will
1:                             // pull up the left one; this means the right gets an equalParent
1:                             heap[nextIdx + 1].equalParent = true;
1:                         }
1:                     }
1:                     else
1:                         ++nextIdx;  // descend down the path where we found the equal child
1:                 }
1: 
1:                 heap[currIdx] = heap[nextIdx];
1:                 currIdx = nextIdx;
1:             }
1: 
1:             // our loop guard ensures there are always two siblings to process; typically when we exit the loop we will
1:             // be well past the end of the heap and this next condition will match...
1:             if (nextIdx >= size)
1:             {
1:                 heap[currIdx] = candidate;
1:                 return;
1:             }
1: 
1:             // ... but sometimes we will have one last child to compare against, that has no siblings
1:             if (!heap[nextIdx].equalParent)
1:             {
1:                 int cmp = candidate.compareTo(heap[nextIdx]);
1:                 if (cmp <= 0)
1:                 {
1:                     heap[nextIdx].equalParent = cmp == 0;
1:                     heap[currIdx] = candidate;
1:                     return;
1:                 }
1:             }
1: 
1:             heap[currIdx] = heap[nextIdx];
1:             heap[nextIdx] = candidate;
/////////////////////////////////////////////////////////////////////////
1:         boolean equalParent;
/////////////////////////////////////////////////////////////////////////
1:         /** @return this if our iterator had an item, and it is now available, otherwise null */
1:         protected Candidate<In> advance()
1:                 return null;
1:             return this;
0:             assert item != null && that.item != null;
1: 
0:         public In consume()
1:         {
0:             In temp = item;
0:             item = null;
0:             assert temp != null;
0:             return temp;
1:         }
1: 
1:         public boolean needsAdvance()
1:         {
1:             return item == null;
1:         }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static <In, Out> MergeIterator<In, Out> get(List<? extends Iterator<In>> sources,
1:                                                        Comparator<? super In> comparator,
1:                                                        Reducer<In, Out> reducer)
/////////////////////////////////////////////////////////////////////////
1:                 if (iterator instanceof AutoCloseable)
1:                     ((AutoCloseable)iterator).close();
1:             catch (Exception e)
/////////////////////////////////////////////////////////////////////////
1:         public ManyToOne(List<? extends Iterator<In>> iters, Comparator<? super In> comp, Reducer<In, Out> reducer)
1:             for (int i = 0; i < iters.size(); i++)
1:                 Candidate<In> candidate = new Candidate<>(i, iters.get(i), comp);
/////////////////////////////////////////////////////////////////////////
0:                 reducer.reduce(candidate.idx, candidate.item);
/////////////////////////////////////////////////////////////////////////
1:         private final Iterator<? extends In> iter;
1:         private final Comparator<? super In> comp;
1:         private final int idx;
1:         public Candidate(int idx, Iterator<? extends In> iter, Comparator<? super In> comp)
1:             this.idx = idx;
/////////////////////////////////////////////////////////////////////////
1:         public abstract void reduce(int idx, In current);
/////////////////////////////////////////////////////////////////////////
1:             reducer.reduce(0, source.next());
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
commit:f64c17e
/////////////////////////////////////////////////////////////////////////
1: 
1:         reducer.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
1:          * May be overridden by implementations that require cleaning up after use
1:          */
1:         public void close() {}
commit:4708aa0
/////////////////////////////////////////////////////////////////////////
author:belliottsmith
-------------------------------------------------------------------------------
commit:9881ea6
/////////////////////////////////////////////////////////////////////////
0:     public static <In, Out> IMergeIterator<In, Out> get(List<? extends Iterator<In>> sources,
0:                                                         Comparator<In> comparator,
0:                                                         Reducer<In, Out> reducer)
1:         {
1:                  ? new TrivialOneToOne<>(sources, reducer)
1:                  : new OneToOne<>(sources, reducer);
1:         }
1:         return new ManyToOne<>(sources, comparator, reducer);
/////////////////////////////////////////////////////////////////////////
0:             this.queue = new PriorityQueue<>(Math.max(1, iters.size()));
0:                 Candidate<In> candidate = new Candidate<>(iter, comp);
0:             this.candidates = new ArrayDeque<>(queue.size());
/////////////////////////////////////////////////////////////////////////
1:          * Called at the beginning of each new key, before any reduce is called.
1:          * To be overridden by implementing classes.
/////////////////////////////////////////////////////////////////////////
1:         @SuppressWarnings("unchecked")
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:177bf5f
/////////////////////////////////////////////////////////////////////////
0: import java.io.Closeable;
/////////////////////////////////////////////////////////////////////////
1:     protected final List<? extends Iterator<In>> iterators;
1:     protected MergeIterator(List<? extends Iterator<In>> iters, Reducer<In, Out> reducer)
0:     public static <In, Out> IMergeIterator<In, Out> get(final List<? extends Iterator<In>> sources,
/////////////////////////////////////////////////////////////////////////
1:     public Iterable<? extends Iterator<In>> iterators()
1:         for (Iterator<In> iterator : this.iterators)
0:                 ((Closeable)iterator).close();
/////////////////////////////////////////////////////////////////////////
0:         public ManyToOne(List<? extends Iterator<In>> iters, Comparator<In> comp, Reducer<In, Out> reducer)
0:             for (Iterator<In> iter : iters)
/////////////////////////////////////////////////////////////////////////
0:         private final Iterator<In> iter;
0:         public Candidate(Iterator<In> iter, Comparator<In> comp)
/////////////////////////////////////////////////////////////////////////
1:         private final Iterator<In> source;
1:         public OneToOne(List<? extends Iterator<In>> sources, Reducer<In, Out> reducer)
/////////////////////////////////////////////////////////////////////////
1:         private final Iterator<In> source;
1:         public TrivialOneToOne(List<? extends Iterator<In>> sources, Reducer<In, Out> reducer)
commit:debb15e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 throw new RuntimeException(e);
commit:ea82722
/////////////////////////////////////////////////////////////////////////
1:         public boolean trivialReduceIsTrivial()
1:         {
1:             return false;
1:         }
commit:2a585c0
/////////////////////////////////////////////////////////////////////////
1:             return reducer.trivialReduceIsTrivial()
0:                    ? new TrivialOneToOne<In, Out>(sources, reducer)
0:                    : new OneToOne<In, Out>(sources, reducer);
/////////////////////////////////////////////////////////////////////////
1:          * @return true if Out is the same as In for the case of a single source iterator
1:          */
0:         public abstract boolean trivialReduceIsTrivial();
1: 
1:         /**
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static class TrivialOneToOne<In, Out> extends MergeIterator<In, Out>
1:     {
0:         private final CloseableIterator<?> source;
1: 
0:         public TrivialOneToOne(List<? extends CloseableIterator<In>> sources, Reducer<In, Out> reducer)
1:         {
1:             super(sources, reducer);
1:             source = sources.get(0);
1:         }
1: 
1:         protected Out computeNext()
1:         {
1:             if (!source.hasNext())
1:                 return endOfData();
1:             return (Out) source.next();
1:         }
1:     }
commit:a4f75e2
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
1: public abstract class MergeIterator<In,Out> extends AbstractIterator<Out> implements IMergeIterator<In, Out>
1:     protected final Reducer<In,Out> reducer;
0:     protected MergeIterator(List<? extends CloseableIterator<In>> iters, Reducer<In, Out> reducer)
1:         this.reducer = reducer;
0:     public static <In, Out> IMergeIterator<In, Out> get(final List<? extends CloseableIterator<In>> sources,
0:                                                     Comparator<In> comparator,
0:                                                     final Reducer<In, Out> reducer)
0:         assert !sources.isEmpty();
1:         if (sources.size() == 1)
0:             return new OneToOne<In, Out>(sources, reducer);
0:         return new ManyToOne<In, Out>(sources, comparator, reducer);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         public final Comparator<In> comp;
0:         // a queue for return: all candidates must be open and have at least one item
0:         protected final PriorityQueue<Candidate<In>> queue;
1:             super(iters, reducer);
1:             this.comp = comp;
0:             this.queue = new PriorityQueue<Candidate<In>>(Math.max(1, iters.size()));
0:             for (CloseableIterator<In> iter : iters)
1:             {
0:                 Candidate<In> candidate = new Candidate<In>(iter, comp);
0:                 if (!candidate.advance())
0:                     // was empty
0:                     continue;
0:                 this.queue.add(candidate);
1:             }
1:         protected final Out computeNext()
1:         {
1:             advance();
1:             return consume();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static class OneToOne<In, Out> extends MergeIterator<In, Out>
1:     {
0:         private final CloseableIterator<In> source;
1: 
0:         public OneToOne(List<? extends CloseableIterator<In>> sources, Reducer<In, Out> reducer)
1:         {
1:             super(sources, reducer);
1:             source = sources.get(0);
1:         }
1: 
1:         protected Out computeNext()
1:         {
1:             if (!source.hasNext())
1:                 return endOfData();
1:             reducer.onKeyChange();
0:             reducer.reduce(source.next());
1:             return reducer.getReduced();
1:         }
1:     }
commit:35d9347
/////////////////////////////////////////////////////////////////////////
1: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
1: */
1: package org.apache.cassandra.utils;
1: 
0: import java.io.IOException;
0: import java.io.IOError;
0: import java.util.ArrayDeque;
0: import java.util.Comparator;
0: import java.util.List;
0: import java.util.PriorityQueue;
1: 
0: import com.google.common.collect.AbstractIterator;
0: import com.google.common.collect.Ordering;
1: 
1: /** Merges sorted input iterators which individually contain unique items. */
0: public abstract class MergeIterator<In,Out> extends AbstractIterator<Out> implements CloseableIterator<Out>
1: {
0:     public final Comparator<In> comp;
0:     protected final List<? extends CloseableIterator<In>> iterators;
0:     // a queue for return: all candidates must be open and have at least one item
0:     protected final PriorityQueue<Candidate<In>> queue;
1: 
0:     protected MergeIterator(List<? extends CloseableIterator<In>> iters, Comparator<In> comp)
1:     {
1:         this.iterators = iters;
0:         this.comp = comp;
0:         this.queue = new PriorityQueue<Candidate<In>>(Math.max(1, iters.size()));
0:         for (CloseableIterator<In> iter : iters)
1:         {
0:             Candidate<In> candidate = new Candidate<In>(iter, comp);
0:             if (!candidate.advance())
0:                 // was empty
0:                 continue;
0:             this.queue.add(candidate);
1:         }
1:     }
1: 
0:     public static <E> MergeIterator<E,E> get(List<? extends CloseableIterator<E>> iters)
1:     {
0:         return get(iters, (Comparator<E>)Ordering.natural());
1:     }
1: 
0:     public static <E> MergeIterator<E,E> get(List<? extends CloseableIterator<E>> iters, Comparator<E> comp)
1:     {
0:         return new OneToOne<E>(iters, comp);
1:     }
1: 
0:     public static <In,Out> MergeIterator<In,Out> get(List<? extends CloseableIterator<In>> iters, Comparator<In> comp, Reducer<In,Out> reducer)
1:     {
0:         return new ManyToOne<In,Out>(iters, comp, reducer);
1:     }
1: 
0:     public Iterable<? extends CloseableIterator<In>> iterators()
1:     {
1:         return iterators;
1:     }
1: 
1:     /**
0:      * Consumes sorted items from the queue: should only remove items from the queue,
0:      * not add them.
1:      */
0:     protected abstract Out consume();
1: 
1:     /**
0:      * Returns consumed items to the queue.
1:      */
0:     protected abstract void advance();
1: 
0:     protected final Out computeNext()
1:     {
0:         advance();
0:         return consume();
1:     }
1: 
1:     public void close()
1:     {
0:         for (CloseableIterator<In> iterator : this.iterators)
1:         {
1:             try
1:             {
0:                 iterator.close();
1:             }
0:             catch (IOException e)
1:             {
0:                 throw new IOError(e);
1:             }
1:         }
1:     }
1: 
0:     /** A MergeIterator that returns a single value for each one consumed. */
0:     private static final class OneToOne<E> extends MergeIterator<E,E>
1:     {
0:         // the last returned candidate, so that we can lazily call 'advance()'
0:         protected Candidate<E> candidate;
0:         public OneToOne(List<? extends CloseableIterator<E>> iters, Comparator<E> comp)
1:         {
0:             super(iters, comp);
1:         }
1: 
0:         protected final E consume()
1:         {
0:             candidate = queue.poll();
0:             if (candidate == null)
0:                 return endOfData();
0:             return candidate.item;
1:         }
1: 
0:         protected final void advance()
1:         {
0:             if (candidate != null && candidate.advance())
0:                 // has more items
0:                 queue.add(candidate);
1:         }
1:     }
1: 
0:     /** A MergeIterator that consumes multiple input values per output value. */
0:     private static final class ManyToOne<In,Out> extends MergeIterator<In,Out>
1:     {
0:         protected final Reducer<In,Out> reducer;
0:         // a stack of the last consumed candidates, so that we can lazily call 'advance()'
0:         // TODO: if we had our own PriorityQueue implementation we could stash items
0:         // at the end of its array, so we wouldn't need this storage
0:         protected final ArrayDeque<Candidate<In>> candidates;
0:         public ManyToOne(List<? extends CloseableIterator<In>> iters, Comparator<In> comp, Reducer<In,Out> reducer)
1:         {
0:             super(iters, comp);
0:             this.reducer = reducer;
0:             this.candidates = new ArrayDeque<Candidate<In>>(queue.size());
1:         }
1: 
0:         /** Consume values by sending them to the reducer while they are equal. */
0:         protected final Out consume()
1:         {
0:             reducer.onKeyChange();
0:             Candidate<In> candidate = queue.peek();
0:             if (candidate == null)
0:                 return endOfData();
0:             do
1:             {
0:                 candidate = queue.poll();
0:                 candidates.push(candidate);
0:                 reducer.reduce(candidate.item);
1:             }
0:             while (queue.peek() != null && queue.peek().compareTo(candidate) == 0);
1:             return reducer.getReduced();
1:         }
1: 
0:         /** Advance and re-enqueue all items we consumed in the last iteration. */
0:         protected final void advance()
1:         {
0:             Candidate<In> candidate;
0:             while ((candidate = candidates.pollFirst()) != null)
0:                 if (candidate.advance())
0:                     queue.add(candidate);
1:         }
1:     }
1: 
1:     // Holds and is comparable by the head item of an iterator it owns
1:     protected static final class Candidate<In> implements Comparable<Candidate<In>>
1:     {
0:         private final CloseableIterator<In> iter;
0:         private final Comparator<In> comp;
1:         private In item;
0:         public Candidate(CloseableIterator<In> iter, Comparator<In> comp)
1:         {
1:             this.iter = iter;
0:             this.comp = comp;
1:         }
1: 
0:         public In item()
1:         {
0:             return item;
1:         }
1: 
0:         /** @return True if our iterator had an item, and it is now available */
0:         protected boolean advance()
1:         {
1:             if (!iter.hasNext())
0:                 return false;
1:             item = iter.next();
0:             return true;
1:         }
1: 
1:         public int compareTo(Candidate<In> that)
1:         {
0:             return comp.compare(this.item, that.item);
1:         }
1:     }
1: 
1:     /** Accumulator that collects values of type A, and outputs a value of type B. */
1:     public static abstract class Reducer<In,Out>
1:     {
1:         /**
1:          * combine this object with the previous ones.
1:          * intermediate state is up to your implementation.
1:          */
0:         public abstract void reduce(In current);
1: 
1:         /** @return The last object computed by reduce */
1:         protected abstract Out getReduced();
1: 
1:         /**
0:          * Called at the begining of each new key, before any reduce is called.
0:          * To be overriden by implementing classes.
1:          */
1:         protected void onKeyChange() {}
1:     }
1: }
author:Dave Brosius
-------------------------------------------------------------------------------
commit:5c5fe91
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
============================================================================