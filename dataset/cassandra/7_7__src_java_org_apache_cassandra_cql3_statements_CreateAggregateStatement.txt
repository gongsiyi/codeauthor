1:e2f35c7: /*
1:e2f35c7:  * Licensed to the Apache Software Foundation (ASF) under one
1:e2f35c7:  * or more contributor license agreements.  See the NOTICE file
1:e2f35c7:  * distributed with this work for additional information
1:e2f35c7:  * regarding copyright ownership.  The ASF licenses this file
1:e2f35c7:  * to you under the Apache License, Version 2.0 (the
1:e2f35c7:  * "License"); you may not use this file except in compliance
1:e2f35c7:  * with the License.  You may obtain a copy of the License at
1:e2f35c7:  *
1:e2f35c7:  *     http://www.apache.org/licenses/LICENSE-2.0
1:e2f35c7:  *
1:e2f35c7:  * Unless required by applicable law or agreed to in writing, software
1:e2f35c7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e2f35c7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e2f35c7:  * See the License for the specific language governing permissions and
1:e2f35c7:  * limitations under the License.
1:e2f35c7:  */
1:e2f35c7: package org.apache.cassandra.cql3.statements;
1:e2f35c7: 
1:e2f35c7: import java.nio.ByteBuffer;
1:e2f35c7: import java.util.ArrayList;
1:e2f35c7: import java.util.Collections;
1:c6ed2e0: import java.util.Objects;
1:e2f35c7: import java.util.List;
1:e2f35c7: 
1:cb5897f: import org.apache.cassandra.auth.*;
1:cb5897f: import org.apache.cassandra.config.DatabaseDescriptor;
1:e2f35c7: import org.apache.cassandra.config.Schema;
1:cb5897f: import org.apache.cassandra.cql3.*;
1:e2f35c7: import org.apache.cassandra.cql3.functions.*;
1:e2f35c7: import org.apache.cassandra.db.marshal.AbstractType;
1:cb5897f: import org.apache.cassandra.exceptions.*;
1:c6ed2e0: import org.apache.cassandra.serializers.MarshalException;
1:e2f35c7: import org.apache.cassandra.service.ClientState;
1:e2f35c7: import org.apache.cassandra.service.MigrationManager;
1:cb5897f: import org.apache.cassandra.service.QueryState;
1:e2f35c7: import org.apache.cassandra.thrift.ThriftValidation;
1:e2f35c7: import org.apache.cassandra.transport.Event;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:e2f35c7: 
1:e2f35c7: /**
1:40a7e86:  * A {@code CREATE AGGREGATE} statement parsed from a CQL query.
1:e2f35c7:  */
1:e2f35c7: public final class CreateAggregateStatement extends SchemaAlteringStatement
1:e2f35c7: {
1:e2f35c7:     private final boolean orReplace;
1:e2f35c7:     private final boolean ifNotExists;
1:e2f35c7:     private FunctionName functionName;
1:6eea3ea:     private FunctionName stateFunc;
1:6eea3ea:     private FunctionName finalFunc;
1:e2f35c7:     private final CQL3Type.Raw stateTypeRaw;
1:e2f35c7: 
1:e2f35c7:     private final List<CQL3Type.Raw> argRawTypes;
1:e2f35c7:     private final Term.Raw ival;
1:dcc3bb0: 
1:cb5897f:     private List<AbstractType<?>> argTypes;
1:cb5897f:     private AbstractType<?> returnType;
1:cb5897f:     private ScalarFunction stateFunction;
1:cb5897f:     private ScalarFunction finalFunction;
1:cb5897f:     private ByteBuffer initcond;
1:e2f35c7: 
1:e2f35c7:     public CreateAggregateStatement(FunctionName functionName,
1:e2f35c7:                                     List<CQL3Type.Raw> argRawTypes,
1:fec40fd:                                     String stateFunc,
1:e2f35c7:                                     CQL3Type.Raw stateType,
1:fec40fd:                                     String finalFunc,
1:e2f35c7:                                     Term.Raw ival,
1:e2f35c7:                                     boolean orReplace,
1:e2f35c7:                                     boolean ifNotExists)
1:e2f35c7:     {
1:e2f35c7:         this.functionName = functionName;
1:e2f35c7:         this.argRawTypes = argRawTypes;
1:fec40fd:         this.stateFunc = new FunctionName(functionName.keyspace, stateFunc);
1:fec40fd:         this.finalFunc = finalFunc != null ? new FunctionName(functionName.keyspace, finalFunc) : null;
1:e2f35c7:         this.stateTypeRaw = stateType;
1:e2f35c7:         this.ival = ival;
1:e2f35c7:         this.orReplace = orReplace;
1:e2f35c7:         this.ifNotExists = ifNotExists;
1:e2f35c7:     }
1:e2f35c7: 
1:cb5897f:     public Prepared prepare()
1:e2f35c7:     {
1:cb5897f:         argTypes = new ArrayList<>(argRawTypes.size());
1:e2f35c7:         for (CQL3Type.Raw rawType : argRawTypes)
1:1de8e39:             argTypes.add(prepareType("arguments", rawType));
1:e2f35c7: 
1:1de8e39:         AbstractType<?> stateType = prepareType("state type", stateTypeRaw);
1:d6312c5: 
1:d6312c5:         List<AbstractType<?>> stateArgs = stateArguments(stateType, argTypes);
1:d6312c5: 
1:3566843:         Function f = Schema.instance.findFunction(stateFunc, stateArgs).orElse(null);
1:e2f35c7:         if (!(f instanceof ScalarFunction))
1:6eea3ea:             throw new InvalidRequestException("State function " + stateFuncSig(stateFunc, stateTypeRaw, argRawTypes) + " does not exist or is not a scalar function");
1:cb5897f:         stateFunction = (ScalarFunction)f;
1:e2f35c7: 
1:40a7e86:         AbstractType<?> stateReturnType = stateFunction.returnType();
1:40a7e86:         if (!stateReturnType.equals(stateType))
1:40a7e86:             throw new InvalidRequestException("State function " + stateFuncSig(stateFunction.name(), stateTypeRaw, argRawTypes) + " return type must be the same as the first argument type - check STYPE, argument and return types");
1:40a7e86: 
1:6eea3ea:         if (finalFunc != null)
1:e2f35c7:         {
1:d6312c5:             List<AbstractType<?>> finalArgs = Collections.<AbstractType<?>>singletonList(stateType);
1:3566843:             f = Schema.instance.findFunction(finalFunc, finalArgs).orElse(null);
1:e2f35c7:             if (!(f instanceof ScalarFunction))
1:6eea3ea:                 throw new InvalidRequestException("Final function " + finalFunc + '(' + stateTypeRaw + ") does not exist or is not a scalar function");
1:cb5897f:             finalFunction = (ScalarFunction) f;
1:cb5897f:             returnType = finalFunction.returnType();
1:e2f35c7:         }
1:cb5897f:         else
1:e2f35c7:         {
1:40a7e86:             returnType = stateReturnType;
1:e2f35c7:         }
1:6eea3ea: 
1:e2f35c7:         if (ival != null)
4:cb5897f:         {
1:e94032a:             initcond = Terms.asBytes(functionName.keyspace, ival.toString(), stateType);
1:c6ed2e0: 
1:c6ed2e0:             if (initcond != null)
1:c6ed2e0:             {
1:c6ed2e0:                 try
1:c6ed2e0:                 {
1:c6ed2e0:                     stateType.validate(initcond);
1:c6ed2e0:                 }
1:c6ed2e0:                 catch (MarshalException e)
1:c6ed2e0:                 {
1:c6ed2e0:                     throw new InvalidRequestException(String.format("Invalid value for INITCOND of type %s%s", stateType.asCQL3Type(),
1:c6ed2e0:                                                                     e.getMessage() == null ? "" : String.format(" (%s)", e.getMessage())));
1:c6ed2e0:                 }
1:c6ed2e0:             }
1:c6ed2e0: 
1:c6ed2e0:             // Sanity check that converts the initcond to a CQL literal and parse it back to avoid getting in CASSANDRA-11064.
1:e0adc16:             String initcondAsCql = stateType.asCQL3Type().toCQLLiteral(initcond, ProtocolVersion.CURRENT);
1:c6ed2e0:             assert Objects.equals(initcond, Terms.asBytes(functionName.keyspace, initcondAsCql, stateType));
1:c6ed2e0: 
1:4df4f79:             if (Constants.NULL_LITERAL != ival && UDHelper.isNullOrEmpty(stateType, initcond))
1:4df4f79:                 throw new InvalidRequestException("INITCOND must not be empty for all types except TEXT, ASCII, BLOB");
1:e2f35c7:         }
1:e2f35c7: 
1:cb5897f:         return super.prepare();
4:cb5897f:     }
1:e2f35c7: 
1:1de8e39:     private AbstractType<?> prepareType(String typeName, CQL3Type.Raw rawType)
1:1de8e39:     {
1:1de8e39:         if (rawType.isFrozen())
1:1de8e39:             throw new InvalidRequestException(String.format("The function %s should not be frozen; remove the frozen<> modifier", typeName));
1:e2f35c7: 
1:1de8e39:         // UDT are not supported non frozen but we do not allow the frozen keyword for argument. So for the moment we
1:1de8e39:         // freeze them here
1:1de8e39:         if (!rawType.canBeNonFrozen())
1:1de8e39:             rawType.freeze();
1:e2f35c7: 
1:1de8e39:         AbstractType<?> type = rawType.prepare(functionName.keyspace).getType();
1:1de8e39:         return type;
1:1de8e39:     }
3:1de8e39: 
1:e2f35c7:     public void prepareKeyspace(ClientState state) throws InvalidRequestException
1:e2f35c7:     {
1:e2f35c7:         if (!functionName.hasKeyspace() && state.getRawKeyspace() != null)
1:e2f35c7:             functionName = new FunctionName(state.getKeyspace(), functionName.name);
1:e2f35c7: 
1:e2f35c7:         if (!functionName.hasKeyspace())
1:e2f35c7:             throw new InvalidRequestException("Functions must be fully qualified with a keyspace name if a keyspace is not set for the session");
1:6eea3ea: 
1:e2f35c7:         ThriftValidation.validateKeyspaceNotSystem(functionName.keyspace);
1:d6312c5: 
1:fec40fd:         stateFunc = new FunctionName(functionName.keyspace, stateFunc.name);
1:fec40fd:         if (finalFunc != null)
1:fec40fd:             finalFunc = new FunctionName(functionName.keyspace, finalFunc.name);
1:d6312c5:     }
1:6eea3ea: 
1:cb5897f:     protected void grantPermissionsToCreator(QueryState state)
1:d6312c5:     {
1:cb5897f:         try
1:6eea3ea:         {
1:cb5897f:             IResource resource = FunctionResource.function(functionName.keyspace, functionName.name, argTypes);
1:cb5897f:             DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,
1:cb5897f:                                                      resource.applicablePermissions(),
1:cb5897f:                                                      resource,
1:cb5897f:                                                      RoleResource.role(state.getClientState().getUser().getName()));
1:6eea3ea:         }
1:cb5897f:         catch (RequestExecutionException e)
1:e2f35c7:         {
1:cb5897f:             throw new RuntimeException(e);
1:e2f35c7:         }
1:e2f35c7:     }
1:e2f35c7: 
1:e2f35c7:     public void checkAccess(ClientState state) throws UnauthorizedException, InvalidRequestException
1:e2f35c7:     {
1:3566843:         if (Schema.instance.findFunction(functionName, argTypes).isPresent() && orReplace)
1:cb5897f:             state.ensureHasPermission(Permission.ALTER, FunctionResource.function(functionName.keyspace,
1:cb5897f:                                                                                   functionName.name,
1:cb5897f:                                                                                   argTypes));
1:e2f35c7:         else
1:cb5897f:             state.ensureHasPermission(Permission.CREATE, FunctionResource.keyspace(functionName.keyspace));
1:e2f35c7: 
1:89464ea:         state.ensureHasPermission(Permission.EXECUTE, stateFunction);
1:e2f35c7: 
1:cb5897f:         if (finalFunction != null)
1:89464ea:             state.ensureHasPermission(Permission.EXECUTE, finalFunction);
1:e2f35c7:     }
1:e2f35c7: 
1:e2f35c7:     public void validate(ClientState state) throws InvalidRequestException
1:e2f35c7:     {
1:e2f35c7:         if (ifNotExists && orReplace)
1:e2f35c7:             throw new InvalidRequestException("Cannot use both 'OR REPLACE' and 'IF NOT EXISTS' directives");
1:e2f35c7: 
1:e2f35c7:         if (Schema.instance.getKSMetaData(functionName.keyspace) == null)
1:e2f35c7:             throw new InvalidRequestException(String.format("Cannot add aggregate '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
1:e2f35c7:     }
1:e2f35c7: 
1:2cbd776:     public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
1:e2f35c7:     {
1:3566843:         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
1:2cbd776:         boolean replaced = old != null;
1:2cbd776:         if (replaced)
1:e2f35c7:         {
1:e2f35c7:             if (ifNotExists)
1:e2f35c7:                 return null;
1:e2f35c7:             if (!orReplace)
1:e2f35c7:                 throw new InvalidRequestException(String.format("Function %s already exists", old));
1:e2f35c7:             if (!(old instanceof AggregateFunction))
1:e2f35c7:                 throw new InvalidRequestException(String.format("Aggregate %s can only replace an aggregate", old));
1:e2f35c7: 
1:e2f35c7:             // Means we're replacing the function. We still need to validate that 1) it's not a native function and 2) that the return type
1:e2f35c7:             // matches (or that could break existing code badly)
1:e2f35c7:             if (old.isNative())
1:e2f35c7:                 throw new InvalidRequestException(String.format("Cannot replace native aggregate %s", old));
1:e2f35c7:             if (!old.returnType().isValueCompatibleWith(returnType))
1:e2f35c7:                 throw new InvalidRequestException(String.format("Cannot replace aggregate %s, the new return type %s is not compatible with the return type %s of existing function",
1:e2f35c7:                                                                 functionName, returnType.asCQL3Type(), old.returnType().asCQL3Type()));
1:e2f35c7:         }
1:e2f35c7: 
1:1937bed:         if (!stateFunction.isCalledOnNullInput() && initcond == null)
1:1937bed:             throw new InvalidRequestException(String.format("Cannot create aggregate %s without INITCOND because state function %s does not accept 'null' arguments", functionName, stateFunc));
1:1937bed: 
1:2cbd776:         UDAggregate udAggregate = new UDAggregate(functionName, argTypes, returnType, stateFunction, finalFunction, initcond);
1:e2f35c7: 
1:e2f35c7:         MigrationManager.announceNewAggregate(udAggregate, isLocalOnly);
1:e2f35c7: 
1:dcc3bb0:         return new Event.SchemaChange(replaced ? Event.SchemaChange.Change.UPDATED : Event.SchemaChange.Change.CREATED,
1:dcc3bb0:                                       Event.SchemaChange.Target.AGGREGATE,
1:dcc3bb0:                                       udAggregate.name().keyspace, udAggregate.name().name, AbstractType.asCQLTypeStringList(udAggregate.argTypes()));
1:e2f35c7:     }
1:e2f35c7: 
1:40a7e86:     private static String stateFuncSig(FunctionName stateFuncName, CQL3Type.Raw stateTypeRaw, List<CQL3Type.Raw> argRawTypes)
1:e2f35c7:     {
1:e2f35c7:         StringBuilder sb = new StringBuilder();
1:e2f35c7:         sb.append(stateFuncName.toString()).append('(').append(stateTypeRaw);
1:e2f35c7:         for (CQL3Type.Raw argRawType : argRawTypes)
1:e2f35c7:             sb.append(", ").append(argRawType);
1:e2f35c7:         sb.append(')');
1:e2f35c7:         return sb.toString();
1:e2f35c7:     }
1:e2f35c7: 
1:1937bed:     private static List<AbstractType<?>> stateArguments(AbstractType<?> stateType, List<AbstractType<?>> argTypes)
1:e2f35c7:     {
1:e2f35c7:         List<AbstractType<?>> r = new ArrayList<>(argTypes.size() + 1);
1:e2f35c7:         r.add(stateType);
1:e2f35c7:         r.addAll(argTypes);
1:e2f35c7:         return r;
1:e2f35c7:     }
1:e2f35c7: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:             String initcondAsCql = stateType.asCQL3Type().toCQLLiteral(initcond, ProtocolVersion.CURRENT);
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:89464ea
/////////////////////////////////////////////////////////////////////////
1:         state.ensureHasPermission(Permission.EXECUTE, stateFunction);
1:             state.ensureHasPermission(Permission.EXECUTE, finalFunction);
author:Robert Stupp
-------------------------------------------------------------------------------
commit:c6ed2e0
/////////////////////////////////////////////////////////////////////////
1: import java.util.Objects;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.MarshalException;
0: import org.apache.cassandra.transport.Server;
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (initcond != null)
1:             {
1:                 try
1:                 {
1:                     stateType.validate(initcond);
1:                 }
1:                 catch (MarshalException e)
1:                 {
1:                     throw new InvalidRequestException(String.format("Invalid value for INITCOND of type %s%s", stateType.asCQL3Type(),
1:                                                                     e.getMessage() == null ? "" : String.format(" (%s)", e.getMessage())));
1:                 }
1:             }
1: 
1:             // Sanity check that converts the initcond to a CQL literal and parse it back to avoid getting in CASSANDRA-11064.
0:             String initcondAsCql = stateType.asCQL3Type().toCQLLiteral(initcond, Server.CURRENT_VERSION);
1:             assert Objects.equals(initcond, Terms.asBytes(functionName.keyspace, initcondAsCql, stateType));
1: 
commit:e94032a
/////////////////////////////////////////////////////////////////////////
1:             initcond = Terms.asBytes(functionName.keyspace, ival.toString(), stateType);
commit:1455837
commit:fec40fd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                     String stateFunc,
1:                                     String finalFunc,
1:         this.stateFunc = new FunctionName(functionName.keyspace, stateFunc);
1:         this.finalFunc = finalFunc != null ? new FunctionName(functionName.keyspace, finalFunc) : null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         stateFunc = new FunctionName(functionName.keyspace, stateFunc.name);
1:         if (finalFunc != null)
1:             finalFunc = new FunctionName(functionName.keyspace, finalFunc.name);
commit:418c793
commit:fc202a7
/////////////////////////////////////////////////////////////////////////
0:         stateFunc = validateFunctionKeyspace(stateFunc);
/////////////////////////////////////////////////////////////////////////
0:             finalFunc = validateFunctionKeyspace(finalFunc);
/////////////////////////////////////////////////////////////////////////
0:     private FunctionName validateFunctionKeyspace(FunctionName func)
commit:d6312c5
/////////////////////////////////////////////////////////////////////////
1: 
1:         List<AbstractType<?>> stateArgs = stateArguments(stateType, argTypes);
0:         stateFunc = validateFunctionKeyspace(stateFunc, stateArgs);
1: 
0:         Function f = Functions.find(stateFunc, stateArgs);
/////////////////////////////////////////////////////////////////////////
1:             List<AbstractType<?>> finalArgs = Collections.<AbstractType<?>>singletonList(stateType);
0:             finalFunc = validateFunctionKeyspace(finalFunc, finalArgs);
0:             f = Functions.find(finalFunc, finalArgs);
/////////////////////////////////////////////////////////////////////////
0:     private FunctionName validateFunctionKeyspace(FunctionName func, List<AbstractType<?>> argTypes)
1:         {
0:             // If state/final function has no keyspace, check SYSTEM keyspace before logged keyspace.
0:             FunctionName nativeName = FunctionName.nativeFunction(func.name);
0:             if (Functions.find(nativeName, argTypes) != null)
0:                 return nativeName;
1: 
1:         }
commit:4df4f79
/////////////////////////////////////////////////////////////////////////
1:             if (Constants.NULL_LITERAL != ival && UDHelper.isNullOrEmpty(stateType, initcond))
1:                 throw new InvalidRequestException("INITCOND must not be empty for all types except TEXT, ASCII, BLOB");
commit:6eea3ea
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SystemKeyspace;
/////////////////////////////////////////////////////////////////////////
1:     private FunctionName stateFunc;
1:     private FunctionName finalFunc;
/////////////////////////////////////////////////////////////////////////
0:                                     FunctionName stateFunc,
0:                                     FunctionName finalFunc,
/////////////////////////////////////////////////////////////////////////
0:         Function f = Functions.find(stateFunc, stateArguments(stateType, argTypes));
1:             throw new InvalidRequestException("State function " + stateFuncSig(stateFunc, stateTypeRaw, argRawTypes) + " does not exist or is not a scalar function");
/////////////////////////////////////////////////////////////////////////
0:             f = Functions.find(finalFunc, Collections.<AbstractType<?>>singletonList(stateType));
1:                 throw new InvalidRequestException("Final function " + finalFunc + '(' + stateTypeRaw + ") does not exist or is not a scalar function");
/////////////////////////////////////////////////////////////////////////
0:         stateFunc = validateFunctionKeyspace(stateFunc);
1: 
1:         if (finalFunc != null)
0:             finalFunc = validateFunctionKeyspace(finalFunc);
1: 
0:     private FunctionName validateFunctionKeyspace(FunctionName func)
1:     {
0:         if (!func.hasKeyspace())
0:             return new FunctionName(functionName.keyspace, func.name);
0:         else if (!SystemKeyspace.NAME.equals(func.keyspace) && !functionName.keyspace.equals(func.keyspace))
0:             throw new InvalidRequestException(String.format("Statement on keyspace %s cannot refer to a user function in keyspace %s; "
0:                                                             + "user functions can only be used in the keyspace they are defined in",
0:                                                             functionName.keyspace, func.keyspace));
0:         return func;
1:     }
1: 
commit:1937bed
/////////////////////////////////////////////////////////////////////////
1:         if (!stateFunction.isCalledOnNullInput() && initcond == null)
1:             throw new InvalidRequestException(String.format("Cannot create aggregate %s without INITCOND because state function %s does not accept 'null' arguments", functionName, stateFunc));
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static List<AbstractType<?>> stateArguments(AbstractType<?> stateType, List<AbstractType<?>> argTypes)
commit:40a7e86
/////////////////////////////////////////////////////////////////////////
1:  * A {@code CREATE AGGREGATE} statement parsed from a CQL query.
/////////////////////////////////////////////////////////////////////////
1:         AbstractType<?> stateReturnType = stateFunction.returnType();
1:         if (!stateReturnType.equals(stateType))
1:             throw new InvalidRequestException("State function " + stateFuncSig(stateFunction.name(), stateTypeRaw, argRawTypes) + " return type must be the same as the first argument type - check STYPE, argument and return types");
1: 
0:                 throw new InvalidRequestException("Final function " + finalFuncName + '(' + stateTypeRaw + ") does not exist or is not a scalar function");
1:             returnType = stateReturnType;
/////////////////////////////////////////////////////////////////////////
1:     private static String stateFuncSig(FunctionName stateFuncName, CQL3Type.Raw stateTypeRaw, List<CQL3Type.Raw> argRawTypes)
commit:e3c0186
/////////////////////////////////////////////////////////////////////////
0:                 throw new InvalidRequestException("Final function " + finalFuncName + "(" + stateTypeRaw + ") does not exist or is not a scalar function");
commit:dcc3bb0
/////////////////////////////////////////////////////////////////////////
0:     private final String stateFunc;
0:     private final String finalFunc;
0:     private UDAggregate udAggregate;
0:     private boolean replaced;
1: 
/////////////////////////////////////////////////////////////////////////
1:         return new Event.SchemaChange(replaced ? Event.SchemaChange.Change.UPDATED : Event.SchemaChange.Change.CREATED,
1:                                       Event.SchemaChange.Target.AGGREGATE,
1:                                       udAggregate.name().keyspace, udAggregate.name().name, AbstractType.asCQLTypeStringList(udAggregate.argTypes()));
/////////////////////////////////////////////////////////////////////////
0:         udAggregate = new UDAggregate(functionName, argTypes, returnType,
0:         replaced = old != null;
commit:e2f35c7
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.cql3.statements;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.List;
1: 
0: import org.apache.cassandra.auth.Permission;
1: import org.apache.cassandra.config.Schema;
0: import org.apache.cassandra.cql3.CQL3Type;
0: import org.apache.cassandra.cql3.ColumnIdentifier;
0: import org.apache.cassandra.cql3.ColumnSpecification;
0: import org.apache.cassandra.cql3.QueryOptions;
0: import org.apache.cassandra.cql3.Term;
1: import org.apache.cassandra.cql3.functions.*;
1: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.exceptions.InvalidRequestException;
0: import org.apache.cassandra.exceptions.RequestValidationException;
0: import org.apache.cassandra.exceptions.UnauthorizedException;
1: import org.apache.cassandra.service.ClientState;
1: import org.apache.cassandra.service.MigrationManager;
1: import org.apache.cassandra.thrift.ThriftValidation;
1: import org.apache.cassandra.transport.Event;
1: 
1: /**
0:  * A <code>CREATE AGGREGATE</code> statement parsed from a CQL query.
1:  */
1: public final class CreateAggregateStatement extends SchemaAlteringStatement
1: {
1:     private final boolean orReplace;
1:     private final boolean ifNotExists;
1:     private FunctionName functionName;
0:     private String stateFunc;
0:     private String finalFunc;
1:     private final CQL3Type.Raw stateTypeRaw;
1: 
1:     private final List<CQL3Type.Raw> argRawTypes;
1:     private final Term.Raw ival;
1: 
1:     public CreateAggregateStatement(FunctionName functionName,
1:                                     List<CQL3Type.Raw> argRawTypes,
0:                                     String stateFunc,
1:                                     CQL3Type.Raw stateType,
0:                                     String finalFunc,
1:                                     Term.Raw ival,
1:                                     boolean orReplace,
1:                                     boolean ifNotExists)
1:     {
1:         this.functionName = functionName;
1:         this.argRawTypes = argRawTypes;
0:         this.stateFunc = stateFunc;
0:         this.finalFunc = finalFunc;
1:         this.stateTypeRaw = stateType;
1:         this.ival = ival;
1:         this.orReplace = orReplace;
1:         this.ifNotExists = ifNotExists;
1:     }
1: 
1:     public void prepareKeyspace(ClientState state) throws InvalidRequestException
1:     {
1:         if (!functionName.hasKeyspace() && state.getRawKeyspace() != null)
1:             functionName = new FunctionName(state.getKeyspace(), functionName.name);
1: 
1:         if (!functionName.hasKeyspace())
1:             throw new InvalidRequestException("Functions must be fully qualified with a keyspace name if a keyspace is not set for the session");
1: 
1:         ThriftValidation.validateKeyspaceNotSystem(functionName.keyspace);
1:     }
1: 
1:     public void checkAccess(ClientState state) throws UnauthorizedException, InvalidRequestException
1:     {
0:         // TODO CASSANDRA-7557 (function DDL permission)
1: 
0:         state.hasKeyspaceAccess(functionName.keyspace, Permission.CREATE);
1:     }
1: 
1:     public void validate(ClientState state) throws InvalidRequestException
1:     {
1:         if (ifNotExists && orReplace)
1:             throw new InvalidRequestException("Cannot use both 'OR REPLACE' and 'IF NOT EXISTS' directives");
1: 
1:         if (Schema.instance.getKSMetaData(functionName.keyspace) == null)
1:             throw new InvalidRequestException(String.format("Cannot add aggregate '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
1:     }
1: 
0:     public Event.SchemaChange changeEvent()
1:     {
1:         return null;
1:     }
1: 
0:     public boolean announceMigration(boolean isLocalOnly) throws RequestValidationException
1:     {
0:         List<AbstractType<?>> argTypes = new ArrayList<>(argRawTypes.size());
1:         for (CQL3Type.Raw rawType : argRawTypes)
0:             argTypes.add(rawType.prepare(functionName.keyspace).getType());
1: 
0:         FunctionName stateFuncName = new FunctionName(functionName.keyspace, stateFunc);
0:         FunctionName finalFuncName;
1: 
0:         ScalarFunction fFinal = null;
0:         AbstractType<?> stateType = stateTypeRaw.prepare(functionName.keyspace).getType();
0:         Function f = Functions.find(stateFuncName, stateArguments(stateType, argTypes));
1:         if (!(f instanceof ScalarFunction))
0:             throw new InvalidRequestException("State function " + stateFuncSig(stateFuncName, stateTypeRaw, argRawTypes) + " does not exist or is not a scalar function");
0:         ScalarFunction fState = (ScalarFunction)f;
1: 
0:         AbstractType<?> returnType;
0:         if (finalFunc != null)
1:         {
0:             finalFuncName = new FunctionName(functionName.keyspace, finalFunc);
0:             f = Functions.find(finalFuncName, Collections.<AbstractType<?>>singletonList(stateType));
1:             if (!(f instanceof ScalarFunction))
0:                 throw new InvalidRequestException("Final function " + finalFuncName + "(" + stateTypeRaw + ") does not exist");
0:             fFinal = (ScalarFunction) f;
0:             returnType = fFinal.returnType();
1:         }
1:         else
1:         {
0:             returnType = fState.returnType();
0:             if (!returnType.equals(stateType))
0:                 throw new InvalidRequestException("State function " + stateFuncSig(stateFuncName, stateTypeRaw, argRawTypes) + " return type must be the same as the first argument type (if no final function is used)");
1:         }
1: 
0:         Function old = Functions.find(functionName, argTypes);
0:         if (old != null)
1:         {
1:             if (ifNotExists)
0:                 return false;
1:             if (!orReplace)
1:                 throw new InvalidRequestException(String.format("Function %s already exists", old));
1:             if (!(old instanceof AggregateFunction))
1:                 throw new InvalidRequestException(String.format("Aggregate %s can only replace an aggregate", old));
1: 
1:             // Means we're replacing the function. We still need to validate that 1) it's not a native function and 2) that the return type
1:             // matches (or that could break existing code badly)
1:             if (old.isNative())
1:                 throw new InvalidRequestException(String.format("Cannot replace native aggregate %s", old));
1:             if (!old.returnType().isValueCompatibleWith(returnType))
1:                 throw new InvalidRequestException(String.format("Cannot replace aggregate %s, the new return type %s is not compatible with the return type %s of existing function",
1:                                                                 functionName, returnType.asCQL3Type(), old.returnType().asCQL3Type()));
1:         }
1: 
0:         ByteBuffer initcond = null;
1:         if (ival != null)
1:         {
0:             ColumnSpecification receiver = new ColumnSpecification(functionName.keyspace, "--dummy--", new ColumnIdentifier("(aggregate_initcond)", true), stateType);
0:             initcond = ival.prepare(functionName.keyspace, receiver).bindAndGet(QueryOptions.DEFAULT);
1:         }
1: 
0:         UDAggregate udAggregate = new UDAggregate(functionName, argTypes, returnType,
0:                                                   fState,
0:                                                   fFinal,
0:                                                   initcond);
1: 
1:         MigrationManager.announceNewAggregate(udAggregate, isLocalOnly);
1: 
0:         return true;
1:     }
1: 
0:     private String stateFuncSig(FunctionName stateFuncName, CQL3Type.Raw stateTypeRaw, List<CQL3Type.Raw> argRawTypes)
1:     {
1:         StringBuilder sb = new StringBuilder();
1:         sb.append(stateFuncName.toString()).append('(').append(stateTypeRaw);
1:         for (CQL3Type.Raw argRawType : argRawTypes)
1:             sb.append(", ").append(argRawType);
1:         sb.append(')');
1:         return sb.toString();
1:     }
1: 
0:     private List<AbstractType<?>> stateArguments(AbstractType<?> stateType, List<AbstractType<?>> argTypes)
1:     {
1:         List<AbstractType<?>> r = new ArrayList<>(argTypes.size() + 1);
1:         r.add(stateType);
1:         r.addAll(argTypes);
1:         return r;
1:     }
1: }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:2cbd776
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
1:         boolean replaced = old != null;
1:         if (replaced)
0:                 return null;
/////////////////////////////////////////////////////////////////////////
1:         UDAggregate udAggregate = new UDAggregate(functionName, argTypes, returnType, stateFunction, finalFunction, initcond);
0:         return new Event.SchemaChange(replaced ? Event.SchemaChange.Change.UPDATED : Event.SchemaChange.Change.CREATED,
0:                                       Event.SchemaChange.Target.AGGREGATE,
0:                                       udAggregate.name().keyspace, udAggregate.name().name, AbstractType.asCQLTypeStringList(udAggregate.argTypes()));
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:3566843
/////////////////////////////////////////////////////////////////////////
1:         Function f = Schema.instance.findFunction(stateFunc, stateArgs).orElse(null);
/////////////////////////////////////////////////////////////////////////
1:             f = Schema.instance.findFunction(finalFunc, finalArgs).orElse(null);
/////////////////////////////////////////////////////////////////////////
0:             if (Schema.instance.findFunction(nativeName, argTypes).isPresent())
/////////////////////////////////////////////////////////////////////////
1:         if (Schema.instance.findFunction(functionName, argTypes).isPresent() && orReplace)
/////////////////////////////////////////////////////////////////////////
1:         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
author:blerer
-------------------------------------------------------------------------------
commit:1de8e39
/////////////////////////////////////////////////////////////////////////
1:             argTypes.add(prepareType("arguments", rawType));
1:         AbstractType<?> stateType = prepareType("state type", stateTypeRaw);
/////////////////////////////////////////////////////////////////////////
1:     private AbstractType<?> prepareType(String typeName, CQL3Type.Raw rawType)
1:     {
1:         if (rawType.isFrozen())
1:             throw new InvalidRequestException(String.format("The function %s should not be frozen; remove the frozen<> modifier", typeName));
1: 
1:         // UDT are not supported non frozen but we do not allow the frozen keyword for argument. So for the moment we
1:         // freeze them here
1:         if (!rawType.canBeNonFrozen())
1:             rawType.freeze();
1: 
1:         AbstractType<?> type = rawType.prepare(functionName.keyspace).getType();
1:         return type;
1:     }
1: 
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:cb5897f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.auth.*;
1: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.cql3.*;
1: import org.apache.cassandra.exceptions.*;
1: import org.apache.cassandra.service.QueryState;
/////////////////////////////////////////////////////////////////////////
1:     private List<AbstractType<?>> argTypes;
1:     private AbstractType<?> returnType;
1:     private ScalarFunction stateFunction;
1:     private ScalarFunction finalFunction;
1:     private ByteBuffer initcond;
0: 
/////////////////////////////////////////////////////////////////////////
1:     public Prepared prepare()
1:     {
1:         argTypes = new ArrayList<>(argRawTypes.size());
0:         for (CQL3Type.Raw rawType : argRawTypes)
0:             argTypes.add(rawType.prepare(functionName.keyspace).getType());
0: 
0:         AbstractType<?> stateType = stateTypeRaw.prepare(functionName.keyspace).getType();
0:         FunctionName stateFuncName = new FunctionName(functionName.keyspace, stateFunc);
0:         Function f = Functions.find(stateFuncName, stateArguments(stateType, argTypes));
0:         if (!(f instanceof ScalarFunction))
0:             throw new InvalidRequestException("State function " + stateFuncSig(stateFuncName, stateTypeRaw, argRawTypes) + " does not exist or is not a scalar function");
1:         stateFunction = (ScalarFunction)f;
0: 
0:         if (finalFunc != null)
1:         {
0:             FunctionName finalFuncName = new FunctionName(functionName.keyspace, finalFunc);
0:             f = Functions.find(finalFuncName, Collections.<AbstractType<?>>singletonList(stateType));
0:             if (!(f instanceof ScalarFunction))
0:                 throw new InvalidRequestException("Final function " + finalFuncName + "(" + stateTypeRaw + ") does not exist or is not a scalar function");
1:             finalFunction = (ScalarFunction) f;
1:             returnType = finalFunction.returnType();
1:         }
1:         else
1:         {
0:             returnType = stateFunction.returnType();
0:             if (!returnType.equals(stateType))
0:                 throw new InvalidRequestException("State function " + stateFuncSig(stateFunction.name(), stateTypeRaw, argRawTypes) + " return type must be the same as the first argument type (if no final function is used)");
1:         }
0: 
0:         if (ival != null)
1:         {
0:             ColumnSpecification receiver = new ColumnSpecification(functionName.keyspace, "--dummy--", new ColumnIdentifier("(aggregate_initcond)", true), stateType);
0:             initcond = ival.prepare(functionName.keyspace, receiver).bindAndGet(QueryOptions.DEFAULT);
1:         }
0: 
1:         return super.prepare();
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     protected void grantPermissionsToCreator(QueryState state)
0:     {
1:         try
0:         {
1:             IResource resource = FunctionResource.function(functionName.keyspace, functionName.name, argTypes);
1:             DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,
1:                                                      resource.applicablePermissions(),
1:                                                      resource,
1:                                                      RoleResource.role(state.getClientState().getUser().getName()));
0:         }
1:         catch (RequestExecutionException e)
0:         {
1:             throw new RuntimeException(e);
0:         }
0:     }
0: 
0:         if (Functions.find(functionName, argTypes) != null && orReplace)
1:             state.ensureHasPermission(Permission.ALTER, FunctionResource.function(functionName.keyspace,
1:                                                                                   functionName.name,
1:                                                                                   argTypes));
0:         else
1:             state.ensureHasPermission(Permission.CREATE, FunctionResource.keyspace(functionName.keyspace));
0:         for (Function referencedFunction : stateFunction.getFunctions())
0:             state.ensureHasPermission(Permission.EXECUTE, referencedFunction);
0: 
1:         if (finalFunction != null)
0:             for (Function referencedFunction : finalFunction.getFunctions())
0:                 state.ensureHasPermission(Permission.EXECUTE, referencedFunction);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                                   stateFunction,
0:                                                   finalFunction,
============================================================================