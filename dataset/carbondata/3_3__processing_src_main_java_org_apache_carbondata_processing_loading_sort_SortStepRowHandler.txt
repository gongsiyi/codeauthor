1:2b41f14: /*
1:2b41f14:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:2b41f14:  * contributor license agreements.  See the NOTICE file distributed with
1:2b41f14:  * this work for additional information regarding copyright ownership.
1:2b41f14:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:2b41f14:  * (the "License"); you may not use this file except in compliance with
1:2b41f14:  * the License.  You may obtain a copy of the License at
1:2b41f14:  *
1:2b41f14:  *    http://www.apache.org/licenses/LICENSE-2.0
1:2b41f14:  *
1:2b41f14:  * Unless required by applicable law or agreed to in writing, software
1:2b41f14:  * distributed under the License is distributed on an "AS IS" BASIS,
1:2b41f14:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2b41f14:  * See the License for the specific language governing permissions and
1:2b41f14:  * limitations under the License.
1:2b41f14:  */
8:2b41f14: 
1:2b41f14: package org.apache.carbondata.processing.loading.sort;
1:2b41f14: 
1:2b41f14: import java.io.DataInputStream;
1:2b41f14: import java.io.DataOutputStream;
1:2b41f14: import java.io.IOException;
1:2b41f14: import java.io.Serializable;
1:2b41f14: import java.math.BigDecimal;
1:2b41f14: import java.nio.ByteBuffer;
1:2b41f14: 
1:2b41f14: import org.apache.carbondata.core.memory.CarbonUnsafe;
1:2b41f14: import org.apache.carbondata.core.metadata.datatype.DataType;
1:2b41f14: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:2b41f14: import org.apache.carbondata.core.util.DataTypeUtil;
1:2b41f14: import org.apache.carbondata.core.util.NonDictionaryUtil;
1:2b41f14: import org.apache.carbondata.processing.loading.row.IntermediateSortTempRow;
1:2b41f14: import org.apache.carbondata.processing.sort.sortdata.SortParameters;
1:2b41f14: import org.apache.carbondata.processing.sort.sortdata.TableFieldStat;
1:2b41f14: 
1:2b41f14: /**
1:2b41f14:  * This class is used to convert/write/read row in sort step in carbondata.
1:2b41f14:  * It consists the following function:
1:2b41f14:  * 1. convert raw row & intermediate sort temp row to 3-parted row
1:2b41f14:  * 2. read/write intermediate sort temp row to sort temp file & unsafe memory
1:2b41f14:  * 3. write raw row directly to sort temp file & unsafe memory as intermediate sort temp row
1:2b41f14:  */
1:2b41f14: public class SortStepRowHandler implements Serializable {
1:2b41f14:   private static final long serialVersionUID = 1L;
1:2b41f14:   private int dictSortDimCnt = 0;
1:2b41f14:   private int dictNoSortDimCnt = 0;
1:2b41f14:   private int noDictSortDimCnt = 0;
1:2b41f14:   private int noDictNoSortDimCnt = 0;
1:dc53dee:   private int varcharDimCnt = 0;
1:11fb422:   private int complexDimCnt = 0;
1:2b41f14:   private int measureCnt;
1:2b41f14: 
1:2b41f14:   // indices for dict & sort dimension columns
1:2b41f14:   private int[] dictSortDimIdx;
1:2b41f14:   // indices for dict & no-sort dimension columns
1:2b41f14:   private int[] dictNoSortDimIdx;
1:2b41f14:   // indices for no-dict & sort dimension columns
1:2b41f14:   private int[] noDictSortDimIdx;
1:11fb422:   // indices for no-dict & no-sort dimension columns, excluding complex/varchar columns
1:2b41f14:   private int[] noDictNoSortDimIdx;
1:dc53dee:   private int[] varcharDimIdx;
1:11fb422:   private int[] complexDimIdx;
1:2b41f14:   // indices for measure columns
1:2b41f14:   private int[] measureIdx;
1:2b41f14: 
1:2b41f14:   private DataType[] dataTypes;
1:2b41f14: 
1:2b41f14:   /**
1:2b41f14:    * constructor
1:2b41f14:    * @param tableFieldStat table field stat
1:2b41f14:    */
1:2b41f14:   public SortStepRowHandler(TableFieldStat tableFieldStat) {
1:2b41f14:     this.dictSortDimCnt = tableFieldStat.getDictSortDimCnt();
1:2b41f14:     this.dictNoSortDimCnt = tableFieldStat.getDictNoSortDimCnt();
1:2b41f14:     this.noDictSortDimCnt = tableFieldStat.getNoDictSortDimCnt();
1:2b41f14:     this.noDictNoSortDimCnt = tableFieldStat.getNoDictNoSortDimCnt();
1:dc53dee:     this.varcharDimCnt = tableFieldStat.getVarcharDimCnt();
1:11fb422:     this.complexDimCnt = tableFieldStat.getComplexDimCnt();
1:2b41f14:     this.measureCnt = tableFieldStat.getMeasureCnt();
1:2b41f14:     this.dictSortDimIdx = tableFieldStat.getDictSortDimIdx();
1:2b41f14:     this.dictNoSortDimIdx = tableFieldStat.getDictNoSortDimIdx();
1:2b41f14:     this.noDictSortDimIdx = tableFieldStat.getNoDictSortDimIdx();
1:2b41f14:     this.noDictNoSortDimIdx = tableFieldStat.getNoDictNoSortDimIdx();
1:dc53dee:     this.varcharDimIdx = tableFieldStat.getVarcharDimIdx();
1:11fb422:     this.complexDimIdx = tableFieldStat.getComplexDimIdx();
1:2b41f14:     this.measureIdx = tableFieldStat.getMeasureIdx();
1:2b41f14:     this.dataTypes = tableFieldStat.getMeasureDataType();
1:2b41f14:   }
1:2b41f14: 
1:2b41f14:   /**
1:2b41f14:    * constructor
1:2b41f14:    * @param sortParameters sort parameters
1:2b41f14:    */
1:2b41f14:   public SortStepRowHandler(SortParameters sortParameters) {
1:2b41f14:     this(new TableFieldStat(sortParameters));
1:2b41f14:   }
1:2b41f14: 
1:2b41f14:   /**
1:2b41f14:    * Convert carbon row from raw format to 3-parted format.
1:2b41f14:    * This method is used in global-sort.
1:2b41f14:    *
1:2b41f14:    * @param row raw row whose length is the same as field number
1:2b41f14:    * @return 3-parted row whose length is 3. (1 for dict dims ,1 for non-dict and complex,
1:2b41f14:    * 1 for measures)
1:2b41f14:    */
1:2b41f14:   public Object[] convertRawRowTo3Parts(Object[] row) {
2:2b41f14:     Object[] holder = new Object[3];
1:2b41f14:     try {
2:2b41f14:       int[] dictDims
2:2b41f14:           = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
1:11fb422:       byte[][] nonDictArray = new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt
1:11fb422:                                        + this.varcharDimCnt + this.complexDimCnt ][];
2:2b41f14:       Object[] measures = new Object[this.measureCnt];
1:2b41f14: 
1:2b41f14:       // convert dict & data
1:2b41f14:       int idxAcc = 0;
1:2b41f14:       for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:2b41f14:         dictDims[idxAcc++] = (int) row[this.dictSortDimIdx[idx]];
1:2b41f14:       }
1:2b41f14: 
1:2b41f14:       // convert dict & no-sort
1:2b41f14:       for (int idx = 0; idx < this.dictNoSortDimCnt; idx++) {
1:2b41f14:         dictDims[idxAcc++] = (int) row[this.dictNoSortDimIdx[idx]];
1:2b41f14:       }
1:2b41f14:       // convert no-dict & sort
1:2b41f14:       idxAcc = 0;
1:2b41f14:       for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:2b41f14:         nonDictArray[idxAcc++] = (byte[]) row[this.noDictSortDimIdx[idx]];
1:2b41f14:       }
1:2b41f14:       // convert no-dict & no-sort
1:2b41f14:       for (int idx = 0; idx < this.noDictNoSortDimCnt; idx++) {
1:2b41f14:         nonDictArray[idxAcc++] = (byte[]) row[this.noDictNoSortDimIdx[idx]];
1:2b41f14:       }
1:dc53dee:       // convert varchar dims
1:dc53dee:       for (int idx = 0; idx < this.varcharDimCnt; idx++) {
1:dc53dee:         nonDictArray[idxAcc++] = (byte[]) row[this.varcharDimIdx[idx]];
1:dc53dee:       }
1:11fb422:       // convert complex dims
1:11fb422:       for (int idx = 0; idx < this.complexDimCnt; idx++) {
1:11fb422:         nonDictArray[idxAcc++] = (byte[]) row[this.complexDimIdx[idx]];
1:11fb422:       }
1:2b41f14: 
1:2b41f14:       // convert measure data
1:2b41f14:       for (int idx = 0; idx < this.measureCnt; idx++) {
1:2b41f14:         measures[idx] = row[this.measureIdx[idx]];
1:2b41f14:       }
1:2b41f14: 
1:2b41f14:       NonDictionaryUtil.prepareOutObj(holder, dictDims, nonDictArray, measures);
1:2b41f14:     } catch (Exception e) {
1:2b41f14:       throw new RuntimeException("Problem while converting row to 3 parts", e);
1:2b41f14:     }
2:2b41f14:     return holder;
1:2b41f14:   }
1:2b41f14: 
1:2b41f14:   /**
1:2b41f14:    * Convert intermediate sort temp row to 3-parted row.
1:2b41f14:    * This method is used in the final merge sort to feed rows to the next write step.
1:2b41f14:    *
1:2b41f14:    * @param sortTempRow intermediate sort temp row
1:2b41f14:    * @return 3-parted row
1:2b41f14:    */
1:2b41f14:   public Object[] convertIntermediateSortTempRowTo3Parted(IntermediateSortTempRow sortTempRow) {
1:f27efb3:     Object[] out = new Object[3];
1:f27efb3:     NonDictionaryUtil
1:f27efb3:         .prepareOutObj(out, sortTempRow.getDictSortDims(), sortTempRow.getNoDictSortDims(),
1:f27efb3:             sortTempRow.getMeasures());
1:f27efb3:     return out;
1:2b41f14:   }
1:2b41f14: 
1:2b41f14:   /**
1:2b41f14:    * Read intermediate sort temp row from InputStream.
1:f27efb3:    * This method is used during the intermediate merge sort phase to read row from sort temp file.
1:2b41f14:    *
1:2b41f14:    * @param inputStream input stream
1:2b41f14:    * @return a row that contains three parts
1:2b41f14:    * @throws IOException if error occrus while reading from stream
1:2b41f14:    */
1:f27efb3:   public IntermediateSortTempRow readWithoutNoSortFieldConvert(
1:2b41f14:       DataInputStream inputStream) throws IOException {
1:2b41f14:     int[] dictSortDims = new int[this.dictSortDimCnt];
1:2b41f14:     byte[][] noDictSortDims = new byte[this.noDictSortDimCnt][];
1:2b41f14: 
1:2b41f14:     // read dict & sort dim data
1:2b41f14:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:2b41f14:       dictSortDims[idx] = inputStream.readInt();
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // read no-dict & sort data
1:2b41f14:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:2b41f14:       short len = inputStream.readShort();
1:2b41f14:       byte[] bytes = new byte[len];
1:2b41f14:       inputStream.readFully(bytes);
1:2b41f14:       noDictSortDims[idx] = bytes;
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // read no-dict dims & measures
1:2b41f14:     int len = inputStream.readInt();
1:2b41f14:     byte[] noSortDimsAndMeasures = new byte[len];
1:2b41f14:     inputStream.readFully(noSortDimsAndMeasures);
1:f27efb3:     // keeping no sort fields and measure in pack byte array as it will not participate in sort
1:2b41f14:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims, noSortDimsAndMeasures);
1:2b41f14:   }
1:2b41f14: 
1:2b41f14:   /**
1:f27efb3:    * Read intermediate sort temp row from InputStream.
1:f27efb3:    * This method is used during the final merge sort phase to read row from sort temp file and
1:f27efb3:    * merged sort temp file.
1:f27efb3:    *
1:f27efb3:    * @param inputStream input stream
1:f27efb3:    * @return a row that contains three parts
1:f27efb3:    * @throws IOException if error occrus while reading from stream
1:f27efb3:    */
1:f27efb3:   public IntermediateSortTempRow readWithNoSortFieldConvert(
1:f27efb3:       DataInputStream inputStream) throws IOException {
1:f27efb3:     int[] dictSortDims = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
1:f27efb3:     byte[][] noDictSortDims =
1:f27efb3:         new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt + this.varcharDimCnt
1:f27efb3:             + this.complexDimCnt][];
1:f27efb3: 
1:f27efb3:     // read dict & sort dim data
1:f27efb3:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:f27efb3:       dictSortDims[idx] = inputStream.readInt();
1:f27efb3:     }
1:f27efb3: 
1:f27efb3:     // read no-dict & sort data
1:f27efb3:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:f27efb3:       short len = inputStream.readShort();
1:f27efb3:       byte[] bytes = new byte[len];
1:f27efb3:       inputStream.readFully(bytes);
1:f27efb3:       noDictSortDims[idx] = bytes;
1:f27efb3:     }
1:f27efb3: 
1:f27efb3:     // read no-dict dims & measures
1:f27efb3:     int len = inputStream.readInt();
1:f27efb3:     byte[] noSortDimsAndMeasures = new byte[len];
1:f27efb3:     inputStream.readFully(noSortDimsAndMeasures);
1:f27efb3:     Object[] measure = new Object[this.measureCnt];
1:f27efb3:     // unpack the no sort fields and measure fields
1:f27efb3:     unpackNoSortFromBytes(noSortDimsAndMeasures, dictSortDims, noDictSortDims, measure);
1:f27efb3:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims,measure);
1:f27efb3:   }
1:f27efb3: 
1:f27efb3:   private void unpackNoSortFromBytes(byte[] noSortDimsAndMeasures, int[] dictDims,
1:f27efb3:       byte[][] noDictDims, Object[] measures) {
1:f27efb3:     ByteBuffer rowBuffer = ByteBuffer.wrap(noSortDimsAndMeasures);
1:f27efb3:     // read dict_no_sort
1:f27efb3:     for (int i = dictSortDimCnt; i < dictDims.length; i++) {
1:f27efb3:       dictDims[i] = rowBuffer.getInt();
1:f27efb3:     }
1:f27efb3: 
1:f27efb3:     int noDictIndex = noDictSortDimCnt;
1:f27efb3:     // read no_dict_no_sort
1:f27efb3:     for (int i = 0; i < noDictNoSortDimCnt; i++) {
1:f27efb3:       short len = rowBuffer.getShort();
1:f27efb3:       byte[] bytes = new byte[len];
1:f27efb3:       rowBuffer.get(bytes);
1:f27efb3:       noDictDims[noDictIndex++] = bytes;
1:f27efb3:     }
1:f27efb3: 
1:f27efb3:     // read varchar dims
1:f27efb3:     for (int i = 0; i < varcharDimCnt; i++) {
1:f27efb3:       int len = rowBuffer.getInt();
1:f27efb3:       byte[] bytes = new byte[len];
1:f27efb3:       rowBuffer.get(bytes);
1:f27efb3:       noDictDims[noDictIndex++] = bytes;
1:f27efb3:     }
1:f27efb3: 
1:f27efb3:     // read complex dims
1:f27efb3:     for (int i = 0; i < complexDimCnt; i++) {
1:f27efb3:       short len = rowBuffer.getShort();
1:f27efb3:       byte[] bytes = new byte[len];
1:f27efb3:       rowBuffer.get(bytes);
1:f27efb3:       noDictDims[noDictIndex++] = bytes;
1:f27efb3:     }
1:f27efb3: 
1:f27efb3:     // read measure
1:f27efb3:     int measureCnt = measures.length;
1:f27efb3:     DataType tmpDataType;
1:f27efb3:     Object tmpContent;
1:f27efb3:     for (short idx = 0 ; idx < measureCnt; idx++) {
1:f27efb3:       if ((byte) 0 == rowBuffer.get()) {
1:f27efb3:         measures[idx] = null;
1:f27efb3:         continue;
1:f27efb3:       }
1:f27efb3: 
1:f27efb3:       tmpDataType = dataTypes[idx];
1:f27efb3:       if (DataTypes.BOOLEAN == tmpDataType) {
1:f27efb3:         if ((byte) 1 == rowBuffer.get()) {
1:f27efb3:           tmpContent = true;
1:f27efb3:         } else {
1:f27efb3:           tmpContent = false;
1:f27efb3:         }
1:f27efb3:       } else if (DataTypes.SHORT == tmpDataType) {
1:f27efb3:         tmpContent = rowBuffer.getShort();
1:f27efb3:       } else if (DataTypes.INT == tmpDataType) {
1:f27efb3:         tmpContent = rowBuffer.getInt();
1:f27efb3:       } else if (DataTypes.LONG == tmpDataType) {
1:f27efb3:         tmpContent = rowBuffer.getLong();
1:f27efb3:       } else if (DataTypes.DOUBLE == tmpDataType) {
1:f27efb3:         tmpContent = rowBuffer.getDouble();
1:f27efb3:       } else if (DataTypes.isDecimal(tmpDataType)) {
1:f27efb3:         short len = rowBuffer.getShort();
1:f27efb3:         byte[] decimalBytes = new byte[len];
1:f27efb3:         rowBuffer.get(decimalBytes);
1:f27efb3:         tmpContent = DataTypeUtil.byteToBigDecimal(decimalBytes);
1:f27efb3:       } else {
1:f27efb3:         throw new IllegalArgumentException("Unsupported data type: " + tmpDataType);
1:f27efb3:       }
1:f27efb3:       measures[idx] = tmpContent;
1:f27efb3:     }
1:f27efb3:   }
1:f27efb3: 
1:f27efb3:   /**
1:2b41f14:    * Write intermediate sort temp row to OutputStream
1:2b41f14:    * This method is used during the merge sort phase to write row to sort temp file.
1:2b41f14:    *
1:2b41f14:    * @param sortTempRow intermediate sort temp row
1:2b41f14:    * @param outputStream output stream
1:2b41f14:    * @throws IOException if error occurs while writing to stream
1:2b41f14:    */
1:2b41f14:   public void writeIntermediateSortTempRowToOutputStream(IntermediateSortTempRow sortTempRow,
1:2b41f14:       DataOutputStream outputStream) throws IOException {
1:2b41f14:     // write dict & sort dim
1:2b41f14:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:2b41f14:       outputStream.writeInt(sortTempRow.getDictSortDims()[idx]);
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // write no-dict & sort dim
1:2b41f14:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:2b41f14:       byte[] bytes = sortTempRow.getNoDictSortDims()[idx];
1:2b41f14:       outputStream.writeShort(bytes.length);
1:2b41f14:       outputStream.write(bytes);
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // write packed no-sort dim & measure
1:2b41f14:     outputStream.writeInt(sortTempRow.getNoSortDimsAndMeasures().length);
1:2b41f14:     outputStream.write(sortTempRow.getNoSortDimsAndMeasures());
1:2b41f14:   }
1:2b41f14: 
1:2b41f14:   /**
1:2b41f14:    * Write raw row as an intermediate sort temp row to sort temp file.
1:2b41f14:    * This method is used in the beginning of the sort phase. Comparing with converting raw row to
1:2b41f14:    * intermediate sort temp row and then writing the converted one, Writing raw row directly will
1:2b41f14:    * save the intermediate trivial loss.
1:2b41f14:    * This method use an array backend buffer to save memory allocation. The buffer will be reused
1:2b41f14:    * for all rows (per thread).
1:2b41f14:    *
1:2b41f14:    * @param row raw row
1:2b41f14:    * @param outputStream output stream
1:2b41f14:    * @param rowBuffer array backend buffer
1:2b41f14:    * @throws IOException if error occurs while writing to stream
1:2b41f14:    */
1:2b41f14:   public void writeRawRowAsIntermediateSortTempRowToOutputStream(Object[] row,
1:2b41f14:       DataOutputStream outputStream, ByteBuffer rowBuffer) throws IOException {
1:2b41f14:     // write dict & sort
1:2b41f14:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:2b41f14:       outputStream.writeInt((int) row[this.dictSortDimIdx[idx]]);
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // write no-dict & sort
1:2b41f14:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:2b41f14:       byte[] bytes = (byte[]) row[this.noDictSortDimIdx[idx]];
1:2b41f14:       outputStream.writeShort(bytes.length);
1:2b41f14:       outputStream.write(bytes);
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // pack no-sort
1:2b41f14:     rowBuffer.clear();
1:2b41f14:     packNoSortFieldsToBytes(row, rowBuffer);
1:2b41f14:     rowBuffer.flip();
1:2b41f14:     int packSize = rowBuffer.limit();
1:2b41f14: 
1:2b41f14:     // write no-sort
1:2b41f14:     outputStream.writeInt(packSize);
1:2b41f14:     outputStream.write(rowBuffer.array(), 0, packSize);
1:2b41f14:   }
1:2b41f14: 
1:2b41f14:   /**
1:f27efb3:    * Read intermediate sort temp row from unsafe memory.
1:f27efb3:    * This method is used during merge sort phase for off-heap sort.
1:f27efb3:    *
1:f27efb3:    * @param baseObject base object of memory block
1:f27efb3:    * @param address address of the row
1:f27efb3:    * @return intermediate sort temp row
1:f27efb3:    */
1:f27efb3:   public IntermediateSortTempRow readFromMemoryWithoutNoSortFieldConvert(Object baseObject,
1:2b41f14:       long address) {
1:2b41f14:     int size = 0;
1:f27efb3: 
1:2b41f14:     int[] dictSortDims = new int[this.dictSortDimCnt];
1:2b41f14:     byte[][] noDictSortDims = new byte[this.noDictSortDimCnt][];
1:2b41f14: 
1:2b41f14:     // read dict & sort dim
1:2b41f14:     for (int idx = 0; idx < dictSortDims.length; idx++) {
1:2b41f14:       dictSortDims[idx] = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:2b41f14:       size += 4;
1:f27efb3:     }
1:2b41f14: 
1:2b41f14:     // read no-dict & sort dim
1:2b41f14:     for (int idx = 0; idx < noDictSortDims.length; idx++) {
1:2b41f14:       short length = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
1:2b41f14:       size += 2;
1:2b41f14:       byte[] bytes = new byte[length];
1:f27efb3:       CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:2b41f14:           bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, length);
1:2b41f14:       size += length;
1:2b41f14:       noDictSortDims[idx] = bytes;
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // read no-sort dims & measures
1:2b41f14:     int len = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:2b41f14:     size += 4;
1:2b41f14:     byte[] noSortDimsAndMeasures = new byte[len];
1:2b41f14:     CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:2b41f14:         noSortDimsAndMeasures, CarbonUnsafe.BYTE_ARRAY_OFFSET, len);
1:2b41f14: 
1:2b41f14:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims, noSortDimsAndMeasures);
1:2b41f14:   }
1:2b41f14: 
1:2b41f14:   /**
1:2b41f14:    * Read intermediate sort temp row from unsafe memory.
1:2b41f14:    * This method is used during merge sort phase for off-heap sort.
1:2b41f14:    *
1:2b41f14:    * @param baseObject base object of memory block
1:2b41f14:    * @param address address of the row
1:2b41f14:    * @return intermediate sort temp row
1:2b41f14:    */
1:f27efb3:   public IntermediateSortTempRow readRowFromMemoryWithNoSortFieldConvert(Object baseObject,
1:f27efb3:       long address) {
1:f27efb3:     int size = 0;
1:f27efb3: 
1:f27efb3:     int[] dictSortDims = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
1:f27efb3:     byte[][] noDictSortDims =
1:f27efb3:         new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt + this.varcharDimCnt
1:f27efb3:             + this.complexDimCnt][];
1:f27efb3: 
1:f27efb3:     // read dict & sort dim
1:f27efb3:     for (int idx = 0; idx < dictSortDimCnt; idx++) {
1:f27efb3:       dictSortDims[idx] = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:f27efb3:       size += 4;
1:f27efb3:     }
1:f27efb3: 
1:f27efb3:     // read no-dict & sort dim
1:f27efb3:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:f27efb3:       short length = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
1:f27efb3:       size += 2;
1:f27efb3:       byte[] bytes = new byte[length];
1:f27efb3:       CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:f27efb3:           bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, length);
1:f27efb3:       size += length;
1:f27efb3:       noDictSortDims[idx] = bytes;
1:2b41f14:     }
1:2b41f14: 
1:f27efb3:     // read no-sort dims & measures
1:f27efb3:     int len = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:f27efb3:     size += 4;
1:f27efb3:     byte[] noSortDimsAndMeasures = new byte[len];
1:2b41f14:     CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:f27efb3:         noSortDimsAndMeasures, CarbonUnsafe.BYTE_ARRAY_OFFSET, len);
1:f27efb3:     Object[] measures = new Object[measureCnt];
1:f27efb3:     unpackNoSortFromBytes(noSortDimsAndMeasures, dictSortDims, noDictSortDims, measures);
1:f27efb3:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims, measures);
1:f27efb3:   }
1:f27efb3: 
1:f27efb3:   /**
1:2b41f14:    * Write intermediate sort temp row directly from unsafe memory to stream.
1:2b41f14:    * This method is used at the late beginning of the sort phase to write in-memory pages
1:2b41f14:    * to sort temp file. Comparing with reading intermediate sort temp row from memory and then
1:2b41f14:    * writing it, Writing directly from memory to stream will save the intermediate trivial loss.
1:2b41f14:    *
1:2b41f14:    * @param baseObject base object of the memory block
1:2b41f14:    * @param address base address of the row
1:2b41f14:    * @param outputStream output stream
1:2b41f14:    * @throws IOException if error occurs while writing to stream
1:2b41f14:    */
1:2b41f14:   public void writeIntermediateSortTempRowFromUnsafeMemoryToStream(Object baseObject,
1:2b41f14:       long address, DataOutputStream outputStream) throws IOException {
1:2b41f14:     int size = 0;
1:2b41f14: 
1:2b41f14:     // dict & sort
1:2b41f14:     for (int idx = 0; idx < dictSortDimCnt; idx++) {
1:2b41f14:       outputStream.writeInt(CarbonUnsafe.getUnsafe().getInt(baseObject, address + size));
1:2b41f14:       size += 4;
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // no-dict & sort
1:2b41f14:     for (int idx = 0; idx < noDictSortDimCnt; idx++) {
1:2b41f14:       short length = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
1:2b41f14:       size += 2;
1:2b41f14:       byte[] bytes = new byte[length];
1:2b41f14:       CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:2b41f14:           bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, length);
1:2b41f14:       size += length;
1:2b41f14: 
1:2b41f14:       outputStream.writeShort(length);
1:2b41f14:       outputStream.write(bytes);
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // packed no-sort & measure
1:2b41f14:     int len = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:2b41f14:     size += 4;
1:2b41f14:     byte[] noSortDimsAndMeasures = new byte[len];
1:2b41f14:     CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:2b41f14:         noSortDimsAndMeasures, CarbonUnsafe.BYTE_ARRAY_OFFSET, len);
1:2b41f14:     size += len;
1:2b41f14: 
1:2b41f14:     outputStream.writeInt(len);
1:2b41f14:     outputStream.write(noSortDimsAndMeasures);
1:2b41f14:   }
1:2b41f14: 
1:2b41f14:   /**
1:2b41f14:    * Write raw row as an intermediate sort temp row to memory.
1:2b41f14:    * This method is used in the beginning of the off-heap sort phase. Comparing with converting
1:2b41f14:    * raw row to intermediate sort temp row and then writing the converted one,
1:2b41f14:    * Writing raw row directly will save the intermediate trivial loss.
1:2b41f14:    * This method use an array backend buffer to save memory allocation. The buffer will be reused
1:2b41f14:    * for all rows (per thread).
1:2b41f14:    *
1:2b41f14:    * @param row raw row
1:2b41f14:    * @param baseObject base object of the memory block
1:2b41f14:    * @param address base address for the row
1:2b41f14:    * @param rowBuffer array backend buffer
1:2b41f14:    * @return number of bytes written to memory
1:2b41f14:    */
1:2b41f14:   public int writeRawRowAsIntermediateSortTempRowToUnsafeMemory(Object[] row,
1:2b41f14:       Object baseObject, long address, ByteBuffer rowBuffer) {
1:2b41f14:     int size = 0;
1:2b41f14:     // write dict & sort
1:2b41f14:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:2b41f14:       CarbonUnsafe.getUnsafe()
1:2b41f14:           .putInt(baseObject, address + size, (int) row[this.dictSortDimIdx[idx]]);
1:2b41f14:       size += 4;
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // write no-dict & sort
1:2b41f14:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:2b41f14:       byte[] bytes = (byte[]) row[this.noDictSortDimIdx[idx]];
1:2b41f14:       CarbonUnsafe.getUnsafe().putShort(baseObject, address + size, (short) bytes.length);
1:2b41f14:       size += 2;
1:2b41f14:       CarbonUnsafe.getUnsafe()
1:2b41f14:           .copyMemory(bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject, address + size,
1:2b41f14:               bytes.length);
1:2b41f14:       size += bytes.length;
1:2b41f14:     }
1:2b41f14: 
1:2b41f14:     // convert pack no-sort
1:2b41f14:     rowBuffer.clear();
1:2b41f14:     packNoSortFieldsToBytes(row, rowBuffer);
1:2b41f14:     rowBuffer.flip();
1:2b41f14:     int packSize = rowBuffer.limit();
1:2b41f14: 
1:2b41f14:     // write no-sort
1:2b41f14:     CarbonUnsafe.getUnsafe().putInt(baseObject, address + size, packSize);
1:2b41f14:     size += 4;
1:2b41f14:     CarbonUnsafe.getUnsafe()
1:2b41f14:         .copyMemory(rowBuffer.array(), CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject, address + size,
1:2b41f14:             packSize);
1:2b41f14:     size += packSize;
1:2b41f14:     return size;
1:2b41f14:   }
1:f27efb3: 
1:f27efb3: 
1:2b41f14: 
1:2b41f14:   /**
1:2b41f14:    * Pack to no-sort fields to byte array
1:2b41f14:    *
1:2b41f14:    * @param row raw row
1:2b41f14:    * @param rowBuffer byte array backend buffer
1:2b41f14:    */
1:2b41f14:   private void packNoSortFieldsToBytes(Object[] row, ByteBuffer rowBuffer) {
1:2b41f14:     // convert dict & no-sort
1:2b41f14:     for (int idx = 0; idx < this.dictNoSortDimCnt; idx++) {
1:2b41f14:       rowBuffer.putInt((int) row[this.dictNoSortDimIdx[idx]]);
1:2b41f14:     }
1:2b41f14:     // convert no-dict & no-sort
1:2b41f14:     for (int idx = 0; idx < this.noDictNoSortDimCnt; idx++) {
1:2b41f14:       byte[] bytes = (byte[]) row[this.noDictNoSortDimIdx[idx]];
1:2b41f14:       rowBuffer.putShort((short) bytes.length);
1:2b41f14:       rowBuffer.put(bytes);
1:2b41f14:     }
1:dc53dee:     // convert varchar dims
1:dc53dee:     for (int idx = 0; idx < this.varcharDimCnt; idx++) {
1:dc53dee:       byte[] bytes = (byte[]) row[this.varcharDimIdx[idx]];
1:dc53dee:       rowBuffer.putInt(bytes.length);
1:dc53dee:       rowBuffer.put(bytes);
1:dc53dee:     }
1:11fb422:     // convert complex dims
1:11fb422:     for (int idx = 0; idx < this.complexDimCnt; idx++) {
1:11fb422:       byte[] bytes = (byte[]) row[this.complexDimIdx[idx]];
1:11fb422:       rowBuffer.putShort((short) bytes.length);
1:11fb422:       rowBuffer.put(bytes);
1:11fb422:     }
1:2b41f14: 
1:2b41f14:     // convert measure
1:2b41f14:     Object tmpValue;
1:2b41f14:     DataType tmpDataType;
1:2b41f14:     for (int idx = 0; idx < this.measureCnt; idx++) {
1:2b41f14:       tmpValue = row[this.measureIdx[idx]];
1:2b41f14:       tmpDataType = this.dataTypes[idx];
1:2b41f14:       if (null == tmpValue) {
1:2b41f14:         rowBuffer.put((byte) 0);
1:2b41f14:         continue;
1:2b41f14:       }
1:2b41f14:       rowBuffer.put((byte) 1);
1:2b41f14:       if (DataTypes.BOOLEAN == tmpDataType) {
1:2b41f14:         if ((boolean) tmpValue) {
1:2b41f14:           rowBuffer.put((byte) 1);
1:2b41f14:         } else {
1:2b41f14:           rowBuffer.put((byte) 0);
1:2b41f14:         }
1:2b41f14:       } else if (DataTypes.SHORT == tmpDataType) {
1:2b41f14:         rowBuffer.putShort((Short) tmpValue);
1:2b41f14:       } else if (DataTypes.INT == tmpDataType) {
1:2b41f14:         rowBuffer.putInt((Integer) tmpValue);
1:2b41f14:       } else if (DataTypes.LONG == tmpDataType) {
1:2b41f14:         rowBuffer.putLong((Long) tmpValue);
1:2b41f14:       } else if (DataTypes.DOUBLE == tmpDataType) {
1:2b41f14:         rowBuffer.putDouble((Double) tmpValue);
1:2b41f14:       } else if (DataTypes.isDecimal(tmpDataType)) {
1:2b41f14:         byte[] decimalBytes = DataTypeUtil.bigDecimalToByte((BigDecimal) tmpValue);
1:2b41f14:         rowBuffer.putShort((short) decimalBytes.length);
1:2b41f14:         rowBuffer.put(decimalBytes);
1:2b41f14:       } else {
1:2b41f14:         throw new IllegalArgumentException("Unsupported data type: " + tmpDataType);
1:2b41f14:       }
1:2b41f14:     }
1:2b41f14:   }
1:2b41f14: }
============================================================================
author:kumarvishal09
-------------------------------------------------------------------------------
commit:f27efb3
/////////////////////////////////////////////////////////////////////////
1:     Object[] out = new Object[3];
1:     NonDictionaryUtil
1:         .prepareOutObj(out, sortTempRow.getDictSortDims(), sortTempRow.getNoDictSortDims(),
1:             sortTempRow.getMeasures());
1:     return out;
1:    * This method is used during the intermediate merge sort phase to read row from sort temp file.
1:   public IntermediateSortTempRow readWithoutNoSortFieldConvert(
/////////////////////////////////////////////////////////////////////////
1:     // keeping no sort fields and measure in pack byte array as it will not participate in sort
1:    * Read intermediate sort temp row from InputStream.
1:    * This method is used during the final merge sort phase to read row from sort temp file and
1:    * merged sort temp file.
1:    *
1:    * @param inputStream input stream
1:    * @return a row that contains three parts
1:    * @throws IOException if error occrus while reading from stream
1:    */
1:   public IntermediateSortTempRow readWithNoSortFieldConvert(
1:       DataInputStream inputStream) throws IOException {
1:     int[] dictSortDims = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
1:     byte[][] noDictSortDims =
1:         new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt + this.varcharDimCnt
1:             + this.complexDimCnt][];
1: 
1:     // read dict & sort dim data
1:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:       dictSortDims[idx] = inputStream.readInt();
1:     }
1: 
1:     // read no-dict & sort data
1:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:       short len = inputStream.readShort();
1:       byte[] bytes = new byte[len];
1:       inputStream.readFully(bytes);
1:       noDictSortDims[idx] = bytes;
1:     }
1: 
1:     // read no-dict dims & measures
1:     int len = inputStream.readInt();
1:     byte[] noSortDimsAndMeasures = new byte[len];
1:     inputStream.readFully(noSortDimsAndMeasures);
1:     Object[] measure = new Object[this.measureCnt];
1:     // unpack the no sort fields and measure fields
1:     unpackNoSortFromBytes(noSortDimsAndMeasures, dictSortDims, noDictSortDims, measure);
1:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims,measure);
1:   }
1: 
1:   private void unpackNoSortFromBytes(byte[] noSortDimsAndMeasures, int[] dictDims,
1:       byte[][] noDictDims, Object[] measures) {
1:     ByteBuffer rowBuffer = ByteBuffer.wrap(noSortDimsAndMeasures);
1:     // read dict_no_sort
1:     for (int i = dictSortDimCnt; i < dictDims.length; i++) {
1:       dictDims[i] = rowBuffer.getInt();
1:     }
1: 
1:     int noDictIndex = noDictSortDimCnt;
1:     // read no_dict_no_sort
1:     for (int i = 0; i < noDictNoSortDimCnt; i++) {
1:       short len = rowBuffer.getShort();
1:       byte[] bytes = new byte[len];
1:       rowBuffer.get(bytes);
1:       noDictDims[noDictIndex++] = bytes;
1:     }
1: 
1:     // read varchar dims
1:     for (int i = 0; i < varcharDimCnt; i++) {
1:       int len = rowBuffer.getInt();
1:       byte[] bytes = new byte[len];
1:       rowBuffer.get(bytes);
1:       noDictDims[noDictIndex++] = bytes;
1:     }
1: 
1:     // read complex dims
1:     for (int i = 0; i < complexDimCnt; i++) {
1:       short len = rowBuffer.getShort();
1:       byte[] bytes = new byte[len];
1:       rowBuffer.get(bytes);
1:       noDictDims[noDictIndex++] = bytes;
1:     }
1: 
1:     // read measure
1:     int measureCnt = measures.length;
1:     DataType tmpDataType;
1:     Object tmpContent;
1:     for (short idx = 0 ; idx < measureCnt; idx++) {
1:       if ((byte) 0 == rowBuffer.get()) {
1:         measures[idx] = null;
1:         continue;
1:       }
1: 
1:       tmpDataType = dataTypes[idx];
1:       if (DataTypes.BOOLEAN == tmpDataType) {
1:         if ((byte) 1 == rowBuffer.get()) {
1:           tmpContent = true;
1:         } else {
1:           tmpContent = false;
1:         }
1:       } else if (DataTypes.SHORT == tmpDataType) {
1:         tmpContent = rowBuffer.getShort();
1:       } else if (DataTypes.INT == tmpDataType) {
1:         tmpContent = rowBuffer.getInt();
1:       } else if (DataTypes.LONG == tmpDataType) {
1:         tmpContent = rowBuffer.getLong();
1:       } else if (DataTypes.DOUBLE == tmpDataType) {
1:         tmpContent = rowBuffer.getDouble();
1:       } else if (DataTypes.isDecimal(tmpDataType)) {
1:         short len = rowBuffer.getShort();
1:         byte[] decimalBytes = new byte[len];
1:         rowBuffer.get(decimalBytes);
1:         tmpContent = DataTypeUtil.byteToBigDecimal(decimalBytes);
1:       } else {
1:         throw new IllegalArgumentException("Unsupported data type: " + tmpDataType);
1:       }
1:       measures[idx] = tmpContent;
1:     }
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:   public IntermediateSortTempRow readFromMemoryWithoutNoSortFieldConvert(Object baseObject,
/////////////////////////////////////////////////////////////////////////
1:    * Read intermediate sort temp row from unsafe memory.
1:    * This method is used during merge sort phase for off-heap sort.
1:    *
1:    * @param baseObject base object of memory block
1:    * @param address address of the row
1:    * @return intermediate sort temp row
1:    */
1:   public IntermediateSortTempRow readRowFromMemoryWithNoSortFieldConvert(Object baseObject,
1:       long address) {
1:     int size = 0;
1: 
1:     int[] dictSortDims = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
1:     byte[][] noDictSortDims =
1:         new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt + this.varcharDimCnt
1:             + this.complexDimCnt][];
1: 
1:     // read dict & sort dim
1:     for (int idx = 0; idx < dictSortDimCnt; idx++) {
1:       dictSortDims[idx] = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:       size += 4;
1:     }
1: 
1:     // read no-dict & sort dim
1:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:       short length = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
1:       size += 2;
1:       byte[] bytes = new byte[length];
1:       CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:           bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, length);
1:       size += length;
1:       noDictSortDims[idx] = bytes;
1:     }
1: 
1:     // read no-sort dims & measures
1:     int len = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:     size += 4;
1:     byte[] noSortDimsAndMeasures = new byte[len];
1:     CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:         noSortDimsAndMeasures, CarbonUnsafe.BYTE_ARRAY_OFFSET, len);
1:     Object[] measures = new Object[measureCnt];
1:     unpackNoSortFromBytes(noSortDimsAndMeasures, dictSortDims, noDictSortDims, measures);
1:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims, measures);
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1: 
1: 
author:Manhua
-------------------------------------------------------------------------------
commit:11fb422
/////////////////////////////////////////////////////////////////////////
1:   private int complexDimCnt = 0;
/////////////////////////////////////////////////////////////////////////
1:   // indices for no-dict & no-sort dimension columns, excluding complex/varchar columns
1:   private int[] complexDimIdx;
/////////////////////////////////////////////////////////////////////////
1:     this.complexDimCnt = tableFieldStat.getComplexDimCnt();
1:     this.complexDimIdx = tableFieldStat.getComplexDimIdx();
/////////////////////////////////////////////////////////////////////////
1:       byte[][] nonDictArray = new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt
1:                                        + this.varcharDimCnt + this.complexDimCnt ][];
/////////////////////////////////////////////////////////////////////////
1:       // convert complex dims
1:       for (int idx = 0; idx < this.complexDimCnt; idx++) {
1:         nonDictArray[idxAcc++] = (byte[]) row[this.complexDimIdx[idx]];
1:       }
/////////////////////////////////////////////////////////////////////////
0:     int[] dictDims = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
0:     byte[][] noDictArray = new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt
0:                                     + this.varcharDimCnt + this.complexDimCnt][];
0:     byte[][] noDictNoSortAndVarcharComplexDims
0:         = new byte[this.noDictNoSortDimCnt + this.varcharDimCnt + this.complexDimCnt][];
0:     sortTempRow.unpackNoSortFromBytes(dictNoSortDims, noDictNoSortAndVarcharComplexDims, measures,
0:         this.dataTypes, this.varcharDimCnt, this.complexDimCnt);
/////////////////////////////////////////////////////////////////////////
0:     System.arraycopy(noDictNoSortAndVarcharComplexDims, 0, noDictArray,
0:         this.noDictSortDimCnt, this.noDictNoSortDimCnt + this.varcharDimCnt + this.complexDimCnt);
/////////////////////////////////////////////////////////////////////////
1:     // convert complex dims
1:     for (int idx = 0; idx < this.complexDimCnt; idx++) {
1:       byte[] bytes = (byte[]) row[this.complexDimIdx[idx]];
1:       rowBuffer.putShort((short) bytes.length);
1:       rowBuffer.put(bytes);
1:     }
commit:c2c5b18
/////////////////////////////////////////////////////////////////////////
0:       byte[][] nonDictArray
0:           = new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt + this.varcharDimCnt][];
author:xuchuanyin
-------------------------------------------------------------------------------
commit:dc53dee
/////////////////////////////////////////////////////////////////////////
1:   private int varcharDimCnt = 0;
/////////////////////////////////////////////////////////////////////////
1:   private int[] varcharDimIdx;
/////////////////////////////////////////////////////////////////////////
1:     this.varcharDimCnt = tableFieldStat.getVarcharDimCnt();
1:     this.varcharDimIdx = tableFieldStat.getVarcharDimIdx();
/////////////////////////////////////////////////////////////////////////
1:       // convert varchar dims
1:       for (int idx = 0; idx < this.varcharDimCnt; idx++) {
1:         nonDictArray[idxAcc++] = (byte[]) row[this.varcharDimIdx[idx]];
1:       }
/////////////////////////////////////////////////////////////////////////
0:         = new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt + this.varcharDimCnt][];
0:     byte[][] noDictNoSortAndVarcharDims
0:         = new byte[this.noDictNoSortDimCnt + this.varcharDimCnt][];
0:     sortTempRow.unpackNoSortFromBytes(dictNoSortDims, noDictNoSortAndVarcharDims, measures,
0:         this.dataTypes, this.varcharDimCnt);
/////////////////////////////////////////////////////////////////////////
0:     System.arraycopy(noDictNoSortAndVarcharDims, 0, noDictArray,
0:         this.noDictSortDimCnt, this.noDictNoSortDimCnt + this.varcharDimCnt);
/////////////////////////////////////////////////////////////////////////
1:     // convert varchar dims
1:     for (int idx = 0; idx < this.varcharDimCnt; idx++) {
1:       byte[] bytes = (byte[]) row[this.varcharDimIdx[idx]];
1:       rowBuffer.putInt(bytes.length);
1:       rowBuffer.put(bytes);
1:     }
commit:2b41f14
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.processing.loading.sort;
1: 
1: import java.io.DataInputStream;
1: import java.io.DataOutputStream;
1: import java.io.IOException;
1: import java.io.Serializable;
1: import java.math.BigDecimal;
1: import java.nio.ByteBuffer;
1: 
1: import org.apache.carbondata.core.memory.CarbonUnsafe;
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1: import org.apache.carbondata.core.util.DataTypeUtil;
1: import org.apache.carbondata.core.util.NonDictionaryUtil;
1: import org.apache.carbondata.processing.loading.row.IntermediateSortTempRow;
1: import org.apache.carbondata.processing.sort.sortdata.SortParameters;
1: import org.apache.carbondata.processing.sort.sortdata.TableFieldStat;
1: 
1: /**
1:  * This class is used to convert/write/read row in sort step in carbondata.
1:  * It consists the following function:
1:  * 1. convert raw row & intermediate sort temp row to 3-parted row
1:  * 2. read/write intermediate sort temp row to sort temp file & unsafe memory
1:  * 3. write raw row directly to sort temp file & unsafe memory as intermediate sort temp row
1:  */
1: public class SortStepRowHandler implements Serializable {
1:   private static final long serialVersionUID = 1L;
1:   private int dictSortDimCnt = 0;
1:   private int dictNoSortDimCnt = 0;
1:   private int noDictSortDimCnt = 0;
1:   private int noDictNoSortDimCnt = 0;
1:   private int measureCnt;
1: 
1:   // indices for dict & sort dimension columns
1:   private int[] dictSortDimIdx;
1:   // indices for dict & no-sort dimension columns
1:   private int[] dictNoSortDimIdx;
1:   // indices for no-dict & sort dimension columns
1:   private int[] noDictSortDimIdx;
0:   // indices for no-dict & no-sort dimension columns, including complex columns
1:   private int[] noDictNoSortDimIdx;
1:   // indices for measure columns
1:   private int[] measureIdx;
1: 
1:   private DataType[] dataTypes;
1: 
1:   /**
1:    * constructor
1:    * @param tableFieldStat table field stat
1:    */
1:   public SortStepRowHandler(TableFieldStat tableFieldStat) {
1:     this.dictSortDimCnt = tableFieldStat.getDictSortDimCnt();
1:     this.dictNoSortDimCnt = tableFieldStat.getDictNoSortDimCnt();
1:     this.noDictSortDimCnt = tableFieldStat.getNoDictSortDimCnt();
1:     this.noDictNoSortDimCnt = tableFieldStat.getNoDictNoSortDimCnt();
1:     this.measureCnt = tableFieldStat.getMeasureCnt();
1:     this.dictSortDimIdx = tableFieldStat.getDictSortDimIdx();
1:     this.dictNoSortDimIdx = tableFieldStat.getDictNoSortDimIdx();
1:     this.noDictSortDimIdx = tableFieldStat.getNoDictSortDimIdx();
1:     this.noDictNoSortDimIdx = tableFieldStat.getNoDictNoSortDimIdx();
1:     this.measureIdx = tableFieldStat.getMeasureIdx();
1:     this.dataTypes = tableFieldStat.getMeasureDataType();
1:   }
1: 
1:   /**
1:    * constructor
1:    * @param sortParameters sort parameters
1:    */
1:   public SortStepRowHandler(SortParameters sortParameters) {
1:     this(new TableFieldStat(sortParameters));
1:   }
1: 
1:   /**
1:    * Convert carbon row from raw format to 3-parted format.
1:    * This method is used in global-sort.
1:    *
1:    * @param row raw row whose length is the same as field number
1:    * @return 3-parted row whose length is 3. (1 for dict dims ,1 for non-dict and complex,
1:    * 1 for measures)
1:    */
1:   public Object[] convertRawRowTo3Parts(Object[] row) {
1:     Object[] holder = new Object[3];
1:     try {
1:       int[] dictDims
1:           = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
0:       byte[][] nonDictArray = new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt][];
1:       Object[] measures = new Object[this.measureCnt];
1: 
1:       // convert dict & data
1:       int idxAcc = 0;
1:       for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:         dictDims[idxAcc++] = (int) row[this.dictSortDimIdx[idx]];
1:       }
1: 
1:       // convert dict & no-sort
1:       for (int idx = 0; idx < this.dictNoSortDimCnt; idx++) {
1:         dictDims[idxAcc++] = (int) row[this.dictNoSortDimIdx[idx]];
1:       }
1:       // convert no-dict & sort
1:       idxAcc = 0;
1:       for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:         nonDictArray[idxAcc++] = (byte[]) row[this.noDictSortDimIdx[idx]];
1:       }
1:       // convert no-dict & no-sort
1:       for (int idx = 0; idx < this.noDictNoSortDimCnt; idx++) {
1:         nonDictArray[idxAcc++] = (byte[]) row[this.noDictNoSortDimIdx[idx]];
1:       }
1: 
1:       // convert measure data
1:       for (int idx = 0; idx < this.measureCnt; idx++) {
1:         measures[idx] = row[this.measureIdx[idx]];
1:       }
1: 
1:       NonDictionaryUtil.prepareOutObj(holder, dictDims, nonDictArray, measures);
1:     } catch (Exception e) {
1:       throw new RuntimeException("Problem while converting row to 3 parts", e);
1:     }
1:     return holder;
1:   }
1: 
1:   /**
1:    * Convert intermediate sort temp row to 3-parted row.
1:    * This method is used in the final merge sort to feed rows to the next write step.
1:    *
1:    * @param sortTempRow intermediate sort temp row
1:    * @return 3-parted row
1:    */
1:   public Object[] convertIntermediateSortTempRowTo3Parted(IntermediateSortTempRow sortTempRow) {
1:     int[] dictDims
1:         = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
0:     byte[][] noDictArray
0:         = new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt][];
1: 
0:     int[] dictNoSortDims = new int[this.dictNoSortDimCnt];
0:     byte[][] noDictNoSortDims = new byte[this.noDictNoSortDimCnt][];
1:     Object[] measures = new Object[this.measureCnt];
1: 
0:     sortTempRow.unpackNoSortFromBytes(dictNoSortDims, noDictNoSortDims, measures, this.dataTypes);
1: 
0:     // dict dims
0:     System.arraycopy(sortTempRow.getDictSortDims(), 0 , dictDims,
0:         0, this.dictSortDimCnt);
0:     System.arraycopy(dictNoSortDims, 0, dictDims,
0:         this.dictSortDimCnt, this.dictNoSortDimCnt);;
1: 
0:     // no dict dims, including complex
0:     System.arraycopy(sortTempRow.getNoDictSortDims(), 0,
0:         noDictArray, 0, this.noDictSortDimCnt);
0:     System.arraycopy(noDictNoSortDims, 0, noDictArray,
0:         this.noDictSortDimCnt, this.noDictNoSortDimCnt);
1: 
0:     // measures are already here
1: 
1:     Object[] holder = new Object[3];
0:     NonDictionaryUtil.prepareOutObj(holder, dictDims, noDictArray, measures);
1:     return holder;
1:   }
1: 
1:   /**
1:    * Read intermediate sort temp row from InputStream.
0:    * This method is used during the merge sort phase to read row from sort temp file.
1:    *
1:    * @param inputStream input stream
1:    * @return a row that contains three parts
1:    * @throws IOException if error occrus while reading from stream
1:    */
0:   public IntermediateSortTempRow readIntermediateSortTempRowFromInputStream(
1:       DataInputStream inputStream) throws IOException {
1:     int[] dictSortDims = new int[this.dictSortDimCnt];
1:     byte[][] noDictSortDims = new byte[this.noDictSortDimCnt][];
1: 
1:     // read dict & sort dim data
1:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:       dictSortDims[idx] = inputStream.readInt();
1:     }
1: 
1:     // read no-dict & sort data
1:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:       short len = inputStream.readShort();
1:       byte[] bytes = new byte[len];
1:       inputStream.readFully(bytes);
1:       noDictSortDims[idx] = bytes;
1:     }
1: 
1:     // read no-dict dims & measures
1:     int len = inputStream.readInt();
1:     byte[] noSortDimsAndMeasures = new byte[len];
1:     inputStream.readFully(noSortDimsAndMeasures);
1: 
1:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims, noSortDimsAndMeasures);
1:   }
1: 
1:   /**
1:    * Write intermediate sort temp row to OutputStream
1:    * This method is used during the merge sort phase to write row to sort temp file.
1:    *
1:    * @param sortTempRow intermediate sort temp row
1:    * @param outputStream output stream
1:    * @throws IOException if error occurs while writing to stream
1:    */
1:   public void writeIntermediateSortTempRowToOutputStream(IntermediateSortTempRow sortTempRow,
1:       DataOutputStream outputStream) throws IOException {
1:     // write dict & sort dim
1:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:       outputStream.writeInt(sortTempRow.getDictSortDims()[idx]);
1:     }
1: 
1:     // write no-dict & sort dim
1:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:       byte[] bytes = sortTempRow.getNoDictSortDims()[idx];
1:       outputStream.writeShort(bytes.length);
1:       outputStream.write(bytes);
1:     }
1: 
1:     // write packed no-sort dim & measure
1:     outputStream.writeInt(sortTempRow.getNoSortDimsAndMeasures().length);
1:     outputStream.write(sortTempRow.getNoSortDimsAndMeasures());
1:   }
1: 
1:   /**
1:    * Write raw row as an intermediate sort temp row to sort temp file.
1:    * This method is used in the beginning of the sort phase. Comparing with converting raw row to
1:    * intermediate sort temp row and then writing the converted one, Writing raw row directly will
1:    * save the intermediate trivial loss.
1:    * This method use an array backend buffer to save memory allocation. The buffer will be reused
1:    * for all rows (per thread).
1:    *
1:    * @param row raw row
1:    * @param outputStream output stream
1:    * @param rowBuffer array backend buffer
1:    * @throws IOException if error occurs while writing to stream
1:    */
1:   public void writeRawRowAsIntermediateSortTempRowToOutputStream(Object[] row,
1:       DataOutputStream outputStream, ByteBuffer rowBuffer) throws IOException {
1:     // write dict & sort
1:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:       outputStream.writeInt((int) row[this.dictSortDimIdx[idx]]);
1:     }
1: 
1:     // write no-dict & sort
1:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:       byte[] bytes = (byte[]) row[this.noDictSortDimIdx[idx]];
1:       outputStream.writeShort(bytes.length);
1:       outputStream.write(bytes);
1:     }
1: 
1:     // pack no-sort
1:     rowBuffer.clear();
1:     packNoSortFieldsToBytes(row, rowBuffer);
1:     rowBuffer.flip();
1:     int packSize = rowBuffer.limit();
1: 
1:     // write no-sort
1:     outputStream.writeInt(packSize);
1:     outputStream.write(rowBuffer.array(), 0, packSize);
1:   }
1: 
1:   /**
1:    * Read intermediate sort temp row from unsafe memory.
1:    * This method is used during merge sort phase for off-heap sort.
1:    *
1:    * @param baseObject base object of memory block
1:    * @param address address of the row
1:    * @return intermediate sort temp row
1:    */
0:   public IntermediateSortTempRow readIntermediateSortTempRowFromUnsafeMemory(Object baseObject,
1:       long address) {
1:     int size = 0;
1: 
1:     int[] dictSortDims = new int[this.dictSortDimCnt];
1:     byte[][] noDictSortDims = new byte[this.noDictSortDimCnt][];
1: 
1:     // read dict & sort dim
1:     for (int idx = 0; idx < dictSortDims.length; idx++) {
1:       dictSortDims[idx] = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:       size += 4;
1:     }
1: 
1:     // read no-dict & sort dim
1:     for (int idx = 0; idx < noDictSortDims.length; idx++) {
1:       short length = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
1:       size += 2;
1:       byte[] bytes = new byte[length];
1:       CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:           bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, length);
1:       size += length;
1:       noDictSortDims[idx] = bytes;
1:     }
1: 
1:     // read no-sort dims & measures
1:     int len = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:     size += 4;
1:     byte[] noSortDimsAndMeasures = new byte[len];
1:     CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:         noSortDimsAndMeasures, CarbonUnsafe.BYTE_ARRAY_OFFSET, len);
1: 
1:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims, noSortDimsAndMeasures);
1:   }
1: 
1:   /**
1:    * Write intermediate sort temp row directly from unsafe memory to stream.
1:    * This method is used at the late beginning of the sort phase to write in-memory pages
1:    * to sort temp file. Comparing with reading intermediate sort temp row from memory and then
1:    * writing it, Writing directly from memory to stream will save the intermediate trivial loss.
1:    *
1:    * @param baseObject base object of the memory block
1:    * @param address base address of the row
1:    * @param outputStream output stream
1:    * @throws IOException if error occurs while writing to stream
1:    */
1:   public void writeIntermediateSortTempRowFromUnsafeMemoryToStream(Object baseObject,
1:       long address, DataOutputStream outputStream) throws IOException {
1:     int size = 0;
1: 
1:     // dict & sort
1:     for (int idx = 0; idx < dictSortDimCnt; idx++) {
1:       outputStream.writeInt(CarbonUnsafe.getUnsafe().getInt(baseObject, address + size));
1:       size += 4;
1:     }
1: 
1:     // no-dict & sort
1:     for (int idx = 0; idx < noDictSortDimCnt; idx++) {
1:       short length = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
1:       size += 2;
1:       byte[] bytes = new byte[length];
1:       CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:           bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, length);
1:       size += length;
1: 
1:       outputStream.writeShort(length);
1:       outputStream.write(bytes);
1:     }
1: 
1:     // packed no-sort & measure
1:     int len = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
1:     size += 4;
1:     byte[] noSortDimsAndMeasures = new byte[len];
1:     CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
1:         noSortDimsAndMeasures, CarbonUnsafe.BYTE_ARRAY_OFFSET, len);
1:     size += len;
1: 
1:     outputStream.writeInt(len);
1:     outputStream.write(noSortDimsAndMeasures);
1:   }
1: 
1:   /**
1:    * Write raw row as an intermediate sort temp row to memory.
1:    * This method is used in the beginning of the off-heap sort phase. Comparing with converting
1:    * raw row to intermediate sort temp row and then writing the converted one,
1:    * Writing raw row directly will save the intermediate trivial loss.
1:    * This method use an array backend buffer to save memory allocation. The buffer will be reused
1:    * for all rows (per thread).
1:    *
1:    * @param row raw row
1:    * @param baseObject base object of the memory block
1:    * @param address base address for the row
1:    * @param rowBuffer array backend buffer
1:    * @return number of bytes written to memory
1:    */
1:   public int writeRawRowAsIntermediateSortTempRowToUnsafeMemory(Object[] row,
1:       Object baseObject, long address, ByteBuffer rowBuffer) {
1:     int size = 0;
1:     // write dict & sort
1:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
1:       CarbonUnsafe.getUnsafe()
1:           .putInt(baseObject, address + size, (int) row[this.dictSortDimIdx[idx]]);
1:       size += 4;
1:     }
1: 
1:     // write no-dict & sort
1:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
1:       byte[] bytes = (byte[]) row[this.noDictSortDimIdx[idx]];
1:       CarbonUnsafe.getUnsafe().putShort(baseObject, address + size, (short) bytes.length);
1:       size += 2;
1:       CarbonUnsafe.getUnsafe()
1:           .copyMemory(bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject, address + size,
1:               bytes.length);
1:       size += bytes.length;
1:     }
1: 
1:     // convert pack no-sort
1:     rowBuffer.clear();
1:     packNoSortFieldsToBytes(row, rowBuffer);
1:     rowBuffer.flip();
1:     int packSize = rowBuffer.limit();
1: 
1:     // write no-sort
1:     CarbonUnsafe.getUnsafe().putInt(baseObject, address + size, packSize);
1:     size += 4;
1:     CarbonUnsafe.getUnsafe()
1:         .copyMemory(rowBuffer.array(), CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject, address + size,
1:             packSize);
1:     size += packSize;
1:     return size;
1:   }
1: 
1:   /**
1:    * Pack to no-sort fields to byte array
1:    *
1:    * @param row raw row
1:    * @param rowBuffer byte array backend buffer
1:    */
1:   private void packNoSortFieldsToBytes(Object[] row, ByteBuffer rowBuffer) {
1:     // convert dict & no-sort
1:     for (int idx = 0; idx < this.dictNoSortDimCnt; idx++) {
1:       rowBuffer.putInt((int) row[this.dictNoSortDimIdx[idx]]);
1:     }
1:     // convert no-dict & no-sort
1:     for (int idx = 0; idx < this.noDictNoSortDimCnt; idx++) {
1:       byte[] bytes = (byte[]) row[this.noDictNoSortDimIdx[idx]];
1:       rowBuffer.putShort((short) bytes.length);
1:       rowBuffer.put(bytes);
1:     }
1: 
1:     // convert measure
1:     Object tmpValue;
1:     DataType tmpDataType;
1:     for (int idx = 0; idx < this.measureCnt; idx++) {
1:       tmpValue = row[this.measureIdx[idx]];
1:       tmpDataType = this.dataTypes[idx];
1:       if (null == tmpValue) {
1:         rowBuffer.put((byte) 0);
1:         continue;
1:       }
1:       rowBuffer.put((byte) 1);
1:       if (DataTypes.BOOLEAN == tmpDataType) {
1:         if ((boolean) tmpValue) {
1:           rowBuffer.put((byte) 1);
1:         } else {
1:           rowBuffer.put((byte) 0);
1:         }
1:       } else if (DataTypes.SHORT == tmpDataType) {
1:         rowBuffer.putShort((Short) tmpValue);
1:       } else if (DataTypes.INT == tmpDataType) {
1:         rowBuffer.putInt((Integer) tmpValue);
1:       } else if (DataTypes.LONG == tmpDataType) {
1:         rowBuffer.putLong((Long) tmpValue);
1:       } else if (DataTypes.DOUBLE == tmpDataType) {
1:         rowBuffer.putDouble((Double) tmpValue);
1:       } else if (DataTypes.isDecimal(tmpDataType)) {
1:         byte[] decimalBytes = DataTypeUtil.bigDecimalToByte((BigDecimal) tmpValue);
1:         rowBuffer.putShort((short) decimalBytes.length);
1:         rowBuffer.put(decimalBytes);
1:       } else {
1:         throw new IllegalArgumentException("Unsupported data type: " + tmpDataType);
1:       }
1:     }
1:   }
1: }
commit:8d8b589
/////////////////////////////////////////////////////////////////////////
commit:21704cf
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  *    http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.carbondata.processing.loading.sort;
0: 
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.io.Serializable;
0: import java.math.BigDecimal;
0: import java.nio.ByteBuffer;
0: 
0: import org.apache.carbondata.core.memory.CarbonUnsafe;
0: import org.apache.carbondata.core.metadata.datatype.DataType;
0: import org.apache.carbondata.core.metadata.datatype.DataTypes;
0: import org.apache.carbondata.core.util.DataTypeUtil;
0: import org.apache.carbondata.core.util.NonDictionaryUtil;
0: import org.apache.carbondata.processing.loading.row.IntermediateSortTempRow;
0: import org.apache.carbondata.processing.sort.sortdata.SortParameters;
0: import org.apache.carbondata.processing.sort.sortdata.TableFieldStat;
0: 
0: /**
0:  * This class is used to convert/write/read row in sort step in carbondata.
0:  * It consists the following function:
0:  * 1. convert raw row & intermediate sort temp row to 3-parted row
0:  * 2. read/write intermediate sort temp row to sort temp file & unsafe memory
0:  * 3. write raw row directly to sort temp file & unsafe memory as intermediate sort temp row
0:  */
0: public class SortStepRowHandler implements Serializable {
0:   private static final long serialVersionUID = 1L;
0:   private int dictSortDimCnt = 0;
0:   private int dictNoSortDimCnt = 0;
0:   private int noDictSortDimCnt = 0;
0:   private int noDictNoSortDimCnt = 0;
0:   private int measureCnt;
0: 
0:   // indices for dict & sort dimension columns
0:   private int[] dictSortDimIdx;
0:   // indices for dict & no-sort dimension columns
0:   private int[] dictNoSortDimIdx;
0:   // indices for no-dict & sort dimension columns
0:   private int[] noDictSortDimIdx;
0:   // indices for no-dict & no-sort dimension columns, including complex columns
0:   private int[] noDictNoSortDimIdx;
0:   // indices for measure columns
0:   private int[] measureIdx;
0: 
0:   private DataType[] dataTypes;
0: 
0:   /**
0:    * constructor
0:    * @param tableFieldStat table field stat
0:    */
0:   public SortStepRowHandler(TableFieldStat tableFieldStat) {
0:     this.dictSortDimCnt = tableFieldStat.getDictSortDimCnt();
0:     this.dictNoSortDimCnt = tableFieldStat.getDictNoSortDimCnt();
0:     this.noDictSortDimCnt = tableFieldStat.getNoDictSortDimCnt();
0:     this.noDictNoSortDimCnt = tableFieldStat.getNoDictNoSortDimCnt();
0:     this.measureCnt = tableFieldStat.getMeasureCnt();
0:     this.dictSortDimIdx = tableFieldStat.getDictSortDimIdx();
0:     this.dictNoSortDimIdx = tableFieldStat.getDictNoSortDimIdx();
0:     this.noDictSortDimIdx = tableFieldStat.getNoDictSortDimIdx();
0:     this.noDictNoSortDimIdx = tableFieldStat.getNoDictNoSortDimIdx();
0:     this.measureIdx = tableFieldStat.getMeasureIdx();
0:     this.dataTypes = tableFieldStat.getMeasureDataType();
0:   }
0: 
0:   /**
0:    * constructor
0:    * @param sortParameters sort parameters
0:    */
0:   public SortStepRowHandler(SortParameters sortParameters) {
0:     this(new TableFieldStat(sortParameters));
0:   }
0: 
0:   /**
0:    * Convert carbon row from raw format to 3-parted format.
0:    * This method is used in global-sort.
0:    *
0:    * @param row raw row whose length is the same as field number
0:    * @return 3-parted row whose length is 3. (1 for dict dims ,1 for non-dict and complex,
0:    * 1 for measures)
0:    */
0:   public Object[] convertRawRowTo3Parts(Object[] row) {
0:     Object[] holder = new Object[3];
0:     try {
0:       int[] dictDims
0:           = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
0:       byte[][] nonDictArray = new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt][];
0:       Object[] measures = new Object[this.measureCnt];
0: 
0:       // convert dict & data
0:       int idxAcc = 0;
0:       for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
0:         dictDims[idxAcc++] = (int) row[this.dictSortDimIdx[idx]];
0:       }
0: 
0:       // convert dict & no-sort
0:       for (int idx = 0; idx < this.dictNoSortDimCnt; idx++) {
0:         dictDims[idxAcc++] = (int) row[this.dictNoSortDimIdx[idx]];
0:       }
0:       // convert no-dict & sort
0:       idxAcc = 0;
0:       for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
0:         nonDictArray[idxAcc++] = (byte[]) row[this.noDictSortDimIdx[idx]];
0:       }
0:       // convert no-dict & no-sort
0:       for (int idx = 0; idx < this.noDictNoSortDimCnt; idx++) {
0:         nonDictArray[idxAcc++] = (byte[]) row[this.noDictNoSortDimIdx[idx]];
0:       }
0: 
0:       // convert measure data
0:       for (int idx = 0; idx < this.measureCnt; idx++) {
0:         measures[idx] = row[this.measureIdx[idx]];
0:       }
0: 
0:       NonDictionaryUtil.prepareOutObj(holder, dictDims, nonDictArray, measures);
0:     } catch (Exception e) {
0:       throw new RuntimeException("Problem while converting row to 3 parts", e);
0:     }
0:     return holder;
0:   }
0: 
0:   /**
0:    * Convert intermediate sort temp row to 3-parted row.
0:    * This method is used in the final merge sort to feed rows to the next write step.
0:    *
0:    * @param sortTempRow intermediate sort temp row
0:    * @return 3-parted row
0:    */
0:   public Object[] convertIntermediateSortTempRowTo3Parted(IntermediateSortTempRow sortTempRow) {
0:     int[] dictDims
0:         = new int[this.dictSortDimCnt + this.dictNoSortDimCnt];
0:     byte[][] noDictArray
0:         = new byte[this.noDictSortDimCnt + this.noDictNoSortDimCnt][];
0: 
0:     int[] dictNoSortDims = new int[this.dictNoSortDimCnt];
0:     byte[][] noDictNoSortDims = new byte[this.noDictNoSortDimCnt][];
0:     Object[] measures = new Object[this.measureCnt];
0: 
0:     sortTempRow.unpackNoSortFromBytes(dictNoSortDims, noDictNoSortDims, measures, this.dataTypes);
0: 
0:     // dict dims
0:     System.arraycopy(sortTempRow.getDictSortDims(), 0 , dictDims,
0:         0, this.dictSortDimCnt);
0:     System.arraycopy(dictNoSortDims, 0, dictDims,
0:         this.dictSortDimCnt, this.dictNoSortDimCnt);;
0: 
0:     // no dict dims, including complex
0:     System.arraycopy(sortTempRow.getNoDictSortDims(), 0,
0:         noDictArray, 0, this.noDictSortDimCnt);
0:     System.arraycopy(noDictNoSortDims, 0, noDictArray,
0:         this.noDictSortDimCnt, this.noDictNoSortDimCnt);
0: 
0:     // measures are already here
0: 
0:     Object[] holder = new Object[3];
0:     NonDictionaryUtil.prepareOutObj(holder, dictDims, noDictArray, measures);
0:     return holder;
0:   }
0: 
0:   /**
0:    * Read intermediate sort temp row from InputStream.
0:    * This method is used during the merge sort phase to read row from sort temp file.
0:    *
0:    * @param inputStream input stream
0:    * @return a row that contains three parts
0:    * @throws IOException if error occrus while reading from stream
0:    */
0:   public IntermediateSortTempRow readIntermediateSortTempRowFromInputStream(
0:       DataInputStream inputStream) throws IOException {
0:     int[] dictSortDims = new int[this.dictSortDimCnt];
0:     byte[][] noDictSortDims = new byte[this.noDictSortDimCnt][];
0: 
0:     // read dict & sort dim data
0:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
0:       dictSortDims[idx] = inputStream.readInt();
0:     }
0: 
0:     // read no-dict & sort data
0:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
0:       short len = inputStream.readShort();
0:       byte[] bytes = new byte[len];
0:       inputStream.readFully(bytes);
0:       noDictSortDims[idx] = bytes;
0:     }
0: 
0:     // read no-dict dims & measures
0:     int len = inputStream.readInt();
0:     byte[] noSortDimsAndMeasures = new byte[len];
0:     inputStream.readFully(noSortDimsAndMeasures);
0: 
0:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims, noSortDimsAndMeasures);
0:   }
0: 
0:   /**
0:    * Write intermediate sort temp row to OutputStream
0:    * This method is used during the merge sort phase to write row to sort temp file.
0:    *
0:    * @param sortTempRow intermediate sort temp row
0:    * @param outputStream output stream
0:    * @throws IOException if error occurs while writing to stream
0:    */
0:   public void writeIntermediateSortTempRowToOutputStream(IntermediateSortTempRow sortTempRow,
0:       DataOutputStream outputStream) throws IOException {
0:     // write dict & sort dim
0:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
0:       outputStream.writeInt(sortTempRow.getDictSortDims()[idx]);
0:     }
0: 
0:     // write no-dict & sort dim
0:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
0:       byte[] bytes = sortTempRow.getNoDictSortDims()[idx];
0:       outputStream.writeShort(bytes.length);
0:       outputStream.write(bytes);
0:     }
0: 
0:     // write packed no-sort dim & measure
0:     outputStream.writeInt(sortTempRow.getNoSortDimsAndMeasures().length);
0:     outputStream.write(sortTempRow.getNoSortDimsAndMeasures());
0:   }
0: 
0:   /**
0:    * Write raw row as an intermediate sort temp row to sort temp file.
0:    * This method is used in the beginning of the sort phase. Comparing with converting raw row to
0:    * intermediate sort temp row and then writing the converted one, Writing raw row directly will
0:    * save the intermediate trivial loss.
0:    * This method use an array backend buffer to save memory allocation. The buffer will be reused
0:    * for all rows (per thread).
0:    *
0:    * @param row raw row
0:    * @param outputStream output stream
0:    * @param rowBuffer array backend buffer
0:    * @throws IOException if error occurs while writing to stream
0:    */
0:   public void writeRawRowAsIntermediateSortTempRowToOutputStream(Object[] row,
0:       DataOutputStream outputStream, ByteBuffer rowBuffer) throws IOException {
0:     // write dict & sort
0:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
0:       outputStream.writeInt((int) row[this.dictSortDimIdx[idx]]);
0:     }
0: 
0:     // write no-dict & sort
0:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
0:       byte[] bytes = (byte[]) row[this.noDictSortDimIdx[idx]];
0:       outputStream.writeShort(bytes.length);
0:       outputStream.write(bytes);
0:     }
0: 
0:     // pack no-sort
0:     rowBuffer.clear();
0:     packNoSortFieldsToBytes(row, rowBuffer);
0:     rowBuffer.flip();
0:     int packSize = rowBuffer.limit();
0: 
0:     // write no-sort
0:     outputStream.writeInt(packSize);
0:     outputStream.write(rowBuffer.array(), 0, packSize);
0:   }
0: 
0:   /**
0:    * Read intermediate sort temp row from unsafe memory.
0:    * This method is used during merge sort phase for off-heap sort.
0:    *
0:    * @param baseObject base object of memory block
0:    * @param address address of the row
0:    * @return intermediate sort temp row
0:    */
0:   public IntermediateSortTempRow readIntermediateSortTempRowFromUnsafeMemory(Object baseObject,
0:       long address) {
0:     int size = 0;
0: 
0:     int[] dictSortDims = new int[this.dictSortDimCnt];
0:     byte[][] noDictSortDims = new byte[this.noDictSortDimCnt][];
0: 
0:     // read dict & sort dim
0:     for (int idx = 0; idx < dictSortDims.length; idx++) {
0:       dictSortDims[idx] = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:       size += 4;
0:     }
0: 
0:     // read no-dict & sort dim
0:     for (int idx = 0; idx < noDictSortDims.length; idx++) {
0:       short length = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:       size += 2;
0:       byte[] bytes = new byte[length];
0:       CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
0:           bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, length);
0:       size += length;
0:       noDictSortDims[idx] = bytes;
0:     }
0: 
0:     // read no-sort dims & measures
0:     int len = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:     size += 4;
0:     byte[] noSortDimsAndMeasures = new byte[len];
0:     CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
0:         noSortDimsAndMeasures, CarbonUnsafe.BYTE_ARRAY_OFFSET, len);
0: 
0:     return new IntermediateSortTempRow(dictSortDims, noDictSortDims, noSortDimsAndMeasures);
0:   }
0: 
0:   /**
0:    * Write intermediate sort temp row directly from unsafe memory to stream.
0:    * This method is used at the late beginning of the sort phase to write in-memory pages
0:    * to sort temp file. Comparing with reading intermediate sort temp row from memory and then
0:    * writing it, Writing directly from memory to stream will save the intermediate trivial loss.
0:    *
0:    * @param baseObject base object of the memory block
0:    * @param address base address of the row
0:    * @param outputStream output stream
0:    * @throws IOException if error occurs while writing to stream
0:    */
0:   public void writeIntermediateSortTempRowFromUnsafeMemoryToStream(Object baseObject,
0:       long address, DataOutputStream outputStream) throws IOException {
0:     int size = 0;
0: 
0:     // dict & sort
0:     for (int idx = 0; idx < dictSortDimCnt; idx++) {
0:       outputStream.writeInt(CarbonUnsafe.getUnsafe().getInt(baseObject, address + size));
0:       size += 4;
0:     }
0: 
0:     // no-dict & sort
0:     for (int idx = 0; idx < noDictSortDimCnt; idx++) {
0:       short length = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:       size += 2;
0:       byte[] bytes = new byte[length];
0:       CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
0:           bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, length);
0:       size += length;
0: 
0:       outputStream.writeShort(length);
0:       outputStream.write(bytes);
0:     }
0: 
0:     // packed no-sort & measure
0:     int len = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:     size += 4;
0:     byte[] noSortDimsAndMeasures = new byte[len];
0:     CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size,
0:         noSortDimsAndMeasures, CarbonUnsafe.BYTE_ARRAY_OFFSET, len);
0:     size += len;
0: 
0:     outputStream.writeInt(len);
0:     outputStream.write(noSortDimsAndMeasures);
0:   }
0: 
0:   /**
0:    * Write raw row as an intermediate sort temp row to memory.
0:    * This method is used in the beginning of the off-heap sort phase. Comparing with converting
0:    * raw row to intermediate sort temp row and then writing the converted one,
0:    * Writing raw row directly will save the intermediate trivial loss.
0:    * This method use an array backend buffer to save memory allocation. The buffer will be reused
0:    * for all rows (per thread).
0:    *
0:    * @param row raw row
0:    * @param baseObject base object of the memory block
0:    * @param address base address for the row
0:    * @param rowBuffer array backend buffer
0:    * @return number of bytes written to memory
0:    */
0:   public int writeRawRowAsIntermediateSortTempRowToUnsafeMemory(Object[] row,
0:       Object baseObject, long address, ByteBuffer rowBuffer) {
0:     int size = 0;
0:     // write dict & sort
0:     for (int idx = 0; idx < this.dictSortDimCnt; idx++) {
0:       CarbonUnsafe.getUnsafe()
0:           .putInt(baseObject, address + size, (int) row[this.dictSortDimIdx[idx]]);
0:       size += 4;
0:     }
0: 
0:     // write no-dict & sort
0:     for (int idx = 0; idx < this.noDictSortDimCnt; idx++) {
0:       byte[] bytes = (byte[]) row[this.noDictSortDimIdx[idx]];
0:       CarbonUnsafe.getUnsafe().putShort(baseObject, address + size, (short) bytes.length);
0:       size += 2;
0:       CarbonUnsafe.getUnsafe()
0:           .copyMemory(bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject, address + size,
0:               bytes.length);
0:       size += bytes.length;
0:     }
0: 
0:     // convert pack no-sort
0:     rowBuffer.clear();
0:     packNoSortFieldsToBytes(row, rowBuffer);
0:     rowBuffer.flip();
0:     int packSize = rowBuffer.limit();
0: 
0:     // write no-sort
0:     CarbonUnsafe.getUnsafe().putInt(baseObject, address + size, packSize);
0:     size += 4;
0:     CarbonUnsafe.getUnsafe()
0:         .copyMemory(rowBuffer.array(), CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject, address + size,
0:             packSize);
0:     size += packSize;
0:     return size;
0:   }
0: 
0:   /**
0:    * Pack to no-sort fields to byte array
0:    *
0:    * @param row raw row
0:    * @param rowBuffer byte array backend buffer
0:    */
0:   private void packNoSortFieldsToBytes(Object[] row, ByteBuffer rowBuffer) {
0:     // convert dict & no-sort
0:     for (int idx = 0; idx < this.dictNoSortDimCnt; idx++) {
0:       rowBuffer.putInt((int) row[this.dictNoSortDimIdx[idx]]);
0:     }
0:     // convert no-dict & no-sort
0:     for (int idx = 0; idx < this.noDictNoSortDimCnt; idx++) {
0:       byte[] bytes = (byte[]) row[this.noDictNoSortDimIdx[idx]];
0:       rowBuffer.putShort((short) bytes.length);
0:       rowBuffer.put(bytes);
0:     }
0: 
0:     // convert measure
0:     Object tmpValue;
0:     DataType tmpDataType;
0:     for (int idx = 0; idx < this.measureCnt; idx++) {
0:       tmpValue = row[this.measureIdx[idx]];
0:       tmpDataType = this.dataTypes[idx];
0:       if (null == tmpValue) {
0:         rowBuffer.put((byte) 0);
0:         continue;
0:       }
0:       rowBuffer.put((byte) 1);
0:       if (DataTypes.BOOLEAN == tmpDataType) {
0:         if ((boolean) tmpValue) {
0:           rowBuffer.put((byte) 1);
0:         } else {
0:           rowBuffer.put((byte) 0);
0:         }
0:       } else if (DataTypes.SHORT == tmpDataType) {
0:         rowBuffer.putShort((Short) tmpValue);
0:       } else if (DataTypes.INT == tmpDataType) {
0:         rowBuffer.putInt((Integer) tmpValue);
0:       } else if (DataTypes.LONG == tmpDataType) {
0:         rowBuffer.putLong((Long) tmpValue);
0:       } else if (DataTypes.DOUBLE == tmpDataType) {
0:         rowBuffer.putDouble((Double) tmpValue);
0:       } else if (DataTypes.isDecimal(tmpDataType)) {
0:         byte[] decimalBytes = DataTypeUtil.bigDecimalToByte((BigDecimal) tmpValue);
0:         rowBuffer.putShort((short) decimalBytes.length);
0:         rowBuffer.put(decimalBytes);
0:       } else {
0:         throw new IllegalArgumentException("Unsupported data type: " + tmpDataType);
0:       }
0:     }
0:   }
0: }
============================================================================