1:70256e7: /*
1:70256e7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:70256e7:  * contributor license agreements.  See the NOTICE file distributed with
1:70256e7:  * this work for additional information regarding copyright ownership.
1:70256e7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:70256e7:  * (the "License"); you may not use this file except in compliance with
1:70256e7:  * the License.  You may obtain a copy of the License at
2:70256e7:  *
1:70256e7:  *    http://www.apache.org/licenses/LICENSE-2.0
1:70256e7:  *
1:70256e7:  * Unless required by applicable law or agreed to in writing, software
1:70256e7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:70256e7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:70256e7:  * See the License for the specific language governing permissions and
1:70256e7:  * limitations under the License.
2:70256e7:  */
1:70256e7: package org.apache.carbondata.core.scan.collector.impl;
11:70256e7: 
1:982d03f: import java.math.BigDecimal;
1:70256e7: import java.util.List;
1:70256e7: 
1:36ceb59: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryKeyGeneratorFactory;
1:ea5e80c: import org.apache.carbondata.core.metadata.datatype.DataType;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:70256e7: import org.apache.carbondata.core.metadata.encoder.Encoding;
1:70256e7: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:70256e7: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
1:70256e7: import org.apache.carbondata.core.scan.executor.infos.BlockExecutionInfo;
1:6b3b16c: import org.apache.carbondata.core.scan.executor.util.RestructureUtil;
1:daa6465: import org.apache.carbondata.core.scan.result.BlockletScannedResult;
1:70256e7: import org.apache.carbondata.core.scan.result.vector.CarbonColumnVector;
1:70256e7: import org.apache.carbondata.core.scan.result.vector.CarbonColumnarBatch;
1:70256e7: import org.apache.carbondata.core.scan.result.vector.ColumnVectorInfo;
1:70256e7: 
2:70256e7: /**
1:70256e7:  * It is not a collector it is just a scanned result holder.
1:70256e7:  */
1:6b3b16c: public class RestructureBasedVectorResultCollector extends DictionaryBasedVectorResultCollector {
1:70256e7: 
1:8c5c00c:   private Object[] measureDefaultValues = null;
1:8c5c00c: 
1:70256e7:   public RestructureBasedVectorResultCollector(BlockExecutionInfo blockExecutionInfos) {
1:70256e7:     super(blockExecutionInfos);
1:daa6465:     queryDimensions = executionInfo.getActualQueryDimensions();
1:daa6465:     queryMeasures = executionInfo.getActualQueryMeasures();
1:8c5c00c:     measureDefaultValues = new Object[queryMeasures.length];
1:70256e7:     allColumnInfo = new ColumnVectorInfo[queryDimensions.length + queryMeasures.length];
1:6b3b16c:     createVectorForNewlyAddedDimensions();
1:6b3b16c:     createVectorForNewlyAddedMeasures();
1:6b3b16c:     prepareDimensionAndMeasureColumnVectors();
1:6b3b16c:   }
1:6b3b16c: 
1:6b3b16c:   /**
1:6b3b16c:    * create column vector for newly added dimension columns
1:6b3b16c:    */
1:6b3b16c:   private void createVectorForNewlyAddedDimensions() {
1:70256e7:     for (int i = 0; i < queryDimensions.length; i++) {
1:70256e7:       if (!dimensionInfo.getDimensionExists()[i]) {
1:70256e7:         // add a dummy column vector result collector object
5:70256e7:         ColumnVectorInfo columnVectorInfo = new ColumnVectorInfo();
1:36ceb59:         columnVectorInfo.dimension = queryDimensions[i];
1:956833e:         if (queryDimensions[i].getDimension().getDataType().equals(DataTypes.TIMESTAMP)
1:956833e:             || queryDimensions[i].getDimension().getDataType().equals(DataTypes.DATE)) {
1:36ceb59:           columnVectorInfo.directDictionaryGenerator = DirectDictionaryKeyGeneratorFactory
1:36ceb59:               .getDirectDictionaryGenerator(queryDimensions[i].getDimension().getDataType());
1:36ceb59:         }
1:daa6465:         allColumnInfo[queryDimensions[i].getOrdinal()] = columnVectorInfo;
1:6b3b16c:       }
11:70256e7:     }
1:70256e7:   }
1:6b3b16c: 
1:6b3b16c:   /**
1:6b3b16c:    * create column vector for newly added measure columns
1:6b3b16c:    */
1:6b3b16c:   private void createVectorForNewlyAddedMeasures() {
1:70256e7:     for (int i = 0; i < queryMeasures.length; i++) {
1:70256e7:       if (!measureInfo.getMeasureExists()[i]) {
1:35739e5:         // add a dummy column vector result collector object
1:70256e7:         ColumnVectorInfo columnVectorInfo = new ColumnVectorInfo();
1:daa6465:         allColumnInfo[queryMeasures[i].getOrdinal()] = columnVectorInfo;
1:36ceb59:         columnVectorInfo.measure = queryMeasures[i];
1:8c5c00c:         measureDefaultValues[i] = getMeasureDefaultValue(queryMeasures[i].getMeasure());
1:70256e7:       }
1:70256e7:     }
1:70256e7:   }
1:70256e7: 
1:8c5c00c:   /**
1:8c5c00c:    * Gets the default value for each CarbonMeasure
1:cc4bc81:    *
1:8c5c00c:    * @param carbonMeasure
1:8c5c00c:    * @return
1:8c5c00c:    */
1:8c5c00c:   private Object getMeasureDefaultValue(CarbonMeasure carbonMeasure) {
1:8c5c00c:     return RestructureUtil.getMeasureDefaultValueByType(carbonMeasure.getColumnSchema(),
1:8c5c00c:         carbonMeasure.getDefaultValue());
1:8c5c00c:   }
1:8c5c00c: 
1:daa6465:   @Override
1:daa6465:   public List<Object[]> collectResultInRow(BlockletScannedResult scannedResult, int batchSize) {
1:daa6465:     throw new UnsupportedOperationException("collectResultInRow is not supported here");
1:70256e7:   }
1:8c5c00c: 
1:daa6465:   @Override
1:daa6465:   public void collectResultInColumnarBatch(BlockletScannedResult scannedResult,
1:70256e7:       CarbonColumnarBatch columnarBatch) {
1:70256e7:     int numberOfPages = scannedResult.numberOfpages();
1:70256e7:     while (scannedResult.getCurrentPageCounter() < numberOfPages) {
1:70256e7:       int currentPageRowCount = scannedResult.getCurrentPageRowCount();
1:70256e7:       if (currentPageRowCount == 0) {
2:70256e7:         scannedResult.incrementPageCounter();
3:70256e7:         continue;
1:70256e7:       }
1:70256e7:       int rowCounter = scannedResult.getRowCounter();
1:70256e7:       int availableRows = currentPageRowCount - rowCounter;
1:03d484a:       int requiredRows = columnarBatch.getBatchSize() - columnarBatch.getRowCounter();
1:70256e7:       requiredRows = Math.min(requiredRows, availableRows);
1:70256e7:       if (requiredRows < 1) {
1:70256e7:         return;
1:70256e7:       }
1:6b3b16c:       fillColumnVectorDetails(columnarBatch, rowCounter, requiredRows);
1:90000e6:       int filteredRows = scannedResult
1:90000e6:           .markFilteredRows(columnarBatch, rowCounter, requiredRows, columnarBatch.getRowCounter());
1:70256e7:       // fill default values for non existing dimensions and measures
1:70256e7:       fillDataForNonExistingDimensions();
1:70256e7:       fillDataForNonExistingMeasures();
1:6b3b16c:       // fill existing dimensions and measures data
1:daa6465:       fillResultToColumnarBatch(
1:daa6465:           scannedResult, columnarBatch, rowCounter, availableRows, requiredRows);
1:90000e6:       columnarBatch.setActualSize(columnarBatch.getActualSize() + requiredRows - filteredRows);
1:70256e7:     }
1:70256e7:   }
1:8c5c00c: 
1:70256e7:   /**
1:70256e7:    * This method will fill the default values of non existing dimensions in the current block
1:70256e7:    */
1:70256e7:   private void fillDataForNonExistingDimensions() {
1:daa6465:     for (int i = 0; i < executionInfo.getActualQueryDimensions().length; i++) {
1:70256e7:       if (!dimensionInfo.getDimensionExists()[i]) {
1:daa6465:         int queryOrder = executionInfo.getActualQueryDimensions()[i].getOrdinal();
1:70256e7:         CarbonDimension dimension =
1:daa6465:             executionInfo.getActualQueryDimensions()[i].getDimension();
1:70256e7:         if (dimension.hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:70256e7:           // fill direct dictionary column data
1:22be345:           fillDirectDictionaryData(allColumnInfo[queryOrder].vector, allColumnInfo[queryOrder],
1:70256e7:               dimensionInfo.getDefaultValues()[i]);
1:70256e7:         } else if (dimension.hasEncoding(Encoding.DICTIONARY)) {
1:70256e7:           // fill dictionary column data
1:22be345:           fillDictionaryData(allColumnInfo[queryOrder].vector, allColumnInfo[queryOrder],
1:70256e7:               dimensionInfo.getDefaultValues()[i]);
6:70256e7:         } else {
1:70256e7:           // fill no dictionary data
1:22be345:           fillNoDictionaryData(allColumnInfo[queryOrder].vector, allColumnInfo[queryOrder],
1:36ceb59:               dimensionInfo.getDefaultValues()[i]);
1:70256e7:         }
1:70256e7:       }
1:70256e7:     }
1:70256e7:   }
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * This method will fill the dictionary column data
1:70256e7:    *
1:70256e7:    * @param vector
1:70256e7:    * @param columnVectorInfo
1:70256e7:    * @param defaultValue
1:70256e7:    */
1:70256e7:   private void fillDictionaryData(CarbonColumnVector vector, ColumnVectorInfo columnVectorInfo,
1:70256e7:       Object defaultValue) {
1:ea5e80c:     vector.putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size, (int) defaultValue);
1:70256e7:   }
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * This method will fill the direct dictionary column data
1:70256e7:    *
1:70256e7:    * @param vector
1:70256e7:    * @param columnVectorInfo
1:70256e7:    * @param defaultValue
1:70256e7:    */
1:70256e7:   private void fillDirectDictionaryData(CarbonColumnVector vector,
1:70256e7:       ColumnVectorInfo columnVectorInfo, Object defaultValue) {
1:6b3b16c:     if (null != defaultValue) {
1:956833e:       if (columnVectorInfo.directDictionaryGenerator.getReturnType().equals(DataTypes.INT)) {
1:36ceb59:         vector.putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size, (int) defaultValue);
1:ea5e80c:       } else {
1:ea5e80c:         vector.putLongs(columnVectorInfo.vectorOffset, columnVectorInfo.size, (long) defaultValue);
1:ea5e80c:       }
1:6b3b16c:     } else {
1:6b3b16c:       vector.putNulls(columnVectorInfo.vectorOffset, columnVectorInfo.size);
1:70256e7:     }
1:70256e7:   }
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * This method will fill the no dictionary column data
1:70256e7:    *
1:70256e7:    * @param vector
1:70256e7:    * @param columnVectorInfo
1:70256e7:    * @param defaultValue
1:70256e7:    */
1:70256e7:   private void fillNoDictionaryData(CarbonColumnVector vector, ColumnVectorInfo columnVectorInfo,
1:36ceb59:       Object defaultValue) {
1:6b3b16c:     if (null != defaultValue) {
1:956833e:       DataType dataType = columnVectorInfo.dimension.getDimension().getDataType();
1:956833e:       if (dataType == DataTypes.INT) {
1:956833e:         vector.putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size, (int) defaultValue);
1:956833e:       } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
1:956833e:         vector.putLongs(columnVectorInfo.vectorOffset, columnVectorInfo.size, (long) defaultValue);
1:956833e:       } else {
1:982d03f:         vector.putBytes(columnVectorInfo.vectorOffset, columnVectorInfo.size, (byte[])defaultValue);
1:36ceb59:       }
1:6b3b16c:     } else {
1:6b3b16c:       vector.putNulls(columnVectorInfo.vectorOffset, columnVectorInfo.size);
1:70256e7:     }
1:70256e7:   }
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * This method will fill the default values of non existing measures in the current block
1:70256e7:    */
1:70256e7:   private void fillDataForNonExistingMeasures() {
1:daa6465:     for (int i = 0; i < executionInfo.getActualQueryMeasures().length; i++) {
1:70256e7:       if (!measureInfo.getMeasureExists()[i]) {
1:daa6465:         int queryOrder = executionInfo.getActualQueryMeasures()[i].getOrdinal();
1:daa6465:         CarbonMeasure measure = executionInfo.getActualQueryMeasures()[i].getMeasure();
1:8c5c00c:         ColumnVectorInfo columnVectorInfo = allColumnInfo[queryOrder];
1:8c5c00c:         CarbonColumnVector vector = columnVectorInfo.vector;
1:8c5c00c:         Object defaultValue = measureDefaultValues[i];
1:6b3b16c:         if (null == defaultValue) {
1:6b3b16c:           vector.putNulls(columnVectorInfo.vectorOffset, columnVectorInfo.size);
1:6b3b16c:         } else {
1:956833e:           DataType dataType = measureInfo.getMeasureDataTypes()[i];
1:956833e:           if (dataType == DataTypes.SHORT) {
1:956833e:             vector.putShorts(columnVectorInfo.vectorOffset, columnVectorInfo.size,
1:956833e:                 (short) defaultValue);
1:956833e:           } else if (dataType == DataTypes.INT) {
1:956833e:             vector
1:956833e:                 .putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size, (int) defaultValue);
1:956833e:           } else if (dataType == DataTypes.LONG) {
1:956833e:             vector.putLongs(columnVectorInfo.vectorOffset, columnVectorInfo.size,
1:956833e:                 (long) defaultValue);
1:f209e8e:           } else if (DataTypes.isDecimal(dataType)) {
1:956833e:             vector.putDecimals(columnVectorInfo.vectorOffset, columnVectorInfo.size,
1:982d03f:                 (BigDecimal) defaultValue, measure.getPrecision());
1:cc4bc81:           } else if (dataType == DataTypes.BOOLEAN) {
1:cc4bc81:             vector.putBoolean(columnVectorInfo.vectorOffset, (Boolean) defaultValue);
1:956833e:           } else {
1:956833e:             vector.putDoubles(columnVectorInfo.vectorOffset, columnVectorInfo.size,
1:956833e:                 (double) defaultValue);
1:70256e7:           }
1:70256e7:         }
1:70256e7:       }
1:70256e7:     }
1:70256e7:   }
1:70256e7: 
1:70256e7: }
============================================================================
author:Jacky Li
-------------------------------------------------------------------------------
commit:982d03f
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         vector.putBytes(columnVectorInfo.vectorOffset, columnVectorInfo.size, (byte[])defaultValue);
/////////////////////////////////////////////////////////////////////////
1:                 (BigDecimal) defaultValue, measure.getPrecision());
commit:daa6465
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.result.BlockletScannedResult;
/////////////////////////////////////////////////////////////////////////
1:     queryDimensions = executionInfo.getActualQueryDimensions();
1:     queryMeasures = executionInfo.getActualQueryMeasures();
/////////////////////////////////////////////////////////////////////////
1:         allColumnInfo[queryDimensions[i].getOrdinal()] = columnVectorInfo;
/////////////////////////////////////////////////////////////////////////
1:         allColumnInfo[queryMeasures[i].getOrdinal()] = columnVectorInfo;
/////////////////////////////////////////////////////////////////////////
1:   @Override
1:   public List<Object[]> collectResultInRow(BlockletScannedResult scannedResult, int batchSize) {
1:     throw new UnsupportedOperationException("collectResultInRow is not supported here");
1:   @Override
1:   public void collectResultInColumnarBatch(BlockletScannedResult scannedResult,
/////////////////////////////////////////////////////////////////////////
1:       fillResultToColumnarBatch(
1:           scannedResult, columnarBatch, rowCounter, availableRows, requiredRows);
/////////////////////////////////////////////////////////////////////////
1:     for (int i = 0; i < executionInfo.getActualQueryDimensions().length; i++) {
1:         int queryOrder = executionInfo.getActualQueryDimensions()[i].getOrdinal();
1:             executionInfo.getActualQueryDimensions()[i].getDimension();
/////////////////////////////////////////////////////////////////////////
1:     for (int i = 0; i < executionInfo.getActualQueryMeasures().length; i++) {
1:         int queryOrder = executionInfo.getActualQueryMeasures()[i].getOrdinal();
1:         CarbonMeasure measure = executionInfo.getActualQueryMeasures()[i].getMeasure();
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
1:           } else if (DataTypes.isDecimal(dataType)) {
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
1:         if (queryDimensions[i].getDimension().getDataType().equals(DataTypes.TIMESTAMP)
1:             || queryDimensions[i].getDimension().getDataType().equals(DataTypes.DATE)) {
/////////////////////////////////////////////////////////////////////////
1:       if (columnVectorInfo.directDictionaryGenerator.getReturnType().equals(DataTypes.INT)) {
/////////////////////////////////////////////////////////////////////////
1:       DataType dataType = columnVectorInfo.dimension.getDimension().getDataType();
1:       if (dataType == DataTypes.INT) {
1:         vector.putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size, (int) defaultValue);
1:       } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
1:         vector.putLongs(columnVectorInfo.vectorOffset, columnVectorInfo.size, (long) defaultValue);
1:       } else {
0:         vector.putBytes(columnVectorInfo.vectorOffset, columnVectorInfo.size,
0:             ((UTF8String) defaultValue).getBytes());
/////////////////////////////////////////////////////////////////////////
1:           DataType dataType = measureInfo.getMeasureDataTypes()[i];
1:           if (dataType == DataTypes.SHORT) {
1:             vector.putShorts(columnVectorInfo.vectorOffset, columnVectorInfo.size,
1:                 (short) defaultValue);
1:           } else if (dataType == DataTypes.INT) {
1:             vector
1:                 .putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size, (int) defaultValue);
1:           } else if (dataType == DataTypes.LONG) {
1:             vector.putLongs(columnVectorInfo.vectorOffset, columnVectorInfo.size,
1:                 (long) defaultValue);
0:           } else if (dataType == DataTypes.DECIMAL) {
1:             vector.putDecimals(columnVectorInfo.vectorOffset, columnVectorInfo.size,
0:                 (Decimal) defaultValue, measure.getPrecision());
1:           } else {
1:             vector.putDoubles(columnVectorInfo.vectorOffset, columnVectorInfo.size,
1:                 (double) defaultValue);
author:anubhav100
-------------------------------------------------------------------------------
commit:cc4bc81
/////////////////////////////////////////////////////////////////////////
1:    *
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:           } else if (dataType == DataTypes.BOOLEAN) {
1:             vector.putBoolean(columnVectorInfo.vectorOffset, (Boolean) defaultValue);
author:Bhavya
-------------------------------------------------------------------------------
commit:e5e74fc
/////////////////////////////////////////////////////////////////////////
0:                 ((Decimal) defaultValue).toJavaBigDecimal(), measure.getPrecision());
author:dhatchayani
-------------------------------------------------------------------------------
commit:36ceb59
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryKeyGeneratorFactory;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.spark.unsafe.types.UTF8String;
/////////////////////////////////////////////////////////////////////////
1:         columnVectorInfo.dimension = queryDimensions[i];
0:         if (queryDimensions[i].getDimension().getDataType().equals(DataType.TIMESTAMP)
0:             || queryDimensions[i].getDimension().getDataType().equals(DataType.DATE)) {
1:           columnVectorInfo.directDictionaryGenerator = DirectDictionaryKeyGeneratorFactory
1:               .getDirectDictionaryGenerator(queryDimensions[i].getDimension().getDataType());
1:         }
/////////////////////////////////////////////////////////////////////////
1:         columnVectorInfo.measure = queryMeasures[i];
/////////////////////////////////////////////////////////////////////////
1:               dimensionInfo.getDefaultValues()[i]);
/////////////////////////////////////////////////////////////////////////
1:       Object defaultValue) {
0:       switch (columnVectorInfo.dimension.getDimension().getDataType()) {
0:         case INT:
1:           vector.putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size, (int) defaultValue);
0:           break;
0:         case LONG:
0:         case TIMESTAMP:
0:           vector
0:               .putLongs(columnVectorInfo.vectorOffset, columnVectorInfo.size, (long) defaultValue);
0:           break;
0:         default:
0:           vector.putBytes(columnVectorInfo.vectorOffset, columnVectorInfo.size,
0:               ((UTF8String) defaultValue).getBytes());
1:       }
author:sounakr
-------------------------------------------------------------------------------
commit:03d484a
/////////////////////////////////////////////////////////////////////////
1:       int requiredRows = columnarBatch.getBatchSize() - columnarBatch.getRowCounter();
author:ravikiran23
-------------------------------------------------------------------------------
commit:90000e6
/////////////////////////////////////////////////////////////////////////
1:       int filteredRows = scannedResult
1:           .markFilteredRows(columnarBatch, rowCounter, requiredRows, columnarBatch.getRowCounter());
1:       columnarBatch.setActualSize(columnarBatch.getActualSize() + requiredRows - filteredRows);
author:kunal642
-------------------------------------------------------------------------------
commit:ea5e80c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataType;
/////////////////////////////////////////////////////////////////////////
0:       if (columnVectorInfo.directDictionaryGenerator.getReturnType().equals(DataType.INT)) {
1:         vector.putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size, (int) defaultValue);
1:       } else {
1:         vector.putLongs(columnVectorInfo.vectorOffset, columnVectorInfo.size, (long) defaultValue);
1:       }
commit:8c5c00c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private Object[] measureDefaultValues = null;
1: 
1:     measureDefaultValues = new Object[queryMeasures.length];
/////////////////////////////////////////////////////////////////////////
1:         measureDefaultValues[i] = getMeasureDefaultValue(queryMeasures[i].getMeasure());
1:   /**
1:    * Gets the default value for each CarbonMeasure
1:    * @param carbonMeasure
1:    * @return
1:    */
1:   private Object getMeasureDefaultValue(CarbonMeasure carbonMeasure) {
1:     return RestructureUtil.getMeasureDefaultValueByType(carbonMeasure.getColumnSchema(),
1:         carbonMeasure.getDefaultValue());
1:   }
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         int queryOrder = tableBlockExecutionInfos.getActualQueryMeasures()[i].getQueryOrder();
1:         ColumnVectorInfo columnVectorInfo = allColumnInfo[queryOrder];
1:         CarbonColumnVector vector = columnVectorInfo.vector;
1:         Object defaultValue = measureDefaultValues[i];
/////////////////////////////////////////////////////////////////////////
0:                   (Decimal) defaultValue, measure.getPrecision());
commit:22be345
/////////////////////////////////////////////////////////////////////////
0:         int queryOrder = tableBlockExecutionInfos.getActualQueryDimensions()[i].getQueryOrder();
1:           fillDirectDictionaryData(allColumnInfo[queryOrder].vector, allColumnInfo[queryOrder],
1:           fillDictionaryData(allColumnInfo[queryOrder].vector, allColumnInfo[queryOrder],
1:           fillNoDictionaryData(allColumnInfo[queryOrder].vector, allColumnInfo[queryOrder],
author:manishgupta88
-------------------------------------------------------------------------------
commit:6b3b16c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.executor.util.RestructureUtil;
1: public class RestructureBasedVectorResultCollector extends DictionaryBasedVectorResultCollector {
0:     queryDimensions = tableBlockExecutionInfos.getActualQueryDimensions();
0:     queryMeasures = tableBlockExecutionInfos.getActualQueryMeasures();
1:     createVectorForNewlyAddedDimensions();
1:     createVectorForNewlyAddedMeasures();
1:     prepareDimensionAndMeasureColumnVectors();
1:   }
1: 
1:   /**
1:    * create column vector for newly added dimension columns
1:    */
1:   private void createVectorForNewlyAddedDimensions() {
1:   }
1: 
1:   /**
1:    * create column vector for newly added measure columns
1:    */
1:   private void createVectorForNewlyAddedMeasures() {
/////////////////////////////////////////////////////////////////////////
1:       fillColumnVectorDetails(columnarBatch, rowCounter, requiredRows);
1:       // fill existing dimensions and measures data
0:       scanAndFillResult(scannedResult, columnarBatch, rowCounter, availableRows, requiredRows);
/////////////////////////////////////////////////////////////////////////
0:     vector.putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size, (int) defaultValue);
/////////////////////////////////////////////////////////////////////////
1:     if (null != defaultValue) {
0:       vector.putLongs(columnVectorInfo.vectorOffset, columnVectorInfo.size, (long) defaultValue);
1:     } else {
1:       vector.putNulls(columnVectorInfo.vectorOffset, columnVectorInfo.size);
/////////////////////////////////////////////////////////////////////////
1:     if (null != defaultValue) {
0:       vector.putBytes(columnVectorInfo.vectorOffset, columnVectorInfo.size, defaultValue);
1:     } else {
1:       vector.putNulls(columnVectorInfo.vectorOffset, columnVectorInfo.size);
/////////////////////////////////////////////////////////////////////////
0:         Object defaultValue = RestructureUtil
0:             .getMeasureDefaultValue(measure.getColumnSchema(), measure.getDefaultValue());
1:         if (null == defaultValue) {
1:           vector.putNulls(columnVectorInfo.vectorOffset, columnVectorInfo.size);
1:         } else {
0:           switch (measureInfo.getMeasureDataTypes()[i]) {
0:             case SHORT:
0:               vector.putShorts(columnVectorInfo.vectorOffset, columnVectorInfo.size,
0:                   (short) defaultValue);
0:               break;
0:             case INT:
0:               vector.putInts(columnVectorInfo.vectorOffset, columnVectorInfo.size,
0:                   (int) defaultValue);
0:               break;
0:             case LONG:
0:               vector.putLongs(columnVectorInfo.vectorOffset, columnVectorInfo.size,
0:                   (long) defaultValue);
0:               break;
0:             case DECIMAL:
0:               Decimal convertToSparkType = Decimal.apply((BigDecimal) defaultValue);
0:               vector.putDecimals(columnVectorInfo.vectorOffset, columnVectorInfo.size,
0:                   convertToSparkType, measure.getPrecision());
0:               break;
0:             default:
0:               vector.putDoubles(columnVectorInfo.vectorOffset, columnVectorInfo.size,
0:                   (double) defaultValue);
commit:70256e7
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.carbondata.core.scan.collector.impl;
1: 
0: import java.math.BigDecimal;
0: import java.util.ArrayList;
0: import java.util.Arrays;
1: import java.util.List;
1: 
0: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryKeyGeneratorFactory;
1: import org.apache.carbondata.core.metadata.encoder.Encoding;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
1: import org.apache.carbondata.core.scan.executor.infos.BlockExecutionInfo;
0: import org.apache.carbondata.core.scan.model.QueryDimension;
0: import org.apache.carbondata.core.scan.model.QueryMeasure;
0: import org.apache.carbondata.core.scan.result.AbstractScannedResult;
1: import org.apache.carbondata.core.scan.result.vector.CarbonColumnVector;
1: import org.apache.carbondata.core.scan.result.vector.CarbonColumnarBatch;
1: import org.apache.carbondata.core.scan.result.vector.ColumnVectorInfo;
0: import org.apache.carbondata.core.scan.result.vector.MeasureDataVectorProcessor;
1: 
0: import org.apache.spark.sql.types.Decimal;
1: 
1: /**
1:  * It is not a collector it is just a scanned result holder.
1:  */
0: public class RestructureBasedVectorResultCollector extends AbstractScannedResultCollector {
1: 
0:   private ColumnVectorInfo[] dictionaryInfo;
1: 
0:   private ColumnVectorInfo[] noDictionaryInfo;
1: 
0:   private ColumnVectorInfo[] complexInfo;
1: 
0:   private ColumnVectorInfo[] measureColumnInfo;
1: 
0:   private ColumnVectorInfo[] allColumnInfo;
1: 
1:   public RestructureBasedVectorResultCollector(BlockExecutionInfo blockExecutionInfos) {
1:     super(blockExecutionInfos);
0:     QueryDimension[] queryDimensions = tableBlockExecutionInfos.getActualQueryDimensions();
0:     QueryMeasure[] queryMeasures = tableBlockExecutionInfos.getActualQueryMeasures();
0:     measureColumnInfo = new ColumnVectorInfo[queryMeasures.length];
1:     allColumnInfo = new ColumnVectorInfo[queryDimensions.length + queryMeasures.length];
0:     List<ColumnVectorInfo> dictInfoList = new ArrayList<>();
0:     List<ColumnVectorInfo> noDictInfoList = new ArrayList<>();
0:     List<ColumnVectorInfo> complexList = new ArrayList<>();
0:     int dimensionExistIndex = 0;
1:     for (int i = 0; i < queryDimensions.length; i++) {
1:       if (!dimensionInfo.getDimensionExists()[i]) {
1:         // add a dummy column vector result collector object
1:         ColumnVectorInfo columnVectorInfo = new ColumnVectorInfo();
0:         allColumnInfo[queryDimensions[i].getQueryOrder()] = columnVectorInfo;
1:         continue;
1:       }
0:       // get the current block dimension and fetch the required information from it
0:       QueryDimension currentBlockDimension =
0:           tableBlockExecutionInfos.getQueryDimensions()[dimensionExistIndex++];
0:       if (!queryDimensions[i].getDimension().hasEncoding(Encoding.DICTIONARY)) {
1:         ColumnVectorInfo columnVectorInfo = new ColumnVectorInfo();
0:         noDictInfoList.add(columnVectorInfo);
0:         columnVectorInfo.dimension = currentBlockDimension;
0:         columnVectorInfo.ordinal = currentBlockDimension.getDimension().getOrdinal();
0:         allColumnInfo[queryDimensions[i].getQueryOrder()] = columnVectorInfo;
0:       } else if (queryDimensions[i].getDimension().hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:         ColumnVectorInfo columnVectorInfo = new ColumnVectorInfo();
0:         dictInfoList.add(columnVectorInfo);
0:         columnVectorInfo.dimension = currentBlockDimension;
0:         columnVectorInfo.directDictionaryGenerator = DirectDictionaryKeyGeneratorFactory
0:             .getDirectDictionaryGenerator(currentBlockDimension.getDimension().getDataType());
0:         columnVectorInfo.ordinal = currentBlockDimension.getDimension().getOrdinal();
0:         allColumnInfo[queryDimensions[i].getQueryOrder()] = columnVectorInfo;
0:       } else if (queryDimensions[i].getDimension().isComplex()) {
1:         ColumnVectorInfo columnVectorInfo = new ColumnVectorInfo();
0:         complexList.add(columnVectorInfo);
0:         columnVectorInfo.dimension = currentBlockDimension;
0:         columnVectorInfo.ordinal = currentBlockDimension.getDimension().getOrdinal();
0:         columnVectorInfo.genericQueryType =
0:             tableBlockExecutionInfos.getComlexDimensionInfoMap().get(columnVectorInfo.ordinal);
0:         allColumnInfo[queryDimensions[i].getQueryOrder()] = columnVectorInfo;
1:       } else {
1:         ColumnVectorInfo columnVectorInfo = new ColumnVectorInfo();
0:         dictInfoList.add(columnVectorInfo);
0:         columnVectorInfo.dimension = currentBlockDimension;
0:         columnVectorInfo.ordinal = currentBlockDimension.getDimension().getOrdinal();
0:         allColumnInfo[queryDimensions[i].getQueryOrder()] = columnVectorInfo;
1:       }
1:     }
0:     int measureExistIndex = 0;
1:     for (int i = 0; i < queryMeasures.length; i++) {
1:       if (!measureInfo.getMeasureExists()[i]) {
1:         continue;
1:       }
0:       QueryMeasure currentBlockMeasure =
0:           tableBlockExecutionInfos.getQueryMeasures()[measureExistIndex++];
1:       ColumnVectorInfo columnVectorInfo = new ColumnVectorInfo();
0:       columnVectorInfo.measureVectorFiller = MeasureDataVectorProcessor.MeasureVectorFillerFactory
0:           .getMeasureVectorFiller(currentBlockMeasure.getMeasure().getDataType());
0:       columnVectorInfo.ordinal = currentBlockMeasure.getMeasure().getOrdinal();
0:       columnVectorInfo.measure = currentBlockMeasure;
0:       this.measureColumnInfo[i] = columnVectorInfo;
0:       allColumnInfo[queryMeasures[i].getQueryOrder()] = columnVectorInfo;
1:     }
0:     dictionaryInfo = dictInfoList.toArray(new ColumnVectorInfo[dictInfoList.size()]);
0:     noDictionaryInfo = noDictInfoList.toArray(new ColumnVectorInfo[noDictInfoList.size()]);
0:     complexInfo = complexList.toArray(new ColumnVectorInfo[complexList.size()]);
0:     Arrays.sort(dictionaryInfo);
0:     Arrays.sort(noDictionaryInfo);
0:     Arrays.sort(complexInfo);
1:   }
1: 
0:   @Override public List<Object[]> collectData(AbstractScannedResult scannedResult, int batchSize) {
0:     throw new UnsupportedOperationException("collectData is not supported here");
1:   }
1: 
0:   @Override public void collectVectorBatch(AbstractScannedResult scannedResult,
1:       CarbonColumnarBatch columnarBatch) {
1:     int numberOfPages = scannedResult.numberOfpages();
1:     while (scannedResult.getCurrentPageCounter() < numberOfPages) {
1:       int currentPageRowCount = scannedResult.getCurrentPageRowCount();
1:       if (currentPageRowCount == 0) {
1:         scannedResult.incrementPageCounter();
1:         continue;
1:       }
1:       int rowCounter = scannedResult.getRowCounter();
1:       int availableRows = currentPageRowCount - rowCounter;
0:       int requiredRows = columnarBatch.getBatchSize() - columnarBatch.getActualSize();
1:       requiredRows = Math.min(requiredRows, availableRows);
1:       if (requiredRows < 1) {
1:         return;
1:       }
0:       for (int i = 0; i < allColumnInfo.length; i++) {
0:         allColumnInfo[i].size = requiredRows;
0:         allColumnInfo[i].offset = rowCounter;
0:         allColumnInfo[i].vectorOffset = columnarBatch.getRowCounter();
0:         allColumnInfo[i].vector = columnarBatch.columnVectors[i];
1:       }
1: 
0:       scannedResult.fillColumnarDictionaryBatch(dictionaryInfo);
0:       scannedResult.fillColumnarNoDictionaryBatch(noDictionaryInfo);
0:       scannedResult.fillColumnarMeasureBatch(measureColumnInfo, measureInfo.getMeasureOrdinals());
0:       scannedResult.fillColumnarComplexBatch(complexInfo);
1:       // fill default values for non existing dimensions and measures
1:       fillDataForNonExistingDimensions();
1:       fillDataForNonExistingMeasures();
0:       // it means fetched all data out of page so increment the page counter
0:       if (availableRows == requiredRows) {
1:         scannedResult.incrementPageCounter();
1:       } else {
0:         // Or set the row counter.
0:         scannedResult.setRowCounter(rowCounter + requiredRows);
1:       }
0:       columnarBatch.setActualSize(columnarBatch.getActualSize() + requiredRows);
0:       columnarBatch.setRowCounter(columnarBatch.getRowCounter() + requiredRows);
1:     }
1:   }
1: 
1:   /**
1:    * This method will fill the default values of non existing dimensions in the current block
1:    */
1:   private void fillDataForNonExistingDimensions() {
0:     for (int i = 0; i < tableBlockExecutionInfos.getActualQueryMeasures().length; i++) {
1:       if (!dimensionInfo.getDimensionExists()[i]) {
1:         CarbonDimension dimension =
0:             tableBlockExecutionInfos.getActualQueryDimensions()[i].getDimension();
1:         if (dimension.hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:           // fill direct dictionary column data
0:           fillDirectDictionaryData(allColumnInfo[i].vector, allColumnInfo[i],
1:               dimensionInfo.getDefaultValues()[i]);
1:         } else if (dimension.hasEncoding(Encoding.DICTIONARY)) {
1:           // fill dictionary column data
0:           fillDictionaryData(allColumnInfo[i].vector, allColumnInfo[i],
1:               dimensionInfo.getDefaultValues()[i]);
1:         } else {
1:           // fill no dictionary data
0:           fillNoDictionaryData(allColumnInfo[i].vector, allColumnInfo[i],
0:               dimension.getDefaultValue());
1:         }
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * This method will fill the dictionary column data
1:    *
1:    * @param vector
1:    * @param columnVectorInfo
1:    * @param defaultValue
1:    */
1:   private void fillDictionaryData(CarbonColumnVector vector, ColumnVectorInfo columnVectorInfo,
1:       Object defaultValue) {
0:     int offset = columnVectorInfo.offset;
0:     int vectorOffset = columnVectorInfo.vectorOffset;
0:     int len = columnVectorInfo.size + offset;
0:     for (int j = offset; j < len; j++) {
0:       vector.putInt(vectorOffset++, (int) defaultValue);
1:     }
1:   }
1: 
1:   /**
1:    * This method will fill the direct dictionary column data
1:    *
1:    * @param vector
1:    * @param columnVectorInfo
1:    * @param defaultValue
1:    */
1:   private void fillDirectDictionaryData(CarbonColumnVector vector,
1:       ColumnVectorInfo columnVectorInfo, Object defaultValue) {
0:     int offset = columnVectorInfo.offset;
0:     int vectorOffset = columnVectorInfo.vectorOffset;
0:     int len = columnVectorInfo.size + offset;
0:     for (int j = offset; j < len; j++) {
0:       if (null != defaultValue) {
0:         vector.putLong(vectorOffset++, (long) defaultValue);
1:       } else {
0:         vector.putNull(vectorOffset++);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * This method will fill the no dictionary column data
1:    *
1:    * @param vector
1:    * @param columnVectorInfo
1:    * @param defaultValue
1:    */
1:   private void fillNoDictionaryData(CarbonColumnVector vector, ColumnVectorInfo columnVectorInfo,
0:       byte[] defaultValue) {
0:     int offset = columnVectorInfo.offset;
0:     int vectorOffset = columnVectorInfo.vectorOffset;
0:     int len = columnVectorInfo.size + offset;
0:     for (int j = offset; j < len; j++) {
0:       if (null != defaultValue) {
0:         vector.putBytes(vectorOffset++, defaultValue);
1:       } else {
0:         vector.putNull(vectorOffset++);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * This method will fill the default values of non existing measures in the current block
1:    */
1:   private void fillDataForNonExistingMeasures() {
0:     for (int i = 0; i < tableBlockExecutionInfos.getActualQueryMeasures().length; i++) {
1:       if (!measureInfo.getMeasureExists()[i]) {
0:         CarbonMeasure measure = tableBlockExecutionInfos.getActualQueryMeasures()[i].getMeasure();
0:         ColumnVectorInfo columnVectorInfo = allColumnInfo[i];
0:         CarbonColumnVector vector = allColumnInfo[i].vector;
0:         int offset = columnVectorInfo.offset;
0:         int len = offset + columnVectorInfo.size;
0:         int vectorOffset = columnVectorInfo.vectorOffset;
0:         // convert decimal default value to spark decimal type so that new object is not getting
0:         // created for every row added
0:         Object defaultValue = convertDecimalValue(measure, measureInfo.getDefaultValues()[i]);
0:         for (int j = offset; j < len; j++) {
0:           if (null == defaultValue) {
0:             vector.putNull(vectorOffset++);
1:           } else {
0:             switch (measureInfo.getMeasureDataTypes()[i]) {
0:               case SHORT:
0:                 vector.putShort(vectorOffset++, (short) defaultValue);
0:                 break;
0:               case INT:
0:                 vector.putInt(vectorOffset++, (int) defaultValue);
0:                 break;
0:               case LONG:
0:                 vector.putLong(vectorOffset++, (long) defaultValue);
0:                 break;
0:               case DECIMAL:
0:                 vector.putDecimal(vectorOffset, (Decimal) defaultValue, measure.getPrecision());
0:                 break;
0:               default:
0:                 vector.putDouble(vectorOffset++, (double) defaultValue);
1:             }
1:           }
1:         }
1:       }
1:     }
1:   }
1: 
1:   /**
0:    * This method will parse the measure default value based on data type
1:    *
0:    * @param measure
0:    * @return
1:    */
0:   private Object convertDecimalValue(CarbonMeasure measure, Object defaultValue) {
0:     if (null != measure.getDefaultValue()) {
0:       switch (measure.getDataType()) {
0:         case DECIMAL:
0:           defaultValue = org.apache.spark.sql.types.Decimal.apply((BigDecimal) defaultValue);
0:           return defaultValue;
0:         default:
0:           return defaultValue;
1:       }
1:     }
0:     return defaultValue;
1:   }
1: 
1: }
author:nareshpr
-------------------------------------------------------------------------------
commit:35739e5
/////////////////////////////////////////////////////////////////////////
1:         // add a dummy column vector result collector object
0:         ColumnVectorInfo columnVectorInfo = new ColumnVectorInfo();
0:         allColumnInfo[queryMeasures[i].getQueryOrder()] = columnVectorInfo;
/////////////////////////////////////////////////////////////////////////
0:     for (int i = 0; i < tableBlockExecutionInfos.getActualQueryDimensions().length; i++) {
/////////////////////////////////////////////////////////////////////////
0:    *
============================================================================