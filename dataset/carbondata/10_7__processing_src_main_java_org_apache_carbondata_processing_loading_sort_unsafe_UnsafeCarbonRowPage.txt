1:f1f9348: /*
1:f1f9348:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:f1f9348:  * contributor license agreements.  See the NOTICE file distributed with
1:f1f9348:  * this work for additional information regarding copyright ownership.
1:f1f9348:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:f1f9348:  * (the "License"); you may not use this file except in compliance with
1:f1f9348:  * the License.  You may obtain a copy of the License at
1:21704cf:  *
1:f1f9348:  *    http://www.apache.org/licenses/LICENSE-2.0
2:f1f9348:  *
1:f1f9348:  * Unless required by applicable law or agreed to in writing, software
1:f1f9348:  * distributed under the License is distributed on an "AS IS" BASIS,
1:f1f9348:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f1f9348:  * See the License for the specific language governing permissions and
1:f1f9348:  * limitations under the License.
2:21704cf:  */
44:f1f9348: 
1:349c59c: package org.apache.carbondata.processing.loading.sort.unsafe;
1:21704cf: 
1:f1f9348: import java.io.DataOutputStream;
1:f1f9348: import java.io.IOException;
1:2b41f14: import java.nio.ByteBuffer;
1:f1f9348: 
1:edda248: import org.apache.carbondata.core.memory.IntPointerBuffer;
1:f1f9348: import org.apache.carbondata.core.memory.MemoryBlock;
1:df22368: import org.apache.carbondata.core.memory.UnsafeMemoryManager;
1:df22368: import org.apache.carbondata.core.memory.UnsafeSortMemoryManager;
1:2b41f14: import org.apache.carbondata.processing.loading.row.IntermediateSortTempRow;
1:2b41f14: import org.apache.carbondata.processing.loading.sort.SortStepRowHandler;
1:2b41f14: import org.apache.carbondata.processing.sort.sortdata.TableFieldStat;
1:f1f9348: 
3:21704cf: /**
1:f1f9348:  * It can keep the data of prescribed size data in offheap/onheap memory and returns it when needed
1:21704cf:  */
1:f1f9348: public class UnsafeCarbonRowPage {
1:f1f9348:   private IntPointerBuffer buffer;
1:8d8b589: 
1:f1f9348:   private int lastSize;
1:8d8b589: 
1:f1f9348:   private long sizeToBeUsed;
1:8d8b589: 
1:f1f9348:   private MemoryBlock dataBlock;
1:8d8b589: 
1:f1f9348:   private boolean saveToDisk;
1:8d8b589: 
1:df22368:   private MemoryManagerType managerType;
1:8d8b589: 
1:df22368:   private long taskId;
1:8d8b589: 
1:2b41f14:   private TableFieldStat tableFieldStat;
1:2b41f14:   private SortStepRowHandler sortStepRowHandler;
1:f27efb3:   private boolean convertNoSortFields;
1:2b41f14: 
1:2b41f14:   public UnsafeCarbonRowPage(TableFieldStat tableFieldStat, MemoryBlock memoryBlock,
1:2b41f14:       boolean saveToDisk, long taskId) {
1:2b41f14:     this.tableFieldStat = tableFieldStat;
1:2b41f14:     this.sortStepRowHandler = new SortStepRowHandler(tableFieldStat);
1:f1f9348:     this.saveToDisk = saveToDisk;
1:df22368:     this.taskId = taskId;
1:df22368:     buffer = new IntPointerBuffer(this.taskId);
1:df22368:     this.dataBlock = memoryBlock;
1:f1f9348:     // TODO Only using 98% of space for safe side.May be we can have different logic.
1:f1f9348:     sizeToBeUsed = dataBlock.size() - (dataBlock.size() * 5) / 100;
1:df22368:     this.managerType = MemoryManagerType.UNSAFE_MEMORY_MANAGER;
5:8d8b589:   }
1:8d8b589: 
1:2b41f14:   public int addRow(Object[] row, ByteBuffer rowBuffer) {
1:2b41f14:     int size = addRow(row, dataBlock.getBaseOffset() + lastSize, rowBuffer);
1:f1f9348:     buffer.set(lastSize);
1:f1f9348:     lastSize = lastSize + size;
1:8d8b589:     return size;
1:8d8b589:   }
1:8d8b589: 
1:2b41f14:   /**
1:2b41f14:    * add raw row as intermidiate sort temp row to page
1:2b41f14:    *
1:2b41f14:    * @param row
1:2b41f14:    * @param address
1:2b41f14:    * @return
1:2b41f14:    */
1:2b41f14:   private int addRow(Object[] row, long address, ByteBuffer rowBuffer) {
1:2b41f14:     return sortStepRowHandler.writeRawRowAsIntermediateSortTempRowToUnsafeMemory(row,
1:2b41f14:         dataBlock.getBaseObject(), address, rowBuffer);
1:8d8b589:   }
1:8d8b589: 
1:2b41f14:   /**
1:2b41f14:    * get one row from memory address
1:2b41f14:    * @param address address
1:2b41f14:    * @return one row
1:2b41f14:    */
1:2b41f14:   public IntermediateSortTempRow getRow(long address) {
1:f27efb3:     if (convertNoSortFields) {
1:f27efb3:       return sortStepRowHandler
1:f27efb3:           .readRowFromMemoryWithNoSortFieldConvert(dataBlock.getBaseObject(), address);
1:f27efb3:     } else {
1:f27efb3:       return sortStepRowHandler
1:f27efb3:           .readFromMemoryWithoutNoSortFieldConvert(dataBlock.getBaseObject(), address);
1:f27efb3:     }
1:8d8b589:   }
1:8d8b589: 
1:2b41f14:   /**
1:2b41f14:    * write a row to stream
1:2b41f14:    * @param address address of a row
1:2b41f14:    * @param stream stream
1:2b41f14:    * @throws IOException
1:2b41f14:    */
1:2b41f14:   public void writeRow(long address, DataOutputStream stream) throws IOException {
1:2b41f14:     sortStepRowHandler.writeIntermediateSortTempRowFromUnsafeMemoryToStream(
1:2b41f14:         dataBlock.getBaseObject(), address, stream);
1:8d8b589:   }
1:8d8b589: 
1:f1f9348:   public void freeMemory() {
1:df22368:     switch (managerType) {
1:df22368:       case UNSAFE_MEMORY_MANAGER:
1:df22368:         UnsafeMemoryManager.INSTANCE.freeMemory(taskId, dataBlock);
2:8b3fa7f:         break;
1:06b0d08:       default:
1:df22368:         UnsafeSortMemoryManager.INSTANCE.freeMemory(taskId, dataBlock);
1:f1f9348:         buffer.freeMemory();
1:8d8b589:     }
1:8d8b589:   }
1:8d8b589: 
1:f1f9348:   public boolean isSaveToDisk() {
1:f1f9348:     return saveToDisk;
1:8d8b589:   }
1:8d8b589: 
1:f1f9348:   public IntPointerBuffer getBuffer() {
1:f1f9348:     return buffer;
1:8d8b589:   }
1:8d8b589: 
1:f1f9348:   public int getUsedSize() {
1:f1f9348:     return lastSize;
1:8d8b589:   }
1:8d8b589: 
1:f1f9348:   public boolean canAdd() {
1:f1f9348:     return lastSize < sizeToBeUsed;
1:8d8b589:   }
1:8d8b589: 
1:f1f9348:   public MemoryBlock getDataBlock() {
1:f1f9348:     return dataBlock;
1:8d8b589:   }
1:8d8b589: 
1:2b41f14:   public TableFieldStat getTableFieldStat() {
1:2b41f14:     return tableFieldStat;
1:8d8b589:   }
1:8d8b589: 
1:df22368:   public void setNewDataBlock(MemoryBlock newMemoryBlock) {
1:df22368:     this.dataBlock = newMemoryBlock;
1:df22368:     this.managerType = MemoryManagerType.UNSAFE_SORT_MEMORY_MANAGER;
1:8d8b589:   }
1:8d8b589: 
1:df22368:   public enum MemoryManagerType {
1:df22368:     UNSAFE_MEMORY_MANAGER, UNSAFE_SORT_MEMORY_MANAGER
1:8d8b589:   }
1:f27efb3: 
1:f27efb3:   public void setReadConvertedNoSortField() {
1:f27efb3:     this.convertNoSortFields = true;
1:f27efb3:   }
1:8d8b589: }
============================================================================
author:kumarvishal09
-------------------------------------------------------------------------------
commit:f27efb3
/////////////////////////////////////////////////////////////////////////
1:   private boolean convertNoSortFields;
/////////////////////////////////////////////////////////////////////////
1:     if (convertNoSortFields) {
1:       return sortStepRowHandler
1:           .readRowFromMemoryWithNoSortFieldConvert(dataBlock.getBaseObject(), address);
1:     } else {
1:       return sortStepRowHandler
1:           .readFromMemoryWithoutNoSortFieldConvert(dataBlock.getBaseObject(), address);
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:   public void setReadConvertedNoSortField() {
1:     this.convertNoSortFields = true;
1:   }
author:xuchuanyin
-------------------------------------------------------------------------------
commit:2b41f14
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
1: import org.apache.carbondata.processing.loading.row.IntermediateSortTempRow;
1: import org.apache.carbondata.processing.loading.sort.SortStepRowHandler;
1: import org.apache.carbondata.processing.sort.sortdata.TableFieldStat;
/////////////////////////////////////////////////////////////////////////
1:   private TableFieldStat tableFieldStat;
1:   private SortStepRowHandler sortStepRowHandler;
1: 
1:   public UnsafeCarbonRowPage(TableFieldStat tableFieldStat, MemoryBlock memoryBlock,
1:       boolean saveToDisk, long taskId) {
1:     this.tableFieldStat = tableFieldStat;
1:     this.sortStepRowHandler = new SortStepRowHandler(tableFieldStat);
/////////////////////////////////////////////////////////////////////////
1:   public int addRow(Object[] row, ByteBuffer rowBuffer) {
1:     int size = addRow(row, dataBlock.getBaseOffset() + lastSize, rowBuffer);
1:   /**
1:    * add raw row as intermidiate sort temp row to page
1:    *
1:    * @param row
1:    * @param address
1:    * @return
1:    */
1:   private int addRow(Object[] row, long address, ByteBuffer rowBuffer) {
1:     return sortStepRowHandler.writeRawRowAsIntermediateSortTempRowToUnsafeMemory(row,
1:         dataBlock.getBaseObject(), address, rowBuffer);
1:   /**
1:    * get one row from memory address
1:    * @param address address
1:    * @return one row
1:    */
1:   public IntermediateSortTempRow getRow(long address) {
0:     return sortStepRowHandler.readIntermediateSortTempRowFromUnsafeMemory(
0:         dataBlock.getBaseObject(), address);
1:   /**
1:    * write a row to stream
1:    * @param address address of a row
1:    * @param stream stream
1:    * @throws IOException
1:    */
1:   public void writeRow(long address, DataOutputStream stream) throws IOException {
1:     sortStepRowHandler.writeIntermediateSortTempRowFromUnsafeMemoryToStream(
1:         dataBlock.getBaseObject(), address, stream);
/////////////////////////////////////////////////////////////////////////
1:   public TableFieldStat getTableFieldStat() {
1:     return tableFieldStat;
commit:8d8b589
/////////////////////////////////////////////////////////////////////////
0: import java.math.BigDecimal;
0: import java.util.Arrays;
0: import org.apache.carbondata.core.memory.CarbonUnsafe;
0: import org.apache.carbondata.core.metadata.datatype.DataType;
0: import org.apache.carbondata.core.metadata.datatype.DataTypes;
0: import org.apache.carbondata.core.util.DataTypeUtil;
1: 
0:   private boolean[] noDictionaryDimensionMapping;
1: 
0:   private boolean[] noDictionarySortColumnMapping;
1: 
0:   private int dimensionSize;
1: 
0:   private int measureSize;
1: 
0:   private DataType[] measureDataType;
1: 
0:   private long[] nullSetWords;
1: 
/////////////////////////////////////////////////////////////////////////
0:   public UnsafeCarbonRowPage(boolean[] noDictionaryDimensionMapping,
0:       boolean[] noDictionarySortColumnMapping, int dimensionSize, int measureSize, DataType[] type,
0:       MemoryBlock memoryBlock, boolean saveToDisk, long taskId) {
0:     this.noDictionaryDimensionMapping = noDictionaryDimensionMapping;
0:     this.noDictionarySortColumnMapping = noDictionarySortColumnMapping;
0:     this.dimensionSize = dimensionSize;
0:     this.measureSize = measureSize;
0:     this.measureDataType = type;
0:     this.nullSetWords = new long[((measureSize - 1) >> 6) + 1];
/////////////////////////////////////////////////////////////////////////
0:   public int addRow(Object[] row) {
0:     int size = addRow(row, dataBlock.getBaseOffset() + lastSize);
0:   private int addRow(Object[] row, long address) {
0:     if (row == null) {
0:       throw new RuntimeException("Row is null ??");
1:     }
0:     int dimCount = 0;
0:     int size = 0;
0:     Object baseObject = dataBlock.getBaseObject();
0:     for (; dimCount < noDictionaryDimensionMapping.length; dimCount++) {
0:       if (noDictionaryDimensionMapping[dimCount]) {
0:         byte[] col = (byte[]) row[dimCount];
0:         CarbonUnsafe.getUnsafe()
0:             .putShort(baseObject, address + size, (short) col.length);
0:         size += 2;
0:         CarbonUnsafe.getUnsafe().copyMemory(col, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
0:             address + size, col.length);
0:         size += col.length;
0:       } else {
0:         int value = (int) row[dimCount];
0:         CarbonUnsafe.getUnsafe().putInt(baseObject, address + size, value);
0:         size += 4;
1:       }
1:     }
1: 
0:     // write complex dimensions here.
0:     for (; dimCount < dimensionSize; dimCount++) {
0:       byte[] col = (byte[]) row[dimCount];
0:       CarbonUnsafe.getUnsafe().putShort(baseObject, address + size, (short) col.length);
0:       size += 2;
0:       CarbonUnsafe.getUnsafe().copyMemory(col, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
0:           address + size, col.length);
0:       size += col.length;
1:     }
0:     Arrays.fill(nullSetWords, 0);
0:     int nullSetSize = nullSetWords.length * 8;
0:     int nullWordLoc = size;
0:     size += nullSetSize;
0:     for (int mesCount = 0; mesCount < measureSize; mesCount++) {
0:       Object value = row[mesCount + dimensionSize];
0:       if (null != value) {
0:         DataType dataType = measureDataType[mesCount];
0:         if (dataType == DataTypes.BOOLEAN) {
0:           Boolean bval = (Boolean) value;
0:           CarbonUnsafe.getUnsafe().putBoolean(baseObject, address + size, bval);
0:           size += 1;
0:         } else if (dataType == DataTypes.SHORT) {
0:           Short sval = (Short) value;
0:           CarbonUnsafe.getUnsafe().putShort(baseObject, address + size, sval);
0:           size += 2;
0:         } else if (dataType == DataTypes.INT) {
0:           Integer ival = (Integer) value;
0:           CarbonUnsafe.getUnsafe().putInt(baseObject, address + size, ival);
0:           size += 4;
0:         } else if (dataType == DataTypes.LONG) {
0:           Long val = (Long) value;
0:           CarbonUnsafe.getUnsafe().putLong(baseObject, address + size, val);
0:           size += 8;
0:         } else if (dataType == DataTypes.DOUBLE) {
0:           Double doubleVal = (Double) value;
0:           CarbonUnsafe.getUnsafe().putDouble(baseObject, address + size, doubleVal);
0:           size += 8;
0:         } else if (DataTypes.isDecimal(dataType)) {
0:           BigDecimal decimalVal = (BigDecimal) value;
0:           byte[] bigDecimalInBytes = DataTypeUtil.bigDecimalToByte(decimalVal);
0:           CarbonUnsafe.getUnsafe()
0:               .putShort(baseObject, address + size, (short) bigDecimalInBytes.length);
0:           size += 2;
0:           CarbonUnsafe.getUnsafe()
0:               .copyMemory(bigDecimalInBytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
0:                   address + size, bigDecimalInBytes.length);
0:           size += bigDecimalInBytes.length;
0:         } else {
0:           throw new IllegalArgumentException("unsupported data type:" + measureDataType[mesCount]);
1:         }
0:         set(nullSetWords, mesCount);
0:       } else {
0:         unset(nullSetWords, mesCount);
1:       }
1:     }
0:     CarbonUnsafe.getUnsafe().copyMemory(nullSetWords, CarbonUnsafe.LONG_ARRAY_OFFSET, baseObject,
0:         address + nullWordLoc, nullSetSize);
1:     return size;
0:   public Object[] getRow(long address, Object[] rowToFill) {
0:     int dimCount = 0;
0:     int size = 0;
1: 
0:     Object baseObject = dataBlock.getBaseObject();
0:     for (; dimCount < noDictionaryDimensionMapping.length; dimCount++) {
0:       if (noDictionaryDimensionMapping[dimCount]) {
0:         short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:         byte[] col = new byte[aShort];
0:         size += 2;
0:         CarbonUnsafe.getUnsafe()
0:             .copyMemory(baseObject, address + size, col, CarbonUnsafe.BYTE_ARRAY_OFFSET,
0:                 col.length);
0:         size += col.length;
0:         rowToFill[dimCount] = col;
0:       } else {
0:         int anInt = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:         size += 4;
0:         rowToFill[dimCount] = anInt;
1:       }
1:     }
1: 
0:     // write complex dimensions here.
0:     for (; dimCount < dimensionSize; dimCount++) {
0:       short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:       byte[] col = new byte[aShort];
0:       size += 2;
0:       CarbonUnsafe.getUnsafe()
0:           .copyMemory(baseObject, address + size, col, CarbonUnsafe.BYTE_ARRAY_OFFSET, col.length);
0:       size += col.length;
0:       rowToFill[dimCount] = col;
1:     }
1: 
0:     int nullSetSize = nullSetWords.length * 8;
0:     Arrays.fill(nullSetWords, 0);
0:     CarbonUnsafe.getUnsafe()
0:         .copyMemory(baseObject, address + size, nullSetWords, CarbonUnsafe.LONG_ARRAY_OFFSET,
0:             nullSetSize);
0:     size += nullSetSize;
1: 
0:     for (int mesCount = 0; mesCount < measureSize; mesCount++) {
0:       if (isSet(nullSetWords, mesCount)) {
0:         DataType dataType = measureDataType[mesCount];
0:         if (dataType == DataTypes.BOOLEAN) {
0:           Boolean bval = CarbonUnsafe.getUnsafe().getBoolean(baseObject, address + size);
0:           size += 1;
0:           rowToFill[dimensionSize + mesCount] = bval;
0:         } else if (dataType == DataTypes.SHORT) {
0:           Short sval = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:           size += 2;
0:           rowToFill[dimensionSize + mesCount] = sval;
0:         } else if (dataType == DataTypes.INT) {
0:           Integer ival = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:           size += 4;
0:           rowToFill[dimensionSize + mesCount] = ival;
0:         } else if (dataType == DataTypes.LONG) {
0:           Long val = CarbonUnsafe.getUnsafe().getLong(baseObject, address + size);
0:           size += 8;
0:           rowToFill[dimensionSize + mesCount] = val;
0:         } else if (dataType == DataTypes.DOUBLE) {
0:           Double doubleVal = CarbonUnsafe.getUnsafe().getDouble(baseObject, address + size);
0:           size += 8;
0:           rowToFill[dimensionSize + mesCount] = doubleVal;
0:         } else if (DataTypes.isDecimal(dataType)) {
0:           short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:           byte[] bigDecimalInBytes = new byte[aShort];
0:           size += 2;
0:           CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size, bigDecimalInBytes,
0:               CarbonUnsafe.BYTE_ARRAY_OFFSET, bigDecimalInBytes.length);
0:           size += bigDecimalInBytes.length;
0:           rowToFill[dimensionSize + mesCount] = DataTypeUtil.byteToBigDecimal(bigDecimalInBytes);
0:         } else {
0:           throw new IllegalArgumentException("unsupported data type:" + measureDataType[mesCount]);
1:         }
0:       } else {
0:         rowToFill[dimensionSize + mesCount] = null;
1:       }
1:     }
0:     return rowToFill;
0:   public void fillRow(long address, DataOutputStream stream) throws IOException {
0:     int dimCount = 0;
0:     int size = 0;
1: 
0:     Object baseObject = dataBlock.getBaseObject();
0:     for (; dimCount < noDictionaryDimensionMapping.length; dimCount++) {
0:       if (noDictionaryDimensionMapping[dimCount]) {
0:         short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:         byte[] col = new byte[aShort];
0:         size += 2;
0:         CarbonUnsafe.getUnsafe()
0:             .copyMemory(baseObject, address + size, col, CarbonUnsafe.BYTE_ARRAY_OFFSET,
0:                 col.length);
0:         size += col.length;
0:         stream.writeShort(aShort);
0:         stream.write(col);
0:       } else {
0:         int anInt = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:         size += 4;
0:         stream.writeInt(anInt);
1:       }
1:     }
1: 
0:     // write complex dimensions here.
0:     for (; dimCount < dimensionSize; dimCount++) {
0:       short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:       byte[] col = new byte[aShort];
0:       size += 2;
0:       CarbonUnsafe.getUnsafe()
0:           .copyMemory(baseObject, address + size, col, CarbonUnsafe.BYTE_ARRAY_OFFSET, col.length);
0:       size += col.length;
0:       stream.writeShort(aShort);
0:       stream.write(col);
1:     }
1: 
0:     int nullSetSize = nullSetWords.length * 8;
0:     Arrays.fill(nullSetWords, 0);
0:     CarbonUnsafe.getUnsafe()
0:         .copyMemory(baseObject, address + size, nullSetWords, CarbonUnsafe.LONG_ARRAY_OFFSET,
0:             nullSetSize);
0:     size += nullSetSize;
0:     for (int i = 0; i < nullSetWords.length; i++) {
0:       stream.writeLong(nullSetWords[i]);
1:     }
1: 
0:     for (int mesCount = 0; mesCount < measureSize; mesCount++) {
0:       if (isSet(nullSetWords, mesCount)) {
0:         DataType dataType = measureDataType[mesCount];
0:         if (dataType == DataTypes.SHORT) {
0:           short sval = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:           size += 2;
0:           stream.writeShort(sval);
0:         } else if (dataType == DataTypes.INT) {
0:           int ival = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:           size += 4;
0:           stream.writeInt(ival);
0:         } else if (dataType == DataTypes.LONG) {
0:           long val = CarbonUnsafe.getUnsafe().getLong(baseObject, address + size);
0:           size += 8;
0:           stream.writeLong(val);
0:         } else if (dataType == DataTypes.DOUBLE) {
0:           double doubleVal = CarbonUnsafe.getUnsafe().getDouble(baseObject, address + size);
0:           size += 8;
0:           stream.writeDouble(doubleVal);
0:         } else if (DataTypes.isDecimal(dataType)) {
0:           short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:           byte[] bigDecimalInBytes = new byte[aShort];
0:           size += 2;
0:           CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size, bigDecimalInBytes,
0:               CarbonUnsafe.BYTE_ARRAY_OFFSET, bigDecimalInBytes.length);
0:           size += bigDecimalInBytes.length;
0:           stream.writeShort(aShort);
0:           stream.write(bigDecimalInBytes);
0:         } else {
0:           throw new IllegalArgumentException("unsupported data type:" + measureDataType[mesCount]);
1:         }
1:       }
1:     }
/////////////////////////////////////////////////////////////////////////
0:   public static void set(long[] words, int index) {
0:     int wordOffset = (index >> 6);
0:     words[wordOffset] |= (1L << index);
0:   }
1: 
0:   public static void unset(long[] words, int index) {
0:     int wordOffset = (index >> 6);
0:     words[wordOffset] &= ~(1L << index);
0:   }
1: 
0:   public static boolean isSet(long[] words, int index) {
0:     int wordOffset = (index >> 6);
0:     return ((words[wordOffset] & (1L << index)) != 0);
0:   }
1: 
0:   public boolean[] getNoDictionaryDimensionMapping() {
0:     return noDictionaryDimensionMapping;
0:   }
1: 
0:   public boolean[] getNoDictionarySortColumnMapping() {
0:     return noDictionarySortColumnMapping;
commit:21704cf
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: import org.apache.carbondata.processing.loading.row.IntermediateSortTempRow;
0: import org.apache.carbondata.processing.loading.sort.SortStepRowHandler;
0: import org.apache.carbondata.processing.sort.sortdata.TableFieldStat;
/////////////////////////////////////////////////////////////////////////
0:   private TableFieldStat tableFieldStat;
0:   private SortStepRowHandler sortStepRowHandler;
1: 
0:   public UnsafeCarbonRowPage(TableFieldStat tableFieldStat, MemoryBlock memoryBlock,
0:       boolean saveToDisk, long taskId) {
0:     this.tableFieldStat = tableFieldStat;
0:     this.sortStepRowHandler = new SortStepRowHandler(tableFieldStat);
/////////////////////////////////////////////////////////////////////////
0:   public int addRow(Object[] row, ByteBuffer rowBuffer) {
0:     int size = addRow(row, dataBlock.getBaseOffset() + lastSize, rowBuffer);
1:   /**
0:    * add raw row as intermidiate sort temp row to page
1:    *
0:    * @param row
0:    * @param address
0:    * @return
1:    */
0:   private int addRow(Object[] row, long address, ByteBuffer rowBuffer) {
0:     return sortStepRowHandler.writeRawRowAsIntermediateSortTempRowToUnsafeMemory(row,
0:         dataBlock.getBaseObject(), address, rowBuffer);
1:   /**
0:    * get one row from memory address
0:    * @param address address
0:    * @return one row
1:    */
0:   public IntermediateSortTempRow getRow(long address) {
0:     return sortStepRowHandler.readIntermediateSortTempRowFromUnsafeMemory(
0:         dataBlock.getBaseObject(), address);
1:   /**
0:    * write a row to stream
0:    * @param address address of a row
0:    * @param stream stream
0:    * @throws IOException
1:    */
0:   public void writeRow(long address, DataOutputStream stream) throws IOException {
0:     sortStepRowHandler.writeIntermediateSortTempRowFromUnsafeMemoryToStream(
0:         dataBlock.getBaseObject(), address, stream);
/////////////////////////////////////////////////////////////////////////
0:   public TableFieldStat getTableFieldStat() {
0:     return tableFieldStat;
author:Jacky Li
-------------------------------------------------------------------------------
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
0:         } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
0:         } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
0:         } else if (DataTypes.isDecimal(dataType)) {
commit:956833e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
0:         DataType dataType = measureDataType[mesCount];
0:         if (dataType == DataTypes.SHORT) {
0:           Short sval = (Short) value;
0:           CarbonUnsafe.getUnsafe().putShort(baseObject, address + size, sval);
0:           size += 2;
0:         } else if (dataType == DataTypes.INT) {
0:           Integer ival = (Integer) value;
0:           CarbonUnsafe.getUnsafe().putInt(baseObject, address + size, ival);
0:           size += 4;
0:         } else if (dataType == DataTypes.LONG) {
0:           Long val = (Long) value;
0:           CarbonUnsafe.getUnsafe().putLong(baseObject, address + size, val);
0:           size += 8;
0:         } else if (dataType == DataTypes.DOUBLE) {
0:           Double doubleVal = (Double) value;
0:           CarbonUnsafe.getUnsafe().putDouble(baseObject, address + size, doubleVal);
0:           size += 8;
0:         } else if (dataType == DataTypes.DECIMAL) {
0:           BigDecimal decimalVal = (BigDecimal) value;
0:           byte[] bigDecimalInBytes = DataTypeUtil.bigDecimalToByte(decimalVal);
0:           CarbonUnsafe.getUnsafe()
0:               .putShort(baseObject, address + size, (short) bigDecimalInBytes.length);
0:           size += 2;
0:           CarbonUnsafe.getUnsafe()
0:               .copyMemory(bigDecimalInBytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
0:                   address + size, bigDecimalInBytes.length);
0:           size += bigDecimalInBytes.length;
0:         } else {
0:           throw new IllegalArgumentException("unsupported data type:" + measureDataType[mesCount]);
/////////////////////////////////////////////////////////////////////////
0:         DataType dataType = measureDataType[mesCount];
0:         if (dataType == DataTypes.SHORT) {
0:           Short sval = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:           size += 2;
0:           rowToFill[dimensionSize + mesCount] = sval;
0:         } else if (dataType == DataTypes.INT) {
0:           Integer ival = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:           size += 4;
0:           rowToFill[dimensionSize + mesCount] = ival;
0:         } else if (dataType == DataTypes.LONG) {
0:           Long val = CarbonUnsafe.getUnsafe().getLong(baseObject, address + size);
0:           size += 8;
0:           rowToFill[dimensionSize + mesCount] = val;
0:         } else if (dataType == DataTypes.DOUBLE) {
0:           Double doubleVal = CarbonUnsafe.getUnsafe().getDouble(baseObject, address + size);
0:           size += 8;
0:           rowToFill[dimensionSize + mesCount] = doubleVal;
0:         } else if (dataType == DataTypes.DECIMAL) {
0:           short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:           byte[] bigDecimalInBytes = new byte[aShort];
0:           size += 2;
0:           CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size, bigDecimalInBytes,
0:               CarbonUnsafe.BYTE_ARRAY_OFFSET, bigDecimalInBytes.length);
0:           size += bigDecimalInBytes.length;
0:           rowToFill[dimensionSize + mesCount] = DataTypeUtil.byteToBigDecimal(bigDecimalInBytes);
0:         } else {
0:           throw new IllegalArgumentException("unsupported data type:" + measureDataType[mesCount]);
/////////////////////////////////////////////////////////////////////////
0:         DataType dataType = measureDataType[mesCount];
0:         if (dataType == DataTypes.SHORT) {
0:           short sval = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:           size += 2;
0:           stream.writeShort(sval);
0:         } else if (dataType == DataTypes.INT) {
0:           int ival = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:           size += 4;
0:           stream.writeInt(ival);
0:         } else if (dataType == DataTypes.LONG) {
0:           long val = CarbonUnsafe.getUnsafe().getLong(baseObject, address + size);
0:           size += 8;
0:           stream.writeLong(val);
0:         } else if (dataType == DataTypes.DOUBLE) {
0:           double doubleVal = CarbonUnsafe.getUnsafe().getDouble(baseObject, address + size);
0:           size += 8;
0:           stream.writeDouble(doubleVal);
0:         } else if (dataType == DataTypes.DECIMAL) {
0:           short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:           byte[] bigDecimalInBytes = new byte[aShort];
0:           size += 2;
0:           CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size, bigDecimalInBytes,
0:               CarbonUnsafe.BYTE_ARRAY_OFFSET, bigDecimalInBytes.length);
0:           size += bigDecimalInBytes.length;
0:           stream.writeShort(aShort);
0:           stream.write(bigDecimalInBytes);
0:         } else {
0:           throw new IllegalArgumentException("unsupported data type:" + measureDataType[mesCount]);
commit:349c59c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.carbondata.processing.loading.sort.unsafe;
author:xubo245
-------------------------------------------------------------------------------
commit:6abdd97
/////////////////////////////////////////////////////////////////////////
0:         if (dataType == DataTypes.BOOLEAN) {
0:           Boolean bval = (Boolean) value;
0:           CarbonUnsafe.getUnsafe().putBoolean(baseObject, address + size, bval);
0:           size += 1;
0:         } else if (dataType == DataTypes.SHORT) {
/////////////////////////////////////////////////////////////////////////
0:         if (dataType == DataTypes.BOOLEAN) {
0:           Boolean bval = CarbonUnsafe.getUnsafe().getBoolean(baseObject, address + size);
0:           size += 1;
0:           rowToFill[dimensionSize + mesCount] = bval;
0:         } else if (dataType == DataTypes.SHORT) {
author:Raghunandan S
-------------------------------------------------------------------------------
commit:06b0d08
/////////////////////////////////////////////////////////////////////////
1:           default:
0:             throw  new IllegalArgumentException("unsupported data type:" +
0:                 measureDataType[mesCount]);
/////////////////////////////////////////////////////////////////////////
0:           default:
0:             throw new IllegalArgumentException("unsupported data type:" +
0:                 measureDataType[mesCount]);
/////////////////////////////////////////////////////////////////////////
0:           default:
0:             throw new IllegalArgumentException("unsupported data type:" +
0:                 measureDataType[mesCount]);
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
0:         CarbonUnsafe.getUnsafe()
0:         CarbonUnsafe.getUnsafe().copyMemory(col, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
0:         CarbonUnsafe.getUnsafe().putInt(baseObject, address + size, value);
/////////////////////////////////////////////////////////////////////////
0:       CarbonUnsafe.getUnsafe().putShort(baseObject, address + size, (short) col.length);
0:       CarbonUnsafe.getUnsafe().copyMemory(col, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
/////////////////////////////////////////////////////////////////////////
0:             CarbonUnsafe.getUnsafe().putShort(baseObject, address + size, sval);
0:             CarbonUnsafe.getUnsafe().putInt(baseObject, address + size, ival);
0:             CarbonUnsafe.getUnsafe().putLong(baseObject, address + size, val);
0:             CarbonUnsafe.getUnsafe().putDouble(baseObject, address + size, doubleVal);
0:             CarbonUnsafe.getUnsafe().putShort(baseObject, address + size,
0:             CarbonUnsafe.getUnsafe()
/////////////////////////////////////////////////////////////////////////
0:     CarbonUnsafe.getUnsafe().copyMemory(nullSetWords, CarbonUnsafe.LONG_ARRAY_OFFSET, baseObject,
/////////////////////////////////////////////////////////////////////////
0:         short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:         CarbonUnsafe.getUnsafe()
0:         int anInt = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
/////////////////////////////////////////////////////////////////////////
0:       short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:       CarbonUnsafe.getUnsafe()
/////////////////////////////////////////////////////////////////////////
0:     CarbonUnsafe.getUnsafe()
/////////////////////////////////////////////////////////////////////////
0:             Short sval = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:             Integer ival = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:             Long val = CarbonUnsafe.getUnsafe().getLong(baseObject, address + size);
0:             Double doubleVal = CarbonUnsafe.getUnsafe().getDouble(baseObject, address + size);
0:             short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:             CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size, bigDecimalInBytes,
/////////////////////////////////////////////////////////////////////////
0:         short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:         CarbonUnsafe.getUnsafe()
0:         int anInt = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
/////////////////////////////////////////////////////////////////////////
0:       short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:       CarbonUnsafe.getUnsafe()
/////////////////////////////////////////////////////////////////////////
0:     CarbonUnsafe.getUnsafe()
/////////////////////////////////////////////////////////////////////////
0:             short sval = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:             int ival = CarbonUnsafe.getUnsafe().getInt(baseObject, address + size);
0:             long val = CarbonUnsafe.getUnsafe().getLong(baseObject, address + size);
0:             double doubleVal = CarbonUnsafe.getUnsafe().getDouble(baseObject, address + size);
0:             short aShort = CarbonUnsafe.getUnsafe().getShort(baseObject, address + size);
0:             CarbonUnsafe.getUnsafe().copyMemory(baseObject, address + size, bigDecimalInBytes,
author:ravipesala
-------------------------------------------------------------------------------
commit:9e064ee
/////////////////////////////////////////////////////////////////////////
0:             rowToFill[dimensionSize + mesCount] = DataTypeUtil.byteToBigDecimal(bigDecimalInBytes);
commit:8b3fa7f
/////////////////////////////////////////////////////////////////////////
0:             Short sval = (Short) value;
0:             CarbonUnsafe.unsafe.putShort(baseObject, address + size, sval);
0:             size += 2;
1:             break;
0:             Integer ival = (Integer) value;
0:             CarbonUnsafe.unsafe.putInt(baseObject, address + size, ival);
0:             size += 4;
1:             break;
/////////////////////////////////////////////////////////////////////////
0:             Short sval = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:             size += 2;
0:             rowToFill[dimensionSize + mesCount] = sval;
0:             break;
0:             Integer ival = CarbonUnsafe.unsafe.getInt(baseObject, address + size);
0:             size += 4;
0:             rowToFill[dimensionSize + mesCount] = ival;
0:             break;
/////////////////////////////////////////////////////////////////////////
0:             short sval = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:             size += 2;
0:             stream.writeShort(sval);
0:             break;
0:             int ival = CarbonUnsafe.unsafe.getInt(baseObject, address + size);
0:             size += 4;
0:             stream.writeInt(ival);
0:             break;
commit:b13ead9
/////////////////////////////////////////////////////////////////////////
0:   public int addRow(Object[] row) {
0:     return size;
commit:aca59ce
/////////////////////////////////////////////////////////////////////////
0:           rowToFill[dimensionSize + mesCount] = bigDecimalInBytes;
commit:f1f9348
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: package org.apache.carbondata.processing.newflow.sort.unsafe;
1: 
1: import java.io.DataOutputStream;
1: import java.io.IOException;
0: import java.math.BigDecimal;
0: import java.util.Arrays;
0: import java.util.Iterator;
1: 
0: import org.apache.carbondata.common.CarbonIterator;
0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.memory.MemoryBlock;
0: import org.apache.carbondata.core.unsafe.CarbonUnsafe;
0: import org.apache.carbondata.core.util.DataTypeUtil;
1: 
0: /**
1:  * It can keep the data of prescribed size data in offheap/onheap memory and returns it when needed
0:  */
1: public class UnsafeCarbonRowPage {
1: 
0:   private boolean[] noDictionaryDimensionMapping;
1: 
0:   private int dimensionSize;
1: 
0:   private int measureSize;
1: 
0:   private char[] aggType;
1: 
0:   private long[] nullSetWords;
1: 
1:   private IntPointerBuffer buffer;
1: 
1:   private int lastSize;
1: 
1:   private long sizeToBeUsed;
1: 
1:   private MemoryBlock dataBlock;
1: 
1:   private boolean saveToDisk;
1: 
0:   public UnsafeCarbonRowPage(boolean[] noDictionaryDimensionMapping, int dimensionSize,
0:       int measureSize, char[] aggType, MemoryBlock memoryBlock, boolean saveToDisk) {
0:     this.noDictionaryDimensionMapping = noDictionaryDimensionMapping;
0:     this.dimensionSize = dimensionSize;
0:     this.measureSize = measureSize;
0:     this.aggType = aggType;
1:     this.saveToDisk = saveToDisk;
0:     this.nullSetWords = new long[((measureSize - 1) >> 6) + 1];
0:     buffer = new IntPointerBuffer(memoryBlock);
0:     this.dataBlock = buffer.getBaseBlock();
1:     // TODO Only using 98% of space for safe side.May be we can have different logic.
1:     sizeToBeUsed = dataBlock.size() - (dataBlock.size() * 5) / 100;
0:   }
1: 
0:   public void addRow(Object[] row) {
0:     int size = addRow(row, dataBlock.getBaseOffset() + lastSize);
1:     buffer.set(lastSize);
1:     lastSize = lastSize + size;
0:   }
1: 
0:   public Iterator<Object[]> getIterator() {
0:     return new UnsafeIterator();
0:   }
1: 
0:   private int addRow(Object[] row, long address) {
0:     if (row == null) {
0:       throw new RuntimeException("Row is null ??");
0:     }
0:     int dimCount = 0;
0:     int size = 0;
0:     Object baseObject = dataBlock.getBaseObject();
0:     for (; dimCount < noDictionaryDimensionMapping.length; dimCount++) {
0:       if (noDictionaryDimensionMapping[dimCount]) {
0:         byte[] col = (byte[]) row[dimCount];
0:         CarbonUnsafe.unsafe
0:             .putShort(baseObject, address + size, (short) col.length);
0:         size += 2;
0:         CarbonUnsafe.unsafe.copyMemory(col, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
0:             address + size, col.length);
0:         size += col.length;
0:       } else {
0:         int value = (int) row[dimCount];
0:         CarbonUnsafe.unsafe.putInt(baseObject, address + size, value);
0:         size += 4;
0:       }
0:     }
1: 
0:     // write complex dimensions here.
0:     for (; dimCount < dimensionSize; dimCount++) {
0:       byte[] col = (byte[]) row[dimCount];
0:       CarbonUnsafe.unsafe.putShort(baseObject, address + size, (short) col.length);
0:       size += 2;
0:       CarbonUnsafe.unsafe.copyMemory(col, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
0:           address + size, col.length);
0:       size += col.length;
0:     }
0:     Arrays.fill(nullSetWords, 0);
0:     int nullSetSize = nullSetWords.length * 8;
0:     int nullWordLoc = size;
0:     size += nullSetSize;
0:     for (int mesCount = 0; mesCount < measureSize; mesCount++) {
0:       Object value = row[mesCount + dimensionSize];
0:       if (null != value) {
0:         if (aggType[mesCount] == CarbonCommonConstants.SUM_COUNT_VALUE_MEASURE) {
0:           Double val = (Double) value;
0:           CarbonUnsafe.unsafe.putDouble(baseObject, address + size, val);
0:           size += 8;
0:         } else if (aggType[mesCount] == CarbonCommonConstants.BIG_INT_MEASURE) {
0:           Long val = (Long) value;
0:           CarbonUnsafe.unsafe.putLong(baseObject, address + size, val);
0:           size += 8;
0:         } else if (aggType[mesCount] == CarbonCommonConstants.BIG_DECIMAL_MEASURE) {
0:           BigDecimal val = (BigDecimal) value;
0:           byte[] bigDecimalInBytes = DataTypeUtil.bigDecimalToByte(val);
0:           CarbonUnsafe.unsafe.putShort(baseObject, address + size,
0:               (short) bigDecimalInBytes.length);
0:           size += 2;
0:           CarbonUnsafe.unsafe
0:               .copyMemory(bigDecimalInBytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
0:                   address + size, bigDecimalInBytes.length);
0:           size += bigDecimalInBytes.length;
0:         }
0:         set(nullSetWords, mesCount);
0:       } else {
0:         unset(nullSetWords, mesCount);
0:       }
0:     }
0:     CarbonUnsafe.unsafe.copyMemory(nullSetWords, CarbonUnsafe.LONG_ARRAY_OFFSET, baseObject,
0:         address + nullWordLoc, nullSetSize);
0:     return size;
0:   }
1: 
0:   public Object[] getRow(long address, Object[] rowToFill) {
0:     int dimCount = 0;
0:     int size = 0;
1: 
0:     Object baseObject = dataBlock.getBaseObject();
0:     for (; dimCount < noDictionaryDimensionMapping.length; dimCount++) {
0:       if (noDictionaryDimensionMapping[dimCount]) {
0:         short aShort = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:         byte[] col = new byte[aShort];
0:         size += 2;
0:         CarbonUnsafe.unsafe
0:             .copyMemory(baseObject, address + size, col, CarbonUnsafe.BYTE_ARRAY_OFFSET,
0:                 col.length);
0:         size += col.length;
0:         rowToFill[dimCount] = col;
0:       } else {
0:         int anInt = CarbonUnsafe.unsafe.getInt(baseObject, address + size);
0:         size += 4;
0:         rowToFill[dimCount] = anInt;
0:       }
0:     }
1: 
0:     // write complex dimensions here.
0:     for (; dimCount < dimensionSize; dimCount++) {
0:       short aShort = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:       byte[] col = new byte[aShort];
0:       size += 2;
0:       CarbonUnsafe.unsafe
0:           .copyMemory(baseObject, address + size, col, CarbonUnsafe.BYTE_ARRAY_OFFSET, col.length);
0:       size += col.length;
0:       rowToFill[dimCount] = col;
0:     }
1: 
0:     int nullSetSize = nullSetWords.length * 8;
0:     Arrays.fill(nullSetWords, 0);
0:     CarbonUnsafe.unsafe
0:         .copyMemory(baseObject, address + size, nullSetWords, CarbonUnsafe.LONG_ARRAY_OFFSET,
0:             nullSetSize);
0:     size += nullSetSize;
1: 
0:     for (int mesCount = 0; mesCount < measureSize; mesCount++) {
0:       if (isSet(nullSetWords, mesCount)) {
0:         if (aggType[mesCount] == CarbonCommonConstants.SUM_COUNT_VALUE_MEASURE) {
0:           Double val = CarbonUnsafe.unsafe.getDouble(baseObject, address + size);
0:           size += 8;
0:           rowToFill[dimensionSize + mesCount] = val;
0:         } else if (aggType[mesCount] == CarbonCommonConstants.BIG_INT_MEASURE) {
0:           Long val = CarbonUnsafe.unsafe.getLong(baseObject, address + size);
0:           size += 8;
0:           rowToFill[dimensionSize + mesCount] = val;
0:         } else if (aggType[mesCount] == CarbonCommonConstants.BIG_DECIMAL_MEASURE) {
0:           short aShort = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:           byte[] bigDecimalInBytes = new byte[aShort];
0:           size += 2;
0:           CarbonUnsafe.unsafe.copyMemory(baseObject, address + size, bigDecimalInBytes,
0:               CarbonUnsafe.BYTE_ARRAY_OFFSET, bigDecimalInBytes.length);
0:           BigDecimal val = DataTypeUtil.byteToBigDecimal(bigDecimalInBytes);
0:           size += bigDecimalInBytes.length;
0:           rowToFill[dimensionSize + mesCount] = val;
0:         }
0:       } else {
0:         rowToFill[dimensionSize + mesCount] = null;
0:       }
0:     }
0:     return rowToFill;
0:   }
1: 
0:   public void fillRow(long address, DataOutputStream stream) throws IOException {
0:     int dimCount = 0;
0:     int size = 0;
1: 
0:     Object baseObject = dataBlock.getBaseObject();
0:     for (; dimCount < noDictionaryDimensionMapping.length; dimCount++) {
0:       if (noDictionaryDimensionMapping[dimCount]) {
0:         short aShort = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:         byte[] col = new byte[aShort];
0:         size += 2;
0:         CarbonUnsafe.unsafe
0:             .copyMemory(baseObject, address + size, col, CarbonUnsafe.BYTE_ARRAY_OFFSET,
0:                 col.length);
0:         size += col.length;
0:         stream.writeShort(aShort);
0:         stream.write(col);
0:       } else {
0:         int anInt = CarbonUnsafe.unsafe.getInt(baseObject, address + size);
0:         size += 4;
0:         stream.writeInt(anInt);
0:       }
0:     }
1: 
0:     // write complex dimensions here.
0:     for (; dimCount < dimensionSize; dimCount++) {
0:       short aShort = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:       byte[] col = new byte[aShort];
0:       size += 2;
0:       CarbonUnsafe.unsafe
0:           .copyMemory(baseObject, address + size, col, CarbonUnsafe.BYTE_ARRAY_OFFSET, col.length);
0:       size += col.length;
0:       stream.writeShort(aShort);
0:       stream.write(col);
0:     }
1: 
0:     int nullSetSize = nullSetWords.length * 8;
0:     Arrays.fill(nullSetWords, 0);
0:     CarbonUnsafe.unsafe
0:         .copyMemory(baseObject, address + size, nullSetWords, CarbonUnsafe.LONG_ARRAY_OFFSET,
0:             nullSetSize);
0:     size += nullSetSize;
0:     for (int i = 0; i < nullSetWords.length; i++) {
0:       stream.writeLong(nullSetWords[i]);
0:     }
1: 
0:     for (int mesCount = 0; mesCount < measureSize; mesCount++) {
0:       if (isSet(nullSetWords, mesCount)) {
0:         if (aggType[mesCount] == CarbonCommonConstants.SUM_COUNT_VALUE_MEASURE) {
0:           double val = CarbonUnsafe.unsafe.getDouble(baseObject, address + size);
0:           size += 8;
0:           stream.writeDouble(val);
0:         } else if (aggType[mesCount] == CarbonCommonConstants.BIG_INT_MEASURE) {
0:           long val = CarbonUnsafe.unsafe.getLong(baseObject, address + size);
0:           size += 8;
0:           stream.writeLong(val);
0:         } else if (aggType[mesCount] == CarbonCommonConstants.BIG_DECIMAL_MEASURE) {
0:           short aShort = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:           byte[] bigDecimalInBytes = new byte[aShort];
0:           size += 2;
0:           CarbonUnsafe.unsafe.copyMemory(baseObject, address + size, bigDecimalInBytes,
0:               CarbonUnsafe.BYTE_ARRAY_OFFSET, bigDecimalInBytes.length);
0:           size += bigDecimalInBytes.length;
0:           stream.writeShort(aShort);
0:           stream.write(bigDecimalInBytes);
0:         }
0:       }
0:     }
0:   }
1: 
0:   private Object[] getRow(long address) {
0:     Object[] row = new Object[dimensionSize + measureSize];
0:     return getRow(address, row);
0:   }
1: 
1:   public void freeMemory() {
1:     buffer.freeMemory();
0:   }
1: 
1:   public boolean isSaveToDisk() {
1:     return saveToDisk;
0:   }
1: 
1:   public IntPointerBuffer getBuffer() {
1:     return buffer;
0:   }
1: 
1:   public int getUsedSize() {
1:     return lastSize;
0:   }
1: 
1:   public boolean canAdd() {
1:     return lastSize < sizeToBeUsed;
0:   }
1: 
1:   public MemoryBlock getDataBlock() {
1:     return dataBlock;
0:   }
1: 
0:   class UnsafeIterator extends CarbonIterator<Object[]> {
1: 
0:     private int counter;
1: 
0:     private int actualSize;
1: 
0:     public UnsafeIterator() {
0:       this.actualSize = buffer.getActualSize();
0:     }
1: 
0:     @Override public boolean hasNext() {
0:       if (counter < actualSize) {
0:         return true;
0:       }
0:       return false;
0:     }
1: 
0:     @Override public Object[] next() {
0:       long address = buffer.get(counter);
0:       counter++;
0:       return getRow(address + dataBlock.getBaseOffset());
0:     }
0:   }
1: 
0:   public static void set(long[] words, int index) {
0:     int wordOffset = (index >> 6);
0:     words[wordOffset] |= (1L << index);
0:   }
1: 
0:   public static void unset(long[] words, int index) {
0:     int wordOffset = (index >> 6);
0:     words[wordOffset] &= ~(1L << index);
0:   }
1: 
0:   public static boolean isSet(long[] words, int index) {
0:     int wordOffset = (index >> 6);
0:     return ((words[wordOffset] & (1L << index)) != 0);
0:   }
1: 
0:   public boolean[] getNoDictionaryDimensionMapping() {
0:     return noDictionaryDimensionMapping;
0:   }
1: 
0: }
author:kumarvishal
-------------------------------------------------------------------------------
commit:df22368
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.memory.UnsafeMemoryManager;
1: import org.apache.carbondata.core.memory.UnsafeSortMemoryManager;
/////////////////////////////////////////////////////////////////////////
1:   private MemoryManagerType managerType;
0: 
1:   private long taskId;
0: 
0:       MemoryBlock memoryBlock, boolean saveToDisk, long taskId) {
/////////////////////////////////////////////////////////////////////////
1:     this.taskId = taskId;
1:     buffer = new IntPointerBuffer(this.taskId);
1:     this.dataBlock = memoryBlock;
1:     this.managerType = MemoryManagerType.UNSAFE_MEMORY_MANAGER;
/////////////////////////////////////////////////////////////////////////
1:     switch (managerType) {
1:       case UNSAFE_MEMORY_MANAGER:
1:         UnsafeMemoryManager.INSTANCE.freeMemory(taskId, dataBlock);
0:         break;
0:       default:
1:         UnsafeSortMemoryManager.INSTANCE.freeMemory(taskId, dataBlock);
0:         buffer.freeMemory();
0:     }
/////////////////////////////////////////////////////////////////////////
0: 
1:   public void setNewDataBlock(MemoryBlock newMemoryBlock) {
1:     this.dataBlock = newMemoryBlock;
1:     this.managerType = MemoryManagerType.UNSAFE_SORT_MEMORY_MANAGER;
0:   }
0: 
1:   public enum MemoryManagerType {
1:     UNSAFE_MEMORY_MANAGER, UNSAFE_SORT_MEMORY_MANAGER
0:   }
author:jackylk
-------------------------------------------------------------------------------
commit:edda248
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.memory.IntPointerBuffer;
commit:98df130
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.datatype.DataType;
/////////////////////////////////////////////////////////////////////////
0:   private DataType[] measureDataType;
/////////////////////////////////////////////////////////////////////////
0:       boolean[] noDictionarySortColumnMapping, int dimensionSize, int measureSize, DataType[] type,
0:     this.measureDataType = type;
/////////////////////////////////////////////////////////////////////////
0:         switch (measureDataType[mesCount]) {
0:           case SHORT:
0:           case INT:
0:           case LONG:
0:             Long val = (Long) value;
0:             CarbonUnsafe.unsafe.putLong(baseObject, address + size, val);
0:             size += 8;
0:             break;
0:           case DOUBLE:
0:             Double doubleVal = (Double) value;
0:             CarbonUnsafe.unsafe.putDouble(baseObject, address + size, doubleVal);
0:             size += 8;
0:             break;
0:           case DECIMAL:
0:             BigDecimal decimalVal = (BigDecimal) value;
0:             byte[] bigDecimalInBytes = DataTypeUtil.bigDecimalToByte(decimalVal);
0:             CarbonUnsafe.unsafe.putShort(baseObject, address + size,
0:                 (short) bigDecimalInBytes.length);
0:             size += 2;
0:             CarbonUnsafe.unsafe
0:                 .copyMemory(bigDecimalInBytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, baseObject,
0:                     address + size, bigDecimalInBytes.length);
0:             size += bigDecimalInBytes.length;
0:             break;
/////////////////////////////////////////////////////////////////////////
0:         switch (measureDataType[mesCount]) {
0:           case SHORT:
0:           case INT:
0:           case LONG:
0:             Long val = CarbonUnsafe.unsafe.getLong(baseObject, address + size);
0:             size += 8;
0:             rowToFill[dimensionSize + mesCount] = val;
0:             break;
0:           case DOUBLE:
0:             Double doubleVal = CarbonUnsafe.unsafe.getDouble(baseObject, address + size);
0:             size += 8;
0:             rowToFill[dimensionSize + mesCount] = doubleVal;
0:             break;
0:           case DECIMAL:
0:             short aShort = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:             byte[] bigDecimalInBytes = new byte[aShort];
0:             size += 2;
0:             CarbonUnsafe.unsafe.copyMemory(baseObject, address + size, bigDecimalInBytes,
0:                 CarbonUnsafe.BYTE_ARRAY_OFFSET, bigDecimalInBytes.length);
0:             size += bigDecimalInBytes.length;
0:             rowToFill[dimensionSize + mesCount] = bigDecimalInBytes;
0:             break;
/////////////////////////////////////////////////////////////////////////
0:         switch (measureDataType[mesCount]) {
0:           case SHORT:
0:           case INT:
0:           case LONG:
0:             long val = CarbonUnsafe.unsafe.getLong(baseObject, address + size);
0:             size += 8;
0:             stream.writeLong(val);
0:             break;
0:           case DOUBLE:
0:             double doubleVal = CarbonUnsafe.unsafe.getDouble(baseObject, address + size);
0:             size += 8;
0:             stream.writeDouble(doubleVal);
0:             break;
0:           case DECIMAL:
0:             short aShort = CarbonUnsafe.unsafe.getShort(baseObject, address + size);
0:             byte[] bigDecimalInBytes = new byte[aShort];
0:             size += 2;
0:             CarbonUnsafe.unsafe.copyMemory(baseObject, address + size, bigDecimalInBytes,
0:                 CarbonUnsafe.BYTE_ARRAY_OFFSET, bigDecimalInBytes.length);
0:             size += bigDecimalInBytes.length;
0:             stream.writeShort(aShort);
0:             stream.write(bigDecimalInBytes);
0:             break;
commit:8cca0af
/////////////////////////////////////////////////////////////////////////
0:         if (aggType[mesCount] == CarbonCommonConstants.DOUBLE_MEASURE) {
/////////////////////////////////////////////////////////////////////////
0:         if (aggType[mesCount] == CarbonCommonConstants.DOUBLE_MEASURE) {
/////////////////////////////////////////////////////////////////////////
0:         if (aggType[mesCount] == CarbonCommonConstants.DOUBLE_MEASURE) {
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.memory.CarbonUnsafe;
commit:3fe6903
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:QiangCai
-------------------------------------------------------------------------------
commit:9f94529
/////////////////////////////////////////////////////////////////////////
0:   private boolean[] noDictionarySortColumnMapping;
0: 
/////////////////////////////////////////////////////////////////////////
0:   public UnsafeCarbonRowPage(boolean[] noDictionaryDimensionMapping,
0:       boolean[] noDictionarySortColumnMapping, int dimensionSize, int measureSize, char[] aggType,
0:       MemoryBlock memoryBlock, boolean saveToDisk) {
0:     this.noDictionarySortColumnMapping = noDictionarySortColumnMapping;
/////////////////////////////////////////////////////////////////////////
0:   public boolean[] getNoDictionarySortColumnMapping() {
0:     return noDictionarySortColumnMapping;
0:   }
commit:41347d8
/////////////////////////////////////////////////////////////////////////
0: 
============================================================================