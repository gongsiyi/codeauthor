1:7359601: /*
1:7359601:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7359601:  * contributor license agreements.  See the NOTICE file distributed with
1:7359601:  * this work for additional information regarding copyright ownership.
1:7359601:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7359601:  * (the "License"); you may not use this file except in compliance with
1:7359601:  * the License.  You may obtain a copy of the License at
1:7359601:  *
1:7359601:  *    http://www.apache.org/licenses/LICENSE-2.0
1:7359601:  *
1:7359601:  * Unless required by applicable law or agreed to in writing, software
1:7359601:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7359601:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7359601:  * See the License for the specific language governing permissions and
1:7359601:  * limitations under the License.
1:7359601:  */
2:7359601: 
1:7359601: package org.apache.carbondata.core.datastore.page;
1:7359601: 
1:eadfea7: import java.io.IOException;
1:7359601: import java.math.BigDecimal;
1:7359601: 
1:7359601: import org.apache.carbondata.core.datastore.compression.Compressor;
1:8f08c4a: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
1:7359601: import org.apache.carbondata.core.memory.CarbonUnsafe;
1:7359601: import org.apache.carbondata.core.memory.MemoryBlock;
1:7359601: import org.apache.carbondata.core.memory.MemoryException;
1:7359601: import org.apache.carbondata.core.memory.UnsafeMemoryManager;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:7d386a4: import org.apache.carbondata.core.util.ByteUtil;
1:df22368: import org.apache.carbondata.core.util.ThreadLocalTaskInfo;
1:7359601: 
1:7359601: 
1:7359601: // This extension uses unsafe memory to store page data, for fix length data type only (byte,
1:7359601: // short, integer, long, float, double)
1:7359601: public class UnsafeFixLengthColumnPage extends ColumnPage {
1:7359601:   // memory allocated by Unsafe
1:7359601:   private MemoryBlock memoryBlock;
1:7359601: 
1:7359601:   // base address of memoryBlock
1:7359601:   private Object baseAddress;
1:7359601: 
1:7359601:   // base offset of memoryBlock
1:7359601:   private long baseOffset;
1:7359601: 
1:6297ea0:   private int eachRowSize;
1:6297ea0: 
1:438b442:   // the length of the bytes added in the page
1:438b442:   private int totalLength;
1:438b442: 
1:438b442:   // size of the allocated memory, in bytes
1:438b442:   private int capacity;
1:438b442: 
1:df22368:   private final long taskId = ThreadLocalTaskInfo.getCarbonTaskInfo().getTaskId();
1:df22368: 
1:956833e:   private static final int byteBits = DataTypes.BYTE.getSizeBits();
1:956833e:   private static final int shortBits = DataTypes.SHORT.getSizeBits();
1:956833e:   private static final int intBits = DataTypes.INT.getSizeBits();
1:956833e:   private static final int longBits = DataTypes.LONG.getSizeBits();
1:956833e:   private static final int floatBits = DataTypes.FLOAT.getSizeBits();
1:956833e:   private static final int doubleBits = DataTypes.DOUBLE.getSizeBits();
1:7359601: 
1:8f08c4a:   UnsafeFixLengthColumnPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize)
1:6297ea0:       throws MemoryException {
1:8f08c4a:     super(columnPageEncoderMeta, pageSize);
1:8f08c4a:     if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BOOLEAN ||
1:8f08c4a:         columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE ||
1:8f08c4a:         columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT ||
1:8f08c4a:         columnPageEncoderMeta.getStoreDataType() == DataTypes.INT ||
1:8f08c4a:         columnPageEncoderMeta.getStoreDataType() == DataTypes.LONG ||
1:8f08c4a:         columnPageEncoderMeta.getStoreDataType() == DataTypes.FLOAT ||
1:8f08c4a:         columnPageEncoderMeta.getStoreDataType() == DataTypes.DOUBLE) {
1:8f08c4a:       int size = pageSize << columnPageEncoderMeta.getStoreDataType().getSizeBits();
1:956833e:       memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, size);
1:956833e:       baseAddress = memoryBlock.getBaseObject();
1:956833e:       baseOffset = memoryBlock.getBaseOffset();
1:438b442:       capacity = size;
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT_INT) {
1:956833e:       int size = pageSize * 3;
1:956833e:       memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, size);
1:956833e:       baseAddress = memoryBlock.getBaseObject();
1:956833e:       baseOffset = memoryBlock.getBaseOffset();
1:438b442:       capacity = size;
1:8f08c4a:     } else if (DataTypes.isDecimal(columnPageEncoderMeta.getStoreDataType()) ||
1:8f08c4a:         columnPageEncoderMeta.getStoreDataType() == DataTypes.STRING) {
1:8f08c4a:       throw new UnsupportedOperationException(
1:8f08c4a:           "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
13:7359601:     }
1:438b442:     totalLength = 0;
1:7359601:   }
1:7359601: 
1:8f08c4a:   UnsafeFixLengthColumnPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize,
1:8f08c4a:       int eachRowSize) throws MemoryException {
1:8f08c4a:     this(columnPageEncoderMeta, pageSize);
1:6297ea0:     this.eachRowSize = eachRowSize;
1:438b442:     totalLength = 0;
1:8f08c4a:     if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE_ARRAY) {
1:6297ea0:       memoryBlock =
1:6297ea0:           UnsafeMemoryManager.allocateMemoryWithRetry(taskId, (long) pageSize * eachRowSize);
1:6297ea0:       baseAddress = memoryBlock.getBaseObject();
1:6297ea0:       baseOffset = memoryBlock.getBaseOffset();
1:6297ea0:     }
1:6297ea0:   }
1:6297ea0: 
1:438b442:   private void checkDataFileSize() {
1:438b442:     // 16 is a Watermark in order to stop from overflowing.
1:438b442:     if (totalLength > (Integer.MAX_VALUE - 16)) {
1:438b442:       // since we later store a column page in a byte array, so its maximum size is 2GB
1:438b442:       throw new RuntimeException("Carbondata only support maximum 2GB size for one column page");
1:438b442:     }
1:7359601:   }
1:7359601: 
1:8925947:   private void updatePageSize(int rowId) {
1:8925947:     if (pageSize < rowId) {
1:8925947:       pageSize = rowId;
1:8925947:     }
1:8925947:   }
1:8925947: 
1:6297ea0:   @Override
1:438b442:   public void putByte(int rowId, byte value) {
1:438b442:     try {
1:438b442:       ensureMemory(ByteUtil.SIZEOF_BYTE);
1:438b442:     } catch (MemoryException e) {
1:438b442:       throw new RuntimeException(e);
1:438b442:     }
1:438b442:     long offset = ((long)rowId) << byteBits;
1:438b442:     CarbonUnsafe.getUnsafe().putByte(baseAddress, baseOffset + offset, value);
1:438b442:     totalLength += ByteUtil.SIZEOF_BYTE;
1:8925947:     updatePageSize(rowId);
1:438b442:   }
1:438b442: 
1:438b442: 
1:438b442: 
1:438b442:   @Override
1:7359601:   public void putShort(int rowId, short value) {
1:438b442:     try {
1:438b442:       ensureMemory(shortBits);
1:438b442:     } catch (MemoryException e) {
1:438b442:       throw new RuntimeException(e);
1:438b442:     }
1:7ef9164:     long offset = ((long)rowId) << shortBits;
1:500654e:     CarbonUnsafe.getUnsafe().putShort(baseAddress, baseOffset + offset, value);
1:438b442:     totalLength += ByteUtil.SIZEOF_SHORT;
1:8925947:     updatePageSize(rowId);
1:7359601:   }
1:7359601: 
1:e6a4f64:   @Override
1:7d386a4:   public void putShortInt(int rowId, int value) {
1:438b442:     try {
1:438b442:       ensureMemory(ByteUtil.SIZEOF_SHORT_INT);
1:438b442:     } catch (MemoryException e) {
1:438b442:       throw new RuntimeException(e);
1:438b442:     }
1:7d386a4:     byte[] data = ByteUtil.to3Bytes(value);
1:500654e:     long offset = rowId * 3L;
1:500654e:     CarbonUnsafe.getUnsafe().putByte(baseAddress, baseOffset + offset, data[0]);
1:500654e:     CarbonUnsafe.getUnsafe().putByte(baseAddress, baseOffset + offset + 1, data[1]);
1:500654e:     CarbonUnsafe.getUnsafe().putByte(baseAddress, baseOffset + offset + 2, data[2]);
1:438b442:     totalLength += ByteUtil.SIZEOF_SHORT_INT;
1:8925947:     updatePageSize(rowId);
1:7d386a4:   }
1:7d386a4: 
1:7d386a4:   @Override
1:7359601:   public void putInt(int rowId, int value) {
1:438b442:     try {
1:438b442:       ensureMemory(ByteUtil.SIZEOF_INT);
1:438b442:     } catch (MemoryException e) {
1:438b442:       throw new RuntimeException(e);
1:438b442:     }
1:7ef9164:     long offset = ((long)rowId) << intBits;
1:500654e:     CarbonUnsafe.getUnsafe().putInt(baseAddress, baseOffset + offset, value);
1:438b442:     totalLength += ByteUtil.SIZEOF_INT;
1:8925947:     updatePageSize(rowId);
1:7359601:   }
1:7359601: 
5:7359601:   @Override
1:7359601:   public void putLong(int rowId, long value) {
1:438b442:     try {
1:438b442:       ensureMemory(ByteUtil.SIZEOF_LONG);
1:438b442:     } catch (MemoryException e) {
1:438b442:       throw new RuntimeException(e);
1:438b442:     }
1:7ef9164:     long offset = ((long)rowId) << longBits;
1:500654e:     CarbonUnsafe.getUnsafe().putLong(baseAddress, baseOffset + offset, value);
1:438b442:     totalLength += ByteUtil.SIZEOF_LONG;
1:8925947:     updatePageSize(rowId);
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void putDouble(int rowId, double value) {
1:438b442:     try {
1:438b442:       ensureMemory(ByteUtil.SIZEOF_DOUBLE);
1:438b442:     } catch (MemoryException e) {
1:438b442:       throw new RuntimeException(e);
1:438b442:     }
1:7ef9164:     long offset = ((long)rowId) << doubleBits;
1:500654e:     CarbonUnsafe.getUnsafe().putDouble(baseAddress, baseOffset + offset, value);
1:438b442:     totalLength += ByteUtil.SIZEOF_DOUBLE;
1:8925947:     updatePageSize(rowId);
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void putBytes(int rowId, byte[] bytes) {
1:43285bb:     try {
1:43285bb:       ensureMemory(eachRowSize);
1:43285bb:     } catch (MemoryException e) {
1:43285bb:       throw new RuntimeException(e);
1:43285bb:     }
1:6297ea0:     // copy the data to memory
1:6297ea0:     long offset = (long)rowId * eachRowSize;
1:6297ea0:     CarbonUnsafe.getUnsafe()
1:6297ea0:         .copyMemory(bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, memoryBlock.getBaseObject(),
1:6297ea0:             baseOffset + offset, bytes.length);
1:8925947:     updatePageSize(rowId);
1:43285bb:     totalLength += eachRowSize;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void putBytes(int rowId, byte[] bytes, int offset, int length) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:9e064ee:   @Override public void putDecimal(int rowId, BigDecimal decimal) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:9e064ee:   }
1:9e064ee: 
1:7359601:   @Override
1:7359601:   public byte getByte(int rowId) {
1:7ef9164:     long offset = ((long)rowId) << byteBits;
1:500654e:     return CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset);
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public short getShort(int rowId) {
1:7ef9164:     long offset = ((long)rowId) << shortBits;
1:500654e:     return CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset);
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7d386a4:   public int getShortInt(int rowId) {
1:500654e:     long offset = rowId * 3L;
1:7d386a4:     byte[] data = new byte[3];
1:500654e:     data[0] = CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset);
1:500654e:     data[1] = CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset + 1);
1:500654e:     data[2] = CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset + 2);
1:7d386a4:     return ByteUtil.valueOf3Bytes(data, 0);
1:7d386a4:   }
1:7d386a4: 
1:7d386a4:   @Override
1:7359601:   public int getInt(int rowId) {
1:7ef9164:     long offset = ((long)rowId) << intBits;
1:500654e:     return CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset);
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public long getLong(int rowId) {
1:7ef9164:     long offset = ((long)rowId) << longBits;
1:500654e:     return CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset);
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public float getFloat(int rowId) {
1:7ef9164:     long offset = ((long)rowId) << floatBits;
1:500654e:     return CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset);
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public double getDouble(int rowId) {
1:7ef9164:     long offset = ((long)rowId) << doubleBits;
1:500654e:     return CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset);
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public BigDecimal getDecimal(int rowId) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:e6a4f64:   public byte[] getBytes(int rowId) {
1:6297ea0:     // creating a row
1:6297ea0:     byte[] data = new byte[eachRowSize];
1:6297ea0:     //copy the row from memory block based on offset
1:6297ea0:     // offset position will be index * each column value length
1:6297ea0:     CarbonUnsafe.getUnsafe().copyMemory(memoryBlock.getBaseObject(),
1:6297ea0:         baseOffset + ((long)rowId * eachRowSize), data,
1:6297ea0:         CarbonUnsafe.BYTE_ARRAY_OFFSET, eachRowSize);
1:6297ea0:     return data;
1:e6a4f64:   }
1:e6a4f64: 
1:9e064ee:   @Override public byte[] getDecimalPage() {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:9e064ee:   }
1:9e064ee: 
1:7359601:   @Override
1:7359601:   public byte[] getBytePage() {
1:8925947:     byte[] data = new byte[getEndLoop()];
1:7ef9164:     for (long i = 0; i < data.length; i++) {
1:956833e:       long offset = i << byteBits;
1:7ef9164:       data[(int)i] = CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset);
1:956833e:     }
1:7359601:     return data;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public short[] getShortPage() {
1:8925947:     short[] data = new short[getEndLoop()];
1:7ef9164:     for (long i = 0; i < data.length; i++) {
1:956833e:       long offset = i << shortBits;
1:7ef9164:       data[(int)i] = CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset);
1:956833e:     }
1:7359601:     return data;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7d386a4:   public byte[] getShortIntPage() {
1:8925947:     byte[] data = new byte[getEndLoop() * 3];
1:500654e:     CarbonUnsafe.getUnsafe().copyMemory(baseAddress, baseOffset,
1:7d386a4:         data, CarbonUnsafe.BYTE_ARRAY_OFFSET, data.length);
1:7d386a4:     return data;
1:7d386a4:   }
1:7d386a4: 
1:7d386a4:   @Override
1:7359601:   public int[] getIntPage() {
1:8925947:     int[] data = new int[getEndLoop()];
1:7ef9164:     for (long i = 0; i < data.length; i++) {
1:956833e:       long offset = i << intBits;
1:7ef9164:       data[(int)i] = CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset);
1:956833e:     }
1:7359601:     return data;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public long[] getLongPage() {
1:8925947:     long[] data = new long[getEndLoop()];
1:7ef9164:     for (long i = 0; i < data.length; i++) {
1:956833e:       long offset = i << longBits;
1:7ef9164:       data[(int)i] = CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset);
1:956833e:     }
1:7359601:     return data;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public float[] getFloatPage() {
1:7359601:     float[] data = new float[getPageSize()];
1:7ef9164:     for (long i = 0; i < data.length; i++) {
1:956833e:       long offset = i << floatBits;
1:7ef9164:       data[(int)i] = CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset);
1:956833e:     }
1:7359601:     return data;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public double[] getDoublePage() {
1:7359601:     double[] data = new double[getPageSize()];
1:7ef9164:     for (long i = 0; i < data.length; i++) {
1:956833e:       long offset = i << doubleBits;
1:7ef9164:       data[(int)i] = CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset);
1:956833e:     }
1:7359601:     return data;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public byte[][] getByteArrayPage() {
1:43285bb:     byte[][] data = new byte[getEndLoop()][eachRowSize];
1:43285bb:     long offset = baseOffset;
1:43285bb:     for (int i = 0; i < data.length; i++) {
1:43285bb:       //copy the row from memory block based on offset
1:43285bb:       // offset position will be index * each column value length
1:43285bb:       CarbonUnsafe.getUnsafe().copyMemory(memoryBlock.getBaseObject(), offset, data[i],
1:43285bb:           CarbonUnsafe.BYTE_ARRAY_OFFSET, eachRowSize);
1:43285bb:       offset += eachRowSize;
1:43285bb:     }
1:43285bb:     return data;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:8c1ddbf:   public byte[] getLVFlattenedBytePage() {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:6297ea0:   }
1:43285bb: 
1:43285bb:   @Override public byte[] getComplexChildrenLVFlattenedBytePage() {
1:43285bb:     byte[] data = new byte[totalLength];
1:43285bb:     CarbonUnsafe.getUnsafe()
1:43285bb:         .copyMemory(baseAddress, baseOffset, data, CarbonUnsafe.BYTE_ARRAY_OFFSET, totalLength);
1:43285bb:     return data;
1:7359601:   }
1:6297ea0: 
1:6297ea0:   @Override
1:6297ea0:   public byte[] getComplexParentFlattenedBytePage() {
1:6297ea0:     throw new UnsupportedOperationException("internal error");
1:6297ea0:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setBytePage(byte[] byteData) {
1:500654e:     CarbonUnsafe.getUnsafe().copyMemory(byteData, CarbonUnsafe.BYTE_ARRAY_OFFSET,
1:7d386a4:         baseAddress, baseOffset, byteData.length << byteBits);
1:438b442:     capacity = byteData.length;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setShortPage(short[] shortData) {
1:500654e:     CarbonUnsafe.getUnsafe().copyMemory(shortData, CarbonUnsafe.SHORT_ARRAY_OFFSET,
1:7d386a4:         baseAddress, baseOffset, shortData.length << shortBits);
1:438b442:     capacity = shortData.length;
1:7d386a4:   }
1:7d386a4: 
1:7d386a4:   @Override
1:7d386a4:   public void setShortIntPage(byte[] shortIntData) {
1:500654e:     CarbonUnsafe.getUnsafe().copyMemory(shortIntData, CarbonUnsafe.BYTE_ARRAY_OFFSET,
1:7d386a4:         baseAddress, baseOffset, shortIntData.length);
1:438b442:     capacity = shortIntData.length;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setIntPage(int[] intData) {
1:500654e:     CarbonUnsafe.getUnsafe().copyMemory(intData, CarbonUnsafe.INT_ARRAY_OFFSET,
1:7d386a4:         baseAddress, baseOffset, intData.length << intBits);
1:438b442:     capacity = intData.length;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setLongPage(long[] longData) {
1:500654e:     CarbonUnsafe.getUnsafe().copyMemory(longData, CarbonUnsafe.LONG_ARRAY_OFFSET,
1:7d386a4:         baseAddress, baseOffset, longData.length << longBits);
1:438b442:     capacity = longData.length;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setFloatPage(float[] floatData) {
1:500654e:     CarbonUnsafe.getUnsafe().copyMemory(floatData, CarbonUnsafe.FLOAT_ARRAY_OFFSET,
1:7d386a4:         baseAddress, baseOffset, floatData.length << floatBits);
1:438b442:     capacity = floatData.length;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setDoublePage(double[] doubleData) {
1:500654e:     CarbonUnsafe.getUnsafe().copyMemory(doubleData, CarbonUnsafe.DOUBLE_ARRAY_OFFSET,
1:7d386a4:         baseAddress, baseOffset, doubleData.length << doubleBits);
1:438b442:     capacity = doubleData.length;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setByteArrayPage(byte[][] byteArray) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   public void freeMemory() {
1:7359601:     if (memoryBlock != null) {
1:df22368:       UnsafeMemoryManager.INSTANCE.freeMemory(taskId, memoryBlock);
1:7359601:       memoryBlock = null;
1:7359601:       baseAddress = null;
1:7359601:       baseOffset = 0;
1:7359601:     }
1:7359601:   }
1:7359601: 
1:438b442:   @Override public void convertValue(ColumnPageValueConverter codec) {
1:438b442:     int endLoop = getEndLoop();
1:8f08c4a:     if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE) {
1:438b442:       for (long i = 0; i < endLoop; i++) {
3:7359601:         long offset = i << byteBits;
1:438b442:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset));
1:7359601:       }
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT) {
1:438b442:       for (long i = 0; i < endLoop; i++) {
3:7359601:         long offset = i << shortBits;
1:438b442:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset));
1:7359601:       }
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.INT) {
1:438b442:       for (long i = 0; i < endLoop; i++) {
3:7359601:         long offset = i << intBits;
1:438b442:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset));
1:7359601:       }
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.LONG) {
1:438b442:       for (long i = 0; i < endLoop; i++) {
3:7359601:         long offset = i << longBits;
1:438b442:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset));
1:7359601:       }
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.FLOAT) {
1:438b442:       for (long i = 0; i < endLoop; i++) {
3:7359601:         long offset = i << floatBits;
1:438b442:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset));
1:7359601:       }
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.DOUBLE) {
1:438b442:       for (long i = 0; i < endLoop; i++) {
3:7359601:         long offset = i << doubleBits;
1:438b442:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset));
1:7359601:       }
1:956833e:     } else {
1:8f08c4a:       throw new UnsupportedOperationException(
1:8f08c4a:           "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:     }
1:7359601:   }
1:7359601: 
1:438b442:   private int getEndLoop() {
1:8f08c4a:     if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE) {
1:438b442:       return totalLength / ByteUtil.SIZEOF_BYTE;
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT) {
1:438b442:       return totalLength / ByteUtil.SIZEOF_SHORT;
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT_INT) {
1:4d95dfc:       return totalLength / ByteUtil.SIZEOF_SHORT_INT;
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.INT) {
1:438b442:       return totalLength / ByteUtil.SIZEOF_INT;
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.LONG) {
1:438b442:       return totalLength / ByteUtil.SIZEOF_LONG;
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.FLOAT) {
1:438b442:       return totalLength / DataTypes.FLOAT.getSizeInBytes();
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.DOUBLE) {
1:438b442:       return totalLength / DataTypes.DOUBLE.getSizeInBytes();
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE_ARRAY) {
1:43285bb:       return totalLength / eachRowSize;
1:438b442:     } else {
1:8f08c4a:       throw new UnsupportedOperationException(
1:8f08c4a:           "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:438b442:     }
1:438b442:   }
1:438b442: 
1:500654e:   @Override public byte[] compress(Compressor compressor) throws MemoryException, IOException {
1:8f08c4a:     if (UnsafeMemoryManager.isOffHeap() && compressor.supportUnsafe()) {
1:eadfea7:       // use raw compression and copy to byte[]
1:438b442:       int inputSize = totalLength;
1:8f08c4a:       long compressedMaxSize = compressor.maxCompressedLength(inputSize);
1:df22368:       MemoryBlock compressed =
1:df22368:           UnsafeMemoryManager.allocateMemoryWithRetry(taskId, compressedMaxSize);
1:eadfea7:       long outSize = compressor.rawCompress(baseOffset, inputSize, compressed.getBaseOffset());
1:eadfea7:       assert outSize < Integer.MAX_VALUE;
1:eadfea7:       byte[] output = new byte[(int) outSize];
1:500654e:       CarbonUnsafe.getUnsafe()
1:500654e:           .copyMemory(compressed.getBaseObject(), compressed.getBaseOffset(), output,
1:500654e:               CarbonUnsafe.BYTE_ARRAY_OFFSET, outSize);
1:df22368:       UnsafeMemoryManager.INSTANCE.freeMemory(taskId, compressed);
1:eadfea7:       return output;
1:eadfea7:     } else {
1:eadfea7:       return super.compress(compressor);
1:eadfea7:     }
1:7359601:   }
1:438b442: 
1:438b442:   /**
1:438b442:    * reallocate memory if capacity length than current size + request size
1:438b442:    */
1:438b442:   protected void ensureMemory(int requestSize) throws MemoryException {
1:438b442:     checkDataFileSize();
1:438b442:     if (totalLength + requestSize > capacity) {
1:438b442:       int newSize = Math.max(2 * capacity, totalLength + requestSize);
1:438b442:       MemoryBlock newBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, newSize);
1:438b442:       CarbonUnsafe.getUnsafe().copyMemory(baseAddress, baseOffset,
1:438b442:           newBlock.getBaseObject(), newBlock.getBaseOffset(), totalLength);
1:438b442:       UnsafeMemoryManager.INSTANCE.freeMemory(taskId, memoryBlock);
1:438b442:       memoryBlock = newBlock;
1:438b442:       baseAddress = newBlock.getBaseObject();
1:438b442:       baseOffset = newBlock.getBaseOffset();
1:438b442:       capacity = newSize;
1:438b442:     }
1:438b442:   }
1:8925947: 
1:8925947:   public int getActualRowCount() {
1:8925947:     return getEndLoop();
1:8925947:   }
1:7359601: }
============================================================================
author:xuchuanyin
-------------------------------------------------------------------------------
commit:8f08c4a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
/////////////////////////////////////////////////////////////////////////
1:   UnsafeFixLengthColumnPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize)
1:     super(columnPageEncoderMeta, pageSize);
1:     if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BOOLEAN ||
1:         columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE ||
1:         columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT ||
1:         columnPageEncoderMeta.getStoreDataType() == DataTypes.INT ||
1:         columnPageEncoderMeta.getStoreDataType() == DataTypes.LONG ||
1:         columnPageEncoderMeta.getStoreDataType() == DataTypes.FLOAT ||
1:         columnPageEncoderMeta.getStoreDataType() == DataTypes.DOUBLE) {
1:       int size = pageSize << columnPageEncoderMeta.getStoreDataType().getSizeBits();
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT_INT) {
1:     } else if (DataTypes.isDecimal(columnPageEncoderMeta.getStoreDataType()) ||
1:         columnPageEncoderMeta.getStoreDataType() == DataTypes.STRING) {
1:       throw new UnsupportedOperationException(
1:           "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:   UnsafeFixLengthColumnPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize,
1:       int eachRowSize) throws MemoryException {
1:     this(columnPageEncoderMeta, pageSize);
1:     if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE_ARRAY) {
/////////////////////////////////////////////////////////////////////////
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
/////////////////////////////////////////////////////////////////////////
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
/////////////////////////////////////////////////////////////////////////
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
/////////////////////////////////////////////////////////////////////////
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
/////////////////////////////////////////////////////////////////////////
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
/////////////////////////////////////////////////////////////////////////
1:     if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.INT) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.LONG) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.FLOAT) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.DOUBLE) {
1:       throw new UnsupportedOperationException(
1:           "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.SHORT_INT) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.INT) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.LONG) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.FLOAT) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.DOUBLE) {
1:     } else if (columnPageEncoderMeta.getStoreDataType() == DataTypes.BYTE_ARRAY) {
1:       throw new UnsupportedOperationException(
1:           "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     if (UnsafeMemoryManager.isOffHeap() && compressor.supportUnsafe()) {
1:       long compressedMaxSize = compressor.maxCompressedLength(inputSize);
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:4d95dfc
/////////////////////////////////////////////////////////////////////////
0:     } else if (dataType == DataTypes.SHORT_INT) {
1:       return totalLength / ByteUtil.SIZEOF_SHORT_INT;
commit:438b442
/////////////////////////////////////////////////////////////////////////
1:   // the length of the bytes added in the page
1:   private int totalLength;
1: 
1:   // size of the allocated memory, in bytes
1:   private int capacity;
1: 
/////////////////////////////////////////////////////////////////////////
1:       capacity = size;
1:       capacity = size;
1:     totalLength = 0;
/////////////////////////////////////////////////////////////////////////
1:     totalLength = 0;
/////////////////////////////////////////////////////////////////////////
1:   private void checkDataFileSize() {
1:     // 16 is a Watermark in order to stop from overflowing.
1:     if (totalLength > (Integer.MAX_VALUE - 16)) {
1:       // since we later store a column page in a byte array, so its maximum size is 2GB
1:       throw new RuntimeException("Carbondata only support maximum 2GB size for one column page");
1:     }
1:   public void putByte(int rowId, byte value) {
1:     try {
1:       ensureMemory(ByteUtil.SIZEOF_BYTE);
1:     } catch (MemoryException e) {
1:       throw new RuntimeException(e);
1:     }
1:     long offset = ((long)rowId) << byteBits;
1:     CarbonUnsafe.getUnsafe().putByte(baseAddress, baseOffset + offset, value);
1:     totalLength += ByteUtil.SIZEOF_BYTE;
1:   }
1: 
1: 
1: 
1:   @Override
1:     try {
1:       ensureMemory(shortBits);
1:     } catch (MemoryException e) {
1:       throw new RuntimeException(e);
1:     }
1:     totalLength += ByteUtil.SIZEOF_SHORT;
1:     try {
1:       ensureMemory(ByteUtil.SIZEOF_SHORT_INT);
1:     } catch (MemoryException e) {
1:       throw new RuntimeException(e);
1:     }
1:     totalLength += ByteUtil.SIZEOF_SHORT_INT;
1:     try {
1:       ensureMemory(ByteUtil.SIZEOF_INT);
1:     } catch (MemoryException e) {
1:       throw new RuntimeException(e);
1:     }
1:     totalLength += ByteUtil.SIZEOF_INT;
1:     try {
1:       ensureMemory(ByteUtil.SIZEOF_LONG);
1:     } catch (MemoryException e) {
1:       throw new RuntimeException(e);
1:     }
1:     totalLength += ByteUtil.SIZEOF_LONG;
1:     try {
1:       ensureMemory(ByteUtil.SIZEOF_DOUBLE);
1:     } catch (MemoryException e) {
1:       throw new RuntimeException(e);
1:     }
1:     totalLength += ByteUtil.SIZEOF_DOUBLE;
/////////////////////////////////////////////////////////////////////////
1:     capacity = byteData.length;
1:     capacity = shortData.length;
1:     capacity = shortIntData.length;
1:     capacity = intData.length;
1:     capacity = longData.length;
1:     capacity = floatData.length;
1:     capacity = doubleData.length;
/////////////////////////////////////////////////////////////////////////
1:   @Override public void convertValue(ColumnPageValueConverter codec) {
1:     int endLoop = getEndLoop();
1:       for (long i = 0; i < endLoop; i++) {
1:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset));
1:       for (long i = 0; i < endLoop; i++) {
1:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset));
1:       for (long i = 0; i < endLoop; i++) {
1:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset));
1:       for (long i = 0; i < endLoop; i++) {
1:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset));
1:       for (long i = 0; i < endLoop; i++) {
1:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset));
1:       for (long i = 0; i < endLoop; i++) {
1:         codec.encode((int) i, CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset));
1:   private int getEndLoop() {
0:     if (dataType == DataTypes.BYTE) {
1:       return totalLength / ByteUtil.SIZEOF_BYTE;
0:     } else if (dataType == DataTypes.SHORT) {
1:       return totalLength / ByteUtil.SIZEOF_SHORT;
0:     } else if (dataType == DataTypes.INT) {
1:       return totalLength / ByteUtil.SIZEOF_INT;
0:     } else if (dataType == DataTypes.LONG) {
1:       return totalLength / ByteUtil.SIZEOF_LONG;
0:     } else if (dataType == DataTypes.FLOAT) {
1:       return totalLength / DataTypes.FLOAT.getSizeInBytes();
0:     } else if (dataType == DataTypes.DOUBLE) {
1:       return totalLength / DataTypes.DOUBLE.getSizeInBytes();
1:     } else {
0:       throw new UnsupportedOperationException("invalid data type: " + dataType);
1:     }
1:   }
1: 
1:       int inputSize = totalLength;
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * reallocate memory if capacity length than current size + request size
1:    */
1:   protected void ensureMemory(int requestSize) throws MemoryException {
1:     checkDataFileSize();
1:     if (totalLength + requestSize > capacity) {
1:       int newSize = Math.max(2 * capacity, totalLength + requestSize);
1:       MemoryBlock newBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, newSize);
1:       CarbonUnsafe.getUnsafe().copyMemory(baseAddress, baseOffset,
1:           newBlock.getBaseObject(), newBlock.getBaseOffset(), totalLength);
1:       UnsafeMemoryManager.INSTANCE.freeMemory(taskId, memoryBlock);
1:       memoryBlock = newBlock;
1:       baseAddress = newBlock.getBaseObject();
1:       baseOffset = newBlock.getBaseOffset();
1:       capacity = newSize;
1:     }
1:   }
author:kumarvishal09
-------------------------------------------------------------------------------
commit:43285bb
/////////////////////////////////////////////////////////////////////////
1:     try {
1:       ensureMemory(eachRowSize);
1:     } catch (MemoryException e) {
1:       throw new RuntimeException(e);
1:     }
1:     totalLength += eachRowSize;
/////////////////////////////////////////////////////////////////////////
1:     byte[][] data = new byte[getEndLoop()][eachRowSize];
1:     long offset = baseOffset;
1:     for (int i = 0; i < data.length; i++) {
1:       //copy the row from memory block based on offset
1:       // offset position will be index * each column value length
1:       CarbonUnsafe.getUnsafe().copyMemory(memoryBlock.getBaseObject(), offset, data[i],
1:           CarbonUnsafe.BYTE_ARRAY_OFFSET, eachRowSize);
1:       offset += eachRowSize;
1:     }
1:     return data;
1: 
1:   @Override public byte[] getComplexChildrenLVFlattenedBytePage() {
1:     byte[] data = new byte[totalLength];
1:     CarbonUnsafe.getUnsafe()
1:         .copyMemory(baseAddress, baseOffset, data, CarbonUnsafe.BYTE_ARRAY_OFFSET, totalLength);
1:     return data;
/////////////////////////////////////////////////////////////////////////
0:     } else if (dataType == DataTypes.BYTE_ARRAY) {
1:       return totalLength / eachRowSize;
commit:8925947
/////////////////////////////////////////////////////////////////////////
1:   private void updatePageSize(int rowId) {
1:     if (pageSize < rowId) {
1:       pageSize = rowId;
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:     updatePageSize(rowId);
/////////////////////////////////////////////////////////////////////////
1:     updatePageSize(rowId);
/////////////////////////////////////////////////////////////////////////
1:     updatePageSize(rowId);
/////////////////////////////////////////////////////////////////////////
1:     updatePageSize(rowId);
/////////////////////////////////////////////////////////////////////////
1:     updatePageSize(rowId);
/////////////////////////////////////////////////////////////////////////
1:     updatePageSize(rowId);
/////////////////////////////////////////////////////////////////////////
1:     updatePageSize(rowId);
/////////////////////////////////////////////////////////////////////////
1:     byte[] data = new byte[getEndLoop()];
/////////////////////////////////////////////////////////////////////////
1:     short[] data = new short[getEndLoop()];
/////////////////////////////////////////////////////////////////////////
1:     byte[] data = new byte[getEndLoop() * 3];
/////////////////////////////////////////////////////////////////////////
1:     int[] data = new int[getEndLoop()];
/////////////////////////////////////////////////////////////////////////
1:     long[] data = new long[getEndLoop()];
/////////////////////////////////////////////////////////////////////////
1: 
1:   public int getActualRowCount() {
1:     return getEndLoop();
1:   }
commit:6297ea0
/////////////////////////////////////////////////////////////////////////
1:   private int eachRowSize;
1: 
/////////////////////////////////////////////////////////////////////////
0:   UnsafeFixLengthColumnPage(TableSpec.ColumnSpec columnSpec, DataType dataType, int pageSize,
0:       int eachRowSize)
1:       throws MemoryException {
0:     this(columnSpec, dataType, pageSize);
1:     this.eachRowSize = eachRowSize;
0:     if (dataType == DataTypes.BYTE_ARRAY) {
1:       memoryBlock =
1:           UnsafeMemoryManager.allocateMemoryWithRetry(taskId, (long) pageSize * eachRowSize);
1:       baseAddress = memoryBlock.getBaseObject();
1:       baseOffset = memoryBlock.getBaseOffset();
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:     // copy the data to memory
1:     long offset = (long)rowId * eachRowSize;
1:     CarbonUnsafe.getUnsafe()
1:         .copyMemory(bytes, CarbonUnsafe.BYTE_ARRAY_OFFSET, memoryBlock.getBaseObject(),
1:             baseOffset + offset, bytes.length);
/////////////////////////////////////////////////////////////////////////
1:     // creating a row
1:     byte[] data = new byte[eachRowSize];
1:     //copy the row from memory block based on offset
1:     // offset position will be index * each column value length
1:     CarbonUnsafe.getUnsafe().copyMemory(memoryBlock.getBaseObject(),
1:         baseOffset + ((long)rowId * eachRowSize), data,
1:         CarbonUnsafe.BYTE_ARRAY_OFFSET, eachRowSize);
1:     return data;
/////////////////////////////////////////////////////////////////////////
1:   @Override
0:   public byte[] getComplexChildrenLVFlattenedBytePage() throws IOException {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public byte[] getComplexParentFlattenedBytePage() {
1:     throw new UnsupportedOperationException("internal error");
1:   }
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1:     long offset = ((long)rowId) << byteBits;
1:     long offset = ((long)rowId) << shortBits;
/////////////////////////////////////////////////////////////////////////
1:     long offset = ((long)rowId) << intBits;
1:     long offset = ((long)rowId) << longBits;
1:     long offset = ((long)rowId) << doubleBits;
/////////////////////////////////////////////////////////////////////////
0:     long offset = ((long)rowId) << byteBits;
1:     long offset = ((long)rowId) << shortBits;
/////////////////////////////////////////////////////////////////////////
1:     long offset = ((long)rowId) << intBits;
1:     long offset = ((long)rowId) << longBits;
1:     long offset = ((long)rowId) << floatBits;
1:     long offset = ((long)rowId) << doubleBits;
/////////////////////////////////////////////////////////////////////////
1:     for (long i = 0; i < data.length; i++) {
1:       data[(int)i] = CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
1:     for (long i = 0; i < data.length; i++) {
1:       data[(int)i] = CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
1:     for (long i = 0; i < data.length; i++) {
1:       data[(int)i] = CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
1:     for (long i = 0; i < data.length; i++) {
1:       data[(int)i] = CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
1:     for (long i = 0; i < data.length; i++) {
1:       data[(int)i] = CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
1:     for (long i = 0; i < data.length; i++) {
1:       data[(int)i] = CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
0:       for (long i = 0; i < pageSize; i++) {
0:         codec.encode((int)i, CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset));
0:       for (long i = 0; i < pageSize; i++) {
0:         codec.encode((int)i, CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset));
0:       for (long i = 0; i < pageSize; i++) {
0:         codec.encode((int)i, CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset));
0:       for (long i = 0; i < pageSize; i++) {
0:         codec.encode((int)i, CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset));
0:       for (long i = 0; i < pageSize; i++) {
0:         codec.encode((int)i, CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset));
0:       for (long i = 0; i < pageSize; i++) {
0:         codec.encode((int)i, CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset));
author:Jacky Li
-------------------------------------------------------------------------------
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
0:     } else if (DataTypes.isDecimal(dataType) || dataType == DataTypes.STRING) {
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
1:   private static final int byteBits = DataTypes.BYTE.getSizeBits();
1:   private static final int shortBits = DataTypes.SHORT.getSizeBits();
1:   private static final int intBits = DataTypes.INT.getSizeBits();
1:   private static final int longBits = DataTypes.LONG.getSizeBits();
1:   private static final int floatBits = DataTypes.FLOAT.getSizeBits();
1:   private static final int doubleBits = DataTypes.DOUBLE.getSizeBits();
0:     if (dataType == DataTypes.BYTE ||
0:         dataType == DataTypes.SHORT ||
0:         dataType == DataTypes.INT ||
0:         dataType == DataTypes.LONG ||
0:         dataType == DataTypes.FLOAT ||
0:         dataType == DataTypes.DOUBLE) {
0:       int size = pageSize << dataType.getSizeBits();
1:       memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, size);
1:       baseAddress = memoryBlock.getBaseObject();
1:       baseOffset = memoryBlock.getBaseOffset();
0:     } else if (dataType == DataTypes.SHORT_INT) {
1:       int size = pageSize * 3;
1:       memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, size);
1:       baseAddress = memoryBlock.getBaseObject();
1:       baseOffset = memoryBlock.getBaseOffset();
0:     } else if (dataType == DataTypes.DECIMAL || dataType == DataTypes.STRING) {
0:       throw new UnsupportedOperationException("invalid data type: " + dataType);
/////////////////////////////////////////////////////////////////////////
0:     if (dataType == DataTypes.BYTE) {
0:       for (int i = 0; i < pageSize; i++) {
1:         long offset = i << byteBits;
0:         codec.encode(i, CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset));
1:       }
0:     } else if (dataType == DataTypes.SHORT) {
0:       for (int i = 0; i < pageSize; i++) {
1:         long offset = i << shortBits;
0:         codec.encode(i, CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset));
1:       }
0:     } else if (dataType == DataTypes.INT) {
0:       for (int i = 0; i < pageSize; i++) {
1:         long offset = i << intBits;
0:         codec.encode(i, CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset));
1:       }
0:     } else if (dataType == DataTypes.LONG) {
0:       for (int i = 0; i < pageSize; i++) {
1:         long offset = i << longBits;
0:         codec.encode(i, CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset));
1:       }
0:     } else if (dataType == DataTypes.FLOAT) {
0:       for (int i = 0; i < pageSize; i++) {
1:         long offset = i << floatBits;
0:         codec.encode(i, CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset));
1:       }
0:     } else if (dataType == DataTypes.DOUBLE) {
0:       for (int i = 0; i < pageSize; i++) {
1:         long offset = i << doubleBits;
0:         codec.encode(i, CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset));
1:       }
1:     } else {
0:       throw new UnsupportedOperationException("invalid data type: " + dataType);
commit:8c1ddbf
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datastore.TableSpec;
/////////////////////////////////////////////////////////////////////////
0:   UnsafeFixLengthColumnPage(TableSpec.ColumnSpec columnSpec, DataType dataType, int pageSize)
0:     super(columnSpec, dataType, pageSize);
/////////////////////////////////////////////////////////////////////////
1:   public byte[] getLVFlattenedBytePage() {
commit:e6a4f64
/////////////////////////////////////////////////////////////////////////
1:   @Override
1:   public byte[] getBytes(int rowId) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:   public void convertValue(ColumnPageValueConverter codec) {
author:xubo245
-------------------------------------------------------------------------------
commit:6abdd97
/////////////////////////////////////////////////////////////////////////
0:     if (dataType == DataTypes.BOOLEAN ||
0:         dataType == DataTypes.BYTE ||
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
0:     CarbonUnsafe.getUnsafe().putByte(baseAddress, baseOffset + offset, value);
1:     CarbonUnsafe.getUnsafe().putShort(baseAddress, baseOffset + offset, value);
1:     long offset = rowId * 3L;
1:     CarbonUnsafe.getUnsafe().putByte(baseAddress, baseOffset + offset, data[0]);
1:     CarbonUnsafe.getUnsafe().putByte(baseAddress, baseOffset + offset + 1, data[1]);
1:     CarbonUnsafe.getUnsafe().putByte(baseAddress, baseOffset + offset + 2, data[2]);
1:     CarbonUnsafe.getUnsafe().putInt(baseAddress, baseOffset + offset, value);
1:     CarbonUnsafe.getUnsafe().putLong(baseAddress, baseOffset + offset, value);
1:     CarbonUnsafe.getUnsafe().putDouble(baseAddress, baseOffset + offset, value);
/////////////////////////////////////////////////////////////////////////
1:     return CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset);
1:     return CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset);
1:     long offset = rowId * 3L;
1:     data[0] = CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset);
1:     data[1] = CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset + 1);
1:     data[2] = CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset + 2);
1:     return CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset);
1:     return CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset);
1:     return CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset);
1:     return CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
0:       data[i] = CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
0:       data[i] = CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
1:     CarbonUnsafe.getUnsafe().copyMemory(baseAddress, baseOffset,
/////////////////////////////////////////////////////////////////////////
0:       data[i] = CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
0:       data[i] = CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
0:       data[i] = CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
0:       data[i] = CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset);
/////////////////////////////////////////////////////////////////////////
1:     CarbonUnsafe.getUnsafe().copyMemory(byteData, CarbonUnsafe.BYTE_ARRAY_OFFSET,
1:     CarbonUnsafe.getUnsafe().copyMemory(shortData, CarbonUnsafe.SHORT_ARRAY_OFFSET,
1:     CarbonUnsafe.getUnsafe().copyMemory(shortIntData, CarbonUnsafe.BYTE_ARRAY_OFFSET,
1:     CarbonUnsafe.getUnsafe().copyMemory(intData, CarbonUnsafe.INT_ARRAY_OFFSET,
1:     CarbonUnsafe.getUnsafe().copyMemory(longData, CarbonUnsafe.LONG_ARRAY_OFFSET,
1:     CarbonUnsafe.getUnsafe().copyMemory(floatData, CarbonUnsafe.FLOAT_ARRAY_OFFSET,
1:     CarbonUnsafe.getUnsafe().copyMemory(doubleData, CarbonUnsafe.DOUBLE_ARRAY_OFFSET,
/////////////////////////////////////////////////////////////////////////
0:           codec.encode(i, CarbonUnsafe.getUnsafe().getByte(baseAddress, baseOffset + offset));
0:           codec.encode(i, CarbonUnsafe.getUnsafe().getShort(baseAddress, baseOffset + offset));
0:           codec.encode(i, CarbonUnsafe.getUnsafe().getInt(baseAddress, baseOffset + offset));
0:           codec.encode(i, CarbonUnsafe.getUnsafe().getLong(baseAddress, baseOffset + offset));
0:           codec.encode(i, CarbonUnsafe.getUnsafe().getFloat(baseAddress, baseOffset + offset));
0:           codec.encode(i, CarbonUnsafe.getUnsafe().getDouble(baseAddress, baseOffset + offset));
/////////////////////////////////////////////////////////////////////////
1:   @Override public byte[] compress(Compressor compressor) throws MemoryException, IOException {
/////////////////////////////////////////////////////////////////////////
1:       CarbonUnsafe.getUnsafe()
1:           .copyMemory(compressed.getBaseObject(), compressed.getBaseOffset(), output,
1:               CarbonUnsafe.BYTE_ARRAY_OFFSET, outSize);
author:ravipesala
-------------------------------------------------------------------------------
commit:9e064ee
/////////////////////////////////////////////////////////////////////////
0:   UnsafeFixLengthColumnPage(DataType dataType, int pageSize, int scale, int precision)
0:       throws MemoryException {
0:     super(dataType, pageSize, scale, precision);
/////////////////////////////////////////////////////////////////////////
1:   @Override public void putDecimal(int rowId, BigDecimal decimal) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   @Override public byte[] getDecimalPage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
author:kumarvishal
-------------------------------------------------------------------------------
commit:df22368
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.ThreadLocalTaskInfo;
/////////////////////////////////////////////////////////////////////////
1:   private final long taskId = ThreadLocalTaskInfo.getCarbonTaskInfo().getTaskId();
1: 
/////////////////////////////////////////////////////////////////////////
0:         memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, size);
0:         memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, size);
/////////////////////////////////////////////////////////////////////////
1:       UnsafeMemoryManager.INSTANCE.freeMemory(taskId, memoryBlock);
/////////////////////////////////////////////////////////////////////////
1:       MemoryBlock compressed =
1:           UnsafeMemoryManager.allocateMemoryWithRetry(taskId, compressedMaxSize);
1:       UnsafeMemoryManager.INSTANCE.freeMemory(taskId, compressed);
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:52ab730
/////////////////////////////////////////////////////////////////////////
0:       int inputSize = pageSize * dataType.getSizeInBytes();
author:jackylk
-------------------------------------------------------------------------------
commit:eadfea7
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:   public byte[] compress(Compressor compressor) throws MemoryException, IOException {
0:     if (UnsafeMemoryManager.isOffHeap()) {
1:       // use raw compression and copy to byte[]
0:       int inputSize = pageSize << dataType.getSizeBits();
0:       int compressedMaxSize = compressor.maxCompressedLength(inputSize);
0:       MemoryBlock compressed = UnsafeMemoryManager.allocateMemoryWithRetry(compressedMaxSize);
1:       long outSize = compressor.rawCompress(baseOffset, inputSize, compressed.getBaseOffset());
1:       assert outSize < Integer.MAX_VALUE;
1:       byte[] output = new byte[(int) outSize];
0:       CarbonUnsafe.unsafe.copyMemory(compressed.getBaseObject(), compressed.getBaseOffset(), output,
0:           CarbonUnsafe.BYTE_ARRAY_OFFSET, outSize);
0:       UnsafeMemoryManager.INSTANCE.freeMemory(compressed);
1:       return output;
1:     } else {
1:       return super.compress(compressor);
1:     }
commit:7d386a4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.ByteUtil;
/////////////////////////////////////////////////////////////////////////
0:       case SHORT_INT:
0:         size = pageSize * 3;
0:         memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(size);
0:         baseAddress = memoryBlock.getBaseObject();
0:         baseOffset = memoryBlock.getBaseOffset();
0:         break;
/////////////////////////////////////////////////////////////////////////
1:   public void putShortInt(int rowId, int value) {
1:     byte[] data = ByteUtil.to3Bytes(value);
0:     long offset = rowId * 3;
0:     CarbonUnsafe.unsafe.putByte(baseAddress, baseOffset + offset, data[0]);
0:     CarbonUnsafe.unsafe.putByte(baseAddress, baseOffset + offset + 1, data[1]);
0:     CarbonUnsafe.unsafe.putByte(baseAddress, baseOffset + offset + 2, data[2]);
1:   }
1: 
1:   @Override
/////////////////////////////////////////////////////////////////////////
1:   public int getShortInt(int rowId) {
0:     long offset = rowId * 3;
1:     byte[] data = new byte[3];
0:     data[0] = CarbonUnsafe.unsafe.getByte(baseAddress, baseOffset + offset);
0:     data[1] = CarbonUnsafe.unsafe.getByte(baseAddress, baseOffset + offset + 1);
0:     data[2] = CarbonUnsafe.unsafe.getByte(baseAddress, baseOffset + offset + 2);
1:     return ByteUtil.valueOf3Bytes(data, 0);
1:   }
1: 
1:   @Override
/////////////////////////////////////////////////////////////////////////
1:   public byte[] getShortIntPage() {
0:     byte[] data = new byte[pageSize * 3];
0:     CarbonUnsafe.unsafe.copyMemory(baseAddress, baseOffset,
1:         data, CarbonUnsafe.BYTE_ARRAY_OFFSET, data.length);
1:     return data;
1:   }
1: 
1:   @Override
/////////////////////////////////////////////////////////////////////////
0:     CarbonUnsafe.unsafe.copyMemory(byteData, CarbonUnsafe.BYTE_ARRAY_OFFSET,
1:         baseAddress, baseOffset, byteData.length << byteBits);
0:     CarbonUnsafe.unsafe.copyMemory(shortData, CarbonUnsafe.SHORT_ARRAY_OFFSET,
1:         baseAddress, baseOffset, shortData.length << shortBits);
1:   }
1: 
1:   @Override
1:   public void setShortIntPage(byte[] shortIntData) {
0:     CarbonUnsafe.unsafe.copyMemory(shortIntData, CarbonUnsafe.BYTE_ARRAY_OFFSET,
1:         baseAddress, baseOffset, shortIntData.length);
0:     CarbonUnsafe.unsafe.copyMemory(intData, CarbonUnsafe.INT_ARRAY_OFFSET,
1:         baseAddress, baseOffset, intData.length << intBits);
0:     CarbonUnsafe.unsafe.copyMemory(longData, CarbonUnsafe.LONG_ARRAY_OFFSET,
1:         baseAddress, baseOffset, longData.length << longBits);
0:     CarbonUnsafe.unsafe.copyMemory(floatData, CarbonUnsafe.FLOAT_ARRAY_OFFSET,
1:         baseAddress, baseOffset, floatData.length << floatBits);
0:     CarbonUnsafe.unsafe.copyMemory(doubleData, CarbonUnsafe.DOUBLE_ARRAY_OFFSET,
1:         baseAddress, baseOffset, doubleData.length << doubleBits);
commit:7359601
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.core.datastore.page;
1: 
1: import java.math.BigDecimal;
1: 
1: import org.apache.carbondata.core.datastore.compression.Compressor;
1: import org.apache.carbondata.core.memory.CarbonUnsafe;
1: import org.apache.carbondata.core.memory.MemoryBlock;
1: import org.apache.carbondata.core.memory.MemoryException;
1: import org.apache.carbondata.core.memory.UnsafeMemoryManager;
0: import org.apache.carbondata.core.metadata.datatype.DataType;
1: 
0: import static org.apache.carbondata.core.metadata.datatype.DataType.BYTE;
1: 
1: // This extension uses unsafe memory to store page data, for fix length data type only (byte,
1: // short, integer, long, float, double)
1: public class UnsafeFixLengthColumnPage extends ColumnPage {
1:   // memory allocated by Unsafe
1:   private MemoryBlock memoryBlock;
1: 
1:   // base address of memoryBlock
1:   private Object baseAddress;
1: 
1:   // base offset of memoryBlock
1:   private long baseOffset;
1: 
0:   private static final int byteBits = BYTE.getSizeBits();
0:   private static final int shortBits = DataType.SHORT.getSizeBits();
0:   private static final int intBits = DataType.INT.getSizeBits();
0:   private static final int longBits = DataType.LONG.getSizeBits();
0:   private static final int floatBits = DataType.FLOAT.getSizeBits();
0:   private static final int doubleBits = DataType.DOUBLE.getSizeBits();
1: 
0:   UnsafeFixLengthColumnPage(DataType dataType, int pageSize) throws MemoryException {
0:     super(dataType, pageSize);
0:     switch (dataType) {
0:       case BYTE:
0:       case SHORT:
0:       case INT:
0:       case LONG:
0:       case FLOAT:
0:       case DOUBLE:
0:         int size = pageSize << dataType.getSizeBits();
0:         memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(size);
0:         baseAddress = memoryBlock.getBaseObject();
0:         baseOffset = memoryBlock.getBaseOffset();
0:         break;
0:       case DECIMAL:
0:       case STRING:
0:         throw new UnsupportedOperationException("invalid data type: " + dataType);
1:     }
1:   }
1: 
1:   @Override
0:   public void putByte(int rowId, byte value) {
0:     long offset = rowId << byteBits;
0:     CarbonUnsafe.unsafe.putByte(baseAddress, baseOffset + offset, value);
1:   }
1: 
1:   @Override
1:   public void putShort(int rowId, short value) {
0:     long offset = rowId << shortBits;
0:     CarbonUnsafe.unsafe.putShort(baseAddress, baseOffset + offset, value);
1:   }
1: 
1:   @Override
1:   public void putInt(int rowId, int value) {
0:     long offset = rowId << intBits;
0:     CarbonUnsafe.unsafe.putInt(baseAddress, baseOffset + offset, value);
1:   }
1: 
1:   @Override
1:   public void putLong(int rowId, long value) {
0:     long offset = rowId << longBits;
0:     CarbonUnsafe.unsafe.putLong(baseAddress, baseOffset + offset, value);
1:   }
1: 
1:   @Override
1:   public void putDouble(int rowId, double value) {
0:     long offset = rowId << doubleBits;
0:     CarbonUnsafe.unsafe.putDouble(baseAddress, baseOffset + offset, value);
1:   }
1: 
1:   @Override
1:   public void putBytes(int rowId, byte[] bytes) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void putBytes(int rowId, byte[] bytes, int offset, int length) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public byte getByte(int rowId) {
0:     long offset = rowId << byteBits;
0:     return CarbonUnsafe.unsafe.getByte(baseAddress, baseOffset + offset);
1:   }
1: 
1:   @Override
1:   public short getShort(int rowId) {
0:     long offset = rowId << shortBits;
0:     return CarbonUnsafe.unsafe.getShort(baseAddress, baseOffset + offset);
1:   }
1: 
1:   @Override
1:   public int getInt(int rowId) {
0:     long offset = rowId << intBits;
0:     return CarbonUnsafe.unsafe.getInt(baseAddress, baseOffset + offset);
1:   }
1: 
1:   @Override
1:   public long getLong(int rowId) {
0:     long offset = rowId << longBits;
0:     return CarbonUnsafe.unsafe.getLong(baseAddress, baseOffset + offset);
1:   }
1: 
1:   @Override
1:   public float getFloat(int rowId) {
0:     long offset = rowId << floatBits;
0:     return CarbonUnsafe.unsafe.getFloat(baseAddress, baseOffset + offset);
1:   }
1: 
1:   @Override
1:   public double getDouble(int rowId) {
0:     long offset = rowId << doubleBits;
0:     return CarbonUnsafe.unsafe.getDouble(baseAddress, baseOffset + offset);
1:   }
1: 
1:   @Override
1:   public BigDecimal getDecimal(int rowId) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public byte[] getBytePage() {
0:     byte[] data = new byte[getPageSize()];
0:     for (int i = 0; i < data.length; i++) {
1:       long offset = i << byteBits;
0:       data[i] = CarbonUnsafe.unsafe.getByte(baseAddress, baseOffset + offset);
1:     }
1:     return data;
1:   }
1: 
1:   @Override
1:   public short[] getShortPage() {
0:     short[] data = new short[getPageSize()];
0:     for (int i = 0; i < data.length; i++) {
1:       long offset = i << shortBits;
0:       data[i] = CarbonUnsafe.unsafe.getShort(baseAddress, baseOffset + offset);
1:     }
1:     return data;
1:   }
1: 
1:   @Override
1:   public int[] getIntPage() {
0:     int[] data = new int[getPageSize()];
0:     for (int i = 0; i < data.length; i++) {
1:       long offset = i << intBits;
0:       data[i] = CarbonUnsafe.unsafe.getInt(baseAddress, baseOffset + offset);
1:     }
1:     return data;
1:   }
1: 
1:   @Override
1:   public long[] getLongPage() {
0:     long[] data = new long[getPageSize()];
0:     for (int i = 0; i < data.length; i++) {
1:       long offset = i << longBits;
0:       data[i] = CarbonUnsafe.unsafe.getLong(baseAddress, baseOffset + offset);
1:     }
1:     return data;
1:   }
1: 
1:   @Override
1:   public float[] getFloatPage() {
1:     float[] data = new float[getPageSize()];
0:     for (int i = 0; i < data.length; i++) {
1:       long offset = i << floatBits;
0:       data[i] = CarbonUnsafe.unsafe.getFloat(baseAddress, baseOffset + offset);
1:     }
1:     return data;
1:   }
1: 
1:   @Override
1:   public double[] getDoublePage() {
1:     double[] data = new double[getPageSize()];
0:     for (int i = 0; i < data.length; i++) {
1:       long offset = i << doubleBits;
0:       data[i] = CarbonUnsafe.unsafe.getDouble(baseAddress, baseOffset + offset);
1:     }
1:     return data;
1:   }
1: 
1:   @Override
1:   public byte[][] getByteArrayPage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
0:   public byte[] getFlattenedBytePage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void setBytePage(byte[] byteData) {
0:     for (int i = 0; i < byteData.length; i++) {
1:       long offset = i << byteBits;
0:       CarbonUnsafe.unsafe.putByte(baseAddress, baseOffset + offset, byteData[i]);
1:     }
1:   }
1: 
1:   @Override
1:   public void setShortPage(short[] shortData) {
0:     for (int i = 0; i < shortData.length; i++) {
1:       long offset = i << shortBits;
0:       CarbonUnsafe.unsafe.putShort(baseAddress, baseOffset + offset, shortData[i]);
1:     }
1:   }
1: 
1:   @Override
1:   public void setIntPage(int[] intData) {
0:     for (int i = 0; i < intData.length; i++) {
1:       long offset = i << intBits;
0:       CarbonUnsafe.unsafe.putInt(baseAddress, baseOffset + offset, intData[i]);
1:     }
1:   }
1: 
1:   @Override
1:   public void setLongPage(long[] longData) {
0:     for (int i = 0; i < longData.length; i++) {
1:       long offset = i << longBits;
0:       CarbonUnsafe.unsafe.putLong(baseAddress, baseOffset + offset, longData[i]);
1:     }
1:   }
1: 
1:   @Override
1:   public void setFloatPage(float[] floatData) {
0:     for (int i = 0; i < floatData.length; i++) {
1:       long offset = i << floatBits;
0:       CarbonUnsafe.unsafe.putFloat(baseAddress, baseOffset + offset, floatData[i]);
1:     }
1:   }
1: 
1:   @Override
1:   public void setDoublePage(double[] doubleData) {
0:     for (int i = 0; i < doubleData.length; i++) {
1:       long offset = i << doubleBits;
0:       CarbonUnsafe.unsafe.putDouble(baseAddress, baseOffset + offset, doubleData[i]);
1:     }
1:   }
1: 
1:   @Override
1:   public void setByteArrayPage(byte[][] byteArray) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   public void freeMemory() {
1:     if (memoryBlock != null) {
0:       UnsafeMemoryManager.INSTANCE.freeMemory(memoryBlock);
1:       memoryBlock = null;
1:       baseAddress = null;
1:       baseOffset = 0;
1:     }
1:   }
1: 
1:   @Override
0:   public void encode(PrimitiveCodec codec) {
0:     int pageSize = getPageSize();
0:     switch (dataType) {
0:       case BYTE:
0:         for (int i = 0; i < pageSize; i++) {
1:           long offset = i << byteBits;
0:           codec.encode(i, CarbonUnsafe.unsafe.getByte(baseAddress, baseOffset + offset));
1:         }
0:         break;
0:       case SHORT:
0:         for (int i = 0; i < pageSize; i++) {
1:           long offset = i << shortBits;
0:           codec.encode(i, CarbonUnsafe.unsafe.getShort(baseAddress, baseOffset + offset));
1:         }
0:         break;
0:       case INT:
0:         for (int i = 0; i < pageSize; i++) {
1:           long offset = i << intBits;
0:           codec.encode(i, CarbonUnsafe.unsafe.getInt(baseAddress, baseOffset + offset));
1:         }
0:         break;
0:       case LONG:
0:         for (int i = 0; i < pageSize; i++) {
1:           long offset = i << longBits;
0:           codec.encode(i, CarbonUnsafe.unsafe.getLong(baseAddress, baseOffset + offset));
1:         }
0:         break;
0:       case FLOAT:
0:         for (int i = 0; i < pageSize; i++) {
1:           long offset = i << floatBits;
0:           codec.encode(i, CarbonUnsafe.unsafe.getFloat(baseAddress, baseOffset + offset));
1:         }
0:         break;
0:       case DOUBLE:
0:         for (int i = 0; i < pageSize; i++) {
1:           long offset = i << doubleBits;
0:           codec.encode(i, CarbonUnsafe.unsafe.getDouble(baseAddress, baseOffset + offset));
1:         }
0:         break;
0:       default:
0:         throw new UnsupportedOperationException("invalid data type: " + dataType);
1:     }
1:   }
1: 
1:   @Override
0:   public byte[] compress(Compressor compressor) {
0:     // TODO: use zero-copy raw compression
0:     return super.compress(compressor);
1:   }
1: 
1: }
============================================================================