1:c2e4eb2: /*
1:c2e4eb2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:c2e4eb2:  * contributor license agreements.  See the NOTICE file distributed with
1:c2e4eb2:  * this work for additional information regarding copyright ownership.
1:c2e4eb2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:c2e4eb2:  * (the "License"); you may not use this file except in compliance with
1:c2e4eb2:  * the License.  You may obtain a copy of the License at
1:c2e4eb2:  *
1:c2e4eb2:  *    http://www.apache.org/licenses/LICENSE-2.0
1:c2e4eb2:  *
1:c2e4eb2:  * Unless required by applicable law or agreed to in writing, software
1:c2e4eb2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c2e4eb2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c2e4eb2:  * See the License for the specific language governing permissions and
1:c2e4eb2:  * limitations under the License.
1:c2e4eb2:  */
2:c2e4eb2: 
1:c2e4eb2: package org.apache.carbondata.core.util;
1:c2e4eb2: 
1:c2e4eb2: import java.util.Arrays;
1:c2e4eb2: 
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:c2e4eb2: import org.apache.carbondata.core.metadata.encoder.Encoding;
1:c2e4eb2: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:c2e4eb2: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.ColumnExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.Expression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.LiteralExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanEqualToExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.LessThanEqualToExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.NotEqualsExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.logical.RangeExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.logical.TrueExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.filter.executer.RangeValueFilterExecuterImpl;
1:c2e4eb2: import org.apache.carbondata.core.scan.filter.intf.FilterOptimizer;
1:c2e4eb2: import org.apache.carbondata.core.scan.filter.optimizer.RangeFilterOptmizer;
1:c2e4eb2: 
1:c2e4eb2: import mockit.Deencapsulation;
1:c2e4eb2: import mockit.MockUp;
1:c2e4eb2: import org.junit.AfterClass;
1:c2e4eb2: import org.junit.Assert;
1:c2e4eb2: import org.junit.BeforeClass;
1:c2e4eb2: import org.junit.Test;
1:c2e4eb2: 
1:c2e4eb2: /* Test Cases for Range Filter */
1:c2e4eb2: public class RangeFilterProcessorTest {
1:c2e4eb2:   @BeforeClass public static void setUp() throws Exception {
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   public boolean checkBothTrees(Expression a, Expression b) {
1:c2e4eb2: 
1:c2e4eb2:     if (null == a && null == b) {
1:c2e4eb2:       return true;
1:c2e4eb2:     }
1:c2e4eb2: 
1:c2e4eb2:     if (null == a) return false;
1:c2e4eb2:     if (null == b) return false;
1:c2e4eb2: 
1:c2e4eb2:     if ((a != null) && (b != null)) {
1:c2e4eb2:       return ((a.getClass() == b.getClass()) && (
1:c2e4eb2:           (a.getChildren().size() == 0 && b.getChildren().size() == 0) || (
1:c2e4eb2:               a.getChildren().size() == 2 && b.getChildren().size() == 2 && checkBothTrees(
1:c2e4eb2:                   a.getChildren().get(0), b.getChildren().get(0)) && checkBothTrees(
1:c2e4eb2:                   a.getChildren().get(1), b.getChildren().get(1)))));
1:c2e4eb2:     }
1:c2e4eb2:     return false;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void createFilterTree() {
1:c2e4eb2: 
1:c2e4eb2:     Expression inputFilter;
1:c2e4eb2:     boolean result = false;
1:956833e:     ColumnExpression cola = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola.setDimension(true);
1:c2e4eb2: 
1:c2e4eb2:     ColumnSchema empColumnSchema = new ColumnSchema();
1:c2e4eb2:     empColumnSchema.setColumnName("empNameCol");
1:c2e4eb2:     empColumnSchema.setColumnUniqueId("empNameCol");
1:c2e4eb2:     empColumnSchema.setDimensionColumn(true);
1:c2e4eb2:     empColumnSchema.setEncodingList(Arrays.asList(Encoding.DICTIONARY));
1:956833e:     empColumnSchema.setDataType(DataTypes.STRING);
1:f911403:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0);
1:c2e4eb2:     cola.setDimension(empDimension);
1:c2e4eb2: 
1:c2e4eb2:     Expression greaterThan =
1:956833e:         new GreaterThanEqualToExpression(cola, new LiteralExpression("11", DataTypes.STRING));
1:c2e4eb2: 
1:956833e:     ColumnExpression colb = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     colb.setDimension(true);
1:c2e4eb2:     colb.setDimension(empDimension);
1:c2e4eb2:     Expression lessThan =
1:956833e:         new LessThanEqualToExpression(colb, new LiteralExpression("20", DataTypes.STRING));
1:81149f6:     inputFilter = new AndExpression(greaterThan, lessThan);
1:c2e4eb2: 
1:c2e4eb2:     Expression output = new AndExpression(new RangeExpression(
1:956833e:         new GreaterThanEqualToExpression(new ColumnExpression("a", DataTypes.STRING),
1:956833e:             new LiteralExpression("11", DataTypes.STRING)),
1:956833e:         new LessThanEqualToExpression(new ColumnExpression("a", DataTypes.STRING),
1:956833e:             new LiteralExpression("20", DataTypes.STRING))), new TrueExpression(null));
1:c2e4eb2:     FilterOptimizer rangeFilterOptimizer =
1:daa6465:         new RangeFilterOptmizer(inputFilter);
1:c2e4eb2:     rangeFilterOptimizer.optimizeFilter();
3:c2e4eb2:     result = checkBothTrees(inputFilter, output);
1:c2e4eb2:     Assert.assertTrue(result);
1:c2e4eb2: 
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void createFilterTree_noChange() {
1:c2e4eb2: 
1:c2e4eb2:     // Build 2nd Tree no change a < 5 and a > 20
1:c2e4eb2: 
1:c2e4eb2:     Expression inputFilter;
1:c2e4eb2:     boolean result = false;
1:956833e:     ColumnExpression cola = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola.setDimension(true);
1:c2e4eb2: 
1:c2e4eb2:     ColumnSchema empColumnSchema = new ColumnSchema();
1:c2e4eb2:     empColumnSchema.setColumnName("empNameCol");
1:c2e4eb2:     empColumnSchema.setColumnUniqueId("empNameCol");
1:c2e4eb2:     empColumnSchema.setDimensionColumn(true);
1:c2e4eb2:     empColumnSchema.setEncodingList(Arrays.asList(Encoding.DICTIONARY));
1:956833e:     empColumnSchema.setDataType(DataTypes.STRING);
1:f911403:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0);
1:c2e4eb2:     cola.setDimension(empDimension);
1:c2e4eb2: 
1:c2e4eb2:     Expression greaterThan =
1:956833e:         new GreaterThanEqualToExpression(cola, new LiteralExpression("20", DataTypes.STRING));
1:c2e4eb2: 
1:956833e:     ColumnExpression colb = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     colb.setDimension(true);
1:c2e4eb2:     colb.setDimension(empDimension);
1:c2e4eb2:     Expression lessThan =
1:956833e:         new LessThanEqualToExpression(colb, new LiteralExpression("05", DataTypes.STRING));
1:81149f6:     inputFilter = new AndExpression(greaterThan, lessThan);
1:c2e4eb2: 
1:c2e4eb2:     Expression output = new AndExpression(
1:956833e:         new GreaterThanEqualToExpression(new ColumnExpression("a", DataTypes.STRING),
1:956833e:             new LiteralExpression("20", DataTypes.STRING)),
1:956833e:         new LessThanEqualToExpression(new ColumnExpression("a", DataTypes.STRING),
1:956833e:             new LiteralExpression("05", DataTypes.STRING)));
1:c2e4eb2:     FilterOptimizer rangeFilterOptimizer =
1:daa6465:         new RangeFilterOptmizer(inputFilter);
1:c2e4eb2:     rangeFilterOptimizer.optimizeFilter();
1:c2e4eb2:     result = checkBothTrees(inputFilter, output);
1:c2e4eb2:     // no change
1:c2e4eb2:     Assert.assertTrue(result);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void createFilterTree_flavor1() {
1:c2e4eb2: 
1:c2e4eb2:     // Build 3rd BTree a >= '11' and a > '12' and a <= '20' and a <= '15'
1:c2e4eb2: 
1:c2e4eb2:     Expression inputFilter;
1:c2e4eb2:     boolean result = false;
1:c2e4eb2: 
1:c2e4eb2:     ColumnSchema empColumnSchema = new ColumnSchema();
1:c2e4eb2:     empColumnSchema.setColumnName("a");
1:c2e4eb2:     empColumnSchema.setColumnUniqueId("a");
1:c2e4eb2:     empColumnSchema.setDimensionColumn(true);
1:c2e4eb2:     empColumnSchema.setEncodingList(Arrays.asList(Encoding.DICTIONARY));
1:956833e:     empColumnSchema.setDataType(DataTypes.STRING);
1:f911403:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0);
1:c2e4eb2: 
1:956833e:     ColumnExpression cola1 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola1.setDimension(true);
1:c2e4eb2:     cola1.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression cola2 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola2.setDimension(true);
1:c2e4eb2:     cola2.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression cola3 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola3.setDimension(true);
1:c2e4eb2:     cola3.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression cola4 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola4.setDimension(true);
1:c2e4eb2:     cola4.setDimension(empDimension);
1:c2e4eb2: 
1:c2e4eb2:     Expression lessThan1 =
1:956833e:         new LessThanEqualToExpression(cola1, new LiteralExpression("15", DataTypes.STRING));
1:c2e4eb2:     Expression lessThan2 =
1:956833e:         new LessThanEqualToExpression(cola2, new LiteralExpression("20", DataTypes.STRING));
1:c2e4eb2:     Expression greaterThan1 =
1:956833e:         new GreaterThanExpression(cola3, new LiteralExpression("12", DataTypes.STRING));
1:c2e4eb2:     Expression greaterThan2 =
1:956833e:         new GreaterThanEqualToExpression(cola4, new LiteralExpression("11", DataTypes.STRING));
1:c2e4eb2: 
1:c2e4eb2:     Expression And1 = new AndExpression(new NotEqualsExpression(null, null), greaterThan2);
1:c2e4eb2:     Expression And2 = new AndExpression(And1, greaterThan1);
1:c2e4eb2:     Expression And3 = new AndExpression(And2, lessThan2);
1:81149f6:     inputFilter = new AndExpression(And3, lessThan1);
1:c2e4eb2: 
1:c2e4eb2:     // Build The output
1:c2e4eb2: 
1:956833e:     ColumnExpression colb1 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola1.setDimension(true);
1:c2e4eb2:     cola1.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression colb2 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola2.setDimension(true);
1:c2e4eb2:     cola2.setDimension(empDimension);
1:c2e4eb2: 
1:c2e4eb2:     Expression greaterThanb1 =
1:956833e:         new GreaterThanExpression(cola3, new LiteralExpression("12", DataTypes.STRING));
1:c2e4eb2: 
1:c2e4eb2:     Expression lessThanb1 =
1:956833e:         new LessThanEqualToExpression(cola1, new LiteralExpression("15", DataTypes.STRING));
1:c2e4eb2: 
1:c2e4eb2:     Expression Andb1 =
1:c2e4eb2:         new AndExpression(new NotEqualsExpression(null, null), new TrueExpression(null));
1:c2e4eb2: 
1:c2e4eb2:     Expression Andb2 = new AndExpression(Andb1, new RangeExpression(greaterThanb1, lessThanb1));
1:c2e4eb2:     Expression Andb3 = new AndExpression(Andb2, new TrueExpression(null));
1:c2e4eb2: 
1:c2e4eb2:     FilterOptimizer rangeFilterOptimizer =
1:daa6465:         new RangeFilterOptmizer(inputFilter);
1:c2e4eb2:     rangeFilterOptimizer.optimizeFilter();
1:81149f6:     result = checkBothTrees(inputFilter, new AndExpression(Andb3, new TrueExpression(null)));
1:c2e4eb2:     // no change
1:c2e4eb2:     Assert.assertTrue(result);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void createFilterTree_flavor2() {
1:c2e4eb2: 
1:c2e4eb2:     // Build 3rd BTree a >= '11' or a > '12' or a <= '20' or a <= '15'
1:c2e4eb2: 
1:c2e4eb2:     Expression inputFilter;
1:c2e4eb2:     boolean result = false;
1:c2e4eb2: 
1:c2e4eb2:     ColumnSchema empColumnSchema = new ColumnSchema();
1:c2e4eb2:     empColumnSchema.setColumnName("a");
1:c2e4eb2:     empColumnSchema.setColumnUniqueId("a");
1:c2e4eb2:     empColumnSchema.setDimensionColumn(true);
1:c2e4eb2:     empColumnSchema.setEncodingList(Arrays.asList(Encoding.DICTIONARY));
1:956833e:     empColumnSchema.setDataType(DataTypes.STRING);
1:f911403:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0);
1:c2e4eb2: 
1:956833e:     ColumnExpression cola1 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola1.setDimension(true);
1:c2e4eb2:     cola1.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression cola2 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola2.setDimension(true);
1:c2e4eb2:     cola2.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression cola3 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola3.setDimension(true);
1:c2e4eb2:     cola3.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression cola4 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola4.setDimension(true);
1:c2e4eb2:     cola4.setDimension(empDimension);
1:c2e4eb2: 
1:c2e4eb2:     Expression lessThan1 =
1:956833e:         new LessThanEqualToExpression(cola1, new LiteralExpression("15", DataTypes.STRING));
1:c2e4eb2:     Expression lessThan2 =
1:956833e:         new LessThanEqualToExpression(cola2, new LiteralExpression("20", DataTypes.STRING));
1:c2e4eb2:     Expression greaterThan1 =
1:956833e:         new GreaterThanExpression(cola3, new LiteralExpression("12", DataTypes.STRING));
1:c2e4eb2:     Expression greaterThan2 =
1:956833e:         new GreaterThanEqualToExpression(cola4, new LiteralExpression("11", DataTypes.STRING));
1:c2e4eb2: 
1:c2e4eb2:     Expression Or1 = new OrExpression(new NotEqualsExpression(null, null), greaterThan2);
1:c2e4eb2:     Expression Or2 = new OrExpression(Or1, greaterThan1);
1:c2e4eb2:     Expression Or3 = new OrExpression(Or2, lessThan2);
1:81149f6:     inputFilter = new OrExpression(Or3, lessThan1);
1:c2e4eb2: 
1:c2e4eb2:     // Build The output
1:c2e4eb2: 
1:956833e:     ColumnExpression colb1 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola1.setDimension(true);
1:c2e4eb2:     cola1.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression colb2 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola2.setDimension(true);
1:c2e4eb2:     cola2.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression colb3 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola3.setDimension(true);
1:c2e4eb2:     cola3.setDimension(empDimension);
1:c2e4eb2: 
1:956833e:     ColumnExpression colb4 = new ColumnExpression("a", DataTypes.STRING);
1:c2e4eb2:     cola4.setDimension(true);
1:c2e4eb2:     cola4.setDimension(empDimension);
1:c2e4eb2: 
1:c2e4eb2:     Expression lessThanb1 =
1:956833e:         new LessThanEqualToExpression(colb1, new LiteralExpression("15", DataTypes.STRING));
1:c2e4eb2:     Expression lessThanb2 =
1:956833e:         new LessThanEqualToExpression(colb2, new LiteralExpression("20", DataTypes.STRING));
1:c2e4eb2:     Expression greaterThanb1 =
1:956833e:         new GreaterThanExpression(colb3, new LiteralExpression("12", DataTypes.STRING));
1:c2e4eb2:     Expression greaterThanb2 =
1:956833e:         new GreaterThanEqualToExpression(colb4, new LiteralExpression("11", DataTypes.STRING));
1:c2e4eb2: 
1:c2e4eb2:     Expression Orb1 = new OrExpression(new NotEqualsExpression(null, null), greaterThanb2);
1:c2e4eb2:     Expression Orb2 = new OrExpression(Orb1, greaterThanb1);
1:c2e4eb2:     Expression Orb3 = new OrExpression(Orb2, lessThanb2);
1:c2e4eb2: 
1:c2e4eb2:     FilterOptimizer rangeFilterOptimizer =
1:daa6465:         new RangeFilterOptmizer(inputFilter);
1:c2e4eb2:     rangeFilterOptimizer.optimizeFilter();
1:81149f6:     result = checkBothTrees(inputFilter, new OrExpression(Orb3, lessThanb1));
1:c2e4eb2:     // no change
1:c2e4eb2:     Assert.assertTrue(result);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void checkIsScanRequired1() {
1:c2e4eb2:     byte[] BlockMin = { 1 };
1:c2e4eb2:     byte[] BlockMax = { 2 };
1:c2e4eb2:     boolean result;
1:c2e4eb2: 
1:c2e4eb2:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1:c2e4eb2: 
1:c2e4eb2:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:c2e4eb2:     }.getMockInstance();
1:c2e4eb2:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:c2e4eb2:     Deencapsulation.setField(range, "lessThanExp", true);
1:c2e4eb2:     Deencapsulation.setField(range, "greaterThanExp", true);
1:c2e4eb2:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:c2e4eb2:     Assert.assertFalse(result);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void checkIsScanRequired1_1() {
1:c2e4eb2:     byte[] BlockMin = { 21 };
1:c2e4eb2:     byte[] BlockMax = { 22 };
1:c2e4eb2:     boolean result;
1:c2e4eb2: 
1:c2e4eb2:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1:c2e4eb2: 
1:c2e4eb2:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:c2e4eb2:     }.getMockInstance();
1:c2e4eb2:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:c2e4eb2:     Deencapsulation.setField(range, "lessThanExp", true);
1:c2e4eb2:     Deencapsulation.setField(range, "greaterThanExp", true);
1:c2e4eb2:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:c2e4eb2:     Assert.assertFalse(result);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void checkIsScanRequired2() {
1:c2e4eb2:     byte[] BlockMin = { 12 };
1:c2e4eb2:     byte[] BlockMax = { 16 };
1:c2e4eb2:     boolean result;
1:c2e4eb2: 
1:c2e4eb2:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1:c2e4eb2: 
1:c2e4eb2:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:c2e4eb2:     }.getMockInstance();
1:c2e4eb2:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:c2e4eb2:     Deencapsulation.setField(range, "lessThanExp", true);
1:c2e4eb2:     Deencapsulation.setField(range, "greaterThanExp", true);
1:c2e4eb2:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:c2e4eb2:     Assert.assertTrue(result);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void checkIsScanRequired3() {
1:c2e4eb2:     byte[] BlockMin = { 12 };
1:c2e4eb2:     byte[] BlockMax = { 16 };
1:c2e4eb2:     boolean result;
1:c2e4eb2:     boolean rangeCovered;
1:c2e4eb2: 
1:c2e4eb2:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1:c2e4eb2: 
1:c2e4eb2:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:c2e4eb2:     }.getMockInstance();
1:c2e4eb2:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:c2e4eb2:     Deencapsulation.setField(range, "lessThanExp", true);
1:c2e4eb2:     Deencapsulation.setField(range, "greaterThanExp", true);
1:c2e4eb2: 
1:c2e4eb2:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:c2e4eb2:     rangeCovered = Deencapsulation.getField(range, "isRangeFullyCoverBlock");
1:c2e4eb2:     Assert.assertTrue(result);
1:c2e4eb2:     Assert.assertTrue(rangeCovered);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void checkIsScanRequired4() {
1:c2e4eb2:     byte[] BlockMin = { 12 };
1:c2e4eb2:     byte[] BlockMax = { 30 };
1:c2e4eb2:     boolean result;
1:c2e4eb2:     boolean startBlockMinIsDefaultStart;
1:c2e4eb2: 
1:c2e4eb2:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1:c2e4eb2: 
1:c2e4eb2:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:c2e4eb2:     }.getMockInstance();
1:c2e4eb2:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:c2e4eb2:     Deencapsulation.setField(range, "lessThanExp", true);
1:c2e4eb2:     Deencapsulation.setField(range, "greaterThanExp", true);
1:c2e4eb2: 
1:c2e4eb2:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:c2e4eb2:     startBlockMinIsDefaultStart = Deencapsulation.getField(range, "startBlockMinIsDefaultStart");
1:c2e4eb2:     Assert.assertTrue(result);
1:c2e4eb2:     Assert.assertTrue(startBlockMinIsDefaultStart);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @Test public void checkIsScanRequired5() {
1:c2e4eb2:     byte[] BlockMin = { 10 };
1:c2e4eb2:     byte[] BlockMax = { 16 };
1:c2e4eb2:     boolean result;
1:c2e4eb2:     boolean endBlockMaxisDefaultEnd;
1:c2e4eb2: 
1:c2e4eb2:     byte[][] filterMinMax = { { (byte) 15 }, { (byte) 20 } };
1:c2e4eb2: 
1:c2e4eb2:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:c2e4eb2:     }.getMockInstance();
1:c2e4eb2:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:c2e4eb2:     Deencapsulation.setField(range, "lessThanExp", true);
1:c2e4eb2:     Deencapsulation.setField(range, "greaterThanExp", true);
1:c2e4eb2: 
1:c2e4eb2:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:c2e4eb2:     endBlockMaxisDefaultEnd = Deencapsulation.getField(range, "endBlockMaxisDefaultEnd");
1:c2e4eb2:     Assert.assertTrue(result);
1:c2e4eb2:     Assert.assertTrue(endBlockMaxisDefaultEnd);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   @AfterClass public static void testcleanUp() {
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2: }
1:c2e4eb2: 
============================================================================
author:sraghunandan
-------------------------------------------------------------------------------
commit:f911403
/////////////////////////////////////////////////////////////////////////
1:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0);
/////////////////////////////////////////////////////////////////////////
1:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0);
/////////////////////////////////////////////////////////////////////////
1:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0);
/////////////////////////////////////////////////////////////////////////
1:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0);
author:Jacky Li
-------------------------------------------------------------------------------
commit:daa6465
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         new RangeFilterOptmizer(inputFilter);
/////////////////////////////////////////////////////////////////////////
1:         new RangeFilterOptmizer(inputFilter);
/////////////////////////////////////////////////////////////////////////
1:         new RangeFilterOptmizer(inputFilter);
/////////////////////////////////////////////////////////////////////////
1:         new RangeFilterOptmizer(inputFilter);
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
1:     ColumnExpression cola = new ColumnExpression("a", DataTypes.STRING);
/////////////////////////////////////////////////////////////////////////
1:     empColumnSchema.setDataType(DataTypes.STRING);
1:         new GreaterThanEqualToExpression(cola, new LiteralExpression("11", DataTypes.STRING));
1:     ColumnExpression colb = new ColumnExpression("a", DataTypes.STRING);
1:         new LessThanEqualToExpression(colb, new LiteralExpression("20", DataTypes.STRING));
1:         new GreaterThanEqualToExpression(new ColumnExpression("a", DataTypes.STRING),
1:             new LiteralExpression("11", DataTypes.STRING)),
1:         new LessThanEqualToExpression(new ColumnExpression("a", DataTypes.STRING),
1:             new LiteralExpression("20", DataTypes.STRING))), new TrueExpression(null));
/////////////////////////////////////////////////////////////////////////
1:     ColumnExpression cola = new ColumnExpression("a", DataTypes.STRING);
/////////////////////////////////////////////////////////////////////////
1:     empColumnSchema.setDataType(DataTypes.STRING);
1:         new GreaterThanEqualToExpression(cola, new LiteralExpression("20", DataTypes.STRING));
1:     ColumnExpression colb = new ColumnExpression("a", DataTypes.STRING);
1:         new LessThanEqualToExpression(colb, new LiteralExpression("05", DataTypes.STRING));
1:         new GreaterThanEqualToExpression(new ColumnExpression("a", DataTypes.STRING),
1:             new LiteralExpression("20", DataTypes.STRING)),
1:         new LessThanEqualToExpression(new ColumnExpression("a", DataTypes.STRING),
1:             new LiteralExpression("05", DataTypes.STRING)));
/////////////////////////////////////////////////////////////////////////
1:     empColumnSchema.setDataType(DataTypes.STRING);
1:     ColumnExpression cola1 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression cola2 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression cola3 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression cola4 = new ColumnExpression("a", DataTypes.STRING);
1:         new LessThanEqualToExpression(cola1, new LiteralExpression("15", DataTypes.STRING));
1:         new LessThanEqualToExpression(cola2, new LiteralExpression("20", DataTypes.STRING));
1:         new GreaterThanExpression(cola3, new LiteralExpression("12", DataTypes.STRING));
1:         new GreaterThanEqualToExpression(cola4, new LiteralExpression("11", DataTypes.STRING));
/////////////////////////////////////////////////////////////////////////
1:     ColumnExpression colb1 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression colb2 = new ColumnExpression("a", DataTypes.STRING);
1:         new GreaterThanExpression(cola3, new LiteralExpression("12", DataTypes.STRING));
1:         new LessThanEqualToExpression(cola1, new LiteralExpression("15", DataTypes.STRING));
/////////////////////////////////////////////////////////////////////////
1:     empColumnSchema.setDataType(DataTypes.STRING);
1:     ColumnExpression cola1 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression cola2 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression cola3 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression cola4 = new ColumnExpression("a", DataTypes.STRING);
1:         new LessThanEqualToExpression(cola1, new LiteralExpression("15", DataTypes.STRING));
1:         new LessThanEqualToExpression(cola2, new LiteralExpression("20", DataTypes.STRING));
1:         new GreaterThanExpression(cola3, new LiteralExpression("12", DataTypes.STRING));
1:         new GreaterThanEqualToExpression(cola4, new LiteralExpression("11", DataTypes.STRING));
/////////////////////////////////////////////////////////////////////////
1:     ColumnExpression colb1 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression colb2 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression colb3 = new ColumnExpression("a", DataTypes.STRING);
1:     ColumnExpression colb4 = new ColumnExpression("a", DataTypes.STRING);
1:         new LessThanEqualToExpression(colb1, new LiteralExpression("15", DataTypes.STRING));
1:         new LessThanEqualToExpression(colb2, new LiteralExpression("20", DataTypes.STRING));
1:         new GreaterThanExpression(colb3, new LiteralExpression("12", DataTypes.STRING));
1:         new GreaterThanEqualToExpression(colb4, new LiteralExpression("11", DataTypes.STRING));
author:xubo245
-------------------------------------------------------------------------------
commit:e2a2d99
/////////////////////////////////////////////////////////////////////////
author:QiangCai
-------------------------------------------------------------------------------
commit:81149f6
/////////////////////////////////////////////////////////////////////////
1:     inputFilter = new AndExpression(greaterThan, lessThan);
/////////////////////////////////////////////////////////////////////////
1:     inputFilter = new AndExpression(greaterThan, lessThan);
/////////////////////////////////////////////////////////////////////////
1:     inputFilter = new AndExpression(And3, lessThan1);
/////////////////////////////////////////////////////////////////////////
1:     result = checkBothTrees(inputFilter, new AndExpression(Andb3, new TrueExpression(null)));
/////////////////////////////////////////////////////////////////////////
1:     inputFilter = new OrExpression(Or3, lessThan1);
/////////////////////////////////////////////////////////////////////////
1:     result = checkBothTrees(inputFilter, new OrExpression(Orb3, lessThanb1));
author:sounakr
-------------------------------------------------------------------------------
commit:c2e4eb2
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.core.util;
1: 
1: import java.util.Arrays;
1: 
0: import org.apache.carbondata.core.metadata.datatype.DataType;
1: import org.apache.carbondata.core.metadata.encoder.Encoding;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1: import org.apache.carbondata.core.scan.expression.ColumnExpression;
1: import org.apache.carbondata.core.scan.expression.Expression;
1: import org.apache.carbondata.core.scan.expression.LiteralExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanEqualToExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.LessThanEqualToExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.NotEqualsExpression;
1: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1: import org.apache.carbondata.core.scan.expression.logical.RangeExpression;
1: import org.apache.carbondata.core.scan.expression.logical.TrueExpression;
1: import org.apache.carbondata.core.scan.filter.executer.RangeValueFilterExecuterImpl;
1: import org.apache.carbondata.core.scan.filter.intf.FilterOptimizer;
0: import org.apache.carbondata.core.scan.filter.intf.FilterOptimizerBasic;
1: import org.apache.carbondata.core.scan.filter.optimizer.RangeFilterOptmizer;
1: 
1: import mockit.Deencapsulation;
1: import mockit.MockUp;
1: import org.junit.AfterClass;
1: import org.junit.Assert;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: 
1: /* Test Cases for Range Filter */
1: public class RangeFilterProcessorTest {
1:   @BeforeClass public static void setUp() throws Exception {
1:   }
1: 
1:   public boolean checkBothTrees(Expression a, Expression b) {
1: 
1:     if (null == a && null == b) {
1:       return true;
1:     }
1: 
1:     if (null == a) return false;
1:     if (null == b) return false;
1: 
1:     if ((a != null) && (b != null)) {
1:       return ((a.getClass() == b.getClass()) && (
1:           (a.getChildren().size() == 0 && b.getChildren().size() == 0) || (
1:               a.getChildren().size() == 2 && b.getChildren().size() == 2 && checkBothTrees(
1:                   a.getChildren().get(0), b.getChildren().get(0)) && checkBothTrees(
1:                   a.getChildren().get(1), b.getChildren().get(1)))));
1:     }
1:     return false;
1:   }
1: 
1:   @Test public void createFilterTree() {
1: 
1:     Expression inputFilter;
1:     boolean result = false;
0:     ColumnExpression cola = new ColumnExpression("a", DataType.STRING);
1:     cola.setDimension(true);
1: 
1:     ColumnSchema empColumnSchema = new ColumnSchema();
1:     empColumnSchema.setColumnName("empNameCol");
1:     empColumnSchema.setColumnUniqueId("empNameCol");
1:     empColumnSchema.setDimensionColumn(true);
1:     empColumnSchema.setEncodingList(Arrays.asList(Encoding.DICTIONARY));
0:     empColumnSchema.setDataType(DataType.STRING);
0:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0, 0);
1:     cola.setDimension(empDimension);
1: 
1:     Expression greaterThan =
0:         new GreaterThanEqualToExpression(cola, new LiteralExpression("11", DataType.STRING));
1: 
0:     ColumnExpression colb = new ColumnExpression("a", DataType.STRING);
1:     colb.setDimension(true);
1:     colb.setDimension(empDimension);
1:     Expression lessThan =
0:         new LessThanEqualToExpression(colb, new LiteralExpression("20", DataType.STRING));
0:     Expression andExp = new AndExpression(greaterThan, lessThan);
0:     inputFilter = andExp;
1: 
1:     Expression output = new AndExpression(new RangeExpression(
0:         new GreaterThanEqualToExpression(new ColumnExpression("a", DataType.STRING),
0:             new LiteralExpression("11", DataType.STRING)),
0:         new LessThanEqualToExpression(new ColumnExpression("a", DataType.STRING),
0:             new LiteralExpression("20", DataType.STRING))), new TrueExpression(null));
1:     FilterOptimizer rangeFilterOptimizer =
0:         new RangeFilterOptmizer(new FilterOptimizerBasic(), inputFilter);
1:     rangeFilterOptimizer.optimizeFilter();
1:     result = checkBothTrees(inputFilter, output);
1:     Assert.assertTrue(result);
1: 
1:   }
1: 
1:   @Test public void createFilterTree_noChange() {
1: 
1:     // Build 2nd Tree no change a < 5 and a > 20
1: 
1:     Expression inputFilter;
1:     boolean result = false;
0:     ColumnExpression cola = new ColumnExpression("a", DataType.STRING);
1:     cola.setDimension(true);
1: 
1:     ColumnSchema empColumnSchema = new ColumnSchema();
1:     empColumnSchema.setColumnName("empNameCol");
1:     empColumnSchema.setColumnUniqueId("empNameCol");
1:     empColumnSchema.setDimensionColumn(true);
1:     empColumnSchema.setEncodingList(Arrays.asList(Encoding.DICTIONARY));
0:     empColumnSchema.setDataType(DataType.STRING);
0:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0, 0);
1:     cola.setDimension(empDimension);
1: 
1:     Expression greaterThan =
0:         new GreaterThanEqualToExpression(cola, new LiteralExpression("20", DataType.STRING));
1: 
0:     ColumnExpression colb = new ColumnExpression("a", DataType.STRING);
1:     colb.setDimension(true);
1:     colb.setDimension(empDimension);
1:     Expression lessThan =
0:         new LessThanEqualToExpression(colb, new LiteralExpression("05", DataType.STRING));
0:     Expression andExp = new AndExpression(greaterThan, lessThan);
0:     inputFilter = andExp;
1: 
1:     Expression output = new AndExpression(
0:         new GreaterThanEqualToExpression(new ColumnExpression("a", DataType.STRING),
0:             new LiteralExpression("20", DataType.STRING)),
0:         new LessThanEqualToExpression(new ColumnExpression("a", DataType.STRING),
0:             new LiteralExpression("05", DataType.STRING)));
1:     FilterOptimizer rangeFilterOptimizer =
0:         new RangeFilterOptmizer(new FilterOptimizerBasic(), inputFilter);
1:     rangeFilterOptimizer.optimizeFilter();
1:     result = checkBothTrees(inputFilter, output);
1:     // no change
1:     Assert.assertTrue(result);
1:   }
1: 
1:   @Test public void createFilterTree_flavor1() {
1: 
1:     // Build 3rd BTree a >= '11' and a > '12' and a <= '20' and a <= '15'
1: 
1:     Expression inputFilter;
1:     boolean result = false;
1: 
1:     ColumnSchema empColumnSchema = new ColumnSchema();
1:     empColumnSchema.setColumnName("a");
1:     empColumnSchema.setColumnUniqueId("a");
1:     empColumnSchema.setDimensionColumn(true);
1:     empColumnSchema.setEncodingList(Arrays.asList(Encoding.DICTIONARY));
0:     empColumnSchema.setDataType(DataType.STRING);
0:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0, 0);
1: 
0:     ColumnExpression cola1 = new ColumnExpression("a", DataType.STRING);
1:     cola1.setDimension(true);
1:     cola1.setDimension(empDimension);
1: 
0:     ColumnExpression cola2 = new ColumnExpression("a", DataType.STRING);
1:     cola2.setDimension(true);
1:     cola2.setDimension(empDimension);
1: 
0:     ColumnExpression cola3 = new ColumnExpression("a", DataType.STRING);
1:     cola3.setDimension(true);
1:     cola3.setDimension(empDimension);
1: 
0:     ColumnExpression cola4 = new ColumnExpression("a", DataType.STRING);
1:     cola4.setDimension(true);
1:     cola4.setDimension(empDimension);
1: 
1:     Expression lessThan1 =
0:         new LessThanEqualToExpression(cola1, new LiteralExpression("15", DataType.STRING));
1:     Expression lessThan2 =
0:         new LessThanEqualToExpression(cola2, new LiteralExpression("20", DataType.STRING));
1:     Expression greaterThan1 =
0:         new GreaterThanExpression(cola3, new LiteralExpression("12", DataType.STRING));
1:     Expression greaterThan2 =
0:         new GreaterThanEqualToExpression(cola4, new LiteralExpression("11", DataType.STRING));
1: 
1:     Expression And1 = new AndExpression(new NotEqualsExpression(null, null), greaterThan2);
1:     Expression And2 = new AndExpression(And1, greaterThan1);
1:     Expression And3 = new AndExpression(And2, lessThan2);
0:     Expression And4 = new AndExpression(And3, lessThan1);
0:     inputFilter = And4;
1: 
1:     // Build The output
1: 
0:     ColumnExpression colb1 = new ColumnExpression("a", DataType.STRING);
1:     cola1.setDimension(true);
1:     cola1.setDimension(empDimension);
1: 
0:     ColumnExpression colb2 = new ColumnExpression("a", DataType.STRING);
1:     cola2.setDimension(true);
1:     cola2.setDimension(empDimension);
1: 
1:     Expression greaterThanb1 =
0:         new GreaterThanExpression(cola3, new LiteralExpression("12", DataType.STRING));
1: 
1:     Expression lessThanb1 =
0:         new LessThanEqualToExpression(cola1, new LiteralExpression("15", DataType.STRING));
1: 
1:     Expression Andb1 =
1:         new AndExpression(new NotEqualsExpression(null, null), new TrueExpression(null));
1: 
1:     Expression Andb2 = new AndExpression(Andb1, new RangeExpression(greaterThanb1, lessThanb1));
1:     Expression Andb3 = new AndExpression(Andb2, new TrueExpression(null));
0:     Expression Andb4 = new AndExpression(Andb3, new TrueExpression(null));
1: 
0:     Expression output = Andb4;
1: 
1:     FilterOptimizer rangeFilterOptimizer =
0:         new RangeFilterOptmizer(new FilterOptimizerBasic(), inputFilter);
1:     rangeFilterOptimizer.optimizeFilter();
1:     result = checkBothTrees(inputFilter, output);
1:     // no change
1:     Assert.assertTrue(result);
1:   }
1: 
1:   @Test public void createFilterTree_flavor2() {
1: 
1:     // Build 3rd BTree a >= '11' or a > '12' or a <= '20' or a <= '15'
1: 
1:     Expression inputFilter;
1:     boolean result = false;
1: 
1:     ColumnSchema empColumnSchema = new ColumnSchema();
1:     empColumnSchema.setColumnName("a");
1:     empColumnSchema.setColumnUniqueId("a");
1:     empColumnSchema.setDimensionColumn(true);
1:     empColumnSchema.setEncodingList(Arrays.asList(Encoding.DICTIONARY));
0:     empColumnSchema.setDataType(DataType.STRING);
0:     CarbonDimension empDimension = new CarbonDimension(empColumnSchema, 0, 0, 0, 0, 0);
1: 
0:     ColumnExpression cola1 = new ColumnExpression("a", DataType.STRING);
1:     cola1.setDimension(true);
1:     cola1.setDimension(empDimension);
1: 
0:     ColumnExpression cola2 = new ColumnExpression("a", DataType.STRING);
1:     cola2.setDimension(true);
1:     cola2.setDimension(empDimension);
1: 
0:     ColumnExpression cola3 = new ColumnExpression("a", DataType.STRING);
1:     cola3.setDimension(true);
1:     cola3.setDimension(empDimension);
1: 
0:     ColumnExpression cola4 = new ColumnExpression("a", DataType.STRING);
1:     cola4.setDimension(true);
1:     cola4.setDimension(empDimension);
1: 
1:     Expression lessThan1 =
0:         new LessThanEqualToExpression(cola1, new LiteralExpression("15", DataType.STRING));
1:     Expression lessThan2 =
0:         new LessThanEqualToExpression(cola2, new LiteralExpression("20", DataType.STRING));
1:     Expression greaterThan1 =
0:         new GreaterThanExpression(cola3, new LiteralExpression("12", DataType.STRING));
1:     Expression greaterThan2 =
0:         new GreaterThanEqualToExpression(cola4, new LiteralExpression("11", DataType.STRING));
1: 
1:     Expression Or1 = new OrExpression(new NotEqualsExpression(null, null), greaterThan2);
1:     Expression Or2 = new OrExpression(Or1, greaterThan1);
1:     Expression Or3 = new OrExpression(Or2, lessThan2);
0:     Expression Or4 = new OrExpression(Or3, lessThan1);
0:     inputFilter = Or4;
1: 
1:     // Build The output
1: 
0:     ColumnExpression colb1 = new ColumnExpression("a", DataType.STRING);
1:     cola1.setDimension(true);
1:     cola1.setDimension(empDimension);
1: 
0:     ColumnExpression colb2 = new ColumnExpression("a", DataType.STRING);
1:     cola2.setDimension(true);
1:     cola2.setDimension(empDimension);
1: 
0:     ColumnExpression colb3 = new ColumnExpression("a", DataType.STRING);
1:     cola3.setDimension(true);
1:     cola3.setDimension(empDimension);
1: 
0:     ColumnExpression colb4 = new ColumnExpression("a", DataType.STRING);
1:     cola4.setDimension(true);
1:     cola4.setDimension(empDimension);
1: 
1:     Expression lessThanb1 =
0:         new LessThanEqualToExpression(colb1, new LiteralExpression("15", DataType.STRING));
1:     Expression lessThanb2 =
0:         new LessThanEqualToExpression(colb2, new LiteralExpression("20", DataType.STRING));
1:     Expression greaterThanb1 =
0:         new GreaterThanExpression(colb3, new LiteralExpression("12", DataType.STRING));
1:     Expression greaterThanb2 =
0:         new GreaterThanEqualToExpression(colb4, new LiteralExpression("11", DataType.STRING));
1: 
1:     Expression Orb1 = new OrExpression(new NotEqualsExpression(null, null), greaterThanb2);
1:     Expression Orb2 = new OrExpression(Orb1, greaterThanb1);
1:     Expression Orb3 = new OrExpression(Orb2, lessThanb2);
0:     Expression Orb4 = new OrExpression(Orb3, lessThanb1);
0:     Expression output = Orb4;
1: 
1:     FilterOptimizer rangeFilterOptimizer =
0:         new RangeFilterOptmizer(new FilterOptimizerBasic(), inputFilter);
1:     rangeFilterOptimizer.optimizeFilter();
1:     result = checkBothTrees(inputFilter, output);
1:     // no change
1:     Assert.assertTrue(result);
1:   }
1: 
1:   @Test public void checkIsScanRequired1() {
1:     byte[] BlockMin = { 1 };
1:     byte[] BlockMax = { 2 };
1:     boolean result;
1: 
1:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1: 
1:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:     }.getMockInstance();
1:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:     Deencapsulation.setField(range, "lessThanExp", true);
1:     Deencapsulation.setField(range, "greaterThanExp", true);
1:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:     Assert.assertFalse(result);
1:   }
1: 
1:   @Test public void checkIsScanRequired1_1() {
1:     byte[] BlockMin = { 21 };
1:     byte[] BlockMax = { 22 };
1:     boolean result;
1: 
1:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1: 
1:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:     }.getMockInstance();
1:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:     Deencapsulation.setField(range, "lessThanExp", true);
1:     Deencapsulation.setField(range, "greaterThanExp", true);
1:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:     Assert.assertFalse(result);
1:   }
1: 
1:   @Test public void checkIsScanRequired2() {
1:     byte[] BlockMin = { 12 };
1:     byte[] BlockMax = { 16 };
1:     boolean result;
1: 
1:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1: 
1:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:     }.getMockInstance();
1:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:     Deencapsulation.setField(range, "lessThanExp", true);
1:     Deencapsulation.setField(range, "greaterThanExp", true);
1:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:     Assert.assertTrue(result);
1:   }
1: 
1:   @Test public void checkIsScanRequired3() {
1:     byte[] BlockMin = { 12 };
1:     byte[] BlockMax = { 16 };
1:     boolean result;
1:     boolean rangeCovered;
1: 
1:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1: 
1:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:     }.getMockInstance();
1:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:     Deencapsulation.setField(range, "lessThanExp", true);
1:     Deencapsulation.setField(range, "greaterThanExp", true);
1: 
1:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:     rangeCovered = Deencapsulation.getField(range, "isRangeFullyCoverBlock");
1:     Assert.assertTrue(result);
1:     Assert.assertTrue(rangeCovered);
1:   }
1: 
1:   @Test public void checkIsScanRequired4() {
1:     byte[] BlockMin = { 12 };
1:     byte[] BlockMax = { 30 };
1:     boolean result;
1:     boolean startBlockMinIsDefaultStart;
1: 
1:     byte[][] filterMinMax = { { (byte) 10 }, { (byte) 20 } };
1: 
1:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:     }.getMockInstance();
1:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:     Deencapsulation.setField(range, "lessThanExp", true);
1:     Deencapsulation.setField(range, "greaterThanExp", true);
1: 
1:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:     startBlockMinIsDefaultStart = Deencapsulation.getField(range, "startBlockMinIsDefaultStart");
1:     Assert.assertTrue(result);
1:     Assert.assertTrue(startBlockMinIsDefaultStart);
1:   }
1: 
1:   @Test public void checkIsScanRequired5() {
1:     byte[] BlockMin = { 10 };
1:     byte[] BlockMax = { 16 };
1:     boolean result;
1:     boolean endBlockMaxisDefaultEnd;
1: 
1:     byte[][] filterMinMax = { { (byte) 15 }, { (byte) 20 } };
1: 
1:     RangeValueFilterExecuterImpl range = new MockUp<RangeValueFilterExecuterImpl>() {
1:     }.getMockInstance();
1:     Deencapsulation.setField(range, "isDimensionPresentInCurrentBlock", true);
1:     Deencapsulation.setField(range, "lessThanExp", true);
1:     Deencapsulation.setField(range, "greaterThanExp", true);
1: 
1:     result = range.isScanRequired(BlockMin, BlockMax, filterMinMax);
1:     endBlockMaxisDefaultEnd = Deencapsulation.getField(range, "endBlockMaxisDefaultEnd");
1:     Assert.assertTrue(result);
1:     Assert.assertTrue(endBlockMaxisDefaultEnd);
1:   }
1: 
1:   @AfterClass public static void testcleanUp() {
1:   }
1: 
1: }
1: 
============================================================================