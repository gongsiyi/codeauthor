1:f1f9348: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
2:f1f9348:  *
1:f1f9348:  *    http://www.apache.org/licenses/LICENSE-2.0
1:f1f9348:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
1:f1f9348:  */
1:349c59c: package org.apache.carbondata.processing.loading.sort.unsafe.sort;
2:f1f9348: 
1:f1f9348: import java.util.Comparator;
1:f1f9348: 
2:f1f9348: /**
1:f1f9348:  * A port of the Apache Spark's TimSort and they originally ported from Android TimSort class,
1:f1f9348:  * which utilizes a "stable, adaptive, iterative mergesort."
1:f1f9348:  * See the method comment on sort() for more details.
1:f1f9348:  *
1:f1f9348:  * This has been kept in Java with the original style in order to match very closely with the
1:f1f9348:  * Android source code, and thus be easy to verify correctness. The class is package private. We put
1:f1f9348:  * a simple Scala wrapper {@link org.apache.spark.util.collection.Sorter}, which is available to
1:f1f9348:  * package org.apache.spark.
1:f1f9348:  *
1:f1f9348:  * The purpose of the port is to generalize the interface to the sort to accept input data formats
1:f1f9348:  * besides simple arrays where every element is sorted individually. For instance, the AppendOnlyMap
1:f1f9348:  * uses this to sort an Array with alternating elements of the form [key, value, key, value].
1:f1f9348:  * This generalization comes with minimal overhead -- see SortDataFormat for more information.
1:f1f9348:  *
1:f1f9348:  * We allow key reuse to prevent creating many key objects -- see SortDataFormat.
1:f1f9348:  *
1:f1f9348:  * @see SortDataFormat
1:f1f9348:  * @see org.apache.spark.util.collection.Sorter
1:f1f9348:  */
1:f1f9348: public class TimSort<K, Buffer> {
1:f1f9348: 
1:f1f9348:   /**
1:f1f9348:    * This is the minimum sized sequence that will be merged.  Shorter
1:f1f9348:    * sequences will be lengthened by calling binarySort.  If the entire
1:f1f9348:    * array is less than this length, no merges will be performed.
1:f1f9348:    *
1:f1f9348:    * This constant should be a power of two.  It was 64 in Tim Peter's C
1:f1f9348:    * implementation, but 32 was empirically determined to work better in
1:f1f9348:    * this implementation.  In the unlikely event that you set this constant
1:f1f9348:    * to be a number that's not a power of two, you'll need to change the
1:f1f9348:    * minRunLength computation.
1:f1f9348:    *
1:f1f9348:    * If you decrease this constant, you must change the stackLen
1:f1f9348:    * computation in the TimSort constructor, or you risk an
1:f1f9348:    * ArrayOutOfBounds exception.  See listsort.txt for a discussion
1:f1f9348:    * of the minimum stack length required as a function of the length
1:f1f9348:    * of the array being sorted and the minimum merge sequence length.
1:f1f9348:    */
1:f1f9348:   private static final int MIN_MERGE = 32;
1:f1f9348: 
1:f1f9348:   private final SortDataFormat<K, Buffer> s;
1:f1f9348: 
1:f1f9348:   public TimSort(SortDataFormat<K, Buffer> sortDataFormat) {
1:f1f9348:     this.s = sortDataFormat;
1:f1f9348:   }
1:f1f9348: 
1:f1f9348:   /**
1:f1f9348:    * A stable, adaptive, iterative mergesort that requires far fewer than
1:f1f9348:    * n lg(n) comparisons when running on partially sorted arrays, while
1:f1f9348:    * offering performance comparable to a traditional mergesort when run
1:f1f9348:    * on random arrays.  Like all proper mergesorts, this sort is stable and
1:f1f9348:    * runs O(n log n) time (worst case).  In the worst case, this sort requires
1:f1f9348:    * temporary storage space for n/2 object references; in the best case,
1:f1f9348:    * it requires only a small constant amount of space.
1:f1f9348:    *
1:f1f9348:    * This implementation was adapted from Tim Peters's list sort for
1:f1f9348:    * Python, which is described in detail here:
1:f1f9348:    *
1:f1f9348:    *   http://svn.python.org/projects/python/trunk/Objects/listsort.txt
1:f1f9348:    *
1:f1f9348:    * Tim's C code may be found here:
1:f1f9348:    *
1:f1f9348:    *   http://svn.python.org/projects/python/trunk/Objects/listobject.c
1:f1f9348:    *
1:f1f9348:    * The underlying techniques are described in this paper (and may have
1:f1f9348:    * even earlier origins):
1:f1f9348:    *
1:f1f9348:    *  "Optimistic Sorting and Information Theoretic Complexity"
1:f1f9348:    *  Peter McIlroy
1:f1f9348:    *  SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
1:f1f9348:    *  pp 467-474, Austin, Texas, 25-27 January 1993.
1:f1f9348:    *
1:f1f9348:    * While the API to this class consists solely of static methods, it is
1:f1f9348:    * (privately) instantiable; a TimSort instance holds the state of an ongoing
1:f1f9348:    * sort, assuming the input array is large enough to warrant the full-blown
1:f1f9348:    * TimSort. Small arrays are sorted in place, using a binary insertion sort.
1:f1f9348:    */
1:f1f9348:   public void sort(Buffer a, int lo, int hi, Comparator<? super K> c) {
1:f1f9348:     assert c != null;
1:f1f9348: 
1:f1f9348:     int nRemaining  = hi - lo;
1:002279e:     if (nRemaining < 2) {
1:f1f9348:       return;  // Arrays of size 0 and 1 are always sorted
1:002279e:     }
1:f1f9348: 
1:f1f9348:     // If array is small, do a "mini-TimSort" with no merges
1:f1f9348:     if (nRemaining < MIN_MERGE) {
1:f1f9348:       int initRunLen = countRunAndMakeAscending(a, lo, hi, c);
1:f1f9348:       binarySort(a, lo, hi, lo + initRunLen, c);
1:f1f9348:       return;
1:f1f9348:     }
1:f1f9348: 
1:086b06d:     /*
1:f1f9348:      * March over the array once, left to right, finding natural runs,
1:f1f9348:      * extending short natural runs to minRun elements, and merging runs
1:f1f9348:      * to maintain stack invariant.
1:f1f9348:      */
1:f1f9348:     SortState sortState = new SortState(a, c, hi - lo);
1:f1f9348:     int minRun = minRunLength(nRemaining);
1:f1f9348:     do {
1:f1f9348:       // Identify next run
1:f1f9348:       int runLen = countRunAndMakeAscending(a, lo, hi, c);
1:f1f9348: 
1:f1f9348:       // If run is short, extend to min(minRun, nRemaining)
1:f1f9348:       if (runLen < minRun) {
1:f1f9348:         int force = nRemaining <= minRun ? nRemaining : minRun;
1:f1f9348:         binarySort(a, lo, lo + force, lo + runLen, c);
1:f1f9348:         runLen = force;
1:f1f9348:       }
1:f1f9348: 
1:f1f9348:       // Push run onto pending-run stack, and maybe merge
1:f1f9348:       sortState.pushRun(lo, runLen);
1:f1f9348:       sortState.mergeCollapse();
1:f1f9348: 
1:f1f9348:       // Advance to find next run
1:f1f9348:       lo += runLen;
1:f1f9348:       nRemaining -= runLen;
1:f1f9348:     } while (nRemaining != 0);
1:f1f9348: 
1:f1f9348:     // Merge all remaining runs to complete sort
1:f1f9348:     assert lo == hi;
1:f1f9348:     sortState.mergeForceCollapse();
1:f1f9348:     assert sortState.stackSize == 1;
1:f1f9348:   }
1:f1f9348: 
1:f1f9348:   /**
1:f1f9348:    * Sorts the specified portion of the specified array using a binary
1:f1f9348:    * insertion sort.  This is the best method for sorting small numbers
1:f1f9348:    * of elements.  It requires O(n log n) compares, but O(n^2) data
1:f1f9348:    * movement (worst case).
1:f1f9348:    *
1:f1f9348:    * If the initial part of the specified range is already sorted,
1:f1f9348:    * this method can take advantage of it: the method assumes that the
1:f1f9348:    * elements from index {@code lo}, inclusive, to {@code start},
1:f1f9348:    * exclusive are already sorted.
1:f1f9348:    *
1:f1f9348:    * @param a the array in which a range is to be sorted
1:f1f9348:    * @param lo the index of the first element in the range to be sorted
1:f1f9348:    * @param hi the index after the last element in the range to be sorted
1:f1f9348:    * @param start the index of the first element in the range that is
1:f1f9348:    *        not already known to be sorted ({@code lo <= start <= hi})
1:f1f9348:    * @param c comparator to used for the sort
1:f1f9348:    */
1:f1f9348:   @SuppressWarnings("fallthrough")
1:f1f9348:   private void binarySort(Buffer a, int lo, int hi, int start, Comparator<? super K> c) {
1:f1f9348:     assert lo <= start && start <= hi;
1:002279e:     if (start == lo) {
1:f1f9348:       start++;
1:002279e:     }
1:f1f9348: 
1:f1f9348:     K key0 = s.newKey();
1:f1f9348:     K key1 = s.newKey();
1:f1f9348: 
1:f1f9348:     Buffer pivotStore = s.allocate(1);
1:f1f9348:     for ( ; start < hi; start++) {
1:f1f9348:       s.copyElement(a, start, pivotStore, 0);
1:f1f9348:       K pivot = s.getKey(pivotStore, 0, key0);
1:f1f9348: 
1:f1f9348:       // Set left (and right) to the index where a[start] (pivot) belongs
1:f1f9348:       int left = lo;
1:f1f9348:       int right = start;
1:f1f9348:       assert left <= right;
1:f1f9348:       /*
1:f1f9348:        * Invariants:
1:f1f9348:        *   pivot >= all in [lo, left).
1:f1f9348:        *   pivot <  all in [right, start).
1:f1f9348:        */
1:f1f9348:       while (left < right) {
1:f1f9348:         int mid = (left + right) >>> 1;
1:002279e:         if (c.compare(pivot, s.getKey(a, mid, key1)) < 0) {
1:f1f9348:           right = mid;
1:002279e:         }
1:002279e:         else {
1:f1f9348:           left = mid + 1;
1:002279e:         }
1:f1f9348:       }
1:f1f9348:       assert left == right;
1:f1f9348: 
1:f1f9348:       /*
1:f1f9348:        * The invariants still hold: pivot >= all in [lo, left) and
1:f1f9348:        * pivot < all in [left, start), so pivot belongs at left.  Note
1:f1f9348:        * that if there are elements equal to pivot, left points to the
1:f1f9348:        * first slot after them -- that's why this sort is stable.
1:f1f9348:        * Slide elements over to make room for pivot.
1:f1f9348:        */
1:f1f9348:       int n = start - left;  // The number of elements to move
1:f1f9348:       // Switch is just an optimization for arraycopy in default case
1:f1f9348:       switch (n) {
1:002279e:         case 2:  {
1:002279e:           s.copyElement(a, left + 1, a, left + 2);
1:002279e:           s.copyElement(a, left, a, left + 1);
1:f1f9348:           break;
1:002279e:         }
1:002279e:         case 1:  {
1:002279e:           s.copyElement(a, left, a, left + 1);
1:002279e:           break;
1:002279e:         }
1:f1f9348:         default: s.copyRange(a, left, a, left + 1, n);
1:f1f9348:       }
1:f1f9348:       s.copyElement(pivotStore, 0, a, left);
1:f1f9348:     }
1:f1f9348:   }
1:f1f9348: 
1:f1f9348:   /**
1:f1f9348:    * Returns the length of the run beginning at the specified position in
1:f1f9348:    * the specified array and reverses the run if it is descending (ensuring
1:f1f9348:    * that the run will always be ascending when the method returns).
1:f1f9348:    *
1:f1f9348:    * A run is the longest ascending sequence with:
1:f1f9348:    *
1:f1f9348:    *    a[lo] <= a[lo + 1] <= a[lo + 2] <= ...
1:f1f9348:    *
1:f1f9348:    * or the longest descending sequence with:
1:f1f9348:    *
1:f1f9348:    *    a[lo] >  a[lo + 1] >  a[lo + 2] >  ...
1:f1f9348:    *
1:f1f9348:    * For its intended use in a stable mergesort, the strictness of the
1:f1f9348:    * definition of "descending" is needed so that the call can safely
1:f1f9348:    * reverse a descending sequence without violating stability.
1:f1f9348:    *
1:f1f9348:    * @param a the array in which a run is to be counted and possibly reversed
1:f1f9348:    * @param lo index of the first element in the run
1:f1f9348:    * @param hi index after the last element that may be contained in the run.
1:f1f9348:   It is required that {@code lo < hi}.
1:f1f9348:    * @param c the comparator to used for the sort
1:f1f9348:    * @return  the length of the run beginning at the specified position in
1:f1f9348:    *          the specified array
1:f1f9348:    */
1:f1f9348:   private int countRunAndMakeAscending(Buffer a, int lo, int hi, Comparator<? super K> c) {
1:f1f9348:     assert lo < hi;
1:f1f9348:     int runHi = lo + 1;
1:002279e:     if (runHi == hi) {
1:f1f9348:       return 1;
1:002279e:     }
1:f1f9348: 
1:f1f9348:     K key0 = s.newKey();
1:f1f9348:     K key1 = s.newKey();
1:f1f9348: 
1:f1f9348:     // Find end of run, and reverse range if descending
1:f1f9348:     if (c.compare(s.getKey(a, runHi++, key0), s.getKey(a, lo, key1)) < 0) { // Descending
1:002279e:       while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) < 0) {
1:f1f9348:         runHi++;
1:002279e:       }
1:f1f9348:       reverseRange(a, lo, runHi);
1:f1f9348:     } else {                              // Ascending
1:002279e:       while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) >= 0) {
1:f1f9348:         runHi++;
1:002279e:       }
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     return runHi - lo;
1:f1f9348:   }
1:f1f9348: 
1:f1f9348:   /**
1:f1f9348:    * Reverse the specified range of the specified array.
1:f1f9348:    *
1:f1f9348:    * @param a the array in which a range is to be reversed
1:f1f9348:    * @param lo the index of the first element in the range to be reversed
1:f1f9348:    * @param hi the index after the last element in the range to be reversed
1:f1f9348:    */
1:f1f9348:   private void reverseRange(Buffer a, int lo, int hi) {
1:f1f9348:     hi--;
1:f1f9348:     while (lo < hi) {
1:f1f9348:       s.swap(a, lo, hi);
1:f1f9348:       lo++;
1:f1f9348:       hi--;
1:f1f9348:     }
1:f1f9348:   }
1:f1f9348: 
1:f1f9348:   /**
1:f1f9348:    * Returns the minimum acceptable run length for an array of the specified
1:f1f9348:    * length. Natural runs shorter than this will be extended with
1:f1f9348:    * {@link #binarySort}.
1:f1f9348:    *
1:f1f9348:    * Roughly speaking, the computation is:
1:f1f9348:    *
1:f1f9348:    *  If n < MIN_MERGE, return n (it's too small to bother with fancy stuff).
1:f1f9348:    *  Else if n is an exact power of 2, return MIN_MERGE/2.
1:f1f9348:    *  Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k
1:f1f9348:    *   is close to, but strictly less than, an exact power of 2.
1:f1f9348:    *
1:f1f9348:    * For the rationale, see listsort.txt.
1:f1f9348:    *
1:f1f9348:    * @param n the length of the array to be sorted
1:f1f9348:    * @return the length of the minimum run to be merged
1:f1f9348:    */
1:f1f9348:   private int minRunLength(int n) {
1:f1f9348:     assert n >= 0;
1:f1f9348:     int r = 0;      // Becomes 1 if any 1 bits are shifted off
1:f1f9348:     while (n >= MIN_MERGE) {
1:f1f9348:       r |= (n & 1);
1:f1f9348:       n >>= 1;
1:f1f9348:     }
1:f1f9348:     return n + r;
1:f1f9348:   }
1:f1f9348: 
1:f1f9348:   private class SortState {
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * The Buffer being sorted.
1:f1f9348:      */
1:f1f9348:     private final Buffer a;
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Length of the sort Buffer.
1:f1f9348:      */
1:f1f9348:     private final int aLength;
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * The comparator for this sort.
1:f1f9348:      */
1:f1f9348:     private final Comparator<? super K> c;
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * When we get into galloping mode, we stay there until both runs win less
1:f1f9348:      * often than MIN_GALLOP consecutive times.
1:f1f9348:      */
1:f1f9348:     private static final int  MIN_GALLOP = 7;
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * This controls when we get *into* galloping mode.  It is initialized
1:f1f9348:      * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
1:f1f9348:      * random data, and lower for highly structured data.
1:f1f9348:      */
1:f1f9348:     private int minGallop = MIN_GALLOP;
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Maximum initial size of tmp array, which is used for merging.  The array
1:f1f9348:      * can grow to accommodate demand.
1:f1f9348:      *
1:f1f9348:      * Unlike Tim's original C version, we do not allocate this much storage
1:f1f9348:      * when sorting smaller arrays.  This change was required for performance.
1:f1f9348:      */
1:f1f9348:     private static final int INITIAL_TMP_STORAGE_LENGTH = 256;
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Temp storage for merges.
1:f1f9348:      */
1:f1f9348:     private Buffer tmp; // Actual runtime type will be Object[], regardless of T
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Length of the temp storage.
1:f1f9348:      */
1:f1f9348:     private int tmpLength = 0;
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * A stack of pending runs yet to be merged.  Run i starts at
1:f1f9348:      * address base[i] and extends for len[i] elements.  It's always
1:f1f9348:      * true (so long as the indices are in bounds) that:
1:f1f9348:      *
1:f1f9348:      *     runBase[i] + runLen[i] == runBase[i + 1]
1:f1f9348:      *
1:f1f9348:      * so we could cut the storage for this, but it's a minor amount,
1:f1f9348:      * and keeping all the info explicit simplifies the code.
1:f1f9348:      */
1:f1f9348:     private int stackSize = 0;  // Number of pending runs on stack
1:f1f9348:     private final int[] runBase;
1:f1f9348:     private final int[] runLen;
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Creates a TimSort instance to maintain the state of an ongoing sort.
1:f1f9348:      *
1:f1f9348:      * @param a the array to be sorted
1:f1f9348:      * @param c the comparator to determine the order of the sort
1:f1f9348:      */
1:f1f9348:     private SortState(Buffer a, Comparator<? super K> c, int len) {
1:f1f9348:       this.aLength = len;
1:f1f9348:       this.a = a;
1:f1f9348:       this.c = c;
1:f1f9348: 
1:f1f9348:       // Allocate temp storage (which may be increased later if necessary)
1:f1f9348:       tmpLength = len < 2 * INITIAL_TMP_STORAGE_LENGTH ? len >>> 1 : INITIAL_TMP_STORAGE_LENGTH;
1:f1f9348:       tmp = s.allocate(tmpLength);
1:f1f9348: 
1:f1f9348:       /*
1:f1f9348:        * Allocate runs-to-be-merged stack (which cannot be expanded).  The
1:f1f9348:        * stack length requirements are described in listsort.txt.  The C
1:f1f9348:        * version always uses the same stack length (85), but this was
1:f1f9348:        * measured to be too expensive when sorting "mid-sized" arrays (e.g.,
1:f1f9348:        * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
1:f1f9348:        * large) stack lengths for smaller arrays.  The "magic numbers" in the
1:f1f9348:        * computation below must be changed if MIN_MERGE is decreased.  See
1:f1f9348:        * the MIN_MERGE declaration above for more information.
1:f1f9348:        */
1:f1f9348:       int stackLen = (len <    120  ?  5 :
1:f1f9348:                       len <   1542  ? 10 :
1:f1f9348:                       len < 119151  ? 19 : 40);
1:f1f9348:       runBase = new int[stackLen];
1:f1f9348:       runLen = new int[stackLen];
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Pushes the specified run onto the pending-run stack.
1:f1f9348:      *
1:f1f9348:      * @param runBase index of the first element in the run
1:f1f9348:      * @param runLen  the number of elements in the run
1:f1f9348:      */
1:f1f9348:     private void pushRun(int runBase, int runLen) {
1:f1f9348:       this.runBase[stackSize] = runBase;
1:f1f9348:       this.runLen[stackSize] = runLen;
1:f1f9348:       stackSize++;
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Examines the stack of runs waiting to be merged and merges adjacent runs
1:f1f9348:      * until the stack invariants are reestablished:
1:f1f9348:      *
1:f1f9348:      *     1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]
1:f1f9348:      *     2. runLen[i - 2] > runLen[i - 1]
1:f1f9348:      *
1:f1f9348:      * This method is called each time a new run is pushed onto the stack,
1:f1f9348:      * so the invariants are guaranteed to hold for i < stackSize upon
1:f1f9348:      * entry to the method.
1:f1f9348:      */
1:f1f9348:     private void mergeCollapse() {
1:f1f9348:       while (stackSize > 1) {
1:f1f9348:         int n = stackSize - 2;
1:9e932d1:         if ((n >= 1 && runLen[n - 1] <= runLen[n] + runLen[n + 1])
1:9e932d1:             || (n >= 2 && runLen[n - 2] <= runLen[n] + runLen[n - 1])) {
1:002279e:           if (runLen[n - 1] < runLen[n + 1]) {
1:f1f9348:             n--;
1:002279e:           }
1:f1f9348:         } else if (runLen[n] > runLen[n + 1]) {
1:f1f9348:           break; // Invariant is established
1:f1f9348:         }
1:f1f9348:         mergeAt(n);
1:f1f9348:       }
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Merges all runs on the stack until only one remains.  This method is
1:f1f9348:      * called once, to complete the sort.
1:f1f9348:      */
1:f1f9348:     private void mergeForceCollapse() {
1:f1f9348:       while (stackSize > 1) {
1:f1f9348:         int n = stackSize - 2;
1:002279e:         if (n > 0 && runLen[n - 1] < runLen[n + 1]) {
1:f1f9348:           n--;
1:002279e:         }
1:f1f9348:         mergeAt(n);
1:f1f9348:       }
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Merges the two runs at stack indices i and i+1.  Run i must be
1:f1f9348:      * the penultimate or antepenultimate run on the stack.  In other words,
1:f1f9348:      * i must be equal to stackSize-2 or stackSize-3.
1:f1f9348:      *
1:f1f9348:      * @param i stack index of the first of the two runs to merge
1:f1f9348:      */
1:f1f9348:     private void mergeAt(int i) {
1:f1f9348:       assert stackSize >= 2;
1:f1f9348:       assert i >= 0;
1:f1f9348:       assert i == stackSize - 2 || i == stackSize - 3;
1:f1f9348: 
1:f1f9348:       int base1 = runBase[i];
1:f1f9348:       int len1 = runLen[i];
1:f1f9348:       int base2 = runBase[i + 1];
1:f1f9348:       int len2 = runLen[i + 1];
1:f1f9348:       assert len1 > 0 && len2 > 0;
1:f1f9348:       assert base1 + len1 == base2;
1:f1f9348: 
1:f1f9348:       /*
1:f1f9348:        * Record the length of the combined runs; if i is the 3rd-last
1:f1f9348:        * run now, also slide over the last run (which isn't involved
1:f1f9348:        * in this merge).  The current run (i+1) goes away in any case.
1:f1f9348:        */
1:f1f9348:       runLen[i] = len1 + len2;
1:f1f9348:       if (i == stackSize - 3) {
1:f1f9348:         runBase[i + 1] = runBase[i + 2];
1:f1f9348:         runLen[i + 1] = runLen[i + 2];
1:f1f9348:       }
1:f1f9348:       stackSize--;
1:f1f9348: 
1:f1f9348:       K key0 = s.newKey();
1:f1f9348: 
1:f1f9348:       /*
1:f1f9348:        * Find where the first element of run2 goes in run1. Prior elements
1:f1f9348:        * in run1 can be ignored (because they're already in place).
1:f1f9348:        */
1:f1f9348:       int k = gallopRight(s.getKey(a, base2, key0), a, base1, len1, 0, c);
1:f1f9348:       assert k >= 0;
1:f1f9348:       base1 += k;
1:f1f9348:       len1 -= k;
1:002279e:       if (len1 == 0) {
1:f1f9348:         return;
1:002279e:       }
1:f1f9348: 
1:f1f9348:       /*
1:f1f9348:        * Find where the last element of run1 goes in run2. Subsequent elements
1:f1f9348:        * in run2 can be ignored (because they're already in place).
1:f1f9348:        */
1:f1f9348:       len2 = gallopLeft(s.getKey(a, base1 + len1 - 1, key0), a, base2, len2, len2 - 1, c);
1:f1f9348:       assert len2 >= 0;
1:002279e:       if (len2 == 0) {
1:f1f9348:         return;
1:002279e:       }
1:f1f9348: 
1:f1f9348:       // Merge remaining runs, using tmp array with min(len1, len2) elements
1:002279e:       if (len1 <= len2) {
1:f1f9348:         mergeLo(base1, len1, base2, len2);
1:002279e:       }
1:002279e:       else {
1:f1f9348:         mergeHi(base1, len1, base2, len2);
1:002279e:       }
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Locates the position at which to insert the specified key into the
1:f1f9348:      * specified sorted range; if the range contains an element equal to key,
1:f1f9348:      * returns the index of the leftmost equal element.
1:f1f9348:      *
1:f1f9348:      * @param key the key whose insertion point to search for
1:f1f9348:      * @param a the array in which to search
1:f1f9348:      * @param base the index of the first element in the range
1:f1f9348:      * @param len the length of the range; must be > 0
1:f1f9348:      * @param hint the index at which to begin the search, 0 <= hint < n.
1:f1f9348:      *     The closer hint is to the result, the faster this method will run.
1:f1f9348:      * @param c the comparator used to order the range, and to search
1:f1f9348:      * @return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
1:f1f9348:      *    pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
1:f1f9348:      *    In other words, key belongs at index b + k; or in other words,
1:f1f9348:      *    the first k elements of a should precede key, and the last n - k
1:f1f9348:      *    should follow it.
1:f1f9348:      */
1:f1f9348:     private int gallopLeft(K key, Buffer a, int base, int len, int hint, Comparator<? super K> c) {
1:f1f9348:       assert len > 0 && hint >= 0 && hint < len;
1:f1f9348:       int lastOfs = 0;
1:f1f9348:       int ofs = 1;
1:f1f9348:       K key0 = s.newKey();
1:f1f9348: 
1:f1f9348:       if (c.compare(key, s.getKey(a, base + hint, key0)) > 0) {
1:f1f9348:         // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
1:f1f9348:         int maxOfs = len - hint;
1:f1f9348:         while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint + ofs, key0)) > 0) {
1:f1f9348:           lastOfs = ofs;
1:f1f9348:           ofs = (ofs << 1) + 1;
1:002279e:           if (ofs <= 0) {  // int overflow
1:f1f9348:             ofs = maxOfs;
1:002279e:           }
1:f1f9348:         }
1:002279e:         if (ofs > maxOfs) {
1:f1f9348:           ofs = maxOfs;
1:002279e:         }
1:f1f9348: 
1:f1f9348:         // Make offsets relative to base
1:f1f9348:         lastOfs += hint;
1:f1f9348:         ofs += hint;
1:f1f9348:       } else { // key <= a[base + hint]
1:f1f9348:         // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
1:f1f9348:         final int maxOfs = hint + 1;
1:f1f9348:         while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint - ofs, key0)) <= 0) {
1:f1f9348:           lastOfs = ofs;
1:f1f9348:           ofs = (ofs << 1) + 1;
1:002279e:           if (ofs <= 0) {  // int overflow
1:f1f9348:             ofs = maxOfs;
1:002279e:           }
1:002279e:         }
1:002279e:         if (ofs > maxOfs) {
1:f1f9348:           ofs = maxOfs;
1:f1f9348:         }
1:f1f9348: 
1:f1f9348:         // Make offsets relative to base
1:f1f9348:         int tmp = lastOfs;
1:f1f9348:         lastOfs = hint - ofs;
1:f1f9348:         ofs = hint - tmp;
1:f1f9348:       }
1:f1f9348:       assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;
1:f1f9348: 
1:f1f9348:       /*
1:f1f9348:        * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
1:f1f9348:        * to the right of lastOfs but no farther right than ofs.  Do a binary
1:f1f9348:        * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
1:f1f9348:        */
1:f1f9348:       lastOfs++;
1:f1f9348:       while (lastOfs < ofs) {
1:f1f9348:         int m = lastOfs + ((ofs - lastOfs) >>> 1);
1:f1f9348: 
1:002279e:         if (c.compare(key, s.getKey(a, base + m, key0)) > 0) {
1:f1f9348:           lastOfs = m + 1;  // a[base + m] < key
1:002279e:         }
1:002279e:         else {
1:f1f9348:           ofs = m;          // key <= a[base + m]
1:002279e:         }
1:f1f9348:       }
1:f1f9348:       assert lastOfs == ofs;    // so a[base + ofs - 1] < key <= a[base + ofs]
1:f1f9348:       return ofs;
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Like gallopLeft, except that if the range contains an element equal to
1:f1f9348:      * key, gallopRight returns the index after the rightmost equal element.
1:f1f9348:      *
1:f1f9348:      * @param key the key whose insertion point to search for
1:f1f9348:      * @param a the array in which to search
1:f1f9348:      * @param base the index of the first element in the range
1:f1f9348:      * @param len the length of the range; must be > 0
1:f1f9348:      * @param hint the index at which to begin the search, 0 <= hint < n.
1:f1f9348:      *     The closer hint is to the result, the faster this method will run.
1:f1f9348:      * @param c the comparator used to order the range, and to search
1:f1f9348:      * @return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]
1:f1f9348:      */
1:f1f9348:     private int gallopRight(K key, Buffer a, int base, int len, int hint, Comparator<? super K> c) {
1:f1f9348:       assert len > 0 && hint >= 0 && hint < len;
1:f1f9348: 
1:f1f9348:       int ofs = 1;
1:f1f9348:       int lastOfs = 0;
1:f1f9348:       K key1 = s.newKey();
1:f1f9348: 
1:f1f9348:       if (c.compare(key, s.getKey(a, base + hint, key1)) < 0) {
1:f1f9348:         // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
1:f1f9348:         int maxOfs = hint + 1;
1:f1f9348:         while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint - ofs, key1)) < 0) {
1:f1f9348:           lastOfs = ofs;
1:f1f9348:           ofs = (ofs << 1) + 1;
1:002279e:           if (ofs <= 0) {  // int overflow
1:f1f9348:             ofs = maxOfs;
1:002279e:           }
1:002279e:         }
1:002279e:         if (ofs > maxOfs) {
1:f1f9348:           ofs = maxOfs;
1:f1f9348:         }
1:f1f9348: 
1:f1f9348:         // Make offsets relative to b
1:f1f9348:         int tmp = lastOfs;
1:f1f9348:         lastOfs = hint - ofs;
1:f1f9348:         ofs = hint - tmp;
1:f1f9348:       } else { // a[b + hint] <= key
1:f1f9348:         // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
1:f1f9348:         int maxOfs = len - hint;
1:f1f9348:         while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint + ofs, key1)) >= 0) {
1:f1f9348:           lastOfs = ofs;
1:f1f9348:           ofs = (ofs << 1) + 1;
1:002279e:           if (ofs <= 0) {  // int overflow
1:f1f9348:             ofs = maxOfs;
1:002279e:           }
1:002279e:         }
1:002279e:         if (ofs > maxOfs) {
1:f1f9348:           ofs = maxOfs;
1:f1f9348:         }
1:f1f9348: 
1:f1f9348:         // Make offsets relative to b
1:f1f9348:         lastOfs += hint;
1:f1f9348:         ofs += hint;
1:f1f9348:       }
1:f1f9348:       assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;
1:f1f9348: 
1:f1f9348:       /*
1:f1f9348:        * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
1:f1f9348:        * the right of lastOfs but no farther right than ofs.  Do a binary
1:f1f9348:        * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
1:f1f9348:        */
1:f1f9348:       lastOfs++;
1:f1f9348:       while (lastOfs < ofs) {
1:f1f9348:         int m = lastOfs + ((ofs - lastOfs) >>> 1);
1:f1f9348: 
1:002279e:         if (c.compare(key, s.getKey(a, base + m, key1)) < 0) {
1:f1f9348:           ofs = m;          // key < a[b + m]
1:002279e:         }
1:002279e:         else {
1:f1f9348:           lastOfs = m + 1;  // a[b + m] <= key
1:002279e:         }
1:f1f9348:       }
1:f1f9348:       assert lastOfs == ofs;    // so a[b + ofs - 1] <= key < a[b + ofs]
1:f1f9348:       return ofs;
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Merges two adjacent runs in place, in a stable fashion.  The first
1:f1f9348:      * element of the first run must be greater than the first element of the
1:f1f9348:      * second run (a[base1] > a[base2]), and the last element of the first run
1:f1f9348:      * (a[base1 + len1-1]) must be greater than all elements of the second run.
1:f1f9348:      *
1:f1f9348:      * For performance, this method should be called only when len1 <= len2;
1:f1f9348:      * its twin, mergeHi should be called if len1 >= len2.  (Either method
1:f1f9348:      * may be called if len1 == len2.)
1:f1f9348:      *
1:f1f9348:      * @param base1 index of first element in first run to be merged
1:f1f9348:      * @param len1  length of first run to be merged (must be > 0)
1:f1f9348:      * @param base2 index of first element in second run to be merged
1:f1f9348:      *        (must be aBase + aLen)
1:f1f9348:      * @param len2  length of second run to be merged (must be > 0)
1:f1f9348:      */
1:f1f9348:     private void mergeLo(int base1, int len1, int base2, int len2) {
1:f1f9348:       assert len1 > 0 && len2 > 0 && base1 + len1 == base2;
1:f1f9348: 
1:f1f9348:       // Copy first run into temp array
1:f1f9348:       Buffer a = this.a; // For performance
1:f1f9348:       Buffer tmp = ensureCapacity(len1);
1:f1f9348:       s.copyRange(a, base1, tmp, 0, len1);
1:f1f9348: 
1:f1f9348:       int cursor1 = 0;       // Indexes into tmp array
1:f1f9348:       int cursor2 = base2;   // Indexes int a
1:f1f9348:       int dest = base1;      // Indexes int a
1:f1f9348: 
1:f1f9348:       // Move first element of second run and deal with degenerate cases
1:f1f9348:       s.copyElement(a, cursor2++, a, dest++);
1:f1f9348:       if (--len2 == 0) {
1:f1f9348:         s.copyRange(tmp, cursor1, a, dest, len1);
1:f1f9348:         return;
1:f1f9348:       }
1:f1f9348:       if (len1 == 1) {
1:f1f9348:         s.copyRange(a, cursor2, a, dest, len2);
1:f1f9348:         s.copyElement(tmp, cursor1, a, dest + len2); // Last elt of run 1 to end of merge
1:f1f9348:         return;
1:f1f9348:       }
1:f1f9348: 
1:f1f9348:       K key0 = s.newKey();
1:f1f9348:       K key1 = s.newKey();
1:f1f9348: 
1:f1f9348:       Comparator<? super K> c = this.c;  // Use local variable for performance
1:f1f9348:       int minGallop = this.minGallop;    //  "    "       "     "      "
1:f1f9348:       outer:
1:f1f9348:       while (true) {
1:f1f9348:         int count1 = 0; // Number of times in a row that first run won
1:f1f9348:         int count2 = 0; // Number of times in a row that second run won
1:f1f9348: 
1:f1f9348:         /*
1:f1f9348:          * Do the straightforward thing until (if ever) one run starts
1:f1f9348:          * winning consistently.
1:f1f9348:          */
1:f1f9348:         do {
1:f1f9348:           assert len1 > 1 && len2 > 0;
1:f1f9348:           if (c.compare(s.getKey(a, cursor2, key0), s.getKey(tmp, cursor1, key1)) < 0) {
1:f1f9348:             s.copyElement(a, cursor2++, a, dest++);
1:f1f9348:             count2++;
1:f1f9348:             count1 = 0;
1:002279e:             if (--len2 == 0) {
1:f1f9348:               break outer;
1:002279e:             }
1:f1f9348:           } else {
1:f1f9348:             s.copyElement(tmp, cursor1++, a, dest++);
1:f1f9348:             count1++;
1:f1f9348:             count2 = 0;
1:002279e:             if (--len1 == 1) {
1:f1f9348:               break outer;
1:002279e:             }
1:f1f9348:           }
1:f1f9348:         } while ((count1 | count2) < minGallop);
1:f1f9348: 
1:f1f9348:         /*
1:f1f9348:          * One run is winning so consistently that galloping may be a
1:f1f9348:          * huge win. So try that, and continue galloping until (if ever)
1:f1f9348:          * neither run appears to be winning consistently anymore.
1:f1f9348:          */
1:f1f9348:         do {
1:f1f9348:           assert len1 > 1 && len2 > 0;
1:f1f9348:           count1 = gallopRight(s.getKey(a, cursor2, key0), tmp, cursor1, len1, 0, c);
1:f1f9348:           if (count1 != 0) {
1:f1f9348:             s.copyRange(tmp, cursor1, a, dest, count1);
1:f1f9348:             dest += count1;
1:f1f9348:             cursor1 += count1;
1:f1f9348:             len1 -= count1;
1:002279e:             if (len1 <= 1) { // len1 == 1 || len1 == 0
1:f1f9348:               break outer;
1:002279e:             }
1:002279e:           }
1:f1f9348:           s.copyElement(a, cursor2++, a, dest++);
1:002279e:           if (--len2 == 0) {
1:f1f9348:             break outer;
1:f1f9348:           }
1:f1f9348: 
1:f1f9348:           count2 = gallopLeft(s.getKey(tmp, cursor1, key0), a, cursor2, len2, 0, c);
1:f1f9348:           if (count2 != 0) {
1:f1f9348:             s.copyRange(a, cursor2, a, dest, count2);
1:f1f9348:             dest += count2;
1:f1f9348:             cursor2 += count2;
1:f1f9348:             len2 -= count2;
1:002279e:             if (len2 == 0) {
1:f1f9348:               break outer;
1:002279e:             }
1:002279e:           }
1:f1f9348:           s.copyElement(tmp, cursor1++, a, dest++);
1:002279e:           if (--len1 == 1) {
1:f1f9348:             break outer;
1:002279e:           }
1:f1f9348:           minGallop--;
1:f1f9348:         } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
1:002279e:         if (minGallop < 0) {
1:f1f9348:           minGallop = 0;
1:002279e:         }
1:f1f9348:         minGallop += 2;  // Penalize for leaving gallop mode
1:f1f9348:       }  // End of "outer" loop
1:f1f9348:       this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field
1:f1f9348: 
1:f1f9348:       if (len1 == 1) {
1:f1f9348:         assert len2 > 0;
1:f1f9348:         s.copyRange(a, cursor2, a, dest, len2);
1:f1f9348:         s.copyElement(tmp, cursor1, a, dest + len2); //  Last elt of run 1 to end of merge
1:f1f9348:       } else if (len1 == 0) {
1:f1f9348:         throw new IllegalArgumentException(
1:f1f9348:             "Comparison method violates its general contract!");
1:f1f9348:       } else {
1:f1f9348:         assert len2 == 0;
1:f1f9348:         assert len1 > 1;
1:f1f9348:         s.copyRange(tmp, cursor1, a, dest, len1);
1:f1f9348:       }
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Like mergeLo, except that this method should be called only if
1:f1f9348:      * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
1:f1f9348:      * may be called if len1 == len2.)
1:f1f9348:      *
1:f1f9348:      * @param base1 index of first element in first run to be merged
1:f1f9348:      * @param len1  length of first run to be merged (must be > 0)
1:f1f9348:      * @param base2 index of first element in second run to be merged
1:f1f9348:      *        (must be aBase + aLen)
1:f1f9348:      * @param len2  length of second run to be merged (must be > 0)
1:f1f9348:      */
1:f1f9348:     private void mergeHi(int base1, int len1, int base2, int len2) {
1:f1f9348:       assert len1 > 0 && len2 > 0 && base1 + len1 == base2;
1:f1f9348: 
1:f1f9348:       // Copy second run into temp array
1:f1f9348:       Buffer a = this.a; // For performance
1:f1f9348:       Buffer tmp = ensureCapacity(len2);
1:f1f9348:       s.copyRange(a, base2, tmp, 0, len2);
1:f1f9348: 
1:f1f9348:       int cursor1 = base1 + len1 - 1;  // Indexes into a
1:f1f9348:       int cursor2 = len2 - 1;          // Indexes into tmp array
1:f1f9348:       int dest = base2 + len2 - 1;     // Indexes into a
1:f1f9348: 
1:f1f9348:       K key0 = s.newKey();
1:f1f9348:       K key1 = s.newKey();
1:f1f9348: 
1:f1f9348:       // Move last element of first run and deal with degenerate cases
1:f1f9348:       s.copyElement(a, cursor1--, a, dest--);
1:002279e:       if (--len1 == 0) {
1:f1f9348:         s.copyRange(tmp, 0, a, dest - (len2 - 1), len2);
1:f1f9348:         return;
1:002279e:       }
1:f1f9348:       if (len2 == 1) {
1:f1f9348:         dest -= len1;
1:f1f9348:         cursor1 -= len1;
1:f1f9348:         s.copyRange(a, cursor1 + 1, a, dest + 1, len1);
1:f1f9348:         s.copyElement(tmp, cursor2, a, dest);
1:f1f9348:         return;
1:f1f9348:       }
1:f1f9348: 
1:f1f9348:       Comparator<? super K> c = this.c;  // Use local variable for performance
1:f1f9348:       int minGallop = this.minGallop;    //  "    "       "     "      "
1:f1f9348:       outer:
1:f1f9348:       while (true) {
1:f1f9348:         int count1 = 0; // Number of times in a row that first run won
1:f1f9348:         int count2 = 0; // Number of times in a row that second run won
1:f1f9348: 
1:f1f9348:         /*
1:f1f9348:          * Do the straightforward thing until (if ever) one run
1:f1f9348:          * appears to win consistently.
1:f1f9348:          */
1:f1f9348:         do {
1:f1f9348:           assert len1 > 0 && len2 > 1;
1:f1f9348:           if (c.compare(s.getKey(tmp, cursor2, key0), s.getKey(a, cursor1, key1)) < 0) {
1:f1f9348:             s.copyElement(a, cursor1--, a, dest--);
1:f1f9348:             count1++;
1:f1f9348:             count2 = 0;
1:f1f9348:             if (--len1 == 0) {
1:f1f9348:               break outer;
1:f1f9348:             }
1:f1f9348:           } else {
1:f1f9348:             s.copyElement(tmp, cursor2--, a, dest--);
1:f1f9348:             count2++;
1:f1f9348:             count1 = 0;
1:002279e:             if (--len2 == 1) {
1:f1f9348:               break outer;
1:002279e:             }
1:f1f9348:           }
1:f1f9348:         } while ((count1 | count2) < minGallop);
1:f1f9348: 
1:f1f9348:         /*
1:f1f9348:          * One run is winning so consistently that galloping may be a
1:f1f9348:          * huge win. So try that, and continue galloping until (if ever)
1:f1f9348:          * neither run appears to be winning consistently anymore.
1:f1f9348:          */
1:f1f9348:         do {
1:f1f9348:           assert len1 > 0 && len2 > 1;
1:f1f9348:           count1 = len1 - gallopRight(s.getKey(tmp, cursor2, key0), a, base1, len1, len1 - 1, c);
1:f1f9348:           if (count1 != 0) {
1:f1f9348:             dest -= count1;
1:f1f9348:             cursor1 -= count1;
1:f1f9348:             len1 -= count1;
1:f1f9348:             s.copyRange(a, cursor1 + 1, a, dest + 1, count1);
1:002279e:             if (len1 == 0) {
1:f1f9348:               break outer;
1:002279e:             }
1:002279e:           }
1:f1f9348:           s.copyElement(tmp, cursor2--, a, dest--);
1:002279e:           if (--len2 == 1) {
1:f1f9348:             break outer;
1:f1f9348:           }
1:f1f9348: 
1:f1f9348:           count2 = len2 - gallopLeft(s.getKey(a, cursor1, key0), tmp, 0, len2, len2 - 1, c);
1:f1f9348:           if (count2 != 0) {
1:f1f9348:             dest -= count2;
1:f1f9348:             cursor2 -= count2;
1:f1f9348:             len2 -= count2;
1:f1f9348:             s.copyRange(tmp, cursor2 + 1, a, dest + 1, count2);
1:002279e:             if (len2 <= 1) { // len2 == 1 || len2 == 0
1:f1f9348:               break outer;
1:002279e:             }
1:002279e:           }
1:f1f9348:           s.copyElement(a, cursor1--, a, dest--);
1:002279e:           if (--len1 == 0) {
1:f1f9348:             break outer;
1:f1f9348:           }
1:f1f9348:           minGallop--;
1:f1f9348:         } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
1:002279e:         if (minGallop < 0) {
1:f1f9348:           minGallop = 0;
1:f1f9348:         }
1:f1f9348:         minGallop += 2;  // Penalize for leaving gallop mode
1:f1f9348:       }  // End of "outer" loop
1:f1f9348:       this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field
1:f1f9348: 
1:f1f9348:       if (len2 == 1) {
1:f1f9348:         assert len1 > 0;
1:f1f9348:         dest -= len1;
1:f1f9348:         cursor1 -= len1;
1:f1f9348:         s.copyRange(a, cursor1 + 1, a, dest + 1, len1);
1:f1f9348:         s.copyElement(tmp, cursor2, a, dest); // Move first elt of run2 to front of merge
1:f1f9348:       } else if (len2 == 0) {
1:f1f9348:         throw new IllegalArgumentException(
1:f1f9348:             "Comparison method violates its general contract!");
1:f1f9348:       } else {
1:f1f9348:         assert len1 == 0;
1:f1f9348:         assert len2 > 0;
1:f1f9348:         s.copyRange(tmp, 0, a, dest - (len2 - 1), len2);
1:f1f9348:       }
1:f1f9348:     }
1:f1f9348: 
1:f1f9348:     /**
1:f1f9348:      * Ensures that the external array tmp has at least the specified
1:f1f9348:      * number of elements, increasing its size if necessary.  The size
1:f1f9348:      * increases exponentially to ensure amortized linear time complexity.
1:f1f9348:      *
1:f1f9348:      * @param minCapacity the minimum required capacity of the tmp array
1:f1f9348:      * @return tmp, whether or not it grew
1:f1f9348:      */
1:f1f9348:     private Buffer ensureCapacity(int minCapacity) {
1:f1f9348:       if (tmpLength < minCapacity) {
1:f1f9348:         // Compute smallest power of 2 > minCapacity
1:f1f9348:         int newSize = minCapacity;
1:f1f9348:         newSize |= newSize >> 1;
1:f1f9348:         newSize |= newSize >> 2;
1:f1f9348:         newSize |= newSize >> 4;
1:f1f9348:         newSize |= newSize >> 8;
1:f1f9348:         newSize |= newSize >> 16;
1:f1f9348:         newSize++;
1:f1f9348: 
1:002279e:         if (newSize < 0) { // Not bloody likely!
1:f1f9348:           newSize = minCapacity;
1:002279e:         }
1:002279e:         else {
1:f1f9348:           newSize = Math.min(newSize, aLength >>> 1);
1:002279e:         }
1:f1f9348: 
1:f1f9348:         tmp = s.allocate(newSize);
1:f1f9348:         tmpLength = newSize;
1:f1f9348:       }
1:f1f9348:       return tmp;
1:f1f9348:     }
1:f1f9348:   }
1:f1f9348: }
============================================================================
author:Jacky Li
-------------------------------------------------------------------------------
commit:982d03f
/////////////////////////////////////////////////////////////////////////
commit:349c59c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.carbondata.processing.loading.sort.unsafe.sort;
author:QiangCai
-------------------------------------------------------------------------------
commit:086b06d
/////////////////////////////////////////////////////////////////////////
1:     /*
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
author:bill1208
-------------------------------------------------------------------------------
commit:9e932d1
/////////////////////////////////////////////////////////////////////////
1:         if ((n >= 1 && runLen[n - 1] <= runLen[n] + runLen[n + 1])
1:             || (n >= 2 && runLen[n - 2] <= runLen[n] + runLen[n - 1])) {
author:Manohar
-------------------------------------------------------------------------------
commit:6650c63
/////////////////////////////////////////////////////////////////////////
author:sraghunandan
-------------------------------------------------------------------------------
commit:002279e
/////////////////////////////////////////////////////////////////////////
1:     if (nRemaining < 2) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     if (start == lo) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:         if (c.compare(pivot, s.getKey(a, mid, key1)) < 0) {
1:         }
1:         else {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         case 2:  {
1:           s.copyElement(a, left + 1, a, left + 2);
1:           s.copyElement(a, left, a, left + 1);
1:         }
1:         case 1:  {
1:           s.copyElement(a, left, a, left + 1);
1:           break;
1:         }
/////////////////////////////////////////////////////////////////////////
1:     if (runHi == hi) {
1:     }
1:       while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) < 0) {
1:       }
1:       while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) >= 0) {
1:       }
/////////////////////////////////////////////////////////////////////////
0:         if ((n >= 1 && runLen[n-1] <= runLen[n] + runLen[n+1])
0:             || (n >= 2 && runLen[n-2] <= runLen[n] + runLen[n-1])) {
1:           if (runLen[n - 1] < runLen[n + 1]) {
1:           }
/////////////////////////////////////////////////////////////////////////
1:         if (n > 0 && runLen[n - 1] < runLen[n + 1]) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:       if (len1 == 0) {
1:       }
/////////////////////////////////////////////////////////////////////////
1:       if (len2 == 0) {
1:       }
1:       if (len1 <= len2) {
1:       }
1:       else {
1:       }
/////////////////////////////////////////////////////////////////////////
1:           if (ofs <= 0) {  // int overflow
1:           }
1:         if (ofs > maxOfs) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:           if (ofs <= 0) {  // int overflow
1:           }
1:         if (ofs > maxOfs) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (c.compare(key, s.getKey(a, base + m, key0)) > 0) {
1:         }
1:         else {
1:         }
/////////////////////////////////////////////////////////////////////////
1:           if (ofs <= 0) {  // int overflow
1:           }
1:         if (ofs > maxOfs) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:           if (ofs <= 0) {  // int overflow
1:           }
1:         if (ofs > maxOfs) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (c.compare(key, s.getKey(a, base + m, key1)) < 0) {
1:         }
1:         else {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (--len2 == 0) {
1:             }
1:             if (--len1 == 1) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (len1 <= 1) { // len1 == 1 || len1 == 0
1:             }
1:           if (--len2 == 0) {
1:           }
/////////////////////////////////////////////////////////////////////////
1:             if (len2 == 0) {
1:             }
1:           if (--len1 == 1) {
1:           }
1:         if (minGallop < 0) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (--len1 == 0) {
1:             }
1:             if (--len2 == 1) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (len1 == 0) {
1:             }
1:           if (--len2 == 1) {
1:           }
/////////////////////////////////////////////////////////////////////////
1:             if (len2 <= 1) { // len2 == 1 || len2 == 0
1:             }
1:           if (--len1 == 0) {
1:           }
1:         if (minGallop < 0) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (newSize < 0) { // Not bloody likely!
1:         }
1:         else {
1:         }
author:ravipesala
-------------------------------------------------------------------------------
commit:f1f9348
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
0: package org.apache.carbondata.processing.newflow.sort.unsafe.sort;
1: 
1: import java.util.Comparator;
1: 
0: import org.apache.spark.util.collection.SortDataFormat;
1: 
1: /**
1:  * A port of the Apache Spark's TimSort and they originally ported from Android TimSort class,
1:  * which utilizes a "stable, adaptive, iterative mergesort."
1:  * See the method comment on sort() for more details.
1:  *
1:  * This has been kept in Java with the original style in order to match very closely with the
1:  * Android source code, and thus be easy to verify correctness. The class is package private. We put
1:  * a simple Scala wrapper {@link org.apache.spark.util.collection.Sorter}, which is available to
1:  * package org.apache.spark.
1:  *
1:  * The purpose of the port is to generalize the interface to the sort to accept input data formats
1:  * besides simple arrays where every element is sorted individually. For instance, the AppendOnlyMap
1:  * uses this to sort an Array with alternating elements of the form [key, value, key, value].
1:  * This generalization comes with minimal overhead -- see SortDataFormat for more information.
1:  *
1:  * We allow key reuse to prevent creating many key objects -- see SortDataFormat.
1:  *
1:  * @see SortDataFormat
1:  * @see org.apache.spark.util.collection.Sorter
1:  */
1: public class TimSort<K, Buffer> {
1: 
1:   /**
1:    * This is the minimum sized sequence that will be merged.  Shorter
1:    * sequences will be lengthened by calling binarySort.  If the entire
1:    * array is less than this length, no merges will be performed.
1:    *
1:    * This constant should be a power of two.  It was 64 in Tim Peter's C
1:    * implementation, but 32 was empirically determined to work better in
1:    * this implementation.  In the unlikely event that you set this constant
1:    * to be a number that's not a power of two, you'll need to change the
1:    * minRunLength computation.
1:    *
1:    * If you decrease this constant, you must change the stackLen
1:    * computation in the TimSort constructor, or you risk an
1:    * ArrayOutOfBounds exception.  See listsort.txt for a discussion
1:    * of the minimum stack length required as a function of the length
1:    * of the array being sorted and the minimum merge sequence length.
1:    */
1:   private static final int MIN_MERGE = 32;
1: 
1:   private final SortDataFormat<K, Buffer> s;
1: 
1:   public TimSort(SortDataFormat<K, Buffer> sortDataFormat) {
1:     this.s = sortDataFormat;
1:   }
1: 
1:   /**
1:    * A stable, adaptive, iterative mergesort that requires far fewer than
1:    * n lg(n) comparisons when running on partially sorted arrays, while
1:    * offering performance comparable to a traditional mergesort when run
1:    * on random arrays.  Like all proper mergesorts, this sort is stable and
1:    * runs O(n log n) time (worst case).  In the worst case, this sort requires
1:    * temporary storage space for n/2 object references; in the best case,
1:    * it requires only a small constant amount of space.
1:    *
1:    * This implementation was adapted from Tim Peters's list sort for
1:    * Python, which is described in detail here:
1:    *
1:    *   http://svn.python.org/projects/python/trunk/Objects/listsort.txt
1:    *
1:    * Tim's C code may be found here:
1:    *
1:    *   http://svn.python.org/projects/python/trunk/Objects/listobject.c
1:    *
1:    * The underlying techniques are described in this paper (and may have
1:    * even earlier origins):
1:    *
1:    *  "Optimistic Sorting and Information Theoretic Complexity"
1:    *  Peter McIlroy
1:    *  SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
1:    *  pp 467-474, Austin, Texas, 25-27 January 1993.
1:    *
1:    * While the API to this class consists solely of static methods, it is
1:    * (privately) instantiable; a TimSort instance holds the state of an ongoing
1:    * sort, assuming the input array is large enough to warrant the full-blown
1:    * TimSort. Small arrays are sorted in place, using a binary insertion sort.
1:    *
0:    * @author Josh Bloch
1:    */
1:   public void sort(Buffer a, int lo, int hi, Comparator<? super K> c) {
1:     assert c != null;
1: 
1:     int nRemaining  = hi - lo;
0:     if (nRemaining < 2)
1:       return;  // Arrays of size 0 and 1 are always sorted
1: 
1:     // If array is small, do a "mini-TimSort" with no merges
1:     if (nRemaining < MIN_MERGE) {
1:       int initRunLen = countRunAndMakeAscending(a, lo, hi, c);
1:       binarySort(a, lo, hi, lo + initRunLen, c);
1:       return;
1:     }
1: 
1:     /**
1:      * March over the array once, left to right, finding natural runs,
1:      * extending short natural runs to minRun elements, and merging runs
1:      * to maintain stack invariant.
1:      */
1:     SortState sortState = new SortState(a, c, hi - lo);
1:     int minRun = minRunLength(nRemaining);
1:     do {
1:       // Identify next run
1:       int runLen = countRunAndMakeAscending(a, lo, hi, c);
1: 
1:       // If run is short, extend to min(minRun, nRemaining)
1:       if (runLen < minRun) {
1:         int force = nRemaining <= minRun ? nRemaining : minRun;
1:         binarySort(a, lo, lo + force, lo + runLen, c);
1:         runLen = force;
1:       }
1: 
1:       // Push run onto pending-run stack, and maybe merge
1:       sortState.pushRun(lo, runLen);
1:       sortState.mergeCollapse();
1: 
1:       // Advance to find next run
1:       lo += runLen;
1:       nRemaining -= runLen;
1:     } while (nRemaining != 0);
1: 
1:     // Merge all remaining runs to complete sort
1:     assert lo == hi;
1:     sortState.mergeForceCollapse();
1:     assert sortState.stackSize == 1;
1:   }
1: 
1:   /**
1:    * Sorts the specified portion of the specified array using a binary
1:    * insertion sort.  This is the best method for sorting small numbers
1:    * of elements.  It requires O(n log n) compares, but O(n^2) data
1:    * movement (worst case).
1:    *
1:    * If the initial part of the specified range is already sorted,
1:    * this method can take advantage of it: the method assumes that the
1:    * elements from index {@code lo}, inclusive, to {@code start},
1:    * exclusive are already sorted.
1:    *
1:    * @param a the array in which a range is to be sorted
1:    * @param lo the index of the first element in the range to be sorted
1:    * @param hi the index after the last element in the range to be sorted
1:    * @param start the index of the first element in the range that is
1:    *        not already known to be sorted ({@code lo <= start <= hi})
1:    * @param c comparator to used for the sort
1:    */
1:   @SuppressWarnings("fallthrough")
1:   private void binarySort(Buffer a, int lo, int hi, int start, Comparator<? super K> c) {
1:     assert lo <= start && start <= hi;
0:     if (start == lo)
1:       start++;
1: 
1:     K key0 = s.newKey();
1:     K key1 = s.newKey();
1: 
1:     Buffer pivotStore = s.allocate(1);
1:     for ( ; start < hi; start++) {
1:       s.copyElement(a, start, pivotStore, 0);
1:       K pivot = s.getKey(pivotStore, 0, key0);
1: 
1:       // Set left (and right) to the index where a[start] (pivot) belongs
1:       int left = lo;
1:       int right = start;
1:       assert left <= right;
1:       /*
1:        * Invariants:
1:        *   pivot >= all in [lo, left).
1:        *   pivot <  all in [right, start).
1:        */
1:       while (left < right) {
1:         int mid = (left + right) >>> 1;
0:         if (c.compare(pivot, s.getKey(a, mid, key1)) < 0)
1:           right = mid;
0:         else
1:           left = mid + 1;
1:       }
1:       assert left == right;
1: 
1:       /*
1:        * The invariants still hold: pivot >= all in [lo, left) and
1:        * pivot < all in [left, start), so pivot belongs at left.  Note
1:        * that if there are elements equal to pivot, left points to the
1:        * first slot after them -- that's why this sort is stable.
1:        * Slide elements over to make room for pivot.
1:        */
1:       int n = start - left;  // The number of elements to move
1:       // Switch is just an optimization for arraycopy in default case
1:       switch (n) {
0:         case 2:  s.copyElement(a, left + 1, a, left + 2);
0:         case 1:  s.copyElement(a, left, a, left + 1);
1:           break;
1:         default: s.copyRange(a, left, a, left + 1, n);
1:       }
1:       s.copyElement(pivotStore, 0, a, left);
1:     }
1:   }
1: 
1:   /**
1:    * Returns the length of the run beginning at the specified position in
1:    * the specified array and reverses the run if it is descending (ensuring
1:    * that the run will always be ascending when the method returns).
1:    *
1:    * A run is the longest ascending sequence with:
1:    *
1:    *    a[lo] <= a[lo + 1] <= a[lo + 2] <= ...
1:    *
1:    * or the longest descending sequence with:
1:    *
1:    *    a[lo] >  a[lo + 1] >  a[lo + 2] >  ...
1:    *
1:    * For its intended use in a stable mergesort, the strictness of the
1:    * definition of "descending" is needed so that the call can safely
1:    * reverse a descending sequence without violating stability.
1:    *
1:    * @param a the array in which a run is to be counted and possibly reversed
1:    * @param lo index of the first element in the run
1:    * @param hi index after the last element that may be contained in the run.
1:   It is required that {@code lo < hi}.
1:    * @param c the comparator to used for the sort
1:    * @return  the length of the run beginning at the specified position in
1:    *          the specified array
1:    */
1:   private int countRunAndMakeAscending(Buffer a, int lo, int hi, Comparator<? super K> c) {
1:     assert lo < hi;
1:     int runHi = lo + 1;
0:     if (runHi == hi)
1:       return 1;
1: 
1:     K key0 = s.newKey();
1:     K key1 = s.newKey();
1: 
1:     // Find end of run, and reverse range if descending
1:     if (c.compare(s.getKey(a, runHi++, key0), s.getKey(a, lo, key1)) < 0) { // Descending
0:       while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) < 0)
1:         runHi++;
1:       reverseRange(a, lo, runHi);
1:     } else {                              // Ascending
0:       while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) >= 0)
1:         runHi++;
1:     }
1: 
1:     return runHi - lo;
1:   }
1: 
1:   /**
1:    * Reverse the specified range of the specified array.
1:    *
1:    * @param a the array in which a range is to be reversed
1:    * @param lo the index of the first element in the range to be reversed
1:    * @param hi the index after the last element in the range to be reversed
1:    */
1:   private void reverseRange(Buffer a, int lo, int hi) {
1:     hi--;
1:     while (lo < hi) {
1:       s.swap(a, lo, hi);
1:       lo++;
1:       hi--;
1:     }
1:   }
1: 
1:   /**
1:    * Returns the minimum acceptable run length for an array of the specified
1:    * length. Natural runs shorter than this will be extended with
1:    * {@link #binarySort}.
1:    *
1:    * Roughly speaking, the computation is:
1:    *
1:    *  If n < MIN_MERGE, return n (it's too small to bother with fancy stuff).
1:    *  Else if n is an exact power of 2, return MIN_MERGE/2.
1:    *  Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k
1:    *   is close to, but strictly less than, an exact power of 2.
1:    *
1:    * For the rationale, see listsort.txt.
1:    *
1:    * @param n the length of the array to be sorted
1:    * @return the length of the minimum run to be merged
1:    */
1:   private int minRunLength(int n) {
1:     assert n >= 0;
1:     int r = 0;      // Becomes 1 if any 1 bits are shifted off
1:     while (n >= MIN_MERGE) {
1:       r |= (n & 1);
1:       n >>= 1;
1:     }
1:     return n + r;
1:   }
1: 
1:   private class SortState {
1: 
1:     /**
1:      * The Buffer being sorted.
1:      */
1:     private final Buffer a;
1: 
1:     /**
1:      * Length of the sort Buffer.
1:      */
1:     private final int aLength;
1: 
1:     /**
1:      * The comparator for this sort.
1:      */
1:     private final Comparator<? super K> c;
1: 
1:     /**
1:      * When we get into galloping mode, we stay there until both runs win less
1:      * often than MIN_GALLOP consecutive times.
1:      */
1:     private static final int  MIN_GALLOP = 7;
1: 
1:     /**
1:      * This controls when we get *into* galloping mode.  It is initialized
1:      * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
1:      * random data, and lower for highly structured data.
1:      */
1:     private int minGallop = MIN_GALLOP;
1: 
1:     /**
1:      * Maximum initial size of tmp array, which is used for merging.  The array
1:      * can grow to accommodate demand.
1:      *
1:      * Unlike Tim's original C version, we do not allocate this much storage
1:      * when sorting smaller arrays.  This change was required for performance.
1:      */
1:     private static final int INITIAL_TMP_STORAGE_LENGTH = 256;
1: 
1:     /**
1:      * Temp storage for merges.
1:      */
1:     private Buffer tmp; // Actual runtime type will be Object[], regardless of T
1: 
1:     /**
1:      * Length of the temp storage.
1:      */
1:     private int tmpLength = 0;
1: 
1:     /**
1:      * A stack of pending runs yet to be merged.  Run i starts at
1:      * address base[i] and extends for len[i] elements.  It's always
1:      * true (so long as the indices are in bounds) that:
1:      *
1:      *     runBase[i] + runLen[i] == runBase[i + 1]
1:      *
1:      * so we could cut the storage for this, but it's a minor amount,
1:      * and keeping all the info explicit simplifies the code.
1:      */
1:     private int stackSize = 0;  // Number of pending runs on stack
1:     private final int[] runBase;
1:     private final int[] runLen;
1: 
1:     /**
1:      * Creates a TimSort instance to maintain the state of an ongoing sort.
1:      *
1:      * @param a the array to be sorted
1:      * @param c the comparator to determine the order of the sort
1:      */
1:     private SortState(Buffer a, Comparator<? super K> c, int len) {
1:       this.aLength = len;
1:       this.a = a;
1:       this.c = c;
1: 
1:       // Allocate temp storage (which may be increased later if necessary)
1:       tmpLength = len < 2 * INITIAL_TMP_STORAGE_LENGTH ? len >>> 1 : INITIAL_TMP_STORAGE_LENGTH;
1:       tmp = s.allocate(tmpLength);
1: 
1:       /*
1:        * Allocate runs-to-be-merged stack (which cannot be expanded).  The
1:        * stack length requirements are described in listsort.txt.  The C
1:        * version always uses the same stack length (85), but this was
1:        * measured to be too expensive when sorting "mid-sized" arrays (e.g.,
1:        * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
1:        * large) stack lengths for smaller arrays.  The "magic numbers" in the
1:        * computation below must be changed if MIN_MERGE is decreased.  See
1:        * the MIN_MERGE declaration above for more information.
1:        */
1:       int stackLen = (len <    120  ?  5 :
1:                       len <   1542  ? 10 :
1:                       len < 119151  ? 19 : 40);
1:       runBase = new int[stackLen];
1:       runLen = new int[stackLen];
1:     }
1: 
1:     /**
1:      * Pushes the specified run onto the pending-run stack.
1:      *
1:      * @param runBase index of the first element in the run
1:      * @param runLen  the number of elements in the run
1:      */
1:     private void pushRun(int runBase, int runLen) {
1:       this.runBase[stackSize] = runBase;
1:       this.runLen[stackSize] = runLen;
1:       stackSize++;
1:     }
1: 
1:     /**
1:      * Examines the stack of runs waiting to be merged and merges adjacent runs
1:      * until the stack invariants are reestablished:
1:      *
1:      *     1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]
1:      *     2. runLen[i - 2] > runLen[i - 1]
1:      *
1:      * This method is called each time a new run is pushed onto the stack,
1:      * so the invariants are guaranteed to hold for i < stackSize upon
1:      * entry to the method.
1:      */
1:     private void mergeCollapse() {
1:       while (stackSize > 1) {
1:         int n = stackSize - 2;
0:         if ( (n >= 1 && runLen[n-1] <= runLen[n] + runLen[n+1])
0:           || (n >= 2 && runLen[n-2] <= runLen[n] + runLen[n-1])) {
0:           if (runLen[n - 1] < runLen[n + 1])
1:             n--;
1:         } else if (runLen[n] > runLen[n + 1]) {
1:           break; // Invariant is established
1:         }
1:         mergeAt(n);
1:       }
1:     }
1: 
1:     /**
1:      * Merges all runs on the stack until only one remains.  This method is
1:      * called once, to complete the sort.
1:      */
1:     private void mergeForceCollapse() {
1:       while (stackSize > 1) {
1:         int n = stackSize - 2;
0:         if (n > 0 && runLen[n - 1] < runLen[n + 1])
1:           n--;
1:         mergeAt(n);
1:       }
1:     }
1: 
1:     /**
1:      * Merges the two runs at stack indices i and i+1.  Run i must be
1:      * the penultimate or antepenultimate run on the stack.  In other words,
1:      * i must be equal to stackSize-2 or stackSize-3.
1:      *
1:      * @param i stack index of the first of the two runs to merge
1:      */
1:     private void mergeAt(int i) {
1:       assert stackSize >= 2;
1:       assert i >= 0;
1:       assert i == stackSize - 2 || i == stackSize - 3;
1: 
1:       int base1 = runBase[i];
1:       int len1 = runLen[i];
1:       int base2 = runBase[i + 1];
1:       int len2 = runLen[i + 1];
1:       assert len1 > 0 && len2 > 0;
1:       assert base1 + len1 == base2;
1: 
1:       /*
1:        * Record the length of the combined runs; if i is the 3rd-last
1:        * run now, also slide over the last run (which isn't involved
1:        * in this merge).  The current run (i+1) goes away in any case.
1:        */
1:       runLen[i] = len1 + len2;
1:       if (i == stackSize - 3) {
1:         runBase[i + 1] = runBase[i + 2];
1:         runLen[i + 1] = runLen[i + 2];
1:       }
1:       stackSize--;
1: 
1:       K key0 = s.newKey();
1: 
1:       /*
1:        * Find where the first element of run2 goes in run1. Prior elements
1:        * in run1 can be ignored (because they're already in place).
1:        */
1:       int k = gallopRight(s.getKey(a, base2, key0), a, base1, len1, 0, c);
1:       assert k >= 0;
1:       base1 += k;
1:       len1 -= k;
0:       if (len1 == 0)
1:         return;
1: 
1:       /*
1:        * Find where the last element of run1 goes in run2. Subsequent elements
1:        * in run2 can be ignored (because they're already in place).
1:        */
1:       len2 = gallopLeft(s.getKey(a, base1 + len1 - 1, key0), a, base2, len2, len2 - 1, c);
1:       assert len2 >= 0;
0:       if (len2 == 0)
1:         return;
1: 
1:       // Merge remaining runs, using tmp array with min(len1, len2) elements
0:       if (len1 <= len2)
1:         mergeLo(base1, len1, base2, len2);
0:       else
1:         mergeHi(base1, len1, base2, len2);
1:     }
1: 
1:     /**
1:      * Locates the position at which to insert the specified key into the
1:      * specified sorted range; if the range contains an element equal to key,
1:      * returns the index of the leftmost equal element.
1:      *
1:      * @param key the key whose insertion point to search for
1:      * @param a the array in which to search
1:      * @param base the index of the first element in the range
1:      * @param len the length of the range; must be > 0
1:      * @param hint the index at which to begin the search, 0 <= hint < n.
1:      *     The closer hint is to the result, the faster this method will run.
1:      * @param c the comparator used to order the range, and to search
1:      * @return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
1:      *    pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
1:      *    In other words, key belongs at index b + k; or in other words,
1:      *    the first k elements of a should precede key, and the last n - k
1:      *    should follow it.
1:      */
1:     private int gallopLeft(K key, Buffer a, int base, int len, int hint, Comparator<? super K> c) {
1:       assert len > 0 && hint >= 0 && hint < len;
1:       int lastOfs = 0;
1:       int ofs = 1;
1:       K key0 = s.newKey();
1: 
1:       if (c.compare(key, s.getKey(a, base + hint, key0)) > 0) {
1:         // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
1:         int maxOfs = len - hint;
1:         while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint + ofs, key0)) > 0) {
1:           lastOfs = ofs;
1:           ofs = (ofs << 1) + 1;
0:           if (ofs <= 0)   // int overflow
1:             ofs = maxOfs;
1:         }
0:         if (ofs > maxOfs)
1:           ofs = maxOfs;
1: 
1:         // Make offsets relative to base
1:         lastOfs += hint;
1:         ofs += hint;
1:       } else { // key <= a[base + hint]
1:         // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
1:         final int maxOfs = hint + 1;
1:         while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint - ofs, key0)) <= 0) {
1:           lastOfs = ofs;
1:           ofs = (ofs << 1) + 1;
0:           if (ofs <= 0)   // int overflow
1:             ofs = maxOfs;
1:         }
0:         if (ofs > maxOfs)
1:           ofs = maxOfs;
1: 
1:         // Make offsets relative to base
1:         int tmp = lastOfs;
1:         lastOfs = hint - ofs;
1:         ofs = hint - tmp;
1:       }
1:       assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;
1: 
1:       /*
1:        * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
1:        * to the right of lastOfs but no farther right than ofs.  Do a binary
1:        * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
1:        */
1:       lastOfs++;
1:       while (lastOfs < ofs) {
1:         int m = lastOfs + ((ofs - lastOfs) >>> 1);
1: 
0:         if (c.compare(key, s.getKey(a, base + m, key0)) > 0)
1:           lastOfs = m + 1;  // a[base + m] < key
0:         else
1:           ofs = m;          // key <= a[base + m]
1:       }
1:       assert lastOfs == ofs;    // so a[base + ofs - 1] < key <= a[base + ofs]
1:       return ofs;
1:     }
1: 
1:     /**
1:      * Like gallopLeft, except that if the range contains an element equal to
1:      * key, gallopRight returns the index after the rightmost equal element.
1:      *
1:      * @param key the key whose insertion point to search for
1:      * @param a the array in which to search
1:      * @param base the index of the first element in the range
1:      * @param len the length of the range; must be > 0
1:      * @param hint the index at which to begin the search, 0 <= hint < n.
1:      *     The closer hint is to the result, the faster this method will run.
1:      * @param c the comparator used to order the range, and to search
1:      * @return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]
1:      */
1:     private int gallopRight(K key, Buffer a, int base, int len, int hint, Comparator<? super K> c) {
1:       assert len > 0 && hint >= 0 && hint < len;
1: 
1:       int ofs = 1;
1:       int lastOfs = 0;
1:       K key1 = s.newKey();
1: 
1:       if (c.compare(key, s.getKey(a, base + hint, key1)) < 0) {
1:         // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
1:         int maxOfs = hint + 1;
1:         while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint - ofs, key1)) < 0) {
1:           lastOfs = ofs;
1:           ofs = (ofs << 1) + 1;
0:           if (ofs <= 0)   // int overflow
1:             ofs = maxOfs;
1:         }
0:         if (ofs > maxOfs)
1:           ofs = maxOfs;
1: 
1:         // Make offsets relative to b
1:         int tmp = lastOfs;
1:         lastOfs = hint - ofs;
1:         ofs = hint - tmp;
1:       } else { // a[b + hint] <= key
1:         // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
1:         int maxOfs = len - hint;
1:         while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint + ofs, key1)) >= 0) {
1:           lastOfs = ofs;
1:           ofs = (ofs << 1) + 1;
0:           if (ofs <= 0)   // int overflow
1:             ofs = maxOfs;
1:         }
0:         if (ofs > maxOfs)
1:           ofs = maxOfs;
1: 
1:         // Make offsets relative to b
1:         lastOfs += hint;
1:         ofs += hint;
1:       }
1:       assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;
1: 
1:       /*
1:        * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
1:        * the right of lastOfs but no farther right than ofs.  Do a binary
1:        * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
1:        */
1:       lastOfs++;
1:       while (lastOfs < ofs) {
1:         int m = lastOfs + ((ofs - lastOfs) >>> 1);
1: 
0:         if (c.compare(key, s.getKey(a, base + m, key1)) < 0)
1:           ofs = m;          // key < a[b + m]
0:         else
1:           lastOfs = m + 1;  // a[b + m] <= key
1:       }
1:       assert lastOfs == ofs;    // so a[b + ofs - 1] <= key < a[b + ofs]
1:       return ofs;
1:     }
1: 
1:     /**
1:      * Merges two adjacent runs in place, in a stable fashion.  The first
1:      * element of the first run must be greater than the first element of the
1:      * second run (a[base1] > a[base2]), and the last element of the first run
1:      * (a[base1 + len1-1]) must be greater than all elements of the second run.
1:      *
1:      * For performance, this method should be called only when len1 <= len2;
1:      * its twin, mergeHi should be called if len1 >= len2.  (Either method
1:      * may be called if len1 == len2.)
1:      *
1:      * @param base1 index of first element in first run to be merged
1:      * @param len1  length of first run to be merged (must be > 0)
1:      * @param base2 index of first element in second run to be merged
1:      *        (must be aBase + aLen)
1:      * @param len2  length of second run to be merged (must be > 0)
1:      */
1:     private void mergeLo(int base1, int len1, int base2, int len2) {
1:       assert len1 > 0 && len2 > 0 && base1 + len1 == base2;
1: 
1:       // Copy first run into temp array
1:       Buffer a = this.a; // For performance
1:       Buffer tmp = ensureCapacity(len1);
1:       s.copyRange(a, base1, tmp, 0, len1);
1: 
1:       int cursor1 = 0;       // Indexes into tmp array
1:       int cursor2 = base2;   // Indexes int a
1:       int dest = base1;      // Indexes int a
1: 
1:       // Move first element of second run and deal with degenerate cases
1:       s.copyElement(a, cursor2++, a, dest++);
1:       if (--len2 == 0) {
1:         s.copyRange(tmp, cursor1, a, dest, len1);
1:         return;
1:       }
1:       if (len1 == 1) {
1:         s.copyRange(a, cursor2, a, dest, len2);
1:         s.copyElement(tmp, cursor1, a, dest + len2); // Last elt of run 1 to end of merge
1:         return;
1:       }
1: 
1:       K key0 = s.newKey();
1:       K key1 = s.newKey();
1: 
1:       Comparator<? super K> c = this.c;  // Use local variable for performance
1:       int minGallop = this.minGallop;    //  "    "       "     "      "
1:       outer:
1:       while (true) {
1:         int count1 = 0; // Number of times in a row that first run won
1:         int count2 = 0; // Number of times in a row that second run won
1: 
1:         /*
1:          * Do the straightforward thing until (if ever) one run starts
1:          * winning consistently.
1:          */
1:         do {
1:           assert len1 > 1 && len2 > 0;
1:           if (c.compare(s.getKey(a, cursor2, key0), s.getKey(tmp, cursor1, key1)) < 0) {
1:             s.copyElement(a, cursor2++, a, dest++);
1:             count2++;
1:             count1 = 0;
0:             if (--len2 == 0)
1:               break outer;
1:           } else {
1:             s.copyElement(tmp, cursor1++, a, dest++);
1:             count1++;
1:             count2 = 0;
0:             if (--len1 == 1)
1:               break outer;
1:           }
1:         } while ((count1 | count2) < minGallop);
1: 
1:         /*
1:          * One run is winning so consistently that galloping may be a
1:          * huge win. So try that, and continue galloping until (if ever)
1:          * neither run appears to be winning consistently anymore.
1:          */
1:         do {
1:           assert len1 > 1 && len2 > 0;
1:           count1 = gallopRight(s.getKey(a, cursor2, key0), tmp, cursor1, len1, 0, c);
1:           if (count1 != 0) {
1:             s.copyRange(tmp, cursor1, a, dest, count1);
1:             dest += count1;
1:             cursor1 += count1;
1:             len1 -= count1;
0:             if (len1 <= 1) // len1 == 1 || len1 == 0
1:               break outer;
1:           }
1:           s.copyElement(a, cursor2++, a, dest++);
0:           if (--len2 == 0)
1:             break outer;
1: 
1:           count2 = gallopLeft(s.getKey(tmp, cursor1, key0), a, cursor2, len2, 0, c);
1:           if (count2 != 0) {
1:             s.copyRange(a, cursor2, a, dest, count2);
1:             dest += count2;
1:             cursor2 += count2;
1:             len2 -= count2;
0:             if (len2 == 0)
1:               break outer;
1:           }
1:           s.copyElement(tmp, cursor1++, a, dest++);
0:           if (--len1 == 1)
1:             break outer;
1:           minGallop--;
1:         } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
0:         if (minGallop < 0)
1:           minGallop = 0;
1:         minGallop += 2;  // Penalize for leaving gallop mode
1:       }  // End of "outer" loop
1:       this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field
1: 
1:       if (len1 == 1) {
1:         assert len2 > 0;
1:         s.copyRange(a, cursor2, a, dest, len2);
1:         s.copyElement(tmp, cursor1, a, dest + len2); //  Last elt of run 1 to end of merge
1:       } else if (len1 == 0) {
1:         throw new IllegalArgumentException(
1:             "Comparison method violates its general contract!");
1:       } else {
1:         assert len2 == 0;
1:         assert len1 > 1;
1:         s.copyRange(tmp, cursor1, a, dest, len1);
1:       }
1:     }
1: 
1:     /**
1:      * Like mergeLo, except that this method should be called only if
1:      * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
1:      * may be called if len1 == len2.)
1:      *
1:      * @param base1 index of first element in first run to be merged
1:      * @param len1  length of first run to be merged (must be > 0)
1:      * @param base2 index of first element in second run to be merged
1:      *        (must be aBase + aLen)
1:      * @param len2  length of second run to be merged (must be > 0)
1:      */
1:     private void mergeHi(int base1, int len1, int base2, int len2) {
1:       assert len1 > 0 && len2 > 0 && base1 + len1 == base2;
1: 
1:       // Copy second run into temp array
1:       Buffer a = this.a; // For performance
1:       Buffer tmp = ensureCapacity(len2);
1:       s.copyRange(a, base2, tmp, 0, len2);
1: 
1:       int cursor1 = base1 + len1 - 1;  // Indexes into a
1:       int cursor2 = len2 - 1;          // Indexes into tmp array
1:       int dest = base2 + len2 - 1;     // Indexes into a
1: 
1:       K key0 = s.newKey();
1:       K key1 = s.newKey();
1: 
1:       // Move last element of first run and deal with degenerate cases
1:       s.copyElement(a, cursor1--, a, dest--);
1:       if (--len1 == 0) {
1:         s.copyRange(tmp, 0, a, dest - (len2 - 1), len2);
1:         return;
1:       }
1:       if (len2 == 1) {
1:         dest -= len1;
1:         cursor1 -= len1;
1:         s.copyRange(a, cursor1 + 1, a, dest + 1, len1);
1:         s.copyElement(tmp, cursor2, a, dest);
1:         return;
1:       }
1: 
1:       Comparator<? super K> c = this.c;  // Use local variable for performance
1:       int minGallop = this.minGallop;    //  "    "       "     "      "
1:       outer:
1:       while (true) {
1:         int count1 = 0; // Number of times in a row that first run won
1:         int count2 = 0; // Number of times in a row that second run won
1: 
1:         /*
1:          * Do the straightforward thing until (if ever) one run
1:          * appears to win consistently.
1:          */
1:         do {
1:           assert len1 > 0 && len2 > 1;
1:           if (c.compare(s.getKey(tmp, cursor2, key0), s.getKey(a, cursor1, key1)) < 0) {
1:             s.copyElement(a, cursor1--, a, dest--);
1:             count1++;
1:             count2 = 0;
0:             if (--len1 == 0)
1:               break outer;
1:           } else {
1:             s.copyElement(tmp, cursor2--, a, dest--);
1:             count2++;
1:             count1 = 0;
0:             if (--len2 == 1)
1:               break outer;
1:           }
1:         } while ((count1 | count2) < minGallop);
1: 
1:         /*
1:          * One run is winning so consistently that galloping may be a
1:          * huge win. So try that, and continue galloping until (if ever)
1:          * neither run appears to be winning consistently anymore.
1:          */
1:         do {
1:           assert len1 > 0 && len2 > 1;
1:           count1 = len1 - gallopRight(s.getKey(tmp, cursor2, key0), a, base1, len1, len1 - 1, c);
1:           if (count1 != 0) {
1:             dest -= count1;
1:             cursor1 -= count1;
1:             len1 -= count1;
1:             s.copyRange(a, cursor1 + 1, a, dest + 1, count1);
0:             if (len1 == 0)
1:               break outer;
1:           }
1:           s.copyElement(tmp, cursor2--, a, dest--);
0:           if (--len2 == 1)
1:             break outer;
1: 
1:           count2 = len2 - gallopLeft(s.getKey(a, cursor1, key0), tmp, 0, len2, len2 - 1, c);
1:           if (count2 != 0) {
1:             dest -= count2;
1:             cursor2 -= count2;
1:             len2 -= count2;
1:             s.copyRange(tmp, cursor2 + 1, a, dest + 1, count2);
0:             if (len2 <= 1)  // len2 == 1 || len2 == 0
1:               break outer;
1:           }
1:           s.copyElement(a, cursor1--, a, dest--);
0:           if (--len1 == 0)
1:             break outer;
1:           minGallop--;
1:         } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
0:         if (minGallop < 0)
1:           minGallop = 0;
1:         minGallop += 2;  // Penalize for leaving gallop mode
1:       }  // End of "outer" loop
1:       this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field
1: 
1:       if (len2 == 1) {
1:         assert len1 > 0;
1:         dest -= len1;
1:         cursor1 -= len1;
1:         s.copyRange(a, cursor1 + 1, a, dest + 1, len1);
1:         s.copyElement(tmp, cursor2, a, dest); // Move first elt of run2 to front of merge
1:       } else if (len2 == 0) {
1:         throw new IllegalArgumentException(
1:             "Comparison method violates its general contract!");
1:       } else {
1:         assert len1 == 0;
1:         assert len2 > 0;
1:         s.copyRange(tmp, 0, a, dest - (len2 - 1), len2);
1:       }
1:     }
1: 
1:     /**
1:      * Ensures that the external array tmp has at least the specified
1:      * number of elements, increasing its size if necessary.  The size
1:      * increases exponentially to ensure amortized linear time complexity.
1:      *
1:      * @param minCapacity the minimum required capacity of the tmp array
1:      * @return tmp, whether or not it grew
1:      */
1:     private Buffer ensureCapacity(int minCapacity) {
1:       if (tmpLength < minCapacity) {
1:         // Compute smallest power of 2 > minCapacity
1:         int newSize = minCapacity;
1:         newSize |= newSize >> 1;
1:         newSize |= newSize >> 2;
1:         newSize |= newSize >> 4;
1:         newSize |= newSize >> 8;
1:         newSize |= newSize >> 16;
1:         newSize++;
1: 
0:         if (newSize < 0) // Not bloody likely!
1:           newSize = minCapacity;
0:         else
1:           newSize = Math.min(newSize, aLength >>> 1);
1: 
1:         tmp = s.allocate(newSize);
1:         tmpLength = newSize;
1:       }
1:       return tmp;
1:     }
1:   }
1: }
============================================================================