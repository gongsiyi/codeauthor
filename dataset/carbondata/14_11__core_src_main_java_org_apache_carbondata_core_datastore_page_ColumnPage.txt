1:98df130: /*
1:98df130:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:98df130:  * contributor license agreements.  See the NOTICE file distributed with
1:98df130:  * this work for additional information regarding copyright ownership.
1:98df130:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:98df130:  * (the "License"); you may not use this file except in compliance with
1:98df130:  * the License.  You may obtain a copy of the License at
1:98df130:  *
1:98df130:  *    http://www.apache.org/licenses/LICENSE-2.0
1:98df130:  *
1:98df130:  * Unless required by applicable law or agreed to in writing, software
1:98df130:  * distributed under the License is distributed on an "AS IS" BASIS,
1:98df130:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:98df130:  * See the License for the specific language governing permissions and
1:98df130:  * limitations under the License.
2:edda248:  */
1:edda248: 
1:98df130: package org.apache.carbondata.core.datastore.page;
1:7359601: 
1:eadfea7: import java.io.IOException;
1:dc83b2a: import java.math.BigDecimal;
1:e6a4f64: import java.util.BitSet;
1:7359601: 
1:dc83b2a: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:6297ea0: import org.apache.carbondata.core.datastore.ColumnType;
1:8c1ddbf: import org.apache.carbondata.core.datastore.TableSpec;
1:edda248: import org.apache.carbondata.core.datastore.compression.Compressor;
1:8c1ddbf: import org.apache.carbondata.core.datastore.compression.CompressorFactory;
1:8c1ddbf: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
1:6abdd97: import org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert;
1:bc3e684: import org.apache.carbondata.core.datastore.page.statistics.ColumnPageStatsCollector;
1:e6a4f64: import org.apache.carbondata.core.datastore.page.statistics.SimpleStatsResult;
1:e710339: import org.apache.carbondata.core.localdictionary.PageLevelDictionary;
1:e710339: import org.apache.carbondata.core.localdictionary.generator.LocalDictionaryGenerator;
1:7359601: import org.apache.carbondata.core.memory.MemoryException;
1:dc83b2a: import org.apache.carbondata.core.metadata.datatype.DataType;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:edda248: import org.apache.carbondata.core.util.CarbonProperties;
1:edda248: 
1:956833e: import static org.apache.carbondata.core.metadata.datatype.DataTypes.BYTE;
1:956833e: import static org.apache.carbondata.core.metadata.datatype.DataTypes.BYTE_ARRAY;
1:956833e: import static org.apache.carbondata.core.metadata.datatype.DataTypes.DOUBLE;
1:956833e: import static org.apache.carbondata.core.metadata.datatype.DataTypes.FLOAT;
1:956833e: import static org.apache.carbondata.core.metadata.datatype.DataTypes.INT;
1:956833e: import static org.apache.carbondata.core.metadata.datatype.DataTypes.LONG;
1:956833e: import static org.apache.carbondata.core.metadata.datatype.DataTypes.SHORT;
1:956833e: import static org.apache.carbondata.core.metadata.datatype.DataTypes.SHORT_INT;
1:edda248: 
1:7359601: public abstract class ColumnPage {
1:7359601: 
1:8c1ddbf:   // number of row in this page
1:8925947:   protected int pageSize;
1:8c1ddbf: 
1:8f08c4a:   protected ColumnPageEncoderMeta columnPageEncoderMeta;
1:8c1ddbf: 
1:e6a4f64:   // The index of the rowId whose value is null, will be set to 1
1:438b442:   protected BitSet nullBitSet;
1:e6a4f64: 
1:bc3e684:   // statistics collector for this column page
1:e710339:   protected ColumnPageStatsCollector statsCollector;
1:edda248: 
1:7359601:   protected static final boolean unsafe = Boolean.parseBoolean(CarbonProperties.getInstance()
1:be600bc:       .getProperty(CarbonCommonConstants.ENABLE_UNSAFE_COLUMN_PAGE,
1:be600bc:           CarbonCommonConstants.ENABLE_UNSAFE_COLUMN_PAGE_DEFAULT));
1:7359601: 
1:8c1ddbf:   /**
1:8c1ddbf:    * Create a new column page with input data type and page size.
1:8c1ddbf:    */
1:8f08c4a:   protected ColumnPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize) {
1:7359601:     this.pageSize = pageSize;
1:e6a4f64:     this.nullBitSet = new BitSet(pageSize);
1:8f08c4a:     this.columnPageEncoderMeta = columnPageEncoderMeta;
1:e6a4f64:   }
1:e6a4f64: 
1:dc83b2a:   public DataType getDataType() {
1:8f08c4a:     return columnPageEncoderMeta.getStoreDataType();
1:e6a4f64:   }
1:e6a4f64: 
1:e6a4f64:   public SimpleStatsResult getStatistics() {
1:e710339:     return statsCollector.getPageStats();
1:e6a4f64:   }
1:e6a4f64: 
1:edda248:   public int getPageSize() {
1:edda248:     return pageSize;
1:e6a4f64:   }
1:e6a4f64: 
1:bc3e684:   public void setStatsCollector(ColumnPageStatsCollector statsCollector) {
1:bc3e684:     this.statsCollector = statsCollector;
1:e6a4f64:   }
1:e6a4f64: 
1:8f08c4a:   private static ColumnPage createDecimalPage(ColumnPageEncoderMeta columnPageEncoderMeta,
2:8c1ddbf:       int pageSize) {
1:e710339:     if (unsafe) {
1:6297ea0:       try {
1:8f08c4a:         return new UnsafeDecimalColumnPage(columnPageEncoderMeta, pageSize);
1:6297ea0:       } catch (MemoryException e) {
1:6297ea0:         throw new RuntimeException(e);
1:6297ea0:       }
1:e710339:     } else {
1:8f08c4a:       return new SafeDecimalColumnPage(columnPageEncoderMeta, pageSize);
1:e710339:     }
1:e710339:   }
1:e710339: 
1:8f08c4a:   private static ColumnPage createVarLengthPage(ColumnPageEncoderMeta columnPageEncoderMeta,
1:8c1ddbf:       int pageSize) {
1:6297ea0:     if (unsafe) {
1:6f20437:       try {
1:8f08c4a:         return new UnsafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
1:6f20437:       } catch (MemoryException e) {
1:6f20437:         throw new RuntimeException(e);
1:6297ea0:       }
1:6297ea0:     } else {
1:8f08c4a:       return new SafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
1:6297ea0:     }
1:e6a4f64:   }
1:6297ea0: 
1:8f08c4a:   private static ColumnPage createFixLengthPage(
1:8f08c4a:       ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize) {
1:6f20437:     if (unsafe) {
2:7359601:       try {
1:8f08c4a:         return new UnsafeFixLengthColumnPage(columnPageEncoderMeta, pageSize);
2:7359601:       } catch (MemoryException e) {
2:7359601:         throw new RuntimeException(e);
1:e6a4f64:       }
1:e6a4f64:     } else {
1:8f08c4a:       return new SafeFixLengthColumnPage(columnPageEncoderMeta, pageSize);
1:e6a4f64:     }
1:379d4f6:   }
1:e6a4f64: 
1:8f08c4a:   private static ColumnPage createFixLengthByteArrayPage(
1:8f08c4a:       ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize, int eachValueSize) {
2:7359601:     if (unsafe) {
1:7359601:       try {
1:8f08c4a:         return new UnsafeFixLengthColumnPage(columnPageEncoderMeta, pageSize, eachValueSize);
1:7359601:       } catch (MemoryException e) {
1:7359601:         throw new RuntimeException(e);
1:6f20437:       }
1:6f20437:     } else {
1:8f08c4a:       return new SafeFixLengthColumnPage(columnPageEncoderMeta, pageSize);
1:6f20437:     }
1:6f20437:   }
1:e6a4f64: 
1:8f08c4a:   private static ColumnPage createPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize) {
1:8f08c4a:     if (DataTypes.isDecimal(columnPageEncoderMeta.getStoreDataType())) {
1:8f08c4a:       return createDecimalPage(columnPageEncoderMeta, pageSize);
1:8f08c4a:     } else if (columnPageEncoderMeta.getStoreDataType().equals(BYTE_ARRAY)) {
1:8f08c4a:       return createVarLengthPage(columnPageEncoderMeta, pageSize);
3:7359601:     } else {
1:8f08c4a:       return createFixLengthPage(columnPageEncoderMeta, pageSize);
1:bc3e684:     }
1:7359601:   }
1:379d4f6: 
1:8f08c4a:   public static ColumnPage newDecimalPage(ColumnPageEncoderMeta columnPageEncoderMeta,
1:8f08c4a:       int pageSize) throws MemoryException {
1:8f08c4a:     return newPage(columnPageEncoderMeta, pageSize);
1:7359601:   }
1:6f20437: 
1:8f08c4a:   public static ColumnPage newLocalDictPage(ColumnPageEncoderMeta columnPageEncoderMeta,
1:3a4b881:       int pageSize, LocalDictionaryGenerator localDictionaryGenerator,
1:3a4b881:       boolean isComplexTypePrimitive) throws MemoryException {
1:2ccdbb7:     boolean isDecoderBasedFallBackEnabled = Boolean.parseBoolean(CarbonProperties.getInstance()
1:2ccdbb7:         .getProperty(CarbonCommonConstants.LOCAL_DICTIONARY_DECODER_BASED_FALLBACK,
1:2ccdbb7:             CarbonCommonConstants.LOCAL_DICTIONARY_DECODER_BASED_FALLBACK_DEFAULT));
1:8f08c4a:     ColumnPage actualPage;
1:8f08c4a:     ColumnPage encodedPage;
1:7359601:     if (unsafe) {
1:8f08c4a:       actualPage = new UnsafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
1:8f08c4a:       encodedPage = new UnsafeFixLengthColumnPage(
1:8f08c4a:           new ColumnPageEncoderMeta(columnPageEncoderMeta.getColumnSpec(), DataTypes.BYTE_ARRAY,
1:8f08c4a:               columnPageEncoderMeta.getCompressorName()),
1:8f08c4a:           pageSize,
1:8f08c4a:           CarbonCommonConstants.LOCAL_DICT_ENCODED_BYTEARRAY_SIZE);
1:7359601:     } else {
1:8f08c4a:       actualPage = new SafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
1:8f08c4a:       encodedPage = new SafeFixLengthColumnPage(
1:8f08c4a:           new ColumnPageEncoderMeta(columnPageEncoderMeta.getColumnSpec(), DataTypes.BYTE_ARRAY,
1:8f08c4a:               columnPageEncoderMeta.getCompressorName()),
1:8f08c4a:           pageSize);
1:7359601:     }
1:8f08c4a:     return new LocalDictColumnPage(actualPage, encodedPage, localDictionaryGenerator,
1:8f08c4a:         isComplexTypePrimitive, isDecoderBasedFallBackEnabled);
1:7359601:   }
1:bc3e684: 
1:7359601:   /**
1:7359601:    * Create a new page of dataType and number of row = pageSize
1:7359601:    */
1:8f08c4a:   public static ColumnPage newPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize)
1:8f08c4a:       throws MemoryException {
1:7359601:     ColumnPage instance;
1:8f08c4a:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:8f08c4a:     TableSpec.ColumnSpec columnSpec = columnPageEncoderMeta.getColumnSpec();
1:8f08c4a:     String compressorName = columnPageEncoderMeta.getCompressorName();
1:7359601:     if (unsafe) {
1:6abdd97:       if (dataType == DataTypes.BOOLEAN) {
1:8f08c4a:         instance = new UnsafeFixLengthColumnPage(
1:8f08c4a:             new ColumnPageEncoderMeta(columnSpec, BYTE, compressorName), pageSize);
1:6abdd97:       } else if (dataType == DataTypes.BYTE ||
1:956833e:           dataType == DataTypes.SHORT ||
1:956833e:           dataType == DataTypes.SHORT_INT ||
1:956833e:           dataType == DataTypes.INT ||
1:956833e:           dataType == DataTypes.LONG ||
1:956833e:           dataType == DataTypes.FLOAT ||
1:956833e:           dataType == DataTypes.DOUBLE) {
1:8f08c4a:         instance = new UnsafeFixLengthColumnPage(
1:8f08c4a:             new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), pageSize);
1:438b442:       } else if (dataType == DataTypes.TIMESTAMP) {
1:8f08c4a:         instance = new UnsafeFixLengthColumnPage(
1:8f08c4a:             new ColumnPageEncoderMeta(columnSpec, DataTypes.LONG, compressorName), pageSize);
1:f209e8e:       } else if (DataTypes.isDecimal(dataType)) {
1:8f08c4a:         instance = new UnsafeDecimalColumnPage(
1:8f08c4a:             new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), pageSize);
1:dc53dee:       } else if (dataType == DataTypes.STRING
1:dc53dee:           || dataType == DataTypes.BYTE_ARRAY
1:dc53dee:           || dataType == DataTypes.VARCHAR) {
1:8f08c4a:         instance = new UnsafeVarLengthColumnPage(
1:8f08c4a:             new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), pageSize);
1:956833e:       } else {
1:956833e:         throw new RuntimeException("Unsupported data dataType: " + dataType);
1:7359601:       }
1:7359601:     } else {
1:6abdd97:       if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:8f08c4a:         instance = newBytePage(columnSpec, new byte[pageSize], compressorName);
1:956833e:       } else if (dataType == DataTypes.SHORT) {
1:8f08c4a:         instance = newShortPage(columnSpec, new short[pageSize], compressorName);
1:956833e:       } else if (dataType == DataTypes.SHORT_INT) {
1:8f08c4a:         instance = newShortIntPage(columnSpec, new byte[pageSize * 3], compressorName);
1:956833e:       } else if (dataType == DataTypes.INT) {
1:8f08c4a:         instance = newIntPage(columnSpec, new int[pageSize], compressorName);
1:438b442:       } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
1:8f08c4a:         instance = newLongPage(columnSpec, new long[pageSize], compressorName);
1:956833e:       } else if (dataType == DataTypes.FLOAT) {
1:8f08c4a:         instance = newFloatPage(columnSpec, new float[pageSize], compressorName);
1:956833e:       } else if (dataType == DataTypes.DOUBLE) {
1:8f08c4a:         instance = newDoublePage(columnSpec, new double[pageSize], compressorName);
1:f209e8e:       } else if (DataTypes.isDecimal(dataType)) {
1:8f08c4a:         instance = newDecimalPage(columnSpec, new byte[pageSize][], compressorName);
1:dc53dee:       } else if (dataType == DataTypes.STRING
1:dc53dee:           || dataType == DataTypes.BYTE_ARRAY
1:dc53dee:           || dataType == DataTypes.VARCHAR) {
1:8f08c4a:         instance = new SafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
1:956833e:       } else {
1:956833e:         throw new RuntimeException("Unsupported data dataType: " + dataType);
1:7359601:       }
1:7359601:     }
1:7359601:     return instance;
1:7359601:   }
1:7359601: 
1:8f08c4a:   public static ColumnPage wrapByteArrayPage(TableSpec.ColumnSpec columnSpec, byte[][] byteArray,
1:8f08c4a:       String compressorName) {
1:8f08c4a:     ColumnPage columnPage = createPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, BYTE_ARRAY, compressorName), byteArray.length);
1:e6a4f64:     columnPage.setByteArrayPage(byteArray);
1:e6a4f64:     return columnPage;
1:e6a4f64:   }
1:e6a4f64: 
1:8f08c4a:   private static ColumnPage newBytePage(TableSpec.ColumnSpec columnSpec, byte[] byteData,
1:8f08c4a:       String compressorName) {
1:8f08c4a:     ColumnPage columnPage = createPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, BYTE, compressorName), byteData.length);
1:7359601:     columnPage.setBytePage(byteData);
1:7359601:     return columnPage;
1:7359601:   }
1:7359601: 
1:8f08c4a:   private static ColumnPage newShortPage(TableSpec.ColumnSpec columnSpec, short[] shortData,
1:8f08c4a:       String compressorName) {
1:8f08c4a:     ColumnPage columnPage = createPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, SHORT, compressorName), shortData.length);
1:7359601:     columnPage.setShortPage(shortData);
1:7359601:     return columnPage;
1:7359601:   }
1:7359601: 
1:8f08c4a:   private static ColumnPage newShortIntPage(TableSpec.ColumnSpec columnSpec, byte[] shortIntData,
1:8f08c4a:       String compressorName) {
1:8f08c4a:     ColumnPage columnPage = createPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, SHORT_INT, compressorName), shortIntData.length / 3);
1:7d386a4:     columnPage.setShortIntPage(shortIntData);
1:7d386a4:     return columnPage;
1:7d386a4:   }
1:7d386a4: 
1:8f08c4a:   private static ColumnPage newIntPage(TableSpec.ColumnSpec columnSpec, int[] intData,
1:8f08c4a:       String compressorName) {
1:8f08c4a:     ColumnPage columnPage = createPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, INT, compressorName), intData.length);
1:7359601:     columnPage.setIntPage(intData);
1:7359601:     return columnPage;
1:7359601:   }
1:7359601: 
1:8f08c4a:   private static ColumnPage newLongPage(TableSpec.ColumnSpec columnSpec, long[] longData,
1:8f08c4a:       String compressorName) {
1:8f08c4a:     ColumnPage columnPage = createPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, LONG, compressorName), longData.length);
1:7359601:     columnPage.setLongPage(longData);
1:7359601:     return columnPage;
1:7359601:   }
1:7359601: 
1:8f08c4a:   private static ColumnPage newFloatPage(TableSpec.ColumnSpec columnSpec, float[] floatData,
1:8f08c4a:       String compressorName) {
1:8f08c4a:     ColumnPage columnPage = createPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, FLOAT, compressorName), floatData.length);
1:7359601:     columnPage.setFloatPage(floatData);
1:7359601:     return columnPage;
1:7359601:   }
1:7359601: 
1:8f08c4a:   private static ColumnPage newDoublePage(TableSpec.ColumnSpec columnSpec, double[] doubleData,
1:8f08c4a:       String compressorName) {
1:8f08c4a:     ColumnPage columnPage = createPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, DOUBLE, compressorName), doubleData.length);
1:7359601:     columnPage.setDoublePage(doubleData);
1:7359601:     return columnPage;
1:7359601:   }
1:7359601: 
1:8f08c4a:   private static ColumnPage newDecimalPage(TableSpec.ColumnSpec columnSpec, byte[][] byteArray,
1:8f08c4a:       String compressorName) {
1:8f08c4a:     ColumnPage columnPage = createPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, columnSpec.getSchemaDataType(), compressorName),
1:8f08c4a:         byteArray.length);
1:7359601:     columnPage.setByteArrayPage(byteArray);
1:7359601:     return columnPage;
1:7359601:   }
1:7359601: 
1:8c1ddbf:   private static ColumnPage newDecimalPage(TableSpec.ColumnSpec columnSpec,
1:8f08c4a:       byte[] lvEncodedByteArray, String compressorName) throws MemoryException {
1:8f08c4a:     return VarLengthColumnPageBase.newDecimalColumnPage(
1:8f08c4a:         columnSpec, lvEncodedByteArray, compressorName);
1:7359601:   }
1:7359601: 
1:8c1ddbf:   private static ColumnPage newLVBytesPage(TableSpec.ColumnSpec columnSpec,
1:8f08c4a:       byte[] lvEncodedByteArray, int lvLength, String compressorName) throws MemoryException {
1:8f08c4a:     return VarLengthColumnPageBase.newLVBytesColumnPage(
1:8f08c4a:         columnSpec, lvEncodedByteArray, lvLength, compressorName);
1:6297ea0:   }
1:6297ea0: 
1:6297ea0:   private static ColumnPage newComplexLVBytesPage(TableSpec.ColumnSpec columnSpec,
1:8f08c4a:       byte[] lvEncodedByteArray, int lvLength, String compressorName) throws MemoryException {
1:8f08c4a:     return VarLengthColumnPageBase.newComplexLVBytesColumnPage(
1:8f08c4a:         columnSpec, lvEncodedByteArray, lvLength, compressorName);
1:6297ea0:   }
1:6297ea0: 
1:6297ea0:   private static ColumnPage newFixedByteArrayPage(TableSpec.ColumnSpec columnSpec,
1:8f08c4a:       byte[] lvEncodedByteArray, int eachValueSize, String compressorName) throws MemoryException {
1:6297ea0:     int pageSize = lvEncodedByteArray.length / eachValueSize;
1:8f08c4a:     ColumnPage fixLengthByteArrayPage = createFixLengthByteArrayPage(
1:8f08c4a:         new ColumnPageEncoderMeta(columnSpec, columnSpec.getSchemaDataType(), compressorName),
1:8f08c4a:         pageSize, eachValueSize);
1:6297ea0:     byte[] data = null;
1:6297ea0:     int offset = 0;
1:6297ea0:     for (int i = 0; i < pageSize; i++) {
1:6297ea0:       data = new byte[eachValueSize];
1:6297ea0:       System.arraycopy(lvEncodedByteArray, offset, data, 0, eachValueSize);
1:6297ea0:       fixLengthByteArrayPage.putBytes(i, data);
1:6297ea0:       offset += eachValueSize;
1:6297ea0:     }
1:6297ea0:     return fixLengthByteArrayPage;
1:7359601:   }
1:7359601: 
1:7359601:   /**
1:7359601:    * Set byte values to page
1:7359601:    */
1:7359601:   public abstract void setBytePage(byte[] byteData);
1:7359601: 
1:7359601:   /**
1:7359601:    * Set short values to page
1:7359601:    */
1:7359601:   public abstract void setShortPage(short[] shortData);
1:7359601: 
1:7359601:   /**
1:7d386a4:    * Set short int values to page
1:7d386a4:    */
1:7d386a4:   public abstract void setShortIntPage(byte[] shortIntData);
1:7d386a4: 
1:7d386a4:   /**
1:7359601:    * Set int values to page
1:7359601:    */
1:7359601:   public abstract void setIntPage(int[] intData);
1:7359601: 
1:7359601:   /**
1:7359601:    * Set long values to page
1:7359601:    */
1:7359601:   public abstract void setLongPage(long[] longData);
1:7359601: 
1:7359601:   /**
1:7359601:    * Set float values to page
1:7359601:    */
1:7359601:   public abstract void setFloatPage(float[] floatData);
1:7359601: 
1:7359601:   /**
1:7359601:    * Set double value to page
1:7359601:    */
1:7359601:   public abstract void setDoublePage(double[] doubleData);
1:7359601: 
1:7359601:   /**
1:7359601:    * Set byte array to page
1:7359601:    */
1:7359601:   public abstract void setByteArrayPage(byte[][] byteArray);
1:7359601: 
1:7359601:   /**
1:7359601:    * free memory as needed
1:7359601:    */
1:7359601:   public abstract void freeMemory();
1:7359601: 
1:7359601:   /**
1:7359601:    * Set value at rowId
1:7359601:    */
1:dc83b2a:   public void putData(int rowId, Object value) {
1:dc83b2a:     if (value == null) {
1:dc83b2a:       putNull(rowId);
1:bc3e684:       statsCollector.updateNull(rowId);
1:e6a4f64:       nullBitSet.set(rowId);
1:dc83b2a:       return;
1:7359601:     }
1:8f08c4a:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:6abdd97:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:8f08c4a:       if (columnPageEncoderMeta.getColumnSpec().getSchemaDataType() == DataTypes.BOOLEAN) {
1:6abdd97:         value = BooleanConvert.boolean2Byte((Boolean) value);
1:6abdd97:       }
1:956833e:       putByte(rowId, (byte) value);
1:956833e:       statsCollector.update((byte) value);
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       putShort(rowId, (short) value);
1:956833e:       statsCollector.update((short) value);
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       putInt(rowId, (int) value);
1:956833e:       statsCollector.update((int) value);
1:956833e:     } else if (dataType == DataTypes.LONG) {
1:956833e:       putLong(rowId, (long) value);
1:956833e:       statsCollector.update((long) value);
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       putDouble(rowId, (double) value);
1:956833e:       statsCollector.update((double) value);
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       putDecimal(rowId, (BigDecimal) value);
1:956833e:       statsCollector.update((BigDecimal) value);
1:dc53dee:     } else if (dataType == DataTypes.STRING
1:dc53dee:         || dataType == DataTypes.BYTE_ARRAY
1:dc53dee:         || dataType == DataTypes.VARCHAR) {
1:956833e:       putBytes(rowId, (byte[]) value);
1:956833e:       statsCollector.update((byte[]) value);
1:956833e:     } else {
1:956833e:       throw new RuntimeException("unsupported data type: " + dataType);
1:7359601:     }
1:7359601:   }
1:7359601: 
1:edda248:   /**
1:ecd6c0c:    * get value at rowId, note that the value of string&bytes is LV format
1:ecd6c0c:    * @param rowId rowId
1:ecd6c0c:    * @return value
1:ecd6c0c:    */
1:ecd6c0c:   public Object getData(int rowId) {
1:ecd6c0c:     if (nullBitSet.get(rowId)) {
1:ecd6c0c:       return getNull(rowId);
1:ecd6c0c:     }
1:8f08c4a:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:ecd6c0c:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:ecd6c0c:       byte value = getByte(rowId);
1:8f08c4a:       if (columnPageEncoderMeta.getColumnSpec().getSchemaDataType() == DataTypes.BOOLEAN) {
1:ecd6c0c:         return BooleanConvert.byte2Boolean(value);
1:ecd6c0c:       }
1:ecd6c0c:       return value;
1:ecd6c0c:     } else if (dataType == DataTypes.SHORT) {
1:ecd6c0c:       return getShort(rowId);
1:ecd6c0c:     } else if (dataType == DataTypes.INT) {
1:ecd6c0c:       return getInt(rowId);
1:ecd6c0c:     } else if (dataType == DataTypes.LONG) {
1:ecd6c0c:       return getLong(rowId);
1:ecd6c0c:     } else if (dataType == DataTypes.DOUBLE) {
1:ecd6c0c:       return getDouble(rowId);
1:ecd6c0c:     } else if (DataTypes.isDecimal(dataType)) {
1:ecd6c0c:       return getDecimal(rowId);
1:dc53dee:     } else if (dataType == DataTypes.STRING
1:dc53dee:         || dataType == DataTypes.BYTE_ARRAY
1:dc53dee:         || dataType == DataTypes.VARCHAR) {
1:ecd6c0c:       return getBytes(rowId);
1:ecd6c0c:     } else {
1:ecd6c0c:       throw new RuntimeException("unsupported data type: " + dataType);
1:ecd6c0c:     }
1:ecd6c0c:   }
1:ecd6c0c: 
1:ecd6c0c:   /**
1:dc83b2a:    * Set byte value at rowId
1:edda248:    */
1:7359601:   public abstract void putByte(int rowId, byte value);
1:edda248: 
1:edda248:   /**
1:dc83b2a:    * Set short value at rowId
1:edda248:    */
1:7359601:   public abstract void putShort(int rowId, short value);
1:edda248: 
1:edda248:   /**
1:dc83b2a:    * Set integer value at rowId
1:edda248:    */
1:7359601:   public abstract void putInt(int rowId, int value);
1:edda248: 
1:edda248:   /**
1:dc83b2a:    * Set long value at rowId
1:edda248:    */
1:7359601:   public abstract void putLong(int rowId, long value);
1:edda248: 
1:edda248:   /**
1:dc83b2a:    * Set double value at rowId
1:edda248:    */
1:7359601:   public abstract void putDouble(int rowId, double value);
1:edda248: 
1:edda248:   /**
1:7359601:    * Set byte array value at rowId
1:edda248:    */
1:7359601:   public abstract void putBytes(int rowId, byte[] bytes);
1:edda248: 
1:edda248:   /**
1:9e064ee:    * Set byte array value at rowId
1:edda248:    */
1:9e064ee:   public abstract void putDecimal(int rowId, BigDecimal decimal);
1:edda248: 
1:edda248:   /**
1:7d386a4:    * Type cast int value to 3 bytes value and set at rowId
1:7d386a4:    */
1:7d386a4:   public abstract void putShortInt(int rowId, int value);
1:7d386a4: 
1:7d386a4:   /**
1:6abdd97:    * Set boolean value at rowId
1:6abdd97:    */
1:6abdd97:   public void putBoolean(int rowId, boolean value) {
1:6abdd97:     putByte(rowId, BooleanConvert.boolean2Byte(value));
1:6abdd97:   }
1:6abdd97: 
1:6abdd97:   /**
1:7359601:    * Set byte array from offset to length at rowId
1:edda248:    */
1:7359601:   public abstract void putBytes(int rowId, byte[] bytes, int offset, int length);
1:7359601: 
6:edda248: 
1:edda248:   /**
1:dc83b2a:    * Set null at rowId
1:edda248:    */
1:438b442:   protected void putNull(int rowId) {
1:8f08c4a:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:6abdd97:     if (dataType == DataTypes.BOOLEAN) {
1:6abdd97:       putBoolean(rowId, false);
1:6abdd97:     } else if (dataType == DataTypes.BYTE) {
1:956833e:       putByte(rowId, (byte) 0);
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       putShort(rowId, (short) 0);
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       putInt(rowId, 0);
1:956833e:     } else if (dataType == DataTypes.LONG) {
1:956833e:       putLong(rowId, 0L);
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       putDouble(rowId, 0.0);
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       putDecimal(rowId, BigDecimal.ZERO);
1:956833e:     } else {
1:956833e:       throw new IllegalArgumentException("unsupported data type: " + dataType);
1:7359601:     }
1:7359601:   }
1:edda248: 
3:edda248:   /**
1:ecd6c0c:    * Get null at rowId
1:ecd6c0c:    */
1:ecd6c0c:   private Object getNull(int rowId) {
1:ecd6c0c:     Object result;
1:8f08c4a:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:ecd6c0c:     if (dataType == DataTypes.BOOLEAN) {
1:ecd6c0c:       result = getBoolean(rowId);
1:ecd6c0c:     } else if (dataType == DataTypes.BYTE) {
1:ecd6c0c:       result = getByte(rowId);
1:8f08c4a:       if (columnPageEncoderMeta.getColumnSpec().getSchemaDataType() == DataTypes.BOOLEAN) {
1:7551cc6:         result = BooleanConvert.byte2Boolean((byte)result);
1:7551cc6:       }
1:ecd6c0c:     } else if (dataType == DataTypes.SHORT) {
1:ecd6c0c:       result = getShort(rowId);
1:ecd6c0c:     } else if (dataType == DataTypes.INT) {
1:ecd6c0c:       result = getInt(rowId);
1:ecd6c0c:     } else if (dataType == DataTypes.LONG) {
1:ecd6c0c:       result = getLong(rowId);
1:ecd6c0c:     } else if (dataType == DataTypes.DOUBLE) {
1:ecd6c0c:       result = getDouble(rowId);
1:ecd6c0c:     } else if (DataTypes.isDecimal(dataType)) {
1:ecd6c0c:       result = getDecimal(rowId);
1:ecd6c0c:     } else {
1:ecd6c0c:       throw new IllegalArgumentException("unsupported data type: " + dataType);
1:ecd6c0c:     }
1:ecd6c0c:     return result;
1:ecd6c0c:   }
1:ecd6c0c: 
1:ecd6c0c:   /**
1:7359601:    * Get byte value at rowId
1:edda248:    */
1:7359601:   public abstract byte getByte(int rowId);
1:edda248: 
1:edda248:   /**
1:7359601:    * Get short value at rowId
1:7359601:    */
1:7359601:   public abstract short getShort(int rowId);
1:7359601: 
1:7359601:   /**
1:7d386a4:    * Get short int value at rowId
1:7d386a4:    */
1:7d386a4:   public abstract int getShortInt(int rowId);
1:7d386a4: 
1:7d386a4:   /**
1:6abdd97:    * Get boolean value at rowId
1:6abdd97:    */
1:6abdd97:   public boolean getBoolean(int rowId) {
1:6abdd97:     return BooleanConvert.byte2Boolean(getByte(rowId));
1:6abdd97:   }
1:6abdd97: 
1:6abdd97:   /**
1:7359601:    * Get int value at rowId
1:7359601:    */
1:7359601:   public abstract int getInt(int rowId);
1:7359601: 
1:7359601:   /**
1:7359601:    * Get long value at rowId
1:7359601:    */
1:7359601:   public abstract long getLong(int rowId);
1:7359601: 
1:7359601:   /**
1:7359601:    * Get float value at rowId
1:7359601:    */
1:7359601:   public abstract float getFloat(int rowId);
1:7359601: 
1:7359601:   /**
1:7359601:    * Get double value at rowId
1:7359601:    */
1:7359601:   public abstract double getDouble(int rowId);
1:7359601: 
1:7359601:   /**
1:7359601:    * Get decimal value at rowId
1:7359601:    */
1:7359601:   public abstract BigDecimal getDecimal(int rowId);
1:7359601: 
1:7359601:   /**
1:e6a4f64:    * Get byte array at rowId
1:e6a4f64:    */
1:e6a4f64:   public abstract byte[] getBytes(int rowId);
1:e6a4f64: 
1:e6a4f64:   /**
1:7359601:    * Get byte value page
1:7359601:    */
1:7359601:   public abstract byte[] getBytePage();
1:7359601: 
1:7359601:   /**
1:7359601:    * Get short value page
1:7359601:    */
1:7359601:   public abstract short[] getShortPage();
1:7359601: 
1:7359601:   /**
1:7d386a4:    * Get short int value page
1:7d386a4:    */
1:7d386a4:   public abstract byte[] getShortIntPage();
1:7d386a4: 
1:7d386a4:   /**
1:6abdd97:    * Get boolean value page
1:6abdd97:    */
1:6abdd97:   public byte[] getBooleanPage() {
1:6abdd97:     return getBytePage();
1:6abdd97:   }
1:6abdd97: 
1:6abdd97:   /**
1:7359601:    * Get int value page
1:7359601:    */
1:7359601:   public abstract int[] getIntPage();
1:7359601: 
1:7359601:   /**
1:7359601:    * Get long value page
1:7359601:    */
1:7359601:   public abstract long[] getLongPage();
1:7359601: 
1:7359601:   /**
1:7359601:    * Get float value page
1:7359601:    */
1:7359601:   public abstract float[] getFloatPage();
1:7359601: 
1:7359601:   /**
1:7359601:    * Get double value page
1:7359601:    */
1:7359601:   public abstract double[] getDoublePage();
1:7359601: 
1:7359601:   /**
1:7359601:    * Get variable length page data
1:7359601:    */
1:7359601:   public abstract byte[][] getByteArrayPage();
1:7359601: 
1:7359601:   /**
1:7359601:    * For variable length page, get the flattened data
1:7359601:    */
1:8c1ddbf:   public abstract byte[] getLVFlattenedBytePage() throws IOException;
1:7359601: 
1:7359601:   /**
1:6297ea0:    * For complex type columns
1:6297ea0:    * @return
1:6297ea0:    * @throws IOException
1:6297ea0:    */
1:6297ea0:   public abstract byte[] getComplexChildrenLVFlattenedBytePage() throws IOException;
1:6297ea0: 
1:6297ea0:   /**
1:6297ea0:    * For complex type columns
1:6297ea0:    * @return
1:6297ea0:    * @throws IOException
1:6297ea0:    */
1:6297ea0:   public abstract byte[] getComplexParentFlattenedBytePage() throws IOException;
1:6297ea0: 
1:6297ea0:   /**
1:9e064ee:    * For decimals
1:edda248:    */
1:9e064ee:   public abstract byte[] getDecimalPage();
1:edda248: 
1:edda248:   /**
1:7359601:    * Encode the page data by codec (Visitor)
1:7359601:    */
1:e6a4f64:   public abstract void convertValue(ColumnPageValueConverter codec);
1:7359601: 
1:e710339:   public PageLevelDictionary getPageDictionary() {
1:e710339:     throw new UnsupportedOperationException("Operation Not Supported");
1:e710339:   }
1:8f08c4a: 
1:7359601:   /**
1:7359601:    * Compress page data using specified compressor
1:edda248:    */
1:eadfea7:   public byte[] compress(Compressor compressor) throws MemoryException, IOException {
1:8f08c4a:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:6abdd97:     if (dataType == DataTypes.BOOLEAN) {
1:6abdd97:       return compressor.compressByte(getBooleanPage());
1:6abdd97:     } else if (dataType == DataTypes.BYTE) {
1:956833e:       return compressor.compressByte(getBytePage());
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       return compressor.compressShort(getShortPage());
1:956833e:     } else if (dataType == DataTypes.SHORT_INT) {
1:956833e:       return compressor.compressByte(getShortIntPage());
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       return compressor.compressInt(getIntPage());
1:956833e:     } else if (dataType == DataTypes.LONG) {
1:956833e:       return compressor.compressLong(getLongPage());
1:956833e:     } else if (dataType == DataTypes.FLOAT) {
1:956833e:       return compressor.compressFloat(getFloatPage());
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       return compressor.compressDouble(getDoublePage());
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       return compressor.compressByte(getDecimalPage());
1:6297ea0:     } else if (dataType == DataTypes.BYTE_ARRAY
1:8f08c4a:         && columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.COMPLEX_PRIMITIVE) {
1:6297ea0:       return compressor.compressByte(getComplexChildrenLVFlattenedBytePage());
1:8f08c4a:     } else if (dataType == DataTypes.BYTE_ARRAY
1:8f08c4a:         && (columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.COMPLEX_STRUCT
1:8f08c4a:         || columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.COMPLEX_ARRAY
1:8f08c4a:         || columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.PLAIN_LONG_VALUE
1:8f08c4a:         || columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.PLAIN_VALUE)) {
1:6297ea0:       return compressor.compressByte(getComplexParentFlattenedBytePage());
1:956833e:     } else if (dataType == DataTypes.BYTE_ARRAY) {
1:956833e:       return compressor.compressByte(getLVFlattenedBytePage());
1:956833e:     } else {
1:956833e:       throw new UnsupportedOperationException("unsupport compress column page: " + dataType);
1:7359601:     }
7:edda248:   }
1:edda248: 
1:edda248:   /**
1:e6a4f64:    * Decompress data and create a column page using the decompressed data,
1:e6a4f64:    * except for decimal page
1:edda248:    */
1:8c1ddbf:   public static ColumnPage decompress(ColumnPageEncoderMeta meta, byte[] compressedData,
1:43285bb:       int offset, int length, boolean isLVEncoded)
1:e6a4f64:       throws MemoryException {
1:8c1ddbf:     Compressor compressor = CompressorFactory.getInstance().getCompressor(meta.getCompressorName());
1:8c1ddbf:     TableSpec.ColumnSpec columnSpec = meta.getColumnSpec();
1:956833e:     DataType storeDataType = meta.getStoreDataType();
1:6abdd97:     if (storeDataType == DataTypes.BOOLEAN || storeDataType == DataTypes.BYTE) {
1:956833e:       byte[] byteData = compressor.unCompressByte(compressedData, offset, length);
1:8f08c4a:       return newBytePage(columnSpec, byteData, meta.getCompressorName());
1:956833e:     } else if (storeDataType == DataTypes.SHORT) {
1:956833e:       short[] shortData = compressor.unCompressShort(compressedData, offset, length);
1:8f08c4a:       return newShortPage(columnSpec, shortData, meta.getCompressorName());
1:956833e:     } else if (storeDataType == DataTypes.SHORT_INT) {
1:956833e:       byte[] shortIntData = compressor.unCompressByte(compressedData, offset, length);
1:8f08c4a:       return newShortIntPage(columnSpec, shortIntData, meta.getCompressorName());
1:956833e:     } else if (storeDataType == DataTypes.INT) {
1:956833e:       int[] intData = compressor.unCompressInt(compressedData, offset, length);
1:8f08c4a:       return newIntPage(columnSpec, intData, meta.getCompressorName());
1:956833e:     } else if (storeDataType == DataTypes.LONG) {
1:956833e:       long[] longData = compressor.unCompressLong(compressedData, offset, length);
1:8f08c4a:       return newLongPage(columnSpec, longData, meta.getCompressorName());
1:956833e:     } else if (storeDataType == DataTypes.FLOAT) {
1:956833e:       float[] floatData = compressor.unCompressFloat(compressedData, offset, length);
1:8f08c4a:       return newFloatPage(columnSpec, floatData, meta.getCompressorName());
1:956833e:     } else if (storeDataType == DataTypes.DOUBLE) {
1:956833e:       double[] doubleData = compressor.unCompressDouble(compressedData, offset, length);
1:8f08c4a:       return newDoublePage(columnSpec, doubleData, meta.getCompressorName());
1:43285bb:     } else if (!isLVEncoded && storeDataType == DataTypes.BYTE_ARRAY && (
1:e710339:         columnSpec.getColumnType() == ColumnType.COMPLEX_PRIMITIVE
1:e710339:             || columnSpec.getColumnType() == ColumnType.PLAIN_VALUE)) {
1:6297ea0:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
1:6297ea0:       return newComplexLVBytesPage(columnSpec, lvVarBytes,
1:8f08c4a:           CarbonCommonConstants.SHORT_SIZE_IN_BYTE, meta.getCompressorName());
1:43285bb:     } else if (isLVEncoded && storeDataType == DataTypes.BYTE_ARRAY &&
1:43285bb:         columnSpec.getColumnType() == ColumnType.COMPLEX_PRIMITIVE) {
1:43285bb:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
1:8f08c4a:       return newFixedByteArrayPage(columnSpec, lvVarBytes, 3, meta.getCompressorName());
2:6297ea0:     } else if (storeDataType == DataTypes.BYTE_ARRAY
1:6297ea0:         && columnSpec.getColumnType() == ColumnType.COMPLEX_STRUCT) {
1:6297ea0:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
1:6297ea0:       return newFixedByteArrayPage(columnSpec, lvVarBytes,
1:8f08c4a:           CarbonCommonConstants.SHORT_SIZE_IN_BYTE, meta.getCompressorName());
1:6297ea0:     } else if (storeDataType == DataTypes.BYTE_ARRAY
1:6297ea0:         && columnSpec.getColumnType() == ColumnType.COMPLEX_ARRAY) {
1:6297ea0:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
1:8f08c4a:       return newFixedByteArrayPage(columnSpec, lvVarBytes,
1:8f08c4a:           CarbonCommonConstants.LONG_SIZE_IN_BYTE, meta.getCompressorName());
1:e710339:     } else if (storeDataType == DataTypes.BYTE_ARRAY
1:e710339:         && columnSpec.getColumnType() == ColumnType.PLAIN_LONG_VALUE) {
1:e710339:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
1:8f08c4a:       return newLVBytesPage(columnSpec, lvVarBytes,
1:8f08c4a:           CarbonCommonConstants.INT_SIZE_IN_BYTE, meta.getCompressorName());
1:956833e:     } else if (storeDataType == DataTypes.BYTE_ARRAY) {
1:956833e:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
1:8f08c4a:       return newLVBytesPage(columnSpec, lvVarBytes,
1:8f08c4a:           CarbonCommonConstants.INT_SIZE_IN_BYTE, meta.getCompressorName());
1:956833e:     } else {
1:6297ea0:       throw new UnsupportedOperationException(
1:6297ea0:           "unsupport uncompress column page: " + meta.getStoreDataType());
1:edda248:     }
1:edda248:   }
1:edda248: 
1:e6a4f64:   /**
1:6f20437:    * Decompress data and create a decimal column page using the decompressed data
1:e6a4f64:    */
1:8c1ddbf:   public static ColumnPage decompressDecimalPage(ColumnPageEncoderMeta meta, byte[] compressedData,
1:8c1ddbf:       int offset, int length) throws MemoryException {
1:8c1ddbf:     Compressor compressor = CompressorFactory.getInstance().getCompressor(meta.getCompressorName());
1:8c1ddbf:     TableSpec.ColumnSpec columnSpec = meta.getColumnSpec();
1:6f20437:     ColumnPage decimalPage = null;
1:956833e:     DataType storeDataType = meta.getStoreDataType();
1:956833e:     if (storeDataType == DataTypes.BYTE) {
1:956833e:       byte[] byteData = compressor.unCompressByte(compressedData, offset, length);
1:8f08c4a:       decimalPage = createDecimalPage(meta, byteData.length);
1:956833e:       decimalPage.setBytePage(byteData);
1:956833e:       return decimalPage;
1:956833e:     } else if (storeDataType == DataTypes.SHORT) {
1:956833e:       short[] shortData = compressor.unCompressShort(compressedData, offset, length);
1:8f08c4a:       decimalPage = createDecimalPage(meta, shortData.length);
1:956833e:       decimalPage.setShortPage(shortData);
1:956833e:       return decimalPage;
1:956833e:     } else if (storeDataType == DataTypes.SHORT_INT) {
1:956833e:       byte[] shortIntData = compressor.unCompressByte(compressedData, offset, length);
1:8f08c4a:       decimalPage = createDecimalPage(meta, shortIntData.length);
1:956833e:       decimalPage.setShortIntPage(shortIntData);
1:956833e:       return decimalPage;
1:956833e:     }  else if (storeDataType == DataTypes.INT) {
1:956833e:       int[] intData = compressor.unCompressInt(compressedData, offset, length);
1:8f08c4a:       decimalPage = createDecimalPage(meta, intData.length);
1:956833e:       decimalPage.setIntPage(intData);
1:956833e:       return decimalPage;
1:956833e:     } else if (storeDataType == DataTypes.LONG) {
1:956833e:       long[] longData = compressor.unCompressLong(compressedData, offset, length);
1:8f08c4a:       decimalPage = createDecimalPage(meta, longData.length);
1:956833e:       decimalPage.setLongPage(longData);
1:956833e:       return decimalPage;
1:956833e:     } else {
1:956833e:       byte[] lvEncodedBytes = compressor.unCompressByte(compressedData, offset, length);
1:8f08c4a:       return newDecimalPage(columnSpec, lvEncodedBytes, meta.getCompressorName());
1:e6a4f64:     }
1:6f20437:   }
1:e6a4f64: 
1:e6a4f64:   public BitSet getNullBits() {
1:e6a4f64:     return nullBitSet;
1:e6a4f64:   }
1:e6a4f64: 
1:e6a4f64:   public void setNullBits(BitSet nullBitSet) {
1:e6a4f64:     this.nullBitSet = nullBitSet;
1:e6a4f64:   }
1:8c1ddbf: 
1:8c1ddbf:   public TableSpec.ColumnSpec getColumnSpec() {
1:8f08c4a:     return columnPageEncoderMeta.getColumnSpec();
1:8c1ddbf:   }
1:e710339: 
1:e710339:   public boolean isLocalDictGeneratedPage() {
1:e710339:     return false;
1:e710339:   }
1:e710339: 
1:e710339:   public void disableLocalDictEncoding() {
1:e710339:     throw new UnsupportedOperationException("Operation not supported");
1:e710339:   }
1:e710339: 
1:e710339:   public PageLevelDictionary getColumnPageDictionary() {
1:e710339:     throw new UnsupportedOperationException("Operation not supported");
1:e710339:   }
1:8925947: 
1:8925947:   public int getActualRowCount() {
1:8925947:     throw new UnsupportedOperationException("Operation not supported");
1:8925947:   }
1:8f08c4a: 
1:8f08c4a:   public String getColumnCompressorName() {
1:8f08c4a:     return columnPageEncoderMeta.getCompressorName();
1:8f08c4a:   }
1:8f08c4a: 
1:8f08c4a:   public ColumnPageEncoderMeta getColumnPageEncoderMeta() {
1:8f08c4a:     return columnPageEncoderMeta;
1:8f08c4a:   }
1:edda248: }
============================================================================
author:xuchuanyin
-------------------------------------------------------------------------------
commit:8f08c4a
/////////////////////////////////////////////////////////////////////////
1:   protected ColumnPageEncoderMeta columnPageEncoderMeta;
/////////////////////////////////////////////////////////////////////////
1:   protected ColumnPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize) {
1:     this.columnPageEncoderMeta = columnPageEncoderMeta;
1:     return columnPageEncoderMeta.getStoreDataType();
/////////////////////////////////////////////////////////////////////////
1:   private static ColumnPage createDecimalPage(ColumnPageEncoderMeta columnPageEncoderMeta,
1:         return new UnsafeDecimalColumnPage(columnPageEncoderMeta, pageSize);
1:       return new SafeDecimalColumnPage(columnPageEncoderMeta, pageSize);
1:   private static ColumnPage createVarLengthPage(ColumnPageEncoderMeta columnPageEncoderMeta,
1:         return new UnsafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
1:       return new SafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
1:   private static ColumnPage createFixLengthPage(
1:       ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize) {
1:         return new UnsafeFixLengthColumnPage(columnPageEncoderMeta, pageSize);
1:       return new SafeFixLengthColumnPage(columnPageEncoderMeta, pageSize);
1:   private static ColumnPage createFixLengthByteArrayPage(
1:       ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize, int eachValueSize) {
1:         return new UnsafeFixLengthColumnPage(columnPageEncoderMeta, pageSize, eachValueSize);
1:       return new SafeFixLengthColumnPage(columnPageEncoderMeta, pageSize);
1:   private static ColumnPage createPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize) {
1:     if (DataTypes.isDecimal(columnPageEncoderMeta.getStoreDataType())) {
1:       return createDecimalPage(columnPageEncoderMeta, pageSize);
1:     } else if (columnPageEncoderMeta.getStoreDataType().equals(BYTE_ARRAY)) {
1:       return createVarLengthPage(columnPageEncoderMeta, pageSize);
1:       return createFixLengthPage(columnPageEncoderMeta, pageSize);
1:   public static ColumnPage newDecimalPage(ColumnPageEncoderMeta columnPageEncoderMeta,
1:       int pageSize) throws MemoryException {
1:     return newPage(columnPageEncoderMeta, pageSize);
1:   public static ColumnPage newLocalDictPage(ColumnPageEncoderMeta columnPageEncoderMeta,
1:     ColumnPage actualPage;
1:     ColumnPage encodedPage;
1:       actualPage = new UnsafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
1:       encodedPage = new UnsafeFixLengthColumnPage(
1:           new ColumnPageEncoderMeta(columnPageEncoderMeta.getColumnSpec(), DataTypes.BYTE_ARRAY,
1:               columnPageEncoderMeta.getCompressorName()),
1:           pageSize,
1:           CarbonCommonConstants.LOCAL_DICT_ENCODED_BYTEARRAY_SIZE);
1:       actualPage = new SafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
1:       encodedPage = new SafeFixLengthColumnPage(
1:           new ColumnPageEncoderMeta(columnPageEncoderMeta.getColumnSpec(), DataTypes.BYTE_ARRAY,
1:               columnPageEncoderMeta.getCompressorName()),
1:           pageSize);
1:     return new LocalDictColumnPage(actualPage, encodedPage, localDictionaryGenerator,
1:         isComplexTypePrimitive, isDecoderBasedFallBackEnabled);
1:   public static ColumnPage newPage(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize)
1:       throws MemoryException {
1:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:     TableSpec.ColumnSpec columnSpec = columnPageEncoderMeta.getColumnSpec();
1:     String compressorName = columnPageEncoderMeta.getCompressorName();
1:         instance = new UnsafeFixLengthColumnPage(
1:             new ColumnPageEncoderMeta(columnSpec, BYTE, compressorName), pageSize);
/////////////////////////////////////////////////////////////////////////
1:         instance = new UnsafeFixLengthColumnPage(
1:             new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), pageSize);
1:         instance = new UnsafeFixLengthColumnPage(
1:             new ColumnPageEncoderMeta(columnSpec, DataTypes.LONG, compressorName), pageSize);
1:         instance = new UnsafeDecimalColumnPage(
1:             new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), pageSize);
1:         instance = new UnsafeVarLengthColumnPage(
1:             new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), pageSize);
1:         instance = newBytePage(columnSpec, new byte[pageSize], compressorName);
1:         instance = newShortPage(columnSpec, new short[pageSize], compressorName);
1:         instance = newShortIntPage(columnSpec, new byte[pageSize * 3], compressorName);
1:         instance = newIntPage(columnSpec, new int[pageSize], compressorName);
1:         instance = newLongPage(columnSpec, new long[pageSize], compressorName);
1:         instance = newFloatPage(columnSpec, new float[pageSize], compressorName);
1:         instance = newDoublePage(columnSpec, new double[pageSize], compressorName);
1:         instance = newDecimalPage(columnSpec, new byte[pageSize][], compressorName);
1:         instance = new SafeVarLengthColumnPage(columnPageEncoderMeta, pageSize);
/////////////////////////////////////////////////////////////////////////
1:   public static ColumnPage wrapByteArrayPage(TableSpec.ColumnSpec columnSpec, byte[][] byteArray,
1:       String compressorName) {
1:     ColumnPage columnPage = createPage(
1:         new ColumnPageEncoderMeta(columnSpec, BYTE_ARRAY, compressorName), byteArray.length);
1:   private static ColumnPage newBytePage(TableSpec.ColumnSpec columnSpec, byte[] byteData,
1:       String compressorName) {
1:     ColumnPage columnPage = createPage(
1:         new ColumnPageEncoderMeta(columnSpec, BYTE, compressorName), byteData.length);
1:   private static ColumnPage newShortPage(TableSpec.ColumnSpec columnSpec, short[] shortData,
1:       String compressorName) {
1:     ColumnPage columnPage = createPage(
1:         new ColumnPageEncoderMeta(columnSpec, SHORT, compressorName), shortData.length);
1:   private static ColumnPage newShortIntPage(TableSpec.ColumnSpec columnSpec, byte[] shortIntData,
1:       String compressorName) {
1:     ColumnPage columnPage = createPage(
1:         new ColumnPageEncoderMeta(columnSpec, SHORT_INT, compressorName), shortIntData.length / 3);
1:   private static ColumnPage newIntPage(TableSpec.ColumnSpec columnSpec, int[] intData,
1:       String compressorName) {
1:     ColumnPage columnPage = createPage(
1:         new ColumnPageEncoderMeta(columnSpec, INT, compressorName), intData.length);
1:   private static ColumnPage newLongPage(TableSpec.ColumnSpec columnSpec, long[] longData,
1:       String compressorName) {
1:     ColumnPage columnPage = createPage(
1:         new ColumnPageEncoderMeta(columnSpec, LONG, compressorName), longData.length);
1:   private static ColumnPage newFloatPage(TableSpec.ColumnSpec columnSpec, float[] floatData,
1:       String compressorName) {
1:     ColumnPage columnPage = createPage(
1:         new ColumnPageEncoderMeta(columnSpec, FLOAT, compressorName), floatData.length);
1:   private static ColumnPage newDoublePage(TableSpec.ColumnSpec columnSpec, double[] doubleData,
1:       String compressorName) {
1:     ColumnPage columnPage = createPage(
1:         new ColumnPageEncoderMeta(columnSpec, DOUBLE, compressorName), doubleData.length);
1:   private static ColumnPage newDecimalPage(TableSpec.ColumnSpec columnSpec, byte[][] byteArray,
1:       String compressorName) {
1:     ColumnPage columnPage = createPage(
1:         new ColumnPageEncoderMeta(columnSpec, columnSpec.getSchemaDataType(), compressorName),
1:         byteArray.length);
1:       byte[] lvEncodedByteArray, String compressorName) throws MemoryException {
1:     return VarLengthColumnPageBase.newDecimalColumnPage(
1:         columnSpec, lvEncodedByteArray, compressorName);
1:       byte[] lvEncodedByteArray, int lvLength, String compressorName) throws MemoryException {
1:     return VarLengthColumnPageBase.newLVBytesColumnPage(
1:         columnSpec, lvEncodedByteArray, lvLength, compressorName);
1:       byte[] lvEncodedByteArray, int lvLength, String compressorName) throws MemoryException {
1:     return VarLengthColumnPageBase.newComplexLVBytesColumnPage(
1:         columnSpec, lvEncodedByteArray, lvLength, compressorName);
1:       byte[] lvEncodedByteArray, int eachValueSize, String compressorName) throws MemoryException {
1:     ColumnPage fixLengthByteArrayPage = createFixLengthByteArrayPage(
1:         new ColumnPageEncoderMeta(columnSpec, columnSpec.getSchemaDataType(), compressorName),
1:         pageSize, eachValueSize);
/////////////////////////////////////////////////////////////////////////
1:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:       if (columnPageEncoderMeta.getColumnSpec().getSchemaDataType() == DataTypes.BOOLEAN) {
/////////////////////////////////////////////////////////////////////////
1:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:       if (columnPageEncoderMeta.getColumnSpec().getSchemaDataType() == DataTypes.BOOLEAN) {
/////////////////////////////////////////////////////////////////////////
1:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
/////////////////////////////////////////////////////////////////////////
1:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
1:       if (columnPageEncoderMeta.getColumnSpec().getSchemaDataType() == DataTypes.BOOLEAN) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     DataType dataType = columnPageEncoderMeta.getStoreDataType();
/////////////////////////////////////////////////////////////////////////
1:         && columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.COMPLEX_PRIMITIVE) {
1:     } else if (dataType == DataTypes.BYTE_ARRAY
1:         && (columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.COMPLEX_STRUCT
1:         || columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.COMPLEX_ARRAY
1:         || columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.PLAIN_LONG_VALUE
1:         || columnPageEncoderMeta.getColumnSpec().getColumnType() == ColumnType.PLAIN_VALUE)) {
/////////////////////////////////////////////////////////////////////////
1:       return newBytePage(columnSpec, byteData, meta.getCompressorName());
1:       return newShortPage(columnSpec, shortData, meta.getCompressorName());
1:       return newShortIntPage(columnSpec, shortIntData, meta.getCompressorName());
1:       return newIntPage(columnSpec, intData, meta.getCompressorName());
1:       return newLongPage(columnSpec, longData, meta.getCompressorName());
1:       return newFloatPage(columnSpec, floatData, meta.getCompressorName());
1:       return newDoublePage(columnSpec, doubleData, meta.getCompressorName());
1:           CarbonCommonConstants.SHORT_SIZE_IN_BYTE, meta.getCompressorName());
1:       return newFixedByteArrayPage(columnSpec, lvVarBytes, 3, meta.getCompressorName());
1:           CarbonCommonConstants.SHORT_SIZE_IN_BYTE, meta.getCompressorName());
1:       return newFixedByteArrayPage(columnSpec, lvVarBytes,
1:           CarbonCommonConstants.LONG_SIZE_IN_BYTE, meta.getCompressorName());
1:       return newLVBytesPage(columnSpec, lvVarBytes,
1:           CarbonCommonConstants.INT_SIZE_IN_BYTE, meta.getCompressorName());
1:       return newLVBytesPage(columnSpec, lvVarBytes,
1:           CarbonCommonConstants.INT_SIZE_IN_BYTE, meta.getCompressorName());
/////////////////////////////////////////////////////////////////////////
1:       decimalPage = createDecimalPage(meta, byteData.length);
1:       decimalPage = createDecimalPage(meta, shortData.length);
1:       decimalPage = createDecimalPage(meta, shortIntData.length);
1:       decimalPage = createDecimalPage(meta, intData.length);
1:       decimalPage = createDecimalPage(meta, longData.length);
1:       return newDecimalPage(columnSpec, lvEncodedBytes, meta.getCompressorName());
/////////////////////////////////////////////////////////////////////////
1:     return columnPageEncoderMeta.getColumnSpec();
/////////////////////////////////////////////////////////////////////////
1: 
1:   public String getColumnCompressorName() {
1:     return columnPageEncoderMeta.getCompressorName();
1:   }
1: 
1:   public ColumnPageEncoderMeta getColumnPageEncoderMeta() {
1:     return columnPageEncoderMeta;
1:   }
commit:dc53dee
/////////////////////////////////////////////////////////////////////////
1:       } else if (dataType == DataTypes.STRING
1:           || dataType == DataTypes.BYTE_ARRAY
1:           || dataType == DataTypes.VARCHAR) {
/////////////////////////////////////////////////////////////////////////
1:       } else if (dataType == DataTypes.STRING
1:           || dataType == DataTypes.BYTE_ARRAY
1:           || dataType == DataTypes.VARCHAR) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (dataType == DataTypes.STRING
1:         || dataType == DataTypes.BYTE_ARRAY
1:         || dataType == DataTypes.VARCHAR) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (dataType == DataTypes.STRING
1:         || dataType == DataTypes.BYTE_ARRAY
1:         || dataType == DataTypes.VARCHAR) {
commit:ecd6c0c
/////////////////////////////////////////////////////////////////////////
1:    * get value at rowId, note that the value of string&bytes is LV format
1:    * @param rowId rowId
1:    * @return value
1:    */
1:   public Object getData(int rowId) {
1:     if (nullBitSet.get(rowId)) {
1:       return getNull(rowId);
1:     }
1:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:       byte value = getByte(rowId);
0:       if (columnSpec.getSchemaDataType() == DataTypes.BOOLEAN) {
1:         return BooleanConvert.byte2Boolean(value);
1:       }
1:       return value;
1:     } else if (dataType == DataTypes.SHORT) {
1:       return getShort(rowId);
1:     } else if (dataType == DataTypes.INT) {
1:       return getInt(rowId);
1:     } else if (dataType == DataTypes.LONG) {
1:       return getLong(rowId);
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       return getDouble(rowId);
1:     } else if (DataTypes.isDecimal(dataType)) {
1:       return getDecimal(rowId);
0:     } else if (dataType == DataTypes.STRING || dataType == DataTypes.BYTE_ARRAY) {
1:       return getBytes(rowId);
1:     } else {
1:       throw new RuntimeException("unsupported data type: " + dataType);
1:     }
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:    * Get null at rowId
1:    */
1:   private Object getNull(int rowId) {
1:     Object result;
1:     if (dataType == DataTypes.BOOLEAN) {
1:       result = getBoolean(rowId);
1:     } else if (dataType == DataTypes.BYTE) {
1:       result = getByte(rowId);
1:     } else if (dataType == DataTypes.SHORT) {
1:       result = getShort(rowId);
1:     } else if (dataType == DataTypes.INT) {
1:       result = getInt(rowId);
1:     } else if (dataType == DataTypes.LONG) {
1:       result = getLong(rowId);
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       result = getDouble(rowId);
1:     } else if (DataTypes.isDecimal(dataType)) {
1:       result = getDecimal(rowId);
1:     } else {
1:       throw new IllegalArgumentException("unsupported data type: " + dataType);
1:     }
1:     return result;
1:   }
1: 
1:   /**
author:akashrn5
-------------------------------------------------------------------------------
commit:2ccdbb7
/////////////////////////////////////////////////////////////////////////
1:     boolean isDecoderBasedFallBackEnabled = Boolean.parseBoolean(CarbonProperties.getInstance()
1:         .getProperty(CarbonCommonConstants.LOCAL_DICTIONARY_DECODER_BASED_FALLBACK,
1:             CarbonCommonConstants.LOCAL_DICTIONARY_DECODER_BASED_FALLBACK_DEFAULT));
0:               CarbonCommonConstants.LOCAL_DICT_ENCODED_BYTEARRAY_SIZE), localDictionaryGenerator,
0:           isComplexTypePrimitive, isDecoderBasedFallBackEnabled);
0:           localDictionaryGenerator, isComplexTypePrimitive, isDecoderBasedFallBackEnabled);
author:kumarvishal09
-------------------------------------------------------------------------------
commit:43285bb
/////////////////////////////////////////////////////////////////////////
0:       return new SafeFixLengthColumnPage(columnSpec, dataType, pageSize);
/////////////////////////////////////////////////////////////////////////
0:           new UnsafeFixLengthColumnPage(columnSpec, DataTypes.BYTE_ARRAY, pageSize,
0:               CarbonCommonConstants.LOCAL_DICT_ENCODED_BYTEARRAY_SIZE),
0:           new SafeFixLengthColumnPage(columnSpec, DataTypes.BYTE_ARRAY, pageSize),
/////////////////////////////////////////////////////////////////////////
1:       int offset, int length, boolean isLVEncoded)
/////////////////////////////////////////////////////////////////////////
1:     } else if (!isLVEncoded && storeDataType == DataTypes.BYTE_ARRAY && (
1:     } else if (isLVEncoded && storeDataType == DataTypes.BYTE_ARRAY &&
1:         columnSpec.getColumnType() == ColumnType.COMPLEX_PRIMITIVE) {
1:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
0:       return newFixedByteArrayPage(columnSpec, lvVarBytes, 3);
commit:8925947
/////////////////////////////////////////////////////////////////////////
1:   protected int pageSize;
/////////////////////////////////////////////////////////////////////////
1: 
1:   public int getActualRowCount() {
1:     throw new UnsupportedOperationException("Operation not supported");
1:   }
commit:3a4b881
/////////////////////////////////////////////////////////////////////////
1:       int pageSize, LocalDictionaryGenerator localDictionaryGenerator,
1:       boolean isComplexTypePrimitive) throws MemoryException {
0:           localDictionaryGenerator, isComplexTypePrimitive);
0:           localDictionaryGenerator, isComplexTypePrimitive);
commit:e710339
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.localdictionary.PageLevelDictionary;
1: import org.apache.carbondata.core.localdictionary.generator.LocalDictionaryGenerator;
/////////////////////////////////////////////////////////////////////////
1:   protected ColumnPageStatsCollector statsCollector;
/////////////////////////////////////////////////////////////////////////
1:     return statsCollector.getPageStats();
/////////////////////////////////////////////////////////////////////////
0:   public static ColumnPage newLocalDictPage(TableSpec.ColumnSpec columnSpec, DataType dataType,
0:       int pageSize, LocalDictionaryGenerator localDictionaryGenerator) throws MemoryException {
1:     if (unsafe) {
0:       return new LocalDictColumnPage(new UnsafeVarLengthColumnPage(columnSpec, dataType, pageSize),
0:           new UnsafeVarLengthColumnPage(columnSpec, DataTypes.BYTE_ARRAY, pageSize),
0:           localDictionaryGenerator);
1:     } else {
0:       return new LocalDictColumnPage(new SafeVarLengthColumnPage(columnSpec, dataType, pageSize),
0:           new SafeVarLengthColumnPage(columnSpec, DataTypes.BYTE_ARRAY, pageSize),
0:           localDictionaryGenerator);
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   public PageLevelDictionary getPageDictionary() {
1:     throw new UnsupportedOperationException("Operation Not Supported");
1:   }
/////////////////////////////////////////////////////////////////////////
0:             || columnSpec.getColumnType() == ColumnType.COMPLEX_ARRAY
0:             || columnSpec.getColumnType() == ColumnType.PLAIN_LONG_VALUE
1:             || columnSpec.getColumnType() == ColumnType.PLAIN_VALUE)) {
/////////////////////////////////////////////////////////////////////////
0:     } else if (storeDataType == DataTypes.BYTE_ARRAY && (
1:         columnSpec.getColumnType() == ColumnType.COMPLEX_PRIMITIVE
0:             || columnSpec.getColumnType() == ColumnType.PLAIN_VALUE)) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (storeDataType == DataTypes.BYTE_ARRAY
1:         && columnSpec.getColumnType() == ColumnType.PLAIN_LONG_VALUE) {
1:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
0:       return newLVBytesPage(columnSpec, lvVarBytes, CarbonCommonConstants.INT_SIZE_IN_BYTE);
/////////////////////////////////////////////////////////////////////////
1: 
1:   public boolean isLocalDictGeneratedPage() {
1:     return false;
1:   }
1: 
1:   public void disableLocalDictEncoding() {
1:     throw new UnsupportedOperationException("Operation not supported");
1:   }
1: 
1:   public PageLevelDictionary getColumnPageDictionary() {
1:     throw new UnsupportedOperationException("Operation not supported");
1:   }
commit:6297ea0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.ColumnType;
/////////////////////////////////////////////////////////////////////////
0:   private static ColumnPage createFixLengthByteArrayPage(TableSpec.ColumnSpec columnSpec,
0:       DataType dataType, int pageSize, int eachValueSize) {
1:     if (unsafe) {
1:       try {
0:         return new UnsafeFixLengthColumnPage(columnSpec, dataType, pageSize, eachValueSize);
1:       } catch (MemoryException e) {
1:         throw new RuntimeException(e);
1:       }
1:     } else {
0:       return new SafeFixLengthColumnPage(columnSpec, dataType, pageSize, eachValueSize);
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:       byte[] lvEncodedByteArray, int lvLength) throws MemoryException {
0:     return VarLengthColumnPageBase.newLVBytesColumnPage(columnSpec, lvEncodedByteArray, lvLength);
1:   }
1: 
1:   private static ColumnPage newComplexLVBytesPage(TableSpec.ColumnSpec columnSpec,
0:       byte[] lvEncodedByteArray, int lvLength) throws MemoryException {
0:     return VarLengthColumnPageBase
0:         .newComplexLVBytesColumnPage(columnSpec, lvEncodedByteArray, lvLength);
1:   }
1: 
1:   private static ColumnPage newFixedByteArrayPage(TableSpec.ColumnSpec columnSpec,
0:       byte[] lvEncodedByteArray, int eachValueSize) throws MemoryException {
1:     int pageSize = lvEncodedByteArray.length / eachValueSize;
0:     ColumnPage fixLengthByteArrayPage =
0:         createFixLengthByteArrayPage(columnSpec, columnSpec.getSchemaDataType(), pageSize,
0:             eachValueSize);
1:     byte[] data = null;
1:     int offset = 0;
1:     for (int i = 0; i < pageSize; i++) {
1:       data = new byte[eachValueSize];
1:       System.arraycopy(lvEncodedByteArray, offset, data, 0, eachValueSize);
1:       fixLengthByteArrayPage.putBytes(i, data);
1:       offset += eachValueSize;
1:     }
1:     return fixLengthByteArrayPage;
/////////////////////////////////////////////////////////////////////////
1:    * For complex type columns
1:    * @return
1:    * @throws IOException
1:    */
1:   public abstract byte[] getComplexChildrenLVFlattenedBytePage() throws IOException;
1: 
1:   /**
1:    * For complex type columns
1:    * @return
1:    * @throws IOException
1:    */
1:   public abstract byte[] getComplexParentFlattenedBytePage() throws IOException;
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:     } else if (dataType == DataTypes.BYTE_ARRAY
0:         && columnSpec.getColumnType() == ColumnType.COMPLEX_PRIMITIVE) {
1:       return compressor.compressByte(getComplexChildrenLVFlattenedBytePage());
0:     } else if (dataType == DataTypes.BYTE_ARRAY && (
0:         columnSpec.getColumnType() == ColumnType.COMPLEX_STRUCT
0:             || columnSpec.getColumnType() == ColumnType.COMPLEX_ARRAY)) {
1:       return compressor.compressByte(getComplexParentFlattenedBytePage());
/////////////////////////////////////////////////////////////////////////
1:     } else if (storeDataType == DataTypes.BYTE_ARRAY
0:         && columnSpec.getColumnType() == ColumnType.COMPLEX_PRIMITIVE) {
1:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
1:       return newComplexLVBytesPage(columnSpec, lvVarBytes,
0:           CarbonCommonConstants.SHORT_SIZE_IN_BYTE);
1:     } else if (storeDataType == DataTypes.BYTE_ARRAY
1:         && columnSpec.getColumnType() == ColumnType.COMPLEX_STRUCT) {
1:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
1:       return newFixedByteArrayPage(columnSpec, lvVarBytes,
0:           CarbonCommonConstants.SHORT_SIZE_IN_BYTE);
1:     } else if (storeDataType == DataTypes.BYTE_ARRAY
1:         && columnSpec.getColumnType() == ColumnType.COMPLEX_ARRAY) {
1:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
0:       return newFixedByteArrayPage(columnSpec, lvVarBytes, CarbonCommonConstants.LONG_SIZE_IN_BYTE);
0:       return newLVBytesPage(columnSpec, lvVarBytes, CarbonCommonConstants.INT_SIZE_IN_BYTE);
1:       throw new UnsupportedOperationException(
1:           "unsupport uncompress column page: " + meta.getStoreDataType());
author:Manhua
-------------------------------------------------------------------------------
commit:7551cc6
/////////////////////////////////////////////////////////////////////////
0:       if (columnSpec.getSchemaDataType() == DataTypes.BOOLEAN) {
1:         result = BooleanConvert.byte2Boolean((byte)result);
1:       }
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:438b442
/////////////////////////////////////////////////////////////////////////
1:   protected BitSet nullBitSet;
/////////////////////////////////////////////////////////////////////////
1:       } else if (dataType == DataTypes.TIMESTAMP) {
0:         instance = new UnsafeFixLengthColumnPage(columnSpec, DataTypes.LONG, pageSize);
/////////////////////////////////////////////////////////////////////////
1:       } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
/////////////////////////////////////////////////////////////////////////
1:   protected void putNull(int rowId) {
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:be600bc
/////////////////////////////////////////////////////////////////////////
1:       .getProperty(CarbonCommonConstants.ENABLE_UNSAFE_COLUMN_PAGE,
1:           CarbonCommonConstants.ENABLE_UNSAFE_COLUMN_PAGE_DEFAULT));
author:Jacky Li
-------------------------------------------------------------------------------
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:       } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:       } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
0:     ColumnPage columnPage =
0:         createPage(columnSpec, columnSpec.getSchemaDataType(), byteArray.length);
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1: import static org.apache.carbondata.core.metadata.datatype.DataTypes.BYTE;
1: import static org.apache.carbondata.core.metadata.datatype.DataTypes.BYTE_ARRAY;
0: import static org.apache.carbondata.core.metadata.datatype.DataTypes.DECIMAL;
1: import static org.apache.carbondata.core.metadata.datatype.DataTypes.DOUBLE;
1: import static org.apache.carbondata.core.metadata.datatype.DataTypes.FLOAT;
1: import static org.apache.carbondata.core.metadata.datatype.DataTypes.INT;
1: import static org.apache.carbondata.core.metadata.datatype.DataTypes.LONG;
1: import static org.apache.carbondata.core.metadata.datatype.DataTypes.SHORT;
1: import static org.apache.carbondata.core.metadata.datatype.DataTypes.SHORT_INT;
/////////////////////////////////////////////////////////////////////////
0:       if (dataType == DataTypes.BYTE ||
1:           dataType == DataTypes.SHORT ||
1:           dataType == DataTypes.SHORT_INT ||
1:           dataType == DataTypes.INT ||
1:           dataType == DataTypes.LONG ||
1:           dataType == DataTypes.FLOAT ||
1:           dataType == DataTypes.DOUBLE) {
0:         instance = new UnsafeFixLengthColumnPage(columnSpec, dataType, pageSize);
0:       } else if (dataType == DataTypes.DECIMAL) {
0:         instance = new UnsafeDecimalColumnPage(columnSpec, dataType, pageSize);
0:       } else if (dataType == DataTypes.STRING || dataType == DataTypes.BYTE_ARRAY) {
0:         instance = new UnsafeVarLengthColumnPage(columnSpec, dataType, pageSize);
1:       } else {
1:         throw new RuntimeException("Unsupported data dataType: " + dataType);
0:       if (dataType == DataTypes.BYTE) {
0:         instance = newBytePage(columnSpec, new byte[pageSize]);
1:       } else if (dataType == DataTypes.SHORT) {
0:         instance = newShortPage(columnSpec, new short[pageSize]);
1:       } else if (dataType == DataTypes.SHORT_INT) {
0:         instance = newShortIntPage(columnSpec, new byte[pageSize * 3]);
1:       } else if (dataType == DataTypes.INT) {
0:         instance = newIntPage(columnSpec, new int[pageSize]);
1:       } else if (dataType == DataTypes.LONG) {
0:         instance = newLongPage(columnSpec, new long[pageSize]);
1:       } else if (dataType == DataTypes.FLOAT) {
0:         instance = newFloatPage(columnSpec, new float[pageSize]);
1:       } else if (dataType == DataTypes.DOUBLE) {
0:         instance = newDoublePage(columnSpec, new double[pageSize]);
0:       } else if (dataType == DataTypes.DECIMAL) {
0:         instance = newDecimalPage(columnSpec, new byte[pageSize][]);
0:       } else if (dataType == DataTypes.STRING || dataType == DataTypes.BYTE_ARRAY) {
0:         instance = new SafeVarLengthColumnPage(columnSpec, dataType, pageSize);
1:       } else {
1:         throw new RuntimeException("Unsupported data dataType: " + dataType);
/////////////////////////////////////////////////////////////////////////
0:     if (dataType == DataTypes.BYTE) {
1:       putByte(rowId, (byte) value);
1:       statsCollector.update((byte) value);
1:     } else if (dataType == DataTypes.SHORT) {
1:       putShort(rowId, (short) value);
1:       statsCollector.update((short) value);
1:     } else if (dataType == DataTypes.INT) {
1:       putInt(rowId, (int) value);
1:       statsCollector.update((int) value);
1:     } else if (dataType == DataTypes.LONG) {
1:       putLong(rowId, (long) value);
1:       statsCollector.update((long) value);
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       putDouble(rowId, (double) value);
1:       statsCollector.update((double) value);
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       putDecimal(rowId, (BigDecimal) value);
1:       statsCollector.update((BigDecimal) value);
0:     } else if (dataType == DataTypes.STRING || dataType == DataTypes.BYTE_ARRAY) {
1:       putBytes(rowId, (byte[]) value);
1:       statsCollector.update((byte[]) value);
1:     } else {
1:       throw new RuntimeException("unsupported data type: " + dataType);
/////////////////////////////////////////////////////////////////////////
0:     if (dataType == DataTypes.BYTE) {
1:       putByte(rowId, (byte) 0);
1:     } else if (dataType == DataTypes.SHORT) {
1:       putShort(rowId, (short) 0);
1:     } else if (dataType == DataTypes.INT) {
1:       putInt(rowId, 0);
1:     } else if (dataType == DataTypes.LONG) {
1:       putLong(rowId, 0L);
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       putDouble(rowId, 0.0);
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       putDecimal(rowId, BigDecimal.ZERO);
1:     } else {
1:       throw new IllegalArgumentException("unsupported data type: " + dataType);
/////////////////////////////////////////////////////////////////////////
0:     if (dataType == DataTypes.BYTE) {
1:       return compressor.compressByte(getBytePage());
1:     } else if (dataType == DataTypes.SHORT) {
1:       return compressor.compressShort(getShortPage());
1:     } else if (dataType == DataTypes.SHORT_INT) {
1:       return compressor.compressByte(getShortIntPage());
1:     } else if (dataType == DataTypes.INT) {
1:       return compressor.compressInt(getIntPage());
0:     } else if (dataType == DataTypes.LONG) {
1:       return compressor.compressLong(getLongPage());
1:     } else if (dataType == DataTypes.FLOAT) {
1:       return compressor.compressFloat(getFloatPage());
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       return compressor.compressDouble(getDoublePage());
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       return compressor.compressByte(getDecimalPage());
1:     } else if (dataType == DataTypes.BYTE_ARRAY) {
1:       return compressor.compressByte(getLVFlattenedBytePage());
1:     } else {
1:       throw new UnsupportedOperationException("unsupport compress column page: " + dataType);
/////////////////////////////////////////////////////////////////////////
1:     DataType storeDataType = meta.getStoreDataType();
1:     if (storeDataType == DataTypes.BYTE) {
1:       byte[] byteData = compressor.unCompressByte(compressedData, offset, length);
0:       return newBytePage(columnSpec, byteData);
1:     } else if (storeDataType == DataTypes.SHORT) {
1:       short[] shortData = compressor.unCompressShort(compressedData, offset, length);
0:       return newShortPage(columnSpec, shortData);
1:     } else if (storeDataType == DataTypes.SHORT_INT) {
1:       byte[] shortIntData = compressor.unCompressByte(compressedData, offset, length);
0:       return newShortIntPage(columnSpec, shortIntData);
1:     } else if (storeDataType == DataTypes.INT) {
1:       int[] intData = compressor.unCompressInt(compressedData, offset, length);
0:       return newIntPage(columnSpec, intData);
1:     } else if (storeDataType == DataTypes.LONG) {
1:       long[] longData = compressor.unCompressLong(compressedData, offset, length);
0:       return newLongPage(columnSpec, longData);
1:     } else if (storeDataType == DataTypes.FLOAT) {
1:       float[] floatData = compressor.unCompressFloat(compressedData, offset, length);
0:       return newFloatPage(columnSpec, floatData);
1:     } else if (storeDataType == DataTypes.DOUBLE) {
1:       double[] doubleData = compressor.unCompressDouble(compressedData, offset, length);
0:       return newDoublePage(columnSpec, doubleData);
1:     } else if (storeDataType == DataTypes.BYTE_ARRAY) {
1:       byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
0:       return newLVBytesPage(columnSpec, lvVarBytes);
1:     } else {
0:       throw new UnsupportedOperationException("unsupport uncompress column page: " +
0:           meta.getStoreDataType());
/////////////////////////////////////////////////////////////////////////
1:     DataType storeDataType = meta.getStoreDataType();
0:     if (storeDataType == DataTypes.BYTE) {
1:       byte[] byteData = compressor.unCompressByte(compressedData, offset, length);
0:       decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), byteData.length);
1:       decimalPage.setBytePage(byteData);
1:       return decimalPage;
1:     } else if (storeDataType == DataTypes.SHORT) {
1:       short[] shortData = compressor.unCompressShort(compressedData, offset, length);
0:       decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), shortData.length);
1:       decimalPage.setShortPage(shortData);
1:       return decimalPage;
1:     } else if (storeDataType == DataTypes.SHORT_INT) {
1:       byte[] shortIntData = compressor.unCompressByte(compressedData, offset, length);
0:       decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), shortIntData.length);
1:       decimalPage.setShortIntPage(shortIntData);
1:       return decimalPage;
1:     }  else if (storeDataType == DataTypes.INT) {
1:       int[] intData = compressor.unCompressInt(compressedData, offset, length);
0:       decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), intData.length);
1:       decimalPage.setIntPage(intData);
1:       return decimalPage;
1:     } else if (storeDataType == DataTypes.LONG) {
1:       long[] longData = compressor.unCompressLong(compressedData, offset, length);
0:       decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), longData.length);
1:       decimalPage.setLongPage(longData);
1:       return decimalPage;
1:     } else {
1:       byte[] lvEncodedBytes = compressor.unCompressByte(compressedData, offset, length);
0:       return newDecimalPage(columnSpec, lvEncodedBytes);
commit:8c1ddbf
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datastore.ColumnType;
1: import org.apache.carbondata.core.datastore.TableSpec;
1: import org.apache.carbondata.core.datastore.compression.CompressorFactory;
1: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
/////////////////////////////////////////////////////////////////////////
1:   // number of row in this page
1: 
0:   // data type of the page storage
1: 
0:   // specification of this column
0:   private final TableSpec.ColumnSpec columnSpec;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Create a new column page with input data type and page size.
1:    */
0:   protected ColumnPage(TableSpec.ColumnSpec columnSpec, DataType dataType, int pageSize) {
0:     this.columnSpec = columnSpec;
0:       assert (columnSpec.getColumnType() == ColumnType.MEASURE);
0:       int precision = columnSpec.getPrecision();
0:       int scale = columnSpec.getScale();
/////////////////////////////////////////////////////////////////////////
0:   private static ColumnPage createVarLengthPage(TableSpec.ColumnSpec columnSpec, DataType dataType,
1:       int pageSize) {
0:         return new UnsafeVarLengthColumnPage(columnSpec, dataType, pageSize);
0:       return new SafeVarLengthColumnPage(columnSpec, dataType, pageSize);
0:   private static ColumnPage createFixLengthPage(TableSpec.ColumnSpec columnSpec, DataType dataType,
1:       int pageSize) {
0:         return new UnsafeFixLengthColumnPage(columnSpec, dataType, pageSize);
0:       return new SafeFixLengthColumnPage(columnSpec, dataType, pageSize);
0:   private static ColumnPage createPage(TableSpec.ColumnSpec columnSpec, DataType dataType,
1:       int pageSize) {
0:       return createVarLengthPage(columnSpec, dataType, pageSize);
0:       return createFixLengthPage(columnSpec, dataType, pageSize);
0:   public static ColumnPage newDecimalPage(TableSpec.ColumnSpec columnSpec, DataType dataType,
0:       int pageSize)
0:     return newPage(columnSpec, dataType, pageSize);
0:   public static ColumnPage newPage(TableSpec.ColumnSpec columnSpec, DataType dataType,
0:       int pageSize) throws MemoryException {
/////////////////////////////////////////////////////////////////////////
0:           instance = new UnsafeFixLengthColumnPage(columnSpec, dataType, pageSize);
0:           instance =
0:               new UnsafeVarLengthColumnPage(columnSpec, dataType, pageSize);
/////////////////////////////////////////////////////////////////////////
0:           instance = newBytePage(columnSpec, new byte[pageSize]);
0:           instance = newShortPage(columnSpec, new short[pageSize]);
0:           instance = newShortIntPage(columnSpec, new byte[pageSize * 3]);
0:           instance = newIntPage(columnSpec, new int[pageSize]);
0:           instance = newLongPage(columnSpec, new long[pageSize]);
0:           instance = newFloatPage(columnSpec, new float[pageSize]);
0:           instance = newDoublePage(columnSpec, new double[pageSize]);
0:           instance = newDecimalPage(columnSpec, new byte[pageSize][]);
0:           instance = new SafeVarLengthColumnPage(columnSpec, dataType, pageSize);
/////////////////////////////////////////////////////////////////////////
0:   public static ColumnPage wrapByteArrayPage(TableSpec.ColumnSpec columnSpec, byte[][] byteArray) {
0:     ColumnPage columnPage = createPage(columnSpec, BYTE_ARRAY, byteArray.length);
0:   private static ColumnPage newBytePage(TableSpec.ColumnSpec columnSpec, byte[] byteData) {
0:     ColumnPage columnPage = createPage(columnSpec, BYTE, byteData.length);
0:   private static ColumnPage newShortPage(TableSpec.ColumnSpec columnSpec, short[] shortData) {
0:     ColumnPage columnPage = createPage(columnSpec, SHORT, shortData.length);
0:   private static ColumnPage newShortIntPage(TableSpec.ColumnSpec columnSpec, byte[] shortIntData) {
0:     ColumnPage columnPage = createPage(columnSpec, SHORT_INT, shortIntData.length / 3);
0:   private static ColumnPage newIntPage(TableSpec.ColumnSpec columnSpec, int[] intData) {
0:     ColumnPage columnPage = createPage(columnSpec, INT, intData.length);
0:   private static ColumnPage newLongPage(TableSpec.ColumnSpec columnSpec, long[] longData) {
0:     ColumnPage columnPage = createPage(columnSpec, LONG, longData.length);
0:   private static ColumnPage newFloatPage(TableSpec.ColumnSpec columnSpec, float[] floatData) {
0:     ColumnPage columnPage = createPage(columnSpec, FLOAT, floatData.length);
0:   private static ColumnPage newDoublePage(TableSpec.ColumnSpec columnSpec, double[] doubleData) {
0:     ColumnPage columnPage = createPage(columnSpec, DOUBLE, doubleData.length);
0:   private static ColumnPage newDecimalPage(TableSpec.ColumnSpec columnSpec, byte[][] byteArray) {
0:     ColumnPage columnPage = createPage(columnSpec, DECIMAL, byteArray.length);
1:   private static ColumnPage newDecimalPage(TableSpec.ColumnSpec columnSpec,
0:       byte[] lvEncodedByteArray) throws MemoryException {
0:     return VarLengthColumnPageBase.newDecimalColumnPage(columnSpec, lvEncodedByteArray);
1:   private static ColumnPage newLVBytesPage(TableSpec.ColumnSpec columnSpec,
0:       byte[] lvEncodedByteArray) throws MemoryException {
0:     return VarLengthColumnPageBase.newLVBytesColumnPage(columnSpec, lvEncodedByteArray);
/////////////////////////////////////////////////////////////////////////
1:   public abstract byte[] getLVFlattenedBytePage() throws IOException;
/////////////////////////////////////////////////////////////////////////
0:         return compressor.compressByte(getLVFlattenedBytePage());
/////////////////////////////////////////////////////////////////////////
1:   public static ColumnPage decompress(ColumnPageEncoderMeta meta, byte[] compressedData,
0:       int offset, int length)
1:     Compressor compressor = CompressorFactory.getInstance().getCompressor(meta.getCompressorName());
1:     TableSpec.ColumnSpec columnSpec = meta.getColumnSpec();
0:     switch (meta.getStoreDataType()) {
0:         return newBytePage(columnSpec, byteData);
0:         return newShortPage(columnSpec, shortData);
0:         return newShortIntPage(columnSpec, shortIntData);
0:         return newIntPage(columnSpec, intData);
0:         return newLongPage(columnSpec, longData);
0:         return newFloatPage(columnSpec, floatData);
0:         return newDoublePage(columnSpec, doubleData);
0:         return newLVBytesPage(columnSpec, lvVarBytes);
0:         throw new UnsupportedOperationException("unsupport uncompress column page: " +
0:             meta.getStoreDataType());
1:   public static ColumnPage decompressDecimalPage(ColumnPageEncoderMeta meta, byte[] compressedData,
1:       int offset, int length) throws MemoryException {
1:     Compressor compressor = CompressorFactory.getInstance().getCompressor(meta.getCompressorName());
1:     TableSpec.ColumnSpec columnSpec = meta.getColumnSpec();
0:     return newDecimalPage(columnSpec, lvEncodedBytes);
/////////////////////////////////////////////////////////////////////////
1: 
1:   public TableSpec.ColumnSpec getColumnSpec() {
0:     return columnSpec;
1:   }
commit:4f7487d
/////////////////////////////////////////////////////////////////////////
0:     @Override public int getDecimalCount() {
commit:e6a4f64
/////////////////////////////////////////////////////////////////////////
1: import java.util.BitSet;
1: import org.apache.carbondata.core.datastore.page.statistics.SimpleStatsResult;
/////////////////////////////////////////////////////////////////////////
1:   // The index of the rowId whose value is null, will be set to 1
0:   private BitSet nullBitSet;
1: 
0:   DecimalConverterFactory.DecimalConverter decimalConverter;
/////////////////////////////////////////////////////////////////////////
1:     this.nullBitSet = new BitSet(pageSize);
/////////////////////////////////////////////////////////////////////////
0:   private static final SimpleStatsResult statsForComplexType = new SimpleStatsResult() {
0:     @Override public Object getMin() {
0:       return new byte[0];
1:     }
1: 
0:     @Override public Object getMax() {
0:       return new byte[0];
1:     }
1: 
0:     @Override public int getDecimalPoint() {
0:       return 0;
1:     }
1: 
0:     @Override public DataType getDataType() {
0:       return BYTE_ARRAY;
1:     }
1: 
0:     @Override public int getScale() {
0:       return 0;
1:     }
1: 
0:     @Override public int getPrecision() {
0:       return 0;
1:     }
0:   };
1: 
1:   public SimpleStatsResult getStatistics() {
0:     if (statsCollector != null) {
0:       return statsCollector.getPageStats();
1:     } else {
0:       // TODO: for sub column of complex type, there no stats yet, return a dummy result
0:       return statsForComplexType;
1:     }
/////////////////////////////////////////////////////////////////////////
0:     return newPage(dataType, pageSize, -1, -1);
1:   }
1: 
0:   public static ColumnPage newDecimalPage(DataType dataType, int pageSize, int scale, int precision)
1:     throws MemoryException {
0:     return newPage(dataType, pageSize, scale, precision);
0:   private static ColumnPage newPage(DataType dataType, int pageSize, int scale, int precision)
/////////////////////////////////////////////////////////////////////////
0:           instance = new UnsafeFixLengthColumnPage(dataType, pageSize, -1, -1);
0:         case STRING:
/////////////////////////////////////////////////////////////////////////
0:         case STRING:
0:           instance = new SafeVarLengthColumnPage(dataType, pageSize, -1, -1);
/////////////////////////////////////////////////////////////////////////
0:   public static ColumnPage wrapByteArrayPage(byte[][] byteArray) {
0:     ColumnPage columnPage = createPage(BYTE_ARRAY, byteArray.length, -1, -1);
1:     columnPage.setByteArrayPage(byteArray);
1:     return columnPage;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:   private static ColumnPage newLVBytesPage(byte[] lvEncodedByteArray)
0:     return VarLengthColumnPageBase.newLVBytesColumnPage(lvEncodedByteArray);
/////////////////////////////////////////////////////////////////////////
1:       nullBitSet.set(rowId);
/////////////////////////////////////////////////////////////////////////
0:       case STRING:
/////////////////////////////////////////////////////////////////////////
1:    * Get byte array at rowId
1:    */
1:   public abstract byte[] getBytes(int rowId);
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:   public abstract void convertValue(ColumnPageValueConverter codec);
/////////////////////////////////////////////////////////////////////////
1:    * Decompress data and create a column page using the decompressed data,
1:    * except for decimal page
0:       byte[] compressedData, int offset, int length)
/////////////////////////////////////////////////////////////////////////
0:         return newLVBytesPage(lvVarBytes);
1:   /**
0:    * Decompress decimal data and create a column page
1:    */
0:   public static ColumnPage decompressDecimalPage(Compressor compressor,
0:       byte[] compressedData, int offset, int length, int scale, int precision)
0:       throws MemoryException {
0:     byte[] lvEncodedBytes = compressor.unCompressByte(compressedData, offset, length);
0:     return newDecimalPage(lvEncodedBytes, scale, precision);
1:   }
1: 
1:   public BitSet getNullBits() {
1:     return nullBitSet;
1:   }
1: 
1:   public void setNullBits(BitSet nullBitSet) {
1:     this.nullBitSet = nullBitSet;
1:   }
commit:379d4f6
/////////////////////////////////////////////////////////////////////////
0:   public static ColumnPage newPage(DataType dataType, int pageSize) throws MemoryException {
0:     return newPage(dataType, pageSize, 0, 0);
1:   }
1: 
author:xubo245
-------------------------------------------------------------------------------
commit:6abdd97
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert;
/////////////////////////////////////////////////////////////////////////
1:       if (dataType == DataTypes.BOOLEAN) {
0:         instance = new UnsafeFixLengthColumnPage(columnSpec, BYTE, pageSize);
1:       } else if (dataType == DataTypes.BYTE ||
/////////////////////////////////////////////////////////////////////////
1:       if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
0:       if (columnSpec.getSchemaDataType() == DataTypes.BOOLEAN) {
1:         value = BooleanConvert.boolean2Byte((Boolean) value);
1:       }
/////////////////////////////////////////////////////////////////////////
1:    * Set boolean value at rowId
1:    */
1:   public void putBoolean(int rowId, boolean value) {
1:     putByte(rowId, BooleanConvert.boolean2Byte(value));
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN) {
1:       putBoolean(rowId, false);
1:     } else if (dataType == DataTypes.BYTE) {
/////////////////////////////////////////////////////////////////////////
1:    * Get boolean value at rowId
1:    */
1:   public boolean getBoolean(int rowId) {
1:     return BooleanConvert.byte2Boolean(getByte(rowId));
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:    * Get boolean value page
1:    */
1:   public byte[] getBooleanPage() {
1:     return getBytePage();
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN) {
1:       return compressor.compressByte(getBooleanPage());
1:     } else if (dataType == DataTypes.BYTE) {
/////////////////////////////////////////////////////////////////////////
1:     if (storeDataType == DataTypes.BOOLEAN || storeDataType == DataTypes.BYTE) {
author:manishgupta88
-------------------------------------------------------------------------------
commit:6f20437
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:   private static ColumnPage createDecimalPage(TableSpec.ColumnSpec columnSpec, DataType dataType,
0:       int pageSize) {
1:     if (unsafe) {
1:       try {
0:         return new UnsafeDecimalColumnPage(columnSpec, dataType, pageSize);
1:       } catch (MemoryException e) {
1:         throw new RuntimeException(e);
1:       }
1:     } else {
0:       return new SafeDecimalColumnPage(columnSpec, dataType, pageSize);
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:     if (dataType.equals(DECIMAL)) {
0:       return createDecimalPage(columnSpec, dataType, pageSize);
0:     } else if (dataType.equals(BYTE_ARRAY)) {
/////////////////////////////////////////////////////////////////////////
0:           instance = new UnsafeDecimalColumnPage(columnSpec, dataType, pageSize);
0:           break;
/////////////////////////////////////////////////////////////////////////
1:    * Decompress data and create a decimal column page using the decompressed data
1:     ColumnPage decimalPage = null;
0:     switch (meta.getStoreDataType()) {
0:       case BYTE:
0:         byte[] byteData = compressor.unCompressByte(compressedData, offset, length);
0:         decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), byteData.length);
0:         decimalPage.setBytePage(byteData);
0:         return decimalPage;
0:       case SHORT:
0:         short[] shortData = compressor.unCompressShort(compressedData, offset, length);
0:         decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), shortData.length);
0:         decimalPage.setShortPage(shortData);
0:         return decimalPage;
0:       case SHORT_INT:
0:         byte[] shortIntData = compressor.unCompressByte(compressedData, offset, length);
0:         decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), shortIntData.length);
0:         decimalPage.setShortIntPage(shortIntData);
0:         return decimalPage;
0:       case INT:
0:         int[] intData = compressor.unCompressInt(compressedData, offset, length);
0:         decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), intData.length);
0:         decimalPage.setIntPage(intData);
0:         return decimalPage;
0:       case LONG:
0:         long[] longData = compressor.unCompressLong(compressedData, offset, length);
0:         decimalPage = createDecimalPage(columnSpec, meta.getStoreDataType(), longData.length);
0:         decimalPage.setLongPage(longData);
0:         return decimalPage;
0:       default:
0:         byte[] lvEncodedBytes = compressor.unCompressByte(compressedData, offset, length);
0:         return newDecimalPage(columnSpec, lvEncodedBytes);
1:     }
commit:2b66476
/////////////////////////////////////////////////////////////////////////
0:     if (dataType.equals(BYTE_ARRAY) || dataType.equals(DECIMAL)) {
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
0:       default:
0:         throw new IllegalArgumentException("unsupported data type: " + dataType);
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:4e83509
/////////////////////////////////////////////////////////////////////////
0:         statsCollector.update((BigDecimal) value);
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7422690
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:           instance = new SafeVarLengthColumnPage(dataType, pageSize, scale, precision);
/////////////////////////////////////////////////////////////////////////
0:         statsCollector.update(((BigDecimal) value).unscaledValue().longValue());
author:jackylk
-------------------------------------------------------------------------------
commit:a5af0ff
/////////////////////////////////////////////////////////////////////////
0:         case BYTE_ARRAY:
0:           instance = new SafeVarLengthColumnPage(dataType, pageSize);
0:           break;
commit:bc3e684
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.page.statistics.ColumnPageStatsCollector;
/////////////////////////////////////////////////////////////////////////
1:   // statistics collector for this column page
0:   private ColumnPageStatsCollector statsCollector;
/////////////////////////////////////////////////////////////////////////
0:   public Object getStatistics() {
0:     return statsCollector.getPageStats();
1:   public void setStatsCollector(ColumnPageStatsCollector statsCollector) {
1:     this.statsCollector = statsCollector;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:       statsCollector.updateNull(rowId);
0:         statsCollector.update((byte) value);
0:         statsCollector.update((short) value);
0:         statsCollector.update((int) value);
0:         statsCollector.update((long) value);
0:         statsCollector.update((double) value);
0:         statsCollector.update((byte[]) value);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:eadfea7
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1:   public byte[] compress(Compressor compressor) throws MemoryException, IOException {
commit:7d386a4
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.carbondata.core.metadata.datatype.DataType.SHORT_INT;
/////////////////////////////////////////////////////////////////////////
0:         case SHORT_INT:
/////////////////////////////////////////////////////////////////////////
0:         case SHORT_INT:
0:           instance = newShortIntPage(new byte[pageSize * 3]);
0:           break;
/////////////////////////////////////////////////////////////////////////
0:   private static ColumnPage newShortIntPage(byte[] shortIntData) {
0:     ColumnPage columnPage = createPage(SHORT_INT, shortIntData.length / 3);
1:     columnPage.setShortIntPage(shortIntData);
1:     return columnPage;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:    * Set short int values to page
1:    */
1:   public abstract void setShortIntPage(byte[] shortIntData);
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:    * Type cast int value to 3 bytes value and set at rowId
1:    */
1:   public abstract void putShortInt(int rowId, int value);
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:    * Get short int value at rowId
1:    */
1:   public abstract int getShortInt(int rowId);
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:    * Get short int value page
1:    */
1:   public abstract byte[] getShortIntPage();
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
0:       case SHORT_INT:
0:         return compressor.compressByte(getShortIntPage());
/////////////////////////////////////////////////////////////////////////
0:       case SHORT_INT:
0:         byte[] shortIntData = compressor.unCompressByte(compressedData, offset, length);
0:         return newShortIntPage(shortIntData);
commit:7359601
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.memory.MemoryException;
/////////////////////////////////////////////////////////////////////////
1: public abstract class ColumnPage {
0:   protected final int pageSize;
0:   protected final DataType dataType;
1: 
0:   // statistics of this column page
1:   protected static final boolean unsafe = Boolean.parseBoolean(CarbonProperties.getInstance()
0:       .getProperty(CarbonCommonConstants.ENABLE_UNSAFE_COLUMN_PAGE_LOADING,
0:           CarbonCommonConstants.ENABLE_UNSAFE_COLUMN_PAGE_LOADING_DEFAULT));
1: 
1:     this.pageSize = pageSize;
0:     this.stats = new ColumnPageStatsVO(dataType);
0:     this.nullBitSet = new BitSet(pageSize);
/////////////////////////////////////////////////////////////////////////
0:   private static ColumnPage createVarLengthPage(DataType dataType, int pageSize) {
1:     if (unsafe) {
1:       try {
0:         return new UnsafeVarLengthColumnPage(dataType, pageSize);
1:       } catch (MemoryException e) {
1:         throw new RuntimeException(e);
1:       }
1:     } else {
0:       return new SafeVarLengthColumnPage(dataType, pageSize);
1:     }
1:   }
1: 
0:   private static ColumnPage createFixLengthPage(DataType dataType, int pageSize) {
1:     if (unsafe) {
1:       try {
0:         return new UnsafeFixLengthColumnPage(dataType, pageSize);
1:       } catch (MemoryException e) {
1:         throw new RuntimeException(e);
1:       }
1:     } else {
0:       return new SafeFixLengthColumnPage(dataType, pageSize);
1:     }
1:   }
1: 
0:   private static ColumnPage createPage(DataType dataType, int pageSize) {
0:     if (dataType.equals(BYTE_ARRAY) | dataType.equals(DECIMAL)) {
0:       return createVarLengthPage(dataType, pageSize);
1:     } else {
0:       return createFixLengthPage(dataType, pageSize);
1:     }
1:   }
1: 
0:   public static ColumnPage newVarLengthPath(DataType dataType, int pageSize) {
1:     if (unsafe) {
1:       try {
0:         return new UnsafeVarLengthColumnPage(dataType, pageSize);
1:       } catch (MemoryException e) {
1:         throw new RuntimeException(e);
1:       }
1:     } else {
0:       return new SafeVarLengthColumnPage(dataType, pageSize);
1:     }
1:   }
1: 
1:   /**
1:    * Create a new page of dataType and number of row = pageSize
1:    */
0:   public static ColumnPage newPage(DataType dataType, int pageSize) throws MemoryException {
1:     ColumnPage instance;
1:     if (unsafe) {
0:       switch (dataType) {
0:         case BYTE:
0:         case SHORT:
0:         case INT:
0:         case LONG:
0:         case FLOAT:
0:         case DOUBLE:
0:           instance = new UnsafeFixLengthColumnPage(dataType, pageSize);
0:           break;
0:         case DECIMAL:
0:         case BYTE_ARRAY:
0:           instance = new UnsafeVarLengthColumnPage(dataType, pageSize);
0:           break;
0:         default:
0:           throw new RuntimeException("Unsupported data dataType: " + dataType);
1:       }
1:     } else {
0:       switch (dataType) {
0:         case BYTE:
0:           instance = newBytePage(new byte[pageSize]);
0:           break;
0:         case SHORT:
0:           instance = newShortPage(new short[pageSize]);
0:           break;
0:         case INT:
0:           instance = newIntPage(new int[pageSize]);
0:           break;
0:         case LONG:
0:           instance = newLongPage(new long[pageSize]);
0:           break;
0:         case FLOAT:
0:           instance = newFloatPage(new float[pageSize]);
0:           break;
0:         case DOUBLE:
0:           instance = newDoublePage(new double[pageSize]);
0:           break;
0:         case DECIMAL:
0:           instance = newDecimalPage(new byte[pageSize][]);
0:           break;
0:         default:
0:           throw new RuntimeException("Unsupported data dataType: " + dataType);
1:       }
1:     }
1:     return instance;
1:   }
1: 
0:   private static ColumnPage newBytePage(byte[] byteData) {
0:     ColumnPage columnPage = createPage(BYTE, byteData.length);
1:     columnPage.setBytePage(byteData);
1:     return columnPage;
1:   }
1: 
0:   private static ColumnPage newShortPage(short[] shortData) {
0:     ColumnPage columnPage = createPage(SHORT, shortData.length);
1:     columnPage.setShortPage(shortData);
1:     return columnPage;
1:   }
1: 
0:   private static ColumnPage newIntPage(int[] intData) {
0:     ColumnPage columnPage = createPage(INT, intData.length);
1:     columnPage.setIntPage(intData);
1:     return columnPage;
1:   }
1: 
0:   private static ColumnPage newLongPage(long[] longData) {
0:     ColumnPage columnPage = createPage(LONG, longData.length);
1:     columnPage.setLongPage(longData);
1:     return columnPage;
1:   }
1: 
0:   private static ColumnPage newFloatPage(float[] floatData) {
0:     ColumnPage columnPage = createPage(FLOAT, floatData.length);
1:     columnPage.setFloatPage(floatData);
1:     return columnPage;
1:   }
1: 
0:   private static ColumnPage newDoublePage(double[] doubleData) {
0:     ColumnPage columnPage = createPage(DOUBLE, doubleData.length);
1:     columnPage.setDoublePage(doubleData);
1:     return columnPage;
1:   }
1: 
0:   private static ColumnPage newDecimalPage(byte[][] byteArray) {
0:     ColumnPage columnPage = createPage(DECIMAL, byteArray.length);
1:     columnPage.setByteArrayPage(byteArray);
1:     return columnPage;
1:   }
1: 
0:   private static ColumnPage newDecimalPage(byte[] lvEncodedByteArray) throws MemoryException {
0:     return VarLengthColumnPageBase.newDecimalColumnPage(lvEncodedByteArray);
1:   }
1: 
1:   /**
1:    * Set byte values to page
1:    */
1:   public abstract void setBytePage(byte[] byteData);
1: 
1:   /**
1:    * Set short values to page
1:    */
1:   public abstract void setShortPage(short[] shortData);
1: 
1:   /**
1:    * Set int values to page
1:    */
1:   public abstract void setIntPage(int[] intData);
1: 
1:   /**
1:    * Set long values to page
1:    */
1:   public abstract void setLongPage(long[] longData);
1: 
1:   /**
1:    * Set float values to page
1:    */
1:   public abstract void setFloatPage(float[] floatData);
1: 
1:   /**
1:    * Set double value to page
1:    */
1:   public abstract void setDoublePage(double[] doubleData);
1: 
1:   /**
1:    * Set byte array to page
1:    */
1:   public abstract void setByteArrayPage(byte[][] byteArray);
1: 
1:   /**
1:    * free memory as needed
1:    */
1:   public abstract void freeMemory();
1: 
1:   /**
1:    * Set value at rowId
1:    */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   public abstract void putByte(int rowId, byte value);
1:   public abstract void putShort(int rowId, short value);
1:   public abstract void putInt(int rowId, int value);
1:   public abstract void putLong(int rowId, long value);
1:   public abstract void putDouble(int rowId, double value);
1:    * Set byte array value at rowId
1:   public abstract void putBytes(int rowId, byte[] bytes);
1:    * Set byte array from offset to length at rowId
1:   public abstract void putBytes(int rowId, byte[] bytes, int offset, int length);
1: 
0:   private static final byte[] ZERO = DataTypeUtil.bigDecimalToByte(BigDecimal.ZERO);
0:   private void putNull(int rowId) {
/////////////////////////////////////////////////////////////////////////
0:         putBytes(rowId, ZERO);
1:    * Get byte value at rowId
1:   public abstract byte getByte(int rowId);
1:    * Get short value at rowId
1:    */
1:   public abstract short getShort(int rowId);
1: 
1:   /**
1:    * Get int value at rowId
1:    */
1:   public abstract int getInt(int rowId);
1: 
1:   /**
1:    * Get long value at rowId
1:    */
1:   public abstract long getLong(int rowId);
1: 
1:   /**
1:    * Get float value at rowId
1:    */
1:   public abstract float getFloat(int rowId);
1: 
1:   /**
1:    * Get double value at rowId
1:    */
1:   public abstract double getDouble(int rowId);
1: 
1:   /**
1:    * Get decimal value at rowId
1:    */
1:   public abstract BigDecimal getDecimal(int rowId);
1: 
1:   /**
1:    * Get byte value page
1:    */
1:   public abstract byte[] getBytePage();
1: 
1:   /**
1:    * Get short value page
1:    */
1:   public abstract short[] getShortPage();
1: 
1:   /**
1:    * Get int value page
1:    */
1:   public abstract int[] getIntPage();
1: 
1:   /**
1:    * Get long value page
1:    */
1:   public abstract long[] getLongPage();
1: 
1:   /**
1:    * Get float value page
1:    */
1:   public abstract float[] getFloatPage();
1: 
1:   /**
1:    * Get double value page
1:    */
1:   public abstract double[] getDoublePage();
1: 
1:   /**
1:    * Get variable length page data
1:    */
1:   public abstract byte[][] getByteArrayPage();
1: 
1:   /**
1:    * For variable length page, get the flattened data
1:    */
0:   public abstract byte[] getFlattenedBytePage();
1: 
1:   /**
1:    * Encode the page data by codec (Visitor)
1:    */
0:   public abstract void encode(PrimitiveCodec codec);
1: 
1:   /**
1:    * Compress page data using specified compressor
/////////////////////////////////////////////////////////////////////////
0:         return compressor.compressByte(getFlattenedBytePage());
0:         return compressor.compressByte(getFlattenedBytePage());
0:    * Decompress data and create a column page using the decompressed data
0:       byte[] compressedData, int offset, int length) throws MemoryException {
/////////////////////////////////////////////////////////////////////////
0:         byte[] lvEncodedBytes = compressor.unCompressByte(compressedData, offset, length);
0:         return newDecimalPage(lvEncodedBytes);
commit:edda248
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.constants.CarbonV3DataFormatConstants;
1: import org.apache.carbondata.core.datastore.compression.Compressor;
0: import org.apache.carbondata.core.datastore.page.statistics.ColumnPageStatsVO;
0: import org.apache.carbondata.core.util.ByteUtil;
1: import org.apache.carbondata.core.util.CarbonProperties;
0: import static org.apache.carbondata.core.metadata.datatype.DataType.BYTE;
0: import static org.apache.carbondata.core.metadata.datatype.DataType.BYTE_ARRAY;
0: import static org.apache.carbondata.core.metadata.datatype.DataType.DECIMAL;
0: import static org.apache.carbondata.core.metadata.datatype.DataType.DOUBLE;
0: import static org.apache.carbondata.core.metadata.datatype.DataType.FLOAT;
0: import static org.apache.carbondata.core.metadata.datatype.DataType.INT;
0: import static org.apache.carbondata.core.metadata.datatype.DataType.LONG;
0: import static org.apache.carbondata.core.metadata.datatype.DataType.SHORT;
1: 
1: /**
0:  * Represent a columnar data in one page for one column.
1:  */
0:   private final int pageSize;
0:   private DataType dataType;
0:   private ColumnPageStatsVO stats;
0:   private float[] floatData;
/////////////////////////////////////////////////////////////////////////
0:   protected ColumnPage(DataType dataType, int pageSize) {
0:     this.dataType = dataType;
1:   }
1: 
0:   // create a new page
0:   public static ColumnPage newPage(DataType dataType, int pageSize) {
0:     ColumnPage instance;
0:       case BYTE:
0:         instance = newBytePage(new byte[pageSize]);
0:         break;
0:         instance = newShortPage(new short[pageSize]);
0:         break;
0:         instance = newIntPage(new int[pageSize]);
0:         break;
0:         instance = newLongPage(new long[pageSize]);
0:         break;
0:       case FLOAT:
0:         instance = newFloatPage(new float[pageSize]);
0:         instance = newDoublePage(new double[pageSize]);
0:         instance = newDecimalPage(new byte[pageSize][]);
0:       case BYTE_ARRAY:
0:         instance = newVarLengthPage(new byte[pageSize][]);
0:     instance.stats = new ColumnPageStatsVO(dataType);
0:     instance.nullBitSet = new BitSet(pageSize);
0:     return instance;
1:   }
1: 
0:   protected static ColumnPage newBytePage(byte[] byteData) {
0:     ColumnPage columnPage = new ColumnPage(BYTE, byteData.length);
0:     columnPage.byteData = byteData;
0:     return columnPage;
1:   }
1: 
0:   protected static ColumnPage newShortPage(short[] shortData) {
0:     ColumnPage columnPage = new ColumnPage(SHORT, shortData.length);
0:     columnPage.shortData = shortData;
0:     return columnPage;
1:   }
1: 
0:   protected static ColumnPage newIntPage(int[] intData) {
0:     ColumnPage columnPage = new ColumnPage(INT, intData.length);
0:     columnPage.intData = intData;
0:     return columnPage;
1:   }
1: 
0:   protected static ColumnPage newLongPage(long[] longData) {
0:     ColumnPage columnPage = new ColumnPage(LONG, longData.length);
0:     columnPage.longData = longData;
0:     return columnPage;
1:   }
1: 
0:   protected static ColumnPage newFloatPage(float[] floatData) {
0:     ColumnPage columnPage = new ColumnPage(FLOAT, floatData.length);
0:     columnPage.floatData = floatData;
0:     return columnPage;
1:   }
1: 
0:   protected static ColumnPage newDoublePage(double[] doubleData) {
0:     ColumnPage columnPage = new ColumnPage(DOUBLE, doubleData.length);
0:     columnPage.doubleData = doubleData;
0:     return columnPage;
1:   }
1: 
0:   protected static ColumnPage newDecimalPage(byte[][] decimalData) {
0:     ColumnPage columnPage = new ColumnPage(DECIMAL, decimalData.length);
0:     columnPage.byteArrayData = decimalData;
0:     return columnPage;
1:   }
1: 
0:   protected static ColumnPage newVarLengthPage(byte[][] stringData) {
0:     ColumnPage columnPage = new ColumnPage(BYTE_ARRAY, stringData.length);
0:     columnPage.byteArrayData = stringData;
0:     return columnPage;
0:   public ColumnPageStatsVO getStatistics() {
1:   public int getPageSize() {
1:     return pageSize;
1:   }
1: 
0:       stats.updateNull();
0:         // TODO: change sort step to store as exact data type
0:         putByte(rowId, (byte) value);
0:         break;
0:         putShort(rowId, (short) value);
0:         putInt(rowId, (int) value);
/////////////////////////////////////////////////////////////////////////
0:       case BYTE_ARRAY:
0:         putBytes(rowId, (byte[]) value);
/////////////////////////////////////////////////////////////////////////
0:   public void putBytes(int rowId, byte[] bytes) {
0:     byteArrayData[rowId] = bytes;
/////////////////////////////////////////////////////////////////////////
0:         putByte(rowId, (byte) 0);
0:         break;
0:         putShort(rowId, (short) 0);
0:         break;
0:         putInt(rowId, 0);
0:         break;
/////////////////////////////////////////////////////////////////////////
0:    * Get byte value at rowId
1:    */
0:   public byte getByte(int rowId) {
0:     return byteData[rowId];
0:   }
1: 
1:   /**
0:    * Get short value at rowId
1:    */
0:   public short getShort(int rowId) {
0:     return shortData[rowId];
0:   }
1: 
1:   /**
0:    * Get int value at rowId
1:    */
0:   public int getInt(int rowId) {
0:     return intData[rowId];
0:   }
1: 
1:   /**
0:    * Get long value at rowId
1:    */
0:   public long getLong(int rowId) {
0:     return longData[rowId];
0:   }
1: 
1:   /**
0:    * Get float value at rowId
1:    */
0:   public float getFloat(int rowId) {
0:     return floatData[rowId];
0:   }
1: 
1:   /**
0:    * Get double value at rowId
1:    */
0:   public double getDouble(int rowId) {
0:     return doubleData[rowId];
0:   }
1: 
1:   /**
0:    * Get decimal value at rowId
1:    */
0:   public byte[] getDecimalBytes(int rowId) {
0:     return byteArrayData[rowId];
0:   }
1: 
0:   public BigDecimal getDecimal(int rowId) {
0:     byte[] bytes = getDecimalBytes(rowId);
0:     return DataTypeUtil.byteToBigDecimal(bytes);
0:   }
1: 
1:   /**
0:    * Get byte value page
1:    */
0:   public byte[] getBytePage() {
0:     return byteData;
0:   }
1: 
1:   /**
0:    * Get short value page
1:    */
0:   public short[] getShortPage() {
0:     return shortData;
0:   }
1: 
1:   /**
0:    * Get int value page
1:    */
0:   public int[] getIntPage() {
0:     return intData;
0:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
0:    * Get float value page
1:    */
0:   public float[] getFloatPage() {
0:     return floatData;
0:   }
0: 
1:   /**
/////////////////////////////////////////////////////////////////////////
0:   public byte[][] getByteArrayPage() {
/////////////////////////////////////////////////////////////////////////
0: 
0:   public void freeMemory() {
0:   }
0: 
1:   /**
0:    * apply encoding to page data
0:    * @param codec type of transformation
1:    */
0:   public void encode(PrimitiveCodec codec) {
0:     switch (dataType) {
0:       case BYTE:
0:         for (int i = 0; i < pageSize; i++) {
0:           codec.encode(i, byteData[i]);
0:         }
0:         break;
0:       case SHORT:
0:         for (int i = 0; i < pageSize; i++) {
0:           codec.encode(i, shortData[i]);
0:         }
0:         break;
0:       case INT:
0:         for (int i = 0; i < pageSize; i++) {
0:           codec.encode(i, intData[i]);
0:         }
0:         break;
0:       case LONG:
0:         for (int i = 0; i < pageSize; i++) {
0:           codec.encode(i, longData[i]);
0:         }
0:         break;
0:       case FLOAT:
0:         for (int i = 0; i < pageSize; i++) {
0:           codec.encode(i, floatData[i]);
0:         }
0:         break;
0:       case DOUBLE:
0:         for (int i = 0; i < pageSize; i++) {
0:           codec.encode(i, doubleData[i]);
0:         }
0:         break;
0:       default:
0:         throw new UnsupportedOperationException("not support encode on " + dataType + " page");
0:     }
0:   }
0: 
1:   /**
0:    * compress page data using specified compressor
1:    */
0:   public byte[] compress(Compressor compressor) {
0:     switch (dataType) {
0:       case BYTE:
0:         return compressor.compressByte(getBytePage());
0:       case SHORT:
0:         return compressor.compressShort(getShortPage());
0:       case INT:
0:         return compressor.compressInt(getIntPage());
0:       case LONG:
0:         return compressor.compressLong(getLongPage());
0:       case FLOAT:
0:         return compressor.compressFloat(getFloatPage());
0:       case DOUBLE:
0:         return compressor.compressDouble(getDoublePage());
0:       case DECIMAL:
0:         byte[] flattenedDecimal = ByteUtil.flatten(getDecimalPage());
0:         return compressor.compressByte(flattenedDecimal);
0:       case BYTE_ARRAY:
0:         byte[] flattenedString = ByteUtil.flatten(getByteArrayPage());
0:         return compressor.compressByte(flattenedString);
0:       default:
0:         throw new UnsupportedOperationException("unsupport compress column page: " + dataType);
0:     }
0:   }
0: 
1:   /**
0:    * decompress data and create a column page using the decompressed data
1:    */
0:   public static ColumnPage decompress(Compressor compressor, DataType dataType,
0:       byte[] compressedData, int offset, int length) {
0:     switch (dataType) {
0:       case BYTE:
0:         byte[] byteData = compressor.unCompressByte(compressedData, offset, length);
0:         return newBytePage(byteData);
0:       case SHORT:
0:         short[] shortData = compressor.unCompressShort(compressedData, offset, length);
0:         return newShortPage(shortData);
0:       case INT:
0:         int[] intData = compressor.unCompressInt(compressedData, offset, length);
0:         return newIntPage(intData);
0:       case LONG:
0:         long[] longData = compressor.unCompressLong(compressedData, offset, length);
0:         return newLongPage(longData);
0:       case FLOAT:
0:         float[] floatData = compressor.unCompressFloat(compressedData, offset, length);
0:         return newFloatPage(floatData);
0:       case DOUBLE:
0:         double[] doubleData = compressor.unCompressDouble(compressedData, offset, length);
0:         return newDoublePage(doubleData);
0:       case DECIMAL:
0:         byte[] decompressed = compressor.unCompressByte(compressedData, offset, length);
0:         byte[][] decimal = deflatten(decompressed);
0:         return newDecimalPage(decimal);
0:       case BYTE_ARRAY:
0:         decompressed = compressor.unCompressByte(compressedData, offset, length);
0:         byte[][] string = deflatten(decompressed);
0:         return newVarLengthPage(string);
0:       default:
0:         throw new UnsupportedOperationException("unsupport uncompress column page: " + dataType);
0:     }
0:   }
0: 
0:   // input byte[] is LV encoded, this function can expand it into byte[][]
0:   private static byte[][] deflatten(byte[] input) {
0:     int pageSize = Integer.valueOf(
0:         CarbonProperties.getInstance().getProperty(
0:             CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE,
0:             CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT));
0:     int numRows = 0;
0:     // offset of value of each row in input data
0:     int[] offsetOfRow = new int[pageSize];
0:     ByteBuffer buffer = ByteBuffer.allocate(CarbonCommonConstants.INT_SIZE_IN_BYTE);
0:     for (int currentLength = 0; currentLength < input.length;) {
0:       buffer.put(input, currentLength, CarbonCommonConstants.INT_SIZE_IN_BYTE);
0:       buffer.flip();
0:       int valueLength = buffer.getInt();
0:       offsetOfRow[numRows] = currentLength + CarbonCommonConstants.INT_SIZE_IN_BYTE;
0:       currentLength += CarbonCommonConstants.INT_SIZE_IN_BYTE + valueLength;
0:       buffer.clear();
0:       numRows++;
0:     }
0:     byte[][] byteArrayData = new byte[numRows][];
0:     for (int rowId = 0; rowId < numRows; rowId++) {
0:       int valueOffset = offsetOfRow[rowId];
0:       int valueLength;
0:       if (rowId != numRows - 1) {
0:         valueLength = offsetOfRow[rowId + 1] - valueOffset - CarbonCommonConstants.INT_SIZE_IN_BYTE;
0:       } else {
0:         // last row
0:         buffer.put(input, offsetOfRow[rowId] - CarbonCommonConstants.INT_SIZE_IN_BYTE,
0:             CarbonCommonConstants.INT_SIZE_IN_BYTE);
0:         buffer.flip();
0:         valueLength = buffer.getInt();
0:       }
0:       byte[] value = new byte[valueLength];
0:       System.arraycopy(input, valueOffset, value, 0, valueLength);
0:       byteArrayData[rowId] = value;
0:     }
0:     return byteArrayData;
0:   }
commit:dc83b2a
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
0: import java.nio.ByteBuffer;
0: import java.util.BitSet;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: import org.apache.carbondata.core.datastore.page.statistics.ColumnPageStatistics;
1: import org.apache.carbondata.core.metadata.datatype.DataType;
0: import org.apache.carbondata.core.util.DataTypeUtil;
0: 
0: // Represent a columnar data in one page for one column.
0:   protected ColumnPageStatistics stats;
0:   // Only one of following fields will be used
0:   private byte[] byteData;
0:   private short[] shortData;
0:   private int[] intData;
0:   private long[] longData;
0:   private double[] doubleData;
0: 
0:   // for string and decimal data
0:   private byte[][] byteArrayData;
0: 
0:   // The index of the rowId whose value is null, will be set to 1
0:   private BitSet nullBitSet;
0: 
0:   public ColumnPage(DataType dataType, int pageSize) {
0:     this.stats = new ColumnPageStatistics(dataType);
0:     this.nullBitSet = new BitSet(pageSize);
0:     switch (dataType) {
0:       case SHORT:
0:       case INT:
0:       case LONG:
0:         longData = new long[pageSize];
0:         break;
0:       case DOUBLE:
0:         doubleData = new double[pageSize];
0:         break;
0:       case DECIMAL:
0:         byteArrayData = new byte[pageSize][];
0:         break;
0:       case STRING:
0:         byteArrayData = new byte[pageSize][];
0:         break;
0:       default:
0:         throw new RuntimeException("Unsupported data dataType: " + dataType);
0:     }
1:   public DataType getDataType() {
0:     return dataType;
0:   }
0: 
0:   public ColumnPageStatistics getStatistics() {
0:     return stats;
0:   }
0: 
1:   public void putData(int rowId, Object value) {
1:     if (value == null) {
1:       putNull(rowId);
1:       return;
0:     }
0:     switch (dataType) {
0:       case BYTE:
0:       case SHORT:
0:         putLong(rowId, ((Short) value).longValue());
0:         break;
0:       case INT:
0:         putLong(rowId, ((Integer) value).longValue());
0:         break;
0:       case LONG:
0:         putLong(rowId, (long) value);
0:         break;
0:       case DOUBLE:
0:         putDouble(rowId, (double) value);
0:         break;
0:       case DECIMAL:
0:         putDecimalBytes(rowId, (byte[]) value);
0:         break;
0:       case STRING:
0:         putStringBytes(rowId, (byte[]) value);
0:         break;
0:       default:
0:         throw new RuntimeException("unsupported data type: " + dataType);
0:     }
0:   /**
1:    * Set byte value at rowId
0:    */
0:   public void putByte(int rowId, byte value) {
0:     byteData[rowId] = value;
0:   }
0: 
0:   /**
1:    * Set short value at rowId
0:    */
0:   public void putShort(int rowId, short value) {
0:     shortData[rowId] = value;
0:   }
0: 
0:   /**
1:    * Set integer value at rowId
0:    */
0:   public void putInt(int rowId, int value) {
0:     intData[rowId] = value;
0:   }
0: 
0:   /**
1:    * Set long value at rowId
0:    */
0:   public void putLong(int rowId, long value) {
0:     longData[rowId] = value;
0:   }
0: 
0:   /**
1:    * Set double value at rowId
0:    */
0:   public void putDouble(int rowId, double value) {
0:     doubleData[rowId] = value;
0:   }
0: 
0:   /**
0:    * Set decimal value at rowId
0:    */
0:   public void putDecimalBytes(int rowId, byte[] decimalInBytes) {
0:     // do LV (length value) coded of input bytes
0:     ByteBuffer byteBuffer = ByteBuffer.allocate(decimalInBytes.length +
0:         CarbonCommonConstants.INT_SIZE_IN_BYTE);
0:     byteBuffer.putInt(decimalInBytes.length);
0:     byteBuffer.put(decimalInBytes);
0:     byteBuffer.flip();
0:     byteArrayData[rowId] = byteBuffer.array();
0:   }
0: 
0:   /**
0:    * Set string value at rowId
0:    */
0:   public void putStringBytes(int rowId, byte[] stringInBytes) {
0:     byteArrayData[rowId] = stringInBytes;
0:   }
0: 
0:   /**
1:    * Set null at rowId
0:    */
0:   public void putNull(int rowId) {
0:     nullBitSet.set(rowId);
0:     switch (dataType) {
0:       case BYTE:
0:       case SHORT:
0:       case INT:
0:       case LONG:
0:         putLong(rowId, 0L);
0:         break;
0:       case DOUBLE:
0:         putDouble(rowId, 0.0);
0:         break;
0:       case DECIMAL:
0:         byte[] decimalInBytes = DataTypeUtil.bigDecimalToByte(BigDecimal.ZERO);
0:         putDecimalBytes(rowId, decimalInBytes);
0:         break;
0:     }
0:   }
0: 
0:   /**
0:    * Get long value page
0:    */
0:   public long[] getLongPage() {
0:     return longData;
0:   }
0: 
0:   /**
0:    * Get double value page
0:    */
0:   public double[] getDoublePage() {
0:     return doubleData;
0:   }
0: 
0:   /**
0:    * Get decimal value page
0:    */
0:   public byte[][] getDecimalPage() {
0:     return byteArrayData;
0:   }
0: 
0:   /**
0:    * Get string page
0:    */
0:   public byte[][] getStringPage() {
0:     return byteArrayData;
0:   }
0: 
0:   /**
0:    * Get null bitset page
0:    */
0:   public BitSet getNullBitSet() {
0:     return nullBitSet;
commit:98df130
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: 
1: package org.apache.carbondata.core.datastore.page;
0: 
0: import org.apache.carbondata.core.datastore.page.statistics.PageStatistics;
0: import org.apache.carbondata.core.metadata.datatype.DataType;
0: 
0: public class ColumnPage {
0: 
0:   protected final DataType dataType;
0:   protected final int pageSize;
0:   protected PageStatistics stats;
0: 
0:   protected ColumnPage(DataType dataType, int pageSize) {
0:     this.dataType = dataType;
0:     this.pageSize = pageSize;
0:     this.stats = new PageStatistics(dataType);
0:   }
0: 
0:   protected void updateStatistics(Object value) {
0:     stats.update(value);
0:   }
0: 
0:   public PageStatistics getStatistics() {
0:     return stats;
0:   }
0: }
author:ravipesala
-------------------------------------------------------------------------------
commit:9e064ee
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.datatype.DecimalConverterFactory;
/////////////////////////////////////////////////////////////////////////
0:   protected int scale;
0:   protected int precision;
/////////////////////////////////////////////////////////////////////////
0:   protected DecimalConverterFactory.DecimalConverter decimalConverter;
0: 
0:   protected ColumnPage(DataType dataType, int pageSize, int scale, int precision) {
0:     this.scale = scale;
0:     this.precision = precision;
0:     if (dataType == DECIMAL) {
0:       decimalConverter = DecimalConverterFactory.INSTANCE.getDecimalConverter(precision, scale);
0:     }
/////////////////////////////////////////////////////////////////////////
0:   private static ColumnPage createVarLengthPage(DataType dataType, int pageSize, int scale,
0:       int precision) {
0:         return new UnsafeVarLengthColumnPage(dataType, pageSize, scale, precision);
0:       return new SafeVarLengthColumnPage(dataType, pageSize, scale, precision);
0:   private static ColumnPage createFixLengthPage(DataType dataType, int pageSize, int scale,
0:       int precision) {
0:         return new UnsafeFixLengthColumnPage(dataType, pageSize, scale, precision);
0:       return new SafeFixLengthColumnPage(dataType, pageSize, scale, pageSize);
0:   private static ColumnPage createPage(DataType dataType, int pageSize, int scale, int precision) {
0:       return createVarLengthPage(dataType, pageSize, scale, precision);
0:       return createFixLengthPage(dataType, pageSize, scale, precision);
0:   public static ColumnPage newVarLengthPage(DataType dataType, int pageSize) {
0:     return newVarLengthPage(dataType, pageSize, -1, -1);
0:   }
0: 
0:   private static ColumnPage newVarLengthPage(DataType dataType, int pageSize, int scale,
0:       int precision) {
0:         return new UnsafeVarLengthColumnPage(dataType, pageSize, scale, precision);
0:       return new SafeVarLengthColumnPage(dataType, pageSize, scale, precision);
0:   public static ColumnPage newPage(DataType dataType, int pageSize, int scale, int precision)
0:       throws MemoryException {
/////////////////////////////////////////////////////////////////////////
0:           instance = new UnsafeFixLengthColumnPage(dataType, pageSize, scale, precision);
0:           instance = new UnsafeVarLengthColumnPage(dataType, pageSize, scale, precision);
/////////////////////////////////////////////////////////////////////////
0:           instance = newDecimalPage(new byte[pageSize][], scale, precision);
/////////////////////////////////////////////////////////////////////////
0:     ColumnPage columnPage = createPage(BYTE, byteData.length,  -1, -1);
0:     ColumnPage columnPage = createPage(SHORT, shortData.length,  -1, -1);
0:     ColumnPage columnPage = createPage(SHORT_INT, shortIntData.length / 3,  -1, -1);
0:     ColumnPage columnPage = createPage(INT, intData.length,  -1, -1);
0:     ColumnPage columnPage = createPage(LONG, longData.length,  -1, -1);
0:     ColumnPage columnPage = createPage(FLOAT, floatData.length,  -1, -1);
0:     ColumnPage columnPage = createPage(DOUBLE, doubleData.length, -1, -1);
0:   private static ColumnPage newDecimalPage(byte[][] byteArray, int scale, int precision) {
0:     ColumnPage columnPage = createPage(DECIMAL, byteArray.length, scale, precision);
0:   private static ColumnPage newDecimalPage(byte[] lvEncodedByteArray, int scale, int precision)
0:       throws MemoryException {
0:     return VarLengthColumnPageBase.newDecimalColumnPage(lvEncodedByteArray, scale, precision);
0:   }
0: 
0:   private static ColumnPage newVarLengthPage(byte[] lvEncodedByteArray, int scale, int precision)
0:       throws MemoryException {
0:     return VarLengthColumnPageBase.newVarLengthColumnPage(lvEncodedByteArray, scale, precision);
/////////////////////////////////////////////////////////////////////////
0:         putDecimal(rowId, (BigDecimal) value);
0:         break;
/////////////////////////////////////////////////////////////////////////
1:    * Set byte array value at rowId
0:    */
1:   public abstract void putDecimal(int rowId, BigDecimal decimal);
0: 
0:   /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         putDecimal(rowId, BigDecimal.ZERO);
/////////////////////////////////////////////////////////////////////////
1:    * For decimals
0:    */
1:   public abstract byte[] getDecimalPage();
0: 
0:   /**
/////////////////////////////////////////////////////////////////////////
0:         return compressor.compressByte(getDecimalPage());
/////////////////////////////////////////////////////////////////////////
0:       byte[] compressedData, int offset, int length, int scale, int precision)
0:       throws MemoryException {
/////////////////////////////////////////////////////////////////////////
0:         return newDecimalPage(lvEncodedBytes, scale, precision);
0:       case BYTE_ARRAY:
0:         byte[] lvVarBytes = compressor.unCompressByte(compressedData, offset, length);
0:         return newVarLengthPage(lvVarBytes, scale, precision);
============================================================================