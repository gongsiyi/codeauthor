1:56330ae: /*
1:56330ae:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:56330ae:  * contributor license agreements.  See the NOTICE file distributed with
1:56330ae:  * this work for additional information regarding copyright ownership.
1:56330ae:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:56330ae:  * (the "License"); you may not use this file except in compliance with
1:56330ae:  * the License.  You may obtain a copy of the License at
1:56330ae:  *
1:56330ae:  *    http://www.apache.org/licenses/LICENSE-2.0
1:56330ae:  *
1:56330ae:  * Unless required by applicable law or agreed to in writing, software
1:56330ae:  * distributed under the License is distributed on an "AS IS" BASIS,
1:56330ae:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:56330ae:  * See the License for the specific language governing permissions and
1:56330ae:  * limitations under the License.
1:56330ae:  */
1:56330ae: package org.apache.carbondata.core.datamap;
2:56330ae: 
1:5f2a748: import java.io.IOException;
1:56330ae: import java.util.ArrayList;
1:56330ae: import java.util.Collections;
1:56330ae: import java.util.HashSet;
1:56330ae: import java.util.List;
1:747be9b: import java.util.Map;
1:56330ae: import java.util.Set;
1:56330ae: 
1:56330ae: import org.apache.carbondata.common.annotations.InterfaceAudience;
1:56330ae: import org.apache.carbondata.core.datamap.dev.expr.AndDataMapExprWrapper;
1:56330ae: import org.apache.carbondata.core.datamap.dev.expr.DataMapExprWrapper;
1:56330ae: import org.apache.carbondata.core.datamap.dev.expr.DataMapExprWrapperImpl;
1:56330ae: import org.apache.carbondata.core.datamap.dev.expr.OrDataMapExprWrapper;
1:747be9b: import org.apache.carbondata.core.datamap.status.DataMapStatusDetail;
1:747be9b: import org.apache.carbondata.core.datamap.status.DataMapStatusManager;
1:56330ae: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1:56330ae: import org.apache.carbondata.core.scan.expression.ColumnExpression;
1:56330ae: import org.apache.carbondata.core.scan.expression.Expression;
1:46f0c85: import org.apache.carbondata.core.scan.expression.MatchExpression;
1:56330ae: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1:56330ae: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1:56330ae: import org.apache.carbondata.core.scan.filter.intf.ExpressionType;
1:56330ae: import org.apache.carbondata.core.scan.filter.resolver.FilterResolverIntf;
1:56330ae: 
1:56330ae: /**
1:56330ae:  * This chooser does 2 jobs.
1:56330ae:  * 1. Based on filter expression it converts the available datamaps to datamap expression.
1:56330ae:  *   For example, there are 2 datamaps available on table1
1:56330ae:  *   Datamap1 : column1
1:56330ae:  *   Datamap2 : column2
1:56330ae:  *   Query: select * from table1 where column1 ='a' and column2 =b
1:56330ae:  *   For the above query, we create datamap expression as AndDataMapExpression(Datamap1, DataMap2).
1:56330ae:  *   So for the above query both the datamaps are included and the output of them will be
1:56330ae:  *   applied AND condition to improve the performance
1:56330ae:  *
1:56330ae:  * 2. It chooses the datamap out of available datamaps based on simple logic.
1:56330ae:  *   Like if there is filter condition on column1 then for
1:56330ae:  *   supposing 2 datamaps(1. column1 2. column1+column2) are supporting this column then we choose
1:56330ae:  *   the datamap which has fewer columns that is the first datamap.
1:56330ae:  */
1:56330ae: @InterfaceAudience.Internal
1:56330ae: public class DataMapChooser {
1:56330ae: 
1:747be9b:   private CarbonTable carbonTable;
1:747be9b:   private List<TableDataMap> cgDataMaps;
1:747be9b:   private List<TableDataMap> fgDataMaps;
1:56330ae: 
1:747be9b:   public DataMapChooser(CarbonTable carbonTable) throws IOException {
1:747be9b:     this.carbonTable = carbonTable;
1:747be9b:     // read all datamaps for this table and populate CG and FG datamap list
1:747be9b:     List<TableDataMap> visibleDataMaps =
1:747be9b:         DataMapStoreManager.getInstance().getAllVisibleDataMap(carbonTable);
1:747be9b:     Map<String, DataMapStatusDetail> map = DataMapStatusManager.readDataMapStatusMap();
1:747be9b:     cgDataMaps = new ArrayList<>(visibleDataMaps.size());
1:747be9b:     fgDataMaps = new ArrayList<>(visibleDataMaps.size());
1:747be9b:     for (TableDataMap visibleDataMap : visibleDataMaps) {
1:747be9b:       DataMapStatusDetail status = map.get(visibleDataMap.getDataMapSchema().getDataMapName());
1:747be9b:       if (status != null && status.isEnabled()) {
1:747be9b:         DataMapLevel level = visibleDataMap.getDataMapFactory().getDataMapLevel();
1:747be9b:         if (level == DataMapLevel.CG) {
1:747be9b:           cgDataMaps.add(visibleDataMap);
1:747be9b:         } else {
1:747be9b:           fgDataMaps.add(visibleDataMap);
1:747be9b:         }
1:747be9b:       }
1:bbb1092:     }
4:56330ae:   }
1:56330ae: 
1:4a47630:   /**
1:56330ae:    * Return a chosen datamap based on input filter. See {@link DataMapChooser}
1:4a47630:    */
1:747be9b:   public DataMapExprWrapper choose(FilterResolverIntf filter) {
1:03a735b:     if (filter != null) {
1:03a735b:       Expression expression = filter.getFilterExpression();
1:4a47630:       // First check for FG datamaps if any exist
1:747be9b:       ExpressionTuple tuple = selectDataMap(expression, fgDataMaps, filter);
1:56330ae:       if (tuple.dataMapExprWrapper == null) {
1:4a47630:         // Check for CG datamap
1:747be9b:         tuple = selectDataMap(expression, cgDataMaps, filter);
1:56330ae:       }
1:4a47630:       if (tuple.dataMapExprWrapper != null) {
1:4a47630:         return tuple.dataMapExprWrapper;
1:4a47630:       }
1:56330ae:     }
1:4a47630:     // Return the default datamap if no other datamap exists.
1:7e0803f:     return new DataMapExprWrapperImpl(
1:03a735b:         DataMapStoreManager.getInstance().getDefaultDataMap(carbonTable), filter);
1:4a47630:   }
1:56330ae: 
1:4a47630:   /**
1:4a47630:    * Return a chosen FG datamap based on input filter. See {@link DataMapChooser}
1:56330ae:    */
1:747be9b:   public DataMapExprWrapper chooseFGDataMap(FilterResolverIntf resolverIntf) {
1:747be9b:     return chooseDataMap(DataMapLevel.FG, resolverIntf);
1:4a47630:   }
1:4a47630: 
1:4a47630:   /**
1:4a47630:    * Return a chosen CG datamap based on input filter. See {@link DataMapChooser}
1:4a47630:    */
1:747be9b:   public DataMapExprWrapper chooseCGDataMap(FilterResolverIntf resolverIntf) {
1:747be9b:     return chooseDataMap(DataMapLevel.CG, resolverIntf);
1:747be9b:   }
1:747be9b: 
1:747be9b:   private DataMapExprWrapper chooseDataMap(DataMapLevel level, FilterResolverIntf resolverIntf) {
2:4a47630:     if (resolverIntf != null) {
2:4a47630:       Expression expression = resolverIntf.getFilterExpression();
1:747be9b:       List<TableDataMap> datamaps = level == DataMapLevel.CG ? cgDataMaps : fgDataMaps;
1:747be9b:       ExpressionTuple tuple = selectDataMap(expression, datamaps, resolverIntf);
1:4a47630:       if (tuple.dataMapExprWrapper != null) {
1:4a47630:         return tuple.dataMapExprWrapper;
1:4a47630:       }
1:4a47630:     }
1:4a47630:     return null;
1:4a47630:   }
1:4a47630: 
1:9db662a:   /**
1:2018048:    * Get all datamaps of the table for clearing purpose
1:2018048:    */
1:2018048:   public DataMapExprWrapper getAllDataMapsForClear(CarbonTable carbonTable)
1:2018048:       throws IOException {
1:2018048:     List<TableDataMap> allDataMapFG =
1:2018048:         DataMapStoreManager.getInstance().getAllDataMap(carbonTable);
1:2018048:     DataMapExprWrapper initialExpr = null;
1:2018048:     if (allDataMapFG.size() > 0) {
1:2018048:       initialExpr = new DataMapExprWrapperImpl(allDataMapFG.get(0), null);
1:2018048: 
1:2018048:       for (int i = 1; i < allDataMapFG.size(); i++) {
1:2018048:         initialExpr = new AndDataMapExprWrapper(initialExpr,
1:2018048:             new DataMapExprWrapperImpl(allDataMapFG.get(i), null), null);
1:2018048:       }
1:2018048:     }
1:2018048:     return initialExpr;
1:2018048:   }
1:2018048: 
1:2018048:   /**
1:4a47630:    * Returns default blocklet datamap
1:4a47630:    * @param carbonTable
1:4a47630:    * @param resolverIntf
1:4a47630:    * @return
1:4a47630:    */
1:747be9b:   public static DataMapExprWrapper getDefaultDataMap(CarbonTable carbonTable,
1:4a47630:       FilterResolverIntf resolverIntf) {
1:4a47630:     // Return the default datamap if no other datamap exists.
1:4a47630:     return new DataMapExprWrapperImpl(
1:4a47630:         DataMapStoreManager.getInstance().getDefaultDataMap(carbonTable), resolverIntf);
1:4a47630:   }
1:4a47630: 
1:9ee74fe:   private ExpressionTuple selectDataMap(Expression expression, List<TableDataMap> allDataMap,
1:9ee74fe:       FilterResolverIntf filterResolverIntf) {
1:56330ae:     switch (expression.getFilterExpressionType()) {
1:56330ae:       case AND:
1:56330ae:         if (expression instanceof AndExpression) {
1:56330ae:           AndExpression andExpression = (AndExpression) expression;
1:9ee74fe:           ExpressionTuple left = selectDataMap(andExpression.getLeft(), allDataMap,
1:9ee74fe:               filterResolverIntf.getLeft());
1:9ee74fe:           ExpressionTuple right = selectDataMap(andExpression.getRight(), allDataMap,
1:9ee74fe:               filterResolverIntf.getRight());
1:56330ae:           Set<ExpressionType> filterExpressionTypes = new HashSet<>();
1:56330ae:           // If both left and right has datamap then we can either merge both datamaps to single
1:56330ae:           // datamap if possible. Otherwise apply AND expression.
1:56330ae:           if (left.dataMapExprWrapper != null && right.dataMapExprWrapper != null) {
1:56330ae:             filterExpressionTypes.add(
1:56330ae:                 left.dataMapExprWrapper.getFilterResolverIntf().getFilterExpression()
1:56330ae:                     .getFilterExpressionType());
1:56330ae:             filterExpressionTypes.add(
1:56330ae:                 right.dataMapExprWrapper.getFilterResolverIntf().getFilterExpression()
1:56330ae:                     .getFilterExpressionType());
1:56330ae:             List<ColumnExpression> columnExpressions = new ArrayList<>();
1:56330ae:             columnExpressions.addAll(left.columnExpressions);
1:56330ae:             columnExpressions.addAll(right.columnExpressions);
1:56330ae:             // Check if we can merge them to single datamap.
1:56330ae:             TableDataMap dataMap =
1:56330ae:                 chooseDataMap(allDataMap, columnExpressions, filterExpressionTypes);
1:56330ae:             if (dataMap != null) {
1:56330ae:               ExpressionTuple tuple = new ExpressionTuple();
1:56330ae:               tuple.columnExpressions = columnExpressions;
1:9ee74fe:               tuple.dataMapExprWrapper = new DataMapExprWrapperImpl(dataMap, filterResolverIntf);
1:56330ae:               return tuple;
1:56330ae:             } else {
1:56330ae:               // Apply AND expression.
1:56330ae:               ExpressionTuple tuple = new ExpressionTuple();
1:56330ae:               tuple.columnExpressions = columnExpressions;
1:9ee74fe:               tuple.dataMapExprWrapper = new AndDataMapExprWrapper(left.dataMapExprWrapper,
1:9ee74fe:                   right.dataMapExprWrapper, filterResolverIntf);
1:56330ae:               return tuple;
1:56330ae:             }
1:56330ae:           } else if (left.dataMapExprWrapper != null && right.dataMapExprWrapper == null) {
1:56330ae:             return left;
1:56330ae:           } else if (left.dataMapExprWrapper == null && right.dataMapExprWrapper != null) {
1:56330ae:             return right;
1:56330ae:           } else {
1:56330ae:             return left;
1:56330ae:           }
1:56330ae:         }
1:56330ae:         break;
1:56330ae:       case OR:
1:56330ae:         if (expression instanceof OrExpression) {
1:56330ae:           OrExpression orExpression = (OrExpression) expression;
1:9ee74fe:           ExpressionTuple left = selectDataMap(orExpression.getLeft(), allDataMap,
1:9ee74fe:               filterResolverIntf.getLeft());
1:9ee74fe:           ExpressionTuple right = selectDataMap(orExpression.getRight(), allDataMap,
1:9ee74fe:               filterResolverIntf.getRight());
1:56330ae:           Set<ExpressionType> filterExpressionTypes = new HashSet<>();
1:56330ae:           // If both left and right has datamap then we can either merge both datamaps to single
1:56330ae:           // datamap if possible. Otherwise apply OR expression.
1:56330ae:           if (left.dataMapExprWrapper != null && right.dataMapExprWrapper != null) {
1:56330ae:             filterExpressionTypes.add(
1:56330ae:                 left.dataMapExprWrapper.getFilterResolverIntf().getFilterExpression()
1:56330ae:                     .getFilterExpressionType());
1:56330ae:             filterExpressionTypes.add(
1:56330ae:                 right.dataMapExprWrapper.getFilterResolverIntf().getFilterExpression()
1:56330ae:                     .getFilterExpressionType());
1:56330ae:             List<ColumnExpression> columnExpressions = new ArrayList<>();
1:56330ae:             columnExpressions.addAll(left.columnExpressions);
1:56330ae:             columnExpressions.addAll(right.columnExpressions);
1:56330ae:             TableDataMap dataMap =
1:56330ae:                 chooseDataMap(allDataMap, columnExpressions, filterExpressionTypes);
1:56330ae:             if (dataMap != null) {
1:56330ae:               ExpressionTuple tuple = new ExpressionTuple();
1:56330ae:               tuple.columnExpressions = columnExpressions;
1:9ee74fe:               tuple.dataMapExprWrapper = new DataMapExprWrapperImpl(dataMap, filterResolverIntf);
1:56330ae:               return tuple;
1:56330ae:             } else {
1:56330ae:               ExpressionTuple tuple = new ExpressionTuple();
1:56330ae:               tuple.columnExpressions = columnExpressions;
1:9ee74fe:               tuple.dataMapExprWrapper = new OrDataMapExprWrapper(left.dataMapExprWrapper,
1:9ee74fe:                   right.dataMapExprWrapper, filterResolverIntf);
1:56330ae:               return tuple;
1:56330ae:             }
1:56330ae:           } else {
1:56330ae:             left.dataMapExprWrapper = null;
1:56330ae:             return left;
1:56330ae:           }
1:56330ae:         }
1:56330ae:         break;
1:56330ae:       default:
1:56330ae:         ExpressionTuple tuple = new ExpressionTuple();
1:56330ae:         extractColumnExpression(expression, tuple.columnExpressions);
1:56330ae:         Set<ExpressionType> filterExpressionTypes = new HashSet<>();
1:56330ae:         filterExpressionTypes.add(expression.getFilterExpressionType());
1:56330ae:         TableDataMap dataMap =
1:56330ae:             chooseDataMap(allDataMap, tuple.columnExpressions, filterExpressionTypes);
1:56330ae:         if (dataMap != null) {
1:9ee74fe:           tuple.dataMapExprWrapper = new DataMapExprWrapperImpl(dataMap, filterResolverIntf);
1:56330ae:         }
1:56330ae:         return tuple;
1:56330ae:     }
1:56330ae:     return new ExpressionTuple();
1:56330ae:   }
1:56330ae: 
1:56330ae:   private void extractColumnExpression(Expression expression,
1:56330ae:       List<ColumnExpression> columnExpressions) {
1:56330ae:     if (expression instanceof ColumnExpression) {
1:56330ae:       columnExpressions.add((ColumnExpression) expression);
1:46f0c85:     } else if (expression instanceof MatchExpression) {
1:46f0c85:       // this is a special case for lucene
1:46f0c85:       // build a fake ColumnExpression to filter datamaps which contain target column
1:46f0c85:       // a Lucene query string is alike "column:query term"
1:46f0c85:       String[] queryItems = expression.getString().split(":", 2);
1:46f0c85:       if (queryItems.length == 2) {
1:46f0c85:         columnExpressions.add(new ColumnExpression(queryItems[0], null));
1:46f0c85:       }
1:56330ae:     } else if (expression != null) {
1:56330ae:       List<Expression> children = expression.getChildren();
1:56330ae:       if (children != null && children.size() > 0) {
1:56330ae:         for (Expression exp : children) {
1:56330ae:           extractColumnExpression(exp, columnExpressions);
1:56330ae:         }
1:56330ae:       }
1:56330ae:     }
1:56330ae:   }
1:56330ae: 
1:56330ae:   private TableDataMap chooseDataMap(List<TableDataMap> allDataMap,
1:56330ae:       List<ColumnExpression> columnExpressions, Set<ExpressionType> expressionTypes) {
1:56330ae:     List<DataMapTuple> tuples = new ArrayList<>();
1:56330ae:     for (TableDataMap dataMap : allDataMap) {
1:7ef9164:       if (null != dataMap.getDataMapFactory().getMeta() && contains(
1:7ef9164:           dataMap.getDataMapFactory().getMeta(), columnExpressions, expressionTypes)) {
1:56330ae:         tuples.add(
1:fc2a7eb:             new DataMapTuple(dataMap.getDataMapFactory().getMeta().getIndexedColumns().size(),
1:56330ae:                 dataMap));
1:56330ae:       }
1:56330ae:     }
1:56330ae:     if (tuples.size() > 0) {
1:56330ae:       Collections.sort(tuples);
1:56330ae:       return tuples.get(0).dataMap;
1:56330ae:     }
1:4a47630:     return null;
1:56330ae:   }
1:56330ae: 
1:56330ae:   /**
1:9db662a:    * Return true if the input datamap contains the column that needed in
1:9db662a:    * specified expression
1:9db662a:    */
1:56330ae:   private boolean contains(DataMapMeta mapMeta, List<ColumnExpression> columnExpressions,
1:56330ae:       Set<ExpressionType> expressionTypes) {
1:56330ae:     if (mapMeta.getIndexedColumns().size() == 0 || columnExpressions.size() == 0) {
1:56330ae:       return false;
1:56330ae:     }
1:56330ae:     boolean contains = true;
1:56330ae:     for (ColumnExpression expression : columnExpressions) {
1:9db662a:       if (!mapMeta.getIndexedColumnNames().contains(expression.getColumnName()) ||
1:9db662a:           !mapMeta.getOptimizedOperation().containsAll(expressionTypes)) {
1:56330ae:         contains = false;
1:56330ae:         break;
1:56330ae:       }
1:56330ae:     }
1:56330ae:     return contains;
1:56330ae:   }
1:56330ae: 
1:56330ae:   private static class ExpressionTuple {
1:56330ae: 
1:56330ae:     DataMapExprWrapper dataMapExprWrapper;
1:56330ae: 
1:56330ae:     List<ColumnExpression> columnExpressions = new ArrayList<>();
1:56330ae: 
1:56330ae:   }
1:56330ae: 
1:56330ae:   private static class DataMapTuple implements Comparable<DataMapTuple> {
1:56330ae: 
1:56330ae:     int order;
1:56330ae: 
1:56330ae:     TableDataMap dataMap;
1:56330ae: 
1:56330ae:     public DataMapTuple(int order, TableDataMap dataMap) {
1:56330ae:       this.order = order;
1:56330ae:       this.dataMap = dataMap;
1:56330ae:     }
1:56330ae: 
1:56330ae:     @Override public int compareTo(DataMapTuple o) {
1:56330ae:       return order - o.order;
1:56330ae:     }
1:56330ae: 
1:56330ae:     @Override public boolean equals(Object o) {
1:56330ae:       if (this == o) return true;
1:56330ae:       if (o == null || getClass() != o.getClass()) return false;
1:56330ae: 
1:56330ae:       DataMapTuple that = (DataMapTuple) o;
1:56330ae: 
1:56330ae:       if (order != that.order) return false;
1:56330ae:       return dataMap != null ? dataMap.equals(that.dataMap) : that.dataMap == null;
1:56330ae:     }
1:56330ae: 
1:56330ae:     @Override public int hashCode() {
1:56330ae:       int result = order;
1:56330ae:       result = 31 * result + (dataMap != null ? dataMap.hashCode() : 0);
1:56330ae:       return result;
1:56330ae:     }
1:56330ae:   }
1:56330ae: 
1:56330ae: }
============================================================================
author:Manhua
-------------------------------------------------------------------------------
commit:46f0c85
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.expression.MatchExpression;
/////////////////////////////////////////////////////////////////////////
1:     } else if (expression instanceof MatchExpression) {
1:       // this is a special case for lucene
1:       // build a fake ColumnExpression to filter datamaps which contain target column
1:       // a Lucene query string is alike "column:query term"
1:       String[] queryItems = expression.getString().split(":", 2);
1:       if (queryItems.length == 2) {
1:         columnExpressions.add(new ColumnExpression(queryItems[0], null));
1:       }
/////////////////////////////////////////////////////////////////////////
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1:       if (null != dataMap.getDataMapFactory().getMeta() && contains(
1:           dataMap.getDataMapFactory().getMeta(), columnExpressions, expressionTypes)) {
author:akashrn5
-------------------------------------------------------------------------------
commit:2018048
/////////////////////////////////////////////////////////////////////////
1:    * Get all datamaps of the table for clearing purpose
1:    */
1:   public DataMapExprWrapper getAllDataMapsForClear(CarbonTable carbonTable)
1:       throws IOException {
1:     List<TableDataMap> allDataMapFG =
1:         DataMapStoreManager.getInstance().getAllDataMap(carbonTable);
1:     DataMapExprWrapper initialExpr = null;
1:     if (allDataMapFG.size() > 0) {
1:       initialExpr = new DataMapExprWrapperImpl(allDataMapFG.get(0), null);
1: 
1:       for (int i = 1; i < allDataMapFG.size(); i++) {
1:         initialExpr = new AndDataMapExprWrapper(initialExpr,
1:             new DataMapExprWrapperImpl(allDataMapFG.get(i), null), null);
1:       }
1:     }
1:     return initialExpr;
1:   }
1: 
1:   /**
author:Jacky Li
-------------------------------------------------------------------------------
commit:747be9b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datamap.status.DataMapStatusDetail;
1: import org.apache.carbondata.core.datamap.status.DataMapStatusManager;
/////////////////////////////////////////////////////////////////////////
1:   private CarbonTable carbonTable;
1:   private List<TableDataMap> cgDataMaps;
1:   private List<TableDataMap> fgDataMaps;
1:   public DataMapChooser(CarbonTable carbonTable) throws IOException {
1:     this.carbonTable = carbonTable;
1:     // read all datamaps for this table and populate CG and FG datamap list
1:     List<TableDataMap> visibleDataMaps =
1:         DataMapStoreManager.getInstance().getAllVisibleDataMap(carbonTable);
1:     Map<String, DataMapStatusDetail> map = DataMapStatusManager.readDataMapStatusMap();
1:     cgDataMaps = new ArrayList<>(visibleDataMaps.size());
1:     fgDataMaps = new ArrayList<>(visibleDataMaps.size());
1:     for (TableDataMap visibleDataMap : visibleDataMaps) {
1:       DataMapStatusDetail status = map.get(visibleDataMap.getDataMapSchema().getDataMapName());
1:       if (status != null && status.isEnabled()) {
1:         DataMapLevel level = visibleDataMap.getDataMapFactory().getDataMapLevel();
1:         if (level == DataMapLevel.CG) {
1:           cgDataMaps.add(visibleDataMap);
1:         } else {
1:           fgDataMaps.add(visibleDataMap);
1:         }
1:       }
1:   public DataMapExprWrapper choose(FilterResolverIntf filter) {
1:       ExpressionTuple tuple = selectDataMap(expression, fgDataMaps, filter);
1:         tuple = selectDataMap(expression, cgDataMaps, filter);
/////////////////////////////////////////////////////////////////////////
1:   public DataMapExprWrapper chooseFGDataMap(FilterResolverIntf resolverIntf) {
1:     return chooseDataMap(DataMapLevel.FG, resolverIntf);
1:   public DataMapExprWrapper chooseCGDataMap(FilterResolverIntf resolverIntf) {
1:     return chooseDataMap(DataMapLevel.CG, resolverIntf);
1:   }
1: 
1:   private DataMapExprWrapper chooseDataMap(DataMapLevel level, FilterResolverIntf resolverIntf) {
1:       List<TableDataMap> datamaps = level == DataMapLevel.CG ? cgDataMaps : fgDataMaps;
1:       ExpressionTuple tuple = selectDataMap(expression, datamaps, resolverIntf);
/////////////////////////////////////////////////////////////////////////
1:   public static DataMapExprWrapper getDefaultDataMap(CarbonTable carbonTable,
commit:9db662a
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Return true if the input datamap contains the column that needed in
1:    * specified expression
1:    */
/////////////////////////////////////////////////////////////////////////
1:       if (!mapMeta.getIndexedColumnNames().contains(expression.getColumnName()) ||
1:           !mapMeta.getOptimizedOperation().containsAll(expressionTypes)) {
commit:03a735b
/////////////////////////////////////////////////////////////////////////
0: import java.util.Objects;
/////////////////////////////////////////////////////////////////////////
0:   public DataMapExprWrapper choose(CarbonTable carbonTable, FilterResolverIntf filter)
0:     Objects.requireNonNull(carbonTable);
1:     if (filter != null) {
1:       Expression expression = filter.getFilterExpression();
0:       ExpressionTuple tuple = selectDataMap(expression, allDataMapFG, filter);
0:         tuple = selectDataMap(expression, allDataMapCG, filter);
/////////////////////////////////////////////////////////////////////////
1:         DataMapStoreManager.getInstance().getDefaultDataMap(carbonTable), filter);
commit:7e0803f
/////////////////////////////////////////////////////////////////////////
1:     return new DataMapExprWrapperImpl(
0:         DataMapStoreManager.getInstance().getDefaultDataMap(carbonTable),
0:         resolverIntf);
commit:bbb1092
/////////////////////////////////////////////////////////////////////////
0:     if (mapMeta.getOptimizedOperation().contains(ExpressionType.TEXT_MATCH)) {
0:       // TODO: fix it with right logic
0:       return true;
1:     }
commit:fc2a7eb
/////////////////////////////////////////////////////////////////////////
0:           DataMapStoreManager.getInstance().getAllDataMap(carbonTable, DataMapLevel.FG);
0:             DataMapStoreManager.getInstance().getAllDataMap(carbonTable, DataMapLevel.CG);
/////////////////////////////////////////////////////////////////////////
0:       if (contains(dataMap.getDataMapFactory().getMeta(), columnExpressions, expressionTypes))
1:             new DataMapTuple(dataMap.getDataMapFactory().getMeta().getIndexedColumns().size(),
commit:89a12af
/////////////////////////////////////////////////////////////////////////
0:       if (contains(dataMap.getIndexDataMapFactory().getMeta(), columnExpressions, expressionTypes))
0:       {
0:             new DataMapTuple(dataMap.getIndexDataMapFactory().getMeta().getIndexedColumns().size(),
author:xuchuanyin
-------------------------------------------------------------------------------
commit:b08ef00
/////////////////////////////////////////////////////////////////////////
0:           DataMapStoreManager.getInstance().getAllVisibleDataMap(carbonTable, DataMapLevel.FG);
0:             DataMapStoreManager.getInstance().getAllVisibleDataMap(carbonTable, DataMapLevel.CG);
/////////////////////////////////////////////////////////////////////////
0:           DataMapStoreManager.getInstance().getAllVisibleDataMap(carbonTable, DataMapLevel.FG);
/////////////////////////////////////////////////////////////////////////
0:           DataMapStoreManager.getInstance().getAllVisibleDataMap(carbonTable, DataMapLevel.CG);
commit:9ee74fe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       ExpressionTuple tuple = selectDataMap(expression, allDataMapFG, resolverIntf);
0:         tuple = selectDataMap(expression, allDataMapCG, resolverIntf);
/////////////////////////////////////////////////////////////////////////
1:   private ExpressionTuple selectDataMap(Expression expression, List<TableDataMap> allDataMap,
1:       FilterResolverIntf filterResolverIntf) {
1:           ExpressionTuple left = selectDataMap(andExpression.getLeft(), allDataMap,
1:               filterResolverIntf.getLeft());
1:           ExpressionTuple right = selectDataMap(andExpression.getRight(), allDataMap,
1:               filterResolverIntf.getRight());
/////////////////////////////////////////////////////////////////////////
1:               tuple.dataMapExprWrapper = new DataMapExprWrapperImpl(dataMap, filterResolverIntf);
1:               tuple.dataMapExprWrapper = new AndDataMapExprWrapper(left.dataMapExprWrapper,
1:                   right.dataMapExprWrapper, filterResolverIntf);
/////////////////////////////////////////////////////////////////////////
1:           ExpressionTuple left = selectDataMap(orExpression.getLeft(), allDataMap,
1:               filterResolverIntf.getLeft());
1:           ExpressionTuple right = selectDataMap(orExpression.getRight(), allDataMap,
1:               filterResolverIntf.getRight());
/////////////////////////////////////////////////////////////////////////
1:               tuple.dataMapExprWrapper = new DataMapExprWrapperImpl(dataMap, filterResolverIntf);
1:               tuple.dataMapExprWrapper = new OrDataMapExprWrapper(left.dataMapExprWrapper,
1:                   right.dataMapExprWrapper, filterResolverIntf);
/////////////////////////////////////////////////////////////////////////
1:           tuple.dataMapExprWrapper = new DataMapExprWrapperImpl(dataMap, filterResolverIntf);
author:ravipesala
-------------------------------------------------------------------------------
commit:4a47630
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Return a chosen FG datamap based on input filter. See {@link DataMapChooser}
1:    */
0:   public DataMapExprWrapper chooseFGDataMap(CarbonTable carbonTable,
0:       FilterResolverIntf resolverIntf) throws IOException {
1:     if (resolverIntf != null) {
1:       Expression expression = resolverIntf.getFilterExpression();
1:       // First check for FG datamaps if any exist
0:       List<TableDataMap> allDataMapFG =
0:           DataMapStoreManager.getInstance().getAllDataMap(carbonTable, DataMapLevel.FG);
0:       ExpressionTuple tuple = selectDataMap(expression, allDataMapFG, resolverIntf);
1:       if (tuple.dataMapExprWrapper != null) {
1:         return tuple.dataMapExprWrapper;
1:       }
1:     }
1:     // Return the default datamap if no other datamap exists.
1:     return null;
1:   }
1: 
1:   /**
1:    * Return a chosen CG datamap based on input filter. See {@link DataMapChooser}
1:    */
0:   public DataMapExprWrapper chooseCGDataMap(CarbonTable carbonTable,
0:       FilterResolverIntf resolverIntf) throws IOException {
1:     if (resolverIntf != null) {
1:       Expression expression = resolverIntf.getFilterExpression();
1:       // Check for CG datamap
0:       List<TableDataMap> allDataMapCG =
0:           DataMapStoreManager.getInstance().getAllDataMap(carbonTable, DataMapLevel.CG);
0:       ExpressionTuple tuple = selectDataMap(expression, allDataMapCG, resolverIntf);
1:       if (tuple.dataMapExprWrapper != null) {
1:         return tuple.dataMapExprWrapper;
1:       }
1:     }
1:     return null;
1:   }
1: 
1:   /**
1:    * Returns default blocklet datamap
1:    * @param carbonTable
1:    * @param resolverIntf
1:    * @return
1:    */
0:   public DataMapExprWrapper getDefaultDataMap(CarbonTable carbonTable,
1:       FilterResolverIntf resolverIntf) {
1:     // Return the default datamap if no other datamap exists.
1:     return new DataMapExprWrapperImpl(
1:         DataMapStoreManager.getInstance().getDefaultDataMap(carbonTable), resolverIntf);
1:   }
1: 
commit:5f2a748
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:   public DataMapExprWrapper choose(CarbonTable carbonTable, FilterResolverIntf resolverIntf)
0:       throws IOException {
commit:5eb476f
/////////////////////////////////////////////////////////////////////////
0:     if (mapMeta.getOptimizedOperation().contains(ExpressionType.TEXT_MATCH) &&
0:         expressionTypes.contains(ExpressionType.TEXT_MATCH)) {
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:56330ae
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.carbondata.core.datamap;
1: 
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Set;
1: 
1: import org.apache.carbondata.common.annotations.InterfaceAudience;
1: import org.apache.carbondata.core.datamap.dev.expr.AndDataMapExprWrapper;
1: import org.apache.carbondata.core.datamap.dev.expr.DataMapExprWrapper;
1: import org.apache.carbondata.core.datamap.dev.expr.DataMapExprWrapperImpl;
1: import org.apache.carbondata.core.datamap.dev.expr.OrDataMapExprWrapper;
1: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1: import org.apache.carbondata.core.scan.expression.ColumnExpression;
1: import org.apache.carbondata.core.scan.expression.Expression;
1: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1: import org.apache.carbondata.core.scan.filter.intf.ExpressionType;
1: import org.apache.carbondata.core.scan.filter.resolver.FilterResolverIntf;
0: import org.apache.carbondata.core.scan.filter.resolver.resolverinfo.TrueConditionalResolverImpl;
1: 
1: /**
1:  * This chooser does 2 jobs.
1:  * 1. Based on filter expression it converts the available datamaps to datamap expression.
1:  *   For example, there are 2 datamaps available on table1
1:  *   Datamap1 : column1
1:  *   Datamap2 : column2
1:  *   Query: select * from table1 where column1 ='a' and column2 =b
1:  *   For the above query, we create datamap expression as AndDataMapExpression(Datamap1, DataMap2).
1:  *   So for the above query both the datamaps are included and the output of them will be
1:  *   applied AND condition to improve the performance
1:  *
1:  * 2. It chooses the datamap out of available datamaps based on simple logic.
1:  *   Like if there is filter condition on column1 then for
1:  *   supposing 2 datamaps(1. column1 2. column1+column2) are supporting this column then we choose
1:  *   the datamap which has fewer columns that is the first datamap.
1:  */
1: @InterfaceAudience.Internal
1: public class DataMapChooser {
1: 
0:   private static DataMapChooser INSTANCE;
1: 
0:   private DataMapChooser() { }
1: 
0:   public static DataMapChooser get() {
0:     if (INSTANCE == null) {
0:       INSTANCE = new DataMapChooser();
1:     }
0:     return INSTANCE;
1:   }
1: 
1:   /**
1:    * Return a chosen datamap based on input filter. See {@link DataMapChooser}
1:    */
0:   public DataMapExprWrapper choose(CarbonTable carbonTable, FilterResolverIntf resolverIntf) {
0:     if (resolverIntf != null) {
0:       Expression expression = resolverIntf.getFilterExpression();
0:       // First check for FG datamaps if any exist
0:       List<TableDataMap> allDataMapFG =
0:           DataMapStoreManager.getInstance().getAllDataMap(carbonTable, DataMapType.FG);
0:       ExpressionTuple tuple = selectDataMap(expression, allDataMapFG);
1:       if (tuple.dataMapExprWrapper == null) {
0:         // Check for CG datamap
0:         List<TableDataMap> allDataMapCG =
0:             DataMapStoreManager.getInstance().getAllDataMap(carbonTable, DataMapType.CG);
0:         tuple = selectDataMap(expression, allDataMapCG);
1:       }
0:       if (tuple.dataMapExprWrapper != null) {
0:         return tuple.dataMapExprWrapper;
1:       }
1:     }
0:     // Return the default datamap if no other datamap exists.
0:     return new DataMapExprWrapperImpl(DataMapStoreManager.getInstance()
0:         .getDefaultDataMap(carbonTable.getAbsoluteTableIdentifier()), resolverIntf);
1:   }
1: 
0:   private ExpressionTuple selectDataMap(Expression expression, List<TableDataMap> allDataMap) {
1:     switch (expression.getFilterExpressionType()) {
1:       case AND:
1:         if (expression instanceof AndExpression) {
1:           AndExpression andExpression = (AndExpression) expression;
0:           ExpressionTuple left = selectDataMap(andExpression.getLeft(), allDataMap);
0:           ExpressionTuple right = selectDataMap(andExpression.getRight(), allDataMap);
1:           Set<ExpressionType> filterExpressionTypes = new HashSet<>();
1:           // If both left and right has datamap then we can either merge both datamaps to single
1:           // datamap if possible. Otherwise apply AND expression.
1:           if (left.dataMapExprWrapper != null && right.dataMapExprWrapper != null) {
1:             filterExpressionTypes.add(
1:                 left.dataMapExprWrapper.getFilterResolverIntf().getFilterExpression()
1:                     .getFilterExpressionType());
1:             filterExpressionTypes.add(
1:                 right.dataMapExprWrapper.getFilterResolverIntf().getFilterExpression()
1:                     .getFilterExpressionType());
1:             List<ColumnExpression> columnExpressions = new ArrayList<>();
1:             columnExpressions.addAll(left.columnExpressions);
1:             columnExpressions.addAll(right.columnExpressions);
1:             // Check if we can merge them to single datamap.
1:             TableDataMap dataMap =
1:                 chooseDataMap(allDataMap, columnExpressions, filterExpressionTypes);
1:             if (dataMap != null) {
1:               ExpressionTuple tuple = new ExpressionTuple();
1:               tuple.columnExpressions = columnExpressions;
0:               tuple.dataMapExprWrapper = new DataMapExprWrapperImpl(dataMap,
0:                   new TrueConditionalResolverImpl(expression, false, false));
1:               return tuple;
1:             } else {
1:               // Apply AND expression.
1:               ExpressionTuple tuple = new ExpressionTuple();
1:               tuple.columnExpressions = columnExpressions;
0:               tuple.dataMapExprWrapper =
0:                   new AndDataMapExprWrapper(left.dataMapExprWrapper, right.dataMapExprWrapper,
0:                       new TrueConditionalResolverImpl(expression, false, false));
1:               return tuple;
1:             }
1:           } else if (left.dataMapExprWrapper != null && right.dataMapExprWrapper == null) {
1:             return left;
1:           } else if (left.dataMapExprWrapper == null && right.dataMapExprWrapper != null) {
1:             return right;
1:           } else {
1:             return left;
1:           }
1:         }
1:         break;
1:       case OR:
1:         if (expression instanceof OrExpression) {
1:           OrExpression orExpression = (OrExpression) expression;
0:           ExpressionTuple left = selectDataMap(orExpression.getLeft(), allDataMap);
0:           ExpressionTuple right = selectDataMap(orExpression.getRight(), allDataMap);
1:           Set<ExpressionType> filterExpressionTypes = new HashSet<>();
1:           // If both left and right has datamap then we can either merge both datamaps to single
1:           // datamap if possible. Otherwise apply OR expression.
1:           if (left.dataMapExprWrapper != null && right.dataMapExprWrapper != null) {
1:             filterExpressionTypes.add(
1:                 left.dataMapExprWrapper.getFilterResolverIntf().getFilterExpression()
1:                     .getFilterExpressionType());
1:             filterExpressionTypes.add(
1:                 right.dataMapExprWrapper.getFilterResolverIntf().getFilterExpression()
1:                     .getFilterExpressionType());
1:             List<ColumnExpression> columnExpressions = new ArrayList<>();
1:             columnExpressions.addAll(left.columnExpressions);
1:             columnExpressions.addAll(right.columnExpressions);
1:             TableDataMap dataMap =
1:                 chooseDataMap(allDataMap, columnExpressions, filterExpressionTypes);
1:             if (dataMap != null) {
1:               ExpressionTuple tuple = new ExpressionTuple();
1:               tuple.columnExpressions = columnExpressions;
0:               tuple.dataMapExprWrapper = new DataMapExprWrapperImpl(dataMap,
0:                   new TrueConditionalResolverImpl(expression, false, false));
1:               return tuple;
1:             } else {
1:               ExpressionTuple tuple = new ExpressionTuple();
1:               tuple.columnExpressions = columnExpressions;
0:               tuple.dataMapExprWrapper =
0:                   new OrDataMapExprWrapper(left.dataMapExprWrapper, right.dataMapExprWrapper,
0:                       new TrueConditionalResolverImpl(expression, false, false));
1:               return tuple;
1:             }
1:           } else {
1:             left.dataMapExprWrapper = null;
1:             return left;
1:           }
1:         }
1:         break;
1:       default:
1:         ExpressionTuple tuple = new ExpressionTuple();
1:         extractColumnExpression(expression, tuple.columnExpressions);
1:         Set<ExpressionType> filterExpressionTypes = new HashSet<>();
1:         filterExpressionTypes.add(expression.getFilterExpressionType());
1:         TableDataMap dataMap =
1:             chooseDataMap(allDataMap, tuple.columnExpressions, filterExpressionTypes);
1:         if (dataMap != null) {
0:           tuple.dataMapExprWrapper = new DataMapExprWrapperImpl(dataMap,
0:               new TrueConditionalResolverImpl(expression, false, false));
1:         }
1:         return tuple;
1:     }
1:     return new ExpressionTuple();
1:   }
1: 
1:   private void extractColumnExpression(Expression expression,
1:       List<ColumnExpression> columnExpressions) {
1:     if (expression instanceof ColumnExpression) {
1:       columnExpressions.add((ColumnExpression) expression);
1:     } else if (expression != null) {
1:       List<Expression> children = expression.getChildren();
1:       if (children != null && children.size() > 0) {
1:         for (Expression exp : children) {
1:           extractColumnExpression(exp, columnExpressions);
1:         }
1:       }
1:     }
1:   }
1: 
1:   private TableDataMap chooseDataMap(List<TableDataMap> allDataMap,
1:       List<ColumnExpression> columnExpressions, Set<ExpressionType> expressionTypes) {
1:     List<DataMapTuple> tuples = new ArrayList<>();
1:     for (TableDataMap dataMap : allDataMap) {
0:       if (contains(dataMap.getDataMapFactory().getMeta(), columnExpressions, expressionTypes)) {
1:         tuples.add(
0:             new DataMapTuple(dataMap.getDataMapFactory().getMeta().getIndexedColumns().size(),
1:                 dataMap));
1:       }
1:     }
1:     if (tuples.size() > 0) {
1:       Collections.sort(tuples);
1:       return tuples.get(0).dataMap;
1:     }
0:     return null;
1:   }
1: 
1:   private boolean contains(DataMapMeta mapMeta, List<ColumnExpression> columnExpressions,
1:       Set<ExpressionType> expressionTypes) {
1:     if (mapMeta.getIndexedColumns().size() == 0 || columnExpressions.size() == 0) {
1:       return false;
1:     }
1:     boolean contains = true;
1:     for (ColumnExpression expression : columnExpressions) {
0:       if (!mapMeta.getIndexedColumns().contains(expression.getColumnName()) || !mapMeta
0:           .getOptimizedOperation().containsAll(expressionTypes)) {
1:         contains = false;
1:         break;
1:       }
1:     }
1:     return contains;
1:   }
1: 
1:   private static class ExpressionTuple {
1: 
1:     DataMapExprWrapper dataMapExprWrapper;
1: 
1:     List<ColumnExpression> columnExpressions = new ArrayList<>();
1: 
1:   }
1: 
1:   private static class DataMapTuple implements Comparable<DataMapTuple> {
1: 
1:     int order;
1: 
1:     TableDataMap dataMap;
1: 
1:     public DataMapTuple(int order, TableDataMap dataMap) {
1:       this.order = order;
1:       this.dataMap = dataMap;
1:     }
1: 
1:     @Override public int compareTo(DataMapTuple o) {
1:       return order - o.order;
1:     }
1: 
1:     @Override public boolean equals(Object o) {
1:       if (this == o) return true;
1:       if (o == null || getClass() != o.getClass()) return false;
1: 
1:       DataMapTuple that = (DataMapTuple) o;
1: 
1:       if (order != that.order) return false;
1:       return dataMap != null ? dataMap.equals(that.dataMap) : that.dataMap == null;
1:     }
1: 
1:     @Override public int hashCode() {
1:       int result = order;
1:       result = 31 * result + (dataMap != null ? dataMap.hashCode() : 0);
1:       return result;
1:     }
1:   }
1: 
1: }
============================================================================