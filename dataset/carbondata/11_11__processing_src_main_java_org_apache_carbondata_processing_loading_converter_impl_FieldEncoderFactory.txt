1:d96f09a: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
1:d96f09a:  *
1:d96f09a:  *    http://www.apache.org/licenses/LICENSE-2.0
1:d96f09a:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
1:d96f09a:  */
1:349c59c: package org.apache.carbondata.processing.loading.converter.impl;
1:d96f09a: 
1:eaadc88: import java.io.IOException;
1:496cde4: import java.util.List;
1:87dade7: import java.util.Map;
1:496cde4: 
1:d96f09a: import org.apache.carbondata.core.cache.dictionary.DictionaryColumnUniqueIdentifier;
1:05b2654: import org.apache.carbondata.core.dictionary.client.DictionaryClient;
1:1155d4d: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1:ce09aaa: import org.apache.carbondata.core.metadata.CarbonTableIdentifier;
1:cc0e6f1: import org.apache.carbondata.core.metadata.ColumnIdentifier;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataType;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:ce09aaa: import org.apache.carbondata.core.metadata.encoder.Encoding;
1:cc0e6f1: import org.apache.carbondata.core.metadata.schema.table.RelationIdentifier;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:cc0e6f1: import org.apache.carbondata.core.metadata.schema.table.column.ParentColumnTableRelation;
1:496cde4: import org.apache.carbondata.processing.datatypes.ArrayDataType;
1:f089287: import org.apache.carbondata.processing.datatypes.GenericDataType;
1:496cde4: import org.apache.carbondata.processing.datatypes.PrimitiveDataType;
1:496cde4: import org.apache.carbondata.processing.datatypes.StructDataType;
1:349c59c: import org.apache.carbondata.processing.loading.DataField;
1:349c59c: import org.apache.carbondata.processing.loading.converter.FieldConverter;
1:d96f09a: 
1:d96f09a: public class FieldEncoderFactory {
1:d96f09a: 
1:d96f09a:   private static FieldEncoderFactory instance;
1:d96f09a: 
1:d96f09a:   private FieldEncoderFactory() {
1:d96f09a: 
3:d96f09a:   }
1:d96f09a: 
1:d96f09a:   public static FieldEncoderFactory getInstance() {
1:d96f09a:     if (instance == null) {
1:d96f09a:       instance = new FieldEncoderFactory();
1:d96f09a:     }
1:d96f09a:     return instance;
1:d96f09a:   }
1:d96f09a: 
1:d96f09a:   /**
1:d96f09a:    * Creates the FieldConverter for all dimensions, for measures return null.
1:496cde4:    *
1:496cde4:    * @param dataField             column schema
1:1155d4d:    * @param absoluteTableIdentifier table identifier
1:496cde4:    * @param index                 index of column in the row.
1:3251c89:    * @param isEmptyBadRecord
1:d96f09a:    * @return
1:d96f09a:    */
1:d96f09a:   public FieldConverter createFieldEncoder(DataField dataField,
1:1155d4d:       AbsoluteTableIdentifier absoluteTableIdentifier, int index, String nullFormat,
1:ff5166e:       DictionaryClient client, Boolean useOnePass, Map<Object, Integer> localCache,
1:7a1d12a:       boolean isEmptyBadRecord, String parentTablePath) throws IOException {
1:d96f09a:     // Converters are only needed for dimensions and measures it return null.
1:353272e:     if (dataField.getColumn().isDimension()) {
1:496cde4:       if (dataField.getColumn().hasEncoding(Encoding.DIRECT_DICTIONARY) &&
1:496cde4:           !dataField.getColumn().isComplex()) {
1:3251c89:         return new DirectDictionaryFieldConverterImpl(dataField, nullFormat, index,
1:3251c89:             isEmptyBadRecord);
1:496cde4:       } else if (dataField.getColumn().hasEncoding(Encoding.DICTIONARY) &&
1:496cde4:           !dataField.getColumn().isComplex()) {
1:cc0e6f1:         DictionaryColumnUniqueIdentifier identifier = null;
1:cc0e6f1:         // if parent column table relation is not null then it's a child table
1:cc0e6f1:         // in case of child table it will use parent table dictionary
1:cc0e6f1:         if (null == dataField.getColumn().getColumnSchema().getParentColumnTableRelations()
1:cc0e6f1:             || dataField.getColumn().getColumnSchema().getParentColumnTableRelations().isEmpty()) {
1:1155d4d:           identifier = new DictionaryColumnUniqueIdentifier(absoluteTableIdentifier,
1:29dc302:               dataField.getColumn().getColumnIdentifier(), dataField.getColumn().getDataType());
1:cd7c210:           return new DictionaryFieldConverterImpl(dataField.getColumn(),
1:cd7c210:               absoluteTableIdentifier.getCarbonTableIdentifier().getTableId(),
1:1155d4d:               nullFormat, index, client, useOnePass, localCache, isEmptyBadRecord,
1:cc0e6f1:               identifier);
1:cc0e6f1:         } else {
1:cc0e6f1:           ParentColumnTableRelation parentColumnTableRelation =
1:cc0e6f1:               dataField.getColumn().getColumnSchema().getParentColumnTableRelations().get(0);
1:cc0e6f1:           RelationIdentifier relationIdentifier =
1:cc0e6f1:               parentColumnTableRelation
1:cc0e6f1:                   .getRelationIdentifier();
1:cc0e6f1:           CarbonTableIdentifier parentTableIdentifier =
1:cc0e6f1:               new CarbonTableIdentifier(relationIdentifier.getDatabaseName(),
1:cc0e6f1:                   relationIdentifier.getTableName(), relationIdentifier.getTableId());
1:cc0e6f1:           ColumnIdentifier parentColumnIdentifier =
1:cc0e6f1:               new ColumnIdentifier(parentColumnTableRelation.getColumnId(), null,
1:cc0e6f1:                   dataField.getColumn().getDataType());
1:2fe7758:           AbsoluteTableIdentifier parentAbsoluteTableIdentifier =
1:7a1d12a:               AbsoluteTableIdentifier.from(parentTablePath, parentTableIdentifier);
1:1155d4d:           identifier = new DictionaryColumnUniqueIdentifier(parentAbsoluteTableIdentifier,
1:29dc302:               parentColumnIdentifier, dataField.getColumn().getDataType());
1:cd7c210:           return new DictionaryFieldConverterImpl(dataField.getColumn(),
1:cd7c210:               parentAbsoluteTableIdentifier.getCarbonTableIdentifier().getTableId(),
1:1155d4d:               nullFormat, index, null, false, null, isEmptyBadRecord, identifier);
1:cc0e6f1:         }
1:d96f09a:       } else if (dataField.getColumn().isComplex()) {
1:496cde4:         return new ComplexFieldConverterImpl(
1:ff5166e:             createComplexDataType(dataField, absoluteTableIdentifier,
1:3202cf5:                 client, useOnePass, localCache, index, nullFormat, isEmptyBadRecord), index);
1:496cde4:       } else {
1:3251c89:         return new NonDictionaryFieldConverterImpl(dataField, nullFormat, index, isEmptyBadRecord);
1:496cde4:       }
1:d96f09a:     } else {
1:3251c89:       return new MeasureFieldConverterImpl(dataField, nullFormat, index, isEmptyBadRecord);
1:d96f09a:     }
1:d96f09a:   }
1:496cde4: 
1:496cde4:   /**
1:496cde4:    * Create parser for the carbon column.
1:496cde4:    */
1:ec33c11:   public static GenericDataType createComplexDataType(DataField dataField,
1:1155d4d:       AbsoluteTableIdentifier absoluteTableIdentifier, DictionaryClient client, Boolean useOnePass,
1:3202cf5:       Map<Object, Integer> localCache, int index, String nullFormat, Boolean isEmptyBadRecords) {
1:ff5166e:     return createComplexType(dataField.getColumn(), dataField.getColumn().getColName(),
1:3202cf5:         absoluteTableIdentifier, client, useOnePass, localCache, index, nullFormat,
1:3202cf5:         isEmptyBadRecords);
1:496cde4:   }
1:496cde4: 
1:496cde4:   /**
1:496cde4:    * This method may be called recursively if the carbon column is complex type.
1:496cde4:    *
1:496cde4:    * @return GenericDataType
1:496cde4:    */
1:3202cf5: 
1:496cde4:   private static GenericDataType createComplexType(CarbonColumn carbonColumn, String parentName,
1:1155d4d:       AbsoluteTableIdentifier absoluteTableIdentifier, DictionaryClient client, Boolean useOnePass,
1:3202cf5:       Map<Object, Integer> localCache, int index, String nullFormat, Boolean isEmptyBadRecords) {
1:956833e:     DataType dataType = carbonColumn.getDataType();
1:fb6dffe:     if (DataTypes.isArrayType(dataType) || DataTypes.isMapType(dataType)) {
1:956833e:       List<CarbonDimension> listOfChildDimensions =
1:956833e:           ((CarbonDimension) carbonColumn).getListOfChildDimensions();
1:956833e:       // Create array parser with complex delimiter
1:956833e:       ArrayDataType arrayDataType =
1:cfbf7b6:           new ArrayDataType(carbonColumn.getColName(), parentName, carbonColumn.getColumnId(),
1:cfbf7b6:               carbonColumn.hasEncoding(Encoding.DICTIONARY));
1:956833e:       for (CarbonDimension dimension : listOfChildDimensions) {
1:956833e:         arrayDataType.addChildren(
1:ff5166e:             createComplexType(dimension, carbonColumn.getColName(), absoluteTableIdentifier,
1:3202cf5:                 client, useOnePass, localCache, index, nullFormat, isEmptyBadRecords));
1:956833e:       }
1:956833e:       return arrayDataType;
1:933e30c:     } else if (DataTypes.isStructType(dataType)) {
1:956833e:       List<CarbonDimension> dimensions =
1:956833e:           ((CarbonDimension) carbonColumn).getListOfChildDimensions();
1:956833e:       // Create struct parser with complex delimiter
1:956833e:       StructDataType structDataType =
1:cfbf7b6:           new StructDataType(carbonColumn.getColName(), parentName, carbonColumn.getColumnId(),
1:cfbf7b6:               carbonColumn.hasEncoding(Encoding.DICTIONARY));
1:956833e:       for (CarbonDimension dimension : dimensions) {
1:956833e:         structDataType.addChildren(
1:ff5166e:             createComplexType(dimension, carbonColumn.getColName(), absoluteTableIdentifier,
1:3202cf5:                 client, useOnePass, localCache, index, nullFormat, isEmptyBadRecords));
1:956833e:       }
1:956833e:       return structDataType;
1:956833e:     } else {
1:3202cf5:       return new PrimitiveDataType(carbonColumn, parentName, carbonColumn.getColumnId(),
1:ff5166e:           (CarbonDimension) carbonColumn, absoluteTableIdentifier, client, useOnePass,
1:3202cf5:           localCache, nullFormat, isEmptyBadRecords);
1:496cde4:     }
1:496cde4:   }
1:3202cf5: 
1:496cde4: }
============================================================================
author:manishgupta88
-------------------------------------------------------------------------------
commit:fb6dffe
/////////////////////////////////////////////////////////////////////////
1:     if (DataTypes.isArrayType(dataType) || DataTypes.isMapType(dataType)) {
/////////////////////////////////////////////////////////////////////////
commit:29dc302
/////////////////////////////////////////////////////////////////////////
1:               dataField.getColumn().getColumnIdentifier(), dataField.getColumn().getDataType());
/////////////////////////////////////////////////////////////////////////
1:               parentColumnIdentifier, dataField.getColumn().getDataType());
author:Indhumathi27
-------------------------------------------------------------------------------
commit:cfbf7b6
/////////////////////////////////////////////////////////////////////////
1:           new ArrayDataType(carbonColumn.getColName(), parentName, carbonColumn.getColumnId(),
1:               carbonColumn.hasEncoding(Encoding.DICTIONARY));
/////////////////////////////////////////////////////////////////////////
1:           new StructDataType(carbonColumn.getColName(), parentName, carbonColumn.getColumnId(),
1:               carbonColumn.hasEncoding(Encoding.DICTIONARY));
author:kunal642
-------------------------------------------------------------------------------
commit:7a1d12a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       boolean isEmptyBadRecord, String parentTablePath) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:               AbsoluteTableIdentifier.from(parentTablePath, parentTableIdentifier);
commit:cc0e6f1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.ColumnIdentifier;
1: import org.apache.carbondata.core.metadata.schema.table.RelationIdentifier;
1: import org.apache.carbondata.core.metadata.schema.table.column.ParentColumnTableRelation;
0: import org.apache.carbondata.core.util.path.CarbonStorePath;
/////////////////////////////////////////////////////////////////////////
1:         DictionaryColumnUniqueIdentifier identifier = null;
1:         // if parent column table relation is not null then it's a child table
1:         // in case of child table it will use parent table dictionary
1:         if (null == dataField.getColumn().getColumnSchema().getParentColumnTableRelations()
1:             || dataField.getColumn().getColumnSchema().getParentColumnTableRelations().isEmpty()) {
0:           identifier = new DictionaryColumnUniqueIdentifier(carbonTableIdentifier,
0:               dataField.getColumn().getColumnIdentifier(), dataField.getColumn().getDataType(),
0:               CarbonStorePath.getCarbonTablePath(storePath, carbonTableIdentifier));
0:           return new DictionaryFieldConverterImpl(dataField, cache, carbonTableIdentifier,
0:               nullFormat, index, client, useOnePass, storePath, localCache, isEmptyBadRecord,
1:               identifier);
1:         } else {
1:           ParentColumnTableRelation parentColumnTableRelation =
1:               dataField.getColumn().getColumnSchema().getParentColumnTableRelations().get(0);
1:           RelationIdentifier relationIdentifier =
1:               parentColumnTableRelation
1:                   .getRelationIdentifier();
1:           CarbonTableIdentifier parentTableIdentifier =
1:               new CarbonTableIdentifier(relationIdentifier.getDatabaseName(),
1:                   relationIdentifier.getTableName(), relationIdentifier.getTableId());
1:           ColumnIdentifier parentColumnIdentifier =
1:               new ColumnIdentifier(parentColumnTableRelation.getColumnId(), null,
1:                   dataField.getColumn().getDataType());
0:           identifier =
0:               new DictionaryColumnUniqueIdentifier(parentTableIdentifier, parentColumnIdentifier,
0:                   dataField.getColumn().getDataType(),
0:                   CarbonStorePath.getCarbonTablePath(storePath, parentTableIdentifier));
0:           return new DictionaryFieldConverterImpl(dataField, cache, parentTableIdentifier,
0:               nullFormat, index, null, false, storePath, null, isEmptyBadRecord, identifier);
1:         }
0:                 client, useOnePass, storePath, localCache), index);
commit:ee5f65f
/////////////////////////////////////////////////////////////////////////
0:       DictionaryClient client, Boolean useOnePass, String storePath,
/////////////////////////////////////////////////////////////////////////
0:             index, client, useOnePass, storePath, localCache, isEmptyBadRecord);
0:                     client, useOnePass, storePath, localCache), index);
/////////////////////////////////////////////////////////////////////////
0:       String storePath, Map<Object, Integer> localCache) {
0:         carbonTableIdentifier, client, useOnePass, storePath, localCache);
/////////////////////////////////////////////////////////////////////////
0:       String storePath, Map<Object, Integer> localCache) {
/////////////////////////////////////////////////////////////////////////
0:               carbonTableIdentifier, client, useOnePass, storePath, localCache));
/////////////////////////////////////////////////////////////////////////
0:               carbonTableIdentifier, client, useOnePass, storePath, localCache));
/////////////////////////////////////////////////////////////////////////
0:             carbonTableIdentifier, client, useOnePass, storePath, localCache);
author:xuchuanyin
-------------------------------------------------------------------------------
commit:cd7c210
/////////////////////////////////////////////////////////////////////////
1:           return new DictionaryFieldConverterImpl(dataField.getColumn(),
1:               absoluteTableIdentifier.getCarbonTableIdentifier().getTableId(),
/////////////////////////////////////////////////////////////////////////
1:           return new DictionaryFieldConverterImpl(dataField.getColumn(),
1:               parentAbsoluteTableIdentifier.getCarbonTableIdentifier().getTableId(),
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:ff5166e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       DictionaryClient client, Boolean useOnePass, Map<Object, Integer> localCache,
0:       boolean isEmptyBadRecord) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:           return new DictionaryFieldConverterImpl(dataField, absoluteTableIdentifier,
/////////////////////////////////////////////////////////////////////////
0:           return new DictionaryFieldConverterImpl(dataField, parentAbsoluteTableIdentifier,
1:             createComplexDataType(dataField, absoluteTableIdentifier,
/////////////////////////////////////////////////////////////////////////
1:     return createComplexType(dataField.getColumn(), dataField.getColumn().getColName(),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             createComplexType(dimension, carbonColumn.getColName(), absoluteTableIdentifier,
/////////////////////////////////////////////////////////////////////////
1:             createComplexType(dimension, carbonColumn.getColName(), absoluteTableIdentifier,
/////////////////////////////////////////////////////////////////////////
1:           (CarbonDimension) carbonColumn, absoluteTableIdentifier, client, useOnePass,
author:sounakr
-------------------------------------------------------------------------------
commit:ec33c11
/////////////////////////////////////////////////////////////////////////
1:   public static GenericDataType createComplexDataType(DataField dataField,
commit:3202cf5
/////////////////////////////////////////////////////////////////////////
0:             createComplexDataType(dataField, cache, absoluteTableIdentifier,
1:                 client, useOnePass, localCache, index, nullFormat, isEmptyBadRecord), index);
/////////////////////////////////////////////////////////////////////////
0:   private static GenericDataType createComplexDataType(DataField dataField,
1:       Map<Object, Integer> localCache, int index, String nullFormat, Boolean isEmptyBadRecords) {
1:         absoluteTableIdentifier, client, useOnePass, localCache, index, nullFormat,
1:         isEmptyBadRecords);
/////////////////////////////////////////////////////////////////////////
1: 
1:       Map<Object, Integer> localCache, int index, String nullFormat, Boolean isEmptyBadRecords) {
/////////////////////////////////////////////////////////////////////////
1:                 client, useOnePass, localCache, index, nullFormat, isEmptyBadRecords));
/////////////////////////////////////////////////////////////////////////
1:                 client, useOnePass, localCache, index, nullFormat, isEmptyBadRecords));
1:       return new PrimitiveDataType(carbonColumn, parentName, carbonColumn.getColumnId(),
0:           (CarbonDimension) carbonColumn, cache, absoluteTableIdentifier, client, useOnePass,
1:           localCache, nullFormat, isEmptyBadRecords);
1: 
author:Jacky Li
-------------------------------------------------------------------------------
commit:bf6c471
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                   CarbonTablePath.getNewTablePath(
0:                       absoluteTableIdentifier.getTablePath(), parentTableIdentifier.getTableName()),
0:                   parentTableIdentifier);
commit:2fe7758
/////////////////////////////////////////////////////////////////////////
1:           AbsoluteTableIdentifier parentAbsoluteTableIdentifier =
0:               AbsoluteTableIdentifier.from(
0:               CarbonUtil.getNewTablePath(carbonTablePath, parentTableIdentifier.getTableName()),
commit:933e30c
/////////////////////////////////////////////////////////////////////////
0:     if (DataTypes.isArrayType(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isStructType(dataType)) {
/////////////////////////////////////////////////////////////////////////
0:     } else if (DataTypes.isMapType(dataType)) {
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
1:     DataType dataType = carbonColumn.getDataType();
0:     if (dataType == DataTypes.ARRAY) {
1:       List<CarbonDimension> listOfChildDimensions =
1:           ((CarbonDimension) carbonColumn).getListOfChildDimensions();
1:       // Create array parser with complex delimiter
1:       ArrayDataType arrayDataType =
0:           new ArrayDataType(carbonColumn.getColName(), parentName, carbonColumn.getColumnId());
1:       for (CarbonDimension dimension : listOfChildDimensions) {
1:         arrayDataType.addChildren(
0:             createComplexType(dimension, carbonColumn.getColName(), cache, carbonTableIdentifier,
0:                 client, useOnePass, storePath, localCache));
1:       }
1:       return arrayDataType;
0:     } else if (dataType == DataTypes.STRUCT) {
1:       List<CarbonDimension> dimensions =
1:           ((CarbonDimension) carbonColumn).getListOfChildDimensions();
1:       // Create struct parser with complex delimiter
1:       StructDataType structDataType =
0:           new StructDataType(carbonColumn.getColName(), parentName, carbonColumn.getColumnId());
1:       for (CarbonDimension dimension : dimensions) {
1:         structDataType.addChildren(
0:             createComplexType(dimension, carbonColumn.getColName(), cache, carbonTableIdentifier,
0:                 client, useOnePass, storePath, localCache));
1:       }
1:       return structDataType;
0:     } else if (dataType == DataTypes.MAP) {
0:       throw new UnsupportedOperationException("Complex type Map is not supported yet");
1:     } else {
0:       return new PrimitiveDataType(carbonColumn.getColName(), parentName,
0:           carbonColumn.getColumnId(), (CarbonDimension) carbonColumn, cache, carbonTableIdentifier,
0:           client, useOnePass, storePath, localCache);
commit:349c59c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.carbondata.processing.loading.converter.impl;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.loading.DataField;
1: import org.apache.carbondata.processing.loading.converter.FieldConverter;
commit:f089287
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.datatypes.GenericDataType;
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:1155d4d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.util.CarbonUtil;
0: import org.apache.carbondata.core.util.path.CarbonTablePath;
/////////////////////////////////////////////////////////////////////////
1:    * @param absoluteTableIdentifier table identifier
1:       AbsoluteTableIdentifier absoluteTableIdentifier, int index, String nullFormat,
0:       DictionaryClient client, Boolean useOnePass,
/////////////////////////////////////////////////////////////////////////
1:           identifier = new DictionaryColumnUniqueIdentifier(absoluteTableIdentifier,
0:               CarbonStorePath.getCarbonTablePath(absoluteTableIdentifier));
0:           return new DictionaryFieldConverterImpl(dataField, cache, absoluteTableIdentifier,
1:               nullFormat, index, client, useOnePass, localCache, isEmptyBadRecord,
/////////////////////////////////////////////////////////////////////////
0:           CarbonTablePath carbonTablePath =
0:               CarbonStorePath.getCarbonTablePath(absoluteTableIdentifier);
0:           AbsoluteTableIdentifier parentAbsoluteTableIdentifier = new AbsoluteTableIdentifier(
0:               CarbonUtil.getNewTablePath(carbonTablePath, parentTableIdentifier),
0:               parentTableIdentifier);
1:           identifier = new DictionaryColumnUniqueIdentifier(parentAbsoluteTableIdentifier,
0:               parentColumnIdentifier, dataField.getColumn().getDataType(),
0:               CarbonStorePath.getCarbonTablePath(parentAbsoluteTableIdentifier));
0:           return new DictionaryFieldConverterImpl(dataField, cache, parentAbsoluteTableIdentifier,
1:               nullFormat, index, null, false, null, isEmptyBadRecord, identifier);
0:             createComplexType(dataField, cache, absoluteTableIdentifier,
0:                 client, useOnePass, localCache), index);
/////////////////////////////////////////////////////////////////////////
1:       AbsoluteTableIdentifier absoluteTableIdentifier, DictionaryClient client, Boolean useOnePass,
0:       Map<Object, Integer> localCache) {
0:         absoluteTableIdentifier, client, useOnePass, localCache);
/////////////////////////////////////////////////////////////////////////
1:       AbsoluteTableIdentifier absoluteTableIdentifier, DictionaryClient client, Boolean useOnePass,
0:       Map<Object, Integer> localCache) {
/////////////////////////////////////////////////////////////////////////
0:             createComplexType(dimension, carbonColumn.getColName(), cache, absoluteTableIdentifier,
0:                 client, useOnePass, localCache));
/////////////////////////////////////////////////////////////////////////
0:             createComplexType(dimension, carbonColumn.getColName(), cache, absoluteTableIdentifier,
0:                 client, useOnePass, localCache));
0:           carbonColumn.getColumnId(), (CarbonDimension) carbonColumn, cache,
0:           absoluteTableIdentifier, client, useOnePass, localCache);
commit:3bc9152
/////////////////////////////////////////////////////////////////////////
0:             index, client, useOnePass, storePath, tableInitialize, localCache, isEmptyBadRecord);
commit:3251c89
/////////////////////////////////////////////////////////////////////////
1:    * @param isEmptyBadRecord
0:       Map<Object, Integer> localCache, boolean isEmptyBadRecord)
1:         return new DirectDictionaryFieldConverterImpl(dataField, nullFormat, index,
1:             isEmptyBadRecord);
/////////////////////////////////////////////////////////////////////////
1:         return new NonDictionaryFieldConverterImpl(dataField, nullFormat, index, isEmptyBadRecord);
1:       return new MeasureFieldConverterImpl(dataField, nullFormat, index, isEmptyBadRecord);
author:jackylk
-------------------------------------------------------------------------------
commit:dc83b2a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datastore.GenericDataType;
commit:353272e
/////////////////////////////////////////////////////////////////////////
1:     if (dataField.getColumn().isDimension()) {
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.CarbonTableIdentifier;
1: import org.apache.carbondata.core.metadata.encoder.Encoding;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:       DictionaryClient client, Boolean useOnePass, String storePath)
0:       throws IOException {
author:ravipesala
-------------------------------------------------------------------------------
commit:87dade7
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:       DictionaryClient client, Boolean useOnePass, String storePath, boolean tableInitialize,
0:       Map<Object, Integer> localCache)
/////////////////////////////////////////////////////////////////////////
0:             index, client, useOnePass, storePath, tableInitialize, localCache);
0:                     client, useOnePass, storePath, tableInitialize, localCache), index);
/////////////////////////////////////////////////////////////////////////
0:       CarbonTableIdentifier carbonTableIdentifier, DictionaryClient client, Boolean useOnePass,
0:       String storePath, boolean tableInitialize, Map<Object, Integer> localCache) {
0:         carbonTableIdentifier, client, useOnePass, storePath, tableInitialize, localCache);
/////////////////////////////////////////////////////////////////////////
0:       CarbonTableIdentifier carbonTableIdentifier, DictionaryClient client, Boolean useOnePass,
0:       String storePath, boolean tableInitialize, Map<Object, Integer> localCache) {
/////////////////////////////////////////////////////////////////////////
0:               carbonTableIdentifier, client, useOnePass, storePath, tableInitialize, localCache));
/////////////////////////////////////////////////////////////////////////
0:               carbonTableIdentifier, client, useOnePass, storePath, tableInitialize, localCache));
/////////////////////////////////////////////////////////////////////////
0:             carbonTableIdentifier, client, useOnePass, storePath, tableInitialize, localCache);
commit:05b2654
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.dictionary.client.DictionaryClient;
/////////////////////////////////////////////////////////////////////////
0:       CarbonTableIdentifier carbonTableIdentifier, int index, String nullFormat,
0:       DictionaryClient client, Boolean useOnePass, String storePath) {
/////////////////////////////////////////////////////////////////////////
0:             index, client, useOnePass, storePath);
0:             createComplexType(dataField, cache, carbonTableIdentifier,
0:                     client, useOnePass, storePath), index);
/////////////////////////////////////////////////////////////////////////
0:       CarbonTableIdentifier carbonTableIdentifier,
0:       DictionaryClient client, Boolean useOnePass, String storePath) {
0:         carbonTableIdentifier, client, useOnePass, storePath);
/////////////////////////////////////////////////////////////////////////
0:       CarbonTableIdentifier carbonTableIdentifier,
0:       DictionaryClient client, Boolean useOnePass, String storePath) {
/////////////////////////////////////////////////////////////////////////
0:               carbonTableIdentifier, client, useOnePass, storePath));
/////////////////////////////////////////////////////////////////////////
0:               carbonTableIdentifier, client, useOnePass, storePath));
/////////////////////////////////////////////////////////////////////////
0:             carbonTableIdentifier, client, useOnePass, storePath);
commit:496cde4
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: 
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonColumn;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.processing.datatypes.ArrayDataType;
0: import org.apache.carbondata.processing.datatypes.GenericDataType;
1: import org.apache.carbondata.processing.datatypes.PrimitiveDataType;
1: import org.apache.carbondata.processing.datatypes.StructDataType;
/////////////////////////////////////////////////////////////////////////
1:    *
1:    * @param dataField             column schema
0:    * @param cache                 dicionary cache.
1:    * @param index                 index of column in the row.
0:       CarbonTableIdentifier carbonTableIdentifier, int index, String nullFormat) {
1:       if (dataField.getColumn().hasEncoding(Encoding.DIRECT_DICTIONARY) &&
1:           !dataField.getColumn().isComplex()) {
0:         return new DirectDictionaryFieldConverterImpl(dataField, nullFormat, index);
1:       } else if (dataField.getColumn().hasEncoding(Encoding.DICTIONARY) &&
1:           !dataField.getColumn().isComplex()) {
0:         return new DictionaryFieldConverterImpl(dataField, cache, carbonTableIdentifier, nullFormat,
0:             index);
1:         return new ComplexFieldConverterImpl(
0:             createComplexType(dataField, cache, carbonTableIdentifier), index);
0:         return new NonDictionaryFieldConverterImpl(dataField, nullFormat, index);
1:     } else {
0:       return new MeasureFieldConverterImpl(dataField, nullFormat, index);
1:   }
1: 
1:   /**
1:    * Create parser for the carbon column.
1:    */
0:   private static GenericDataType createComplexType(DataField dataField,
0:       Cache<DictionaryColumnUniqueIdentifier, Dictionary> cache,
0:       CarbonTableIdentifier carbonTableIdentifier) {
0:     return createComplexType(dataField.getColumn(), dataField.getColumn().getColName(), cache,
0:         carbonTableIdentifier);
1:   }
1: 
1:   /**
1:    * This method may be called recursively if the carbon column is complex type.
1:    *
1:    * @return GenericDataType
1:    */
1:   private static GenericDataType createComplexType(CarbonColumn carbonColumn, String parentName,
0:       Cache<DictionaryColumnUniqueIdentifier, Dictionary> cache,
0:       CarbonTableIdentifier carbonTableIdentifier) {
0:     switch (carbonColumn.getDataType()) {
0:       case ARRAY:
0:         List<CarbonDimension> listOfChildDimensions =
0:             ((CarbonDimension) carbonColumn).getListOfChildDimensions();
0:         // Create array parser with complex delimiter
0:         ArrayDataType arrayDataType =
0:             new ArrayDataType(carbonColumn.getColName(), parentName, carbonColumn.getColumnId());
0:         for (CarbonDimension dimension : listOfChildDimensions) {
0:           arrayDataType.addChildren(createComplexType(dimension, carbonColumn.getColName(), cache,
0:               carbonTableIdentifier));
1:         }
0:         return arrayDataType;
0:       case STRUCT:
0:         List<CarbonDimension> dimensions =
0:             ((CarbonDimension) carbonColumn).getListOfChildDimensions();
0:         // Create struct parser with complex delimiter
0:         StructDataType structDataType =
0:             new StructDataType(carbonColumn.getColName(), parentName, carbonColumn.getColumnId());
0:         for (CarbonDimension dimension : dimensions) {
0:           structDataType.addChildren(createComplexType(dimension, carbonColumn.getColName(), cache,
0:               carbonTableIdentifier));
1:         }
0:         return structDataType;
0:       case MAP:
0:         throw new UnsupportedOperationException("Complex type Map is not supported yet");
0:       default:
0:         return new PrimitiveDataType(carbonColumn.getColName(), parentName,
0:             carbonColumn.getColumnId(), (CarbonDimension) carbonColumn, cache,
0:             carbonTableIdentifier);
1:     }
commit:d96f09a
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
0: package org.apache.carbondata.processing.newflow.converter.impl;
1: 
0: import org.apache.carbondata.core.cache.Cache;
0: import org.apache.carbondata.core.cache.dictionary.Dictionary;
1: import org.apache.carbondata.core.cache.dictionary.DictionaryColumnUniqueIdentifier;
0: import org.apache.carbondata.core.carbon.CarbonTableIdentifier;
0: import org.apache.carbondata.core.carbon.metadata.encoder.Encoding;
0: import org.apache.carbondata.processing.newflow.DataField;
0: import org.apache.carbondata.processing.newflow.converter.FieldConverter;
1: 
1: public class FieldEncoderFactory {
1: 
1:   private static FieldEncoderFactory instance;
1: 
1:   private FieldEncoderFactory() {
1: 
1:   }
1: 
1:   public static FieldEncoderFactory getInstance() {
1:     if (instance == null) {
1:       instance = new FieldEncoderFactory();
1:     }
1:     return instance;
1:   }
1: 
1:   /**
1:    * Creates the FieldConverter for all dimensions, for measures return null.
0:    * @param dataField column schema
0:    * @param cache dicionary cache.
0:    * @param carbonTableIdentifier table identifier
0:    * @param index index of column in the row.
1:    * @return
1:    */
1:   public FieldConverter createFieldEncoder(DataField dataField,
0:       Cache<DictionaryColumnUniqueIdentifier, Dictionary> cache,
0:       CarbonTableIdentifier carbonTableIdentifier, int index) {
1:     // Converters are only needed for dimensions and measures it return null.
0:     if (dataField.getColumn().isDimesion()) {
0:       if (dataField.getColumn().hasEncoding(Encoding.DICTIONARY)) {
0:         return new DictionaryFieldConverterImpl(dataField, cache, carbonTableIdentifier, index);
0:       } else if (dataField.getColumn().hasEncoding(Encoding.DIRECT_DICTIONARY)) {
0:         return new DirectDictionaryFieldConverterImpl(dataField, index);
1:       } else if (dataField.getColumn().isComplex()) {
0:         return new ComplexFieldConverterImpl();
1:       } else {
0:         return new NonDictionaryFieldConverterImpl(dataField, index);
1:       }
1:     }
0:     return null;
1:   }
1: }
author:QiangCai
-------------------------------------------------------------------------------
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
============================================================================