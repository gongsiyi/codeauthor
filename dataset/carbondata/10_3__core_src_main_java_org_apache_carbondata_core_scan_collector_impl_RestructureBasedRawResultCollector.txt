1:70256e7: /*
1:70256e7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:70256e7:  * contributor license agreements.  See the NOTICE file distributed with
1:70256e7:  * this work for additional information regarding copyright ownership.
1:70256e7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:70256e7:  * (the "License"); you may not use this file except in compliance with
1:70256e7:  * the License.  You may obtain a copy of the License at
1:70256e7:  *
1:70256e7:  *    http://www.apache.org/licenses/LICENSE-2.0
1:70256e7:  *
1:70256e7:  * Unless required by applicable law or agreed to in writing, software
1:70256e7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:70256e7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:70256e7:  * See the License for the specific language governing permissions and
1:70256e7:  * limitations under the License.
1:70256e7:  */
1:70256e7: package org.apache.carbondata.core.scan.collector.impl;
1:70256e7: 
1:70256e7: import java.util.ArrayList;
1:70256e7: import java.util.List;
1:70256e7: 
1:70256e7: import org.apache.carbondata.common.logging.LogService;
1:70256e7: import org.apache.carbondata.common.logging.LogServiceFactory;
1:70256e7: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:70256e7: import org.apache.carbondata.core.datastore.block.SegmentProperties;
1:70256e7: import org.apache.carbondata.core.keygenerator.KeyGenException;
1:70256e7: import org.apache.carbondata.core.keygenerator.KeyGenerator;
1:70256e7: import org.apache.carbondata.core.keygenerator.mdkey.MultiDimKeyVarLengthGenerator;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:70256e7: import org.apache.carbondata.core.metadata.encoder.Encoding;
1:70256e7: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:70256e7: import org.apache.carbondata.core.scan.executor.infos.BlockExecutionInfo;
1:daa6465: import org.apache.carbondata.core.scan.model.ProjectionDimension;
1:daa6465: import org.apache.carbondata.core.scan.model.ProjectionMeasure;
1:daa6465: import org.apache.carbondata.core.scan.result.BlockletScannedResult;
1:26607fb: import org.apache.carbondata.core.scan.wrappers.ByteArrayWrapper;
1:26607fb: import org.apache.carbondata.core.stats.QueryStatistic;
1:26607fb: import org.apache.carbondata.core.stats.QueryStatisticsConstants;
1:70256e7: import org.apache.carbondata.core.util.CarbonUtil;
1:982d03f: import org.apache.carbondata.core.util.DataTypeUtil;
1:70256e7: 
1:70256e7: import org.apache.commons.lang3.ArrayUtils;
1:70256e7: 
1:70256e7: /**
1:70256e7:  * It is not a collector it is just a scanned result holder.
1:70256e7:  */
1:6b3b16c: public class RestructureBasedRawResultCollector extends RawBasedResultCollector {
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * logger
1:70256e7:    */
1:70256e7:   private static final LogService LOGGER =
1:70256e7:       LogServiceFactory.getLogService(RestructureBasedRawResultCollector.class.getName());
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * Key generator which will form the mdKey according to latest schema
1:70256e7:    */
1:70256e7:   private KeyGenerator restructuredKeyGenerator;
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * Key generator for uncompressing current block values
1:70256e7:    */
1:70256e7:   private KeyGenerator updatedCurrentBlockKeyGenerator;
1:70256e7: 
1:70256e7:   public RestructureBasedRawResultCollector(BlockExecutionInfo blockExecutionInfos) {
1:70256e7:     super(blockExecutionInfos);
1:70256e7:     initRestructuredKeyGenerator();
1:70256e7:     initCurrentBlockKeyGenerator();
8:70256e7:   }
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * This method will create a new key generator for generating mdKey according to latest schema
1:70256e7:    */
1:70256e7:   private void initRestructuredKeyGenerator() {
1:70256e7:     SegmentProperties segmentProperties =
1:daa6465:         executionInfo.getDataBlock().getSegmentProperties();
1:daa6465:     ProjectionDimension[] queryDimensions = executionInfo.getActualQueryDimensions();
1:70256e7:     List<Integer> updatedColumnCardinality = new ArrayList<>(queryDimensions.length);
1:70256e7:     List<Integer> updatedDimensionPartitioner = new ArrayList<>(queryDimensions.length);
1:daa6465:     int[] dictionaryColumnBlockIndex = executionInfo.getDictionaryColumnChunkIndex();
1:70256e7:     int dimCounterInCurrentBlock = 0;
1:70256e7:     for (int i = 0; i < queryDimensions.length; i++) {
1:70256e7:       if (queryDimensions[i].getDimension().hasEncoding(Encoding.DICTIONARY)) {
1:daa6465:         if (executionInfo.getDimensionInfo().getDimensionExists()[i]) {
1:70256e7:           // get the dictionary key ordinal as column cardinality in segment properties
1:70256e7:           // will only be for dictionary encoded columns
2:70256e7:           CarbonDimension currentBlockDimension = segmentProperties.getDimensions()
1:70256e7:               .get(dictionaryColumnBlockIndex[dimCounterInCurrentBlock]);
1:6b3b16c:           updatedColumnCardinality.add(
1:6b3b16c:               segmentProperties.getDimColumnsCardinality()[currentBlockDimension.getKeyOrdinal()]);
1:6b3b16c:           updatedDimensionPartitioner.add(
1:6b3b16c:               segmentProperties.getDimensionPartitions()[currentBlockDimension.getKeyOrdinal()]);
1:70256e7:           dimCounterInCurrentBlock++;
3:70256e7:         } else {
1:70256e7:           // partitioner index will be 1 every column will be in columnar format
1:70256e7:           updatedDimensionPartitioner.add(1);
1:70256e7:           // for direct dictionary 4 bytes need to be allocated else 1
1:70256e7:           if (queryDimensions[i].getDimension().hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:70256e7:             updatedColumnCardinality.add(Integer.MAX_VALUE);
1:70256e7:           } else {
1:70256e7:             // cardinality will be 2 will user has provided a default value
1:70256e7:             byte[] defaultValue = queryDimensions[i].getDimension().getDefaultValue();
3:70256e7:             if (null != defaultValue) {
1:70256e7:               updatedColumnCardinality
1:70256e7:                   .add(CarbonCommonConstants.DICTIONARY_DEFAULT_CARDINALITY + 1);
1:70256e7:             } else {
1:70256e7:               updatedColumnCardinality.add(CarbonCommonConstants.DICTIONARY_DEFAULT_CARDINALITY);
1:70256e7:             }
1:70256e7:           }
1:70256e7:         }
1:70256e7:       }
1:70256e7:     }
1:70256e7:     if (!updatedColumnCardinality.isEmpty()) {
1:70256e7:       int[] latestColumnCardinality = ArrayUtils.toPrimitive(
1:70256e7:           updatedColumnCardinality.toArray(new Integer[updatedColumnCardinality.size()]));
1:70256e7:       int[] latestColumnPartitioner = ArrayUtils.toPrimitive(
1:70256e7:           updatedDimensionPartitioner.toArray(new Integer[updatedDimensionPartitioner.size()]));
1:70256e7:       int[] dimensionBitLength =
1:70256e7:           CarbonUtil.getDimensionBitLength(latestColumnCardinality, latestColumnPartitioner);
1:70256e7:       restructuredKeyGenerator = new MultiDimKeyVarLengthGenerator(dimensionBitLength);
1:70256e7:     }
1:70256e7:   }
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * This method will initialize the block key generator for the current block based on the
1:70256e7:    * dictionary columns present in the current block
1:70256e7:    */
1:70256e7:   private void initCurrentBlockKeyGenerator() {
1:70256e7:     SegmentProperties segmentProperties =
1:daa6465:         executionInfo.getDataBlock().getSegmentProperties();
1:daa6465:     int[] dictionaryColumnBlockIndex = executionInfo.getDictionaryColumnChunkIndex();
1:70256e7:     int[] updatedColumnCardinality = new int[dictionaryColumnBlockIndex.length];
1:70256e7:     int[] updatedDimensionPartitioner = new int[dictionaryColumnBlockIndex.length];
1:70256e7:     for (int i = 0; i < dictionaryColumnBlockIndex.length; i++) {
1:70256e7:       // get the dictionary key ordinal as column cardinality in segment properties
1:70256e7:       // will only be for dictionary encoded columns
1:6b3b16c:       CarbonDimension currentBlockDimension =
1:6b3b16c:           segmentProperties.getDimensions().get(dictionaryColumnBlockIndex[i]);
1:70256e7:       updatedColumnCardinality[i] =
1:70256e7:           segmentProperties.getDimColumnsCardinality()[currentBlockDimension.getKeyOrdinal()];
1:70256e7:       updatedDimensionPartitioner[i] =
1:70256e7:           segmentProperties.getDimensionPartitions()[currentBlockDimension.getKeyOrdinal()];
1:70256e7:     }
1:70256e7:     if (dictionaryColumnBlockIndex.length > 0) {
1:70256e7:       int[] dimensionBitLength =
1:70256e7:           CarbonUtil.getDimensionBitLength(updatedColumnCardinality, updatedDimensionPartitioner);
1:70256e7:       updatedCurrentBlockKeyGenerator = new MultiDimKeyVarLengthGenerator(dimensionBitLength);
1:70256e7:     }
1:70256e7:   }
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * This method will add a record both key and value to list object
1:70256e7:    * it will keep track of how many record is processed, to handle limit scenario
1:70256e7:    */
1:daa6465:   @Override
1:daa6465:   public List<Object[]> collectResultInRow(BlockletScannedResult scannedResult, int batchSize) {
1:26607fb:     long startTime = System.currentTimeMillis();
1:70256e7:     List<Object[]> listBasedResult = new ArrayList<>(batchSize);
1:daa6465:     ProjectionMeasure[] queryMeasures = executionInfo.getActualQueryMeasures();
1:70256e7:     // scan the record and add to list
1:26607fb:     scanAndFillData(scannedResult, batchSize, listBasedResult, queryMeasures);
1:26607fb:     // re-fill dictionary and no dictionary key arrays for the newly added columns
1:26607fb:     if (dimensionInfo.isDictionaryColumnAdded()) {
1:26607fb:       fillDictionaryKeyArrayBatchWithLatestSchema(listBasedResult);
1:6b3b16c:     }
1:26607fb:     if (dimensionInfo.isNoDictionaryColumnAdded()) {
1:26607fb:       fillNoDictionaryKeyArrayBatchWithLatestSchema(listBasedResult);
1:26607fb:     }
1:26607fb:     QueryStatistic resultPrepTime = queryStatisticsModel.getStatisticsTypeAndObjMap()
1:26607fb:         .get(QueryStatisticsConstants.RESULT_PREP_TIME);
1:26607fb:     resultPrepTime.addCountStatistic(QueryStatisticsConstants.RESULT_PREP_TIME,
1:26607fb:         resultPrepTime.getCount() + (System.currentTimeMillis() - startTime));
1:70256e7:     return listBasedResult;
1:6b3b16c:   }
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * This method will fill the dictionary key array with newly added dictionary columns if any
1:70256e7:    *
1:26607fb:    * @param rows
1:70256e7:    * @return
1:70256e7:    */
1:26607fb:   private void fillDictionaryKeyArrayBatchWithLatestSchema(List<Object[]> rows) {
1:26607fb:     for (Object[] row : rows) {
1:26607fb:       ByteArrayWrapper byteArrayWrapper = (ByteArrayWrapper) row[0];
1:26607fb:       byte[] dictKeyArray = byteArrayWrapper.getDictionaryKey();
1:26607fb:       ProjectionDimension[] actualQueryDimensions = executionInfo.getActualQueryDimensions();
1:26607fb:       int newKeyArrayLength = dimensionInfo.getNewDictionaryColumnCount();
1:26607fb:       long[] keyArray = null;
1:26607fb:       if (null != updatedCurrentBlockKeyGenerator) {
1:26607fb:         keyArray = updatedCurrentBlockKeyGenerator.getKeyArray(dictKeyArray);
1:26607fb:         newKeyArrayLength += keyArray.length;
1:26607fb:       }
1:26607fb:       long[] keyArrayWithNewAddedColumns = new long[newKeyArrayLength];
1:26607fb:       int existingColumnKeyArrayIndex = 0;
1:26607fb:       int newKeyArrayIndex = 0;
1:26607fb:       for (int i = 0; i < dimensionInfo.getDimensionExists().length; i++) {
1:26607fb:         if (CarbonUtil.hasEncoding(actualQueryDimensions[i].getDimension().getEncoder(),
1:26607fb:             Encoding.DICTIONARY)) {
1:26607fb:           // if dimension exists then add the key array value else add the default value
1:7ef9164:           if (dimensionInfo.getDimensionExists()[i] && null != keyArray && 0 != keyArray.length) {
1:26607fb:             keyArrayWithNewAddedColumns[newKeyArrayIndex++] =
1:26607fb:                 keyArray[existingColumnKeyArrayIndex++];
1:70256e7:           } else {
1:26607fb:             long defaultValueAsLong;
1:26607fb:             Object defaultValue = dimensionInfo.getDefaultValues()[i];
1:26607fb:             if (null != defaultValue) {
1:26607fb:               defaultValueAsLong = ((Integer) defaultValue).longValue();
1:26607fb:             } else {
1:26607fb:               defaultValueAsLong = (long) CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
1:26607fb:             }
1:26607fb:             keyArrayWithNewAddedColumns[newKeyArrayIndex++] = defaultValueAsLong;
1:70256e7:           }
1:70256e7:         }
1:70256e7:       }
1:26607fb:       try {
1:26607fb:         dictKeyArray = restructuredKeyGenerator.generateKey(keyArrayWithNewAddedColumns);
1:26607fb:         byteArrayWrapper.setDictionaryKey(dictKeyArray);
1:26607fb:       } catch (KeyGenException e) {
1:26607fb:         throw new RuntimeException(e);
1:26607fb:       }
1:70256e7:     }
1:70256e7:   }
1:70256e7: 
1:70256e7:   /**
1:70256e7:    * This method will fill the no dictionary byte array with newly added no dictionary columns
1:70256e7:    *
1:26607fb:    * @param rows
1:70256e7:    * @return
1:70256e7:    */
1:26607fb:   private void fillNoDictionaryKeyArrayBatchWithLatestSchema(List<Object[]> rows) {
1:26607fb:     for (Object[] row : rows) {
1:26607fb:       ByteArrayWrapper byteArrayWrapper = (ByteArrayWrapper) row[0];
1:26607fb:       byte[][] noDictKeyArray = byteArrayWrapper.getNoDictionaryKeys();
1:26607fb:       ProjectionDimension[] actualQueryDimensions = executionInfo.getActualQueryDimensions();
1:26607fb:       byte[][] noDictionaryKeyArrayWithNewlyAddedColumns =
1:26607fb:           new byte[noDictKeyArray.length + dimensionInfo.getNewNoDictionaryColumnCount()][];
1:26607fb:       int existingColumnValueIndex = 0;
1:26607fb:       int newKeyArrayIndex = 0;
1:26607fb:       for (int i = 0; i < dimensionInfo.getDimensionExists().length; i++) {
1:26607fb:         if (!actualQueryDimensions[i].getDimension().hasEncoding(Encoding.DICTIONARY)
1:26607fb:             && !actualQueryDimensions[i].getDimension().hasEncoding(Encoding.IMPLICIT)) {
1:26607fb:           // if dimension exists then add the byte array value else add the default value
2:26607fb:           if (dimensionInfo.getDimensionExists()[i]) {
1:26607fb:             noDictionaryKeyArrayWithNewlyAddedColumns[newKeyArrayIndex++] =
1:26607fb:                 noDictKeyArray[existingColumnValueIndex++];
1:70256e7:           } else {
1:26607fb:             byte[] newColumnDefaultValue = null;
1:26607fb:             Object defaultValue = dimensionInfo.getDefaultValues()[i];
1:26607fb:             if (null != defaultValue) {
1:26607fb:               newColumnDefaultValue = (byte[]) defaultValue;
1:26607fb:             } else if (actualQueryDimensions[i].getDimension().getDataType() == DataTypes.STRING) {
1:26607fb:               newColumnDefaultValue =
1:26607fb:                   DataTypeUtil.getDataTypeConverter().convertFromByteToUTF8Bytes(
1:26607fb:                       CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY);
1:26607fb:             } else {
1:26607fb:               newColumnDefaultValue = CarbonCommonConstants.EMPTY_BYTE_ARRAY;
1:26607fb:             }
1:26607fb:             noDictionaryKeyArrayWithNewlyAddedColumns[newKeyArrayIndex++] = newColumnDefaultValue;
1:70256e7:           }
1:70256e7:         }
1:70256e7:       }
1:26607fb:       byteArrayWrapper.setNoDictionaryKeys(noDictionaryKeyArrayWithNewlyAddedColumns);
1:70256e7:     }
1:70256e7:   }
1:70256e7: }
============================================================================
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1:           if (dimensionInfo.getDimensionExists()[i] && null != keyArray && 0 != keyArray.length) {
author:manishgupta88
-------------------------------------------------------------------------------
commit:26607fb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.wrappers.ByteArrayWrapper;
1: import org.apache.carbondata.core.stats.QueryStatistic;
1: import org.apache.carbondata.core.stats.QueryStatisticsConstants;
/////////////////////////////////////////////////////////////////////////
1:     long startTime = System.currentTimeMillis();
1:     scanAndFillData(scannedResult, batchSize, listBasedResult, queryMeasures);
1:     // re-fill dictionary and no dictionary key arrays for the newly added columns
1:     if (dimensionInfo.isDictionaryColumnAdded()) {
1:       fillDictionaryKeyArrayBatchWithLatestSchema(listBasedResult);
1:     if (dimensionInfo.isNoDictionaryColumnAdded()) {
1:       fillNoDictionaryKeyArrayBatchWithLatestSchema(listBasedResult);
1:     }
1:     QueryStatistic resultPrepTime = queryStatisticsModel.getStatisticsTypeAndObjMap()
1:         .get(QueryStatisticsConstants.RESULT_PREP_TIME);
1:     resultPrepTime.addCountStatistic(QueryStatisticsConstants.RESULT_PREP_TIME,
1:         resultPrepTime.getCount() + (System.currentTimeMillis() - startTime));
1:    * @param rows
1:   private void fillDictionaryKeyArrayBatchWithLatestSchema(List<Object[]> rows) {
1:     for (Object[] row : rows) {
1:       ByteArrayWrapper byteArrayWrapper = (ByteArrayWrapper) row[0];
1:       byte[] dictKeyArray = byteArrayWrapper.getDictionaryKey();
1:       ProjectionDimension[] actualQueryDimensions = executionInfo.getActualQueryDimensions();
1:       int newKeyArrayLength = dimensionInfo.getNewDictionaryColumnCount();
1:       long[] keyArray = null;
1:       if (null != updatedCurrentBlockKeyGenerator) {
1:         keyArray = updatedCurrentBlockKeyGenerator.getKeyArray(dictKeyArray);
1:         newKeyArrayLength += keyArray.length;
1:       }
1:       long[] keyArrayWithNewAddedColumns = new long[newKeyArrayLength];
1:       int existingColumnKeyArrayIndex = 0;
1:       int newKeyArrayIndex = 0;
1:       for (int i = 0; i < dimensionInfo.getDimensionExists().length; i++) {
1:         if (CarbonUtil.hasEncoding(actualQueryDimensions[i].getDimension().getEncoder(),
1:             Encoding.DICTIONARY)) {
1:           // if dimension exists then add the key array value else add the default value
1:           if (dimensionInfo.getDimensionExists()[i]) {
1:             keyArrayWithNewAddedColumns[newKeyArrayIndex++] =
1:                 keyArray[existingColumnKeyArrayIndex++];
1:             long defaultValueAsLong;
1:             Object defaultValue = dimensionInfo.getDefaultValues()[i];
1:             if (null != defaultValue) {
1:               defaultValueAsLong = ((Integer) defaultValue).longValue();
1:             } else {
1:               defaultValueAsLong = (long) CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
1:             }
1:             keyArrayWithNewAddedColumns[newKeyArrayIndex++] = defaultValueAsLong;
1:       try {
1:         dictKeyArray = restructuredKeyGenerator.generateKey(keyArrayWithNewAddedColumns);
1:         byteArrayWrapper.setDictionaryKey(dictKeyArray);
1:       } catch (KeyGenException e) {
1:         throw new RuntimeException(e);
1:       }
1:    * @param rows
1:   private void fillNoDictionaryKeyArrayBatchWithLatestSchema(List<Object[]> rows) {
1:     for (Object[] row : rows) {
1:       ByteArrayWrapper byteArrayWrapper = (ByteArrayWrapper) row[0];
1:       byte[][] noDictKeyArray = byteArrayWrapper.getNoDictionaryKeys();
1:       ProjectionDimension[] actualQueryDimensions = executionInfo.getActualQueryDimensions();
1:       byte[][] noDictionaryKeyArrayWithNewlyAddedColumns =
1:           new byte[noDictKeyArray.length + dimensionInfo.getNewNoDictionaryColumnCount()][];
1:       int existingColumnValueIndex = 0;
1:       int newKeyArrayIndex = 0;
1:       for (int i = 0; i < dimensionInfo.getDimensionExists().length; i++) {
1:         if (!actualQueryDimensions[i].getDimension().hasEncoding(Encoding.DICTIONARY)
1:             && !actualQueryDimensions[i].getDimension().hasEncoding(Encoding.IMPLICIT)) {
1:           // if dimension exists then add the byte array value else add the default value
1:           if (dimensionInfo.getDimensionExists()[i]) {
1:             noDictionaryKeyArrayWithNewlyAddedColumns[newKeyArrayIndex++] =
1:                 noDictKeyArray[existingColumnValueIndex++];
1:             byte[] newColumnDefaultValue = null;
1:             Object defaultValue = dimensionInfo.getDefaultValues()[i];
1:             if (null != defaultValue) {
1:               newColumnDefaultValue = (byte[]) defaultValue;
1:             } else if (actualQueryDimensions[i].getDimension().getDataType() == DataTypes.STRING) {
1:               newColumnDefaultValue =
1:                   DataTypeUtil.getDataTypeConverter().convertFromByteToUTF8Bytes(
1:                       CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY);
1:             } else {
1:               newColumnDefaultValue = CarbonCommonConstants.EMPTY_BYTE_ARRAY;
1:             }
1:             noDictionaryKeyArrayWithNewlyAddedColumns[newKeyArrayIndex++] = newColumnDefaultValue;
1:       byteArrayWrapper.setNoDictionaryKeys(noDictionaryKeyArrayWithNewlyAddedColumns);
commit:cc59b24
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6b3b16c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class RestructureBasedRawResultCollector extends RawBasedResultCollector {
/////////////////////////////////////////////////////////////////////////
1:           updatedColumnCardinality.add(
1:               segmentProperties.getDimColumnsCardinality()[currentBlockDimension.getKeyOrdinal()]);
1:           updatedDimensionPartitioner.add(
1:               segmentProperties.getDimensionPartitions()[currentBlockDimension.getKeyOrdinal()]);
/////////////////////////////////////////////////////////////////////////
1:       CarbonDimension currentBlockDimension =
1:           segmentProperties.getDimensions().get(dictionaryColumnBlockIndex[i]);
/////////////////////////////////////////////////////////////////////////
0:       scanResultAndGetData(scannedResult);
0:       // re-fill dictionary and no dictionary key arrays for the newly added columns
0:       if (dimensionInfo.isDictionaryColumnAdded()) {
0:         dictionaryKeyArray = fillDictionaryKeyArrayWithLatestSchema(dictionaryKeyArray);
1:       }
0:       if (dimensionInfo.isNoDictionaryColumnAdded()) {
0:         noDictionaryKeyArray = fillNoDictionaryKeyArrayWithLatestSchema(noDictionaryKeyArray);
1:       }
0:       prepareRow(scannedResult, listBasedResult, queryMeasures);
/////////////////////////////////////////////////////////////////////////
0:     long[] keyArrayWithNewAddedColumns =
0:         new long[keyArray.length + dimensionInfo.getNewDictionaryColumnCount()];
0:     int newKeyArrayIndex = 0;
0:           keyArrayWithNewAddedColumns[newKeyArrayIndex++] = keyArray[existingColumnKeyArrayIndex++];
0:           long defaultValueAsLong;
/////////////////////////////////////////////////////////////////////////
0:           keyArrayWithNewAddedColumns[newKeyArrayIndex++] = defaultValueAsLong;
0:     try {
0:       dictionaryKeyArray = restructuredKeyGenerator.generateKey(keyArrayWithNewAddedColumns);
0:     } catch (KeyGenException e) {
0:       LOGGER.error(e, e.getMessage());
/////////////////////////////////////////////////////////////////////////
0:     byte[][] noDictionaryKeyArrayWithNewlyAddedColumns =
0:         new byte[noDictionaryKeyArray.length + dimensionInfo.getNewNoDictionaryColumnCount()][];
0:     int newKeyArrayIndex = 0;
0:           noDictionaryKeyArrayWithNewlyAddedColumns[newKeyArrayIndex++] =
0:               noDictionaryKeyArray[existingColumnValueIndex++];
0:             newColumnDefaultValue = ((UTF8String) defaultValue).getBytes();
0:           noDictionaryKeyArrayWithNewlyAddedColumns[newKeyArrayIndex++] = newColumnDefaultValue;
0:     return noDictionaryKeyArrayWithNewlyAddedColumns;
commit:70256e7
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.carbondata.core.scan.collector.impl;
1: 
0: import java.nio.charset.Charset;
1: import java.util.ArrayList;
1: import java.util.List;
1: 
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
0: import org.apache.carbondata.core.cache.update.BlockletLevelDeleteDeltaDataCache;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.datastore.block.SegmentProperties;
1: import org.apache.carbondata.core.keygenerator.KeyGenException;
1: import org.apache.carbondata.core.keygenerator.KeyGenerator;
1: import org.apache.carbondata.core.keygenerator.mdkey.MultiDimKeyVarLengthGenerator;
1: import org.apache.carbondata.core.metadata.encoder.Encoding;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.core.scan.executor.infos.BlockExecutionInfo;
0: import org.apache.carbondata.core.scan.model.QueryDimension;
0: import org.apache.carbondata.core.scan.model.QueryMeasure;
0: import org.apache.carbondata.core.scan.result.AbstractScannedResult;
0: import org.apache.carbondata.core.scan.wrappers.ByteArrayWrapper;
1: import org.apache.carbondata.core.util.CarbonUtil;
1: 
1: import org.apache.commons.lang3.ArrayUtils;
0: import org.apache.spark.unsafe.types.UTF8String;
1: 
1: /**
1:  * It is not a collector it is just a scanned result holder.
1:  */
0: public class RestructureBasedRawResultCollector extends AbstractScannedResultCollector {
1: 
1:   /**
1:    * logger
1:    */
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(RestructureBasedRawResultCollector.class.getName());
1: 
1:   /**
1:    * Key generator which will form the mdKey according to latest schema
1:    */
1:   private KeyGenerator restructuredKeyGenerator;
1: 
1:   /**
1:    * Key generator for uncompressing current block values
1:    */
1:   private KeyGenerator updatedCurrentBlockKeyGenerator;
1: 
1:   public RestructureBasedRawResultCollector(BlockExecutionInfo blockExecutionInfos) {
1:     super(blockExecutionInfos);
1:     initRestructuredKeyGenerator();
1:     initCurrentBlockKeyGenerator();
1:   }
1: 
1:   /**
1:    * This method will create a new key generator for generating mdKey according to latest schema
1:    */
1:   private void initRestructuredKeyGenerator() {
1:     SegmentProperties segmentProperties =
0:         tableBlockExecutionInfos.getDataBlock().getSegmentProperties();
0:     QueryDimension[] queryDimensions = tableBlockExecutionInfos.getActualQueryDimensions();
1:     List<Integer> updatedColumnCardinality = new ArrayList<>(queryDimensions.length);
1:     List<Integer> updatedDimensionPartitioner = new ArrayList<>(queryDimensions.length);
0:     int[] dictionaryColumnBlockIndex = tableBlockExecutionInfos.getDictionaryColumnBlockIndex();
1:     int dimCounterInCurrentBlock = 0;
1:     for (int i = 0; i < queryDimensions.length; i++) {
1:       if (queryDimensions[i].getDimension().hasEncoding(Encoding.DICTIONARY)) {
0:         if (tableBlockExecutionInfos.getDimensionInfo().getDimensionExists()[i]) {
1:           // get the dictionary key ordinal as column cardinality in segment properties
1:           // will only be for dictionary encoded columns
1:           CarbonDimension currentBlockDimension = segmentProperties.getDimensions()
1:               .get(dictionaryColumnBlockIndex[dimCounterInCurrentBlock]);
0:           updatedColumnCardinality.add(segmentProperties
0:               .getDimColumnsCardinality()[currentBlockDimension.getKeyOrdinal()]);
0:           updatedDimensionPartitioner.add(segmentProperties
0:               .getDimensionPartitions()[currentBlockDimension.getKeyOrdinal()]);
1:           dimCounterInCurrentBlock++;
1:         } else {
1:           // partitioner index will be 1 every column will be in columnar format
1:           updatedDimensionPartitioner.add(1);
1:           // for direct dictionary 4 bytes need to be allocated else 1
1:           if (queryDimensions[i].getDimension().hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:             updatedColumnCardinality.add(Integer.MAX_VALUE);
1:           } else {
1:             // cardinality will be 2 will user has provided a default value
1:             byte[] defaultValue = queryDimensions[i].getDimension().getDefaultValue();
1:             if (null != defaultValue) {
1:               updatedColumnCardinality
1:                   .add(CarbonCommonConstants.DICTIONARY_DEFAULT_CARDINALITY + 1);
1:             } else {
1:               updatedColumnCardinality.add(CarbonCommonConstants.DICTIONARY_DEFAULT_CARDINALITY);
1:             }
1:           }
1:         }
1:       }
1:     }
1:     if (!updatedColumnCardinality.isEmpty()) {
1:       int[] latestColumnCardinality = ArrayUtils.toPrimitive(
1:           updatedColumnCardinality.toArray(new Integer[updatedColumnCardinality.size()]));
1:       int[] latestColumnPartitioner = ArrayUtils.toPrimitive(
1:           updatedDimensionPartitioner.toArray(new Integer[updatedDimensionPartitioner.size()]));
1:       int[] dimensionBitLength =
1:           CarbonUtil.getDimensionBitLength(latestColumnCardinality, latestColumnPartitioner);
1:       restructuredKeyGenerator = new MultiDimKeyVarLengthGenerator(dimensionBitLength);
1:     }
1:   }
1: 
1:   /**
1:    * This method will initialize the block key generator for the current block based on the
1:    * dictionary columns present in the current block
1:    */
1:   private void initCurrentBlockKeyGenerator() {
1:     SegmentProperties segmentProperties =
0:         tableBlockExecutionInfos.getDataBlock().getSegmentProperties();
0:     int[] dictionaryColumnBlockIndex = tableBlockExecutionInfos.getDictionaryColumnBlockIndex();
1:     int[] updatedColumnCardinality = new int[dictionaryColumnBlockIndex.length];
1:     int[] updatedDimensionPartitioner = new int[dictionaryColumnBlockIndex.length];
1:     for (int i = 0; i < dictionaryColumnBlockIndex.length; i++) {
1:       // get the dictionary key ordinal as column cardinality in segment properties
1:       // will only be for dictionary encoded columns
1:       CarbonDimension currentBlockDimension = segmentProperties.getDimensions()
0:           .get(dictionaryColumnBlockIndex[i]);
1:       updatedColumnCardinality[i] =
1:           segmentProperties.getDimColumnsCardinality()[currentBlockDimension.getKeyOrdinal()];
1:       updatedDimensionPartitioner[i] =
1:           segmentProperties.getDimensionPartitions()[currentBlockDimension.getKeyOrdinal()];
1:     }
1:     if (dictionaryColumnBlockIndex.length > 0) {
1:       int[] dimensionBitLength =
1:           CarbonUtil.getDimensionBitLength(updatedColumnCardinality, updatedDimensionPartitioner);
1:       updatedCurrentBlockKeyGenerator = new MultiDimKeyVarLengthGenerator(dimensionBitLength);
1:     }
1:   }
1: 
1:   /**
1:    * This method will add a record both key and value to list object
1:    * it will keep track of how many record is processed, to handle limit scenario
1:    */
0:   @Override public List<Object[]> collectData(AbstractScannedResult scannedResult, int batchSize) {
1:     List<Object[]> listBasedResult = new ArrayList<>(batchSize);
0:     QueryMeasure[] queryMeasures = tableBlockExecutionInfos.getActualQueryMeasures();
0:     ByteArrayWrapper wrapper = null;
0:     BlockletLevelDeleteDeltaDataCache deleteDeltaDataCache =
0:         scannedResult.getDeleteDeltaDataCache();
1:     // scan the record and add to list
0:     int rowCounter = 0;
0:     while (scannedResult.hasNext() && rowCounter < batchSize) {
0:       byte[] dictionaryKeyArray = scannedResult.getDictionaryKeyArray();
0:       byte[][] noDictionaryKeyArray = scannedResult.getNoDictionaryKeyArray();
0:       byte[][] complexTypeKeyArray = scannedResult.getComplexTypeKeyArray();
0:       byte[] implicitColumnByteArray = scannedResult.getBlockletId()
0:           .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
0:       if (null != deleteDeltaDataCache && deleteDeltaDataCache
0:           .contains(scannedResult.getCurrenrRowId())) {
0:         continue;
1:       }
0:       Object[] row = new Object[1 + queryMeasures.length];
0:       wrapper = new ByteArrayWrapper();
0:       wrapper.setDictionaryKey(fillDictionaryKeyArrayWithLatestSchema(dictionaryKeyArray));
0:       wrapper.setNoDictionaryKeys(fillNoDictionaryKeyArrayWithLatestSchema(noDictionaryKeyArray));
0:       wrapper.setComplexTypesKeys(complexTypeKeyArray);
0:       wrapper.setImplicitColumnByteArray(implicitColumnByteArray);
0:       row[0] = wrapper;
0:       fillMeasureData(row, 1, scannedResult);
0:       listBasedResult.add(row);
0:       rowCounter++;
1:     }
1:     return listBasedResult;
1:   }
1: 
1:   /**
1:    * This method will fill the dictionary key array with newly added dictionary columns if any
1:    *
0:    * @param dictionaryKeyArray
1:    * @return
1:    */
0:   private byte[] fillDictionaryKeyArrayWithLatestSchema(byte[] dictionaryKeyArray) {
0:     QueryDimension[] actualQueryDimensions = tableBlockExecutionInfos.getActualQueryDimensions();
0:     List<Long> keyArrayWithNewColumnValues = new ArrayList<>(actualQueryDimensions.length);
0:     long[] keyArray = updatedCurrentBlockKeyGenerator.getKeyArray(dictionaryKeyArray);
0:     int existingColumnKeyArrayIndex = 0;
0:     for (int i = 0; i < dimensionInfo.getDimensionExists().length; i++) {
0:       if (CarbonUtil
0:           .hasEncoding(actualQueryDimensions[i].getDimension().getEncoder(), Encoding.DICTIONARY)) {
0:         // if dimension exists then add the key array value else add the default value
0:         if (dimensionInfo.getDimensionExists()[i]) {
0:           keyArrayWithNewColumnValues.add(keyArray[existingColumnKeyArrayIndex++]);
1:         } else {
0:           Long defaultValueAsLong = null;
0:           Object defaultValue = dimensionInfo.getDefaultValues()[i];
1:           if (null != defaultValue) {
0:             defaultValueAsLong = ((Integer) defaultValue).longValue();
1:           } else {
0:             defaultValueAsLong =
0:                 new Integer(CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY).longValue();
1:           }
0:           keyArrayWithNewColumnValues.add(defaultValueAsLong);
1:         }
1:       }
1:     }
0:     if (!keyArrayWithNewColumnValues.isEmpty()) {
0:       long[] keyArrayWithLatestSchema = ArrayUtils.toPrimitive(
0:           keyArrayWithNewColumnValues.toArray(new Long[keyArrayWithNewColumnValues.size()]));
0:       try {
0:         dictionaryKeyArray = restructuredKeyGenerator.generateKey(keyArrayWithLatestSchema);
0:       } catch (KeyGenException e) {
0:         LOGGER.error(e, e.getMessage());
1:       }
1:     }
0:     return dictionaryKeyArray;
1:   }
1: 
1:   /**
1:    * This method will fill the no dictionary byte array with newly added no dictionary columns
1:    *
0:    * @param noDictionaryKeyArray
1:    * @return
1:    */
0:   private byte[][] fillNoDictionaryKeyArrayWithLatestSchema(byte[][] noDictionaryKeyArray) {
0:     QueryDimension[] actualQueryDimensions = tableBlockExecutionInfos.getActualQueryDimensions();
0:     List<byte[]> noDictionaryValueList = new ArrayList<>(actualQueryDimensions.length);
0:     int existingColumnValueIndex = 0;
0:     for (int i = 0; i < dimensionInfo.getDimensionExists().length; i++) {
0:       if (!actualQueryDimensions[i].getDimension().hasEncoding(Encoding.DICTIONARY)) {
0:         // if dimension exists then add the byte array value else add the default value
0:         if (dimensionInfo.getDimensionExists()[i]) {
0:           noDictionaryValueList.add(noDictionaryKeyArray[existingColumnValueIndex++]);
1:         } else {
0:           byte[] newColumnDefaultValue = null;
0:           Object defaultValue = dimensionInfo.getDefaultValues()[i];
1:           if (null != defaultValue) {
0:             newColumnDefaultValue = UTF8String.fromString((String) defaultValue).getBytes();
1:           } else {
0:             newColumnDefaultValue =
0:                 UTF8String.fromString(CarbonCommonConstants.MEMBER_DEFAULT_VAL).getBytes();
1:           }
0:           noDictionaryValueList.add(newColumnDefaultValue);
1:         }
1:       }
1:     }
0:     // fill the 2-D byte array with all the values of columns in latest schema
0:     if (!noDictionaryValueList.isEmpty()) {
0:       noDictionaryKeyArray = new byte[noDictionaryValueList.size()][];
0:       for (int i = 0; i < noDictionaryKeyArray.length; i++) {
0:         noDictionaryKeyArray[i] = noDictionaryValueList.get(i);
1:       }
1:     }
0:     return noDictionaryKeyArray;
1:   }
1: }
author:Jacky Li
-------------------------------------------------------------------------------
commit:982d03f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.DataTypeUtil;
/////////////////////////////////////////////////////////////////////////
0:             newColumnDefaultValue = (byte[]) defaultValue;
0:                 DataTypeUtil.getDataTypeConverter().convertFromByteToUTF8Bytes(
0:                     CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY);
commit:daa6465
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.model.ProjectionDimension;
1: import org.apache.carbondata.core.scan.model.ProjectionMeasure;
1: import org.apache.carbondata.core.scan.result.BlockletScannedResult;
/////////////////////////////////////////////////////////////////////////
1:         executionInfo.getDataBlock().getSegmentProperties();
1:     ProjectionDimension[] queryDimensions = executionInfo.getActualQueryDimensions();
1:     int[] dictionaryColumnBlockIndex = executionInfo.getDictionaryColumnChunkIndex();
1:         if (executionInfo.getDimensionInfo().getDimensionExists()[i]) {
/////////////////////////////////////////////////////////////////////////
1:         executionInfo.getDataBlock().getSegmentProperties();
1:     int[] dictionaryColumnBlockIndex = executionInfo.getDictionaryColumnChunkIndex();
/////////////////////////////////////////////////////////////////////////
1:   @Override
1:   public List<Object[]> collectResultInRow(BlockletScannedResult scannedResult, int batchSize) {
1:     ProjectionMeasure[] queryMeasures = executionInfo.getActualQueryMeasures();
/////////////////////////////////////////////////////////////////////////
0:     ProjectionDimension[] actualQueryDimensions = executionInfo.getActualQueryDimensions();
/////////////////////////////////////////////////////////////////////////
0:     ProjectionDimension[] actualQueryDimensions = executionInfo.getActualQueryDimensions();
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
0:           } else if (actualQueryDimensions[i].getDimension().getDataType() == DataTypes.STRING) {
author:dhatchayani
-------------------------------------------------------------------------------
commit:36ceb59
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.datatype.DataType;
/////////////////////////////////////////////////////////////////////////
0:           } else if (actualQueryDimensions[i].getDimension().getDataType() == DataType.STRING) {
0:           } else {
0:             newColumnDefaultValue = CarbonCommonConstants.EMPTY_BYTE_ARRAY;
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
0:             defaultValueAsLong = (long)CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
author:kumarvishal
-------------------------------------------------------------------------------
commit:8a5ed81
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       if (scannedResult.containsDeletedRow(scannedResult.getCurrentRowId())) {
author:ravikiran23
-------------------------------------------------------------------------------
commit:90000e6
/////////////////////////////////////////////////////////////////////////
0:           .contains(scannedResult.getCurrentRowId(),
0:               scannedResult.getCurrentPageCounter())) {
author:kunal642
-------------------------------------------------------------------------------
commit:22be345
/////////////////////////////////////////////////////////////////////////
0:     int newKeyArrayLength = dimensionInfo.getNewDictionaryColumnCount();
0:     long[] keyArray = null;
0:     if (null != updatedCurrentBlockKeyGenerator) {
0:       keyArray = updatedCurrentBlockKeyGenerator.getKeyArray(dictionaryKeyArray);
0:       newKeyArrayLength += keyArray.length;
0:     }
0:     long[] keyArrayWithNewAddedColumns = new long[newKeyArrayLength];
/////////////////////////////////////////////////////////////////////////
0:       if (!actualQueryDimensions[i].getDimension().hasEncoding(Encoding.DICTIONARY)
0:           && !actualQueryDimensions[i].getDimension().hasEncoding(Encoding.IMPLICIT)) {
author:mayun
-------------------------------------------------------------------------------
commit:040982b
/////////////////////////////////////////////////////////////////////////
0:           .contains(scannedResult.getCurrentRowId())) {
author:nareshpr
-------------------------------------------------------------------------------
commit:35739e5
/////////////////////////////////////////////////////////////////////////
0:             newColumnDefaultValue = ((UTF8String)defaultValue).getBytes();
============================================================================