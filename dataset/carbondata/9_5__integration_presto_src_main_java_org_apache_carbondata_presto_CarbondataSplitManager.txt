1:4422c52: /*
1:4422c52:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:4422c52:  * contributor license agreements.  See the NOTICE file distributed with
1:4422c52:  * this work for additional information regarding copyright ownership.
1:4422c52:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:4422c52:  * (the "License"); you may not use this file except in compliance with
1:4422c52:  * the License.  You may obtain a copy of the License at
1:0d46976:  *
1:4422c52:  *    http://www.apache.org/licenses/LICENSE-2.0
2:4422c52:  *
1:4422c52:  * Unless required by applicable law or agreed to in writing, software
1:4422c52:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4422c52:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4422c52:  * See the License for the specific language governing permissions and
1:4422c52:  * limitations under the License.
3:4422c52:  */
23:4422c52: 
1:4422c52: package org.apache.carbondata.presto;
1:4422c52: 
1:4422c52: import java.util.List;
1:4422c52: import java.util.Optional;
1:4422c52: 
1:d4a1577: import javax.inject.Inject;
1:d4a1577: 
1:d4a1577: import static java.util.Objects.requireNonNull;
1:d4a1577: 
1:0d46976: import org.apache.carbondata.core.scan.expression.Expression;
1:01b48fc: import org.apache.carbondata.core.stats.QueryStatistic;
1:01b48fc: import org.apache.carbondata.core.stats.QueryStatisticsConstants;
1:01b48fc: import org.apache.carbondata.core.stats.QueryStatisticsRecorder;
1:01b48fc: import org.apache.carbondata.core.util.CarbonTimeStatisticsFactory;
1:01b48fc: import org.apache.carbondata.presto.impl.CarbonLocalMultiBlockSplit;
1:0d46976: import org.apache.carbondata.presto.impl.CarbonTableCacheModel;
1:0d46976: import org.apache.carbondata.presto.impl.CarbonTableReader;
1:0d46976: 
1:d4a1577: import static org.apache.carbondata.presto.Types.checkType;
1:d4a1577: 
1:0d46976: import com.facebook.presto.spi.ColumnHandle;
1:0d46976: import com.facebook.presto.spi.ConnectorSession;
1:0d46976: import com.facebook.presto.spi.ConnectorSplit;
1:0d46976: import com.facebook.presto.spi.ConnectorSplitSource;
1:0d46976: import com.facebook.presto.spi.ConnectorTableLayoutHandle;
1:0d46976: import com.facebook.presto.spi.FixedSplitSource;
1:0d46976: import com.facebook.presto.spi.SchemaTableName;
1:0d46976: import com.facebook.presto.spi.connector.ConnectorSplitManager;
1:0d46976: import com.facebook.presto.spi.connector.ConnectorTransactionHandle;
1:0d46976: import com.facebook.presto.spi.predicate.TupleDomain;
1:0d46976: import com.google.common.collect.ImmutableList;
1:0d46976: 
1:4422c52: 
3:4422c52: /**
1:4422c52:  * Build Carbontable splits
1:4422c52:  * filtering irrelevant blocks
1:4422c52:  */
1:4422c52: public class CarbondataSplitManager implements ConnectorSplitManager {
1:4422c52: 
1:4422c52:   private final String connectorId;
1:4422c52:   private final CarbonTableReader carbonTableReader;
1:4422c52: 
1:4422c52:   @Inject
1:4422c52:   public CarbondataSplitManager(CarbondataConnectorId connectorId, CarbonTableReader reader) {
1:4422c52:     this.connectorId = requireNonNull(connectorId, "connectorId is null").toString();
1:4422c52:     this.carbonTableReader = requireNonNull(reader, "client is null");
20:4422c52:   }
1:0d46976: 
1:4422c52:   public ConnectorSplitSource getSplits(ConnectorTransactionHandle transactionHandle,
1:4422c52:       ConnectorSession session, ConnectorTableLayoutHandle layout) {
1:4422c52:     CarbondataTableLayoutHandle layoutHandle = (CarbondataTableLayoutHandle) layout;
1:4422c52:     CarbondataTableHandle tableHandle = layoutHandle.getTable();
1:4422c52:     SchemaTableName key = tableHandle.getSchemaTableName();
1:0d46976: 
1:01b48fc:     String queryId = System.nanoTime() + "";
1:01b48fc:     QueryStatistic statistic = new QueryStatistic();
1:01b48fc:     QueryStatisticsRecorder statisticRecorder = CarbonTimeStatisticsFactory.createDriverRecorder();
1:01b48fc:     statistic.addStatistics(QueryStatisticsConstants.BLOCK_ALLOCATION, System.currentTimeMillis());
1:01b48fc:     statisticRecorder.recordStatisticsForDriver(statistic, queryId);
1:01b48fc:     statistic = new QueryStatistic();
1:01b48fc: 
1:01b48fc:     carbonTableReader.setQueryId(queryId);
1:01b48fc:     // Packaging presto-TupleDomain into CarbondataColumnConstraint,
1:01b48fc:     // to decouple from presto-spi Module
1:4422c52:     List<CarbondataColumnConstraint> rebuildConstraints =
1:4422c52:         getColumnConstraints(layoutHandle.getConstraint());
1:4422c52: 
1:4422c52:     CarbonTableCacheModel cache = carbonTableReader.getCarbonCache(key);
1:7ef9164:     if (null != cache) {
1:531dcd2:       Expression filters = PrestoFilterUtil.parseFilterExpression(layoutHandle.getConstraint());
1:7ef9164:       try {
1:01b48fc:         List<CarbonLocalMultiBlockSplit> splits =
1:01b48fc:             carbonTableReader.getInputSplits2(cache, filters, layoutHandle.getConstraint());
1:4422c52: 
1:7ef9164:         ImmutableList.Builder<ConnectorSplit> cSplits = ImmutableList.builder();
1:01b48fc:         long index = 0;
1:01b48fc:         for (CarbonLocalMultiBlockSplit split : splits) {
1:01b48fc:           index++;
1:7ef9164:           cSplits.add(new CarbondataSplit(connectorId, tableHandle.getSchemaTableName(),
1:01b48fc:               layoutHandle.getConstraint(), split, rebuildConstraints, queryId, index));
1:7ef9164:         }
1:01b48fc: 
1:01b48fc:         statisticRecorder.logStatisticsAsTableDriver();
1:01b48fc: 
1:01b48fc:         statistic.addStatistics(QueryStatisticsConstants.BLOCK_IDENTIFICATION,
1:01b48fc:             System.currentTimeMillis());
1:01b48fc:         statisticRecorder.recordStatisticsForDriver(statistic, queryId);
1:01b48fc:         statisticRecorder.logStatisticsAsTableDriver();
1:7ef9164:         return new FixedSplitSource(cSplits.build());
1:7ef9164:       } catch (Exception ex) {
1:531dcd2:         throw new RuntimeException(ex.getMessage(), ex);
1:4422c52:       }
1:4422c52:     }
1:7ef9164:     return null;
1:4422c52:   }
1:531dcd2: 
1:531dcd2:   /**
1:531dcd2:    *
1:531dcd2:    * @param constraint
1:531dcd2:    * @return
1:531dcd2:    */
1:4422c52:   public List<CarbondataColumnConstraint> getColumnConstraints(
1:4422c52:       TupleDomain<ColumnHandle> constraint) {
1:4422c52:     ImmutableList.Builder<CarbondataColumnConstraint> constraintBuilder = ImmutableList.builder();
1:4422c52:     for (TupleDomain.ColumnDomain<ColumnHandle> columnDomain : constraint.getColumnDomains()
1:4422c52:         .get()) {
1:4422c52:       CarbondataColumnHandle columnHandle =
1:4422c52:           checkType(columnDomain.getColumn(), CarbondataColumnHandle.class, "column handle");
1:4422c52: 
1:4422c52:       constraintBuilder.add(new CarbondataColumnConstraint(columnHandle.getColumnName(),
1:4422c52:           Optional.of(columnDomain.getDomain()), columnHandle.isInvertedIndex()));
1:4422c52:     }
1:4422c52: 
1:4422c52:     return constraintBuilder.build();
1:4422c52:   }
1:4422c52: 
1:4422c52: }
============================================================================
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:d4a1577
/////////////////////////////////////////////////////////////////////////
1: import javax.inject.Inject;
1: 
1: import static java.util.Objects.requireNonNull;
1: 
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.carbondata.presto.Types.checkType;
1: 
/////////////////////////////////////////////////////////////////////////
author:Bhavya
-------------------------------------------------------------------------------
commit:01b48fc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.stats.QueryStatistic;
1: import org.apache.carbondata.core.stats.QueryStatisticsConstants;
1: import org.apache.carbondata.core.stats.QueryStatisticsRecorder;
1: import org.apache.carbondata.core.util.CarbonTimeStatisticsFactory;
1: import org.apache.carbondata.presto.impl.CarbonLocalMultiBlockSplit;
/////////////////////////////////////////////////////////////////////////
1:     String queryId = System.nanoTime() + "";
1:     QueryStatistic statistic = new QueryStatistic();
1:     QueryStatisticsRecorder statisticRecorder = CarbonTimeStatisticsFactory.createDriverRecorder();
1:     statistic.addStatistics(QueryStatisticsConstants.BLOCK_ALLOCATION, System.currentTimeMillis());
1:     statisticRecorder.recordStatisticsForDriver(statistic, queryId);
1:     statistic = new QueryStatistic();
1: 
1:     carbonTableReader.setQueryId(queryId);
1:     // Packaging presto-TupleDomain into CarbondataColumnConstraint,
1:     // to decouple from presto-spi Module
/////////////////////////////////////////////////////////////////////////
1:         List<CarbonLocalMultiBlockSplit> splits =
1:             carbonTableReader.getInputSplits2(cache, filters, layoutHandle.getConstraint());
1:         long index = 0;
1:         for (CarbonLocalMultiBlockSplit split : splits) {
1:           index++;
1:               layoutHandle.getConstraint(), split, rebuildConstraints, queryId, index));
1: 
1:         statisticRecorder.logStatisticsAsTableDriver();
1: 
1:         statistic.addStatistics(QueryStatisticsConstants.BLOCK_IDENTIFICATION,
1:             System.currentTimeMillis());
1:         statisticRecorder.recordStatisticsForDriver(statistic, queryId);
1:         statisticRecorder.logStatisticsAsTableDriver();
commit:531dcd2
/////////////////////////////////////////////////////////////////////////
1:     Expression filters = PrestoFilterUtil.parseFilterExpression(layoutHandle.getConstraint());
/////////////////////////////////////////////////////////////////////////
1:       throw new RuntimeException(ex.getMessage(), ex);
1: 
1:   /**
1:    *
1:    * @param constraint
1:    * @return
1:    */
/////////////////////////////////////////////////////////////////////////
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1:     if (null != cache) {
0:       Expression filters = PrestoFilterUtil.parseFilterExpression(layoutHandle.getConstraint());
1:       try {
0:         List<CarbonLocalInputSplit> splits = carbonTableReader.getInputSplits2(cache, filters,
0:                 layoutHandle.getConstraint());
1:         ImmutableList.Builder<ConnectorSplit> cSplits = ImmutableList.builder();
0:         for (CarbonLocalInputSplit split : splits) {
1:           cSplits.add(new CarbondataSplit(connectorId, tableHandle.getSchemaTableName(),
0:               layoutHandle.getConstraint(), split, rebuildConstraints));
1:         }
1:         return new FixedSplitSource(cSplits.build());
1:       } catch (Exception ex) {
0:         throw new RuntimeException(ex.getMessage(), ex);
1:     return null;
commit:110f9b2
/////////////////////////////////////////////////////////////////////////
0:     try {
0:       List<CarbonLocalInputSplit> splits = carbonTableReader.getInputSplits2(cache, filters);
0:       ImmutableList.Builder<ConnectorSplit> cSplits = ImmutableList.builder();
0:       for (CarbonLocalInputSplit split : splits) {
0:         cSplits.add(new CarbondataSplit(connectorId, tableHandle.getSchemaTableName(),
0:             layoutHandle.getConstraint(), split, rebuildConstraints));
0:       return new FixedSplitSource(cSplits.build());
0:     } catch (Exception ex) {
0:       System.out.println(ex.toString());
/////////////////////////////////////////////////////////////////////////
0:             Object value = convertDataByType(range.getLow().getValue(), type);
/////////////////////////////////////////////////////////////////////////
0:             Object value = convertDataByType(range.getHigh().getValue(), type);
/////////////////////////////////////////////////////////////////////////
0:           return new LiteralExpression(convertDataByType(a, type), coltype);
/////////////////////////////////////////////////////////////////////////
0:   public static DataType spi2CarbondataTypeMapper(Type colType) {
/////////////////////////////////////////////////////////////////////////
0:   public Object convertDataByType(Object rawdata, Type type) {
0:     if (type.equals(IntegerType.INTEGER)) return Integer.valueOf(rawdata.toString());
author:anubhav100
-------------------------------------------------------------------------------
commit:3740535
/////////////////////////////////////////////////////////////////////////
0:       List<CarbonLocalInputSplit> splits = carbonTableReader.getInputSplits2(cache, filters, layoutHandle.getConstraint());
author:xubo245
-------------------------------------------------------------------------------
commit:e2a2d99
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Geetika gupta
-------------------------------------------------------------------------------
commit:0d46976
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.datatype.DataType;
0: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
0: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
0: import org.apache.carbondata.core.scan.expression.ColumnExpression;
1: import org.apache.carbondata.core.scan.expression.Expression;
0: import org.apache.carbondata.core.scan.expression.LiteralExpression;
0: import org.apache.carbondata.core.scan.expression.conditional.EqualToExpression;
0: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanEqualToExpression;
0: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanExpression;
0: import org.apache.carbondata.core.scan.expression.conditional.InExpression;
0: import org.apache.carbondata.core.scan.expression.conditional.LessThanEqualToExpression;
0: import org.apache.carbondata.core.scan.expression.conditional.LessThanExpression;
0: import org.apache.carbondata.core.scan.expression.conditional.ListExpression;
0: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
0: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
0: import org.apache.carbondata.presto.impl.CarbonLocalInputSplit;
1: import org.apache.carbondata.presto.impl.CarbonTableCacheModel;
1: import org.apache.carbondata.presto.impl.CarbonTableReader;
1: 
1: import com.facebook.presto.spi.ColumnHandle;
1: import com.facebook.presto.spi.ConnectorSession;
1: import com.facebook.presto.spi.ConnectorSplit;
1: import com.facebook.presto.spi.ConnectorSplitSource;
1: import com.facebook.presto.spi.ConnectorTableLayoutHandle;
1: import com.facebook.presto.spi.FixedSplitSource;
1: import com.facebook.presto.spi.SchemaTableName;
1: import com.facebook.presto.spi.connector.ConnectorSplitManager;
1: import com.facebook.presto.spi.connector.ConnectorTransactionHandle;
0: import com.facebook.presto.spi.predicate.Domain;
0: import com.facebook.presto.spi.predicate.Range;
1: import com.facebook.presto.spi.predicate.TupleDomain;
0: import com.facebook.presto.spi.type.BigintType;
0: import com.facebook.presto.spi.type.BooleanType;
0: import com.facebook.presto.spi.type.DateType;
0: import com.facebook.presto.spi.type.DecimalType;
0: import com.facebook.presto.spi.type.DoubleType;
0: import com.facebook.presto.spi.type.IntegerType;
0: import com.facebook.presto.spi.type.SmallintType;
0: import com.facebook.presto.spi.type.TimestampType;
0: import com.facebook.presto.spi.type.Type;
0: import com.facebook.presto.spi.type.VarcharType;
1: import com.google.common.collect.ImmutableList;
0: import io.airlift.slice.Slice;
1: 
0: import static org.apache.carbondata.presto.Types.checkType;
/////////////////////////////////////////////////////////////////////////
1: 
0:       List<Expression> disjuncts = new ArrayList<>();
1: 
0:           List<Expression> rangeConjuncts = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
0:                   rangeConjuncts.add(greater);
0:                 rangeConjuncts.add(greater);
/////////////////////////////////////////////////////////////////////////
0:                 rangeConjuncts.add(less);
0:                 rangeConjuncts.add(less2);
0:           disjuncts.addAll(rangeConjuncts);
/////////////////////////////////////////////////////////////////////////
0:       } else if (disjuncts.size() > 0) {
0:         if (disjuncts.size() > 1) {
0:           Expression finalFilters = new OrExpression(disjuncts.get(0), disjuncts.get(1));
0:           if (disjuncts.size() > 2) {
0:             for (int i = 2; i < disjuncts.size(); i++) {
0:               filters.add(new AndExpression(finalFilters, disjuncts.get(i)));
0:         } else if (disjuncts.size() == 1)//only have one value
0:           filters.add(disjuncts.get(0));
0:       finalFilters = new OrExpression(tmp.get(0), tmp.get(1));
0:           finalFilters = new OrExpression(finalFilters, tmp.get(i));
/////////////////////////////////////////////////////////////////////////
1:    *
author:jackylk
-------------------------------------------------------------------------------
commit:353272e
/////////////////////////////////////////////////////////////////////////
0:       colExpression.setDimension(target.get().isDimension());
author:ffpeng90
-------------------------------------------------------------------------------
commit:4422c52
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.presto;
1: 
0: import org.apache.carbondata.presto.impl.CarbonLocalInputSplit;
0: import org.apache.carbondata.presto.impl.CarbonTableCacheModel;
0: import org.apache.carbondata.presto.impl.CarbonTableReader;
0: import com.facebook.presto.spi.*;
0: import com.facebook.presto.spi.connector.ConnectorSplitManager;
0: import com.facebook.presto.spi.connector.ConnectorTransactionHandle;
0: import com.facebook.presto.spi.predicate.Domain;
0: import com.facebook.presto.spi.predicate.Range;
0: import com.facebook.presto.spi.predicate.TupleDomain;
0: import com.facebook.presto.spi.type.*;
0: import com.google.common.collect.ImmutableList;
0: import io.airlift.slice.Slice;
0: import org.apache.carbondata.core.metadata.datatype.DataType;
0: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
0: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
0: import org.apache.carbondata.core.scan.expression.ColumnExpression;
0: import org.apache.carbondata.core.scan.expression.Expression;
0: import org.apache.carbondata.core.scan.expression.LiteralExpression;
0: import org.apache.carbondata.core.scan.expression.conditional.*;
0: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
0: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1: 
0: import javax.inject.Inject;
0: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.Optional;
0: import java.util.stream.Collectors;
1: 
0: import static org.apache.carbondata.presto.Types.checkType;
0: import static com.google.common.base.Preconditions.checkArgument;
0: import static com.google.common.base.Preconditions.checkState;
0: import static java.util.Objects.requireNonNull;
1: 
1: /**
1:  * Build Carbontable splits
1:  * filtering irrelevant blocks
1:  */
1: public class CarbondataSplitManager implements ConnectorSplitManager {
1: 
1:   private final String connectorId;
1:   private final CarbonTableReader carbonTableReader;
1: 
1:   @Inject
1:   public CarbondataSplitManager(CarbondataConnectorId connectorId, CarbonTableReader reader) {
1:     this.connectorId = requireNonNull(connectorId, "connectorId is null").toString();
1:     this.carbonTableReader = requireNonNull(reader, "client is null");
1:   }
1: 
1:   public ConnectorSplitSource getSplits(ConnectorTransactionHandle transactionHandle,
1:       ConnectorSession session, ConnectorTableLayoutHandle layout) {
1:     CarbondataTableLayoutHandle layoutHandle = (CarbondataTableLayoutHandle) layout;
1:     CarbondataTableHandle tableHandle = layoutHandle.getTable();
1:     SchemaTableName key = tableHandle.getSchemaTableName();
1: 
0:     // Packaging presto-TupleDomain into CarbondataColumnConstraint, to decouple from presto-spi Module
1:     List<CarbondataColumnConstraint> rebuildConstraints =
1:         getColumnConstraints(layoutHandle.getConstraint());
1: 
1:     CarbonTableCacheModel cache = carbonTableReader.getCarbonCache(key);
0:     Expression filters = parseFilterExpression(layoutHandle.getConstraint(), cache.carbonTable);
1: 
0:     if (cache != null) {
0:       try {
0:         List<CarbonLocalInputSplit> splits = carbonTableReader.getInputSplits2(cache, filters);
1: 
0:         ImmutableList.Builder<ConnectorSplit> cSplits = ImmutableList.builder();
0:         for (CarbonLocalInputSplit split : splits) {
0:           cSplits.add(new CarbondataSplit(connectorId, tableHandle.getSchemaTableName(),
0:               layoutHandle.getConstraint(), split, rebuildConstraints));
1:         }
0:         return new FixedSplitSource(cSplits.build());
0:       } catch (Exception ex) {
0:         System.out.println(ex.toString());
1:       }
1:     }
0:     return null;
1:   }
1: 
1:   public List<CarbondataColumnConstraint> getColumnConstraints(
1:       TupleDomain<ColumnHandle> constraint) {
1:     ImmutableList.Builder<CarbondataColumnConstraint> constraintBuilder = ImmutableList.builder();
1:     for (TupleDomain.ColumnDomain<ColumnHandle> columnDomain : constraint.getColumnDomains()
1:         .get()) {
1:       CarbondataColumnHandle columnHandle =
1:           checkType(columnDomain.getColumn(), CarbondataColumnHandle.class, "column handle");
1: 
1:       constraintBuilder.add(new CarbondataColumnConstraint(columnHandle.getColumnName(),
1:           Optional.of(columnDomain.getDomain()), columnHandle.isInvertedIndex()));
1:     }
1: 
1:     return constraintBuilder.build();
1:   }
1: 
1:   /**
0:    * Convert presto-TupleDomain predication into Carbon scan express condition
0:    * @param originalConstraint  presto-TupleDomain
0:    * @param carbonTable
0:    * @return
1:    */
0:   public Expression parseFilterExpression(TupleDomain<ColumnHandle> originalConstraint,
0:       CarbonTable carbonTable) {
0:     ImmutableList.Builder<Expression> filters = ImmutableList.builder();
1: 
0:     Domain domain = null;
1: 
0:     for (ColumnHandle c : originalConstraint.getDomains().get().keySet()) {
1: 
0:       CarbondataColumnHandle cdch = (CarbondataColumnHandle) c;
0:       Type type = cdch.getColumnType();
1: 
0:       List<CarbonColumn> ccols = carbonTable.getCreateOrderColumn(carbonTable.getFactTableName());
0:       Optional<CarbonColumn> target =
0:           ccols.stream().filter(a -> a.getColName().equals(cdch.getColumnName())).findFirst();
1: 
0:       if (target.get() == null) return null;
1: 
0:       DataType coltype = target.get().getDataType();
0:       ColumnExpression colExpression =
0:           new ColumnExpression(cdch.getColumnName(), target.get().getDataType());
0:       //colExpression.setColIndex(cs.getSchemaOrdinal());
0:       colExpression.setDimension(target.get().isDimesion());
0:       colExpression.setDimension(
0:           carbonTable.getDimensionByName(carbonTable.getFactTableName(), cdch.getColumnName()));
0:       colExpression.setCarbonColumn(target.get());
1: 
0:       domain = originalConstraint.getDomains().get().get(c);
0:       checkArgument(domain.getType().isOrderable(), "Domain type must be orderable");
1: 
0:       if (domain.getValues().isNone()) {
1:       }
1: 
0:       if (domain.getValues().isAll()) {
1:       }
1: 
0:       List<Object> singleValues = new ArrayList<>();
0:       List<Expression> rangeFilter = new ArrayList<>();
0:       for (Range range : domain.getValues().getRanges().getOrderedRanges()) {
0:         checkState(!range.isAll()); // Already checked
0:         if (range.isSingleValue()) {
0:           singleValues.add(range.getLow().getValue());
0:         } else {
0:           List<String> rangeConjuncts = new ArrayList<>();
0:           if (!range.getLow().isLowerUnbounded()) {
0:             Object value = ConvertDataByType(range.getLow().getValue(), type);
0:             switch (range.getLow().getBound()) {
0:               case ABOVE:
0:                 if (type == TimestampType.TIMESTAMP) {
0:                   //todo not now
0:                 } else {
0:                   GreaterThanExpression greater = new GreaterThanExpression(colExpression,
0:                       new LiteralExpression(value, coltype));
0:                   rangeFilter.add(greater);
1:                 }
0:                 break;
0:               case EXACTLY:
0:                 GreaterThanEqualToExpression greater =
0:                     new GreaterThanEqualToExpression(colExpression,
0:                         new LiteralExpression(value, coltype));
0:                 rangeFilter.add(greater);
0:                 break;
0:               case BELOW:
0:                 throw new IllegalArgumentException("Low marker should never use BELOW bound");
0:               default:
0:                 throw new AssertionError("Unhandled bound: " + range.getLow().getBound());
1:             }
1:           }
0:           if (!range.getHigh().isUpperUnbounded()) {
0:             Object value = ConvertDataByType(range.getHigh().getValue(), type);
0:             switch (range.getHigh().getBound()) {
0:               case ABOVE:
0:                 throw new IllegalArgumentException("High marker should never use ABOVE bound");
0:               case EXACTLY:
0:                 LessThanEqualToExpression less = new LessThanEqualToExpression(colExpression,
0:                     new LiteralExpression(value, coltype));
0:                 rangeFilter.add(less);
0:                 break;
0:               case BELOW:
0:                 LessThanExpression less2 =
0:                     new LessThanExpression(colExpression, new LiteralExpression(value, coltype));
0:                 rangeFilter.add(less2);
0:                 break;
0:               default:
0:                 throw new AssertionError("Unhandled bound: " + range.getHigh().getBound());
1:             }
1:           }
1:         }
1:       }
1: 
0:       if (singleValues.size() == 1) {
0:         Expression ex = null;
0:         if (coltype.equals(DataType.STRING)) {
0:           ex = new EqualToExpression(colExpression,
0:               new LiteralExpression(((Slice) singleValues.get(0)).toStringUtf8(), coltype));
0:         } else ex = new EqualToExpression(colExpression,
0:             new LiteralExpression(singleValues.get(0), coltype));
0:         filters.add(ex);
0:       } else if (singleValues.size() > 1) {
0:         ListExpression candidates = null;
0:         List<Expression> exs = singleValues.stream().map((a) -> {
0:           return new LiteralExpression(ConvertDataByType(a, type), coltype);
0:         }).collect(Collectors.toList());
0:         candidates = new ListExpression(exs);
1: 
0:         if (candidates != null) filters.add(new InExpression(colExpression, candidates));
0:       } else if (rangeFilter.size() > 0) {
0:         if (rangeFilter.size() > 1) {
0:           Expression finalFilters = new OrExpression(rangeFilter.get(0), rangeFilter.get(1));
0:           if (rangeFilter.size() > 2) {
0:             for (int i = 2; i < rangeFilter.size(); i++) {
0:               filters.add(new AndExpression(finalFilters, rangeFilter.get(i)));
1:             }
1:           }
0:         } else if (rangeFilter.size() == 1)//only have one value
0:           filters.add(rangeFilter.get(0));
1:       }
1:     }
1: 
0:     Expression finalFilters;
0:     List<Expression> tmp = filters.build();
0:     if (tmp.size() > 1) {
0:       finalFilters = new AndExpression(tmp.get(0), tmp.get(1));
0:       if (tmp.size() > 2) {
0:         for (int i = 2; i < tmp.size(); i++) {
0:           finalFilters = new AndExpression(finalFilters, tmp.get(i));
1:         }
1:       }
0:     } else if (tmp.size() == 1) finalFilters = tmp.get(0);
0:     else//no filter
0:       return null;
1: 
0:     return finalFilters;
1:   }
1: 
1:   /**
0:    * Convert presto spi Type into Carbondata Type
0:    * @param colType
0:    * @return
1:    */
0:   public static DataType Spi2CarbondataTypeMapper(Type colType) {
0:     if (colType == BooleanType.BOOLEAN) return DataType.BOOLEAN;
0:     else if (colType == SmallintType.SMALLINT) return DataType.SHORT;
0:     else if (colType == IntegerType.INTEGER) return DataType.INT;
0:     else if (colType == BigintType.BIGINT) return DataType.LONG;
0:     else if (colType == DoubleType.DOUBLE) return DataType.DOUBLE;
0:     else if (colType == DecimalType.createDecimalType()) return DataType.DECIMAL;
0:     else if (colType == VarcharType.VARCHAR) return DataType.STRING;
0:     else if (colType == DateType.DATE) return DataType.DATE;
0:     else if (colType == TimestampType.TIMESTAMP) return DataType.TIMESTAMP;
0:     else return DataType.STRING;
1:   }
1: 
0:   public Object ConvertDataByType(Object rawdata, Type type) {
0:     if (type.equals(IntegerType.INTEGER)) return new Integer((rawdata.toString()));
0:     else if (type.equals(BigintType.BIGINT)) return (Long) rawdata;
0:     else if (type.equals(VarcharType.VARCHAR)) return ((Slice) rawdata).toStringUtf8();
0:     else if (type.equals(BooleanType.BOOLEAN)) return (Boolean) (rawdata);
1: 
0:     return rawdata;
1:   }
1: }
author:chenliang613
-------------------------------------------------------------------------------
commit:7ee8e27
/////////////////////////////////////////////////////////////////////////
commit:2712330
/////////////////////////////////////////////////////////////////////////
0: public class CarbondataSplitManager implements ConnectorSplitManager {
0:   private final String connectorId;
0:   private final CarbonTableReader carbonTableReader;
0:   @Inject
0:   public CarbondataSplitManager(CarbondataConnectorId connectorId, CarbonTableReader reader) {
0:     this.connectorId = requireNonNull(connectorId, "connectorId is null").toString();
0:     this.carbonTableReader = requireNonNull(reader, "client is null");
0:   }
0:   public ConnectorSplitSource getSplits(ConnectorTransactionHandle transactionHandle,
0:       ConnectorSession session, ConnectorTableLayoutHandle layout) {
0:     CarbondataTableLayoutHandle layoutHandle = (CarbondataTableLayoutHandle) layout;
0:     CarbondataTableHandle tableHandle = layoutHandle.getTable();
0:     SchemaTableName key = tableHandle.getSchemaTableName();
0:     //get all filter domain
0:     List<CarbondataColumnConstraint> rebuildConstraints =
0:         getColumnConstraints(layoutHandle.getConstraint());
0:     CarbonTableCacheModel cache = carbonTableReader.getCarbonCache(key);
0:     Expression filters = parseFilterExpression(layoutHandle.getConstraint(), cache.carbonTable);
0:     if (cache != null) {
0:       try {
0:         List<CarbonLocalInputSplit> splits = carbonTableReader.getInputSplits2(cache, filters);
0:         ImmutableList.Builder<ConnectorSplit> cSplits = ImmutableList.builder();
0:         for (CarbonLocalInputSplit split : splits) {
0:           cSplits.add(new CarbondataSplit(connectorId, tableHandle.getSchemaTableName(),
0:               layoutHandle.getConstraint(), split, rebuildConstraints));
0:         return new FixedSplitSource(cSplits.build());
0:       } catch (Exception ex) {
0:         System.out.println(ex.toString());
0:       }
0:     }
0:     return null;
0:   }
0: 
0:   public List<CarbondataColumnConstraint> getColumnConstraints(
0:       TupleDomain<ColumnHandle> constraint) {
0:     ImmutableList.Builder<CarbondataColumnConstraint> constraintBuilder = ImmutableList.builder();
0:     for (TupleDomain.ColumnDomain<ColumnHandle> columnDomain : constraint.getColumnDomains()
0:         .get()) {
0:       CarbondataColumnHandle columnHandle =
0:           checkType(columnDomain.getColumn(), CarbondataColumnHandle.class, "column handle");
0: 
0:       constraintBuilder.add(new CarbondataColumnConstraint(columnHandle.getColumnName(),
0:           Optional.of(columnDomain.getDomain()), columnHandle.isInvertedIndex()));
0:     return constraintBuilder.build();
0:   }
0:   public Expression parseFilterExpression(TupleDomain<ColumnHandle> originalConstraint,
0:       CarbonTable carbonTable) {
0:     ImmutableList.Builder<Expression> filters = ImmutableList.builder();
0:     Domain domain = null;
0: 
0:     for (ColumnHandle c : originalConstraint.getDomains().get().keySet()) {
0: 
0:       CarbondataColumnHandle cdch = (CarbondataColumnHandle) c;
0:       Type type = cdch.getColumnType();
0: 
0:       List<CarbonColumn> ccols = carbonTable.getCreateOrderColumn(carbonTable.getFactTableName());
0:       Optional<CarbonColumn> target =
0:           ccols.stream().filter(a -> a.getColName().equals(cdch.getColumnName())).findFirst();
0: 
0:       if (target.get() == null) return null;
0: 
0:       DataType coltype = target.get().getDataType();
0:       ColumnExpression colExpression =
0:           new ColumnExpression(cdch.getColumnName(), target.get().getDataType());
0:       //colExpression.setColIndex(cs.getSchemaOrdinal());
0:       colExpression.setDimension(target.get().isDimesion());
0:       colExpression.setDimension(
0:           carbonTable.getDimensionByName(carbonTable.getFactTableName(), cdch.getColumnName()));
0:       colExpression.setCarbonColumn(target.get());
0: 
0:       domain = originalConstraint.getDomains().get().get(c);
0:       checkArgument(domain.getType().isOrderable(), "Domain type must be orderable");
0: 
0:       if (domain.getValues().isNone()) {
0:         //return QueryBuilders.filteredQuery(null, FilterBuilders.missingFilter(columnName));
0:         //return domain.isNullAllowed() ? columnName + " IS NULL" : "FALSE";
0:         //new Expression()
0:       }
0: 
0:       if (domain.getValues().isAll()) {
0:         //return QueryBuilders.filteredQuery(null, FilterBuilders.existsFilter(columnName));
0:         //return domain.isNullAllowed() ? "TRUE" : columnName + " IS NOT NULL";
0:       }
0: 
0:       List<Object> singleValues = new ArrayList<>();
0:       List<Expression> rangeFilter = new ArrayList<>();
0:       for (Range range : domain.getValues().getRanges().getOrderedRanges()) {
0:         checkState(!range.isAll()); // Already checked
0:         if (range.isSingleValue()) {
0:           singleValues.add(range.getLow().getValue());
0:         } else {
0:           List<String> rangeConjuncts = new ArrayList<>();
0:           if (!range.getLow().isLowerUnbounded()) {
0:             Object value = ConvertDataByType(range.getLow().getValue(), type);
0:             switch (range.getLow().getBound()) {
0:               case ABOVE:
0:                 if (type == TimestampType.TIMESTAMP) {
0:                   //todo not now
0:                 } else {
0:                   GreaterThanExpression greater = new GreaterThanExpression(colExpression,
0:                       new LiteralExpression(value, coltype));
0:                   //greater.setRangeExpression(true);
0:                   rangeFilter.add(greater);
0:                 }
0:                 break;
0:               case EXACTLY:
0:                 GreaterThanEqualToExpression greater =
0:                     new GreaterThanEqualToExpression(colExpression,
0:                         new LiteralExpression(value, coltype));
0:                 //greater.setRangeExpression(true);
0:                 rangeFilter.add(greater);
0:                 break;
0:               case BELOW:
0:                 throw new IllegalArgumentException("Low marker should never use BELOW bound");
0:               default:
0:                 throw new AssertionError("Unhandled bound: " + range.getLow().getBound());
0:             }
0:           }
0:           if (!range.getHigh().isUpperUnbounded()) {
0:             Object value = ConvertDataByType(range.getHigh().getValue(), type);
0:             switch (range.getHigh().getBound()) {
0:               case ABOVE:
0:                 throw new IllegalArgumentException("High marker should never use ABOVE bound");
0:               case EXACTLY:
0:                 LessThanEqualToExpression less = new LessThanEqualToExpression(colExpression,
0:                     new LiteralExpression(value, coltype));
0:                 //less.setRangeExpression(true);
0:                 rangeFilter.add(less);
0:                 break;
0:               case BELOW:
0:                 LessThanExpression less2 =
0:                     new LessThanExpression(colExpression, new LiteralExpression(value, coltype));
0:                 //less2.setRangeExpression(true);
0:                 rangeFilter.add(less2);
0:                 break;
0:               default:
0:                 throw new AssertionError("Unhandled bound: " + range.getHigh().getBound());
0:             }
0:           }
0:       }
0:       if (singleValues.size() == 1) {
0:         Expression ex = null;
0:         if (coltype.equals(DataType.STRING)) {
0:           ex = new EqualToExpression(colExpression,
0:               new LiteralExpression(((Slice) singleValues.get(0)).toStringUtf8(), coltype));
0:         } else ex = new EqualToExpression(colExpression,
0:             new LiteralExpression(singleValues.get(0), coltype));
0:         filters.add(ex);
0:       } else if (singleValues.size() > 1) {
0:         ListExpression candidates = null;
0:         List<Expression> exs = singleValues.stream().map((a) -> {
0:           return new LiteralExpression(ConvertDataByType(a, type), coltype);
0:         }).collect(Collectors.toList());
0:         candidates = new ListExpression(exs);
0: 
0:         if (candidates != null) filters.add(new InExpression(colExpression, candidates));
0:       } else if (rangeFilter.size() > 0) {
0:         if (rangeFilter.size() > 1) {
0:           Expression finalFilters = new OrExpression(rangeFilter.get(0), rangeFilter.get(1));
0:           if (rangeFilter.size() > 2) {
0:             for (int i = 2; i < rangeFilter.size(); i++) {
0:               filters.add(new AndExpression(finalFilters, rangeFilter.get(i)));
0:             }
0:           }
0:         } else if (rangeFilter.size() == 1)//only have one value
0:           filters.add(rangeFilter.get(0));
0:       }
0:     Expression finalFilters;
0:     List<Expression> tmp = filters.build();
0:     if (tmp.size() > 1) {
0:       finalFilters = new AndExpression(tmp.get(0), tmp.get(1));
0:       if (tmp.size() > 2) {
0:         for (int i = 2; i < tmp.size(); i++) {
0:           finalFilters = new AndExpression(finalFilters, tmp.get(i));
0:       }
0:     } else if (tmp.size() == 1) finalFilters = tmp.get(0);
0:     else//no filter
0:       return null;
0:     return finalFilters;
0:   }
0:   public static DataType Spi2CarbondataTypeMapper(Type colType) {
0:     if (colType == BooleanType.BOOLEAN) return DataType.BOOLEAN;
0:     else if (colType == SmallintType.SMALLINT) return DataType.SHORT;
0:     else if (colType == IntegerType.INTEGER) return DataType.INT;
0:     else if (colType == BigintType.BIGINT) return DataType.LONG;
0:     else if (colType == DoubleType.DOUBLE) return DataType.DOUBLE;
0:     else if (colType == DecimalType.createDecimalType()) return DataType.DECIMAL;
0:     else if (colType == VarcharType.VARCHAR) return DataType.STRING;
0:     else if (colType == DateType.DATE) return DataType.DATE;
0:     else if (colType == TimestampType.TIMESTAMP) return DataType.TIMESTAMP;
0:     else return DataType.STRING;
0:   }
0:   public Object ConvertDataByType(Object rawdata, Type type) {
0:     if (type.equals(IntegerType.INTEGER)) return new Integer((rawdata.toString()));
0:     else if (type.equals(BigintType.BIGINT)) return (Long) rawdata;
0:     else if (type.equals(VarcharType.VARCHAR)) return ((Slice) rawdata).toStringUtf8();
0:     else if (type.equals(BooleanType.BOOLEAN)) return (Boolean) (rawdata);
0:     return rawdata;
0:   }
commit:9e3818e
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.carbondata.presto.Types.checkType;
commit:32bf296
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *    http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0: package org.apache.carbondata.presto;
0: 
0: import org.apache.carbondata.presto.impl.CarbonLocalInputSplit;
0: import org.apache.carbondata.presto.impl.CarbonTableCacheModel;
0: import org.apache.carbondata.presto.impl.CarbonTableReader;
commit:9d7dbea
============================================================================