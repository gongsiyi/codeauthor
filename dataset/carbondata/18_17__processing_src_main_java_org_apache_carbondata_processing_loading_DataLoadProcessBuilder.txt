1:496cde4: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
1:41347d8:  *
1:41347d8:  *    http://www.apache.org/licenses/LICENSE-2.0
1:41347d8:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
1:496cde4:  */
1:496cde4: 
1:349c59c: package org.apache.carbondata.processing.loading;
1:496cde4: 
1:496cde4: import java.io.File;
1:496cde4: import java.util.ArrayList;
1:496cde4: import java.util.List;
1:496cde4: 
1:63434fa: import org.apache.carbondata.common.CarbonIterator;
1:d5396b1: import org.apache.carbondata.common.logging.LogService;
1:d5396b1: import org.apache.carbondata.common.logging.LogServiceFactory;
1:496cde4: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:39644b5: import org.apache.carbondata.core.constants.CarbonLoadOptionConstants;
1:dc83b2a: import org.apache.carbondata.core.datastore.TableSpec;
1:ce09aaa: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1:ce09aaa: import org.apache.carbondata.core.metadata.CarbonMetadata;
1:85dc4ff: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:d5396b1: import org.apache.carbondata.core.metadata.schema.SortColumnRangeInfo;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
1:496cde4: import org.apache.carbondata.core.util.CarbonProperties;
1:349c59c: import org.apache.carbondata.processing.loading.constants.DataLoadProcessorConstants;
1:d5396b1: import org.apache.carbondata.processing.loading.exception.CarbonDataLoadingException;
1:349c59c: import org.apache.carbondata.processing.loading.model.CarbonLoadModel;
1:349c59c: import org.apache.carbondata.processing.loading.sort.SortScopeOptions;
1:349c59c: import org.apache.carbondata.processing.loading.steps.CarbonRowDataWriterProcessorStepImpl;
1:349c59c: import org.apache.carbondata.processing.loading.steps.DataConverterProcessorStepImpl;
1:349c59c: import org.apache.carbondata.processing.loading.steps.DataWriterBatchProcessorStepImpl;
1:349c59c: import org.apache.carbondata.processing.loading.steps.DataWriterProcessorStepImpl;
1:349c59c: import org.apache.carbondata.processing.loading.steps.InputProcessorStepImpl;
1:ec33c11: import org.apache.carbondata.processing.loading.steps.InputProcessorStepWithNoConverterImpl;
1:5804d75: import org.apache.carbondata.processing.loading.steps.JsonInputProcessorStepImpl;
1:349c59c: import org.apache.carbondata.processing.loading.steps.SortProcessorStepImpl;
1:496cde4: import org.apache.carbondata.processing.util.CarbonDataProcessorUtil;
1:05b2654: 
1:ded8b41: import org.apache.commons.lang3.StringUtils;
1:ded8b41: 
1:dded5d5: /**
1:496cde4:  * It builds the pipe line of steps for loading data to carbon.
1:496cde4:  */
1:496cde4: public final class DataLoadProcessBuilder {
1:d5396b1:   private static final LogService LOGGER =
1:d5396b1:       LogServiceFactory.getLogService(DataLoadProcessBuilder.class.getName());
1:496cde4: 
1:ded8b41:   public AbstractDataLoadProcessorStep build(CarbonLoadModel loadModel, String[] storeLocation,
1:63434fa:       CarbonIterator[] inputIterators) throws Exception {
1:353272e:     CarbonDataLoadConfiguration configuration = createConfiguration(loadModel, storeLocation);
1:3807b2f:     SortScopeOptions.SortScope sortScope = CarbonDataProcessorUtil.getSortScope(configuration);
1:cf55028:     if (loadModel.isLoadWithoutConverterStep()) {
1:ec33c11:       return buildInternalWithNoConverter(inputIterators, configuration, sortScope);
1:5804d75:     } else if (loadModel.isJsonFileLoad()) {
1:5804d75:       return buildInternalWithJsonInputProcessor(inputIterators, configuration, sortScope);
1:5804d75:     } else if (!configuration.isSortTable() || sortScope.equals(
1:5804d75:         SortScopeOptions.SortScope.NO_SORT)) {
1:4827315:       return buildInternalForNoSort(inputIterators, configuration);
1:4827315:     } else if (configuration.getBucketingInfo() != null) {
1:cbf8797:       return buildInternalForBucketing(inputIterators, configuration);
1:3807b2f:     } else if (sortScope.equals(SortScopeOptions.SortScope.BATCH_SORT)) {
1:b13ead9:       return buildInternalForBatchSort(inputIterators, configuration);
1:cbf8797:     } else {
1:cbf8797:       return buildInternal(inputIterators, configuration);
1:05b2654:     }
1:cbf8797:   }
1:cbf8797: 
1:cbf8797:   private AbstractDataLoadProcessorStep buildInternal(CarbonIterator[] inputIterators,
1:cbf8797:       CarbonDataLoadConfiguration configuration) {
1:496cde4:     // 1. Reads the data input iterators and parses the data.
1:496cde4:     AbstractDataLoadProcessorStep inputProcessorStep =
1:496cde4:         new InputProcessorStepImpl(configuration, inputIterators);
1:496cde4:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:496cde4:     // data types and configurations.
1:496cde4:     AbstractDataLoadProcessorStep converterProcessorStep =
1:d5396b1:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
1:4827315:     // 3. Sorts the data by SortColumn
1:496cde4:     AbstractDataLoadProcessorStep sortProcessorStep =
1:496cde4:         new SortProcessorStepImpl(configuration, converterProcessorStep);
1:496cde4:     // 4. Writes the sorted data in carbondata format.
1:81149f6:     return new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
1:cbf8797:   }
1:496cde4: 
1:4827315:   private AbstractDataLoadProcessorStep buildInternalForNoSort(CarbonIterator[] inputIterators,
1:4827315:       CarbonDataLoadConfiguration configuration) {
1:4827315:     // 1. Reads the data input iterators and parses the data.
1:4827315:     AbstractDataLoadProcessorStep inputProcessorStep =
1:4827315:         new InputProcessorStepImpl(configuration, inputIterators);
1:4827315:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:4827315:     // data types and configurations.
1:4827315:     AbstractDataLoadProcessorStep converterProcessorStep =
1:496cde4:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
1:4827315:     // 3. Writes the sorted data in carbondata format.
1:910d496:     return new CarbonRowDataWriterProcessorStepImpl(configuration, converterProcessorStep);
4:496cde4:   }
1:496cde4: 
1:5804d75:   /**
1:ec33c11:    * Build pipe line for Load without Conversion Step.
1:dded5d5:    */
1:ec33c11:   private AbstractDataLoadProcessorStep buildInternalWithNoConverter(
1:dded5d5:       CarbonIterator[] inputIterators, CarbonDataLoadConfiguration configuration,
1:dded5d5:       SortScopeOptions.SortScope sortScope) {
1:dded5d5:     // Wraps with dummy processor.
1:dded5d5:     AbstractDataLoadProcessorStep inputProcessorStep =
1:ec33c11:         new InputProcessorStepWithNoConverterImpl(configuration, inputIterators);
1:dded5d5:     if (sortScope.equals(SortScopeOptions.SortScope.LOCAL_SORT)) {
1:dded5d5:       AbstractDataLoadProcessorStep sortProcessorStep =
1:dded5d5:           new SortProcessorStepImpl(configuration, inputProcessorStep);
1:dded5d5:       //  Writes the sorted data in carbondata format.
1:dded5d5:       return new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
1:dded5d5:     } else if (sortScope.equals(SortScopeOptions.SortScope.BATCH_SORT)) {
1:dded5d5:       //  Sorts the data by SortColumn or not
1:dded5d5:       AbstractDataLoadProcessorStep sortProcessorStep =
1:dded5d5:           new SortProcessorStepImpl(configuration, inputProcessorStep);
1:dded5d5:       // Writes the sorted data in carbondata format.
1:dded5d5:       return new DataWriterBatchProcessorStepImpl(configuration, sortProcessorStep);
1:dded5d5:     } else {
1:dded5d5:       // In all other cases like global sort and no sort uses this step
1:dded5d5:       return new CarbonRowDataWriterProcessorStepImpl(configuration, inputProcessorStep);
1:dded5d5:     }
1:dded5d5:   }
1:dded5d5: 
1:496cde4:   /**
1:5804d75:    * Build pipe line for Load with json input processor.
1:5804d75:    */
1:5804d75:   private AbstractDataLoadProcessorStep buildInternalWithJsonInputProcessor(
1:5804d75:       CarbonIterator[] inputIterators, CarbonDataLoadConfiguration configuration,
1:5804d75:       SortScopeOptions.SortScope sortScope) {
1:5804d75:     // currently row by row conversion of string json to carbon row is supported.
1:5804d75:     AbstractDataLoadProcessorStep inputProcessorStep =
1:5804d75:         new JsonInputProcessorStepImpl(configuration, inputIterators);
1:5804d75:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:5804d75:     // data types and configurations.
1:5804d75:     AbstractDataLoadProcessorStep converterProcessorStep =
1:5804d75:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
1:5804d75:     if (sortScope.equals(SortScopeOptions.SortScope.LOCAL_SORT)) {
1:5804d75:       AbstractDataLoadProcessorStep sortProcessorStep =
1:5804d75:           new SortProcessorStepImpl(configuration, converterProcessorStep);
1:5804d75:       //  Writes the sorted data in carbondata format.
1:5804d75:       return new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
1:5804d75:     } else if (sortScope.equals(SortScopeOptions.SortScope.BATCH_SORT)) {
1:5804d75:       //  Sorts the data by SortColumn or not
1:5804d75:       AbstractDataLoadProcessorStep sortProcessorStep =
1:5804d75:           new SortProcessorStepImpl(configuration, converterProcessorStep);
1:5804d75:       // Writes the sorted data in carbondata format.
1:5804d75:       return new DataWriterBatchProcessorStepImpl(configuration, sortProcessorStep);
1:5804d75:     } else {
1:5804d75:       // In all other cases like global sort and no sort uses this step
1:5804d75:       return new CarbonRowDataWriterProcessorStepImpl(configuration, converterProcessorStep);
1:5804d75:     }
1:5804d75:   }
1:5804d75: 
1:b13ead9:   private AbstractDataLoadProcessorStep buildInternalForBatchSort(CarbonIterator[] inputIterators,
1:b13ead9:       CarbonDataLoadConfiguration configuration) {
1:b13ead9:     // 1. Reads the data input iterators and parses the data.
1:b13ead9:     AbstractDataLoadProcessorStep inputProcessorStep =
1:b13ead9:         new InputProcessorStepImpl(configuration, inputIterators);
1:b13ead9:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:b13ead9:     // data types and configurations.
1:b13ead9:     AbstractDataLoadProcessorStep converterProcessorStep =
1:b13ead9:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
1:9f94529:     // 3. Sorts the data by SortColumn or not
1:b13ead9:     AbstractDataLoadProcessorStep sortProcessorStep =
1:b13ead9:         new SortProcessorStepImpl(configuration, converterProcessorStep);
1:b13ead9:     // 4. Writes the sorted data in carbondata format.
1:81149f6:     return new DataWriterBatchProcessorStepImpl(configuration, sortProcessorStep);
1:b13ead9:   }
1:b13ead9: 
1:cbf8797:   private AbstractDataLoadProcessorStep buildInternalForBucketing(CarbonIterator[] inputIterators,
1:cbf8797:       CarbonDataLoadConfiguration configuration) throws Exception {
1:cbf8797:     // 1. Reads the data input iterators and parses the data.
1:cbf8797:     AbstractDataLoadProcessorStep inputProcessorStep =
1:cbf8797:         new InputProcessorStepImpl(configuration, inputIterators);
1:cbf8797:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:cbf8797:     // data types and configurations.
1:cbf8797:     AbstractDataLoadProcessorStep converterProcessorStep =
1:4827315:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
1:9f94529:     // 3. Sorts the data by SortColumn or not
1:cbf8797:     AbstractDataLoadProcessorStep sortProcessorStep =
1:cbf8797:         new SortProcessorStepImpl(configuration, converterProcessorStep);
1:cbf8797:     // 4. Writes the sorted data in carbondata format.
1:81149f6:     return new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
1:cbf8797:   }
1:cbf8797: 
1:82741c1:   public static CarbonDataLoadConfiguration createConfiguration(CarbonLoadModel loadModel,
1:ded8b41:       String[] storeLocation) {
1:ded8b41:     CarbonDataProcessorUtil.createLocations(storeLocation);
1:496cde4: 
1:496cde4:     String databaseName = loadModel.getDatabaseName();
1:496cde4:     String tableName = loadModel.getTableName();
1:f890d00:     String tempLocationKey = CarbonDataProcessorUtil
1:1f83125:         .getTempStoreLocationKey(databaseName, tableName, loadModel.getSegmentId(),
1:874764f:             loadModel.getTaskNo(), false, false);
1:ded8b41:     CarbonProperties.getInstance().addProperty(tempLocationKey,
1:ded8b41:         StringUtils.join(storeLocation, File.pathSeparator));
1:496cde4: 
1:82741c1:     return createConfiguration(loadModel);
1:496cde4:   }
1:496cde4: 
1:82741c1:   public static CarbonDataLoadConfiguration createConfiguration(CarbonLoadModel loadModel) {
1:496cde4:     CarbonDataLoadConfiguration configuration = new CarbonDataLoadConfiguration();
1:496cde4:     CarbonTable carbonTable = loadModel.getCarbonDataLoadSchema().getCarbonTable();
1:496cde4:     AbsoluteTableIdentifier identifier = carbonTable.getAbsoluteTableIdentifier();
1:7a1d12a:     configuration.setParentTablePath(loadModel.getParentTablePath());
1:496cde4:     configuration.setTableIdentifier(identifier);
1:b7b8073:     configuration.setCarbonTransactionalTable(loadModel.isCarbonTransactionalTable());
1:fc1af96:     configuration.setSchemaUpdatedTimeStamp(carbonTable.getTableLastUpdatedTime());
1:cbc33c4:     configuration.setHeader(loadModel.getCsvHeaderColumns());
1:496cde4:     configuration.setSegmentId(loadModel.getSegmentId());
1:496cde4:     configuration.setTaskNo(loadModel.getTaskNo());
1:496cde4:     configuration.setDataLoadProperty(DataLoadProcessorConstants.COMPLEX_DELIMITERS,
1:496cde4:         new String[] { loadModel.getComplexDelimiterLevel1(),
1:496cde4:             loadModel.getComplexDelimiterLevel2() });
1:496cde4:     configuration.setDataLoadProperty(DataLoadProcessorConstants.SERIALIZATION_NULL_FORMAT,
1:496cde4:         loadModel.getSerializationNullFormat().split(",")[1]);
1:496cde4:     configuration.setDataLoadProperty(DataLoadProcessorConstants.FACT_TIME_STAMP,
1:496cde4:         loadModel.getFactTimeStamp());
1:496cde4:     configuration.setDataLoadProperty(DataLoadProcessorConstants.BAD_RECORDS_LOGGER_ENABLE,
1:496cde4:         loadModel.getBadRecordsLoggerEnable().split(",")[1]);
1:496cde4:     configuration.setDataLoadProperty(DataLoadProcessorConstants.BAD_RECORDS_LOGGER_ACTION,
1:496cde4:         loadModel.getBadRecordsAction().split(",")[1]);
1:3251c89:     configuration.setDataLoadProperty(DataLoadProcessorConstants.IS_EMPTY_DATA_BAD_RECORD,
1:3251c89:         loadModel.getIsEmptyDataBadRecord().split(",")[1]);
1:40f0608:     configuration.setDataLoadProperty(DataLoadProcessorConstants.SKIP_EMPTY_LINE,
1:40f0608:         loadModel.getSkipEmptyLine());
1:496cde4:     configuration.setDataLoadProperty(DataLoadProcessorConstants.FACT_FILE_PATH,
1:496cde4:         loadModel.getFactFilePath());
1:7a1d12a:     configuration.setParentTablePath(loadModel.getParentTablePath());
1:3807b2f:     configuration
1:3807b2f:         .setDataLoadProperty(CarbonCommonConstants.LOAD_SORT_SCOPE, loadModel.getSortScope());
1:3807b2f:     configuration.setDataLoadProperty(CarbonCommonConstants.LOAD_BATCH_SORT_SIZE_INMB,
1:3807b2f:         loadModel.getBatchSortSizeInMb());
1:82741c1:     configuration.setDataLoadProperty(CarbonCommonConstants.LOAD_GLOBAL_SORT_PARTITIONS,
1:82741c1:         loadModel.getGlobalSortPartitions());
1:39644b5:     configuration.setDataLoadProperty(CarbonLoadOptionConstants.CARBON_OPTIONS_BAD_RECORD_PATH,
1:39644b5:         loadModel.getBadRecordsLocation());
1:280a400: 
1:63434fa:     CarbonMetadata.getInstance().addCarbonTable(carbonTable);
1:496cde4:     List<CarbonDimension> dimensions =
1:5fc7f06:         carbonTable.getDimensionByTableName(carbonTable.getTableName());
1:496cde4:     List<CarbonMeasure> measures =
1:5fc7f06:         carbonTable.getMeasureByTableName(carbonTable.getTableName());
1:496cde4:     List<DataField> dataFields = new ArrayList<>();
1:496cde4:     List<DataField> complexDataFields = new ArrayList<>();
1:496cde4: 
1:496cde4:     // First add dictionary and non dictionary dimensions because these are part of mdk key.
1:496cde4:     // And then add complex data types and measures.
1:496cde4:     for (CarbonColumn column : dimensions) {
1:496cde4:       DataField dataField = new DataField(column);
1:85dc4ff:       if (column.getDataType() == DataTypes.DATE) {
1:85dc4ff:         dataField.setDateFormat(loadModel.getDateFormat());
1:3202cf5:         column.setDateFormat(loadModel.getDateFormat());
1:85dc4ff:       } else if (column.getDataType() == DataTypes.TIMESTAMP) {
1:85dc4ff:         dataField.setTimestampFormat(loadModel.getTimestampformat());
1:3202cf5:         column.setTimestampFormat(loadModel.getTimestampformat());
1:63434fa:       }
1:496cde4:       if (column.isComplex()) {
1:496cde4:         complexDataFields.add(dataField);
1:6b70b7e:         List<CarbonDimension> childDimensions =
1:6b70b7e:             ((CarbonDimension) dataField.getColumn()).getListOfChildDimensions();
1:6b70b7e:         for (CarbonDimension childDimension : childDimensions) {
1:6b70b7e:           if (childDimension.getDataType() == DataTypes.DATE) {
1:6b70b7e:             childDimension.setDateFormat(loadModel.getDateFormat());
1:6b70b7e:           } else if (childDimension.getDataType() == DataTypes.TIMESTAMP) {
1:6b70b7e:             childDimension.setTimestampFormat(loadModel.getTimestampformat());
1:6b70b7e:           }
1:6b70b7e:         }
3:496cde4:       } else {
1:496cde4:         dataFields.add(dataField);
1:496cde4:       }
1:496cde4:     }
1:496cde4:     dataFields.addAll(complexDataFields);
1:496cde4:     for (CarbonColumn column : measures) {
1:496cde4:       // This dummy measure is added when no measure was present. We no need to load it.
1:496cde4:       if (!(column.getColName().equals("default_dummy_measure"))) {
1:496cde4:         dataFields.add(new DataField(column));
1:496cde4:       }
1:496cde4:     }
1:496cde4:     configuration.setDataFields(dataFields.toArray(new DataField[dataFields.size()]));
1:5fc7f06:     configuration.setBucketingInfo(carbonTable.getBucketingInfo(carbonTable.getTableName()));
1:05b2654:     // configuration for one pass load: dictionary server info
1:05b2654:     configuration.setUseOnePass(loadModel.getUseOnePass());
1:05b2654:     configuration.setDictionaryServerHost(loadModel.getDictionaryServerHost());
1:05b2654:     configuration.setDictionaryServerPort(loadModel.getDictionaryServerPort());
1:4daf063:     configuration.setDictionaryServerSecretKey(loadModel.getDictionaryServerSecretKey());
1:4daf063:     configuration.setDictionaryEncryptServerSecure(loadModel.getDictionaryEncryptServerSecure());
1:4daf063:     configuration.setDictionaryServiceProvider(loadModel.getDictionaryServiceProvider());
1:8100d94:     configuration.setPreFetch(loadModel.isPreFetch());
1:9f94529:     configuration.setNumberOfSortColumns(carbonTable.getNumberOfSortColumns());
1:9f94529:     configuration.setNumberOfNoDictSortColumns(carbonTable.getNumberOfNoDictSortColumns());
1:8d3c774:     configuration.setDataWritePath(loadModel.getDataWritePath());
1:d5396b1:     setSortColumnInfo(carbonTable, loadModel, configuration);
1:a89587e:     // For partition loading always use single core as it already runs in multiple
1:a89587e:     // threads per partition
1:a89587e:     if (carbonTable.isHivePartitionTable()) {
1:a89587e:       configuration.setWritingCoresCount((short) 1);
1:a89587e:     }
1:56330ae:     TableSpec tableSpec = new TableSpec(carbonTable);
1:dc83b2a:     configuration.setTableSpec(tableSpec);
1:94d2089:     if (loadModel.getSdkWriterCores() > 0) {
1:94d2089:       configuration.setWritingCoresCount(loadModel.getSdkWriterCores());
1:17a4b48:     }
1:8f08c4a:     configuration.setColumnCompressor(loadModel.getColumnCompressor());
1:496cde4:     return configuration;
1:496cde4:   }
1:05b2654: 
1:d5396b1:   /**
1:d5396b1:    * set sort column info in configuration
1:d5396b1:    * @param carbonTable carbon table
1:d5396b1:    * @param loadModel load model
1:d5396b1:    * @param configuration configuration
1:d5396b1:    */
1:d5396b1:   private static void setSortColumnInfo(CarbonTable carbonTable, CarbonLoadModel loadModel,
1:d5396b1:       CarbonDataLoadConfiguration configuration) {
1:d5396b1:     List<String> sortCols = carbonTable.getSortColumns(carbonTable.getTableName());
1:d5396b1:     SortScopeOptions.SortScope sortScope = SortScopeOptions.getSortScope(loadModel.getSortScope());
1:d5396b1:     if (!SortScopeOptions.SortScope.LOCAL_SORT.equals(sortScope)
1:d5396b1:         || sortCols.size() == 0
1:d5396b1:         || StringUtils.isBlank(loadModel.getSortColumnsBoundsStr())) {
1:d5396b1:       if (!StringUtils.isBlank(loadModel.getSortColumnsBoundsStr())) {
1:d5396b1:         LOGGER.warn("sort column bounds will be ignored");
1:d5396b1:       }
1:d5396b1: 
1:d5396b1:       configuration.setSortColumnRangeInfo(null);
1:d5396b1:       return;
1:d5396b1:     }
1:d5396b1:     // column index for sort columns
1:d5396b1:     int[] sortColIndex = new int[sortCols.size()];
1:d5396b1:     boolean[] isSortColNoDict = new boolean[sortCols.size()];
1:d5396b1: 
1:d5396b1:     DataField[] outFields = configuration.getDataFields();
1:d5396b1:     int j = 0;
1:d5396b1:     boolean columnExist;
1:d5396b1:     for (String sortCol : sortCols) {
1:d5396b1:       columnExist = false;
1:d5396b1: 
1:d5396b1:       for (int i = 0; !columnExist && i < outFields.length; i++) {
1:d5396b1:         if (outFields[i].getColumn().getColName().equalsIgnoreCase(sortCol)) {
1:d5396b1:           columnExist = true;
1:d5396b1: 
1:d5396b1:           sortColIndex[j] = i;
1:d5396b1:           isSortColNoDict[j] = !outFields[i].hasDictionaryEncoding();
1:d5396b1:           j++;
1:d5396b1:         }
1:d5396b1:       }
1:d5396b1: 
1:d5396b1:       if (!columnExist) {
1:d5396b1:         throw new CarbonDataLoadingException("Field " + sortCol + " does not exist.");
1:d5396b1:       }
1:d5396b1:     }
1:d5396b1: 
1:d5396b1:     String[] sortColumnBounds = StringUtils.splitPreserveAllTokens(
1:d5396b1:         loadModel.getSortColumnsBoundsStr(),
1:d5396b1:         CarbonLoadOptionConstants.SORT_COLUMN_BOUNDS_ROW_DELIMITER, -1);
1:d5396b1:     for (String bound : sortColumnBounds) {
1:d5396b1:       String[] fieldInBounds = StringUtils.splitPreserveAllTokens(bound,
1:d5396b1:           CarbonLoadOptionConstants.SORT_COLUMN_BOUNDS_FIELD_DELIMITER, -1);
1:d5396b1:       if (fieldInBounds.length != sortCols.size()) {
1:d5396b1:         String msg = new StringBuilder(
1:d5396b1:             "The number of field in bounds should be equal to that in sort columns.")
1:d5396b1:             .append(" Expected ").append(sortCols.size())
1:d5396b1:             .append(", actual ").append(String.valueOf(fieldInBounds.length)).append(".")
1:d5396b1:             .append(" The illegal bound is '").append(bound).append("'.").toString();
1:d5396b1:         throw new CarbonDataLoadingException(msg);
1:d5396b1:       }
1:d5396b1:     }
1:d5396b1: 
1:d5396b1:     SortColumnRangeInfo sortColumnRangeInfo = new SortColumnRangeInfo(sortColIndex,
1:d5396b1:         isSortColNoDict,
1:d5396b1:         sortColumnBounds,
1:d5396b1:         CarbonLoadOptionConstants.SORT_COLUMN_BOUNDS_FIELD_DELIMITER);
1:d5396b1:     configuration.setSortColumnRangeInfo(sortColumnRangeInfo);
1:d5396b1:   }
1:496cde4: }
============================================================================
author:xuchuanyin
-------------------------------------------------------------------------------
commit:8f08c4a
/////////////////////////////////////////////////////////////////////////
1:     configuration.setColumnCompressor(loadModel.getColumnCompressor());
commit:d5396b1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
1: import org.apache.carbondata.core.metadata.schema.SortColumnRangeInfo;
1: import org.apache.carbondata.processing.loading.exception.CarbonDataLoadingException;
/////////////////////////////////////////////////////////////////////////
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(DataLoadProcessBuilder.class.getName());
/////////////////////////////////////////////////////////////////////////
1:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
/////////////////////////////////////////////////////////////////////////
1:     setSortColumnInfo(carbonTable, loadModel, configuration);
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * set sort column info in configuration
1:    * @param carbonTable carbon table
1:    * @param loadModel load model
1:    * @param configuration configuration
1:    */
1:   private static void setSortColumnInfo(CarbonTable carbonTable, CarbonLoadModel loadModel,
1:       CarbonDataLoadConfiguration configuration) {
1:     List<String> sortCols = carbonTable.getSortColumns(carbonTable.getTableName());
1:     SortScopeOptions.SortScope sortScope = SortScopeOptions.getSortScope(loadModel.getSortScope());
1:     if (!SortScopeOptions.SortScope.LOCAL_SORT.equals(sortScope)
1:         || sortCols.size() == 0
1:         || StringUtils.isBlank(loadModel.getSortColumnsBoundsStr())) {
1:       if (!StringUtils.isBlank(loadModel.getSortColumnsBoundsStr())) {
1:         LOGGER.warn("sort column bounds will be ignored");
1:       }
1: 
1:       configuration.setSortColumnRangeInfo(null);
1:       return;
1:     }
1:     // column index for sort columns
1:     int[] sortColIndex = new int[sortCols.size()];
1:     boolean[] isSortColNoDict = new boolean[sortCols.size()];
1: 
1:     DataField[] outFields = configuration.getDataFields();
1:     int j = 0;
1:     boolean columnExist;
1:     for (String sortCol : sortCols) {
1:       columnExist = false;
1: 
1:       for (int i = 0; !columnExist && i < outFields.length; i++) {
1:         if (outFields[i].getColumn().getColName().equalsIgnoreCase(sortCol)) {
1:           columnExist = true;
1: 
1:           sortColIndex[j] = i;
1:           isSortColNoDict[j] = !outFields[i].hasDictionaryEncoding();
1:           j++;
1:         }
1:       }
1: 
1:       if (!columnExist) {
1:         throw new CarbonDataLoadingException("Field " + sortCol + " does not exist.");
1:       }
1:     }
1: 
1:     String[] sortColumnBounds = StringUtils.splitPreserveAllTokens(
1:         loadModel.getSortColumnsBoundsStr(),
1:         CarbonLoadOptionConstants.SORT_COLUMN_BOUNDS_ROW_DELIMITER, -1);
1:     for (String bound : sortColumnBounds) {
1:       String[] fieldInBounds = StringUtils.splitPreserveAllTokens(bound,
1:           CarbonLoadOptionConstants.SORT_COLUMN_BOUNDS_FIELD_DELIMITER, -1);
1:       if (fieldInBounds.length != sortCols.size()) {
1:         String msg = new StringBuilder(
1:             "The number of field in bounds should be equal to that in sort columns.")
1:             .append(" Expected ").append(sortCols.size())
1:             .append(", actual ").append(String.valueOf(fieldInBounds.length)).append(".")
1:             .append(" The illegal bound is '").append(bound).append("'.").toString();
1:         throw new CarbonDataLoadingException(msg);
1:       }
1:     }
1: 
1:     SortColumnRangeInfo sortColumnRangeInfo = new SortColumnRangeInfo(sortColIndex,
1:         isSortColNoDict,
1:         sortColumnBounds,
1:         CarbonLoadOptionConstants.SORT_COLUMN_BOUNDS_FIELD_DELIMITER);
1:     configuration.setSortColumnRangeInfo(sortColumnRangeInfo);
1:   }
commit:910d496
/////////////////////////////////////////////////////////////////////////
1:     return new CarbonRowDataWriterProcessorStepImpl(configuration, converterProcessorStep);
commit:ded8b41
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.lang3.StringUtils;
1: 
/////////////////////////////////////////////////////////////////////////
1:   public AbstractDataLoadProcessorStep build(CarbonLoadModel loadModel, String[] storeLocation,
/////////////////////////////////////////////////////////////////////////
1:       String[] storeLocation) {
1:     CarbonDataProcessorUtil.createLocations(storeLocation);
1:     CarbonProperties.getInstance().addProperty(tempLocationKey,
1:         StringUtils.join(storeLocation, File.pathSeparator));
author:Raghunandan S
-------------------------------------------------------------------------------
commit:67a8a37
/////////////////////////////////////////////////////////////////////////
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:94d2089
/////////////////////////////////////////////////////////////////////////
1:     if (loadModel.getSdkWriterCores() > 0) {
1:       configuration.setWritingCoresCount(loadModel.getSdkWriterCores());
commit:17a4b48
/////////////////////////////////////////////////////////////////////////
0:     if (loadModel.getSdkUserCores() > 0) {
0:       configuration.setWritingCoresCount(loadModel.getSdkUserCores());
1:     }
commit:5804d75
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.loading.steps.JsonInputProcessorStepImpl;
/////////////////////////////////////////////////////////////////////////
1:     } else if (loadModel.isJsonFileLoad()) {
1:       return buildInternalWithJsonInputProcessor(inputIterators, configuration, sortScope);
1:     } else if (!configuration.isSortTable() || sortScope.equals(
1:         SortScopeOptions.SortScope.NO_SORT)) {
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Build pipe line for Load with json input processor.
1:    */
1:   private AbstractDataLoadProcessorStep buildInternalWithJsonInputProcessor(
1:       CarbonIterator[] inputIterators, CarbonDataLoadConfiguration configuration,
1:       SortScopeOptions.SortScope sortScope) {
1:     // currently row by row conversion of string json to carbon row is supported.
1:     AbstractDataLoadProcessorStep inputProcessorStep =
1:         new JsonInputProcessorStepImpl(configuration, inputIterators);
1:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:     // data types and configurations.
1:     AbstractDataLoadProcessorStep converterProcessorStep =
1:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
1:     if (sortScope.equals(SortScopeOptions.SortScope.LOCAL_SORT)) {
1:       AbstractDataLoadProcessorStep sortProcessorStep =
1:           new SortProcessorStepImpl(configuration, converterProcessorStep);
1:       //  Writes the sorted data in carbondata format.
1:       return new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
1:     } else if (sortScope.equals(SortScopeOptions.SortScope.BATCH_SORT)) {
1:       //  Sorts the data by SortColumn or not
1:       AbstractDataLoadProcessorStep sortProcessorStep =
1:           new SortProcessorStepImpl(configuration, converterProcessorStep);
1:       // Writes the sorted data in carbondata format.
1:       return new DataWriterBatchProcessorStepImpl(configuration, sortProcessorStep);
1:     } else {
1:       // In all other cases like global sort and no sort uses this step
1:       return new CarbonRowDataWriterProcessorStepImpl(configuration, converterProcessorStep);
1:     }
1:   }
1: 
commit:280a400
/////////////////////////////////////////////////////////////////////////
0:     configuration.setCarbonUnmanagedTable(loadModel.isCarbonUnmanagedTable());
/////////////////////////////////////////////////////////////////////////
1: 
author:kunal642
-------------------------------------------------------------------------------
commit:7a1d12a
/////////////////////////////////////////////////////////////////////////
1:     configuration.setParentTablePath(loadModel.getParentTablePath());
/////////////////////////////////////////////////////////////////////////
1:     configuration.setParentTablePath(loadModel.getParentTablePath());
commit:6b70b7e
/////////////////////////////////////////////////////////////////////////
1:         List<CarbonDimension> childDimensions =
1:             ((CarbonDimension) dataField.getColumn()).getListOfChildDimensions();
1:         for (CarbonDimension childDimension : childDimensions) {
1:           if (childDimension.getDataType() == DataTypes.DATE) {
1:             childDimension.setDateFormat(loadModel.getDateFormat());
1:           } else if (childDimension.getDataType() == DataTypes.TIMESTAMP) {
1:             childDimension.setTimestampFormat(loadModel.getTimestampformat());
1:           }
1:         }
author:xubo245
-------------------------------------------------------------------------------
commit:cf55028
/////////////////////////////////////////////////////////////////////////
1:     if (loadModel.isLoadWithoutConverterStep()) {
author:sounakr
-------------------------------------------------------------------------------
commit:ec33c11
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.loading.steps.InputProcessorStepWithNoConverterImpl;
/////////////////////////////////////////////////////////////////////////
0:     if (loadModel.isLoadWithoutCoverterStep()) {
1:       return buildInternalWithNoConverter(inputIterators, configuration, sortScope);
/////////////////////////////////////////////////////////////////////////
1:    * Build pipe line for Load without Conversion Step.
1:   private AbstractDataLoadProcessorStep buildInternalWithNoConverter(
1:         new InputProcessorStepWithNoConverterImpl(configuration, inputIterators);
commit:3202cf5
/////////////////////////////////////////////////////////////////////////
1:         column.setDateFormat(loadModel.getDateFormat());
1:         column.setTimestampFormat(loadModel.getTimestampformat());
commit:b7b8073
/////////////////////////////////////////////////////////////////////////
1:     configuration.setCarbonTransactionalTable(loadModel.isCarbonTransactionalTable());
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:56330ae
/////////////////////////////////////////////////////////////////////////
1:     TableSpec tableSpec = new TableSpec(carbonTable);
author:Jacky Li
-------------------------------------------------------------------------------
commit:5bedd77
/////////////////////////////////////////////////////////////////////////
commit:5fc7f06
/////////////////////////////////////////////////////////////////////////
1:         carbonTable.getDimensionByTableName(carbonTable.getTableName());
1:         carbonTable.getMeasureByTableName(carbonTable.getTableName());
/////////////////////////////////////////////////////////////////////////
1:     configuration.setBucketingInfo(carbonTable.getBucketingInfo(carbonTable.getTableName()));
commit:349c59c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.carbondata.processing.loading;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.loading.constants.DataLoadProcessorConstants;
1: import org.apache.carbondata.processing.loading.model.CarbonLoadModel;
1: import org.apache.carbondata.processing.loading.sort.SortScopeOptions;
1: import org.apache.carbondata.processing.loading.steps.CarbonRowDataWriterProcessorStepImpl;
1: import org.apache.carbondata.processing.loading.steps.DataConverterProcessorStepImpl;
0: import org.apache.carbondata.processing.loading.steps.DataConverterProcessorWithBucketingStepImpl;
1: import org.apache.carbondata.processing.loading.steps.DataWriterBatchProcessorStepImpl;
1: import org.apache.carbondata.processing.loading.steps.DataWriterProcessorStepImpl;
1: import org.apache.carbondata.processing.loading.steps.InputProcessorStepImpl;
1: import org.apache.carbondata.processing.loading.steps.SortProcessorStepImpl;
/////////////////////////////////////////////////////////////////////////
author:ravipesala
-------------------------------------------------------------------------------
commit:74f5d67
/////////////////////////////////////////////////////////////////////////
0:     if (loadModel.isPartitionLoad()) {
0:       return buildInternalForPartitionLoad(inputIterators, configuration, sortScope);
0:     } else if (!configuration.isSortTable() ||
0:         sortScope.equals(SortScopeOptions.SortScope.NO_SORT)) {
commit:8d3c774
/////////////////////////////////////////////////////////////////////////
0:     if ((!configuration.isSortTable() || sortScope.equals(SortScopeOptions.SortScope.NO_SORT))
0:         && !loadModel.isPartitionLoad()) {
/////////////////////////////////////////////////////////////////////////
1:     configuration.setDataWritePath(loadModel.getDataWritePath());
commit:dded5d5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.loading.steps.InputProcessorStepForPartitionImpl;
/////////////////////////////////////////////////////////////////////////
0:     } else if (loadModel.isPartitionLoad()) {
0:       return buildInternalForPartitionLoad(inputIterators, configuration, sortScope);
/////////////////////////////////////////////////////////////////////////
1:   /**
0:    * Build pipe line for partition load
1:    */
0:   private AbstractDataLoadProcessorStep buildInternalForPartitionLoad(
1:       CarbonIterator[] inputIterators, CarbonDataLoadConfiguration configuration,
1:       SortScopeOptions.SortScope sortScope) {
1:     // Wraps with dummy processor.
1:     AbstractDataLoadProcessorStep inputProcessorStep =
0:         new InputProcessorStepForPartitionImpl(configuration, inputIterators);
1:     if (sortScope.equals(SortScopeOptions.SortScope.LOCAL_SORT)) {
1:       AbstractDataLoadProcessorStep sortProcessorStep =
1:           new SortProcessorStepImpl(configuration, inputProcessorStep);
1:       //  Writes the sorted data in carbondata format.
1:       return new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
1:     } else if (sortScope.equals(SortScopeOptions.SortScope.BATCH_SORT)) {
1:       //  Sorts the data by SortColumn or not
1:       AbstractDataLoadProcessorStep sortProcessorStep =
1:           new SortProcessorStepImpl(configuration, inputProcessorStep);
1:       // Writes the sorted data in carbondata format.
1:       return new DataWriterBatchProcessorStepImpl(configuration, sortProcessorStep);
1:     } else {
1:       // In all other cases like global sort and no sort uses this step
1:       return new CarbonRowDataWriterProcessorStepImpl(configuration, inputProcessorStep);
1:     }
1:   }
1: 
commit:a89587e
/////////////////////////////////////////////////////////////////////////
1:     // For partition loading always use single core as it already runs in multiple
1:     // threads per partition
1:     if (carbonTable.isHivePartitionTable()) {
1:       configuration.setWritingCoresCount((short) 1);
1:     }
commit:3807b2f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.newflow.sort.SortScopeOptions;
/////////////////////////////////////////////////////////////////////////
1:     SortScopeOptions.SortScope sortScope = CarbonDataProcessorUtil.getSortScope(configuration);
0:     if (!configuration.isSortTable() || sortScope.equals(SortScopeOptions.SortScope.NO_SORT)) {
1:     } else if (sortScope.equals(SortScopeOptions.SortScope.BATCH_SORT)) {
/////////////////////////////////////////////////////////////////////////
1:     configuration
1:         .setDataLoadProperty(CarbonCommonConstants.LOAD_SORT_SCOPE, loadModel.getSortScope());
1:     configuration.setDataLoadProperty(CarbonCommonConstants.LOAD_BATCH_SORT_SIZE_INMB,
1:         loadModel.getBatchSortSizeInMb());
commit:b13ead9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.newflow.steps.DataWriterBatchProcessorStepImpl;
/////////////////////////////////////////////////////////////////////////
0:     boolean batchSort = Boolean.parseBoolean(CarbonProperties.getInstance()
0:         .getProperty(CarbonCommonConstants.LOAD_USE_BATCH_SORT,
0:             CarbonCommonConstants.LOAD_USE_BATCH_SORT_DEFAULT));
0:     } else if (batchSort) {
1:       return buildInternalForBatchSort(inputIterators, configuration);
/////////////////////////////////////////////////////////////////////////
1:   private AbstractDataLoadProcessorStep buildInternalForBatchSort(CarbonIterator[] inputIterators,
1:       CarbonDataLoadConfiguration configuration) {
1:     // 1. Reads the data input iterators and parses the data.
1:     AbstractDataLoadProcessorStep inputProcessorStep =
1:         new InputProcessorStepImpl(configuration, inputIterators);
1:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:     // data types and configurations.
1:     AbstractDataLoadProcessorStep converterProcessorStep =
1:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
0:     // 3. Sorts the data which are part of key (all dimensions except complex types)
1:     AbstractDataLoadProcessorStep sortProcessorStep =
1:         new SortProcessorStepImpl(configuration, converterProcessorStep);
1:     // 4. Writes the sorted data in carbondata format.
0:     AbstractDataLoadProcessorStep writerProcessorStep =
0:         new DataWriterBatchProcessorStepImpl(configuration, sortProcessorStep);
0:     return writerProcessorStep;
1:   }
1: 
commit:8100d94
/////////////////////////////////////////////////////////////////////////
1:     configuration.setPreFetch(loadModel.isPreFetch());
commit:05b2654
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang3.StringUtils;
1: 
/////////////////////////////////////////////////////////////////////////
0:       // if firstRow = " ", then throw exception
0:       if (StringUtils.isNotEmpty(csvHeader) && StringUtils.isBlank(csvHeader)) {
0:         throw new CarbonDataLoadingException("First line of the csv is not valid.");
1:       }
/////////////////////////////////////////////////////////////////////////
1:     // configuration for one pass load: dictionary server info
1:     configuration.setUseOnePass(loadModel.getUseOnePass());
1:     configuration.setDictionaryServerHost(loadModel.getDictionaryServerHost());
1:     configuration.setDictionaryServerPort(loadModel.getDictionaryServerPort());
1: 
commit:cbf8797
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.newflow.steps.DataConverterProcessorWithBucketingStepImpl;
/////////////////////////////////////////////////////////////////////////
0:     if (configuration.getBucketingInfo() != null) {
1:       return buildInternalForBucketing(inputIterators, configuration);
1:     } else {
1:       return buildInternal(inputIterators, configuration);
1:     }
1:   }
1: 
1:   private AbstractDataLoadProcessorStep buildInternal(CarbonIterator[] inputIterators,
1:       CarbonDataLoadConfiguration configuration) {
/////////////////////////////////////////////////////////////////////////
1:   private AbstractDataLoadProcessorStep buildInternalForBucketing(CarbonIterator[] inputIterators,
1:       CarbonDataLoadConfiguration configuration) throws Exception {
1:     // 1. Reads the data input iterators and parses the data.
1:     AbstractDataLoadProcessorStep inputProcessorStep =
1:         new InputProcessorStepImpl(configuration, inputIterators);
1:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:     // data types and configurations.
1:     AbstractDataLoadProcessorStep converterProcessorStep =
0:         new DataConverterProcessorWithBucketingStepImpl(configuration, inputProcessorStep);
0:     // 3. Sorts the data which are part of key (all dimensions except complex types)
1:     AbstractDataLoadProcessorStep sortProcessorStep =
1:         new SortProcessorStepImpl(configuration, converterProcessorStep);
1:     // 4. Writes the sorted data in carbondata format.
0:     AbstractDataLoadProcessorStep writerProcessorStep =
0:         new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
0:     return writerProcessorStep;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:     configuration.setBucketingInfo(carbonTable.getBucketingInfo(carbonTable.getFactTableName()));
commit:63434fa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.common.CarbonIterator;
0: import org.apache.carbondata.core.carbon.metadata.CarbonMetadata;
/////////////////////////////////////////////////////////////////////////
1:       CarbonIterator[] inputIterators) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     if(CarbonMetadata.getInstance().getCarbonTable(carbonTable.getTableUniqueName()) == null) {
1:       CarbonMetadata.getInstance().addCarbonTable(carbonTable);
1:     }
commit:496cde4
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
0: package org.apache.carbondata.processing.newflow;
1: 
1: import java.io.File;
1: import java.util.ArrayList;
0: import java.util.Iterator;
1: import java.util.List;
0: import java.util.Map;
1: 
0: import org.apache.carbondata.common.logging.LogService;
0: import org.apache.carbondata.common.logging.LogServiceFactory;
0: import org.apache.carbondata.core.carbon.AbsoluteTableIdentifier;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.CarbonTable;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonColumn;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonDimension;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonMeasure;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: import org.apache.carbondata.core.datastorage.store.filesystem.CarbonFile;
1: import org.apache.carbondata.core.util.CarbonProperties;
0: import org.apache.carbondata.processing.model.CarbonLoadModel;
0: import org.apache.carbondata.processing.newflow.constants.DataLoadProcessorConstants;
0: import org.apache.carbondata.processing.newflow.exception.CarbonDataLoadingException;
0: import org.apache.carbondata.processing.newflow.steps.DataConverterProcessorStepImpl;
0: import org.apache.carbondata.processing.newflow.steps.DataWriterProcessorStepImpl;
0: import org.apache.carbondata.processing.newflow.steps.InputProcessorStepImpl;
0: import org.apache.carbondata.processing.newflow.steps.SortProcessorStepImpl;
1: import org.apache.carbondata.processing.util.CarbonDataProcessorUtil;
1: 
1: /**
1:  * It builds the pipe line of steps for loading data to carbon.
1:  */
1: public final class DataLoadProcessBuilder {
1: 
0:   private static final LogService LOGGER =
0:       LogServiceFactory.getLogService(DataLoadProcessBuilder.class.getName());
1: 
0:   public AbstractDataLoadProcessorStep build(CarbonLoadModel loadModel, String storeLocation,
0:       Iterator[] inputIterators) throws Exception {
0:     CarbonDataLoadConfiguration configuration =
0:         createConfiguration(loadModel, storeLocation);
1:     // 1. Reads the data input iterators and parses the data.
1:     AbstractDataLoadProcessorStep inputProcessorStep =
1:         new InputProcessorStepImpl(configuration, inputIterators);
1:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:     // data types and configurations.
1:     AbstractDataLoadProcessorStep converterProcessorStep =
1:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
0:     // 3. Sorts the data which are part of key (all dimensions except complex types)
1:     AbstractDataLoadProcessorStep sortProcessorStep =
1:         new SortProcessorStepImpl(configuration, converterProcessorStep);
1:     // 4. Writes the sorted data in carbondata format.
0:     AbstractDataLoadProcessorStep writerProcessorStep =
0:         new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
0:     return writerProcessorStep;
1:   }
1: 
0:   private CarbonDataLoadConfiguration createConfiguration(CarbonLoadModel loadModel,
0:       String storeLocation) throws Exception {
0:     if (!new File(storeLocation).mkdirs()) {
0:       LOGGER.error("Error while creating the temp store path: " + storeLocation);
1:     }
1:     CarbonDataLoadConfiguration configuration = new CarbonDataLoadConfiguration();
1:     String databaseName = loadModel.getDatabaseName();
1:     String tableName = loadModel.getTableName();
0:     String tempLocationKey = databaseName + CarbonCommonConstants.UNDERSCORE + tableName
0:         + CarbonCommonConstants.UNDERSCORE + loadModel.getTaskNo();
0:     CarbonProperties.getInstance().addProperty(tempLocationKey, storeLocation);
0:     CarbonProperties.getInstance()
0:         .addProperty(CarbonCommonConstants.STORE_LOCATION_HDFS, loadModel.getStorePath());
1: 
1:     CarbonTable carbonTable = loadModel.getCarbonDataLoadSchema().getCarbonTable();
1:     AbsoluteTableIdentifier identifier = carbonTable.getAbsoluteTableIdentifier();
1:     configuration.setTableIdentifier(identifier);
0:     String csvHeader = loadModel.getCsvHeader();
0:     String csvFileName = null;
0:     if (csvHeader != null && !csvHeader.isEmpty()) {
0:       configuration.setHeader(CarbonDataProcessorUtil.getColumnFields(csvHeader, ","));
1:     } else {
0:       CarbonFile csvFile =
0:           CarbonDataProcessorUtil.getCsvFileToRead(loadModel.getFactFilesToProcess().get(0));
0:       csvFileName = csvFile.getName();
0:       csvHeader = CarbonDataProcessorUtil.getFileHeader(csvFile);
0:       configuration.setHeader(
0:           CarbonDataProcessorUtil.getColumnFields(csvHeader, loadModel.getCsvDelimiter()));
1:     }
0:     if (!CarbonDataProcessorUtil
0:         .isHeaderValid(loadModel.getTableName(), csvHeader, loadModel.getCarbonDataLoadSchema(),
0:             loadModel.getCsvDelimiter())) {
0:       if (csvFileName == null) {
0:         LOGGER.error("CSV header provided in DDL is not proper."
0:             + " Column names in schema and CSV header are not the same.");
0:         throw new CarbonDataLoadingException(
0:             "CSV header provided in DDL is not proper. Column names in schema and CSV header are "
0:                 + "not the same.");
1:       } else {
0:         LOGGER.error(
0:             "CSV File provided is not proper. Column names in schema and csv header are not same. "
0:                 + "CSVFile Name : " + csvFileName);
0:         throw new CarbonDataLoadingException(
0:             "CSV File provided is not proper. Column names in schema and csv header are not same. "
0:                 + "CSVFile Name : " + csvFileName);
1:       }
1:     }
1: 
0:     configuration.setPartitionId(loadModel.getPartitionId());
1:     configuration.setSegmentId(loadModel.getSegmentId());
1:     configuration.setTaskNo(loadModel.getTaskNo());
1:     configuration.setDataLoadProperty(DataLoadProcessorConstants.COMPLEX_DELIMITERS,
1:         new String[] { loadModel.getComplexDelimiterLevel1(),
1:             loadModel.getComplexDelimiterLevel2() });
1:     configuration.setDataLoadProperty(DataLoadProcessorConstants.SERIALIZATION_NULL_FORMAT,
1:         loadModel.getSerializationNullFormat().split(",")[1]);
1:     configuration.setDataLoadProperty(DataLoadProcessorConstants.FACT_TIME_STAMP,
1:         loadModel.getFactTimeStamp());
1:     configuration.setDataLoadProperty(DataLoadProcessorConstants.BAD_RECORDS_LOGGER_ENABLE,
1:         loadModel.getBadRecordsLoggerEnable().split(",")[1]);
1:     configuration.setDataLoadProperty(DataLoadProcessorConstants.BAD_RECORDS_LOGGER_ACTION,
1:         loadModel.getBadRecordsAction().split(",")[1]);
1:     configuration.setDataLoadProperty(DataLoadProcessorConstants.FACT_FILE_PATH,
1:         loadModel.getFactFilePath());
1:     List<CarbonDimension> dimensions =
0:         carbonTable.getDimensionByTableName(carbonTable.getFactTableName());
1:     List<CarbonMeasure> measures =
0:         carbonTable.getMeasureByTableName(carbonTable.getFactTableName());
0:     Map<String, String> dateFormatMap =
0:         CarbonDataProcessorUtil.getDateFormatMap(loadModel.getDateFormat());
1:     List<DataField> dataFields = new ArrayList<>();
1:     List<DataField> complexDataFields = new ArrayList<>();
1: 
1:     // First add dictionary and non dictionary dimensions because these are part of mdk key.
1:     // And then add complex data types and measures.
1:     for (CarbonColumn column : dimensions) {
1:       DataField dataField = new DataField(column);
0:       dataField.setDateFormat(dateFormatMap.get(column.getColName()));
1:       if (column.isComplex()) {
1:         complexDataFields.add(dataField);
1:       } else {
1:         dataFields.add(dataField);
1:       }
1:     }
1:     dataFields.addAll(complexDataFields);
1:     for (CarbonColumn column : measures) {
1:       // This dummy measure is added when no measure was present. We no need to load it.
1:       if (!(column.getColName().equals("default_dummy_measure"))) {
1:         dataFields.add(new DataField(column));
1:       }
1:     }
1:     configuration.setDataFields(dataFields.toArray(new DataField[dataFields.size()]));
1:     return configuration;
1:   }
1: 
1: }
author:sounak
-------------------------------------------------------------------------------
commit:4daf063
/////////////////////////////////////////////////////////////////////////
1:     configuration.setDictionaryServerSecretKey(loadModel.getDictionaryServerSecretKey());
1:     configuration.setDictionaryEncryptServerSecure(loadModel.getDictionaryEncryptServerSecure());
1:     configuration.setDictionaryServiceProvider(loadModel.getDictionaryServiceProvider());
author:dhatchayani
-------------------------------------------------------------------------------
commit:40f0608
/////////////////////////////////////////////////////////////////////////
1:     configuration.setDataLoadProperty(DataLoadProcessorConstants.SKIP_EMPTY_LINE,
1:         loadModel.getSkipEmptyLine());
author:akashrn5
-------------------------------------------------------------------------------
commit:85dc4ff
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       if (column.getDataType() == DataTypes.DATE) {
1:         dataField.setDateFormat(loadModel.getDateFormat());
1:       } else if (column.getDataType() == DataTypes.TIMESTAMP) {
1:         dataField.setTimestampFormat(loadModel.getTimestampformat());
0:       }
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:1155d4d
/////////////////////////////////////////////////////////////////////////
0:         .addProperty(CarbonCommonConstants.STORE_LOCATION_HDFS, loadModel.getTablePath());
commit:39644b5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.constants.CarbonLoadOptionConstants;
/////////////////////////////////////////////////////////////////////////
1:     configuration.setDataLoadProperty(CarbonLoadOptionConstants.CARBON_OPTIONS_BAD_RECORD_PATH,
1:         loadModel.getBadRecordsLocation());
commit:3251c89
/////////////////////////////////////////////////////////////////////////
1:     configuration.setDataLoadProperty(DataLoadProcessorConstants.IS_EMPTY_DATA_BAD_RECORD,
1:         loadModel.getIsEmptyDataBadRecord().split(",")[1]);
author:lionelcao
-------------------------------------------------------------------------------
commit:874764f
/////////////////////////////////////////////////////////////////////////
1:             loadModel.getTaskNo(), false, false);
author:manishgupta88
-------------------------------------------------------------------------------
commit:1f83125
/////////////////////////////////////////////////////////////////////////
1:         .getTempStoreLocationKey(databaseName, tableName, loadModel.getSegmentId(),
0:             loadModel.getTaskNo(), false);
commit:f890d00
/////////////////////////////////////////////////////////////////////////
1:     String tempLocationKey = CarbonDataProcessorUtil
0:         .getTempStoreLocationKey(databaseName, tableName, loadModel.getTaskNo(), false);
commit:cc59b24
/////////////////////////////////////////////////////////////////////////
0:     CarbonMetadata.getInstance().addCarbonTable(carbonTable);
commit:6b3b16c
/////////////////////////////////////////////////////////////////////////
0:       DataField dataField = new DataField(column);
0:       dataField.setDateFormat(dateFormatMap.get(column.getColName()));
0:       if (column.isComplex()) {
0:         complexDataFields.add(dataField);
0:       } else {
0:         dataFields.add(dataField);
0:       if (!(column.getColName().equals("default_dummy_measure"))) {
commit:fc1af96
/////////////////////////////////////////////////////////////////////////
1:     configuration.setSchemaUpdatedTimeStamp(carbonTable.getTableLastUpdatedTime());
commit:70256e7
/////////////////////////////////////////////////////////////////////////
0:       if (!column.isInvisible()) {
0:         DataField dataField = new DataField(column);
0:         dataField.setDateFormat(dateFormatMap.get(column.getColName()));
0:         if (column.isComplex()) {
0:           complexDataFields.add(dataField);
0:         } else {
0:           dataFields.add(dataField);
0:         }
0:       if (!column.isInvisible() && !(column.getColName().equals("default_dummy_measure"))) {
author:Yadong Qi
-------------------------------------------------------------------------------
commit:82741c1
/////////////////////////////////////////////////////////////////////////
1:   public static CarbonDataLoadConfiguration createConfiguration(CarbonLoadModel loadModel,
0:       String storeLocation) {
0: 
/////////////////////////////////////////////////////////////////////////
1:     return createConfiguration(loadModel);
0:   }
0: 
1:   public static CarbonDataLoadConfiguration createConfiguration(CarbonLoadModel loadModel) {
0:     CarbonDataLoadConfiguration configuration = new CarbonDataLoadConfiguration();
/////////////////////////////////////////////////////////////////////////
1:     configuration.setDataLoadProperty(CarbonCommonConstants.LOAD_GLOBAL_SORT_PARTITIONS,
1:         loadModel.getGlobalSortPartitions());
author:jackylk
-------------------------------------------------------------------------------
commit:dc83b2a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.TableSpec;
/////////////////////////////////////////////////////////////////////////
0:     TableSpec tableSpec = new TableSpec(dimensions, measures);
1:     configuration.setTableSpec(tableSpec);
commit:353272e
/////////////////////////////////////////////////////////////////////////
1:     CarbonDataLoadConfiguration configuration = createConfiguration(loadModel, storeLocation);
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1: import org.apache.carbondata.core.metadata.CarbonMetadata;
1: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
author:QiangCai
-------------------------------------------------------------------------------
commit:81149f6
/////////////////////////////////////////////////////////////////////////
1:     return new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
/////////////////////////////////////////////////////////////////////////
1:     return new DataWriterBatchProcessorStepImpl(configuration, sortProcessorStep);
/////////////////////////////////////////////////////////////////////////
1:     return new DataWriterProcessorStepImpl(configuration, sortProcessorStep);
commit:4827315
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.newflow.steps.CarbonRowDataWriterProcessorStepImpl;
/////////////////////////////////////////////////////////////////////////
0:     if (!configuration.isSortTable()) {
1:       return buildInternalForNoSort(inputIterators, configuration);
1:     } else if (configuration.getBucketingInfo() != null) {
/////////////////////////////////////////////////////////////////////////
1:     // 3. Sorts the data by SortColumn
0:     AbstractDataLoadProcessorStep sortProcessorStep =
0:         new SortProcessorStepImpl(configuration, converterProcessorStep);
1:   private AbstractDataLoadProcessorStep buildInternalForNoSort(CarbonIterator[] inputIterators,
1:       CarbonDataLoadConfiguration configuration) {
1:     // 1. Reads the data input iterators and parses the data.
1:     AbstractDataLoadProcessorStep inputProcessorStep =
1:         new InputProcessorStepImpl(configuration, inputIterators);
1:     // 2. Converts the data like dictionary or non dictionary or complex objects depends on
1:     // data types and configurations.
1:     AbstractDataLoadProcessorStep converterProcessorStep =
1:         new DataConverterProcessorStepImpl(configuration, inputProcessorStep);
1:     // 3. Writes the sorted data in carbondata format.
0:     AbstractDataLoadProcessorStep writerProcessorStep =
0:         new CarbonRowDataWriterProcessorStepImpl(configuration, converterProcessorStep);
0:     return writerProcessorStep;
0:   }
0: 
/////////////////////////////////////////////////////////////////////////
0:     AbstractDataLoadProcessorStep sortProcessorStep =
0:         new SortProcessorStepImpl(configuration, converterProcessorStep);
/////////////////////////////////////////////////////////////////////////
0:     AbstractDataLoadProcessorStep sortProcessorStep =
0:         new SortProcessorStepImpl(configuration, converterProcessorStep);
commit:9f94529
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.newflow.steps.NoSortProcessorStepImpl;
/////////////////////////////////////////////////////////////////////////
1:     // 3. Sorts the data by SortColumn or not
0:     AbstractDataLoadProcessorStep sortProcessorStep = configuration.isSortTable() ?
0:         new SortProcessorStepImpl(configuration, converterProcessorStep) :
0:         new NoSortProcessorStepImpl(configuration, converterProcessorStep);
/////////////////////////////////////////////////////////////////////////
1:     // 3. Sorts the data by SortColumn or not
0:     AbstractDataLoadProcessorStep sortProcessorStep = configuration.isSortTable() ?
0:         new SortProcessorStepImpl(configuration, converterProcessorStep) :
0:         new NoSortProcessorStepImpl(configuration, converterProcessorStep);
/////////////////////////////////////////////////////////////////////////
0:     // 3. Sorts the data by SortColumn or not
0:     AbstractDataLoadProcessorStep sortProcessorStep = configuration.isSortTable() ?
0:         new SortProcessorStepImpl(configuration, converterProcessorStep) :
0:         new NoSortProcessorStepImpl(configuration, converterProcessorStep);
/////////////////////////////////////////////////////////////////////////
1:     configuration.setNumberOfSortColumns(carbonTable.getNumberOfSortColumns());
1:     configuration.setNumberOfNoDictSortColumns(carbonTable.getNumberOfNoDictSortColumns());
commit:256dbed
/////////////////////////////////////////////////////////////////////////
0:     if (CarbonMetadata.getInstance().getCarbonTable(carbonTable.getTableUniqueName()) == null) {
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0: 
commit:cbc33c4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     configuration.setHeader(loadModel.getCsvHeaderColumns());
============================================================================