2:cd6a4ff: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
1:9f94529:  *
1:cd6a4ff:  *    http://www.apache.org/licenses/LICENSE-2.0
1:9f94529:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
9:cd6a4ff:  */
20:cd6a4ff: 
1:cd6a4ff: package org.apache.carbondata.core.util;
1:cd6a4ff: 
1:9f94529: import java.io.UnsupportedEncodingException;
1:cd6a4ff: import java.nio.ByteBuffer;
1:9f94529: import java.nio.charset.StandardCharsets;
1:cd6a4ff: 
1:cd61beb: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:b13ead9: import org.apache.carbondata.core.memory.CarbonUnsafe;
1:cd6a4ff: 
8:cd6a4ff: /**
1:cd6a4ff:  * Util class for byte comparision
1:cd6a4ff:  */
1:cd6a4ff: public final class ByteUtil {
1:9f94529: 
1:438b442:   public static final int SIZEOF_BYTE = 1;
1:438b442: 
1:9f94529:   public static final int SIZEOF_SHORT = 2;
1:438b442: 
1:438b442:   public static final int SIZEOF_SHORT_INT = 3;
1:cd6a4ff: 
1:9f94529:   public static final int SIZEOF_INT = 4;
1:438b442: 
1:9f94529:   public static final int SIZEOF_LONG = 8;
1:9f94529: 
1:8f08c4a:   public static final int SIZEOF_FLOAT = 4;
1:8f08c4a: 
1:438b442:   public static final int SIZEOF_DOUBLE = 8;
1:9f94529: 
1:9f94529:   public static final String UTF8_CSN = StandardCharsets.UTF_8.name();
1:98df130: 
1:cd6a4ff:   private ByteUtil() {
1:cd6a4ff: 
22:cd6a4ff:   }
1:6297ea0: 
1:9f94529:   /**
1:cd6a4ff:    * Compare method for bytes
1:9f94529:    *
1:cd6a4ff:    * @param buffer1
1:cd6a4ff:    * @param buffer2
3:9f94529:    * @return
1:9f94529:    */
1:cd6a4ff:   public static int compare(byte[] buffer1, byte[] buffer2) {
1:cd6a4ff:     // Short circuit equal case
1:cd6a4ff:     if (buffer1 == buffer2) {
2:cd6a4ff:       return 0;
1:6297ea0:     }
1:105e3a0:     int len1 = buffer1.length;
1:105e3a0:     int len2 = buffer2.length;
1:105e3a0:     int offset1 = 0;
1:105e3a0:     int offset2 = 0;
1:105e3a0:     // Call UnsafeComparer compareTo for comparision.
1:105e3a0:     return ByteUtil.UnsafeComparer.INSTANCE
1:105e3a0:         .compareTo(buffer1, offset1, len1, buffer2, offset2, len2);
1:7d386a4:   }
1:d85fb72: 
1:105e3a0: 
1:7d386a4:   /**
1:cd6a4ff:    * covert the long[] to int[]
1:9f94529:    *
1:cd6a4ff:    * @param longArray
1:9f94529:    * @return
1:7d386a4:    */
1:cd6a4ff:   public static int[] convertToIntArray(long[] longArray) {
1:cd6a4ff:     int[] intArray = new int[longArray.length];
1:cd6a4ff:     for (int i = 0; i < longArray.length; i++) {
1:cd6a4ff:       intArray[i] = (int) longArray[i];
1:7d386a4: 
1:7359601:     }
1:cd6a4ff:     return intArray;
1:dc83b2a:   }
1:7359601: 
1:dc83b2a:   /**
1:cd61beb:    * convert number in byte to more readable format
1:cd61beb:    * @param sizeInbyte
1:9f94529:    * @return
1:7d386a4:    */
1:cd61beb:   public static String convertByteToReadable(long sizeInbyte) {
1:7359601: 
1:cd61beb:     String readableSize;
1:cd61beb:     if (sizeInbyte < CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR) {
1:cd61beb:       readableSize = sizeInbyte + " Byte";
1:cd61beb:     } else if (sizeInbyte < CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR *
1:cd61beb:             CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR) {
1:cd61beb:       readableSize = sizeInbyte / CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR + " KB";
1:cd6a4ff:     } else {
1:cd61beb:       readableSize = sizeInbyte / CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR /
1:cd61beb:               CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR + " MB";
1:dc83b2a:     }
1:cd61beb:     return readableSize;
1:dc83b2a:   }
1:dc83b2a: 
1:9f94529:   /**
1:cd6a4ff:    * Unsafe comparator
1:dc83b2a:    */
1:cd6a4ff:   public enum UnsafeComparer {
1:7d386a4:     /**
1:cd6a4ff:      * instance.
1:cd6a4ff:      */
1:cd6a4ff:     INSTANCE;
1:dc83b2a: 
1:cd6a4ff:     /**
1:cd6a4ff:      * Returns true if x1 is less than x2, when both values are treated as
1:cd6a4ff:      * unsigned.
1:cd6a4ff:      */
1:cd6a4ff:     static boolean lessThanUnsigned(long x1, long x2) {
1:cd6a4ff:       return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);
1:cd6a4ff:     }
1:b13ead9: 
1:cd6a4ff:     /**
1:cd6a4ff:      * Lexicographically compare two arrays.
1:9f94529:      *
1:cd6a4ff:      * @param buffer1 left operand
1:cd6a4ff:      * @param buffer2 right operand
1:cd6a4ff:      * @param offset1 Where to start comparing in the left buffer
1:cd6a4ff:      * @param offset2 Where to start comparing in the right buffer
1:cd6a4ff:      * @param length1 How much to compare from the left buffer
1:cd6a4ff:      * @param length2 How much to compare from the right buffer
1:cd6a4ff:      * @return 0 if equal, < 0 if left is less than right, etc.
1:cd6a4ff:      */
1:cd6a4ff:     public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
1:cd6a4ff:         int length2) {
1:cd6a4ff:       // Short circuit equal case
1:cd6a4ff:       if (buffer1 == buffer2 && offset1 == offset2 && length1 == length2) {
1:cd6a4ff:         return 0;
1:cd6a4ff:       }
1:cd6a4ff:       int minLength = Math.min(length1, length2);
1:cd6a4ff:       int minWords = minLength / SIZEOF_LONG;
1:b13ead9:       int offset1Adj = offset1 + CarbonUnsafe.BYTE_ARRAY_OFFSET;
1:b13ead9:       int offset2Adj = offset2 + CarbonUnsafe.BYTE_ARRAY_OFFSET;
1:b13ead9: 
1:cd6a4ff:       /*
2:cd6a4ff:        * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes
2:cd6a4ff:        * at a time is no slower than comparing 4 bytes at a time even on
2:cd6a4ff:        * 32-bit. On the other hand, it is substantially faster on 64-bit.
1:b13ead9:        */
2:cd6a4ff:       for (int i = 0; i < minWords * SIZEOF_LONG; i += SIZEOF_LONG) {
1:500654e:         long lw = CarbonUnsafe.getUnsafe().getLong(buffer1, offset1Adj + (long) i);
1:500654e:         long rw = CarbonUnsafe.getUnsafe().getLong(buffer2, offset2Adj + (long) i);
2:cd6a4ff:         long diff = lw ^ rw;
1:cd6a4ff: 
2:cd6a4ff:         if (diff != 0) {
1:b13ead9:           if (!CarbonUnsafe.ISLITTLEENDIAN) {
2:cd6a4ff:             return lessThanUnsigned(lw, rw) ? -1 : 1;
1:cd6a4ff:           }
1:cd6a4ff: 
2:cd6a4ff:           // Use binary search
1:9f94529:           int n = 0;
2:cd6a4ff:           int y;
2:cd6a4ff:           int x = (int) diff;
2:cd6a4ff:           if (x == 0) {
2:cd6a4ff:             x = (int) (diff >>> 32);
1:cd6a4ff:             n = 32;
1:cd6a4ff:           }
1:cd6a4ff: 
2:cd6a4ff:           y = x << 16;
3:cd6a4ff:           if (y == 0) {
1:cd6a4ff:             n += 16;
1:cd6a4ff:           } else {
2:cd6a4ff:             x = y;
1:cd6a4ff:           }
1:cd6a4ff: 
2:cd6a4ff:           y = x << 8;
1:cd6a4ff:           if (y == 0) {
1:cd6a4ff:             n += 8;
1:cd6a4ff:           }
1:cd6a4ff:           return (int) (((lw >>> n) & 0xFFL) - ((rw >>> n) & 0xFFL));
1:cd6a4ff:         }
1:cd6a4ff:       }
1:cd6a4ff: 
2:cd6a4ff:       // The epilogue to cover the last (minLength % 8) elements.
2:cd6a4ff:       for (int i = minWords * SIZEOF_LONG; i < minLength; i++) {
1:cd6a4ff:         int a = (buffer1[offset1 + i] & 0xff);
1:cd6a4ff:         int b = (buffer2[offset2 + i] & 0xff);
3:cd6a4ff:         if (a != b) {
3:cd6a4ff:           return a - b;
1:cd6a4ff:         }
1:cd6a4ff:       }
1:cd6a4ff:       return length1 - length2;
1:cd6a4ff:     }
1:cd6a4ff: 
1:cd6a4ff:     public int compareTo(byte[] buffer1, byte[] buffer2) {
1:cd6a4ff: 
1:cd6a4ff:       // Short circuit equal case
1:cd6a4ff:       if (buffer1 == buffer2) {
1:cd6a4ff:         return 0;
1:cd6a4ff:       }
1:cd6a4ff:       int len1 = buffer1.length;
1:cd6a4ff:       int len2 = buffer2.length;
1:cd6a4ff:       int minLength = (len1 <= len2) ? len1 : len2;
1:b13ead9:       return compareTo(buffer1, buffer2, len1, len2, minLength);
1:b13ead9:     }
1:cd6a4ff: 
1:b13ead9:     public int compareTo(byte[] buffer1, byte[] buffer2, int len1, int len2, int minLength) {
1:b13ead9:       int minWords = 0;
1:b13ead9:       /*
1:b13ead9:        * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes
1:b13ead9:        * at a time is no slower than comparing 4 bytes at a time even on
1:b13ead9:        * 32-bit. On the other hand, it is substantially faster on 64-bit.
1:9f94529:        */
1:b13ead9:       if (minLength > 7) {
1:b13ead9:         minWords = minLength / SIZEOF_LONG;
1:b13ead9:         for (int i = 0; i < minWords * SIZEOF_LONG; i += SIZEOF_LONG) {
1:500654e:           long lw =
1:500654e:               CarbonUnsafe.getUnsafe().getLong(buffer1, CarbonUnsafe.BYTE_ARRAY_OFFSET + (long) i);
1:500654e:           long rw =
1:500654e:               CarbonUnsafe.getUnsafe().getLong(buffer2, CarbonUnsafe.BYTE_ARRAY_OFFSET + (long) i);
1:b13ead9:           long diff = lw ^ rw;
1:b13ead9: 
1:b13ead9:           if (diff != 0) {
1:b13ead9:             if (!CarbonUnsafe.ISLITTLEENDIAN) {
1:b13ead9:               return lessThanUnsigned(lw, rw) ? -1 : 1;
1:b13ead9:             }
1:b13ead9: 
1:b13ead9:             // Use binary search
1:b13ead9:             int k = 0;
1:b13ead9:             int y;
1:b13ead9:             int x = (int) diff;
1:b13ead9:             if (x == 0) {
1:b13ead9:               x = (int) (diff >>> 32);
1:b13ead9:               k = 32;
1:b13ead9:             }
1:b13ead9:             y = x << 16;
1:b13ead9:             if (y == 0) {
1:b13ead9:               k += 16;
1:b13ead9:             } else {
1:b13ead9:               x = y;
1:b13ead9:             }
1:b13ead9: 
1:b13ead9:             y = x << 8;
1:b13ead9:             if (y == 0) {
1:b13ead9:               k += 8;
1:b13ead9:             }
1:b13ead9:             return (int) (((lw >>> k) & 0xFFL) - ((rw >>> k) & 0xFFL));
1:b13ead9:           }
1:b13ead9:         }
1:b13ead9:       }
1:b13ead9: 
1:b13ead9:       // The epilogue to cover the last (minLength % 8) elements.
1:b13ead9:       for (int i = minWords * SIZEOF_LONG; i < minLength; i++) {
2:cd6a4ff:         int a = (buffer1[i] & 0xff);
1:cd6a4ff:         int b = (buffer2[i] & 0xff);
1:b13ead9:         if (a != b) {
1:b13ead9:           return a - b;
1:b13ead9:         }
1:b13ead9:       }
1:b13ead9:       return len1 - len2;
1:b13ead9:     }
1:500654e: 
1:cd6a4ff:     public boolean equals(byte[] buffer1, byte[] buffer2) {
1:cd6a4ff:       if (buffer1.length != buffer2.length) {
1:cd6a4ff:         return false;
1:cd6a4ff:       }
1:cd6a4ff:       int len = buffer1.length / 8;
1:b13ead9:       long currentOffset = CarbonUnsafe.BYTE_ARRAY_OFFSET;
1:cd6a4ff:       for (int i = 0; i < len; i++) {
1:500654e:         long lw = CarbonUnsafe.getUnsafe().getLong(buffer1, currentOffset);
1:500654e:         long rw = CarbonUnsafe.getUnsafe().getLong(buffer2, currentOffset);
1:8f59a32:         if (lw != rw) {
1:cd6a4ff:           return false;
1:cd6a4ff:         }
1:cd6a4ff:         currentOffset += 8;
1:cd6a4ff:       }
1:cd6a4ff:       len = buffer1.length % 8;
1:cd6a4ff:       if (len > 0) {
1:cd6a4ff:         for (int i = 0; i < len; i += 1) {
1:500654e:           long lw = CarbonUnsafe.getUnsafe().getByte(buffer1, currentOffset);
1:500654e:           long rw = CarbonUnsafe.getUnsafe().getByte(buffer2, currentOffset);
1:cd6a4ff:           if (lw != rw) {
1:cd6a4ff:             return false;
1:cd6a4ff:           }
1:cd6a4ff:           currentOffset += 1;
1:cd6a4ff:         }
1:cd6a4ff:       }
1:cd6a4ff:       return true;
1:8f59a32:     }
1:b13ead9: 
1:8f59a32:     public boolean equals(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
1:8f59a32:         int length2) {
1:8f59a32:       if (length1 != length2) {
1:8f59a32:         return false;
1:8f59a32:       }
1:8f59a32:       int len = length1 / 8;
1:8f59a32:       long currentOffset = CarbonUnsafe.BYTE_ARRAY_OFFSET;
1:8f59a32:       for (int i = 0; i < len; i++) {
1:500654e:         long lw = CarbonUnsafe.getUnsafe().getLong(buffer1, currentOffset + offset1);
1:500654e:         long rw = CarbonUnsafe.getUnsafe().getLong(buffer2, currentOffset + offset2);
1:8f59a32:         if (lw != rw) {
1:8f59a32:           return false;
1:8f59a32:         }
1:8f59a32:         currentOffset += 8;
1:8f59a32:       }
1:8f59a32:       len = buffer1.length % 8;
1:8f59a32:       if (len > 0) {
1:8f59a32:         for (int i = 0; i < len; i += 1) {
1:500654e:           long lw = CarbonUnsafe.getUnsafe().getByte(buffer1, currentOffset + offset1);
1:500654e:           long rw = CarbonUnsafe.getUnsafe().getByte(buffer2, currentOffset + offset2);
1:cd6a4ff:           if (lw != rw) {
1:8f59a32:             return false;
1:8f59a32:           }
1:8f59a32:           currentOffset += 1;
1:8f59a32:         }
1:8f59a32:       }
1:8f59a32:       return true;
1:cd6a4ff:     }
1:8f59a32: 
1:9f94529:     /**
1:cd6a4ff:      * Comparing the 2 byte buffers. This is used in case of data load sorting step.
1:9f94529:      *
1:cd6a4ff:      * @param byteBuffer1
1:cd6a4ff:      * @param byteBuffer2
1:9f94529:      * @return
1:9f94529:      */
1:cd6a4ff:     public int compareTo(ByteBuffer byteBuffer1, ByteBuffer byteBuffer2) {
1:cd6a4ff: 
1:cd6a4ff:       // Short circuit equal case
1:cd6a4ff:       if (byteBuffer1 == byteBuffer2) {
1:cd6a4ff:         return 0;
1:cd6a4ff:       }
1:cd6a4ff:       int len1 = byteBuffer1.remaining();
1:cd6a4ff:       int len2 = byteBuffer2.remaining();
1:cd6a4ff:       byte[] buffer1 = new byte[len1];
1:cd6a4ff:       byte[] buffer2 = new byte[len2];
1:cd6a4ff:       byteBuffer1.get(buffer1);
1:cd6a4ff:       byteBuffer2.get(buffer2);
1:cd6a4ff:       return compareTo(buffer1, buffer2);
1:cd6a4ff:     }
1:cd6a4ff: 
1:cd6a4ff:   }
1:cd6a4ff: 
1:9f94529:   /**
1:9f94529:    * Stirng => byte[]
1:9f94529:    *
1:9f94529:    * @param s
1:9f94529:    * @return
1:9f94529:    */
1:9f94529:   public static byte[] toBytes(String s) {
1:9f94529:     try {
1:9f94529:       return s.getBytes(UTF8_CSN);
1:9f94529:     } catch (UnsupportedEncodingException e) {
1:9f94529:       // should never happen!
1:9f94529:       throw new IllegalArgumentException("UTF8 decoding is not supported", e);
1:9f94529:     }
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:9f94529:    * byte[] => String
1:9f94529:    *
1:9f94529:    * @param b
1:9f94529:    * @param off
1:9f94529:    * @param len
1:9f94529:    * @return
1:9f94529:    */
1:9f94529:   public static String toString(final byte[] b, int off, int len) {
1:9f94529:     if (b == null) {
2:9f94529:       return null;
1:9f94529:     }
1:9f94529:     if (len == 0) {
1:9f94529:       return "";
1:9f94529:     }
1:9f94529:     try {
1:9f94529:       return new String(b, off, len, UTF8_CSN);
1:9f94529:     } catch (UnsupportedEncodingException e) {
1:9f94529:       // should never happen!
1:9f94529:       throw new IllegalArgumentException("UTF8 encoding is not supported", e);
1:9f94529:     }
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:9f94529:    * boolean => byte[]
1:9f94529:    *
1:9f94529:    * @param b
1:9f94529:    * @return
1:9f94529:    */
1:9f94529:   public static byte[] toBytes(final boolean b) {
1:9f94529:     return new byte[] { b ? (byte) -1 : (byte) 0 };
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:9f94529:    * byte[] => boolean
1:9f94529:    *
1:9f94529:    * @param b
1:9f94529:    * @return
1:9f94529:    */
1:9f94529:   public static boolean toBoolean(final byte[] b) {
1:9f94529:     if (b.length != 1) {
1:9f94529:       throw new IllegalArgumentException("Array has wrong size: " + b.length);
1:9f94529:     }
1:9f94529:     return b[0] != (byte) 0;
1:9f94529:   }
1:9f94529: 
1:bf44c9f:   public static boolean toBoolean(final byte b) {
1:bf44c9f:     return b != (byte) 0;
1:bf44c9f:   }
1:bf44c9f: 
1:9f94529:   /**
1:9f94529:    * short => byte[]
1:9f94529:    *
2:9f94529:    * @param val
1:9f94529:    * @return
1:9f94529:    */
1:9f94529:   public static byte[] toBytes(short val) {
1:9f94529:     byte[] b = new byte[SIZEOF_SHORT];
1:9f94529:     b[1] = (byte) val;
1:9f94529:     val >>= 8;
1:9f94529:     b[0] = (byte) val;
1:9f94529:     return b;
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:9f94529:    * byte[] => short
1:9f94529:    *
4:9f94529:    * @param bytes
4:9f94529:    * @param offset
2:9f94529:    * @param length
1:9f94529:    * @return
1:9f94529:    */
1:9f94529:   public static short toShort(byte[] bytes, int offset, final int length) {
1:9f94529:     if (length != SIZEOF_SHORT || offset + length > bytes.length) {
1:9f94529:       throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_SHORT);
1:9f94529:     }
1:f5c6f28:     short n = 0;
1:500654e:     if (CarbonUnsafe.getUnsafe() != null) {
1:9f94529:       if (CarbonUnsafe.ISLITTLEENDIAN) {
1:f5c6f28:         n = Short.reverseBytes(
1:500654e:             CarbonUnsafe.getUnsafe().getShort(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET));
1:9f94529:       } else {
1:500654e:         n = CarbonUnsafe.getUnsafe().getShort(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
1:9f94529:       }
1:9f94529:     } else {
1:f5c6f28: 
1:9f94529:       n ^= bytes[offset] & 0xFF;
1:9f94529:       n <<= 8;
1:9f94529:       n ^= bytes[offset + 1] & 0xFF;
1:9f94529:     }
1:f012f5b:     return n;
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:9f94529:    * int => byte[]
1:9f94529:    *
1:9f94529:    * @param val
1:9f94529:    * @return
1:9f94529:    */
1:9f94529:   public static byte[] toBytes(int val) {
1:9f94529:     byte[] b = new byte[4];
1:9f94529:     for (int i = 3; i > 0; i--) {
1:9f94529:       b[i] = (byte) val;
1:9f94529:       val >>>= 8;
1:9f94529:     }
1:9f94529:     b[0] = (byte) val;
1:9f94529:     return b;
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:7d386a4:    * int => byte[3]
1:7d386a4:    * supported range is [-8388608, 8388607], note that Math.pow(2, 24) == 8388608
1:9f94529:    */
1:7d386a4:   public static byte[] to3Bytes(int val) {
1:7d386a4:     assert val <= (Math.pow(2, 23) - 1) && val >= (-Math.pow(2, 23));
1:7d386a4:     return new byte[]{ (byte)(val >> 16), (byte)(val >> 8), (byte)val };
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:7d386a4:    * convert 3 bytes to int
1:9f94529:    */
1:7d386a4:   public static int valueOf3Bytes(byte[] val, int offset) {
1:7d386a4:     assert val.length >= offset + 3;
1:7d386a4:     if (val[offset] < 0) {
1:7d386a4:       return (((val[offset] & 0xFFFF) << 16) |
1:7d386a4:           ((val[offset + 1] & 0xFF) << 8) |
1:7d386a4:           ((val[offset + 2] & 0xFF)));
1:9f94529:     } else {
1:7d386a4:       return (((val[offset] & 0xFF) << 16) |
1:7d386a4:           ((val[offset + 1] & 0xFF) << 8) |
1:7d386a4:           ((val[offset + 2] & 0xFF)));
1:9f94529:     }
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:9f94529:    * byte[] => int
1:9f94529:    *
1:9f94529:    * @param bytes
1:9f94529:    * @param offset
1:9f94529:    * @param length
1:9f94529:    * @return
1:9f94529:    */
1:9f94529:   public static int toInt(byte[] bytes, int offset, final int length) {
1:9f94529:     if (length != SIZEOF_INT || offset + length > bytes.length) {
1:9f94529:       throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_INT);
1:9f94529:     }
1:f5c6f28:     int n = 0;
1:500654e:     if (CarbonUnsafe.getUnsafe() != null) {
1:9f94529:       if (CarbonUnsafe.ISLITTLEENDIAN) {
1:f5c6f28:         n = Integer.reverseBytes(
1:500654e:             CarbonUnsafe.getUnsafe().getInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET));
1:9f94529:       } else {
1:500654e:         n = CarbonUnsafe.getUnsafe().getInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
1:d85fb72:       }
1:7d386a4:     } else {
1:9f94529:       for (int i = offset; i < (offset + length); i++) {
1:9f94529:         n <<= 8;
1:9f94529:         n ^= bytes[i] & 0xFF;
1:9f94529:       }
1:9f94529:     }
1:f012f5b:     return n;
1:9f94529:   }
1:9f94529: 
1:7359601:   public static int toInt(byte[] bytes, int offset) {
1:ceb7c8d:     return (((int)bytes[offset] & 0xff) << 24) + (((int)bytes[offset + 1] & 0xff) << 16) +
1:ceb7c8d:         (((int)bytes[offset + 2] & 0xff) << 8) + ((int)bytes[offset + 3] & 0xff);
1:9f94529:   }
1:9f94529: 
1:6297ea0:   public static int toShort(byte[] bytes, int offset) {
1:6297ea0:     return (((int)bytes[offset] & 0xff) << 8) + ((int)bytes[offset + 1] & 0xff);
1:9f94529:   }
1:9f94529: 
1:7359601:   public static void setInt(byte[] data, int offset, int value) {
1:7359601:     data[offset] = (byte) (value >> 24);
1:7359601:     data[offset + 1] = (byte) (value >> 16);
1:7359601:     data[offset + 2] = (byte) (value >> 8);
1:7359601:     data[offset + 3] = (byte) value;
1:9f94529:   }
1:9f94529: 
1:6297ea0:   public static void setShort(byte[] data, int offset, int value) {
1:6297ea0:     data[offset] = (byte) (value >> 8);
1:6297ea0:     data[offset + 1] = (byte) value;
1:9f94529:   }
1:6297ea0: 
1:9f94529:   /**
1:9f94529:    * long => byte[]
1:9f94529:    *
1:9f94529:    * @param val
1:9f94529:    * @return
1:9f94529:    */
1:9f94529:   public static byte[] toBytes(long val) {
1:9f94529:     byte[] b = new byte[8];
1:9f94529:     for (int i = 7; i > 0; i--) {
1:9f94529:       b[i] = (byte) val;
1:9f94529:       val >>>= 8;
1:9f94529:     }
1:9f94529:     b[0] = (byte) val;
1:9f94529:     return b;
1:9f94529:   }
1:9f94529: 
1:d85fb72:   public static byte[] toBytes(double val) {
1:d85fb72:     return toBytes(Double.doubleToLongBits(val));
1:9f94529:   }
1:9f94529: 
1:d85fb72:   public static double toDouble(byte[] value, int offset, int length) {
1:d85fb72:     return Double.longBitsToDouble(toLong(value, offset, length));
1:6297ea0:   }
1:9f94529: 
1:9f94529:   /**
1:9f94529:    * byte[] => long
1:9f94529:    */
1:9f94529:   public static long toLong(byte[] bytes, int offset, final int length) {
1:9f94529:     if (length != SIZEOF_LONG || offset + length > bytes.length) {
1:9f94529:       throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_LONG);
1:9f94529:     }
1:f5c6f28:     long l = 0;
1:500654e:     if (CarbonUnsafe.getUnsafe() != null) {
1:9f94529:       if (CarbonUnsafe.ISLITTLEENDIAN) {
1:f5c6f28:         l = Long.reverseBytes(
1:500654e:             CarbonUnsafe.getUnsafe().getLong(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET));
1:9f94529:       } else {
1:500654e:         l = CarbonUnsafe.getUnsafe().getLong(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
1:9f94529:       }
1:9f94529:     } else {
1:9f94529:       for (int i = offset; i < offset + length; i++) {
1:9f94529:         l <<= 8;
1:9f94529:         l ^= bytes[i] & 0xFF;
1:9f94529:       }
1:9f94529:     }
1:f012f5b:     return l;
1:9f94529:   }
1:9f94529: 
1:9f94529:   private static IllegalArgumentException explainWrongLengthOrOffset(final byte[] bytes,
1:9f94529:       final int offset, final int length, final int expectedLength) {
1:9f94529:     String reason;
1:9f94529:     if (length != expectedLength) {
1:9f94529:       reason = "Wrong length: " + length + ", expected " + expectedLength;
1:9f94529:     } else {
1:9f94529:       reason = "offset (" + offset + ") + length (" + length + ") exceed the"
1:9f94529:           + " capacity of the array: " + bytes.length;
1:9f94529:     }
1:9f94529:     return new IllegalArgumentException(reason);
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:9f94529:    * Put an int value out to the specified byte array position.
1:9f94529:    *
1:9f94529:    * @param bytes  the byte array
1:9f94529:    * @param offset position in the array
1:9f94529:    * @param val    int to write out
1:9f94529:    * @return incremented offset
1:9f94529:    * @throws IllegalArgumentException if the byte array given doesn't have
1:9f94529:    *                                  enough room at the offset specified.
1:9f94529:    */
1:9f94529:   public static int putInt(byte[] bytes, int offset, int val) {
1:9f94529:     if (bytes.length - offset < SIZEOF_INT) {
1:9f94529:       throw new IllegalArgumentException(
1:9f94529:           "Not enough room to put an int at" + " offset " + offset + " in a " + bytes.length
1:9f94529:               + " byte array");
1:9f94529:     }
1:500654e:     if (CarbonUnsafe.getUnsafe() != null) {
1:9f94529:       if (CarbonUnsafe.ISLITTLEENDIAN) {
1:9f94529:         val = Integer.reverseBytes(val);
1:9f94529:       }
1:500654e:       CarbonUnsafe.getUnsafe().putInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET, val);
1:9f94529:       return offset + ByteUtil.SIZEOF_INT;
1:9f94529:     } else {
1:9f94529:       for (int i = offset + 3; i > offset; i--) {
1:9f94529:         bytes[i] = (byte) val;
1:9f94529:         val >>>= 8;
1:9f94529:       }
1:9f94529:       bytes[offset] = (byte) val;
1:9f94529:       return offset + SIZEOF_INT;
1:9f94529:     }
1:9f94529:   }
1:9f94529: 
1:9f94529:   /**
1:9f94529:    * Put bytes at the specified byte array position.
1:9f94529:    *
1:9f94529:    * @param tgtBytes  the byte array
1:9f94529:    * @param tgtOffset position in the array
1:9f94529:    * @param srcBytes  array to write out
1:9f94529:    * @param srcOffset source offset
1:9f94529:    * @param srcLength source length
1:9f94529:    * @return incremented offset
1:9f94529:    */
1:9f94529:   public static int putBytes(byte[] tgtBytes, int tgtOffset, byte[] srcBytes, int srcOffset,
1:9f94529:       int srcLength) {
1:9f94529:     System.arraycopy(srcBytes, srcOffset, tgtBytes, tgtOffset, srcLength);
1:9f94529:     return tgtOffset + srcLength;
1:9f94529:   }
1:d85fb72: 
1:9f94529:   /**
1:dc83b2a:    * flatten input byte[][] to byte[] and return
1:9f94529:    */
1:dc83b2a:   public static byte[] flatten(byte[][] input) {
1:dc83b2a:     int totalSize = 0;
1:dc83b2a:     for (int i = 0; i < input.length; i++) {
1:dc83b2a:       totalSize += input[i].length;
1:d85fb72:     }
1:dc83b2a:     byte[] flattenedData = new byte[totalSize];
1:dc83b2a:     int pos = 0;
1:dc83b2a:     for (int i = 0; i < input.length; i++) {
1:dc83b2a:       System.arraycopy(input[i], 0, flattenedData, pos, input[i].length);
1:dc83b2a:       pos += input[i].length;
1:7d386a4:     }
1:dc83b2a:     return flattenedData;
1:7d386a4:   }
1:7d386a4: 
1:f012f5b:   /**
1:f012f5b:    * If number type column is in sort_columns, the column will be no-dictionary column.
1:f012f5b:    * It will compare byte arrays to sort the data.
1:f012f5b:    * For example the binary string of int value as follows.
1:f012f5b:    * 1  : 00000000 00000000 00000000 00000001
1:f012f5b:    * -1 : 11111111 11111111 11111111 11111111
1:f012f5b:    * In this case, the compare method of byte arrays will return a wrong result.(1 < -1)
1:f012f5b:    * The root cause is that the sign bit of negative number is 1.
1:f012f5b:    * These XOR methods will change the sign bit as follows.
1:f012f5b:    * 1  ^ MIN_VALUE : 10000000 00000000 00000000 00000001
1:f012f5b:    * -1 ^ MIN_VALUE : 01111111 11111111 11111111 11111111
1:f012f5b:    * After the transform, the compare method of byte arrays will return a right result.(1 > -1)
1:f012f5b:    */
1:f012f5b:   public static byte[] toXorBytes(short val) {
1:f012f5b:     val = (short) (val ^ Short.MIN_VALUE);
1:f012f5b:     return toBytes(val);
1:f012f5b:   }
1:f012f5b: 
1:f012f5b:   public static byte[] toXorBytes(int val) {
1:f012f5b:     val = val ^ Integer.MIN_VALUE;
1:f012f5b:     return toBytes(val);
1:f012f5b:   }
1:f012f5b: 
1:f012f5b:   public static byte[] toXorBytes(long val) {
1:f012f5b:     val = val ^ Long.MIN_VALUE;
1:f012f5b:     return toBytes(val);
1:f012f5b:   }
1:f012f5b: 
1:f012f5b:   public static byte[] toXorBytes(double val) {
1:f012f5b:     return toXorBytes(Double.doubleToLongBits(val));
1:f012f5b:   }
1:f012f5b: 
1:f012f5b:   /**
1:f012f5b:    * The following methods convert byte array back to the real value.
1:f012f5b:    */
1:f012f5b:   public static short toXorShort(byte[] bytes, int offset, final int length) {
1:f012f5b:     return (short) (toShort(bytes, offset, length) ^ Short.MIN_VALUE);
1:f012f5b:   }
1:f012f5b: 
1:f012f5b:   public static int toXorInt(byte[] bytes, int offset, final int length) {
1:f012f5b:     return toInt(bytes, offset, length) ^ Integer.MIN_VALUE;
1:f012f5b:   }
1:f012f5b: 
1:f012f5b:   public static long toXorLong(byte[] bytes, int offset, final int length) {
1:f012f5b:     return toLong(bytes, offset, length) ^ Long.MIN_VALUE;
1:f012f5b:   }
1:f012f5b: 
1:f012f5b:   public static double toXorDouble(byte[] value, int offset, int length) {
1:f012f5b:     return Double.longBitsToDouble(toXorLong(value, offset, length));
1:f012f5b:   }
1:7359601: }
============================================================================
author:xuchuanyin
-------------------------------------------------------------------------------
commit:8f08c4a
/////////////////////////////////////////////////////////////////////////
1:   public static final int SIZEOF_FLOAT = 4;
1: 
author:QiangCai
-------------------------------------------------------------------------------
commit:f012f5b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     return n;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     return n;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     return l;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * If number type column is in sort_columns, the column will be no-dictionary column.
1:    * It will compare byte arrays to sort the data.
1:    * For example the binary string of int value as follows.
1:    * 1  : 00000000 00000000 00000000 00000001
1:    * -1 : 11111111 11111111 11111111 11111111
1:    * In this case, the compare method of byte arrays will return a wrong result.(1 < -1)
1:    * The root cause is that the sign bit of negative number is 1.
1:    * These XOR methods will change the sign bit as follows.
1:    * 1  ^ MIN_VALUE : 10000000 00000000 00000000 00000001
1:    * -1 ^ MIN_VALUE : 01111111 11111111 11111111 11111111
1:    * After the transform, the compare method of byte arrays will return a right result.(1 > -1)
1:    */
1:   public static byte[] toXorBytes(short val) {
1:     val = (short) (val ^ Short.MIN_VALUE);
1:     return toBytes(val);
1:   }
1: 
1:   public static byte[] toXorBytes(int val) {
1:     val = val ^ Integer.MIN_VALUE;
1:     return toBytes(val);
1:   }
1: 
1:   public static byte[] toXorBytes(long val) {
1:     val = val ^ Long.MIN_VALUE;
1:     return toBytes(val);
1:   }
1: 
1:   public static byte[] toXorBytes(double val) {
1:     return toXorBytes(Double.doubleToLongBits(val));
1:   }
1: 
1:   /**
1:    * The following methods convert byte array back to the real value.
1:    */
1:   public static short toXorShort(byte[] bytes, int offset, final int length) {
1:     return (short) (toShort(bytes, offset, length) ^ Short.MIN_VALUE);
1:   }
1: 
1:   public static int toXorInt(byte[] bytes, int offset, final int length) {
1:     return toInt(bytes, offset, length) ^ Integer.MIN_VALUE;
1:   }
1: 
1:   public static long toXorLong(byte[] bytes, int offset, final int length) {
1:     return toLong(bytes, offset, length) ^ Long.MIN_VALUE;
1:   }
1: 
1:   public static double toXorDouble(byte[] value, int offset, int length) {
1:     return Double.longBitsToDouble(toXorLong(value, offset, length));
1:   }
commit:5f9741e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:bf44c9f
/////////////////////////////////////////////////////////////////////////
1:   public static boolean toBoolean(final byte b) {
1:     return b != (byte) 0;
1:   }
1: 
commit:f5c6f28
/////////////////////////////////////////////////////////////////////////
0:     val = (short)(val ^ Short.MIN_VALUE);
/////////////////////////////////////////////////////////////////////////
1:     short n = 0;
1:         n = Short.reverseBytes(
0:         n = CarbonUnsafe.unsafe.getShort(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
1: 
0:     return (short)(n ^ Short.MIN_VALUE);
/////////////////////////////////////////////////////////////////////////
0:     val = val ^ Integer.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
1:     int n = 0;
1:         n = Integer.reverseBytes(
0:         n = CarbonUnsafe.unsafe.getInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
0:     return n ^ Integer.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
0:     val = val ^ Long.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
1:     long l = 0;
1:         l = Long.reverseBytes(
0:         l = CarbonUnsafe.unsafe.getLong(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
0:     return l ^ Long.MIN_VALUE;
commit:9f94529
/////////////////////////////////////////////////////////////////////////
1: import java.io.UnsupportedEncodingException;
0: import java.math.BigDecimal;
0: import java.math.BigInteger;
1: import java.nio.charset.StandardCharsets;
/////////////////////////////////////////////////////////////////////////
1:   public static final int SIZEOF_LONG = 8;
1: 
1:   public static final int SIZEOF_INT = 4;
1: 
1:   public static final int SIZEOF_SHORT = 2;
1: 
1:   public static final String UTF8_CSN = StandardCharsets.UTF_8.name();
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Stirng => byte[]
1:    *
1:    * @param s
1:    * @return
1:    */
1:   public static byte[] toBytes(String s) {
1:     try {
1:       return s.getBytes(UTF8_CSN);
1:     } catch (UnsupportedEncodingException e) {
1:       // should never happen!
1:       throw new IllegalArgumentException("UTF8 decoding is not supported", e);
1:     }
1:   }
1: 
1:   /**
1:    * byte[] => String
1:    *
1:    * @param b
1:    * @param off
1:    * @param len
1:    * @return
1:    */
1:   public static String toString(final byte[] b, int off, int len) {
1:     if (b == null) {
1:       return null;
1:     }
1:     if (len == 0) {
1:       return "";
1:     }
1:     try {
1:       return new String(b, off, len, UTF8_CSN);
1:     } catch (UnsupportedEncodingException e) {
1:       // should never happen!
1:       throw new IllegalArgumentException("UTF8 encoding is not supported", e);
1:     }
1:   }
1: 
1:   /**
1:    * boolean => byte[]
1:    *
1:    * @param b
1:    * @return
1:    */
1:   public static byte[] toBytes(final boolean b) {
1:     return new byte[] { b ? (byte) -1 : (byte) 0 };
1:   }
1: 
1:   /**
1:    * byte[] => boolean
1:    *
1:    * @param b
1:    * @return
1:    */
1:   public static boolean toBoolean(final byte[] b) {
1:     if (b.length != 1) {
1:       throw new IllegalArgumentException("Array has wrong size: " + b.length);
1:     }
1:     return b[0] != (byte) 0;
1:   }
1: 
1:   /**
1:    * short => byte[]
1:    *
1:    * @param val
1:    * @return
1:    */
1:   public static byte[] toBytes(short val) {
1:     byte[] b = new byte[SIZEOF_SHORT];
1:     b[1] = (byte) val;
1:     val >>= 8;
1:     b[0] = (byte) val;
1:     return b;
1:   }
1: 
1:   /**
1:    * byte[] => short
1:    *
1:    * @param bytes
1:    * @param offset
1:    * @param length
1:    * @return
1:    */
1:   public static short toShort(byte[] bytes, int offset, final int length) {
1:     if (length != SIZEOF_SHORT || offset + length > bytes.length) {
1:       throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_SHORT);
1:     }
0:     if (CarbonUnsafe.unsafe != null) {
1:       if (CarbonUnsafe.ISLITTLEENDIAN) {
0:         return Short.reverseBytes(
0:             CarbonUnsafe.unsafe.getShort(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET));
1:       } else {
0:         return CarbonUnsafe.unsafe.getShort(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
1:       }
1:     } else {
0:       short n = 0;
1:       n ^= bytes[offset] & 0xFF;
1:       n <<= 8;
1:       n ^= bytes[offset + 1] & 0xFF;
0:       return n;
1:     }
1:   }
1: 
1:   /**
1:    * int => byte[]
1:    *
1:    * @param val
1:    * @return
1:    */
1:   public static byte[] toBytes(int val) {
1:     byte[] b = new byte[4];
1:     for (int i = 3; i > 0; i--) {
1:       b[i] = (byte) val;
1:       val >>>= 8;
1:     }
1:     b[0] = (byte) val;
1:     return b;
1:   }
1: 
1:   /**
1:    * byte[] => int
1:    *
1:    * @param bytes
1:    * @param offset
1:    * @param length
1:    * @return
1:    */
1:   public static int toInt(byte[] bytes, int offset, final int length) {
1:     if (length != SIZEOF_INT || offset + length > bytes.length) {
1:       throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_INT);
1:     }
0:     if (CarbonUnsafe.unsafe != null) {
1:       if (CarbonUnsafe.ISLITTLEENDIAN) {
0:         return Integer.reverseBytes(
0:             CarbonUnsafe.unsafe.getInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET));
1:       } else {
0:         return CarbonUnsafe.unsafe.getInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
1:       }
1:     } else {
1:       int n = 0;
1:       for (int i = offset; i < (offset + length); i++) {
1:         n <<= 8;
1:         n ^= bytes[i] & 0xFF;
1:       }
0:       return n;
1:     }
1:   }
1: 
1:   /**
0:    * float => byte[]
1:    *
0:    * @param f
1:    * @return
1:    */
0:   public static byte[] toBytes(final float f) {
0:     // Encode it as int
0:     return toBytes(Float.floatToRawIntBits(f));
1:   }
1: 
1:   /**
0:    * byte[] => float
1:    *
1:    * @param bytes
1:    * @param offset
1:    * @return
1:    */
0:   public static float toFloat(byte[] bytes, int offset) {
0:     return Float.intBitsToFloat(toInt(bytes, offset, SIZEOF_INT));
1:   }
1: 
1:   /**
1:    * long => byte[]
1:    *
1:    * @param val
1:    * @return
1:    */
1:   public static byte[] toBytes(long val) {
1:     byte[] b = new byte[8];
1:     for (int i = 7; i > 0; i--) {
1:       b[i] = (byte) val;
1:       val >>>= 8;
1:     }
1:     b[0] = (byte) val;
1:     return b;
1:   }
1: 
1:   /**
1:    * byte[] => long
1:    */
1:   public static long toLong(byte[] bytes, int offset, final int length) {
1:     if (length != SIZEOF_LONG || offset + length > bytes.length) {
1:       throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_LONG);
1:     }
0:     if (CarbonUnsafe.unsafe != null) {
1:       if (CarbonUnsafe.ISLITTLEENDIAN) {
0:         return Long.reverseBytes(
0:             CarbonUnsafe.unsafe.getLong(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET));
1:       } else {
0:         return CarbonUnsafe.unsafe.getLong(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
1:       }
1:     } else {
0:       long l = 0;
1:       for (int i = offset; i < offset + length; i++) {
1:         l <<= 8;
1:         l ^= bytes[i] & 0xFF;
1:       }
0:       return l;
1:     }
1:   }
1: 
1:   /**
0:    * doube => byte[]
1:    *
0:    * @param d
1:    * @return
1:    */
0:   public static byte[] toBytes(final double d) {
0:     // Encode it as a long
0:     return toBytes(Double.doubleToRawLongBits(d));
1:   }
1: 
1:   /**
0:    * byte[] => double
1:    *
1:    * @param bytes
1:    * @param offset
1:    * @return
1:    */
0:   public static double toDouble(final byte[] bytes, final int offset) {
0:     return Double.longBitsToDouble(toLong(bytes, offset, SIZEOF_LONG));
1:   }
1: 
1:   /**
0:    * BigDecimal => byte[]
1:    *
1:    * @param val
1:    * @return
1:    */
0:   public static byte[] toBytes(BigDecimal val) {
0:     byte[] valueBytes = val.unscaledValue().toByteArray();
0:     byte[] result = new byte[valueBytes.length + SIZEOF_INT];
0:     int offset = putInt(result, 0, val.scale());
0:     putBytes(result, offset, valueBytes, 0, valueBytes.length);
0:     return result;
1:   }
1: 
1:   /**
0:    * byte[] => BigDecimal
1:    *
1:    * @param bytes
1:    * @param offset
1:    * @param length
1:    * @return
1:    */
0:   public static BigDecimal toBigDecimal(byte[] bytes, int offset, final int length) {
0:     if (bytes == null || length < SIZEOF_INT + 1 || (offset + length > bytes.length)) {
1:       return null;
1:     }
1: 
0:     int scale = toInt(bytes, offset, bytes.length);
0:     byte[] tcBytes = new byte[length - SIZEOF_INT];
0:     System.arraycopy(bytes, offset + SIZEOF_INT, tcBytes, 0, length - SIZEOF_INT);
0:     return new BigDecimal(new BigInteger(tcBytes), scale);
1:   }
1: 
1:   private static IllegalArgumentException explainWrongLengthOrOffset(final byte[] bytes,
1:       final int offset, final int length, final int expectedLength) {
1:     String reason;
1:     if (length != expectedLength) {
1:       reason = "Wrong length: " + length + ", expected " + expectedLength;
1:     } else {
1:       reason = "offset (" + offset + ") + length (" + length + ") exceed the"
1:           + " capacity of the array: " + bytes.length;
1:     }
1:     return new IllegalArgumentException(reason);
1:   }
1: 
1:   /**
1:    * Put an int value out to the specified byte array position.
1:    *
1:    * @param bytes  the byte array
1:    * @param offset position in the array
1:    * @param val    int to write out
1:    * @return incremented offset
1:    * @throws IllegalArgumentException if the byte array given doesn't have
1:    *                                  enough room at the offset specified.
1:    */
1:   public static int putInt(byte[] bytes, int offset, int val) {
1:     if (bytes.length - offset < SIZEOF_INT) {
1:       throw new IllegalArgumentException(
1:           "Not enough room to put an int at" + " offset " + offset + " in a " + bytes.length
1:               + " byte array");
1:     }
0:     if (CarbonUnsafe.unsafe != null) {
1:       if (CarbonUnsafe.ISLITTLEENDIAN) {
1:         val = Integer.reverseBytes(val);
1:       }
0:       CarbonUnsafe.unsafe.putInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET, val);
1:       return offset + ByteUtil.SIZEOF_INT;
1:     } else {
1:       for (int i = offset + 3; i > offset; i--) {
1:         bytes[i] = (byte) val;
1:         val >>>= 8;
1:       }
1:       bytes[offset] = (byte) val;
1:       return offset + SIZEOF_INT;
1:     }
1:   }
1: 
1:   /**
1:    * Put bytes at the specified byte array position.
1:    *
1:    * @param tgtBytes  the byte array
1:    * @param tgtOffset position in the array
1:    * @param srcBytes  array to write out
1:    * @param srcOffset source offset
1:    * @param srcLength source length
1:    * @return incremented offset
1:    */
1:   public static int putBytes(byte[] tgtBytes, int tgtOffset, byte[] srcBytes, int srcOffset,
1:       int srcLength) {
1:     System.arraycopy(srcBytes, srcOffset, tgtBytes, tgtOffset, srcLength);
1:     return tgtOffset + srcLength;
1:   }
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:438b442
/////////////////////////////////////////////////////////////////////////
1:   public static final int SIZEOF_BYTE = 1;
1: 
0:   public static final int SIZEOF_SHORT = 2;
1: 
1:   public static final int SIZEOF_SHORT_INT = 3;
0:   public static final int SIZEOF_LONG = 8;
1: 
1:   public static final int SIZEOF_DOUBLE = 8;
author:kumarvishal09
-------------------------------------------------------------------------------
commit:6297ea0
/////////////////////////////////////////////////////////////////////////
1:   public static int toShort(byte[] bytes, int offset) {
1:     return (((int)bytes[offset] & 0xff) << 8) + ((int)bytes[offset + 1] & 0xff);
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   public static void setShort(byte[] data, int offset, int value) {
1:     data[offset] = (byte) (value >> 8);
1:     data[offset + 1] = (byte) value;
1:   }
1: 
commit:d85fb72
/////////////////////////////////////////////////////////////////////////
1:   public static byte[] toBytes(double val) {
1:     return toBytes(Double.doubleToLongBits(val));
1:   }
1: 
1:   public static double toDouble(byte[] value, int offset, int length) {
1:     return Double.longBitsToDouble(toLong(value, offset, length));
1:   }
1: 
commit:ceb7c8d
/////////////////////////////////////////////////////////////////////////
1:     return (((int)bytes[offset] & 0xff) << 24) + (((int)bytes[offset + 1] & 0xff) << 16) +
1:         (((int)bytes[offset + 2] & 0xff) << 8) + ((int)bytes[offset + 3] & 0xff);
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
1:         long lw = CarbonUnsafe.getUnsafe().getLong(buffer1, offset1Adj + (long) i);
1:         long rw = CarbonUnsafe.getUnsafe().getLong(buffer2, offset2Adj + (long) i);
/////////////////////////////////////////////////////////////////////////
1:           long lw =
1:               CarbonUnsafe.getUnsafe().getLong(buffer1, CarbonUnsafe.BYTE_ARRAY_OFFSET + (long) i);
1:           long rw =
1:               CarbonUnsafe.getUnsafe().getLong(buffer2, CarbonUnsafe.BYTE_ARRAY_OFFSET + (long) i);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         long lw = CarbonUnsafe.getUnsafe().getLong(buffer1, currentOffset);
1:         long rw = CarbonUnsafe.getUnsafe().getLong(buffer2, currentOffset);
/////////////////////////////////////////////////////////////////////////
1:           long lw = CarbonUnsafe.getUnsafe().getByte(buffer1, currentOffset);
1:           long rw = CarbonUnsafe.getUnsafe().getByte(buffer2, currentOffset);
/////////////////////////////////////////////////////////////////////////
1:         long lw = CarbonUnsafe.getUnsafe().getLong(buffer1, currentOffset + offset1);
1:         long rw = CarbonUnsafe.getUnsafe().getLong(buffer2, currentOffset + offset2);
/////////////////////////////////////////////////////////////////////////
1:           long lw = CarbonUnsafe.getUnsafe().getByte(buffer1, currentOffset + offset1);
1:           long rw = CarbonUnsafe.getUnsafe().getByte(buffer2, currentOffset + offset2);
/////////////////////////////////////////////////////////////////////////
1:     if (CarbonUnsafe.getUnsafe() != null) {
1:             CarbonUnsafe.getUnsafe().getShort(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET));
1:         n = CarbonUnsafe.getUnsafe().getShort(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
/////////////////////////////////////////////////////////////////////////
1:     if (CarbonUnsafe.getUnsafe() != null) {
1:             CarbonUnsafe.getUnsafe().getInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET));
1:         n = CarbonUnsafe.getUnsafe().getInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
/////////////////////////////////////////////////////////////////////////
1:     if (CarbonUnsafe.getUnsafe() != null) {
1:             CarbonUnsafe.getUnsafe().getLong(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET));
1:         l = CarbonUnsafe.getUnsafe().getLong(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET);
/////////////////////////////////////////////////////////////////////////
1:     if (CarbonUnsafe.getUnsafe() != null) {
1:       CarbonUnsafe.getUnsafe().putInt(bytes, offset + CarbonUnsafe.BYTE_ARRAY_OFFSET, val);
author:sounakr
-------------------------------------------------------------------------------
commit:266c473
/////////////////////////////////////////////////////////////////////////
commit:105e3a0
/////////////////////////////////////////////////////////////////////////
1:     int len1 = buffer1.length;
1:     int len2 = buffer2.length;
1:     int offset1 = 0;
1:     int offset2 = 0;
1:     // Call UnsafeComparer compareTo for comparision.
1:     return ByteUtil.UnsafeComparer.INSTANCE
1:         .compareTo(buffer1, offset1, len1, buffer2, offset2, len2);
1: 
author:jackylk
-------------------------------------------------------------------------------
commit:7d386a4
/////////////////////////////////////////////////////////////////////////
1:    * int => byte[3]
1:    * supported range is [-8388608, 8388607], note that Math.pow(2, 24) == 8388608
1:    */
1:   public static byte[] to3Bytes(int val) {
1:     assert val <= (Math.pow(2, 23) - 1) && val >= (-Math.pow(2, 23));
1:     return new byte[]{ (byte)(val >> 16), (byte)(val >> 8), (byte)val };
1:   }
1: 
1:   /**
1:    * convert 3 bytes to int
1:    */
1:   public static int valueOf3Bytes(byte[] val, int offset) {
1:     assert val.length >= offset + 3;
1:     if (val[offset] < 0) {
1:       return (((val[offset] & 0xFFFF) << 16) |
1:           ((val[offset + 1] & 0xFF) << 8) |
1:           ((val[offset + 2] & 0xFF)));
1:     } else {
1:       return (((val[offset] & 0xFF) << 16) |
1:           ((val[offset + 1] & 0xFF) << 8) |
1:           ((val[offset + 2] & 0xFF)));
1:     }
1:   }
1: 
1:   /**
commit:7359601
/////////////////////////////////////////////////////////////////////////
1:   public static int toInt(byte[] bytes, int offset) {
0:     return (((int)bytes[offset]) << 24) + (((int)bytes[offset + 1]) << 16) +
0:         (((int)bytes[offset + 2]) << 8) + bytes[offset + 3];
1:   }
1: 
1:   public static void setInt(byte[] data, int offset, int value) {
1:     data[offset] = (byte) (value >> 24);
1:     data[offset + 1] = (byte) (value >> 16);
1:     data[offset + 2] = (byte) (value >> 8);
1:     data[offset + 3] = (byte) value;
1:   }
1: 
commit:dc83b2a
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * flatten input byte[][] to byte[] and return
1:    */
1:   public static byte[] flatten(byte[][] input) {
1:     int totalSize = 0;
1:     for (int i = 0; i < input.length; i++) {
1:       totalSize += input[i].length;
1:     }
1:     byte[] flattenedData = new byte[totalSize];
1:     int pos = 0;
1:     for (int i = 0; i < input.length; i++) {
1:       System.arraycopy(input[i], 0, flattenedData, pos, input[i].length);
1:       pos += input[i].length;
1:     }
1:     return flattenedData;
1:   }
1: 
commit:98df130
/////////////////////////////////////////////////////////////////////////
0:   public static final byte[] ZERO_IN_BYTES = toBytes(0);
1: 
author:ravipesala
-------------------------------------------------------------------------------
commit:bfa306b
/////////////////////////////////////////////////////////////////////////
commit:8f59a32
/////////////////////////////////////////////////////////////////////////
1:     public boolean equals(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
1:         int length2) {
1:       if (length1 != length2) {
1:         return false;
1:       }
1:       int len = length1 / 8;
1:       long currentOffset = CarbonUnsafe.BYTE_ARRAY_OFFSET;
1:       for (int i = 0; i < len; i++) {
0:         long lw = CarbonUnsafe.unsafe.getLong(buffer1, currentOffset + offset1);
0:         long rw = CarbonUnsafe.unsafe.getLong(buffer2, currentOffset + offset2);
1:         if (lw != rw) {
1:           return false;
1:         }
1:         currentOffset += 8;
1:       }
1:       len = buffer1.length % 8;
1:       if (len > 0) {
1:         for (int i = 0; i < len; i += 1) {
0:           long lw = CarbonUnsafe.unsafe.getByte(buffer1, currentOffset + offset1);
0:           long rw = CarbonUnsafe.unsafe.getByte(buffer2, currentOffset + offset2);
1:           if (lw != rw) {
1:             return false;
1:           }
1:           currentOffset += 1;
1:         }
1:       }
1:       return true;
1:     }
1: 
commit:b13ead9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.memory.CarbonUnsafe;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       int offset1Adj = offset1 + CarbonUnsafe.BYTE_ARRAY_OFFSET;
1:       int offset2Adj = offset2 + CarbonUnsafe.BYTE_ARRAY_OFFSET;
/////////////////////////////////////////////////////////////////////////
0:         long lw = CarbonUnsafe.unsafe.getLong(buffer1, offset1Adj + (long) i);
0:         long rw = CarbonUnsafe.unsafe.getLong(buffer2, offset2Adj + (long) i);
1:           if (!CarbonUnsafe.ISLITTLEENDIAN) {
/////////////////////////////////////////////////////////////////////////
1:       return compareTo(buffer1, buffer2, len1, len2, minLength);
1:     }
1:     public int compareTo(byte[] buffer1, byte[] buffer2, int len1, int len2, int minLength) {
1:       int minWords = 0;
/////////////////////////////////////////////////////////////////////////
0:           long lw = CarbonUnsafe.unsafe.getLong(buffer1, CarbonUnsafe.BYTE_ARRAY_OFFSET + (long) i);
0:           long rw = CarbonUnsafe.unsafe.getLong(buffer2, CarbonUnsafe.BYTE_ARRAY_OFFSET + (long) i);
1:             if (!CarbonUnsafe.ISLITTLEENDIAN) {
/////////////////////////////////////////////////////////////////////////
0:     public int compareUnsafeTo(Object baseObject1, Object baseObject2, long address1, long address2,
0:         int len1, int len2, int minLength) {
1: 
0:       int minWords = 0;
1: 
1:       /*
1:        * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes
1:        * at a time is no slower than comparing 4 bytes at a time even on
1:        * 32-bit. On the other hand, it is substantially faster on 64-bit.
1:        */
1:       if (minLength > 7) {
1:         minWords = minLength / SIZEOF_LONG;
1:         for (int i = 0; i < minWords * SIZEOF_LONG; i += SIZEOF_LONG) {
0:           long lw = CarbonUnsafe.unsafe
0:               .getLong(baseObject1, CarbonUnsafe.BYTE_ARRAY_OFFSET + (long) i + address1);
0:           long rw = CarbonUnsafe.unsafe
0:               .getLong(baseObject2, CarbonUnsafe.BYTE_ARRAY_OFFSET + (long) i + address2);
1:           long diff = lw ^ rw;
1: 
1:           if (diff != 0) {
0:             if (!CarbonUnsafe.ISLITTLEENDIAN) {
1:               return lessThanUnsigned(lw, rw) ? -1 : 1;
1:             }
1: 
1:             // Use binary search
1:             int k = 0;
1:             int y;
1:             int x = (int) diff;
1:             if (x == 0) {
1:               x = (int) (diff >>> 32);
1:               k = 32;
1:             }
1:             y = x << 16;
1:             if (y == 0) {
1:               k += 16;
1:             } else {
1:               x = y;
1:             }
1: 
1:             y = x << 8;
1:             if (y == 0) {
1:               k += 8;
1:             }
1:             return (int) (((lw >>> k) & 0xFFL) - ((rw >>> k) & 0xFFL));
1:           }
1:         }
1:       }
1: 
1:       // The epilogue to cover the last (minLength % 8) elements.
1:       for (int i = minWords * SIZEOF_LONG; i < minLength; i++) {
0:         int a =
0:             (CarbonUnsafe.unsafe.getByte(baseObject1, CarbonUnsafe.BYTE_ARRAY_OFFSET + i + address1)
0:                 & 0xff);
0:         int b =
0:             (CarbonUnsafe.unsafe.getByte(baseObject2, CarbonUnsafe.BYTE_ARRAY_OFFSET + i + address2)
0:                 & 0xff);
1:         if (a != b) {
1:           return a - b;
1:         }
1:       }
1:       return len1 - len2;
1:     }
1: 
1:       long currentOffset = CarbonUnsafe.BYTE_ARRAY_OFFSET;
0:         long lw = CarbonUnsafe.unsafe.getLong(buffer1, currentOffset);
0:         long rw = CarbonUnsafe.unsafe.getLong(buffer2, currentOffset);
/////////////////////////////////////////////////////////////////////////
0:           long lw = CarbonUnsafe.unsafe.getByte(buffer1, currentOffset);
0:           long rw = CarbonUnsafe.unsafe.getByte(buffer2, currentOffset);
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: 
1: package org.apache.carbondata.core.util;
1: 
0: import java.lang.reflect.Field;
1: import java.nio.ByteBuffer;
0: import java.nio.ByteOrder;
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
1: 
1: /**
1:  * Util class for byte comparision
1:  */
1: public final class ByteUtil {
1: 
0:   private static final int SIZEOF_LONG = 8;
1: 
1:   private ByteUtil() {
1: 
1:   }
1: 
1:   /**
1:    * Compare method for bytes
0:    *
1:    * @param buffer1
1:    * @param buffer2
0:    * @return
1:    */
1:   public static int compare(byte[] buffer1, byte[] buffer2) {
1:     // Short circuit equal case
1:     if (buffer1 == buffer2) {
1:       return 0;
1:     }
0:     // Bring WritableComparator code local
0:     int i = 0;
0:     int j = 0;
0:     for (; i < buffer1.length && j < buffer2.length; i++, j++) {
1:       int a = (buffer1[i] & 0xff);
0:       int b = (buffer2[j] & 0xff);
1:       if (a != b) {
1:         return a - b;
1:       }
1:     }
1:     return 0;
1:   }
1: 
1:   /**
1:    * covert the long[] to int[]
0:    *
1:    * @param longArray
0:    * @return
1:    */
1:   public static int[] convertToIntArray(long[] longArray) {
1:     int[] intArray = new int[longArray.length];
1:     for (int i = 0; i < longArray.length; i++) {
1:       intArray[i] = (int) longArray[i];
1: 
1:     }
1:     return intArray;
1:   }
1: 
1:   /**
1:    * Unsafe comparator
1:    */
1:   public enum UnsafeComparer {
1:     /**
1:      * instance.
1:      */
1:     INSTANCE;
1: 
1:     /**
0:      * unsafe .
1:      */
0:     static final sun.misc.Unsafe THEUNSAFE;
1: 
1:     /**
0:      * The offset to the first element in a byte array.
1:      */
0:     static final int BYTE_ARRAY_BASE_OFFSET;
0:     static final boolean LITTLEENDIAN = ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN);
1: 
0:     static {
0:       THEUNSAFE = (sun.misc.Unsafe) AccessController.doPrivileged(new PrivilegedAction<Object>() {
0:         @Override public Object run() {
0:           try {
0:             Field f = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
0:             f.setAccessible(true);
0:             return f.get(null);
0:           } catch (NoSuchFieldException e) {
0:             // It doesn't matter what we throw;
0:             // it's swallowed in getBestComparer().
0:             throw new Error();
0:           } catch (IllegalAccessException e) {
0:             throw new Error();
1:           }
1:         }
0:       });
1: 
0:       BYTE_ARRAY_BASE_OFFSET = THEUNSAFE.arrayBaseOffset(byte[].class);
1: 
0:       // sanity check - this should never fail
0:       if (THEUNSAFE.arrayIndexScale(byte[].class) != 1) {
0:         throw new AssertionError();
1:       }
1: 
1:     }
1: 
1:     /**
1:      * Returns true if x1 is less than x2, when both values are treated as
1:      * unsigned.
1:      */
1:     static boolean lessThanUnsigned(long x1, long x2) {
1:       return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);
1:     }
1: 
1:     /**
1:      * Lexicographically compare two arrays.
0:      *
1:      * @param buffer1 left operand
1:      * @param buffer2 right operand
1:      * @param offset1 Where to start comparing in the left buffer
1:      * @param offset2 Where to start comparing in the right buffer
1:      * @param length1 How much to compare from the left buffer
1:      * @param length2 How much to compare from the right buffer
1:      * @return 0 if equal, < 0 if left is less than right, etc.
1:      */
1:     public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
1:         int length2) {
1:       // Short circuit equal case
1:       if (buffer1 == buffer2 && offset1 == offset2 && length1 == length2) {
1:         return 0;
1:       }
1:       int minLength = Math.min(length1, length2);
1:       int minWords = minLength / SIZEOF_LONG;
0:       int offset1Adj = offset1 + BYTE_ARRAY_BASE_OFFSET;
0:       int offset2Adj = offset2 + BYTE_ARRAY_BASE_OFFSET;
1: 
1:       /*
1:        * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes
1:        * at a time is no slower than comparing 4 bytes at a time even on
1:        * 32-bit. On the other hand, it is substantially faster on 64-bit.
1:        */
1:       for (int i = 0; i < minWords * SIZEOF_LONG; i += SIZEOF_LONG) {
0:         long lw = THEUNSAFE.getLong(buffer1, offset1Adj + (long) i);
0:         long rw = THEUNSAFE.getLong(buffer2, offset2Adj + (long) i);
1:         long diff = lw ^ rw;
1: 
1:         if (diff != 0) {
0:           if (!LITTLEENDIAN) {
1:             return lessThanUnsigned(lw, rw) ? -1 : 1;
1:           }
1: 
1:           // Use binary search
0:           int n = 0;
1:           int y;
1:           int x = (int) diff;
1:           if (x == 0) {
1:             x = (int) (diff >>> 32);
1:             n = 32;
1:           }
1: 
1:           y = x << 16;
1:           if (y == 0) {
1:             n += 16;
1:           } else {
1:             x = y;
1:           }
1: 
1:           y = x << 8;
1:           if (y == 0) {
1:             n += 8;
1:           }
1:           return (int) (((lw >>> n) & 0xFFL) - ((rw >>> n) & 0xFFL));
1:         }
1:       }
1: 
1:       // The epilogue to cover the last (minLength % 8) elements.
1:       for (int i = minWords * SIZEOF_LONG; i < minLength; i++) {
1:         int a = (buffer1[offset1 + i] & 0xff);
1:         int b = (buffer2[offset2 + i] & 0xff);
1:         if (a != b) {
1:           return a - b;
1:         }
1:       }
1:       return length1 - length2;
1:     }
1: 
1:     public int compareTo(byte[] buffer1, byte[] buffer2) {
1: 
1:       // Short circuit equal case
1:       if (buffer1 == buffer2) {
1:         return 0;
1:       }
1:       int len1 = buffer1.length;
1:       int len2 = buffer2.length;
1:       int minLength = (len1 <= len2) ? len1 : len2;
0:       int minWords = 0;
1: 
1:       /*
1:        * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes
1:        * at a time is no slower than comparing 4 bytes at a time even on
1:        * 32-bit. On the other hand, it is substantially faster on 64-bit.
1:        */
0:       if (minLength > 7) {
0:         minWords = minLength / SIZEOF_LONG;
1:         for (int i = 0; i < minWords * SIZEOF_LONG; i += SIZEOF_LONG) {
0:           long lw = THEUNSAFE.getLong(buffer1, BYTE_ARRAY_BASE_OFFSET + (long) i);
0:           long rw = THEUNSAFE.getLong(buffer2, BYTE_ARRAY_BASE_OFFSET + (long) i);
1:           long diff = lw ^ rw;
1: 
1:           if (diff != 0) {
0:             if (!LITTLEENDIAN) {
1:               return lessThanUnsigned(lw, rw) ? -1 : 1;
1:             }
1: 
1:             // Use binary search
0:             int k = 0;
1:             int y;
1:             int x = (int) diff;
1:             if (x == 0) {
1:               x = (int) (diff >>> 32);
0:               k = 32;
1:             }
1:             y = x << 16;
1:             if (y == 0) {
0:               k += 16;
1:             } else {
1:               x = y;
1:             }
1: 
1:             y = x << 8;
1:             if (y == 0) {
0:               k += 8;
1:             }
0:             return (int) (((lw >>> k) & 0xFFL) - ((rw >>> k) & 0xFFL));
1:           }
1:         }
1:       }
1: 
1:       // The epilogue to cover the last (minLength % 8) elements.
1:       for (int i = minWords * SIZEOF_LONG; i < minLength; i++) {
1:         int a = (buffer1[i] & 0xff);
1:         int b = (buffer2[i] & 0xff);
1:         if (a != b) {
1:           return a - b;
1:         }
1:       }
0:       return len1 - len2;
1:     }
1: 
1:     public boolean equals(byte[] buffer1, byte[] buffer2) {
1:       if (buffer1.length != buffer2.length) {
1:         return false;
1:       }
1:       int len = buffer1.length / 8;
0:       long currentOffset = BYTE_ARRAY_BASE_OFFSET;
1:       for (int i = 0; i < len; i++) {
0:         long lw = THEUNSAFE.getLong(buffer1, currentOffset);
0:         long rw = THEUNSAFE.getLong(buffer2, currentOffset);
1:         if (lw != rw) {
1:           return false;
1:         }
1:         currentOffset += 8;
1:       }
1:       len = buffer1.length % 8;
1:       if (len > 0) {
1:         for (int i = 0; i < len; i += 1) {
0:           long lw = THEUNSAFE.getByte(buffer1, currentOffset);
0:           long rw = THEUNSAFE.getByte(buffer2, currentOffset);
1:           if (lw != rw) {
1:             return false;
1:           }
1:           currentOffset += 1;
1:         }
1:       }
1:       return true;
1:     }
1: 
1:     /**
1:      * Comparing the 2 byte buffers. This is used in case of data load sorting step.
0:      *
1:      * @param byteBuffer1
1:      * @param byteBuffer2
0:      * @return
1:      */
1:     public int compareTo(ByteBuffer byteBuffer1, ByteBuffer byteBuffer2) {
1: 
1:       // Short circuit equal case
1:       if (byteBuffer1 == byteBuffer2) {
1:         return 0;
1:       }
1:       int len1 = byteBuffer1.remaining();
1:       int len2 = byteBuffer2.remaining();
1:       byte[] buffer1 = new byte[len1];
1:       byte[] buffer2 = new byte[len2];
1:       byteBuffer1.get(buffer1);
1:       byteBuffer2.get(buffer2);
1:       return compareTo(buffer1, buffer2);
1:     }
1: 
1:   }
1: 
1: }
author:Jay357089
-------------------------------------------------------------------------------
commit:cd61beb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: 
/////////////////////////////////////////////////////////////////////////
1:    * convert number in byte to more readable format
1:    * @param sizeInbyte
0:    * @return
0:    */
1:   public static String convertByteToReadable(long sizeInbyte) {
0: 
1:     String readableSize;
1:     if (sizeInbyte < CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR) {
1:       readableSize = sizeInbyte + " Byte";
1:     } else if (sizeInbyte < CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR *
1:             CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR) {
1:       readableSize = sizeInbyte / CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR + " KB";
0:     } else {
1:       readableSize = sizeInbyte / CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR /
1:               CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR + " MB";
0:     }
1:     return readableSize;
0:   }
0: 
0:   /**
============================================================================