1:cd6a4ff: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
1:cd6a4ff:  *
1:cd6a4ff:  *    http://www.apache.org/licenses/LICENSE-2.0
1:cd6a4ff:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
1:cd6a4ff:  */
1:e3f98fa: 
1:cd6a4ff: package org.apache.carbondata.core.cache.dictionary;
1:c79bd52: 
1:eaadc88: import java.io.IOException;
1:cd6a4ff: import java.util.ArrayList;
1:cd6a4ff: import java.util.List;
1:c79bd52: import java.util.Map;
1:cd6a4ff: import java.util.concurrent.Callable;
1:7ef9164: import java.util.concurrent.ConcurrentHashMap;
1:cd6a4ff: import java.util.concurrent.ExecutorService;
1:cd6a4ff: import java.util.concurrent.Executors;
1:cd6a4ff: import java.util.concurrent.Future;
1:cd6a4ff: import java.util.concurrent.TimeUnit;
1:d53feef: 
1:cd6a4ff: import org.apache.carbondata.common.logging.LogService;
1:cd6a4ff: import org.apache.carbondata.common.logging.LogServiceFactory;
1:cd6a4ff: import org.apache.carbondata.core.cache.CacheType;
1:cd6a4ff: import org.apache.carbondata.core.cache.CarbonLRUCache;
1:377dee9: import org.apache.carbondata.core.reader.CarbonDictionaryColumnMetaChunk;
1:377dee9: import org.apache.carbondata.core.util.CarbonUtil;
1:377dee9: import org.apache.carbondata.core.util.ObjectSizeCalculator;
1:e3f98fa: import org.apache.carbondata.core.util.TaskMetricsMap;
1:d53feef: 
1:cd6a4ff: /**
1:cd6a4ff:  * This class implements methods to create dictionary cache which will hold
1:cd6a4ff:  * dictionary chunks for look up of surrogate keys and values
1:cd6a4ff:  */
1:c79bd52: public class ForwardDictionaryCache<K extends
1:c79bd52:     DictionaryColumnUniqueIdentifier, V extends Dictionary> extends AbstractDictionaryCache<K, V> {
12:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * Attribute for Carbon LOGGER
1:cd6a4ff:    */
1:cd6a4ff:   private static final LogService LOGGER =
1:cd6a4ff:       LogServiceFactory.getLogService(ForwardDictionaryCache.class.getName());
1:c79bd52: 
1:c79bd52:   private static final Map<DictionaryColumnUniqueIdentifier, Object> DICTIONARY_LOCK_OBJECT =
1:7ef9164:       new ConcurrentHashMap<>();
1:377dee9: 
1:377dee9:   private static final long sizeOfEmptyDictChunks =
1:377dee9:       ObjectSizeCalculator.estimate(new ArrayList<byte[]>(CarbonUtil.getDictionaryChunkSize()), 16);
1:377dee9: 
1:377dee9:   private static final long byteArraySize = ObjectSizeCalculator.estimate(new byte[0], 16);
1:377dee9: 
1:cd6a4ff:   /**
1:cd6a4ff:    * @param carbonLRUCache
1:cd6a4ff:    */
1:1155d4d:   public ForwardDictionaryCache(CarbonLRUCache carbonLRUCache) {
1:1155d4d:     super(carbonLRUCache);
14:cd6a4ff:   }
1:377dee9: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will get the value for the given key. If value does not exist
1:cd6a4ff:    * for the given key, it will check and load the value.
1:cd6a4ff:    *
1:cd6a4ff:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:cd6a4ff:    *                                         tableName and columnIdentifier
1:cd6a4ff:    * @return dictionary
1:eaadc88:    * @throws IOException in case memory is not sufficient to load dictionary into memory
1:cd6a4ff:    */
1:cd6a4ff:   @Override public Dictionary get(DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier)
1:eaadc88:       throws IOException {
1:cd6a4ff:     return getDictionary(dictionaryColumnUniqueIdentifier);
1:cd6a4ff:   }
1:377dee9: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will return a list of values for the given list of keys.
1:cd6a4ff:    * For each key, this method will check and load the data if required.
1:cd6a4ff:    *
1:cd6a4ff:    * @param dictionaryColumnUniqueIdentifiers unique identifier which contains dbName,
1:cd6a4ff:    *                                          tableName and columnIdentifier
1:cd6a4ff:    * @return list of dictionary
1:eaadc88:    * @throws IOException in case memory is not sufficient to load dictionary into memory
1:cd6a4ff:    */
1:cd6a4ff:   @Override public List<Dictionary> getAll(
1:c79bd52:       List<DictionaryColumnUniqueIdentifier> dictionaryColumnUniqueIdentifiers) throws IOException {
1:cd6a4ff:     boolean exceptionOccurredInDictionaryLoading = false;
1:cd6a4ff:     String exceptionMessage = "";
1:cd6a4ff:     List<Dictionary> forwardDictionaryObjectList =
1:cd6a4ff:         new ArrayList<Dictionary>(dictionaryColumnUniqueIdentifiers.size());
1:cd6a4ff:     List<Future<Dictionary>> taskSubmitList =
1:cd6a4ff:         new ArrayList<>(dictionaryColumnUniqueIdentifiers.size());
1:cd6a4ff:     ExecutorService executorService = Executors.newFixedThreadPool(thread_pool_size);
1:cd6a4ff:     for (final DictionaryColumnUniqueIdentifier uniqueIdent : dictionaryColumnUniqueIdentifiers) {
1:cd6a4ff:       taskSubmitList.add(executorService.submit(new Callable<Dictionary>() {
1:eaadc88:         @Override public Dictionary call() throws IOException {
1:e3f98fa:           try {
1:e3f98fa:             // Register thread callback for calculating metrics
1:e3f98fa:             TaskMetricsMap.getInstance().registerThreadCallback();
1:e3f98fa:             // in case of multiple task for same query same executor
1:e3f98fa:             // only one task should load the dictionary
1:e3f98fa:             // others will wait on monitor and get the loaded dictionary values
1:e3f98fa:             Object lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
1:e3f98fa:             // if lock object is null
1:e3f98fa:             if (null == lockObject) {
1:e3f98fa:               // Acquire the lock on map
1:e3f98fa:               synchronized (DICTIONARY_LOCK_OBJECT) {
1:e3f98fa:                 // double checking the dictionary lock object
1:e3f98fa:                 lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
1:e3f98fa:                 // if still it is null add new lock object
1:e3f98fa:                 if (null == lockObject) {
1:e3f98fa:                   lockObject = new Object();
1:e3f98fa:                   DICTIONARY_LOCK_OBJECT.put(uniqueIdent, lockObject);
1:e3f98fa:                 }
1:e3f98fa:               }
1:e3f98fa:             }
1:e3f98fa:             Dictionary dictionary = null;
1:e3f98fa:             synchronized (lockObject) {
1:e3f98fa:               dictionary = getDictionary(uniqueIdent);
1:e3f98fa:             }
1:e3f98fa:             return dictionary;
1:e3f98fa:           }  finally {
1:e3f98fa:             // update read bytes metrics for this thread
1:e3f98fa:             TaskMetricsMap.getInstance().updateReadBytes(Thread.currentThread().getId());
1:c79bd52:           }
1:377dee9: 
1:c79bd52:         }
1:cd6a4ff:       }));
1:c79bd52:     }
1:e3f98fa:     try {
1:cd6a4ff:       executorService.shutdown();
1:cd6a4ff:       executorService.awaitTermination(2, TimeUnit.HOURS);
1:cd6a4ff:     } catch (InterruptedException e) {
1:cd6a4ff:       LOGGER.error("Error loading the dictionary: " + e.getMessage());
1:c79bd52:     }
1:cd6a4ff:     for (int i = 0; i < taskSubmitList.size(); i++) {
2:cd6a4ff:       try {
1:cd6a4ff:         Dictionary columnDictionary = taskSubmitList.get(i).get();
1:cd6a4ff:         forwardDictionaryObjectList.add(columnDictionary);
1:cd6a4ff:       } catch (Throwable e) {
1:cd6a4ff:         exceptionOccurredInDictionaryLoading = true;
1:cd6a4ff:         exceptionMessage = e.getMessage();
1:c79bd52:       }
1:c79bd52:     }
1:cd6a4ff:     if (exceptionOccurredInDictionaryLoading) {
1:cd6a4ff:       clearDictionary(forwardDictionaryObjectList);
1:cd6a4ff:       LOGGER.error(exceptionMessage);
1:eaadc88:       throw new IOException(exceptionMessage);
1:c79bd52:     }
1:cd6a4ff:     return forwardDictionaryObjectList;
1:c79bd52:   }
1:377dee9: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will return the value for the given key. It will not check and load
1:cd6a4ff:    * the data for the given key
1:cd6a4ff:    *
1:cd6a4ff:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:cd6a4ff:    *                                         tableName and columnIdentifier
1:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   @Override public Dictionary getIfPresent(
1:cd6a4ff:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
1:cd6a4ff:     Dictionary forwardDictionary = null;
1:cd6a4ff:     ColumnDictionaryInfo columnDictionaryInfo = (ColumnDictionaryInfo) carbonLRUCache.get(
1:d53feef:         getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
1:d53feef:             CacheType.FORWARD_DICTIONARY));
1:cd6a4ff:     if (null != columnDictionaryInfo) {
1:cd6a4ff:       forwardDictionary = new ForwardDictionary(columnDictionaryInfo);
1:cd6a4ff:       incrementDictionaryAccessCount(columnDictionaryInfo);
1:d53feef:     }
1:cd6a4ff:     return forwardDictionary;
1:d53feef:   }
1:377dee9: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will remove the cache for a given key
1:cd6a4ff:    *
1:cd6a4ff:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:cd6a4ff:    *                                         tableName and columnIdentifier
1:cd6a4ff:    */
1:cd6a4ff:   @Override public void invalidate(
1:cd6a4ff:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
1:cd6a4ff:     carbonLRUCache.remove(
2:cd6a4ff:         getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
2:cd6a4ff:             CacheType.FORWARD_DICTIONARY));
1:d53feef:   }
1:377dee9: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will get the value for the given key. If value does not exist
1:cd6a4ff:    * for the given key, it will check and load the value.
1:cd6a4ff:    *
1:cd6a4ff:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:cd6a4ff:    *                                         tableName and columnIdentifier
1:cd6a4ff:    * @return dictionary
1:eaadc88:    * @throws IOException in case memory is not sufficient to load dictionary into memory
1:cd6a4ff:    */
1:cd6a4ff:   private Dictionary getDictionary(
1:c79bd52:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {
1:cd6a4ff:     Dictionary forwardDictionary = null;
1:f031394:     // dictionary is only for primitive data type
1:d53feef:     assert (!dictionaryColumnUniqueIdentifier.getDataType().isComplexType());
1:cd6a4ff:     String columnIdentifier = dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId();
1:cd6a4ff:     ColumnDictionaryInfo columnDictionaryInfo =
1:cd6a4ff:         getColumnDictionaryInfo(dictionaryColumnUniqueIdentifier, columnIdentifier);
1:cd6a4ff:     // load sort index file in case of forward dictionary
1:cd6a4ff:     checkAndLoadDictionaryData(dictionaryColumnUniqueIdentifier, columnDictionaryInfo,
1:cd6a4ff:         getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
1:cd6a4ff:             CacheType.FORWARD_DICTIONARY), true);
1:cd6a4ff:     forwardDictionary = new ForwardDictionary(columnDictionaryInfo);
1:cd6a4ff:     return forwardDictionary;
1:cd6a4ff:   }
1:377dee9: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will check and create columnDictionaryInfo object for the given column
1:cd6a4ff:    *
1:cd6a4ff:    * @param dictionaryColumnUniqueIdentifier
1:cd6a4ff:    * @param columnIdentifier
1:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   private ColumnDictionaryInfo getColumnDictionaryInfo(
1:cd6a4ff:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, String columnIdentifier) {
1:cd6a4ff:     ColumnDictionaryInfo columnDictionaryInfo = (ColumnDictionaryInfo) carbonLRUCache
1:cd6a4ff:         .get(getLruCacheKey(columnIdentifier, CacheType.FORWARD_DICTIONARY));
1:cd6a4ff:     if (null == columnDictionaryInfo) {
1:cd6a4ff:       synchronized (dictionaryColumnUniqueIdentifier) {
1:cd6a4ff:         columnDictionaryInfo = (ColumnDictionaryInfo) carbonLRUCache
1:cd6a4ff:             .get(getLruCacheKey(columnIdentifier, CacheType.FORWARD_DICTIONARY));
1:cd6a4ff:         if (null == columnDictionaryInfo) {
1:cd6a4ff:           columnDictionaryInfo =
1:cd6a4ff:               new ColumnDictionaryInfo(dictionaryColumnUniqueIdentifier.getDataType());
1:cd6a4ff:         }
1:cd6a4ff:       }
1:cd6a4ff:     }
1:cd6a4ff:     return columnDictionaryInfo;
1:d53feef:   }
1:e3f98fa: 
1:d53feef:   @Override public void clearAccessCount(List<DictionaryColumnUniqueIdentifier> keys) {
1:d53feef:     for (DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier : keys) {
1:d53feef:       Dictionary cacheable = (Dictionary) carbonLRUCache.get(
1:d53feef:           getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
1:d53feef:               CacheType.FORWARD_DICTIONARY));
1:d53feef:       cacheable.clear();
1:377dee9:     }
1:377dee9:   }
1:377dee9: 
1:377dee9:   @Override protected long getEstimatedDictionarySize(DictionaryInfo dictionaryInfo,
1:377dee9:       CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk,
1:377dee9:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, boolean
1:377dee9:       readSortIndexSize) throws IOException {
1:377dee9:     // required size will be size total size of file - offset till file is
1:377dee9:     // already read
1:377dee9:     long requiredSize =
1:377dee9:         carbonDictionaryColumnMetaChunk.getEnd_offset() -
1:377dee9:             dictionaryInfo.getOffsetTillFileIsRead();
1:377dee9: 
1:377dee9:     long numOfRecords = dictionaryInfo.getOffsetTillFileIsRead() == 0 ?
1:377dee9:         carbonDictionaryColumnMetaChunk.getMax_surrogate_key() :
1:377dee9:         carbonDictionaryColumnMetaChunk.getMax_surrogate_key()
1:377dee9:             - getNumRecordsInCarbonDictionaryColumnMetaChunk(
1:377dee9:             dictionaryColumnUniqueIdentifier,
1:377dee9:             dictionaryInfo.getOffsetTillFileIsRead());
1:377dee9: 
1:377dee9:     if (numOfRecords > 0) {
1:377dee9:       long avgRecordsSize = requiredSize / numOfRecords;
1:377dee9:       long bytesPerRecord = (long)Math.ceil(avgRecordsSize / 8.0) * 8;
1:377dee9: 
1:377dee9:       requiredSize = (bytesPerRecord + byteArraySize) * numOfRecords;
1:377dee9:     }
1:377dee9: 
1:377dee9:     if (readSortIndexSize) {
1:377dee9:       // every time we are loading all the sort index files.Hence memory calculation for all
1:377dee9:       // the records
1:377dee9:       requiredSize = requiredSize + getSortIndexSize(
1:377dee9:           carbonDictionaryColumnMetaChunk.getMax_surrogate_key());
1:377dee9:     }
1:377dee9: 
1:377dee9:     return requiredSize + sizeOfEmptyDictChunks;
1:377dee9:   }
1:377dee9: }
============================================================================
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1:       new ConcurrentHashMap<>();
commit:377dee9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.reader.CarbonDictionaryColumnMetaChunk;
1: import org.apache.carbondata.core.util.CarbonUtil;
1: import org.apache.carbondata.core.util.ObjectSizeCalculator;
/////////////////////////////////////////////////////////////////////////
1:   private static final long sizeOfEmptyDictChunks =
1:       ObjectSizeCalculator.estimate(new ArrayList<byte[]>(CarbonUtil.getDictionaryChunkSize()), 16);
1: 
1:   private static final long byteArraySize = ObjectSizeCalculator.estimate(new byte[0], 16);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:   @Override protected long getEstimatedDictionarySize(DictionaryInfo dictionaryInfo,
1:       CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk,
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, boolean
1:       readSortIndexSize) throws IOException {
1:     // required size will be size total size of file - offset till file is
1:     // already read
1:     long requiredSize =
1:         carbonDictionaryColumnMetaChunk.getEnd_offset() -
1:             dictionaryInfo.getOffsetTillFileIsRead();
1: 
1:     long numOfRecords = dictionaryInfo.getOffsetTillFileIsRead() == 0 ?
1:         carbonDictionaryColumnMetaChunk.getMax_surrogate_key() :
1:         carbonDictionaryColumnMetaChunk.getMax_surrogate_key()
1:             - getNumRecordsInCarbonDictionaryColumnMetaChunk(
1:             dictionaryColumnUniqueIdentifier,
1:             dictionaryInfo.getOffsetTillFileIsRead());
1: 
1:     if (numOfRecords > 0) {
1:       long avgRecordsSize = requiredSize / numOfRecords;
1:       long bytesPerRecord = (long)Math.ceil(avgRecordsSize / 8.0) * 8;
1: 
1:       requiredSize = (bytesPerRecord + byteArraySize) * numOfRecords;
1:     }
1: 
1:     if (readSortIndexSize) {
1:       // every time we are loading all the sort index files.Hence memory calculation for all
1:       // the records
1:       requiredSize = requiredSize + getSortIndexSize(
1:           carbonDictionaryColumnMetaChunk.getMax_surrogate_key());
1:     }
1: 
1:     return requiredSize + sizeOfEmptyDictChunks;
1:   }
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
0:       new ConcurrentHashMap<>();
commit:377dee9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.reader.CarbonDictionaryColumnMetaChunk;
0: import org.apache.carbondata.core.util.CarbonUtil;
0: import org.apache.carbondata.core.util.ObjectSizeCalculator;
/////////////////////////////////////////////////////////////////////////
0:   private static final long sizeOfEmptyDictChunks =
0:       ObjectSizeCalculator.estimate(new ArrayList<byte[]>(CarbonUtil.getDictionaryChunkSize()), 16);
1: 
0:   private static final long byteArraySize = ObjectSizeCalculator.estimate(new byte[0], 16);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:   @Override protected long getEstimatedDictionarySize(DictionaryInfo dictionaryInfo,
0:       CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk,
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, boolean
0:       readSortIndexSize) throws IOException {
0:     // required size will be size total size of file - offset till file is
0:     // already read
0:     long requiredSize =
0:         carbonDictionaryColumnMetaChunk.getEnd_offset() -
0:             dictionaryInfo.getOffsetTillFileIsRead();
1: 
0:     long numOfRecords = dictionaryInfo.getOffsetTillFileIsRead() == 0 ?
0:         carbonDictionaryColumnMetaChunk.getMax_surrogate_key() :
0:         carbonDictionaryColumnMetaChunk.getMax_surrogate_key()
0:             - getNumRecordsInCarbonDictionaryColumnMetaChunk(
0:             dictionaryColumnUniqueIdentifier,
0:             dictionaryInfo.getOffsetTillFileIsRead());
1: 
0:     if (numOfRecords > 0) {
0:       long avgRecordsSize = requiredSize / numOfRecords;
0:       long bytesPerRecord = (long)Math.ceil(avgRecordsSize / 8.0) * 8;
1: 
0:       requiredSize = (bytesPerRecord + byteArraySize) * numOfRecords;
1:     }
1: 
0:     if (readSortIndexSize) {
0:       // every time we are loading all the sort index files.Hence memory calculation for all
0:       // the records
0:       requiredSize = requiredSize + getSortIndexSize(
0:           carbonDictionaryColumnMetaChunk.getMax_surrogate_key());
1:     }
1: 
0:     return requiredSize + sizeOfEmptyDictChunks;
1:   }
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:1155d4d
/////////////////////////////////////////////////////////////////////////
1:   public ForwardDictionaryCache(CarbonLRUCache carbonLRUCache) {
1:     super(carbonLRUCache);
commit:1155d4d
/////////////////////////////////////////////////////////////////////////
0:   public ForwardDictionaryCache(CarbonLRUCache carbonLRUCache) {
0:     super(carbonLRUCache);
author:Manohar
-------------------------------------------------------------------------------
commit:e3f98fa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.TaskMetricsMap;
/////////////////////////////////////////////////////////////////////////
1:           try {
1:             // Register thread callback for calculating metrics
1:             TaskMetricsMap.getInstance().registerThreadCallback();
1:             // in case of multiple task for same query same executor
1:             // only one task should load the dictionary
1:             // others will wait on monitor and get the loaded dictionary values
1:             Object lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
1:             // if lock object is null
1:             if (null == lockObject) {
1:               // Acquire the lock on map
1:               synchronized (DICTIONARY_LOCK_OBJECT) {
1:                 // double checking the dictionary lock object
1:                 lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
1:                 // if still it is null add new lock object
1:                 if (null == lockObject) {
1:                   lockObject = new Object();
1:                   DICTIONARY_LOCK_OBJECT.put(uniqueIdent, lockObject);
1:                 }
1:             Dictionary dictionary = null;
1:             synchronized (lockObject) {
1:               dictionary = getDictionary(uniqueIdent);
1:             }
1:             return dictionary;
1:           }  finally {
1:             // update read bytes metrics for this thread
1:             TaskMetricsMap.getInstance().updateReadBytes(Thread.currentThread().getId());
1: 
commit:e3f98fa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.util.TaskMetricsMap;
/////////////////////////////////////////////////////////////////////////
1:           try {
0:             // Register thread callback for calculating metrics
0:             TaskMetricsMap.getInstance().registerThreadCallback();
0:             // in case of multiple task for same query same executor
0:             // only one task should load the dictionary
0:             // others will wait on monitor and get the loaded dictionary values
0:             Object lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
0:             // if lock object is null
0:             if (null == lockObject) {
0:               // Acquire the lock on map
0:               synchronized (DICTIONARY_LOCK_OBJECT) {
0:                 // double checking the dictionary lock object
0:                 lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
0:                 // if still it is null add new lock object
0:                 if (null == lockObject) {
0:                   lockObject = new Object();
0:                   DICTIONARY_LOCK_OBJECT.put(uniqueIdent, lockObject);
1:                 }
0:             Dictionary dictionary = null;
0:             synchronized (lockObject) {
0:               dictionary = getDictionary(uniqueIdent);
1:             }
0:             return dictionary;
0:           }  finally {
0:             // update read bytes metrics for this thread
0:             TaskMetricsMap.getInstance().updateReadBytes(Thread.currentThread().getId());
1: 
author:kumarvishal
-------------------------------------------------------------------------------
commit:c79bd52
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: public class ForwardDictionaryCache<K extends
1:     DictionaryColumnUniqueIdentifier, V extends Dictionary> extends AbstractDictionaryCache<K, V> {
/////////////////////////////////////////////////////////////////////////
1:   private static final Map<DictionaryColumnUniqueIdentifier, Object> DICTIONARY_LOCK_OBJECT =
0:       new HashMap<>();
1: 
/////////////////////////////////////////////////////////////////////////
1:       List<DictionaryColumnUniqueIdentifier> dictionaryColumnUniqueIdentifiers) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:           // in case of multiple task for same query same executor
0:           // only one task should load the dictionary
0:           // others will wait on monitor and get the loaded dictionary values
0:           Object lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
0:           // if lock object is null
0:           if (null == lockObject) {
0:             // Acquire the lock on map
0:             synchronized (DICTIONARY_LOCK_OBJECT) {
0:               // double checking the dictionary lock object
0:               lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
0:               // if still it is null add new lock object
0:               if (null == lockObject) {
0:                 lockObject = new Object();
0:                 DICTIONARY_LOCK_OBJECT.put(uniqueIdent, lockObject);
1:               }
1:             }
1:           }
0:           Dictionary dictionary = null;
0:           synchronized (lockObject) {
0:             dictionary = getDictionary(uniqueIdent);
1:           }
/////////////////////////////////////////////////////////////////////////
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {
commit:c79bd52
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: public class ForwardDictionaryCache<K extends
0:     DictionaryColumnUniqueIdentifier, V extends Dictionary> extends AbstractDictionaryCache<K, V> {
/////////////////////////////////////////////////////////////////////////
0:   private static final Map<DictionaryColumnUniqueIdentifier, Object> DICTIONARY_LOCK_OBJECT =
0:       new HashMap<>();
1: 
/////////////////////////////////////////////////////////////////////////
0:       List<DictionaryColumnUniqueIdentifier> dictionaryColumnUniqueIdentifiers) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:           // in case of multiple task for same query same executor
0:           // only one task should load the dictionary
0:           // others will wait on monitor and get the loaded dictionary values
0:           Object lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
0:           // if lock object is null
0:           if (null == lockObject) {
0:             // Acquire the lock on map
0:             synchronized (DICTIONARY_LOCK_OBJECT) {
0:               // double checking the dictionary lock object
0:               lockObject = DICTIONARY_LOCK_OBJECT.get(uniqueIdent);
0:               // if still it is null add new lock object
0:               if (null == lockObject) {
0:                 lockObject = new Object();
0:                 DICTIONARY_LOCK_OBJECT.put(uniqueIdent, lockObject);
1:               }
1:             }
1:           }
0:           Dictionary dictionary = null;
0:           synchronized (lockObject) {
0:             dictionary = getDictionary(uniqueIdent);
1:           }
/////////////////////////////////////////////////////////////////////////
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {
author:QiangCai
-------------------------------------------------------------------------------
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:41347d8
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
author:jackylk
-------------------------------------------------------------------------------
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:    * @throws IOException in case memory is not sufficient to load dictionary into memory
1:       throws IOException {
/////////////////////////////////////////////////////////////////////////
1:    * @throws IOException in case memory is not sufficient to load dictionary into memory
0:       throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         @Override public Dictionary call() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:       throw new IOException(exceptionMessage);
/////////////////////////////////////////////////////////////////////////
1:    * @throws IOException in case memory is not sufficient to load dictionary into memory
0:       throws IOException {
commit:f031394
/////////////////////////////////////////////////////////////////////////
1:     // dictionary is only for primitive data type
0:     assert(!dictionaryColumnUniqueIdentifier.getDataType().isComplexType());
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:    * @throws IOException in case memory is not sufficient to load dictionary into memory
0:       throws IOException {
/////////////////////////////////////////////////////////////////////////
0:    * @throws IOException in case memory is not sufficient to load dictionary into memory
0:       throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         @Override public Dictionary call() throws IOException {
/////////////////////////////////////////////////////////////////////////
0:       throw new IOException(exceptionMessage);
/////////////////////////////////////////////////////////////////////////
0:    * @throws IOException in case memory is not sufficient to load dictionary into memory
0:       throws IOException {
commit:f031394
/////////////////////////////////////////////////////////////////////////
0:     // dictionary is only for primitive data type
0:     assert(!dictionaryColumnUniqueIdentifier.getDataType().isComplexType());
author:Venkata Ramana G
-------------------------------------------------------------------------------
commit:d53feef
/////////////////////////////////////////////////////////////////////////
1:     assert (!dictionaryColumnUniqueIdentifier.getDataType().isComplexType());
/////////////////////////////////////////////////////////////////////////
1: 
1:   @Override public void clearAccessCount(List<DictionaryColumnUniqueIdentifier> keys) {
1:     for (DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier : keys) {
1:       Dictionary cacheable = (Dictionary) carbonLRUCache.get(
1:           getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
1:               CacheType.FORWARD_DICTIONARY));
1:       cacheable.clear();
1:     }
1:   }
commit:d53feef
/////////////////////////////////////////////////////////////////////////
0:     assert (!dictionaryColumnUniqueIdentifier.getDataType().isComplexType());
/////////////////////////////////////////////////////////////////////////
1: 
0:   @Override public void clearAccessCount(List<DictionaryColumnUniqueIdentifier> keys) {
0:     for (DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier : keys) {
0:       Dictionary cacheable = (Dictionary) carbonLRUCache.get(
1:           getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
1:               CacheType.FORWARD_DICTIONARY));
0:       cacheable.clear();
1:     }
1:   }
author:ravipesala
-------------------------------------------------------------------------------
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: 
1: package org.apache.carbondata.core.cache.dictionary;
1: 
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.Future;
1: import java.util.concurrent.TimeUnit;
1: 
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
1: import org.apache.carbondata.core.cache.CacheType;
1: import org.apache.carbondata.core.cache.CarbonLRUCache;
0: import org.apache.carbondata.core.util.CarbonUtilException;
1: 
1: /**
1:  * This class implements methods to create dictionary cache which will hold
1:  * dictionary chunks for look up of surrogate keys and values
1:  */
0: public class ForwardDictionaryCache<K extends DictionaryColumnUniqueIdentifier,
0:                                     V extends Dictionary>
0:     extends AbstractDictionaryCache<K, V> {
1: 
1:   /**
1:    * Attribute for Carbon LOGGER
1:    */
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(ForwardDictionaryCache.class.getName());
1: 
1:   /**
0:    * @param carbonStorePath
1:    * @param carbonLRUCache
1:    */
0:   public ForwardDictionaryCache(String carbonStorePath, CarbonLRUCache carbonLRUCache) {
0:     super(carbonStorePath, carbonLRUCache);
1:   }
1: 
1:   /**
1:    * This method will get the value for the given key. If value does not exist
1:    * for the given key, it will check and load the value.
1:    *
1:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:    *                                         tableName and columnIdentifier
1:    * @return dictionary
0:    * @throws CarbonUtilException in case memory is not sufficient to load dictionary into memory
1:    */
1:   @Override public Dictionary get(DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier)
0:       throws CarbonUtilException {
1:     return getDictionary(dictionaryColumnUniqueIdentifier);
1:   }
1: 
1:   /**
1:    * This method will return a list of values for the given list of keys.
1:    * For each key, this method will check and load the data if required.
1:    *
1:    * @param dictionaryColumnUniqueIdentifiers unique identifier which contains dbName,
1:    *                                          tableName and columnIdentifier
1:    * @return list of dictionary
0:    * @throws CarbonUtilException in case memory is not sufficient to load dictionary into memory
1:    */
1:   @Override public List<Dictionary> getAll(
0:       List<DictionaryColumnUniqueIdentifier> dictionaryColumnUniqueIdentifiers)
0:       throws CarbonUtilException {
1:     boolean exceptionOccurredInDictionaryLoading = false;
1:     String exceptionMessage = "";
1:     List<Dictionary> forwardDictionaryObjectList =
1:         new ArrayList<Dictionary>(dictionaryColumnUniqueIdentifiers.size());
1:     List<Future<Dictionary>> taskSubmitList =
1:         new ArrayList<>(dictionaryColumnUniqueIdentifiers.size());
1:     ExecutorService executorService = Executors.newFixedThreadPool(thread_pool_size);
1:     for (final DictionaryColumnUniqueIdentifier uniqueIdent : dictionaryColumnUniqueIdentifiers) {
1:       taskSubmitList.add(executorService.submit(new Callable<Dictionary>() {
0:         @Override public Dictionary call() throws CarbonUtilException {
0:           Dictionary dictionary = getDictionary(uniqueIdent);
0:           return dictionary;
1:         }
1:       }));
1:     }
1:     try {
1:       executorService.shutdown();
1:       executorService.awaitTermination(2, TimeUnit.HOURS);
1:     } catch (InterruptedException e) {
1:       LOGGER.error("Error loading the dictionary: " + e.getMessage());
1:     }
1:     for (int i = 0; i < taskSubmitList.size(); i++) {
1:       try {
1:         Dictionary columnDictionary = taskSubmitList.get(i).get();
1:         forwardDictionaryObjectList.add(columnDictionary);
1:       } catch (Throwable e) {
1:         exceptionOccurredInDictionaryLoading = true;
1:         exceptionMessage = e.getMessage();
1:       }
1:     }
1:     if (exceptionOccurredInDictionaryLoading) {
1:       clearDictionary(forwardDictionaryObjectList);
1:       LOGGER.error(exceptionMessage);
0:       throw new CarbonUtilException(exceptionMessage);
1:     }
1:     return forwardDictionaryObjectList;
1:   }
1: 
1:   /**
1:    * This method will return the value for the given key. It will not check and load
1:    * the data for the given key
1:    *
1:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:    *                                         tableName and columnIdentifier
1:    * @return
1:    */
1:   @Override public Dictionary getIfPresent(
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
1:     Dictionary forwardDictionary = null;
1:     ColumnDictionaryInfo columnDictionaryInfo = (ColumnDictionaryInfo) carbonLRUCache.get(
1:         getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
1:             CacheType.FORWARD_DICTIONARY));
1:     if (null != columnDictionaryInfo) {
1:       forwardDictionary = new ForwardDictionary(columnDictionaryInfo);
1:       incrementDictionaryAccessCount(columnDictionaryInfo);
1:     }
1:     return forwardDictionary;
1:   }
1: 
1:   /**
1:    * This method will remove the cache for a given key
1:    *
1:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:    *                                         tableName and columnIdentifier
1:    */
1:   @Override public void invalidate(
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
1:     carbonLRUCache.remove(
1:         getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
1:             CacheType.FORWARD_DICTIONARY));
1:   }
1: 
1:   /**
1:    * This method will get the value for the given key. If value does not exist
1:    * for the given key, it will check and load the value.
1:    *
1:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:    *                                         tableName and columnIdentifier
1:    * @return dictionary
0:    * @throws CarbonUtilException in case memory is not sufficient to load dictionary into memory
1:    */
1:   private Dictionary getDictionary(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier)
0:       throws CarbonUtilException {
1:     Dictionary forwardDictionary = null;
0:     // create column dictionary info object only if dictionary and its
0:     // metadata file exists for a given column identifier
0:     if (!isFileExistsForGivenColumn(dictionaryColumnUniqueIdentifier)) {
0:       throw new CarbonUtilException(
0:           "Either dictionary or its metadata does not exist for column identifier :: "
0:               + dictionaryColumnUniqueIdentifier.getColumnIdentifier());
1:     }
1:     String columnIdentifier = dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId();
1:     ColumnDictionaryInfo columnDictionaryInfo =
1:         getColumnDictionaryInfo(dictionaryColumnUniqueIdentifier, columnIdentifier);
1:     // load sort index file in case of forward dictionary
1:     checkAndLoadDictionaryData(dictionaryColumnUniqueIdentifier, columnDictionaryInfo,
1:         getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
1:             CacheType.FORWARD_DICTIONARY), true);
1:     forwardDictionary = new ForwardDictionary(columnDictionaryInfo);
1:     return forwardDictionary;
1:   }
1: 
1:   /**
1:    * This method will check and create columnDictionaryInfo object for the given column
1:    *
1:    * @param dictionaryColumnUniqueIdentifier
1:    * @param columnIdentifier
1:    * @return
1:    */
1:   private ColumnDictionaryInfo getColumnDictionaryInfo(
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, String columnIdentifier) {
1:     ColumnDictionaryInfo columnDictionaryInfo = (ColumnDictionaryInfo) carbonLRUCache
1:         .get(getLruCacheKey(columnIdentifier, CacheType.FORWARD_DICTIONARY));
1:     if (null == columnDictionaryInfo) {
1:       synchronized (dictionaryColumnUniqueIdentifier) {
1:         columnDictionaryInfo = (ColumnDictionaryInfo) carbonLRUCache
1:             .get(getLruCacheKey(columnIdentifier, CacheType.FORWARD_DICTIONARY));
1:         if (null == columnDictionaryInfo) {
1:           columnDictionaryInfo =
1:               new ColumnDictionaryInfo(dictionaryColumnUniqueIdentifier.getDataType());
1:         }
1:       }
1:     }
1:     return columnDictionaryInfo;
1:   }
1: }
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *    http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: package org.apache.carbondata.core.cache.dictionary;
0: 
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.concurrent.Callable;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.Future;
0: import java.util.concurrent.TimeUnit;
0: 
0: import org.apache.carbondata.common.logging.LogService;
0: import org.apache.carbondata.common.logging.LogServiceFactory;
0: import org.apache.carbondata.core.cache.CacheType;
0: import org.apache.carbondata.core.cache.CarbonLRUCache;
0: import org.apache.carbondata.core.util.CarbonUtilException;
0: 
0: /**
0:  * This class implements methods to create dictionary cache which will hold
0:  * dictionary chunks for look up of surrogate keys and values
0:  */
0: public class ForwardDictionaryCache<K extends DictionaryColumnUniqueIdentifier,
0:                                     V extends Dictionary>
0:     extends AbstractDictionaryCache<K, V> {
0: 
0:   /**
0:    * Attribute for Carbon LOGGER
0:    */
0:   private static final LogService LOGGER =
0:       LogServiceFactory.getLogService(ForwardDictionaryCache.class.getName());
0: 
0:   /**
0:    * @param carbonStorePath
0:    * @param carbonLRUCache
0:    */
0:   public ForwardDictionaryCache(String carbonStorePath, CarbonLRUCache carbonLRUCache) {
0:     super(carbonStorePath, carbonLRUCache);
0:   }
0: 
0:   /**
0:    * This method will get the value for the given key. If value does not exist
0:    * for the given key, it will check and load the value.
0:    *
0:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
0:    *                                         tableName and columnIdentifier
0:    * @return dictionary
0:    * @throws CarbonUtilException in case memory is not sufficient to load dictionary into memory
0:    */
0:   @Override public Dictionary get(DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier)
0:       throws CarbonUtilException {
0:     return getDictionary(dictionaryColumnUniqueIdentifier);
0:   }
0: 
0:   /**
0:    * This method will return a list of values for the given list of keys.
0:    * For each key, this method will check and load the data if required.
0:    *
0:    * @param dictionaryColumnUniqueIdentifiers unique identifier which contains dbName,
0:    *                                          tableName and columnIdentifier
0:    * @return list of dictionary
0:    * @throws CarbonUtilException in case memory is not sufficient to load dictionary into memory
0:    */
0:   @Override public List<Dictionary> getAll(
0:       List<DictionaryColumnUniqueIdentifier> dictionaryColumnUniqueIdentifiers)
0:       throws CarbonUtilException {
0:     boolean exceptionOccurredInDictionaryLoading = false;
0:     String exceptionMessage = "";
0:     List<Dictionary> forwardDictionaryObjectList =
0:         new ArrayList<Dictionary>(dictionaryColumnUniqueIdentifiers.size());
0:     List<Future<Dictionary>> taskSubmitList =
0:         new ArrayList<>(dictionaryColumnUniqueIdentifiers.size());
0:     ExecutorService executorService = Executors.newFixedThreadPool(thread_pool_size);
0:     for (final DictionaryColumnUniqueIdentifier uniqueIdent : dictionaryColumnUniqueIdentifiers) {
0:       taskSubmitList.add(executorService.submit(new Callable<Dictionary>() {
0:         @Override public Dictionary call() throws CarbonUtilException {
0:           Dictionary dictionary = getDictionary(uniqueIdent);
0:           return dictionary;
0:         }
0:       }));
0:     }
0:     try {
0:       executorService.shutdown();
0:       executorService.awaitTermination(2, TimeUnit.HOURS);
0:     } catch (InterruptedException e) {
0:       LOGGER.error("Error loading the dictionary: " + e.getMessage());
0:     }
0:     for (int i = 0; i < taskSubmitList.size(); i++) {
0:       try {
0:         Dictionary columnDictionary = taskSubmitList.get(i).get();
0:         forwardDictionaryObjectList.add(columnDictionary);
0:       } catch (Throwable e) {
0:         exceptionOccurredInDictionaryLoading = true;
0:         exceptionMessage = e.getMessage();
0:       }
0:     }
0:     if (exceptionOccurredInDictionaryLoading) {
0:       clearDictionary(forwardDictionaryObjectList);
0:       LOGGER.error(exceptionMessage);
0:       throw new CarbonUtilException(exceptionMessage);
0:     }
0:     return forwardDictionaryObjectList;
0:   }
0: 
0:   /**
0:    * This method will return the value for the given key. It will not check and load
0:    * the data for the given key
0:    *
0:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
0:    *                                         tableName and columnIdentifier
0:    * @return
0:    */
0:   @Override public Dictionary getIfPresent(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
0:     Dictionary forwardDictionary = null;
0:     ColumnDictionaryInfo columnDictionaryInfo = (ColumnDictionaryInfo) carbonLRUCache.get(
0:         getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
0:             CacheType.FORWARD_DICTIONARY));
0:     if (null != columnDictionaryInfo) {
0:       forwardDictionary = new ForwardDictionary(columnDictionaryInfo);
0:       incrementDictionaryAccessCount(columnDictionaryInfo);
0:     }
0:     return forwardDictionary;
0:   }
0: 
0:   /**
0:    * This method will remove the cache for a given key
0:    *
0:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
0:    *                                         tableName and columnIdentifier
0:    */
0:   @Override public void invalidate(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
0:     carbonLRUCache.remove(
0:         getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
0:             CacheType.FORWARD_DICTIONARY));
0:   }
0: 
0:   /**
0:    * This method will get the value for the given key. If value does not exist
0:    * for the given key, it will check and load the value.
0:    *
0:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
0:    *                                         tableName and columnIdentifier
0:    * @return dictionary
0:    * @throws CarbonUtilException in case memory is not sufficient to load dictionary into memory
0:    */
0:   private Dictionary getDictionary(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier)
0:       throws CarbonUtilException {
0:     Dictionary forwardDictionary = null;
0:     // create column dictionary info object only if dictionary and its
0:     // metadata file exists for a given column identifier
0:     if (!isFileExistsForGivenColumn(dictionaryColumnUniqueIdentifier)) {
0:       throw new CarbonUtilException(
0:           "Either dictionary or its metadata does not exist for column identifier :: "
0:               + dictionaryColumnUniqueIdentifier.getColumnIdentifier());
0:     }
0:     String columnIdentifier = dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId();
0:     ColumnDictionaryInfo columnDictionaryInfo =
0:         getColumnDictionaryInfo(dictionaryColumnUniqueIdentifier, columnIdentifier);
0:     // load sort index file in case of forward dictionary
0:     checkAndLoadDictionaryData(dictionaryColumnUniqueIdentifier, columnDictionaryInfo,
0:         getLruCacheKey(dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId(),
0:             CacheType.FORWARD_DICTIONARY), true);
0:     forwardDictionary = new ForwardDictionary(columnDictionaryInfo);
0:     return forwardDictionary;
0:   }
0: 
0:   /**
0:    * This method will check and create columnDictionaryInfo object for the given column
0:    *
0:    * @param dictionaryColumnUniqueIdentifier
0:    * @param columnIdentifier
0:    * @return
0:    */
0:   private ColumnDictionaryInfo getColumnDictionaryInfo(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, String columnIdentifier) {
0:     ColumnDictionaryInfo columnDictionaryInfo = (ColumnDictionaryInfo) carbonLRUCache
0:         .get(getLruCacheKey(columnIdentifier, CacheType.FORWARD_DICTIONARY));
0:     if (null == columnDictionaryInfo) {
0:       synchronized (dictionaryColumnUniqueIdentifier) {
0:         columnDictionaryInfo = (ColumnDictionaryInfo) carbonLRUCache
0:             .get(getLruCacheKey(columnIdentifier, CacheType.FORWARD_DICTIONARY));
0:         if (null == columnDictionaryInfo) {
0:           columnDictionaryInfo =
0:               new ColumnDictionaryInfo(dictionaryColumnUniqueIdentifier.getDataType());
0:         }
0:       }
0:     }
0:     return columnDictionaryInfo;
0:   }
0: }
============================================================================