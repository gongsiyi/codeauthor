1:c2e4eb2: /*
1:c2e4eb2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:c2e4eb2:  * contributor license agreements.  See the NOTICE file distributed with
1:c2e4eb2:  * this work for additional information regarding copyright ownership.
1:c2e4eb2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:c2e4eb2:  * (the "License"); you may not use this file except in compliance with
1:c2e4eb2:  * the License.  You may obtain a copy of the License at
2:c2e4eb2:  *
1:c2e4eb2:  *    http://www.apache.org/licenses/LICENSE-2.0
1:c2e4eb2:  *
1:c2e4eb2:  * Unless required by applicable law or agreed to in writing, software
1:c2e4eb2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c2e4eb2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c2e4eb2:  * See the License for the specific language governing permissions and
1:c2e4eb2:  * limitations under the License.
2:c2e4eb2:  */
7:c2e4eb2: 
1:c2e4eb2: package org.apache.carbondata.core.scan.filter.executer;
1:c2e4eb2: 
1:c2e4eb2: import java.io.IOException;
1:c2e4eb2: import java.util.BitSet;
1:c2e4eb2: 
1:c2e4eb2: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:c2e4eb2: import org.apache.carbondata.core.datastore.block.SegmentProperties;
1:daa6465: import org.apache.carbondata.core.datastore.chunk.DimensionColumnPage;
1:c2e4eb2: import org.apache.carbondata.core.datastore.chunk.impl.DimensionRawColumnChunk;
1:d963a70: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryGenerator;
1:d963a70: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryKeyGeneratorFactory;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:d963a70: import org.apache.carbondata.core.metadata.encoder.Encoding;
1:c2e4eb2: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.Expression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanEqualToExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.LessThanEqualToExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.LessThanExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.exception.FilterUnsupportedException;
1:c2e4eb2: import org.apache.carbondata.core.scan.filter.FilterUtil;
1:9360370: import org.apache.carbondata.core.scan.filter.intf.RowIntf;
1:c2e4eb2: import org.apache.carbondata.core.scan.filter.resolver.resolverinfo.DimColumnResolvedFilterInfo;
1:daa6465: import org.apache.carbondata.core.scan.processor.RawBlockletColumnChunks;
1:c2e4eb2: import org.apache.carbondata.core.util.BitSetGroup;
1:c2e4eb2: import org.apache.carbondata.core.util.ByteUtil;
1:c2e4eb2: import org.apache.carbondata.core.util.CarbonUtil;
1:c2e4eb2: 
2:c2e4eb2: /**
1:c2e4eb2:  * This Class get a Min And Max value of a RANGE expression. Finds out if scan is required
1:c2e4eb2:  * for this Range. Also search the data block and set the required bitsets which falls within
1:c2e4eb2:  * the Range of the RANGE Expression.
1:c2e4eb2:  */
1:f911403: public class RangeValueFilterExecuterImpl implements FilterExecuter {
1:c2e4eb2: 
1:c2e4eb2:   private DimColumnResolvedFilterInfo dimColEvaluatorInfo;
1:c2e4eb2:   private Expression exp;
1:c2e4eb2:   private byte[][] filterRangesValues;
1:c2e4eb2:   private SegmentProperties segmentProperties;
1:c2e4eb2:   private boolean isDefaultValuePresentInFilter;
1:c2e4eb2:   /**
1:c2e4eb2:    * it has index at which given dimension is stored in file
1:c2e4eb2:    */
1:daa6465:   private int dimensionChunkIndex;
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * flag to check whether the filter dimension is present in current block list of dimensions.
1:c2e4eb2:    * Applicable for restructure scenarios
1:c2e4eb2:    */
1:daa6465:   private boolean isDimensionPresentInCurrentBlock;
1:daa6465:   private boolean lessThanExp;
1:daa6465:   private boolean lessThanEqualExp;
1:daa6465:   private boolean greaterThanExp;
1:daa6465:   private boolean greaterThanEqualExp;
1:daa6465:   private boolean startBlockMinIsDefaultStart;
1:daa6465:   private boolean endBlockMaxisDefaultEnd;
1:daa6465:   private boolean isRangeFullyCoverBlock;
1:4935cb1:   private boolean isNaturalSorted;
1:c2e4eb2: 
1:c2e4eb2:   public RangeValueFilterExecuterImpl(DimColumnResolvedFilterInfo dimColEvaluatorInfo,
1:daa6465:       Expression exp, byte[][] filterRangeValues, SegmentProperties segmentProperties) {
1:c2e4eb2: 
1:c2e4eb2:     this.dimColEvaluatorInfo = dimColEvaluatorInfo;
1:c2e4eb2:     this.exp = exp;
1:c2e4eb2:     this.segmentProperties = segmentProperties;
1:c2e4eb2:     this.filterRangesValues = filterRangeValues;
1:c2e4eb2:     this.lessThanExp = isLessThan();
1:c2e4eb2:     this.lessThanEqualExp = isLessThanEqualTo();
1:c2e4eb2:     this.greaterThanExp = isGreaterThan();
1:c2e4eb2:     this.greaterThanEqualExp = isGreaterThanEqualTo();
1:c2e4eb2:     startBlockMinIsDefaultStart = false;
1:c2e4eb2:     endBlockMaxisDefaultEnd = false;
1:c2e4eb2:     isRangeFullyCoverBlock = false;
1:daa6465:     initDimensionChunkIndexes();
1:c2e4eb2:     ifDefaultValueMatchesFilter();
1:3a4b881:     if (isDimensionPresentInCurrentBlock) {
1:4935cb1:       isNaturalSorted = dimColEvaluatorInfo.getDimension().isUseInvertedIndex()
1:4935cb1:           && dimColEvaluatorInfo.getDimension().isSortColumn();
1:4935cb1:     }
7:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method will initialize the dimension info for the current block to be
1:c2e4eb2:    * used for filtering the data
1:c2e4eb2:    */
1:daa6465:   private void initDimensionChunkIndexes() {
1:c2e4eb2:     // find the dimension in the current block dimensions list
1:c2e4eb2:     CarbonDimension dimensionFromCurrentBlock =
1:c2e4eb2:         segmentProperties.getDimensionFromCurrentBlock(dimColEvaluatorInfo.getDimension());
1:c2e4eb2:     if (null != dimensionFromCurrentBlock) {
1:c2e4eb2:       dimColEvaluatorInfo.setColumnIndex(dimensionFromCurrentBlock.getOrdinal());
1:daa6465:       this.dimensionChunkIndex = segmentProperties.getDimensionOrdinalToChunkMapping()
1:c2e4eb2:           .get(dimensionFromCurrentBlock.getOrdinal());
1:c2e4eb2:       isDimensionPresentInCurrentBlock = true;
1:c2e4eb2:     }
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method will check whether default value is present in the given filter values
1:c2e4eb2:    */
1:c2e4eb2:   private void ifDefaultValueMatchesFilter() {
1:c2e4eb2:     isDefaultValuePresentInFilter = false;
1:7ef9164:     if (!this.isDimensionPresentInCurrentBlock && null != filterRangesValues) {
1:c2e4eb2:       CarbonDimension dimension = this.dimColEvaluatorInfo.getDimension();
1:c2e4eb2:       byte[] defaultValue = dimension.getDefaultValue();
1:c2e4eb2:       if (null != defaultValue) {
1:c2e4eb2:         int maxCompare =
1:c2e4eb2:             ByteUtil.UnsafeComparer.INSTANCE.compareTo(defaultValue, filterRangesValues[0]);
1:c2e4eb2:         int minCompare =
1:c2e4eb2:             ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterRangesValues[1], defaultValue);
1:c2e4eb2: 
1:c2e4eb2:         if (((greaterThanExp && maxCompare > 0) || (greaterThanEqualExp && maxCompare >= 0))
1:c2e4eb2:             && ((lessThanExp && minCompare > 0) || (lessThanEqualExp && minCompare >= 0))) {
1:c2e4eb2:           isDefaultValuePresentInFilter = true;
1:c2e4eb2:         }
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * Method to apply the filter.
1:daa6465:    * @param rawBlockletColumnChunks
1:c2e4eb2:    * @return
2:c2e4eb2:    * @throws FilterUnsupportedException
1:c2e4eb2:    * @throws IOException
1:c2e4eb2:    */
1:daa6465:   public BitSetGroup applyFilter(RawBlockletColumnChunks rawBlockletColumnChunks,
1:daa6465:       boolean useBitsetPipeLine) throws FilterUnsupportedException, IOException {
1:4935cb1:     return applyNoAndDirectFilter(rawBlockletColumnChunks, useBitsetPipeLine);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:9360370:    * apply range filter on a row
1:9360370:    */
1:9360370:   public boolean applyFilter(RowIntf value, int dimOrdinalMax)
1:9360370:       throws FilterUnsupportedException, IOException {
1:9360370: 
1:9360370:     byte[] col = (byte[]) value.getVal(dimColEvaluatorInfo.getDimension().getOrdinal());
1:9360370:     byte[][] filterValues = this.filterRangesValues;
1:9360370: 
1:9360370:     if (isDimensionPresentInCurrentBlock) {
1:9360370:       boolean result;
1:9360370:       if (greaterThanExp) {
1:9360370:         result = ByteUtil.compare(filterValues[0], col) < 0;
1:9360370:       } else {
1:9360370:         result = ByteUtil.compare(filterValues[0], col) <= 0;
1:9360370:       }
1:9360370: 
1:9360370:       if (result) {
1:9360370:         if (lessThanExp) {
1:9360370:           return ByteUtil.compare(filterValues[1], col) > 0;
1:9360370:         } else {
1:9360370:           return ByteUtil.compare(filterValues[1], col) >= 0;
1:9360370:         }
1:9360370:       }
1:9360370:     }
1:9360370:     return false;
1:9360370:   }
1:9360370: 
1:9360370:   /**
1:c2e4eb2:    * Method to find presence of LessThan Expression.
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private boolean isLessThan() {
1:c2e4eb2:     for (Expression result : this.exp.getChildren()) {
1:c2e4eb2:       if (result instanceof LessThanExpression) {
1:c2e4eb2:         return true;
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return false;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * Method to find presence of LessThanEqualTo Expression.
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private boolean isLessThanEqualTo() {
1:c2e4eb2:     for (Expression result : this.exp.getChildren()) {
1:c2e4eb2:       if (result instanceof LessThanEqualToExpression) {
1:c2e4eb2:         return true;
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return false;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * Method to find presence of GreaterThan Expression.
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private boolean isGreaterThan() {
1:c2e4eb2:     for (Expression result : this.exp.getChildren()) {
1:c2e4eb2:       if (result instanceof GreaterThanExpression) {
1:c2e4eb2:         return true;
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return false;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * Method to find presence of GreaterThanEqual Expression.
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private boolean isGreaterThanEqualTo() {
1:c2e4eb2:     for (Expression result : this.exp.getChildren()) {
1:c2e4eb2:       if (result instanceof GreaterThanEqualToExpression) {
1:c2e4eb2:         return true;
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return false;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2: 
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * Method to identify if scanning of Data Block required or not by comparing the Block Min and Max
1:c2e4eb2:    * values and comparing them with filter min and max value.
1:c2e4eb2:    * @param blockMinValue
1:c2e4eb2:    * @param blockMaxValue
1:c2e4eb2:    * @param filterValues
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   public boolean isScanRequired(byte[] blockMinValue, byte[] blockMaxValue, byte[][] filterValues) {
1:c2e4eb2:     boolean isScanRequired = true;
1:c2e4eb2:     isRangeFullyCoverBlock = false;
1:c2e4eb2:     startBlockMinIsDefaultStart = false;
1:c2e4eb2:     endBlockMaxisDefaultEnd = false;
1:c2e4eb2: 
1:c2e4eb2:     /*
1:c2e4eb2:     For Undertsanding the below logic kept the value evaluation code intact.
1:c2e4eb2:     int filterMinlessThanBlockMin =
1:c2e4eb2:         ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[0]);
1:c2e4eb2:     int filterMaxLessThanBlockMin =
1:c2e4eb2:         ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[1]);
1:c2e4eb2: 
1:c2e4eb2:     int filterMinGreaterThanBlockMax =
1:c2e4eb2:         ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[0], blockMaxValue);
1:c2e4eb2:     int filterMaxGreaterThanBlockMax =
1:c2e4eb2:         ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[1], blockMaxValue);
1:c2e4eb2:      */
1:c2e4eb2: 
1:c2e4eb2:     // if any filter value is in range than this block needs to be
1:c2e4eb2:     // scanned less than equal to max range.
1:c2e4eb2:     // There are 4 cases which has been explicitly handled.
1:c2e4eb2:     // case A: Outside Boundary > No Scan required
1:c2e4eb2:     //                                                Block Min <---------->  Block Max
1:c2e4eb2:     //        Filter Min <----------> Filter Max
1:c2e4eb2:     // case B: Filter Overlaps Upper Part Block then Block Start Scan Becomes StartIndex of Block.
1:c2e4eb2:     //                         Block Min <-----------------> Block Max
1:c2e4eb2:     //   Filter Min <-------------------------> Filter Min
1:c2e4eb2:     // Case C: Filter Overlaps Lower Part of Block then Block End Scan becomes Number Of Rows - 1
1:c2e4eb2:     //         Block Min <-------------------------> Block Max
1:c2e4eb2:     //                          Filter Min <--------------------------> Filter Max
1:c2e4eb2:     // Case D: Filter Values Completely overlaps Block Min and Max then all bits are set.
1:c2e4eb2:     //                       Block Min <-----------------------> Block Max
1:c2e4eb2:     //         Filter Min <-----------------------------------------------> Filter Max
1:c2e4eb2: 
1:3ae4472:     if (isDimensionPresentInCurrentBlock) {
1:daa6465:       if (((lessThanExp) && (
1:c2e4eb2:           ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[1]) >= 0)) || (
1:daa6465:           (lessThanEqualExp) && (
1:c2e4eb2:               ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[1]) > 0)) || (
1:daa6465:           (greaterThanExp) && (
1:c2e4eb2:               ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[0], blockMaxValue) >= 0)) || (
1:daa6465:           (greaterThanEqualExp) && (
1:c2e4eb2:               ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[0], blockMaxValue) > 0))) {
1:c2e4eb2:         // completely out of block boundary
1:c2e4eb2:         isScanRequired = false;
2:c2e4eb2:       } else {
1:daa6465:         if (((greaterThanExp) && (
1:c2e4eb2:             ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[0]) > 0)) || (
1:daa6465:             (greaterThanEqualExp) && (
1:c2e4eb2:                 ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[0]) >= 0))) {
1:c2e4eb2:           startBlockMinIsDefaultStart = true;
1:c2e4eb2:         }
1:c2e4eb2: 
1:daa6465:         if (((lessThanExp) && (
1:c2e4eb2:             ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[1], blockMaxValue) > 0)) || (
1:daa6465:             (lessThanEqualExp) && (
1:c2e4eb2:                 ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[1], blockMaxValue) >= 0))) {
1:c2e4eb2:           endBlockMaxisDefaultEnd = true;
1:c2e4eb2:         }
1:c2e4eb2: 
1:daa6465:         if (startBlockMinIsDefaultStart && endBlockMaxisDefaultEnd) {
1:c2e4eb2:           isRangeFullyCoverBlock = true;
1:c2e4eb2:         }
1:c2e4eb2:       }
1:c2e4eb2:       return isScanRequired;
1:c2e4eb2:     } else {
1:c2e4eb2:       return isDefaultValuePresentInFilter;
1:c2e4eb2:     }
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * Method checks is the scan lies within the range values or not.
1:c2e4eb2:    * @param blockMaxValue
1:c2e4eb2:    * @param blockMinValue
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:daa6465:   @Override
1:daa6465:   public BitSet isScanRequired(byte[][] blockMaxValue, byte[][] blockMinValue) {
1:c2e4eb2:     BitSet bitSet = new BitSet(1);
1:c2e4eb2:     byte[][] filterValues = this.filterRangesValues;
1:dc29319:     int columnIndex = this.dimColEvaluatorInfo.getColumnIndexInMinMaxByteArray();
1:b681244:     boolean isScanRequired = columnIndex >= blockMinValue.length ||
1:c2e4eb2:         isScanRequired(blockMinValue[columnIndex], blockMaxValue[columnIndex], filterValues);
1:c2e4eb2:     if (isScanRequired) {
1:c2e4eb2:       bitSet.set(0);
1:c2e4eb2:     }
1:c2e4eb2:     return bitSet;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * Method to apply the Range Filter.
3:c2e4eb2:    * @param blockChunkHolder
1:c2e4eb2:    * @return
1:c2e4eb2:    * @throws IOException
1:c2e4eb2:    */
1:4935cb1:   private BitSetGroup applyNoAndDirectFilter(RawBlockletColumnChunks blockChunkHolder,
1:4935cb1:       boolean useBitsetPipeLine) throws IOException {
1:c2e4eb2: 
1:c2e4eb2:     // In case of Alter Table Add and Delete Columns the isDimensionPresentInCurrentBlock can be
1:c2e4eb2:     // false, in that scenario the default values of the column should be shown.
1:c2e4eb2:     // select all rows if dimension does not exists in the current block
1:c2e4eb2:     if (!isDimensionPresentInCurrentBlock) {
1:daa6465:       int numberOfRows = blockChunkHolder.getDataBlock().numRows();
1:daa6465:       return FilterUtil.createBitSetGroupWithDefaultValue(
1:daa6465:           blockChunkHolder.getDataBlock().numberOfPages(), numberOfRows, true);
1:c2e4eb2:     }
1:c2e4eb2: 
1:daa6465:     int chunkIndex = segmentProperties.getDimensionOrdinalToChunkMapping()
1:c2e4eb2:         .get(dimColEvaluatorInfo.getColumnIndex());
1:c2e4eb2: 
1:daa6465:     if (null == blockChunkHolder.getDimensionRawColumnChunks()[chunkIndex]) {
1:daa6465:       blockChunkHolder.getDimensionRawColumnChunks()[chunkIndex] =
1:daa6465:           blockChunkHolder.getDataBlock().readDimensionChunk(
1:daa6465:               blockChunkHolder.getFileReader(), chunkIndex);
1:c2e4eb2:     }
1:c2e4eb2: 
1:c2e4eb2:     DimensionRawColumnChunk rawColumnChunk =
1:daa6465:         blockChunkHolder.getDimensionRawColumnChunks()[chunkIndex];
1:c2e4eb2:     BitSetGroup bitSetGroup = new BitSetGroup(rawColumnChunk.getPagesCount());
1:4935cb1:     FilterExecuter filterExecuter = null;
1:4935cb1:     boolean isExclude = false;
1:c2e4eb2:     for (int i = 0; i < rawColumnChunk.getPagesCount(); i++) {
1:c2e4eb2:       if (rawColumnChunk.getMaxValues() != null) {
1:c2e4eb2:         if (isScanRequired(rawColumnChunk.getMinValues()[i], rawColumnChunk.getMaxValues()[i],
1:c2e4eb2:             this.filterRangesValues)) {
1:daa6465:           if (isRangeFullyCoverBlock) {
1:c2e4eb2:             // Set all the bits in this case as filter Min Max values cover the whole block.
1:c2e4eb2:             BitSet bitSet = new BitSet(rawColumnChunk.getRowCount()[i]);
1:c2e4eb2:             bitSet.flip(0, rawColumnChunk.getRowCount()[i]);
1:c2e4eb2:             bitSetGroup.setBitSet(bitSet, i);
1:c2e4eb2:           } else {
1:4935cb1:             BitSet bitSet;
1:4935cb1:             DimensionColumnPage dimensionColumnPage = rawColumnChunk.decodeColumnPage(i);
1:4935cb1:             if (null != rawColumnChunk.getLocalDictionary()) {
1:4935cb1:               if (null == filterExecuter) {
1:4935cb1:                 filterExecuter = FilterUtil
1:3a4b881:                     .getFilterExecutorForRangeFilters(rawColumnChunk, exp, isNaturalSorted);
1:4935cb1:                 if (filterExecuter instanceof ExcludeFilterExecuterImpl) {
1:4935cb1:                   isExclude = true;
1:4935cb1:                 }
1:4935cb1:               }
1:4935cb1:               if (!isExclude) {
1:4935cb1:                 bitSet = ((IncludeFilterExecuterImpl) filterExecuter)
1:4935cb1:                     .getFilteredIndexes(dimensionColumnPage,
1:4935cb1:                         rawColumnChunk.getRowCount()[i], useBitsetPipeLine,
1:4935cb1:                         blockChunkHolder.getBitSetGroup(), i);
1:4935cb1:               } else {
1:4935cb1:                 bitSet = ((ExcludeFilterExecuterImpl) filterExecuter)
1:4935cb1:                     .getFilteredIndexes(dimensionColumnPage,
1:4935cb1:                         rawColumnChunk.getRowCount()[i], useBitsetPipeLine,
1:4935cb1:                         blockChunkHolder.getBitSetGroup(), i);
1:4935cb1:               }
1:4935cb1:             } else {
1:4935cb1:               bitSet = getFilteredIndexes(dimensionColumnPage,
1:4935cb1:                   rawColumnChunk.getRowCount()[i]);
1:4935cb1:             }
1:c2e4eb2:             bitSetGroup.setBitSet(bitSet, i);
1:c2e4eb2:           }
1:c2e4eb2:         }
1:c2e4eb2:       } else {
2:daa6465:         BitSet bitSet = getFilteredIndexes(rawColumnChunk.decodeColumnPage(i),
2:c2e4eb2:             rawColumnChunk.getRowCount()[i]);
1:c2e4eb2:         bitSetGroup.setBitSet(bitSet, i);
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return bitSetGroup;
1:c2e4eb2:   }
1:c2e4eb2: 
1:daa6465:   private BitSet getFilteredIndexes(DimensionColumnPage dimensionColumnPage,
1:c2e4eb2:       int numerOfRows) {
1:daa6465:     if (dimensionColumnPage.isExplicitSorted()) {
1:daa6465:       return setFilterdIndexToBitSetWithColumnIndex(dimensionColumnPage, numerOfRows);
1:c2e4eb2:     }
1:daa6465:     return setFilterdIndexToBitSet(dimensionColumnPage, numerOfRows);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * Method will scan the block and finds the range start index from which all members
1:c2e4eb2:    * will be considered for applying range filters. this method will be called if the
1:c2e4eb2:    * column is not supported by default so column index mapping  will be present for
1:c2e4eb2:    * accesing the members from the block.
1:c2e4eb2:    *
1:daa6465:    * @param dimensionColumnPage
1:c2e4eb2:    * @param numerOfRows
1:c2e4eb2:    * @return BitSet.
1:c2e4eb2:    */
1:c2e4eb2:   private BitSet setFilterdIndexToBitSetWithColumnIndex(
1:daa6465:       DimensionColumnPage dimensionColumnPage, int numerOfRows) {
1:c2e4eb2:     BitSet bitSet = new BitSet(numerOfRows);
1:3ae4472:     int start = 0;
2:c2e4eb2:     int startIndex = 0;
1:3ae4472:     int startMin = 0;
1:3ae4472:     int endMax = 0;
1:c2e4eb2:     byte[][] filterValues = this.filterRangesValues;
1:c2e4eb2: 
1:3ae4472:     // For Range expression we expect two values. The First is the Min Value and Second is the
1:3ae4472:     // Max value.
1:c2e4eb2:     // Get the Min Value
1:daa6465:     if (!startBlockMinIsDefaultStart) {
3:c2e4eb2:       start = CarbonUtil
1:daa6465:           .getFirstIndexUsingBinarySearch(dimensionColumnPage, startIndex, numerOfRows - 1,
1:3ae4472:               filterValues[0], greaterThanExp);
1:daa6465:       if (greaterThanExp && start >= 0) {
1:3ae4472:         start = CarbonUtil
1:daa6465:             .nextGreaterValueToTarget(start, dimensionColumnPage, filterValues[0],
1:3ae4472:                 numerOfRows);
1:3ae4472:       }
1:3ae4472: 
1:3ae4472:       if (start < 0) {
1:3ae4472:         start = -(start + 1);
1:3ae4472:         if (start == numerOfRows) {
1:3ae4472:           start = start - 1;
1:3ae4472:         }
1:3ae4472:         // Method will compare the tentative index value after binary search, this tentative
1:3ae4472:         // index needs to be compared by the filter member if its >= filter then from that
1:3ae4472:         // index the bitset will be considered for filtering process.
1:daa6465:         if ((ByteUtil.compare(filterValues[0], dimensionColumnPage
1:daa6465:             .getChunkData(dimensionColumnPage.getInvertedIndex(start)))) > 0) {
4:c2e4eb2:           start = start + 1;
1:3ae4472:         }
1:c2e4eb2:       }
1:3ae4472: 
2:c2e4eb2:       startMin = start;
1:3ae4472:     } else {
2:c2e4eb2:       startMin = startIndex;
1:c2e4eb2:     }
1:c2e4eb2: 
1:c2e4eb2:     // Get the Max value
1:daa6465:     if (!endBlockMaxisDefaultEnd) {
1:c2e4eb2:       start = CarbonUtil
1:daa6465:           .getFirstIndexUsingBinarySearch(dimensionColumnPage, startIndex, numerOfRows - 1,
2:c2e4eb2:               filterValues[1], lessThanEqualExp);
1:105e3a0: 
1:daa6465:       if (lessThanExp && start >= 0) {
2:c2e4eb2:         start =
1:daa6465:             CarbonUtil.nextLesserValueToTarget(start, dimensionColumnPage, filterValues[1]);
1:c2e4eb2:       }
1:c2e4eb2: 
3:c2e4eb2:       if (start < 0) {
3:c2e4eb2:         start = -(start + 1);
3:c2e4eb2:         if (start == numerOfRows) {
1:3ae4472:           start = start - 1;
1:c2e4eb2:         }
1:105e3a0:         // In case the start is less than 0, then positive value of start is pointing to the next
1:105e3a0:         // value of the searched key. So move to the previous one.
1:105e3a0:         if ((ByteUtil.compare(filterValues[1],
1:daa6465:             dimensionColumnPage.getChunkData(dimensionColumnPage.getInvertedIndex(start)))
1:105e3a0:             < 0)) {
6:c2e4eb2:           start = start - 1;
1:c2e4eb2:         }
1:c2e4eb2:       }
2:c2e4eb2:       endMax = start;
1:c2e4eb2:     } else {
2:c2e4eb2:       endMax = numerOfRows - 1;
1:c2e4eb2:     }
1:c2e4eb2: 
2:c2e4eb2:     for (int j = startMin; j <= endMax; j++) {
1:daa6465:       bitSet.set(dimensionColumnPage.getInvertedIndex(j));
1:c2e4eb2:     }
1:c2e4eb2: 
2:c2e4eb2:     // Binary Search cannot be done on '@NU#LL$!", so need to check and compare for null on
2:c2e4eb2:     // matching row.
1:daa6465:     if (dimensionColumnPage.isNoDicitionaryColumn()) {
1:daa6465:       updateForNoDictionaryColumn(startMin, endMax, dimensionColumnPage, bitSet);
1:c2e4eb2:     }
1:c2e4eb2:     return bitSet;
1:c2e4eb2:   }
1:c2e4eb2: 
1:daa6465:   private void updateForNoDictionaryColumn(int start, int end, DimensionColumnPage dataChunk,
1:c2e4eb2:       BitSet bitset) {
1:c2e4eb2:     for (int j = start; j <= end; j++) {
1:36ceb59:       if (dataChunk.compareTo(j, CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY) == 0
1:36ceb59:           || dataChunk.compareTo(j, CarbonCommonConstants.EMPTY_BYTE_ARRAY) == 0) {
1:c2e4eb2:         bitset.flip(j);
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * Method will scan the block and finds the range start index from which all
1:c2e4eb2:    * members will be considered for applying range filters. this method will
1:c2e4eb2:    * be called if the column is sorted default so column index
1:c2e4eb2:    * mapping will be present for accesaing the members from the block.
1:3ae4472:    *
1:daa6465:    * @param dimensionColumnPage
1:c2e4eb2:    * @param numerOfRows
1:c2e4eb2:    * @return BitSet.
1:3ae4472:    */
1:daa6465:   private BitSet setFilterdIndexToBitSet(DimensionColumnPage dimensionColumnPage,
1:c2e4eb2:       int numerOfRows) {
1:c2e4eb2:     BitSet bitSet = new BitSet(numerOfRows);
1:daa6465:     // if (dimensionColumnPage instanceof FixedLengthDimensionColumnPage) {
1:c2e4eb2:     byte[][] filterValues = this.filterRangesValues;
1:daa6465:     if (dimensionColumnPage.isExplicitSorted()) {
2:c2e4eb2:       int start = 0;
2:c2e4eb2:       int startMin = 0;
2:c2e4eb2:       int endMax = 0;
1:3ae4472:       int startIndex = 0;
2:c2e4eb2:       // For Range expression we expect two values. The First is the Min Value and Second is the
2:c2e4eb2:       // Max value.
1:daa6465:       if (!startBlockMinIsDefaultStart) {
1:c2e4eb2: 
1:c2e4eb2:         start = CarbonUtil
1:daa6465:             .getFirstIndexUsingBinarySearch(dimensionColumnPage, startIndex, numerOfRows - 1,
1:c2e4eb2:                 filterValues[0], greaterThanExp);
1:c2e4eb2: 
1:daa6465:         if (greaterThanExp && start >= 0) {
1:c2e4eb2:           start = CarbonUtil
1:daa6465:               .nextGreaterValueToTarget(start, dimensionColumnPage, filterValues[0],
2:c2e4eb2:                   numerOfRows);
1:c2e4eb2:         }
1:c2e4eb2: 
1:c2e4eb2:         if (start < 0) {
1:c2e4eb2:           start = -(start + 1);
1:c2e4eb2:           if (start == numerOfRows) {
1:c2e4eb2:             start = start - 1;
1:c2e4eb2:           }
4:c2e4eb2:           // Method will compare the tentative index value after binary search, this tentative
4:c2e4eb2:           // index needs to be compared by the filter member if its >= filter then from that
4:c2e4eb2:           // index the bitset will be considered for filtering process.
1:daa6465:           if ((ByteUtil.compare(filterValues[0], dimensionColumnPage.getChunkData(start)))
1:3ae4472:               > 0) {
1:3ae4472:             start = start + 1;
1:3ae4472:           }
1:3ae4472:         }
1:3ae4472:         startMin = start;
1:3ae4472:       } else {
1:3ae4472:         startMin = startIndex;
1:3ae4472:       }
1:3ae4472: 
1:daa6465:       if (!endBlockMaxisDefaultEnd) {
1:3ae4472:         start = CarbonUtil
1:daa6465:             .getFirstIndexUsingBinarySearch(dimensionColumnPage, startIndex, numerOfRows - 1,
1:3ae4472:                 filterValues[1], lessThanEqualExp);
1:3ae4472: 
1:daa6465:         if (lessThanExp && start >= 0) {
1:3ae4472:           start =
1:daa6465:               CarbonUtil.nextLesserValueToTarget(start, dimensionColumnPage, filterValues[1]);
1:3ae4472:         }
1:3ae4472: 
1:3ae4472:         if (start < 0) {
1:3ae4472:           start = -(start + 1);
1:3ae4472:           if (start == numerOfRows) {
1:3ae4472:             start = start - 1;
1:c2e4eb2:           }
1:3ae4472:           // In case the start is less than 0, then positive value of start is pointing to the next
1:3ae4472:           // value of the searched key. So move to the previous one.
1:daa6465:           if ((ByteUtil.compare(filterValues[1], dimensionColumnPage.getChunkData(start))
1:3ae4472:               < 0)) {
1:c2e4eb2:             start = start - 1;
1:c2e4eb2:           }
1:c2e4eb2:         }
1:3ae4472:         endMax = start;
1:c2e4eb2:       } else {
1:3ae4472:         endMax = numerOfRows - 1;
1:c2e4eb2:       }
1:c2e4eb2: 
1:3ae4472:       for (int j = startMin; j <= endMax; j++) {
1:3ae4472:         bitSet.set(j);
1:3ae4472:       }
1:3ae4472: 
1:3ae4472:       // Binary Search cannot be done on '@NU#LL$!", so need to check and compare for null on
1:3ae4472:       // matching row.
1:daa6465:       if (dimensionColumnPage.isNoDicitionaryColumn()) {
1:daa6465:         updateForNoDictionaryColumn(startMin, endMax, dimensionColumnPage, bitSet);
1:c2e4eb2:       }
1:c2e4eb2:     } else {
1:d963a70:       byte[] defaultValue = null;
1:d963a70:       if (dimColEvaluatorInfo.getDimension().hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:d963a70:         DirectDictionaryGenerator directDictionaryGenerator = DirectDictionaryKeyGeneratorFactory
1:d963a70:             .getDirectDictionaryGenerator(dimColEvaluatorInfo.getDimension().getDataType());
1:17892b1:         int key = directDictionaryGenerator.generateDirectSurrogateKey(null);
1:d963a70:         CarbonDimension currentBlockDimension =
1:daa6465:             segmentProperties.getDimensions().get(dimensionChunkIndex);
1:887310f:         if (currentBlockDimension.isSortColumn()) {
1:d963a70:           defaultValue = FilterUtil.getMaskKey(key, currentBlockDimension,
1:d963a70:               this.segmentProperties.getSortColumnsGenerator());
1:d963a70:         } else {
1:f012f5b:           defaultValue = ByteUtil.toXorBytes(key);
1:887310f:         }
1:887310f:       } else {
1:956833e:         if (dimColEvaluatorInfo.getDimension().getDataType() == DataTypes.STRING) {
1:36ceb59:           defaultValue = CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY;
1:36ceb59:         } else {
1:36ceb59:           defaultValue = CarbonCommonConstants.EMPTY_BYTE_ARRAY;
1:36ceb59:         }
1:d963a70:       }
1:3ae4472:       // evaluate result for lower range value first and then perform and operation in the
1:3ae4472:       // upper range value in order to compute the final result
1:daa6465:       bitSet = evaluateGreaterThanFilterForUnsortedColumn(dimensionColumnPage, filterValues[0],
1:3ae4472:           numerOfRows);
1:3ae4472:       BitSet upperRangeBitSet =
1:daa6465:           evaluateLessThanFilterForUnsortedColumn(dimensionColumnPage, filterValues[1],
1:3ae4472:               numerOfRows);
1:3ae4472:       bitSet.and(upperRangeBitSet);
1:daa6465:       FilterUtil.removeNullValues(dimensionColumnPage, bitSet, defaultValue);
1:3ae4472:     }
1:3ae4472:     return bitSet;
1:3ae4472:   }
1:c2e4eb2: 
1:3ae4472:   /**
1:3ae4472:    * This method will evaluate the result for filter column based on the lower range value
1:3ae4472:    *
1:daa6465:    * @param dimensionColumnPage
1:3ae4472:    * @param filterValue
1:3ae4472:    * @param numberOfRows
1:3ae4472:    * @return
1:3ae4472:    */
1:3ae4472:   private BitSet evaluateGreaterThanFilterForUnsortedColumn(
1:daa6465:       DimensionColumnPage dimensionColumnPage, byte[] filterValue, int numberOfRows) {
1:3ae4472:     BitSet bitSet = new BitSet(numberOfRows);
1:3ae4472:     if (greaterThanExp) {
1:3ae4472:       for (int i = 0; i < numberOfRows; i++) {
1:daa6465:         if ((ByteUtil.compare(dimensionColumnPage.getChunkData(i), filterValue) > 0)) {
1:3ae4472:           bitSet.set(i);
1:3ae4472:         }
1:3ae4472:       }
1:3ae4472:     } else if (greaterThanEqualExp) {
1:3ae4472:       for (int i = 0; i < numberOfRows; i++) {
1:daa6465:         if ((ByteUtil.compare(dimensionColumnPage.getChunkData(i), filterValue) >= 0)) {
1:3ae4472:           bitSet.set(i);
1:3ae4472:         }
1:3ae4472:       }
1:3ae4472:     }
1:3ae4472:     return bitSet;
1:c2e4eb2:   }
1:c2e4eb2: 
1:3ae4472:   /**
1:3ae4472:    * This method will evaluate the result for filter column based on the upper range value
1:3ae4472:    *
1:daa6465:    * @param dimensionColumnPage
1:3ae4472:    * @param filterValue
1:3ae4472:    * @param numberOfRows
1:3ae4472:    * @return
1:3ae4472:    */
1:3ae4472:   private BitSet evaluateLessThanFilterForUnsortedColumn(
1:daa6465:       DimensionColumnPage dimensionColumnPage, byte[] filterValue, int numberOfRows) {
1:3ae4472:     BitSet bitSet = new BitSet(numberOfRows);
1:3ae4472:     if (lessThanExp) {
1:3ae4472:       for (int i = 0; i < numberOfRows; i++) {
1:daa6465:         if ((ByteUtil.compare(dimensionColumnPage.getChunkData(i), filterValue) < 0)) {
1:3ae4472:           bitSet.set(i);
1:3ae4472:         }
1:3ae4472:       }
1:3ae4472:     } else if (lessThanEqualExp) {
1:3ae4472:       for (int i = 0; i < numberOfRows; i++) {
1:daa6465:         if ((ByteUtil.compare(dimensionColumnPage.getChunkData(i), filterValue) <= 0)) {
1:3ae4472:           bitSet.set(i);
1:3ae4472:         }
1:3ae4472:       }
1:c2e4eb2:     }
1:c2e4eb2:     return bitSet;
1:c2e4eb2:   }
1:c2e4eb2: 
1:3ae4472:   /**
1:c2e4eb2:    * Method to read the blocks.
1:daa6465:    * @param rawBlockletColumnChunks
1:c2e4eb2:    * @throws IOException
1:c2e4eb2:    */
1:daa6465:   @Override
1:daa6465:   public void readColumnChunks(RawBlockletColumnChunks rawBlockletColumnChunks) throws IOException {
1:daa6465:     if (isDimensionPresentInCurrentBlock) {
1:daa6465:       int chunkIndex = segmentProperties.getDimensionOrdinalToChunkMapping()
1:c2e4eb2:           .get(dimColEvaluatorInfo.getColumnIndex());
1:daa6465:       if (null == rawBlockletColumnChunks.getDimensionRawColumnChunks()[chunkIndex]) {
1:daa6465:         rawBlockletColumnChunks.getDimensionRawColumnChunks()[chunkIndex] =
1:daa6465:             rawBlockletColumnChunks.getDataBlock().readDimensionChunk(
1:daa6465:                 rawBlockletColumnChunks.getFileReader(), chunkIndex);
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:   }
1:c2e4eb2: }
============================================================================
author:QiangCai
-------------------------------------------------------------------------------
commit:f012f5b
/////////////////////////////////////////////////////////////////////////
1:           defaultValue = ByteUtil.toXorBytes(key);
commit:9360370
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.filter.intf.RowIntf;
/////////////////////////////////////////////////////////////////////////
1:    * apply range filter on a row
1:    */
1:   public boolean applyFilter(RowIntf value, int dimOrdinalMax)
1:       throws FilterUnsupportedException, IOException {
1: 
1:     byte[] col = (byte[]) value.getVal(dimColEvaluatorInfo.getDimension().getOrdinal());
1:     byte[][] filterValues = this.filterRangesValues;
1: 
1:     if (isDimensionPresentInCurrentBlock) {
1:       boolean result;
1:       if (greaterThanExp) {
1:         result = ByteUtil.compare(filterValues[0], col) < 0;
1:       } else {
1:         result = ByteUtil.compare(filterValues[0], col) <= 0;
1:       }
1: 
1:       if (result) {
1:         if (lessThanExp) {
1:           return ByteUtil.compare(filterValues[1], col) > 0;
1:         } else {
1:           return ByteUtil.compare(filterValues[1], col) >= 0;
1:         }
1:       }
1:     }
1:     return false;
1:   }
1: 
1:   /**
author:sraghunandan
-------------------------------------------------------------------------------
commit:f911403
/////////////////////////////////////////////////////////////////////////
1: public class RangeValueFilterExecuterImpl implements FilterExecuter {
author:manishgupta88
-------------------------------------------------------------------------------
commit:dc29319
/////////////////////////////////////////////////////////////////////////
1:     int columnIndex = this.dimColEvaluatorInfo.getColumnIndexInMinMaxByteArray();
commit:3ae4472
/////////////////////////////////////////////////////////////////////////
1:     if (isDimensionPresentInCurrentBlock) {
/////////////////////////////////////////////////////////////////////////
0:     if (dimensionColumnDataChunk.isExplicitSorted()) {
1:       int start = 0;
1:       int startMin = 0;
1:       int endMax = 0;
1:       int startIndex = 0;
1:       // For Range expression we expect two values. The First is the Min Value and Second is the
1:       // Max value.
0:       if (startBlockMinIsDefaultStart == false) {
0:             .getFirstIndexUsingBinarySearch(dimensionColumnDataChunk, startIndex, numerOfRows - 1,
1:                 filterValues[0], greaterThanExp);
1: 
0:         if (greaterThanExp == true && start >= 0) {
1:           start = CarbonUtil
0:               .nextGreaterValueToTarget(start, dimensionColumnDataChunk, filterValues[0],
1:                   numerOfRows);
1:         }
1: 
1:         if (start < 0) {
1:           start = -(start + 1);
1:           if (start == numerOfRows) {
1:             start = start - 1;
1:           }
1:           // Method will compare the tentative index value after binary search, this tentative
1:           // index needs to be compared by the filter member if its >= filter then from that
1:           // index the bitset will be considered for filtering process.
0:           if ((ByteUtil.compare(filterValues[0], dimensionColumnDataChunk.getChunkData(start)))
1:               > 0) {
1:             start = start + 1;
1:           }
1:         }
1:         startMin = start;
1:       } else {
1:         startMin = startIndex;
0:       if (endBlockMaxisDefaultEnd == false) {
1:         start = CarbonUtil
0:             .getFirstIndexUsingBinarySearch(dimensionColumnDataChunk, startIndex, numerOfRows - 1,
1:                 filterValues[1], lessThanEqualExp);
1: 
0:         if (lessThanExp == true && start >= 0) {
1:           start =
0:               CarbonUtil.nextLesserValueToTarget(start, dimensionColumnDataChunk, filterValues[1]);
1: 
1:         if (start < 0) {
1:           start = -(start + 1);
1:           if (start == numerOfRows) {
1:             start = start - 1;
1:           }
1:           // In case the start is less than 0, then positive value of start is pointing to the next
1:           // value of the searched key. So move to the previous one.
0:           if ((ByteUtil.compare(filterValues[1], dimensionColumnDataChunk.getChunkData(start))
1:               < 0)) {
1:             start = start - 1;
1:           }
1:         endMax = start;
1:       } else {
1:         endMax = numerOfRows - 1;
1: 
1:       for (int j = startMin; j <= endMax; j++) {
1:         bitSet.set(j);
1:       }
1: 
1:       // Binary Search cannot be done on '@NU#LL$!", so need to check and compare for null on
1:       // matching row.
0:       if (dimensionColumnDataChunk.isNoDicitionaryColumn()) {
0:         updateForNoDictionaryColumn(startMin, endMax, dimensionColumnDataChunk, bitSet);
1:       }
1:       // evaluate result for lower range value first and then perform and operation in the
1:       // upper range value in order to compute the final result
0:       bitSet = evaluateGreaterThanFilterForUnsortedColumn(dimensionColumnDataChunk, filterValues[0],
1:           numerOfRows);
0:       // remove null values from lower range selected bitSet values
0:       removeNullValues(dimensionColumnDataChunk, bitSet);
1:       BitSet upperRangeBitSet =
0:           evaluateLessThanFilterForUnsortedColumn(dimensionColumnDataChunk, filterValues[1],
1:               numerOfRows);
0:       // remove null values from upper range selected bitSet values
0:       removeNullValues(dimensionColumnDataChunk, upperRangeBitSet);
1:       bitSet.and(upperRangeBitSet);
1:     return bitSet;
1:   }
1:   /**
0:    * This method will compare the selected data against null values and
0:    * flip the bitSet if any null value is found
1:    *
0:    * @param dimensionColumnDataChunk
0:    * @param bitSet
1:    */
0:   private void removeNullValues(DimensionColumnDataChunk dimensionColumnDataChunk, BitSet bitSet) {
0:     if (!bitSet.isEmpty()) {
0:       for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) {
0:         if (dimensionColumnDataChunk.compareTo(i, CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY)
0:             == 0) {
0:           bitSet.flip(i);
1:   }
1:   /**
1:    * This method will evaluate the result for filter column based on the lower range value
1:    *
0:    * @param dimensionColumnDataChunk
1:    * @param filterValue
1:    * @param numberOfRows
1:    * @return
1:    */
1:   private BitSet evaluateGreaterThanFilterForUnsortedColumn(
0:       DimensionColumnDataChunk dimensionColumnDataChunk, byte[] filterValue, int numberOfRows) {
1:     BitSet bitSet = new BitSet(numberOfRows);
1:     if (greaterThanExp) {
1:       for (int i = 0; i < numberOfRows; i++) {
0:         if ((ByteUtil.compare(dimensionColumnDataChunk.getChunkData(i), filterValue) > 0)) {
1:           bitSet.set(i);
1:         }
1:       }
1:     } else if (greaterThanEqualExp) {
1:       for (int i = 0; i < numberOfRows; i++) {
0:         if ((ByteUtil.compare(dimensionColumnDataChunk.getChunkData(i), filterValue) >= 0)) {
1:           bitSet.set(i);
1:         }
1:       }
1:     return bitSet;
1:   }
1:   /**
1:    * This method will evaluate the result for filter column based on the upper range value
1:    *
0:    * @param dimensionColumnDataChunk
1:    * @param filterValue
1:    * @param numberOfRows
1:    * @return
1:    */
1:   private BitSet evaluateLessThanFilterForUnsortedColumn(
0:       DimensionColumnDataChunk dimensionColumnDataChunk, byte[] filterValue, int numberOfRows) {
1:     BitSet bitSet = new BitSet(numberOfRows);
1:     if (lessThanExp) {
1:       for (int i = 0; i < numberOfRows; i++) {
0:         if ((ByteUtil.compare(dimensionColumnDataChunk.getChunkData(i), filterValue) < 0)) {
1:           bitSet.set(i);
1:         }
1:       }
1:     } else if (lessThanEqualExp) {
1:       for (int i = 0; i < numberOfRows; i++) {
0:         if ((ByteUtil.compare(dimensionColumnDataChunk.getChunkData(i), filterValue) <= 0)) {
1:           bitSet.set(i);
1:         }
1:       }
author:kumarvishal09
-------------------------------------------------------------------------------
commit:3a4b881
/////////////////////////////////////////////////////////////////////////
1:     if (isDimensionPresentInCurrentBlock) {
/////////////////////////////////////////////////////////////////////////
1:                     .getFilterExecutorForRangeFilters(rawColumnChunk, exp, isNaturalSorted);
author:akashrn5
-------------------------------------------------------------------------------
commit:4935cb1
/////////////////////////////////////////////////////////////////////////
1:   private boolean isNaturalSorted;
/////////////////////////////////////////////////////////////////////////
0:     if (isDimensionPresentInCurrentBlock == true) {
1:       isNaturalSorted = dimColEvaluatorInfo.getDimension().isUseInvertedIndex()
1:           && dimColEvaluatorInfo.getDimension().isSortColumn();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     return applyNoAndDirectFilter(rawBlockletColumnChunks, useBitsetPipeLine);
/////////////////////////////////////////////////////////////////////////
1:   private BitSetGroup applyNoAndDirectFilter(RawBlockletColumnChunks blockChunkHolder,
1:       boolean useBitsetPipeLine) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     FilterExecuter filterExecuter = null;
1:     boolean isExclude = false;
/////////////////////////////////////////////////////////////////////////
1:             BitSet bitSet;
1:             DimensionColumnPage dimensionColumnPage = rawColumnChunk.decodeColumnPage(i);
1:             if (null != rawColumnChunk.getLocalDictionary()) {
1:               if (null == filterExecuter) {
1:                 filterExecuter = FilterUtil
0:                     .getFilterExecutorForLocalDictionary(rawColumnChunk, exp, isNaturalSorted);
1:                 if (filterExecuter instanceof ExcludeFilterExecuterImpl) {
1:                   isExclude = true;
1:                 }
1:               }
1:               if (!isExclude) {
1:                 bitSet = ((IncludeFilterExecuterImpl) filterExecuter)
1:                     .getFilteredIndexes(dimensionColumnPage,
1:                         rawColumnChunk.getRowCount()[i], useBitsetPipeLine,
1:                         blockChunkHolder.getBitSetGroup(), i);
1:               } else {
1:                 bitSet = ((ExcludeFilterExecuterImpl) filterExecuter)
1:                     .getFilteredIndexes(dimensionColumnPage,
1:                         rawColumnChunk.getRowCount()[i], useBitsetPipeLine,
1:                         blockChunkHolder.getBitSetGroup(), i);
1:               }
1:             } else {
1:               bitSet = getFilteredIndexes(dimensionColumnPage,
1:                   rawColumnChunk.getRowCount()[i]);
1:             }
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1:     if (!this.isDimensionPresentInCurrentBlock && null != filterRangesValues) {
author:Jacky Li
-------------------------------------------------------------------------------
commit:daa6465
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.chunk.DimensionColumnPage;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.processor.RawBlockletColumnChunks;
/////////////////////////////////////////////////////////////////////////
1:   private int dimensionChunkIndex;
1:   private boolean isDimensionPresentInCurrentBlock;
1:   private boolean lessThanExp;
1:   private boolean lessThanEqualExp;
1:   private boolean greaterThanExp;
1:   private boolean greaterThanEqualExp;
1:   private boolean startBlockMinIsDefaultStart;
1:   private boolean endBlockMaxisDefaultEnd;
1:   private boolean isRangeFullyCoverBlock;
1:       Expression exp, byte[][] filterRangeValues, SegmentProperties segmentProperties) {
/////////////////////////////////////////////////////////////////////////
1:     initDimensionChunkIndexes();
/////////////////////////////////////////////////////////////////////////
1:   private void initDimensionChunkIndexes() {
1:       this.dimensionChunkIndex = segmentProperties.getDimensionOrdinalToChunkMapping()
/////////////////////////////////////////////////////////////////////////
1:    * @param rawBlockletColumnChunks
1:   public BitSetGroup applyFilter(RawBlockletColumnChunks rawBlockletColumnChunks,
1:       boolean useBitsetPipeLine) throws FilterUnsupportedException, IOException {
0:     return applyNoAndDirectFilter(rawBlockletColumnChunks);
/////////////////////////////////////////////////////////////////////////
1:       if (((lessThanExp) && (
1:           (lessThanEqualExp) && (
1:           (greaterThanExp) && (
1:           (greaterThanEqualExp) && (
1:         if (((greaterThanExp) && (
1:             (greaterThanEqualExp) && (
1:         if (((lessThanExp) && (
1:             (lessThanEqualExp) && (
1:         if (startBlockMinIsDefaultStart && endBlockMaxisDefaultEnd) {
/////////////////////////////////////////////////////////////////////////
1:   @Override
1:   public BitSet isScanRequired(byte[][] blockMaxValue, byte[][] blockMinValue) {
/////////////////////////////////////////////////////////////////////////
0:   private BitSetGroup applyNoAndDirectFilter(RawBlockletColumnChunks blockChunkHolder)
0:       throws IOException {
1:       int numberOfRows = blockChunkHolder.getDataBlock().numRows();
1:       return FilterUtil.createBitSetGroupWithDefaultValue(
1:           blockChunkHolder.getDataBlock().numberOfPages(), numberOfRows, true);
1:     int chunkIndex = segmentProperties.getDimensionOrdinalToChunkMapping()
1:     if (null == blockChunkHolder.getDimensionRawColumnChunks()[chunkIndex]) {
1:       blockChunkHolder.getDimensionRawColumnChunks()[chunkIndex] =
1:           blockChunkHolder.getDataBlock().readDimensionChunk(
1:               blockChunkHolder.getFileReader(), chunkIndex);
1:         blockChunkHolder.getDimensionRawColumnChunks()[chunkIndex];
1:           if (isRangeFullyCoverBlock) {
1:             BitSet bitSet = getFilteredIndexes(rawColumnChunk.decodeColumnPage(i),
1:         BitSet bitSet = getFilteredIndexes(rawColumnChunk.decodeColumnPage(i),
/////////////////////////////////////////////////////////////////////////
1:   private BitSet getFilteredIndexes(DimensionColumnPage dimensionColumnPage,
1:     if (dimensionColumnPage.isExplicitSorted()) {
1:       return setFilterdIndexToBitSetWithColumnIndex(dimensionColumnPage, numerOfRows);
1:     return setFilterdIndexToBitSet(dimensionColumnPage, numerOfRows);
/////////////////////////////////////////////////////////////////////////
1:    * @param dimensionColumnPage
1:       DimensionColumnPage dimensionColumnPage, int numerOfRows) {
/////////////////////////////////////////////////////////////////////////
1:     if (!startBlockMinIsDefaultStart) {
1:           .getFirstIndexUsingBinarySearch(dimensionColumnPage, startIndex, numerOfRows - 1,
1:       if (greaterThanExp && start >= 0) {
1:             .nextGreaterValueToTarget(start, dimensionColumnPage, filterValues[0],
/////////////////////////////////////////////////////////////////////////
1:         if ((ByteUtil.compare(filterValues[0], dimensionColumnPage
1:             .getChunkData(dimensionColumnPage.getInvertedIndex(start)))) > 0) {
/////////////////////////////////////////////////////////////////////////
1:     if (!endBlockMaxisDefaultEnd) {
1:           .getFirstIndexUsingBinarySearch(dimensionColumnPage, startIndex, numerOfRows - 1,
1:       if (lessThanExp && start >= 0) {
1:             CarbonUtil.nextLesserValueToTarget(start, dimensionColumnPage, filterValues[1]);
/////////////////////////////////////////////////////////////////////////
1:             dimensionColumnPage.getChunkData(dimensionColumnPage.getInvertedIndex(start)))
/////////////////////////////////////////////////////////////////////////
1:       bitSet.set(dimensionColumnPage.getInvertedIndex(j));
1:     if (dimensionColumnPage.isNoDicitionaryColumn()) {
1:       updateForNoDictionaryColumn(startMin, endMax, dimensionColumnPage, bitSet);
1:   private void updateForNoDictionaryColumn(int start, int end, DimensionColumnPage dataChunk,
/////////////////////////////////////////////////////////////////////////
1:    * @param dimensionColumnPage
1:   private BitSet setFilterdIndexToBitSet(DimensionColumnPage dimensionColumnPage,
1:     // if (dimensionColumnPage instanceof FixedLengthDimensionColumnPage) {
1:     if (dimensionColumnPage.isExplicitSorted()) {
1:       if (!startBlockMinIsDefaultStart) {
1:             .getFirstIndexUsingBinarySearch(dimensionColumnPage, startIndex, numerOfRows - 1,
1:         if (greaterThanExp && start >= 0) {
1:               .nextGreaterValueToTarget(start, dimensionColumnPage, filterValues[0],
/////////////////////////////////////////////////////////////////////////
1:           if ((ByteUtil.compare(filterValues[0], dimensionColumnPage.getChunkData(start)))
/////////////////////////////////////////////////////////////////////////
1:       if (!endBlockMaxisDefaultEnd) {
1:             .getFirstIndexUsingBinarySearch(dimensionColumnPage, startIndex, numerOfRows - 1,
1:         if (lessThanExp && start >= 0) {
1:               CarbonUtil.nextLesserValueToTarget(start, dimensionColumnPage, filterValues[1]);
/////////////////////////////////////////////////////////////////////////
1:           if ((ByteUtil.compare(filterValues[1], dimensionColumnPage.getChunkData(start))
/////////////////////////////////////////////////////////////////////////
1:       if (dimensionColumnPage.isNoDicitionaryColumn()) {
1:         updateForNoDictionaryColumn(startMin, endMax, dimensionColumnPage, bitSet);
/////////////////////////////////////////////////////////////////////////
1:             segmentProperties.getDimensions().get(dimensionChunkIndex);
/////////////////////////////////////////////////////////////////////////
1:       bitSet = evaluateGreaterThanFilterForUnsortedColumn(dimensionColumnPage, filterValues[0],
1:           evaluateLessThanFilterForUnsortedColumn(dimensionColumnPage, filterValues[1],
1:       FilterUtil.removeNullValues(dimensionColumnPage, bitSet, defaultValue);
1:    * @param dimensionColumnPage
1:       DimensionColumnPage dimensionColumnPage, byte[] filterValue, int numberOfRows) {
1:         if ((ByteUtil.compare(dimensionColumnPage.getChunkData(i), filterValue) > 0)) {
1:         if ((ByteUtil.compare(dimensionColumnPage.getChunkData(i), filterValue) >= 0)) {
/////////////////////////////////////////////////////////////////////////
1:    * @param dimensionColumnPage
1:       DimensionColumnPage dimensionColumnPage, byte[] filterValue, int numberOfRows) {
1:         if ((ByteUtil.compare(dimensionColumnPage.getChunkData(i), filterValue) < 0)) {
1:         if ((ByteUtil.compare(dimensionColumnPage.getChunkData(i), filterValue) <= 0)) {
/////////////////////////////////////////////////////////////////////////
1:    * @param rawBlockletColumnChunks
1:   @Override
1:   public void readColumnChunks(RawBlockletColumnChunks rawBlockletColumnChunks) throws IOException {
1:     if (isDimensionPresentInCurrentBlock) {
1:       int chunkIndex = segmentProperties.getDimensionOrdinalToChunkMapping()
1:       if (null == rawBlockletColumnChunks.getDimensionRawColumnChunks()[chunkIndex]) {
1:         rawBlockletColumnChunks.getDimensionRawColumnChunks()[chunkIndex] =
1:             rawBlockletColumnChunks.getDataBlock().readDimensionChunk(
1:                 rawBlockletColumnChunks.getFileReader(), chunkIndex);
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
1:         if (dimColEvaluatorInfo.getDimension().getDataType() == DataTypes.STRING) {
author:dhatchayani
-------------------------------------------------------------------------------
commit:17892b1
/////////////////////////////////////////////////////////////////////////
1:         int key = directDictionaryGenerator.generateDirectSurrogateKey(null);
commit:36ceb59
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.datatype.DataType;
/////////////////////////////////////////////////////////////////////////
1:       if (dataChunk.compareTo(j, CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY) == 0
1:           || dataChunk.compareTo(j, CarbonCommonConstants.EMPTY_BYTE_ARRAY) == 0) {
/////////////////////////////////////////////////////////////////////////
0:         if (dimColEvaluatorInfo.getDimension().getDataType() == DataType.STRING) {
1:           defaultValue = CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY;
1:         } else {
1:           defaultValue = CarbonCommonConstants.EMPTY_BYTE_ARRAY;
1:         }
author:kumarvishal
-------------------------------------------------------------------------------
commit:75e0bd4
/////////////////////////////////////////////////////////////////////////
0:   public BitSetGroup applyFilter(BlocksChunkHolder blockChunkHolder, boolean useBitsetPipeLine)
commit:d963a70
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryGenerator;
1: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryKeyGeneratorFactory;
1: import org.apache.carbondata.core.metadata.encoder.Encoding;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       byte[] defaultValue = null;
1:       if (dimColEvaluatorInfo.getDimension().hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:         DirectDictionaryGenerator directDictionaryGenerator = DirectDictionaryKeyGeneratorFactory
1:             .getDirectDictionaryGenerator(dimColEvaluatorInfo.getDimension().getDataType());
0:         int key = directDictionaryGenerator.generateDirectSurrogateKey(null) + 1;
1:         CarbonDimension currentBlockDimension =
0:             segmentProperties.getDimensions().get(dimensionBlocksIndex);
1:         defaultValue = FilterUtil.getMaskKey(key, currentBlockDimension,
1:             this.segmentProperties.getSortColumnsGenerator());
1:       } else {
0:         defaultValue = CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY;
1:       }
0:       FilterUtil.removeNullValues(dimensionColumnDataChunk, bitSet, defaultValue);
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:642b4bf
/////////////////////////////////////////////////////////////////////////
0:         int key = directDictionaryGenerator.generateDirectSurrogateKey(null) + 1;
commit:887310f
/////////////////////////////////////////////////////////////////////////
0:         int key = directDictionaryGenerator.generateDirectSurrogateKey(null);
1:         if (currentBlockDimension.isSortColumn()) {
0:           defaultValue = FilterUtil.getMaskKey(key, currentBlockDimension,
0:               this.segmentProperties.getSortColumnsGenerator());
1:         } else {
0:           defaultValue = ByteUtil.toBytes(key);
1:         }
author:ravipesala
-------------------------------------------------------------------------------
commit:b681244
/////////////////////////////////////////////////////////////////////////
1:     boolean isScanRequired = columnIndex >= blockMinValue.length ||
author:sounakr
-------------------------------------------------------------------------------
commit:105e3a0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     if (!this.isDimensionPresentInCurrentBlock) {
/////////////////////////////////////////////////////////////////////////
0:     if (dimensionColumnDataChunk.isExplicitSorted()) {
/////////////////////////////////////////////////////////////////////////
0:         if ((ByteUtil.compare(filterValues[0], dimensionColumnDataChunk
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         // In case the start is less than 0, then positive value of start is pointing to the next
1:         // value of the searched key. So move to the previous one.
1:         if ((ByteUtil.compare(filterValues[1],
/////////////////////////////////////////////////////////////////////////
0:         if ((ByteUtil.compare(filterValues[0], dimensionColumnDataChunk.getChunkData(start)))
/////////////////////////////////////////////////////////////////////////
0:         // In case the start is less than 0, then positive value of start is pointing to the next
0:         // value of the searched key. So move to the previous one.
0:         if ((ByteUtil.compare(filterValues[1], dimensionColumnDataChunk.getChunkData(start))
1:             < 0)) {
commit:c2e4eb2
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.core.scan.filter.executer;
1: 
1: import java.io.IOException;
1: import java.util.BitSet;
1: 
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.datastore.block.SegmentProperties;
0: import org.apache.carbondata.core.datastore.chunk.DimensionColumnDataChunk;
1: import org.apache.carbondata.core.datastore.chunk.impl.DimensionRawColumnChunk;
0: import org.apache.carbondata.core.datastore.chunk.impl.FixedLengthDimensionDataChunk;
0: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.core.scan.expression.Expression;
1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanEqualToExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.LessThanEqualToExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.LessThanExpression;
1: import org.apache.carbondata.core.scan.expression.exception.FilterUnsupportedException;
1: import org.apache.carbondata.core.scan.filter.FilterUtil;
1: import org.apache.carbondata.core.scan.filter.resolver.resolverinfo.DimColumnResolvedFilterInfo;
0: import org.apache.carbondata.core.scan.filter.resolver.resolverinfo.MeasureColumnResolvedFilterInfo;
0: import org.apache.carbondata.core.scan.processor.BlocksChunkHolder;
1: import org.apache.carbondata.core.util.BitSetGroup;
1: import org.apache.carbondata.core.util.ByteUtil;
1: import org.apache.carbondata.core.util.CarbonUtil;
1: 
1: /**
1:  * This Class get a Min And Max value of a RANGE expression. Finds out if scan is required
1:  * for this Range. Also search the data block and set the required bitsets which falls within
1:  * the Range of the RANGE Expression.
1:  */
0: public class RangeValueFilterExecuterImpl extends ValueBasedFilterExecuterImpl {
1: 
1:   private DimColumnResolvedFilterInfo dimColEvaluatorInfo;
0:   private MeasureColumnResolvedFilterInfo msrColEvalutorInfo;
0:   private AbsoluteTableIdentifier tableIdentifier;
1:   private Expression exp;
1:   private byte[][] filterRangesValues;
1:   private SegmentProperties segmentProperties;
1:   private boolean isDefaultValuePresentInFilter;
1:   /**
1:    * it has index at which given dimension is stored in file
1:    */
0:   protected int dimensionBlocksIndex;
1: 
1:   /**
1:    * flag to check whether the filter dimension is present in current block list of dimensions.
1:    * Applicable for restructure scenarios
1:    */
0:   protected boolean isDimensionPresentInCurrentBlock;
0:   boolean lessThanExp;
0:   boolean lessThanEqualExp;
0:   boolean greaterThanExp;
0:   boolean greaterThanEqualExp;
0:   boolean startBlockMinIsDefaultStart;
0:   boolean endBlockMaxisDefaultEnd;
0:   boolean isRangeFullyCoverBlock;
1: 
1:   public RangeValueFilterExecuterImpl(DimColumnResolvedFilterInfo dimColEvaluatorInfo,
0:       MeasureColumnResolvedFilterInfo msrColEvaluatorInfo, Expression exp,
0:       AbsoluteTableIdentifier tableIdentifier, byte[][] filterRangeValues,
0:       SegmentProperties segmentProperties) {
1: 
1:     this.dimColEvaluatorInfo = dimColEvaluatorInfo;
0:     this.msrColEvalutorInfo = msrColEvaluatorInfo;
1:     this.exp = exp;
1:     this.segmentProperties = segmentProperties;
0:     this.tableIdentifier = tableIdentifier;
1:     this.filterRangesValues = filterRangeValues;
1:     this.lessThanExp = isLessThan();
1:     this.lessThanEqualExp = isLessThanEqualTo();
1:     this.greaterThanExp = isGreaterThan();
1:     this.greaterThanEqualExp = isGreaterThanEqualTo();
1:     startBlockMinIsDefaultStart = false;
1:     endBlockMaxisDefaultEnd = false;
1:     isRangeFullyCoverBlock = false;
0:     initDimensionBlockIndexes();
1:     ifDefaultValueMatchesFilter();
1: 
1:   }
1: 
1:   /**
1:    * This method will initialize the dimension info for the current block to be
1:    * used for filtering the data
1:    */
0:   private void initDimensionBlockIndexes() {
1:     // find the dimension in the current block dimensions list
1:     CarbonDimension dimensionFromCurrentBlock =
1:         segmentProperties.getDimensionFromCurrentBlock(dimColEvaluatorInfo.getDimension());
1:     if (null != dimensionFromCurrentBlock) {
1:       dimColEvaluatorInfo.setColumnIndex(dimensionFromCurrentBlock.getOrdinal());
0:       this.dimensionBlocksIndex = segmentProperties.getDimensionOrdinalToBlockMapping()
1:           .get(dimensionFromCurrentBlock.getOrdinal());
1:       isDimensionPresentInCurrentBlock = true;
1:     }
1:   }
1: 
1:   /**
1:    * This method will check whether default value is present in the given filter values
1:    */
1:   private void ifDefaultValueMatchesFilter() {
1:     isDefaultValuePresentInFilter = false;
0:     if (this.isDimensionPresentInCurrentBlock) {
1:       CarbonDimension dimension = this.dimColEvaluatorInfo.getDimension();
1:       byte[] defaultValue = dimension.getDefaultValue();
1:       if (null != defaultValue) {
1:         int maxCompare =
1:             ByteUtil.UnsafeComparer.INSTANCE.compareTo(defaultValue, filterRangesValues[0]);
1:         int minCompare =
1:             ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterRangesValues[1], defaultValue);
1: 
1:         if (((greaterThanExp && maxCompare > 0) || (greaterThanEqualExp && maxCompare >= 0))
1:             && ((lessThanExp && minCompare > 0) || (lessThanEqualExp && minCompare >= 0))) {
1:           isDefaultValuePresentInFilter = true;
1:         }
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Method to apply the filter.
1:    * @param blockChunkHolder
1:    * @return
1:    * @throws FilterUnsupportedException
1:    * @throws IOException
1:    */
0:   public BitSetGroup applyFilter(BlocksChunkHolder blockChunkHolder)
0:       throws FilterUnsupportedException, IOException {
0:     return applyNoAndDirectFilter(blockChunkHolder);
1:   }
1: 
1:   /**
1:    * Method to find presence of LessThan Expression.
1:    * @return
1:    */
1:   private boolean isLessThan() {
1:     for (Expression result : this.exp.getChildren()) {
1:       if (result instanceof LessThanExpression) {
1:         return true;
1:       }
1:     }
1:     return false;
1:   }
1: 
1:   /**
1:    * Method to find presence of LessThanEqualTo Expression.
1:    * @return
1:    */
1:   private boolean isLessThanEqualTo() {
1:     for (Expression result : this.exp.getChildren()) {
1:       if (result instanceof LessThanEqualToExpression) {
1:         return true;
1:       }
1:     }
1:     return false;
1:   }
1: 
1:   /**
1:    * Method to find presence of GreaterThan Expression.
1:    * @return
1:    */
1:   private boolean isGreaterThan() {
1:     for (Expression result : this.exp.getChildren()) {
1:       if (result instanceof GreaterThanExpression) {
1:         return true;
1:       }
1:     }
1:     return false;
1:   }
1: 
1:   /**
1:    * Method to find presence of GreaterThanEqual Expression.
1:    * @return
1:    */
1:   private boolean isGreaterThanEqualTo() {
1:     for (Expression result : this.exp.getChildren()) {
1:       if (result instanceof GreaterThanEqualToExpression) {
1:         return true;
1:       }
1:     }
1:     return false;
1:   }
1: 
1: 
1: 
1:   /**
1:    * Method to identify if scanning of Data Block required or not by comparing the Block Min and Max
1:    * values and comparing them with filter min and max value.
1:    * @param blockMinValue
1:    * @param blockMaxValue
1:    * @param filterValues
1:    * @return
1:    */
1:   public boolean isScanRequired(byte[] blockMinValue, byte[] blockMaxValue, byte[][] filterValues) {
1:     boolean isScanRequired = true;
1:     isRangeFullyCoverBlock = false;
1:     startBlockMinIsDefaultStart = false;
1:     endBlockMaxisDefaultEnd = false;
1: 
1:     /*
1:     For Undertsanding the below logic kept the value evaluation code intact.
1:     int filterMinlessThanBlockMin =
1:         ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[0]);
1:     int filterMaxLessThanBlockMin =
1:         ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[1]);
1: 
1:     int filterMinGreaterThanBlockMax =
1:         ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[0], blockMaxValue);
1:     int filterMaxGreaterThanBlockMax =
1:         ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[1], blockMaxValue);
1:      */
1: 
1:     // if any filter value is in range than this block needs to be
1:     // scanned less than equal to max range.
1:     // There are 4 cases which has been explicitly handled.
1:     // case A: Outside Boundary > No Scan required
1:     //                                                Block Min <---------->  Block Max
1:     //        Filter Min <----------> Filter Max
1:     // case B: Filter Overlaps Upper Part Block then Block Start Scan Becomes StartIndex of Block.
1:     //                         Block Min <-----------------> Block Max
1:     //   Filter Min <-------------------------> Filter Min
1:     // Case C: Filter Overlaps Lower Part of Block then Block End Scan becomes Number Of Rows - 1
1:     //         Block Min <-------------------------> Block Max
1:     //                          Filter Min <--------------------------> Filter Max
1:     // Case D: Filter Values Completely overlaps Block Min and Max then all bits are set.
1:     //                       Block Min <-----------------------> Block Max
1:     //         Filter Min <-----------------------------------------------> Filter Max
1: 
0:     if (isDimensionPresentInCurrentBlock == true) {
0:       if (((lessThanExp == true) && (
1:           ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[1]) >= 0)) || (
0:           (lessThanEqualExp == true) && (
1:               ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[1]) > 0)) || (
0:           (greaterThanExp == true) && (
1:               ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[0], blockMaxValue) >= 0)) || (
0:           (greaterThanEqualExp == true) && (
1:               ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[0], blockMaxValue) > 0))) {
1:         // completely out of block boundary
1:         isScanRequired = false;
1:       } else {
0:         if (((greaterThanExp == true) && (
1:             ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[0]) > 0)) || (
0:             (greaterThanEqualExp == true) && (
1:                 ByteUtil.UnsafeComparer.INSTANCE.compareTo(blockMinValue, filterValues[0]) >= 0))) {
1:           startBlockMinIsDefaultStart = true;
1:         }
1: 
0:         if (((lessThanExp == true) && (
1:             ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[1], blockMaxValue) > 0)) || (
0:             (lessThanEqualExp == true) && (
1:                 ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[1], blockMaxValue) >= 0))) {
1:           endBlockMaxisDefaultEnd = true;
1:         }
1: 
0:         if (startBlockMinIsDefaultStart == true && endBlockMaxisDefaultEnd == true) {
1:           isRangeFullyCoverBlock = true;
1:         }
1:       }
1:       return isScanRequired;
1:     } else {
1:       return isDefaultValuePresentInFilter;
1:     }
1:   }
1: 
1:   /**
1:    * Method checks is the scan lies within the range values or not.
1:    * @param blockMaxValue
1:    * @param blockMinValue
1:    * @return
1:    */
0:   @Override public BitSet isScanRequired(byte[][] blockMaxValue, byte[][] blockMinValue) {
1:     BitSet bitSet = new BitSet(1);
1:     byte[][] filterValues = this.filterRangesValues;
0:     int columnIndex = this.dimColEvaluatorInfo.getColumnIndex();
0:     boolean isScanRequired =
1:         isScanRequired(blockMinValue[columnIndex], blockMaxValue[columnIndex], filterValues);
1:     if (isScanRequired) {
1:       bitSet.set(0);
1:     }
1:     return bitSet;
1:   }
1: 
1:   /**
1:    * Method to apply the Range Filter.
1:    * @param blockChunkHolder
1:    * @return
1:    * @throws FilterUnsupportedException
1:    * @throws IOException
1:    */
0:   public BitSetGroup applyNoAndDirectFilter(BlocksChunkHolder blockChunkHolder)
0:       throws FilterUnsupportedException, IOException {
1: 
1:     // In case of Alter Table Add and Delete Columns the isDimensionPresentInCurrentBlock can be
1:     // false, in that scenario the default values of the column should be shown.
1:     // select all rows if dimension does not exists in the current block
1:     if (!isDimensionPresentInCurrentBlock) {
0:       int numberOfRows = blockChunkHolder.getDataBlock().nodeSize();
0:       return FilterUtil
0:           .createBitSetGroupWithDefaultValue(blockChunkHolder.getDataBlock().numberOfPages(),
0:               numberOfRows, true);
1:     }
1: 
0:     int blockIndex = segmentProperties.getDimensionOrdinalToBlockMapping()
1:         .get(dimColEvaluatorInfo.getColumnIndex());
1: 
0:     if (null == blockChunkHolder.getDimensionRawDataChunk()[blockIndex]) {
0:       blockChunkHolder.getDimensionRawDataChunk()[blockIndex] = blockChunkHolder.getDataBlock()
0:           .getDimensionChunk(blockChunkHolder.getFileReader(), blockIndex);
1:     }
1: 
1:     DimensionRawColumnChunk rawColumnChunk =
0:         blockChunkHolder.getDimensionRawDataChunk()[blockIndex];
1:     BitSetGroup bitSetGroup = new BitSetGroup(rawColumnChunk.getPagesCount());
1:     for (int i = 0; i < rawColumnChunk.getPagesCount(); i++) {
1:       if (rawColumnChunk.getMaxValues() != null) {
1:         if (isScanRequired(rawColumnChunk.getMinValues()[i], rawColumnChunk.getMaxValues()[i],
1:             this.filterRangesValues)) {
0:           if (isRangeFullyCoverBlock == true) {
1:             // Set all the bits in this case as filter Min Max values cover the whole block.
1:             BitSet bitSet = new BitSet(rawColumnChunk.getRowCount()[i]);
1:             bitSet.flip(0, rawColumnChunk.getRowCount()[i]);
1:             bitSetGroup.setBitSet(bitSet, i);
1:           } else {
0:             BitSet bitSet = getFilteredIndexes(rawColumnChunk.convertToDimColDataChunk(i),
1:                 rawColumnChunk.getRowCount()[i]);
1:             bitSetGroup.setBitSet(bitSet, i);
1:           }
1:         }
1:       } else {
0:         BitSet bitSet = getFilteredIndexes(rawColumnChunk.convertToDimColDataChunk(i),
1:             rawColumnChunk.getRowCount()[i]);
1:         bitSetGroup.setBitSet(bitSet, i);
1:       }
1:     }
1:     return bitSetGroup;
1:   }
1: 
0:   private BitSet getFilteredIndexes(DimensionColumnDataChunk dimensionColumnDataChunk,
1:       int numerOfRows) {
0:     if (dimensionColumnDataChunk.isExplicitSorted()
0:         && dimensionColumnDataChunk instanceof FixedLengthDimensionDataChunk) {
0:       return setFilterdIndexToBitSetWithColumnIndex(dimensionColumnDataChunk, numerOfRows);
1:     }
0:     return setFilterdIndexToBitSet(dimensionColumnDataChunk, numerOfRows);
1:   }
1: 
1:   /**
1:    * Method will scan the block and finds the range start index from which all members
1:    * will be considered for applying range filters. this method will be called if the
1:    * column is not supported by default so column index mapping  will be present for
1:    * accesing the members from the block.
1:    *
0:    * @param dimensionColumnDataChunk
1:    * @param numerOfRows
1:    * @return BitSet.
1:    */
1:   private BitSet setFilterdIndexToBitSetWithColumnIndex(
0:       DimensionColumnDataChunk dimensionColumnDataChunk, int numerOfRows) {
1:     BitSet bitSet = new BitSet(numerOfRows);
1:     int start = 0;
1:     int startIndex = 0;
1:     int startMin = 0;
1:     int endMax = 0;
1:     byte[][] filterValues = this.filterRangesValues;
1: 
1:     // For Range expression we expect two values. The First is the Min Value and Second is the
1:     // Max value.
1:     // Get the Min Value
0:     if (startBlockMinIsDefaultStart == false) {
1:       start = CarbonUtil
0:           .getFirstIndexUsingBinarySearch(dimensionColumnDataChunk, startIndex, numerOfRows - 1,
1:               filterValues[0], greaterThanExp);
0:       if (greaterThanExp == true && start >= 0) {
1:         start = CarbonUtil
0:             .nextGreaterValueToTarget(start, dimensionColumnDataChunk, filterValues[0],
1:                 numerOfRows);
1:       }
1: 
1:       if (start < 0) {
1:         start = -(start + 1);
1:         if (start == numerOfRows) {
1:           start = start - 1;
1:         }
1:         // Method will compare the tentative index value after binary search, this tentative
1:         // index needs to be compared by the filter member if its >= filter then from that
1:         // index the bitset will be considered for filtering process.
0:         if ((greaterThanExp == true) && (ByteUtil.compare(filterValues[0], dimensionColumnDataChunk
0:             .getChunkData(dimensionColumnDataChunk.getInvertedIndex(start)))) > 0) {
1:           start = start + 1;
0:         } else if ((greaterThanEqualExp == true) && (ByteUtil.compare(filterValues[0],
0:             dimensionColumnDataChunk
0:                 .getChunkData(dimensionColumnDataChunk.getInvertedIndex(start)))) >= 0) {
1:           start = start + 1;
1:         }
1:       }
1: 
1:       startMin = start;
1:     } else {
1:       startMin = startIndex;
1:     }
1: 
1:     // Get the Max value
0:     if (endBlockMaxisDefaultEnd == false) {
1:       start = CarbonUtil
0:           .getFirstIndexUsingBinarySearch(dimensionColumnDataChunk, startIndex, numerOfRows - 1,
1:               filterValues[1], lessThanEqualExp);
0:       if (lessThanExp == true && start >= 0) {
1:         start =
0:             CarbonUtil.nextLesserValueToTarget(start, dimensionColumnDataChunk, filterValues[1]);
1:       }
1: 
1:       if (start < 0) {
1:         start = -(start + 1);
1:         if (start == numerOfRows) {
1:           start = start - 1;
1:         }
1:         // Method will compare the tentative index value after binary search, this tentative
1:         // index needs to be compared by the filter member if its >= filter then from that
1:         // index the bitset will be considered for filtering process.
0:         if ((lessThanExp == true) && (ByteUtil.compare(filterValues[1],
0:             dimensionColumnDataChunk.getChunkData(dimensionColumnDataChunk.getInvertedIndex(start)))
0:             < 0)) {
1:           start = start - 1;
0:         } else if ((lessThanEqualExp == true) && (ByteUtil.compare(filterValues[1],
0:             dimensionColumnDataChunk.getChunkData(dimensionColumnDataChunk.getInvertedIndex(start)))
0:             <= 0)) {
1:           start = start - 1;
1:         }
1:       }
1:       endMax = start;
1:     } else {
1:       endMax = numerOfRows - 1;
1:     }
1: 
1:     for (int j = startMin; j <= endMax; j++) {
0:       bitSet.set(dimensionColumnDataChunk.getInvertedIndex(j));
1:     }
1: 
1:     // Binary Search cannot be done on '@NU#LL$!", so need to check and compare for null on
1:     // matching row.
0:     if (dimensionColumnDataChunk.isNoDicitionaryColumn()) {
0:       updateForNoDictionaryColumn(startMin, endMax, dimensionColumnDataChunk, bitSet);
1:     }
1:     return bitSet;
1:   }
1: 
0:   private void updateForNoDictionaryColumn(int start, int end, DimensionColumnDataChunk dataChunk,
1:       BitSet bitset) {
1:     for (int j = start; j <= end; j++) {
0:       if (dataChunk.compareTo(j, CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY) == 0) {
1:         bitset.flip(j);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Method will scan the block and finds the range start index from which all
1:    * members will be considered for applying range filters. this method will
1:    * be called if the column is sorted default so column index
1:    * mapping will be present for accesaing the members from the block.
1:    *
0:    * @param dimensionColumnDataChunk
1:    * @param numerOfRows
1:    * @return BitSet.
1:    */
0:   private BitSet setFilterdIndexToBitSet(DimensionColumnDataChunk dimensionColumnDataChunk,
1:       int numerOfRows) {
1:     BitSet bitSet = new BitSet(numerOfRows);
0:     // if (dimensionColumnDataChunk instanceof FixedLengthDimensionDataChunk) {
1:     int start = 0;
1:     int startMin = 0;
1:     int endMax = 0;
1:     int startIndex = 0;
1:     byte[][] filterValues = this.filterRangesValues;
1:     // For Range expression we expect two values. The First is the Min Value and Second is the
1:     // Max value.
0:     if (startBlockMinIsDefaultStart == false) {
1: 
1:       start = CarbonUtil
0:           .getFirstIndexUsingBinarySearch(dimensionColumnDataChunk,
0:               startIndex, numerOfRows - 1, filterValues[0], greaterThanExp);
1: 
0:       if (greaterThanExp == true && start >= 0) {
1:         start = CarbonUtil
0:             .nextGreaterValueToTarget(start, dimensionColumnDataChunk, filterValues[0],
1:                 numerOfRows);
1:       }
1: 
1:       if (start < 0) {
1:         start = -(start + 1);
1:         if (start == numerOfRows) {
1:           start = start - 1;
1:         }
1:         // Method will compare the tentative index value after binary search, this tentative
1:         // index needs to be compared by the filter member if its >= filter then from that
1:         // index the bitset will be considered for filtering process.
0:         if ((greaterThanExp == true)
0:             && (ByteUtil.compare(filterValues[0], dimensionColumnDataChunk.getChunkData(start)))
0:             > 0) {
1:           start = start + 1;
0:         } else if ((greaterThanEqualExp == true)
0:             && (ByteUtil.compare(filterValues[0], dimensionColumnDataChunk.getChunkData(start)))
0:             >= 0) {
1:           start = start + 1;
1:         }
1:       }
1:       startMin = start;
1:     } else {
1:       startMin = startIndex;
1:     }
1: 
0:     if (endBlockMaxisDefaultEnd == false) {
1:       start = CarbonUtil
0:           .getFirstIndexUsingBinarySearch(dimensionColumnDataChunk, startIndex, numerOfRows - 1,
1:               filterValues[1], lessThanEqualExp);
1: 
0:       if (lessThanExp == true && start >= 0) {
1:         start =
0:             CarbonUtil.nextLesserValueToTarget(start, dimensionColumnDataChunk, filterValues[1]);
1:       }
1: 
1:       if (start < 0) {
1:         start = -(start + 1);
1:         if (start == numerOfRows) {
1:           start = start - 1;
1:         }
1:         // Method will compare the tentative index value after binary search, this tentative
1:         // index needs to be compared by the filter member if its >= filter then from that
1:         // index the bitset will be considered for filtering process.
0:         if ((lessThanExp == true) && (
0:             ByteUtil.compare(filterValues[1], dimensionColumnDataChunk.getChunkData(start)) < 0)) {
1:           start = start - 1;
0:         } else if ((lessThanEqualExp == true) && (
0:             ByteUtil.compare(filterValues[1], dimensionColumnDataChunk.getChunkData(start)) <= 0)) {
1:           start = start - 1;
1:         }
1:       }
1:       endMax = start;
1:     } else {
1:       endMax = numerOfRows - 1;
1:     }
1: 
1:     for (int j = startMin; j <= endMax; j++) {
0:       bitSet.set(j);
1:     }
1: 
1:     // Binary Search cannot be done on '@NU#LL$!", so need to check and compare for null on
1:     // matching row.
0:     if (dimensionColumnDataChunk.isNoDicitionaryColumn()) {
0:       updateForNoDictionaryColumn(startMin, endMax, dimensionColumnDataChunk, bitSet);
1:     }
1: 
1:     return bitSet;
1:   }
1: 
1:   /**
1:    * Method to read the blocks.
1:    * @param blockChunkHolder
1:    * @throws IOException
1:    */
0:   @Override public void readBlocks(BlocksChunkHolder blockChunkHolder) throws IOException {
0:     if (isDimensionPresentInCurrentBlock == true) {
0:       int blockIndex = segmentProperties.getDimensionOrdinalToBlockMapping()
1:           .get(dimColEvaluatorInfo.getColumnIndex());
0:       if (null == blockChunkHolder.getDimensionRawDataChunk()[blockIndex]) {
0:         blockChunkHolder.getDimensionRawDataChunk()[blockIndex] = blockChunkHolder.getDataBlock()
0:             .getDimensionChunk(blockChunkHolder.getFileReader(), blockIndex);
1:       }
1:     }
1:   }
1: }
============================================================================