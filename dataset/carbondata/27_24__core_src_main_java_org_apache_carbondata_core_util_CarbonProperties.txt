1:cd6a4ff: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
1:cd6a4ff:  *
1:cd6a4ff:  *    http://www.apache.org/licenses/LICENSE-2.0
1:cd6a4ff:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
1:cd6a4ff:  */
1:cd6a4ff: 
1:cd6a4ff: package org.apache.carbondata.core.util;
1:cd6a4ff: 
1:cd6a4ff: import java.io.File;
1:cd6a4ff: import java.io.FileInputStream;
1:cd6a4ff: import java.io.FileNotFoundException;
1:cd6a4ff: import java.io.IOException;
1:39644b5: import java.lang.reflect.Field;
1:bcf3ca3: import java.text.SimpleDateFormat;
1:39644b5: import java.util.HashSet;
1:1462495: import java.util.Map;
1:cd6a4ff: import java.util.Properties;
1:39644b5: import java.util.Set;
1:2a9604c: import java.util.concurrent.ConcurrentHashMap;
1:cd6a4ff: 
1:002279e: import org.apache.carbondata.common.logging.LogService;
1:002279e: import org.apache.carbondata.common.logging.LogServiceFactory;
1:002279e: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:39644b5: import org.apache.carbondata.core.constants.CarbonLoadOptionConstants;
1:2cf1104: import org.apache.carbondata.core.constants.CarbonV3DataFormatConstants;
1:bea277f: import org.apache.carbondata.core.datastore.impl.FileFactory;
1:ce09aaa: import org.apache.carbondata.core.metadata.ColumnarFormatVersion;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.BLOCKLET_SIZE;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_CUSTOM_BLOCK_DISTRIBUTION;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_DATA_FILE_VERSION;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_DATE_FORMAT;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MAX;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MIN;
1:2f85381: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SEARCH_MODE_SCAN_THREAD;
1:2f85381: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_WORKLOAD_LIMIT;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SORT_FILE_WRITE_BUFFER_SIZE;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_BLOCK;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_BLOCKLET;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_CUSTOM;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_MERGE_FILES;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CSV_READ_BUFFER_SIZE;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_AUTO_HANDOFF;
1:d8bafa3: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_OFFHEAP_SORT;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_UNSAFE_SORT;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_VECTOR_READER;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.HANDOFF_SIZE;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.LOCK_TYPE;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.SORT_INTERMEDIATE_FILES_LIMIT;
1:473bd31: import static org.apache.carbondata.core.constants.CarbonCommonConstants.SORT_SIZE;
1:8cb37dd: import static org.apache.carbondata.core.constants.CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE;
1:bcf3ca3: import static org.apache.carbondata.core.constants.CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB;
1:bcf3ca3: import static org.apache.carbondata.core.constants.CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO;
1:002279e: 
1:1a35cfb: import org.apache.hadoop.conf.Configuration;
1:1a35cfb: 
1:cd6a4ff: public final class CarbonProperties {
1:cd6a4ff:   /**
1:cd6a4ff:    * Attribute for Carbon LOGGER.
1:28e2e17:    */
1:cd6a4ff:   private static final LogService LOGGER =
1:cd6a4ff:       LogServiceFactory.getLogService(CarbonProperties.class.getName());
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * class instance.
1:cd6a4ff:    */
1:cd6a4ff:   private static final CarbonProperties CARBONPROPERTIESINSTANCE = new CarbonProperties();
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * porpeties .
1:cd6a4ff:    */
1:cd6a4ff:   private Properties carbonProperties;
1:28e2e17: 
1:39644b5:   private Set<String> propertySet = new HashSet<String>();
1:cd6a4ff: 
1:28e2e17:   /**
1:1462495:    * It is purely for testing
1:1462495:    */
1:2a9604c:   private Map<String, String> addedProperty = new ConcurrentHashMap<>();
1:1462495: 
1:1462495:   /**
1:cd6a4ff:    * Private constructor this will call load properties method to load all the
1:cd6a4ff:    * carbon properties in memory.
1:cd6a4ff:    */
1:cd6a4ff:   private CarbonProperties() {
1:cd6a4ff:     carbonProperties = new Properties();
1:cd6a4ff:     loadProperties();
1:cd6a4ff:     validateAndLoadDefaultProperties();
1:cd6a4ff:   }
1:cd6a4ff: 
1:0609fc5:   /**
1:cd6a4ff:    * This method will be responsible for get this class instance
1:cd6a4ff:    *
1:cd6a4ff:    * @return carbon properties instance
1:0be69cd:    */
1:cd6a4ff:   public static CarbonProperties getInstance() {
1:cd6a4ff:     return CARBONPROPERTIESINSTANCE;
1:cd6a4ff:   }
1:cd6a4ff: 
1:d0858b7:   /**
1:bcf3ca3:    * This method is to validate only a specific key added to carbonProperties using addProperty
1:bcf3ca3:    *
1:bcf3ca3:    * @param key
1:bcf3ca3:    */
1:bcf3ca3:   private void validateAndLoadDefaultProperties(String key) {
1:bcf3ca3:     switch (key) {
1:bcf3ca3:       case BLOCKLET_SIZE:
1:bcf3ca3:         validateBlockletSize();
1:bcf3ca3:         break;
1:bcf3ca3:       case SORT_SIZE:
1:bcf3ca3:         validateSortSize();
1:bcf3ca3:         break;
1:bcf3ca3:       case CARBON_DATA_FILE_VERSION:
1:bcf3ca3:         validateCarbonDataFileVersion();
1:bcf3ca3:         break;
1:473bd31:       case CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT:
1:473bd31:         validateDynamicSchedulerTimeOut();
1:bcf3ca3:         break;
1:bcf3ca3:       case CARBON_PREFETCH_BUFFERSIZE:
1:bcf3ca3:         validatePrefetchBufferSize();
1:bcf3ca3:         break;
1:bcf3ca3:       case BLOCKLET_SIZE_IN_MB:
1:bcf3ca3:         validateBlockletGroupSizeInMB();
1:bcf3ca3:         break;
1:bcf3ca3:       case NUMBER_OF_COLUMN_TO_READ_IN_IO:
1:bcf3ca3:         validateNumberOfColumnPerIORead();
1:bcf3ca3:         break;
1:bcf3ca3:       case ENABLE_UNSAFE_SORT:
1:bcf3ca3:         validateEnableUnsafeSort();
1:bcf3ca3:         break;
1:d8bafa3:       case ENABLE_OFFHEAP_SORT:
1:d8bafa3:         validateEnableOffHeapSort();
1:bcf3ca3:         break;
1:bcf3ca3:       case CARBON_CUSTOM_BLOCK_DISTRIBUTION:
1:bcf3ca3:         validateCustomBlockDistribution();
1:bcf3ca3:         break;
1:bcf3ca3:       case ENABLE_VECTOR_READER:
1:bcf3ca3:         validateEnableVectorReader();
1:bcf3ca3:         break;
1:bcf3ca3:       case CSV_READ_BUFFER_SIZE:
1:bcf3ca3:         validateCarbonCSVReadBufferSizeByte();
1:bcf3ca3:         break;
1:bcf3ca3:       case HANDOFF_SIZE:
1:bcf3ca3:         validateHandoffSize();
1:bcf3ca3:         break;
1:b4dc866:       case CARBON_TASK_DISTRIBUTION:
1:b4dc866:         validateCarbonTaskDistribution();
1:bcf3ca3:         break;
1:bcf3ca3:       // The method validate the validity of configured carbon.timestamp.format value
1:bcf3ca3:       // and reset to default value if validation fail
1:bcf3ca3:       case CARBON_TIMESTAMP_FORMAT:
1:bcf3ca3:         validateTimeFormatKey(CARBON_TIMESTAMP_FORMAT,
1:bcf3ca3:             CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:bcf3ca3:         break;
1:bcf3ca3:       // The method validate the validity of configured carbon.date.format value
1:bcf3ca3:       // and reset to default value if validation fail
1:bcf3ca3:       case CARBON_DATE_FORMAT:
1:bcf3ca3:         validateTimeFormatKey(CARBON_DATE_FORMAT, CarbonCommonConstants.CARBON_DATE_DEFAULT_FORMAT);
1:bcf3ca3:         break;
1:bcf3ca3:       case CARBON_SORT_FILE_WRITE_BUFFER_SIZE:
1:bcf3ca3:         validateSortFileWriteBufferSize();
1:bcf3ca3:         break;
1:bcf3ca3:       case SORT_INTERMEDIATE_FILES_LIMIT:
1:bcf3ca3:         validateSortIntermediateFilesLimit();
1:bcf3ca3:         break;
1:bcf3ca3:       case ENABLE_AUTO_HANDOFF:
1:bcf3ca3:         validateHandoffSize();
1:bcf3ca3:         break;
1:473bd31:       case CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO:
1:473bd31:         validateSchedulerMinRegisteredRatio();
1:473bd31:         break;
1:2f85381:       case CARBON_SEARCH_MODE_SCAN_THREAD:
1:2f85381:         validatePositiveInteger(CARBON_SEARCH_MODE_SCAN_THREAD);
1:bcf3ca3:         break;
1:2f85381:       case CARBON_SEARCH_MODE_WORKER_WORKLOAD_LIMIT:
1:2f85381:         validatePositiveInteger(CARBON_SEARCH_MODE_WORKER_WORKLOAD_LIMIT);
1:500654e:         break;
1:8cb37dd:       case CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE:
1:8cb37dd:         validateSortMemorySpillPercentage();
1:8cb37dd:         break;
1:bcf3ca3:       // TODO : Validation for carbon.lock.type should be handled for addProperty flow
1:bcf3ca3:       default:
1:bcf3ca3:         // none
1:bcf3ca3:     }
1:bcf3ca3:   }
1:2f85381: 
1:bcf3ca3:   /**
1:2f85381:    * Validate the specified property is positive integer value
1:2f85381:    */
1:2f85381:   private void validatePositiveInteger(String propertyName) {
1:2f85381:     String value = getInstance().getProperty(propertyName);
1:2f85381:     try {
1:2f85381:       int intValue = Integer.parseInt(value);
1:2f85381:       if (intValue <= 0) {
1:2f85381:         getInstance().removeProperty(propertyName);
1:2f85381:         LOGGER.warn(String.format("The value \"%s\" configured for key \"%s\" " +
1:2f85381:             "is invalid. Ignoring it", value, propertyName));
1:2f85381:         throw new IllegalArgumentException();
1:1a35cfb:       }
1:2f85381:     } catch (NumberFormatException e) {
1:2f85381:       getInstance().removeProperty(propertyName);
1:2f85381:       LOGGER.warn(String.format("The value \"%s\" configured for key \"%s\" " +
1:2f85381:           "is invalid. Ignoring it", value, propertyName));
1:2f85381:       throw e;
1:2f85381:     }
1:2f85381:   }
1:2f85381: 
1:2f85381:   /**
1:cd6a4ff:    * This method validates the loaded properties and loads default
1:cd6a4ff:    * values in case of wrong values.
1:013db60:    */
1:cd6a4ff:   private void validateAndLoadDefaultProperties() {
1:cd6a4ff:     validateBlockletSize();
1:cd6a4ff:     validateSortSize();
1:d54dc64:     validateCarbonDataFileVersion();
1:473bd31:     validateDynamicSchedulerTimeOut();
1:c5aba5f:     validatePrefetchBufferSize();
1:ebf13dc:     validateBlockletGroupSizeInMB();
1:2cf1104:     validateNumberOfColumnPerIORead();
1:1a35cfb:     validateEnableUnsafeSort();
1:d8bafa3:     validateEnableOffHeapSort();
1:1a35cfb:     validateCustomBlockDistribution();
1:1a35cfb:     validateEnableVectorReader();
1:1a35cfb:     validateLockType();
1:1a35cfb:     validateCarbonCSVReadBufferSizeByte();
1:0f407de:     validateHandoffSize();
1:b4dc866:     validateCarbonTaskDistribution();
1:bcf3ca3:     // The method validate the validity of configured carbon.timestamp.format value
1:bcf3ca3:     // and reset to default value if validation fail
1:bcf3ca3:     validateTimeFormatKey(CARBON_TIMESTAMP_FORMAT,
1:bcf3ca3:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:bcf3ca3:     // The method validate the validity of configured carbon.date.format value
1:bcf3ca3:     // and reset to default value if validation fail
1:bcf3ca3:     validateTimeFormatKey(CARBON_DATE_FORMAT,
1:bcf3ca3:         CarbonCommonConstants.CARBON_DATE_DEFAULT_FORMAT);
1:bcf3ca3:     validateSortFileWriteBufferSize();
1:bcf3ca3:     validateSortIntermediateFilesLimit();
1:a51ad30:     validateEnableAutoHandoff();
1:473bd31:     validateSchedulerMinRegisteredRatio();
1:27ec651:     validateSortMemorySizeInMB();
1:27ec651:     validateWorkingMemory();
1:27ec651:     validateSortStorageMemory();
1:d5bec4d:     validateEnableQueryStatistics();
1:8cb37dd:     validateSortMemorySpillPercentage();
1:1a35cfb:   }
1:1a35cfb: 
1:bcf3ca3:   /**
1:bcf3ca3:    * Sort intermediate file size validation and if not valid then reset to the default value
1:bcf3ca3:    */
1:bcf3ca3:   private void validateSortIntermediateFilesLimit() {
1:bcf3ca3:     validateRange(SORT_INTERMEDIATE_FILES_LIMIT,
1:bcf3ca3:         CarbonCommonConstants.SORT_INTERMEDIATE_FILES_LIMIT_DEFAULT_VALUE,
1:bcf3ca3:         CarbonCommonConstants.SORT_INTERMEDIATE_FILES_LIMIT_MIN,
1:bcf3ca3:         CarbonCommonConstants.SORT_INTERMEDIATE_FILES_LIMIT_MAX);
1:bcf3ca3:   }
1:bcf3ca3: 
1:bcf3ca3:   /**
1:bcf3ca3:    *
1:bcf3ca3:    * @param key
1:bcf3ca3:    * @param defaultValue default value for the given key
1:bcf3ca3:    * @param minValue Minimum value for the given key
1:bcf3ca3:    * @param maxValue Max value for the given key
1:bcf3ca3:    */
1:bcf3ca3:   private void validateRange(String key, String defaultValue, int minValue, int maxValue) {
1:bcf3ca3:     String fileBufferSize = carbonProperties
1:bcf3ca3:         .getProperty(key, defaultValue);
1:bcf3ca3:     if (null != fileBufferSize) {
1:1a35cfb:       try {
1:bcf3ca3:         int bufferSize = Integer.parseInt(fileBufferSize);
1:bcf3ca3: 
1:bcf3ca3:         if (bufferSize < minValue
1:bcf3ca3:             || bufferSize > maxValue) {
1:bcf3ca3:           LOGGER.warn("The value \"" + fileBufferSize + "\" configured for key "
1:bcf3ca3:               + key
1:1a35cfb:               + "\" is not in range. Valid range is (byte) \""
1:bcf3ca3:               + minValue + " to \""
1:bcf3ca3:               + maxValue +
1:bcf3ca3:               ". Using the default value \""
1:bcf3ca3:               + defaultValue);
1:bcf3ca3:           carbonProperties.setProperty(key,
1:bcf3ca3:               defaultValue);
1:1a35cfb:         }
1:1a35cfb:       } catch (NumberFormatException nfe) {
1:bcf3ca3:         LOGGER.warn("The value \"" + fileBufferSize + "\" configured for key "
1:bcf3ca3:             + key
1:1a35cfb:             + "\" is invalid. Using the default value \""
1:bcf3ca3:             + defaultValue);
1:bcf3ca3:         carbonProperties.setProperty(key,
1:bcf3ca3:             defaultValue);
1:1a35cfb:       }
1:1a35cfb:     }
1:1a35cfb:   }
1:1a35cfb: 
1:bcf3ca3:   /**
1:bcf3ca3:    * validate carbon.sort.file.write.buffer.size and if not valid then reset to the default value
1:bcf3ca3:    */
1:bcf3ca3:   private void validateSortFileWriteBufferSize() {
1:bcf3ca3:     validateRange(CARBON_SORT_FILE_WRITE_BUFFER_SIZE,
1:bcf3ca3:         CarbonCommonConstants.CARBON_SORT_FILE_WRITE_BUFFER_SIZE_DEFAULT_VALUE,
1:bcf3ca3:         CarbonCommonConstants.CARBON_SORT_FILE_WRITE_BUFFER_SIZE_MIN,
1:bcf3ca3:         CarbonCommonConstants.CARBON_SORT_FILE_WRITE_BUFFER_SIZE_MAX);
1:bcf3ca3:   }
1:bcf3ca3: 
1:bcf3ca3:   /**
1:473bd31:    * minimum required registered resource for starting block distribution
1:473bd31:    */
1:473bd31:   private void validateSchedulerMinRegisteredRatio() {
1:473bd31:     String value = carbonProperties
1:473bd31:         .getProperty(CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO,
1:473bd31:             CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:473bd31:     try {
1:473bd31:       double minRegisteredResourceRatio = java.lang.Double.parseDouble(value);
1:473bd31:       if (minRegisteredResourceRatio < CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MIN
1:473bd31:           || minRegisteredResourceRatio > CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MAX) {
1:473bd31:         LOGGER.warn("The value \"" + value
1:473bd31:             + "\" configured for key " + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO
1:473bd31:             + "\" is not in range. Valid range is (byte) \""
1:473bd31:             + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MIN + " to \""
1:473bd31:             + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MAX + ". Using the default value \""
1:473bd31:             + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:473bd31:         carbonProperties.setProperty(CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO,
1:473bd31:             CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:473bd31:       }
1:473bd31:     } catch (NumberFormatException e) {
1:473bd31:       LOGGER.warn("The value \"" + value
1:473bd31:           + "\" configured for key " + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO
1:473bd31:           + "\" is invalid. Using the default value \""
1:473bd31:           + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:473bd31:       carbonProperties.setProperty(CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO,
1:473bd31:           CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:473bd31:     }
1:473bd31:   }
1:473bd31: 
1:473bd31:   /**
1:bcf3ca3:    * The method validate the validity of configured carbon.date.format value
1:bcf3ca3:    * and reset to default value if validation fail
1:bcf3ca3:    */
1:bcf3ca3:   private void validateTimeFormatKey(String key, String defaultValue) {
1:bcf3ca3:     String dateFormat = carbonProperties
1:bcf3ca3:         .getProperty(key, defaultValue);
1:bcf3ca3:     try {
1:bcf3ca3:       new SimpleDateFormat(dateFormat);
1:bcf3ca3:     } catch (Exception e) {
1:bcf3ca3:       LOGGER.warn("The value \"" + dateFormat + "\" configured for key "
1:bcf3ca3:           + key
1:bcf3ca3:           + "\" is invalid. Using the default value \""
1:bcf3ca3:           + key);
1:bcf3ca3:       carbonProperties.setProperty(key, defaultValue);
1:bcf3ca3:     }
1:bcf3ca3:   }
1:bcf3ca3: 
1:bcf3ca3:   /**
1:bcf3ca3:    * The method value csv read buffer size and if not valid then reset to the default value
1:bcf3ca3:    */
1:bcf3ca3:   private void validateCarbonCSVReadBufferSizeByte() {
1:bcf3ca3:     validateRange(CSV_READ_BUFFER_SIZE,
1:bcf3ca3:         CarbonCommonConstants.CSV_READ_BUFFER_SIZE_DEFAULT,
1:bcf3ca3:         CarbonCommonConstants.CSV_READ_BUFFER_SIZE_MIN,
1:bcf3ca3:         CarbonCommonConstants.CSV_READ_BUFFER_SIZE_MAX);
1:bcf3ca3:   }
1:bcf3ca3: 
1:1a35cfb:   private void validateLockType() {
1:500654e:     String lockTypeConfigured = carbonProperties
1:bcf3ca3:         .getProperty(LOCK_TYPE, CarbonCommonConstants.LOCK_TYPE_DEFAULT);
1:1a35cfb:     switch (lockTypeConfigured.toUpperCase()) {
1:1a35cfb:       // if user is setting the lock type as CARBON_LOCK_TYPE_ZOOKEEPER then no need to validate
1:1a35cfb:       // else validate based on the file system type for LOCAL file system lock will be
1:1a35cfb:       // CARBON_LOCK_TYPE_LOCAL and for the distributed one CARBON_LOCK_TYPE_HDFS
1:1a35cfb:       case CarbonCommonConstants.CARBON_LOCK_TYPE_ZOOKEEPER:
1:1a35cfb:         break;
1:1a35cfb:       case CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL:
1:1a35cfb:       case CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS:
1:1a35cfb:       default:
2:1a35cfb:         validateAndConfigureLockType(lockTypeConfigured);
1:1a35cfb:     }
1:1a35cfb:   }
1:1a35cfb: 
1:1a35cfb:   /**
1:1a35cfb:    * the method decide and set the lock type based on the configured system type
1:1a35cfb:    *
1:1a35cfb:    * @param lockTypeConfigured
1:1a35cfb:    */
1:1a35cfb:   private void validateAndConfigureLockType(String lockTypeConfigured) {
1:2a9604c:     Configuration configuration = FileFactory.getConfiguration();
1:1a35cfb:     String defaultFs = configuration.get("fs.defaultFS");
1:1a35cfb:     if (null != defaultFs && (defaultFs.startsWith(CarbonCommonConstants.HDFSURL_PREFIX)
1:1a35cfb:         || defaultFs.startsWith(CarbonCommonConstants.VIEWFSURL_PREFIX) || defaultFs
1:5ab0957:         .startsWith(CarbonCommonConstants.ALLUXIOURL_PREFIX) || defaultFs
1:5ab0957:         .startsWith(CarbonCommonConstants.S3A_PREFIX))
1:1a35cfb:         && !CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS.equalsIgnoreCase(lockTypeConfigured)) {
1:1a35cfb:       LOGGER.warn("The value \"" + lockTypeConfigured + "\" configured for key "
1:bcf3ca3:           + LOCK_TYPE + " is invalid for current file system. "
1:c81c3b1:           + "Use the default value " + CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS + " instead.");
1:bcf3ca3:       carbonProperties.setProperty(LOCK_TYPE,
1:1a35cfb:           CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS);
1:1a35cfb:     } else if (null != defaultFs && defaultFs.startsWith(CarbonCommonConstants.LOCAL_FILE_PREFIX)
1:1a35cfb:         && !CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL.equalsIgnoreCase(lockTypeConfigured)) {
1:bcf3ca3:       carbonProperties.setProperty(LOCK_TYPE,
1:1a35cfb:           CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL);
1:1a35cfb:       LOGGER.warn("The value \"" + lockTypeConfigured + "\" configured for key "
1:bcf3ca3:           + LOCK_TYPE + " is invalid for current file system. "
1:c81c3b1:           + "Use the default value " + CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL + " instead.");
1:1a35cfb:     }
1:1a35cfb:   }
1:1a35cfb: 
1:1a35cfb:   private void validateEnableVectorReader() {
1:1a35cfb:     String vectorReaderStr =
1:bcf3ca3:         carbonProperties.getProperty(ENABLE_VECTOR_READER);
1:1a35cfb:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(vectorReaderStr);
1:1a35cfb:     if (!isValidBooleanValue) {
1:1a35cfb:       LOGGER.warn("The enable vector reader value \"" + vectorReaderStr
1:1a35cfb:           + "\" is invalid. Using the default value \""
1:1a35cfb:           + CarbonCommonConstants.ENABLE_VECTOR_READER_DEFAULT);
1:bcf3ca3:       carbonProperties.setProperty(ENABLE_VECTOR_READER,
1:1a35cfb:           CarbonCommonConstants.ENABLE_VECTOR_READER_DEFAULT);
1:1a35cfb:     }
1:1a35cfb:   }
1:1a35cfb: 
1:1a35cfb:   private void validateCustomBlockDistribution() {
1:1a35cfb:     String customBlockDistributionStr =
1:bcf3ca3:         carbonProperties.getProperty(CARBON_CUSTOM_BLOCK_DISTRIBUTION);
1:1a35cfb:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(customBlockDistributionStr);
1:1a35cfb:     if (!isValidBooleanValue) {
1:1a35cfb:       LOGGER.warn("The custom block distribution value \"" + customBlockDistributionStr
1:1a35cfb:           + "\" is invalid. Using the default value \""
1:b4dc866:           + false);
1:b4dc866:       carbonProperties.setProperty(CARBON_CUSTOM_BLOCK_DISTRIBUTION, "false");
1:1a35cfb:     }
1:1a35cfb:   }
1:1a35cfb: 
1:b4dc866:   private void validateCarbonTaskDistribution() {
1:b4dc866:     String carbonTaskDistribution = carbonProperties.getProperty(CARBON_TASK_DISTRIBUTION);
1:b4dc866:     boolean isValid = carbonTaskDistribution != null && (
1:b4dc866:         carbonTaskDistribution.equalsIgnoreCase(CARBON_TASK_DISTRIBUTION_MERGE_FILES)
1:b4dc866:             || carbonTaskDistribution.equalsIgnoreCase(CARBON_TASK_DISTRIBUTION_BLOCKLET)
1:b4dc866:             || carbonTaskDistribution.equalsIgnoreCase(CARBON_TASK_DISTRIBUTION_BLOCK)
1:b4dc866:             || carbonTaskDistribution.equalsIgnoreCase(CARBON_TASK_DISTRIBUTION_CUSTOM));
1:b4dc866:     if (!isValid) {
1:b4dc866:       LOGGER.warn("The carbon task distribution value \"" + carbonTaskDistribution
1:1a35cfb:           + "\" is invalid. Using the default value \""
1:b4dc866:           + CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_DEFAULT);
1:b4dc866:       carbonProperties.setProperty(CARBON_TASK_DISTRIBUTION,
1:b4dc866:           CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_DEFAULT);
1:2f85381:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:1a35cfb:   private void validateEnableUnsafeSort() {
1:bcf3ca3:     String unSafeSortStr = carbonProperties.getProperty(ENABLE_UNSAFE_SORT);
1:1a35cfb:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(unSafeSortStr);
1:1a35cfb:     if (!isValidBooleanValue) {
1:1a35cfb:       LOGGER.warn("The enable unsafe sort value \"" + unSafeSortStr
1:1a35cfb:           + "\" is invalid. Using the default value \""
1:1a35cfb:           + CarbonCommonConstants.ENABLE_UNSAFE_SORT_DEFAULT);
1:bcf3ca3:       carbonProperties.setProperty(ENABLE_UNSAFE_SORT,
1:1a35cfb:           CarbonCommonConstants.ENABLE_UNSAFE_SORT_DEFAULT);
1:1a35cfb:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:d8bafa3:   private void validateEnableOffHeapSort() {
1:d8bafa3:     String value = carbonProperties.getProperty(ENABLE_OFFHEAP_SORT);
1:d8bafa3:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(value);
1:d8bafa3:     if (!isValidBooleanValue) {
1:d8bafa3:       LOGGER.warn("The enable off heap sort value \"" + value
1:d8bafa3:           + "\" is invalid. Using the default value \""
1:d8bafa3:           + CarbonCommonConstants.ENABLE_OFFHEAP_SORT_DEFAULT);
1:d8bafa3:       carbonProperties.setProperty(ENABLE_OFFHEAP_SORT,
1:d8bafa3:           CarbonCommonConstants.ENABLE_OFFHEAP_SORT_DEFAULT);
1:d8bafa3:     }
1:d8bafa3:   }
1:d8bafa3: 
1:39644b5:   private void initPropertySet() throws IllegalAccessException {
1:39644b5:     Field[] declaredFields = CarbonCommonConstants.class.getDeclaredFields();
1:39644b5:     for (Field field : declaredFields) {
1:39644b5:       if (field.isAnnotationPresent(CarbonProperty.class)) {
1:39644b5:         propertySet.add(field.get(field.getName()).toString());
1:39644b5:       }
1:39644b5:     }
1:39644b5:     declaredFields = CarbonV3DataFormatConstants.class.getDeclaredFields();
1:39644b5:     for (Field field : declaredFields) {
1:39644b5:       if (field.isAnnotationPresent(CarbonProperty.class)) {
1:39644b5:         propertySet.add(field.get(field.getName()).toString());
1:39644b5:       }
1:39644b5:     }
1:39644b5:     declaredFields = CarbonLoadOptionConstants.class.getDeclaredFields();
1:39644b5:     for (Field field : declaredFields) {
1:39644b5:       if (field.isAnnotationPresent(CarbonProperty.class)) {
1:39644b5:         propertySet.add(field.get(field.getName()).toString());
1:39644b5:       }
1:39644b5:     }
1:39644b5:   }
1:39644b5: 
1:c5aba5f:   private void validatePrefetchBufferSize() {
1:c5aba5f:     String prefetchBufferSizeStr =
1:bcf3ca3:         carbonProperties.getProperty(CARBON_PREFETCH_BUFFERSIZE);
1:cd6a4ff: 
1:c5aba5f:     if (null == prefetchBufferSizeStr || prefetchBufferSizeStr.length() == 0) {
1:bcf3ca3:       carbonProperties.setProperty(CARBON_PREFETCH_BUFFERSIZE,
1:c5aba5f:           CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE_DEFAULT);
1:1a35cfb:     } else {
1:39644b5:       try {
1:c5aba5f:         Integer.parseInt(prefetchBufferSizeStr);
1:cd6a4ff:       } catch (NumberFormatException e) {
1:c5aba5f:         LOGGER.info("The prefetch buffer size value \"" + prefetchBufferSizeStr
1:cd6a4ff:             + "\" is invalid. Using the default value \""
1:c5aba5f:             + CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE_DEFAULT + "\"");
1:bcf3ca3:         carbonProperties.setProperty(CARBON_PREFETCH_BUFFERSIZE,
1:c5aba5f:             CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE_DEFAULT);
1:cd6a4ff:       }
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:0f407de:   private void validateHandoffSize() {
1:bcf3ca3:     String handoffSizeStr = carbonProperties.getProperty(HANDOFF_SIZE);
1:0f407de:     if (null == handoffSizeStr || handoffSizeStr.length() == 0) {
1:bcf3ca3:       carbonProperties.setProperty(HANDOFF_SIZE,
1:0f407de:           "" + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT);
1:0f407de:     } else {
1:cd6a4ff:       try {
1:0f407de:         long handoffSize = Long.parseLong(handoffSizeStr);
1:0f407de:         if (handoffSize < CarbonCommonConstants.HANDOFF_SIZE_MIN) {
1:0f407de:           LOGGER.info("The streaming segment max size configured value " + handoffSizeStr +
1:0f407de:               " is invalid. Using the default value "
1:0f407de:               + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT);
1:bcf3ca3:           carbonProperties.setProperty(HANDOFF_SIZE,
1:0f407de:               "" + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT);
1:cd6a4ff:         }
1:cd6a4ff:       } catch (NumberFormatException e) {
1:0f407de:         LOGGER.info("The streaming segment max size value \"" + handoffSizeStr
1:cd6a4ff:             + "\" is invalid. Using the default value \""
1:0f407de:             + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT + "\"");
1:bcf3ca3:         carbonProperties.setProperty(HANDOFF_SIZE,
1:0f407de:             "" + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT);
1:cd6a4ff:       }
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:a51ad30:   private void validateEnableAutoHandoff() {
1:a51ad30:     String enableAutoHandoffStr =
1:bcf3ca3:         carbonProperties.getProperty(ENABLE_AUTO_HANDOFF);
1:a51ad30:     boolean isValid = CarbonUtil.validateBoolean(enableAutoHandoffStr);
1:a51ad30:     if (!isValid) {
1:a51ad30:       LOGGER.warn("The enable auto handoff value \"" + enableAutoHandoffStr
1:cd6a4ff:           + "\" is invalid. Using the default value \""
1:a51ad30:           + CarbonCommonConstants.ENABLE_AUTO_HANDOFF_DEFAULT);
1:bcf3ca3:       carbonProperties.setProperty(ENABLE_AUTO_HANDOFF,
1:a51ad30:           CarbonCommonConstants.ENABLE_AUTO_HANDOFF_DEFAULT);
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:2cf1104:    * This method validates the number of pages per blocklet column
1:cd6a4ff:    */
1:ebf13dc:   private void validateBlockletGroupSizeInMB() {
1:2cf1104:     String numberOfPagePerBlockletColumnString = carbonProperties
1:bcf3ca3:         .getProperty(BLOCKLET_SIZE_IN_MB,
1:ebf13dc:             CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
1:cd6a4ff:     try {
1:2cf1104:       short numberOfPagePerBlockletColumn = Short.parseShort(numberOfPagePerBlockletColumnString);
1:ebf13dc:       if (numberOfPagePerBlockletColumn < CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_MIN) {
1:ebf13dc:         LOGGER.info("Blocklet Size Configured value \"" + numberOfPagePerBlockletColumnString
1:cd6a4ff:             + "\" is invalid. Using the default value \""
1:ebf13dc:             + CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
1:bcf3ca3:         carbonProperties.setProperty(BLOCKLET_SIZE_IN_MB,
1:ebf13dc:             CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
1:cd6a4ff:       }
1:cd6a4ff:     } catch (NumberFormatException e) {
1:ebf13dc:       LOGGER.info("Blocklet Size Configured value \"" + numberOfPagePerBlockletColumnString
1:cd6a4ff:           + "\" is invalid. Using the default value \""
1:ebf13dc:           + CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
1:bcf3ca3:       carbonProperties.setProperty(BLOCKLET_SIZE_IN_MB,
1:ebf13dc:           CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
1:cd6a4ff:     }
1:ebf13dc:     LOGGER.info("Blocklet Size Configured value is \"" + carbonProperties
1:bcf3ca3:         .getProperty(BLOCKLET_SIZE_IN_MB,
1:ebf13dc:             CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE));
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
2:2cf1104:    * This method validates the number of column read in one IO
1:cd6a4ff:    */
1:2cf1104:   private void validateNumberOfColumnPerIORead() {
1:2cf1104:     String numberofColumnPerIOString = carbonProperties
1:bcf3ca3:         .getProperty(NUMBER_OF_COLUMN_TO_READ_IN_IO,
1:2cf1104:             CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
1:cd6a4ff:     try {
1:2cf1104:       short numberofColumnPerIO = Short.parseShort(numberofColumnPerIOString);
1:2cf1104:       if (numberofColumnPerIO < CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_MIN
1:2cf1104:           || numberofColumnPerIO > CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_MAX) {
1:2cf1104:         LOGGER.info("The Number Of pages per blocklet column value \"" + numberofColumnPerIOString
1:cd6a4ff:             + "\" is invalid. Using the default value \""
1:2cf1104:             + CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
1:bcf3ca3:         carbonProperties.setProperty(NUMBER_OF_COLUMN_TO_READ_IN_IO,
1:2cf1104:             CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
1:cd6a4ff:       }
1:cd6a4ff:     } catch (NumberFormatException e) {
1:2cf1104:       LOGGER.info("The Number Of pages per blocklet column value \"" + numberofColumnPerIOString
1:cd6a4ff:           + "\" is invalid. Using the default value \""
1:2cf1104:           + CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
1:bcf3ca3:       carbonProperties.setProperty(NUMBER_OF_COLUMN_TO_READ_IN_IO,
1:2cf1104:           CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method validates the blocklet size
1:cd6a4ff:    */
1:cd6a4ff:   private void validateBlockletSize() {
1:bcf3ca3:     String blockletSizeStr = carbonProperties.getProperty(BLOCKLET_SIZE,
1:cd6a4ff:         CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
1:cd6a4ff:     try {
1:cd6a4ff:       int blockletSize = Integer.parseInt(blockletSizeStr);
1:cd6a4ff: 
1:cd6a4ff:       if (blockletSize < CarbonCommonConstants.BLOCKLET_SIZE_MIN_VAL
1:cd6a4ff:           || blockletSize > CarbonCommonConstants.BLOCKLET_SIZE_MAX_VAL) {
1:cd6a4ff:         LOGGER.info("The blocklet size value \"" + blockletSizeStr
1:cd6a4ff:             + "\" is invalid. Using the default value \""
1:cd6a4ff:             + CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
1:bcf3ca3:         carbonProperties.setProperty(BLOCKLET_SIZE,
1:cd6a4ff:             CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
1:cd6a4ff:       }
1:cd6a4ff:     } catch (NumberFormatException e) {
1:cd6a4ff:       LOGGER.info("The blocklet size value \"" + blockletSizeStr
1:cd6a4ff:           + "\" is invalid. Using the default value \""
1:cd6a4ff:           + CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
1:bcf3ca3:       carbonProperties.setProperty(BLOCKLET_SIZE,
1:cd6a4ff:           CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method validates the sort size
1:cd6a4ff:    */
1:cd6a4ff:   private void validateSortSize() {
1:cd6a4ff:     String sortSizeStr = carbonProperties
1:bcf3ca3:         .getProperty(SORT_SIZE, CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
1:cd6a4ff:     try {
1:cd6a4ff:       int sortSize = Integer.parseInt(sortSizeStr);
1:cd6a4ff: 
1:cd6a4ff:       if (sortSize < CarbonCommonConstants.SORT_SIZE_MIN_VAL) {
1:2cf1104:         LOGGER.info(
1:d54dc64:             "The batch size value \"" + sortSizeStr + "\" is invalid. Using the default value \""
1:cd6a4ff:                 + CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
1:bcf3ca3:         carbonProperties.setProperty(SORT_SIZE,
1:cd6a4ff:             CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
1:cd6a4ff:       }
1:cd6a4ff:     } catch (NumberFormatException e) {
1:2cf1104:       LOGGER.info(
1:d54dc64:           "The batch size value \"" + sortSizeStr + "\" is invalid. Using the default value \""
1:cd6a4ff:               + CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
1:bcf3ca3:       carbonProperties.setProperty(SORT_SIZE,
1:cd6a4ff:           CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:d54dc64:    * Below method will be used to validate the data file version parameter
1:d54dc64:    * if parameter is invalid current version will be set
1:cd6a4ff:    */
1:d54dc64:   private void validateCarbonDataFileVersion() {
1:d54dc64:     String carbondataFileVersionString =
1:bcf3ca3:         carbonProperties.getProperty(CARBON_DATA_FILE_VERSION);
1:0ef3fb8:     if (carbondataFileVersionString == null) {
1:0ef3fb8:       // use default property if user does not specify version property
1:bcf3ca3:       carbonProperties.setProperty(CARBON_DATA_FILE_VERSION,
1:2cf1104:           CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION);
1:c5aba5f:     } else {
1:cd6a4ff:       try {
1:0ef3fb8:         ColumnarFormatVersion.valueOf(carbondataFileVersionString);
1:0ef3fb8:       } catch (IllegalArgumentException e) {
1:0ef3fb8:         // use default property if user specifies an invalid version property
1:2cf1104:         LOGGER.warn("Specified file version property is invalid: " + carbondataFileVersionString
1:2cf1104:             + ". Using " + CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION
1:2cf1104:             + " as default file version");
1:bcf3ca3:         carbonProperties.setProperty(CARBON_DATA_FILE_VERSION,
2:0ef3fb8:             CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION);
1:cd6a4ff:       }
1:cd6a4ff:     }
1:ebf13dc:     LOGGER.info("Carbon Current data file version: " + carbonProperties
1:bcf3ca3:         .setProperty(CARBON_DATA_FILE_VERSION,
1:ebf13dc:             CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION));
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will read all the properties from file and load it into
1:cd6a4ff:    * memory
1:cd6a4ff:    */
1:cd6a4ff:   private void loadProperties() {
1:cd6a4ff:     String property = System.getProperty("carbon.properties.filepath");
1:cd6a4ff:     if (null == property) {
1:cd6a4ff:       property = CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH;
1:cd6a4ff:     }
1:cd6a4ff:     File file = new File(property);
1:cd6a4ff:     LOGGER.info("Property file path: " + file.getAbsolutePath());
1:cd6a4ff: 
1:cd6a4ff:     FileInputStream fis = null;
1:cd6a4ff:     try {
1:cd6a4ff:       if (file.exists()) {
1:cd6a4ff:         fis = new FileInputStream(file);
1:cd6a4ff: 
1:cd6a4ff:         carbonProperties.load(fis);
1:cd6a4ff:       }
1:cd6a4ff:     } catch (FileNotFoundException e) {
1:0609fc5:       LOGGER.error(
1:d54dc64:           "The file: " + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH + " does not exist");
1:cd6a4ff:     } catch (IOException e) {
1:72f50b5:       LOGGER.error(
1:d54dc64:           "Error while reading the file: " + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH);
1:cd6a4ff:     } finally {
1:cd6a4ff:       if (null != fis) {
1:cd6a4ff:         try {
1:cd6a4ff:           fis.close();
1:cd6a4ff:         } catch (IOException e) {
1:cd6a4ff:           LOGGER.error("Error while closing the file stream for file: "
2:cd6a4ff:               + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH);
1:cd6a4ff:         }
1:cd6a4ff:       }
1:cd6a4ff:     }
1:cd6a4ff: 
1:cd6a4ff:     print();
1:bcf3ca3:     try {
1:bcf3ca3:       initPropertySet();
1:bcf3ca3:     } catch (IllegalAccessException e) {
1:bcf3ca3:       LOGGER.error("Illegal access to declared field" + e.getMessage());
1:bcf3ca3:     }
1:39644b5:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:5fc7f06:    * Return the store path
1:5fc7f06:    */
1:5fc7f06:   public static String getStorePath() {
1:5fc7f06:     return getInstance().getProperty(CarbonCommonConstants.STORE_LOCATION);
1:5fc7f06:   }
1:5fc7f06: 
1:5fc7f06:   /**
1:cd6a4ff:    * This method will be used to get the properties value
1:cd6a4ff:    *
1:cd6a4ff:    * @param key
1:cd6a4ff:    * @return properties value
1:cd6a4ff:    */
1:cd6a4ff:   public String getProperty(String key) {
1:39644b5:     // get the property value from session parameters,
1:39644b5:     // if its null then get value from carbonProperties
1:39644b5:     String sessionPropertyValue = getSessionPropertyValue(key);
1:39644b5:     if (null != sessionPropertyValue) {
1:39644b5:       return sessionPropertyValue;
1:39644b5:     }
1:cd6a4ff:     return carbonProperties.getProperty(key);
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:39644b5:    * returns session property value
1:39644b5:    *
1:39644b5:    * @param key
1:39644b5:    * @return
1:39644b5:    */
1:39644b5:   private String getSessionPropertyValue(String key) {
1:39644b5:     String value = null;
1:39644b5:     CarbonSessionInfo carbonSessionInfo = ThreadLocalSessionInfo.getCarbonSessionInfo();
1:39644b5:     if (null != carbonSessionInfo) {
1:39644b5:       SessionParams sessionParams =
1:39644b5:           ThreadLocalSessionInfo.getCarbonSessionInfo().getSessionParams();
1:39644b5:       if (null != sessionParams) {
1:39644b5:         value = sessionParams.getProperty(key);
1:39644b5:       }
1:39644b5:     }
1:39644b5:     return value;
1:39644b5:   }
1:39644b5: 
1:39644b5:   /**
1:cd6a4ff:    * This method will be used to get the properties value if property is not
1:cd6a4ff:    * present then it will return tghe default value
1:cd6a4ff:    *
1:cd6a4ff:    * @param key
1:cd6a4ff:    * @return properties value
1:cd6a4ff:    */
1:cd6a4ff:   public String getProperty(String key, String defaultValue) {
1:cd6a4ff:     String value = getProperty(key);
1:cd6a4ff:     if (null == value) {
1:cd6a4ff:       return defaultValue;
1:cd6a4ff:     }
1:cd6a4ff:     return value;
1:cd6a4ff:   }
1:181f0ac: 
1:181f0ac:   /**
1:cd6a4ff:    * This method will be used to add a new property
1:cd6a4ff:    *
1:cd6a4ff:    * @param key
1:cd6a4ff:    * @return properties value
1:cd6a4ff:    */
1:f67ec01:   public CarbonProperties addProperty(String key, String value) {
1:cd6a4ff:     carbonProperties.setProperty(key, value);
1:1462495:     addedProperty.put(key, value);
1:bcf3ca3:     // the method will validate the added property
1:bcf3ca3:     // if the added property is not valid then will reset to default value.
1:bcf3ca3:     validateAndLoadDefaultProperties(key.toLowerCase());
1:f67ec01:     return this;
1:28e2e17:   }
1:28e2e17: 
1:2f85381:   /**
1:7843845:    * This method will be used to add a new property which need not be serialized
1:7843845:    *
1:7843845:    * @param key
1:7843845:    */
1:7843845:   public void addNonSerializableProperty(String key, String value) {
1:7843845:     carbonProperties.setProperty(key, value);
1:7843845:   }
1:7843845: 
1:7843845:   /**
1:2f85381:    * Remove the specified key in property
1:2f85381:    */
1:2f85381:   public CarbonProperties removeProperty(String key) {
1:2f85381:     carbonProperties.remove(key);
1:2f85381:     addedProperty.remove(key);
1:2f85381:     return this;
1:2f85381:   }
1:2f85381: 
1:0ef3fb8:   private ColumnarFormatVersion getDefaultFormatVersion() {
1:0ef3fb8:     return ColumnarFormatVersion.valueOf(CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION);
1:28e2e17:   }
1:28e2e17: 
1:0ef3fb8:   public ColumnarFormatVersion getFormatVersion() {
1:bcf3ca3:     String versionStr = getInstance().getProperty(CARBON_DATA_FILE_VERSION);
1:0ef3fb8:     if (versionStr == null) {
1:0ef3fb8:       return getDefaultFormatVersion();
1:0ef3fb8:     } else {
1:cd6a4ff:       try {
1:51425d4:         short version = Short.parseShort(versionStr);
1:51425d4:         return ColumnarFormatVersion.valueOf(version);
1:0ef3fb8:       } catch (IllegalArgumentException e) {
1:0ef3fb8:         return getDefaultFormatVersion();
1:28e2e17:       }
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:28e2e17:   /**
1:cd6a4ff:    * returns major compaction size value from carbon properties or default value if it is not valid
1:cd6a4ff:    *
1:28e2e17:    * @return
1:28e2e17:    */
1:cd6a4ff:   public long getMajorCompactionSize() {
1:cd6a4ff:     long compactionSize;
1:cd6a4ff:     try {
1:f1c6ddd:       compactionSize = Long.parseLong(getProperty(
1:f1c6ddd:               CarbonCommonConstants.CARBON_MAJOR_COMPACTION_SIZE,
1:f1c6ddd:               CarbonCommonConstants.DEFAULT_CARBON_MAJOR_COMPACTION_SIZE));
1:cd6a4ff:     } catch (NumberFormatException e) {
1:f1c6ddd:       compactionSize = Long.parseLong(
1:f1c6ddd:               CarbonCommonConstants.DEFAULT_CARBON_MAJOR_COMPACTION_SIZE);
1:cd6a4ff:     }
1:cd6a4ff:     return compactionSize;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * returns the number of loads to be preserved.
1:cd6a4ff:    *
6:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   public int getNumberOfSegmentsToBePreserved() {
1:cd6a4ff:     int numberOfSegmentsToBePreserved;
1:cd6a4ff:     try {
1:cd6a4ff:       numberOfSegmentsToBePreserved = Integer.parseInt(
1:cd6a4ff:           getProperty(CarbonCommonConstants.PRESERVE_LATEST_SEGMENTS_NUMBER,
1:cd6a4ff:               CarbonCommonConstants.DEFAULT_PRESERVE_LATEST_SEGMENTS_NUMBER));
1:cd6a4ff:       // checking min and max . 0  , 100 is min & max.
1:cd6a4ff:       if (numberOfSegmentsToBePreserved < 0 || numberOfSegmentsToBePreserved > 100) {
1:877eabd:         LOGGER.warn("The specified value for property "
1:cd6a4ff:             + CarbonCommonConstants.PRESERVE_LATEST_SEGMENTS_NUMBER + " is incorrect."
1:cd6a4ff:             + " Correct value should be in range of 0 -100. Taking the default value.");
1:cd6a4ff:         numberOfSegmentsToBePreserved =
1:cd6a4ff:             Integer.parseInt(CarbonCommonConstants.DEFAULT_PRESERVE_LATEST_SEGMENTS_NUMBER);
1:cd6a4ff:       }
1:cd6a4ff:     } catch (NumberFormatException e) {
1:cd6a4ff:       numberOfSegmentsToBePreserved =
1:cd6a4ff:           Integer.parseInt(CarbonCommonConstants.DEFAULT_PRESERVE_LATEST_SEGMENTS_NUMBER);
1:cd6a4ff:     }
1:cd6a4ff:     return numberOfSegmentsToBePreserved;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   public void print() {
1:cd6a4ff:     LOGGER.info("------Using Carbon.properties --------");
1:cd6a4ff:     LOGGER.info(carbonProperties.toString());
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * gettting the unmerged segment numbers to be merged.
1:cd6a4ff:    *
1:9326cfd:    * @return corrected value of unmerged segments to be merged
1:cd6a4ff:    */
1:cd6a4ff:   public int[] getCompactionSegmentLevelCount() {
1:cd6a4ff:     String commaSeparatedLevels;
1:cd6a4ff: 
1:cd6a4ff:     commaSeparatedLevels = getProperty(CarbonCommonConstants.COMPACTION_SEGMENT_LEVEL_THRESHOLD,
1:cd6a4ff:         CarbonCommonConstants.DEFAULT_SEGMENT_LEVEL_THRESHOLD);
1:cd6a4ff:     int[] compactionSize = getIntArray(commaSeparatedLevels);
1:cd6a4ff: 
1:d25fee2:     if (0 == compactionSize.length) {
1:cd6a4ff:       compactionSize = getIntArray(CarbonCommonConstants.DEFAULT_SEGMENT_LEVEL_THRESHOLD);
1:cd6a4ff:     }
1:cd6a4ff: 
1:cd6a4ff:     return compactionSize;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:9326cfd:    * Separating the count for Number of segments to be merged in levels by comma
1:9326cfd:    *
1:9326cfd:    * @param commaSeparatedLevels the string format value before separating
1:9326cfd:    * @return the int array format value after separating by comma
1:cd6a4ff:    */
1:f1c6ddd:   public int[] getIntArray(String commaSeparatedLevels) {
1:cd6a4ff:     String[] levels = commaSeparatedLevels.split(",");
1:cd6a4ff:     int[] compactionSize = new int[levels.length];
1:cd6a4ff:     int i = 0;
1:cd6a4ff:     for (String levelSize : levels) {
1:cd6a4ff:       try {
1:cd6a4ff:         int size = Integer.parseInt(levelSize.trim());
1:d54dc64:         if (validate(size, 100, 0, -1) < 0) {
1:cd6a4ff:           // if given size is out of boundary then take default value for all levels.
1:d25fee2:           return new int[0];
1:cd6a4ff:         }
1:cd6a4ff:         compactionSize[i++] = size;
1:cd6a4ff:       } catch (NumberFormatException e) {
1:877eabd:         LOGGER.warn(
1:cd6a4ff:             "Given value for property" + CarbonCommonConstants.COMPACTION_SEGMENT_LEVEL_THRESHOLD
1:cd6a4ff:                 + " is not proper. Taking the default value "
1:cd6a4ff:                 + CarbonCommonConstants.DEFAULT_SEGMENT_LEVEL_THRESHOLD);
1:d25fee2:         return new int[0];
1:cd6a4ff:       }
1:cd6a4ff:     }
1:cd6a4ff:     return compactionSize;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:f63b1ff:    * Number of cores should be used while loading data.
1:f63b1ff:    *
1:f63b1ff:    * @return
1:f63b1ff:    */
1:f63b1ff:   public int getNumberOfCores() {
1:f63b1ff:     int numberOfCores;
1:f63b1ff:     try {
1:873c3de:       numberOfCores = Integer.parseInt(
1:873c3de:           CarbonProperties.getInstance().getProperty(
1:873c3de:               CarbonCommonConstants.NUM_CORES_LOADING,
1:873c3de:               CarbonCommonConstants.NUM_CORES_DEFAULT_VAL));
1:f63b1ff:     } catch (NumberFormatException exc) {
1:877eabd:       LOGGER.warn("Configured value for property " + CarbonCommonConstants.NUM_CORES_LOADING
1:9e9d689:           + " is wrong. Falling back to the default value "
1:9e9d689:           + CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
1:f63b1ff:       numberOfCores = Integer.parseInt(CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
1:f63b1ff:     }
1:f63b1ff:     return numberOfCores;
1:f63b1ff:   }
1:f63b1ff: 
1:f63b1ff:   /**
1:013db60:    * Get the sort chunk memory size
1:013db60:    * @return
1:cd6a4ff:    */
1:013db60:   public int getSortMemoryChunkSizeInMB() {
1:013db60:     int inMemoryChunkSizeInMB;
1:013db60:     try {
1:013db60:       inMemoryChunkSizeInMB = Integer.parseInt(CarbonProperties.getInstance()
1:013db60:           .getProperty(CarbonCommonConstants.OFFHEAP_SORT_CHUNK_SIZE_IN_MB,
1:013db60:               CarbonCommonConstants.OFFHEAP_SORT_CHUNK_SIZE_IN_MB_DEFAULT));
1:013db60:     } catch (Exception e) {
1:013db60:       inMemoryChunkSizeInMB =
1:013db60:           Integer.parseInt(CarbonCommonConstants.OFFHEAP_SORT_CHUNK_SIZE_IN_MB_DEFAULT);
1:877eabd:       LOGGER.warn("Problem in parsing the sort memory chunk size, setting with default value"
1:013db60:           + inMemoryChunkSizeInMB);
1:013db60:     }
1:013db60:     if (inMemoryChunkSizeInMB > 1024) {
1:013db60:       inMemoryChunkSizeInMB = 1024;
1:877eabd:       LOGGER.warn(
1:013db60:           "It is not recommended to increase the sort memory chunk size more than 1024MB, "
1:013db60:               + "so setting the value to "
1:013db60:               + inMemoryChunkSizeInMB);
1:013db60:     } else if (inMemoryChunkSizeInMB < 1) {
1:013db60:       inMemoryChunkSizeInMB = 1;
1:877eabd:       LOGGER.warn(
1:013db60:           "It is not recommended to decrease the sort memory chunk size less than 1MB, "
1:013db60:               + "so setting the value to "
1:013db60:               + inMemoryChunkSizeInMB);
1:013db60:     }
1:013db60:     return inMemoryChunkSizeInMB;
1:013db60:   }
1:013db60: 
1:013db60:   /**
1:f63b1ff:    * Batch size of rows while sending data from one step to another in data loading.
1:f63b1ff:    *
1:f63b1ff:    * @return
1:f63b1ff:    */
1:f63b1ff:   public int getBatchSize() {
1:f63b1ff:     int batchSize;
1:f63b1ff:     try {
1:f63b1ff:       batchSize = Integer.parseInt(CarbonProperties.getInstance()
1:f63b1ff:           .getProperty(CarbonCommonConstants.DATA_LOAD_BATCH_SIZE,
1:f63b1ff:               CarbonCommonConstants.DATA_LOAD_BATCH_SIZE_DEFAULT));
1:f63b1ff:     } catch (NumberFormatException exc) {
1:f63b1ff:       batchSize = Integer.parseInt(CarbonCommonConstants.DATA_LOAD_BATCH_SIZE_DEFAULT);
1:f63b1ff:     }
1:f63b1ff:     return batchSize;
1:f63b1ff:   }
1:f63b1ff: 
1:0f407de:   public long getHandoffSize() {
1:0f407de:     Long handoffSize;
1:cd6a4ff:     try {
1:0f407de:       handoffSize = Long.parseLong(
1:0f407de:           CarbonProperties.getInstance().getProperty(
1:bcf3ca3:               HANDOFF_SIZE,
1:0f407de:               "" + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT
1:0f407de:           )
1:0f407de:       );
1:0f407de:     } catch (NumberFormatException exc) {
1:0f407de:       handoffSize = CarbonCommonConstants.HANDOFF_SIZE_DEFAULT;
1:cd6a4ff:     }
1:0f407de:     return handoffSize;
1:cd6a4ff:   }
1:cd6a4ff: 
1:a51ad30:   public boolean isEnableAutoHandoff() {
1:a51ad30:     String enableAutoHandoffStr = CarbonProperties.getInstance().getProperty(
1:bcf3ca3:         ENABLE_AUTO_HANDOFF,
1:a51ad30:         CarbonCommonConstants.ENABLE_AUTO_HANDOFF_DEFAULT);
1:a51ad30:     return enableAutoHandoffStr.equalsIgnoreCase("true");
1:cd6a4ff:   }
1:cd6a4ff: 
1:3ff574d:   public boolean isEnableVectorReader() {
1:3ff574d:     return getInstance().getProperty(CarbonCommonConstants.ENABLE_VECTOR_READER,
1:3ff574d:         CarbonCommonConstants.ENABLE_VECTOR_READER_DEFAULT).equalsIgnoreCase("true");
1:3ff574d:   }
1:3ff574d: 
1:f63b1ff:   /**
2:cd6a4ff:    * Validate the restrictions
1:cd6a4ff:    *
1:9326cfd:    * @param actual the actual value for minor compaction
1:9326cfd:    * @param max max value for minor compaction
1:9326cfd:    * @param min min value for minor compaction
1:9326cfd:    * @param defaultVal default value when the actual is improper
1:9326cfd:    * @return  corrected Value after validating
1:cd6a4ff:    */
1:cd6a4ff:   public int validate(int actual, int max, int min, int defaultVal) {
2:cd6a4ff:     if (actual <= max && actual >= min) {
2:cd6a4ff:       return actual;
1:cd6a4ff:     }
2:cd6a4ff:     return defaultVal;
1:cd6a4ff:   }
1:cd6a4ff: 
1:ff7793b:   /**
1:ff7793b:    * This method will validate and set the value for executor start up waiting time out
1:ff7793b:    */
1:473bd31:   private void validateDynamicSchedulerTimeOut() {
1:473bd31:     validateRange(CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT,
1:473bd31:         CarbonCommonConstants.CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT_DEFAULT,
1:473bd31:         CarbonCommonConstants.CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT_MIN,
1:473bd31:         CarbonCommonConstants.CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT_MAX);
1:ff7793b:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:9b8090b:    * Returns configured update deleta files value for IUD compaction
1:cd6a4ff:    *
1:9b8090b:    * @return numberOfDeltaFilesThreshold
1:cd6a4ff:    */
1:0d42f52:   public int getNoUpdateDeltaFilesThresholdForIUDCompaction() {
1:0d42f52:     int numberOfDeltaFilesThreshold;
1:ff7793b:     try {
1:0d42f52:       numberOfDeltaFilesThreshold = Integer.parseInt(
1:0d42f52:           getProperty(CarbonCommonConstants.UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION,
1:0d42f52:               CarbonCommonConstants.DEFAULT_UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION));
1:cd6a4ff: 
1:0d42f52:       if (numberOfDeltaFilesThreshold < 0 || numberOfDeltaFilesThreshold > 10000) {
1:877eabd:         LOGGER.warn("The specified value for property "
2:0d42f52:             + CarbonCommonConstants.UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION
3:0d42f52:             + "is incorrect."
1:0d42f52:             + " Correct value should be in range of 0 -10000. Taking the default value.");
1:0d42f52:         numberOfDeltaFilesThreshold = Integer.parseInt(
1:0d42f52:             CarbonCommonConstants.DEFAULT_UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION);
1:cd6a4ff:       }
1:cd6a4ff:     } catch (NumberFormatException e) {
1:877eabd:       LOGGER.warn("The specified value for property "
1:2cf1104:           + CarbonCommonConstants.UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION + "is incorrect."
1:0d42f52:           + " Correct value should be in range of 0 -10000. Taking the default value.");
1:0d42f52:       numberOfDeltaFilesThreshold = Integer
1:0d42f52:           .parseInt(CarbonCommonConstants.DEFAULT_UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION);
1:cd6a4ff:     }
1:0d42f52:     return numberOfDeltaFilesThreshold;
1:a51ad30:   }
1:39644b5: 
1:39644b5:   /**
1:9b8090b:    * Returns configured delete deleta files value for IUD compaction
1:2cf1104:    *
1:9b8090b:    * @return numberOfDeltaFilesThreshold
1:cd6a4ff:    */
1:0d42f52:   public int getNoDeleteDeltaFilesThresholdForIUDCompaction() {
1:0d42f52:     int numberOfDeltaFilesThreshold;
1:0f407de:     try {
1:0d42f52:       numberOfDeltaFilesThreshold = Integer.parseInt(
1:0d42f52:           getProperty(CarbonCommonConstants.DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION,
1:0d42f52:               CarbonCommonConstants.DEFAULT_DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION));
1:cd6a4ff: 
1:0d42f52:       if (numberOfDeltaFilesThreshold < 0 || numberOfDeltaFilesThreshold > 10000) {
1:877eabd:         LOGGER.warn("The specified value for property "
2:0d42f52:             + CarbonCommonConstants.DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION
1:0d42f52:             + "is incorrect."
1:0d42f52:             + " Correct value should be in range of 0 -10000. Taking the default value.");
1:0d42f52:         numberOfDeltaFilesThreshold = Integer.parseInt(
1:0d42f52:             CarbonCommonConstants.DEFAULT_DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION);
1:a51ad30:       }
1:0f407de:     } catch (NumberFormatException e) {
1:877eabd:       LOGGER.warn("The specified value for property "
1:2cf1104:           + CarbonCommonConstants.DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION + "is incorrect."
1:0d42f52:           + " Correct value should be in range of 0 -10000. Taking the default value.");
1:0d42f52:       numberOfDeltaFilesThreshold = Integer
1:0d42f52:           .parseInt(CarbonCommonConstants.DEFAULT_DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION);
1:a51ad30:     }
1:0d42f52:     return numberOfDeltaFilesThreshold;
1:694ee77:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:ded8b41:    * Returns whether to use multi temp dirs
1:ded8b41:    * @return boolean
1:cd6a4ff:    */
1:ded8b41:   public boolean isUseMultiTempDir() {
1:ded8b41:     String usingMultiDirStr = getProperty(CarbonCommonConstants.CARBON_USE_MULTI_TEMP_DIR,
1:ded8b41:         CarbonCommonConstants.CARBON_USE_MULTI_TEMP_DIR_DEFAULT);
1:ded8b41:     boolean validateBoolean = CarbonUtil.validateBoolean(usingMultiDirStr);
1:1a35cfb:     if (!validateBoolean) {
1:877eabd:       LOGGER.warn("The carbon.use.multiple.temp.dir configuration value is invalid."
1:ded8b41:           + "Configured value: \"" + usingMultiDirStr + "\"."
1:ded8b41:           + "Data Load will not use multiple temp directories.");
1:ded8b41:       usingMultiDirStr = CarbonCommonConstants.CARBON_USE_MULTI_TEMP_DIR_DEFAULT;
1:694ee77:     }
1:ded8b41:     return usingMultiDirStr.equalsIgnoreCase("true");
1:0f407de:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:0be69cd:    * Return valid storage level
1:181f0ac:    * @return String
1:181f0ac:    */
1:0be69cd:   public String getGlobalSortRddStorageLevel() {
1:0be69cd:     String storageLevel = getProperty(CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL,
1:0be69cd:         CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL_DEFAULT);
1:0be69cd:     boolean validateStorageLevel = CarbonUtil.isValidStorageLevel(storageLevel);
1:0be69cd:     if (!validateStorageLevel) {
1:877eabd:       LOGGER.warn("The " + CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL
1:0be69cd:           + " configuration value is invalid. It will use default storage level("
1:0be69cd:           + CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL_DEFAULT
1:0be69cd:           + ") to persist rdd.");
1:0be69cd:       storageLevel = CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL_DEFAULT;
1:0be69cd:     }
1:0be69cd:     return storageLevel.toUpperCase();
1:0be69cd:   }
1:8cb37dd: 
1:8cb37dd:   /**
1:2ee7775:    * Returns parallelism for segment update
1:2ee7775:    * @return int
1:cd6a4ff:    */
1:2ee7775:   public int getParallelismForSegmentUpdate() {
1:2ee7775:     int parallelism = Integer.parseInt(
1:2ee7775:         CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM_DEFAULT);
1:2ee7775:     boolean isInvalidValue = false;
1:0f407de:     try {
1:2ee7775:       String strParallelism = getProperty(CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM,
1:2ee7775:           CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM_DEFAULT);
1:2ee7775:       parallelism = Integer.parseInt(strParallelism);
1:2ee7775:       if (parallelism <= 0 || parallelism > 1000) {
1:2ee7775:         isInvalidValue = true;
1:0f407de:       }
1:c5aba5f:     } catch (NumberFormatException e) {
1:2ee7775:       isInvalidValue = true;
1:0f407de:     }
1:0be69cd: 
1:2ee7775:     if (isInvalidValue) {
1:877eabd:       LOGGER.warn("The specified value for property "
1:2ee7775:           + CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM
1:2ee7775:           + " is incorrect. Correct value should be in range of 0 - 1000."
1:2ee7775:           + " Taking the default value: "
1:2ee7775:           + CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM_DEFAULT);
1:2ee7775:       parallelism = Integer.parseInt(
1:2ee7775:           CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM_DEFAULT);
1:0f407de:     }
1:cd6a4ff: 
1:2ee7775:     return parallelism;
1:0f407de:   }
1:a51ad30: 
1:0be69cd:   /**
1:0ab928e:    * Return valid CARBON_UPDATE_STORAGE_LEVEL
1:0ab928e:    * @return boolean
1:0ab928e:    */
1:0ab928e:   public boolean isPersistUpdateDataset() {
1:0ab928e:     String isPersistEnabled = getProperty(CarbonCommonConstants.isPersistEnabled,
1:0ab928e:             CarbonCommonConstants.defaultValueIsPersistEnabled);
1:0ab928e:     boolean validatePersistEnabled = CarbonUtil.validateBoolean(isPersistEnabled);
1:0ab928e:     if (!validatePersistEnabled) {
1:877eabd:       LOGGER.warn("The " + CarbonCommonConstants.isPersistEnabled
1:0ab928e:           + " configuration value is invalid. It will use default value("
1:0ab928e:           + CarbonCommonConstants.defaultValueIsPersistEnabled
1:0ab928e:           + ").");
1:0ab928e:       isPersistEnabled = CarbonCommonConstants.defaultValueIsPersistEnabled;
1:0ab928e:     }
1:0ab928e:     return isPersistEnabled.equalsIgnoreCase("true");
1:0ab928e:   }
1:0ab928e: 
1:0ab928e:   /**
1:0ab928e:    * Return valid storage level for CARBON_UPDATE_STORAGE_LEVEL
1:0ab928e:    * @return String
1:0ab928e:    */
1:0ab928e:   public String getUpdateDatasetStorageLevel() {
1:0ab928e:     String storageLevel = getProperty(CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL,
1:0ab928e:         CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL_DEFAULT);
1:0ab928e:     boolean validateStorageLevel = CarbonUtil.isValidStorageLevel(storageLevel);
1:0ab928e:     if (!validateStorageLevel) {
1:877eabd:       LOGGER.warn("The " + CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL
1:0ab928e:           + " configuration value is invalid. It will use default storage level("
1:0ab928e:           + CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL_DEFAULT
1:0ab928e:           + ") to persist dataset.");
1:0ab928e:       storageLevel = CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL_DEFAULT;
1:0ab928e:     }
1:0ab928e:     return storageLevel.toUpperCase();
1:0ab928e:   }
1:0ab928e: 
1:0ab928e:   /**
1:c100251:    * get compressor name for compressing sort temp files
1:c100251:    * @return compressor name
1:c100251:    */
1:c100251:   public String getSortTempCompressor() {
1:c100251:     String compressor = getProperty(CarbonCommonConstants.CARBON_SORT_TEMP_COMPRESSOR,
1:c100251:         CarbonCommonConstants.CARBON_SORT_TEMP_COMPRESSOR_DEFAULT).toUpperCase();
1:c100251:     if (compressor.isEmpty() || "SNAPPY".equals(compressor) || "GZIP".equals(compressor)
1:ece0672:         || "BZIP2".equals(compressor) || "LZ4".equals(compressor) || "ZSTD".equals(compressor)) {
1:c100251:       return compressor;
1:c100251:     } else {
1:877eabd:       LOGGER.warn("The ".concat(CarbonCommonConstants.CARBON_SORT_TEMP_COMPRESSOR)
1:ece0672:           .concat(" configuration value is invalid. Only snappy, gzip, bip2, lz4, zstd and")
1:c100251:           .concat(" empty are allowed. It will not compress the sort temp files by default"));
1:c100251:       return CarbonCommonConstants.CARBON_SORT_TEMP_COMPRESSOR_DEFAULT;
1:0f407de:     }
1:c5aba5f:   }
1:a51ad30: 
1:cd6a4ff:   /**
1:9a423c2:    * whether optimization for skewed data is enabled
1:9a423c2:    * @return true, if enabled; false for not enabled.
1:9a423c2:    */
1:9a423c2:   public boolean isLoadSkewedDataOptimizationEnabled() {
1:9a423c2:     String skewedEnabled = getProperty(
1:9a423c2:         CarbonLoadOptionConstants.ENABLE_CARBON_LOAD_SKEWED_DATA_OPTIMIZATION,
1:9a423c2:         CarbonLoadOptionConstants.ENABLE_CARBON_LOAD_SKEWED_DATA_OPTIMIZATION_DEFAULT);
1:9a423c2:     return skewedEnabled.equalsIgnoreCase("true");
1:c5aba5f:   }
1:685087e: 
1:685087e:   /**
1:685087e:    * whether optimization for the node loads the minimum amount of data is enabled
1:685087e:    * @return true, if enabled; false for not enabled.
1:685087e:    */
1:685087e:   public boolean isLoadMinSizeOptimizationEnabled() {
1:685087e:     String loadMinSize = getProperty(
1:685087e:             CarbonLoadOptionConstants.ENABLE_CARBON_LOAD_NODE_DATA_MIN_SIZE,
1:685087e:             CarbonLoadOptionConstants.ENABLE_CARBON_LOAD_NODE_DATA_MIN_SIZE_DEFAULT);
1:685087e:     return loadMinSize.equalsIgnoreCase("true");
1:685087e:   }
1:685087e: 
1:cd6a4ff:   /**
1:39644b5:    * returns true if carbon property
1:39644b5:    * @param key
1:39644b5:    * @return
1:39644b5:    */
1:39644b5:   public boolean isCarbonProperty(String key) {
1:39644b5:     return propertySet.contains(key);
1:39644b5:   }
1:1462495: 
1:1462495:   public Map<String, String> getAddedProperty() {
1:1462495:     return addedProperty;
1:1462495:   }
1:25c2824: 
1:34cb551:   /**
1:34cb551:    * to add external property
1:34cb551:    *
1:34cb551:    * @param externalPropertySet
1:34cb551:    */
1:34cb551:   public void addPropertyToPropertySet(Set<String> externalPropertySet) {
1:34cb551:     propertySet.addAll(externalPropertySet);
1:34cb551:   }
1:694ee77: 
1:27ec651:   private void validateSortMemorySizeInMB() {
1:c5aba5f:     try {
1:54dcd8d:       int unsafeSortStorageMemoryString = Integer.parseInt(carbonProperties
1:54dcd8d:           .getProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB));
2:27ec651:       carbonProperties.setProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB,
1:54dcd8d:           unsafeSortStorageMemoryString + "");
1:54dcd8d:     } catch (NumberFormatException ne) {
1:54dcd8d:       LOGGER.warn("The specified value for property "
1:54dcd8d:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB + "is invalid.");
1:ff7793b:     }
1:ff7793b:   }
1:ff7793b: 
1:27ec651:   private void validateWorkingMemory() {
1:2ee7775:     try {
1:54dcd8d:       int unsafeWorkingMemory = Integer.parseInt(
1:27ec651:           carbonProperties.getProperty(CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB));
1:54dcd8d:       carbonProperties
1:54dcd8d:           .setProperty(CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB, unsafeWorkingMemory + "");
1:2ee7775:     } catch (NumberFormatException e) {
1:877eabd:       LOGGER.warn("The specified value for property "
1:54dcd8d:           + CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB_DEFAULT + "is invalid.");
1:c5aba5f:     }
1:9a423c2:   }
1:0f407de: 
1:27ec651:   private void validateSortStorageMemory() {
1:27ec651:     int unsafeSortStorageMemoryDefault =
1:27ec651:         Integer.parseInt(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB_DEFAULT);
1:27ec651:     int unsafeSortStorageMemory = 0;
3:27ec651:     try {
1:27ec651:       unsafeSortStorageMemory = Integer.parseInt(carbonProperties
1:27ec651:           .getProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB));
3:27ec651:     } catch (NumberFormatException e) {
2:877eabd:       LOGGER.warn("The specified value for property "
1:27ec651:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB + "is invalid."
2:27ec651:           + " Taking the default value."
1:27ec651:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB_DEFAULT);
1:27ec651:       unsafeSortStorageMemory = unsafeSortStorageMemoryDefault;
1:c100251:     }
1:27ec651:     if (unsafeSortStorageMemory < unsafeSortStorageMemoryDefault) {
1:877eabd:       LOGGER.warn("The specified value for property "
1:27ec651:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB
1:27ec651:           + "is less than the default value." + " Taking the default value."
1:27ec651:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB_DEFAULT);
1:27ec651:       unsafeSortStorageMemory = unsafeSortStorageMemoryDefault;
1:c100251:     }
1:27ec651:     carbonProperties.setProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB,
1:27ec651:         unsafeSortStorageMemory + "");
4:2ee7775:   }
1:0f407de: 
1:d5bec4d:   private void validateEnableQueryStatistics() {
1:d5bec4d:     String enableQueryStatistics = carbonProperties.getProperty(
1:d5bec4d:         CarbonCommonConstants.ENABLE_QUERY_STATISTICS,
1:d5bec4d:         CarbonCommonConstants.ENABLE_QUERY_STATISTICS_DEFAULT);
1:d5bec4d:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(enableQueryStatistics);
1:d5bec4d:     if (!isValidBooleanValue) {
1:d5bec4d:       LOGGER.warn("The enable query statistics value \"" + enableQueryStatistics
1:cd6a4ff:           + "\" is invalid. Using the default value \""
1:d5bec4d:           + CarbonCommonConstants.ENABLE_QUERY_STATISTICS_DEFAULT);
1:d5bec4d:       carbonProperties.setProperty(CarbonCommonConstants.ENABLE_QUERY_STATISTICS,
1:d5bec4d:           CarbonCommonConstants.ENABLE_QUERY_STATISTICS_DEFAULT);
1:d5bec4d:     }
1:d5bec4d:   }
1:d5bec4d: 
1:d5bec4d:   public boolean isEnableQueryStatistics() {
1:d5bec4d:     String enableQueryStatistics = carbonProperties.getProperty(
1:d5bec4d:         CarbonCommonConstants.ENABLE_QUERY_STATISTICS,
1:d5bec4d:         CarbonCommonConstants.ENABLE_QUERY_STATISTICS_DEFAULT);
1:d5bec4d:     return enableQueryStatistics.equalsIgnoreCase("true");
1:d5bec4d:   }
1:d5bec4d: 
1:cd6a4ff:   /**
1:d0858b7:    * Get the heap memory pooling threshold bytes.
1:d0858b7:    */
1:d0858b7:   public int getHeapMemoryPoolingThresholdBytes() {
1:d0858b7:     int thresholdSize;
1:d0858b7:     try {
1:d0858b7:       thresholdSize = Integer.parseInt(CarbonProperties.getInstance()
1:d0858b7:           .getProperty(CarbonCommonConstants.CARBON_HEAP_MEMORY_POOLING_THRESHOLD_BYTES,
1:d0858b7:               CarbonCommonConstants.CARBON_HEAP_MEMORY_POOLING_THRESHOLD_BYTES_DEFAULT));
1:d0858b7:     } catch (NumberFormatException exc) {
1:877eabd:       LOGGER.warn(
1:d0858b7:           "The heap memory pooling threshold bytes is invalid. Using the default value "
1:72f50b5:           + CarbonCommonConstants.CARBON_HEAP_MEMORY_POOLING_THRESHOLD_BYTES_DEFAULT);
1:d0858b7:       thresholdSize = Integer.parseInt(
1:d0858b7:           CarbonCommonConstants.CARBON_HEAP_MEMORY_POOLING_THRESHOLD_BYTES_DEFAULT);
1:d0858b7:     }
1:d0858b7:     return thresholdSize;
1:d0858b7:   }
1:d0858b7: 
1:9a423c2:   /**
1:0609fc5:    * Get the number of hours the segment lock files will be preserved.
1:0609fc5:    * It will be converted to microseconds to return.
1:0609fc5:    */
1:0609fc5:   public long getSegmentLockFilesPreserveHours() {
1:0609fc5:     long preserveSeconds;
1:0609fc5:     try {
1:0609fc5:       int preserveHours = Integer.parseInt(CarbonProperties.getInstance()
1:0609fc5:           .getProperty(CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS,
1:0609fc5:               CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS_DEFAULT));
1:0609fc5:       preserveSeconds = preserveHours * 3600 * 1000L;
1:0609fc5:     } catch (NumberFormatException exc) {
1:877eabd:       LOGGER.warn(
1:72f50b5:           "The value of '" + CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS
1:72f50b5:           + "' is invalid. Using the default value "
1:72f50b5:           + CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS_DEFAULT);
1:0609fc5:       preserveSeconds = Integer.parseInt(
1:0609fc5:           CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS_DEFAULT) * 3600 * 1000L;
1:0609fc5:     }
1:0609fc5:     return preserveSeconds;
1:0609fc5:   }
1:72f50b5: 
1:72f50b5:   /**
1:72f50b5:    * Get the number of invisible segment info which will be preserved in tablestatus file.
1:72f50b5:    */
1:72f50b5:   public int getInvisibleSegmentPreserveCount() {
1:72f50b5:     int preserveCnt;
1:72f50b5:     try {
1:72f50b5:       preserveCnt = Integer.parseInt(CarbonProperties.getInstance()
1:72f50b5:           .getProperty(CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT,
1:72f50b5:               CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT_DEFAULT));
1:72f50b5:     } catch (NumberFormatException exc) {
1:877eabd:       LOGGER.warn(
1:72f50b5:           "The value of '" + CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT
1:72f50b5:           + "' is invalid. Using the default value "
1:72f50b5:           + CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT_DEFAULT);
1:72f50b5:       preserveCnt = Integer.parseInt(
1:72f50b5:           CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT_DEFAULT);
1:72f50b5:     }
1:72f50b5:     return preserveCnt;
1:72f50b5:   }
1:05086e5:   /**
1:05086e5:    * Get the configured system folder location.
1:05086e5:    * @return
1:05086e5:    */
1:05086e5:   public String getSystemFolderLocation() {
1:05086e5:     String systemLocation = CarbonProperties.getInstance()
1:05086e5:         .getProperty(CarbonCommonConstants.CARBON_SYSTEM_FOLDER_LOCATION);
1:05086e5:     if (systemLocation == null) {
1:05086e5:       systemLocation = getStorePath();
1:05086e5:     }
1:fc8510a:     if (systemLocation != null) {
1:fc8510a:       systemLocation = CarbonUtil.checkAndAppendFileSystemURIScheme(systemLocation);
1:fc8510a:       systemLocation = FileFactory.getUpdatedFilePath(systemLocation);
1:fc8510a:     }
1:05086e5:     return systemLocation + CarbonCommonConstants.FILE_SEPARATOR + "_system";
1:05086e5:   }
1:05086e5: 
1:3ff574d:   /**
1:3ff574d:    * Return true if search mode is enabled
1:3ff574d:    */
1:3ff574d:   public static boolean isSearchModeEnabled() {
1:3ff574d:     String value = getInstance().getProperty(
1:3ff574d:         CarbonCommonConstants.CARBON_SEARCH_MODE_ENABLE,
1:3ff574d:         CarbonCommonConstants.CARBON_SEARCH_MODE_ENABLE_DEFAULT);
1:3ff574d:     return Boolean.valueOf(value);
1:3ff574d:   }
1:3ff574d: 
1:3ff574d:   public static void enableSearchMode(boolean enable) {
1:3ff574d:     getInstance().addProperty(
1:3ff574d:         CarbonCommonConstants.CARBON_SEARCH_MODE_ENABLE, String.valueOf(enable));
1:3ff574d:   }
1:3ff574d: 
1:3ff574d:   public static int getSearchMasterPort() {
1:3ff574d:     try {
1:3ff574d:       return Integer.parseInt(
1:3ff574d:           getInstance().getProperty(
1:3ff574d:               CarbonCommonConstants.CARBON_SEARCH_MODE_MASTER_PORT,
1:3ff574d:               CarbonCommonConstants.CARBON_SEARCH_MODE_MASTER_PORT_DEFAULT));
1:3ff574d:     } catch (NumberFormatException e) {
1:3ff574d:       return Integer.parseInt(CarbonCommonConstants.CARBON_SEARCH_MODE_MASTER_PORT_DEFAULT);
1:3ff574d:     }
1:3ff574d:   }
1:3ff574d: 
1:3ff574d:   public static int getSearchWorkerPort() {
1:3ff574d:     try {
1:3ff574d:       return Integer.parseInt(
1:3ff574d:           getInstance().getProperty(
1:3ff574d:               CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_PORT,
1:3ff574d:               CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_PORT_DEFAULT));
1:3ff574d:     } catch (NumberFormatException e) {
1:3ff574d:       return Integer.parseInt(CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_PORT_DEFAULT);
1:3ff574d:     }
1:3ff574d:   }
1:2f85381: 
1:2f85381:   public static int getMaxWorkloadForWorker(int workerCores) {
1:2f85381:     int defaultValue = workerCores * 10;
1:2f85381:     try {
1:2f85381:       return Integer.parseInt(
1:2f85381:           getInstance().getProperty(
1:2f85381:               CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_WORKLOAD_LIMIT,
1:2f85381:               String.valueOf(defaultValue)));
1:2f85381:     } catch (NumberFormatException e) {
1:2f85381:       return defaultValue;
1:2f85381:     }
1:2f85381:   }
1:c5aba5f: 
1:c100251:   /**
1:8cb37dd:    * Return valid storage level for CARBON_INSERT_STORAGE_LEVEL
1:8cb37dd:    * @return String
1:8cb37dd:    */
1:181f0ac:   public String getInsertIntoDatasetStorageLevel() {
1:181f0ac:     String storageLevel = getProperty(CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL,
1:181f0ac:         CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL_DEFAULT);
1:181f0ac:     boolean validateStorageLevel = CarbonUtil.isValidStorageLevel(storageLevel);
1:181f0ac:     if (!validateStorageLevel) {
1:181f0ac:       LOGGER.warn("The " + CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL
1:181f0ac:           + " configuration value is invalid. It will use default storage level("
1:181f0ac:           + CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL_DEFAULT
1:181f0ac:           + ") to persist dataset.");
1:181f0ac:       storageLevel = CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL_DEFAULT;
1:8cb37dd:     }
1:181f0ac:     return storageLevel.toUpperCase();
1:181f0ac:   }
1:c5aba5f: 
1:2ee7775:   /**
1:181f0ac:    * Return valid storage level for CARBON_INSERT_STORAGE_LEVEL
1:0be69cd:    * @return String
1:2ee7775:    */
1:8cb37dd:   public int getSortMemorySpillPercentage() {
1:8cb37dd:     int spillPercentage = 0;
1:8cb37dd:     try {
1:8cb37dd:       String spillPercentageStr = getProperty(
1:8cb37dd:           CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE,
1:8cb37dd:           CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:8cb37dd:       spillPercentage = Integer.parseInt(spillPercentageStr);
1:8cb37dd:     } catch (NumberFormatException e) {
1:8cb37dd:       spillPercentage = Integer.parseInt(
1:8cb37dd:           CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:8cb37dd:     }
1:8cb37dd:     return spillPercentage;
1:8cb37dd:   }
1:8cb37dd: 
1:8cb37dd:   private void validateSortMemorySpillPercentage() {
1:8cb37dd:     String spillPercentageStr = carbonProperties.getProperty(
1:8cb37dd:         CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE,
1:8cb37dd:         CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:8cb37dd: 
1:8cb37dd:     try {
1:8cb37dd:       int spillPercentage = Integer.parseInt(spillPercentageStr);
1:8cb37dd:       if (spillPercentage > 100 || spillPercentage < 0) {
1:8cb37dd:         LOGGER.info(
1:8cb37dd:             "The sort memory spill percentage value \"" + spillPercentageStr +
1:8cb37dd:                 "\" is invalid. Using the default value \""
1:8cb37dd:                 + CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:8cb37dd:         carbonProperties.setProperty(
1:8cb37dd:             CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE,
1:8cb37dd:             CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:8cb37dd:       }
1:8cb37dd:     } catch (NumberFormatException e) {
1:8cb37dd:       LOGGER.info(
1:8cb37dd:           "The sort memory spill percentage value \"" + spillPercentageStr +
1:8cb37dd:               "\" is invalid. Using the default value \""
1:8cb37dd:               + CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:8cb37dd:       carbonProperties.setProperty(
1:8cb37dd:           CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE,
1:8cb37dd:           CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:8cb37dd:     }
1:181f0ac:   }
1:cd6a4ff: }
============================================================================
author:manishgupta88
-------------------------------------------------------------------------------
commit:54dcd8d
/////////////////////////////////////////////////////////////////////////
1:       int unsafeSortStorageMemoryString = Integer.parseInt(carbonProperties
1:           .getProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB));
1:           unsafeSortStorageMemoryString + "");
1:     } catch (NumberFormatException ne) {
1:       LOGGER.warn("The specified value for property "
1:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB + "is invalid.");
1:       int unsafeWorkingMemory = Integer.parseInt(
1:       carbonProperties
1:           .setProperty(CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB, unsafeWorkingMemory + "");
1:           + CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB_DEFAULT + "is invalid.");
commit:83aae94
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ff7793b
/////////////////////////////////////////////////////////////////////////
0:     validateExecutorStartUpTime();
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * This method will validate and set the value for executor start up waiting time out
1:    */
0:   private void validateExecutorStartUpTime() {
0:     int executorStartUpTimeOut = 0;
1:     try {
0:       executorStartUpTimeOut = Integer.parseInt(carbonProperties
0:           .getProperty(CarbonCommonConstants.CARBON_EXECUTOR_STARTUP_TIMEOUT,
0:               CarbonCommonConstants.CARBON_EXECUTOR_WAITING_TIMEOUT_DEFAULT));
0:       // If value configured by user is more than max value of time out then consider the max value
0:       if (executorStartUpTimeOut > CarbonCommonConstants.CARBON_EXECUTOR_WAITING_TIMEOUT_MAX) {
0:         executorStartUpTimeOut = CarbonCommonConstants.CARBON_EXECUTOR_WAITING_TIMEOUT_MAX;
1:       }
0:     } catch (NumberFormatException ne) {
0:       executorStartUpTimeOut =
0:           Integer.parseInt(CarbonCommonConstants.CARBON_EXECUTOR_WAITING_TIMEOUT_DEFAULT);
1:     }
0:     carbonProperties.setProperty(CarbonCommonConstants.CARBON_EXECUTOR_STARTUP_TIMEOUT,
0:         String.valueOf(executorStartUpTimeOut));
0:     LOGGER.info("Executor start up wait time: " + executorStartUpTimeOut);
1:   }
1: 
author:Raghunandan S
-------------------------------------------------------------------------------
commit:67a8a37
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:kunal642
-------------------------------------------------------------------------------
commit:2a9604c
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1:   private Map<String, String> addedProperty = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
1:     Configuration configuration = FileFactory.getConfiguration();
author:akashrn5
-------------------------------------------------------------------------------
commit:7843845
/////////////////////////////////////////////////////////////////////////
1:    * This method will be used to add a new property which need not be serialized
1:    *
1:    * @param key
1:    */
1:   public void addNonSerializableProperty(String key, String value) {
1:     carbonProperties.setProperty(key, value);
1:   }
1: 
1:   /**
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:fc8510a
/////////////////////////////////////////////////////////////////////////
1:     if (systemLocation != null) {
1:       systemLocation = CarbonUtil.checkAndAppendFileSystemURIScheme(systemLocation);
1:       systemLocation = FileFactory.getUpdatedFilePath(systemLocation);
1:     }
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:bea277f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.impl.FileFactory;
/////////////////////////////////////////////////////////////////////////
0:     systemLocation = CarbonUtil.checkAndAppendFileSystemURIScheme(systemLocation);
0:     systemLocation = FileFactory.getUpdatedFilePath(systemLocation);
commit:473bd31
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.BLOCKLET_SIZE;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_CUSTOM_BLOCK_DISTRIBUTION;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_DATA_FILE_VERSION;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_DATE_FORMAT;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MAX;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MIN;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SORT_FILE_WRITE_BUFFER_SIZE;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_BLOCK;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_BLOCKLET;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_CUSTOM;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_MERGE_FILES;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CSV_READ_BUFFER_SIZE;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_AUTO_HANDOFF;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_UNSAFE_SORT;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_VECTOR_READER;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.HANDOFF_SIZE;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.LOCK_TYPE;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.NUM_CORES;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.NUM_CORES_BLOCK_SORT;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.SORT_INTERMEDIATE_FILES_LIMIT;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.SORT_SIZE;
/////////////////////////////////////////////////////////////////////////
1:       case CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT:
1:         validateDynamicSchedulerTimeOut();
/////////////////////////////////////////////////////////////////////////
1:       case CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO:
1:         validateSchedulerMinRegisteredRatio();
1:         break;
/////////////////////////////////////////////////////////////////////////
1:     validateDynamicSchedulerTimeOut();
/////////////////////////////////////////////////////////////////////////
1:     validateSchedulerMinRegisteredRatio();
/////////////////////////////////////////////////////////////////////////
1:    * minimum required registered resource for starting block distribution
1:    */
1:   private void validateSchedulerMinRegisteredRatio() {
1:     String value = carbonProperties
1:         .getProperty(CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO,
1:             CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:     try {
1:       double minRegisteredResourceRatio = java.lang.Double.parseDouble(value);
1:       if (minRegisteredResourceRatio < CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MIN
1:           || minRegisteredResourceRatio > CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MAX) {
1:         LOGGER.warn("The value \"" + value
1:             + "\" configured for key " + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO
1:             + "\" is not in range. Valid range is (byte) \""
1:             + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MIN + " to \""
1:             + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_MAX + ". Using the default value \""
1:             + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:         carbonProperties.setProperty(CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO,
1:             CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:       }
1:     } catch (NumberFormatException e) {
1:       LOGGER.warn("The value \"" + value
1:           + "\" configured for key " + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO
1:           + "\" is invalid. Using the default value \""
1:           + CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:       carbonProperties.setProperty(CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO,
1:           CARBON_SCHEDULER_MIN_REGISTERED_RESOURCES_RATIO_DEFAULT);
1:     }
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:   private void validateDynamicSchedulerTimeOut() {
1:     validateRange(CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT,
1:         CarbonCommonConstants.CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT_DEFAULT,
1:         CarbonCommonConstants.CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT_MIN,
1:         CarbonCommonConstants.CARBON_DYNAMIC_ALLOCATION_SCHEDULER_TIMEOUT_MAX);
commit:bcf3ca3
/////////////////////////////////////////////////////////////////////////
1: import java.text.SimpleDateFormat;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.BLOCKLET_SIZE;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_COMBINE_SMALL_INPUT_FILES;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_CUSTOM_BLOCK_DISTRIBUTION;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_DATA_FILE_VERSION;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_DATE_FORMAT;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_EXECUTOR_STARTUP_TIMEOUT;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SORT_FILE_WRITE_BUFFER_SIZE;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CSV_READ_BUFFER_SIZE;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_AUTO_HANDOFF;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_UNSAFE_SORT;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_VECTOR_READER;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.HANDOFF_SIZE;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.LOCK_TYPE;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.NUM_CORES;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.NUM_CORES_BLOCK_SORT;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.SORT_INTERMEDIATE_FILES_LIMIT;
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.SORT_SIZE;
1: import static org.apache.carbondata.core.constants.CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB;
1: import static org.apache.carbondata.core.constants.CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO;
/////////////////////////////////////////////////////////////////////////
1:    * This method is to validate only a specific key added to carbonProperties using addProperty
1:    *
1:    * @param key
1:    */
1:   private void validateAndLoadDefaultProperties(String key) {
1:     switch (key) {
1:       case BLOCKLET_SIZE:
1:         validateBlockletSize();
1:         break;
0:       case NUM_CORES:
0:         validateNumCores();
1:         break;
0:       case NUM_CORES_BLOCK_SORT:
0:         validateNumCoresBlockSort();
1:         break;
1:       case SORT_SIZE:
1:         validateSortSize();
1:         break;
1:       case CARBON_DATA_FILE_VERSION:
1:         validateCarbonDataFileVersion();
1:         break;
0:       case CARBON_EXECUTOR_STARTUP_TIMEOUT:
0:         validateExecutorStartUpTime();
1:         break;
1:       case CARBON_PREFETCH_BUFFERSIZE:
1:         validatePrefetchBufferSize();
1:         break;
1:       case BLOCKLET_SIZE_IN_MB:
1:         validateBlockletGroupSizeInMB();
1:         break;
1:       case NUMBER_OF_COLUMN_TO_READ_IN_IO:
1:         validateNumberOfColumnPerIORead();
1:         break;
1:       case ENABLE_UNSAFE_SORT:
1:         validateEnableUnsafeSort();
1:         break;
1:       case CARBON_CUSTOM_BLOCK_DISTRIBUTION:
1:         validateCustomBlockDistribution();
1:         break;
1:       case ENABLE_VECTOR_READER:
1:         validateEnableVectorReader();
1:         break;
1:       case CSV_READ_BUFFER_SIZE:
1:         validateCarbonCSVReadBufferSizeByte();
1:         break;
1:       case HANDOFF_SIZE:
1:         validateHandoffSize();
1:         break;
0:       case CARBON_COMBINE_SMALL_INPUT_FILES:
0:         validateCombineSmallInputFiles();
1:         break;
1:       // The method validate the validity of configured carbon.timestamp.format value
1:       // and reset to default value if validation fail
1:       case CARBON_TIMESTAMP_FORMAT:
1:         validateTimeFormatKey(CARBON_TIMESTAMP_FORMAT,
1:             CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:         break;
1:       // The method validate the validity of configured carbon.date.format value
1:       // and reset to default value if validation fail
1:       case CARBON_DATE_FORMAT:
1:         validateTimeFormatKey(CARBON_DATE_FORMAT, CarbonCommonConstants.CARBON_DATE_DEFAULT_FORMAT);
1:         break;
1:       case CARBON_SORT_FILE_WRITE_BUFFER_SIZE:
1:         validateSortFileWriteBufferSize();
1:         break;
1:       case SORT_INTERMEDIATE_FILES_LIMIT:
1:         validateSortIntermediateFilesLimit();
1:         break;
1:       case ENABLE_AUTO_HANDOFF:
1:         validateHandoffSize();
1:         break;
1:       // TODO : Validation for carbon.lock.type should be handled for addProperty flow
1:       default:
1:         // none
1:     }
1:   }
1:   /**
/////////////////////////////////////////////////////////////////////////
1:     // The method validate the validity of configured carbon.timestamp.format value
1:     // and reset to default value if validation fail
1:     validateTimeFormatKey(CARBON_TIMESTAMP_FORMAT,
1:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:     // The method validate the validity of configured carbon.date.format value
1:     // and reset to default value if validation fail
1:     validateTimeFormatKey(CARBON_DATE_FORMAT,
1:         CarbonCommonConstants.CARBON_DATE_DEFAULT_FORMAT);
1:     validateSortFileWriteBufferSize();
1:     validateSortIntermediateFilesLimit();
1:   /**
1:    * Sort intermediate file size validation and if not valid then reset to the default value
1:    */
1:   private void validateSortIntermediateFilesLimit() {
1:     validateRange(SORT_INTERMEDIATE_FILES_LIMIT,
1:         CarbonCommonConstants.SORT_INTERMEDIATE_FILES_LIMIT_DEFAULT_VALUE,
1:         CarbonCommonConstants.SORT_INTERMEDIATE_FILES_LIMIT_MIN,
1:         CarbonCommonConstants.SORT_INTERMEDIATE_FILES_LIMIT_MAX);
1:   }
1: 
1:   /**
1:    *
1:    * @param key
1:    * @param defaultValue default value for the given key
1:    * @param minValue Minimum value for the given key
1:    * @param maxValue Max value for the given key
1:    */
1:   private void validateRange(String key, String defaultValue, int minValue, int maxValue) {
1:     String fileBufferSize = carbonProperties
1:         .getProperty(key, defaultValue);
1:     if (null != fileBufferSize) {
1:         int bufferSize = Integer.parseInt(fileBufferSize);
1: 
1:         if (bufferSize < minValue
1:             || bufferSize > maxValue) {
1:           LOGGER.warn("The value \"" + fileBufferSize + "\" configured for key "
1:               + key
1:               + minValue + " to \""
1:               + maxValue +
1:               ". Using the default value \""
1:               + defaultValue);
1:           carbonProperties.setProperty(key,
1:               defaultValue);
1:         LOGGER.warn("The value \"" + fileBufferSize + "\" configured for key "
1:             + key
1:             + defaultValue);
1:         carbonProperties.setProperty(key,
1:             defaultValue);
1:   /**
1:    * validate carbon.sort.file.write.buffer.size and if not valid then reset to the default value
1:    */
1:   private void validateSortFileWriteBufferSize() {
1:     validateRange(CARBON_SORT_FILE_WRITE_BUFFER_SIZE,
1:         CarbonCommonConstants.CARBON_SORT_FILE_WRITE_BUFFER_SIZE_DEFAULT_VALUE,
1:         CarbonCommonConstants.CARBON_SORT_FILE_WRITE_BUFFER_SIZE_MIN,
1:         CarbonCommonConstants.CARBON_SORT_FILE_WRITE_BUFFER_SIZE_MAX);
1:   }
1: 
1:   /**
1:    * The method validate the validity of configured carbon.date.format value
1:    * and reset to default value if validation fail
1:    */
1:   private void validateTimeFormatKey(String key, String defaultValue) {
1:     String dateFormat = carbonProperties
1:         .getProperty(key, defaultValue);
1:     try {
1:       new SimpleDateFormat(dateFormat);
1:     } catch (Exception e) {
1:       LOGGER.warn("The value \"" + dateFormat + "\" configured for key "
1:           + key
1:           + "\" is invalid. Using the default value \""
1:           + key);
1:       carbonProperties.setProperty(key, defaultValue);
1:     }
1:   }
1: 
1:   /**
1:    * The method value csv read buffer size and if not valid then reset to the default value
1:    */
1:   private void validateCarbonCSVReadBufferSizeByte() {
1:     validateRange(CSV_READ_BUFFER_SIZE,
1:         CarbonCommonConstants.CSV_READ_BUFFER_SIZE_DEFAULT,
1:         CarbonCommonConstants.CSV_READ_BUFFER_SIZE_MIN,
1:         CarbonCommonConstants.CSV_READ_BUFFER_SIZE_MAX);
1:   }
1: 
1:         .getProperty(LOCK_TYPE, CarbonCommonConstants.LOCK_TYPE_DEFAULT);
/////////////////////////////////////////////////////////////////////////
1:           + LOCK_TYPE + " is invalid for current file system. "
1:       carbonProperties.setProperty(LOCK_TYPE,
1:       carbonProperties.setProperty(LOCK_TYPE,
1:           + LOCK_TYPE + " is invalid for current file system. "
1:         carbonProperties.getProperty(ENABLE_VECTOR_READER);
1:       carbonProperties.setProperty(ENABLE_VECTOR_READER,
1:         carbonProperties.getProperty(CARBON_CUSTOM_BLOCK_DISTRIBUTION);
0:       carbonProperties.setProperty(CARBON_CUSTOM_BLOCK_DISTRIBUTION,
0:         carbonProperties.getProperty(CARBON_COMBINE_SMALL_INPUT_FILES);
0:       carbonProperties.setProperty(CARBON_COMBINE_SMALL_INPUT_FILES,
1:     String unSafeSortStr = carbonProperties.getProperty(ENABLE_UNSAFE_SORT);
1:       carbonProperties.setProperty(ENABLE_UNSAFE_SORT,
/////////////////////////////////////////////////////////////////////////
1:         carbonProperties.getProperty(CARBON_PREFETCH_BUFFERSIZE);
1:       carbonProperties.setProperty(CARBON_PREFETCH_BUFFERSIZE,
/////////////////////////////////////////////////////////////////////////
1:         carbonProperties.setProperty(CARBON_PREFETCH_BUFFERSIZE,
1:     String handoffSizeStr = carbonProperties.getProperty(HANDOFF_SIZE);
1:       carbonProperties.setProperty(HANDOFF_SIZE,
/////////////////////////////////////////////////////////////////////////
1:           carbonProperties.setProperty(HANDOFF_SIZE,
1:         carbonProperties.setProperty(HANDOFF_SIZE,
/////////////////////////////////////////////////////////////////////////
1:         carbonProperties.getProperty(ENABLE_AUTO_HANDOFF);
1:       carbonProperties.setProperty(ENABLE_AUTO_HANDOFF,
/////////////////////////////////////////////////////////////////////////
1:         .getProperty(BLOCKLET_SIZE_IN_MB,
/////////////////////////////////////////////////////////////////////////
1:         carbonProperties.setProperty(BLOCKLET_SIZE_IN_MB,
1:       carbonProperties.setProperty(BLOCKLET_SIZE_IN_MB,
1:         .getProperty(BLOCKLET_SIZE_IN_MB,
/////////////////////////////////////////////////////////////////////////
1:         .getProperty(NUMBER_OF_COLUMN_TO_READ_IN_IO,
/////////////////////////////////////////////////////////////////////////
1:         carbonProperties.setProperty(NUMBER_OF_COLUMN_TO_READ_IN_IO,
1:       carbonProperties.setProperty(NUMBER_OF_COLUMN_TO_READ_IN_IO,
/////////////////////////////////////////////////////////////////////////
1:     String blockletSizeStr = carbonProperties.getProperty(BLOCKLET_SIZE,
/////////////////////////////////////////////////////////////////////////
1:         carbonProperties.setProperty(BLOCKLET_SIZE,
1:       carbonProperties.setProperty(BLOCKLET_SIZE,
/////////////////////////////////////////////////////////////////////////
0:         .getProperty(NUM_CORES, CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
/////////////////////////////////////////////////////////////////////////
0:         carbonProperties.setProperty(NUM_CORES,
0:       carbonProperties.setProperty(NUM_CORES,
/////////////////////////////////////////////////////////////////////////
0:     String numCoresStr = carbonProperties.getProperty(NUM_CORES_BLOCK_SORT,
/////////////////////////////////////////////////////////////////////////
0:         carbonProperties.setProperty(NUM_CORES_BLOCK_SORT,
0:       carbonProperties.setProperty(NUM_CORES_BLOCK_SORT,
/////////////////////////////////////////////////////////////////////////
1:         .getProperty(SORT_SIZE, CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
/////////////////////////////////////////////////////////////////////////
1:         carbonProperties.setProperty(SORT_SIZE,
1:       carbonProperties.setProperty(SORT_SIZE,
/////////////////////////////////////////////////////////////////////////
1:         carbonProperties.getProperty(CARBON_DATA_FILE_VERSION);
1:       carbonProperties.setProperty(CARBON_DATA_FILE_VERSION,
/////////////////////////////////////////////////////////////////////////
1:         carbonProperties.setProperty(CARBON_DATA_FILE_VERSION,
1:         .setProperty(CARBON_DATA_FILE_VERSION,
/////////////////////////////////////////////////////////////////////////
1:     try {
1:       initPropertySet();
1:     } catch (IllegalAccessException e) {
1:       LOGGER.error("Illegal access to declared field" + e.getMessage());
1:     }
/////////////////////////////////////////////////////////////////////////
1:     // the method will validate the added property
1:     // if the added property is not valid then will reset to default value.
1:     validateAndLoadDefaultProperties(key.toLowerCase());
/////////////////////////////////////////////////////////////////////////
1:     String versionStr = getInstance().getProperty(CARBON_DATA_FILE_VERSION);
/////////////////////////////////////////////////////////////////////////
1:               HANDOFF_SIZE,
/////////////////////////////////////////////////////////////////////////
1:         ENABLE_AUTO_HANDOFF,
/////////////////////////////////////////////////////////////////////////
0:           .getProperty(CARBON_EXECUTOR_STARTUP_TIMEOUT,
/////////////////////////////////////////////////////////////////////////
0:     carbonProperties.setProperty(CARBON_EXECUTOR_STARTUP_TIMEOUT,
commit:1a35cfb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.hadoop.conf.Configuration;
1: 
/////////////////////////////////////////////////////////////////////////
1:     validateEnableUnsafeSort();
1:     validateCustomBlockDistribution();
1:     validateEnableVectorReader();
1:     validateLockType();
1:     validateCarbonCSVReadBufferSizeByte();
1:   }
1: 
0:   private void validateCarbonCSVReadBufferSizeByte() {
0:     String csvReadBufferSizeStr =
0:         carbonProperties.getProperty(CarbonCommonConstants.CSV_READ_BUFFER_SIZE);
0:     if (null != csvReadBufferSizeStr) {
1:       try {
0:         int bufferSize = Integer.parseInt(csvReadBufferSizeStr);
0:         if (bufferSize < CarbonCommonConstants.CSV_READ_BUFFER_SIZE_MIN
0:             || bufferSize > CarbonCommonConstants.CSV_READ_BUFFER_SIZE_MAX) {
0:           LOGGER.warn("The value \"" + csvReadBufferSizeStr + "\" configured for key "
0:               + CarbonCommonConstants.CSV_READ_BUFFER_SIZE
1:               + "\" is not in range. Valid range is (byte) \""
0:               + CarbonCommonConstants.CSV_READ_BUFFER_SIZE_MIN + " to \""
0:               + CarbonCommonConstants.CSV_READ_BUFFER_SIZE_MAX + ". Using the default value \""
0:               + CarbonCommonConstants.CSV_READ_BUFFER_SIZE_DEFAULT);
0:           carbonProperties.setProperty(CarbonCommonConstants.CSV_READ_BUFFER_SIZE,
0:               CarbonCommonConstants.CSV_READ_BUFFER_SIZE_DEFAULT);
1:         }
1:       } catch (NumberFormatException nfe) {
0:         LOGGER.warn("The value \"" + csvReadBufferSizeStr + "\" configured for key "
0:             + CarbonCommonConstants.CSV_READ_BUFFER_SIZE
1:             + "\" is invalid. Using the default value \""
0:             + CarbonCommonConstants.CSV_READ_BUFFER_SIZE_DEFAULT);
0:         carbonProperties.setProperty(CarbonCommonConstants.CSV_READ_BUFFER_SIZE,
0:             CarbonCommonConstants.CSV_READ_BUFFER_SIZE_DEFAULT);
1:       }
1:     }
1:   }
1: 
1:   private void validateLockType() {
0:     String lockTypeConfigured = carbonProperties.getProperty(CarbonCommonConstants.LOCK_TYPE);
0:     if (null != lockTypeConfigured) {
1:       switch (lockTypeConfigured.toUpperCase()) {
1:         // if user is setting the lock type as CARBON_LOCK_TYPE_ZOOKEEPER then no need to validate
1:         // else validate based on the file system type for LOCAL file system lock will be
1:         // CARBON_LOCK_TYPE_LOCAL and for the distributed one CARBON_LOCK_TYPE_HDFS
1:         case CarbonCommonConstants.CARBON_LOCK_TYPE_ZOOKEEPER:
1:           break;
1:         case CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL:
1:         case CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS:
1:         default:
1:           validateAndConfigureLockType(lockTypeConfigured);
1:       }
1:     } else {
1:       validateAndConfigureLockType(lockTypeConfigured);
1:     }
1:   }
1: 
1:   /**
1:    * the method decide and set the lock type based on the configured system type
1:    *
1:    * @param lockTypeConfigured
1:    */
1:   private void validateAndConfigureLockType(String lockTypeConfigured) {
0:     Configuration configuration = new Configuration(true);
1:     String defaultFs = configuration.get("fs.defaultFS");
1:     if (null != defaultFs && (defaultFs.startsWith(CarbonCommonConstants.HDFSURL_PREFIX)
1:         || defaultFs.startsWith(CarbonCommonConstants.VIEWFSURL_PREFIX) || defaultFs
0:         .startsWith(CarbonCommonConstants.ALLUXIOURL_PREFIX))
1:         && !CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS.equalsIgnoreCase(lockTypeConfigured)) {
1:       LOGGER.warn("The value \"" + lockTypeConfigured + "\" configured for key "
0:           + CarbonCommonConstants.LOCK_TYPE + "\" is invalid. Using the default value \""
0:           + CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS);
0:       carbonProperties.setProperty(CarbonCommonConstants.LOCK_TYPE,
1:           CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS);
1:     } else if (null != defaultFs && defaultFs.startsWith(CarbonCommonConstants.LOCAL_FILE_PREFIX)
1:         && !CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL.equalsIgnoreCase(lockTypeConfigured)) {
0:       carbonProperties.setProperty(CarbonCommonConstants.LOCK_TYPE,
1:           CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL);
1:       LOGGER.warn("The value \"" + lockTypeConfigured + "\" configured for key "
0:           + CarbonCommonConstants.LOCK_TYPE
1:           + "\" is invalid. Using the default value \""
0:           + CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL);
1:     }
1:   }
1: 
1:   private void validateEnableVectorReader() {
1:     String vectorReaderStr =
0:         carbonProperties.getProperty(CarbonCommonConstants.ENABLE_VECTOR_READER);
1:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(vectorReaderStr);
1:     if (!isValidBooleanValue) {
1:       LOGGER.warn("The enable vector reader value \"" + vectorReaderStr
1:           + "\" is invalid. Using the default value \""
1:           + CarbonCommonConstants.ENABLE_VECTOR_READER_DEFAULT);
0:       carbonProperties.setProperty(CarbonCommonConstants.ENABLE_VECTOR_READER,
1:           CarbonCommonConstants.ENABLE_VECTOR_READER_DEFAULT);
1:     }
1:   }
1: 
1:   private void validateCustomBlockDistribution() {
1:     String customBlockDistributionStr =
0:         carbonProperties.getProperty(CarbonCommonConstants.CARBON_CUSTOM_BLOCK_DISTRIBUTION);
1:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(customBlockDistributionStr);
1:     if (!isValidBooleanValue) {
1:       LOGGER.warn("The custom block distribution value \"" + customBlockDistributionStr
1:           + "\" is invalid. Using the default value \""
0:           + CarbonCommonConstants.CARBON_CUSTOM_BLOCK_DISTRIBUTION_DEFAULT);
0:       carbonProperties.setProperty(CarbonCommonConstants.CARBON_CUSTOM_BLOCK_DISTRIBUTION,
0:           CarbonCommonConstants.CARBON_CUSTOM_BLOCK_DISTRIBUTION_DEFAULT);
1:     }
1:   }
1: 
1:   private void validateEnableUnsafeSort() {
0:     String unSafeSortStr = carbonProperties.getProperty(CarbonCommonConstants.ENABLE_UNSAFE_SORT);
1:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(unSafeSortStr);
1:     if (!isValidBooleanValue) {
1:       LOGGER.warn("The enable unsafe sort value \"" + unSafeSortStr
1:           + "\" is invalid. Using the default value \""
1:           + CarbonCommonConstants.ENABLE_UNSAFE_SORT_DEFAULT);
0:       carbonProperties.setProperty(CarbonCommonConstants.ENABLE_UNSAFE_SORT,
1:           CarbonCommonConstants.ENABLE_UNSAFE_SORT_DEFAULT);
1:     }
/////////////////////////////////////////////////////////////////////////
0:     String highcardIdentifyStr =
0:         carbonProperties.getProperty(CarbonCommonConstants.HIGH_CARDINALITY_IDENTIFY_ENABLE);
0:     boolean validateBoolean = CarbonUtil.validateBoolean(highcardIdentifyStr);
1:     if (!validateBoolean) {
commit:39644b5
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Field;
1: import java.util.HashSet;
1: import java.util.Set;
1: import org.apache.carbondata.core.constants.CarbonLoadOptionConstants;
/////////////////////////////////////////////////////////////////////////
1:   private Set<String> propertySet = new HashSet<String>();
/////////////////////////////////////////////////////////////////////////
1:     try {
0:       initPropertySet();
0:     } catch (IllegalAccessException e) {
0:       LOGGER.error("Illelagal access to declared field" + e.getMessage());
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private void initPropertySet() throws IllegalAccessException {
1:     Field[] declaredFields = CarbonCommonConstants.class.getDeclaredFields();
1:     for (Field field : declaredFields) {
1:       if (field.isAnnotationPresent(CarbonProperty.class)) {
1:         propertySet.add(field.get(field.getName()).toString());
1:       }
1:     }
1:     declaredFields = CarbonV3DataFormatConstants.class.getDeclaredFields();
1:     for (Field field : declaredFields) {
1:       if (field.isAnnotationPresent(CarbonProperty.class)) {
1:         propertySet.add(field.get(field.getName()).toString());
1:       }
1:     }
1:     declaredFields = CarbonLoadOptionConstants.class.getDeclaredFields();
1:     for (Field field : declaredFields) {
1:       if (field.isAnnotationPresent(CarbonProperty.class)) {
1:         propertySet.add(field.get(field.getName()).toString());
1:       }
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // get the property value from session parameters,
1:     // if its null then get value from carbonProperties
1:     String sessionPropertyValue = getSessionPropertyValue(key);
1:     if (null != sessionPropertyValue) {
1:       return sessionPropertyValue;
1:     }
/////////////////////////////////////////////////////////////////////////
1:    * returns session property value
1:    *
1:    * @param key
1:    * @return
1:    */
1:   private String getSessionPropertyValue(String key) {
1:     String value = null;
1:     CarbonSessionInfo carbonSessionInfo = ThreadLocalSessionInfo.getCarbonSessionInfo();
1:     if (null != carbonSessionInfo) {
1:       SessionParams sessionParams =
1:           ThreadLocalSessionInfo.getCarbonSessionInfo().getSessionParams();
1:       if (null != sessionParams) {
1:         value = sessionParams.getProperty(key);
1:       }
1:     }
1:     return value;
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * returns true if carbon property
1:    * @param key
1:    * @return
1:    */
1:   public boolean isCarbonProperty(String key) {
1:     return propertySet.contains(key);
1:   }
author:sraghunandan
-------------------------------------------------------------------------------
commit:f911403
/////////////////////////////////////////////////////////////////////////
commit:500654e
/////////////////////////////////////////////////////////////////////////
1:     String lockTypeConfigured = carbonProperties
0:         .getProperty(CarbonCommonConstants.LOCK_TYPE, CarbonCommonConstants.LOCK_TYPE_DEFAULT);
0:     switch (lockTypeConfigured.toUpperCase()) {
0:       // if user is setting the lock type as CARBON_LOCK_TYPE_ZOOKEEPER then no need to validate
0:       // else validate based on the file system type for LOCAL file system lock will be
0:       // CARBON_LOCK_TYPE_LOCAL and for the distributed one CARBON_LOCK_TYPE_HDFS
0:       case CarbonCommonConstants.CARBON_LOCK_TYPE_ZOOKEEPER:
1:         break;
0:       case CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL:
0:       case CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS:
0:       default:
0:         validateAndConfigureLockType(lockTypeConfigured);
commit:002279e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
0: import org.apache.carbondata.core.carbon.ColumnarFormatVersion;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: 
author:ndwangsen
-------------------------------------------------------------------------------
commit:8cb37dd
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.carbondata.core.constants.CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE;
/////////////////////////////////////////////////////////////////////////
1:       case CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE:
1:         validateSortMemorySpillPercentage();
1:         break;
/////////////////////////////////////////////////////////////////////////
1:     validateSortMemorySpillPercentage();
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * Return valid storage level for CARBON_INSERT_STORAGE_LEVEL
1:    * @return String
1:    */
1:   public int getSortMemorySpillPercentage() {
1:     int spillPercentage = 0;
1:     try {
1:       String spillPercentageStr = getProperty(
1:           CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE,
1:           CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:       spillPercentage = Integer.parseInt(spillPercentageStr);
1:     } catch (NumberFormatException e) {
1:       spillPercentage = Integer.parseInt(
1:           CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:     }
1:     return spillPercentage;
1:   }
1: 
1:   private void validateSortMemorySpillPercentage() {
1:     String spillPercentageStr = carbonProperties.getProperty(
1:         CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE,
1:         CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1: 
1:     try {
1:       int spillPercentage = Integer.parseInt(spillPercentageStr);
1:       if (spillPercentage > 100 || spillPercentage < 0) {
1:         LOGGER.info(
1:             "The sort memory spill percentage value \"" + spillPercentageStr +
1:                 "\" is invalid. Using the default value \""
1:                 + CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:         carbonProperties.setProperty(
1:             CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE,
1:             CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:       }
1:     } catch (NumberFormatException e) {
1:       LOGGER.info(
1:           "The sort memory spill percentage value \"" + spillPercentageStr +
1:               "\" is invalid. Using the default value \""
1:               + CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:       carbonProperties.setProperty(
1:           CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE,
1:           CarbonLoadOptionConstants.CARBON_LOAD_SORT_MEMORY_SPILL_PERCENTAGE_DEFAULT);
1:     }
1:   }
commit:685087e
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * whether optimization for the node loads the minimum amount of data is enabled
1:    * @return true, if enabled; false for not enabled.
1:    */
1:   public boolean isLoadMinSizeOptimizationEnabled() {
1:     String loadMinSize = getProperty(
1:             CarbonLoadOptionConstants.ENABLE_CARBON_LOAD_NODE_DATA_MIN_SIZE,
1:             CarbonLoadOptionConstants.ENABLE_CARBON_LOAD_NODE_DATA_MIN_SIZE_DEFAULT);
1:     return loadMinSize.equalsIgnoreCase("true");
1:   }
1: 
author:Manhua
-------------------------------------------------------------------------------
commit:ece0672
/////////////////////////////////////////////////////////////////////////
1:         || "BZIP2".equals(compressor) || "LZ4".equals(compressor) || "ZSTD".equals(compressor)) {
1:           .concat(" configuration value is invalid. Only snappy, gzip, bip2, lz4, zstd and")
author:Zhang Zhichao
-------------------------------------------------------------------------------
commit:181f0ac
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * Return valid storage level for CARBON_INSERT_STORAGE_LEVEL
1:    * @return String
1:    */
1:   public String getInsertIntoDatasetStorageLevel() {
1:     String storageLevel = getProperty(CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL,
1:         CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL_DEFAULT);
1:     boolean validateStorageLevel = CarbonUtil.isValidStorageLevel(storageLevel);
1:     if (!validateStorageLevel) {
1:       LOGGER.warn("The " + CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL
1:           + " configuration value is invalid. It will use default storage level("
1:           + CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL_DEFAULT
1:           + ") to persist dataset.");
1:       storageLevel = CarbonCommonConstants.CARBON_INSERT_STORAGE_LEVEL_DEFAULT;
1:     }
1:     return storageLevel.toUpperCase();
1:   }
commit:72f50b5
/////////////////////////////////////////////////////////////////////////
1:           + CarbonCommonConstants.CARBON_HEAP_MEMORY_POOLING_THRESHOLD_BYTES_DEFAULT);
/////////////////////////////////////////////////////////////////////////
1:           "The value of '" + CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS
1:           + "' is invalid. Using the default value "
1:           + CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS_DEFAULT);
1: 
1:   /**
1:    * Get the number of invisible segment info which will be preserved in tablestatus file.
1:    */
1:   public int getInvisibleSegmentPreserveCount() {
1:     int preserveCnt;
1:     try {
1:       preserveCnt = Integer.parseInt(CarbonProperties.getInstance()
1:           .getProperty(CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT,
1:               CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT_DEFAULT));
1:     } catch (NumberFormatException exc) {
1:       LOGGER.error(
1:           "The value of '" + CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT
1:           + "' is invalid. Using the default value "
1:           + CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT_DEFAULT);
1:       preserveCnt = Integer.parseInt(
1:           CarbonCommonConstants.CARBON_INVISIBLE_SEGMENTS_PRESERVE_COUNT_DEFAULT);
1:     }
1:     return preserveCnt;
1:   }
commit:0609fc5
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Get the number of hours the segment lock files will be preserved.
1:    * It will be converted to microseconds to return.
1:    */
1:   public long getSegmentLockFilesPreserveHours() {
1:     long preserveSeconds;
1:     try {
1:       int preserveHours = Integer.parseInt(CarbonProperties.getInstance()
1:           .getProperty(CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS,
1:               CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS_DEFAULT));
1:       preserveSeconds = preserveHours * 3600 * 1000L;
1:     } catch (NumberFormatException exc) {
1:       LOGGER.error(
0:           "The segment lock files preserv hours is invalid. Using the default value "
0:               + CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS_DEFAULT);
1:       preserveSeconds = Integer.parseInt(
1:           CarbonCommonConstants.CARBON_SEGMENT_LOCK_FILES_PRESERVE_HOURS_DEFAULT) * 3600 * 1000L;
1:     }
1:     return preserveSeconds;
1:   }
commit:d0858b7
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Get the heap memory pooling threshold bytes.
1:    */
1:   public int getHeapMemoryPoolingThresholdBytes() {
1:     int thresholdSize;
1:     try {
1:       thresholdSize = Integer.parseInt(CarbonProperties.getInstance()
1:           .getProperty(CarbonCommonConstants.CARBON_HEAP_MEMORY_POOLING_THRESHOLD_BYTES,
1:               CarbonCommonConstants.CARBON_HEAP_MEMORY_POOLING_THRESHOLD_BYTES_DEFAULT));
1:     } catch (NumberFormatException exc) {
0:       LOGGER.error(
1:           "The heap memory pooling threshold bytes is invalid. Using the default value "
0:               + CarbonCommonConstants.CARBON_HEAP_MEMORY_POOLING_THRESHOLD_BYTES_DEFAULT);
1:       thresholdSize = Integer.parseInt(
1:           CarbonCommonConstants.CARBON_HEAP_MEMORY_POOLING_THRESHOLD_BYTES_DEFAULT);
1:     }
1:     return thresholdSize;
1:   }
1: 
commit:9e9d689
/////////////////////////////////////////////////////////////////////////
0:           .getProperty(CarbonCommonConstants.NUM_CORES_LOADING));
0:       LOGGER.error("Configured value for property " + CarbonCommonConstants.NUM_CORES_LOADING
1:           + " is wrong. Falling back to the default value "
1:           + CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
commit:0ab928e
/////////////////////////////////////////////////////////////////////////
1:    * Return valid CARBON_UPDATE_STORAGE_LEVEL
1:    * @return boolean
1:    */
1:   public boolean isPersistUpdateDataset() {
1:     String isPersistEnabled = getProperty(CarbonCommonConstants.isPersistEnabled,
1:             CarbonCommonConstants.defaultValueIsPersistEnabled);
1:     boolean validatePersistEnabled = CarbonUtil.validateBoolean(isPersistEnabled);
1:     if (!validatePersistEnabled) {
0:       LOGGER.error("The " + CarbonCommonConstants.isPersistEnabled
1:           + " configuration value is invalid. It will use default value("
1:           + CarbonCommonConstants.defaultValueIsPersistEnabled
1:           + ").");
1:       isPersistEnabled = CarbonCommonConstants.defaultValueIsPersistEnabled;
1:     }
1:     return isPersistEnabled.equalsIgnoreCase("true");
1:   }
1: 
1:   /**
1:    * Return valid storage level for CARBON_UPDATE_STORAGE_LEVEL
1:    * @return String
1:    */
1:   public String getUpdateDatasetStorageLevel() {
1:     String storageLevel = getProperty(CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL,
1:         CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL_DEFAULT);
1:     boolean validateStorageLevel = CarbonUtil.isValidStorageLevel(storageLevel);
1:     if (!validateStorageLevel) {
0:       LOGGER.error("The " + CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL
1:           + " configuration value is invalid. It will use default storage level("
1:           + CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL_DEFAULT
1:           + ") to persist dataset.");
1:       storageLevel = CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL_DEFAULT;
1:     }
1:     return storageLevel.toUpperCase();
1:   }
1: 
1:   /**
commit:0be69cd
/////////////////////////////////////////////////////////////////////////
0:       LOGGER.error("The carbon.use.multiple.temp.dir configuration value is invalid."
/////////////////////////////////////////////////////////////////////////
1:    * Return valid storage level
1:    * @return String
1:    */
1:   public String getGlobalSortRddStorageLevel() {
1:     String storageLevel = getProperty(CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL,
1:         CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL_DEFAULT);
1:     boolean validateStorageLevel = CarbonUtil.isValidStorageLevel(storageLevel);
1:     if (!validateStorageLevel) {
0:       LOGGER.error("The " + CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL
1:           + " configuration value is invalid. It will use default storage level("
1:           + CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL_DEFAULT
1:           + ") to persist rdd.");
1:       storageLevel = CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL_DEFAULT;
1:     }
1:     return storageLevel.toUpperCase();
1:   }
1: 
1:   /**
author:xubo245
-------------------------------------------------------------------------------
commit:d8bafa3
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.ENABLE_OFFHEAP_SORT;
/////////////////////////////////////////////////////////////////////////
1:       case ENABLE_OFFHEAP_SORT:
1:         validateEnableOffHeapSort();
0:         break;
/////////////////////////////////////////////////////////////////////////
1:     validateEnableOffHeapSort();
/////////////////////////////////////////////////////////////////////////
1:   private void validateEnableOffHeapSort() {
1:     String value = carbonProperties.getProperty(ENABLE_OFFHEAP_SORT);
1:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(value);
1:     if (!isValidBooleanValue) {
1:       LOGGER.warn("The enable off heap sort value \"" + value
1:           + "\" is invalid. Using the default value \""
1:           + CarbonCommonConstants.ENABLE_OFFHEAP_SORT_DEFAULT);
1:       carbonProperties.setProperty(ENABLE_OFFHEAP_SORT,
1:           CarbonCommonConstants.ENABLE_OFFHEAP_SORT_DEFAULT);
1:     }
1:   }
1: 
commit:9326cfd
/////////////////////////////////////////////////////////////////////////
1:    * @return corrected value of unmerged segments to be merged
/////////////////////////////////////////////////////////////////////////
1:    * Separating the count for Number of segments to be merged in levels by comma
1:    *
1:    * @param commaSeparatedLevels the string format value before separating
1:    * @return the int array format value after separating by comma
/////////////////////////////////////////////////////////////////////////
1:    * @param actual the actual value for minor compaction
1:    * @param max max value for minor compaction
1:    * @param min min value for minor compaction
1:    * @param defaultVal default value when the actual is improper
1:    * @return  corrected Value after validating
author:Jacky Li
-------------------------------------------------------------------------------
commit:2f85381
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SEARCH_MODE_SCAN_THREAD;
1: import static org.apache.carbondata.core.constants.CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_WORKLOAD_LIMIT;
/////////////////////////////////////////////////////////////////////////
1:       case CARBON_SEARCH_MODE_SCAN_THREAD:
1:         validatePositiveInteger(CARBON_SEARCH_MODE_SCAN_THREAD);
0:         break;
1:       case CARBON_SEARCH_MODE_WORKER_WORKLOAD_LIMIT:
1:         validatePositiveInteger(CARBON_SEARCH_MODE_WORKER_WORKLOAD_LIMIT);
0:         break;
1: 
1:   /**
1:    * Validate the specified property is positive integer value
1:    */
1:   private void validatePositiveInteger(String propertyName) {
1:     String value = getInstance().getProperty(propertyName);
1:     try {
1:       int intValue = Integer.parseInt(value);
1:       if (intValue <= 0) {
1:         getInstance().removeProperty(propertyName);
1:         LOGGER.warn(String.format("The value \"%s\" configured for key \"%s\" " +
1:             "is invalid. Ignoring it", value, propertyName));
1:         throw new IllegalArgumentException();
1:       }
1:     } catch (NumberFormatException e) {
1:       getInstance().removeProperty(propertyName);
1:       LOGGER.warn(String.format("The value \"%s\" configured for key \"%s\" " +
1:           "is invalid. Ignoring it", value, propertyName));
1:       throw e;
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Remove the specified key in property
1:    */
1:   public CarbonProperties removeProperty(String key) {
1:     carbonProperties.remove(key);
1:     addedProperty.remove(key);
1:     return this;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:   public static int getMaxWorkloadForWorker(int workerCores) {
1:     int defaultValue = workerCores * 10;
1:     try {
1:       return Integer.parseInt(
1:           getInstance().getProperty(
1:               CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_WORKLOAD_LIMIT,
1:               String.valueOf(defaultValue)));
1:     } catch (NumberFormatException e) {
1:       return defaultValue;
1:     }
1:   }
commit:3ff574d
/////////////////////////////////////////////////////////////////////////
1:   public boolean isEnableVectorReader() {
1:     return getInstance().getProperty(CarbonCommonConstants.ENABLE_VECTOR_READER,
1:         CarbonCommonConstants.ENABLE_VECTOR_READER_DEFAULT).equalsIgnoreCase("true");
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Return true if search mode is enabled
1:    */
1:   public static boolean isSearchModeEnabled() {
1:     String value = getInstance().getProperty(
1:         CarbonCommonConstants.CARBON_SEARCH_MODE_ENABLE,
1:         CarbonCommonConstants.CARBON_SEARCH_MODE_ENABLE_DEFAULT);
1:     return Boolean.valueOf(value);
1:   }
1: 
1:   public static void enableSearchMode(boolean enable) {
1:     getInstance().addProperty(
1:         CarbonCommonConstants.CARBON_SEARCH_MODE_ENABLE, String.valueOf(enable));
1:   }
1: 
1:   public static int getSearchMasterPort() {
1:     try {
1:       return Integer.parseInt(
1:           getInstance().getProperty(
1:               CarbonCommonConstants.CARBON_SEARCH_MODE_MASTER_PORT,
1:               CarbonCommonConstants.CARBON_SEARCH_MODE_MASTER_PORT_DEFAULT));
1:     } catch (NumberFormatException e) {
1:       return Integer.parseInt(CarbonCommonConstants.CARBON_SEARCH_MODE_MASTER_PORT_DEFAULT);
1:     }
1:   }
1: 
1:   public static int getSearchWorkerPort() {
1:     try {
1:       return Integer.parseInt(
1:           getInstance().getProperty(
1:               CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_PORT,
1:               CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_PORT_DEFAULT));
1:     } catch (NumberFormatException e) {
1:       return Integer.parseInt(CarbonCommonConstants.CARBON_SEARCH_MODE_WORKER_PORT_DEFAULT);
1:     }
1:   }
commit:873c3de
/////////////////////////////////////////////////////////////////////////
1:       numberOfCores = Integer.parseInt(
1:           CarbonProperties.getInstance().getProperty(
1:               CarbonCommonConstants.NUM_CORES_LOADING,
1:               CarbonCommonConstants.NUM_CORES_DEFAULT_VAL));
commit:25c2824
/////////////////////////////////////////////////////////////////////////
1: 
commit:5fc7f06
/////////////////////////////////////////////////////////////////////////
1:    * Return the store path
1:    */
1:   public static String getStorePath() {
1:     return getInstance().getProperty(CarbonCommonConstants.STORE_LOCATION);
1:   }
1: 
1:   /**
author:rahulforallp
-------------------------------------------------------------------------------
commit:877eabd
/////////////////////////////////////////////////////////////////////////
1:         LOGGER.warn("The specified value for property "
/////////////////////////////////////////////////////////////////////////
1:         LOGGER.warn(
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("Configured value for property " + CarbonCommonConstants.NUM_CORES_LOADING
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("Problem in parsing the sort memory chunk size, setting with default value"
1:       LOGGER.warn(
1:       LOGGER.warn(
/////////////////////////////////////////////////////////////////////////
1:         LOGGER.warn("The specified value for property "
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The specified value for property "
/////////////////////////////////////////////////////////////////////////
1:         LOGGER.warn("The specified value for property "
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The specified value for property "
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The carbon.use.multiple.temp.dir configuration value is invalid."
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The " + CarbonCommonConstants.CARBON_GLOBAL_SORT_RDD_STORAGE_LEVEL
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The specified value for property "
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The " + CarbonCommonConstants.isPersistEnabled
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The " + CarbonCommonConstants.CARBON_UPDATE_STORAGE_LEVEL
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The ".concat(CarbonCommonConstants.CARBON_SORT_TEMP_COMPRESSOR)
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn(
1:       LOGGER.warn(
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The specified value for property "
1:       LOGGER.warn("The specified value for property "
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn("The specified value for property "
1:       LOGGER.warn("The specified value for property "
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.warn(
/////////////////////////////////////////////////////////////////////////
0:       LOGGER.warn(
/////////////////////////////////////////////////////////////////////////
0:       LOGGER.warn(
commit:34cb551
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * to add external property
1:    *
1:    * @param externalPropertySet
1:    */
1:   public void addPropertyToPropertySet(Set<String> externalPropertySet) {
1:     propertySet.addAll(externalPropertySet);
1:   }
author:ravipesala
-------------------------------------------------------------------------------
commit:05086e5
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Get the configured system folder location.
1:    * @return
1:    */
1:   public String getSystemFolderLocation() {
1:     String systemLocation = CarbonProperties.getInstance()
1:         .getProperty(CarbonCommonConstants.CARBON_SYSTEM_FOLDER_LOCATION);
1:     if (systemLocation == null) {
1:       systemLocation = getStorePath();
1:     }
1:     return systemLocation + CarbonCommonConstants.FILE_SEPARATOR + "_system";
1:   }
1: 
commit:b4dc866
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.carbondata.core.constants.CarbonCommonConstants.*;
/////////////////////////////////////////////////////////////////////////
1:       case CARBON_TASK_DISTRIBUTION:
1:         validateCarbonTaskDistribution();
/////////////////////////////////////////////////////////////////////////
1:     validateCarbonTaskDistribution();
/////////////////////////////////////////////////////////////////////////
1:           + false);
1:       carbonProperties.setProperty(CARBON_CUSTOM_BLOCK_DISTRIBUTION, "false");
1:   private void validateCarbonTaskDistribution() {
1:     String carbonTaskDistribution = carbonProperties.getProperty(CARBON_TASK_DISTRIBUTION);
1:     boolean isValid = carbonTaskDistribution != null && (
1:         carbonTaskDistribution.equalsIgnoreCase(CARBON_TASK_DISTRIBUTION_MERGE_FILES)
1:             || carbonTaskDistribution.equalsIgnoreCase(CARBON_TASK_DISTRIBUTION_BLOCKLET)
1:             || carbonTaskDistribution.equalsIgnoreCase(CARBON_TASK_DISTRIBUTION_BLOCK)
1:             || carbonTaskDistribution.equalsIgnoreCase(CARBON_TASK_DISTRIBUTION_CUSTOM));
1:     if (!isValid) {
1:       LOGGER.warn("The carbon task distribution value \"" + carbonTaskDistribution
1:           + CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_DEFAULT);
1:       carbonProperties.setProperty(CARBON_TASK_DISTRIBUTION,
1:           CarbonCommonConstants.CARBON_TASK_DISTRIBUTION_DEFAULT);
commit:1462495
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:    * It is purely for testing
1:    */
0:   private Map<String, String> addedProperty = new HashMap<>();
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:     addedProperty.put(key, value);
/////////////////////////////////////////////////////////////////////////
1: 
1:   public Map<String, String> getAddedProperty() {
1:     return addedProperty;
1:   }
commit:28e2e17
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:    * Added properties on the fly.
1:    */
0:   private Map<String, String> setProperties = new HashMap<>();
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
0:     setProperties.put(key, value);
1:   /**
0:    * Get all the added properties.
1:    * @return
1:    */
0:   public Map<String, String> getAddedProperies() {
0:     return setProperties;
1:   }
1: 
0:   public void setProperties(Map<String, String> newProperties) {
0:     setProperties.putAll(newProperties);
0:     for (Map.Entry<String, String> entry : newProperties.entrySet()) {
0:       carbonProperties.setProperty(entry.getKey(), entry.getValue());
1:     }
1:   }
1: 
commit:013db60
/////////////////////////////////////////////////////////////////////////
1:    * Get the sort chunk memory size
1:    * @return
1:    */
1:   public int getSortMemoryChunkSizeInMB() {
1:     int inMemoryChunkSizeInMB;
1:     try {
1:       inMemoryChunkSizeInMB = Integer.parseInt(CarbonProperties.getInstance()
1:           .getProperty(CarbonCommonConstants.OFFHEAP_SORT_CHUNK_SIZE_IN_MB,
1:               CarbonCommonConstants.OFFHEAP_SORT_CHUNK_SIZE_IN_MB_DEFAULT));
1:     } catch (Exception e) {
1:       inMemoryChunkSizeInMB =
1:           Integer.parseInt(CarbonCommonConstants.OFFHEAP_SORT_CHUNK_SIZE_IN_MB_DEFAULT);
0:       LOGGER.error("Problem in parsing the sort memory chunk size, setting with default value"
1:           + inMemoryChunkSizeInMB);
1:     }
1:     if (inMemoryChunkSizeInMB > 1024) {
1:       inMemoryChunkSizeInMB = 1024;
0:       LOGGER.error(
1:           "It is not recommended to increase the sort memory chunk size more than 1024MB, "
1:               + "so setting the value to "
1:               + inMemoryChunkSizeInMB);
1:     } else if (inMemoryChunkSizeInMB < 1) {
1:       inMemoryChunkSizeInMB = 1;
0:       LOGGER.error(
1:           "It is not recommended to decrease the sort memory chunk size less than 1MB, "
1:               + "so setting the value to "
1:               + inMemoryChunkSizeInMB);
1:     }
1:     return inMemoryChunkSizeInMB;
1:   }
1: 
1:   /**
commit:f63b1ff
/////////////////////////////////////////////////////////////////////////
1:    * Number of cores should be used while loading data.
1:    *
1:    * @return
1:    */
1:   public int getNumberOfCores() {
1:     int numberOfCores;
1:     try {
0:       numberOfCores = Integer.parseInt(CarbonProperties.getInstance()
0:           .getProperty(CarbonCommonConstants.NUM_CORES_LOADING,
0:               CarbonCommonConstants.NUM_CORES_DEFAULT_VAL));
1:     } catch (NumberFormatException exc) {
1:       numberOfCores = Integer.parseInt(CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
1:     }
1:     return numberOfCores;
1:   }
1: 
1:   /**
1:    * Batch size of rows while sending data from one step to another in data loading.
1:    *
1:    * @return
1:    */
1:   public int getBatchSize() {
1:     int batchSize;
1:     try {
1:       batchSize = Integer.parseInt(CarbonProperties.getInstance()
1:           .getProperty(CarbonCommonConstants.DATA_LOAD_BATCH_SIZE,
1:               CarbonCommonConstants.DATA_LOAD_BATCH_SIZE_DEFAULT));
1:     } catch (NumberFormatException exc) {
1:       batchSize = Integer.parseInt(CarbonCommonConstants.DATA_LOAD_BATCH_SIZE_DEFAULT);
1:     }
1:     return batchSize;
1:   }
1: 
1:   /**
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: 
1: package org.apache.carbondata.core.util;
1: 
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileNotFoundException;
1: import java.io.IOException;
1: import java.util.Properties;
1: 
0: import org.apache.carbondata.common.logging.LogService;
0: import org.apache.carbondata.common.logging.LogServiceFactory;
0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: 
1: public final class CarbonProperties {
1:   /**
1:    * Attribute for Carbon LOGGER.
1:    */
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(CarbonProperties.class.getName());
1: 
1:   /**
1:    * class instance.
1:    */
1:   private static final CarbonProperties CARBONPROPERTIESINSTANCE = new CarbonProperties();
1: 
1:   /**
1:    * porpeties .
1:    */
1:   private Properties carbonProperties;
1: 
1:   /**
1:    * Private constructor this will call load properties method to load all the
1:    * carbon properties in memory.
1:    */
1:   private CarbonProperties() {
1:     carbonProperties = new Properties();
1:     loadProperties();
1:     validateAndLoadDefaultProperties();
1:   }
1: 
1:   /**
1:    * This method will be responsible for get this class instance
1:    *
1:    * @return carbon properties instance
1:    */
1:   public static CarbonProperties getInstance() {
1:     return CARBONPROPERTIESINSTANCE;
1:   }
1: 
1:   /**
1:    * This method validates the loaded properties and loads default
1:    * values in case of wrong values.
1:    */
1:   private void validateAndLoadDefaultProperties() {
0:     if (null == carbonProperties.getProperty(CarbonCommonConstants.STORE_LOCATION)) {
0:       carbonProperties.setProperty(CarbonCommonConstants.STORE_LOCATION,
0:           CarbonCommonConstants.STORE_LOCATION_DEFAULT_VAL);
1:     }
1: 
1:     validateBlockletSize();
0:     validateMaxFileSize();
0:     validateNumCores();
0:     validateNumCoresBlockSort();
1:     validateSortSize();
0:     validateBadRecordsLocation();
0:     validateHighCardinalityIdentify();
0:     validateHighCardinalityThreshold();
0:     validateHighCardinalityInRowCountPercentage();
1:   }
1: 
0:   private void validateBadRecordsLocation() {
0:     String badRecordsLocation =
0:         carbonProperties.getProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC);
0:     if (null == badRecordsLocation || badRecordsLocation.length() == 0) {
0:       carbonProperties.setProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
0:           CarbonCommonConstants.CARBON_BADRECORDS_LOC_DEFAULT_VAL);
1:     }
1:   }
1: 
1:   /**
1:    * This method validates the blocklet size
1:    */
1:   private void validateBlockletSize() {
0:     String blockletSizeStr = carbonProperties.getProperty(CarbonCommonConstants.BLOCKLET_SIZE,
1:         CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
1:     try {
1:       int blockletSize = Integer.parseInt(blockletSizeStr);
1: 
1:       if (blockletSize < CarbonCommonConstants.BLOCKLET_SIZE_MIN_VAL
1:           || blockletSize > CarbonCommonConstants.BLOCKLET_SIZE_MAX_VAL) {
1:         LOGGER.info("The blocklet size value \"" + blockletSizeStr
1:                 + "\" is invalid. Using the default value \""
1:                 + CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
0:         carbonProperties.setProperty(CarbonCommonConstants.BLOCKLET_SIZE,
1:             CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
1:       }
1:     } catch (NumberFormatException e) {
1:       LOGGER.info("The blocklet size value \"" + blockletSizeStr
1:               + "\" is invalid. Using the default value \""
1:               + CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
0:       carbonProperties.setProperty(CarbonCommonConstants.BLOCKLET_SIZE,
1:           CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
1:     }
1:   }
1: 
1:   /**
0:    * TODO: This method validates the maximum number of blocklets per file ?
1:    */
0:   private void validateMaxFileSize() {
0:     String maxFileSizeStr = carbonProperties.getProperty(CarbonCommonConstants.MAX_FILE_SIZE,
0:         CarbonCommonConstants.MAX_FILE_SIZE_DEFAULT_VAL);
1:     try {
0:       int maxFileSize = Integer.parseInt(maxFileSizeStr);
1: 
0:       if (maxFileSize < CarbonCommonConstants.MAX_FILE_SIZE_DEFAULT_VAL_MIN_VAL
0:           || maxFileSize > CarbonCommonConstants.MAX_FILE_SIZE_DEFAULT_VAL_MAX_VAL) {
0:         LOGGER.info("The max file size value \"" + maxFileSizeStr
1:                 + "\" is invalid. Using the default value \""
0:                 + CarbonCommonConstants.MAX_FILE_SIZE_DEFAULT_VAL);
0:         carbonProperties.setProperty(CarbonCommonConstants.MAX_FILE_SIZE,
0:             CarbonCommonConstants.MAX_FILE_SIZE_DEFAULT_VAL);
1:       }
1:     } catch (NumberFormatException e) {
0:       LOGGER.info("The max file size value \"" + maxFileSizeStr
1:               + "\" is invalid. Using the default value \""
0:               + CarbonCommonConstants.MAX_FILE_SIZE_DEFAULT_VAL);
1: 
0:       carbonProperties.setProperty(CarbonCommonConstants.MAX_FILE_SIZE,
0:           CarbonCommonConstants.MAX_FILE_SIZE_DEFAULT_VAL);
1:     }
1:   }
1: 
1:   /**
0:    * This method validates the number cores specified
1:    */
0:   private void validateNumCores() {
0:     String numCoresStr = carbonProperties
0:         .getProperty(CarbonCommonConstants.NUM_CORES, CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
1:     try {
0:       int numCores = Integer.parseInt(numCoresStr);
1: 
0:       if (numCores < CarbonCommonConstants.NUM_CORES_MIN_VAL
0:           || numCores > CarbonCommonConstants.NUM_CORES_MAX_VAL) {
0:         LOGGER.info("The num Cores  value \"" + numCoresStr
1:             + "\" is invalid. Using the default value \""
0:             + CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
0:         carbonProperties.setProperty(CarbonCommonConstants.NUM_CORES,
0:             CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
1:       }
1:     } catch (NumberFormatException e) {
0:       LOGGER.info("The num Cores  value \"" + numCoresStr
1:           + "\" is invalid. Using the default value \""
0:           + CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
0:       carbonProperties.setProperty(CarbonCommonConstants.NUM_CORES,
0:           CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
1:     }
1:   }
1: 
1:   /**
0:    * This method validates the number cores specified for mdk block sort
1:    */
0:   private void validateNumCoresBlockSort() {
0:     String numCoresStr = carbonProperties
0:         .getProperty(CarbonCommonConstants.NUM_CORES_BLOCK_SORT,
0:             CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);
1:     try {
0:       int numCores = Integer.parseInt(numCoresStr);
1: 
0:       if (numCores < CarbonCommonConstants.NUM_CORES_BLOCK_SORT_MIN_VAL
0:           || numCores > CarbonCommonConstants.NUM_CORES_BLOCK_SORT_MAX_VAL) {
0:         LOGGER.info("The num cores value \"" + numCoresStr
0:             + "\" for block sort is invalid. Using the default value \""
0:             + CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);
0:         carbonProperties.setProperty(CarbonCommonConstants.NUM_CORES_BLOCK_SORT,
0:             CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);
1:       }
1:     } catch (NumberFormatException e) {
0:       LOGGER.info("The num cores value \"" + numCoresStr
0:           + "\" for block sort is invalid. Using the default value \""
0:           + CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);
0:       carbonProperties.setProperty(CarbonCommonConstants.NUM_CORES_BLOCK_SORT,
0:           CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);
1:     }
1:   }
1: 
1:   /**
1:    * This method validates the sort size
1:    */
1:   private void validateSortSize() {
1:     String sortSizeStr = carbonProperties
0:         .getProperty(CarbonCommonConstants.SORT_SIZE, CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
1:     try {
1:       int sortSize = Integer.parseInt(sortSizeStr);
1: 
1:       if (sortSize < CarbonCommonConstants.SORT_SIZE_MIN_VAL) {
0:         LOGGER.info("The batch size value \"" + sortSizeStr
1:             + "\" is invalid. Using the default value \""
1:             + CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
0:         carbonProperties.setProperty(CarbonCommonConstants.SORT_SIZE,
1:             CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
1:       }
1:     } catch (NumberFormatException e) {
0:       LOGGER.info("The batch size value \"" + sortSizeStr
1:           + "\" is invalid. Using the default value \""
1:           + CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
0:       carbonProperties.setProperty(CarbonCommonConstants.SORT_SIZE,
1:           CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
1:     }
1:   }
1: 
0:   private void validateHighCardinalityIdentify() {
0:     String highcardIdentifyStr = carbonProperties.getProperty(
0:         CarbonCommonConstants.HIGH_CARDINALITY_IDENTIFY_ENABLE,
0:         CarbonCommonConstants.HIGH_CARDINALITY_IDENTIFY_ENABLE_DEFAULT);
1:     try {
0:       Boolean.parseBoolean(highcardIdentifyStr);
1:     } catch (NumberFormatException e) {
0:       LOGGER.info("The high cardinality identify value \"" + highcardIdentifyStr
1:           + "\" is invalid. Using the default value \""
0:           + CarbonCommonConstants.HIGH_CARDINALITY_IDENTIFY_ENABLE_DEFAULT);
0:       carbonProperties.setProperty(CarbonCommonConstants.HIGH_CARDINALITY_IDENTIFY_ENABLE,
0:           CarbonCommonConstants.HIGH_CARDINALITY_IDENTIFY_ENABLE_DEFAULT);
1:     }
1:   }
1: 
0:   private void validateHighCardinalityThreshold() {
0:     String highcardThresholdStr = carbonProperties.getProperty(
0:         CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD,
0:         CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD_DEFAULT);
1:     try {
0:       int highcardThreshold = Integer.parseInt(highcardThresholdStr);
0:       if(highcardThreshold < CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD_MIN){
0:         LOGGER.info("The high cardinality threshold value \"" + highcardThresholdStr
0:             + "\" is invalid. Using the min value \""
0:             + CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD_MIN);
0:         carbonProperties.setProperty(CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD,
0:             CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD_MIN + "");
1:       }
1:     } catch (NumberFormatException e) {
0:       LOGGER.info("The high cardinality threshold value \"" + highcardThresholdStr
1:           + "\" is invalid. Using the default value \""
0:           + CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD_DEFAULT);
0:       carbonProperties.setProperty(CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD,
0:           CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD_DEFAULT);
1:     }
1:   }
1: 
0:   private void validateHighCardinalityInRowCountPercentage() {
0:     String highcardPercentageStr = carbonProperties.getProperty(
0:         CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE,
0:         CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE_DEFAULT);
1:     try {
0:       double highcardPercentage = Double.parseDouble(highcardPercentageStr);
0:       if(highcardPercentage <= 0){
0:         LOGGER.info("The percentage of high cardinality in row count value \""
0:             + highcardPercentageStr + "\" is invalid. Using the default value \""
0:             + CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE_DEFAULT);
0:         carbonProperties.setProperty(
0:             CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE,
0:             CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE_DEFAULT);
1:       }
1:     } catch (NumberFormatException e) {
0:       LOGGER.info("The percentage of high cardinality in row count value \""
0:           + highcardPercentageStr + "\" is invalid. Using the default value \""
0:           + CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE_DEFAULT);
0:       carbonProperties.setProperty(CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE,
0:           CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE_DEFAULT);
1:     }
1:   }
1: 
1:   /**
1:    * This method will read all the properties from file and load it into
1:    * memory
1:    */
1:   private void loadProperties() {
1:     String property = System.getProperty("carbon.properties.filepath");
1:     if (null == property) {
1:       property = CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH;
1:     }
1:     File file = new File(property);
1:     LOGGER.info("Property file path: " + file.getAbsolutePath());
1: 
1:     FileInputStream fis = null;
1:     try {
1:       if (file.exists()) {
1:         fis = new FileInputStream(file);
1: 
1:         carbonProperties.load(fis);
1:       }
1:     } catch (FileNotFoundException e) {
0:       LOGGER.error("The file: " + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH
0:           + " does not exist");
1:     } catch (IOException e) {
0:       LOGGER.error("Error while reading the file: "
1:           + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH);
1:     } finally {
1:       if (null != fis) {
1:         try {
1:           fis.close();
1:         } catch (IOException e) {
1:           LOGGER.error("Error while closing the file stream for file: "
1:                   + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH);
1:         }
1:       }
1:     }
1: 
1:     print();
1:   }
1: 
1:   /**
1:    * This method will be used to get the properties value
1:    *
1:    * @param key
1:    * @return properties value
1:    */
1:   public String getProperty(String key) {
0:     //TODO temporary fix
0:     if ("carbon.leaf.node.size".equals(key)) {
0:       return "120000";
1:     }
1:     return carbonProperties.getProperty(key);
1:   }
1: 
1:   /**
1:    * This method will be used to get the properties value if property is not
1:    * present then it will return tghe default value
1:    *
1:    * @param key
1:    * @return properties value
1:    */
1:   public String getProperty(String key, String defaultValue) {
1:     String value = getProperty(key);
1:     if (null == value) {
1:       return defaultValue;
1:     }
1:     return value;
1:   }
1: 
1:   /**
1:    * This method will be used to add a new property
1:    *
1:    * @param key
1:    * @return properties value
1:    */
0:   public void addProperty(String key, String value) {
1:     carbonProperties.setProperty(key, value);
1: 
1:   }
1: 
1:   /**
1:    * Validate the restrictions
1:    *
0:    * @param actual
0:    * @param max
0:    * @param min
0:    * @param defaultVal
1:    * @return
1:    */
0:   public long validate(long actual, long max, long min, long defaultVal) {
1:     if (actual <= max && actual >= min) {
1:       return actual;
1:     }
1:     return defaultVal;
1:   }
1: 
1:   /**
1:    * returns major compaction size value from carbon properties or default value if it is not valid
1:    *
1:    * @return
1:    */
1:   public long getMajorCompactionSize() {
1:     long compactionSize;
1:     try {
0:       compactionSize = Long.parseLong(getProperty(CarbonCommonConstants.MAJOR_COMPACTION_SIZE,
0:           CarbonCommonConstants.DEFAULT_MAJOR_COMPACTION_SIZE));
1:     } catch (NumberFormatException e) {
0:       compactionSize = Long.parseLong(CarbonCommonConstants.DEFAULT_MAJOR_COMPACTION_SIZE);
1:     }
1:     return compactionSize;
1:   }
1: 
1:   /**
1:    * returns the number of loads to be preserved.
1:    *
1:    * @return
1:    */
1:   public int getNumberOfSegmentsToBePreserved() {
1:     int numberOfSegmentsToBePreserved;
1:     try {
1:       numberOfSegmentsToBePreserved = Integer.parseInt(
1:           getProperty(CarbonCommonConstants.PRESERVE_LATEST_SEGMENTS_NUMBER,
1:               CarbonCommonConstants.DEFAULT_PRESERVE_LATEST_SEGMENTS_NUMBER));
1:       // checking min and max . 0  , 100 is min & max.
1:       if (numberOfSegmentsToBePreserved < 0 || numberOfSegmentsToBePreserved > 100) {
0:         LOGGER.error("The specified value for property "
1:             + CarbonCommonConstants.PRESERVE_LATEST_SEGMENTS_NUMBER + " is incorrect."
1:             + " Correct value should be in range of 0 -100. Taking the default value.");
1:         numberOfSegmentsToBePreserved =
1:             Integer.parseInt(CarbonCommonConstants.DEFAULT_PRESERVE_LATEST_SEGMENTS_NUMBER);
1:       }
1:     } catch (NumberFormatException e) {
1:       numberOfSegmentsToBePreserved =
1:           Integer.parseInt(CarbonCommonConstants.DEFAULT_PRESERVE_LATEST_SEGMENTS_NUMBER);
1:     }
1:     return numberOfSegmentsToBePreserved;
1:   }
1: 
1:   public void print() {
1:     LOGGER.info("------Using Carbon.properties --------");
1:     LOGGER.info(carbonProperties.toString());
1:   }
1: 
1:   /**
1:    * gettting the unmerged segment numbers to be merged.
1:    * @return
1:    */
1:   public int[] getCompactionSegmentLevelCount() {
1:     String commaSeparatedLevels;
1: 
1:     commaSeparatedLevels = getProperty(CarbonCommonConstants.COMPACTION_SEGMENT_LEVEL_THRESHOLD,
1:         CarbonCommonConstants.DEFAULT_SEGMENT_LEVEL_THRESHOLD);
1:     int[] compactionSize = getIntArray(commaSeparatedLevels);
1: 
0:     if(null == compactionSize){
1:       compactionSize = getIntArray(CarbonCommonConstants.DEFAULT_SEGMENT_LEVEL_THRESHOLD);
1:     }
1: 
1:     return compactionSize;
1:   }
1: 
1:   /**
1:    *
0:    * @param commaSeparatedLevels
1:    * @return
1:    */
0:   private int[] getIntArray(String commaSeparatedLevels) {
1:     String[] levels = commaSeparatedLevels.split(",");
1:     int[] compactionSize = new int[levels.length];
1:     int i = 0;
1:     for (String levelSize : levels) {
1:       try {
1:         int size = Integer.parseInt(levelSize.trim());
0:         if(validate(size,100,0,-1) < 0 ){
1:           // if given size is out of boundary then take default value for all levels.
0:           return null;
1:         }
1:         compactionSize[i++] = size;
1:       }
0:       catch(NumberFormatException e){
0:         LOGGER.error(
1:             "Given value for property" + CarbonCommonConstants.COMPACTION_SEGMENT_LEVEL_THRESHOLD
1:                 + " is not proper. Taking the default value "
1:                 + CarbonCommonConstants.DEFAULT_SEGMENT_LEVEL_THRESHOLD);
0:         return null;
1:       }
1:     }
1:     return compactionSize;
1:   }
1: 
1:   /**
1:    * Validate the restrictions
1:    *
0:    * @param actual
0:    * @param max
0:    * @param min
0:    * @param defaultVal
1:    * @return
1:    */
1:   public int validate(int actual, int max, int min, int defaultVal) {
1:     if (actual <= max && actual >= min) {
1:       return actual;
1:     }
1:     return defaultVal;
1:   }
1: 
1: }
author:QiangCai
-------------------------------------------------------------------------------
commit:d5bec4d
/////////////////////////////////////////////////////////////////////////
1:     validateEnableQueryStatistics();
/////////////////////////////////////////////////////////////////////////
1:   private void validateEnableQueryStatistics() {
1:     String enableQueryStatistics = carbonProperties.getProperty(
1:         CarbonCommonConstants.ENABLE_QUERY_STATISTICS,
1:         CarbonCommonConstants.ENABLE_QUERY_STATISTICS_DEFAULT);
1:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(enableQueryStatistics);
1:     if (!isValidBooleanValue) {
1:       LOGGER.warn("The enable query statistics value \"" + enableQueryStatistics
0:           + "\" is invalid. Using the default value \""
1:           + CarbonCommonConstants.ENABLE_QUERY_STATISTICS_DEFAULT);
1:       carbonProperties.setProperty(CarbonCommonConstants.ENABLE_QUERY_STATISTICS,
1:           CarbonCommonConstants.ENABLE_QUERY_STATISTICS_DEFAULT);
1:     }
1:   }
1: 
1:   public boolean isEnableQueryStatistics() {
1:     String enableQueryStatistics = carbonProperties.getProperty(
1:         CarbonCommonConstants.ENABLE_QUERY_STATISTICS,
1:         CarbonCommonConstants.ENABLE_QUERY_STATISTICS_DEFAULT);
1:     return enableQueryStatistics.equalsIgnoreCase("true");
1:   }
1: 
commit:a51ad30
/////////////////////////////////////////////////////////////////////////
1:     validateEnableAutoHandoff();
/////////////////////////////////////////////////////////////////////////
1:   private void validateEnableAutoHandoff() {
1:     String enableAutoHandoffStr =
0:         carbonProperties.getProperty(CarbonCommonConstants.ENABLE_AUTO_HANDOFF);
1:     boolean isValid = CarbonUtil.validateBoolean(enableAutoHandoffStr);
1:     if (!isValid) {
1:       LOGGER.warn("The enable auto handoff value \"" + enableAutoHandoffStr
0:           + "\" is invalid. Using the default value \""
1:           + CarbonCommonConstants.ENABLE_AUTO_HANDOFF_DEFAULT);
0:       carbonProperties.setProperty(CarbonCommonConstants.ENABLE_AUTO_HANDOFF,
1:           CarbonCommonConstants.ENABLE_AUTO_HANDOFF_DEFAULT);
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   public boolean isEnableAutoHandoff() {
1:     String enableAutoHandoffStr = CarbonProperties.getInstance().getProperty(
0:         CarbonCommonConstants.ENABLE_AUTO_HANDOFF,
1:         CarbonCommonConstants.ENABLE_AUTO_HANDOFF_DEFAULT);
1:     return enableAutoHandoffStr.equalsIgnoreCase("true");
1:   }
1: 
commit:694ee77
/////////////////////////////////////////////////////////////////////////
0:     validateCombineSmallInputFiles();
/////////////////////////////////////////////////////////////////////////
0:   private void validateCombineSmallInputFiles() {
0:     String combineSmallInputFilesStr =
0:         carbonProperties.getProperty(CarbonCommonConstants.CARBON_COMBINE_SMALL_INPUT_FILES);
0:     boolean isValidBooleanValue = CarbonUtil.validateBoolean(combineSmallInputFilesStr);
0:     if (!isValidBooleanValue) {
0:       LOGGER.warn("The combine small files value \"" + combineSmallInputFilesStr
0:           + "\" is invalid. Using the default value \""
0:           + CarbonCommonConstants.CARBON_COMBINE_SMALL_INPUT_FILES_DEFAULT);
0:       carbonProperties.setProperty(CarbonCommonConstants.CARBON_COMBINE_SMALL_INPUT_FILES,
0:           CarbonCommonConstants.CARBON_COMBINE_SMALL_INPUT_FILES_DEFAULT);
1:     }
1:   }
1: 
commit:0f407de
/////////////////////////////////////////////////////////////////////////
1:     validateHandoffSize();
/////////////////////////////////////////////////////////////////////////
1:   private void validateHandoffSize() {
0:     String handoffSizeStr = carbonProperties.getProperty(CarbonCommonConstants.HANDOFF_SIZE);
1:     if (null == handoffSizeStr || handoffSizeStr.length() == 0) {
0:       carbonProperties.setProperty(CarbonCommonConstants.HANDOFF_SIZE,
1:           "" + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT);
1:     } else {
1:       try {
1:         long handoffSize = Long.parseLong(handoffSizeStr);
1:         if (handoffSize < CarbonCommonConstants.HANDOFF_SIZE_MIN) {
1:           LOGGER.info("The streaming segment max size configured value " + handoffSizeStr +
1:               " is invalid. Using the default value "
1:               + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT);
0:           carbonProperties.setProperty(CarbonCommonConstants.HANDOFF_SIZE,
1:               "" + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT);
1:         }
1:       } catch (NumberFormatException e) {
1:         LOGGER.info("The streaming segment max size value \"" + handoffSizeStr
0:             + "\" is invalid. Using the default value \""
1:             + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT + "\"");
0:         carbonProperties.setProperty(CarbonCommonConstants.HANDOFF_SIZE,
1:             "" + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT);
1:       }
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   public long getHandoffSize() {
1:     Long handoffSize;
1:     try {
1:       handoffSize = Long.parseLong(
1:           CarbonProperties.getInstance().getProperty(
0:               CarbonCommonConstants.HANDOFF_SIZE,
1:               "" + CarbonCommonConstants.HANDOFF_SIZE_DEFAULT
1:           )
1:       );
1:     } catch (NumberFormatException exc) {
1:       handoffSize = CarbonCommonConstants.HANDOFF_SIZE_DEFAULT;
1:     }
1:     return handoffSize;
1:   }
1: 
commit:0158968
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c5aba5f
/////////////////////////////////////////////////////////////////////////
1:     validatePrefetchBufferSize();
1:   }
1: 
1:   private void validatePrefetchBufferSize() {
1:     String prefetchBufferSizeStr =
0:         carbonProperties.getProperty(CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE);
1: 
1:     if (null == prefetchBufferSizeStr || prefetchBufferSizeStr.length() == 0) {
0:       carbonProperties.setProperty(CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE,
1:           CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE_DEFAULT);
1:     } else {
1:       try {
1:         Integer.parseInt(prefetchBufferSizeStr);
1:       } catch (NumberFormatException e) {
1:         LOGGER.info("The prefetch buffer size value \"" + prefetchBufferSizeStr
0:             + "\" is invalid. Using the default value \""
1:             + CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE_DEFAULT + "\"");
0:         carbonProperties.setProperty(CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE,
1:             CarbonCommonConstants.CARBON_PREFETCH_BUFFERSIZE_DEFAULT);
1:       }
1:     }
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
author:xuchuanyin
-------------------------------------------------------------------------------
commit:9a423c2
/////////////////////////////////////////////////////////////////////////
0: 
1:   /**
1:    * whether optimization for skewed data is enabled
1:    * @return true, if enabled; false for not enabled.
1:    */
1:   public boolean isLoadSkewedDataOptimizationEnabled() {
1:     String skewedEnabled = getProperty(
1:         CarbonLoadOptionConstants.ENABLE_CARBON_LOAD_SKEWED_DATA_OPTIMIZATION,
1:         CarbonLoadOptionConstants.ENABLE_CARBON_LOAD_SKEWED_DATA_OPTIMIZATION_DEFAULT);
1:     return skewedEnabled.equalsIgnoreCase("true");
1:   }
commit:c100251
/////////////////////////////////////////////////////////////////////////
1:    * get compressor name for compressing sort temp files
1:    * @return compressor name
1:    */
1:   public String getSortTempCompressor() {
1:     String compressor = getProperty(CarbonCommonConstants.CARBON_SORT_TEMP_COMPRESSOR,
1:         CarbonCommonConstants.CARBON_SORT_TEMP_COMPRESSOR_DEFAULT).toUpperCase();
1:     if (compressor.isEmpty() || "SNAPPY".equals(compressor) || "GZIP".equals(compressor)
0:         || "BZIP2".equals(compressor) || "LZ4".equals(compressor)) {
1:       return compressor;
1:     } else {
0:       LOGGER.error("The ".concat(CarbonCommonConstants.CARBON_SORT_TEMP_COMPRESSOR)
0:           .concat(" configuration value is invalid. Only snappy,gzip,bip2,lz4 and")
1:           .concat(" empty are allowed. It will not compress the sort temp files by default"));
1:       return CarbonCommonConstants.CARBON_SORT_TEMP_COMPRESSOR_DEFAULT;
1:     }
1:   }
1:   /**
commit:2ee7775
/////////////////////////////////////////////////////////////////////////
1:    * Returns parallelism for segment update
1:    * @return int
1:    */
1:   public int getParallelismForSegmentUpdate() {
1:     int parallelism = Integer.parseInt(
1:         CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM_DEFAULT);
1:     boolean isInvalidValue = false;
1:     try {
1:       String strParallelism = getProperty(CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM,
1:           CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM_DEFAULT);
1:       parallelism = Integer.parseInt(strParallelism);
1:       if (parallelism <= 0 || parallelism > 1000) {
1:         isInvalidValue = true;
1:       }
1:     } catch (NumberFormatException e) {
1:       isInvalidValue = true;
1:     }
0: 
1:     if (isInvalidValue) {
0:       LOGGER.error("The specified value for property "
1:           + CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM
1:           + " is incorrect. Correct value should be in range of 0 - 1000."
1:           + " Taking the default value: "
1:           + CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM_DEFAULT);
1:       parallelism = Integer.parseInt(
1:           CarbonCommonConstants.CARBON_UPDATE_SEGMENT_PARALLELISM_DEFAULT);
1:     }
0: 
1:     return parallelism;
1:   }
0: 
1:   /**
commit:ded8b41
/////////////////////////////////////////////////////////////////////////
1:    * Returns whether to use multi temp dirs
1:    * @return boolean
0:    */
1:   public boolean isUseMultiTempDir() {
1:     String usingMultiDirStr = getProperty(CarbonCommonConstants.CARBON_USE_MULTI_TEMP_DIR,
1:         CarbonCommonConstants.CARBON_USE_MULTI_TEMP_DIR_DEFAULT);
1:     boolean validateBoolean = CarbonUtil.validateBoolean(usingMultiDirStr);
0:     if (!validateBoolean) {
0:       LOGGER.info("The carbon.use.multiple.temp.dir configuration value is invalid."
1:           + "Configured value: \"" + usingMultiDirStr + "\"."
1:           + "Data Load will not use multiple temp directories.");
1:       usingMultiDirStr = CarbonCommonConstants.CARBON_USE_MULTI_TEMP_DIR_DEFAULT;
0:     }
1:     return usingMultiDirStr.equalsIgnoreCase("true");
0:   }
0: 
0:   /**
author:SangeetaGulia
-------------------------------------------------------------------------------
commit:5ab0957
/////////////////////////////////////////////////////////////////////////
1:         .startsWith(CarbonCommonConstants.ALLUXIOURL_PREFIX) || defaultFs
1:         .startsWith(CarbonCommonConstants.S3A_PREFIX))
author:kumarvishal
-------------------------------------------------------------------------------
commit:27ec651
/////////////////////////////////////////////////////////////////////////
1:     validateSortMemorySizeInMB();
1:     validateWorkingMemory();
1:     validateSortStorageMemory();
/////////////////////////////////////////////////////////////////////////
0: 
1:   private void validateSortMemorySizeInMB() {
0:     int sortMemorySizeInMBDefault =
0:         Integer.parseInt(CarbonCommonConstants.IN_MEMORY_FOR_SORT_DATA_IN_MB_DEFAULT);
0:     int sortMemorySizeInMB = 0;
1:     try {
0:       sortMemorySizeInMB = Integer.parseInt(
0:           carbonProperties.getProperty(CarbonCommonConstants.IN_MEMORY_FOR_SORT_DATA_IN_MB));
1:     } catch (NumberFormatException e) {
0:       LOGGER.error(
0:           "The specified value for property " + CarbonCommonConstants.IN_MEMORY_FOR_SORT_DATA_IN_MB
0:               + "is Invalid." + " Taking the default value."
0:               + CarbonCommonConstants.IN_MEMORY_FOR_SORT_DATA_IN_MB_DEFAULT);
0:       sortMemorySizeInMB = sortMemorySizeInMBDefault;
0:     }
0:     if (sortMemorySizeInMB < sortMemorySizeInMBDefault) {
0:       LOGGER.error(
0:           "The specified value for property " + CarbonCommonConstants.IN_MEMORY_FOR_SORT_DATA_IN_MB
0:               + "is less than default value." + ". Taking the default value."
0:               + CarbonCommonConstants.IN_MEMORY_FOR_SORT_DATA_IN_MB_DEFAULT);
0:       sortMemorySizeInMB = sortMemorySizeInMBDefault;
0:     }
0:     String unsafeWorkingMemoryString =
0:         carbonProperties.getProperty(CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB);
0:     String unsafeSortStorageMemoryString =
0:         carbonProperties.getProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB);
0:     int workingMemory = 512;
0:     int sortStorageMemory;
0:     if (null == unsafeWorkingMemoryString && null == unsafeSortStorageMemoryString) {
0:       workingMemory = workingMemory > ((sortMemorySizeInMB * 20) / 100) ?
0:           workingMemory :
0:           ((sortMemorySizeInMB * 20) / 100);
0:       sortStorageMemory = sortMemorySizeInMB - workingMemory;
0:       carbonProperties
0:           .setProperty(CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB, workingMemory + "");
1:       carbonProperties.setProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB,
0:           sortStorageMemory + "");
0:     } else if (null != unsafeWorkingMemoryString && null == unsafeSortStorageMemoryString) {
1:       carbonProperties.setProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB,
0:           sortMemorySizeInMB + "");
0:     } else if (null == unsafeWorkingMemoryString && null != unsafeSortStorageMemoryString) {
0:       carbonProperties
0:           .setProperty(CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB, sortMemorySizeInMB + "");
0:     }
0:   }
0: 
1:   private void validateWorkingMemory() {
0:     int unsafeWorkingMemoryDefault =
0:         Integer.parseInt(CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB_DEFAULT);
0:     int unsafeWorkingMemory = 0;
1:     try {
0:       unsafeWorkingMemory = Integer.parseInt(
1:           carbonProperties.getProperty(CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB));
1:     } catch (NumberFormatException e) {
0:       LOGGER.error("The specified value for property "
0:           + CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB_DEFAULT + "is invalid."
1:           + " Taking the default value."
0:           + CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB_DEFAULT);
0:       unsafeWorkingMemory = unsafeWorkingMemoryDefault;
0:     }
0:     if (unsafeWorkingMemory < unsafeWorkingMemoryDefault) {
0:       LOGGER.error("The specified value for property "
0:           + CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB_DEFAULT
0:           + "is less than the default value." + ". Taking the default value."
0:           + CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB_DEFAULT);
0:       unsafeWorkingMemory = unsafeWorkingMemoryDefault;
0:     }
0:     carbonProperties
0:         .setProperty(CarbonCommonConstants.UNSAFE_WORKING_MEMORY_IN_MB, unsafeWorkingMemory + "");
0:   }
0: 
1:   private void validateSortStorageMemory() {
1:     int unsafeSortStorageMemoryDefault =
1:         Integer.parseInt(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB_DEFAULT);
1:     int unsafeSortStorageMemory = 0;
1:     try {
1:       unsafeSortStorageMemory = Integer.parseInt(carbonProperties
1:           .getProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB));
1:     } catch (NumberFormatException e) {
0:       LOGGER.error("The specified value for property "
1:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB + "is invalid."
1:           + " Taking the default value."
1:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB_DEFAULT);
1:       unsafeSortStorageMemory = unsafeSortStorageMemoryDefault;
0:     }
1:     if (unsafeSortStorageMemory < unsafeSortStorageMemoryDefault) {
0:       LOGGER.error("The specified value for property "
1:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB
1:           + "is less than the default value." + " Taking the default value."
1:           + CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB_DEFAULT);
1:       unsafeSortStorageMemory = unsafeSortStorageMemoryDefault;
0:     }
1:     carbonProperties.setProperty(CarbonCommonConstants.IN_MEMORY_STORAGE_FOR_SORTED_DATA_IN_MB,
1:         unsafeSortStorageMemory + "");
0:   }
0: 
commit:ebf13dc
/////////////////////////////////////////////////////////////////////////
1:     validateBlockletGroupSizeInMB();
/////////////////////////////////////////////////////////////////////////
1:   private void validateBlockletGroupSizeInMB() {
0:         .getProperty(CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB,
1:             CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
1:       if (numberOfPagePerBlockletColumn < CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_MIN) {
1:         LOGGER.info("Blocklet Size Configured value \"" + numberOfPagePerBlockletColumnString
0:             + "\" is invalid. Using the default value \""
1:             + CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
0:         carbonProperties.setProperty(CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB,
1:             CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
1:       LOGGER.info("Blocklet Size Configured value \"" + numberOfPagePerBlockletColumnString
0:           + "\" is invalid. Using the default value \""
1:           + CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
0:       carbonProperties.setProperty(CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB,
1:           CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE);
1:     LOGGER.info("Blocklet Size Configured value is \"" + carbonProperties
0:         .getProperty(CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB,
1:             CarbonV3DataFormatConstants.BLOCKLET_SIZE_IN_MB_DEFAULT_VALUE));
/////////////////////////////////////////////////////////////////////////
1:     LOGGER.info("Carbon Current data file version: " + carbonProperties
0:         .setProperty(CarbonCommonConstants.CARBON_DATA_FILE_VERSION,
1:             CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION));
commit:2cf1104
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.constants.CarbonV3DataFormatConstants;
/////////////////////////////////////////////////////////////////////////
0:     validateNumberOfPagesPerBlocklet();
1:     validateNumberOfColumnPerIORead();
0:     validateNumberOfRowsPerBlockletColumnPage();
/////////////////////////////////////////////////////////////////////////
0:   /**
1:    * This method validates the number of pages per blocklet column
0:    */
0:   private void validateNumberOfPagesPerBlocklet() {
1:     String numberOfPagePerBlockletColumnString = carbonProperties
0:         .getProperty(CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN,
0:             CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN_DEFAULT_VALUE);
0:     try {
1:       short numberOfPagePerBlockletColumn = Short.parseShort(numberOfPagePerBlockletColumnString);
0:       if (numberOfPagePerBlockletColumn
0:           < CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN_MIN
0:           || numberOfPagePerBlockletColumn
0:           > CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN_MAX) {
1:         LOGGER.info(
0:             "The Number Of pages per blocklet column value \"" + numberOfPagePerBlockletColumnString
0:                 + "\" is invalid. Using the default value \""
0:                 + CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN_DEFAULT_VALUE);
0:         carbonProperties.setProperty(CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN,
0:             CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN_DEFAULT_VALUE);
0:       }
0:     } catch (NumberFormatException e) {
1:       LOGGER.info(
0:           "The Number Of pages per blocklet column value \"" + numberOfPagePerBlockletColumnString
0:               + "\" is invalid. Using the default value \""
0:               + CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN_DEFAULT_VALUE);
0:       carbonProperties.setProperty(CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN,
0:           CarbonV3DataFormatConstants.NUMBER_OF_PAGE_IN_BLOCKLET_COLUMN_DEFAULT_VALUE);
0:     }
0:   }
0: 
0:   /**
1:    * This method validates the number of column read in one IO
0:    */
1:   private void validateNumberOfColumnPerIORead() {
1:     String numberofColumnPerIOString = carbonProperties
0:         .getProperty(CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO,
1:             CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
0:     try {
1:       short numberofColumnPerIO = Short.parseShort(numberofColumnPerIOString);
1:       if (numberofColumnPerIO < CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_MIN
1:           || numberofColumnPerIO > CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_MAX) {
1:         LOGGER.info("The Number Of pages per blocklet column value \"" + numberofColumnPerIOString
0:             + "\" is invalid. Using the default value \""
1:             + CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
0:         carbonProperties.setProperty(CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO,
1:             CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
0:       }
0:     } catch (NumberFormatException e) {
1:       LOGGER.info("The Number Of pages per blocklet column value \"" + numberofColumnPerIOString
0:           + "\" is invalid. Using the default value \""
1:           + CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
0:       carbonProperties.setProperty(CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO,
1:           CarbonV3DataFormatConstants.NUMBER_OF_COLUMN_TO_READ_IN_IO_DEFAULTVALUE);
0:     }
0:   }
0: 
0:   /**
1:    * This method validates the number of column read in one IO
0:    */
0:   private void validateNumberOfRowsPerBlockletColumnPage() {
0:     String numberOfRowsPerBlockletColumnPageString = carbonProperties
0:         .getProperty(CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE,
0:             CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
0:     try {
0:       short numberOfRowsPerBlockletColumnPage =
0:           Short.parseShort(numberOfRowsPerBlockletColumnPageString);
0:       if (numberOfRowsPerBlockletColumnPage
0:           < CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_MIN
0:           || numberOfRowsPerBlockletColumnPage
0:           > CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_MAX) {
0:         LOGGER.info("The Number Of rows per blocklet column pages value \""
0:             + numberOfRowsPerBlockletColumnPageString + "\" is invalid. Using the default value \""
0:             + CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
0:         carbonProperties
0:             .setProperty(CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE,
0:                 CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
0:       }
0:     } catch (NumberFormatException e) {
0:       LOGGER.info("The Number Of rows per blocklet column pages value \""
0:           + numberOfRowsPerBlockletColumnPageString + "\" is invalid. Using the default value \""
0:           + CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
0:       carbonProperties
0:           .setProperty(CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE,
0:               CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
0:     }
0:   }
0: 
/////////////////////////////////////////////////////////////////////////
0:       carbonProperties.setProperty(CarbonCommonConstants.CARBON_DATA_FILE_VERSION,
1:           CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION);
1:         LOGGER.warn("Specified file version property is invalid: " + carbondataFileVersionString
1:             + ". Using " + CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION
1:             + " as default file version");
/////////////////////////////////////////////////////////////////////////
1:    *
/////////////////////////////////////////////////////////////////////////
1:           + CarbonCommonConstants.UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION + "is incorrect."
/////////////////////////////////////////////////////////////////////////
0:    *
/////////////////////////////////////////////////////////////////////////
1:           + CarbonCommonConstants.DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION + "is incorrect."
commit:51425d4
/////////////////////////////////////////////////////////////////////////
1:         short version = Short.parseShort(versionStr);
1:         return ColumnarFormatVersion.valueOf(version);
commit:d54dc64
/////////////////////////////////////////////////////////////////////////
1:     validateCarbonDataFileVersion();
/////////////////////////////////////////////////////////////////////////
0:             + "\" is invalid. Using the default value \""
0:             + CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
0:           + "\" is invalid. Using the default value \""
0:           + CarbonCommonConstants.BLOCKLET_SIZE_DEFAULT_VAL);
/////////////////////////////////////////////////////////////////////////
0:         LOGGER.info(
0:             "The num Cores  value \"" + numCoresStr + "\" is invalid. Using the default value \""
0:                 + CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
0:       LOGGER.info(
0:           "The num Cores  value \"" + numCoresStr + "\" is invalid. Using the default value \""
0:               + CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
/////////////////////////////////////////////////////////////////////////
0:     String numCoresStr = carbonProperties.getProperty(CarbonCommonConstants.NUM_CORES_BLOCK_SORT,
0:         CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);
/////////////////////////////////////////////////////////////////////////
0:         LOGGER.info(
1:             "The batch size value \"" + sortSizeStr + "\" is invalid. Using the default value \""
0:                 + CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
0:       LOGGER.info(
1:           "The batch size value \"" + sortSizeStr + "\" is invalid. Using the default value \""
0:               + CarbonCommonConstants.SORT_SIZE_DEFAULT_VAL);
0:     String highcardIdentifyStr = carbonProperties
0:         .getProperty(CarbonCommonConstants.HIGH_CARDINALITY_IDENTIFY_ENABLE,
0:             CarbonCommonConstants.HIGH_CARDINALITY_IDENTIFY_ENABLE_DEFAULT);
/////////////////////////////////////////////////////////////////////////
0:     String highcardThresholdStr = carbonProperties
0:         .getProperty(CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD,
0:             CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD_DEFAULT);
0:       if (highcardThreshold < CarbonCommonConstants.HIGH_CARDINALITY_THRESHOLD_MIN) {
/////////////////////////////////////////////////////////////////////////
0:     String highcardPercentageStr = carbonProperties
0:         .getProperty(CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE,
0:             CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE_DEFAULT);
0:       if (highcardPercentage <= 0) {
0:         LOGGER.info(
0:             "The percentage of high cardinality in row count value \"" + highcardPercentageStr
0:                 + "\" is invalid. Using the default value \""
0:                 + CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE_DEFAULT);
0:         carbonProperties.setProperty(CarbonCommonConstants.HIGH_CARDINALITY_IN_ROW_COUNT_PERCENTAGE,
0:       LOGGER.info("The percentage of high cardinality in row count value \"" + highcardPercentageStr
0:           + "\" is invalid. Using the default value \""
/////////////////////////////////////////////////////////////////////////
1:    * Below method will be used to validate the data file version parameter
1:    * if parameter is invalid current version will be set
0:    */
1:   private void validateCarbonDataFileVersion() {
0:     short carbondataFileVersion = CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION;
1:     String carbondataFileVersionString =
0:         carbonProperties.getProperty(CarbonCommonConstants.CARBON_DATA_FILE_VERSION);
0:     try {
0:       carbondataFileVersion = Short.parseShort(carbondataFileVersionString);
0:     } catch (NumberFormatException e) {
0:       carbondataFileVersion = CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION;
0:       LOGGER.info("Current Data file version property is invalid  \"" + carbondataFileVersionString
0:           + "\" is invalid. Using the Current data file version value \"" + carbondataFileVersion);
0:       carbonProperties
0:           .setProperty(CarbonCommonConstants.CARBON_DATA_FILE_VERSION, carbondataFileVersion + "");
0:     }
0:     if (carbondataFileVersion > CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION
0:         || carbondataFileVersion < 0) {
0:       LOGGER.info("Current Data file version property is invalid  \"" + carbondataFileVersionString
0:           + "\" is invalid. Using the Current data file version value \"" + carbondataFileVersion);
0:       carbondataFileVersion = CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION;
0:       carbonProperties
0:           .setProperty(CarbonCommonConstants.CARBON_DATA_FILE_VERSION, carbondataFileVersion + "");
0:     }
0: 
0:   }
0: 
0:   /**
/////////////////////////////////////////////////////////////////////////
0:       LOGGER.error(
1:           "The file: " + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH + " does not exist");
0:       LOGGER.error(
1:           "Error while reading the file: " + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH);
0:               + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH);
/////////////////////////////////////////////////////////////////////////
0:    *
/////////////////////////////////////////////////////////////////////////
0:     if (null == compactionSize) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (validate(size, 100, 0, -1) < 0) {
0:       } catch (NumberFormatException e) {
author:Jin Zhou
-------------------------------------------------------------------------------
commit:f1c6ddd
/////////////////////////////////////////////////////////////////////////
1:       compactionSize = Long.parseLong(getProperty(
1:               CarbonCommonConstants.CARBON_MAJOR_COMPACTION_SIZE,
1:               CarbonCommonConstants.DEFAULT_CARBON_MAJOR_COMPACTION_SIZE));
1:       compactionSize = Long.parseLong(
1:               CarbonCommonConstants.DEFAULT_CARBON_MAJOR_COMPACTION_SIZE);
/////////////////////////////////////////////////////////////////////////
1:   public int[] getIntArray(String commaSeparatedLevels) {
author:dhatchayani
-------------------------------------------------------------------------------
commit:435ea26
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d25fee2
/////////////////////////////////////////////////////////////////////////
0:       lockTypeConfigured = lockTypeConfigured.toUpperCase();
0:       switch (lockTypeConfigured) {
/////////////////////////////////////////////////////////////////////////
1:     if (0 == compactionSize.length) {
/////////////////////////////////////////////////////////////////////////
1:           return new int[0];
/////////////////////////////////////////////////////////////////////////
1:         return new int[0];
author:chenerlu
-------------------------------------------------------------------------------
commit:c81c3b1
/////////////////////////////////////////////////////////////////////////
0:           + CarbonCommonConstants.LOCK_TYPE + " is invalid for current file system. "
1:           + "Use the default value " + CarbonCommonConstants.CARBON_LOCK_TYPE_HDFS + " instead.");
/////////////////////////////////////////////////////////////////////////
0:           + CarbonCommonConstants.LOCK_TYPE + " is invalid for current file system. "
1:           + "Use the default value " + CarbonCommonConstants.CARBON_LOCK_TYPE_LOCAL + " instead.");
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:c3b2666
/////////////////////////////////////////////////////////////////////////
author:jackylk
-------------------------------------------------------------------------------
commit:98df130
/////////////////////////////////////////////////////////////////////////
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.ColumnarFormatVersion;
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
commit:0ef3fb8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.carbon.ColumnarFormatVersion;
/////////////////////////////////////////////////////////////////////////
1:     if (carbondataFileVersionString == null) {
1:       // use default property if user does not specify version property
0:           .setProperty(CarbonCommonConstants.CARBON_DATA_FILE_VERSION,
1:               CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION);
1:     } else {
0:       try {
1:         ColumnarFormatVersion.valueOf(carbondataFileVersionString);
1:       } catch (IllegalArgumentException e) {
1:         // use default property if user specifies an invalid version property
0:         LOGGER.warn("Specified file version property is invalid: " +
0:             carbondataFileVersionString + ". Using " +
0:             CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION + " as default file version");
0:         carbonProperties.setProperty(CarbonCommonConstants.CARBON_DATA_FILE_VERSION,
1:             CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION);
0:       }
/////////////////////////////////////////////////////////////////////////
0:   }
1:   private ColumnarFormatVersion getDefaultFormatVersion() {
1:     return ColumnarFormatVersion.valueOf(CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION);
0:   }
0: 
1:   public ColumnarFormatVersion getFormatVersion() {
0:     String versionStr = getInstance().getProperty(CarbonCommonConstants.CARBON_DATA_FILE_VERSION);
1:     if (versionStr == null) {
1:       return getDefaultFormatVersion();
0:     } else {
0:       try {
0:         return ColumnarFormatVersion.valueOf(versionStr);
1:       } catch (IllegalArgumentException e) {
1:         return getDefaultFormatVersion();
0:       }
0:     }
author:ravikiran
-------------------------------------------------------------------------------
commit:9b8090b
/////////////////////////////////////////////////////////////////////////
0: 
0:   /**
1:    * Returns configured update deleta files value for IUD compaction
1:    * @return numberOfDeltaFilesThreshold
0:    */
/////////////////////////////////////////////////////////////////////////
0:   /**
1:    * Returns configured delete deleta files value for IUD compaction
1:    * @return numberOfDeltaFilesThreshold
0:    */
author:ravikiran23
-------------------------------------------------------------------------------
commit:0d42f52
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.common.logging.LogService;
0: import org.apache.carbondata.common.logging.LogServiceFactory;
0: import org.apache.carbondata.core.carbon.ColumnarFormatVersion;
0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: 
/////////////////////////////////////////////////////////////////////////
1:   public int getNoUpdateDeltaFilesThresholdForIUDCompaction() {
1:     int numberOfDeltaFilesThreshold;
0:     try {
1:       numberOfDeltaFilesThreshold = Integer.parseInt(
1:           getProperty(CarbonCommonConstants.UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION,
1:               CarbonCommonConstants.DEFAULT_UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION));
0: 
1:       if (numberOfDeltaFilesThreshold < 0 || numberOfDeltaFilesThreshold > 10000) {
0:         LOGGER.error("The specified value for property "
1:             + CarbonCommonConstants.UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION
1:             + "is incorrect."
1:             + " Correct value should be in range of 0 -10000. Taking the default value.");
1:         numberOfDeltaFilesThreshold = Integer.parseInt(
1:             CarbonCommonConstants.DEFAULT_UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION);
0:       }
0:     } catch (NumberFormatException e) {
0:       LOGGER.error("The specified value for property "
1:           + CarbonCommonConstants.UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION
1:           + "is incorrect."
1:           + " Correct value should be in range of 0 -10000. Taking the default value.");
1:       numberOfDeltaFilesThreshold = Integer
1:           .parseInt(CarbonCommonConstants.DEFAULT_UPDATE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION);
0:     }
1:     return numberOfDeltaFilesThreshold;
0:   }
0: 
1:   public int getNoDeleteDeltaFilesThresholdForIUDCompaction() {
1:     int numberOfDeltaFilesThreshold;
0:     try {
1:       numberOfDeltaFilesThreshold = Integer.parseInt(
1:           getProperty(CarbonCommonConstants.DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION,
1:               CarbonCommonConstants.DEFAULT_DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION));
0: 
1:       if (numberOfDeltaFilesThreshold < 0 || numberOfDeltaFilesThreshold > 10000) {
0:         LOGGER.error("The specified value for property "
1:             + CarbonCommonConstants.DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION
1:             + "is incorrect."
1:             + " Correct value should be in range of 0 -10000. Taking the default value.");
1:         numberOfDeltaFilesThreshold = Integer.parseInt(
1:             CarbonCommonConstants.DEFAULT_DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION);
0:       }
0:     } catch (NumberFormatException e) {
0:       LOGGER.error("The specified value for property "
1:           + CarbonCommonConstants.DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION
1:           + "is incorrect."
1:           + " Correct value should be in range of 0 -10000. Taking the default value.");
1:       numberOfDeltaFilesThreshold = Integer
1:           .parseInt(CarbonCommonConstants.DEFAULT_DELETE_DELTAFILE_COUNT_THRESHOLD_IUD_COMPACTION);
0:     }
1:     return numberOfDeltaFilesThreshold;
0:   }
author:wangfei
-------------------------------------------------------------------------------
commit:f67ec01
/////////////////////////////////////////////////////////////////////////
1:   public CarbonProperties addProperty(String key, String value) {
1:     return this;
author:Zhangshunyu
-------------------------------------------------------------------------------
commit:793d690
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
============================================================================