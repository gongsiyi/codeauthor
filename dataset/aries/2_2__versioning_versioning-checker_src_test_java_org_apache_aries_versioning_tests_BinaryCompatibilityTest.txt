1:6aa0635: /*
1:6aa0635: * Licensed to the Apache Software Foundation (ASF) under one
1:6aa0635: * or more contributor license agreements.  See the NOTICE file
1:6aa0635: * distributed with this work for additional information
1:6aa0635: * regarding copyright ownership.  The ASF licenses this file
1:6aa0635: * to you under the Apache License, Version 2.0 (the
1:6aa0635: * "License"); you may not use this file except in compliance
1:6aa0635: * with the License.  You may obtain a copy of the License at
11:6aa0635: *
1:6aa0635: *   http://www.apache.org/licenses/LICENSE-2.0
1:6aa0635: *
1:6aa0635: * Unless required by applicable law or agreed to in writing,
1:6aa0635: * software distributed under the License is distributed on an
1:6aa0635: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6aa0635: * KIND, either express or implied.  See the License for the
1:6aa0635: * specific language governing permissions and limitations
1:6aa0635: * under the License.
1:6aa0635: */
1:f9b43fb: package org.apache.aries.versioning.tests;
1:f9b43fb: 
1:6aa0635: import static org.junit.Assert.assertEquals;
1:6aa0635: import static org.junit.Assert.assertFalse;
1:6aa0635: import static org.junit.Assert.assertNull;
1:6aa0635: import static org.junit.Assert.assertTrue;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_FINAL;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_INTERFACE;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_NATIVE;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_PROTECTED;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_STATIC;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_SYNCHRONIZED;
1:6aa0635: import static org.objectweb.asm.Opcodes.ACC_TRANSIENT;
1:6aa0635: import static org.objectweb.asm.Opcodes.V1_5;
1:f9b43fb: 
1:6aa0635: import java.io.File;
1:6aa0635: import java.io.IOException;
1:6aa0635: import java.net.URL;
1:6aa0635: import java.net.URLClassLoader;
1:490f397: import java.util.Arrays;
1:6aa0635: import java.util.Collection;
1:6aa0635: import java.util.HashSet;
1:6aa0635: 
1:6aa0635: import org.apache.aries.versioning.utils.BinaryCompatibilityStatus;
1:f9b43fb: import org.apache.aries.versioning.utils.MethodDeclaration;
1:6aa0635: import org.apache.aries.versioning.utils.SemanticVersioningClassVisitor;
1:6aa0635: import org.junit.BeforeClass;
1:6aa0635: import org.junit.Test;
1:6aa0635: import org.objectweb.asm.ClassReader;
1:6aa0635: import org.objectweb.asm.ClassWriter;
1:6aa0635: 
1:6aa0635: 
1:6aa0635: /**
1:6aa0635:  * Test the jdk chap 13 -binary compatibility implementation
1:f9b43fb:  *
1:f9b43fb:  * @author emily
1:6aa0635:  */
1:9822203: public class BinaryCompatibilityTest {
1:6aa0635: 
1:6aa0635:     private static final int ACC_ABASTRACT = 0;
1:6aa0635:     private static URLClassLoader loader = null;
1:6aa0635: 
1:6aa0635:     @BeforeClass
1:9822203:     public static void setup() throws Exception {
1:6aa0635:         Collection<URL> urls = new HashSet<URL>();
1:6aa0635:         urls.add(new File("unitest/").toURI().toURL());
1:6aa0635:         loader = new URLClassLoader(urls.toArray(new URL[0]));
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test of binary incompatibility where a class was not abstract is changed to be declared abstract,
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_1_1() {
1:6aa0635:         // construct original class
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertTrue(
1:6aa0635:                 "When a class is changed from non abstract to abstract, this should break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635: 
1:490f397:         assertEquals(" The class pkg/Test was not abstract but is changed to be abstract.", bcs.get(0));
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test of binary compatibility where a class was abstract is changed to be declared non-abstract,
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_1_2() {
1:6aa0635:         // construct original class
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:6aa0635:         assertTrue(
1:6aa0635:                 "When a class is changed from static to non-static, this should not break binary compatibility.",
1:f9b43fb:                 bcs.isCompatible());
1:6aa0635: 
1:6aa0635: 
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test a binary incompatibility where a class was not final is changed to be final.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_2_1() {
1:6aa0635:         // construct original class
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertTrue(
1:6aa0635:                 "When a class is changed from non final to final, this should break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635: 
1:490f397:         assertEquals(" The class pkg/Test was not final but is changed to be final.", bcs.get(0));
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test a binary compatibility where a class was final is changed to not final.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_2_2() {
1:6aa0635:         // construct original class
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:6aa0635:         assertTrue(
1:6aa0635:                 "When a class is changed from final to not final, this should not break binary compatibility.",
24:6aa0635:                 bcs.isCompatible());
1:6aa0635: 
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test a binary incompatibility where a class was public is changed to not public.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_3_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
2:6aa0635:         assertNull(
1:6aa0635:                 "When a class is changed from public to non-public, this should break binary compatibility.",
1:6aa0635:                 newCV.getClassDeclaration());
1:6aa0635: 
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test a binary incompatibility where a class was not public is changed to public.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_3_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "When a class is changed from non-public to public, this should break binary compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing the direct superclass or the set of direct superinterfaces of a class type will not break compatibility
1:6aa0635:      * with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_4_1() throws IOException {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:f9b43fb:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestBChild", null);
1:f9b43fb: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Changing the direct superclass or the set of direct superinterfaces of a class type will not breake binary compatibility if not losing any members.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:f9b43fb: 
1:f9b43fb:     /**
1:f9b43fb:      * Changing field type breaks binary compatibility
1:f9b43fb:      * with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members but the one of the fields has changed type.
1:f9b43fb:      */
1:f9b43fb:     @Test
1:9822203:     public void test_jdk_chap13_4_7_4() throws IOException {
1:f9b43fb:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:f9b43fb:         cw.visitEnd();
1:f9b43fb:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:f9b43fb:         cw = new ClassWriter(0);
1:f9b43fb:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:f9b43fb: 
1:f9b43fb:         cw.visitEnd();
1:f9b43fb:         byte[] newBytes = cw.toByteArray();
1:f9b43fb:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:f9b43fb:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:f9b43fb:         ClassReader newCR = new ClassReader(newBytes);
1:f9b43fb:         ClassReader oldCR = new ClassReader(oldBytes);
1:f9b43fb: 
1:f9b43fb:         newCR.accept(newCV, 0);
1:f9b43fb:         oldCR.accept(oldCV, 0);
1:f9b43fb:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertTrue(
1:f9b43fb:                 "Changing the direct superclass or the set of direct superinterfaces of a class type results fields changes. This should breake binary compatibility if not losing any members.",
1:490f397:                 bcs.size() == 2);
1:490f397:         assertEquals(new HashSet<String>(Arrays.asList(new String[] {"The public field bar was static but is changed to be non static or vice versa.",
1:490f397:                 "The public field bar has changed its type."})), new HashSet<String>(bcs));
1:f9b43fb:     }
1:f9b43fb: 
1:f9b43fb:     /**
1:f9b43fb:      * Change the signature of the field from Colllection<AA> to Collection<String>
1:f9b43fb:      */
1:f9b43fb:     @Test
1:f9b43fb:     public void test_jdk_chap13_4_7_5() {
1:f9b43fb:         ClassWriter cw = new ClassWriter(0);
1:f9b43fb:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:f9b43fb:         cw.visitField(ACC_PUBLIC, "more", "Ljava/util/Collection;", "Lcom/bim/AA;", null).visitEnd();
1:f9b43fb:         cw.visitEnd();
1:f9b43fb:         byte[] oldBytes = cw.toByteArray();
1:f9b43fb: 
1:f9b43fb:         cw = new ClassWriter(0);
1:f9b43fb:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:f9b43fb:         cw.visitField(ACC_PROTECTED, "more", "Ljava/util/Collection;", "Ljava/lang/String;", null).visitEnd();
1:f9b43fb:         cw.visitEnd();
1:f9b43fb:         byte[] newBytes = cw.toByteArray();
1:f9b43fb:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:f9b43fb:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:f9b43fb:         ClassReader newCR = new ClassReader(newBytes);
1:f9b43fb:         ClassReader oldCR = new ClassReader(oldBytes);
1:f9b43fb: 
1:f9b43fb:         newCR.accept(newCV, 0);
1:f9b43fb:         oldCR.accept(oldCV, 0);
1:f9b43fb:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:cb248d1:         assertEquals(new HashSet<String>(Arrays.asList(new String[] {
1:490f397:                 "The public field more becomes less accessible."})), new HashSet<String>(bcs));
1:490f397:         assertTrue(
1:6aa0635:                 "Changing the declared access of a field to permit less access  , this should break binary compatibility.",
1:cb248d1:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_4_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
2:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:f9b43fb:         assertFalse(
1:6aa0635:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:f9b43fb:                 bcs.isCompatible());
1:490f397:         assertEquals(new HashSet<String>(Arrays.asList(new String[] {"The method int getFooLen(java.lang.String) has been deleted or its return type or parameter list has changed.",
1:490f397:                 "The method java.lang.String getFoo() has changed from non abstract to abstract.",
1:490f397:                 "The method int getBarLen(java.lang.String) has been deleted or its return type or parameter list has changed.",
1:490f397:                 "The method int getBooLen(java.lang.String) has been deleted or its return type or parameter list has changed.",
1:490f397:                 "The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestC, versioning/java/files/TestA].",
1:490f397:                 "The protected field c has been deleted.",
1:490f397:                 "The public field bar was not final but has been changed to be final.",
1:490f397:                 "The public field bar was static but is changed to be non static or vice versa.",
1:490f397:                 "The public field bar has changed its type."})), new HashSet<String>(bcs));
1:f9b43fb:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test deleting a class member or constructor that is not declared private/default breaks binary compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:6aa0635:     public void test_jdk_chap13_4_5_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:9822203:         cw.visitMethod(ACC_PROTECTED + ACC_ABSTRACT, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int convert(java.lang.Object) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "deleting a class member or constructor that is not declared private breaks binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635: 
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test deleting a class member or constructor that is declared private should not break binary compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:6aa0635:     public void test_jdk_chap13_4_5_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitMethod(ACC_PRIVATE, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Deleting a class member or constructor that is declared private should not break binary compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test adding a class member or constructor should not break binary compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:6aa0635:     public void test_jdk_chap13_4_5_3() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitMethod(ACC_PROTECTED, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Adding a class member or constructor should not break binary compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test changing the declared access of a method to permit less access, this should break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:6aa0635:     public void test_jdk_chap13_4_6_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:9822203:         cw.visitMethod(ACC_STATIC, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int convert(java.lang.Object) is less accessible.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Changing the declared access of a member or contructor to permit less access  , this should break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     @Test
1:6aa0635:     public void test_jdk_chap13_4_6_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC, "lESS", "I", null, new Integer(-1)).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitField(ACC_PROTECTED, "lESS", "I", null, new Integer(-1)).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The public field lESS becomes less accessible.", bcs.get(0));
1:490f397:         assertTrue(
1:f9b43fb:                 "Changing the declared access of a field to permit less access  , this should break binary compatibility.",
1:490f397:                 bcs.size()  == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Test deleting a private/default field, this should not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:6aa0635:     public void test_jdk_chap13_4_7_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:6aa0635:         cw.visitField(ACC_PRIVATE, "lESS", "I", null, new Integer(-1)).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
2:9822203:         cw.visitMethod(ACC_PROTECTED, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Deleting a private field should not break binary compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a field is added but is less accessible than the old one or change to static from non-static or from non-static to static.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_7_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PROTECTED, "bar", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The public field bar becomes less accessible.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "The new field conflicts with a field in the super class. Check chapter 13.4.7 java spec for more info.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a field was not final is changed to be final, then it can break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_8_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_FINAL, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The public field aa was not final but has been changed to be final.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Change that a public or protected field was final but is changed to be not final will break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a field was final is changed to be non-final, then it does not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_8_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_FINAL, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
3:9822203:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a field was static is changed to be non-static, then it will break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_9_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_STATIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:9822203:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The public field aa was static but is changed to be non static or vice versa.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "If a field was static is changed to be non-static, then it will break compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a field was non-static is changed to be static, then it will break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_9_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:9822203:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_STATIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The public field aa was static but is changed to be non static or vice versa.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "If a field was non-static is changed to be static, then it will break compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a field was transient is changed to non-transient, then it will not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_10_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:9822203:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:6aa0635: 
1:6aa0635:         assertTrue(
1:6aa0635:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:6aa0635:                 bcs.isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a field was non-transient is changed to transient, then it will not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_10_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:9822203:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:6aa0635: 
1:6aa0635:         assertTrue(
1:6aa0635:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:6aa0635:                 bcs.isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Testing deleting a public/protected method when there is no such a method in the superclass breaks binary compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_11_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getFooLen", "(Ljava/lang/STring;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getFooLen(java.lang.STring) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Deleting a public/protected method when there is no such a method in the superclass breaks binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Testing deleting a public/protected method when there is such a method in the superclass does not break binary compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_11_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getBarLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:6aa0635:         assertTrue(
1:6aa0635:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:6aa0635:                 bcs.isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Testing deleting a public/protected method when there is less accessible method in the superclass does break binary compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_11_3() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getFooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getFooLen(java.lang.String) is less accessible.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Adding a parameter is a binary compatibility change.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_12_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;I)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Changing a parameter list will break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing a method parameter type is a binary compatibility change.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_12_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:f9b43fb:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Changing a method paramether type will break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:f9b43fb:      * Changing a method formal type parameter is not a binary compatibility change.
1:f9b43fb:      */
1:f9b43fb:     @Test
1:9822203:     public void test_jdk_chap13_4_12_3() {
1:f9b43fb:         ClassWriter cw = new ClassWriter(0);
1:f9b43fb:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:f9b43fb:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/util/List;)I", "Ljava/lang/String;", null).visitEnd();
1:f9b43fb:         cw.visitEnd();
1:f9b43fb:         byte[] oldBytes = cw.toByteArray();
1:f9b43fb: 
1:f9b43fb: 
1:f9b43fb:         cw = new ClassWriter(0);
1:f9b43fb:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:f9b43fb: 
1:f9b43fb:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/util/List;)I", "Lcome/ibm/blah;", null).visitEnd();
1:f9b43fb:         cw.visitEnd();
1:f9b43fb:         byte[] newBytes = cw.toByteArray();
1:f9b43fb:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:f9b43fb:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:f9b43fb:         ClassReader newCR = new ClassReader(newBytes);
1:f9b43fb:         ClassReader oldCR = new ClassReader(oldBytes);
1:f9b43fb: 
1:f9b43fb:         newCR.accept(newCV, 0);
1:f9b43fb:         oldCR.accept(oldCV, 0);
1:f9b43fb:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:f9b43fb:         assertTrue(
1:f9b43fb:                 "Changing a method formal type parameter should not break binary compatibility.",
1:f9b43fb:                 bcs.isCompatible());
1:f9b43fb:     }
1:6aa0635: 
1:f9b43fb:     /**
1:6aa0635:      * Changing a method return type is a binary compatibility change.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_13_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)[I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Changing a method return type will break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing a method to be abstract is a binary compatibility change.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_14_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:6aa0635:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getCooLen(java.lang.String) has changed from non abstract to abstract.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Changing a method to be abstract will break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing a method to not to be abstract is not a binary compatibility change.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_14_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC + ACC_ABASTRACT, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
7:9822203:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Changing a method not to be abstract will not break binary compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing an instance method that is not final to be final is a binary compatibility change.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_15_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
2:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getCooLen(java.lang.String) was not final but has been changed to be final.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Changing an instance method from non-final to final will break binary compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing an instance method that is final to be non-final is a binary compatibility change.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_15_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Changing an instance method from final to non-final will not break binary compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing a static method that is not final to final is not a binary compatibility change.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_15_3() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC + ACC_FINAL, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Changing a static method from non-final to final will not break binary compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Adding a native modifier of a method does not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_16_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC + ACC_NATIVE, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Adding a native modifier of a method does not break compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Deleting a native modifier of a method does not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_16_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_NATIVE, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Adding a native modifier of a method does not break compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a method is not private was not declared static and is changed to be declared static, this breaks compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_17_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
4:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getCooLen(java.lang.String) has changed from static to non-static or vice versa.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "If a method is not private was not declared static and is changed to be decalared static, this should break compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a method is not private was declared static and is changed to not be declared static, this breaks compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_17_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getCooLen(java.lang.String) has changed from static to non-static or vice versa.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "If a method is not private was declared static and is changed to not be decalared static, this should break compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * If a method is  private was declared static and is changed to not be declared static, this does not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_17_3() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PRIVATE + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:9822203:         cw.visitMethod(ACC_PRIVATE, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:6aa0635: 
1:6aa0635:         assertTrue(
1:6aa0635:                 "If a method is private was declared static and is changed to not be decalared static, this should not break compatibility.",
1:6aa0635:                 bcs.isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Adding a synchronized modifier of a method does not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_18_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_SYNCHRONIZED, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Adding a synchronized modifier of a method does not break compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Deleting a synchronized modifier of a method does not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_4_18_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_SYNCHRONIZED, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:6aa0635:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:6aa0635:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Adding a synchronized modifier of a method does not break compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing an interface that is not declared public to be declared public does not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_5_1_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertTrue(
1:6aa0635:                 "Changing an interface that is not declared public to be declared public should not break compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing an interface that is declared public to not be declared public should break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_5_1_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635:         assertNull(
1:6aa0635:                 "Changing an interface that is declared public to not be declared public should break compatibility.",
1:6aa0635:                 newCV.getClassDeclaration());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changes to the interface hierarchy resulting an interface not being a super interface should break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_5_2_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", null);
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getFoo", "I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635: 
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals(new HashSet<String>(Arrays.asList(new String[] {"The public field bar has been deleted.",
1:490f397:                 "The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestB].",
1:490f397:                 "The method java.lang.String getFoo() has been deleted or its return type or parameter list has changed."})), new HashSet<String>(bcs));
1:f9b43fb:         assertFalse(
1:6aa0635:                 "Changes to the interface hierarchy resulting an interface not being a super interface should break compatibility.",
1:6aa0635:                 bcs.isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Deleting a method in an interface should break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_5_3_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getFoo", "()I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635: 
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Deleting a method in an interface should break compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Adding a method in an interface should not break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_5_3_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getFoo", "()I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getFoo", "()I", null, null).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getMoo", "()I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635: 
1:6aa0635:         assertTrue(
1:6aa0635:                 "Adding a method in an interface should not break compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing a method return type in an interface should  break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_5_5_1() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getFoo", "()I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getFoo", "(I)I", null, null).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getMoo", "()I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635: 
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Changing a method return type in an interface should  break compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Changing a method parameter in an interface should  break compatibility.
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_jdk_chap13_5_5_2() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getFoo", "(I)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getFoo", "(IZ)I", null, null).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC, "getMoo", "I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635: 
1:6aa0635:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:490f397:         assertEquals("The method int getFoo(int) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:490f397:         assertTrue(
1:6aa0635:                 "Changing a method parameter in an interface should  break compatibility.",
1:490f397:                 bcs.size() == 1);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Check containing more abstract methods
1:6aa0635:      */
1:6aa0635:     @Test
1:490f397:     public void test_containing_more_abstract_methods() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getFoo", "(I)I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getFoo", "(I)I", null, null).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getMoo", "()I", null, null).visitEnd();
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635: 
1:6aa0635:         assertTrue(
1:6aa0635:                 "Adding an abstract methods should not break compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
1:6aa0635: 
1:f9b43fb:         Collection<MethodDeclaration> extraMethods = newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration());
1:f9b43fb:         assertEquals(1, extraMethods.size());
1:f9b43fb:         for (MethodDeclaration md : extraMethods) {
1:f9b43fb:             assertEquals(
1:f9b43fb:                     "getMoo", md.getName());
1:f9b43fb:         }
1:6aa0635:     }
1:f9b43fb: 
1:6aa0635:     /**
1:6aa0635:      * Check not containing more abstract methods
1:6aa0635:      */
1:6aa0635:     @Test
1:9822203:     public void test_not_cotaining_more_abstract_methods() {
1:6aa0635:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getFoo", "(I)I", null, null).visitEnd();
1:f9b43fb:         cw.visitEnd();
1:6aa0635:         byte[] oldBytes = cw.toByteArray();
1:f9b43fb: 
1:f9b43fb: 
1:6aa0635:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getFoo", "(I)I", null, null).visitEnd();
1:6aa0635: 
1:6aa0635:         cw.visitEnd();
1:6aa0635:         byte[] newBytes = cw.toByteArray();
1:6aa0635:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:6aa0635:         ClassReader newCR = new ClassReader(newBytes);
1:6aa0635:         ClassReader oldCR = new ClassReader(oldBytes);
1:6aa0635: 
1:6aa0635:         newCR.accept(newCV, 0);
1:6aa0635:         oldCR.accept(oldCV, 0);
1:6aa0635: 
1:6aa0635:         assertTrue(
1:6aa0635:                 "No change should not break compatibility.",
1:6aa0635:                 newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
1:6aa0635: 
1:6aa0635: 
1:f9b43fb:         assertEquals(
1:f9b43fb:                 "Containing more abstract methods should return false.", 0,
1:f9b43fb:                 newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration()).size());
1:f9b43fb:     }
1:f9b43fb: 
1:f9b43fb:     @Test
1:9822203:     public void test_ignore_clinit() {
1:f9b43fb:         ClassWriter cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitField(ACC_PUBLIC, "foo", "I", null, null).visitEnd();
1:f9b43fb:         cw.visitEnd();
1:f9b43fb:         byte[] oldBytes = cw.toByteArray();
1:f9b43fb: 
1:f9b43fb: 
1:f9b43fb:         cw = new ClassWriter(0);
1:9822203:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:9822203:         cw.visitField(ACC_PUBLIC + ACC_STATIC, "bar", "I", null, null).visitEnd();
1:9822203:         cw.visitField(ACC_PUBLIC, "foo", "I", null, null).visitEnd();
1:9822203:         cw.visitMethod(ACC_PUBLIC, "<clinit>", "()V", null, null).visitEnd();
1:f9b43fb: 
1:6aa0635:         cw.visitEnd();
1:f9b43fb:         byte[] newBytes = cw.toByteArray();
1:f9b43fb:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:f9b43fb:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:f9b43fb:         ClassReader newCR = new ClassReader(newBytes);
1:f9b43fb:         ClassReader oldCR = new ClassReader(oldBytes);
1:f9b43fb: 
1:f9b43fb:         newCR.accept(newCV, 0);
1:f9b43fb:         oldCR.accept(oldCV, 0);
1:6aa0635: 
1:f9b43fb:         assertTrue(
1:f9b43fb:                 "No change should not break compatibility.",
1:f9b43fb:                 newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
1:6aa0635: 
1:6aa0635: 
1:f9b43fb:         assertEquals(
1:f9b43fb:                 "Containing more abstract methods should return false.", 0,
1:f9b43fb:                 newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration()).size());
1:6aa0635:     }
1:9822203: 
1:6aa0635: }
============================================================================
author:Emily Jiang
-------------------------------------------------------------------------------
commit:cb248d1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(new HashSet<String>(Arrays.asList(new String[] {
1:                 bcs.size() == 1);
commit:f9b43fb
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.versioning.tests;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.versioning.utils.MethodDeclaration;
0: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.htmlOneLineBreak;
0: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.htmlTwoLineBreaks;
/////////////////////////////////////////////////////////////////////////
1:  * @author emily
1:  *
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(" The class pkg/Test was not abstract but is changed to be abstract.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(" The class pkg/Test was not final but is changed to be final.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestBChild", null);
1: 
/////////////////////////////////////////////////////////////////////////
1:   
1:   /**
1:    * Changing field type breaks binary compatibility 
1:    * with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members but the one of the fields has changed type.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_7_4() throws IOException
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[] { "versioning/java/files/TestB" });
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1: 
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:     assertFalse(
1:         "Changing the direct superclass or the set of direct superinterfaces of a class type results fields changes. This should breake binary compatibility if not losing any members.",
1:         bcs.isCompatible());
0:     assertEquals("&#13;&#10;The public field bar was static but is changed to be non static or vice versa.&#13;&#10;The public field bar has changed its type.", bcs.getReason());
1:   }
1: 
1:   /**
1:    * Change the signature of the field from Colllection<AA> to Collection<String>
1:    */
1:   @Test
1:   public void test_jdk_chap13_4_7_5() {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitField(ACC_PUBLIC, "more", "Ljava/util/Collection;", "Lcom/bim/AA;", null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitField(ACC_PROTECTED, "more", "Ljava/util/Collection;", "Ljava/lang/String;", null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals(htmlOneLineBreak  +"The public field more has changed its type.&#13;&#10;The public field more becomes less accessible.", bcs.getReason());
1:     assertFalse(
1:         "Changing the declared access of a field to permit less access  , this should break binary compatibility.",
1:         bcs.isCompatible());
1:   }
/////////////////////////////////////////////////////////////////////////
0:    assertEquals("&#13;&#10;&#13;&#10;The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestC, versioning/java/files/TestA].&#13;&#10;The method int getFooLen(java.lang.String) has been deleted or its return type or parameter list has changed.&#13;&#10;The method int getBooLen(java.lang.String) has been deleted or its return type or parameter list has changed.&#13;&#10;The method java.lang.String getFoo() has changed from non abstract to abstract. &#13;&#10;The method int getBarLen(java.lang.String) has been deleted or its return type or parameter list has changed.&#13;&#10;The protcted field c has been deleted.&#13;&#10;The public field bar was not final but has been changed to be final.&#13;&#10;The public field bar was static but is changed to be non static or vice versa.&#13;&#10;The public field bar has changed its type.", bcs.getReason()); 
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int convert(java.lang.Object) has been deleted or its return type or parameter list has changed.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int convert(java.lang.Object) is less accessible.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The public field lESS becomes less accessible.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The public field bar becomes less accessible.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The public field aa was not final but has been changed to be final.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The public field aa was static but is changed to be non static or vice versa.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The public field aa was static but is changed to be non static or vice versa.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getFooLen(java.lang.STring) has been deleted or its return type or parameter list has changed.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getFooLen(java.lang.String) is less accessible.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/Object;)I", null, null).visitEnd();
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
1:    * Changing a method formal type parameter is not a binary compatibility change.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_12_3()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/util/List;)I", "Ljava/lang/String;", null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/util/List;)I", "Lcome/ibm/blah;", null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:     assertTrue(
1:         "Changing a method formal type parameter should not break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1:   /**
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getCooLen(java.lang.String) has changed from non abstract to abstract. ", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getCooLen(java.lang.String) was not final but has been changed to be final.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getCooLen(java.lang.String) has changed from static to non-static or vice versa.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getCooLen(java.lang.String) has changed from static to non-static or vice versa.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals("&#13;&#10;The method java.lang.String getFoo() has been deleted or its return type or parameter list has changed.&#13;&#10;The public field bar has been deleted.&#13;&#10;&#13;&#10;The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestB]."  , bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(htmlOneLineBreak  +"The method int getFoo(int) has been deleted or its return type or parameter list has changed.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
1:     Collection<MethodDeclaration> extraMethods = newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration());
1:     assertEquals(1, extraMethods.size());
1:     for (MethodDeclaration md : extraMethods) {
1:       assertEquals(
1:           "getMoo", md.getName());
1:     }
/////////////////////////////////////////////////////////////////////////
1:     assertEquals(
1:         "Containing more abstract methods should return false.", 0,
1:         newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration()).size());
1:   }
1:   
1:   @Test
0:   public void test_ignore_clinit()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC , "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitField(ACC_PUBLIC , "foo", "I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC , "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitField(ACC_PUBLIC + ACC_STATIC , "bar", "I", null, null).visitEnd();
0:     cw.visitField(ACC_PUBLIC , "foo", "I", null, null).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC , "<clinit>", "()V", null, null).visitEnd();
1: 
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1: 
1:     assertTrue(
1:         "No change should not break compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
1: 
1:     
1:     assertEquals(
1:         "Containing more abstract methods should return false.", 0,
1:         newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration()).size());
commit:6aa0635
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
0: package org.apache.aries.versioning.impl.org.apache.aries.versioning.utils;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
1: import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
1: import static org.objectweb.asm.Opcodes.ACC_FINAL;
1: import static org.objectweb.asm.Opcodes.ACC_INTERFACE;
1: import static org.objectweb.asm.Opcodes.ACC_NATIVE;
1: import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
1: import static org.objectweb.asm.Opcodes.ACC_PROTECTED;
1: import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
1: import static org.objectweb.asm.Opcodes.ACC_STATIC;
1: import static org.objectweb.asm.Opcodes.ACC_SYNCHRONIZED;
1: import static org.objectweb.asm.Opcodes.ACC_TRANSIENT;
1: import static org.objectweb.asm.Opcodes.V1_5;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.util.Collection;
1: import java.util.HashSet;
1: 
1: import org.apache.aries.versioning.utils.BinaryCompatibilityStatus;
1: import org.apache.aries.versioning.utils.SemanticVersioningClassVisitor;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: import org.objectweb.asm.ClassReader;
1: import org.objectweb.asm.ClassWriter;
1: 
1: 
1: /**
1:  * Test the jdk chap 13 -binary compatibility implementation
1:  * 
1:  */
0: public class BinaryCompatibilityTest
0: {
1: 
1:   private static final int ACC_ABASTRACT = 0;
1:   private static URLClassLoader loader = null;
1:   @BeforeClass
0:   public  static void setup() throws Exception{
1:     Collection<URL> urls = new HashSet<URL>();
1:     urls.add(new File("unitest/").toURI().toURL());
1:     loader = new URLClassLoader(urls.toArray(new URL[0]));
1:   } 
1: 
1:   /**
1:    * Test of binary incompatibility where a class was not abstract is changed to be declared abstract, 
1:    * 
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_1_1()
0:   {
1:     // construct original class
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertFalse(
1:         "When a class is changed from non abstract to abstract, this should break binary compatibility.",
1:         bcs.isCompatible());
1: 
0:     assertEquals("The class pkg/Test was not abstract but is changed to be abstract.", bcs.getReason());
1:   }
1: 
1:   /**
1:    * Test of binary compatibility where a class was abstract is changed to be declared non-abstract, 
1:    * 
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_1_2()
0:   {
1:     // construct original class
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1: 
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:     assertTrue(
1:         "When a class is changed from static to non-static, this should not break binary compatibility.",
1:         bcs.isCompatible());
1:    
1:     
1: 
1:   }
1: 
1:   /**
1:    * Test a binary incompatibility where a class was not final is changed to be final.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_2_1()
0:   {
1:     // construct original class
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertFalse(
1:         "When a class is changed from non final to final, this should break binary compatibility.",
1:         bcs.isCompatible());
1: 
0:     assertEquals("The class pkg/Test was not final but is changed to be final.", bcs.getReason());
1:   }
1: 
1:   /**
1:    * Test a binary compatibility where a class was final is changed to not final.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_2_2()
0:   {
1:     // construct original class
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:     assertTrue(
1:         "When a class is changed from final to not final, this should not break binary compatibility.",
1:         bcs.isCompatible());
1:     
1:   }
1: 
1:   /**
1:    * Test a binary incompatibility where a class was public is changed to not public.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_3_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertNull(
1:         "When a class is changed from public to non-public, this should break binary compatibility.",
1:         newCV.getClassDeclaration());
1: 
1:   }
1: 
1:   /**
1:    * Test a binary incompatibility where a class was not public is changed to public.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_3_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "When a class is changed from non-public to public, this should break binary compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * Changing the direct superclass or the set of direct superinterfaces of a class type will not break compatibility 
1:    * with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_4_1() throws IOException
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[] { "versioning/java/files/TestB" });
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Changing the direct superclass or the set of direct superinterfaces of a class type will not breake binary compatibility if not losing any members.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_4_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[] { "versioning/java/files/TestB" });
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertFalse(
1:         "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:         bcs.isCompatible());
0:    assertEquals("The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestC, versioning/java/files/TestA]", bcs.getReason()); 
1:   }
1: 
1:   /**
1:    * Test deleting a class member or constructor that is not declared private/default breaks binary compatibility.
1:    */
1:   @Test
1:   public void test_jdk_chap13_4_5_1() {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:     cw.visitMethod(ACC_PROTECTED+ ACC_ABSTRACT, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1: 
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));    
0:     assertEquals("The method int convert(java/lang/Object) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:     assertFalse(
1:         "deleting a class member or constructor that is not declared private breaks binary compatibility.",
1:         bcs.isCompatible());
1:     
1:   }
1: 
1:   /**
1:    * Test deleting a class member or constructor that is declared private should not break binary compatibility.
1:    */
1:   @Test
1:   public void test_jdk_chap13_4_5_2() {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitMethod(ACC_PRIVATE, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1: 
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Deleting a class member or constructor that is declared private should not break binary compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * Test adding a class member or constructor should not break binary compatibility.
1:    */
1:   @Test
1:   public void test_jdk_chap13_4_5_3() {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1: 
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitMethod(ACC_PROTECTED, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Adding a class member or constructor should not break binary compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1: 
1:   /**
1:    * Test changing the declared access of a method to permit less access, this should break compatibility.
1:    */
1:   @Test
1:   public void test_jdk_chap13_4_6_2() {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:     cw.visitMethod( ACC_STATIC, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int convert(java/lang/Object) is less accessible.", bcs.getReason());
0:     assertFalse(
1:         "Changing the declared access of a member or contructor to permit less access  , this should break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   @Test
1:   public void test_jdk_chap13_4_6_1() {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitField(ACC_PUBLIC, "lESS", "I", null, new Integer(-1)).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitField(ACC_PROTECTED, "lESS", "I", null, new Integer(-1)).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The public or protected field lESS is less accessible.", bcs.getReason());
0:     assertFalse(
1:         "Changing the declared access of a field to permit less access  , this should break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1:   /**
1:    * Test deleting a private/default field, this should not break compatibility.
1:    */
1:   @Test
1:   public void test_jdk_chap13_4_7_1() {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:     cw.visitField(ACC_PRIVATE, "lESS", "I", null, new Integer(-1)).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:     cw.visitMethod( ACC_PROTECTED, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Deleting a private field should not break binary compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * If a field is added but is less accessible than the old one or change to static from non-static or from non-static to static.
1:    * 
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_7_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PROTECTED, "bar", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The new field bar conflicts with the same field in its super class. For more details, check the Binary Compatibility section(Chapter 13) of the Java Specification.", bcs.getReason());
0:     assertFalse(
1:         "The new field conflicts with a field in the super class. Check chapter 13.4.7 java spec for more info.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * If a field was not final is changed to be final, then it can break compatibility.
1:    * 
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_8_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_FINAL, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The public or protected field aa was not final but has been changed to be final.", bcs.getReason());
0:     assertFalse(
1:         "Change that a public or protected field was final but is changed to be not final will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * If a field was final is changed to be non-final, then it does not break compatibility.
1:    * 
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_8_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_FINAL, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:     cw.visitField(ACC_PUBLIC , "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * If a field was static is changed to be non-static, then it will break compatibility.
1:    * 
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_9_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_STATIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:     cw.visitField(ACC_PUBLIC , "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The public or protected field aa was static but is changed to be non static or vice versa.", bcs.getReason());
0:     assertFalse(
1:         "If a field was static is changed to be non-static, then it will break compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * If a field was non-static is changed to be static, then it will break compatibility.
1:    * 
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_9_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:     cw.visitField(ACC_PUBLIC , "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_STATIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The public or protected field aa was static but is changed to be non static or vice versa.", bcs.getReason());
0:     assertFalse(
1:          "If a field was non-static is changed to be static, then it will break compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * If a field was transient is changed to non-transient, then it will not break compatibility.
1:    * 
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_10_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:     cw.visitField(ACC_PUBLIC , "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:     
1:     assertTrue(
1:         "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1:   /**
1:    * If a field was non-transient is changed to transient, then it will not break compatibility.
1:    * 
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_10_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:     cw.visitField(ACC_PUBLIC , "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:     
1:     assertTrue(
1:         "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Testing deleting a public/protected method when there is no such a method in the superclass breaks binary compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_11_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getFooLen", "(Ljava/lang/STring;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getFooLen(java/lang/STring) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:     assertFalse(
1:         "Deleting a public/protected method when there is no such a method in the superclass breaks binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Testing deleting a public/protected method when there is such a method in the superclass does not break binary compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_11_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getBarLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:     assertTrue(
1:         "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Testing deleting a public/protected method when there is less accessible method in the superclass does break binary compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_11_3()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getFooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getFooLen(java/lang/String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:     assertFalse(
1:         "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Adding a parameter is a binary compatibility change.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_12_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;I)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getCooLen(java/lang/String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:     assertFalse(
1:         "Changing a parameter list will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1: 
1:   /**
1:    * Changing a method parameter type is a binary compatibility change.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_12_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/Object)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getCooLen(java/lang/String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:     assertFalse(
1:         "Changing a method paramether type will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Changing a method return type is a binary compatibility change.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_13_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)[I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getCooLen(java/lang/String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:     assertFalse(
1:         "Changing a method return type will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Changing a method to be abstract is a binary compatibility change.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_14_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:     cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getCooLen(java/lang/String) has changed from non abstract to abstract. ", bcs.getReason());
0:     assertFalse(
1:         "Changing a method to be abstract will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Changing a method to not to be abstract is not a binary compatibility change.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_14_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC + ACC_ABASTRACT, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Changing a method not to be abstract will not break binary compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1: 
1:   /**
1:    * Changing an instance method that is not final to be final is a binary compatibility change.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_15_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC + ACC_FINAL , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getCooLen(java/lang/String) was not final but has been changed to be final.", bcs.getReason());
0:     assertFalse(
1:         "Changing an instance method from non-final to final will break binary compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Changing an instance method that is final to be non-final is a binary compatibility change.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_15_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Changing an instance method from final to non-final will not break binary compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * Changing a static method that is not final to final is not a binary compatibility change.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_15_3()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC + ACC_STATIC+ ACC_FINAL , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Changing a static method from non-final to final will not break binary compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * Adding a native modifier of a method does not break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_16_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC + ACC_STATIC+ ACC_NATIVE , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Adding a native modifier of a method does not break compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * Deleting a native modifier of a method does not break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_16_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:     cw.visitMethod(ACC_PUBLIC  + ACC_NATIVE, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC  , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Adding a native modifier of a method does not break compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * If a method is not private was not declared static and is changed to be declared static, this breaks compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_17_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:     cw.visitMethod(ACC_PUBLIC , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC + ACC_STATIC  , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getCooLen(java/lang/String) has changed from static to non-static or vice versa.", bcs.getReason());
0:     assertFalse(
1:         "If a method is not private was not declared static and is changed to be decalared static, this should break compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * If a method is not private was declared static and is changed to not be declared static, this breaks compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_17_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC  , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getCooLen(java/lang/String) has changed from static to non-static or vice versa.", bcs.getReason());
0:     assertFalse(
1:         "If a method is not private was declared static and is changed to not be decalared static, this should break compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * If a method is  private was declared static and is changed to not be declared static, this does not break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_17_3()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PRIVATE + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PRIVATE  , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
1:    
1:     assertTrue(
1:         "If a method is private was declared static and is changed to not be decalared static, this should not break compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Adding a synchronized modifier of a method does not break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_18_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);    
0:     cw.visitMethod(ACC_PUBLIC + ACC_SYNCHRONIZED  , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Adding a synchronized modifier of a method does not break compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * Deleting a synchronized modifier of a method does not break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_4_18_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:     cw.visitMethod(ACC_PUBLIC  + ACC_SYNCHRONIZED, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
1:     cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:     cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC   , "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Adding a synchronized modifier of a method does not break compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * Changing an interface that is not declared public to be declared public does not break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_5_1_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1: 
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1: 
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertTrue(
1:         "Changing an interface that is not declared public to be declared public should not break compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
1:   }
1: 
1:   /**
1:    * Changing an interface that is declared public to not be declared public should break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_5_1_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1: 
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5,  ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1: 
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1:     assertNull(
1:         "Changing an interface that is declared public to not be declared public should break compatibility.",
1:         newCV.getClassDeclaration());
1:   }
1: 
1:   /**
1:    * Changes to the interface hierarchy resulting an interface not being a super interface should break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_5_2_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1: 
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5,  ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", null);
0:     cw.visitMethod(ACC_PUBLIC   , "getFoo", "I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1: 
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestB]", bcs.getReason());
0:     assertFalse(
1:         "Changes to the interface hierarchy resulting an interface not being a super interface should break compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Deleting a method in an interface should break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_5_3_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC   , "getFoo", "()I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1: 
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1: 
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:     assertFalse(
1:         "Deleting a method in an interface should break compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Adding a method in an interface should not break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_5_3_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC   , "getFoo", "()I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC   , "getFoo", "()I", null, null).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC   , "getMoo", "()I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1: 
1:     assertTrue(
1:         "Adding a method in an interface should not break compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
1:   }
1: 
1:   /**
1:    * Changing a method return type in an interface should  break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_5_5_1()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC   , "getFoo", "()I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC   , "getFoo", "(I)I", null, null).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC   , "getMoo", "()I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1: 
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:     assertFalse(
1:         "Changing a method return type in an interface should  break compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Changing a method parameter in an interface should  break compatibility.
1:    */
1:   @Test
0:   public void test_jdk_chap13_5_5_2()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC   , "getFoo", "(I)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC   , "getFoo", "(IZ)I", null, null).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC   , "getMoo", "I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1: 
1:     BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:     assertEquals("The method int getFoo(int) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:     assertFalse(
1:         "Changing a method parameter in an interface should  break compatibility.",
1:         bcs.isCompatible());
1:   }
1: 
1:   /**
1:    * Check containing more abstract methods
1:    */
1:   @Test
0:   public void test_cotaining_more_abstract_methods()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT  , "getFoo", "(I)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT   , "getFoo", "(I)I", null, null).visitEnd();
0:     cw.visitMethod(ACC_PUBLIC  + ACC_ABSTRACT , "getMoo", "()I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1: 
1:     assertTrue(
1:         "Adding an abstract methods should not break compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
1: 
0:     assertEquals(
0:         "getMoo",
0:         newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration()).getName());
1:   }
1: 
1:   /**
1:    * Check not containing more abstract methods
1:    */
1:   @Test
0:   public void test_not_cotaining_more_abstract_methods()
0:   {
1:     ClassWriter cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT  , "getFoo", "(I)I", null, null).visitEnd();
1:     cw.visitEnd();
1:     byte[] oldBytes = cw.toByteArray();
1: 
1: 
1:     cw = new ClassWriter(0);
0:     cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT+ ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:     cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT   , "getFoo", "(I)I", null, null).visitEnd();
1: 
1:     cw.visitEnd();
1:     byte[] newBytes = cw.toByteArray();
1:     SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
1:     SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
1:     ClassReader newCR = new ClassReader(newBytes);
1:     ClassReader oldCR = new ClassReader(oldBytes);
1: 
1:     newCR.accept(newCV, 0);
1:     oldCR.accept(oldCV, 0);
1: 
1:     assertTrue(
1:         "No change should not break compatibility.",
1:         newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
1: 
1:     
1:     assertNull(
0:         "Containing more abstract methods should return false.",
0:         newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration()));
1:   }
1: 
1: }
author:David Jencks
-------------------------------------------------------------------------------
commit:490f397
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(
1:                 bcs.size() == 1);
1:         assertEquals(" The class pkg/Test was not abstract but is changed to be abstract.", bcs.get(0));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(
1:                 bcs.size() == 1);
1:         assertEquals(" The class pkg/Test was not final but is changed to be final.", bcs.get(0));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(
1:                 bcs.size() == 2);
1:         assertEquals(new HashSet<String>(Arrays.asList(new String[] {"The public field bar was static but is changed to be non static or vice versa.",
1:                 "The public field bar has changed its type."})), new HashSet<String>(bcs));
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(new HashSet<String>(Arrays.asList(new String[] {"The public field more has changed its type.",
1:                 "The public field more becomes less accessible."})), new HashSet<String>(bcs));
1:         assertTrue(
0:                 bcs.size() == 2);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(new HashSet<String>(Arrays.asList(new String[] {"The method int getFooLen(java.lang.String) has been deleted or its return type or parameter list has changed.",
1:                 "The method java.lang.String getFoo() has changed from non abstract to abstract.",
1:                 "The method int getBarLen(java.lang.String) has been deleted or its return type or parameter list has changed.",
1:                 "The method int getBooLen(java.lang.String) has been deleted or its return type or parameter list has changed.",
1:                 "The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestC, versioning/java/files/TestA].",
1:                 "The protected field c has been deleted.",
1:                 "The public field bar was not final but has been changed to be final.",
1:                 "The public field bar was static but is changed to be non static or vice versa.",
1:                 "The public field bar has changed its type."})), new HashSet<String>(bcs));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int convert(java.lang.Object) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int convert(java.lang.Object) is less accessible.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The public field lESS becomes less accessible.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size()  == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The public field bar becomes less accessible.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The public field aa was not final but has been changed to be final.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The public field aa was static but is changed to be non static or vice versa.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The public field aa was static but is changed to be non static or vice versa.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getFooLen(java.lang.STring) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getFooLen(java.lang.String) is less accessible.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getCooLen(java.lang.String) has changed from non abstract to abstract.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getCooLen(java.lang.String) was not final but has been changed to be final.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getCooLen(java.lang.String) has changed from static to non-static or vice versa.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getCooLen(java.lang.String) has changed from static to non-static or vice versa.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(new HashSet<String>(Arrays.asList(new String[] {"The public field bar has been deleted.",
1:                 "The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestB].",
1:                 "The method java.lang.String getFoo() has been deleted or its return type or parameter list has changed."})), new HashSet<String>(bcs));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("The method int getFoo(int) has been deleted or its return type or parameter list has changed.", bcs.get(0));
1:         assertTrue(
1:                 bcs.size() == 1);
1:     public void test_containing_more_abstract_methods() {
commit:9822203
/////////////////////////////////////////////////////////////////////////
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *   http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
1: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:  * @author emily
1: public class BinaryCompatibilityTest {
0:     private static final int ACC_ABASTRACT = 0;
0:     private static URLClassLoader loader = null;
0:     @BeforeClass
1:     public static void setup() throws Exception {
0:         Collection<URL> urls = new HashSet<URL>();
0:         urls.add(new File("unitest/").toURI().toURL());
0:         loader = new URLClassLoader(urls.toArray(new URL[0]));
0:     /**
0:      * Test of binary incompatibility where a class was not abstract is changed to be declared abstract,
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_1_1() {
0:         // construct original class
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertFalse(
0:                 "When a class is changed from non abstract to abstract, this should break binary compatibility.",
0:                 bcs.isCompatible());
0: 
0:         assertEquals(" The class pkg/Test was not abstract but is changed to be abstract.", bcs.getReason());
0:     }
0: 
0:     /**
0:      * Test of binary compatibility where a class was abstract is changed to be declared non-abstract,
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_1_2() {
0:         // construct original class
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0: 
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertTrue(
0:                 "When a class is changed from static to non-static, this should not break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0:     /**
0:      * Test a binary incompatibility where a class was not final is changed to be final.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_2_1() {
0:         // construct original class
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertFalse(
0:                 "When a class is changed from non final to final, this should break binary compatibility.",
0:                 bcs.isCompatible());
0:         assertEquals(" The class pkg/Test was not final but is changed to be final.", bcs.getReason());
0:     }
0: 
0:     /**
0:      * Test a binary compatibility where a class was final is changed to not final.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_2_2() {
0:         // construct original class
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertTrue(
0:                 "When a class is changed from final to not final, this should not break binary compatibility.",
0:                 bcs.isCompatible());
0: 
0:     }
0: 
0:     /**
0:      * Test a binary incompatibility where a class was public is changed to not public.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_3_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertNull(
0:                 "When a class is changed from public to non-public, this should break binary compatibility.",
0:                 newCV.getClassDeclaration());
0: 
0:     }
0: 
0:     /**
0:      * Test a binary incompatibility where a class was not public is changed to public.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_3_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "When a class is changed from non-public to public, this should break binary compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * Changing the direct superclass or the set of direct superinterfaces of a class type will not break compatibility
0:      * with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_4_1() throws IOException {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestBChild", null);
0: 
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Changing the direct superclass or the set of direct superinterfaces of a class type will not breake binary compatibility if not losing any members.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * Changing field type breaks binary compatibility
0:      * with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members but the one of the fields has changed type.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_7_4() throws IOException {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0: 
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertFalse(
0:                 "Changing the direct superclass or the set of direct superinterfaces of a class type results fields changes. This should breake binary compatibility if not losing any members.",
0:                 bcs.isCompatible());
0:         assertEquals("&#13;&#10;The public field bar was static but is changed to be non static or vice versa.&#13;&#10;The public field bar has changed its type.", bcs.getReason());
0:     }
0: 
0:     /**
0:      * Change the signature of the field from Colllection<AA> to Collection<String>
0:      */
0:     @Test
0:     public void test_jdk_chap13_4_7_5() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitField(ACC_PUBLIC, "more", "Ljava/util/Collection;", "Lcom/bim/AA;", null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitField(ACC_PROTECTED, "more", "Ljava/util/Collection;", "Ljava/lang/String;", null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The public field more has changed its type.&#13;&#10;The public field more becomes less accessible.", bcs.getReason());
0:         assertFalse(
0:                 "Changing the declared access of a field to permit less access  , this should break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_4_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertFalse(
0:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
0:                 bcs.isCompatible());
0:         assertEquals("&#13;&#10;The method int getFooLen(java.lang.String) has been deleted or its return type or parameter list has changed.&#13;&#10;The method java.lang.String getFoo() has changed from non abstract to abstract. &#13;&#10;The method int getBarLen(java.lang.String) has been deleted or its return type or parameter list has changed.&#13;&#10;The method int getBooLen(java.lang.String) has been deleted or its return type or parameter list has changed.&#13;&#10;&#13;&#10;The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestC, versioning/java/files/TestA].&#13;&#10;The protcted field c has been deleted.&#13;&#10;The public field bar was not final but has been changed to be final.&#13;&#10;The public field bar was static but is changed to be non static or vice versa.&#13;&#10;The public field bar has changed its type.", bcs.getReason());
0:     }
0:     /**
0:      * Test deleting a class member or constructor that is not declared private/default breaks binary compatibility.
0:      */
0:     @Test
0:     public void test_jdk_chap13_4_5_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:         cw.visitMethod(ACC_PROTECTED + ACC_ABSTRACT, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int convert(java.lang.Object) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:         assertFalse(
0:                 "deleting a class member or constructor that is not declared private breaks binary compatibility.",
0:                 bcs.isCompatible());
0: 
0:     }
0: 
0:     /**
0:      * Test deleting a class member or constructor that is declared private should not break binary compatibility.
0:      */
0:     @Test
0:     public void test_jdk_chap13_4_5_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitMethod(ACC_PRIVATE, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0: 
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Deleting a class member or constructor that is declared private should not break binary compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * Test adding a class member or constructor should not break binary compatibility.
0:      */
0:     @Test
0:     public void test_jdk_chap13_4_5_3() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0: 
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:         cw.visitMethod(ACC_PROTECTED, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Adding a class member or constructor should not break binary compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0: 
0:     /**
0:      * Test changing the declared access of a method to permit less access, this should break compatibility.
0:      */
0:     @Test
0:     public void test_jdk_chap13_4_6_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:         cw.visitMethod(ACC_STATIC, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int convert(java.lang.Object) is less accessible.", bcs.getReason());
0:         assertFalse(
0:                 "Changing the declared access of a member or contructor to permit less access  , this should break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     @Test
0:     public void test_jdk_chap13_4_6_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitField(ACC_PUBLIC, "lESS", "I", null, new Integer(-1)).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitField(ACC_PROTECTED, "lESS", "I", null, new Integer(-1)).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The public field lESS becomes less accessible.", bcs.getReason());
0:         assertFalse(
0:                 "Changing the declared access of a field to permit less access  , this should break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Test deleting a private/default field, this should not break compatibility.
0:      */
0:     @Test
0:     public void test_jdk_chap13_4_7_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
0:         cw.visitField(ACC_PRIVATE, "lESS", "I", null, new Integer(-1)).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", null);
1:         cw.visitMethod(ACC_PROTECTED, "convert", "(Ljava/lang/Object;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Deleting a private field should not break binary compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * If a field is added but is less accessible than the old one or change to static from non-static or from non-static to static.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_7_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PROTECTED, "bar", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The public field bar becomes less accessible.", bcs.getReason());
0:         assertFalse(
0:                 "The new field conflicts with a field in the super class. Check chapter 13.4.7 java spec for more info.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * If a field was not final is changed to be final, then it can break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_8_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_FINAL, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The public field aa was not final but has been changed to be final.", bcs.getReason());
0:         assertFalse(
0:                 "Change that a public or protected field was final but is changed to be not final will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * If a field was final is changed to be non-final, then it does not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_8_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_FINAL, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * If a field was static is changed to be non-static, then it will break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_9_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_STATIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The public field aa was static but is changed to be non static or vice versa.", bcs.getReason());
0:         assertFalse(
0:                 "If a field was static is changed to be non-static, then it will break compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * If a field was non-static is changed to be static, then it will break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_9_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_STATIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The public field aa was static but is changed to be non static or vice versa.", bcs.getReason());
0:         assertFalse(
0:                 "If a field was non-static is changed to be static, then it will break compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * If a field was transient is changed to non-transient, then it will not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_10_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0: 
0:         assertTrue(
0:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * If a field was non-transient is changed to transient, then it will not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_10_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0: 
0:         assertTrue(
0:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Testing deleting a public/protected method when there is no such a method in the superclass breaks binary compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_11_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitMethod(ACC_PUBLIC, "getFooLen", "(Ljava/lang/STring;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getFooLen(java.lang.STring) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:         assertFalse(
0:                 "Deleting a public/protected method when there is no such a method in the superclass breaks binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Testing deleting a public/protected method when there is such a method in the superclass does not break binary compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_11_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitMethod(ACC_PUBLIC, "getBarLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertTrue(
0:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Testing deleting a public/protected method when there is less accessible method in the superclass does break binary compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_11_3() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitMethod(ACC_PUBLIC, "getFooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getFooLen(java.lang.String) is less accessible.", bcs.getReason());
0:         assertFalse(
0:                 "If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, it will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Adding a parameter is a binary compatibility change.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_12_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;I)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:         assertFalse(
0:                 "Changing a parameter list will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0: 
0:     /**
0:      * Changing a method parameter type is a binary compatibility change.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_12_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/Object;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:         assertFalse(
0:                 "Changing a method paramether type will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Changing a method formal type parameter is not a binary compatibility change.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_12_3() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/util/List;)I", "Ljava/lang/String;", null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0: 
0:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/util/List;)I", "Lcome/ibm/blah;", null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertTrue(
0:                 "Changing a method formal type parameter should not break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Changing a method return type is a binary compatibility change.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_13_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)[I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getCooLen(java.lang.String) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:         assertFalse(
0:                 "Changing a method return type will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Changing a method to be abstract is a binary compatibility change.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_14_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
0:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getCooLen(java.lang.String) has changed from non abstract to abstract. ", bcs.getReason());
0:         assertFalse(
0:                 "Changing a method to be abstract will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Changing a method to not to be abstract is not a binary compatibility change.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_14_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitMethod(ACC_PUBLIC + ACC_ABASTRACT, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Changing a method not to be abstract will not break binary compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0: 
0:     /**
0:      * Changing an instance method that is not final to be final is a binary compatibility change.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_15_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getCooLen(java.lang.String) was not final but has been changed to be final.", bcs.getReason());
0:         assertFalse(
0:                 "Changing an instance method from non-final to final will break binary compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Changing an instance method that is final to be non-final is a binary compatibility change.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_15_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Changing an instance method from final to non-final will not break binary compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * Changing a static method that is not final to final is not a binary compatibility change.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_15_3() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC + ACC_FINAL, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Changing a static method from non-final to final will not break binary compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * Adding a native modifier of a method does not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_16_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC + ACC_NATIVE, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Adding a native modifier of a method does not break compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * Deleting a native modifier of a method does not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_16_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC + ACC_NATIVE, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Adding a native modifier of a method does not break compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * If a method is not private was not declared static and is changed to be declared static, this breaks compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_17_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getCooLen(java.lang.String) has changed from static to non-static or vice versa.", bcs.getReason());
0:         assertFalse(
0:                 "If a method is not private was not declared static and is changed to be decalared static, this should break compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * If a method is not private was declared static and is changed to not be declared static, this breaks compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_17_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getCooLen(java.lang.String) has changed from static to non-static or vice versa.", bcs.getReason());
0:         assertFalse(
0:                 "If a method is not private was declared static and is changed to not be decalared static, this should break compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * If a method is  private was declared static and is changed to not be declared static, this does not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_17_3() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitMethod(ACC_PRIVATE + ACC_STATIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
0:         cw.visitField(ACC_PUBLIC + ACC_TRANSIENT, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PRIVATE, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0: 
0:         assertTrue(
0:                 "If a method is private was declared static and is changed to not be decalared static, this should not break compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Adding a synchronized modifier of a method does not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_18_1() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC + ACC_SYNCHRONIZED, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Adding a synchronized modifier of a method does not break compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * Deleting a synchronized modifier of a method does not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_4_18_2() {
0:         ClassWriter cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitMethod(ACC_PUBLIC + ACC_SYNCHRONIZED, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
0:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "versioning/java/files/TestA", null);
1:         cw.visitField(ACC_PUBLIC, "aa", "Ljava/lang/String;", null, new String("newBar")).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC, "getCooLen", "(Ljava/lang/String;)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Adding a synchronized modifier of a method does not break compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * Changing an interface that is not declared public to be declared public does not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_5_1_1() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0: 
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0: 
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertTrue(
0:                 "Changing an interface that is not declared public to be declared public should not break compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration())).isCompatible());
0:     }
0: 
0:     /**
0:      * Changing an interface that is declared public to not be declared public should break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_5_1_2() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0: 
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0: 
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0:         assertNull(
0:                 "Changing an interface that is declared public to not be declared public should break compatibility.",
0:                 newCV.getClassDeclaration());
0:     }
0: 
0:     /**
0:      * Changes to the interface hierarchy resulting an interface not being a super interface should break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_5_2_1() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0: 
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", null);
1:         cw.visitMethod(ACC_PUBLIC, "getFoo", "I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0: 
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals("&#13;&#10;The public field bar has been deleted.&#13;&#10;&#13;&#10;The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestB].&#13;&#10;The method java.lang.String getFoo() has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:         assertFalse(
0:                 "Changes to the interface hierarchy resulting an interface not being a super interface should break compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Deleting a method in an interface should break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_5_3_1() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC, "getFoo", "()I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
0: 
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0: 
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:         assertFalse(
0:                 "Deleting a method in an interface should break compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Adding a method in an interface should not break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_5_3_2() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC, "getFoo", "()I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC, "getFoo", "()I", null, null).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC, "getMoo", "()I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0: 
0:         assertTrue(
0:                 "Adding a method in an interface should not break compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
0:     }
0: 
0:     /**
0:      * Changing a method return type in an interface should  break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_5_5_1() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC, "getFoo", "()I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC, "getFoo", "(I)I", null, null).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC, "getMoo", "()I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0: 
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getFoo() has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:         assertFalse(
0:                 "Changing a method return type in an interface should  break compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Changing a method parameter in an interface should  break compatibility.
0:      */
0:     @Test
1:     public void test_jdk_chap13_5_5_2() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC, "getFoo", "(I)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC, "getFoo", "(IZ)I", null, null).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC, "getMoo", "I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0: 
0:         BinaryCompatibilityStatus bcs = newCV.getClassDeclaration().getBinaryCompatibleStatus((oldCV.getClassDeclaration()));
0:         assertEquals(htmlOneLineBreak + "The method int getFoo(int) has been deleted or its return type or parameter list has changed.", bcs.getReason());
0:         assertFalse(
0:                 "Changing a method parameter in an interface should  break compatibility.",
0:                 bcs.isCompatible());
0:     }
0: 
0:     /**
0:      * Check containing more abstract methods
0:      */
0:     @Test
0:     public void test_cotaining_more_abstract_methods() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getFoo", "(I)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getFoo", "(I)I", null, null).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getMoo", "()I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0: 
0:         assertTrue(
0:                 "Adding an abstract methods should not break compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
0: 
0:         Collection<MethodDeclaration> extraMethods = newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration());
0:         assertEquals(1, extraMethods.size());
0:         for (MethodDeclaration md : extraMethods) {
0:             assertEquals(
0:                     "getMoo", md.getName());
0:         }
0:     }
0: 
0:     /**
0:      * Check not containing more abstract methods
0:      */
0:     @Test
1:     public void test_not_cotaining_more_abstract_methods() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getFoo", "(I)I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getFoo", "(I)I", null, null).visitEnd();
0: 
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0: 
0:         assertTrue(
0:                 "No change should not break compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
0: 
0: 
0:         assertEquals(
0:                 "Containing more abstract methods should return false.", 0,
0:                 newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration()).size());
0:     }
0: 
0:     @Test
1:     public void test_ignore_clinit() {
0:         ClassWriter cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitField(ACC_PUBLIC, "foo", "I", null, null).visitEnd();
0:         cw.visitEnd();
0:         byte[] oldBytes = cw.toByteArray();
0: 
0: 
0:         cw = new ClassWriter(0);
1:         cw.visit(V1_5, ACC_PUBLIC, "pkg/Test", null, "java/lang/Object", new String[]{"versioning/java/files/TestB"});
1:         cw.visitField(ACC_PUBLIC + ACC_STATIC, "bar", "I", null, null).visitEnd();
1:         cw.visitField(ACC_PUBLIC, "foo", "I", null, null).visitEnd();
1:         cw.visitMethod(ACC_PUBLIC, "<clinit>", "()V", null, null).visitEnd();
0: 
0:         cw.visitEnd();
0:         byte[] newBytes = cw.toByteArray();
0:         SemanticVersioningClassVisitor oldCV = new SemanticVersioningClassVisitor(loader);
0:         SemanticVersioningClassVisitor newCV = new SemanticVersioningClassVisitor(loader);
0:         ClassReader newCR = new ClassReader(newBytes);
0:         ClassReader oldCR = new ClassReader(oldBytes);
0: 
0:         newCR.accept(newCV, 0);
0:         oldCR.accept(oldCV, 0);
0: 
0:         assertTrue(
0:                 "No change should not break compatibility.",
0:                 newCV.getClassDeclaration().getBinaryCompatibleStatus(oldCV.getClassDeclaration()).isCompatible());
0: 
0: 
0:         assertEquals(
0:                 "Containing more abstract methods should return false.", 0,
0:                 newCV.getClassDeclaration().getExtraMethods(oldCV.getClassDeclaration()).size());
0:     }
commit:715f153
/////////////////////////////////////////////////////////////////////////
0:    assertEquals("&#13;&#10;The method int getFooLen(java.lang.String) has been deleted or its return type or parameter list has changed.&#13;&#10;The method java.lang.String getFoo() has changed from non abstract to abstract. &#13;&#10;The method int getBarLen(java.lang.String) has been deleted or its return type or parameter list has changed.&#13;&#10;The method int getBooLen(java.lang.String) has been deleted or its return type or parameter list has changed.&#13;&#10;&#13;&#10;The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestC, versioning/java/files/TestA].&#13;&#10;The protcted field c has been deleted.&#13;&#10;The public field bar was not final but has been changed to be final.&#13;&#10;The public field bar was static but is changed to be non static or vice versa.&#13;&#10;The public field bar has changed its type.", bcs.getReason());
/////////////////////////////////////////////////////////////////////////
0:     assertEquals("&#13;&#10;The public field bar has been deleted.&#13;&#10;&#13;&#10;The superclasses or superinterfaces have stopped being super: [versioning/java/files/TestB].&#13;&#10;The method java.lang.String getFoo() has been deleted or its return type or parameter list has changed."  , bcs.getReason());
============================================================================