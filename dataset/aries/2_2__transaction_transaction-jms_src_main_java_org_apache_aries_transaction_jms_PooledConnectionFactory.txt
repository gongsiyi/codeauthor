1:4243a2b: /**
1:4243a2b:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:4243a2b:  * contributor license agreements.  See the NOTICE file distributed with
1:4243a2b:  * this work for additional information regarding copyright ownership.
1:4243a2b:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:4243a2b:  * (the "License"); you may not use this file except in compliance with
1:4243a2b:  * the License.  You may obtain a copy of the License at
1:4243a2b:  *
1:4243a2b:  *      http://www.apache.org/licenses/LICENSE-2.0
1:4243a2b:  *
1:4243a2b:  * Unless required by applicable law or agreed to in writing, software
1:4243a2b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4243a2b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4243a2b:  * See the License for the specific language governing permissions and
1:4243a2b:  * limitations under the License.
1:4243a2b:  */
1:4243a2b: package org.apache.aries.transaction.jms;
6:4243a2b: 
1:4243a2b: import java.util.concurrent.atomic.AtomicBoolean;
1:8047ebe: 
1:4243a2b: import javax.jms.Connection;
1:4243a2b: import javax.jms.ConnectionFactory;
1:4243a2b: import javax.jms.JMSException;
1:4c2ef4a: import javax.jms.XAConnection;
1:4c2ef4a: import javax.jms.XAConnectionFactory;
1:4243a2b: 
1:4243a2b: import org.apache.aries.transaction.jms.internal.ConnectionKey;
1:4243a2b: import org.apache.aries.transaction.jms.internal.ConnectionPool;
1:4243a2b: import org.apache.aries.transaction.jms.internal.PooledConnection;
1:4c2ef4a: import org.apache.commons.pool.KeyedPoolableObjectFactory;
1:4c2ef4a: import org.apache.commons.pool.impl.GenericKeyedObjectPool;
1:4243a2b: import org.slf4j.Logger;
1:4243a2b: import org.slf4j.LoggerFactory;
1:4243a2b: 
1:4243a2b: /**
1:4243a2b:  * A JMS provider which pools Connection, Session and MessageProducer instances
1:4c2ef4a:  * so it can be used with tools like <a href="http://camel.apache.org/activemq.html">Camel</a> and Spring's
1:4c2ef4a:  * <a href="http://activemq.apache.org/spring-support.html">JmsTemplate and MessagListenerContainer</a>.
1:4243a2b:  * Connections, sessions and producers are returned to a pool after use so that they can be reused later
1:4243a2b:  * without having to undergo the cost of creating them again.
1:4243a2b:  *
1:4243a2b:  * b>NOTE:</b> while this implementation does allow the creation of a collection of active consumers,
1:4243a2b:  * it does not 'pool' consumers. Pooling makes sense for connections, sessions and producers, which
1:4243a2b:  * are expensive to create and can remain idle a minimal cost. Consumers, on the other hand, are usually
1:4243a2b:  * just created at startup and left active, handling incoming messages as they come. When a consumer is
1:4243a2b:  * complete, it is best to close it rather than return it to a pool for later reuse: this is because,
1:4243a2b:  * even if a consumer is idle, ActiveMQ will keep delivering messages to the consumer's prefetch buffer,
1:4243a2b:  * where they'll get held until the consumer is active again.
1:4243a2b:  *
1:4243a2b:  * If you are creating a collection of consumers (for example, for multi-threaded message consumption), you
1:4243a2b:  * might want to consider using a lower prefetch value for each consumer (e.g. 10 or 20), to ensure that
1:4243a2b:  * all messages don't end up going to just one of the consumers. See this FAQ entry for more detail:
1:4243a2b:  * http://activemq.apache.org/i-do-not-receive-messages-in-my-second-consumer.html
1:4243a2b:  *
1:4c2ef4a:  * Optionally, one may configure the pool to examine and possibly evict objects as they sit idle in the
1:4c2ef4a:  * pool. This is performed by an "idle object eviction" thread, which runs asynchronously. Caution should
1:4c2ef4a:  * be used when configuring this optional feature. Eviction runs contend with client threads for access
1:4c2ef4a:  * to objects in the pool, so if they run too frequently performance issues may result. The idle object
1:4c2ef4a:  * eviction thread may be configured using the {@link PooledConnectionFactory#setTimeBetweenExpirationCheckMillis} method.  By
1:4c2ef4a:  * default the value is -1 which means no eviction thread will be run.  Set to a non-negative value to
1:4c2ef4a:  * configure the idle eviction thread to run.
1:4c2ef4a:  *
1:4243a2b:  * @org.apache.xbean.XBean element="pooledConnectionFactory"
1:4243a2b:  */
1:4243a2b: public class PooledConnectionFactory implements ConnectionFactory {
1:4243a2b:     private static final transient Logger LOG = LoggerFactory.getLogger(PooledConnectionFactory.class);
1:4c2ef4a: 
1:4c2ef4a:     protected final AtomicBoolean stopped = new AtomicBoolean(false);
1:4c2ef4a:     private GenericKeyedObjectPool<ConnectionKey, ConnectionPool> connectionsPool;
1:4c2ef4a: 
1:4243a2b:     private ConnectionFactory connectionFactory;
1:4c2ef4a: 
1:4c2ef4a:     private int maximumActiveSessionPerConnection = 500;
1:4243a2b:     private int idleTimeout = 30 * 1000;
1:4243a2b:     private boolean blockIfSessionPoolIsFull = true;
1:4c2ef4a:     private long blockIfSessionPoolIsFullTimeout = -1L;
1:4243a2b:     private long expiryTimeout = 0l;
1:4c2ef4a:     private boolean createConnectionOnStartup = true;
1:4c2ef4a:     private boolean useAnonymousProducers = true;
1:4243a2b: 
1:4c2ef4a:     public void initConnectionsPool() {
1:4c2ef4a:         if (this.connectionsPool == null) {
1:4c2ef4a:             this.connectionsPool = new GenericKeyedObjectPool<ConnectionKey, ConnectionPool>(
1:4c2ef4a:                     new KeyedPoolableObjectFactory<ConnectionKey, ConnectionPool>() {
1:4c2ef4a: 
1:4c2ef4a:                         @Override
1:4c2ef4a:                         public void activateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:4c2ef4a:                         }
1:4c2ef4a: 
1:4c2ef4a:                         @Override
1:4c2ef4a:                         public void destroyObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:4c2ef4a:                             try {
1:4c2ef4a:                                 if (LOG.isTraceEnabled()) {
1:4c2ef4a:                                     LOG.trace("Destroying connection: {}", connection);
1:4c2ef4a:                                 }
1:4c2ef4a:                                 connection.close();
1:4c2ef4a:                             } catch (Exception e) {
1:4c2ef4a:                                 LOG.warn("Close connection failed for connection: " + connection + ". This exception will be ignored.",e);
1:4c2ef4a:                             }
1:4c2ef4a:                         }
1:4c2ef4a: 
1:4c2ef4a:                         @Override
1:4c2ef4a:                         public ConnectionPool makeObject(ConnectionKey key) throws Exception {
1:4c2ef4a:                             Connection delegate = createConnection(key);
1:4c2ef4a: 
1:4c2ef4a:                             ConnectionPool connection = createConnectionPool(delegate);
1:4c2ef4a:                             connection.setIdleTimeout(getIdleTimeout());
1:4c2ef4a:                             connection.setExpiryTimeout(getExpiryTimeout());
1:4c2ef4a:                             connection.setMaximumActiveSessionPerConnection(getMaximumActiveSessionPerConnection());
1:4c2ef4a:                             connection.setBlockIfSessionPoolIsFull(isBlockIfSessionPoolIsFull());
1:4c2ef4a:                             if (isBlockIfSessionPoolIsFull() && getBlockIfSessionPoolIsFullTimeout() > 0) {
1:4c2ef4a:                                 connection.setBlockIfSessionPoolIsFullTimeout(getBlockIfSessionPoolIsFullTimeout());
1:4c2ef4a:                             }
1:4c2ef4a:                             connection.setUseAnonymousProducers(isUseAnonymousProducers());
1:4c2ef4a: 
1:4c2ef4a:                             if (LOG.isTraceEnabled()) {
1:4c2ef4a:                                 LOG.trace("Created new connection: {}", connection);
1:4c2ef4a:                             }
1:4c2ef4a: 
1:4c2ef4a:                             return connection;
1:4c2ef4a:                         }
1:4c2ef4a: 
1:4c2ef4a:                         @Override
1:4c2ef4a:                         public void passivateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:4c2ef4a:                         }
1:4c2ef4a: 
1:4c2ef4a:                         @Override
1:4c2ef4a:                         public boolean validateObject(ConnectionKey key, ConnectionPool connection) {
1:4c2ef4a:                             if (connection != null && connection.expiredCheck()) {
1:4c2ef4a:                                 if (LOG.isTraceEnabled()) {
1:4c2ef4a:                                     LOG.trace("Connection has expired: {} and will be destroyed", connection);
1:4c2ef4a:                                 }
1:4c2ef4a: 
1:4c2ef4a:                                 return false;
1:4c2ef4a:                             }
1:4c2ef4a: 
1:4c2ef4a:                             return true;
1:4c2ef4a:                         }
1:4c2ef4a:                     });
1:4c2ef4a: 
1:4c2ef4a:             // Set max idle (not max active) since our connections always idle in the pool.
1:4c2ef4a:             this.connectionsPool.setMaxIdle(1);
1:4c2ef4a: 
1:4c2ef4a:             // We always want our validate method to control when idle objects are evicted.
1:4c2ef4a:             this.connectionsPool.setTestOnBorrow(true);
1:4c2ef4a:             this.connectionsPool.setTestWhileIdle(true);
1:4c2ef4a:         }
6:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     /**
1:4c2ef4a:      * @return the currently configured ConnectionFactory used to create the pooled Connections.
1:4c2ef4a:      */
1:4243a2b:     public ConnectionFactory getConnectionFactory() {
1:4243a2b:         return connectionFactory;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     /**
1:4c2ef4a:      * Sets the ConnectionFactory used to create new pooled Connections.
1:4c2ef4a:      * <p/>
1:4c2ef4a:      * Updates to this value do not affect Connections that were previously created and placed
1:4c2ef4a:      * into the pool.  In order to allocate new Connections based off this new ConnectionFactory
1:4c2ef4a:      * it is first necessary to {@link #clear()} the pooled Connections.
1:4c2ef4a:      *
1:4c2ef4a:      * @param toUse
1:4c2ef4a:      *      The factory to use to create pooled Connections.
1:4243a2b:      */
1:4c2ef4a:     public void setConnectionFactory(final ConnectionFactory toUse) {
1:4c2ef4a:         if (toUse instanceof XAConnectionFactory) {
1:4c2ef4a:             this.connectionFactory = new XAConnectionFactoryWrapper((XAConnectionFactory) toUse);
1:4c2ef4a:         } else {
1:4c2ef4a:             this.connectionFactory = toUse;
1:4c2ef4a:         }
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public Connection createConnection() throws JMSException {
1:4243a2b:         return createConnection(null, null);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public synchronized Connection createConnection(String userName, String password) throws JMSException {
1:4243a2b:         if (stopped.get()) {
1:4243a2b:             LOG.debug("PooledConnectionFactory is stopped, skip create new connection.");
1:4243a2b:             return null;
1:4243a2b:         }
1:4243a2b: 
1:4243a2b:         ConnectionPool connection = null;
1:4c2ef4a:         ConnectionKey key = new ConnectionKey(userName, password);
1:4c2ef4a: 
1:4c2ef4a:         // This will either return an existing non-expired ConnectionPool or it
1:4c2ef4a:         // will create a new one to meet the demand.
1:4c2ef4a:         if (getConnectionsPool().getNumIdle(key) < getMaxConnections()) {
1:4c2ef4a:             try {
1:4c2ef4a:                 // we want borrowObject to return the one we added.
1:4c2ef4a:                 connectionsPool.setLifo(true);
1:4c2ef4a:                 connectionsPool.addObject(key);
1:4c2ef4a:             } catch (Exception e) {
1:4c2ef4a:                 throw createJmsException("Error while attempting to add new Connection to the pool", e);
1:4c2ef4a:             }
1:4c2ef4a:         } else {
1:4c2ef4a:             // now we want the oldest one in the pool.
1:4c2ef4a:             connectionsPool.setLifo(false);
1:4243a2b:         }
1:4c2ef4a: 
1:4c2ef4a:         try {
1:4243a2b: 
1:4c2ef4a:             // We can race against other threads returning the connection when there is an
1:4c2ef4a:             // expiration or idle timeout.  We keep pulling out ConnectionPool instances until
1:4c2ef4a:             // we win and get a non-closed instance and then increment the reference count
1:4c2ef4a:             // under lock to prevent another thread from triggering an expiration check and
1:4c2ef4a:             // pulling the rug out from under us.
1:4c2ef4a:             while (connection == null) {
1:4c2ef4a:                 connection = connectionsPool.borrowObject(key);
1:4c2ef4a:                 synchronized (connection) {
1:4c2ef4a:                     if (connection.getConnection() != null) {
1:4c2ef4a:                         connection.incrementReferenceCount();
1:4c2ef4a:                         break;
1:4c2ef4a:                     }
1:4c2ef4a: 
1:4c2ef4a:                     // Return the bad one to the pool and let if get destroyed as normal.
1:4c2ef4a:                     connectionsPool.returnObject(key, connection);
1:4c2ef4a:                     connection = null;
1:4c2ef4a:                 }
1:4c2ef4a:             }
1:4c2ef4a:         } catch (Exception e) {
1:4c2ef4a:             throw createJmsException("Error while attempting to retrieve a connection from the pool", e);
1:4243a2b:         }
1:4243a2b: 
1:4c2ef4a:         try {
1:4c2ef4a:             connectionsPool.returnObject(key, connection);
1:4c2ef4a:         } catch (Exception e) {
1:4c2ef4a:             throw createJmsException("Error when returning connection to the pool", e);
1:4243a2b:         }
1:4c2ef4a: 
1:4c2ef4a:         return newPooledConnection(connection);
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     protected Connection newPooledConnection(ConnectionPool connection) {
1:4243a2b:         return new PooledConnection(connection);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     private JMSException createJmsException(String msg, Exception cause) {
1:4c2ef4a:         JMSException exception = new JMSException(msg);
1:4c2ef4a:         exception.setLinkedException(cause);
1:4c2ef4a:         exception.initCause(cause);
1:4c2ef4a:         return exception;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     protected Connection createConnection(ConnectionKey key) throws JMSException {
1:4243a2b:         if (key.getUserName() == null && key.getPassword() == null) {
1:4243a2b:             return connectionFactory.createConnection();
2:4243a2b:         } else {
1:4243a2b:             return connectionFactory.createConnection(key.getUserName(), key.getPassword());
1:4243a2b:         }
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     public void start() {
1:4c2ef4a:         LOG.debug("Staring the PooledConnectionFactory: create on start = {}", isCreateConnectionOnStartup());
1:4c2ef4a:         stopped.set(false);
1:4c2ef4a:         if (isCreateConnectionOnStartup()) {
1:4c2ef4a:             try {
1:4c2ef4a:                 // warm the pool by creating a connection during startup
1:4c2ef4a:                 createConnection();
1:4c2ef4a:             } catch (JMSException e) {
1:4c2ef4a:                 LOG.warn("Create pooled connection during start failed. This exception will be ignored.", e);
1:4c2ef4a:             }
1:4243a2b:         }
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     public void stop() {
1:4c2ef4a:         if (stopped.compareAndSet(false, true)) {
1:4c2ef4a:             LOG.debug("Stopping the PooledConnectionFactory, number of connections in cache: {}",
1:4c2ef4a:                     connectionsPool != null ? connectionsPool.getNumActive() : 0);
1:4c2ef4a:             try {
1:4c2ef4a:                 if (connectionsPool != null) {
1:4c2ef4a:                     connectionsPool.close();
1:4243a2b:                 }
1:4c2ef4a:             } catch (Exception e) {
1:4243a2b:             }
1:4243a2b:         }
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     /**
1:4c2ef4a:      * Clears all connections from the pool.  Each connection that is currently in the pool is
1:4c2ef4a:      * closed and removed from the pool.  A new connection will be created on the next call to
1:4c2ef4a:      * {@link #createConnection()}.  Care should be taken when using this method as Connections that
1:4c2ef4a:      * are in use be client's will be closed.
1:4243a2b:      */
1:4c2ef4a:     public void clear() {
1:4c2ef4a: 
1:4c2ef4a:         if (stopped.get()) {
1:4c2ef4a:             return;
1:4c2ef4a:         }
1:4c2ef4a: 
1:4c2ef4a:         getConnectionsPool().clear();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Returns the currently configured maximum number of sessions a pooled Connection will
1:4c2ef4a:      * create before it either blocks or throws an exception when a new session is requested,
1:4c2ef4a:      * depending on configuration.
1:4c2ef4a:      *
1:4c2ef4a:      * @return the number of session instances that can be taken from a pooled connection.
1:4c2ef4a:      */
1:4c2ef4a:     public int getMaximumActiveSessionPerConnection() {
1:4c2ef4a:         return maximumActiveSessionPerConnection;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     /**
1:4243a2b:      * Sets the maximum number of active sessions per connection
1:4c2ef4a:      *
1:4c2ef4a:      * @param maximumActiveSessionPerConnection
1:4c2ef4a:      *      The maximum number of active session per connection in the pool.
1:4243a2b:      */
1:4c2ef4a:     public void setMaximumActiveSessionPerConnection(int maximumActiveSessionPerConnection) {
1:4c2ef4a:         this.maximumActiveSessionPerConnection = maximumActiveSessionPerConnection;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     /**
1:4243a2b:      * Controls the behavior of the internal session pool. By default the call to
1:4243a2b:      * Connection.getSession() will block if the session pool is full.  If the
1:4243a2b:      * argument false is given, it will change the default behavior and instead the
1:4243a2b:      * call to getSession() will throw a JMSException.
1:4243a2b:      *
1:4243a2b:      * The size of the session pool is controlled by the @see #maximumActive
1:4243a2b:      * property.
1:4243a2b:      *
1:4243a2b:      * @param block - if true, the call to getSession() blocks if the pool is full
1:4243a2b:      * until a session object is available.  defaults to true.
1:4243a2b:      */
1:4243a2b:     public void setBlockIfSessionPoolIsFull(boolean block) {
1:4243a2b:         this.blockIfSessionPoolIsFull = block;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     /**
1:4c2ef4a:      * Returns whether a pooled Connection will enter a blocked state or will throw an Exception
1:4c2ef4a:      * once the maximum number of sessions has been borrowed from the the Session Pool.
1:4c2ef4a:      *
1:4c2ef4a:      * @return true if the pooled Connection createSession method will block when the limit is hit.
1:4c2ef4a:      * @see #setBlockIfSessionPoolIsFull(boolean)
1:4243a2b:      */
1:4c2ef4a:     public boolean isBlockIfSessionPoolIsFull() {
1:4c2ef4a:         return this.blockIfSessionPoolIsFull;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     /**
1:4c2ef4a:      * Returns the maximum number to pooled Connections that this factory will allow before it
1:4c2ef4a:      * begins to return connections from the pool on calls to ({@link #createConnection()}.
1:4c2ef4a:      *
1:4c2ef4a:      * @return the maxConnections that will be created for this pool.
1:4c2ef4a:      */
1:4c2ef4a:     public int getMaxConnections() {
1:4c2ef4a:         return getConnectionsPool().getMaxIdle();
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Sets the maximum number of pooled Connections (defaults to one).  Each call to
1:4c2ef4a:      * {@link #createConnection()} will result in a new Connection being create up to the max
1:4c2ef4a:      * connections value.
1:4243a2b:      *
1:4243a2b:      * @param maxConnections the maxConnections to set
1:4243a2b:      */
1:4243a2b:     public void setMaxConnections(int maxConnections) {
1:4c2ef4a:         getConnectionsPool().setMaxIdle(maxConnections);
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     /**
1:4c2ef4a:      * Gets the Idle timeout value applied to new Connection's that are created by this pool.
1:4c2ef4a:      * <p/>
1:4c2ef4a:      * The idle timeout is used determine if a Connection instance has sat to long in the pool unused
1:4c2ef4a:      * and if so is closed and removed from the pool.  The default value is 30 seconds.
1:4243a2b:      *
1:4c2ef4a:      * @return idle timeout value (milliseconds)
1:4243a2b:      */
1:4243a2b:     public int getIdleTimeout() {
1:4243a2b:         return idleTimeout;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     /**
1:4c2ef4a:      * Sets the idle timeout  value for Connection's that are created by this pool in Milliseconds,
1:4c2ef4a:      * defaults to 30 seconds.
1:4c2ef4a:      * <p/>
1:4c2ef4a:      * For a Connection that is in the pool but has no current users the idle timeout determines how
1:4c2ef4a:      * long the Connection can live before it is eligible for removal from the pool.  Normally the
1:4c2ef4a:      * connections are tested when an attempt to check one out occurs so a Connection instance can sit
1:4c2ef4a:      * in the pool much longer than its idle timeout if connections are used infrequently.
1:4243a2b:      *
1:4c2ef4a:      * @param idleTimeout
1:4c2ef4a:      *      The maximum time a pooled Connection can sit unused before it is eligible for removal.
1:4243a2b:      */
1:4243a2b:     public void setIdleTimeout(int idleTimeout) {
1:4243a2b:         this.idleTimeout = idleTimeout;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     /**
1:4c2ef4a:      * allow connections to expire, irrespective of load or idle time. This is useful with failover
1:4c2ef4a:      * to force a reconnect from the pool, to reestablish load balancing or use of the master post recovery
1:4243a2b:      *
1:4243a2b:      * @param expiryTimeout non zero in milliseconds
1:4243a2b:      */
1:4243a2b:     public void setExpiryTimeout(long expiryTimeout) {
1:4243a2b:         this.expiryTimeout = expiryTimeout;
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     /**
1:4c2ef4a:      * @return the configured expiration timeout for connections in the pool.
1:4c2ef4a:      */
1:4243a2b:     public long getExpiryTimeout() {
1:4243a2b:         return expiryTimeout;
1:4243a2b:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * @return true if a Connection is created immediately on a call to {@link #start()}.
1:4c2ef4a:      */
1:4c2ef4a:     public boolean isCreateConnectionOnStartup() {
1:4c2ef4a:         return createConnectionOnStartup;
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Whether to create a connection on starting this {@link PooledConnectionFactory}.
1:4c2ef4a:      * <p/>
1:4c2ef4a:      * This can be used to warm-up the pool on startup. Notice that any kind of exception
1:4c2ef4a:      * happens during startup is logged at WARN level and ignored.
1:4c2ef4a:      *
1:4c2ef4a:      * @param createConnectionOnStartup <tt>true</tt> to create a connection on startup
1:4c2ef4a:      */
1:4c2ef4a:     public void setCreateConnectionOnStartup(boolean createConnectionOnStartup) {
1:4c2ef4a:         this.createConnectionOnStartup = createConnectionOnStartup;
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Should Sessions use one anonymous producer for all producer requests or should a new
1:4c2ef4a:      * MessageProducer be created for each request to create a producer object, default is true.
1:4c2ef4a:      *
1:4c2ef4a:      * When enabled the session only needs to allocate one MessageProducer for all requests and
1:4c2ef4a:      * the MessageProducer#send(destination, message) method can be used.  Normally this is the
1:4c2ef4a:      * right thing to do however it does result in the Broker not showing the producers per
1:4c2ef4a:      * destination.
1:4c2ef4a:      *
1:4c2ef4a:      * @return true if a PooledSession will use only a single anonymous message producer instance.
1:4c2ef4a:      */
1:4c2ef4a:     public boolean isUseAnonymousProducers() {
1:4c2ef4a:         return this.useAnonymousProducers;
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Sets whether a PooledSession uses only one anonymous MessageProducer instance or creates
1:4c2ef4a:      * a new MessageProducer for each call the create a MessageProducer.
1:4c2ef4a:      *
1:4c2ef4a:      * @param value
1:4c2ef4a:      *      Boolean value that configures whether anonymous producers are used.
1:4c2ef4a:      */
1:4c2ef4a:     public void setUseAnonymousProducers(boolean value) {
1:4c2ef4a:         this.useAnonymousProducers = value;
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Gets the Pool of ConnectionPool instances which are keyed by different ConnectionKeys.
1:4c2ef4a:      *
1:4c2ef4a:      * @return this factories pool of ConnectionPool instances.
1:4c2ef4a:      */
1:4c2ef4a:     protected GenericKeyedObjectPool<ConnectionKey, ConnectionPool> getConnectionsPool() {
1:4c2ef4a:         initConnectionsPool();
1:4c2ef4a:         return this.connectionsPool;
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Sets the number of milliseconds to sleep between runs of the idle Connection eviction thread.
1:4c2ef4a:      * When non-positive, no idle object eviction thread will be run, and Connections will only be
1:4c2ef4a:      * checked on borrow to determine if they have sat idle for too long or have failed for some
1:4c2ef4a:      * other reason.
1:4c2ef4a:      * <p/>
1:4c2ef4a:      * By default this value is set to -1 and no expiration thread ever runs.
1:4c2ef4a:      *
1:4c2ef4a:      * @param timeBetweenExpirationCheckMillis
1:4c2ef4a:      *      The time to wait between runs of the idle Connection eviction thread.
1:4c2ef4a:      */
1:4c2ef4a:     public void setTimeBetweenExpirationCheckMillis(long timeBetweenExpirationCheckMillis) {
1:4c2ef4a:         getConnectionsPool().setTimeBetweenEvictionRunsMillis(timeBetweenExpirationCheckMillis);
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * @return the number of milliseconds to sleep between runs of the idle connection eviction thread.
1:4c2ef4a:      */
1:4c2ef4a:     public long getTimeBetweenExpirationCheckMillis() {
1:4c2ef4a:         return getConnectionsPool().getTimeBetweenEvictionRunsMillis();
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * @return the number of Connections currently in the Pool
1:4c2ef4a:      */
1:4c2ef4a:     public int getNumConnections() {
1:4c2ef4a:         return getConnectionsPool().getNumIdle();
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Delegate that creates each instance of an ConnectionPool object.  Subclasses can override
1:4c2ef4a:      * this method to customize the type of connection pool returned.
1:4c2ef4a:      *
1:4c2ef4a:      * @param connection
1:4c2ef4a:      *
1:4c2ef4a:      * @return instance of a new ConnectionPool.
1:4c2ef4a:      */
1:4c2ef4a:     protected ConnectionPool createConnectionPool(Connection connection) {
1:4c2ef4a:         return new ConnectionPool(connection);
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Returns the timeout to use for blocking creating new sessions
1:4c2ef4a:      *
1:4c2ef4a:      * @return true if the pooled Connection createSession method will block when the limit is hit.
1:4c2ef4a:      * @see #setBlockIfSessionPoolIsFull(boolean)
1:4c2ef4a:      */
1:4c2ef4a:     public long getBlockIfSessionPoolIsFullTimeout() {
1:4c2ef4a:         return blockIfSessionPoolIsFullTimeout;
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Controls the behavior of the internal session pool. By default the call to
1:4c2ef4a:      * Connection.getSession() will block if the session pool is full.  This setting
1:4c2ef4a:      * will affect how long it blocks and throws an exception after the timeout.
1:4c2ef4a:      *
1:4c2ef4a:      * The size of the session pool is controlled by the @see #maximumActive
1:4c2ef4a:      * property.
1:4c2ef4a:      *
1:4c2ef4a:      * Whether or not the call to create session blocks is controlled by the @see #blockIfSessionPoolIsFull
1:4c2ef4a:      * property
1:4c2ef4a:      *
1:4c2ef4a:      * @param blockIfSessionPoolIsFullTimeout - if blockIfSessionPoolIsFullTimeout is true,
1:4c2ef4a:      *                                        then use this setting to configure how long to block before retry
1:4c2ef4a:      */
1:4c2ef4a:     public void setBlockIfSessionPoolIsFullTimeout(long blockIfSessionPoolIsFullTimeout) {
1:4c2ef4a:         this.blockIfSessionPoolIsFullTimeout = blockIfSessionPoolIsFullTimeout;
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     static class XAConnectionFactoryWrapper implements XAConnectionFactory, ConnectionFactory {
1:4c2ef4a:         private final XAConnectionFactory delegate;
1:4c2ef4a: 
1:4c2ef4a:         XAConnectionFactoryWrapper(XAConnectionFactory delegate) {
1:4c2ef4a:             this.delegate = delegate;
1:4c2ef4a:         }
1:4c2ef4a: 
1:4c2ef4a:         @Override
1:4c2ef4a:         public Connection createConnection() throws JMSException {
1:4c2ef4a:             return createXAConnection();
1:4c2ef4a:         }
1:4c2ef4a: 
1:4c2ef4a:         @Override
1:4c2ef4a:         public Connection createConnection(String userName, String password) throws JMSException {
1:4c2ef4a:             return createXAConnection(userName, password);
1:4c2ef4a:         }
1:4c2ef4a: 
1:4c2ef4a:         @Override
1:4c2ef4a:         public XAConnection createXAConnection() throws JMSException {
1:4c2ef4a:             return delegate.createXAConnection();
1:4c2ef4a:         }
1:4c2ef4a: 
1:4c2ef4a:         @Override
1:4c2ef4a:         public XAConnection createXAConnection(String userName, String password) throws JMSException {
1:4c2ef4a:             return delegate.createXAConnection(userName, password);
1:4c2ef4a:         }
1:4c2ef4a:     }
1:4243a2b: }
============================================================================
author:Christian Schneider
-------------------------------------------------------------------------------
commit:8047ebe
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:4c2ef4a
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.XAConnection;
1: import javax.jms.XAConnectionFactory;
1: import org.apache.commons.pool.KeyedPoolableObjectFactory;
1: import org.apache.commons.pool.impl.GenericKeyedObjectPool;
/////////////////////////////////////////////////////////////////////////
1:  * so it can be used with tools like <a href="http://camel.apache.org/activemq.html">Camel</a> and Spring's
1:  * <a href="http://activemq.apache.org/spring-support.html">JmsTemplate and MessagListenerContainer</a>.
/////////////////////////////////////////////////////////////////////////
1:  * Optionally, one may configure the pool to examine and possibly evict objects as they sit idle in the
1:  * pool. This is performed by an "idle object eviction" thread, which runs asynchronously. Caution should
1:  * be used when configuring this optional feature. Eviction runs contend with client threads for access
1:  * to objects in the pool, so if they run too frequently performance issues may result. The idle object
1:  * eviction thread may be configured using the {@link PooledConnectionFactory#setTimeBetweenExpirationCheckMillis} method.  By
1:  * default the value is -1 which means no eviction thread will be run.  Set to a non-negative value to
1:  * configure the idle eviction thread to run.
1:  *
1: 
1:     protected final AtomicBoolean stopped = new AtomicBoolean(false);
1:     private GenericKeyedObjectPool<ConnectionKey, ConnectionPool> connectionsPool;
1: 
1: 
1:     private int maximumActiveSessionPerConnection = 500;
1:     private long blockIfSessionPoolIsFullTimeout = -1L;
1:     private boolean createConnectionOnStartup = true;
1:     private boolean useAnonymousProducers = true;
1:     public void initConnectionsPool() {
1:         if (this.connectionsPool == null) {
1:             this.connectionsPool = new GenericKeyedObjectPool<ConnectionKey, ConnectionPool>(
1:                     new KeyedPoolableObjectFactory<ConnectionKey, ConnectionPool>() {
1: 
1:                         @Override
1:                         public void activateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:                         }
1: 
1:                         @Override
1:                         public void destroyObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:                             try {
1:                                 if (LOG.isTraceEnabled()) {
1:                                     LOG.trace("Destroying connection: {}", connection);
1:                                 }
1:                                 connection.close();
1:                             } catch (Exception e) {
1:                                 LOG.warn("Close connection failed for connection: " + connection + ". This exception will be ignored.",e);
1:                             }
1:                         }
1: 
1:                         @Override
1:                         public ConnectionPool makeObject(ConnectionKey key) throws Exception {
1:                             Connection delegate = createConnection(key);
1: 
1:                             ConnectionPool connection = createConnectionPool(delegate);
1:                             connection.setIdleTimeout(getIdleTimeout());
1:                             connection.setExpiryTimeout(getExpiryTimeout());
1:                             connection.setMaximumActiveSessionPerConnection(getMaximumActiveSessionPerConnection());
1:                             connection.setBlockIfSessionPoolIsFull(isBlockIfSessionPoolIsFull());
1:                             if (isBlockIfSessionPoolIsFull() && getBlockIfSessionPoolIsFullTimeout() > 0) {
1:                                 connection.setBlockIfSessionPoolIsFullTimeout(getBlockIfSessionPoolIsFullTimeout());
1:                             }
1:                             connection.setUseAnonymousProducers(isUseAnonymousProducers());
1: 
1:                             if (LOG.isTraceEnabled()) {
1:                                 LOG.trace("Created new connection: {}", connection);
1:                             }
1: 
1:                             return connection;
1:                         }
1: 
1:                         @Override
1:                         public void passivateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:                         }
1: 
1:                         @Override
1:                         public boolean validateObject(ConnectionKey key, ConnectionPool connection) {
1:                             if (connection != null && connection.expiredCheck()) {
1:                                 if (LOG.isTraceEnabled()) {
1:                                     LOG.trace("Connection has expired: {} and will be destroyed", connection);
1:                                 }
1: 
1:                                 return false;
1:                             }
1: 
1:                             return true;
1:                         }
1:                     });
1: 
1:             // Set max idle (not max active) since our connections always idle in the pool.
1:             this.connectionsPool.setMaxIdle(1);
1: 
1:             // We always want our validate method to control when idle objects are evicted.
1:             this.connectionsPool.setTestOnBorrow(true);
1:             this.connectionsPool.setTestWhileIdle(true);
1:         }
1:     /**
1:      * @return the currently configured ConnectionFactory used to create the pooled Connections.
1:      */
1:      * Sets the ConnectionFactory used to create new pooled Connections.
1:      * <p/>
1:      * Updates to this value do not affect Connections that were previously created and placed
1:      * into the pool.  In order to allocate new Connections based off this new ConnectionFactory
1:      * it is first necessary to {@link #clear()} the pooled Connections.
1:      *
1:      * @param toUse
1:      *      The factory to use to create pooled Connections.
1:     public void setConnectionFactory(final ConnectionFactory toUse) {
1:         if (toUse instanceof XAConnectionFactory) {
1:             this.connectionFactory = new XAConnectionFactoryWrapper((XAConnectionFactory) toUse);
1:         } else {
1:             this.connectionFactory = toUse;
1:         }
1:     @Override
1:     @Override
1:         ConnectionKey key = new ConnectionKey(userName, password);
1: 
1:         // This will either return an existing non-expired ConnectionPool or it
1:         // will create a new one to meet the demand.
1:         if (getConnectionsPool().getNumIdle(key) < getMaxConnections()) {
1:             try {
1:                 // we want borrowObject to return the one we added.
1:                 connectionsPool.setLifo(true);
1:                 connectionsPool.addObject(key);
1:             } catch (Exception e) {
1:                 throw createJmsException("Error while attempting to add new Connection to the pool", e);
1:             }
1:         } else {
1:             // now we want the oldest one in the pool.
1:             connectionsPool.setLifo(false);
1:         try {
1: 
1:             // We can race against other threads returning the connection when there is an
1:             // expiration or idle timeout.  We keep pulling out ConnectionPool instances until
1:             // we win and get a non-closed instance and then increment the reference count
1:             // under lock to prevent another thread from triggering an expiration check and
1:             // pulling the rug out from under us.
1:             while (connection == null) {
1:                 connection = connectionsPool.borrowObject(key);
1:                 synchronized (connection) {
1:                     if (connection.getConnection() != null) {
1:                         connection.incrementReferenceCount();
1:                         break;
1:                     }
1: 
1:                     // Return the bad one to the pool and let if get destroyed as normal.
1:                     connectionsPool.returnObject(key, connection);
1:                     connection = null;
1:                 }
1:             }
1:         } catch (Exception e) {
1:             throw createJmsException("Error while attempting to retrieve a connection from the pool", e);
1:         try {
1:             connectionsPool.returnObject(key, connection);
1:         } catch (Exception e) {
1:             throw createJmsException("Error when returning connection to the pool", e);
1: 
1:         return newPooledConnection(connection);
1:     }
1: 
1:     protected Connection newPooledConnection(ConnectionPool connection) {
1:     private JMSException createJmsException(String msg, Exception cause) {
1:         JMSException exception = new JMSException(msg);
1:         exception.setLinkedException(cause);
1:         exception.initCause(cause);
1:         return exception;
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Staring the PooledConnectionFactory: create on start = {}", isCreateConnectionOnStartup());
1:         stopped.set(false);
1:         if (isCreateConnectionOnStartup()) {
1:             try {
1:                 // warm the pool by creating a connection during startup
1:                 createConnection();
1:             } catch (JMSException e) {
1:                 LOG.warn("Create pooled connection during start failed. This exception will be ignored.", e);
1:             }
1:         if (stopped.compareAndSet(false, true)) {
1:             LOG.debug("Stopping the PooledConnectionFactory, number of connections in cache: {}",
1:                     connectionsPool != null ? connectionsPool.getNumActive() : 0);
1:             try {
1:                 if (connectionsPool != null) {
1:                     connectionsPool.close();
1:             } catch (Exception e) {
1:      * Clears all connections from the pool.  Each connection that is currently in the pool is
1:      * closed and removed from the pool.  A new connection will be created on the next call to
1:      * {@link #createConnection()}.  Care should be taken when using this method as Connections that
1:      * are in use be client's will be closed.
1:     public void clear() {
1: 
1:         if (stopped.get()) {
1:             return;
1:         }
1: 
1:         getConnectionsPool().clear();
1:     /**
1:      * Returns the currently configured maximum number of sessions a pooled Connection will
1:      * create before it either blocks or throws an exception when a new session is requested,
1:      * depending on configuration.
1:      *
1:      * @return the number of session instances that can be taken from a pooled connection.
1:      */
1:     public int getMaximumActiveSessionPerConnection() {
1:         return maximumActiveSessionPerConnection;
1:      *
1:      * @param maximumActiveSessionPerConnection
1:      *      The maximum number of active session per connection in the pool.
1:     public void setMaximumActiveSessionPerConnection(int maximumActiveSessionPerConnection) {
1:         this.maximumActiveSessionPerConnection = maximumActiveSessionPerConnection;
/////////////////////////////////////////////////////////////////////////
1:      * Returns whether a pooled Connection will enter a blocked state or will throw an Exception
1:      * once the maximum number of sessions has been borrowed from the the Session Pool.
1:      *
1:      * @return true if the pooled Connection createSession method will block when the limit is hit.
1:      * @see #setBlockIfSessionPoolIsFull(boolean)
1:     public boolean isBlockIfSessionPoolIsFull() {
1:         return this.blockIfSessionPoolIsFull;
1:      * Returns the maximum number to pooled Connections that this factory will allow before it
1:      * begins to return connections from the pool on calls to ({@link #createConnection()}.
1:      *
1:      * @return the maxConnections that will be created for this pool.
1:      */
1:     public int getMaxConnections() {
1:         return getConnectionsPool().getMaxIdle();
1:     }
1: 
1:     /**
1:      * Sets the maximum number of pooled Connections (defaults to one).  Each call to
1:      * {@link #createConnection()} will result in a new Connection being create up to the max
1:      * connections value.
1:         getConnectionsPool().setMaxIdle(maxConnections);
1:      * Gets the Idle timeout value applied to new Connection's that are created by this pool.
1:      * <p/>
1:      * The idle timeout is used determine if a Connection instance has sat to long in the pool unused
1:      * and if so is closed and removed from the pool.  The default value is 30 seconds.
1:      * @return idle timeout value (milliseconds)
1:      * Sets the idle timeout  value for Connection's that are created by this pool in Milliseconds,
1:      * defaults to 30 seconds.
1:      * <p/>
1:      * For a Connection that is in the pool but has no current users the idle timeout determines how
1:      * long the Connection can live before it is eligible for removal from the pool.  Normally the
1:      * connections are tested when an attempt to check one out occurs so a Connection instance can sit
1:      * in the pool much longer than its idle timeout if connections are used infrequently.
1:      * @param idleTimeout
1:      *      The maximum time a pooled Connection can sit unused before it is eligible for removal.
1:      * allow connections to expire, irrespective of load or idle time. This is useful with failover
1:      * to force a reconnect from the pool, to reestablish load balancing or use of the master post recovery
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return the configured expiration timeout for connections in the pool.
1:      */
1: 
1:     /**
1:      * @return true if a Connection is created immediately on a call to {@link #start()}.
1:      */
1:     public boolean isCreateConnectionOnStartup() {
1:         return createConnectionOnStartup;
1:     }
1: 
1:     /**
1:      * Whether to create a connection on starting this {@link PooledConnectionFactory}.
1:      * <p/>
1:      * This can be used to warm-up the pool on startup. Notice that any kind of exception
1:      * happens during startup is logged at WARN level and ignored.
1:      *
1:      * @param createConnectionOnStartup <tt>true</tt> to create a connection on startup
1:      */
1:     public void setCreateConnectionOnStartup(boolean createConnectionOnStartup) {
1:         this.createConnectionOnStartup = createConnectionOnStartup;
1:     }
1: 
1:     /**
1:      * Should Sessions use one anonymous producer for all producer requests or should a new
1:      * MessageProducer be created for each request to create a producer object, default is true.
1:      *
1:      * When enabled the session only needs to allocate one MessageProducer for all requests and
1:      * the MessageProducer#send(destination, message) method can be used.  Normally this is the
1:      * right thing to do however it does result in the Broker not showing the producers per
1:      * destination.
1:      *
1:      * @return true if a PooledSession will use only a single anonymous message producer instance.
1:      */
1:     public boolean isUseAnonymousProducers() {
1:         return this.useAnonymousProducers;
1:     }
1: 
1:     /**
1:      * Sets whether a PooledSession uses only one anonymous MessageProducer instance or creates
1:      * a new MessageProducer for each call the create a MessageProducer.
1:      *
1:      * @param value
1:      *      Boolean value that configures whether anonymous producers are used.
1:      */
1:     public void setUseAnonymousProducers(boolean value) {
1:         this.useAnonymousProducers = value;
1:     }
1: 
1:     /**
1:      * Gets the Pool of ConnectionPool instances which are keyed by different ConnectionKeys.
1:      *
1:      * @return this factories pool of ConnectionPool instances.
1:      */
1:     protected GenericKeyedObjectPool<ConnectionKey, ConnectionPool> getConnectionsPool() {
1:         initConnectionsPool();
1:         return this.connectionsPool;
1:     }
1: 
1:     /**
1:      * Sets the number of milliseconds to sleep between runs of the idle Connection eviction thread.
1:      * When non-positive, no idle object eviction thread will be run, and Connections will only be
1:      * checked on borrow to determine if they have sat idle for too long or have failed for some
1:      * other reason.
1:      * <p/>
1:      * By default this value is set to -1 and no expiration thread ever runs.
1:      *
1:      * @param timeBetweenExpirationCheckMillis
1:      *      The time to wait between runs of the idle Connection eviction thread.
1:      */
1:     public void setTimeBetweenExpirationCheckMillis(long timeBetweenExpirationCheckMillis) {
1:         getConnectionsPool().setTimeBetweenEvictionRunsMillis(timeBetweenExpirationCheckMillis);
1:     }
1: 
1:     /**
1:      * @return the number of milliseconds to sleep between runs of the idle connection eviction thread.
1:      */
1:     public long getTimeBetweenExpirationCheckMillis() {
1:         return getConnectionsPool().getTimeBetweenEvictionRunsMillis();
1:     }
1: 
1:     /**
1:      * @return the number of Connections currently in the Pool
1:      */
1:     public int getNumConnections() {
1:         return getConnectionsPool().getNumIdle();
1:     }
1: 
1:     /**
1:      * Delegate that creates each instance of an ConnectionPool object.  Subclasses can override
1:      * this method to customize the type of connection pool returned.
1:      *
1:      * @param connection
1:      *
1:      * @return instance of a new ConnectionPool.
1:      */
1:     protected ConnectionPool createConnectionPool(Connection connection) {
1:         return new ConnectionPool(connection);
1:     }
1: 
1:     /**
1:      * Returns the timeout to use for blocking creating new sessions
1:      *
1:      * @return true if the pooled Connection createSession method will block when the limit is hit.
1:      * @see #setBlockIfSessionPoolIsFull(boolean)
1:      */
1:     public long getBlockIfSessionPoolIsFullTimeout() {
1:         return blockIfSessionPoolIsFullTimeout;
1:     }
1: 
1:     /**
1:      * Controls the behavior of the internal session pool. By default the call to
1:      * Connection.getSession() will block if the session pool is full.  This setting
1:      * will affect how long it blocks and throws an exception after the timeout.
1:      *
1:      * The size of the session pool is controlled by the @see #maximumActive
1:      * property.
1:      *
1:      * Whether or not the call to create session blocks is controlled by the @see #blockIfSessionPoolIsFull
1:      * property
1:      *
1:      * @param blockIfSessionPoolIsFullTimeout - if blockIfSessionPoolIsFullTimeout is true,
1:      *                                        then use this setting to configure how long to block before retry
1:      */
1:     public void setBlockIfSessionPoolIsFullTimeout(long blockIfSessionPoolIsFullTimeout) {
1:         this.blockIfSessionPoolIsFullTimeout = blockIfSessionPoolIsFullTimeout;
1:     }
1: 
1:     static class XAConnectionFactoryWrapper implements XAConnectionFactory, ConnectionFactory {
1:         private final XAConnectionFactory delegate;
1: 
1:         XAConnectionFactoryWrapper(XAConnectionFactory delegate) {
1:             this.delegate = delegate;
1:         }
1: 
1:         @Override
1:         public Connection createConnection() throws JMSException {
1:             return createXAConnection();
1:         }
1: 
1:         @Override
1:         public Connection createConnection(String userName, String password) throws JMSException {
1:             return createXAConnection(userName, password);
1:         }
1: 
1:         @Override
1:         public XAConnection createXAConnection() throws JMSException {
1:             return delegate.createXAConnection();
1:         }
1: 
1:         @Override
1:         public XAConnection createXAConnection(String userName, String password) throws JMSException {
1:             return delegate.createXAConnection(userName, password);
1:         }
1:     }
commit:4243a2b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.aries.transaction.jms;
1: 
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.Map;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.JMSException;
1: 
1: import org.apache.aries.transaction.jms.internal.ConnectionKey;
1: import org.apache.aries.transaction.jms.internal.ConnectionPool;
0: import org.apache.aries.transaction.jms.internal.IOExceptionSupport;
1: import org.apache.aries.transaction.jms.internal.PooledConnection;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: import org.apache.commons.pool.ObjectPoolFactory;
0: import org.apache.commons.pool.impl.GenericObjectPool;
0: import org.apache.commons.pool.impl.GenericObjectPoolFactory;
1: 
1: /**
1:  * A JMS provider which pools Connection, Session and MessageProducer instances
0:  * so it can be used with tools like <a href="http://camel.apache.org/activemq.html">Camel</a> and Spring's <a
0:  * href="http://activemq.apache.org/spring-support.html">JmsTemplate and MessagListenerContainer</a>.
1:  * Connections, sessions and producers are returned to a pool after use so that they can be reused later
1:  * without having to undergo the cost of creating them again.
1:  *
1:  * b>NOTE:</b> while this implementation does allow the creation of a collection of active consumers,
1:  * it does not 'pool' consumers. Pooling makes sense for connections, sessions and producers, which
1:  * are expensive to create and can remain idle a minimal cost. Consumers, on the other hand, are usually
1:  * just created at startup and left active, handling incoming messages as they come. When a consumer is
1:  * complete, it is best to close it rather than return it to a pool for later reuse: this is because,
1:  * even if a consumer is idle, ActiveMQ will keep delivering messages to the consumer's prefetch buffer,
1:  * where they'll get held until the consumer is active again.
1:  *
1:  * If you are creating a collection of consumers (for example, for multi-threaded message consumption), you
1:  * might want to consider using a lower prefetch value for each consumer (e.g. 10 or 20), to ensure that
1:  * all messages don't end up going to just one of the consumers. See this FAQ entry for more detail:
1:  * http://activemq.apache.org/i-do-not-receive-messages-in-my-second-consumer.html
1:  *
1:  * @org.apache.xbean.XBean element="pooledConnectionFactory"
1:  */
1: public class PooledConnectionFactory implements ConnectionFactory {
1: 
1:     private static final transient Logger LOG = LoggerFactory.getLogger(PooledConnectionFactory.class);
1:     private ConnectionFactory connectionFactory;
0:     private Map<ConnectionKey, LinkedList<ConnectionPool>> cache = new HashMap<ConnectionKey, LinkedList<ConnectionPool>>();
0:     private ObjectPoolFactory poolFactory;
0:     private int maximumActive = 500;
0:     private int maxConnections = 1;
1:     private int idleTimeout = 30 * 1000;
1:     private boolean blockIfSessionPoolIsFull = true;
0:     private AtomicBoolean stopped = new AtomicBoolean(false);
1:     private long expiryTimeout = 0l;
1: 
0:     public PooledConnectionFactory() {
1:     }
1: 
1:     public ConnectionFactory getConnectionFactory() {
1:         return connectionFactory;
1:     }
1: 
1:     /**
0:      * The actual JMS ConnectionFactory that will be pooled.
1:      */
0:     public void setConnectionFactory(ConnectionFactory connectionFactory) {
0:         this.connectionFactory = connectionFactory;
1:     }
1: 
1:     public Connection createConnection() throws JMSException {
1:         return createConnection(null, null);
1:     }
1: 
1:     public synchronized Connection createConnection(String userName, String password) throws JMSException {
1:         if (stopped.get()) {
1:             LOG.debug("PooledConnectionFactory is stopped, skip create new connection.");
1:             return null;
1:         }
1: 
0:         ConnectionKey key = new ConnectionKey(userName, password);
0:         LinkedList<ConnectionPool> pools = cache.get(key);
1: 
0:         if (pools == null) {
0:             pools = new LinkedList<ConnectionPool>();
0:             cache.put(key, pools);
1:         }
1: 
1:         ConnectionPool connection = null;
0:         if (pools.size() == maxConnections) {
0:             connection = pools.removeFirst();
1:         }
1: 
0:         // Now.. we might get a connection, but it might be that we need to
0:         // dump it..
0:         if (connection != null && connection.expiredCheck()) {
0:             connection = null;
1:         }
1: 
0:         if (connection == null) {
0:             Connection delegate = createConnection(key);
0:             connection = createConnectionPool(delegate);
1:         }
0:         pools.add(connection);
1:         return new PooledConnection(connection);
1:     }
1: 
0:     protected ConnectionPool createConnectionPool(Connection connection) throws JMSException {
0:         ConnectionPool result =  new ConnectionPool(connection, getPoolFactory());
0:         result.setIdleTimeout(getIdleTimeout());
0:         result.setExpiryTimeout(getExpiryTimeout());
0:         return result;
1:     }
1: 
1:     protected Connection createConnection(ConnectionKey key) throws JMSException {
1:         if (key.getUserName() == null && key.getPassword() == null) {
1:             return connectionFactory.createConnection();
1:         } else {
1:             return connectionFactory.createConnection(key.getUserName(), key.getPassword());
1:         }
1:     }
1: 
1:     public void start() {
0:         try {
0:             stopped.set(false);
0:             createConnection();
0:         } catch (JMSException e) {
0:             LOG.warn("Create pooled connection during start failed.", e);
0:             IOExceptionSupport.create(e);
1:         }
1:     }
1: 
1:     public void stop() {
0:         LOG.debug("Stop the PooledConnectionFactory, number of connections in cache: "+cache.size());
0:         stopped.set(true);
0:         for (Iterator<LinkedList<ConnectionPool>> iter = cache.values().iterator(); iter.hasNext();) {
0:             for (ConnectionPool connection : iter.next()) {
0:                 try {
0:                     connection.close();
0:                 }catch(Exception e) {
0:                     LOG.warn("Close connection failed",e);
1:                 }
1:             }
1:         }
0:         cache.clear();
1:     }
1: 
0:     public ObjectPoolFactory getPoolFactory() {
0:         if (poolFactory == null) {
0:             poolFactory = createPoolFactory();
1:         }
0:         return poolFactory;
1:     }
1: 
1:     /**
0:      * Sets the object pool factory used to create individual session pools for
0:      * each connection
1:      */
0:     public void setPoolFactory(ObjectPoolFactory poolFactory) {
0:         this.poolFactory = poolFactory;
1:     }
1: 
0:     public int getMaximumActive() {
0:         return maximumActive;
1:     }
1: 
1:     /**
1:      * Sets the maximum number of active sessions per connection
1:      */
0:     public void setMaximumActive(int maximumActive) {
0:         this.maximumActive = maximumActive;
1:     }
1: 
1:     /**
1:      * Controls the behavior of the internal session pool. By default the call to
1:      * Connection.getSession() will block if the session pool is full.  If the
1:      * argument false is given, it will change the default behavior and instead the
1:      * call to getSession() will throw a JMSException.
1:      *
1:      * The size of the session pool is controlled by the @see #maximumActive
1:      * property.
1:      *
1:      * @param block - if true, the call to getSession() blocks if the pool is full
1:      * until a session object is available.  defaults to true.
1:      */
1:     public void setBlockIfSessionPoolIsFull(boolean block) {
1:         this.blockIfSessionPoolIsFull = block;
1:     }
1: 
1:     /**
0:      * @return the maxConnections
1:      */
0:     public int getMaxConnections() {
0:         return maxConnections;
1:     }
1: 
1:     /**
0:      * Number of JMS connections to use.  The default is 1 to use a single connection
0:      * to the broker.  For high throughput, it may be interesting to raise this number
0:      * a bit.
1:      *
1:      * @param maxConnections the maxConnections to set
1:      */
1:     public void setMaxConnections(int maxConnections) {
0:         this.maxConnections = maxConnections;
1:     }
1: 
1:     /**
0:      * Creates an ObjectPoolFactory. Its behavior is controlled by the two
0:      * properties @see #maximumActive and @see #blockIfSessionPoolIsFull.
1:      *
0:      * @return the newly created but empty ObjectPoolFactory
1:      */
0:     protected ObjectPoolFactory createPoolFactory() {
0:          if (blockIfSessionPoolIsFull) {
0:             return new GenericObjectPoolFactory(null, maximumActive);
1:         } else {
0:             return new GenericObjectPoolFactory(null,
0:                 maximumActive,
0:                 GenericObjectPool.WHEN_EXHAUSTED_FAIL,
0:                 GenericObjectPool.DEFAULT_MAX_WAIT);
1:         }
1:     }
1: 
1:     public int getIdleTimeout() {
1:         return idleTimeout;
1:     }
1: 
1:     /**
0:      * Specifies the amount of milliseconds after which an idle connection is discarded.
0:      * Defaults to 30 seconds.
1:      *
0:      * @param idleTimeout non zero in milliseconds
1:      */
1:     public void setIdleTimeout(int idleTimeout) {
1:         this.idleTimeout = idleTimeout;
1:     }
1: 
1:     /**
0:      * Allow connections to expire, irrespective of load or idle time. This is useful with failover
0:      * to force a reconnect from the pool, to reestablish load balancing or use of the master post recovery.
1:      *
1:      * @param expiryTimeout non zero in milliseconds
1:      */
1:     public void setExpiryTimeout(long expiryTimeout) {
1:         this.expiryTimeout = expiryTimeout;
1:     }
1: 
1:     public long getExpiryTimeout() {
1:         return expiryTimeout;
1:     }
1: }
============================================================================