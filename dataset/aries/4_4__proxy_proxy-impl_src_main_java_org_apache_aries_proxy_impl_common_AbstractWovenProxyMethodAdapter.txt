1:96d4e06: /*
1:96d4e06:  * Licensed to the Apache Software Foundation (ASF) under one
1:96d4e06:  * or more contributor license agreements.  See the NOTICE file
1:96d4e06:  * distributed with this work for additional information
1:96d4e06:  * regarding copyright ownership.  The ASF licenses this file
1:96d4e06:  * to you under the Apache License, Version 2.0 (the
1:96d4e06:  * "License"); you may not use this file except in compliance
1:96d4e06:  * with the License.  You may obtain a copy of the License at
1:96d4e06:  *
1:96d4e06:  *   http://www.apache.org/licenses/LICENSE-2.0
1:96d4e06:  *
1:96d4e06:  * Unless required by applicable law or agreed to in writing,
1:96d4e06:  * software distributed under the License is distributed on an
1:96d4e06:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:96d4e06:  * KIND, either express or implied.  See the License for the
1:96d4e06:  * specific language governing permissions and limitations
1:96d4e06:  * under the License.
2:96d4e06:  */
1:475ef33: package org.apache.aries.proxy.impl.common;
5:96d4e06: 
1:475ef33: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.DISPATCHER_FIELD;
1:475ef33: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.DISPATCHER_TYPE;
1:475ef33: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.LISTENER_FIELD;
1:475ef33: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.LISTENER_TYPE;
1:475ef33: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.METHOD_TYPE;
1:475ef33: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.NO_ARGS;
1:475ef33: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.OBJECT_TYPE;
1:475ef33: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.THROWABLE_INAME;
1:9a9631e: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.WOVEN_PROXY_IFACE_TYPE;
1:9a9631e: import static org.objectweb.asm.Opcodes.ACONST_NULL;
1:9a9631e: import static org.objectweb.asm.Opcodes.IFNE;
1:9a9631e: import static org.objectweb.asm.Opcodes.ASM5;
1:9a9631e: 
1:9a9631e: import java.util.Arrays;
1:9a9631e: 
1:96d4e06: import org.apache.aries.proxy.InvocationListener;
1:ef57cb3: import org.apache.aries.proxy.impl.NLS;
1:96d4e06: import org.objectweb.asm.Label;
1:96d4e06: import org.objectweb.asm.MethodVisitor;
1:96d4e06: import org.objectweb.asm.Opcodes;
1:96d4e06: import org.objectweb.asm.Type;
1:96d4e06: import org.objectweb.asm.commons.GeneratorAdapter;
1:96d4e06: import org.objectweb.asm.commons.Method;
2:96d4e06: /**
1:96d4e06:  * This class weaves dispatch and listener code into a method, there are two known
1:8f852b6:  * subclasses {@link WovenProxyConcreteMethodAdapter} is used for weaving instance methods
1:8f852b6:  * {@link WovenProxyAbstractMethodAdapter} is used to provide a delegating
1:96d4e06:  * implementation of an interface method.
1:96d4e06:  * 
1:96d4e06:  * Roughly (but not exactly because it's easier to write working bytecode
1:96d4e06:  * if you don't have to exactly recreate the Java!) this is trying to 
1:96d4e06:  * do the following: <code>
1:96d4e06:  * 
1:96d4e06:  *      
1:96d4e06:     if(dispatcher != null) {
1:96d4e06:       int returnValue;
1:96d4e06:       Object token = null;
1:96d4e06:       boolean inInvoke = false;
1:96d4e06:       try {
1:96d4e06:         Object toInvoke = dispatcher.call();
1:96d4e06:         if(listener != null)
1:96d4e06:           token = listener.preInvoke(toInvoke, method, args);
1:96d4e06:         
1:96d4e06:         inInvoke = true;
1:96d4e06:         returnValue = ((Template) toInvoke).doStuff(args);
1:96d4e06:         inInvoke = false;
1:96d4e06:         
1:96d4e06:         if(listener != null)
1:96d4e06:           listener.postInvoke(token, toInvoke, method, args);
1:96d4e06:         
1:96d4e06:       } catch (Throwable e){
1:96d4e06:         // whether the the exception is an error is an application decision
1:96d4e06:         // if we catch an exception we decide carefully which one to
1:96d4e06:         // throw onwards
1:96d4e06:         Throwable exceptionToRethrow = null;
1:96d4e06:         // if the exception came from a precall or postcall 
1:96d4e06:         // we will rethrow it
1:96d4e06:         if (!inInvoke) {
1:96d4e06:           exceptionToRethrow = e;
1:96d4e06:         }
1:96d4e06:         // if the exception didn't come from precall or postcall then it
1:96d4e06:         // came from invoke
1:96d4e06:         // we will rethrow this exception if it is not a runtime
1:96d4e06:         // exception, but we must unwrap InvocationTargetExceptions
1:96d4e06:         else {
1:96d4e06:           if (!(e instanceof RuntimeException)) {
1:96d4e06:             exceptionToRethrow = e;
1:96d4e06:           }
1:96d4e06:         }
1:96d4e06:         try {
1:96d4e06:           if(listener != null)
1:96d4e06:             listener.postInvokeExceptionalReturn(token, method, null, e);
1:96d4e06:         } catch (Throwable f) {
1:96d4e06:           // we caught an exception from
1:96d4e06:           // postInvokeExceptionalReturn
1:96d4e06:           // if we haven't already chosen an exception to rethrow then
1:96d4e06:           // we will throw this exception
1:96d4e06:           if (exceptionToRethrow == null) {
1:96d4e06:             exceptionToRethrow = f;
1:96d4e06:           }
1:96d4e06:         }
1:96d4e06:         // if we made it this far without choosing an exception we
1:96d4e06:         // should throw e
1:96d4e06:         if (exceptionToRethrow == null) {
1:96d4e06:           exceptionToRethrow = e;
1:96d4e06:         }
1:96d4e06:         throw exceptionToRethrow;
1:96d4e06:       }
1:96d4e06:     }
1:96d4e06:     
1:96d4e06:     //...original method body
1:96d4e06:       </code>
1:96d4e06:  *  
1:96d4e06:  *   
1:96d4e06:  */
1:475ef33: public abstract class AbstractWovenProxyMethodAdapter extends GeneratorAdapter
2:96d4e06: {
1:96d4e06:   /** The type of a RuntimeException */
1:96d4e06:   private static final Type RUNTIME_EX_TYPE = Type.getType(RuntimeException.class);
1:96d4e06:   private static final Type THROWABLE_TYPE = Type.getType(Throwable.class);
1:96d4e06:   
1:96d4e06:   /** The postInvoke method of an {@link InvocationListener} */
1:96d4e06:   private static final Method POST_INVOKE_METHOD = getAsmMethodFromClass(InvocationListener.class, "postInvoke", Object.class,
1:96d4e06:       Object.class, java.lang.reflect.Method.class, Object.class);
1:96d4e06:   /** The postInvokeExceptionalReturn method of an {@link InvocationListener} */
1:96d4e06:   private static final Method POST_INVOKE_EXCEPTIONAL_METHOD = getAsmMethodFromClass(InvocationListener.class, 
1:96d4e06:       "postInvokeExceptionalReturn", Object.class, Object.class,
1:96d4e06:       java.lang.reflect.Method.class, Throwable.class);
1:96d4e06:   /** The preInvoke method of an {@link InvocationListener} */
1:96d4e06:   private static final Method PRE_INVOKE_METHOD = getAsmMethodFromClass(InvocationListener.class, "preInvoke", Object.class,
1:96d4e06:       java.lang.reflect.Method.class, Object[].class);
1:96d4e06:   
1:96d4e06:   
1:96d4e06:   /** The name of the static field that stores our {@link java.lang.reflect.Method} */
1:96d4e06:   private final String methodStaticFieldName;
1:96d4e06:   /** The current method */
1:96d4e06:   protected final Method currentTransformMethod;
1:96d4e06:   /** The type of <code>this</code> */
1:96d4e06:   protected final Type typeBeingWoven;
1:96d4e06:   /** True if this is a void method */
1:96d4e06:   private final boolean isVoid;
1:96d4e06: 
1:96d4e06:   //ints for local store
1:96d4e06:   /** The local we use to store the {@link InvocationListener} token */
1:96d4e06:   private int preInvokeReturnedToken;
1:96d4e06:   /** The local we use to note whether we are in the original method body or not */
1:96d4e06:   private int inNormalMethod;
1:96d4e06:   /** The local we use to store the invocation target to dispatch to */
1:96d4e06:   private int dispatchTarget;
1:96d4e06:   /** The local for storing our method's result */
1:96d4e06:   private int normalResult;
1:96d4e06: 
1:96d4e06:   //the Labels we need for jumping around the pre/post/postexception and current method code
1:96d4e06:   /** This marks the start of the try/catch around the pre/postInvoke*/
1:96d4e06:   private final Label beginTry = new Label();
1:96d4e06:   /** This marks the end of the try/catch around the pre/postInvoke*/
1:96d4e06:   private final Label endTry = new Label();
1:96d4e06: 
1:96d4e06:   /** The return type of this method */
1:96d4e06:   private final Type returnType;
1:96d4e06:   
1:8f852b6:   private final Type methodDeclaringType;
1:8f852b6:   
1:8f852b6:   private final boolean isMethodDeclaringTypeInterface;
1:051eadf:   private boolean isDefaultMethod;
1:8f852b6:   
1:96d4e06:   /**
1:96d4e06:    * Construct a new method adapter
1:96d4e06:    * @param mv - the method visitor to write to
1:96d4e06:    * @param access - the access modifiers on this method
1:96d4e06:    * @param name - the name of this method
1:96d4e06:    * @param desc - the descriptor of this method
1:96d4e06:    * @param methodStaticFieldName - the name of the static field that will hold
1:96d4e06:    *                                the {@link java.lang.reflect.Method} representing
1:96d4e06:    *                                this method.
1:96d4e06:    * @param currentTransformMethod - the ASM representation of this method
1:96d4e06:    * @param proxyType - the type being woven that contains this method
1:96d4e06:    */
1:96d4e06:   public AbstractWovenProxyMethodAdapter(MethodVisitor mv, int access, String name, String desc,
1:9a9631e:       String methodStaticFieldName, Method currentTransformMethod, Type typeBeingWoven,
1:9a9631e:       Type methodDeclaringType, boolean isMethodDeclaringTypeInterface, boolean isDefaultMethod)
1:9a9631e:   {
1:9a9631e:     super(ASM5, mv, access, name, desc);
1:9a9631e:     this.methodStaticFieldName = methodStaticFieldName;
1:9a9631e:     this.currentTransformMethod = currentTransformMethod;
1:9a9631e:     returnType = currentTransformMethod.getReturnType();
1:96d4e06:     isVoid = returnType.getSort() == Type.VOID;
1:96d4e06:     this.typeBeingWoven = typeBeingWoven;
1:8f852b6:     this.methodDeclaringType = methodDeclaringType;
1:8f852b6:     this.isMethodDeclaringTypeInterface = isMethodDeclaringTypeInterface;
1:051eadf:     this.isDefaultMethod = isDefaultMethod;
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   @Override
1:96d4e06:   public abstract void visitCode();
1:96d4e06: 
1:96d4e06:   @Override
1:96d4e06:   public abstract void visitMaxs(int stack, int locals);
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    * Write out the bytecode instructions necessary to do the dispatch.
1:96d4e06:    * We know the dispatcher is non-null, and we need a try/catch around the
1:96d4e06:    * invocation and listener calls.
1:96d4e06:    */
1:96d4e06:   protected final void writeDispatcher() {
1:96d4e06:     // Setup locals we will use in the dispatch
1:96d4e06:     setupLocals();
1:96d4e06:     
1:96d4e06:     //Write the try catch block
1:96d4e06:     visitTryCatchBlock(beginTry, endTry, endTry, THROWABLE_INAME);
1:96d4e06:     mark(beginTry);
1:96d4e06:     
1:96d4e06:     //Start dispatching, get the target object and store it
1:96d4e06:     loadThis();
1:96d4e06:     getField(typeBeingWoven, DISPATCHER_FIELD, DISPATCHER_TYPE);
1:96d4e06:     invokeInterface(DISPATCHER_TYPE, new Method("call", OBJECT_TYPE, NO_ARGS));
1:96d4e06:     storeLocal(dispatchTarget);
1:96d4e06:     
1:96d4e06:     //Pre-invoke, invoke, post-invoke, return
1:96d4e06:     writePreInvoke();
1:96d4e06:     //Start the real method
1:96d4e06:     push(true);
1:96d4e06:     storeLocal(inNormalMethod);
1:96d4e06:     
1:96d4e06:     //Dispatch the method and store the result (null for void)
1:96d4e06:     loadLocal(dispatchTarget);
1:8f852b6:     checkCast(methodDeclaringType);
1:96d4e06:     loadArgs();
1:051eadf:     if(isMethodDeclaringTypeInterface && !isDefaultMethod) {
1:8f852b6:       invokeInterface(methodDeclaringType, currentTransformMethod);
1:96d4e06:     } else {
1:8f852b6:       invokeVirtual(methodDeclaringType, currentTransformMethod);
1:96d4e06:     }
1:96d4e06:     if(isVoid) {
1:96d4e06:       visitInsn(ACONST_NULL);
1:96d4e06:     }
1:96d4e06:     storeLocal(normalResult);
1:96d4e06:     
1:96d4e06:     // finish the real method and post-invoke
1:96d4e06:     push(false);
1:96d4e06:     storeLocal(inNormalMethod);
1:96d4e06:     writePostInvoke();
1:96d4e06:     
1:96d4e06:     //Return, with the return value if necessary
1:96d4e06:     if(!!!isVoid) {
1:96d4e06:       loadLocal(normalResult);
1:96d4e06:     }
1:96d4e06:     returnValue();
1:96d4e06:     
1:96d4e06:     //End of our try, start of our catch
1:96d4e06:     mark(endTry);
1:96d4e06:     writeMethodCatchHandler();
1:96d4e06:   }
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    * Setup the normalResult, inNormalMethod, preInvokeReturnedToken and
1:96d4e06:    * dispatch target locals.
1:96d4e06:    */
1:96d4e06:   private final void setupLocals() {
1:96d4e06:     if (isVoid){
1:475ef33:       normalResult = newLocal(OBJECT_TYPE);
1:96d4e06:     } else{
1:96d4e06:       normalResult = newLocal(returnType);
1:96d4e06:     }
1:96d4e06:     
1:96d4e06:     preInvokeReturnedToken = newLocal(OBJECT_TYPE);
1:96d4e06:     visitInsn(ACONST_NULL);
1:96d4e06:     storeLocal(preInvokeReturnedToken);
1:96d4e06:     
1:96d4e06:     inNormalMethod = newLocal(Type.BOOLEAN_TYPE);
1:96d4e06:     push(false);
1:96d4e06:     storeLocal(inNormalMethod);
1:96d4e06:     
1:96d4e06:     dispatchTarget = newLocal(OBJECT_TYPE);
1:96d4e06:     visitInsn(ACONST_NULL);
1:96d4e06:     storeLocal(dispatchTarget);
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Begin trying to invoke the listener, if the listener is
1:96d4e06:    * null the bytecode will branch to the supplied label, other
1:96d4e06:    * otherwise it will load the listener onto the stack.
1:96d4e06:    * @param l The label to branch to
1:96d4e06:    */
1:96d4e06:   private final void beginListenerInvocation(Label l) {
1:96d4e06:     //If there's no listener then skip invocation
1:96d4e06:     loadThis();
1:96d4e06:     getField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);
1:96d4e06:     ifNull(l);
1:96d4e06:     loadThis();
1:96d4e06:     getField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Write out the preInvoke. This copes with the listener being null
1:96d4e06:    */
1:96d4e06:   private final void writePreInvoke() {
1:96d4e06:     //The place to go if the listener is null
1:96d4e06:     Label nullListener = newLabel();
1:96d4e06:     beginListenerInvocation(nullListener);
1:96d4e06: 
1:96d4e06:     // The listener is on the stack, we need (target, method, args)
1:96d4e06:     
1:96d4e06:     loadLocal(dispatchTarget);
1:96d4e06:     getStatic(typeBeingWoven, methodStaticFieldName, METHOD_TYPE);
1:96d4e06:     loadArgArray();
1:96d4e06:     
1:96d4e06:     //invoke it and store the token returned
1:475ef33:     invokeInterface(LISTENER_TYPE, PRE_INVOKE_METHOD);
1:96d4e06:     storeLocal(preInvokeReturnedToken);
1:96d4e06:     
1:96d4e06:     mark(nullListener);
1:96d4e06:   }
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    * Write out the postInvoke. This copes with the listener being null
1:96d4e06:    */
1:96d4e06:   private final void writePostInvoke() {
1:96d4e06:     //The place to go if the listener is null
1:96d4e06:     Label nullListener = newLabel();
1:96d4e06:     beginListenerInvocation(nullListener);
1:96d4e06:     
1:96d4e06:     // The listener is on the stack, we need (token, target, method, result)
1:96d4e06:     
1:96d4e06:     loadLocal(preInvokeReturnedToken);
1:96d4e06:     loadLocal(dispatchTarget);
1:475ef33:     getStatic(typeBeingWoven, methodStaticFieldName, METHOD_TYPE);
1:96d4e06:     loadLocal(normalResult);
1:96d4e06:     
1:96d4e06:     //If the result a primitive then we need to box it
1:96d4e06:     if (!!!isVoid && returnType.getSort() != Type.OBJECT && returnType.getSort() != Type.ARRAY){
1:96d4e06:       box(returnType);
1:96d4e06:     }
1:96d4e06:     
1:96d4e06:     //invoke the listener
1:475ef33:     invokeInterface(LISTENER_TYPE, POST_INVOKE_METHOD);
1:96d4e06:     
1:96d4e06:     mark(nullListener);
1:96d4e06:   }
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    * Write the catch handler for our method level catch, this runs the exceptional
1:96d4e06:    * post-invoke if there is a listener, and throws the correct exception at the
1:96d4e06:    * end
1:96d4e06:    */
1:96d4e06:   private final void writeMethodCatchHandler() {
1:96d4e06:     
1:96d4e06:     //Store the original exception
1:96d4e06:     int originalException = newLocal(THROWABLE_TYPE);
1:96d4e06:     storeLocal(originalException);
1:96d4e06:     
1:96d4e06:     //Start by initialising exceptionToRethrow
1:96d4e06:     int exceptionToRethrow = newLocal(THROWABLE_TYPE);
1:96d4e06:     visitInsn(ACONST_NULL);
1:96d4e06:     storeLocal(exceptionToRethrow);
1:96d4e06:     
1:96d4e06:     //We need another try catch around the postInvokeExceptionalReturn, so here 
1:96d4e06:     //are some labels and the declaration for it
1:96d4e06:     Label beforeInvoke = newLabel();
1:96d4e06:     Label afterInvoke = newLabel();
1:96d4e06:     visitTryCatchBlock(beforeInvoke, afterInvoke, afterInvoke, THROWABLE_INAME);
1:96d4e06:     
1:96d4e06:     //If we aren't in normal flow then set exceptionToRethrow = originalException
1:96d4e06:     loadLocal(inNormalMethod);
1:96d4e06:     Label inNormalMethodLabel = newLabel();
1:96d4e06:     // Jump if not zero (false)
1:96d4e06:     visitJumpInsn(IFNE, inNormalMethodLabel);
1:96d4e06:     loadLocal(originalException);
1:96d4e06:     storeLocal(exceptionToRethrow);
1:96d4e06:     goTo(beforeInvoke);
1:96d4e06:     
1:96d4e06:     mark(inNormalMethodLabel);
1:96d4e06:     //We are in normal method flow so set exceptionToRethrow = originalException
1:96d4e06:     //if originalException is not a runtime exception
1:96d4e06:     loadLocal(originalException);
1:96d4e06:     instanceOf(RUNTIME_EX_TYPE);
1:96d4e06:     //If false then store original in toThrow, otherwise go to beforeInvoke
1:96d4e06:     visitJumpInsn(IFNE, beforeInvoke);
1:96d4e06:     loadLocal(originalException);
1:96d4e06:     storeLocal(exceptionToRethrow);
1:96d4e06:     goTo(beforeInvoke);
1:96d4e06:     //Setup of variables finished, begin try/catch
1:96d4e06:        
1:96d4e06:     //Mark the start of our try
1:96d4e06:     mark(beforeInvoke);
1:96d4e06:     //Begin invocation of the listener, jump to throw if null
1:96d4e06:     Label throwSelectedException = newLabel();
1:96d4e06:     beginListenerInvocation(throwSelectedException);
1:96d4e06:     
1:96d4e06:     //We have a listener, so call it (token, target, method, exception)
1:96d4e06:     loadLocal(preInvokeReturnedToken);
1:96d4e06:     loadLocal(dispatchTarget);
1:96d4e06:     getStatic(typeBeingWoven, methodStaticFieldName, METHOD_TYPE);
1:96d4e06:     loadLocal(originalException);
1:475ef33:     invokeInterface(LISTENER_TYPE, POST_INVOKE_EXCEPTIONAL_METHOD);
1:96d4e06:     goTo(throwSelectedException);
1:96d4e06:     
1:96d4e06:     mark(afterInvoke);
1:96d4e06:     //catching another exception replaces the original
1:96d4e06:     storeLocal(originalException);
1:96d4e06: 
1:96d4e06:     //Throw exceptionToRethrow if it isn't null, or the original if it is
1:96d4e06:     Label throwException = newLabel();
1:96d4e06:     mark(throwSelectedException);
1:96d4e06:     loadLocal(exceptionToRethrow);
1:96d4e06:     ifNonNull(throwException);
1:96d4e06:     loadLocal(originalException);
1:96d4e06:     storeLocal(exceptionToRethrow);
1:96d4e06:     
1:96d4e06:     mark(throwException);
1:96d4e06:     loadLocal(exceptionToRethrow);
1:96d4e06:     throwException();
1:96d4e06:   }
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    * This method unwraps woven proxy instances for use in the right-hand side
1:96d4e06:    * of equals methods
1:96d4e06:    */
1:96d4e06:   protected final void unwrapEqualsArgument() {
1:96d4e06:     
1:96d4e06:     //Create and initialize a local for our work
1:475ef33:     int unwrapLocal = newLocal(OBJECT_TYPE);
1:96d4e06:     visitInsn(ACONST_NULL);
1:96d4e06:     storeLocal(unwrapLocal);
1:96d4e06:     
1:96d4e06:     Label startUnwrap = newLabel();
1:96d4e06:     mark(startUnwrap);
1:96d4e06:     //Load arg and check if it is a WovenProxy instances
1:96d4e06:     loadArg(0);
1:475ef33:     instanceOf(WOVEN_PROXY_IFACE_TYPE);
1:96d4e06:     Label unwrapFinished = newLabel();
1:96d4e06:     //Jump if zero (false)
1:96d4e06:     visitJumpInsn(Opcodes.IFEQ, unwrapFinished);
1:96d4e06:     //Arg is a wovenProxy, if it is the same as last time then we're done
1:96d4e06:     loadLocal(unwrapLocal);
1:96d4e06:     loadArg(0);
1:475ef33:     ifCmp(OBJECT_TYPE, EQ, unwrapFinished);
1:96d4e06:     //Not the same, store current arg in unwrapLocal for next loop
1:96d4e06:     loadArg(0);
1:96d4e06:     storeLocal(unwrapLocal);
1:96d4e06:     
1:96d4e06:     //So arg is a WovenProxy, but not the same as last time, cast it and store 
1:96d4e06:     //the result of unwrap.call in the arg
1:96d4e06:     loadArg(0);
1:475ef33:     checkCast(WOVEN_PROXY_IFACE_TYPE);
1:96d4e06:     //Now unwrap
1:475ef33:     invokeInterface(WOVEN_PROXY_IFACE_TYPE, new Method("org_apache_aries_proxy_weaving_WovenProxy_unwrap",
1:475ef33:         DISPATCHER_TYPE, NO_ARGS));
1:96d4e06:     
1:96d4e06:     //Now we may have a Callable to invoke
1:475ef33:     int callable = newLocal(DISPATCHER_TYPE);
1:96d4e06:     storeLocal(callable);
1:96d4e06:     loadLocal(callable);
1:96d4e06:     ifNull(unwrapFinished);
1:96d4e06:     loadLocal(callable);
1:475ef33:     invokeInterface(DISPATCHER_TYPE, new Method("call",
1:475ef33:         OBJECT_TYPE, NO_ARGS));
1:96d4e06:     //Store the result and we're done (for this iteration)
1:96d4e06:     storeArg(0);
1:96d4e06:     goTo(startUnwrap);
1:96d4e06:     
1:96d4e06:     mark(unwrapFinished);
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * A utility method for getting an ASM method from a Class
1:96d4e06:    * @param clazz the class to search
1:96d4e06:    * @param name The method name
1:96d4e06:    * @param argTypes The method args
2:96d4e06:    * @return
1:96d4e06:    */
1:96d4e06:   private static final Method getAsmMethodFromClass(Class<?> clazz, String name, Class<?>... argTypes)
1:96d4e06:   {
1:96d4e06:     //get the java.lang.reflect.Method to get the types
1:96d4e06:     java.lang.reflect.Method ilMethod = null;
1:96d4e06:     try {
1:96d4e06:       ilMethod = clazz.getMethod(name, argTypes);
1:96d4e06:     } catch (Exception e) {
1:96d4e06:       //Should be impossible!
1:ef57cb3:       throw new RuntimeException(NLS.MESSAGES.getMessage("error.finding.invocation.listener.method", name, Arrays.toString(argTypes)), e);
1:96d4e06:     }
1:96d4e06:     //get the ASM method
1:96d4e06:     return new Method(name, Type.getReturnType(ilMethod), Type.getArgumentTypes(ilMethod));
1:96d4e06:   }
1:96d4e06: }
============================================================================
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:9a9631e
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.WOVEN_PROXY_IFACE_TYPE;
1: import static org.objectweb.asm.Opcodes.ACONST_NULL;
1: import static org.objectweb.asm.Opcodes.IFNE;
1: import static org.objectweb.asm.Opcodes.ASM5;
1: 
1: import java.util.Arrays;
1: 
/////////////////////////////////////////////////////////////////////////
1:       String methodStaticFieldName, Method currentTransformMethod, Type typeBeingWoven,
1:       Type methodDeclaringType, boolean isMethodDeclaringTypeInterface, boolean isDefaultMethod)
1:   {
1:     super(ASM5, mv, access, name, desc);
1:     this.methodStaticFieldName = methodStaticFieldName;
1:     this.currentTransformMethod = currentTransformMethod;
1:     returnType = currentTransformMethod.getReturnType();
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:051eadf
/////////////////////////////////////////////////////////////////////////
0: import static org.objectweb.asm.Opcodes.ASM4;
/////////////////////////////////////////////////////////////////////////
1:   private boolean isDefaultMethod;
/////////////////////////////////////////////////////////////////////////
0:       Type methodDeclaringType, boolean isMethodDeclaringTypeInterface, boolean isDefaultMethod)
0:     super(ASM4, mv, access, name, desc);
/////////////////////////////////////////////////////////////////////////
1:     this.isDefaultMethod = isDefaultMethod;
/////////////////////////////////////////////////////////////////////////
1:     if(isMethodDeclaringTypeInterface && !isDefaultMethod) {
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:8f852b6
/////////////////////////////////////////////////////////////////////////
1:  * subclasses {@link WovenProxyConcreteMethodAdapter} is used for weaving instance methods
1:  * {@link WovenProxyAbstractMethodAdapter} is used to provide a delegating
/////////////////////////////////////////////////////////////////////////
1:   private final Type methodDeclaringType;
1:   
1:   private final boolean isMethodDeclaringTypeInterface;
1:   
/////////////////////////////////////////////////////////////////////////
0:       String methodStaticFieldName, Method currentTransformMethod, Type typeBeingWoven,
0:       Type methodDeclaringType, boolean isMethodDeclaringTypeInterface)
/////////////////////////////////////////////////////////////////////////
1:     this.methodDeclaringType = methodDeclaringType;
1:     this.isMethodDeclaringTypeInterface = isMethodDeclaringTypeInterface;
/////////////////////////////////////////////////////////////////////////
1:     checkCast(methodDeclaringType);
0:     if(isMethodDeclaringTypeInterface) {
1:       invokeInterface(methodDeclaringType, currentTransformMethod);
1:       invokeVirtual(methodDeclaringType, currentTransformMethod);
/////////////////////////////////////////////////////////////////////////
commit:475ef33
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.proxy.impl.common;
1: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.DISPATCHER_FIELD;
1: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.DISPATCHER_TYPE;
1: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.LISTENER_FIELD;
1: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.LISTENER_TYPE;
1: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.METHOD_TYPE;
1: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.NO_ARGS;
1: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.OBJECT_TYPE;
1: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.THROWABLE_INAME;
0: import static org.apache.aries.proxy.impl.common.AbstractWovenProxyAdapter.WOVEN_PROXY_IFACE_TYPE;
/////////////////////////////////////////////////////////////////////////
1: public abstract class AbstractWovenProxyMethodAdapter extends GeneratorAdapter
/////////////////////////////////////////////////////////////////////////
1:       normalResult = newLocal(OBJECT_TYPE);
/////////////////////////////////////////////////////////////////////////
1:     invokeInterface(LISTENER_TYPE, PRE_INVOKE_METHOD);
/////////////////////////////////////////////////////////////////////////
1:     getStatic(typeBeingWoven, methodStaticFieldName, METHOD_TYPE);
/////////////////////////////////////////////////////////////////////////
1:     invokeInterface(LISTENER_TYPE, POST_INVOKE_METHOD);
/////////////////////////////////////////////////////////////////////////
1:     invokeInterface(LISTENER_TYPE, POST_INVOKE_EXCEPTIONAL_METHOD);
/////////////////////////////////////////////////////////////////////////
1:     int unwrapLocal = newLocal(OBJECT_TYPE);
/////////////////////////////////////////////////////////////////////////
1:     instanceOf(WOVEN_PROXY_IFACE_TYPE);
1:     ifCmp(OBJECT_TYPE, EQ, unwrapFinished);
/////////////////////////////////////////////////////////////////////////
1:     checkCast(WOVEN_PROXY_IFACE_TYPE);
1:     invokeInterface(WOVEN_PROXY_IFACE_TYPE, new Method("org_apache_aries_proxy_weaving_WovenProxy_unwrap",
1:         DISPATCHER_TYPE, NO_ARGS));
1:     int callable = newLocal(DISPATCHER_TYPE);
1:     invokeInterface(DISPATCHER_TYPE, new Method("call",
1:         OBJECT_TYPE, NO_ARGS));
commit:96d4e06
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.aries.proxy.impl.weaving;
1: 
0: import static org.apache.aries.proxy.impl.weaving.WovenProxyAdapter.DISPATCHER_FIELD;
0: import static org.apache.aries.proxy.impl.weaving.WovenProxyAdapter.DISPATCHER_TYPE;
0: import static org.apache.aries.proxy.impl.weaving.WovenProxyAdapter.LISTENER_FIELD;
0: import static org.apache.aries.proxy.impl.weaving.WovenProxyAdapter.LISTENER_TYPE;
0: import static org.apache.aries.proxy.impl.weaving.WovenProxyAdapter.METHOD_TYPE;
0: import static org.apache.aries.proxy.impl.weaving.WovenProxyAdapter.NO_ARGS;
0: import static org.apache.aries.proxy.impl.weaving.WovenProxyAdapter.OBJECT_TYPE;
0: import static org.apache.aries.proxy.impl.weaving.WovenProxyAdapter.THROWABLE_INAME;
0: import static org.objectweb.asm.Opcodes.ACONST_NULL;
0: import static org.objectweb.asm.Opcodes.IFNE;
1: 
0: import java.util.Arrays;
1: 
1: import org.apache.aries.proxy.InvocationListener;
1: import org.objectweb.asm.Label;
1: import org.objectweb.asm.MethodVisitor;
1: import org.objectweb.asm.Opcodes;
1: import org.objectweb.asm.Type;
1: import org.objectweb.asm.commons.GeneratorAdapter;
1: import org.objectweb.asm.commons.Method;
1: /**
1:  * This class weaves dispatch and listener code into a method, there are two known
0:  * subclasses {@link WovenProxyMethodAdapter} is used for weaving instance methods
0:  * {@link InterfaceUsingWovenProxyMethodAdapter} is used to provide a delegating
1:  * implementation of an interface method.
1:  * 
1:  * Roughly (but not exactly because it's easier to write working bytecode
1:  * if you don't have to exactly recreate the Java!) this is trying to 
1:  * do the following: <code>
1:  * 
1:  *      
1:     if(dispatcher != null) {
1:       int returnValue;
1:       Object token = null;
1:       boolean inInvoke = false;
1:       try {
1:         Object toInvoke = dispatcher.call();
1:         if(listener != null)
1:           token = listener.preInvoke(toInvoke, method, args);
1:         
1:         inInvoke = true;
1:         returnValue = ((Template) toInvoke).doStuff(args);
1:         inInvoke = false;
1:         
1:         if(listener != null)
1:           listener.postInvoke(token, toInvoke, method, args);
1:         
1:       } catch (Throwable e){
1:         // whether the the exception is an error is an application decision
1:         // if we catch an exception we decide carefully which one to
1:         // throw onwards
1:         Throwable exceptionToRethrow = null;
1:         // if the exception came from a precall or postcall 
1:         // we will rethrow it
1:         if (!inInvoke) {
1:           exceptionToRethrow = e;
1:         }
1:         // if the exception didn't come from precall or postcall then it
1:         // came from invoke
1:         // we will rethrow this exception if it is not a runtime
1:         // exception, but we must unwrap InvocationTargetExceptions
1:         else {
1:           if (!(e instanceof RuntimeException)) {
1:             exceptionToRethrow = e;
1:           }
1:         }
1:         try {
1:           if(listener != null)
1:             listener.postInvokeExceptionalReturn(token, method, null, e);
1:         } catch (Throwable f) {
1:           // we caught an exception from
1:           // postInvokeExceptionalReturn
1:           // if we haven't already chosen an exception to rethrow then
1:           // we will throw this exception
1:           if (exceptionToRethrow == null) {
1:             exceptionToRethrow = f;
1:           }
1:         }
1:         // if we made it this far without choosing an exception we
1:         // should throw e
1:         if (exceptionToRethrow == null) {
1:           exceptionToRethrow = e;
1:         }
1:         throw exceptionToRethrow;
1:       }
1:     }
1:     
1:     //...original method body
1:       </code>
1:  *  
1:  *   
1:  */
0: abstract class AbstractWovenProxyMethodAdapter extends GeneratorAdapter
1: {
1:   /** The type of a RuntimeException */
1:   private static final Type RUNTIME_EX_TYPE = Type.getType(RuntimeException.class);
1:   private static final Type THROWABLE_TYPE = Type.getType(Throwable.class);
1:   
1:   /** The postInvoke method of an {@link InvocationListener} */
1:   private static final Method POST_INVOKE_METHOD = getAsmMethodFromClass(InvocationListener.class, "postInvoke", Object.class,
1:       Object.class, java.lang.reflect.Method.class, Object.class);
1:   /** The postInvokeExceptionalReturn method of an {@link InvocationListener} */
1:   private static final Method POST_INVOKE_EXCEPTIONAL_METHOD = getAsmMethodFromClass(InvocationListener.class, 
1:       "postInvokeExceptionalReturn", Object.class, Object.class,
1:       java.lang.reflect.Method.class, Throwable.class);
1:   /** The preInvoke method of an {@link InvocationListener} */
1:   private static final Method PRE_INVOKE_METHOD = getAsmMethodFromClass(InvocationListener.class, "preInvoke", Object.class,
1:       java.lang.reflect.Method.class, Object[].class);
1:   
1:   
1:   /** The name of the static field that stores our {@link java.lang.reflect.Method} */
1:   private final String methodStaticFieldName;
1:   /** The current method */
1:   protected final Method currentTransformMethod;
1:   /** The type of <code>this</code> */
1:   protected final Type typeBeingWoven;
1:   /** True if this is a void method */
1:   private final boolean isVoid;
1: 
1:   //ints for local store
1:   /** The local we use to store the {@link InvocationListener} token */
1:   private int preInvokeReturnedToken;
1:   /** The local we use to note whether we are in the original method body or not */
1:   private int inNormalMethod;
1:   /** The local we use to store the invocation target to dispatch to */
1:   private int dispatchTarget;
1:   /** The local for storing our method's result */
1:   private int normalResult;
1: 
1:   //the Labels we need for jumping around the pre/post/postexception and current method code
1:   /** This marks the start of the try/catch around the pre/postInvoke*/
1:   private final Label beginTry = new Label();
1:   /** This marks the end of the try/catch around the pre/postInvoke*/
1:   private final Label endTry = new Label();
1: 
1:   /** The return type of this method */
1:   private final Type returnType;
1:   
1:   /**
1:    * Construct a new method adapter
1:    * @param mv - the method visitor to write to
1:    * @param access - the access modifiers on this method
1:    * @param name - the name of this method
1:    * @param desc - the descriptor of this method
1:    * @param methodStaticFieldName - the name of the static field that will hold
1:    *                                the {@link java.lang.reflect.Method} representing
1:    *                                this method.
1:    * @param currentTransformMethod - the ASM representation of this method
1:    * @param proxyType - the type being woven that contains this method
1:    */
1:   public AbstractWovenProxyMethodAdapter(MethodVisitor mv, int access, String name, String desc,
0:       String methodStaticFieldName, Method currentTransformMethod, Type typeBeingWoven)
1:   {
0:     super(mv, access, name, desc);
0:     this.methodStaticFieldName = methodStaticFieldName;
0:     this.currentTransformMethod = currentTransformMethod;
0:     returnType = currentTransformMethod.getReturnType();
1:     isVoid = returnType.getSort() == Type.VOID;
1:     this.typeBeingWoven = typeBeingWoven;
1:   }
1: 
1:   @Override
1:   public abstract void visitCode();
1: 
1:   @Override
1:   public abstract void visitMaxs(int stack, int locals);
1:   
1:   /**
1:    * Write out the bytecode instructions necessary to do the dispatch.
1:    * We know the dispatcher is non-null, and we need a try/catch around the
1:    * invocation and listener calls.
1:    */
1:   protected final void writeDispatcher() {
1:     // Setup locals we will use in the dispatch
1:     setupLocals();
1:     
1:     //Write the try catch block
1:     visitTryCatchBlock(beginTry, endTry, endTry, THROWABLE_INAME);
1:     mark(beginTry);
1:     
1:     //Start dispatching, get the target object and store it
1:     loadThis();
1:     getField(typeBeingWoven, DISPATCHER_FIELD, DISPATCHER_TYPE);
1:     invokeInterface(DISPATCHER_TYPE, new Method("call", OBJECT_TYPE, NO_ARGS));
1:     storeLocal(dispatchTarget);
1:     
1:     //Pre-invoke, invoke, post-invoke, return
1:     writePreInvoke();
1:     //Start the real method
1:     push(true);
1:     storeLocal(inNormalMethod);
1:     
1:     //Dispatch the method and store the result (null for void)
1:     loadLocal(dispatchTarget);
0:     checkCast(getTypeToCastTo());
1:     loadArgs();
0:     if(isTypeToCastToInterface()) {
0:       invokeInterface(getTypeToCastTo(), currentTransformMethod);
1:     } else {
0:       invokeVirtual(getTypeToCastTo(), currentTransformMethod);
1:     }
1:     if(isVoid) {
1:       visitInsn(ACONST_NULL);
1:     }
1:     storeLocal(normalResult);
1:     
1:     // finish the real method and post-invoke
1:     push(false);
1:     storeLocal(inNormalMethod);
1:     writePostInvoke();
1:     
1:     //Return, with the return value if necessary
1:     if(!!!isVoid) {
1:       loadLocal(normalResult);
1:     }
1:     returnValue();
1:     
1:     //End of our try, start of our catch
1:     mark(endTry);
1:     writeMethodCatchHandler();
1:   }
1:   
1:   /**
0:    * Get the type to which the class should be cast for delegation
1:    * @return
1:    */
0:   protected abstract Type getTypeToCastTo();
1:   
0:   protected abstract boolean isTypeToCastToInterface();
1:   
1:   /**
1:    * Setup the normalResult, inNormalMethod, preInvokeReturnedToken and
1:    * dispatch target locals.
1:    */
1:   private final void setupLocals() {
1:     if (isVoid){
0:       normalResult = newLocal(WovenProxyAdapter.OBJECT_TYPE);
1:     } else{
1:       normalResult = newLocal(returnType);
1:     }
1:     
1:     preInvokeReturnedToken = newLocal(OBJECT_TYPE);
1:     visitInsn(ACONST_NULL);
1:     storeLocal(preInvokeReturnedToken);
1:     
1:     inNormalMethod = newLocal(Type.BOOLEAN_TYPE);
1:     push(false);
1:     storeLocal(inNormalMethod);
1:     
1:     dispatchTarget = newLocal(OBJECT_TYPE);
1:     visitInsn(ACONST_NULL);
1:     storeLocal(dispatchTarget);
1:   }
1: 
1:   /**
1:    * Begin trying to invoke the listener, if the listener is
1:    * null the bytecode will branch to the supplied label, other
1:    * otherwise it will load the listener onto the stack.
1:    * @param l The label to branch to
1:    */
1:   private final void beginListenerInvocation(Label l) {
1:     //If there's no listener then skip invocation
1:     loadThis();
1:     getField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);
1:     ifNull(l);
1:     loadThis();
1:     getField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);
1:   }
1: 
1:   /**
1:    * Write out the preInvoke. This copes with the listener being null
1:    */
1:   private final void writePreInvoke() {
1:     //The place to go if the listener is null
1:     Label nullListener = newLabel();
1:     beginListenerInvocation(nullListener);
1: 
1:     // The listener is on the stack, we need (target, method, args)
1:     
1:     loadLocal(dispatchTarget);
1:     getStatic(typeBeingWoven, methodStaticFieldName, METHOD_TYPE);
1:     loadArgArray();
1:     
1:     //invoke it and store the token returned
0:     invokeInterface(WovenProxyAdapter.LISTENER_TYPE, PRE_INVOKE_METHOD);
1:     storeLocal(preInvokeReturnedToken);
1:     
1:     mark(nullListener);
1:   }
1:   
1:   /**
1:    * Write out the postInvoke. This copes with the listener being null
1:    */
1:   private final void writePostInvoke() {
1:     //The place to go if the listener is null
1:     Label nullListener = newLabel();
1:     beginListenerInvocation(nullListener);
1:     
1:     // The listener is on the stack, we need (token, target, method, result)
1:     
1:     loadLocal(preInvokeReturnedToken);
1:     loadLocal(dispatchTarget);
0:     getStatic(typeBeingWoven, methodStaticFieldName, WovenProxyAdapter.METHOD_TYPE);
1:     loadLocal(normalResult);
1:     
1:     //If the result a primitive then we need to box it
1:     if (!!!isVoid && returnType.getSort() != Type.OBJECT && returnType.getSort() != Type.ARRAY){
1:       box(returnType);
1:     }
1:     
1:     //invoke the listener
0:     invokeInterface(WovenProxyAdapter.LISTENER_TYPE, POST_INVOKE_METHOD);
1:     
1:     mark(nullListener);
1:   }
1:   
1:   /**
1:    * Write the catch handler for our method level catch, this runs the exceptional
1:    * post-invoke if there is a listener, and throws the correct exception at the
1:    * end
1:    */
1:   private final void writeMethodCatchHandler() {
1:     
1:     //Store the original exception
1:     int originalException = newLocal(THROWABLE_TYPE);
1:     storeLocal(originalException);
1:     
1:     //Start by initialising exceptionToRethrow
1:     int exceptionToRethrow = newLocal(THROWABLE_TYPE);
1:     visitInsn(ACONST_NULL);
1:     storeLocal(exceptionToRethrow);
1:     
1:     //We need another try catch around the postInvokeExceptionalReturn, so here 
1:     //are some labels and the declaration for it
1:     Label beforeInvoke = newLabel();
1:     Label afterInvoke = newLabel();
1:     visitTryCatchBlock(beforeInvoke, afterInvoke, afterInvoke, THROWABLE_INAME);
1:     
1:     //If we aren't in normal flow then set exceptionToRethrow = originalException
1:     loadLocal(inNormalMethod);
1:     Label inNormalMethodLabel = newLabel();
1:     // Jump if not zero (false)
1:     visitJumpInsn(IFNE, inNormalMethodLabel);
1:     loadLocal(originalException);
1:     storeLocal(exceptionToRethrow);
1:     goTo(beforeInvoke);
1:     
1:     mark(inNormalMethodLabel);
1:     //We are in normal method flow so set exceptionToRethrow = originalException
1:     //if originalException is not a runtime exception
1:     loadLocal(originalException);
1:     instanceOf(RUNTIME_EX_TYPE);
1:     //If false then store original in toThrow, otherwise go to beforeInvoke
1:     visitJumpInsn(IFNE, beforeInvoke);
1:     loadLocal(originalException);
1:     storeLocal(exceptionToRethrow);
1:     goTo(beforeInvoke);
1:     //Setup of variables finished, begin try/catch
1:        
1:     //Mark the start of our try
1:     mark(beforeInvoke);
1:     //Begin invocation of the listener, jump to throw if null
1:     Label throwSelectedException = newLabel();
1:     beginListenerInvocation(throwSelectedException);
1:     
1:     //We have a listener, so call it (token, target, method, exception)
1:     loadLocal(preInvokeReturnedToken);
1:     loadLocal(dispatchTarget);
1:     getStatic(typeBeingWoven, methodStaticFieldName, METHOD_TYPE);
1:     loadLocal(originalException);
0:     invokeInterface(WovenProxyAdapter.LISTENER_TYPE, POST_INVOKE_EXCEPTIONAL_METHOD);
1:     goTo(throwSelectedException);
1:     
1:     mark(afterInvoke);
1:     //catching another exception replaces the original
1:     storeLocal(originalException);
1: 
1:     //Throw exceptionToRethrow if it isn't null, or the original if it is
1:     Label throwException = newLabel();
1:     mark(throwSelectedException);
1:     loadLocal(exceptionToRethrow);
1:     ifNonNull(throwException);
1:     loadLocal(originalException);
1:     storeLocal(exceptionToRethrow);
1:     
1:     mark(throwException);
1:     loadLocal(exceptionToRethrow);
1:     throwException();
1:   }
1:   
1:   /**
1:    * This method unwraps woven proxy instances for use in the right-hand side
1:    * of equals methods
1:    */
1:   protected final void unwrapEqualsArgument() {
1:     
1:     //Create and initialize a local for our work
0:     int unwrapLocal = newLocal(WovenProxyAdapter.OBJECT_TYPE);
1:     visitInsn(ACONST_NULL);
1:     storeLocal(unwrapLocal);
1:     
1:     Label startUnwrap = newLabel();
1:     mark(startUnwrap);
1:     //Load arg and check if it is a WovenProxy instances
1:     loadArg(0);
0:     instanceOf(WovenProxyAdapter.WOVEN_PROXY_IFACE_TYPE);
1:     Label unwrapFinished = newLabel();
1:     //Jump if zero (false)
1:     visitJumpInsn(Opcodes.IFEQ, unwrapFinished);
1:     //Arg is a wovenProxy, if it is the same as last time then we're done
1:     loadLocal(unwrapLocal);
1:     loadArg(0);
0:     ifCmp(WovenProxyAdapter.OBJECT_TYPE, EQ, unwrapFinished);
1:     //Not the same, store current arg in unwrapLocal for next loop
1:     loadArg(0);
1:     storeLocal(unwrapLocal);
1:     
1:     //So arg is a WovenProxy, but not the same as last time, cast it and store 
1:     //the result of unwrap.call in the arg
1:     loadArg(0);
0:     checkCast(WovenProxyAdapter.WOVEN_PROXY_IFACE_TYPE);
1:     //Now unwrap
0:     invokeInterface(WovenProxyAdapter.WOVEN_PROXY_IFACE_TYPE, new Method("org_apache_aries_proxy_weaving_WovenProxy_unwrap",
0:         WovenProxyAdapter.DISPATCHER_TYPE, WovenProxyAdapter.NO_ARGS));
1:     
1:     //Now we may have a Callable to invoke
0:     int callable = newLocal(WovenProxyAdapter.DISPATCHER_TYPE);
1:     storeLocal(callable);
1:     loadLocal(callable);
1:     ifNull(unwrapFinished);
1:     loadLocal(callable);
0:     invokeInterface(WovenProxyAdapter.DISPATCHER_TYPE, new Method("call",
0:         WovenProxyAdapter.OBJECT_TYPE, WovenProxyAdapter.NO_ARGS));
1:     //Store the result and we're done (for this iteration)
1:     storeArg(0);
1:     goTo(startUnwrap);
1:     
1:     mark(unwrapFinished);
1:   }
1: 
1:   /**
1:    * A utility method for getting an ASM method from a Class
1:    * @param clazz the class to search
1:    * @param name The method name
1:    * @param argTypes The method args
1:    * @return
1:    */
1:   private static final Method getAsmMethodFromClass(Class<?> clazz, String name, Class<?>... argTypes)
1:   {
1:     //get the java.lang.reflect.Method to get the types
1:     java.lang.reflect.Method ilMethod = null;
1:     try {
1:       ilMethod = clazz.getMethod(name, argTypes);
1:     } catch (Exception e) {
1:       //Should be impossible!
0:       throw new RuntimeException("Error finding Invocation Listener method " + name
0:           + " " + Arrays.toString(argTypes), e);
1:     }
1:     //get the ASM method
1:     return new Method(name, Type.getReturnType(ilMethod), Type.getArgumentTypes(ilMethod));
1:   }
1: }
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:ef57cb3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.impl.NLS;
/////////////////////////////////////////////////////////////////////////
1:       throw new RuntimeException(NLS.MESSAGES.getMessage("error.finding.invocation.listener.method", name, Arrays.toString(argTypes)), e);
============================================================================