1:2227f26: /*
1:2227f26:  * Licensed to the Apache Software Foundation (ASF) under one
1:2227f26:  * or more contributor license agreements.  See the NOTICE file
1:2227f26:  * distributed with this work for additional information
1:2227f26:  * regarding copyright ownership.  The ASF licenses this file
1:2227f26:  * to you under the Apache License, Version 2.0 (the
1:2227f26:  * "License"); you may not use this file except in compliance
1:2227f26:  * with the License.  You may obtain a copy of the License at
1:754e2c3:  *
1:2227f26:  *   http://www.apache.org/licenses/LICENSE-2.0
1:754e2c3:  *
1:2227f26:  * Unless required by applicable law or agreed to in writing,
1:2227f26:  * software distributed under the License is distributed on an
1:2227f26:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:2227f26:  * KIND, either express or implied.  See the License for the
1:2227f26:  * specific language governing permissions and limitations
1:2227f26:  * under the License.
1:2227f26:  */
5:2ce4177: 
1:910fec0: package org.apache.aries.util.filesystem;
1:754e2c3: 
1:2227f26: import static org.junit.Assert.assertEquals;
1:2227f26: import static org.junit.Assert.assertFalse;
1:2227f26: import static org.junit.Assert.assertNotNull;
1:2227f26: import static org.junit.Assert.assertNull;
1:2227f26: import static org.junit.Assert.assertTrue;
1:8ab18a7: import static org.junit.Assert.fail;
1:2ce4177: 
1:2227f26: import java.io.File;
1:2227f26: import java.io.FileInputStream;
1:2227f26: import java.io.FileOutputStream;
1:2227f26: import java.io.IOException;
1:2227f26: import java.io.InputStream;
1:754e2c3: import java.lang.reflect.Field;
1:e62fca9: import java.util.Collection;
1:5959a0a: import java.util.Iterator;
1:2227f26: import java.util.List;
1:2227f26: import java.util.jar.Manifest;
1:2227f26: import java.util.zip.ZipEntry;
1:2ce4177: import java.util.zip.ZipFile;
1:2227f26: import java.util.zip.ZipOutputStream;
1:910fec0: 
1:2227f26: import org.apache.aries.unittest.junit.Assert;
1:8ab18a7: import org.apache.aries.util.IORuntimeException;
1:c6cb34d: import org.apache.aries.util.io.IOUtils;
1:e4ac3a5: import org.junit.AfterClass;
1:2227f26: import org.junit.BeforeClass;
1:2227f26: import org.junit.Test;
1:2ce4177: 
1:2ce4177: 
1:2227f26: /**
1:2227f26:  * This class contains tests for the virtual file system.
1:2227f26:  */
1:2227f26: public class FileSystemTest
1:2227f26: {
1:2227f26:   /**
1:2227f26:    * Make sure we correctly understand the content of the application when the
1:2227f26:    * application is an exploded directory. This test just checks that the
1:2227f26:    * root directory returns the expected information.
1:8ab18a7:    *
1:2227f26:    * @throws IOException
1:2227f26:    */
1:2227f26:   @Test(expected=UnsupportedOperationException.class)
1:2227f26:   public void basicRootDirTestsWithFiles() throws IOException
1:2227f26:   {
1:e62fca9:     File baseDir = new File(getTestResourceDir(), "/app1");
1:910fec0:     File manifest = new File(baseDir, "META-INF/APPLICATION.MF");
1:2227f26:     IDirectory dir = FileSystem.getFSRoot(baseDir);
1:8ab18a7: 
1:2227f26:     runBasicRootDirTests(dir, baseDir.length(), manifest.lastModified());
5:2227f26:   }
1:8ab18a7: 
1:2227f26:   /**
1:2227f26:    * Make sure we correctly understand the directory structure for exploded
1:2227f26:    * directories.
1:8ab18a7:    *
1:2227f26:    * @throws IOException
1:f2492f7:    */
1:f2492f7:   @Test
1:2227f26:   public void basicDirTestsWithFiles() throws IOException
1:2227f26:   {
1:e62fca9:     File baseDir = new File(getTestResourceDir(), "/app1");
1:2227f26:     IDirectory dir = FileSystem.getFSRoot(baseDir);
1:754e2c3: 
1:910fec0:     File desiredFile = new File(baseDir, "META-INF/APPLICATION.MF");
1:8ab18a7: 
1:2227f26:     runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
1:2ce4177:     runBasicDirTest(dir.toCloseable(), desiredFile.length(), desiredFile.lastModified());
1:2ce4177:   }
1:8ab18a7: 
1:754e2c3:   /**
1:2227f26:    * Make sure we correctly understand the content of the application when the
1:2227f26:    * application is a zip. This test just checks that the
1:2227f26:    * root directory returns the expected information.
1:8ab18a7:    *
1:2227f26:    * @throws IOException
1:2227f26:    */
1:2227f26:   @Test(expected=UnsupportedOperationException.class)
1:2227f26:   public void basicRootDirTestsWithZip() throws IOException
1:2227f26:   {
1:2227f26:     File baseDir = new File("fileSystemTest/app2.zip");
1:2227f26:     IDirectory dir = FileSystem.getFSRoot(baseDir);
1:8ab18a7: 
1:2227f26:     runBasicRootDirTests(dir, baseDir.length(), baseDir.lastModified());
1:d04041b:   }
1:8ab18a7: 
1:754e2c3:   /**
1:754e2c3:    * Make sure we correctly understand the content of the application when the
1:754e2c3:    * application is a zip. This test just checks that the
1:754e2c3:    * root directory returns the expected information.
1:8ab18a7:    *
1:754e2c3:    * @throws IOException
1:754e2c3:    */
1:754e2c3:   @Test(expected=UnsupportedOperationException.class)
1:754e2c3:   public void basicRootDirTestsWithZipInputStream() throws IOException
1:754e2c3:   {
1:754e2c3:     File baseDir = new File("fileSystemTest/app2.zip");
1:754e2c3:     ICloseableDirectory dir = FileSystem.getFSRoot(new FileInputStream(baseDir));
1:8ab18a7: 
1:754e2c3:     try {
1:754e2c3:       runBasicRootDirTests(dir, baseDir.length(), baseDir.lastModified());
1:754e2c3:     } finally {
1:754e2c3:       dir.close();
1:754e2c3:     }
1:754e2c3:   }
1:8ab18a7: 
1:2ce4177:   @Test
1:f2492f7:   public void testInvalidFSRoot() throws IOException
1:f2492f7:   {
1:f2492f7: 	  File baseDir = new File(getTestResourceDir(), "/app1");
1:910fec0: 	  File manifest = new File(baseDir, "META-INF/APPLICATION.MF");
1:8ab18a7: 	  try {
1:8ab18a7: 	      IDirectory dir = FileSystem.getFSRoot(manifest);
1:8ab18a7: 	      fail("Should have thrown an IORuntimeException");
1:8ab18a7: 	  } catch (IORuntimeException e) {
1:8ab18a7: 	      // good!
1:8ab18a7: 	  }
1:f2492f7:   }
1:8ab18a7: 
1:2227f26:   /**
1:e62fca9:    * Make sure that operations work on zip files nested in file IDirectories
1:e62fca9:    * @throws IOException
1:e62fca9:    */
1:f2492f7:   @Test
1:e62fca9:   public void nestedZipInDirectory() throws IOException
1:e62fca9:   {
1:8ab18a7: 	IDirectory dir = FileSystem.getFSRoot(new File("").getAbsoluteFile());
1:8ab18a7: 
1:e62fca9: 	// base convert does not do nested zips
1:e62fca9: 	IDirectory zip = dir.getFile("fileSystemTest/app2.zip").convert();
1:e62fca9: 	assertNull(zip);
1:8ab18a7: 
1:e62fca9: 	// basic conversion works
1:e62fca9: 	zip = dir.getFile("fileSystemTest/app2.zip").convertNested();
1:e62fca9: 	assertNotNull(zip);
1:8ab18a7: 
1:e62fca9: 	// we get the parent and our path right
1:e62fca9: 	assertNotNull(zip.getParent());
1:e62fca9: 	assertEquals("fileSystemTest", zip.getParent().getName());
1:e62fca9: 	assertEquals("fileSystemTest/app2.zip", zip.getName());
1:8ab18a7: 
1:e62fca9: 	// files inside the nested zip have the correct path as well
1:e62fca9: 	IFile appMf = zip.getFile("META-INF/APPLICATION.MF");
1:e62fca9: 	assertNotNull(appMf);
1:e62fca9: 	assertEquals("fileSystemTest/app2.zip/META-INF/APPLICATION.MF", appMf.getName());
1:e62fca9: 	checkManifest(appMf.open());
1:754e2c3: 
1:e62fca9: 	// root is right
1:e62fca9: 	assertFalse(zip.isRoot());
1:e62fca9: 	assertEquals(dir, zip.getRoot());
1:8ab18a7: 	assertEquals(dir, appMf.getRoot());
1:8ab18a7: 
1:e62fca9: 	// check URLs are correct
1:e62fca9: 	checkManifest(appMf.toURL().openStream());
1:8ab18a7: 
1:7a2a976: 	runBasicDirTest(zip, "fileSystemTest/app2.zip/", appMf.getSize(), appMf.getLastModified());
1:e62fca9:   }
1:8ab18a7: 
1:e62fca9:   /**
1:754e2c3:    * Make sure that the operations work with zip files inside other zip files. Performance is not going to be great though :)
1:754e2c3:    */
1:754e2c3:   @Test
1:f2492f7:   public void nestedZipInZip() throws IOException
1:f2492f7:   {
1:f2492f7: 	  IDirectory outer = FileSystem.getFSRoot(new File("fileSystemTest/outer.zip"));
1:8ab18a7: 
1:f2492f7: 	  IFile innerFile = outer.getFile("app2.zip");
1:f2492f7: 	  assertNotNull(innerFile);
1:754e2c3: 
1:f2492f7: 	  IDirectory inner = innerFile.convertNested();
1:f2492f7: 	  assertNotNull(inner);
1:8ab18a7: 
1:8ab18a7: 	  File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
1:8ab18a7: 
1:2ce4177: 	  // no size information when stream reading :(
1:f2492f7: 	  runBasicDirTest(inner, "app2.zip/", -1, desiredFile.lastModified());
1:2ce4177: 	  runBasicDirTest(inner.toCloseable(), "app2.zip/", desiredFile.length(), desiredFile.lastModified());
1:f2492f7:   }
1:8ab18a7: 
1:f2492f7:   /**
1:f2492f7:    * Make sure that the operations work with zip files inside other zip files. Performance is not going to be great though :)
1:2227f26:    */
1:e62fca9:   @Test
1:754e2c3:   public void nestedZipInZipInputStream() throws Exception
1:754e2c3:   {
1:754e2c3:     ICloseableDirectory outer = FileSystem.getFSRoot(new FileInputStream("fileSystemTest/outer.zip"));
1:754e2c3:     try {
1:754e2c3:       IFile innerFile = outer.getFile("app2.zip");
1:754e2c3:       assertNotNull(innerFile);
1:8ab18a7: 
1:754e2c3:       IDirectory inner = innerFile.convertNested();
1:754e2c3:       assertNotNull(inner);
1:8ab18a7: 
1:8ab18a7:       File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
1:8ab18a7: 
1:754e2c3:       // no size information when stream reading :(
1:754e2c3:       runBasicDirTest(inner, "app2.zip/", -1, desiredFile.lastModified());
1:754e2c3:       runBasicDirTest(inner.toCloseable(), "app2.zip/", desiredFile.length(), desiredFile.lastModified());
1:754e2c3:     } finally {
1:754e2c3:       outer.close();
1:8ab18a7: 
1:754e2c3:       Field f = outer.getClass().getDeclaredField("tempFile");
1:8ab18a7: 
1:754e2c3:       f.setAccessible(true);
1:754e2c3:       assertFalse(((File)f.get(outer)).exists());
1:754e2c3:     }
1:754e2c3:   }
1:8ab18a7: 
1:754e2c3:   /**
1:754e2c3:    * Make sure we correctly understand the directory structure for zips.
1:8ab18a7:    *
1:754e2c3:    * @throws IOException
1:754e2c3:    */
1:754e2c3:   @Test
1:2227f26:   public void basicDirTestsWithZip() throws IOException
1:2227f26:   {
1:2227f26:     File baseDir = new File("fileSystemTest/app2.zip");
1:2227f26:     IDirectory dir = FileSystem.getFSRoot(baseDir);
1:8ab18a7: 
1:e62fca9:     assertTrue(dir.toString(), dir.toString().endsWith("app2.zip"));
1:8ab18a7: 
1:754e2c3:     File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
1:8ab18a7: 
1:2227f26:     runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
1:2ce4177:     runBasicDirTest(dir.toCloseable(), desiredFile.length(), desiredFile.lastModified());
1:d04041b:   }
1:8ab18a7: 
1:2227f26:   /**
1:2227f26:    * Make sure we correctly understand the directory structure for zips.
1:8ab18a7:    *
1:2227f26:    * @throws IOException
1:2227f26:    */
1:2227f26:   @Test
1:754e2c3:   public void basicDirTestsWithZipInputStream() throws IOException
1:754e2c3:   {
1:754e2c3:     File baseDir = new File("fileSystemTest/app2.zip");
1:754e2c3:     ICloseableDirectory dir = FileSystem.getFSRoot(new FileInputStream(baseDir));
1:754e2c3: 
1:754e2c3:     try {
1:754e2c3:       File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
1:754e2c3: 
1:754e2c3:       runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
1:754e2c3:       runBasicDirTest(dir.toCloseable(), desiredFile.length(), desiredFile.lastModified());
1:754e2c3:     } finally {
1:754e2c3:       dir.close();
1:754e2c3:     }
1:754e2c3:   }
1:754e2c3: 
1:2227f26:   @Test
1:2ce4177:   public void zipCloseableZipSimplePerformanceTest() throws IOException
1:2ce4177:   {
1:2ce4177: 	  int N = 100000;
1:2ce4177: 	  File baseDir = new File("fileSystemTest/app2.zip");
1:754e2c3: 
1:8ab18a7: 	  ZipFile zip = new ZipFile(baseDir);
1:8ab18a7: 
1:2ce4177: 	  long start = System.currentTimeMillis();
1:2ce4177: 	  for (int i=0; i<N; i++) {
1:910fec0: 		  ZipEntry ze = zip.getEntry("META-INF/APPLICATION.MF");
1:2ce4177: 		  InputStream is = zip.getInputStream(ze);
1:2ce4177: 		  is.close();
1:2ce4177: 	  }
1:2ce4177: 	  long duration = System.currentTimeMillis() - start;
1:8ab18a7: 
1:754e2c3: 
1:8ab18a7: 	  // normal zip files
1:8ab18a7: 
1:2ce4177: 	  ICloseableDirectory dir = FileSystem.getFSRoot(baseDir).toCloseable();
1:754e2c3: 
1:2ce4177: 	  start = System.currentTimeMillis();
1:2ce4177: 	  for (int i=0; i<N; i++) {
1:910fec0: 		  IFile appMf = dir.getFile("META-INF/APPLICATION.MF");
1:2ce4177: 		  InputStream is = appMf.open();
1:2ce4177: 		  is.close();
1:2ce4177: 	  }
1:2ce4177: 	  long duration2 = System.currentTimeMillis() - start;
1:8ab18a7: 
1:2ce4177: 	  dir.close();
1:2ce4177: 	  // within an order of magnitude
1:2ce4177: 	  assertTrue("ZipFile: "+duration+", IDirectory: "+duration2 , duration2 < 10*duration );
1:8ab18a7: 
1:8ab18a7: 
1:2ce4177: 	  // nested zip files
1:8ab18a7: 
1:2ce4177: 	  IDirectory outer = FileSystem.getFSRoot(new File("fileSystemTest/outer.zip"));
1:2ce4177: 	  IFile innerFile = outer.getFile("app2.zip");
1:2ce4177: 	  dir = innerFile.convertNested().toCloseable();
1:8ab18a7: 
1:2ce4177: 	  start = System.currentTimeMillis();
1:2ce4177: 	  for (int i=0; i<N; i++) {
1:910fec0: 		  IFile appMf = dir.getFile("META-INF/APPLICATION.MF");
1:2ce4177: 		  InputStream is = appMf.open();
1:2ce4177: 		  is.close();
1:2ce4177: 	  }
1:2ce4177: 	  long duration3 = System.currentTimeMillis() - start;
1:8ab18a7: 
1:2ce4177: 	  dir.close();
1:2ce4177: 	  // within an order of magnitude
1:2ce4177: 	  assertTrue("ZipFile: "+duration+", IDirectory: "+duration3 , duration3 < 10*duration );
1:8ab18a7: 
1:2227f26:   }
1:8ab18a7: 
1:2227f26:   /**
1:2227f26:    * Zip up the app1 directory to create a zippped version before running any
1:2227f26:    * tests.
1:8ab18a7:    *
1:2227f26:    * @throws IOException
1:2227f26:    */
1:2227f26:   @BeforeClass
1:2227f26:   public static void makeZip() throws IOException
1:2227f26:   {
1:2227f26:     File zipFile = new File("fileSystemTest/app2.zip");
1:2227f26:     zipFile.getParentFile().mkdirs();
1:2227f26:     ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));
1:754e2c3: 
1:8ab18a7:     int index = new File(getTestResourceDir(), "/app1").getAbsolutePath().length();
1:e62fca9:     writeEnties(out, new File(getTestResourceDir(), "/app1"), index);
1:2ce4177: 
1:2227f26:     out.close();
1:8ab18a7: 
1:f2492f7:     zipFile = new File("outer.zip");
1:f2492f7:     out = new ZipOutputStream(new FileOutputStream(zipFile));
1:8ab18a7:     index = new File("fileSystemTest").getAbsolutePath().length();
1:f2492f7:     writeEnties(out, new File("fileSystemTest"), index);
1:8ab18a7: 
1:f2492f7:     out.close();
1:2ce4177: 
1:f2492f7:     if (!!!zipFile.renameTo(new File("fileSystemTest/outer.zip"))) throw new IOException("Rename failed");
1:2227f26:   }
1:8ab18a7: 
1:e62fca9:   private static File getTestResourceDir() {
1:e62fca9: 	  File root = new File("").getAbsoluteFile();
1:8ab18a7: 
1:e62fca9: 	  if (root.getName().equals("target")) return new File("../src/test/resources");
1:e62fca9: 	  else return new File("src/test/resources");
1:e62fca9:   }
1:8ab18a7: 
1:2227f26:   /**
1:2227f26:    * Make sure the test zip is deleted afterwards.
1:2227f26:    */
1:2227f26:   @AfterClass
1:2227f26:   public static void destroyZip()
1:2227f26:   {
1:f2492f7: 	  IOUtils.deleteRecursive(new File("fileSystemTest"));
1:2227f26:   }
1:8ab18a7: 
1:2227f26:   /**
1:2227f26:    * This method writes the given directory into the provided zip output stream.
1:2227f26:    * It removes the first <code>index</code> bytes from the absolute path name
1:2227f26:    * when building the zip.
1:8ab18a7:    *
1:2227f26:    * @param zos   the zip output stream to use
1:2227f26:    * @param f     the directory to write into the zip.
1:2227f26:    * @param index how much of the file name to chop off.
1:2227f26:    * @throws IOException
1:2227f26:    */
1:2227f26:   public static void writeEnties(ZipOutputStream zos, File f, int index) throws IOException {
1:2227f26:     File[] files = f.listFiles();
1:8ab18a7: 
1:2227f26:     if (files != null) {
1:2227f26:       for (File file : files) {
1:2227f26:         String fileName = file.getAbsolutePath().substring(index + 1);
1:8ab18a7: 
1:2227f26:      // Bug 1954: replace any '\' characters with '/' - required by ZipEntry
1:2227f26:         fileName = fileName.replace('\\', '/');
1:8ab18a7: 
1:2227f26:         if (file.isDirectory()) fileName = fileName + "/";
1:8ab18a7: 
1:2227f26:         ZipEntry ze = new ZipEntry(fileName);
1:2227f26:         ze.setSize(file.length());
1:2227f26:         ze.setTime(file.lastModified());
1:2227f26:         zos.putNextEntry(ze);
1:8ab18a7: 
1:2227f26:         if (file.isFile()) {
1:2227f26:           InputStream is = new FileInputStream(file);
1:2227f26:           byte[] buffer = new byte[(int)file.length()];
1:2227f26:           int len = is.read(buffer);
1:2227f26:           zos.write(buffer, 0, len);
1:2227f26:           is.close();   // Bug 1594
1:2227f26:         }
1:2ce4177: 
1:2227f26:         zos.closeEntry();
1:8ab18a7: 
1:2227f26:         if (file.isDirectory()) {
1:2227f26:           writeEnties(zos, file, index);
1:2227f26:         }
1:2227f26:       }
1:2227f26:     }
1:2227f26:   }
1:8ab18a7: 
1:2227f26:   /**
1:2227f26:    * This method makes sure that the data is correctly understood from disk. It
1:2227f26:    * is called for both the file and zip versions of the test to ensure we have
1:2227f26:    * consistent results.
1:8ab18a7:    *
1:2227f26:    * @param dir   The IDirectory for the root of the vFS.
1:2227f26:    * @param len   The size of the file.
1:2227f26:    * @param time  The time the file was last updated.
1:2227f26:    * @throws IOException
1:2227f26:    */
1:2227f26:   public void runBasicRootDirTests(IDirectory dir, long len, long time) throws IOException
1:2227f26:   {
1:2227f26:     assertEquals("The root file system name is not correct", "", dir.getName());
1:2227f26:     assertEquals("The size of the file is not correct", len, dir.getSize());
1:8ab18a7: 
1:5959a0a:     // This assertion just isn't working on Hudson as of build #79
1:5959a0a:     // assertEquals("The last modified time of the file is not correct", time, dir.getLastModified());
1:8ab18a7: 
1:2227f26:     assertNull("I managed to get a parent of a root", dir.getParent());
1:2227f26:     assertTrue("The root dir does not know it is a dir", dir.isDirectory());
1:2227f26:     assertFalse("The root dir has an identity crisis and thinks it is a file", dir.isFile());
1:2ce4177: 
1:2227f26:     dir.open();
1:2227f26:   }
1:8ab18a7: 
1:7a2a976:   private void runBasicDirTest(IDirectory dir, long len, long time) throws IOException
1:7a2a976:   {
1:7a2a976: 	  runBasicDirTest(dir, "", len, time);
1:7a2a976:   }
1:8ab18a7: 
1:2227f26:   /**
1:2227f26:    * This method makes sure that the data is correctly understood from disk. It
1:2227f26:    * is called for both the file and zip versions of the test to ensure we have
1:2227f26:    * consistent results.
1:8ab18a7:    *
1:2227f26:    * @param dir   The IDirectory for the root of the vFS.
1:2227f26:    * @param len   The size of the file.
1:2227f26:    * @param time  The time the file was last updated.
1:2227f26:    * @throws IOException
1:2227f26:    */
1:7a2a976:   private void runBasicDirTest(IDirectory dir, String namePrefix, long len, long time) throws IOException
1:2227f26:   {
1:2227f26:     assertNull("for some reason our fake app has a fake blueprint file.", dir.getFile("OSGI-INF/blueprint/aries.xml"));
1:8ab18a7: 
1:910fec0:     IFile file = dir.getFile("META-INF/APPLICATION.MF");
1:8ab18a7: 
1:2227f26:     assertNotNull("we could not find the application manifest", file);
1:8ab18a7: 
1:f2492f7:     assertNull(file.convert());
1:f2492f7:     assertNull(file.convertNested());
1:8ab18a7: 
1:910fec0:     assertEquals(namePrefix+"META-INF/APPLICATION.MF", file.getName().replace('\\', '/'));
1:2227f26:     assertTrue("The last update time is not within 2 seconds of the expected value. Expected: " + time + " Actual: " + file.getLastModified(), Math.abs(time - file.getLastModified()) < 2000);
1:2ce4177: 
1:2227f26:     assertEquals(len, file.getSize());
1:7a2a976:     assertEquals(namePrefix+"META-INF", file.getParent().getName());
1:2227f26:     assertFalse(file.isDirectory());
1:2227f26:     assertTrue(file.isFile());
1:8ab18a7: 
1:2227f26:     List<IFile> files = dir.listFiles();
1:e62fca9:     filterOutSvn(files);
1:2227f26:     assertEquals(1, files.size());
1:2ce4177: 
1:d04041b:     List<IFile> allFiles = dir.listAllFiles();
1:8ab18a7:     filterOutSvn(allFiles);
1:d04041b:     assertEquals(3, allFiles.size());
1:8ab18a7: 
1:7a2a976:     assertEquals(namePrefix+"META-INF", allFiles.get(1).getParent().getName());
1:8ab18a7: 
1:2227f26:     IFile metaInf = files.get(0);
1:8ab18a7: 
1:2227f26:     assertTrue(metaInf.isDirectory());
1:7a2a976:     assertEquals(namePrefix+"META-INF", metaInf.getName());
1:2227f26:     assertNotNull(metaInf.convert());
1:8ab18a7: 
1:e62fca9:     files = metaInf.convert().listAllFiles();
1:e62fca9:     filterOutSvn(files);
1:8ab18a7:     assertEquals(2, files.size());
1:8ab18a7: 
1:2227f26:     for (IFile aFile : dir) {
1:8ab18a7:       if (!aFile.getName().contains(".svn")) {
1:e4ac3a5:         assertTrue(aFile.isDirectory());
1:7a2a976:         assertEquals(namePrefix+"META-INF", aFile.getName());
1:e4ac3a5:         assertNotNull(aFile.convert());
1:e4ac3a5:       }
1:e4ac3a5:     }
1:2ce4177: 
1:e62fca9:     checkManifest(file.open());
1:8ab18a7: 
1:910fec0:     IFile applicationMF2 = dir.getFile("META-INF/APPLICATION.MF");
1:8ab18a7: 
1:2227f26:     Assert.assertEqualsContract(file, applicationMF2, dir);
1:2227f26:     Assert.assertHashCodeEquals(file, applicationMF2, true);
1:e4ac3a5:   }
1:8ab18a7: 
1:e62fca9:   private void filterOutSvn(Collection<IFile> files) {
1:e62fca9: 	  Iterator<IFile> its = files.iterator();
1:e62fca9: 	  while (its.hasNext()) {
1:e62fca9: 		  IFile f = its.next();
1:e62fca9: 		  if (f.getName().toLowerCase().contains(".svn")) its.remove();
1:e62fca9: 	  }
1:e62fca9:   }
1:8ab18a7: 
1:e62fca9:   private void checkManifest(InputStream is) throws IOException {
1:e62fca9: 	  Manifest man = new Manifest(is);
1:e62fca9: 	  //remember to close the input stream after use
1:e62fca9: 	  is.close();
1:8ab18a7: 	  assertEquals("com.travel.reservation", man.getMainAttributes().getValue("Application-SymbolicName"));
1:e62fca9:   }
1:2227f26: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:8ab18a7
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.fail;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.IORuntimeException;
/////////////////////////////////////////////////////////////////////////
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	  try {
1: 	      IDirectory dir = FileSystem.getFSRoot(manifest);
1: 	      fail("Should have thrown an IORuntimeException");
1: 	  } catch (IORuntimeException e) {
1: 	      // good!
1: 	  }
1: 
/////////////////////////////////////////////////////////////////////////
1: 	IDirectory dir = FileSystem.getFSRoot(new File("").getAbsoluteFile());
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 	assertEquals(dir, appMf.getRoot());
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	  File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:       File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
1: 
1: 
1: 
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	  ZipFile zip = new ZipFile(baseDir);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 	  // normal zip files
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1:     int index = new File(getTestResourceDir(), "/app1").getAbsolutePath().length();
1: 
1:     index = new File("fileSystemTest").getAbsolutePath().length();
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     filterOutSvn(allFiles);
1: 
1: 
1: 
1: 
1:     assertEquals(2, files.size());
1: 
1:       if (!aFile.getName().contains(".svn")) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 	  assertEquals("com.travel.reservation", man.getMainAttributes().getValue("Application-SymbolicName"));
author:David Jencks
-------------------------------------------------------------------------------
commit:6df3ad3
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:754e2c3
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Field;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Make sure we correctly understand the content of the application when the
1:    * application is a zip. This test just checks that the
1:    * root directory returns the expected information.
1:    * 
1:    * @throws IOException
1:    */
1:   @Test(expected=UnsupportedOperationException.class)
1:   public void basicRootDirTestsWithZipInputStream() throws IOException
1:   {
1:     File baseDir = new File("fileSystemTest/app2.zip");
1:     ICloseableDirectory dir = FileSystem.getFSRoot(new FileInputStream(baseDir));
1:     
1:     try {
1:       runBasicRootDirTests(dir, baseDir.length(), baseDir.lastModified());
1:     } finally {
1:       dir.close();
1:     }
1:   }
1:   
/////////////////////////////////////////////////////////////////////////
1:    * Make sure that the operations work with zip files inside other zip files. Performance is not going to be great though :)
1:    */
1:   @Test
1:   public void nestedZipInZipInputStream() throws Exception
1:   {
1:     ICloseableDirectory outer = FileSystem.getFSRoot(new FileInputStream("fileSystemTest/outer.zip"));
1:     try {
1:       IFile innerFile = outer.getFile("app2.zip");
1:       assertNotNull(innerFile);
1: 
1:       IDirectory inner = innerFile.convertNested();
1:       assertNotNull(inner);
1:       
1:       File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");  
1:       
1:       // no size information when stream reading :(
1:       runBasicDirTest(inner, "app2.zip/", -1, desiredFile.lastModified());
1:       runBasicDirTest(inner.toCloseable(), "app2.zip/", desiredFile.length(), desiredFile.lastModified());
1:     } finally {
1:       outer.close();
1:       
1:       Field f = outer.getClass().getDeclaredField("tempFile");
1:       
1:       f.setAccessible(true);
1:       assertFalse(((File)f.get(outer)).exists());
1:     }
1:   }
1:   
1:   /**
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Make sure we correctly understand the directory structure for zips.
1:    * 
1:    * @throws IOException
1:    */
1:   @Test
1:   public void basicDirTestsWithZipInputStream() throws IOException
1:   {
1:     File baseDir = new File("fileSystemTest/app2.zip");
1:     ICloseableDirectory dir = FileSystem.getFSRoot(new FileInputStream(baseDir));
1: 
1:     try {
1:       File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
1:     
1:       runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
1:       runBasicDirTest(dir.toCloseable(), desiredFile.length(), desiredFile.lastModified());
1:     } finally {
1:       dir.close();
1:     }
1:   }
1:   
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:c6cb34d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.io.IOUtils;
commit:910fec0
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.util.filesystem;
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.aries.util.filesystem.FileSystem;
0: import org.apache.aries.util.filesystem.ICloseableDirectory;
0: import org.apache.aries.util.filesystem.IDirectory;
0: import org.apache.aries.util.filesystem.IFile;
0: import org.apache.aries.util.filesystem.IOUtils;
/////////////////////////////////////////////////////////////////////////
1:     File manifest = new File(baseDir, "META-INF/APPLICATION.MF");
/////////////////////////////////////////////////////////////////////////
1:     File desiredFile = new File(baseDir, "META-INF/APPLICATION.MF");
/////////////////////////////////////////////////////////////////////////
1: 	  File manifest = new File(baseDir, "META-INF/APPLICATION.MF");
/////////////////////////////////////////////////////////////////////////
0: 	  File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");  
/////////////////////////////////////////////////////////////////////////
0:     File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
/////////////////////////////////////////////////////////////////////////
1: 		  ZipEntry ze = zip.getEntry("META-INF/APPLICATION.MF");
/////////////////////////////////////////////////////////////////////////
1: 		  IFile appMf = dir.getFile("META-INF/APPLICATION.MF");
/////////////////////////////////////////////////////////////////////////
1: 		  IFile appMf = dir.getFile("META-INF/APPLICATION.MF");
/////////////////////////////////////////////////////////////////////////
1:     IFile file = dir.getFile("META-INF/APPLICATION.MF");
1:     assertEquals(namePrefix+"META-INF/APPLICATION.MF", file.getName().replace('\\', '/'));
/////////////////////////////////////////////////////////////////////////
1:     IFile applicationMF2 = dir.getFile("META-INF/APPLICATION.MF");
commit:2ce4177
/////////////////////////////////////////////////////////////////////////
1: import java.util.zip.ZipFile;
0: import org.apache.aries.application.filesystem.ICloseableDirectory;
/////////////////////////////////////////////////////////////////////////
1:     runBasicDirTest(dir.toCloseable(), desiredFile.length(), desiredFile.lastModified());
/////////////////////////////////////////////////////////////////////////
1: 	  
1: 	  // no size information when stream reading :(
1: 	  runBasicDirTest(inner.toCloseable(), "app2.zip/", desiredFile.length(), desiredFile.lastModified());
/////////////////////////////////////////////////////////////////////////
1:     runBasicDirTest(dir.toCloseable(), desiredFile.length(), desiredFile.lastModified());
1:   }
1:   
1:   @Test
1:   public void zipCloseableZipSimplePerformanceTest() throws IOException
1:   {
1: 	  int N = 100000;
1: 	  File baseDir = new File("fileSystemTest/app2.zip");
1: 
0: 	  ZipFile zip = new ZipFile(baseDir);	  
1: 	  
1: 	  long start = System.currentTimeMillis();
1: 	  for (int i=0; i<N; i++) {
0: 		  ZipEntry ze = zip.getEntry(AppConstants.APPLICATION_MF);
1: 		  InputStream is = zip.getInputStream(ze);
1: 		  is.close();
1: 	  }
1: 	  long duration = System.currentTimeMillis() - start;
1: 
1: 	  
0: 	  // normal zip files 
1: 	  
1: 	  ICloseableDirectory dir = FileSystem.getFSRoot(baseDir).toCloseable();
1: 
1: 	  start = System.currentTimeMillis();
1: 	  for (int i=0; i<N; i++) {
0: 		  IFile appMf = dir.getFile(AppConstants.APPLICATION_MF);
1: 		  InputStream is = appMf.open();
1: 		  is.close();
1: 	  }
1: 	  long duration2 = System.currentTimeMillis() - start;
1: 	  
1: 	  dir.close();
1: 	  // within an order of magnitude
1: 	  assertTrue("ZipFile: "+duration+", IDirectory: "+duration2 , duration2 < 10*duration );
1: 	  
1: 	  
1: 	  // nested zip files
1: 	  
1: 	  IDirectory outer = FileSystem.getFSRoot(new File("fileSystemTest/outer.zip"));
1: 	  IFile innerFile = outer.getFile("app2.zip");
1: 	  dir = innerFile.convertNested().toCloseable();
1: 	  
1: 	  start = System.currentTimeMillis();
1: 	  for (int i=0; i<N; i++) {
0: 		  IFile appMf = dir.getFile(AppConstants.APPLICATION_MF);
1: 		  InputStream is = appMf.open();
1: 		  is.close();
1: 	  }
1: 	  long duration3 = System.currentTimeMillis() - start;
1: 	  
1: 	  dir.close();
1: 	  // within an order of magnitude
1: 	  assertTrue("ZipFile: "+duration+", IDirectory: "+duration3 , duration3 < 10*duration );
1: 	  
commit:f2492f7
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testInvalidFSRoot() throws IOException
1:   {
1: 	  File baseDir = new File(getTestResourceDir(), "/app1");
0: 	  File manifest = new File(baseDir, AppConstants.APPLICATION_MF);
0: 	  IDirectory dir = FileSystem.getFSRoot(manifest);
0: 	  
0: 	  assertNull(dir);
1:   }
0:   
/////////////////////////////////////////////////////////////////////////
1:    * Make sure that the operations work with zip files inside other zip files. Performance is not going to be great though :)
1:    */
1:   @Test
1:   public void nestedZipInZip() throws IOException
1:   {
1: 	  IDirectory outer = FileSystem.getFSRoot(new File("fileSystemTest/outer.zip"));
0: 	  
1: 	  IFile innerFile = outer.getFile("app2.zip");
1: 	  assertNotNull(innerFile);
0: 
1: 	  IDirectory inner = innerFile.convertNested();
1: 	  assertNotNull(inner);
0: 	  
0: 	  File desiredFile = new File(new File(getTestResourceDir(), "/app1"), AppConstants.APPLICATION_MF);  
1: 	  runBasicDirTest(inner, "app2.zip/", -1, desiredFile.lastModified());
1:   }
0:   
1:   /**
/////////////////////////////////////////////////////////////////////////
0:     int index = new File(getTestResourceDir(), "/app1").getAbsolutePath().length();    
0: 
0:     
1:     zipFile = new File("outer.zip");
1:     out = new ZipOutputStream(new FileOutputStream(zipFile));
0:     index = new File("fileSystemTest").getAbsolutePath().length();    
1:     writeEnties(out, new File("fileSystemTest"), index);
0: 
1:     out.close();
0:     
1:     if (!!!zipFile.renameTo(new File("fileSystemTest/outer.zip"))) throw new IOException("Rename failed");
/////////////////////////////////////////////////////////////////////////
1: 	  IOUtils.deleteRecursive(new File("fileSystemTest"));
/////////////////////////////////////////////////////////////////////////
1:     assertNull(file.convert());
1:     assertNull(file.convertNested());
0:     
/////////////////////////////////////////////////////////////////////////
0:         
commit:7a2a976
/////////////////////////////////////////////////////////////////////////
0: 	
1: 	runBasicDirTest(zip, "fileSystemTest/app2.zip/", appMf.getSize(), appMf.getLastModified());
/////////////////////////////////////////////////////////////////////////
1:   private void runBasicDirTest(IDirectory dir, long len, long time) throws IOException
1:   {
1: 	  runBasicDirTest(dir, "", len, time);
1:   }
0:   
/////////////////////////////////////////////////////////////////////////
1:   private void runBasicDirTest(IDirectory dir, String namePrefix, long len, long time) throws IOException
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(namePrefix+AppConstants.APPLICATION_MF, file.getName().replace('\\', '/'));
1:     assertEquals(namePrefix+"META-INF", file.getParent().getName());
/////////////////////////////////////////////////////////////////////////
1:     assertEquals(namePrefix+"META-INF", allFiles.get(1).getParent().getName());
1:     assertEquals(namePrefix+"META-INF", metaInf.getName());
/////////////////////////////////////////////////////////////////////////
0:       if (!aFile.getName().contains(".svn")) { 
1:         assertEquals(namePrefix+"META-INF", aFile.getName());
commit:e62fca9
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1:     File baseDir = new File(getTestResourceDir(), "/app1");
/////////////////////////////////////////////////////////////////////////
1:     File baseDir = new File(getTestResourceDir(), "/app1");
/////////////////////////////////////////////////////////////////////////
1:    * Make sure that operations work on zip files nested in file IDirectories
1:    * @throws IOException
1:    */
1:   @Test
1:   public void nestedZipInDirectory() throws IOException
1:   {
0: 	IDirectory dir = FileSystem.getFSRoot(new File("").getAbsoluteFile());  
0: 	
1: 	// base convert does not do nested zips
1: 	IDirectory zip = dir.getFile("fileSystemTest/app2.zip").convert();
1: 	assertNull(zip);
0: 	
1: 	// basic conversion works
1: 	zip = dir.getFile("fileSystemTest/app2.zip").convertNested();
1: 	assertNotNull(zip);
0: 	
1: 	// we get the parent and our path right
1: 	assertNotNull(zip.getParent());
1: 	assertEquals("fileSystemTest", zip.getParent().getName());
1: 	assertEquals("fileSystemTest/app2.zip", zip.getName());
0: 	
1: 	// files inside the nested zip have the correct path as well
1: 	IFile appMf = zip.getFile("META-INF/APPLICATION.MF");
1: 	assertNotNull(appMf);
1: 	assertEquals("fileSystemTest/app2.zip/META-INF/APPLICATION.MF", appMf.getName());
1: 	checkManifest(appMf.open());
0: 
1: 	// root is right
1: 	assertFalse(zip.isRoot());
1: 	assertEquals(dir, zip.getRoot());
0: 	assertEquals(dir, appMf.getRoot());	
0: 	
1: 	// check URLs are correct
1: 	checkManifest(appMf.toURL().openStream());
1:   }
0:   
1:   /**
/////////////////////////////////////////////////////////////////////////
1:     assertTrue(dir.toString(), dir.toString().endsWith("app2.zip"));
0:     
0:     File desiredFile = new File(new File(getTestResourceDir(), "/app1"), AppConstants.APPLICATION_MF);
/////////////////////////////////////////////////////////////////////////
0: 
0:     int index = new File(getTestResourceDir(), "/app1").getAbsolutePath().length();
1:     writeEnties(out, new File(getTestResourceDir(), "/app1"), index);
1:   private static File getTestResourceDir() {
1: 	  File root = new File("").getAbsoluteFile();
0: 	  
1: 	  if (root.getName().equals("target")) return new File("../src/test/resources");
1: 	  else return new File("src/test/resources");
1:   }
0:   
/////////////////////////////////////////////////////////////////////////
0: 
1:     filterOutSvn(files);
0: 
0:     filterOutSvn(allFiles);    
0:     
0:     assertEquals("META-INF", allFiles.get(1).getParent().getName());
0:     
1:     files = metaInf.convert().listAllFiles();
1:     filterOutSvn(files);
0:     assertEquals(2, files.size());    
0:     
/////////////////////////////////////////////////////////////////////////
0: 
1:     checkManifest(file.open());
0:   
1:   private void filterOutSvn(Collection<IFile> files) {
1: 	  Iterator<IFile> its = files.iterator();
1: 	  while (its.hasNext()) {
1: 		  IFile f = its.next();
1: 		  if (f.getName().toLowerCase().contains(".svn")) its.remove();
1: 	  }
1:   }
0:   
1:   private void checkManifest(InputStream is) throws IOException {
1: 	  Manifest man = new Manifest(is);
1: 	  //remember to close the input stream after use
1: 	  is.close();
0: 	  assertEquals("com.travel.reservation", man.getMainAttributes().getValue("Application-SymbolicName"));	  
1:   }
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:d04041b
/////////////////////////////////////////////////////////////////////////
0: 	  IOUtils.deleteRecursive(new File("fileSystemTest/"));
/////////////////////////////////////////////////////////////////////////
1:     List<IFile> allFiles = dir.listAllFiles();
0:     Iterator<IFile> its = allFiles.iterator();
0:     while (its.hasNext()) { 
0:       IFile f = its.next();
0:       if (f.getName().toLowerCase().contains(".svn")) { 
0:         its.remove();
1:       }
1:     }
1:     assertEquals(3, allFiles.size());
commit:5959a0a
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0:     
1:     // This assertion just isn't working on Hudson as of build #79
1:     // assertEquals("The last modified time of the file is not correct", time, dir.getLastModified());
0:     
/////////////////////////////////////////////////////////////////////////
0:     Iterator<IFile> it = files.iterator();
0:     while (it.hasNext()) { 
0:       IFile f = it.next();
0:         it.remove();
commit:e4ac3a5
/////////////////////////////////////////////////////////////////////////
1: import org.junit.AfterClass;
/////////////////////////////////////////////////////////////////////////
0:     for (IFile f: files) { 
0:       if (f.getName().equalsIgnoreCase(".svn")) { 
0:         files.remove(f);
1:       }
1:     }
/////////////////////////////////////////////////////////////////////////
0:       if (!aFile.getName().equalsIgnoreCase(".svn")) { 
1:         assertTrue(aFile.isDirectory());
0:         assertEquals("META-INF", aFile.getName());
1:         assertNotNull(aFile.convert());
1:       }
commit:2227f26
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: 
0: package org.apache.aries.application.utils.filesystem;
0: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
0: 
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.util.List;
1: import java.util.jar.Manifest;
1: import java.util.zip.ZipEntry;
1: import java.util.zip.ZipOutputStream;
0: 
0: import org.apache.aries.application.filesystem.IDirectory;
0: import org.apache.aries.application.filesystem.IFile;
0: import org.apache.aries.application.utils.AppConstants;
0: import org.junit.AfterClass;
1: import org.apache.aries.unittest.junit.Assert;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
0: 
0: 
1: /**
1:  * This class contains tests for the virtual file system.
1:  */
1: public class FileSystemTest
1: {
1:   /**
1:    * Make sure we correctly understand the content of the application when the
1:    * application is an exploded directory. This test just checks that the
1:    * root directory returns the expected information.
0:    * 
1:    * @throws IOException
1:    */
1:   @Test(expected=UnsupportedOperationException.class)
1:   public void basicRootDirTestsWithFiles() throws IOException
1:   {
0:     File baseDir = new File("../src/test/resources/app1");
0:     File manifest = new File(baseDir, AppConstants.APPLICATION_MF);
1:     IDirectory dir = FileSystem.getFSRoot(baseDir);
0:     
1:     runBasicRootDirTests(dir, baseDir.length(), manifest.lastModified());
1:   }
0:   
1:   /**
1:    * Make sure we correctly understand the directory structure for exploded
1:    * directories.
0:    * 
1:    * @throws IOException
1:    */
1:   @Test
1:   public void basicDirTestsWithFiles() throws IOException
1:   {
0:     File baseDir = new File("../src/test/resources/app1");
1:     IDirectory dir = FileSystem.getFSRoot(baseDir);
0: 
0:     File desiredFile = new File(baseDir, AppConstants.APPLICATION_MF);
0:     
1:     runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
1:   }
0:   
1:   /**
1:    * Make sure we correctly understand the content of the application when the
1:    * application is a zip. This test just checks that the
1:    * root directory returns the expected information.
0:    * 
1:    * @throws IOException
1:    */
1:   @Test(expected=UnsupportedOperationException.class)
1:   public void basicRootDirTestsWithZip() throws IOException
1:   {
1:     File baseDir = new File("fileSystemTest/app2.zip");
1:     IDirectory dir = FileSystem.getFSRoot(baseDir);
0:     
1:     runBasicRootDirTests(dir, baseDir.length(), baseDir.lastModified());
1:   }
0:   
1:   /**
1:    * Make sure we correctly understand the directory structure for zips.
0:    * 
1:    * @throws IOException
1:    */
1:   @Test
1:   public void basicDirTestsWithZip() throws IOException
1:   {
1:     File baseDir = new File("fileSystemTest/app2.zip");
1:     IDirectory dir = FileSystem.getFSRoot(baseDir);
0: 
0:     File desiredFile = new File(new File("../src/test/resources/app1"), AppConstants.APPLICATION_MF);
0:     
1:     runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
1:   }
0:   
1:   /**
1:    * Zip up the app1 directory to create a zippped version before running any
1:    * tests.
0:    * 
1:    * @throws IOException
1:    */
1:   @BeforeClass
1:   public static void makeZip() throws IOException
1:   {
1:     File zipFile = new File("fileSystemTest/app2.zip");
1:     zipFile.getParentFile().mkdirs();
1:     ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));
0:     
0:     int index = new File("../src/test/resources/app1").getAbsolutePath().length();
0:     
0:     writeEnties(out, new File("../src/test/resources/app1"), index);
0:     
1:     out.close();
1:   }
0:   
1:   /**
1:    * Make sure the test zip is deleted afterwards.
1:    */
1:   @AfterClass
1:   public static void destroyZip()
1:   {
0:     new File("fileSystemTest/app2.zip").delete();
0:     new File("fileSystemTest").delete();
1:   }
0:   
1:   /**
1:    * This method writes the given directory into the provided zip output stream.
1:    * It removes the first <code>index</code> bytes from the absolute path name
1:    * when building the zip.
0:    * 
1:    * @param zos   the zip output stream to use
1:    * @param f     the directory to write into the zip.
1:    * @param index how much of the file name to chop off.
1:    * @throws IOException
1:    */
1:   public static void writeEnties(ZipOutputStream zos, File f, int index) throws IOException {
1:     File[] files = f.listFiles();
0:     
1:     if (files != null) {
1:       for (File file : files) {
1:         String fileName = file.getAbsolutePath().substring(index + 1);
0:         
1:      // Bug 1954: replace any '\' characters with '/' - required by ZipEntry
1:         fileName = fileName.replace('\\', '/');
0:         
1:         if (file.isDirectory()) fileName = fileName + "/";
0:         
1:         ZipEntry ze = new ZipEntry(fileName);
1:         ze.setSize(file.length());
1:         ze.setTime(file.lastModified());
1:         zos.putNextEntry(ze);
0:         
1:         if (file.isFile()) {
1:           InputStream is = new FileInputStream(file);
1:           byte[] buffer = new byte[(int)file.length()];
1:           int len = is.read(buffer);
1:           zos.write(buffer, 0, len);
1:           is.close();   // Bug 1594
1:         }
0: 
1:         zos.closeEntry();
0:         
1:         if (file.isDirectory()) {
1:           writeEnties(zos, file, index);
1:         }
1:       }
1:     }
1:   }
0:   
1:   /**
1:    * This method makes sure that the data is correctly understood from disk. It
1:    * is called for both the file and zip versions of the test to ensure we have
1:    * consistent results.
0:    * 
1:    * @param dir   The IDirectory for the root of the vFS.
1:    * @param len   The size of the file.
1:    * @param time  The time the file was last updated.
1:    * @throws IOException
1:    */
1:   public void runBasicRootDirTests(IDirectory dir, long len, long time) throws IOException
1:   {
1:     assertEquals("The root file system name is not correct", "", dir.getName());
1:     assertEquals("The size of the file is not correct", len, dir.getSize());
0:     assertEquals("The last modified time of the file is not correct", time, dir.getLastModified());
1:     assertNull("I managed to get a parent of a root", dir.getParent());
1:     assertTrue("The root dir does not know it is a dir", dir.isDirectory());
1:     assertFalse("The root dir has an identity crisis and thinks it is a file", dir.isFile());
0: 
1:     dir.open();
1:   }
0:   
1:   /**
1:    * This method makes sure that the data is correctly understood from disk. It
1:    * is called for both the file and zip versions of the test to ensure we have
1:    * consistent results.
0:    * 
1:    * @param dir   The IDirectory for the root of the vFS.
1:    * @param len   The size of the file.
1:    * @param time  The time the file was last updated.
1:    * @throws IOException
1:    */
0:   public void runBasicDirTest(IDirectory dir, long len, long time) throws IOException
1:   {
1:     assertNull("for some reason our fake app has a fake blueprint file.", dir.getFile("OSGI-INF/blueprint/aries.xml"));
0:     
0:     IFile file = dir.getFile(AppConstants.APPLICATION_MF);
0:     
1:     assertNotNull("we could not find the application manifest", file);
0:     
0:     assertEquals(AppConstants.APPLICATION_MF, file.getName().replace('\\', '/'));
1:     assertTrue("The last update time is not within 2 seconds of the expected value. Expected: " + time + " Actual: " + file.getLastModified(), Math.abs(time - file.getLastModified()) < 2000);
1:     assertEquals(len, file.getSize());
0:     assertEquals("META-INF", file.getParent().getName());
1:     assertFalse(file.isDirectory());
1:     assertTrue(file.isFile());
0:     
1:     List<IFile> files = dir.listFiles();
0:     
1:     assertEquals(1, files.size());
0:     
1:     IFile metaInf = files.get(0);
0:     
1:     assertTrue(metaInf.isDirectory());
0:     assertEquals("META-INF", metaInf.getName());
1:     assertNotNull(metaInf.convert());
0:     
1:     for (IFile aFile : dir) {
0:       assertTrue(aFile.isDirectory());
0:       assertEquals("META-INF", aFile.getName());
0:       assertNotNull(aFile.convert());
1:     }
0:     
0:     InputStream is = file.open();
0:     
0:     Manifest man = new Manifest(is);
0:     //remember to close the input stream after use
0:     is.close();
0:     assertEquals("com.travel.reservation", man.getMainAttributes().getValue("Application-SymbolicName"));
0:     
0:     IFile applicationMF2 = dir.getFile(AppConstants.APPLICATION_MF);
0:     
1:     Assert.assertEqualsContract(file, applicationMF2, dir);
1:     Assert.assertHashCodeEquals(file, applicationMF2, true);
1:   }
1: }
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:8914925
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: package org.apache.aries.application.utils.filesystem;
0: 
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertFalse;
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: 
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.FileOutputStream;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.jar.Manifest;
0: import java.util.zip.ZipEntry;
0: import java.util.zip.ZipOutputStream;
0: 
0: import org.apache.aries.application.filesystem.IDirectory;
0: import org.apache.aries.application.filesystem.IFile;
0: import org.apache.aries.application.utils.AppConstants;
0: import org.apache.aries.unittest.junit.Assert;
0: import org.junit.AfterClass;
0: import org.junit.BeforeClass;
0: import org.junit.Test;
0: 
0: 
0: /**
0:  * This class contains tests for the virtual file system.
0:  */
0: public class FileSystemTest
0: {
0:   /**
0:    * Make sure we correctly understand the content of the application when the
0:    * application is an exploded directory. This test just checks that the
0:    * root directory returns the expected information.
0:    * 
0:    * @throws IOException
0:    */
0:   @Test(expected=UnsupportedOperationException.class)
0:   public void basicRootDirTestsWithFiles() throws IOException
0:   {
0:     File baseDir = new File("../src/test/resources/app1");
0:     File manifest = new File(baseDir, AppConstants.APPLICATION_MF);
0:     IDirectory dir = FileSystem.getFSRoot(baseDir);
0:     
0:     runBasicRootDirTests(dir, baseDir.length(), manifest.lastModified());
0:   }
0:   
0:   /**
0:    * Make sure we correctly understand the directory structure for exploded
0:    * directories.
0:    * 
0:    * @throws IOException
0:    */
0:   @Test
0:   public void basicDirTestsWithFiles() throws IOException
0:   {
0:     File baseDir = new File("../src/test/resources/app1");
0:     IDirectory dir = FileSystem.getFSRoot(baseDir);
0: 
0:     File desiredFile = new File(baseDir, AppConstants.APPLICATION_MF);
0:     
0:     runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
0:   }
0:   
0:   /**
0:    * Make sure we correctly understand the content of the application when the
0:    * application is a zip. This test just checks that the
0:    * root directory returns the expected information.
0:    * 
0:    * @throws IOException
0:    */
0:   @Test(expected=UnsupportedOperationException.class)
0:   public void basicRootDirTestsWithZip() throws IOException
0:   {
0:     File baseDir = new File("fileSystemTest/app2.zip");
0:     IDirectory dir = FileSystem.getFSRoot(baseDir);
0:     
0:     runBasicRootDirTests(dir, baseDir.length(), baseDir.lastModified());
0:   }
0:   
0:   /**
0:    * Make sure we correctly understand the directory structure for zips.
0:    * 
0:    * @throws IOException
0:    */
0:   @Test
0:   public void basicDirTestsWithZip() throws IOException
0:   {
0:     File baseDir = new File("fileSystemTest/app2.zip");
0:     IDirectory dir = FileSystem.getFSRoot(baseDir);
0: 
0:     File desiredFile = new File(new File("../src/test/resources/app1"), AppConstants.APPLICATION_MF);
0:     
0:     runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
0:   }
0:   
0:   /**
0:    * Zip up the app1 directory to create a zippped version before running any
0:    * tests.
0:    * 
0:    * @throws IOException
0:    */
0:   @BeforeClass
0:   public static void makeZip() throws IOException
0:   {
0:     File zipFile = new File("fileSystemTest/app2.zip");
0:     zipFile.getParentFile().mkdirs();
0:     ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));
0:     
0:     int index = new File("../src/test/resources/app1").getAbsolutePath().length();
0:     
0:     writeEnties(out, new File("../src/test/resources/app1"), index);
0:     
0:     out.close();
0:   }
0:   
0:   /**
0:    * Make sure the test zip is deleted afterwards.
0:    */
0:   @AfterClass
0:   public static void destroyZip()
0:   {
0:     new File("fileSystemTest/app2.zip").delete();
0:     new File("fileSystemTest").delete();
0:   }
0:   
0:   /**
0:    * This method writes the given directory into the provided zip output stream.
0:    * It removes the first <code>index</code> bytes from the absolute path name
0:    * when building the zip.
0:    * 
0:    * @param zos   the zip output stream to use
0:    * @param f     the directory to write into the zip.
0:    * @param index how much of the file name to chop off.
0:    * @throws IOException
0:    */
0:   public static void writeEnties(ZipOutputStream zos, File f, int index) throws IOException {
0:     File[] files = f.listFiles();
0:     
0:     if (files != null) {
0:       for (File file : files) {
0:         String fileName = file.getAbsolutePath().substring(index + 1);
0:         
0:      // Bug 1954: replace any '\' characters with '/' - required by ZipEntry
0:         fileName = fileName.replace('\\', '/');
0:         
0:         if (file.isDirectory()) fileName = fileName + "/";
0:         
0:         ZipEntry ze = new ZipEntry(fileName);
0:         ze.setSize(file.length());
0:         ze.setTime(file.lastModified());
0:         zos.putNextEntry(ze);
0:         
0:         if (file.isFile()) {
0:           InputStream is = new FileInputStream(file);
0:           byte[] buffer = new byte[(int)file.length()];
0:           int len = is.read(buffer);
0:           zos.write(buffer, 0, len);
0:           is.close();   // Bug 1594
0:         }
0: 
0:         zos.closeEntry();
0:         
0:         if (file.isDirectory()) {
0:           writeEnties(zos, file, index);
0:         }
0:       }
0:     }
0:   }
0:   
0:   /**
0:    * This method makes sure that the data is correctly understood from disk. It
0:    * is called for both the file and zip versions of the test to ensure we have
0:    * consistent results.
0:    * 
0:    * @param dir   The IDirectory for the root of the vFS.
0:    * @param len   The size of the file.
0:    * @param time  The time the file was last updated.
0:    * @throws IOException
0:    */
0:   public void runBasicRootDirTests(IDirectory dir, long len, long time) throws IOException
0:   {
0:     assertEquals("The root file system name is not correct", "", dir.getName());
0:     assertEquals("The size of the file is not correct", len, dir.getSize());
0:     
0:     // This assertion just isn't working on Hudson as of build #79
0:     // assertEquals("The last modified time of the file is not correct", time, dir.getLastModified());
0:     
0:     assertNull("I managed to get a parent of a root", dir.getParent());
0:     assertTrue("The root dir does not know it is a dir", dir.isDirectory());
0:     assertFalse("The root dir has an identity crisis and thinks it is a file", dir.isFile());
0: 
0:     dir.open();
0:   }
0:   
0:   /**
0:    * This method makes sure that the data is correctly understood from disk. It
0:    * is called for both the file and zip versions of the test to ensure we have
0:    * consistent results.
0:    * 
0:    * @param dir   The IDirectory for the root of the vFS.
0:    * @param len   The size of the file.
0:    * @param time  The time the file was last updated.
0:    * @throws IOException
0:    */
0:   public void runBasicDirTest(IDirectory dir, long len, long time) throws IOException
0:   {
0:     assertNull("for some reason our fake app has a fake blueprint file.", dir.getFile("OSGI-INF/blueprint/aries.xml"));
0:     
0:     IFile file = dir.getFile(AppConstants.APPLICATION_MF);
0:     
0:     assertNotNull("we could not find the application manifest", file);
0:     
0:     assertEquals(AppConstants.APPLICATION_MF, file.getName().replace('\\', '/'));
0:     assertTrue("The last update time is not within 2 seconds of the expected value. Expected: " + time + " Actual: " + file.getLastModified(), Math.abs(time - file.getLastModified()) < 2000);
0:     assertEquals(len, file.getSize());
0:     assertEquals("META-INF", file.getParent().getName());
0:     assertFalse(file.isDirectory());
0:     assertTrue(file.isFile());
0:     
0:     List<IFile> files = dir.listFiles();
0:     Iterator<IFile> it = files.iterator();
0:     while (it.hasNext()) { 
0:       IFile f = it.next();
0:       if (f.getName().equalsIgnoreCase(".svn")) { 
0:         it.remove();
0:       }
0:     }
0:     
0:     assertEquals(1, files.size());
0:     
0:     IFile metaInf = files.get(0);
0:     
0:     assertTrue(metaInf.isDirectory());
0:     assertEquals("META-INF", metaInf.getName());
0:     assertNotNull(metaInf.convert());
0:     
0:     for (IFile aFile : dir) {
0:       if (!aFile.getName().equalsIgnoreCase(".svn")) { 
0:         assertTrue(aFile.isDirectory());
0:         assertEquals("META-INF", aFile.getName());
0:         assertNotNull(aFile.convert());
0:       }
0:     }
0:     
0:     InputStream is = file.open();
0:     
0:     Manifest man = new Manifest(is);
0:     //remember to close the input stream after use
0:     is.close();
0:     assertEquals("com.travel.reservation", man.getMainAttributes().getValue("Application-SymbolicName"));
0:     
0:     IFile applicationMF2 = dir.getFile(AppConstants.APPLICATION_MF);
0:     
0:     Assert.assertEqualsContract(file, applicationMF2, dir);
0:     Assert.assertHashCodeEquals(file, applicationMF2, true);
0:   }
0: }
============================================================================