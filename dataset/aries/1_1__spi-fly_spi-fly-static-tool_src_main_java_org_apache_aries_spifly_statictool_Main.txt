1:5b14fdd: /**
1:5b14fdd:  * Licensed to the Apache Software Foundation (ASF) under one
1:5b14fdd:  * or more contributor license agreements.  See the NOTICE file
1:5b14fdd:  * distributed with this work for additional information
1:5b14fdd:  * regarding copyright ownership.  The ASF licenses this file
1:5b14fdd:  * to you under the Apache License, Version 2.0 (the
1:5b14fdd:  * "License"); you may not use this file except in compliance
1:5b14fdd:  * with the License.  You may obtain a copy of the License at
1:5b14fdd:  *
1:5b14fdd:  *   http://www.apache.org/licenses/LICENSE-2.0
1:5b14fdd:  *
1:5b14fdd:  * Unless required by applicable law or agreed to in writing,
1:5b14fdd:  * software distributed under the License is distributed on an
1:5b14fdd:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:5b14fdd:  * KIND, either express or implied.  See the License for the
1:5b14fdd:  * specific language governing permissions and limitations
1:5b14fdd:  * under the License.
1:5b14fdd:  */
1:5b14fdd: package org.apache.aries.spifly.statictool;
1:5b14fdd: 
1:5b14fdd: import java.io.ByteArrayInputStream;
1:5b14fdd: import java.io.File;
1:5b14fdd: import java.io.FileInputStream;
1:5b14fdd: import java.io.FileOutputStream;
1:5b14fdd: import java.io.IOException;
1:5b14fdd: import java.io.InputStream;
1:5b14fdd: import java.io.OutputStream;
1:5b14fdd: import java.net.URL;
1:5b14fdd: import java.net.URLClassLoader;
1:5b14fdd: import java.util.Properties;
1:5b14fdd: import java.util.Set;
1:5b14fdd: import java.util.jar.Attributes;
1:5b14fdd: import java.util.jar.JarEntry;
1:5b14fdd: import java.util.jar.JarInputStream;
1:5b14fdd: import java.util.jar.JarOutputStream;
1:5b14fdd: import java.util.jar.Manifest;
1:5b14fdd: 
1:5b14fdd: import org.apache.aries.spifly.ConsumerHeaderProcessor;
1:5b14fdd: import org.apache.aries.spifly.SpiFlyConstants;
1:5b14fdd: import org.apache.aries.spifly.Streams;
1:5b14fdd: import org.apache.aries.spifly.Util;
1:5b14fdd: import org.apache.aries.spifly.WeavingData;
1:5b14fdd: import org.apache.aries.spifly.weaver.TCCLSetterVisitor;
1:5b14fdd: import org.objectweb.asm.ClassReader;
1:5b14fdd: import org.objectweb.asm.ClassWriter;
1:5b14fdd: import org.osgi.framework.Constants;
1:5b14fdd: import org.osgi.framework.Version;
1:5b14fdd: 
1:5b14fdd: public class Main {
1:5b14fdd:     private static final String MODIFIED_BUNDLE_SUFFIX = "_spifly.jar";
1:5b14fdd:     private static final String IMPORT_PACKAGE = "Import-Package";
1:5b14fdd: 
1:5b14fdd:     public static void usage() {
1:5b14fdd:         System.err.println("This tool processes OSGi Bundles that use java.util.ServiceLoader.load() to");
1:5b14fdd:         System.err.println("obtain implementations via META-INF/services. The byte code in the bundles is");
1:5b14fdd:         System.err.println("modified so that the ThreadContextClassLoader is set appropriately for the ");
1:5b14fdd:         System.err.println("duration of the java.util.ServiceLoader.load() call.");
1:5b14fdd:         System.err.println("To opt-in to this process, bundles need to have the following MANIFEST.MF");
1:5b14fdd:         System.err.println("header set:");
1:5b14fdd:         System.err.println("    " + SpiFlyConstants.SPI_CONSUMER_HEADER + ": *");
1:5b14fdd:         System.err.println("Modified bundles are written out under the following name:");
1:5b14fdd:         System.err.println("    <original-bundle-name>" + MODIFIED_BUNDLE_SUFFIX);
1:5b14fdd:         System.err.println();
1:5b14fdd:         System.err.println("Usage: java " + Main.class.getName() + " bundle1.jar bundle2.jar ...");
1:5b14fdd:         System.exit(-1);
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     public static void main(String ... args) throws Exception {
1:5b14fdd:         if (args.length < 1)
1:5b14fdd:             usage();
1:5b14fdd: 
1:5b14fdd:         for (String arg : args) {
1:5b14fdd:             weaveJar(arg);
1:5b14fdd:         }
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     private static void weaveJar(String jarPath) throws Exception {
1:5b14fdd:         System.out.println("[SPI Fly Static Tool] Processing: " + jarPath);
1:5b14fdd: 
1:5b14fdd:         File jarFile = new File(jarPath);
1:5b14fdd:         File tempDir = new File(System.getProperty("java.io.tmpdir") + File.separator + jarFile.getName() + "_" + System.currentTimeMillis());
1:5b14fdd:         Manifest manifest = unJar(jarFile, tempDir);
1:5b14fdd:         String consumerHeaderVal = manifest.getMainAttributes().getValue(SpiFlyConstants.SPI_CONSUMER_HEADER);
1:5b14fdd:         String consumerHeaderKey = null;
1:5b14fdd:         if (consumerHeaderVal != null) {
1:5b14fdd:             consumerHeaderKey = SpiFlyConstants.SPI_CONSUMER_HEADER;
1:5b14fdd:         } else {
1:5b14fdd:             consumerHeaderVal = manifest.getMainAttributes().getValue(SpiFlyConstants.REQUIRE_CAPABILITY);
1:5b14fdd:             if (consumerHeaderVal != null) {
1:5b14fdd:                 consumerHeaderKey = SpiFlyConstants.REQUIRE_CAPABILITY;
1:5b14fdd:             }
1:5b14fdd:         }
1:5b14fdd: 
1:5b14fdd:         if (consumerHeaderVal != null) {
1:5b14fdd:             String bcp = manifest.getMainAttributes().getValue(Constants.BUNDLE_CLASSPATH);
1:5b14fdd:             weaveDir(tempDir, consumerHeaderKey, consumerHeaderVal, bcp);
1:5b14fdd: 
1:5b14fdd:             if (SpiFlyConstants.SPI_CONSUMER_HEADER.equals(consumerHeaderKey)) {
1:5b14fdd:                 manifest.getMainAttributes().remove(new Attributes.Name(SpiFlyConstants.SPI_CONSUMER_HEADER));
1:5b14fdd:                 manifest.getMainAttributes().putValue(SpiFlyConstants.PROCESSED_SPI_CONSUMER_HEADER, consumerHeaderVal);
1:5b14fdd:             } else {
1:5b14fdd:                 // It's SpiFlyConstants.REQUIRE_CAPABILITY
1:5b14fdd: 
1:5b14fdd:                 // Take out the processor requirement, this probably needs to be improved a little bit
1:5b14fdd:                 String newConsumerHeaderVal = consumerHeaderVal.replaceAll(
1:5b14fdd:                         "osgi[.]extender;\\s*filter[:][=][\"]?[(]osgi[.]extender[=]osgi[.]serviceloader[.]processor[)][\"]?", "").
1:5b14fdd:                         trim();
1:5b14fdd:                 if (newConsumerHeaderVal.startsWith(","))
1:5b14fdd:                     newConsumerHeaderVal = newConsumerHeaderVal.substring(1);
1:5b14fdd: 
1:5b14fdd:                 if (newConsumerHeaderVal.endsWith(","))
1:5b14fdd:                     newConsumerHeaderVal = newConsumerHeaderVal.substring(0, newConsumerHeaderVal.length()-1);
1:5b14fdd:                 manifest.getMainAttributes().putValue(SpiFlyConstants.REQUIRE_CAPABILITY, newConsumerHeaderVal);
1:5b14fdd:                 manifest.getMainAttributes().putValue("X-SpiFly-Processed-Require-Capability", consumerHeaderVal);
1:5b14fdd:             }
1:5b14fdd: 
1:5b14fdd:             // TODO if new packages needed then...
1:5b14fdd:             extendImportPackage(manifest);
1:5b14fdd: 
1:5b14fdd:             File newJar = getNewJarFile(jarFile);
1:5b14fdd:             jar(newJar, tempDir, manifest);
1:5b14fdd:         } else {
1:5b14fdd:             System.out.println("[SPI Fly Static Tool] This file is not marked as an SPI Consumer.");
1:5b14fdd:         }
1:5b14fdd:         delTree(tempDir);
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     private static void extendImportPackage(Manifest manifest) throws IOException {
1:5b14fdd:         String utilPkgVersion = getPackageVersion(Util.class);
1:5b14fdd: 
1:5b14fdd:         Version osgiVersion = Version.parseVersion(utilPkgVersion);
1:5b14fdd: 
1:5b14fdd:         Version minVersion = new Version(osgiVersion.getMajor(), osgiVersion.getMinor(), osgiVersion.getMicro());
1:5b14fdd:         Version maxVersion = new Version(osgiVersion.getMajor(), osgiVersion.getMinor() + 1, 0);
1:5b14fdd: 
1:5b14fdd:         String ip = manifest.getMainAttributes().getValue(IMPORT_PACKAGE);
1:5b14fdd:         if (ip == null)
1:5b14fdd:             ip = "";
1:5b14fdd: 
1:5b14fdd:         StringBuilder sb = new StringBuilder(ip);
1:5b14fdd:         if (ip.length() > 0)
1:5b14fdd:             sb.append(",");
1:5b14fdd:         sb.append(Util.class.getPackage().getName());
1:5b14fdd:         sb.append(";version=\"[");
1:5b14fdd:         sb.append(minVersion);
1:5b14fdd:         sb.append(",");
1:5b14fdd:         sb.append(maxVersion);
1:5b14fdd:         sb.append(")\"");
1:5b14fdd:         manifest.getMainAttributes().putValue(IMPORT_PACKAGE, sb.toString());
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     private static String getPackageVersion(Class<?> clazz) throws IOException {
1:5b14fdd:         URL url = clazz.getResource("packageinfo");
1:5b14fdd:         if (url == null) {
1:5b14fdd:             throw new RuntimeException("'packageinfo' file with version information not found for package: "
1:5b14fdd:                     + clazz.getPackage().getName());
1:5b14fdd:         }
1:5b14fdd: 
1:5b14fdd:         byte[] bytes = Streams.suck(url.openStream());
1:5b14fdd:         Properties p = new Properties();
1:5b14fdd:         p.load(new ByteArrayInputStream(bytes));
1:5b14fdd:         return p.getProperty("version");
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     private static File getNewJarFile(File jarFile) {
1:5b14fdd:         String s = jarFile.getAbsolutePath();
1:5b14fdd:         int idx = s.lastIndexOf('.');
1:5b14fdd:         s = s.substring(0, idx);
1:5b14fdd:         s += MODIFIED_BUNDLE_SUFFIX;
1:5b14fdd:         return new File(s);
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     private static void weaveDir(File dir, String consumerHeaderKey, String consumerHeaderValue, String bundleClassPath) throws Exception {
1:5b14fdd:         Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(consumerHeaderKey, consumerHeaderValue);
1:5b14fdd: 
1:5b14fdd:         URLClassLoader cl = new URLClassLoader(new URL [] {dir.toURI().toURL()}, Main.class.getClassLoader());
1:5b14fdd:         String dirName = dir.getAbsolutePath();
1:5b14fdd: 
1:5b14fdd:         DirTree dt = new DirTree(dir);
1:5b14fdd:         for (File f : dt.getFiles()) {
1:5b14fdd:             if (!f.getName().endsWith(".class"))
1:5b14fdd:                 continue;
1:5b14fdd: 
1:5b14fdd:             String className = f.getAbsolutePath().substring(dirName.length());
1:5b14fdd:             if (className.startsWith(File.separator))
1:5b14fdd:                 className = className.substring(1);
1:5b14fdd:             className = className.substring(0, className.length() - ".class".length());
1:5b14fdd:             className = className.replace(File.separator, ".");
1:5b14fdd: 
1:5b14fdd:             InputStream is = new FileInputStream(f);
1:5b14fdd:             byte[] b;
1:5b14fdd:             try {
1:5b14fdd:                 ClassReader cr = new ClassReader(is);
1:5b14fdd:                 ClassWriter cw = new StaticToolClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES, cl);
1:5b14fdd:                 TCCLSetterVisitor cv = new TCCLSetterVisitor(cw, className, wd);
1:5b14fdd:                 cr.accept(cv, ClassReader.SKIP_FRAMES);
1:5b14fdd:                 if (cv.isWoven()) {
1:5b14fdd:                     b = cw.toByteArray();
1:5b14fdd:                 } else {
1:5b14fdd:                     // if not woven, store the original bytes
1:5b14fdd:                     b = Streams.suck(new FileInputStream(f));
1:5b14fdd:                 }
1:5b14fdd:             } finally {
1:5b14fdd:                 is.close();
1:5b14fdd:             }
1:5b14fdd: 
1:5b14fdd:             OutputStream os = new FileOutputStream(f);
1:5b14fdd:             try {
1:5b14fdd:                 os.write(b);
1:5b14fdd:             } finally {
1:5b14fdd:                 os.close();
1:5b14fdd:             }
1:5b14fdd:         }
1:5b14fdd: 
1:5b14fdd:         if (bundleClassPath != null) {
1:5b14fdd:             for (String entry : bundleClassPath.split(",")) {
1:5b14fdd:                 File jarFile = new File(dir, entry.trim());
1:5b14fdd:                 if (jarFile.isFile()) {
1:5b14fdd:                     weaveBCPJar(jarFile, consumerHeaderKey, consumerHeaderValue);
1:5b14fdd:                 }
1:5b14fdd:             }
1:5b14fdd:         }
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     private static void weaveBCPJar(File jarFile, String consumerHeaderKey, String consumerHeaderVal) throws Exception {
1:5b14fdd:         File tempDir = new File(System.getProperty("java.io.tmpdir") + File.separator + jarFile.getName() + "_" + System.currentTimeMillis());
1:5b14fdd:         try {
1:5b14fdd:             Manifest manifest = unJar(jarFile, tempDir);
1:5b14fdd:             weaveDir(tempDir, consumerHeaderKey, consumerHeaderVal, null);
1:5b14fdd:             if (!jarFile.delete()) {
1:5b14fdd:                 throw new IOException("Could not replace file: " + jarFile);
1:5b14fdd:             }
1:5b14fdd: 
1:5b14fdd:             jar(jarFile, tempDir, manifest);
1:5b14fdd:         } finally {
1:5b14fdd:             delTree(tempDir);
1:5b14fdd:         }
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     static Manifest unJar(File jarFile, File tempDir) throws IOException {
1:5b14fdd:         ensureDirectory(tempDir);
1:5b14fdd: 
1:5b14fdd:         JarInputStream jis = new JarInputStream(new FileInputStream(jarFile));
1:5b14fdd:         JarEntry je = null;
1:5b14fdd:         while((je = jis.getNextJarEntry()) != null) {
1:5b14fdd:             if (je.isDirectory()) {
1:5b14fdd:                 File outDir = new File(tempDir, je.getName());
1:5b14fdd:                 ensureDirectory(outDir);
1:5b14fdd: 
1:5b14fdd:                 continue;
1:5b14fdd:             }
1:5b14fdd: 
1:5b14fdd:             File outFile = new File(tempDir, je.getName());
1:5b14fdd:             File outDir = outFile.getParentFile();
1:5b14fdd:             ensureDirectory(outDir);
1:5b14fdd: 
1:5b14fdd:             OutputStream out = new FileOutputStream(outFile);
1:5b14fdd:             try {
1:5b14fdd:                 Streams.pump(jis, out);
1:5b14fdd:             } finally {
1:5b14fdd:                 out.flush();
1:5b14fdd:                 out.close();
1:5b14fdd:                 jis.closeEntry();
1:5b14fdd:             }
1:5b14fdd:             outFile.setLastModified(je.getTime());
1:5b14fdd:         }
1:5b14fdd: 
1:5b14fdd:         Manifest manifest = jis.getManifest();
1:5b14fdd:         if (manifest != null) {
1:5b14fdd:             File mf = new File(tempDir, "META-INF/MANIFEST.MF");
1:5b14fdd:             File mfDir = mf.getParentFile();
1:5b14fdd:             ensureDirectory(mfDir);
1:5b14fdd: 
1:5b14fdd:             OutputStream out = new FileOutputStream(mf);
1:5b14fdd:             try {
1:5b14fdd:                 manifest.write(out);
1:5b14fdd:             } finally {
1:5b14fdd:                 out.flush();
1:5b14fdd:                 out.close();
1:5b14fdd:             }
1:5b14fdd:         }
1:5b14fdd: 
1:5b14fdd:         jis.close();
1:5b14fdd:         return manifest;
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     static void jar(File jarFile, File rootFile, Manifest manifest) throws IOException {
1:5b14fdd:         JarOutputStream jos = new JarOutputStream(new FileOutputStream(jarFile), manifest);
1:5b14fdd:         try {
1:5b14fdd:             addToJarRecursively(jos, rootFile.getAbsoluteFile(), rootFile.getAbsolutePath());
1:5b14fdd:         } finally {
1:5b14fdd:             jos.close();
1:5b14fdd:         }
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     static void addToJarRecursively(JarOutputStream jar, File source, String rootDirectory) throws IOException {
1:5b14fdd:         String sourceName = source.getAbsolutePath().replace("\\", "/");
1:5b14fdd:         sourceName = sourceName.substring(rootDirectory.length());
1:5b14fdd: 
1:5b14fdd:         if (sourceName.startsWith("/")) {
1:5b14fdd:             sourceName = sourceName.substring(1);
1:5b14fdd:         }
1:5b14fdd: 
1:5b14fdd:         if ("META-INF/MANIFEST.MF".equals(sourceName))
1:5b14fdd:             return;
1:5b14fdd: 
1:5b14fdd:         if (source.isDirectory()) {
1:5b14fdd:             /* Is there any point in adding a directory beyond just taking up space?
1:5b14fdd:             if (!sourceName.isEmpty()) {
1:5b14fdd:                 if (!sourceName.endsWith("/")) {
1:5b14fdd:                     sourceName += "/";
1:5b14fdd:                 }
1:5b14fdd:                 JarEntry entry = new JarEntry(sourceName);
1:5b14fdd:                 jar.putNextEntry(entry);
1:5b14fdd:                 jar.closeEntry();
1:5b14fdd:             }
1:5b14fdd:             */
1:5b14fdd:             for (File nested : source.listFiles()) {
1:5b14fdd:                 addToJarRecursively(jar, nested, rootDirectory);
1:5b14fdd:             }
1:5b14fdd:             return;
1:5b14fdd:         }
1:5b14fdd: 
1:5b14fdd:         JarEntry entry = new JarEntry(sourceName);
1:5b14fdd:         jar.putNextEntry(entry);
1:5b14fdd:         InputStream is = new FileInputStream(source);
1:5b14fdd:         try {
1:5b14fdd:             Streams.pump(is, jar);
1:5b14fdd:         } finally {
1:5b14fdd:             jar.closeEntry();
1:5b14fdd:             is.close();
1:5b14fdd:         }
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     static void delTree(File tempDir) throws IOException {
1:5b14fdd:         for (File f : new DirTree(tempDir).getFiles()) {
1:5b14fdd:             if (!f.delete())
1:5b14fdd:                 throw new IOException("Problem deleting file: " + tempDir.getAbsolutePath());
1:5b14fdd:         }
1:5b14fdd:     }
1:5b14fdd: 
1:5b14fdd:     private static void ensureDirectory(File outDir) throws IOException {
1:5b14fdd:         if (!outDir.isDirectory())
1:5b14fdd:             if (!outDir.mkdirs())
1:5b14fdd:                 throw new IOException("Unable to create directory " + outDir.getAbsolutePath());
1:5b14fdd:     }
1:5b14fdd: }
1:5b14fdd: 
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:5b14fdd
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.spifly.statictool;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.util.Properties;
1: import java.util.Set;
1: import java.util.jar.Attributes;
1: import java.util.jar.JarEntry;
1: import java.util.jar.JarInputStream;
1: import java.util.jar.JarOutputStream;
1: import java.util.jar.Manifest;
1: 
1: import org.apache.aries.spifly.ConsumerHeaderProcessor;
1: import org.apache.aries.spifly.SpiFlyConstants;
1: import org.apache.aries.spifly.Streams;
1: import org.apache.aries.spifly.Util;
1: import org.apache.aries.spifly.WeavingData;
1: import org.apache.aries.spifly.weaver.TCCLSetterVisitor;
1: import org.objectweb.asm.ClassReader;
1: import org.objectweb.asm.ClassWriter;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.Version;
1: 
1: public class Main {
1:     private static final String MODIFIED_BUNDLE_SUFFIX = "_spifly.jar";
1:     private static final String IMPORT_PACKAGE = "Import-Package";
1: 
1:     public static void usage() {
1:         System.err.println("This tool processes OSGi Bundles that use java.util.ServiceLoader.load() to");
1:         System.err.println("obtain implementations via META-INF/services. The byte code in the bundles is");
1:         System.err.println("modified so that the ThreadContextClassLoader is set appropriately for the ");
1:         System.err.println("duration of the java.util.ServiceLoader.load() call.");
1:         System.err.println("To opt-in to this process, bundles need to have the following MANIFEST.MF");
1:         System.err.println("header set:");
1:         System.err.println("    " + SpiFlyConstants.SPI_CONSUMER_HEADER + ": *");
1:         System.err.println("Modified bundles are written out under the following name:");
1:         System.err.println("    <original-bundle-name>" + MODIFIED_BUNDLE_SUFFIX);
1:         System.err.println();
1:         System.err.println("Usage: java " + Main.class.getName() + " bundle1.jar bundle2.jar ...");
1:         System.exit(-1);
1:     }
1: 
1:     public static void main(String ... args) throws Exception {
1:         if (args.length < 1)
1:             usage();
1: 
1:         for (String arg : args) {
1:             weaveJar(arg);
1:         }
1:     }
1: 
1:     private static void weaveJar(String jarPath) throws Exception {
1:         System.out.println("[SPI Fly Static Tool] Processing: " + jarPath);
1: 
1:         File jarFile = new File(jarPath);
1:         File tempDir = new File(System.getProperty("java.io.tmpdir") + File.separator + jarFile.getName() + "_" + System.currentTimeMillis());
1:         Manifest manifest = unJar(jarFile, tempDir);
1:         String consumerHeaderVal = manifest.getMainAttributes().getValue(SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         String consumerHeaderKey = null;
1:         if (consumerHeaderVal != null) {
1:             consumerHeaderKey = SpiFlyConstants.SPI_CONSUMER_HEADER;
1:         } else {
1:             consumerHeaderVal = manifest.getMainAttributes().getValue(SpiFlyConstants.REQUIRE_CAPABILITY);
1:             if (consumerHeaderVal != null) {
1:                 consumerHeaderKey = SpiFlyConstants.REQUIRE_CAPABILITY;
1:             }
1:         }
1: 
1:         if (consumerHeaderVal != null) {
1:             String bcp = manifest.getMainAttributes().getValue(Constants.BUNDLE_CLASSPATH);
1:             weaveDir(tempDir, consumerHeaderKey, consumerHeaderVal, bcp);
1: 
1:             if (SpiFlyConstants.SPI_CONSUMER_HEADER.equals(consumerHeaderKey)) {
1:                 manifest.getMainAttributes().remove(new Attributes.Name(SpiFlyConstants.SPI_CONSUMER_HEADER));
1:                 manifest.getMainAttributes().putValue(SpiFlyConstants.PROCESSED_SPI_CONSUMER_HEADER, consumerHeaderVal);
1:             } else {
1:                 // It's SpiFlyConstants.REQUIRE_CAPABILITY
1: 
1:                 // Take out the processor requirement, this probably needs to be improved a little bit
1:                 String newConsumerHeaderVal = consumerHeaderVal.replaceAll(
1:                         "osgi[.]extender;\\s*filter[:][=][\"]?[(]osgi[.]extender[=]osgi[.]serviceloader[.]processor[)][\"]?", "").
1:                         trim();
1:                 if (newConsumerHeaderVal.startsWith(","))
1:                     newConsumerHeaderVal = newConsumerHeaderVal.substring(1);
1: 
1:                 if (newConsumerHeaderVal.endsWith(","))
1:                     newConsumerHeaderVal = newConsumerHeaderVal.substring(0, newConsumerHeaderVal.length()-1);
1:                 manifest.getMainAttributes().putValue(SpiFlyConstants.REQUIRE_CAPABILITY, newConsumerHeaderVal);
1:                 manifest.getMainAttributes().putValue("X-SpiFly-Processed-Require-Capability", consumerHeaderVal);
1:             }
1: 
1:             // TODO if new packages needed then...
1:             extendImportPackage(manifest);
1: 
1:             File newJar = getNewJarFile(jarFile);
1:             jar(newJar, tempDir, manifest);
1:         } else {
1:             System.out.println("[SPI Fly Static Tool] This file is not marked as an SPI Consumer.");
1:         }
1:         delTree(tempDir);
1:     }
1: 
1:     private static void extendImportPackage(Manifest manifest) throws IOException {
1:         String utilPkgVersion = getPackageVersion(Util.class);
1: 
1:         Version osgiVersion = Version.parseVersion(utilPkgVersion);
1: 
1:         Version minVersion = new Version(osgiVersion.getMajor(), osgiVersion.getMinor(), osgiVersion.getMicro());
1:         Version maxVersion = new Version(osgiVersion.getMajor(), osgiVersion.getMinor() + 1, 0);
1: 
1:         String ip = manifest.getMainAttributes().getValue(IMPORT_PACKAGE);
1:         if (ip == null)
1:             ip = "";
1: 
1:         StringBuilder sb = new StringBuilder(ip);
1:         if (ip.length() > 0)
1:             sb.append(",");
1:         sb.append(Util.class.getPackage().getName());
1:         sb.append(";version=\"[");
1:         sb.append(minVersion);
1:         sb.append(",");
1:         sb.append(maxVersion);
1:         sb.append(")\"");
1:         manifest.getMainAttributes().putValue(IMPORT_PACKAGE, sb.toString());
1:     }
1: 
1:     private static String getPackageVersion(Class<?> clazz) throws IOException {
1:         URL url = clazz.getResource("packageinfo");
1:         if (url == null) {
1:             throw new RuntimeException("'packageinfo' file with version information not found for package: "
1:                     + clazz.getPackage().getName());
1:         }
1: 
1:         byte[] bytes = Streams.suck(url.openStream());
1:         Properties p = new Properties();
1:         p.load(new ByteArrayInputStream(bytes));
1:         return p.getProperty("version");
1:     }
1: 
1:     private static File getNewJarFile(File jarFile) {
1:         String s = jarFile.getAbsolutePath();
1:         int idx = s.lastIndexOf('.');
1:         s = s.substring(0, idx);
1:         s += MODIFIED_BUNDLE_SUFFIX;
1:         return new File(s);
1:     }
1: 
1:     private static void weaveDir(File dir, String consumerHeaderKey, String consumerHeaderValue, String bundleClassPath) throws Exception {
1:         Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(consumerHeaderKey, consumerHeaderValue);
1: 
1:         URLClassLoader cl = new URLClassLoader(new URL [] {dir.toURI().toURL()}, Main.class.getClassLoader());
1:         String dirName = dir.getAbsolutePath();
1: 
1:         DirTree dt = new DirTree(dir);
1:         for (File f : dt.getFiles()) {
1:             if (!f.getName().endsWith(".class"))
1:                 continue;
1: 
1:             String className = f.getAbsolutePath().substring(dirName.length());
1:             if (className.startsWith(File.separator))
1:                 className = className.substring(1);
1:             className = className.substring(0, className.length() - ".class".length());
1:             className = className.replace(File.separator, ".");
1: 
1:             InputStream is = new FileInputStream(f);
1:             byte[] b;
1:             try {
1:                 ClassReader cr = new ClassReader(is);
1:                 ClassWriter cw = new StaticToolClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES, cl);
1:                 TCCLSetterVisitor cv = new TCCLSetterVisitor(cw, className, wd);
1:                 cr.accept(cv, ClassReader.SKIP_FRAMES);
1:                 if (cv.isWoven()) {
1:                     b = cw.toByteArray();
1:                 } else {
1:                     // if not woven, store the original bytes
1:                     b = Streams.suck(new FileInputStream(f));
1:                 }
1:             } finally {
1:                 is.close();
1:             }
1: 
1:             OutputStream os = new FileOutputStream(f);
1:             try {
1:                 os.write(b);
1:             } finally {
1:                 os.close();
1:             }
1:         }
1: 
1:         if (bundleClassPath != null) {
1:             for (String entry : bundleClassPath.split(",")) {
1:                 File jarFile = new File(dir, entry.trim());
1:                 if (jarFile.isFile()) {
1:                     weaveBCPJar(jarFile, consumerHeaderKey, consumerHeaderValue);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private static void weaveBCPJar(File jarFile, String consumerHeaderKey, String consumerHeaderVal) throws Exception {
1:         File tempDir = new File(System.getProperty("java.io.tmpdir") + File.separator + jarFile.getName() + "_" + System.currentTimeMillis());
1:         try {
1:             Manifest manifest = unJar(jarFile, tempDir);
1:             weaveDir(tempDir, consumerHeaderKey, consumerHeaderVal, null);
1:             if (!jarFile.delete()) {
1:                 throw new IOException("Could not replace file: " + jarFile);
1:             }
1: 
1:             jar(jarFile, tempDir, manifest);
1:         } finally {
1:             delTree(tempDir);
1:         }
1:     }
1: 
1:     static Manifest unJar(File jarFile, File tempDir) throws IOException {
1:         ensureDirectory(tempDir);
1: 
1:         JarInputStream jis = new JarInputStream(new FileInputStream(jarFile));
1:         JarEntry je = null;
1:         while((je = jis.getNextJarEntry()) != null) {
1:             if (je.isDirectory()) {
1:                 File outDir = new File(tempDir, je.getName());
1:                 ensureDirectory(outDir);
1: 
1:                 continue;
1:             }
1: 
1:             File outFile = new File(tempDir, je.getName());
1:             File outDir = outFile.getParentFile();
1:             ensureDirectory(outDir);
1: 
1:             OutputStream out = new FileOutputStream(outFile);
1:             try {
1:                 Streams.pump(jis, out);
1:             } finally {
1:                 out.flush();
1:                 out.close();
1:                 jis.closeEntry();
1:             }
1:             outFile.setLastModified(je.getTime());
1:         }
1: 
1:         Manifest manifest = jis.getManifest();
1:         if (manifest != null) {
1:             File mf = new File(tempDir, "META-INF/MANIFEST.MF");
1:             File mfDir = mf.getParentFile();
1:             ensureDirectory(mfDir);
1: 
1:             OutputStream out = new FileOutputStream(mf);
1:             try {
1:                 manifest.write(out);
1:             } finally {
1:                 out.flush();
1:                 out.close();
1:             }
1:         }
1: 
1:         jis.close();
1:         return manifest;
1:     }
1: 
1:     static void jar(File jarFile, File rootFile, Manifest manifest) throws IOException {
1:         JarOutputStream jos = new JarOutputStream(new FileOutputStream(jarFile), manifest);
1:         try {
1:             addToJarRecursively(jos, rootFile.getAbsoluteFile(), rootFile.getAbsolutePath());
1:         } finally {
1:             jos.close();
1:         }
1:     }
1: 
1:     static void addToJarRecursively(JarOutputStream jar, File source, String rootDirectory) throws IOException {
1:         String sourceName = source.getAbsolutePath().replace("\\", "/");
1:         sourceName = sourceName.substring(rootDirectory.length());
1: 
1:         if (sourceName.startsWith("/")) {
1:             sourceName = sourceName.substring(1);
1:         }
1: 
1:         if ("META-INF/MANIFEST.MF".equals(sourceName))
1:             return;
1: 
1:         if (source.isDirectory()) {
1:             /* Is there any point in adding a directory beyond just taking up space?
1:             if (!sourceName.isEmpty()) {
1:                 if (!sourceName.endsWith("/")) {
1:                     sourceName += "/";
1:                 }
1:                 JarEntry entry = new JarEntry(sourceName);
1:                 jar.putNextEntry(entry);
1:                 jar.closeEntry();
1:             }
1:             */
1:             for (File nested : source.listFiles()) {
1:                 addToJarRecursively(jar, nested, rootDirectory);
1:             }
1:             return;
1:         }
1: 
1:         JarEntry entry = new JarEntry(sourceName);
1:         jar.putNextEntry(entry);
1:         InputStream is = new FileInputStream(source);
1:         try {
1:             Streams.pump(is, jar);
1:         } finally {
1:             jar.closeEntry();
1:             is.close();
1:         }
1:     }
1: 
1:     static void delTree(File tempDir) throws IOException {
1:         for (File f : new DirTree(tempDir).getFiles()) {
1:             if (!f.delete())
1:                 throw new IOException("Problem deleting file: " + tempDir.getAbsolutePath());
1:         }
1:     }
1: 
1:     private static void ensureDirectory(File outDir) throws IOException {
1:         if (!outDir.isDirectory())
1:             if (!outDir.mkdirs())
1:                 throw new IOException("Unable to create directory " + outDir.getAbsolutePath());
1:     }
1: }
1: 
commit:80f5c0a
/////////////////////////////////////////////////////////////////////////
0:                 manifest.getMainAttributes().putValue(SpiFlyConstants.PROCESSED_SPI_CONSUMER_HEADER, consumerHeaderVal);
0:                         "osgi[.]extender;\\s*filter[:][=][\"]?[(]osgi[.]extender[=]osgi[.]serviceloader[.]processor[)][\"]?", "").
0:                         trim();
0:                 manifest.getMainAttributes().putValue("X-SpiFly-Processed-Require-Capability", consumerHeaderVal);
commit:8c32fc9
/////////////////////////////////////////////////////////////////////////
0:                 if (newConsumerHeaderVal.startsWith(","))
0:                     newConsumerHeaderVal = newConsumerHeaderVal.substring(1);
0: 
0:                 if (newConsumerHeaderVal.endsWith(","))
0:                     newConsumerHeaderVal = newConsumerHeaderVal.substring(0, newConsumerHeaderVal.length()-1);
commit:805ec38
/////////////////////////////////////////////////////////////////////////
0: import java.net.URLClassLoader;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         URLClassLoader cl = new URLClassLoader(new URL [] {dir.toURI().toURL()}, Main.class.getClassLoader());
/////////////////////////////////////////////////////////////////////////
0:                 ClassWriter cw = new StaticToolClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES, cl);
commit:c9a84c5
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor.GenericMetadata;
/////////////////////////////////////////////////////////////////////////
0:         String consumerHeaderVal = manifest.getMainAttributes().getValue(SpiFlyConstants.SPI_CONSUMER_HEADER);
0:         String consumerHeaderKey = null;
0:         if (consumerHeaderVal != null) {
0:             consumerHeaderKey = SpiFlyConstants.SPI_CONSUMER_HEADER;
0:         } else {
0:             consumerHeaderVal = manifest.getMainAttributes().getValue(SpiFlyConstants.REQUIRE_CAPABILITY);
0:             if (consumerHeaderVal != null) {
0:                 consumerHeaderKey = SpiFlyConstants.REQUIRE_CAPABILITY;
0:             }
0:         }
0:         if (consumerHeaderVal != null) {
0:             weaveDir(tempDir, consumerHeaderKey, consumerHeaderVal, bcp);
0:             if (SpiFlyConstants.SPI_CONSUMER_HEADER.equals(consumerHeaderKey)) {
0:                 manifest.getMainAttributes().remove(new Attributes.Name(SpiFlyConstants.SPI_CONSUMER_HEADER));
0:             } else {
0:                 // It's SpiFlyConstants.REQUIRE_CAPABILITY
0: 
0:                 // Take out the processor requirement, this probably needs to be improved a little bit
0:                 String newConsumerHeaderVal = consumerHeaderVal.replaceAll(
0:                         "osgi[.]extender;\\s*filter[:][=][\"]?[(]osgi[.]extender[=]osgi[.]serviceloader[.]processor[)][\"]?", "");
0:                 manifest.getMainAttributes().putValue(SpiFlyConstants.REQUIRE_CAPABILITY, newConsumerHeaderVal);
0:             }
0:             manifest.getMainAttributes().putValue(SpiFlyConstants.PROCESSED_SPI_CONSUMER_HEADER, consumerHeaderVal);
0: 
/////////////////////////////////////////////////////////////////////////
0:     private static String serializeRequirement(GenericMetadata req) {
0:         StringBuilder serialized = new StringBuilder();
0: 
0:         serialized.append(req.getNamespace());
0:         serialized.append(';');
0:         for (Map.Entry<String, Object> attr : req.getAttributes().entrySet()) {
0:             serialized.append(attr.getKey());
0:             serialized.append('=');
0:             serialized.append(attr.getValue());
0:             serialized.append(';');
0:         }
0: 
0:         for (Map.Entry<String, String> dir : req.getDirectives().entrySet()) {
0:             serialized.append(dir.getKey());
0:             serialized.append(":=");
0:             serialized.append(dir.getValue());
0:             serialized.append(';');
0:         }
0:         serialized.deleteCharAt(serialized.length() -1);
0:         serialized.append(',');
0:         return serialized.toString();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     private static void weaveDir(File dir, String consumerHeaderKey, String consumerHeaderValue, String bundleClassPath) throws Exception {
0:         Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(consumerHeaderKey, consumerHeaderValue);
/////////////////////////////////////////////////////////////////////////
0:                     weaveBCPJar(jarFile, consumerHeaderKey, consumerHeaderValue);
0:     private static void weaveBCPJar(File jarFile, String consumerHeaderKey, String consumerHeaderVal) throws Exception {
0:             weaveDir(tempDir, consumerHeaderKey, consumerHeaderVal, null);
commit:e9a5257
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.spifly.SpiFlyConstants;
commit:71814f4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: //        if (consumerHeader == null) {
0: //            String reqCap = manifest.getMainAttributes().getValue(SpiFlyConstants.REQUIRE_CAPABILITY);
0: //            sdasda
0: //        }
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (ip == null)
0:             ip = "";
0: 
0:         if (ip.length() > 0)
0:             sb.append(",");
/////////////////////////////////////////////////////////////////////////
0:         // TODO support Require-Capability in addition to SPI-Consumer
0:         Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(SpiFlyConstants.SPI_CONSUMER_HEADER, consumerHeader);
0: 
/////////////////////////////////////////////////////////////////////////
0:                 TCCLSetterVisitor cv = new TCCLSetterVisitor(cw, className, wd);
0:                 if (cv.isWoven()) {
0:                     b = cw.toByteArray();
0:                 } else {
0:                     // if not woven, store the original bytes
0:                     b = Streams.suck(new FileInputStream(f));
0:                 }
commit:a166d95
/////////////////////////////////////////////////////////////////////////
0:     private static void weaveJar(String jarPath) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     private static void weaveDir(File dir, String consumerHeader, String bundleClassPath) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     private static void weaveBCPJar(File jarFile, String consumerHeader) throws Exception {
commit:5c755ab
/////////////////////////////////////////////////////////////////////////
0:                 ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);
0:                 cr.accept(cv, ClassReader.SKIP_FRAMES);
commit:6591ac7
/////////////////////////////////////////////////////////////////////////
0:             // TODO support Require-Capability in addition to SPI-Consumer
0:             Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(SpiFlyConstants.SPI_CONSUMER_HEADER, consumerHeader);
commit:54f0315
/////////////////////////////////////////////////////////////////////////
0:         System.err.println("To opt-in to this process, bundles need to have the following MANIFEST.MF");
commit:2837d0c
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.Version;
/////////////////////////////////////////////////////////////////////////
0:         Version osgiVersion = Version.parseVersion(utilPkgVersion);
0: 
0:         Version minVersion = new Version(osgiVersion.getMajor(), osgiVersion.getMinor(), osgiVersion.getMicro());
0:         Version maxVersion = new Version(osgiVersion.getMajor(), osgiVersion.getMinor() + 1, 0);
0: 
0:         sb.append(minVersion);
0:         sb.append(maxVersion);
0:         sb.append(")\"");
commit:a000e34
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
0: import java.net.URL;
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             extendImportPackage(manifest);
/////////////////////////////////////////////////////////////////////////
0:     private static void extendImportPackage(Manifest manifest) throws IOException {
0:         String utilPkgVersion = getPackageVersion(Util.class);
0: 
0:         sb.append(utilPkgVersion);
0:         sb.append(utilPkgVersion);
0:     private static String getPackageVersion(Class<?> clazz) throws IOException {
0:         URL url = clazz.getResource("packageinfo");
0:         if (url == null) {
0:             throw new RuntimeException("'packageinfo' file with version information not found for package: "
0:                     + clazz.getPackage().getName());
0:         }
0:         byte[] bytes = Streams.suck(url.openStream());
0:         Properties p = new Properties();
0:         p.load(new ByteArrayInputStream(bytes));
0:         return p.getProperty("version");
commit:b1f1463
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.Constants;
/////////////////////////////////////////////////////////////////////////
0:             String bcp = manifest.getMainAttributes().getValue(Constants.BUNDLE_CLASSPATH);
0:             weaveDir(tempDir, consumerHeader, bcp);
/////////////////////////////////////////////////////////////////////////
0:     private static void weaveDir(File dir, String consumerHeader, String bundleClassPath) throws IOException {
/////////////////////////////////////////////////////////////////////////
0: 
0:         if (bundleClassPath != null) {
0:             for (String entry : bundleClassPath.split(",")) {
0:                 File jarFile = new File(dir, entry.trim());
0:                 if (jarFile.isFile()) {
0:                     weaveBCPJar(jarFile, consumerHeader);
0:                 }
0:             }
0:         }
0:     }
0: 
0:     private static void weaveBCPJar(File jarFile, String consumerHeader) throws IOException {
0:         File tempDir = new File(System.getProperty("java.io.tmpdir") + File.separator + jarFile.getName() + "_" + System.currentTimeMillis());
0:         try {
0:             Manifest manifest = unJar(jarFile, tempDir);
0:             weaveDir(tempDir, consumerHeader, null);
0:             if (!jarFile.delete()) {
0:                 throw new IOException("Could not replace file: " + jarFile);
0:             }
0: 
0:             jar(jarFile, tempDir, manifest);
0:         } finally {
0:             delTree(tempDir);
0:         }
commit:d39cf03
/////////////////////////////////////////////////////////////////////////
0:     private static final String MODIFIED_BUNDLE_SUFFIX = "_spifly.jar";
0:         System.err.println("This tool processes OSGi Bundles that use java.util.ServiceLoader.load() to");
0:         System.err.println("obtain implementations via META-INF/services. The byte code in the bundles is");
0:         System.err.println("modified so that the ThreadContextClassLoader is set appropriately for the ");
0:         System.err.println("duration of the java.util.ServiceLoader.load() call.");
0:         System.err.println("To opt-in to this process, bundles need to have the following Manifest.MF");
0:         System.err.println("header set:");
0:         System.err.println("    " + SpiFlyConstants.SPI_CONSUMER_HEADER + ": *");
0:         System.err.println("Modified bundles are written out under the following name:");
0:         System.err.println("    <original-bundle-name>" + MODIFIED_BUNDLE_SUFFIX);
0: 
0:         if (args.length < 1)
0:             usage();
0: 
0:         System.out.println("[SPI Fly Static Tool] Processing: " + jarPath);
0: 
0:         File tempDir = new File(System.getProperty("java.io.tmpdir") + File.separator + jarFile.getName() + "_" + System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0: 
0:         } else {
0:             System.out.println("[SPI Fly Static Tool] This file is not marked as an SPI Consumer.");
0:         String ip = manifest.getMainAttributes().getValue(IMPORT_PACKAGE);
/////////////////////////////////////////////////////////////////////////
0:         // Should be able to leverage the aries.osgi.version file that appears in the target directory here.
0: 
/////////////////////////////////////////////////////////////////////////
0: //
/////////////////////////////////////////////////////////////////////////
0: //
/////////////////////////////////////////////////////////////////////////
0: //        throw new IOException("This class can only be executed from inside a jar or an exploded jar file.");
0:         s += MODIFIED_BUNDLE_SUFFIX;
0: 
0: 
0:             if (className.startsWith(File.separator))
0: 
0:                 ClassWriter cw = new ClassWriter(0);
0:                 ClassVisitor cv = new TCCLSetterVisitor(cw, className, wd);
0: 
0:                 os.write(b);
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:             ensureDirectory(outDir);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 out.close();
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:     static void addToJarRecursively(JarOutputStream jar, File source, String rootDirectory) throws IOException {
0: 
0: 
0: 
0:             /* Is there any point in adding a directory beyond just taking up space?
0:                     sourceName += "/";
/////////////////////////////////////////////////////////////////////////
0: 
commit:4b6c670
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.spifly.weaver.TCCLSetterVisitor;
commit:b1379cb
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.spifly.Util;
/////////////////////////////////////////////////////////////////////////
0:     private static final String IMPORT_PACKAGE = "Import-Package";
0: 
/////////////////////////////////////////////////////////////////////////
0:         String spiFlyVersion = getMyVersion();
0:         
/////////////////////////////////////////////////////////////////////////
0:             // TODO if new packages needed then...
0:             extendImportPackage(spiFlyVersion, manifest);
/////////////////////////////////////////////////////////////////////////
0:     private static void extendImportPackage(String spiFlyVersion, Manifest manifest) {
0:         String ip = manifest.getMainAttributes().getValue(IMPORT_PACKAGE);            
0:         StringBuilder sb = new StringBuilder(ip);
0:         sb.append(",");
0:         sb.append(Util.class.getPackage().getName());
0:         sb.append(";version=\"[");
0:         sb.append(spiFlyVersion);
0:         sb.append(",");
0:         sb.append(spiFlyVersion);
0:         sb.append("]\"");
0:         manifest.getMainAttributes().putValue(IMPORT_PACKAGE, sb.toString());
0:     }
0: 
0:     private static String getMyVersion() throws IOException {
0:         // Should be able to leverage the aries.osgi.version file that appears in the target directory here. 
0:         // Need to figure that out...
0:         return "0.4.0.SNAPSHOT";
0:         
0: //        String classResource = "/" + Main.class.getName().replace(".", "/") + ".class";
0: //        URL jarUrl = Main.class.getResource(classResource);
0: //        if (jarUrl != null) {
0: //            String jarLoc = jarUrl.toExternalForm();
0: //            Manifest mf = null;
0: //            if (jarLoc.startsWith("jar:")) {
0: //                jarLoc.substring("jar:".length());
0: //                int idx = jarLoc.indexOf("!/");
0: //                if (idx >= 0) {
0: //                    jarLoc = jarLoc.substring(0, idx);
0: //                }
0: //                
0: //                JarFile jr = new JarFile(jarLoc);
0: //                mf = jr.getManifest();
0: //            } else if (jarLoc.startsWith("file:") && jarLoc.endsWith(classResource)) {
0: //                String rootDir = jarLoc.substring(0, jarLoc.length() - classResource.length());
0: //                File manifestFile = new File(rootDir + "/META-INF/MANIFEST.MF");
0: //                if (manifestFile.exists()) {
0: //                    mf = new Manifest(new FileInputStream(manifestFile));
0: //                }
0: //            }
0: //            
0: //            if (mf != null) {
0: //                String version = mf.getMainAttributes().getValue(Attributes.Name.IMPLEMENTATION_VERSION);
0: //                if (version == null)
0: //                    throw new IOException("Could not obtain the implementation version of this jar file from the manifest");
0: //                return version.trim();
0: //            }
0: //        }
0: //        throw new IOException("This class can only be executed from inside a jar or an exploded jar file."); 
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:             Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(consumerHeader);
commit:8e5a7d6
/////////////////////////////////////////////////////////////////////////
0: import java.util.jar.Attributes;
/////////////////////////////////////////////////////////////////////////
0: 
0:             manifest.getMainAttributes().remove(new Attributes.Name(SpiFlyConstants.SPI_CONSUMER_HEADER));
0:             manifest.getMainAttributes().putValue(SpiFlyConstants.PROCESSED_SPI_CONSUMER_HEADER, consumerHeader);
0:             
0:             File newJar = getNewJarFile(jarFile);
0:             jar(newJar, tempDir, manifest);
0:     }
0: 
0:     private static File getNewJarFile(File jarFile) {
0:         String s = jarFile.getAbsolutePath();
0:         int idx = s.lastIndexOf('.');
0:         s = s.substring(0, idx);
0:         s += "_spifly.jar";
0:         return new File(s);
0:         String dirName = dir.getAbsolutePath();
0:         
0:             String className = f.getAbsolutePath().substring(dirName.length());
0:             if (className.startsWith(File.separator)) 
0:                 className = className.substring(1);
0:             className = className.substring(0, className.length() - ".class".length());
0:             className = className.replace(File.separator, ".");
0:             
0:                 ClassWriter cw = new ClassWriter(0);                
0:                 ClassVisitor cv = new TCCLSetterVisitor(cw, className, wd); 
commit:fa5cfba
/////////////////////////////////////////////////////////////////////////
0:         delTree(tempDir);
/////////////////////////////////////////////////////////////////////////
0:     static void delTree(File tempDir) throws IOException {
0:         for (File f : new DirTree(tempDir).getFiles()) {
0:             if (!f.delete())
0:                 throw new IOException("Problem deleting file: " + tempDir.getAbsolutePath());
0:         }
0:     }
0: 
commit:43cb4c6
/////////////////////////////////////////////////////////////////////////
0: import java.io.InputStream;
0: import java.util.jar.JarOutputStream;
0: import org.apache.aries.spifly.ConsumerHeaderProcessor;
0: import org.apache.aries.spifly.TCCLSetterVisitor;
0: import org.apache.aries.spifly.WeavingData;
0: import org.apache.aries.spifly.api.SpiFlyConstants;
0: import org.objectweb.asm.ClassReader;
0: import org.objectweb.asm.ClassVisitor;
0: import org.objectweb.asm.ClassWriter;
/////////////////////////////////////////////////////////////////////////
0:         File tempDir = new File(System.getProperty("java.io.tmpdir") + File.separator + jarFile.getName() + "_" + System.currentTimeMillis());        
0:         Manifest manifest = unJar(jarFile, tempDir);
0:         String consumerHeader = manifest.getMainAttributes().getValue(SpiFlyConstants.SPI_CONSUMER_HEADER);
0:         if (consumerHeader != null) {
0:             weaveDir(tempDir, consumerHeader);
0:             // jar(tempDir, newJar);
0:         }
0:         // finally - clean up
0:     private static void weaveDir(File dir, String consumerHeader) throws IOException {
0:         DirTree dt = new DirTree(dir);
0:         for (File f : dt.getFiles()) {
0:             if (!f.getName().endsWith(".class"))
0:                 continue;
0:             
0:             WeavingData[] wd = ConsumerHeaderProcessor.processHeader(consumerHeader);
0:             InputStream is = new FileInputStream(f);
0:             byte[] b;
0:             try {
0:                 ClassReader cr = new ClassReader(is);
0:                 ClassWriter cw = new ClassWriter(0);
0:                 ClassVisitor cv = new TCCLSetterVisitor(cw, null, wd); 
0:                 cr.accept(cv, 0);
0:                 b = cw.toByteArray();
0:             } finally {
0:                 is.close();
0:             }
0:             
0:             OutputStream os = new FileOutputStream(f);
0:             try {
0:                 os.write(b);                
0:             } finally {
0:                 os.close();
0:             }
0:         }
0:     }
0: 
0:     static Manifest unJar(File jarFile, File tempDir) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         return manifest;
0:     }
0:     
0:     static void jar(File jarFile, File rootFile, Manifest manifest) throws IOException {
0:         JarOutputStream jos = new JarOutputStream(new FileOutputStream(jarFile), manifest);
0:         try {
0:             addToJarRecursively(jos, rootFile.getAbsoluteFile(), rootFile.getAbsolutePath());
0:         } finally {
0:             jos.close();
0:         }
0:     }
0: 
0:     static void addToJarRecursively(JarOutputStream jar, File source, String rootDirectory) throws IOException {                
0:         String sourceName = source.getAbsolutePath().replace("\\", "/");
0:         sourceName = sourceName.substring(rootDirectory.length());
0:         
0:         if (sourceName.startsWith("/")) {
0:             sourceName = sourceName.substring(1);
0:         }
0:         
0:         if ("META-INF/MANIFEST.MF".equals(sourceName))
0:             return;
0:         
0:         if (source.isDirectory()) {
0:             /* Is there any point in adding a directory beyond just taking up space? 
0:             if (!sourceName.isEmpty()) {
0:                 if (!sourceName.endsWith("/")) {
0:                     sourceName += "/";                        
0:                 }
0:                 JarEntry entry = new JarEntry(sourceName);
0:                 jar.putNextEntry(entry);
0:                 jar.closeEntry();
0:             }
0:             */
0:             for (File nested : source.listFiles()) {
0:                 addToJarRecursively(jar, nested, rootDirectory);
0:             }
0:             return;
0:         }
0:         
0:         JarEntry entry = new JarEntry(sourceName);
0:         jar.putNextEntry(entry);
0:         InputStream is = new FileInputStream(source);
0:         try {
0:             Streams.pump(is, jar);
0:         } finally {
0:             jar.closeEntry();
0:             is.close();
0:         }
commit:104d86d
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.spifly.statictool;
0: 
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.FileNotFoundException;
0: import java.io.FileOutputStream;
0: import java.io.IOException;
0: import java.io.OutputStream;
0: import java.util.jar.JarEntry;
0: import java.util.jar.JarInputStream;
0: import java.util.jar.Manifest;
0: 
0: import org.apache.aries.spifly.Streams;
0: 
0: public class Main {
0:     public static void usage() {
0:         System.err.println();
0:         System.err.println("Usage: java " + Main.class.getName() + " bundle1.jar bundle2.jar ...");
0:         System.exit(-1);
0:     }
0:     
0:     public static void main(String ... args) throws Exception {
0:         for (String arg : args) {
0:             weaveJar(arg);
0:         }
0:     }
0: 
0:     private static void weaveJar(String jarPath) throws IOException {
0:         File jarFile = new File(jarPath);
0:         File tempdir = new File(System.getProperty("java.io.tmpdir") + File.separator + jarFile.getName() + "_" + System.currentTimeMillis());        
0:         unJar(jarFile, tempdir);
0:     }
0: 
0:     static void unJar(File jarFile, File tempDir) throws IOException {
0:         ensureDirectory(tempDir);
0: 
0:         JarInputStream jis = new JarInputStream(new FileInputStream(jarFile));
0:         JarEntry je = null;
0:         while((je = jis.getNextJarEntry()) != null) {
0:             if (je.isDirectory()) {
0:                 File outDir = new File(tempDir, je.getName());
0:                 ensureDirectory(outDir);
0:                 
0:                 continue;
0:             }
0:             
0:             File outFile = new File(tempDir, je.getName());
0:             File outDir = outFile.getParentFile();
0:             ensureDirectory(outDir); 
0:             
0:             OutputStream out = new FileOutputStream(outFile);
0:             try {
0:                 Streams.pump(jis, out);
0:             } finally {
0:                 out.flush();
0:                 out.close();
0:                 jis.closeEntry();
0:             }
0:             outFile.setLastModified(je.getTime());
0:         }
0:         
0:         Manifest manifest = jis.getManifest();
0:         if (manifest != null) {
0:             File mf = new File(tempDir, "META-INF/MANIFEST.MF");
0:             File mfDir = mf.getParentFile();
0:             ensureDirectory(mfDir);
0: 
0:             OutputStream out = new FileOutputStream(mf);
0:             try {
0:                 manifest.write(out);
0:             } finally {
0:                 out.flush();
0:                 out.close();                
0:             }
0:         }
0:         
0:         jis.close();
0:     }
0: 
0:     private static void ensureDirectory(File outDir) throws IOException {
0:         if (!outDir.isDirectory())
0:             if (!outDir.mkdirs())
0:                 throw new IOException("Unable to create directory " + outDir.getAbsolutePath());
0:     }
0: }
0: 
============================================================================