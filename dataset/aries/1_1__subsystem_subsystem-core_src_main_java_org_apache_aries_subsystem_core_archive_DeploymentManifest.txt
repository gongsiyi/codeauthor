1:a14f2fd: /*
1:a14f2fd:  * Licensed under the Apache License, Version 2.0 (the "License");
1:a14f2fd:  * you may not use this file except in compliance with the License.
1:a14f2fd:  * You may obtain a copy of the License at
1:a14f2fd:  *
1:a14f2fd:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a14f2fd:  *
1:a14f2fd:  * Unless required by applicable law or agreed to in writing, software
1:a14f2fd:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a14f2fd:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a14f2fd:  * See the License for the specific language governing permissions and
1:a14f2fd:  * limitations under the License.
1:a14f2fd:  */
1:1129914: package org.apache.aries.subsystem.core.archive;
1:bda6868: 
1:1129914: import java.io.File;
1:bda6868: import java.io.FileInputStream;
1:1129914: import java.io.IOException;
1:777b216: import java.io.InputStream;
1:bda6868: import java.io.OutputStream;
1:23d86e6: import java.net.URISyntaxException;
1:777b216: import java.util.ArrayList;
1:777b216: import java.util.Collection;
1:ead9c04: import java.util.Collections;
1:bda6868: import java.util.HashMap;
1:777b216: import java.util.Iterator;
1:777b216: import java.util.List;
1:1129914: import java.util.Map;
1:bda6868: import java.util.Map.Entry;
1:bda6868: import java.util.jar.Attributes;
1:bda6868: import java.util.jar.Manifest;
1:bda6868: 
1:5bd3bf6: import org.apache.aries.subsystem.core.internal.BasicSubsystem;
1:bda6868: import org.apache.aries.util.manifest.ManifestProcessor;
1:bda6868: import org.osgi.framework.Constants;
1:777b216: import org.osgi.resource.Resource;
1:23d86e6: import org.osgi.service.resolver.ResolutionException;
1:777b216: import org.osgi.service.subsystem.Subsystem;
1:bda6868: import org.osgi.service.subsystem.SubsystemConstants;
1:bda6868: 
1:bda6868: public class DeploymentManifest {
1:35094c6: 	public static class Builder {
1:35094c6: 		private Map<String, Header<?>> headers = new HashMap<String, Header<?>>();
1:35094c6: 		
1:35094c6: 		public DeploymentManifest build() {
1:35094c6: 			return new DeploymentManifest(headers);
1:35094c6: 		}
1:777b216: 		
1:777b216: 		public Builder autostart(boolean value) {
1:777b216: 			header(new GenericHeader(ARIESSUBSYSTEM_AUTOSTART, Boolean.toString(value)));
1:777b216: 			return this;
1:777b216: 		}
1:391a1aa: 		
1:391a1aa: 		public Builder content(Resource resource, boolean referenced) {
1:777b216: 			DeployedContentHeader header = (DeployedContentHeader)headers.get(DeploymentManifest.DEPLOYED_CONTENT);
1:777b216: 			if (header == null) {
1:391a1aa: 				DeployedContentHeader.Clause clause = new DeployedContentHeader.Clause(resource, referenced);
1:391a1aa: 				header(new DeployedContentHeader(Collections.singleton(clause)));
1:777b216: 				return this;
1:777b216: 			}
1:777b216: 			DeployedContentHeader.Clause clause = header.getClause(resource);
1:777b216: 			if (clause == null) {
1:391a1aa: 				clause = new DeployedContentHeader.Clause(resource, referenced);
1:777b216: 				List<DeployedContentHeader.Clause> clauses = new ArrayList<DeployedContentHeader.Clause>(header.getClauses().size() + 1);
1:777b216: 				clauses.addAll(header.getClauses());
1:777b216: 				clauses.add(clause);
1:777b216: 				header(new DeployedContentHeader(clauses));
1:777b216: 				return this;
1:777b216: 			}
1:777b216: 			
1:777b216: 			Collection<DeployedContentHeader.Clause> clauses = new ArrayList<DeployedContentHeader.Clause>(header.getClauses());
1:777b216: 			for (Iterator<DeployedContentHeader.Clause> i = clauses.iterator(); i.hasNext();)
1:777b216: 				if (clause.equals(i.next())) {
1:777b216: 					i.remove();
1:777b216: 					break;
1:777b216: 				}
1:391a1aa: 			clauses.add(new DeployedContentHeader.Clause(resource, referenced));
1:777b216: 			header(new DeployedContentHeader(clauses));
1:777b216: 			return this;
1:777b216: 		}
1:777b216: 		
1:35094c6: 		public Builder header(Header<?> value) {
1:35094c6: 			if (value != null)
1:35094c6: 				headers.put(value.getName(), value);
1:35094c6: 			return this;
1:35094c6: 		}
1:35094c6: 		
1:777b216: 		public Builder id(long value) {
1:777b216: 			header(new GenericHeader(ARIESSUBSYSTEM_ID, Long.toString(value)));
1:777b216: 			return this;
1:777b216: 		}
1:777b216: 		
1:777b216: 		public Builder lastId(long value) {
1:777b216: 			header(new GenericHeader(ARIESSUBSYSTEM_LASTID, Long.toString(value)));
1:777b216: 			return this;
1:777b216: 		}
1:777b216: 		
1:777b216: 		public Builder location(String value) {
1:777b216: 			if (value != null)
1:69fd7d4: 				header(new AriesSubsystemLocationHeader(value));
1:777b216: 			return this;
1:777b216: 		}
1:777b216: 		
1:777b216: 		public Builder manifest(DeploymentManifest value) {
1:777b216: 			if (value != null)
1:777b216: 				for (Entry<String, Header<?>> entry : value.getHeaders().entrySet())
1:777b216: 					header(entry.getValue());
1:777b216: 			return this;
1:777b216: 		}
1:777b216: 		
1:35094c6: 		public Builder manifest(SubsystemManifest value) {
1:777b216: 			if (value != null)
1:777b216: 				for (Entry<String, Header<?>> entry : value.getHeaders().entrySet())
1:777b216: 					header(entry.getValue());
1:777b216: 			return this;
1:777b216: 		}
1:777b216: 		
1:5bd3bf6: 		public Builder parent(BasicSubsystem value, boolean referenceCount) {
1:307d743: 			AriesSubsystemParentsHeader.Clause clause = new AriesSubsystemParentsHeader.Clause(value, referenceCount);
1:307d743: 			AriesSubsystemParentsHeader header = (AriesSubsystemParentsHeader)headers.get(ARIESSUBSYSTEM_PARENTS);
1:307d743: 			if (header == null)
1:307d743: 				header(new AriesSubsystemParentsHeader(Collections.singleton(clause)));
1:307d743: 			else {
1:307d743: 				Collection<AriesSubsystemParentsHeader.Clause> clauses = new ArrayList<AriesSubsystemParentsHeader.Clause>(header.getClauses().size() + 1);
1:307d743: 				clauses.addAll(header.getClauses());
1:307d743: 				clauses.add(clause);
1:307d743: 				header(new AriesSubsystemParentsHeader(clauses));
1:307d743: 			}
1:777b216: 			return this;
1:777b216: 		}
1:777b216: 		
1:777b216: 		public Builder region(String value) {
1:777b216: 			if (value != null)
1:777b216: 				header(new GenericHeader(ARIESSUBSYSTEM_REGION, value));
1:777b216: 			return this;
1:777b216: 		}
1:777b216: 		
1:777b216: 		public Builder region(org.eclipse.equinox.region.Region value) {
1:777b216: 			if (value != null)
1:777b216: 				region(value.getName());
1:777b216: 			return this;
1:777b216: 		}
1:777b216: 		
1:777b216: 		public Builder state(Subsystem.State value) {
1:777b216: 			if (value != null)
1:777b216: 				header(new GenericHeader(ARIESSUBSYSTEM_STATE, value.toString()));
1:35094c6: 			return this;
1:35094c6: 		}
1:35094c6: 	}
1:35094c6: 	
1:bda6868: 	public static final String DEPLOYED_CONTENT = SubsystemConstants.DEPLOYED_CONTENT;
1:26123d8: 	public static final String DEPLOYMENT_MANIFESTVERSION = SubsystemConstants.DEPLOYMENT_MANIFESTVERSION;
1:bda6868: 	public static final String EXPORT_PACKAGE = Constants.EXPORT_PACKAGE;
1:bda6868: 	public static final String IMPORT_PACKAGE = Constants.IMPORT_PACKAGE;
1:26123d8: 	public static final String PROVIDE_CAPABILITY = Constants.PROVIDE_CAPABILITY;
1:bda6868: 	public static final String PROVISION_RESOURCE = SubsystemConstants.PROVISION_RESOURCE;
1:bda6868: 	public static final String REQUIRE_BUNDLE = Constants.REQUIRE_BUNDLE;
1:c1afebc: 	public static final String REQUIRE_CAPABILITY = Constants.REQUIRE_CAPABILITY;
1:097d28b: 	public static final String SUBSYSTEM_EXPORTSERVICE = SubsystemConstants.SUBSYSTEM_EXPORTSERVICE;
1:124d6a3: 	public static final String SUBSYSTEM_IMPORTSERVICE = SubsystemConstants.SUBSYSTEM_IMPORTSERVICE;
1:bda6868: 	public static final String SUBSYSTEM_SYMBOLICNAME = SubsystemConstants.SUBSYSTEM_SYMBOLICNAME;
1:bda6868: 	public static final String SUBSYSTEM_VERSION = SubsystemConstants.SUBSYSTEM_VERSION;
1:35094c6: 	
1:bda6868: 	public static final String ARIESSUBSYSTEM_AUTOSTART = "AriesSubsystem-Autostart";
1:bda6868: 	public static final String ARIESSUBSYSTEM_ID = "AriesSubsystem-Id";
1:bda6868: 	public static final String ARIESSUBSYSTEM_LASTID = "AriesSubsystem-LastId";
1:69fd7d4: 	public static final String ARIESSUBSYSTEM_LOCATION = AriesSubsystemLocationHeader.NAME;
1:777b216: 	public static final String ARIESSUBSYSTEM_PARENTS = "AriesSubsystem-Parents";
1:777b216: 	public static final String ARIESSUBSYSTEM_REGION = "AriesSubsystem-Region";
1:777b216: 	public static final String ARIESSUBSYSTEM_STATE = "AriesSubsystem-State";
1:7e004f1: 	
1:bda6868: 	private final Map<String, Header<?>> headers;
1:fc759fb: 	
1:35094c6: 	public DeploymentManifest(java.util.jar.Manifest manifest) {
1:35094c6: 		headers = new HashMap<String, Header<?>>();
1:35094c6: 		for (Entry<Object, Object> entry : manifest.getMainAttributes().entrySet()) {
1:35094c6: 			String key = String.valueOf(entry.getKey());
1:35094c6: 			if (key.equals(SubsystemManifest.SUBSYSTEM_SYMBOLICNAME))
1:35094c6: 				continue;
1:35094c6: 			headers.put(key, HeaderFactory.createHeader(key, String.valueOf(entry.getValue())));
1:35094c6: 		}
1:35094c6: 	}
1:35094c6: 	
1:777b216: 	public DeploymentManifest(File file) throws IOException {
1:777b216: 		this(new FileInputStream(file));
1:777b216: 	}
1:777b216: 	
1:777b216: 	public DeploymentManifest(InputStream in) throws IOException {
1:777b216: 		Manifest manifest = ManifestProcessor.parseManifest(in);
1:bda6868: 		Attributes attributes = manifest.getMainAttributes();
1:bda6868: 		Map<String, Header<?>> headers = new HashMap<String, Header<?>>(attributes.size() + 4); // Plus the # of potentially derived headers.
1:bda6868: 		for (Entry<Object, Object> entry : attributes.entrySet()) {
1:bda6868: 			String key = String.valueOf(entry.getKey());
1:bda6868: 			headers.put(key, HeaderFactory.createHeader(key, String.valueOf(entry.getValue())));
1:574fba9: 		}
1:bda6868: 		this.headers = Collections.unmodifiableMap(headers);
1:574fba9: 	}
1:574fba9: 	
1:bda6868: 	public DeploymentManifest(
1:bda6868: 			DeploymentManifest deploymentManifest, 
1:bda6868: 			SubsystemManifest subsystemManifest, 
1:bda6868: 			boolean autostart, 
1:bda6868: 			long id, 
1:bda6868: 			long lastId, 
1:bda6868: 			String location,
1:fc759fb: 			boolean overwrite,
1:23d86e6: 			boolean acceptDependencies) throws ResolutionException, IOException, URISyntaxException {
1:bda6868: 		Map<String, Header<?>> headers;
1:bda6868: 		if (deploymentManifest == null // We're generating a new deployment manifest.
1:bda6868: 				|| (deploymentManifest != null && overwrite)) { // A deployment manifest already exists but overwriting it with subsystem manifest content is desired.
1:f1b1384: 			headers = computeHeaders(subsystemManifest);
1:574fba9: 		}
1:bda6868: 		else {
1:bda6868: 			headers = new HashMap<String, Header<?>>(deploymentManifest.getHeaders());
1:574fba9: 		}
1:bda6868: 		// TODO DEPLOYMENT_MANIFESTVERSION
1:bda6868: 		headers.put(ARIESSUBSYSTEM_AUTOSTART, new GenericHeader(ARIESSUBSYSTEM_AUTOSTART, Boolean.toString(autostart)));
1:bda6868: 		headers.put(ARIESSUBSYSTEM_ID, new GenericHeader(ARIESSUBSYSTEM_ID, Long.toString(id)));
1:69fd7d4: 		headers.put(ARIESSUBSYSTEM_LOCATION, new AriesSubsystemLocationHeader(location));
1:bda6868: 		headers.put(ARIESSUBSYSTEM_LASTID, new GenericHeader(ARIESSUBSYSTEM_LASTID, Long.toString(lastId)));
1:bda6868: 		this.headers = Collections.unmodifiableMap(headers);
1:7e004f1: 	}
1:bda6868: 	
1:35094c6: 	private DeploymentManifest(Map<String, Header<?>> headers) {
1:35094c6: 		Map<String, Header<?>> map = new HashMap<String, Header<?>>(headers);
1:35094c6: 		this.headers = Collections.unmodifiableMap(map);
1:35094c6: 	}
1:35094c6: 	
1:bda6868: 	public DeployedContentHeader getDeployedContentHeader() {
1:bda6868: 		return (DeployedContentHeader)getHeaders().get(DEPLOYED_CONTENT);
1:7e004f1: 	}
1:bda6868: 	
1:7837a59: 	public ExportPackageHeader getExportPackageHeader() {
1:7837a59: 		return (ExportPackageHeader)getHeaders().get(EXPORT_PACKAGE);
1:7e004f1: 	}
1:7837a59: 	
1:bda6868: 	public Map<String, Header<?>> getHeaders() {
1:bda6868: 		return headers;
1:7e004f1: 	}
1:bda6868: 	
1:307d743: 	public AriesSubsystemParentsHeader getAriesSubsystemParentsHeader() {
1:307d743: 		return (AriesSubsystemParentsHeader)getHeaders().get(ARIESSUBSYSTEM_PARENTS);
1:307d743: 	}
1:307d743: 	
1:fc759fb: 	public ImportPackageHeader getImportPackageHeader() {
1:fc759fb: 		return (ImportPackageHeader)getHeaders().get(IMPORT_PACKAGE);
1:7837a59: 	}
1:fc759fb: 	
1:26123d8: 	public ProvideCapabilityHeader getProvideCapabilityHeader() {
1:26123d8: 		return (ProvideCapabilityHeader)getHeaders().get(PROVIDE_CAPABILITY);
1:26123d8: 	}
1:26123d8: 	
1:bda6868: 	public ProvisionResourceHeader getProvisionResourceHeader() {
1:bda6868: 		return (ProvisionResourceHeader)getHeaders().get(PROVISION_RESOURCE);
1:deca8ed: 	}
1:bda6868: 	
1:47d9366: 	public RequireBundleHeader getRequireBundleHeader() {
1:47d9366: 		return (RequireBundleHeader)getHeaders().get(REQUIRE_BUNDLE);
1:47d9366: 	}
1:47d9366: 	
1:c1afebc: 	public RequireCapabilityHeader getRequireCapabilityHeader() {
1:c1afebc: 		return (RequireCapabilityHeader)getHeaders().get(REQUIRE_CAPABILITY);
1:c1afebc: 	}
1:c1afebc: 	
1:097d28b: 	public SubsystemExportServiceHeader getSubsystemExportServiceHeader() {
1:097d28b: 		return (SubsystemExportServiceHeader)getHeaders().get(SUBSYSTEM_EXPORTSERVICE);
1:097d28b: 	}
1:097d28b: 	
1:124d6a3: 	public SubsystemImportServiceHeader getSubsystemImportServiceHeader() {
1:124d6a3: 		return (SubsystemImportServiceHeader)getHeaders().get(SUBSYSTEM_IMPORTSERVICE);
1:124d6a3: 	}
1:124d6a3: 	
1:bda6868: 	public void write(OutputStream out) throws IOException {
1:bda6868: 		Manifest manifest = new Manifest();
1:bda6868: 		Attributes attributes = manifest.getMainAttributes();
1:bda6868: 		// The manifest won't write anything unless the following header is present.
1:bda6868: 		attributes.put(Attributes.Name.MANIFEST_VERSION, "1.0");
1:bda6868: 		for (Entry<String, Header<?>> entry : headers.entrySet()) {
1:bda6868: 			attributes.putValue(entry.getKey(), entry.getValue().getValue());
1:fc759fb: 		}
1:bda6868: 		manifest.write(out);
2:fc759fb: 	}
1:bda6868: 	
1:f1b1384: 	private Map<String, Header<?>> computeHeaders(SubsystemManifest manifest) {
1:f1b1384: 		return new HashMap<String, Header<?>>(manifest.getHeaders());
1:fc759fb: 	}
1:2ffcfb9: 
1:2ffcfb9:     @Override
1:2ffcfb9:     public int hashCode() {
1:2ffcfb9:     	return 31 * 17 + headers.hashCode();
1:2ffcfb9:     }
1:2ffcfb9: 
1:2ffcfb9:     @Override
1:2ffcfb9:     public boolean equals(Object o) {
1:2ffcfb9:     	if (o == this) {
1:2ffcfb9:     		return true;
1:2ffcfb9:     	}
1:2ffcfb9:     	if (!(o instanceof SubsystemManifest)) {
1:2ffcfb9:     		return false;
1:2ffcfb9:     	}
1:2ffcfb9:     	DeploymentManifest that = (DeploymentManifest)o;
1:2ffcfb9:     	return that.headers.equals(this.headers);
1:2ffcfb9:     }
1:fc759fb: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:69fd7d4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				header(new AriesSubsystemLocationHeader(value));
/////////////////////////////////////////////////////////////////////////
1: 	public static final String ARIESSUBSYSTEM_LOCATION = AriesSubsystemLocationHeader.NAME;
/////////////////////////////////////////////////////////////////////////
1: 		headers.put(ARIESSUBSYSTEM_LOCATION, new AriesSubsystemLocationHeader(location));
commit:2ffcfb9
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public int hashCode() {
1:     	return 31 * 17 + headers.hashCode();
1:     }
1: 
1:     @Override
1:     public boolean equals(Object o) {
1:     	if (o == this) {
1:     		return true;
1:     	}
1:     	if (!(o instanceof SubsystemManifest)) {
1:     		return false;
1:     	}
1:     	DeploymentManifest that = (DeploymentManifest)o;
1:     	return that.headers.equals(this.headers);
1:     }
commit:5bd3bf6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.internal.BasicSubsystem;
/////////////////////////////////////////////////////////////////////////
1: 		public Builder parent(BasicSubsystem value, boolean referenceCount) {
commit:391a1aa
/////////////////////////////////////////////////////////////////////////
0: //		public Builder content(Resource resource) {
0: //			return content(resource, true);
0: //		}
1: 		
1: 		public Builder content(Resource resource, boolean referenced) {
1: 				DeployedContentHeader.Clause clause = new DeployedContentHeader.Clause(resource, referenced);
1: 				header(new DeployedContentHeader(Collections.singleton(clause)));
1: 				clause = new DeployedContentHeader.Clause(resource, referenced);
/////////////////////////////////////////////////////////////////////////
1: 			clauses.add(new DeployedContentHeader.Clause(resource, referenced));
commit:a14f2fd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
commit:2b13b05
/////////////////////////////////////////////////////////////////////////
commit:307d743
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.internal.AriesSubsystem;
/////////////////////////////////////////////////////////////////////////
0: 		public Builder parent(AriesSubsystem value, boolean referenceCount) {
1: 			AriesSubsystemParentsHeader.Clause clause = new AriesSubsystemParentsHeader.Clause(value, referenceCount);
1: 			AriesSubsystemParentsHeader header = (AriesSubsystemParentsHeader)headers.get(ARIESSUBSYSTEM_PARENTS);
1: 			if (header == null)
1: 				header(new AriesSubsystemParentsHeader(Collections.singleton(clause)));
1: 			else {
1: 				Collection<AriesSubsystemParentsHeader.Clause> clauses = new ArrayList<AriesSubsystemParentsHeader.Clause>(header.getClauses().size() + 1);
1: 				clauses.addAll(header.getClauses());
1: 				clauses.add(clause);
1: 				header(new AriesSubsystemParentsHeader(clauses));
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 	public AriesSubsystemParentsHeader getAriesSubsystemParentsHeader() {
1: 		return (AriesSubsystemParentsHeader)getHeaders().get(ARIESSUBSYSTEM_PARENTS);
1: 	}
1: 	
commit:777b216
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Iterator;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.resource.Resource;
1: import org.osgi.service.subsystem.Subsystem;
/////////////////////////////////////////////////////////////////////////
1: 		public Builder autostart(boolean value) {
1: 			header(new GenericHeader(ARIESSUBSYSTEM_AUTOSTART, Boolean.toString(value)));
1: 			return this;
1: 		}
1: 		
0: 		public Builder content(Resource resource) {
1: 			DeployedContentHeader header = (DeployedContentHeader)headers.get(DeploymentManifest.DEPLOYED_CONTENT);
1: 			if (header == null) {
0: 				header(DeployedContentHeader.newInstance(Collections.singletonList(resource)));
1: 				return this;
1: 			}
1: 			DeployedContentHeader.Clause clause = header.getClause(resource);
1: 			if (clause == null) {
0: 				clause = new DeployedContentHeader.Clause(resource);
1: 				List<DeployedContentHeader.Clause> clauses = new ArrayList<DeployedContentHeader.Clause>(header.getClauses().size() + 1);
1: 				clauses.addAll(header.getClauses());
1: 				clauses.add(clause);
1: 				header(new DeployedContentHeader(clauses));
1: 				return this;
1: 			}
1: 			
1: 			Collection<DeployedContentHeader.Clause> clauses = new ArrayList<DeployedContentHeader.Clause>(header.getClauses());
1: 			for (Iterator<DeployedContentHeader.Clause> i = clauses.iterator(); i.hasNext();)
1: 				if (clause.equals(i.next())) {
1: 					i.remove();
1: 					break;
1: 				}
0: 			clauses.add(new DeployedContentHeader.Clause(resource));
1: 			header(new DeployedContentHeader(clauses));
1: 			return this;
0: //			Attribute resourceId = clause.getAttribute(DeployedContentHeader.Clause.ATTRIBUTE_RESOURCEID);
0: //			if (resourceId == null)
0: //				clause = new DeployedContentHeader.Clause(resource);
0: //			List<DeployedContentHeader.Clause> clauses = new ArrayList<DeployedContentHeader.Clause>(header.getClauses().size() + 1);
0: //			clauses.addAll(header.getClauses());
0: //			clauses.add(clause);
0: //			header(new DeployedContentHeader(clauses));
0: //			return this;
1: 		}
1: 		
1: 		public Builder id(long value) {
1: 			header(new GenericHeader(ARIESSUBSYSTEM_ID, Long.toString(value)));
1: 			return this;
1: 		}
1: 		
1: 		public Builder lastId(long value) {
1: 			header(new GenericHeader(ARIESSUBSYSTEM_LASTID, Long.toString(value)));
1: 			return this;
1: 		}
1: 		
1: 		public Builder location(String value) {
1: 			if (value != null)
0: 				header(new GenericHeader(ARIESSUBSYSTEM_LOCATION, value));
1: 			return this;
1: 		}
1: 		
1: 		public Builder manifest(DeploymentManifest value) {
1: 			if (value != null)
1: 				for (Entry<String, Header<?>> entry : value.getHeaders().entrySet())
1: 					header(entry.getValue());
1: 			return this;
1: 		}
1: 		
1: 			if (value != null)
1: 				for (Entry<String, Header<?>> entry : value.getHeaders().entrySet())
1: 					header(entry.getValue());
1: 			return this;
1: 		}
1: 		
0: 		public Builder parent(long value) {
0: 			Header<?> parents = headers.get(ARIESSUBSYSTEM_PARENTS);
0: 			if (parents == null)
0: 				header(new GenericHeader(ARIESSUBSYSTEM_PARENTS, Long.toString(value)));
0: 			else
0: 				header(new GenericHeader(ARIESSUBSYSTEM_PARENTS, parents.getValue() + ',' + Long.toString(value)));
1: 			return this;
1: 		}
1: 		
1: 		public Builder region(String value) {
1: 			if (value != null)
1: 				header(new GenericHeader(ARIESSUBSYSTEM_REGION, value));
1: 			return this;
1: 		}
1: 		
1: 		public Builder region(org.eclipse.equinox.region.Region value) {
1: 			if (value != null)
1: 				region(value.getName());
1: 			return this;
1: 		}
1: 		
1: 		public Builder state(Subsystem.State value) {
1: 			if (value != null)
1: 				header(new GenericHeader(ARIESSUBSYSTEM_STATE, value.toString()));
/////////////////////////////////////////////////////////////////////////
1: 	public static final String ARIESSUBSYSTEM_PARENTS = "AriesSubsystem-Parents";
1: 	public static final String ARIESSUBSYSTEM_REGION = "AriesSubsystem-Region";
1: 	public static final String ARIESSUBSYSTEM_STATE = "AriesSubsystem-State";
/////////////////////////////////////////////////////////////////////////
1: 	public DeploymentManifest(File file) throws IOException {
1: 		this(new FileInputStream(file));
1: 	}
1: 	
1: 	public DeploymentManifest(InputStream in) throws IOException {
1: 		Manifest manifest = ManifestProcessor.parseManifest(in);
commit:67ef08f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:23d86e6
/////////////////////////////////////////////////////////////////////////
1: import java.net.URISyntaxException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.internal.SubsystemResolveContext;
1: import org.osgi.service.resolver.ResolutionException;
/////////////////////////////////////////////////////////////////////////
0: 			SubsystemResolveContext resolveContext,
1: 			boolean acceptDependencies) throws ResolutionException, IOException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
0: 					Resource resource = resolveContext.findResource(requirement);
/////////////////////////////////////////////////////////////////////////
0: 				resolution = Activator.getInstance().getResolver().resolve(new SubsystemResolveContext(resolveContext.getSubsystem(), resources));
commit:f1b1384
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			headers = computeHeaders(subsystemManifest);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private Map<String, Header<?>> computeHeaders(SubsystemManifest manifest) {
1: 		return new HashMap<String, Header<?>>(manifest.getHeaders());
commit:35094c6
/////////////////////////////////////////////////////////////////////////
1: 	public static class Builder {
1: 		private Map<String, Header<?>> headers = new HashMap<String, Header<?>>();
1: 		
1: 		public DeploymentManifest build() {
1: 			return new DeploymentManifest(headers);
1: 		}
1: 		
1: 		public Builder header(Header<?> value) {
1: 			if (value != null)
1: 				headers.put(value.getName(), value);
1: 			return this;
1: 		}
1: 		
1: 		public Builder manifest(SubsystemManifest value) {
0: 			for (Entry<String, Header<?>> entry : value.getHeaders().entrySet())
0: 				header(entry.getValue());
1: 			return this;
1: 		}
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	public DeploymentManifest(java.util.jar.Manifest manifest) {
1: 		headers = new HashMap<String, Header<?>>();
1: 		for (Entry<Object, Object> entry : manifest.getMainAttributes().entrySet()) {
1: 			String key = String.valueOf(entry.getKey());
1: 			if (key.equals(SubsystemManifest.SUBSYSTEM_SYMBOLICNAME))
1: 				continue;
1: 			headers.put(key, HeaderFactory.createHeader(key, String.valueOf(entry.getValue())));
1: 		}
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	private DeploymentManifest(Map<String, Header<?>> headers) {
1: 		Map<String, Header<?>> map = new HashMap<String, Header<?>>(headers);
1: 		this.headers = Collections.unmodifiableMap(map);
1: 	}
1: 	
commit:df175a6
/////////////////////////////////////////////////////////////////////////
commit:875a6d6
/////////////////////////////////////////////////////////////////////////
0: 			if (typeHeader.isApplication()) {
/////////////////////////////////////////////////////////////////////////
0: 			else if (typeHeader.isComposite()) {
commit:28c3eb7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.internal.SubsystemEnvironment;
commit:574fba9
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.namespace.BundleNamespace;
/////////////////////////////////////////////////////////////////////////
0: 					header = computeRequireBundleHeader(resolution, deployedContent, acceptDependencies);
0: 					if (header != null)
0: 						headers.put(REQUIRE_BUNDLE, header);
/////////////////////////////////////////////////////////////////////////
0: 	private static RequireBundleHeader computeRequireBundleHeader(
0: 			Map<Resource, List<Wire>> resolution, 
0: 			Collection<Resource> content,
0: 			boolean acceptDependencies) {
0: 		Collection<RequireBundleHeader.Clause> clauses = new ArrayList<RequireBundleHeader.Clause>();
0: 		for (Entry<Resource, List<Wire>> entry : resolution.entrySet()) {
0: 			for (Wire wire : entry.getValue()) {
0: 				Resource provider = wire.getProvider();
0: 				if (content.contains(provider))
0: 					// If the provider is a content resource, we don't need an import.
0: 					continue;
0: 				// The provider is a dependency that is already provisioned or needs provisioning.
0: 				if (acceptDependencies && !((provider instanceof BundleRevision) || (provider instanceof AriesSubsystem)))
0: 					// If the application accepts dependencies and the provider is a dependency that needs provisioning,
0: 					// we don't need an import.
0: 					continue;
0: 				// For all other cases, we need an import.
0: 				Requirement requirement = wire.getRequirement();
0: 				if (BundleNamespace.BUNDLE_NAMESPACE.equals(requirement.getNamespace())) {
0: 					clauses.add(new RequireBundleHeader.Clause(requirement));
1: 				}
1: 			}
1: 		}
0: 		if (clauses.isEmpty())
0: 			return null;
0: 		return new RequireBundleHeader(clauses);
1: 	}
1: 	
commit:7e004f1
/////////////////////////////////////////////////////////////////////////
0: 					header = computeRequireCapabilityHeader(resolution, deployedContent, acceptDependencies);
0: 					if (header != null)
0: 						headers.put(REQUIRE_CAPABILITY, header);
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private static RequireCapabilityHeader computeRequireCapabilityHeader(
0: 			Map<Resource, List<Wire>> resolution, 
0: 			Collection<Resource> content,
0: 			boolean acceptDependencies) {
0: 		Collection<RequireCapabilityHeader.Clause> clauses = new ArrayList<RequireCapabilityHeader.Clause>();
0: 		for (Entry<Resource, List<Wire>> entry : resolution.entrySet()) {
0: 			for (Wire wire : entry.getValue()) {
0: 				Resource provider = wire.getProvider();
0: 				if (content.contains(provider))
0: 					// If the provider is a content resource, we don't need an imported capability.
0: 					continue;
0: 				// The provider is a dependency that is already provisioned or needs provisioning.
0: 				if (acceptDependencies && !((provider instanceof BundleRevision) || (provider instanceof AriesSubsystem)))
0: 					// If the application accepts dependencies and the provider is a dependency that needs provisioning,
0: 					// we don't need an import.
0: 					continue;
0: 				// For all other cases, we need an import.
0: 				Requirement requirement = wire.getRequirement();
0: 				// TODO Not sure if the startsWith check will be sufficient.
0: 				if (!requirement.getNamespace().startsWith("osgi.")) {
0: 					clauses.add(new RequireCapabilityHeader.Clause(requirement));
1: 				}
1: 			}
1: 		}
0: 		if (clauses.isEmpty())
0: 			return null;
0: 		return new RequireCapabilityHeader(clauses);
1: 	}
commit:097d28b
/////////////////////////////////////////////////////////////////////////
1: 	public static final String SUBSYSTEM_EXPORTSERVICE = SubsystemConstants.SUBSYSTEM_EXPORTSERVICE;
/////////////////////////////////////////////////////////////////////////
0: 				header = subsystemManifest.getSubsystemExportServiceHeader();
0: 				if (header != null)
0: 					headers.put(SUBSYSTEM_EXPORTSERVICE, header);
/////////////////////////////////////////////////////////////////////////
1: 	public SubsystemExportServiceHeader getSubsystemExportServiceHeader() {
1: 		return (SubsystemExportServiceHeader)getHeaders().get(SUBSYSTEM_EXPORTSERVICE);
1: 	}
1: 	
commit:26123d8
/////////////////////////////////////////////////////////////////////////
1: 	public static final String DEPLOYMENT_MANIFESTVERSION = SubsystemConstants.DEPLOYMENT_MANIFESTVERSION;
1: 	public static final String PROVIDE_CAPABILITY = Constants.PROVIDE_CAPABILITY;
/////////////////////////////////////////////////////////////////////////
0: 				header = subsystemManifest.getProvideCapabilityHeader();
0: 				if (header != null)
0: 					headers.put(PROVIDE_CAPABILITY, header);
/////////////////////////////////////////////////////////////////////////
1: 	public ProvideCapabilityHeader getProvideCapabilityHeader() {
1: 		return (ProvideCapabilityHeader)getHeaders().get(PROVIDE_CAPABILITY);
1: 	}
1: 	
commit:7837a59
/////////////////////////////////////////////////////////////////////////
0: 				header = subsystemManifest.getExportPackageHeader();
0: 				if (header != null)
0: 					headers.put(EXPORT_PACKAGE, header);
/////////////////////////////////////////////////////////////////////////
1: 	public ExportPackageHeader getExportPackageHeader() {
1: 		return (ExportPackageHeader)getHeaders().get(EXPORT_PACKAGE);
1: 	}
1: 	
commit:47d9366
/////////////////////////////////////////////////////////////////////////
0: 				header = subsystemManifest.getRequireBundleHeader();
0: 				if (header != null)
0: 					headers.put(REQUIRE_BUNDLE, header);
/////////////////////////////////////////////////////////////////////////
1: 	public RequireBundleHeader getRequireBundleHeader() {
1: 		return (RequireBundleHeader)getHeaders().get(REQUIRE_BUNDLE);
1: 	}
1: 	
commit:124d6a3
/////////////////////////////////////////////////////////////////////////
1: 	public static final String SUBSYSTEM_IMPORTSERVICE = SubsystemConstants.SUBSYSTEM_IMPORTSERVICE;
/////////////////////////////////////////////////////////////////////////
0: 				header = subsystemManifest.getSubsystemImportServiceHeader();
0: 				if (header != null)
0: 					headers.put(SUBSYSTEM_IMPORTSERVICE, header);
/////////////////////////////////////////////////////////////////////////
1: 	public SubsystemImportServiceHeader getSubsystemImportServiceHeader() {
1: 		return (SubsystemImportServiceHeader)getHeaders().get(SUBSYSTEM_IMPORTSERVICE);
1: 	}
1: 	
commit:c1afebc
/////////////////////////////////////////////////////////////////////////
1: 	public static final String REQUIRE_CAPABILITY = Constants.REQUIRE_CAPABILITY;
/////////////////////////////////////////////////////////////////////////
0: 					Header<?> header = computeImportPackageHeader(resolution, deployedContent, acceptDependencies);
0: 				Header<?> header = subsystemManifest.getImportPackageHeader();
0: 				if (header != null)
0: 					headers.put(IMPORT_PACKAGE, header);
0: 				header = subsystemManifest.getRequireCapabilityHeader();
0: 				if (header != null)
0: 					headers.put(REQUIRE_CAPABILITY, header);
/////////////////////////////////////////////////////////////////////////
1: 	public RequireCapabilityHeader getRequireCapabilityHeader() {
1: 		return (RequireCapabilityHeader)getHeaders().get(REQUIRE_CAPABILITY);
1: 	}
1: 	
commit:deca8ed
/////////////////////////////////////////////////////////////////////////
0: 				if (resolution != null) {
0: 					ImportPackageHeader header = computeImportPackageHeader(resolution, deployedContent, acceptDependencies);
0: 					if (header != null)
0: 						headers.put(IMPORT_PACKAGE, header);
1: 				}
0: 				ImportPackageHeader importPackage = subsystemManifest.getImportPackageHeader();
0: 				if (importPackage != null)
0: 					headers.put(IMPORT_PACKAGE, importPackage);
/////////////////////////////////////////////////////////////////////////
0: 					clauses.add(new ImportPackageHeader.Clause(requirement));
0: 		if (clauses.isEmpty())
0: 			return null;
commit:71fe81a
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.resource.Requirement;
0: import org.osgi.resource.Resource;
0: import org.osgi.resource.Wire;
commit:fc759fb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.internal.AriesSubsystem;
0: import org.osgi.framework.namespace.PackageNamespace;
0: import org.osgi.framework.resource.Requirement;
0: import org.osgi.framework.wiring.BundleRevision;
/////////////////////////////////////////////////////////////////////////
1: 			boolean overwrite,
0: 			boolean acceptDependencies) {
0: 			Map<Resource, List<Wire>> resolution = null;
0: 			Collection<Resource> deployedContent = new HashSet<Resource>();
/////////////////////////////////////////////////////////////////////////
0: 				resolution = Activator.getInstance().getResolver().resolve(environment, new ArrayList<Resource>(resources), Collections.EMPTY_LIST);
/////////////////////////////////////////////////////////////////////////
0: 				if (resolution != null)
0: 					headers.put(IMPORT_PACKAGE, computeImportPackageHeader(resolution, deployedContent, acceptDependencies));
/////////////////////////////////////////////////////////////////////////
1: 	public ImportPackageHeader getImportPackageHeader() {
1: 		return (ImportPackageHeader)getHeaders().get(IMPORT_PACKAGE);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private static ImportPackageHeader computeImportPackageHeader(
0: 			Map<Resource, List<Wire>> resolution, 
0: 			Collection<Resource> content,
0: 			boolean acceptDependencies) {
0: 		Collection<ImportPackageHeader.Clause> clauses = new ArrayList<ImportPackageHeader.Clause>();
0: 		for (Entry<Resource, List<Wire>> entry : resolution.entrySet()) {
0: 			for (Wire wire : entry.getValue()) {
0: 				Resource provider = wire.getProvider();
0: 				if (content.contains(provider))
0: 					// If the provider is a content resource, we don't need an import.
0: 					continue;
0: 				// The provider is a dependency that is already provisioned or needs provisioning.
0: 				if (acceptDependencies && !((provider instanceof BundleRevision) || (provider instanceof AriesSubsystem)))
0: 					// If the application accepts dependencies and the provider is a dependency that needs provisioning,
0: 					// we don't need an import.
0: 					continue;
0: 				// For all other cases, we need an import.
0: 				Requirement requirement = wire.getRequirement();
0: 				if (PackageNamespace.PACKAGE_NAMESPACE.equals(requirement.getNamespace())) {
0: 					clauses.add(new ImportPackageRequirement(requirement).toClause());
1: 				}
1: 			}
1: 		}
0: 		return new ImportPackageHeader(clauses);
1: 	}
commit:9272a39
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.Resolver;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				Map<Resource, List<Wire>> resolution = Activator.getInstance().getResolver().resolve(environment, new ArrayList<Resource>(resources), Collections.EMPTY_LIST);
commit:b8ad309
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			if (SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(typeHeader.getValue())) {
0: 			else if (SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(typeHeader.getValue())) {
/////////////////////////////////////////////////////////////////////////
commit:bd2f017
/////////////////////////////////////////////////////////////////////////
0: 					if (resource == null) {
0: 						if (content.isMandatory())
0: 							throw new SubsystemException("Resource does not exist: " + requirement);
0: 						continue;
0: 					}
commit:bda6868
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileInputStream;
0: import java.io.FileNotFoundException;
1: import java.io.OutputStream;
1: import java.util.HashMap;
1: import java.util.Map.Entry;
1: import java.util.jar.Attributes;
1: import java.util.jar.Manifest;
1: import org.apache.aries.util.manifest.ManifestProcessor;
1: import org.osgi.framework.Constants;
1: import org.osgi.service.subsystem.SubsystemConstants;
1: public class DeploymentManifest {
1: 	public static final String DEPLOYED_CONTENT = SubsystemConstants.DEPLOYED_CONTENT;
0: 	public static final String DEPLOYED_EXPORTSERVICE = "Deployed-ExportService"; // TODO Needs constant on SubsystemConstants.
0: 	public static final String DEPLOYED_IMPORTSERVICE = "Deployed-ImportService"; // TODO Needs constant on SubsystemConstants.
0: 	public static final String DEPLOYMENT_MANIFESTVERSION = "Deployment-ManifestVersion"; // TODO Needs constant on SubsystemConstants.
1: 	public static final String EXPORT_PACKAGE = Constants.EXPORT_PACKAGE;
1: 	public static final String IMPORT_PACKAGE = Constants.IMPORT_PACKAGE;
1: 	public static final String PROVISION_RESOURCE = SubsystemConstants.PROVISION_RESOURCE;
1: 	public static final String REQUIRE_BUNDLE = Constants.REQUIRE_BUNDLE;
1: 	public static final String SUBSYSTEM_SYMBOLICNAME = SubsystemConstants.SUBSYSTEM_SYMBOLICNAME;
1: 	public static final String SUBSYSTEM_VERSION = SubsystemConstants.SUBSYSTEM_VERSION;
1: 	public static final String ARIESSUBSYSTEM_AUTOSTART = "AriesSubsystem-Autostart";
1: 	public static final String ARIESSUBSYSTEM_ID = "AriesSubsystem-Id";
1: 	public static final String ARIESSUBSYSTEM_LASTID = "AriesSubsystem-LastId";
0: 	public static final String ARIESSUBSYSTEM_LOCATION = "AriesSubsystem-Location";
1: 	private final Map<String, Header<?>> headers;
1: 	
0: 	public DeploymentManifest(File file) throws FileNotFoundException, IOException {
0: 		Manifest manifest = ManifestProcessor.parseManifest(new FileInputStream(file));
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		Map<String, Header<?>> headers = new HashMap<String, Header<?>>(attributes.size() + 4); // Plus the # of potentially derived headers.
1: 		for (Entry<Object, Object> entry : attributes.entrySet()) {
1: 			String key = String.valueOf(entry.getKey());
1: 			headers.put(key, HeaderFactory.createHeader(key, String.valueOf(entry.getValue())));
0: 		}
1: 		this.headers = Collections.unmodifiableMap(headers);
0: 	}
1: 	
0: //	public DeploymentManifest(DeploymentManifest manifest, boolean autostart, long id, long lastId, String location) {
0: //		Map<String, Header<?>> headers = new HashMap<String, Header<?>>(manifest.getHeaders());
0: //		headers.put(ARIESSUBSYSTEM_AUTOSTART, new GenericHeader(ARIESSUBSYSTEM_AUTOSTART, Boolean.toString(autostart)));
0: //		headers.put(ARIESSUBSYSTEM_ID, new GenericHeader(ARIESSUBSYSTEM_ID, Long.toString(id)));
0: //		headers.put(ARIESSUBSYSTEM_LOCATION, new GenericHeader(ARIESSUBSYSTEM_LOCATION, location));
0: //		headers.put(ARIESSUBSYSTEM_LASTID, new GenericHeader(ARIESSUBSYSTEM_LASTID, Long.toString(lastId)));
0: //		this.headers = Collections.unmodifiableMap(headers);
0: //	}
0: //	
0: //	public DeploymentManifest(SubsystemManifest manifest, SubsystemEnvironment environment) {
0: //		this(null, manifest, environment);
0: //	}
1: 	
1: 	public DeploymentManifest(
1: 			DeploymentManifest deploymentManifest, 
1: 			SubsystemManifest subsystemManifest, 
0: 			SubsystemEnvironment environment,
1: 			boolean autostart, 
1: 			long id, 
1: 			long lastId, 
1: 			String location,
0: 			boolean overwrite) {
1: 		Map<String, Header<?>> headers;
1: 		if (deploymentManifest == null // We're generating a new deployment manifest.
1: 				|| (deploymentManifest != null && overwrite)) { // A deployment manifest already exists but overwriting it with subsystem manifest content is desired.
0: 			headers = new HashMap<String, Header<?>>();
0: 			Collection<Resource> resources = new HashSet<Resource>();
0: 			SubsystemContentHeader contentHeader = subsystemManifest.getSubsystemContentHeader();
0: 			if (contentHeader != null) {
0: 				for (SubsystemContentHeader.Content content : contentHeader.getContents()) {
0: 					OsgiIdentityRequirement requirement = new OsgiIdentityRequirement(content.getName(), content.getVersionRange(), content.getType(), false);
0: 					Resource resource = environment.findResource(requirement);
0: 					// If the resource is null, can't continue.
0: 					// TODO Actually, can continue if resource is optional.
0: 					if (resource == null)
0: 						throw new SubsystemException("Resource does not exist: " + requirement);
0: 					resources.add(resource);
0: 				}
0: 				// TODO This does not validate that all content bundles were found.
0: 				Map<Resource, List<Wire>> resolution = Activator.getInstance().getServiceProvider().getService(Resolver.class).resolve(environment, new ArrayList<Resource>(resources), Collections.EMPTY_LIST);
0: 				// TODO Once we have a resolver that actually returns lists of wires, we can use them to compute other manifest headers such as Import-Package.
0: 				Collection<Resource> deployedContent = new HashSet<Resource>();
0: 				Collection<Resource> provisionResource = new HashSet<Resource>();
0: 				for (Resource resource : resolution.keySet()) {
0: 					if (contentHeader.contains(resource))
0: 						deployedContent.add(resource);
0: 					else
0: 						provisionResource.add(resource);
0: 				}
0: 				// Make sure any already resolved content resources are added back in.
0: 				deployedContent.addAll(resources);
0: 				headers.put(DEPLOYED_CONTENT, DeployedContentHeader.newInstance(deployedContent));
0: 				if (!provisionResource.isEmpty())
0: 					headers.put(PROVISION_RESOURCE, ProvisionResourceHeader.newInstance(provisionResource));
0: 			headers.put(SUBSYSTEM_SYMBOLICNAME, subsystemManifest.getSubsystemSymbolicNameHeader());
0: 			headers.put(SUBSYSTEM_VERSION, subsystemManifest.getSubsystemVersionHeader());
0: 			SubsystemTypeHeader typeHeader = subsystemManifest.getSubsystemTypeHeader();
0: 			// TODO Add to constants.
0: 			if ("osgi.application".equals(typeHeader.getValue())) {
0: 				// TODO Compute additional headers for an application.
0: 			// TODO Add to constants.
0: 			else if ("osgi.composite".equals(typeHeader.getValue())) {
0: 				// TODO Compute additional headers for a composite. 
0: 			}
0: 			// Features require no additional headers.
1: 		else {
1: 			headers = new HashMap<String, Header<?>>(deploymentManifest.getHeaders());
1: 		// TODO DEPLOYMENT_MANIFESTVERSION
1: 		headers.put(ARIESSUBSYSTEM_AUTOSTART, new GenericHeader(ARIESSUBSYSTEM_AUTOSTART, Boolean.toString(autostart)));
1: 		headers.put(ARIESSUBSYSTEM_ID, new GenericHeader(ARIESSUBSYSTEM_ID, Long.toString(id)));
0: 		headers.put(ARIESSUBSYSTEM_LOCATION, new GenericHeader(ARIESSUBSYSTEM_LOCATION, location));
1: 		headers.put(ARIESSUBSYSTEM_LASTID, new GenericHeader(ARIESSUBSYSTEM_LASTID, Long.toString(lastId)));
1: 		this.headers = Collections.unmodifiableMap(headers);
0: 	}
1: 	
0: //	public DeploymentManifest(DeploymentManifest deploymentManifest, SubsystemManifest subsystemManifest, SubsystemEnvironment environment) {
0: //		Map<String, Header<?>> headers;
0: //		if (deploymentManifest == null)
0: //			headers = new HashMap<String, Header<?>>();
0: //		else
0: //			headers = new HashMap<String, Header<?>>(deploymentManifest.getHeaders());
0: //		// TODO DEPLOYMENT_MANIFESTVERSION
0: //		Collection<Resource> resources = new HashSet<Resource>();
0: //		SubsystemContentHeader contentHeader = subsystemManifest.getSubsystemContentHeader();
0: //		if (contentHeader != null) {
0: //			for (SubsystemContentHeader.Content content : contentHeader.getContents()) {
0: //				OsgiIdentityRequirement requirement = new OsgiIdentityRequirement(content.getName(), content.getVersionRange(), content.getType(), false);
0: //				Resource resource = environment.findResource(requirement);
0: //				// If the resource is null, can't continue.
0: //				// TODO Actually, can continue if resource is optional.
0: //				if (resource == null)
0: //					throw new SubsystemException("Resource does not exist: " + requirement);
0: //				resources.add(resource);
0: //			}
0: //			// TODO This does not validate that all content bundles were found.
0: //			Map<Resource, List<Wire>> resolution = Activator.getInstance().getServiceProvider().getService(Resolver.class).resolve(environment, new ArrayList<Resource>(resources), Collections.EMPTY_LIST);
0: //			// TODO Once we have a resolver that actually returns lists of wires, we can use them to compute other manifest headers such as Import-Package.
0: //			Collection<Resource> deployedContent = new HashSet<Resource>();
0: //			Collection<Resource> provisionResource = new HashSet<Resource>();
0: //			for (Resource resource : resolution.keySet()) {
0: //				if (contentHeader.contains(resource))
0: //					deployedContent.add(resource);
0: //				else
0: //					provisionResource.add(resource);
0: //			}
0: //			// Make sure any already resolved content resources are added back in.
0: //			deployedContent.addAll(resources);
0: //			headers.put(DEPLOYED_CONTENT, DeployedContentHeader.newInstance(deployedContent));
0: //			if (!provisionResource.isEmpty())
0: //				headers.put(PROVISION_RESOURCE, ProvisionResourceHeader.newInstance(provisionResource));
0: //		}
0: //		headers.put(SUBSYSTEM_SYMBOLICNAME, subsystemManifest.getSubsystemSymbolicNameHeader());
0: //		headers.put(SUBSYSTEM_VERSION, subsystemManifest.getSubsystemVersionHeader());
0: //		SubsystemTypeHeader typeHeader = subsystemManifest.getSubsystemTypeHeader();
0: //		// TODO Add to constants.
0: //		if ("osgi.application".equals(typeHeader.getValue())) {
0: //			// TODO Compute additional headers for an application.
0: //		}
0: //		// TODO Add to constants.
0: //		else if ("osgi.composite".equals(typeHeader.getValue())) {
0: //			// TODO Compute additional headers for a composite. 
0: //		}
0: //		// Features require no additional headers.
0: //		this.headers = Collections.unmodifiableMap(headers);
0: //	}
1: 	
1: 	public DeployedContentHeader getDeployedContentHeader() {
1: 		return (DeployedContentHeader)getHeaders().get(DEPLOYED_CONTENT);
0: 	}
1: 	
1: 	public Map<String, Header<?>> getHeaders() {
1: 		return headers;
0: 	}
1: 	
1: 	public ProvisionResourceHeader getProvisionResourceHeader() {
1: 		return (ProvisionResourceHeader)getHeaders().get(PROVISION_RESOURCE);
0: 	}
1: 	
1: 	public void write(OutputStream out) throws IOException {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		// The manifest won't write anything unless the following header is present.
1: 		attributes.put(Attributes.Name.MANIFEST_VERSION, "1.0");
1: 		for (Entry<String, Header<?>> entry : headers.entrySet()) {
1: 			attributes.putValue(entry.getKey(), entry.getValue().getValue());
1: 		manifest.write(out);
commit:5725f09
/////////////////////////////////////////////////////////////////////////
0: 			Map<Resource, List<Wire>> resolution = Activator.getInstance().getServiceProvider().getService(Resolver.class).resolve(environment, new ArrayList<Resource>(resources), Collections.EMPTY_LIST);
commit:1c9c28b
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
0: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
0: 
0: import java.util.HashSet;
0: import org.apache.aries.subsystem.core.internal.OsgiIdentityCapability;
0: import org.osgi.framework.Version;
0: import org.osgi.framework.resource.Capability;
0: import org.osgi.framework.resource.Requirement;
0: import org.osgi.framework.resource.ResourceConstants;
0: import org.osgi.service.resolver.Resolver;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: public class DeploymentManifest extends Manifest implements Resource {
0: 	public static final String IDENTITY_TYPE = "org.apache.aries.subsystem.manifest.deployment";
0: 	
0: 	private static final Logger logger = LoggerFactory.getLogger(DeploymentManifest.class);
0: 	
0: 	public static DeploymentManifest newInstance(SubsystemManifest manifest, SubsystemEnvironment environment) {
0: 		if (logger.isDebugEnabled())
0: 			logger.debug(LOG_ENTRY, "newInstance", new Object[]{manifest, environment});
0: 		Collection<Resource> resources = new HashSet<Resource>();
0: 		SubsystemContentHeader contentHeader = manifest.getSubsystemContent();
0: 		if (contentHeader != null) {
0: 			for (SubsystemContentHeader.Content content : contentHeader.getContents()) {
0: 				OsgiIdentityRequirement requirement = new OsgiIdentityRequirement(content.getName(), content.getVersionRange(), content.getType(), false);
0: 				Resource resource = environment.findResource(requirement);
0: 				// If the resource is null, can't continue.
0: 				// TODO Actually, can continue if resource is optional.
0: 				if (resource == null)
0: 					throw new SubsystemException("Resource does not exist: " + requirement);
0: 				resources.add(resource);
0: 			}
0: 			// TODO This does not validate that all content bundles were found.
0: 			Map<Resource, List<Wire>> resolution = Activator.getInstance().getServiceProvider().getService(Resolver.class).resolve(environment, resources, Collections.EMPTY_LIST);
0: 			// TODO Once we have a resolver that actually returns lists of wires, we can use them to compute other manifest headers such as Import-Package.
0: 			Collection<Resource> deployedContent = new HashSet<Resource>();
0: 			Collection<Resource> provisionResource = new HashSet<Resource>();
0: 			for (Resource resource : resolution.keySet()) {
0: 				if (contentHeader.contains(resource))
0: 					deployedContent.add(resource);
0: 				else
0: 					provisionResource.add(resource);
0: 			}
0: 			// Make sure any already resolved content resources are added back in.
0: 			deployedContent.addAll(resources);
0: 			result.headers.put(DeployedContentHeader.NAME, DeployedContentHeader.newInstance(deployedContent));
0: 			if (!provisionResource.isEmpty())
0: 				result.headers.put(ProvisionResourceHeader.NAME, ProvisionResourceHeader.newInstance(provisionResource));
/////////////////////////////////////////////////////////////////////////
0: 		logger.debug(LOG_EXIT, "newInstance", result);
/////////////////////////////////////////////////////////////////////////
0: 	@Override
0: 	public List<Capability> getCapabilities(String namespace) {
0: 		List<Capability> result = new ArrayList<Capability>(1);
0: 		if (namespace == null || namespace.equals(ResourceConstants.IDENTITY_NAMESPACE)) {
0: 			OsgiIdentityCapability capability = new OsgiIdentityCapability(
0: 					this,
0: 					// TODO Reusing IDENTITY_TYPE for the symbolic name here.
0: 					// Since there's only one subsystem manifest per subsystem,
0: 					// this shouldn't cause any technical issues. However, it
0: 					// might be best to use the subsystem's symbolic name here.
0: 					// But there are issues with that as well since type is not
0: 					// part of the unique identity.
0: 					IDENTITY_TYPE,
0: 					Version.emptyVersion,
0: 					IDENTITY_TYPE);
0: 			result.add(capability);
0: 		}
0: 		return result;
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	@Override
0: 	public List<Requirement> getRequirements(String namespace) {
0: 		return Collections.emptyList();
0: 	}
0: 	
0: 	public SubsystemSymbolicNameHeader getSubsystemSymbolicName() {
0: 		return (SubsystemSymbolicNameHeader)getHeader(SubsystemSymbolicNameHeader.NAME);
0: 	}
0: 	
0: 	public SubsystemVersionHeader getSubsystemVersion() {
0: 		SubsystemVersionHeader result = (SubsystemVersionHeader)getHeader(SubsystemVersionHeader.NAME);
0: 		if (result == null)
0: 			return SubsystemVersionHeader.DEFAULT;
0: 		return result;
0: 	}
commit:0c3bb10
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.subsystem.SubsystemException;
/////////////////////////////////////////////////////////////////////////
0: 			Resource resource = environment.findResource(requirement);
0: 			// If the resource is null, can't continue.
0: 			// TODO Actually, can continue if resource is optional.
0: 			if (resource == null)
0: 				throw new SubsystemException("Resource does not exist: " + resource);
0: 			resources.add(resource);
commit:ead9c04
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
0: import org.osgi.framework.resource.Resource;
0: import org.osgi.framework.resource.Wire;
0: 	public static DeploymentManifest newInstance(Archive archive, SubsystemEnvironment environment) {
0: 		SubsystemManifest manifest = archive.getSubsystemManifest();
0: 		Collection<Resource> resources = new ArrayList<Resource>();
0: 			OsgiIdentityRequirement requirement = new OsgiIdentityRequirement(content.getName(), content.getVersionRange(), content.getType(), false);
0: 			resources.add(environment.findResource(requirement));
0: 		Map<Resource, List<Wire>> resolution = Activator.getResolver().resolve(environment, resources, Collections.EMPTY_LIST);
commit:226c63f
/////////////////////////////////////////////////////////////////////////
0: 			Requirement requirement = new OsgiIdentityRequirement(content.getName(), content.getVersionRange(), content.getType(), false);
commit:e6bf465
/////////////////////////////////////////////////////////////////////////
0: 		// TODO This does not validate that all content bundles were found.
commit:1129914
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
1: package org.apache.aries.subsystem.core.archive;
0: 
1: import java.io.File;
1: import java.io.IOException;
0: import java.io.InputStream;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.List;
1: import java.util.Map;
0: 
0: import org.apache.aries.subsystem.core.internal.Activator;
0: import org.apache.aries.subsystem.core.internal.OsgiIdentityRequirement;
0: import org.apache.aries.subsystem.core.obr.SubsystemEnvironment;
0: import org.osgi.framework.wiring.Requirement;
0: import org.osgi.framework.wiring.Resource;
0: import org.osgi.framework.wiring.Wire;
0: 
0: public class DeploymentManifest extends Manifest {
0: 	public static DeploymentManifest newInstance(SubsystemManifest manifest, SubsystemEnvironment environment) {
0: 		DeploymentManifest result = new DeploymentManifest();
0: 		result.headers.put(ManifestVersionHeader.NAME, manifest.getManifestVersion());
0: 		Collection<Requirement> requirements = new ArrayList<Requirement>();
0: 		for (SubsystemContentHeader.Content content : manifest.getSubsystemContent().getContents()) {
0: 			Requirement requirement = OsgiIdentityRequirement.newInstance(content);
0: 			requirements.add(requirement);
0: 		}
0: 		Map<Resource, List<Wire>> resolution = Activator.getResolver().resolve(environment, requirements.toArray(new Requirement[requirements.size()]));
0: 		// TODO Once we have a resolver that actually returns lists of wires, we can use them to compute other manifest headers such as Import-Package.
0: 		Collection<Resource> deployedContent = new ArrayList<Resource>();
0: 		Collection<Resource> provisionResource = new ArrayList<Resource>();
0: 		for (Resource resource : resolution.keySet()) {
0: 			if (environment.isContentResource(resource))
0: 				deployedContent.add(resource);
0: 			else
0: 				provisionResource.add(resource);
0: 		}
0: 		result.headers.put(DeployedContentHeader.NAME, DeployedContentHeader.newInstance(deployedContent));
0: 		if (!provisionResource.isEmpty())
0: 			result.headers.put(ProvisionResourceHeader.NAME, ProvisionResourceHeader.newInstance(provisionResource));
0: 		result.headers.put(SubsystemSymbolicNameHeader.NAME, manifest.getSubsystemSymbolicName());
0: 		result.headers.put(SubsystemVersionHeader.NAME, manifest.getSubsystemVersion());
0: 		SubsystemTypeHeader typeHeader = manifest.getSubsystemType();
0: 		result.headers.put(SubsystemTypeHeader.NAME, typeHeader);
0: 		// TODO Add to constants.
0: 		if ("osgi.application".equals(typeHeader.getValue())) {
0: 			// TODO Compute additional headers for an application.
0: 		}
0: 		// TODO Add to constants.
0: 		else if ("osgi.composite".equals(typeHeader.getValue())) {
0: 			// TODO Compute additional headers for a composite. 
0: 		}
0: 		// Features require no additional headers.
0: 		return result;
0: 	}
0: 	
0: 	public DeploymentManifest(File manifestFile) throws IOException {
0: 		super(manifestFile);
0: 	}
0: 	
0: 	public DeploymentManifest(InputStream in) throws IOException {
0: 		super(in);
0: 	}
0: 	
0: 	private DeploymentManifest() {}
0: 	
0: 	public DeploymentManifest(Collection<Resource> deployedContent, Collection<Resource> provisionResource) {
0: 		headers.put(ManifestVersionHeader.NAME, new ManifestVersionHeader("1.0"));
0: 		headers.put(DeployedContentHeader.NAME, DeployedContentHeader.newInstance(deployedContent));
0: 		if (!provisionResource.isEmpty())
0: 			headers.put(ProvisionResourceHeader.NAME, ProvisionResourceHeader.newInstance(provisionResource));
0: 	}
0: 	
0: 	public DeployedContentHeader getDeployedContent() {
0: 		return (DeployedContentHeader)getHeader(DeployedContentHeader.NAME);
0: 	}
0: 	
0: 	public ProvisionResourceHeader getProvisionResource() {
0: 		return (ProvisionResourceHeader)getHeader(ProvisionResourceHeader.NAME);
0: 	}
0: }
============================================================================