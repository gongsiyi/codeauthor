1:fc74a12: /**
1:fc74a12:  * Licensed to the Apache Software Foundation (ASF) under one
1:fc74a12:  * or more contributor license agreements.  See the NOTICE file
1:fc74a12:  * distributed with this work for additional information
1:fc74a12:  * regarding copyright ownership.  The ASF licenses this file
1:fc74a12:  * to you under the Apache License, Version 2.0 (the
1:fc74a12:  * "License"); you may not use this file except in compliance
1:fc74a12:  * with the License.  You may obtain a copy of the License at
1:fc74a12:  *
1:fc74a12:  *   http://www.apache.org/licenses/LICENSE-2.0
1:fc74a12:  *
1:fc74a12:  * Unless required by applicable law or agreed to in writing,
1:fc74a12:  * software distributed under the License is distributed on an
1:fc74a12:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:fc74a12:  * KIND, either express or implied.  See the License for the
1:fc74a12:  * specific language governing permissions and limitations
1:fc74a12:  * under the License.
1:fc74a12:  */
1:fc74a12: package org.apache.aries.blueprint.compendium.cm;
1:fc74a12: 
1:fc74a12: import java.io.Closeable;
1:fc74a12: import java.io.File;
1:fc74a12: import java.io.FileInputStream;
1:fc74a12: import java.io.FileNotFoundException;
1:fc74a12: import java.io.FileOutputStream;
1:fc74a12: import java.io.IOException;
1:fc74a12: import java.io.InputStream;
1:fc74a12: import java.io.OutputStream;
1:fc74a12: import java.net.MalformedURLException;
1:fc74a12: import java.net.URL;
1:fc74a12: import java.util.ArrayList;
1:fc74a12: import java.util.Arrays;
1:fc74a12: import java.util.Collection;
1:fc74a12: import java.util.Collections;
1:fc74a12: import java.util.Dictionary;
1:fc74a12: import java.util.Enumeration;
1:fc74a12: import java.util.HashMap;
1:fc74a12: import java.util.Iterator;
1:fc74a12: import java.util.List;
1:fc74a12: import java.util.Map;
1:fc74a12: import java.util.Scanner;
1:fc74a12: import java.util.jar.JarInputStream;
1:fc74a12: 
1:fc74a12: import de.kalpatec.pojosr.framework.PojoServiceRegistryFactoryImpl;
1:fc74a12: import de.kalpatec.pojosr.framework.launch.BundleDescriptor;
1:fc74a12: import de.kalpatec.pojosr.framework.launch.ClasspathScanner;
1:fc74a12: import de.kalpatec.pojosr.framework.launch.PojoServiceRegistry;
1:fc74a12: import de.kalpatec.pojosr.framework.launch.PojoServiceRegistryFactory;
1:fc74a12: import org.ops4j.pax.swissbox.tinybundles.core.TinyBundle;
1:fc74a12: import org.ops4j.pax.swissbox.tinybundles.core.TinyBundles;
1:fc74a12: import org.osgi.framework.BundleContext;
1:fc74a12: import org.osgi.framework.BundleException;
1:fc74a12: import org.osgi.framework.Constants;
1:fc74a12: import org.osgi.framework.Filter;
1:fc74a12: import org.osgi.framework.FrameworkUtil;
1:fc74a12: import org.osgi.framework.InvalidSyntaxException;
1:fc74a12: import org.osgi.framework.ServiceReference;
1:fc74a12: import org.osgi.util.tracker.ServiceTracker;
1:fc74a12: import org.slf4j.Logger;
1:fc74a12: import org.slf4j.LoggerFactory;
1:fc74a12: import org.w3c.dom.Node;
1:fc74a12: import org.w3c.dom.NodeList;
1:fc74a12: 
1:fc74a12: public final class Helper {
1:fc74a12: 
1:fc74a12:     public static final long DEFAULT_TIMEOUT = 30000;
1:fc74a12:     public static final String BUNDLE_FILTER = "(Bundle-SymbolicName=*)";
1:fc74a12:     public static final String BUNDLE_VERSION = "1.0.0";
1:fc74a12:     private static final transient Logger LOG = LoggerFactory.getLogger(Helper.class);
1:fc74a12: 
1:fc74a12:     private Helper() {
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static BundleContext createBundleContext(String name, String descriptors, boolean includeTestBundle) throws Exception {
1:fc74a12:         return createBundleContext(name, descriptors, includeTestBundle, BUNDLE_FILTER, BUNDLE_VERSION);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static BundleContext createBundleContext(String name, String descriptors, boolean includeTestBundle,
1:fc74a12:                                                     String bundleFilter, String testBundleVersion) throws Exception {
1:fc74a12:         TinyBundle bundle = null;
1:fc74a12: 
1:fc74a12:         if (includeTestBundle) {
1:fc74a12:             // add ourselves as a bundle
1:fc74a12:             bundle = createTestBundle(name, testBundleVersion, descriptors);
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         return createBundleContext(bundleFilter, new TinyBundle[] { bundle });
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static BundleContext createBundleContext(String bundleFilter, TinyBundle[] testBundles) throws Exception {
1:fc74a12:         deleteDirectory("target/bundles");
1:fc74a12:         createDirectory("target/bundles");
1:fc74a12: 
1:fc74a12:         // ensure pojosr stores bundles in an unique target directory
1:fc74a12:         System.setProperty("org.osgi.framework.storage", "target/bundles/" + System.currentTimeMillis());
1:fc74a12: 
1:fc74a12:         // get the bundles
1:fc74a12:         List<BundleDescriptor> bundles = getBundleDescriptors(bundleFilter);
1:fc74a12: 
1:07887b0:         // Add the test bundles at the beginning of the list so that they get started first.
1:07887b0:         // The reason is that the bundle tracker used by blueprint does not work well
1:07887b0:         // with pojosr because it does not support bundle hooks, so events are lost.
1:fc74a12:         if (testBundles != null) {
1:fc74a12:             for (TinyBundle bundle : testBundles) {
1:fc74a12:                 File tmp = File.createTempFile("test-", ".jar", new File("target/bundles/"));
1:fc74a12:                 tmp.delete();
1:07887b0:                 bundles.add(0, getBundleDescriptor(tmp.getPath(), bundle));
1:fc74a12:             }
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         if (LOG.isDebugEnabled()) {
1:fc74a12:             for (int i = 0; i < bundles.size(); i++) {
1:fc74a12:                 BundleDescriptor desc = bundles.get(i);
1:fc74a12:                 LOG.debug("Bundle #{} -> {}", i, desc);
1:fc74a12:             }
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         // setup pojosr to use our bundles
1:fc74a12:         Map<String, List<BundleDescriptor>> config = new HashMap<String, List<BundleDescriptor>>();
1:fc74a12:         config.put(PojoServiceRegistryFactory.BUNDLE_DESCRIPTORS, bundles);
1:fc74a12: 
1:fc74a12:         // create pojorsr osgi service registry
1:fc74a12:         PojoServiceRegistry reg = new PojoServiceRegistryFactoryImpl().newPojoServiceRegistry(config);
1:fc74a12:         return reg.getBundleContext();
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static void disposeBundleContext(BundleContext bundleContext) throws BundleException {
1:fc74a12:         try {
1:fc74a12:             if (bundleContext != null) {
1:fc74a12:                 bundleContext.getBundle().stop();
1:fc74a12:             }
1:fc74a12:         } finally {
1:fc74a12:             System.clearProperty("org.osgi.framework.storage");
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type, long timeout) {
1:fc74a12:         return getOsgiService(bundleContext, type, null, timeout);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type) {
1:fc74a12:         return getOsgiService(bundleContext, type, null, DEFAULT_TIMEOUT);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type, String filter) {
1:fc74a12:         return getOsgiService(bundleContext, type, filter, DEFAULT_TIMEOUT);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static <T> ServiceReference getOsgiServiceReference(BundleContext bundleContext, Class<T> type, String filter, long timeout) {
1:fc74a12:         ServiceTracker tracker = null;
1:fc74a12:         try {
1:fc74a12:             String flt;
1:fc74a12:             if (filter != null) {
1:fc74a12:                 if (filter.startsWith("(")) {
1:fc74a12:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")" + filter + ")";
1:fc74a12:                 } else {
1:fc74a12:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")(" + filter + "))";
1:fc74a12:                 }
1:fc74a12:             } else {
1:fc74a12:                 flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";
1:fc74a12:             }
1:fc74a12:             Filter osgiFilter = FrameworkUtil.createFilter(flt);
1:fc74a12:             tracker = new ServiceTracker(bundleContext, osgiFilter, null);
1:fc74a12:             tracker.open(true);
1:fc74a12:             // Note that the tracker is not closed to keep the reference
1:fc74a12:             // This is buggy, as the service reference may change i think
1:fc74a12:             Object svc = tracker.waitForService(timeout);
1:fc74a12:             if (svc == null) {
1:fc74a12:                 Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();
1:fc74a12:                 System.err.println("Test bundle headers: " + explode(dic));
1:fc74a12: 
1:fc74a12:                 for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, null))) {
1:fc74a12:                     System.err.println("ServiceReference: " + ref + ", bundle: " + ref.getBundle() + ", symbolicName: " + ref.getBundle().getSymbolicName());
1:fc74a12:                 }
1:fc74a12: 
1:fc74a12:                 for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, flt))) {
1:fc74a12:                     System.err.println("Filtered ServiceReference: " + ref + ", bundle: " + ref.getBundle() + ", symbolicName: " + ref.getBundle().getSymbolicName());
1:fc74a12:                 }
1:fc74a12: 
1:fc74a12:                 throw new RuntimeException("Gave up waiting for service " + flt);
1:fc74a12:             }
1:fc74a12:             return tracker.getServiceReference();
1:fc74a12:         } catch (InvalidSyntaxException e) {
1:fc74a12:             throw new IllegalArgumentException("Invalid filter", e);
1:fc74a12:         } catch (InterruptedException e) {
1:fc74a12:             throw new RuntimeException(e);
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type, String filter, long timeout) {
1:fc74a12:         ServiceTracker tracker = null;
1:fc74a12:         try {
1:fc74a12:             String flt;
1:fc74a12:             if (filter != null) {
1:fc74a12:                 if (filter.startsWith("(")) {
1:fc74a12:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")" + filter + ")";
1:fc74a12:                 } else {
1:fc74a12:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")(" + filter + "))";
1:fc74a12:                 }
1:fc74a12:             } else {
1:fc74a12:                 flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";
1:fc74a12:             }
1:fc74a12:             Filter osgiFilter = FrameworkUtil.createFilter(flt);
1:fc74a12:             tracker = new ServiceTracker(bundleContext, osgiFilter, null);
1:fc74a12:             tracker.open(true);
1:fc74a12:             // Note that the tracker is not closed to keep the reference
1:fc74a12:             // This is buggy, as the service reference may change i think
1:fc74a12:             Object svc = tracker.waitForService(timeout);
1:fc74a12:             if (svc == null) {
1:fc74a12:                 Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();
1:fc74a12:                 System.err.println("Test bundle headers: " + explode(dic));
1:fc74a12: 
1:fc74a12:                 for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, null))) {
1:fc74a12:                     System.err.println("ServiceReference: " + ref + ", bundle: " + ref.getBundle() + ", symbolicName: " + ref.getBundle().getSymbolicName());
1:fc74a12:                 }
1:fc74a12: 
1:fc74a12:                 for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, flt))) {
1:fc74a12:                     System.err.println("Filtered ServiceReference: " + ref + ", bundle: " + ref.getBundle() + ", symbolicName: " + ref.getBundle().getSymbolicName());
1:fc74a12:                 }
1:fc74a12: 
1:fc74a12:                 throw new RuntimeException("Gave up waiting for service " + flt);
1:fc74a12:             }
1:fc74a12:             return type.cast(svc);
1:fc74a12:         } catch (InvalidSyntaxException e) {
1:fc74a12:             throw new IllegalArgumentException("Invalid filter", e);
1:fc74a12:         } catch (InterruptedException e) {
1:fc74a12:             throw new RuntimeException(e);
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     protected static TinyBundle createTestBundle(String name, String version, String descriptors) throws FileNotFoundException, MalformedURLException {
1:fc74a12:         TinyBundle bundle = TinyBundles.newBundle();
1:fc74a12:         for (URL url : getBlueprintDescriptors(descriptors)) {
1:fc74a12:             LOG.info("Using Blueprint XML file: " + url.getFile());
1:fc74a12:             bundle.add("OSGI-INF/blueprint/blueprint-" + url.getFile().replace("/", "-"), url);
1:fc74a12:         }
1:fc74a12:         bundle.set("Manifest-Version", "2")
1:fc74a12:                 .set("Bundle-ManifestVersion", "2")
1:fc74a12:                 .set("Bundle-SymbolicName", name)
1:fc74a12:                 .set("Bundle-Version", version);
1:fc74a12:         return bundle;
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Explode the dictionary into a <code>,</code> delimited list of <code>key=value</code> pairs.
1:fc74a12:      */
1:fc74a12:     private static String explode(Dictionary<?, ?> dictionary) {
1:fc74a12:         Enumeration<?> keys = dictionary.keys();
1:fc74a12:         StringBuffer result = new StringBuffer();
1:fc74a12:         while (keys.hasMoreElements()) {
1:fc74a12:             Object key = keys.nextElement();
1:fc74a12:             result.append(String.format("%s=%s", key, dictionary.get(key)));
1:fc74a12:             if (keys.hasMoreElements()) {
1:fc74a12:                 result.append(", ");
1:fc74a12:             }
1:fc74a12:         }
1:fc74a12:         return result.toString();
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Provides an iterable collection of references, even if the original array is <code>null</code>.
1:fc74a12:      */
1:fc74a12:     private static Collection<ServiceReference> asCollection(ServiceReference[] references) {
1:fc74a12:         return references  == null ? new ArrayList<ServiceReference>(0) : Arrays.asList(references);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Gets list of bundle descriptors.
1:fc74a12:      * @param bundleFilter Filter expression for OSGI bundles.
1:fc74a12:      *
1:fc74a12:      * @return List pointers to OSGi bundles.
1:fc74a12:      * @throws Exception If looking up the bundles fails.
1:fc74a12:      */
1:fc74a12:     private static List<BundleDescriptor> getBundleDescriptors(final String bundleFilter) throws Exception {
1:fc74a12:         return new ClasspathScanner().scanForBundles(bundleFilter);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Gets the bundle descriptors as {@link URL} resources.
1:fc74a12:      *
1:fc74a12:      * @param descriptors the bundle descriptors, can be separated by comma
1:fc74a12:      * @return the bundle descriptors.
1:fc74a12:      * @throws FileNotFoundException is thrown if a bundle descriptor cannot be found
1:fc74a12:      */
1:fc74a12:     private static Collection<URL> getBlueprintDescriptors(String descriptors) throws FileNotFoundException, MalformedURLException {
1:fc74a12:         List<URL> answer = new ArrayList<URL>();
1:fc74a12:         String descriptor = descriptors;
1:fc74a12:         if (descriptor != null) {
1:fc74a12:             // there may be more resources separated by comma
1:fc74a12:             Iterator<Object> it = createIterator(descriptor);
1:fc74a12:             while (it.hasNext()) {
1:fc74a12:                 String s = (String) it.next();
1:fc74a12:                 LOG.trace("Resource descriptor: {}", s);
1:fc74a12: 
1:fc74a12:                 // remove leading / to be able to load resource from the classpath
1:fc74a12:                 s = stripLeadingSeparator(s);
1:fc74a12: 
1:fc74a12:                 // if there is wildcards for *.xml then we need to find the urls from the package
1:fc74a12:                 if (s.endsWith("*.xml")) {
1:fc74a12:                     String packageName = s.substring(0, s.length() - 5);
1:fc74a12:                     // remove trailing / to be able to load resource from the classpath
1:fc74a12:                     Enumeration<URL> urls = loadResourcesAsURL(packageName);
1:fc74a12:                     while (urls.hasMoreElements()) {
1:fc74a12:                         URL url = urls.nextElement();
1:fc74a12:                         File dir = new File(url.getFile());
1:fc74a12:                         if (dir.isDirectory()) {
1:fc74a12:                             File[] files = dir.listFiles();
1:fc74a12:                             if (files != null) {
1:fc74a12:                                 for (File file : files) {
1:fc74a12:                                     if (file.isFile() && file.exists() && file.getName().endsWith(".xml")) {
1:fc74a12:                                         String name = packageName + file.getName();
1:fc74a12:                                         LOG.debug("Resolving resource: {}", name);
1:fc74a12:                                         URL xmlUrl = loadResourceAsURL(name);
1:fc74a12:                                         if (xmlUrl != null) {
1:fc74a12:                                             answer.add(xmlUrl);
1:fc74a12:                                         }
1:fc74a12:                                     }
1:fc74a12:                                 }
1:fc74a12:                             }
1:fc74a12:                         }
1:fc74a12:                     }
1:fc74a12:                 } else {
1:fc74a12:                     LOG.debug("Resolving resource: {}", s);
1:fc74a12:                     URL url = resolveMandatoryResourceAsUrl(s);
1:fc74a12:                     if (url == null) {
1:fc74a12:                         throw new FileNotFoundException("Resource " + s + " not found");
1:fc74a12:                     }
1:fc74a12:                     answer.add(url);
1:fc74a12:                 }
1:fc74a12:             }
1:fc74a12:         } else {
1:fc74a12:             throw new IllegalArgumentException("No bundle descriptor configured. Override getBlueprintDescriptor() or getBlueprintDescriptors() method");
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         if (answer.isEmpty()) {
1:fc74a12:             throw new IllegalArgumentException("Cannot find any resources in classpath from descriptor " + descriptors);
1:fc74a12:         }
1:fc74a12:         return answer;
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     private static BundleDescriptor getBundleDescriptor(String path, TinyBundle bundle) throws Exception {
1:fc74a12:         File file = new File(path);
1:fc74a12:         FileOutputStream fos = new FileOutputStream(file, true);
1:fc74a12:         try {
1:fc74a12:             copy(bundle.build(), fos);
1:fc74a12:         } finally {
1:fc74a12:             close(fos);
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         FileInputStream fis = null;
1:fc74a12:         JarInputStream jis = null;
1:fc74a12:         try {
1:fc74a12:             fis = new FileInputStream(file);
1:fc74a12:             jis = new JarInputStream(fis);
1:fc74a12:             Map<String, String> headers = new HashMap<String, String>();
1:fc74a12:             for (Map.Entry<Object, Object> entry : jis.getManifest().getMainAttributes().entrySet()) {
1:fc74a12:                 headers.put(entry.getKey().toString(), entry.getValue().toString());
1:fc74a12:             }
1:fc74a12: 
1:fc74a12:             return new BundleDescriptor(
1:fc74a12:                     bundle.getClass().getClassLoader(),
1:fc74a12:                     new URL("jar:" + file.toURI().toString() + "!/"),
1:fc74a12:                     headers);
1:fc74a12:         } finally {
1:fc74a12:             close(fis, jis);
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Closes the given resource if it is available, logging any closing exceptions to the given log.
1:fc74a12:      *
1:fc74a12:      * @param closeable the object to close
1:fc74a12:      * @param name the name of the resource
1:fc74a12:      * @param log the log to use when reporting closure warnings, will use this class's own {@link Logger} if <tt>log == null</tt>
1:fc74a12:      */
1:fc74a12:     public static void close(Closeable closeable, String name, Logger log) {
1:fc74a12:         if (closeable != null) {
1:fc74a12:             try {
1:fc74a12:                 closeable.close();
1:fc74a12:             } catch (IOException e) {
1:fc74a12:                 if (log == null) {
1:fc74a12:                     // then fallback to use the own Logger
1:fc74a12:                     log = LOG;
1:fc74a12:                 }
1:fc74a12:                 if (name != null) {
1:fc74a12:                     log.warn("Cannot close: " + name + ". Reason: " + e.getMessage(), e);
1:fc74a12:                 } else {
1:fc74a12:                     log.warn("Cannot close. Reason: " + e.getMessage(), e);
1:fc74a12:                 }
1:fc74a12:             }
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Closes the given resource if it is available.
1:fc74a12:      *
1:fc74a12:      * @param closeable the object to close
1:fc74a12:      * @param name the name of the resource
1:fc74a12:      */
1:fc74a12:     public static void close(Closeable closeable, String name) {
1:fc74a12:         close(closeable, name, LOG);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Closes the given resource if it is available.
1:fc74a12:      *
1:fc74a12:      * @param closeable the object to close
1:fc74a12:      */
1:fc74a12:     public static void close(Closeable closeable) {
1:fc74a12:         close(closeable, null, LOG);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Closes the given resources if they are available.
1:fc74a12:      *
1:fc74a12:      * @param closeables the objects to close
1:fc74a12:      */
1:fc74a12:     public static void close(Closeable... closeables) {
1:fc74a12:         for (Closeable closeable : closeables) {
1:fc74a12:             close(closeable);
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;
1:fc74a12:     private static final String DEFAULT_DELIMITER = ",";
1:fc74a12: 
1:fc74a12:     public static int copy(InputStream input, OutputStream output) throws IOException {
1:fc74a12:         return copy(input, output, DEFAULT_BUFFER_SIZE);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static int copy(final InputStream input, final OutputStream output, int bufferSize) throws IOException {
1:fc74a12:         int avail = input.available();
1:fc74a12:         if (avail > 262144) {
1:fc74a12:             avail = 262144;
1:fc74a12:         }
1:fc74a12:         if (avail > bufferSize) {
1:fc74a12:             bufferSize = avail;
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         final byte[] buffer = new byte[bufferSize];
1:fc74a12:         int n = input.read(buffer);
1:fc74a12:         int total = 0;
1:fc74a12:         while (-1 != n) {
1:fc74a12:             output.write(buffer, 0, n);
1:fc74a12:             total += n;
1:fc74a12:             n = input.read(buffer);
1:fc74a12:         }
1:fc74a12:         output.flush();
1:fc74a12:         return total;
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Creates an iterator over the value if the value is a collection, an
1:fc74a12:      * Object[], a String with values separated by comma,
1:fc74a12:      * or a primitive type array; otherwise to simplify the caller's code,
1:fc74a12:      * we just create a singleton collection iterator over a single value
1:fc74a12:      * <p/>
1:fc74a12:      * Will default use comma for String separating String values.
1:fc74a12:      * This method does <b>not</b> allow empty values
1:fc74a12:      *
1:fc74a12:      * @param value  the value
1:fc74a12:      * @return the iterator
1:fc74a12:      */
1:fc74a12:     public static Iterator<Object> createIterator(Object value) {
1:fc74a12:         return createIterator(value, DEFAULT_DELIMITER);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Creates an iterator over the value if the value is a collection, an
1:fc74a12:      * Object[], a String with values separated by the given delimiter,
1:fc74a12:      * or a primitive type array; otherwise to simplify the caller's
1:fc74a12:      * code, we just create a singleton collection iterator over a single value
1:fc74a12:      * <p/>
1:fc74a12:      * This method does <b>not</b> allow empty values
1:fc74a12:      *
1:fc74a12:      * @param value      the value
1:fc74a12:      * @param delimiter  delimiter for separating String values
1:fc74a12:      * @return the iterator
1:fc74a12:      */
1:fc74a12:     public static Iterator<Object> createIterator(Object value, String delimiter) {
1:fc74a12:         return createIterator(value, delimiter, false);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Creates an iterator over the value if the value is a collection, an
1:fc74a12:      * Object[], a String with values separated by the given delimiter,
1:fc74a12:      * or a primitive type array; otherwise to simplify the caller's
1:fc74a12:      * code, we just create a singleton collection iterator over a single value
1:fc74a12:      *
1:fc74a12:      * @param value             the value
1:fc74a12:      * @param delimiter         delimiter for separating String values
1:fc74a12:      * @param allowEmptyValues  whether to allow empty values
1:fc74a12:      * @return the iterator
1:fc74a12:      */
1:fc74a12:     @SuppressWarnings("unchecked")
1:fc74a12:     public static Iterator<Object> createIterator(Object value, String delimiter, final boolean allowEmptyValues) {
1:fc74a12:         if (value == null) {
1:fc74a12:             return Collections.emptyList().iterator();
1:fc74a12:         } else if (value instanceof Iterator) {
1:fc74a12:             return (Iterator<Object>)value;
1:fc74a12:         } else if (value instanceof Iterable) {
1:fc74a12:             return ((Iterable<Object>)value).iterator();
1:fc74a12:         } else if (value.getClass().isArray()) {
1:fc74a12:             // TODO we should handle primitive array types?
1:fc74a12:             List<Object> list = Arrays.asList((Object[])value);
1:fc74a12:             return list.iterator();
1:fc74a12:         } else if (value instanceof NodeList) {
1:fc74a12:             // lets iterate through DOM results after performing XPaths
1:fc74a12:             final NodeList nodeList = (NodeList) value;
1:fc74a12:             return cast(new Iterator<Node>() {
1:fc74a12:                 int idx = -1;
1:fc74a12: 
1:fc74a12:                 public boolean hasNext() {
1:fc74a12:                     return (idx + 1) < nodeList.getLength();
1:fc74a12:                 }
1:fc74a12: 
1:fc74a12:                 public Node next() {
1:fc74a12:                     idx++;
1:fc74a12:                     return nodeList.item(idx);
1:fc74a12:                 }
1:fc74a12: 
1:fc74a12:                 public void remove() {
1:fc74a12:                     throw new UnsupportedOperationException();
1:fc74a12:                 }
1:fc74a12:             });
1:fc74a12:         } else if (value instanceof String) {
1:fc74a12:             final String s = (String) value;
1:fc74a12: 
1:fc74a12:             // this code is optimized to only use a Scanner if needed, eg there is a delimiter
1:fc74a12: 
1:fc74a12:             if (delimiter != null && s.contains(delimiter)) {
1:fc74a12:                 // use a scanner if it contains the delimiter
1:fc74a12:                 Scanner scanner = new Scanner((String)value);
1:fc74a12: 
1:fc74a12:                 if (DEFAULT_DELIMITER.equals(delimiter)) {
1:fc74a12:                     // we use the default delimiter which is a comma, then cater for bean expressions with OGNL
1:fc74a12:                     // which may have balanced parentheses pairs as well.
1:fc74a12:                     // if the value contains parentheses we need to balance those, to avoid iterating
1:fc74a12:                     // in the middle of parentheses pair, so use this regular expression (a bit hard to read)
1:fc74a12:                     // the regexp will split by comma, but honor parentheses pair that may include commas
1:fc74a12:                     // as well, eg if value = "bean=foo?method=killer(a,b),bean=bar?method=great(a,b)"
1:fc74a12:                     // then the regexp will split that into two:
1:fc74a12:                     // -> bean=foo?method=killer(a,b)
1:fc74a12:                     // -> bean=bar?method=great(a,b)
1:fc74a12:                     // http://stackoverflow.com/questions/1516090/splitting-a-title-into-separate-parts
1:fc74a12:                     delimiter = ",(?!(?:[^\\(,]|[^\\)],[^\\)])+\\))";
1:fc74a12:                 }
1:fc74a12: 
1:fc74a12:                 scanner.useDelimiter(delimiter);
1:fc74a12:                 return cast(scanner);
1:fc74a12:             } else {
1:fc74a12:                 // use a plain iterator that returns the value as is as there are only a single value
1:fc74a12:                 return cast(new Iterator<String>() {
1:fc74a12:                     int idx = -1;
1:fc74a12: 
1:fc74a12:                     public boolean hasNext() {
1:fc74a12:                         return idx + 1 == 0 && (allowEmptyValues || isNotEmpty(s));
1:fc74a12:                     }
1:fc74a12: 
1:fc74a12:                     public String next() {
1:fc74a12:                         idx++;
1:fc74a12:                         return s;
1:fc74a12:                     }
1:fc74a12: 
1:fc74a12:                     public void remove() {
1:fc74a12:                         throw new UnsupportedOperationException();
1:fc74a12:                     }
1:fc74a12:                 });
1:fc74a12:             }
1:fc74a12:         } else {
1:fc74a12:             return Collections.singletonList(value).iterator();
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Tests whether the value is <b>not</b> <tt>null</tt> or an empty string.
1:fc74a12:      *
1:fc74a12:      * @param value  the value, if its a String it will be tested for text length as well
1:fc74a12:      * @return true if <b>not</b> empty
1:fc74a12:      */
1:fc74a12:     public static boolean isNotEmpty(Object value) {
1:fc74a12:         if (value == null) {
1:fc74a12:             return false;
1:fc74a12:         } else if (value instanceof String) {
1:fc74a12:             String text = (String) value;
1:fc74a12:             return text.trim().length() > 0;
1:fc74a12:         } else {
1:fc74a12:             return true;
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static <T> Iterator<T> cast(Iterator<?> p) {
1:fc74a12:         return (Iterator<T>) p;
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Strip any leading separators
1:fc74a12:      */
1:fc74a12:     public static String stripLeadingSeparator(String name) {
1:fc74a12:         if (name == null) {
1:fc74a12:             return null;
1:fc74a12:         }
1:fc74a12:         while (name.startsWith("/") || name.startsWith(File.separator)) {
1:fc74a12:             name = name.substring(1);
1:fc74a12:         }
1:fc74a12:         return name;
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Attempts to load the given resources from the given package name using the thread context
1:fc74a12:      * class loader or the class loader used to load this class
1:fc74a12:      *
1:fc74a12:      * @param packageName the name of the package to load its resources
1:fc74a12:      * @return the URLs for the resources or null if it could not be loaded
1:fc74a12:      */
1:fc74a12:     public static Enumeration<URL> loadResourcesAsURL(String packageName) {
1:fc74a12:         Enumeration<URL> url = null;
1:fc74a12: 
1:fc74a12:         ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
1:fc74a12:         if (contextClassLoader != null) {
1:fc74a12:             try {
1:fc74a12:                 url = contextClassLoader.getResources(packageName);
1:fc74a12:             } catch (IOException e) {
1:fc74a12:                 // ignore
1:fc74a12:             }
1:fc74a12:         }
1:fc74a12:         if (url == null) {
1:fc74a12:             try {
1:fc74a12:                 url = Helper.class.getClassLoader().getResources(packageName);
1:fc74a12:             } catch (IOException e) {
1:fc74a12:                 // ignore
1:fc74a12:             }
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         return url;
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Attempts to load the given resource as a stream using the thread context
1:fc74a12:      * class loader or the class loader used to load this class
1:fc74a12:      *
1:fc74a12:      * @param name the name of the resource to load
1:fc74a12:      * @return the stream or null if it could not be loaded
1:fc74a12:      */
1:fc74a12:     public static URL loadResourceAsURL(String name) {
1:fc74a12:         URL url = null;
1:fc74a12: 
1:fc74a12:         String resolvedName = resolveUriPath(name);
1:fc74a12:         ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
1:fc74a12:         if (contextClassLoader != null) {
1:fc74a12:             url = contextClassLoader.getResource(resolvedName);
1:fc74a12:         }
1:fc74a12:         if (url == null) {
1:fc74a12:             url = Helper.class.getClassLoader().getResource(resolvedName);
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         return url;
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Helper operation used to remove relative path notation from
1:fc74a12:      * resources.  Most critical for resources on the Classpath
1:fc74a12:      * as resource loaders will not resolve the relative paths correctly.
1:fc74a12:      *
1:fc74a12:      * @param name the name of the resource to load
1:fc74a12:      * @return the modified or unmodified string if there were no changes
1:fc74a12:      */
1:fc74a12:     private static String resolveUriPath(String name) {
1:fc74a12:         String answer = name;
1:fc74a12:         if (answer.indexOf("//") > -1) {
1:fc74a12:             answer = answer.replaceAll("//", "/");
1:fc74a12:         }
1:fc74a12:         if (answer.indexOf("../") > -1) {
1:fc74a12:             answer = answer.replaceAll("[A-Za-z0-9]*/\\.\\./", "");
1:fc74a12:         }
1:fc74a12:         if (answer.indexOf("./") > -1) {
1:fc74a12:             answer = answer.replaceAll("\\./", "");
1:fc74a12:         }
1:fc74a12:         return answer;
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Resolves the mandatory resource.
1:fc74a12:      *
1:fc74a12:      * @param uri uri of the resource
1:fc74a12:      * @return the resource as an {@link InputStream}.  Remember to close this stream after usage.
1:fc74a12:      * @throws java.io.FileNotFoundException is thrown if the resource file could not be found
1:fc74a12:      * @throws java.net.MalformedURLException if the URI is malformed
1:fc74a12:      */
1:fc74a12:     public static URL resolveMandatoryResourceAsUrl(String uri) throws FileNotFoundException, MalformedURLException {
1:fc74a12:         if (uri.startsWith("file:")) {
1:fc74a12:             // check if file exists first
1:fc74a12:             String name = after(uri, "file:");
1:fc74a12:             File file = new File(name);
1:fc74a12:             if (!file.exists()) {
1:fc74a12:                 throw new FileNotFoundException("File " + file + " not found");
1:fc74a12:             }
1:fc74a12:             return new URL(uri);
1:fc74a12:         } else if (uri.startsWith("http:")) {
1:fc74a12:             return new URL(uri);
1:fc74a12:         } else if (uri.startsWith("classpath:")) {
1:fc74a12:             uri = after(uri, "classpath:");
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         // load from classpath by default
1:fc74a12:         URL url = loadResourceAsURL(uri);
1:fc74a12:         if (url == null) {
1:fc74a12:             throw new FileNotFoundException("Cannot find resource in classpath for URI: " + uri);
1:fc74a12:         } else {
1:fc74a12:             return url;
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static String after(String text, String after) {
1:fc74a12:         if (!text.contains(after)) {
1:fc74a12:             return null;
1:fc74a12:         }
1:fc74a12:         return text.substring(text.indexOf(after) + after.length());
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Recursively delete a directory, useful to zapping test data
1:fc74a12:      *
1:fc74a12:      * @param file the directory to be deleted
1:fc74a12:      * @return <tt>false</tt> if error deleting directory
1:fc74a12:      */
1:fc74a12:     public static boolean deleteDirectory(String file) {
1:fc74a12:         return deleteDirectory(new File(file));
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * Recursively delete a directory, useful to zapping test data
1:fc74a12:      *
1:fc74a12:      * @param file the directory to be deleted
1:fc74a12:      * @return <tt>false</tt> if error deleting directory
1:fc74a12:      */
1:fc74a12:     public static boolean deleteDirectory(File file) {
1:fc74a12:         int tries = 0;
1:fc74a12:         int maxTries = 5;
1:fc74a12:         boolean exists = true;
1:fc74a12:         while (exists && (tries < maxTries)) {
1:fc74a12:             recursivelyDeleteDirectory(file);
1:fc74a12:             tries++;
1:fc74a12:             exists = file.exists();
1:fc74a12:             if (exists) {
1:fc74a12:                 try {
1:fc74a12:                     Thread.sleep(1000);
1:fc74a12:                 } catch (InterruptedException e) {
1:fc74a12:                     // Ignore
1:fc74a12:                 }
1:fc74a12:             }
1:fc74a12:         }
1:fc74a12:         return !exists;
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     private static void recursivelyDeleteDirectory(File file) {
1:fc74a12:         if (!file.exists()) {
1:fc74a12:             return;
1:fc74a12:         }
1:fc74a12: 
1:fc74a12:         if (file.isDirectory()) {
1:fc74a12:             File[] files = file.listFiles();
1:fc74a12:             for (File child : files) {
1:fc74a12:                 recursivelyDeleteDirectory(child);
1:fc74a12:             }
1:fc74a12:         }
1:fc74a12:         boolean success = file.delete();
1:fc74a12:         if (!success) {
1:fc74a12:             LOG.warn("Deletion of file: " + file.getAbsolutePath() + " failed");
1:fc74a12:         }
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     /**
1:fc74a12:      * create the directory
1:fc74a12:      *
1:fc74a12:      * @param file the directory to be created
1:fc74a12:      */
1:fc74a12:     public static void createDirectory(String file) {
1:fc74a12:         File dir = new File(file);
1:fc74a12:         dir.mkdirs();
1:fc74a12:     }
1:fc74a12: 
1:fc74a12: 
1:fc74a12: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:07887b0
/////////////////////////////////////////////////////////////////////////
1:         // Add the test bundles at the beginning of the list so that they get started first.
1:         // The reason is that the bundle tracker used by blueprint does not work well
1:         // with pojosr because it does not support bundle hooks, so events are lost.
1:                 bundles.add(0, getBundleDescriptor(tmp.getPath(), bundle));
commit:fc74a12
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.blueprint.compendium.cm;
1: 
1: import java.io.Closeable;
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileNotFoundException;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.net.MalformedURLException;
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Scanner;
1: import java.util.jar.JarInputStream;
1: 
1: import de.kalpatec.pojosr.framework.PojoServiceRegistryFactoryImpl;
1: import de.kalpatec.pojosr.framework.launch.BundleDescriptor;
1: import de.kalpatec.pojosr.framework.launch.ClasspathScanner;
1: import de.kalpatec.pojosr.framework.launch.PojoServiceRegistry;
1: import de.kalpatec.pojosr.framework.launch.PojoServiceRegistryFactory;
1: import org.ops4j.pax.swissbox.tinybundles.core.TinyBundle;
1: import org.ops4j.pax.swissbox.tinybundles.core.TinyBundles;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleException;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.Filter;
1: import org.osgi.framework.FrameworkUtil;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.util.tracker.ServiceTracker;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: import org.w3c.dom.Node;
1: import org.w3c.dom.NodeList;
1: 
1: public final class Helper {
1: 
1:     public static final long DEFAULT_TIMEOUT = 30000;
1:     public static final String BUNDLE_FILTER = "(Bundle-SymbolicName=*)";
1:     public static final String BUNDLE_VERSION = "1.0.0";
1:     private static final transient Logger LOG = LoggerFactory.getLogger(Helper.class);
1: 
1:     private Helper() {
1:     }
1: 
1:     public static BundleContext createBundleContext(String name, String descriptors, boolean includeTestBundle) throws Exception {
1:         return createBundleContext(name, descriptors, includeTestBundle, BUNDLE_FILTER, BUNDLE_VERSION);
1:     }
1: 
1:     public static BundleContext createBundleContext(String name, String descriptors, boolean includeTestBundle,
1:                                                     String bundleFilter, String testBundleVersion) throws Exception {
1:         TinyBundle bundle = null;
1: 
1:         if (includeTestBundle) {
1:             // add ourselves as a bundle
1:             bundle = createTestBundle(name, testBundleVersion, descriptors);
1:         }
1: 
1:         return createBundleContext(bundleFilter, new TinyBundle[] { bundle });
1:     }
1: 
1:     public static BundleContext createBundleContext(String bundleFilter, TinyBundle[] testBundles) throws Exception {
1:         deleteDirectory("target/bundles");
1:         createDirectory("target/bundles");
1: 
1:         // ensure pojosr stores bundles in an unique target directory
1:         System.setProperty("org.osgi.framework.storage", "target/bundles/" + System.currentTimeMillis());
1: 
1:         // get the bundles
1:         List<BundleDescriptor> bundles = getBundleDescriptors(bundleFilter);
1: 
1:         if (testBundles != null) {
1:             for (TinyBundle bundle : testBundles) {
1:                 File tmp = File.createTempFile("test-", ".jar", new File("target/bundles/"));
1:                 tmp.delete();
0:                 bundles.add(getBundleDescriptor(tmp.getPath(), bundle));
1:             }
1:         }
1: 
1:         if (LOG.isDebugEnabled()) {
1:             for (int i = 0; i < bundles.size(); i++) {
1:                 BundleDescriptor desc = bundles.get(i);
1:                 LOG.debug("Bundle #{} -> {}", i, desc);
1:             }
1:         }
1: 
1:         // setup pojosr to use our bundles
1:         Map<String, List<BundleDescriptor>> config = new HashMap<String, List<BundleDescriptor>>();
1:         config.put(PojoServiceRegistryFactory.BUNDLE_DESCRIPTORS, bundles);
1: 
1:         // create pojorsr osgi service registry
1:         PojoServiceRegistry reg = new PojoServiceRegistryFactoryImpl().newPojoServiceRegistry(config);
1:         return reg.getBundleContext();
1:     }
1: 
1:     public static void disposeBundleContext(BundleContext bundleContext) throws BundleException {
1:         try {
1:             if (bundleContext != null) {
1:                 bundleContext.getBundle().stop();
1:             }
1:         } finally {
1:             System.clearProperty("org.osgi.framework.storage");
1:         }
1:     }
1: 
1:     public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type, long timeout) {
1:         return getOsgiService(bundleContext, type, null, timeout);
1:     }
1: 
1:     public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type) {
1:         return getOsgiService(bundleContext, type, null, DEFAULT_TIMEOUT);
1:     }
1: 
1:     public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type, String filter) {
1:         return getOsgiService(bundleContext, type, filter, DEFAULT_TIMEOUT);
1:     }
1: 
1:     public static <T> ServiceReference getOsgiServiceReference(BundleContext bundleContext, Class<T> type, String filter, long timeout) {
1:         ServiceTracker tracker = null;
1:         try {
1:             String flt;
1:             if (filter != null) {
1:                 if (filter.startsWith("(")) {
1:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")" + filter + ")";
1:                 } else {
1:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")(" + filter + "))";
1:                 }
1:             } else {
1:                 flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";
1:             }
1:             Filter osgiFilter = FrameworkUtil.createFilter(flt);
1:             tracker = new ServiceTracker(bundleContext, osgiFilter, null);
1:             tracker.open(true);
1:             // Note that the tracker is not closed to keep the reference
1:             // This is buggy, as the service reference may change i think
1:             Object svc = tracker.waitForService(timeout);
1:             if (svc == null) {
1:                 Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();
1:                 System.err.println("Test bundle headers: " + explode(dic));
1: 
1:                 for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, null))) {
1:                     System.err.println("ServiceReference: " + ref + ", bundle: " + ref.getBundle() + ", symbolicName: " + ref.getBundle().getSymbolicName());
1:                 }
1: 
1:                 for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, flt))) {
1:                     System.err.println("Filtered ServiceReference: " + ref + ", bundle: " + ref.getBundle() + ", symbolicName: " + ref.getBundle().getSymbolicName());
1:                 }
1: 
1:                 throw new RuntimeException("Gave up waiting for service " + flt);
1:             }
1:             return tracker.getServiceReference();
1:         } catch (InvalidSyntaxException e) {
1:             throw new IllegalArgumentException("Invalid filter", e);
1:         } catch (InterruptedException e) {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type, String filter, long timeout) {
1:         ServiceTracker tracker = null;
1:         try {
1:             String flt;
1:             if (filter != null) {
1:                 if (filter.startsWith("(")) {
1:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")" + filter + ")";
1:                 } else {
1:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")(" + filter + "))";
1:                 }
1:             } else {
1:                 flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";
1:             }
1:             Filter osgiFilter = FrameworkUtil.createFilter(flt);
1:             tracker = new ServiceTracker(bundleContext, osgiFilter, null);
1:             tracker.open(true);
1:             // Note that the tracker is not closed to keep the reference
1:             // This is buggy, as the service reference may change i think
1:             Object svc = tracker.waitForService(timeout);
1:             if (svc == null) {
1:                 Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();
1:                 System.err.println("Test bundle headers: " + explode(dic));
1: 
1:                 for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, null))) {
1:                     System.err.println("ServiceReference: " + ref + ", bundle: " + ref.getBundle() + ", symbolicName: " + ref.getBundle().getSymbolicName());
1:                 }
1: 
1:                 for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, flt))) {
1:                     System.err.println("Filtered ServiceReference: " + ref + ", bundle: " + ref.getBundle() + ", symbolicName: " + ref.getBundle().getSymbolicName());
1:                 }
1: 
1:                 throw new RuntimeException("Gave up waiting for service " + flt);
1:             }
1:             return type.cast(svc);
1:         } catch (InvalidSyntaxException e) {
1:             throw new IllegalArgumentException("Invalid filter", e);
1:         } catch (InterruptedException e) {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     protected static TinyBundle createTestBundle(String name, String version, String descriptors) throws FileNotFoundException, MalformedURLException {
1:         TinyBundle bundle = TinyBundles.newBundle();
1:         for (URL url : getBlueprintDescriptors(descriptors)) {
1:             LOG.info("Using Blueprint XML file: " + url.getFile());
1:             bundle.add("OSGI-INF/blueprint/blueprint-" + url.getFile().replace("/", "-"), url);
1:         }
1:         bundle.set("Manifest-Version", "2")
1:                 .set("Bundle-ManifestVersion", "2")
1:                 .set("Bundle-SymbolicName", name)
1:                 .set("Bundle-Version", version);
1:         return bundle;
1:     }
1: 
1:     /**
1:      * Explode the dictionary into a <code>,</code> delimited list of <code>key=value</code> pairs.
1:      */
1:     private static String explode(Dictionary<?, ?> dictionary) {
1:         Enumeration<?> keys = dictionary.keys();
1:         StringBuffer result = new StringBuffer();
1:         while (keys.hasMoreElements()) {
1:             Object key = keys.nextElement();
1:             result.append(String.format("%s=%s", key, dictionary.get(key)));
1:             if (keys.hasMoreElements()) {
1:                 result.append(", ");
1:             }
1:         }
1:         return result.toString();
1:     }
1: 
1:     /**
1:      * Provides an iterable collection of references, even if the original array is <code>null</code>.
1:      */
1:     private static Collection<ServiceReference> asCollection(ServiceReference[] references) {
1:         return references  == null ? new ArrayList<ServiceReference>(0) : Arrays.asList(references);
1:     }
1: 
1:     /**
1:      * Gets list of bundle descriptors.
1:      * @param bundleFilter Filter expression for OSGI bundles.
1:      *
1:      * @return List pointers to OSGi bundles.
1:      * @throws Exception If looking up the bundles fails.
1:      */
1:     private static List<BundleDescriptor> getBundleDescriptors(final String bundleFilter) throws Exception {
1:         return new ClasspathScanner().scanForBundles(bundleFilter);
1:     }
1: 
1:     /**
1:      * Gets the bundle descriptors as {@link URL} resources.
1:      *
1:      * @param descriptors the bundle descriptors, can be separated by comma
1:      * @return the bundle descriptors.
1:      * @throws FileNotFoundException is thrown if a bundle descriptor cannot be found
1:      */
1:     private static Collection<URL> getBlueprintDescriptors(String descriptors) throws FileNotFoundException, MalformedURLException {
1:         List<URL> answer = new ArrayList<URL>();
1:         String descriptor = descriptors;
1:         if (descriptor != null) {
1:             // there may be more resources separated by comma
1:             Iterator<Object> it = createIterator(descriptor);
1:             while (it.hasNext()) {
1:                 String s = (String) it.next();
1:                 LOG.trace("Resource descriptor: {}", s);
1: 
1:                 // remove leading / to be able to load resource from the classpath
1:                 s = stripLeadingSeparator(s);
1: 
1:                 // if there is wildcards for *.xml then we need to find the urls from the package
1:                 if (s.endsWith("*.xml")) {
1:                     String packageName = s.substring(0, s.length() - 5);
1:                     // remove trailing / to be able to load resource from the classpath
1:                     Enumeration<URL> urls = loadResourcesAsURL(packageName);
1:                     while (urls.hasMoreElements()) {
1:                         URL url = urls.nextElement();
1:                         File dir = new File(url.getFile());
1:                         if (dir.isDirectory()) {
1:                             File[] files = dir.listFiles();
1:                             if (files != null) {
1:                                 for (File file : files) {
1:                                     if (file.isFile() && file.exists() && file.getName().endsWith(".xml")) {
1:                                         String name = packageName + file.getName();
1:                                         LOG.debug("Resolving resource: {}", name);
1:                                         URL xmlUrl = loadResourceAsURL(name);
1:                                         if (xmlUrl != null) {
1:                                             answer.add(xmlUrl);
1:                                         }
1:                                     }
1:                                 }
1:                             }
1:                         }
1:                     }
1:                 } else {
1:                     LOG.debug("Resolving resource: {}", s);
1:                     URL url = resolveMandatoryResourceAsUrl(s);
1:                     if (url == null) {
1:                         throw new FileNotFoundException("Resource " + s + " not found");
1:                     }
1:                     answer.add(url);
1:                 }
1:             }
1:         } else {
1:             throw new IllegalArgumentException("No bundle descriptor configured. Override getBlueprintDescriptor() or getBlueprintDescriptors() method");
1:         }
1: 
1:         if (answer.isEmpty()) {
1:             throw new IllegalArgumentException("Cannot find any resources in classpath from descriptor " + descriptors);
1:         }
1:         return answer;
1:     }
1: 
1:     private static BundleDescriptor getBundleDescriptor(String path, TinyBundle bundle) throws Exception {
1:         File file = new File(path);
1:         FileOutputStream fos = new FileOutputStream(file, true);
1:         try {
1:             copy(bundle.build(), fos);
1:         } finally {
1:             close(fos);
1:         }
1: 
1:         FileInputStream fis = null;
1:         JarInputStream jis = null;
1:         try {
1:             fis = new FileInputStream(file);
1:             jis = new JarInputStream(fis);
1:             Map<String, String> headers = new HashMap<String, String>();
1:             for (Map.Entry<Object, Object> entry : jis.getManifest().getMainAttributes().entrySet()) {
1:                 headers.put(entry.getKey().toString(), entry.getValue().toString());
1:             }
1: 
1:             return new BundleDescriptor(
1:                     bundle.getClass().getClassLoader(),
1:                     new URL("jar:" + file.toURI().toString() + "!/"),
1:                     headers);
1:         } finally {
1:             close(fis, jis);
1:         }
1:     }
1: 
1:     /**
1:      * Closes the given resource if it is available, logging any closing exceptions to the given log.
1:      *
1:      * @param closeable the object to close
1:      * @param name the name of the resource
1:      * @param log the log to use when reporting closure warnings, will use this class's own {@link Logger} if <tt>log == null</tt>
1:      */
1:     public static void close(Closeable closeable, String name, Logger log) {
1:         if (closeable != null) {
1:             try {
1:                 closeable.close();
1:             } catch (IOException e) {
1:                 if (log == null) {
1:                     // then fallback to use the own Logger
1:                     log = LOG;
1:                 }
1:                 if (name != null) {
1:                     log.warn("Cannot close: " + name + ". Reason: " + e.getMessage(), e);
1:                 } else {
1:                     log.warn("Cannot close. Reason: " + e.getMessage(), e);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Closes the given resource if it is available.
1:      *
1:      * @param closeable the object to close
1:      * @param name the name of the resource
1:      */
1:     public static void close(Closeable closeable, String name) {
1:         close(closeable, name, LOG);
1:     }
1: 
1:     /**
1:      * Closes the given resource if it is available.
1:      *
1:      * @param closeable the object to close
1:      */
1:     public static void close(Closeable closeable) {
1:         close(closeable, null, LOG);
1:     }
1: 
1:     /**
1:      * Closes the given resources if they are available.
1:      *
1:      * @param closeables the objects to close
1:      */
1:     public static void close(Closeable... closeables) {
1:         for (Closeable closeable : closeables) {
1:             close(closeable);
1:         }
1:     }
1: 
1:     private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;
1:     private static final String DEFAULT_DELIMITER = ",";
1: 
1:     public static int copy(InputStream input, OutputStream output) throws IOException {
1:         return copy(input, output, DEFAULT_BUFFER_SIZE);
1:     }
1: 
1:     public static int copy(final InputStream input, final OutputStream output, int bufferSize) throws IOException {
1:         int avail = input.available();
1:         if (avail > 262144) {
1:             avail = 262144;
1:         }
1:         if (avail > bufferSize) {
1:             bufferSize = avail;
1:         }
1: 
1:         final byte[] buffer = new byte[bufferSize];
1:         int n = input.read(buffer);
1:         int total = 0;
1:         while (-1 != n) {
1:             output.write(buffer, 0, n);
1:             total += n;
1:             n = input.read(buffer);
1:         }
1:         output.flush();
1:         return total;
1:     }
1: 
1:     /**
1:      * Creates an iterator over the value if the value is a collection, an
1:      * Object[], a String with values separated by comma,
1:      * or a primitive type array; otherwise to simplify the caller's code,
1:      * we just create a singleton collection iterator over a single value
1:      * <p/>
1:      * Will default use comma for String separating String values.
1:      * This method does <b>not</b> allow empty values
1:      *
1:      * @param value  the value
1:      * @return the iterator
1:      */
1:     public static Iterator<Object> createIterator(Object value) {
1:         return createIterator(value, DEFAULT_DELIMITER);
1:     }
1: 
1:     /**
1:      * Creates an iterator over the value if the value is a collection, an
1:      * Object[], a String with values separated by the given delimiter,
1:      * or a primitive type array; otherwise to simplify the caller's
1:      * code, we just create a singleton collection iterator over a single value
1:      * <p/>
1:      * This method does <b>not</b> allow empty values
1:      *
1:      * @param value      the value
1:      * @param delimiter  delimiter for separating String values
1:      * @return the iterator
1:      */
1:     public static Iterator<Object> createIterator(Object value, String delimiter) {
1:         return createIterator(value, delimiter, false);
1:     }
1: 
1:     /**
1:      * Creates an iterator over the value if the value is a collection, an
1:      * Object[], a String with values separated by the given delimiter,
1:      * or a primitive type array; otherwise to simplify the caller's
1:      * code, we just create a singleton collection iterator over a single value
1:      *
1:      * @param value             the value
1:      * @param delimiter         delimiter for separating String values
1:      * @param allowEmptyValues  whether to allow empty values
1:      * @return the iterator
1:      */
1:     @SuppressWarnings("unchecked")
1:     public static Iterator<Object> createIterator(Object value, String delimiter, final boolean allowEmptyValues) {
1:         if (value == null) {
1:             return Collections.emptyList().iterator();
1:         } else if (value instanceof Iterator) {
1:             return (Iterator<Object>)value;
1:         } else if (value instanceof Iterable) {
1:             return ((Iterable<Object>)value).iterator();
1:         } else if (value.getClass().isArray()) {
1:             // TODO we should handle primitive array types?
1:             List<Object> list = Arrays.asList((Object[])value);
1:             return list.iterator();
1:         } else if (value instanceof NodeList) {
1:             // lets iterate through DOM results after performing XPaths
1:             final NodeList nodeList = (NodeList) value;
1:             return cast(new Iterator<Node>() {
1:                 int idx = -1;
1: 
1:                 public boolean hasNext() {
1:                     return (idx + 1) < nodeList.getLength();
1:                 }
1: 
1:                 public Node next() {
1:                     idx++;
1:                     return nodeList.item(idx);
1:                 }
1: 
1:                 public void remove() {
1:                     throw new UnsupportedOperationException();
1:                 }
1:             });
1:         } else if (value instanceof String) {
1:             final String s = (String) value;
1: 
1:             // this code is optimized to only use a Scanner if needed, eg there is a delimiter
1: 
1:             if (delimiter != null && s.contains(delimiter)) {
1:                 // use a scanner if it contains the delimiter
1:                 Scanner scanner = new Scanner((String)value);
1: 
1:                 if (DEFAULT_DELIMITER.equals(delimiter)) {
1:                     // we use the default delimiter which is a comma, then cater for bean expressions with OGNL
1:                     // which may have balanced parentheses pairs as well.
1:                     // if the value contains parentheses we need to balance those, to avoid iterating
1:                     // in the middle of parentheses pair, so use this regular expression (a bit hard to read)
1:                     // the regexp will split by comma, but honor parentheses pair that may include commas
1:                     // as well, eg if value = "bean=foo?method=killer(a,b),bean=bar?method=great(a,b)"
1:                     // then the regexp will split that into two:
1:                     // -> bean=foo?method=killer(a,b)
1:                     // -> bean=bar?method=great(a,b)
1:                     // http://stackoverflow.com/questions/1516090/splitting-a-title-into-separate-parts
1:                     delimiter = ",(?!(?:[^\\(,]|[^\\)],[^\\)])+\\))";
1:                 }
1: 
1:                 scanner.useDelimiter(delimiter);
1:                 return cast(scanner);
1:             } else {
1:                 // use a plain iterator that returns the value as is as there are only a single value
1:                 return cast(new Iterator<String>() {
1:                     int idx = -1;
1: 
1:                     public boolean hasNext() {
1:                         return idx + 1 == 0 && (allowEmptyValues || isNotEmpty(s));
1:                     }
1: 
1:                     public String next() {
1:                         idx++;
1:                         return s;
1:                     }
1: 
1:                     public void remove() {
1:                         throw new UnsupportedOperationException();
1:                     }
1:                 });
1:             }
1:         } else {
1:             return Collections.singletonList(value).iterator();
1:         }
1:     }
1: 
1:     /**
1:      * Tests whether the value is <b>not</b> <tt>null</tt> or an empty string.
1:      *
1:      * @param value  the value, if its a String it will be tested for text length as well
1:      * @return true if <b>not</b> empty
1:      */
1:     public static boolean isNotEmpty(Object value) {
1:         if (value == null) {
1:             return false;
1:         } else if (value instanceof String) {
1:             String text = (String) value;
1:             return text.trim().length() > 0;
1:         } else {
1:             return true;
1:         }
1:     }
1: 
1:     public static <T> Iterator<T> cast(Iterator<?> p) {
1:         return (Iterator<T>) p;
1:     }
1: 
1:     /**
1:      * Strip any leading separators
1:      */
1:     public static String stripLeadingSeparator(String name) {
1:         if (name == null) {
1:             return null;
1:         }
1:         while (name.startsWith("/") || name.startsWith(File.separator)) {
1:             name = name.substring(1);
1:         }
1:         return name;
1:     }
1: 
1:     /**
1:      * Attempts to load the given resources from the given package name using the thread context
1:      * class loader or the class loader used to load this class
1:      *
1:      * @param packageName the name of the package to load its resources
1:      * @return the URLs for the resources or null if it could not be loaded
1:      */
1:     public static Enumeration<URL> loadResourcesAsURL(String packageName) {
1:         Enumeration<URL> url = null;
1: 
1:         ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
1:         if (contextClassLoader != null) {
1:             try {
1:                 url = contextClassLoader.getResources(packageName);
1:             } catch (IOException e) {
1:                 // ignore
1:             }
1:         }
1:         if (url == null) {
1:             try {
1:                 url = Helper.class.getClassLoader().getResources(packageName);
1:             } catch (IOException e) {
1:                 // ignore
1:             }
1:         }
1: 
1:         return url;
1:     }
1: 
1:     /**
1:      * Attempts to load the given resource as a stream using the thread context
1:      * class loader or the class loader used to load this class
1:      *
1:      * @param name the name of the resource to load
1:      * @return the stream or null if it could not be loaded
1:      */
1:     public static URL loadResourceAsURL(String name) {
1:         URL url = null;
1: 
1:         String resolvedName = resolveUriPath(name);
1:         ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
1:         if (contextClassLoader != null) {
1:             url = contextClassLoader.getResource(resolvedName);
1:         }
1:         if (url == null) {
1:             url = Helper.class.getClassLoader().getResource(resolvedName);
1:         }
1: 
1:         return url;
1:     }
1: 
1:     /**
1:      * Helper operation used to remove relative path notation from
1:      * resources.  Most critical for resources on the Classpath
1:      * as resource loaders will not resolve the relative paths correctly.
1:      *
1:      * @param name the name of the resource to load
1:      * @return the modified or unmodified string if there were no changes
1:      */
1:     private static String resolveUriPath(String name) {
1:         String answer = name;
1:         if (answer.indexOf("//") > -1) {
1:             answer = answer.replaceAll("//", "/");
1:         }
1:         if (answer.indexOf("../") > -1) {
1:             answer = answer.replaceAll("[A-Za-z0-9]*/\\.\\./", "");
1:         }
1:         if (answer.indexOf("./") > -1) {
1:             answer = answer.replaceAll("\\./", "");
1:         }
1:         return answer;
1:     }
1: 
1:     /**
1:      * Resolves the mandatory resource.
1:      *
1:      * @param uri uri of the resource
1:      * @return the resource as an {@link InputStream}.  Remember to close this stream after usage.
1:      * @throws java.io.FileNotFoundException is thrown if the resource file could not be found
1:      * @throws java.net.MalformedURLException if the URI is malformed
1:      */
1:     public static URL resolveMandatoryResourceAsUrl(String uri) throws FileNotFoundException, MalformedURLException {
1:         if (uri.startsWith("file:")) {
1:             // check if file exists first
1:             String name = after(uri, "file:");
1:             File file = new File(name);
1:             if (!file.exists()) {
1:                 throw new FileNotFoundException("File " + file + " not found");
1:             }
1:             return new URL(uri);
1:         } else if (uri.startsWith("http:")) {
1:             return new URL(uri);
1:         } else if (uri.startsWith("classpath:")) {
1:             uri = after(uri, "classpath:");
1:         }
1: 
1:         // load from classpath by default
1:         URL url = loadResourceAsURL(uri);
1:         if (url == null) {
1:             throw new FileNotFoundException("Cannot find resource in classpath for URI: " + uri);
1:         } else {
1:             return url;
1:         }
1:     }
1: 
1:     public static String after(String text, String after) {
1:         if (!text.contains(after)) {
1:             return null;
1:         }
1:         return text.substring(text.indexOf(after) + after.length());
1:     }
1: 
1:     /**
1:      * Recursively delete a directory, useful to zapping test data
1:      *
1:      * @param file the directory to be deleted
1:      * @return <tt>false</tt> if error deleting directory
1:      */
1:     public static boolean deleteDirectory(String file) {
1:         return deleteDirectory(new File(file));
1:     }
1: 
1:     /**
1:      * Recursively delete a directory, useful to zapping test data
1:      *
1:      * @param file the directory to be deleted
1:      * @return <tt>false</tt> if error deleting directory
1:      */
1:     public static boolean deleteDirectory(File file) {
1:         int tries = 0;
1:         int maxTries = 5;
1:         boolean exists = true;
1:         while (exists && (tries < maxTries)) {
1:             recursivelyDeleteDirectory(file);
1:             tries++;
1:             exists = file.exists();
1:             if (exists) {
1:                 try {
1:                     Thread.sleep(1000);
1:                 } catch (InterruptedException e) {
1:                     // Ignore
1:                 }
1:             }
1:         }
1:         return !exists;
1:     }
1: 
1:     private static void recursivelyDeleteDirectory(File file) {
1:         if (!file.exists()) {
1:             return;
1:         }
1: 
1:         if (file.isDirectory()) {
1:             File[] files = file.listFiles();
1:             for (File child : files) {
1:                 recursivelyDeleteDirectory(child);
1:             }
1:         }
1:         boolean success = file.delete();
1:         if (!success) {
1:             LOG.warn("Deletion of file: " + file.getAbsolutePath() + " failed");
1:         }
1:     }
1: 
1:     /**
1:      * create the directory
1:      *
1:      * @param file the directory to be created
1:      */
1:     public static void createDirectory(String file) {
1:         File dir = new File(file);
1:         dir.mkdirs();
1:     }
1: 
1: 
1: }
============================================================================