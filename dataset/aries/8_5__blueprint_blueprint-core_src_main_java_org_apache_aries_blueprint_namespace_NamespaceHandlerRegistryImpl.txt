1:f13c6ac: /*
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
3:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.namespace;
1:ef8161c: 
1:9a1ff22: import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;
1:9a1ff22: import static javax.xml.XMLConstants.XML_NS_URI;
1:9a1ff22: import static org.apache.aries.blueprint.parser.Parser.BLUEPRINT_NAMESPACE;
1:9cbc0c8: 
1:dcc3027: import java.io.Closeable;
1:dcc3027: import java.io.IOException;
1:dcc3027: import java.io.InputStream;
1:dcc3027: import java.io.Reader;
1:3b2c33b: import java.lang.ref.Reference;
1:3b2c33b: import java.lang.ref.SoftReference;
1:f13c6ac: import java.net.URI;
1:8f23124: import java.net.URISyntaxException;
1:f13c6ac: import java.net.URL;
1:fbc9ce1: import java.util.*;
1:dcc3027: import java.util.concurrent.ConcurrentHashMap;
1:fbc9ce1: import java.util.concurrent.ConcurrentMap;
1:dcc3027: import java.util.concurrent.CopyOnWriteArrayList;
1:dcc3027: import java.util.concurrent.CopyOnWriteArraySet;
1:ef8161c: 
1:fbc9ce1: import javax.xml.namespace.QName;
1:fbc9ce1: import javax.xml.parsers.DocumentBuilder;
1:fbc9ce1: import javax.xml.parsers.DocumentBuilderFactory;
1:fbc9ce1: import javax.xml.stream.XMLInputFactory;
1:fbc9ce1: import javax.xml.stream.XMLStreamReader;
1:dcc3027: import javax.xml.transform.Source;
1:dcc3027: import javax.xml.transform.stream.StreamSource;
1:f13c6ac: import javax.xml.validation.Schema;
1:f13c6ac: import javax.xml.validation.SchemaFactory;
37:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.NamespaceHandler;
1:fbc9ce1: import org.apache.aries.blueprint.ParserContext;
1:6414875: import org.apache.aries.blueprint.container.NamespaceHandlerRegistry;
1:09a7647: import org.apache.aries.blueprint.parser.NamespaceHandlerSet;
1:3b2c33b: import org.osgi.framework.Bundle;
1:f13c6ac: import org.osgi.framework.BundleContext;
1:f13c6ac: import org.osgi.framework.ServiceReference;
1:fbc9ce1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:fbc9ce1: import org.osgi.service.blueprint.reflect.Metadata;
1:f13c6ac: import org.osgi.util.tracker.ServiceTracker;
1:f13c6ac: import org.osgi.util.tracker.ServiceTrackerCustomizer;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:fbc9ce1: import org.w3c.dom.Document;
1:fbc9ce1: import org.w3c.dom.Element;
1:fbc9ce1: import org.w3c.dom.Node;
1:dcc3027: import org.w3c.dom.ls.LSInput;
1:dcc3027: import org.w3c.dom.ls.LSResourceResolver;
1:f13c6ac: import org.xml.sax.SAXException;
1:9a1ff22: 
1:f13c6ac: /**
1:f13c6ac:  * Default implementation of the NamespaceHandlerRegistry.
1:9cbc0c8:  * 
1:f13c6ac:  * This registry will track NamespaceHandler objects in the OSGi registry and make
1:f13c6ac:  * them available, calling listeners when handlers are registered or unregistered.
1:ef8161c:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:f13c6ac: public class NamespaceHandlerRegistryImpl implements NamespaceHandlerRegistry, ServiceTrackerCustomizer {
1:9cbc0c8:     
1:f13c6ac:     public static final String NAMESPACE = "osgi.service.blueprint.namespace";
1:9cbc0c8: 
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(NamespaceHandlerRegistryImpl.class);
1:9cbc0c8: 
1:dcc3027:     // The bundle context is thread safe
1:f13c6ac:     private final BundleContext bundleContext;
1:dcc3027: 
1:dcc3027:     // The service tracker is thread safe
1:f13c6ac:     private final ServiceTracker tracker;
1:dcc3027: 
1:dcc3027:     // The handlers map is concurrent
1:dcc3027:     private final ConcurrentHashMap<URI, CopyOnWriteArraySet<NamespaceHandler>> handlers =
1:dcc3027:                         new ConcurrentHashMap<URI, CopyOnWriteArraySet<NamespaceHandler>>();
1:dcc3027: 
1:1aa84c9:     // Access to the LRU schemas map is synchronized on itself
1:1aa84c9:     private final LRUMap<Map<URI, NamespaceHandler>, Reference<Schema>> schemas =
1:dcc3027:                         new LRUMap<Map<URI, NamespaceHandler>, Reference<Schema>>(10);
1:dcc3027: 
1:dcc3027:     // Access to this factory is synchronized on itself
1:dcc3027:     private final SchemaFactory schemaFactory =
1:9a1ff22:                         SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);
1:dcc3027: 
1:453da8a:     // Access to this variable is must be synchronized on itself
1:453da8a:     private final ArrayList<NamespaceHandlerSetImpl> sets =
1:453da8a:                         new ArrayList<NamespaceHandlerSetImpl>();
1:dcc3027: 
1:f13c6ac:     public NamespaceHandlerRegistryImpl(BundleContext bundleContext) {
1:f13c6ac:         this.bundleContext = bundleContext;
1:f13c6ac:         tracker = new ServiceTracker(bundleContext, NamespaceHandler.class.getName(), this);
1:f13c6ac:         tracker.open();
22:3b2c33b:     }
1:9cbc0c8: 
1:f13c6ac:     public Object addingService(ServiceReference reference) {
1:dcc3027:         LOGGER.debug("Adding NamespaceHandler " + reference.toString());
1:f13c6ac:         NamespaceHandler handler = (NamespaceHandler) bundleContext.getService(reference);
1:dcc3027:         if (handler != null) {
1:94f26b1:             try {
1:f13c6ac:                 Map<String, Object> props = new HashMap<String, Object>();
1:f13c6ac:                 for (String name : reference.getPropertyKeys()) {
1:f13c6ac:                     props.put(name, reference.getProperty(name));
1:94f26b1:                 }
1:f13c6ac:                 registerHandler(handler, props);
2:f13c6ac:             } catch (Exception e) {
1:f13c6ac:                 LOGGER.warn("Error registering NamespaceHandler", e);
1:b571b31:             }
1:dcc3027:         } else {
1:e09bd9c:             Bundle bundle = reference.getBundle();
1:e09bd9c:             // If bundle is null, the service has already been unregistered,
1:e09bd9c:             // so do nothing in that case
1:e09bd9c:             if (bundle != null) {
1:e09bd9c:                 LOGGER.warn("Error resolving NamespaceHandler, null Service obtained from tracked ServiceReference {} for bundle {}/{}",
1:e09bd9c:                         reference.toString(), reference.getBundle().getSymbolicName(), reference.getBundle().getVersion());
1:94f26b1:             }
1:94f26b1:         }
1:f13c6ac:         return handler;
1:e09bd9c:     }
1:dcc3027: 
1:f13c6ac:     public void modifiedService(ServiceReference reference, Object service) {
1:f13c6ac:         removedService(reference, service);
1:f13c6ac:         addingService(reference);
1:dcc3027:     }
1:9cbc0c8: 
1:f13c6ac:     public void removedService(ServiceReference reference, Object service) {
1:b571b31:         try {
1:dcc3027:             LOGGER.debug("Removing NamespaceHandler " + reference.toString());
1:f13c6ac:             NamespaceHandler handler = (NamespaceHandler) service;
1:f13c6ac:             Map<String, Object> props = new HashMap<String, Object>();
1:f13c6ac:             for (String name : reference.getPropertyKeys()) {
1:f13c6ac:                 props.put(name, reference.getProperty(name));
1:dcc3027:             }
1:f13c6ac:             unregisterHandler(handler, props);
1:dcc3027:         } catch (Exception e) {
1:f13c6ac:             LOGGER.warn("Error unregistering NamespaceHandler", e);
1:dcc3027:         }
1:dcc3027:     }
1:9cbc0c8: 
1:dcc3027:     public void registerHandler(NamespaceHandler handler, Map properties) {
1:f13c6ac:         List<URI> namespaces = getNamespaces(properties);
1:f13c6ac:         for (URI uri : namespaces) {
1:dcc3027:             CopyOnWriteArraySet<NamespaceHandler> h = handlers.putIfAbsent(uri, new CopyOnWriteArraySet<NamespaceHandler>());
1:94f26b1:             if (h == null) {
1:dcc3027:                 h = handlers.get(uri);
1:dcc3027:             }
1:3b2c33b:             if (h.add(handler)) {
1:453da8a:                 List<NamespaceHandlerSetImpl> sets;
1:453da8a:                 synchronized (this.sets) {
1:453da8a:                     sets = new ArrayList<NamespaceHandlerSetImpl>(this.sets);
1:453da8a:                 }
1:3b2c33b:                 for (NamespaceHandlerSetImpl s : sets) {
1:3b2c33b:                     s.registerHandler(uri, handler);
1:3b2c33b:                 }
1:3b2c33b:             }
1:3b2c33b:         }
1:3b2c33b:     }
1:9cbc0c8: 
1:dcc3027:     public void unregisterHandler(NamespaceHandler handler, Map properties) {
1:f13c6ac:         List<URI> namespaces = getNamespaces(properties);
1:f13c6ac:         for (URI uri : namespaces) {
1:dcc3027:             CopyOnWriteArraySet<NamespaceHandler> h = handlers.get(uri);
1:dcc3027:             if (!h.remove(handler)) {
1:f13c6ac:                 continue;
1:453da8a:             }
1:453da8a:             List<NamespaceHandlerSetImpl> sets;
1:453da8a:             synchronized (this.sets) {
1:453da8a:                 sets = new ArrayList<NamespaceHandlerSetImpl>(this.sets);
1:3b2c33b:             }
1:3b2c33b:             for (NamespaceHandlerSetImpl s : sets) {
1:3b2c33b:                 s.unregisterHandler(uri, handler);
1:3b2c33b:             }
1:3b2c33b:         }
1:3b2c33b:         removeSchemasFor(handler);
1:3b2c33b:     }
1:9cbc0c8: 
1:f13c6ac:     private static List<URI> getNamespaces(Map properties) {
1:f13c6ac:         Object ns = properties != null ? properties.get(NAMESPACE) : null;
1:f13c6ac:         if (ns == null) {
1:dcc3027:             throw new IllegalArgumentException("NamespaceHandler service does not have an associated "
1:dcc3027:                             + NAMESPACE + " property defined");
1:f13c6ac:         } else if (ns instanceof URI[]) {
1:f13c6ac:             return Arrays.asList((URI[]) ns);
1:f13c6ac:         } else if (ns instanceof URI) {
1:f13c6ac:             return Collections.singletonList((URI) ns);
1:f13c6ac:         } else if (ns instanceof String) {
1:f13c6ac:             return Collections.singletonList(URI.create((String) ns));
1:f13c6ac:         } else if (ns instanceof String[]) {
1:f13c6ac:             String[] strings = (String[]) ns;
1:f13c6ac:             List<URI> namespaces = new ArrayList<URI>(strings.length);
1:f13c6ac:             for (String string : strings) {
1:f13c6ac:                 namespaces.add(URI.create(string));
1:3b2c33b:             }
1:f13c6ac:             return namespaces;
1:f13c6ac:         } else if (ns instanceof Collection) {
1:f13c6ac:             Collection col = (Collection) ns;
1:f13c6ac:             List<URI> namespaces = new ArrayList<URI>(col.size());
1:f13c6ac:             for (Object o : col) {
1:f13c6ac:                 namespaces.add(toURI(o));
1:3b2c33b:             }
1:f13c6ac:             return namespaces;
1:f13c6ac:         } else if (ns instanceof Object[]) {
1:f13c6ac:             Object[] array = (Object[]) ns;
1:f13c6ac:             List<URI> namespaces = new ArrayList<URI>(array.length);
1:f13c6ac:             for (Object o : array) {
1:f13c6ac:                 namespaces.add(toURI(o));
1:3b2c33b:             }
1:f13c6ac:             return namespaces;
1:94f26b1:         } else {
1:dcc3027:             throw new IllegalArgumentException("NamespaceHandler service has an associated "
1:dcc3027:                             + NAMESPACE + " property defined which can not be converted to an array of URI");
1:3b2c33b:         }
1:3b2c33b:     }
1:9cbc0c8: 
1:f13c6ac:     private static URI toURI(Object o) {
1:f13c6ac:         if (o instanceof URI) {
1:f13c6ac:             return (URI) o;
1:f13c6ac:         } else if (o instanceof String) {
1:f13c6ac:             return URI.create((String) o);
2:dcc3027:         } else {
1:dcc3027:             throw new IllegalArgumentException("NamespaceHandler service has an associated "
1:dcc3027:                             + NAMESPACE + " property defined which can not be converted to an array of URI");
1:3b2c33b:         }
1:3b2c33b:     }
1:9cbc0c8:     
1:dcc3027:     public NamespaceHandlerSet getNamespaceHandlers(Set<URI> uris, Bundle bundle) {
1:453da8a:         NamespaceHandlerSetImpl s;
1:453da8a:         synchronized (sets) {
1:453da8a:             s = new NamespaceHandlerSetImpl(uris, bundle);
1:453da8a:             sets.add(s);
1:453da8a:         }
1:3b2c33b:         return s;
1:3b2c33b:     }
1:ef8161c: 
1:f13c6ac:     public void destroy() {
1:f13c6ac:         tracker.close();
1:dcc3027:     }
1:dcc3027: 
1:dcc3027:     private Schema getExistingSchema(Map<URI, NamespaceHandler> handlers) {
1:1aa84c9:         synchronized (schemas) {
1:1aa84c9:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
1:1aa84c9:                 boolean found = true;
1:1aa84c9:                 for (URI uri : handlers.keySet()) {
1:1aa84c9:                     if (!handlers.get(uri).equals(key.get(uri))) {
1:1aa84c9:                         found = false;
1:1aa84c9:                         break;
1:1aa84c9:                     }
1:1aa84c9:                 }
1:1aa84c9:                 if (found) {
1:1aa84c9:                     return schemas.get(key).get();
1:dcc3027:                 }
1:dcc3027:             }
1:1aa84c9:             return null;
1:dcc3027:         }
1:dcc3027:     }
1:dcc3027: 
1:dcc3027:     private void removeSchemasFor(NamespaceHandler handler) {
1:1aa84c9:         synchronized (schemas) {
1:1aa84c9:             List<Map<URI, NamespaceHandler>> keys = new ArrayList<Map<URI, NamespaceHandler>>();
2:dcc3027:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
1:dcc3027:                 if (key.values().contains(handler)) {
1:dcc3027:                     keys.add(key);
1:dcc3027:                 }
1:dcc3027:             }
1:1aa84c9:             for (Map<URI, NamespaceHandler> key : keys) {
1:1aa84c9:                 schemas.remove(key);
1:dcc3027:             }
1:dcc3027:         }
1:dcc3027:     }
1:dcc3027: 
1:dcc3027:     private void cacheSchema(Map<URI, NamespaceHandler> handlers, Schema schema) {
1:1aa84c9:         synchronized (schemas) {
1:1aa84c9:             // Remove schemas that are fully included
1:1aa84c9:             for (Iterator<Map<URI, NamespaceHandler>> iterator = schemas.keySet().iterator(); iterator.hasNext();) {
1:1aa84c9:                 Map<URI, NamespaceHandler> key = iterator.next();
1:1aa84c9:                 boolean found = true;
1:1aa84c9:                 for (URI uri : key.keySet()) {
1:1aa84c9:                     if (!key.get(uri).equals(handlers.get(uri))) {
1:1aa84c9:                         found = false;
1:dcc3027:                         break;
1:dcc3027:                     }
1:dcc3027:                 }
1:1aa84c9:                 if (found) {
1:1aa84c9:                     iterator.remove();
1:dcc3027:                     break;
1:dcc3027:                 }
1:dcc3027:             }
1:1aa84c9:             // Add our new schema
1:1aa84c9:             schemas.put(handlers, new SoftReference<Schema>(schema));
1:dcc3027:         }
1:dcc3027:     }
1:dcc3027: 
1:dcc3027:     private static void closeQuietly(Closeable closeable) {
3:dcc3027:         try {
1:dcc3027:             if (closeable != null) {
1:dcc3027:                 closeable.close();
1:dcc3027:             }
2:94f26b1:         } catch (IOException e) {
1:dcc3027:             // Ignore
1:b571b31:         }
1:b571b31:     }
1:dcc3027: 
1:b571b31:     private static class SourceLSInput implements LSInput {
1:dcc3027:         private final StreamSource source;
1:dcc3027: 
1:b571b31:         public SourceLSInput(StreamSource source) {
1:dcc3027:             this.source = source;
1:dcc3027:         }
1:dcc3027: 
1:8f23124:         public Reader getCharacterStream() {
1:dcc3027:             return null;
1:dcc3027:         }
1:dcc3027: 
1:8f23124:         public void setCharacterStream(Reader characterStream) {
1:dcc3027:         }
1:9cbc0c8: 
1:8f23124:         public InputStream getByteStream() {
1:8f23124:             return source.getInputStream();
1:dcc3027:         }
1:9cbc0c8: 
1:8f23124:         public void setByteStream(InputStream byteStream) {
1:dcc3027:         }
1:ef8161c: 
1:8f23124:         public String getStringData() {
1:dcc3027:             return null;
1:dcc3027:         }
1:ef8161c: 
1:8f23124:         public void setStringData(String stringData) {
1:dcc3027:         }
1:ef8161c: 
1:8f23124:         public String getSystemId() {
1:b571b31:             return source.getSystemId();
1:dcc3027:         }
1:3b2c33b: 
1:8f23124:         public void setSystemId(String systemId) {
1:dcc3027:         }
1:3b2c33b: 
1:8f23124:         public String getPublicId() {
1:b571b31:             return null;
1:dcc3027:         }
1:3b2c33b: 
1:8f23124:         public void setPublicId(String publicId) {
1:dcc3027:         }
1:3b2c33b: 
1:8f23124:         public String getBaseURI() {
1:9cbc0c8:             return null;
1:e9345fa:         }
1:3b2c33b: 
1:8f23124:         public void setBaseURI(String baseURI) {
1:9cbc0c8:         }
1:3b2c33b: 
1:8f23124:         public String getEncoding() {
1:3b2c33b:             return null;
1:9cbc0c8:         }
1:3b2c33b: 
1:8f23124:         public void setEncoding(String encoding) {
1:9cbc0c8:         }
1:3b2c33b: 
1:8f23124:         public boolean getCertifiedText() {
1:8f23124:             return false;
1:9cbc0c8:         }
1:3b2c33b: 
1:8f23124:         public void setCertifiedText(boolean certifiedText) {
1:9cbc0c8:         }
1:9cbc0c8:     }
1:3b2c33b: 
1:3b2c33b:     protected class NamespaceHandlerSetImpl implements NamespaceHandlerSet {
1:3b2c33b: 
1:dcc3027:         private final List<Listener> listeners;
1:dcc3027:         private final Bundle bundle;
1:3b2c33b:         private final Set<URI> namespaces;
1:b685f35:         private final Map<URI, NamespaceHandler> handlers;
1:8f23124:         private final Properties schemaMap = new Properties();
1:3b2c33b:         private Schema schema;
1:3b2c33b: 
1:3b2c33b:         public NamespaceHandlerSetImpl(Set<URI> namespaces, Bundle bundle) {
1:dcc3027:             this.listeners = new CopyOnWriteArrayList<Listener>();
1:9a1ff22:             this.namespaces = new HashSet<URI>(namespaces);
1:dcc3027:             this.bundle = bundle;
1:68697bd:             handlers = new ConcurrentHashMap<URI, NamespaceHandler>();
4:3b2c33b:             for (URI ns : namespaces) {
1:3b2c33b:                 findCompatibleNamespaceHandler(ns);
1:9cbc0c8:             }
1:8f23124:             URL url = bundle.getResource("OSGI-INF/blueprint/schema.map");
2:94f26b1:             if (url != null) {
1:8f23124:                 InputStream ins = null;
1:dcc3027:                 try {
1:8f23124:                     ins = url.openStream();
1:8f23124:                     schemaMap.load(ins);
1:8f23124:                 } catch (IOException ex) {
1:8f23124:                     ex.printStackTrace();
2:8f23124:                     //ignore
4:dcc3027:                 } finally {
1:dcc3027:                     closeQuietly(ins);
1:e9345fa:                 }
1:e9345fa:             }
1:8f23124:             for (Object ns : schemaMap.keySet()) {
1:dcc3027:                 try {
1:8f23124:                     this.namespaces.remove(new URI(ns.toString()));
1:8f23124:                 } catch (URISyntaxException e) {
1:8f23124:                     //ignore
1:9cbc0c8:                 }
1:9cbc0c8:             }
1:9cbc0c8:         }
1:dcc3027: 
1:3b2c33b:         public boolean isComplete() {
1:3b2c33b:             return handlers.size() == namespaces.size();
1:9cbc0c8:         }
1:ef8161c: 
1:3b2c33b:         public Set<URI> getNamespaces() {
1:3b2c33b:             return namespaces;
1:9cbc0c8:         }
1:3b2c33b: 
1:3b2c33b:         public NamespaceHandler getNamespaceHandler(URI namespace) {
1:3b2c33b:             return handlers.get(namespace);
1:ef8161c:         }
1:3b2c33b: 
1:3b2c33b:         public Schema getSchema() throws SAXException, IOException {
1:f117d81:             return getSchema(null);
1:f117d81:         }
1:f117d81: 
1:f117d81:         public Schema getSchema(Map<String, String> locations) throws SAXException, IOException {
1:3b2c33b:             if (!isComplete()) {
1:3b2c33b:                 throw new IllegalStateException("NamespaceHandlerSet is not complete");
1:ef8161c:             }
1:1aa84c9:             if (schema == null) {
1:94f26b1:                 schema = doGetSchema(locations);
1:94f26b1:             }
1:1aa84c9:             return schema;
1:9a1ff22:         }
1:dcc3027: 
1:94f26b1:         private Schema doGetSchema(Map<String, String> locations) throws IOException, SAXException {
1:94f26b1:             if (schemaMap != null && !schemaMap.isEmpty()) {
1:94f26b1:                 return createSchema(locations);
1:94f26b1:             }
1:94f26b1:             // Find a schema that can handle all the requested namespaces
1:94f26b1:             // If it contains additional namespaces, it should not be a problem since
1:94f26b1:             // they won't be used at all
1:94f26b1:             Schema schema = getExistingSchema(handlers);
1:94f26b1:             if (schema == null) {
1:94f26b1:                 // Create schema
1:94f26b1:                 schema = createSchema(locations);
1:94f26b1:                 cacheSchema(handlers, schema);
1:94f26b1:             }
1:94f26b1:             return schema;
1:94f26b1:         }
1:94f26b1: 
1:551db01:         private class Loader implements LSResourceResolver, Closeable {
1:9a1ff22:             final List<StreamSource> sources = new ArrayList<StreamSource>();
1:9a1ff22:             final Map<String, URL> loaded = new HashMap<String, URL>();
1:9a1ff22:             final Map<String, String> namespaces = new HashMap<String, String>();
1:9a1ff22:             @Override
1:9a1ff22:             public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {
1:9a1ff22:                 // Compute id
1:9a1ff22:                 String id;
1:9a1ff22:                 String prevNamespace = baseURI != null ? namespaces.get(baseURI) : null;
1:9a1ff22:                 if (namespaceURI != null && prevNamespace != null && namespaceURI.equals(prevNamespace)) {
1:9a1ff22:                     // This is an include
1:9a1ff22:                     id = getId(type, namespaceURI, publicId, systemId);
1:9a1ff22:                 } else {
1:9a1ff22:                     id = getId(type, namespaceURI, publicId, null);
1:9a1ff22:                 }
1:9a1ff22:                 // Check if it has already been loaded
1:9a1ff22:                 if (loaded.containsKey(id)) {
1:9a1ff22:                     return createLSInput(loaded.get(id), id, namespaceURI);
1:9a1ff22:                 }
1:9a1ff22:                 // Schema map
1:9a1ff22:                 //-----------
1:9a1ff22:                 // Use provided schema map to find the resource.
1:9a1ff22:                 // If the schema map contains the namespaceURI, publicId or systemId,
1:9a1ff22:                 // load the corresponding resource directly from the bundle.
1:9a1ff22:                 String loc = null;
1:9a1ff22:                 if (namespaceURI != null) {
1:9a1ff22:                     loc = schemaMap.getProperty(namespaceURI);
1:9a1ff22:                 }
1:9a1ff22:                 if (loc == null && publicId != null) {
1:9a1ff22:                     loc = schemaMap.getProperty(publicId);
1:9a1ff22:                 }
1:9a1ff22:                 if (loc == null && systemId != null) {
1:9a1ff22:                     loc = schemaMap.getProperty(systemId);
1:9a1ff22:                 }
1:9a1ff22:                 if (loc != null) {
1:9a1ff22:                     URL url = bundle.getResource(loc);
1:9a1ff22:                     if (url != null) {
2:9a1ff22:                         return createLSInput(url, id, namespaceURI);
1:9a1ff22:                     }
1:9a1ff22:                 }
1:9a1ff22:                 // Relative uris
1:9a1ff22:                 //---------------
1:9a1ff22:                 // For relative uris, don't use the namespace handlers, but simply resolve the uri
1:9a1ff22:                 // and use that one directly to load the resource.
1:9a1ff22:                 String resolved = resolveIfRelative(systemId, baseURI);
1:9a1ff22:                 if (resolved != null) {
1:9a1ff22:                     URL url;
1:9a1ff22:                     try {
1:9a1ff22:                         url = new URL(resolved);
1:9a1ff22:                     } catch (IOException e) {
1:9a1ff22:                         throw new RuntimeException(e);
1:9a1ff22:                     }
1:9a1ff22:                     return createLSInput(url, id, namespaceURI);
1:9a1ff22:                 }
1:9a1ff22:                 // Only support xml schemas from now on
1:9a1ff22:                 if (namespaceURI == null || !W3C_XML_SCHEMA_NS_URI.equals(type)) {
1:9a1ff22:                     return null;
1:9a1ff22:                 }
1:9a1ff22:                 // We are now loading a schema, or schema part with
1:9a1ff22:                 //  * notNull(namespaceURI)
1:9a1ff22:                 //  * null(systemId) or absolute(systemId)
1:9a1ff22:                 URI nsUri = URI.create(namespaceURI);
1:9a1ff22:                 String rid = systemId != null ? systemId : namespaceURI;
1:9a1ff22:                 NamespaceHandler h = getNamespaceHandler(nsUri);
1:9a1ff22:                 // This is a resource from a known namespace
2:9a1ff22:                 if (h != null) {
2:9a1ff22:                     URL url = h.getSchemaLocation(rid);
2:9a1ff22:                     if (isCorrectUrl(url)) {
1:9a1ff22:                         return createLSInput(url, id, namespaceURI);
1:6972a70:                     }
1:9a1ff22:                 }
1:9a1ff22:                 else {
1:9a1ff22:                     // Ask known handlers if they have this schema
1:9a1ff22:                     for (NamespaceHandler hd : handlers.values()) {
1:9a1ff22:                         URL url = hd.getSchemaLocation(rid);
1:9a1ff22:                         if (isCorrectUrl(url)) {
1:9a1ff22:                             return createLSInput(url, id, namespaceURI);
1:9a1ff22:                         }
1:9a1ff22:                     }
1:9a1ff22:                 }
1:6972a70:                 LOGGER.warn("Unable to find namespace handler for {}", namespaceURI);
1:9a1ff22:                 return null;
1:9a1ff22:             }
1:9a1ff22: 
1:9a1ff22:             public String getId(String type, String namespaceURI, String publicId, String systemId) {
1:9a1ff22:                 return type + "|" + namespaceURI + "|" + publicId + "|" + systemId;
1:9a1ff22:             }
1:9a1ff22: 
1:9a1ff22:             public StreamSource use(URL resource, String id, String namespace) throws IOException {
1:9a1ff22:                 String url = resource.toExternalForm();
1:9a1ff22:                 StreamSource ss = new StreamSource(resource.openStream(), url);
1:9a1ff22:                 sources.add(ss);
1:9a1ff22:                 loaded.put(id, resource);
1:9a1ff22:                 namespaces.put(url, namespace);
1:9a1ff22:                 return ss;
1:9a1ff22:             }
1:9a1ff22: 
1:9a1ff22:             @Override
1:9a1ff22:             public void close() {
1:9a1ff22:                 for (StreamSource source : sources) {
1:9a1ff22:                     closeQuietly(source.getInputStream());
1:9a1ff22:                 }
1:9a1ff22:             }
1:9a1ff22: 
1:9a1ff22:             public Source[] getSources() {
1:9a1ff22:                 return sources.toArray(new Source[sources.size()]);
1:9a1ff22:             }
1:9a1ff22: 
1:9a1ff22:             private boolean isCorrectUrl(URL url) {
1:9a1ff22:                 return url != null && !loaded.values().contains(url);
1:9a1ff22:             }
1:9a1ff22:             private String resolveIfRelative(String systemId, String baseURI) {
1:9a1ff22:                 if (baseURI != null && systemId != null) {
1:9a1ff22:                     URI sId = URI.create(systemId);
1:9a1ff22:                     if (!sId.isAbsolute()) {
1:9a1ff22:                         return URI.create(baseURI).resolve(sId).toString();
1:9a1ff22:                     }
1:9a1ff22:                 }
1:9a1ff22:                 return null;
1:9a1ff22:             }
1:9a1ff22:             private LSInput createLSInput(URL url, String id, String namespace) {
1:9a1ff22:                 try {
1:9a1ff22:                     return new SourceLSInput(use(url, id, namespace));
1:9a1ff22:                 } catch (IOException e) {
1:9a1ff22:                     throw new RuntimeException(e);
1:9a1ff22:                 }
1:9a1ff22:             }
1:9a1ff22:         }
1:9a1ff22: 
1:94f26b1:         private Schema createSchema(Map<String, String> locations) throws IOException, SAXException {
1:9a1ff22:             Loader loader = new Loader();
1:dcc3027:             try {
1:9a1ff22:                 loader.use(getClass().getResource("/org/osgi/service/blueprint/blueprint.xsd"),
1:9a1ff22:                            loader.getId(W3C_XML_SCHEMA_NS_URI, BLUEPRINT_NAMESPACE, null, null),
1:9a1ff22:                            BLUEPRINT_NAMESPACE);
1:9a1ff22:                 loader.use(getClass().getResource("/org/apache/aries/blueprint/ext/impl/xml.xsd"),
1:9a1ff22:                            loader.getId(W3C_XML_SCHEMA_NS_URI, XML_NS_URI, null, null),
1:9a1ff22:                            XML_NS_URI);
1:9a1ff22: 
1:9a1ff22:                 // Create a schema for the namespaces
1:94f26b1:                 for (URI ns : handlers.keySet()) {
1:94f26b1:                     URL url = handlers.get(ns).getSchemaLocation(ns.toString());
1:94f26b1:                     if (url == null && locations != null) {
1:94f26b1:                         String loc = locations.get(ns.toString());
2:94f26b1:                         if (loc != null) {
1:94f26b1:                             url = handlers.get(ns).getSchemaLocation(loc);
1:9a1ff22:                         }
1:9a1ff22:                     }
1:6972a70:                     if (url == null) {
1:94f26b1:                         LOGGER.warn("No URL is defined for schema " + ns + ". This schema will not be validated");
1:94f26b1:                     } else {
1:9a1ff22:                         loader.use(url, loader.getId(W3C_XML_SCHEMA_NS_URI, ns.toString(), null, null), ns.toString());
1:94f26b1:                     }
1:94f26b1:                 }
1:94f26b1:                 for (Object ns : schemaMap.values()) {
1:94f26b1:                     URL url = bundle.getResource(ns.toString());
2:94f26b1:                     if (url == null) {
1:94f26b1:                         LOGGER.warn("No URL is defined for schema " + ns + ". This schema will not be validated");
1:94f26b1:                     } else {
1:9a1ff22:                         loader.use(url, loader.getId(W3C_XML_SCHEMA_NS_URI, ns.toString(), null, null), ns.toString());
1:94f26b1:                     }
1:94f26b1:                 }
1:94f26b1:                 synchronized (schemaFactory) {
1:9a1ff22:                     schemaFactory.setResourceResolver(loader);
1:9a1ff22:                     return schemaFactory.newSchema(loader.getSources());
1:94f26b1:                 }
1:94f26b1:             } finally {
1:9a1ff22:                 loader.close();
1:94f26b1:             }
1:94f26b1:         }
1:94f26b1: 
1:dcc3027:         public void addListener(Listener listener) {
1:dcc3027:             listeners.add(listener);
1:94f26b1:         }
1:94f26b1: 
1:dcc3027:         public void removeListener(Listener listener) {
1:3b2c33b:             listeners.remove(listener);
1:94f26b1:         }
1:dcc3027: 
1:3b2c33b:         public void destroy() {
1:453da8a:             synchronized (NamespaceHandlerRegistryImpl.this.sets) {
1:453da8a:                 NamespaceHandlerRegistryImpl.this.sets.remove(this);
1:94f26b1:             }
1:94f26b1:         }
1:dcc3027: 
1:3b2c33b:         public void registerHandler(URI uri, NamespaceHandler handler) {
1:3b2c33b:             if (namespaces.contains(uri) && handlers.get(uri) == null) {
1:3b2c33b:                 if (findCompatibleNamespaceHandler(uri) !=  null) {
1:dcc3027:                     for (Listener listener : listeners) {
1:94f26b1:                         try {
1:3b2c33b:                             listener.namespaceHandlerRegistered(uri);
2:3b2c33b:                         } catch (Throwable t) {
1:3b2c33b:                             LOGGER.debug("Unexpected exception when notifying a NamespaceHandler listener", t);
1:94f26b1:                         }
1:94f26b1:                     }
1:94f26b1:                 }
1:94f26b1:             }
1:94f26b1:         }
1:dcc3027: 
1:3b2c33b:         public void unregisterHandler(URI uri, NamespaceHandler handler) {
1:3b2c33b:             if (handlers.get(uri) == handler) {
1:3b2c33b:                 handlers.remove(uri);
1:dcc3027:                 for (Listener listener : listeners) {
1:94f26b1:                     try {
1:3b2c33b:                         listener.namespaceHandlerUnregistered(uri);
1:3b2c33b:                     } catch (Throwable t) {
1:3b2c33b:                         LOGGER.debug("Unexpected exception when notifying a NamespaceHandler listener", t);
1:94f26b1:                     }
1:94f26b1:                 }
1:b571b31:             }
1:b571b31:         }
1:dcc3027: 
1:3b2c33b:         private NamespaceHandler findCompatibleNamespaceHandler(URI ns) {
1:3b2c33b:             Set<NamespaceHandler> candidates = NamespaceHandlerRegistryImpl.this.handlers.get(ns);
1:3b2c33b:             if (candidates != null) {
1:3b2c33b:                 for (NamespaceHandler h : candidates) {
2:3b2c33b:                     Set<Class> classes = h.getManagedClasses();
2:3b2c33b:                     boolean compat = true;
2:3b2c33b:                     if (classes != null) {
2:3b2c33b:                         Set<Class> allClasses = new HashSet<Class>();
2:3b2c33b:                         for (Class cl : classes) {
2:3b2c33b:                             for (Class c = cl; c != null; c = c.getSuperclass()) {
2:3b2c33b:                                 allClasses.add(c);
2:3b2c33b:                                 for (Class i : c.getInterfaces()) {
2:3b2c33b:                                     allClasses.add(i);
1:f117d81:                                 }
1:f117d81:                             }
1:453da8a:                         }
2:3b2c33b:                         for (Class cl : allClasses) {
2:3b2c33b:                             Class clb;
1:dcc3027:                             try {
2:3b2c33b:                                 clb = bundle.loadClass(cl.getName());
2:3b2c33b:                                 if (clb != cl) {
2:3b2c33b:                                     compat = false;
1:1aa84c9:                                     break;
1:1aa84c9:                                 }
1:3b2c33b:                             } catch (ClassNotFoundException e) {
1:3b2c33b:                                 // Ignore
1:7a51969:                             } catch (NoClassDefFoundError e) {
1:7a51969:                                 // Ignore
1:1aa84c9:                             }
1:dcc3027:                         }
1:dcc3027:                     }
1:3b2c33b:                     if (compat) {
1:94f26b1:                         namespaces.add(ns);
1:fbc9ce1:                         handlers.put(ns, wrapIfNeeded(h));
1:3b2c33b:                         return h;
1:dcc3027:                     }
1:dcc3027:                 }
1:dcc3027:             }
1:94f26b1:             return null;
1:dcc3027:         }
1:dcc3027:     }
1:dcc3027: 
1:fbc9ce1:     /**
1:fbc9ce1:      * Wrap the handler if needed to fix its behavior.
1:fbc9ce1:      * When asked for a schema location, some simple handlers always return
1:fbc9ce1:      * the same url, whatever the asked location is.  This can lead to lots
1:fbc9ce1:      * of problems, so we need to verify and fix those behaviors.
1:fbc9ce1:      */
1:fbc9ce1:     private static NamespaceHandler wrapIfNeeded(final NamespaceHandler handler) {
1:fbc9ce1:         URL result = null;
1:fbc9ce1:         try {
1:fbc9ce1:             result = handler.getSchemaLocation("");
1:fbc9ce1:         } catch (Throwable t) {
1:fbc9ce1:             // Ignore
1:fbc9ce1:         }
1:fbc9ce1:         if (result != null) {
1:fbc9ce1:             LOGGER.warn("NamespaceHandler " + handler.getClass().getName() + " is behaving badly and should be fixed");
1:fbc9ce1:             final URL res = result;
1:fbc9ce1:             return new NamespaceHandler() {
1:fbc9ce1:                 final ConcurrentMap<String, Boolean> cache = new ConcurrentHashMap<String, Boolean>();
1:fbc9ce1:                 @Override
1:fbc9ce1:                 public URL getSchemaLocation(String s) {
1:fbc9ce1:                     URL url = handler.getSchemaLocation(s);
1:fbc9ce1:                     if (url != null && url.equals(res)) {
1:fbc9ce1:                         Boolean v, newValue;
1:fbc9ce1:                         Boolean valid = ((v = cache.get(s)) == null &&
1:fbc9ce1:                                 (newValue = isValidSchema(s, url)) != null &&
1:fbc9ce1:                                 (v = cache.putIfAbsent(s, newValue)) == null) ? newValue : v;
1:fbc9ce1:                         return valid ? url : null;
1:fbc9ce1:                     }
1:fbc9ce1:                     return url;
1:fbc9ce1:                 }
1:fbc9ce1:                 @Override
1:fbc9ce1:                 public Set<Class> getManagedClasses() {
1:fbc9ce1:                     return handler.getManagedClasses();
1:fbc9ce1:                 }
1:fbc9ce1:                 @Override
1:fbc9ce1:                 public Metadata parse(Element element, ParserContext parserContext) {
1:fbc9ce1:                     return handler.parse(element, parserContext);
1:fbc9ce1:                 }
1:fbc9ce1:                 @Override
1:fbc9ce1:                 public ComponentMetadata decorate(Node node, ComponentMetadata componentMetadata, ParserContext parserContext) {
1:fbc9ce1:                     return handler.decorate(node, componentMetadata, parserContext);
1:fbc9ce1:                 }
1:fbc9ce1:                 private boolean isValidSchema(String ns, URL url) {
1:fbc9ce1:                     try {
1:fbc9ce1:                         InputStream is = url.openStream();
1:fbc9ce1:                         try {
1:fbc9ce1:                             XMLStreamReader reader = XMLInputFactory.newFactory().createXMLStreamReader(is);
1:fbc9ce1:                             try {
1:fbc9ce1:                                 reader.nextTag();
1:fbc9ce1:                                 String nsuri = reader.getNamespaceURI();
1:fbc9ce1:                                 String name = reader.getLocalName();
1:fbc9ce1:                                 if ("http://www.w3.org/2001/XMLSchema".equals(nsuri) && "schema".equals(name)) {
1:fbc9ce1:                                     String target = reader.getAttributeValue(null, "targetNamespace");
1:fbc9ce1:                                     if (ns.equals(target)) {
1:fbc9ce1:                                         return true;
1:fbc9ce1:                                     }
1:fbc9ce1:                                 }
1:fbc9ce1:                             } finally {
1:fbc9ce1:                                 reader.close();
1:fbc9ce1:                             }
1:fbc9ce1:                         } finally {
1:fbc9ce1:                             is.close();
1:fbc9ce1:                         }
1:fbc9ce1:                     } catch (Throwable t) {
1:fbc9ce1:                         // Ignore
1:fbc9ce1:                     }
1:fbc9ce1:                     return false;
1:fbc9ce1:                 }
1:fbc9ce1:             };
1:fbc9ce1:         } else {
1:fbc9ce1:             return handler;
1:fbc9ce1:         }
1:fbc9ce1:     }
1:fbc9ce1: 
1:f13c6ac:     public static class LRUMap<K,V> extends AbstractMap<K,V> {
1:94f26b1: 
1:f13c6ac:         private final int bound;
1:f13c6ac:         private final LinkedList<Entry<K,V>> entries = new LinkedList<Entry<K,V>>();
1:dcc3027: 
1:f13c6ac:         private static class LRUEntry<K,V> implements Entry<K,V> {
1:f13c6ac:             private final K key;
1:f13c6ac:             private final V value;
1:dcc3027: 
1:f13c6ac:             private LRUEntry(K key, V value) {
1:f13c6ac:                 this.key = key;
1:f13c6ac:                 this.value = value;
1:94f26b1:             }
1:dcc3027: 
1:f13c6ac:             public K getKey() {
1:f13c6ac:                 return key;
1:94f26b1:             }
1:dcc3027: 
1:f13c6ac:             public V getValue() {
1:f13c6ac:                 return value;
1:9cbc0c8:             }
1:dcc3027: 
1:f13c6ac:             public V setValue(V value) {
1:f13c6ac:                 throw new UnsupportedOperationException();
1:9cbc0c8:             }
1:e010efe:         }
1:dcc3027: 
1:f13c6ac:         private LRUMap(int bound) {
1:f13c6ac:             this.bound = bound;
1:e010efe:         }
1:dcc3027: 
1:f13c6ac:         public V get(Object key) {
1:f13c6ac:             if (key == null) {
1:f13c6ac:                 throw new NullPointerException();
1:e010efe:             }
1:f13c6ac:             for (Entry<K,V> e : entries) {
1:f13c6ac:                 if (e.getKey().equals(key)) {
1:f13c6ac:                     entries.remove(e);
1:f13c6ac:                     entries.addFirst(e);
1:f13c6ac:                     return e.getValue();
1:e010efe:                 }
1:e010efe:             }
1:dcc3027:             return null;
1:e010efe:         }
1:dcc3027: 
1:f13c6ac:         public V put(K key, V value) {
1:f13c6ac:             if (key == null) {
1:f13c6ac:                 throw new NullPointerException();
1:3b2c33b:             }
1:f13c6ac:             V old = null;
1:f13c6ac:             for (Entry<K,V> e : entries) {
1:f13c6ac:                 if (e.getKey().equals(key)) {
1:f13c6ac:                     entries.remove(e);
1:f13c6ac:                     old = e.getValue();
1:9cbc0c8:                     break;
1:3b2c33b:                 }
1:3b2c33b:             }
1:f13c6ac:             if (value != null) {
1:f13c6ac:                 entries.addFirst(new LRUEntry<K,V>(key, value));
1:f13c6ac:                 while (entries.size() > bound) {
1:f13c6ac:                     entries.removeLast();
1:3b2c33b:                 }
1:3b2c33b:             }
1:f13c6ac:             return old;
1:3b2c33b:         }
1:dcc3027: 
1:f13c6ac:         public Set<Entry<K, V>> entrySet() {
1:f13c6ac:             return new AbstractSet<Entry<K,V>>() {
1:f13c6ac:                 public Iterator<Entry<K, V>> iterator() {
1:f13c6ac:                     return entries.iterator();
1:3b2c33b:                 }
1:dcc3027: 
1:f13c6ac:                 public int size() {
1:f13c6ac:                     return entries.size();
1:3b2c33b:                 }
1:94f26b1:             };
1:3b2c33b:         }
1:3b2c33b:     }
1:dcc3027: 
1:3b2c33b: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:fbc9ce1
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
1: import java.util.concurrent.ConcurrentMap;
1: import javax.xml.namespace.QName;
1: import javax.xml.parsers.DocumentBuilder;
1: import javax.xml.parsers.DocumentBuilderFactory;
1: import javax.xml.stream.XMLInputFactory;
1: import javax.xml.stream.XMLStreamReader;
1: import org.apache.aries.blueprint.ParserContext;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.w3c.dom.Document;
1: import org.w3c.dom.Element;
1: import org.w3c.dom.Node;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         handlers.put(ns, wrapIfNeeded(h));
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Wrap the handler if needed to fix its behavior.
1:      * When asked for a schema location, some simple handlers always return
1:      * the same url, whatever the asked location is.  This can lead to lots
1:      * of problems, so we need to verify and fix those behaviors.
1:      */
1:     private static NamespaceHandler wrapIfNeeded(final NamespaceHandler handler) {
1:         URL result = null;
1:         try {
1:             result = handler.getSchemaLocation("");
1:         } catch (Throwable t) {
1:             // Ignore
1:         }
1:         if (result != null) {
1:             LOGGER.warn("NamespaceHandler " + handler.getClass().getName() + " is behaving badly and should be fixed");
1:             final URL res = result;
1:             return new NamespaceHandler() {
1:                 final ConcurrentMap<String, Boolean> cache = new ConcurrentHashMap<String, Boolean>();
1:                 @Override
1:                 public URL getSchemaLocation(String s) {
1:                     URL url = handler.getSchemaLocation(s);
1:                     if (url != null && url.equals(res)) {
1:                         Boolean v, newValue;
1:                         Boolean valid = ((v = cache.get(s)) == null &&
1:                                 (newValue = isValidSchema(s, url)) != null &&
1:                                 (v = cache.putIfAbsent(s, newValue)) == null) ? newValue : v;
1:                         return valid ? url : null;
1:                     }
1:                     return url;
1:                 }
1:                 @Override
1:                 public Set<Class> getManagedClasses() {
1:                     return handler.getManagedClasses();
1:                 }
1:                 @Override
1:                 public Metadata parse(Element element, ParserContext parserContext) {
1:                     return handler.parse(element, parserContext);
1:                 }
1:                 @Override
1:                 public ComponentMetadata decorate(Node node, ComponentMetadata componentMetadata, ParserContext parserContext) {
1:                     return handler.decorate(node, componentMetadata, parserContext);
1:                 }
1:                 private boolean isValidSchema(String ns, URL url) {
1:                     try {
1:                         InputStream is = url.openStream();
1:                         try {
1:                             XMLStreamReader reader = XMLInputFactory.newFactory().createXMLStreamReader(is);
1:                             try {
1:                                 reader.nextTag();
1:                                 String nsuri = reader.getNamespaceURI();
1:                                 String name = reader.getLocalName();
1:                                 if ("http://www.w3.org/2001/XMLSchema".equals(nsuri) && "schema".equals(name)) {
1:                                     String target = reader.getAttributeValue(null, "targetNamespace");
1:                                     if (ns.equals(target)) {
1:                                         return true;
1:                                     }
1:                                 }
1:                             } finally {
1:                                 reader.close();
1:                             }
1:                         } finally {
1:                             is.close();
1:                         }
1:                     } catch (Throwable t) {
1:                         // Ignore
1:                     }
1:                     return false;
1:                 }
1:             };
1:         } else {
1:             return handler;
1:         }
1:     }
1: 
commit:6972a70
/////////////////////////////////////////////////////////////////////////
0:                         URL url = h.getSchemaLocation(namespaceURI);
1:                         if (url == null) {
0:                             url = h.getSchemaLocation(rid);
1:                         }
0:                             LOGGER.warn("Dynamically adding namespace handler {} to bundle {}/{}",
0:                                     nsUri, bundle.getSymbolicName(), bundle.getVersion());
1:                 LOGGER.warn("Unable to find namespace handler for {}", namespaceURI);
commit:9a1ff22
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;
1: import static javax.xml.XMLConstants.XML_NS_URI;
1: import static org.apache.aries.blueprint.parser.Parser.BLUEPRINT_NAMESPACE;
1: 
/////////////////////////////////////////////////////////////////////////
1:                         SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);
/////////////////////////////////////////////////////////////////////////
1:             this.namespaces = new HashSet<URI>(namespaces);
/////////////////////////////////////////////////////////////////////////
0:         private class Loader implements LSResourceResolver, AutoCloseable {
1:             final List<StreamSource> sources = new ArrayList<StreamSource>();
1:             final Map<String, URL> loaded = new HashMap<String, URL>();
1:             final Map<String, String> namespaces = new HashMap<String, String>();
1:             @Override
1:             public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {
1:                 // Compute id
1:                 String id;
1:                 String prevNamespace = baseURI != null ? namespaces.get(baseURI) : null;
1:                 if (namespaceURI != null && prevNamespace != null && namespaceURI.equals(prevNamespace)) {
1:                     // This is an include
1:                     id = getId(type, namespaceURI, publicId, systemId);
1:                 } else {
1:                     id = getId(type, namespaceURI, publicId, null);
1:                 }
1:                 // Check if it has already been loaded
1:                 if (loaded.containsKey(id)) {
1:                     return createLSInput(loaded.get(id), id, namespaceURI);
1:                 }
1:                 // Schema map
1:                 //-----------
1:                 // Use provided schema map to find the resource.
1:                 // If the schema map contains the namespaceURI, publicId or systemId,
1:                 // load the corresponding resource directly from the bundle.
1:                 String loc = null;
1:                 if (namespaceURI != null) {
1:                     loc = schemaMap.getProperty(namespaceURI);
1:                 }
1:                 if (loc == null && publicId != null) {
1:                     loc = schemaMap.getProperty(publicId);
1:                 }
1:                 if (loc == null && systemId != null) {
1:                     loc = schemaMap.getProperty(systemId);
1:                 }
1:                 if (loc != null) {
1:                     URL url = bundle.getResource(loc);
1:                     if (url != null) {
1:                         return createLSInput(url, id, namespaceURI);
1:                     }
1:                 }
1:                 // Relative uris
1:                 //---------------
1:                 // For relative uris, don't use the namespace handlers, but simply resolve the uri
1:                 // and use that one directly to load the resource.
1:                 String resolved = resolveIfRelative(systemId, baseURI);
1:                 if (resolved != null) {
1:                     URL url;
1:                     try {
1:                         url = new URL(resolved);
1:                     } catch (IOException e) {
1:                         throw new RuntimeException(e);
1:                     }
1:                     return createLSInput(url, id, namespaceURI);
1:                 }
1:                 // Only support xml schemas from now on
1:                 if (namespaceURI == null || !W3C_XML_SCHEMA_NS_URI.equals(type)) {
1:                     return null;
1:                 }
1:                 // We are now loading a schema, or schema part with
1:                 //  * notNull(namespaceURI)
1:                 //  * null(systemId) or absolute(systemId)
1:                 URI nsUri = URI.create(namespaceURI);
1:                 String rid = systemId != null ? systemId : namespaceURI;
1:                 NamespaceHandler h = getNamespaceHandler(nsUri);
1:                 // This is a resource from a known namespace
1:                 if (h != null) {
1:                     URL url = h.getSchemaLocation(rid);
1:                     if (isCorrectUrl(url)) {
1:                         return createLSInput(url, id, namespaceURI);
1:                     }
1:                 }
1:                 else {
1:                     // Ask known handlers if they have this schema
1:                     for (NamespaceHandler hd : handlers.values()) {
1:                         URL url = hd.getSchemaLocation(rid);
1:                         if (isCorrectUrl(url)) {
1:                             return createLSInput(url, id, namespaceURI);
1:                         }
1:                     }
0:                     // Find a compatible namespace handler
0:                     LOGGER.warn("Dynamically adding namespace handler {} to bundle {}/{}",
0:                             nsUri, bundle.getSymbolicName(), bundle.getVersion());
0:                     h = findCompatibleNamespaceHandler(nsUri);
1:                     if (h != null) {
1:                         URL url = h.getSchemaLocation(rid);
1:                         if (isCorrectUrl(url)) {
1:                             return createLSInput(url, id, namespaceURI);
1:                         }
1:                     }
1:                 }
1:                 return null;
1:             }
1: 
1:             public String getId(String type, String namespaceURI, String publicId, String systemId) {
1:                 return type + "|" + namespaceURI + "|" + publicId + "|" + systemId;
1:             }
1: 
1:             public StreamSource use(URL resource, String id, String namespace) throws IOException {
1:                 String url = resource.toExternalForm();
1:                 StreamSource ss = new StreamSource(resource.openStream(), url);
1:                 sources.add(ss);
1:                 loaded.put(id, resource);
1:                 namespaces.put(url, namespace);
1:                 return ss;
1:             }
1: 
1:             @Override
1:             public void close() {
1:                 for (StreamSource source : sources) {
1:                     closeQuietly(source.getInputStream());
1:                 }
1:             }
1: 
1:             public Source[] getSources() {
1:                 return sources.toArray(new Source[sources.size()]);
1:             }
1: 
1:             private boolean isCorrectUrl(URL url) {
1:                 return url != null && !loaded.values().contains(url);
1:             }
1:             private String resolveIfRelative(String systemId, String baseURI) {
1:                 if (baseURI != null && systemId != null) {
1:                     URI sId = URI.create(systemId);
1:                     if (!sId.isAbsolute()) {
1:                         return URI.create(baseURI).resolve(sId).toString();
1:                     }
1:                 }
1:                 return null;
1:             }
1:             private LSInput createLSInput(URL url, String id, String namespace) {
1:                 try {
1:                     return new SourceLSInput(use(url, id, namespace));
1:                 } catch (IOException e) {
1:                     throw new RuntimeException(e);
1:                 }
1:             }
1:         }
1: 
1:             Loader loader = new Loader();
1:                 loader.use(getClass().getResource("/org/osgi/service/blueprint/blueprint.xsd"),
1:                            loader.getId(W3C_XML_SCHEMA_NS_URI, BLUEPRINT_NAMESPACE, null, null),
1:                            BLUEPRINT_NAMESPACE);
1:                 loader.use(getClass().getResource("/org/apache/aries/blueprint/ext/impl/xml.xsd"),
1:                            loader.getId(W3C_XML_SCHEMA_NS_URI, XML_NS_URI, null, null),
1:                            XML_NS_URI);
1: 
1:                 // Create a schema for the namespaces
/////////////////////////////////////////////////////////////////////////
1:                         loader.use(url, loader.getId(W3C_XML_SCHEMA_NS_URI, ns.toString(), null, null), ns.toString());
/////////////////////////////////////////////////////////////////////////
1:                         loader.use(url, loader.getId(W3C_XML_SCHEMA_NS_URI, ns.toString(), null, null), ns.toString());
1:                     schemaFactory.setResourceResolver(loader);
1:                     return schemaFactory.newSchema(loader.getSources());
1:                 loader.close();
commit:94f26b1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 schema = doGetSchema(locations);
1:         private Schema doGetSchema(Map<String, String> locations) throws IOException, SAXException {
1:             if (schemaMap != null && !schemaMap.isEmpty()) {
1:                 return createSchema(locations);
1:             }
1:             // Find a schema that can handle all the requested namespaces
1:             // If it contains additional namespaces, it should not be a problem since
1:             // they won't be used at all
1:             Schema schema = getExistingSchema(handlers);
1:             if (schema == null) {
1:                 // Create schema
1:                 schema = createSchema(locations);
1:                 cacheSchema(handlers, schema);
1:             }
1:             return schema;
1:         }
1: 
1:         private Schema createSchema(Map<String, String> locations) throws IOException, SAXException {
0:             final List<StreamSource> schemaSources = new ArrayList<StreamSource>();
1:             try {
0:                 schemaSources.add(new StreamSource(getClass().getResourceAsStream("/org/apache/aries/blueprint/blueprint.xsd")));
0:                 schemaSources.add(new StreamSource(getClass().getResourceAsStream("/org/apache/aries/blueprint/ext/impl/xml.xsd")));
0:                 // Create a schema for all namespaces known at this point
0:                 // It will speed things as it can be reused for all other blueprint containers
1:                 for (URI ns : handlers.keySet()) {
1:                     URL url = handlers.get(ns).getSchemaLocation(ns.toString());
1:                     if (url == null && locations != null) {
1:                         String loc = locations.get(ns.toString());
1:                         if (loc != null) {
1:                             url = handlers.get(ns).getSchemaLocation(loc);
1:                         }
1:                     }
1:                     if (url == null) {
1:                         LOGGER.warn("No URL is defined for schema " + ns + ". This schema will not be validated");
1:                     } else {
0:                         schemaSources.add(new StreamSource(url.openStream(), url.toExternalForm()));
1:                     }
1:                 }
1:                 for (Object ns : schemaMap.values()) {
1:                     URL url = bundle.getResource(ns.toString());
1:                     if (url == null) {
1:                         LOGGER.warn("No URL is defined for schema " + ns + ". This schema will not be validated");
1:                     } else {
0:                         schemaSources.add(new StreamSource(url.openStream(), url.toExternalForm()));
1:                     }
1:                 }
0:                 LSResourceResolver resolver = new LSResourceResolver() {
0:                     public LSInput resolveResource(String type,
0:                                                    final String namespaceURI,
0:                                                    final String publicId,
0:                                                    String systemId,
0:                                                    String baseURI) {
0:                         URI nsUri = namespaceURI != null ? URI.create(namespaceURI) : null;
0:                         // Use provided schema map to find the resource
0:                         String loc = null;
0:                         if (namespaceURI != null) {
0:                             loc = schemaMap.getProperty(namespaceURI);
1:                         }
0:                         if (loc == null && publicId != null) {
0:                             loc = schemaMap.getProperty(publicId);
1:                         }
0:                         if (loc == null && systemId != null) {
0:                             loc = schemaMap.getProperty(systemId);
1:                         }
1:                         if (loc != null) {
0:                             URL url = bundle.getResource(loc);
1:                             if (url != null) {
0:                                 return createLSInput(url);
1:                             }
1:                         }
0:                         // Support include-relative-path case
0:                         if (baseURI != null && systemId != null && !systemId.matches("^[a-z][-+.0-9a-z]*:.*")) {
0:                             URL url;
1:                             try {
0:                                 url = new URL(new URL(baseURI), systemId);
1:                             } catch (IOException e) {
0:                                 throw new RuntimeException(e);
1:                             }
0:                             return createLSInput(url);
1:                         }
0:                         if (namespaceURI != null) {
0:                             String id = systemId != null ? systemId : namespaceURI;
0:                             // This is a namespace with a known handler
0:                             NamespaceHandler h = getNamespaceHandler(nsUri);
1:                             if (h == null) {
0:                                 // Find a compatible namespace
0:                                 LOGGER.warn("Dynamically adding namespace handler {} to bundle {}/{}",
0:                                         nsUri, bundle.getSymbolicName(), bundle.getVersion());
0:                                 h = findCompatibleNamespaceHandler(nsUri);
1:                             }
0:                             // Load from the handler
0:                             if (h != null) {
0:                                 URL url = h.getSchemaLocation(id);
1:                                 if (url != null) {
0:                                     return createLSInput(url);
1:                                 }
1:                             } else {
0:                                 throw new MissingNamespaceException(nsUri);
1:                             }
1:                         }
1:                         return null;
1:                     }
1: 
0:                     private LSInput createLSInput(URL url) {
1:                         try {
0:                             String systemId = url.toExternalForm();
0:                             final StreamSource source = new StreamSource(url.openStream(), systemId);
0:                             schemaSources.add(source);
0:                             return new SourceLSInput(source);
1:                         } catch (IOException e) {
0:                             throw new RuntimeException(e);
1:                         }
1:                     }
1:                 };
1:                 synchronized (schemaFactory) {
0:                     schemaFactory.setResourceResolver(resolver);
0:                     return schemaFactory.newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
1:                 }
1:             } finally {
0:                 for (StreamSource s : schemaSources) {
0:                     closeQuietly(s.getInputStream());
1:                 }
1:             }
1:         }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                         namespaces.add(ns);
commit:b571b31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final Map<String, URI> urlToNamespace = new HashMap<String, URI>();
0:             schemaSources.add(new StreamSource(getClass().getResourceAsStream("/org/apache/aries/blueprint/ext/impl/xml.xsd")));
/////////////////////////////////////////////////////////////////////////
0:                     urlToNamespace.put(url.toExternalForm(), ns);
/////////////////////////////////////////////////////////////////////////
0:                 schemaFactory.setResourceResolver(new BundleResourceResolver(handlers, schemaMap, bundle, schemaSources, urlToNamespace));
/////////////////////////////////////////////////////////////////////////
0:     private static class BundleResourceResolver implements LSResourceResolver {
0:         private final Map<String, URI> urlToNamespace;
0:         public BundleResourceResolver(Map<URI, NamespaceHandler> handlers, Properties schemaMap, Bundle bundle, List<StreamSource> schemaSources, Map<String, URI> urlToNamespace) {
0:             this.urlToNamespace = urlToNamespace;
0:                                        String systemId,
0:                                        String baseURI) {
0:             URI nsUri = namespaceURI != null ? URI.create(namespaceURI) : null;
0:             // Use provided schema map to find the resource
/////////////////////////////////////////////////////////////////////////
0:                     return createLSInput(url, nsUri);
0:             // Support include-relative-path case
0:             if (baseURI != null && systemId != null && !systemId.matches("^[a-z][-+.0-9a-z]*:.*")) {
0:                 URL url;
1:                 try {
0:                     url = new URL(new URL(baseURI), systemId);
0:                 } catch (IOException e) {
0:                     throw new RuntimeException(e);
1:                 }
0:                 return createLSInput(url, nsUri);
1:             }
0:             if (namespaceURI != null) {
0:                 String id = systemId != null ? systemId : namespaceURI;
0:                 // This is a namespace with a known handler
0:                 if (handlers.containsKey(nsUri)) {
0:                     NamespaceHandler h = handlers.get(nsUri);
0:                     if (h != null) {
0:                         URL url = h.getSchemaLocation(id);
0:                         if (url != null) {
0:                             return createLSInput(url, nsUri);
1:                         }
0:                 // This is a resource loaded from a schema
0:                 if (baseURI != null && urlToNamespace.containsKey(baseURI)) {
0:                     NamespaceHandler h = handlers.get(urlToNamespace.get(baseURI));
0:                     if (h != null) {
0:                         URL url = h.getSchemaLocation(id);
0:                         if (url != null) {
0:                             return createLSInput(url, nsUri);
1:                         }
0:         private LSInput createLSInput(URL url, URI nsUri) {
0:                 String systemId = url.toExternalForm();
0:                 final StreamSource source = new StreamSource(url.openStream(), systemId);
0:                 if (nsUri != null) {
0:                     urlToNamespace.put(systemId, nsUri);
1:                 }
0:                 return new SourceLSInput(source);
1:     private static class SourceLSInput implements LSInput {
1:         public SourceLSInput(StreamSource source) {
/////////////////////////////////////////////////////////////////////////
1:             return source.getSystemId();
1:             return null;
commit:b685f35
/////////////////////////////////////////////////////////////////////////
0:                 schemaFactory.setResourceResolver(new BundleResourceResolver(handlers, schemaMap, bundle, schemaSources));
/////////////////////////////////////////////////////////////////////////
1:         private final Map<URI, NamespaceHandler> handlers;
0:         public BundleResourceResolver(Map<URI, NamespaceHandler> handlers, Properties schemaMap, Bundle bundle, List<StreamSource> schemaSources) {
0:             this.handlers = handlers;
/////////////////////////////////////////////////////////////////////////
0:             for (NamespaceHandler h : handlers.values()) {
commit:e09bd9c
/////////////////////////////////////////////////////////////////////////
1:             Bundle bundle = reference.getBundle();
1:             // If bundle is null, the service has already been unregistered,
1:             // so do nothing in that case
1:             if (bundle != null) {
1:                 LOGGER.warn("Error resolving NamespaceHandler, null Service obtained from tracked ServiceReference {} for bundle {}/{}",
1:                         reference.toString(), reference.getBundle().getSymbolicName(), reference.getBundle().getVersion());
1:             }
commit:f117d81
/////////////////////////////////////////////////////////////////////////
0:                              final Properties schemaMap,
0:                              Map<String, String> locations) throws IOException, SAXException {
0:             return createSchema(handlers, bundle, schemaMap, locations);
/////////////////////////////////////////////////////////////////////////
0:             schema = createSchema(handlers, bundle, schemaMap, locations);
/////////////////////////////////////////////////////////////////////////
0:                                 Properties schemaMap,
0:                                 Map<String, String> locations) throws IOException, SAXException {
/////////////////////////////////////////////////////////////////////////
0:                 if (url == null && locations != null) {
0:                     String loc = locations.get(ns.toString());
0:                     if (loc != null) {
0:                         url = handlers.get(ns).getSchemaLocation(loc);
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             return getSchema(null);
1:         }
1: 
1:         public Schema getSchema(Map<String, String> locations) throws SAXException, IOException {
0:                 schema = NamespaceHandlerRegistryImpl.this.getSchema(handlers, bundle, schemaMap, locations);
commit:db4243b
/////////////////////////////////////////////////////////////////////////
0:             LOGGER.warn("Error resolving NamespaceHandler, null Service obtained from tracked ServiceReference {} for bundle {}/{}",
0:                     reference.toString(), reference.getBundle().getSymbolicName(), reference.getBundle().getVersion());
commit:453da8a
/////////////////////////////////////////////////////////////////////////
1:     // Access to this variable is must be synchronized on itself
1:     private final ArrayList<NamespaceHandlerSetImpl> sets =
1:                         new ArrayList<NamespaceHandlerSetImpl>();
/////////////////////////////////////////////////////////////////////////
1:                 List<NamespaceHandlerSetImpl> sets;
1:                 synchronized (this.sets) {
1:                     sets = new ArrayList<NamespaceHandlerSetImpl>(this.sets);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             List<NamespaceHandlerSetImpl> sets;
1:             synchronized (this.sets) {
1:                 sets = new ArrayList<NamespaceHandlerSetImpl>(this.sets);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         NamespaceHandlerSetImpl s;
1:         synchronized (sets) {
1:             s = new NamespaceHandlerSetImpl(uris, bundle);
1:             sets.add(s);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             synchronized (NamespaceHandlerRegistryImpl.this.sets) {
1:                 NamespaceHandlerRegistryImpl.this.sets.remove(this);
1:             }
commit:1aa84c9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // Access to the LRU schemas map is synchronized on itself
1:     private final LRUMap<Map<URI, NamespaceHandler>, Reference<Schema>> schemas =
/////////////////////////////////////////////////////////////////////////
0:         Schema schema = getExistingSchema(handlers);
1:         if (schema == null) {
0:             // Create schema
0:             schema = createSchema(handlers, bundle, schemaMap);
0:             cacheSchema(handlers, schema);
1:         return schema;
1:         synchronized (schemas) {
1:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
1:                 boolean found = true;
1:                 for (URI uri : handlers.keySet()) {
1:                     if (!handlers.get(uri).equals(key.get(uri))) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     return schemas.get(key).get();
1:             return null;
1:         synchronized (schemas) {
1:             List<Map<URI, NamespaceHandler>> keys = new ArrayList<Map<URI, NamespaceHandler>>();
1:             for (Map<URI, NamespaceHandler> key : keys) {
1:                 schemas.remove(key);
1:         synchronized (schemas) {
1:             // Remove schemas that are fully included
1:             for (Iterator<Map<URI, NamespaceHandler>> iterator = schemas.keySet().iterator(); iterator.hasNext();) {
1:                 Map<URI, NamespaceHandler> key = iterator.next();
1:                 boolean found = true;
1:                 for (URI uri : key.keySet()) {
1:                     if (!key.get(uri).equals(handlers.get(uri))) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     iterator.remove();
1:             // Add our new schema
1:             schemas.put(handlers, new SoftReference<Schema>(schema));
commit:dcc3027
/////////////////////////////////////////////////////////////////////////
1: import java.io.Closeable;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.CopyOnWriteArraySet;
0: import java.util.concurrent.locks.ReadWriteLock;
0: import java.util.concurrent.locks.ReentrantReadWriteLock;
0: import javax.xml.XMLConstants;
1: import javax.xml.transform.Source;
1: import javax.xml.transform.stream.StreamSource;
/////////////////////////////////////////////////////////////////////////
1: import org.w3c.dom.ls.LSInput;
1: import org.w3c.dom.ls.LSResourceResolver;
/////////////////////////////////////////////////////////////////////////
1:     // The bundle context is thread safe
1: 
1:     // The service tracker is thread safe
1: 
1:     // The handlers map is concurrent
1:     private final ConcurrentHashMap<URI, CopyOnWriteArraySet<NamespaceHandler>> handlers =
1:                         new ConcurrentHashMap<URI, CopyOnWriteArraySet<NamespaceHandler>>();
1: 
0:     // Access to the LRU schemas map is synchronized on the lock object
0:     private final Map<Map<URI, NamespaceHandler>, Reference<Schema>> schemas =
1:                         new LRUMap<Map<URI, NamespaceHandler>, Reference<Schema>>(10);
1: 
0:     // Lock to protect access to the schema list
0:     private final ReadWriteLock lock = new ReentrantReadWriteLock();
1: 
1:     // Access to this factory is synchronized on itself
1:     private final SchemaFactory schemaFactory =
0:                         SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
1: 
0:     // Access to this variable is not synchronized.  The list itself is concurrent
0:     private final CopyOnWriteArrayList<NamespaceHandlerSetImpl> sets =
0:                         new CopyOnWriteArrayList<NamespaceHandlerSetImpl>();
1:         LOGGER.debug("Adding NamespaceHandler " + reference.toString());
1:         if (handler != null) {
/////////////////////////////////////////////////////////////////////////
1:         } else {
0:             LOGGER.warn("Error resolving NamespaceHandler, null Service obtained from tracked ServiceReference {} for bundle {}, ver {}",
0:                     new Object[] { reference.toString(), reference.getBundle().getSymbolicName(), reference.getBundle().getVersion() });
/////////////////////////////////////////////////////////////////////////
1:             LOGGER.debug("Removing NamespaceHandler " + reference.toString());
/////////////////////////////////////////////////////////////////////////
1:     public void registerHandler(NamespaceHandler handler, Map properties) {
1:             CopyOnWriteArraySet<NamespaceHandler> h = handlers.putIfAbsent(uri, new CopyOnWriteArraySet<NamespaceHandler>());
1:                 h = handlers.get(uri);
/////////////////////////////////////////////////////////////////////////
1:     public void unregisterHandler(NamespaceHandler handler, Map properties) {
1:             CopyOnWriteArraySet<NamespaceHandler> h = handlers.get(uri);
1:             if (!h.remove(handler)) {
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalArgumentException("NamespaceHandler service does not have an associated "
1:                             + NAMESPACE + " property defined");
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalArgumentException("NamespaceHandler service has an associated "
1:                             + NAMESPACE + " property defined which can not be converted to an array of URI");
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalArgumentException("NamespaceHandler service has an associated "
1:                             + NAMESPACE + " property defined which can not be converted to an array of URI");
1:     public NamespaceHandlerSet getNamespaceHandlers(Set<URI> uris, Bundle bundle) {
/////////////////////////////////////////////////////////////////////////
1: 
0:     private Schema getSchema(Map<URI, NamespaceHandler> handlers,
0:                              final Bundle bundle,
0:                              final Properties schemaMap) throws IOException, SAXException {
0:         if (schemaMap != null && !schemaMap.isEmpty()) {
0:             return createSchema(handlers, bundle, schemaMap);
1:         }
0:         lock.readLock().lock();
1:         try {
0:             Schema schema = getExistingSchema(handlers);
0:             if (schema != null) {
0:                 return schema;
1:             }
1:         } finally {
0:             lock.readLock().unlock();
1:         }
0:         // Create schema
0:         lock.writeLock().lock();
1:         try {
0:             Schema schema = getExistingSchema(handlers);
0:             if (schema == null) {
0:                 schema = createSchema(handlers, bundle, schemaMap);
0:                 cacheSchema(handlers, schema);
1:             }
0:             return schema;
1:         } finally {
0:             lock.writeLock().unlock();
1:         }
1:     }
1: 
1:     private Schema getExistingSchema(Map<URI, NamespaceHandler> handlers) {
1:         for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:             boolean found = true;
0:             for (URI uri : handlers.keySet()) {
0:                 if (!handlers.get(uri).equals(key.get(uri))) {
0:                     found = false;
0:             if (found) {
0:                 return schemas.get(key).get();
1:             }
1:         return null;
1:     }
1: 
1:     private void removeSchemasFor(NamespaceHandler handler) {
0:         List<Map<URI, NamespaceHandler>> keys = new ArrayList<Map<URI, NamespaceHandler>>();
0:         lock.readLock().lock();
1:         try {
1:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
1:                 if (key.values().contains(handler)) {
1:                     keys.add(key);
1:                 }
1:             }
1:         } finally {
0:             lock.readLock().unlock();
1:         }
0:         if (!keys.isEmpty()) {
0:             lock.writeLock().lock();
0:                 for (Map<URI, NamespaceHandler> key : keys) {
0:                     schemas.remove(key);
0:                 lock.writeLock().unlock();
1:             }
1:         }
1:     }
1: 
1:     private void cacheSchema(Map<URI, NamespaceHandler> handlers, Schema schema) {
0:         // Remove schemas that are fully included
0:         for (Iterator<Map<URI, NamespaceHandler>> iterator = schemas.keySet().iterator(); iterator.hasNext();) {
0:             Map<URI, NamespaceHandler> key = iterator.next();
0:             boolean found = true;
0:             for (URI uri : key.keySet()) {
0:                 if (!key.get(uri).equals(handlers.get(uri))) {
0:                     found = false;
1:                     break;
1:                 }
1:             }
0:             if (found) {
0:                 iterator.remove();
1:                 break;
1:             }
1:         }
0:         // Add our new schema
0:         schemas.put(handlers, new SoftReference<Schema>(schema));
1:     }
1: 
0:     private Schema createSchema(Map<URI, NamespaceHandler> handlers,
0:                                 Bundle bundle,
0:                                 Properties schemaMap) throws IOException, SAXException {
0:         final List<StreamSource> schemaSources = new ArrayList<StreamSource>();
1:         try {
0:             schemaSources.add(new StreamSource(getClass().getResourceAsStream("/org/apache/aries/blueprint/blueprint.xsd")));
0:             // Create a schema for all namespaces known at this point
0:             // It will speed things as it can be reused for all other blueprint containers
0:             for (URI ns : handlers.keySet()) {
0:                 URL url = handlers.get(ns).getSchemaLocation(ns.toString());
0:                 if (url == null) {
0:                     LOGGER.warn("No URL is defined for schema " + ns + ". This schema will not be validated");
1:                 } else {
0:                     schemaSources.add(new StreamSource(url.openStream(), url.toExternalForm()));
1:                 }
1:             }
0:             for (Object ns : schemaMap.values()) {
0:                 URL url = bundle.getResource(ns.toString());
0:                 if (url == null) {
0:                     LOGGER.warn("No URL is defined for schema " + ns + ". This schema will not be validated");
1:                 } else {
0:                     schemaSources.add(new StreamSource(url.openStream(), url.toExternalForm()));
1:                 }
1:             }
0:             synchronized (schemaFactory) {
0:                 schemaFactory.setResourceResolver(new BundleResourceResolver(schemaMap, bundle, schemaSources));
0:                 return schemaFactory.newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
1:             }
1:         } finally {
0:             for (StreamSource s : schemaSources) {
0:                 closeQuietly(s.getInputStream());
1:             }
1:         }
1:     }
1: 
1:     private static void closeQuietly(Closeable closeable) {
1:         try {
1:             if (closeable != null) {
1:                 closeable.close();
1:             }
0:         } catch (IOException e) {
1:             // Ignore
1:         }
1:     }
1: 
0:     private class BundleResourceResolver implements LSResourceResolver {
0:         private final Properties schemaMap;
1:         private final Bundle bundle;
0:         private final List<StreamSource> schemaSources;
1: 
0:         public BundleResourceResolver(Properties schemaMap, Bundle bundle, List<StreamSource> schemaSources) {
0:             this.schemaMap = schemaMap;
1:             this.bundle = bundle;
0:             this.schemaSources = schemaSources;
1:         }
1: 
0:         public LSInput resolveResource(String type,
0:                                        final String namespaceURI,
0:                                        final String publicId,
0:                                        String systemId, String baseURI) {
0:             String loc = null;
0:             if (namespaceURI != null) {
0:                 loc = schemaMap.getProperty(namespaceURI);
1:             }
0:             if (loc == null && publicId != null) {
0:                 loc = schemaMap.getProperty(publicId);
1:             }
0:             if (loc == null && systemId != null) {
0:                 loc = schemaMap.getProperty(systemId);
1:             }
0:             if (loc != null) {
0:                 URL url = bundle.getResource(loc);
0:                 if (url != null) {
0:                         StreamSource source
0:                                 = new StreamSource(url.openStream(), url.toExternalForm());
0:                         schemaSources.add(source);
0:                         return new SourceLSInput(source, publicId, url);
0:                         throw new RuntimeException(e);
0:             URI uri = URI.create(namespaceURI);
0:             Set<NamespaceHandler> hs = NamespaceHandlerRegistryImpl.this.handlers.get(uri);
0:             if (hs == null) {
1:                 return null;
1:             }
0:             for (NamespaceHandler h : hs) {
0:                 URL url = h.getSchemaLocation(namespaceURI);
0:                 if (url != null) {
0:                     // handling include-relative-path case
0:                     if (systemId != null && !systemId.matches("^[a-z][-+.0-9a-z]*:.*")) {
1:                         try {
0:                             url = new URL(url, systemId);
1:                         } catch (Exception e) {
0:                             // ignore and use the given systemId
1:                         }
1:                     }
1:                     try {
0:                         final StreamSource source = new StreamSource(url.openStream(), url.toExternalForm());
0:                         schemaSources.add(source);
0:                         return new SourceLSInput(source, publicId, url);
0:                     } catch (IOException e) {
0:                         throw new RuntimeException(e);
1:                     }
1:                 }
1:             }
1:             return null;
1: 
1:         private final StreamSource source;
0:         private final URL systemId;
0:         private final String publicId;
1: 
0:         public SourceLSInput(StreamSource source, String publicId, URL systemId) {
1:             this.source = source;
0:             this.publicId = publicId;
0:             this.systemId = systemId;
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1:         private final List<Listener> listeners;
/////////////////////////////////////////////////////////////////////////
1:             this.listeners = new CopyOnWriteArrayList<Listener>();
/////////////////////////////////////////////////////////////////////////
1:                     closeQuietly(ins);
/////////////////////////////////////////////////////////////////////////
1:         public void addListener(Listener listener) {
1:             listeners.add(listener);
1:         public void removeListener(Listener listener) {
/////////////////////////////////////////////////////////////////////////
1:                     for (Listener listener : listeners) {
/////////////////////////////////////////////////////////////////////////
1:                 for (Listener listener : listeners) {
/////////////////////////////////////////////////////////////////////////
commit:e9345fa
/////////////////////////////////////////////////////////////////////////
0:         lock.readLock().lock();
0:         try {
0:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:                 if (key.values().contains(handler)) {
0:                     keys.add(key);
1:                 }
0:         } finally {
0:             lock.readLock().unlock();
0:         if (!keys.isEmpty()) {
0:             lock.writeLock().lock();
0:             try {
0:                 for (Map<URI, NamespaceHandler> key : keys) {
0:                     schemas.remove(key);
1:                 }
0:             } finally {
0:                 lock.writeLock().unlock();
1:             }
commit:9cbc0c8
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.CopyOnWriteArraySet;
0: import javax.xml.XMLConstants;
0: import javax.xml.transform.Source;
0: import javax.xml.transform.stream.StreamSource;
/////////////////////////////////////////////////////////////////////////
0: import org.w3c.dom.ls.LSInput;
0: import org.w3c.dom.ls.LSResourceResolver;
1:  *
1: 
0:     // The bundle context is thread safe
1: 
0:     // The service tracker is thread safe
1: 
0:     // The handlers map is concurrent
0:     private final ConcurrentHashMap<URI, CopyOnWriteArraySet<NamespaceHandler>> handlers;
1: 
0:     // Access to the LRU schemas map is synchronized on itself
0:     private final Map<Map<URI, NamespaceHandler>, Reference<Schema>> schemas =
0:                         new LRUMap<Map<URI, NamespaceHandler>, Reference<Schema>>(10);
1: 
0:     // Access to this factory is synchronized on itself
0:     private final SchemaFactory schemaFactory;
1: 
0:     // Access to this variable is not synchronized.  The list itself is concurrent
0:     private final CopyOnWriteArrayList<NamespaceHandlerSetImpl> sets;
0:         handlers = new ConcurrentHashMap<URI, CopyOnWriteArraySet<NamespaceHandler>>();
0:         sets = new CopyOnWriteArrayList<NamespaceHandlerSetImpl>();
0:         schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
0:         LOGGER.debug("Adding NamespaceHandler " + reference.toString());
0:         if (handler != null) {
/////////////////////////////////////////////////////////////////////////
0:     public void registerHandler(NamespaceHandler handler, Map properties) {
0:             CopyOnWriteArraySet<NamespaceHandler> h = handlers.putIfAbsent(uri, new CopyOnWriteArraySet<NamespaceHandler>());
0:                 h = handlers.get(uri);
/////////////////////////////////////////////////////////////////////////
0:     public void unregisterHandler(NamespaceHandler handler, Map properties) {
0:             CopyOnWriteArraySet<NamespaceHandler> h = handlers.get(uri);
0:             if (!h.remove(handler)) {
0:         synchronized (schemas) {
0:             List<Map<URI, NamespaceHandler>> keys = new ArrayList<Map<URI, NamespaceHandler>>();
0:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:                 if (key.values().contains(handler)) {
0:                     keys.add(key);
1:                 }
1:             }
0:             for (Map<URI, NamespaceHandler> key : keys) {
0:                 schemas.remove(key);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
0:     public NamespaceHandlerSet getNamespaceHandlers(Set<URI> uris, Bundle bundle) {
/////////////////////////////////////////////////////////////////////////
0:     public Schema getSchema(Map<URI, NamespaceHandler> handlers)
0:             throws IOException, SAXException {
1: 
0:     private Schema getSchema(Map<URI, NamespaceHandler> handlers,
0:                              final Bundle bundle,
0:                              final Properties schemaMap) throws IOException, SAXException {
0:             Schema schema = getExistingSchema(handlers);
0:             if (schema != null) {
0:                 return schema;
0:         synchronized (schemaFactory) {
0:             // Just double check in case the schema has just been created
0:             if (schemaMap == null || schemaMap.isEmpty()) {
0:                 Schema schema = getExistingSchema(handlers);
0:                 if (schema != null) {
0:                     return schema;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
0:                 schemaFactory.setResourceResolver(new LSResourceResolver() {
0:                     public LSInput resolveResource(String type,
0:                                                    final String namespaceURI,
/////////////////////////////////////////////////////////////////////////
0:                                     StreamSource source
0:                                             = new StreamSource(url.openStream(), url.toExternalForm());
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:                                     final StreamSource source
0:                                             = new StreamSource(url.openStream(), url.toExternalForm());
/////////////////////////////////////////////////////////////////////////
1: 
0:                 Schema schema = schemaFactory.newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
0:                 synchronized (schemas) {
0:                     // Remove schemas that are fully included
0:                     for (Iterator<Map<URI, NamespaceHandler>> iterator = schemas.keySet().iterator(); iterator.hasNext();) {
0:                         Map<URI, NamespaceHandler> key = iterator.next();
0:                         boolean found = true;
0:                         for (URI uri : key.keySet()) {
0:                             if (!key.get(uri).equals(handlers.get(uri))) {
0:                                 found = false;
1:                                 break;
1:                             }
1:                         }
0:                         if (found) {
0:                             iterator.remove();
0:                     // Add our new schema
0:                     if (schemaMap.isEmpty()) {
0:                         //only cache non-custom schemas
0:                         schemas.put(handlers, new SoftReference<Schema>(schema));
0:                     return schema;
/////////////////////////////////////////////////////////////////////////
1: 
0:     private Schema getExistingSchema(Map<URI, NamespaceHandler> handlers) {
0:         synchronized (schemas) {
0:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:                 boolean found = true;
0:                 for (URI uri : handlers.keySet()) {
0:                     if (!handlers.get(uri).equals(key.get(uri))) {
0:                         found = false;
0:                         break;
1:                     }
1:                 }
0:                 if (found) {
0:                     return schemas.get(key).get();
1:                 }
1:             }
1:             return null;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             this.handlers = new HashMap<URI, NamespaceHandler>();
/////////////////////////////////////////////////////////////////////////
0:         public void addListener(Listener listener) {
0:         public void removeListener(Listener listener) {
commit:ef8161c
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.util.concurrent.locks.ReadWriteLock;
0: import java.util.concurrent.locks.ReentrantReadWriteLock;
0: import javax.xml.XMLConstants;
0: import javax.xml.transform.Source;
0: import javax.xml.transform.stream.StreamSource;
/////////////////////////////////////////////////////////////////////////
0: import org.w3c.dom.ls.LSInput;
0: import org.w3c.dom.ls.LSResourceResolver;
1:  *
1: 
/////////////////////////////////////////////////////////////////////////
0:     private final ReadWriteLock lock = new ReentrantReadWriteLock();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     public Schema getSchema(Map<URI, NamespaceHandler> handlers)
0:             throws IOException, SAXException {
1: 
0:     private Schema getSchema(Map<URI, NamespaceHandler> handlers,
0:                              final Bundle bundle,
0:                              final Properties schemaMap) throws IOException, SAXException {
0:             try {
0:                 lock.readLock().lock();
0:                 for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:                     boolean found = true;
0:                     for (URI uri : handlers.keySet()) {
0:                         if (!handlers.get(uri).equals(key.get(uri))) {
0:                             found = false;
0:                             break;
1:                         }
1:                     }
0:                     if (found) {
0:                         return schemas.get(key).get();
0:             } finally {
0:                 lock.readLock().unlock();
0:         try {
0:             lock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
0:                     public LSInput resolveResource(String type,
0:                                                    final String namespaceURI,
/////////////////////////////////////////////////////////////////////////
0:                                     StreamSource source
0:                                             = new StreamSource(url.openStream(), url.toExternalForm());
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:                                     final StreamSource source
0:                                             = new StreamSource(url.openStream(), url.toExternalForm());
/////////////////////////////////////////////////////////////////////////
1: 
0:                 Schema schema = factory.newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
/////////////////////////////////////////////////////////////////////////
0:                 return schema;
/////////////////////////////////////////////////////////////////////////
0:         } finally {
0:             lock.writeLock().unlock();
1: 
commit:e010efe
/////////////////////////////////////////////////////////////////////////
0:             boolean found = true;
0:             for (URI uri : handlers.keySet()) {
0:                 if (!handlers.get(uri).equals(key.get(uri))) {
0:                     found = false;
0:                     break;
1:                 }
1:             }
0:             if (found) {
/////////////////////////////////////////////////////////////////////////
0:                 // Remove schemas that are fully included
0:                 for (Iterator<Map<URI, NamespaceHandler>> iterator = schemas.keySet().iterator(); iterator.hasNext();) {
0:                     Map<URI, NamespaceHandler> key = iterator.next();
0:                     boolean found = true;
0:                     for (URI uri : key.keySet()) {
0:                         if (!key.get(uri).equals(handlers.get(uri))) {
0:                             found = false;
0:                             break;
1:                         }
1:                     }
0:                     if (found) {
0:                         iterator.remove();
0:                         break;
1:                     }
1:                 }
0:                 // Add our new schema
commit:7a51969
/////////////////////////////////////////////////////////////////////////
1:                             } catch (NoClassDefFoundError e) {
1:                                 // Ignore
commit:3b2c33b
/////////////////////////////////////////////////////////////////////////
1: import java.lang.ref.Reference;
1: import java.lang.ref.SoftReference;
0: import java.util.AbstractMap;
0: import java.util.AbstractSet;
0: import java.util.Iterator;
0: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Bundle;
/////////////////////////////////////////////////////////////////////////
0:     private final Map<URI, Set<NamespaceHandler>> handlers;
0:     private final Map<Map<URI, NamespaceHandler>, Reference<Schema>> schemas = new LRUMap<Map<URI, NamespaceHandler>, Reference<Schema>>(10);
0:     private List<NamespaceHandlerSetImpl> sets;
0:         handlers = new HashMap<URI, Set<NamespaceHandler>>();
0:         sets = new ArrayList<NamespaceHandlerSetImpl>();
/////////////////////////////////////////////////////////////////////////
0:             Set<NamespaceHandler> h = handlers.get(uri);
0:             if (h == null) {
0:                 h = new HashSet<NamespaceHandler>();
0:                 handlers.put(uri, h);
1:             }
1:             if (h.add(handler)) {
1:                 for (NamespaceHandlerSetImpl s : sets) {
1:                     s.registerHandler(uri, handler);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             Set<NamespaceHandler> h = handlers.get(uri);
0:             if (h == null || !h.remove(handler)) {
1:             for (NamespaceHandlerSetImpl s : sets) {
1:                 s.unregisterHandler(uri, handler);
1:         removeSchemasFor(handler);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized NamespaceHandlerSet getNamespaceHandlers(Set<URI> uris, Bundle bundle) {
0:         NamespaceHandlerSetImpl s = new NamespaceHandlerSetImpl(uris, bundle);
0:         sets.add(s);
1:         return s;
0:     public synchronized Schema getSchema(Map<URI, NamespaceHandler> handlers) throws IOException, SAXException {
0:         for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:             if (key.equals(handlers)) {
/////////////////////////////////////////////////////////////////////////
0:                 for (URI ns : handlers.keySet()) {
0:                     URL url = handlers.get(ns).getSchemaLocation(ns.toString());
0:                     if (url == null) {
0:                         LOGGER.warn("No URL is defined for schema " + ns + ". This schema will not be validated");
0:                     } else {
0:                         schemaSources.add(new StreamSource(url.openStream()));
0:                 schemas.put(handlers, new SoftReference<Schema>(schema));
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void removeSchemasFor(NamespaceHandler handler) {
0:         List<Map<URI, NamespaceHandler>> keys = new ArrayList<Map<URI, NamespaceHandler>>();
0:         for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:             if (key.values().contains(handler)) {
0:                 keys.add(key);
0:         for (Map<URI, NamespaceHandler> key : keys) {
0:         SchemaFactory schemaFactory = null;
1:     protected class NamespaceHandlerSetImpl implements NamespaceHandlerSet {
1: 
0:         private final Map<Listener, Boolean> listeners;
0:         private final Bundle bundle;
1:         private final Set<URI> namespaces;
0:         private final Map<URI, NamespaceHandler> handlers;
1:         private Schema schema;
1: 
1:         public NamespaceHandlerSetImpl(Set<URI> namespaces, Bundle bundle) {
0:             this.listeners = new HashMap<Listener, Boolean>();
0:             this.namespaces = namespaces;
0:             this.bundle = bundle;
0:             handlers = new HashMap<URI, NamespaceHandler>();
1:             for (URI ns : namespaces) {
1:                 findCompatibleNamespaceHandler(ns);
1:             }
1:         }
1: 
1:         public boolean isComplete() {
1:             return handlers.size() == namespaces.size();
1:         }
1: 
1:         public Set<URI> getNamespaces() {
1:             return namespaces;
1:         }
1: 
1:         public NamespaceHandler getNamespaceHandler(URI namespace) {
1:             return handlers.get(namespace);
1:         }
1: 
1:         public Schema getSchema() throws SAXException, IOException {
1:             if (!isComplete()) {
1:                 throw new IllegalStateException("NamespaceHandlerSet is not complete");
1:             }
0:             if (schema == null) {
0:                 schema = NamespaceHandlerRegistryImpl.this.getSchema(handlers);
1:             }
0:             return schema;
1:         }
1: 
0:         public synchronized void addListener(Listener listener) {
0:             listeners.put(listener, Boolean.TRUE);
1:         }
1: 
0:         public synchronized void removeListener(Listener listener) {
1:             listeners.remove(listener);
1:         }
1: 
1:         public void destroy() {
0:             NamespaceHandlerRegistryImpl.this.sets.remove(this);
1:         }
1: 
1:         public void registerHandler(URI uri, NamespaceHandler handler) {
1:             if (namespaces.contains(uri) && handlers.get(uri) == null) {
1:                 if (findCompatibleNamespaceHandler(uri) !=  null) {
0:                     for (Listener listener : listeners.keySet()) {
0:                         try {
1:                             listener.namespaceHandlerRegistered(uri);
1:                         } catch (Throwable t) {
1:                             LOGGER.debug("Unexpected exception when notifying a NamespaceHandler listener", t);
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         public void unregisterHandler(URI uri, NamespaceHandler handler) {
1:             if (handlers.get(uri) == handler) {
1:                 handlers.remove(uri);
0:                 for (Listener listener : listeners.keySet()) {
0:                     try {
1:                         listener.namespaceHandlerUnregistered(uri);
1:                     } catch (Throwable t) {
1:                         LOGGER.debug("Unexpected exception when notifying a NamespaceHandler listener", t);
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         private NamespaceHandler findCompatibleNamespaceHandler(URI ns) {
1:             Set<NamespaceHandler> candidates = NamespaceHandlerRegistryImpl.this.handlers.get(ns);
1:             if (candidates != null) {
1:                 for (NamespaceHandler h : candidates) {
1:                     Set<Class> classes = h.getManagedClasses();
1:                     boolean compat = true;
1:                     if (classes != null) {
1:                         Set<Class> allClasses = new HashSet<Class>();
1:                         for (Class cl : classes) {
1:                             for (Class c = cl; c != null; c = c.getSuperclass()) {
1:                                 allClasses.add(c);
1:                                 for (Class i : c.getInterfaces()) {
1:                                     allClasses.add(i);
1:                                 }
1:                             }
1:                         }
1:                         for (Class cl : allClasses) {
1:                             Class clb;
0:                             try {
1:                                 clb = bundle.loadClass(cl.getName());
1:                                 if (clb != cl) {
1:                                     compat = false;
0:                                     break;
1:                                 }
1:                             } catch (ClassNotFoundException e) {
1:                                 // Ignore
1:                             }
1:                         }
1:                     }
1:                     if (compat) {
0:                         handlers.put(ns, h);
1:                         return h;
1:                     }
1:                 }
1:             }
1:             return null;
1:         }
1:     }
1: 
0:     protected static Map<URI, NamespaceHandler> findHandlers(Map<URI, Set<NamespaceHandler>> allHandlers,
0:                                                              Set<URI> namespaces,
0:                                                              Bundle bundle) {
0:         Map<URI, NamespaceHandler> handlers = new HashMap<URI, NamespaceHandler>();
0:         Map<URI, Set<NamespaceHandler>> candidates = new HashMap<URI, Set<NamespaceHandler>>();
0:         // Populate initial candidates
1:         for (URI ns : namespaces) {
0:             Set<NamespaceHandler> h = new HashSet<NamespaceHandler>();
0:             if (allHandlers.get(ns) != null) {
0:                 h.addAll(allHandlers.get(ns));
1:             }
0:             candidates.put(ns, h);
1:         }
0:         // Exclude directly incompatible handlers
1:         for (URI ns : namespaces) {
0:             for (Iterator<NamespaceHandler> it = candidates.get(ns).iterator(); it.hasNext();) {
0:                 NamespaceHandler h = it.next();
1:                 Set<Class> classes = h.getManagedClasses();
1:                 boolean compat = true;
1:                 if (classes != null) {
1:                     Set<Class> allClasses = new HashSet<Class>();
1:                     for (Class cl : classes) {
1:                         for (Class c = cl; c != null; c = c.getSuperclass()) {
1:                             allClasses.add(c);
1:                             for (Class i : c.getInterfaces()) {
1:                                 allClasses.add(i);
1:                             }
1:                         }
1:                     }
1:                     for (Class cl : allClasses) {
1:                         Class clb;
0:                         try {
1:                             clb = bundle.loadClass(cl.getName());
1:                         } catch (Throwable t) {
0:                             clb = null;
1:                         }
1:                         if (clb != cl) {
1:                             compat = false;
0:                             break;
1:                         }
1:                     }
1:                 }
0:                 if (!compat) {
0:                     it.remove();
1:                 }
1:             }
1:         }
0:         // TODO: do we need to check if there are incompatibilities between namespaces?
0:         // Pick the first ones
1:         for (URI ns : namespaces) {
0:             Set<NamespaceHandler> h = candidates.get(ns);
0:             if (!h.isEmpty()) {
0:                 handlers.put(ns, h.iterator().next());
1:             }
1:         }
0:         return handlers;
1:     }
1: 
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.namespace;
1: 
1: import java.net.URI;
1: import java.net.URL;
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.AbstractMap;
0: import java.util.LinkedList;
0: import java.util.AbstractSet;
0: import java.util.Iterator;
0: import java.util.HashSet;
0: import java.io.IOException;
0: import java.lang.ref.SoftReference;
0: import java.lang.ref.Reference;
1: 
1: import javax.xml.validation.Schema;
1: import javax.xml.validation.SchemaFactory;
0: import javax.xml.transform.stream.StreamSource;
0: import javax.xml.transform.Source;
0: import javax.xml.XMLConstants;
1: 
0: import org.apache.geronimo.blueprint.NamespaceHandler;
0: import org.apache.geronimo.blueprint.container.NamespaceHandlerRegistry;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.util.tracker.ServiceTracker;
1: import org.osgi.util.tracker.ServiceTrackerCustomizer;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: import org.xml.sax.SAXException;
1: 
1: /**
1:  * Default implementation of the NamespaceHandlerRegistry.
1:  * 
1:  * This registry will track NamespaceHandler objects in the OSGi registry and make
1:  * them available, calling listeners when handlers are registered or unregistered.
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 760378 $, $Date: 2009-03-31 11:31:38 +0200 (Tue, 31 Mar 2009) $
1:  */
1: public class NamespaceHandlerRegistryImpl implements NamespaceHandlerRegistry, ServiceTrackerCustomizer {
1:     
0:     public static final URI BLUEPRINT_NAMESPACE = URI.create("http://www.osgi.org/xmlns/blueprint/v1.0.0");
1: 
1:     public static final String NAMESPACE = "osgi.service.blueprint.namespace";
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(NamespaceHandlerRegistryImpl.class);
1: 
1:     private final BundleContext bundleContext;
0:     private final Map<URI, NamespaceHandler> handlers;
1:     private final ServiceTracker tracker;
0:     private final Map<Listener, Boolean> listeners;
0:     private final Map<Set<URI>, Reference<Schema>> schemas = new LRUMap<Set<URI>, Reference<Schema>>(10);
0:     private SchemaFactory schemaFactory;
1: 
1:     public NamespaceHandlerRegistryImpl(BundleContext bundleContext) {
1:         this.bundleContext = bundleContext;
0:         handlers = new HashMap<URI, NamespaceHandler>();
1:         tracker = new ServiceTracker(bundleContext, NamespaceHandler.class.getName(), this);
1:         tracker.open();
0:         listeners = new HashMap<Listener, Boolean>();
0:     }
1: 
1:     public Object addingService(ServiceReference reference) {
1:         NamespaceHandler handler = (NamespaceHandler) bundleContext.getService(reference);
0:         try {
1:             Map<String, Object> props = new HashMap<String, Object>();
1:             for (String name : reference.getPropertyKeys()) {
1:                 props.put(name, reference.getProperty(name));
0:             }
1:             registerHandler(handler, props);
1:         } catch (Exception e) {
1:             LOGGER.warn("Error registering NamespaceHandler", e);
0:         }
1:         return handler;
0:     }
1: 
1:     public void modifiedService(ServiceReference reference, Object service) {
1:         removedService(reference, service);
1:         addingService(reference);
0:     }
1: 
1:     public void removedService(ServiceReference reference, Object service) {
0:         try {
1:             NamespaceHandler handler = (NamespaceHandler) service;
1:             Map<String, Object> props = new HashMap<String, Object>();
1:             for (String name : reference.getPropertyKeys()) {
1:                 props.put(name, reference.getProperty(name));
0:             }
1:             unregisterHandler(handler, props);
1:         } catch (Exception e) {
1:             LOGGER.warn("Error unregistering NamespaceHandler", e);
0:         }
0:     }
1: 
0:     public synchronized void registerHandler(NamespaceHandler handler, Map properties) {
1:         List<URI> namespaces = getNamespaces(properties);
1:         for (URI uri : namespaces) {
0:             if (handlers.containsKey(uri)) {
0:                 LOGGER.warn("Ignoring NamespaceHandler for namespace {}, as another handler has already been registered for the same namespace", uri);
0:             } else {
0:                 handlers.put(uri, handler);
0:                 callListeners(uri, true);
0:             }
0:         }
0:     }
1: 
0:     public synchronized void unregisterHandler(NamespaceHandler handler, Map properties) {
1:         List<URI> namespaces = getNamespaces(properties);
1:         for (URI uri : namespaces) {
0:             if (handlers.get(uri) != handler) {
1:                 continue;
0:             }
0:             handlers.remove(uri);
0:             callListeners(uri, false);
0:         }
0:         removeSchemasFor(namespaces);
0:     }
1: 
0:     private void callListeners(URI uri, boolean registered) {
0:         for (Listener listener : listeners.keySet()) {
0:             try {
0:                 if (registered) {
0:                     listener.namespaceHandlerRegistered(uri);
0:                 } else {
0:                     listener.namespaceHandlerUnregistered(uri);
0:                 }
0:             } catch (Throwable t) {
0:                 LOGGER.debug("Unexpected exception when notifying a NamespaceHandler listener", t);
0:             }
0:         }
0:     }
1: 
1:     private static List<URI> getNamespaces(Map properties) {
1:         Object ns = properties != null ? properties.get(NAMESPACE) : null;
1:         if (ns == null) {
0:             throw new IllegalArgumentException("NamespaceHandler service does not have an associated " + NAMESPACE + " property defined");
1:         } else if (ns instanceof URI[]) {
1:             return Arrays.asList((URI[]) ns);
1:         } else if (ns instanceof URI) {
1:             return Collections.singletonList((URI) ns);
1:         } else if (ns instanceof String) {
1:             return Collections.singletonList(URI.create((String) ns));
1:         } else if (ns instanceof String[]) {
1:             String[] strings = (String[]) ns;
1:             List<URI> namespaces = new ArrayList<URI>(strings.length);
1:             for (String string : strings) {
1:                 namespaces.add(URI.create(string));
0:             }
1:             return namespaces;
1:         } else if (ns instanceof Collection) {
1:             Collection col = (Collection) ns;
1:             List<URI> namespaces = new ArrayList<URI>(col.size());
1:             for (Object o : col) {
1:                 namespaces.add(toURI(o));
0:             }
1:             return namespaces;
1:         } else if (ns instanceof Object[]) {
1:             Object[] array = (Object[]) ns;
1:             List<URI> namespaces = new ArrayList<URI>(array.length);
1:             for (Object o : array) {
1:                 namespaces.add(toURI(o));
0:             }
1:             return namespaces;
0:         } else {
0:             throw new IllegalArgumentException("NamespaceHandler service has an associated " + NAMESPACE + " property defined which can not be converted to an array of URI");
0:         }
0:     }
1: 
1:     private static URI toURI(Object o) {
1:         if (o instanceof URI) {
1:             return (URI) o;
1:         } else if (o instanceof String) {
1:             return URI.create((String) o);
0:         } else {
0:             throw new IllegalArgumentException("NamespaceHandler service has an associated " + NAMESPACE + " property defined which can not be converted to an array of URI");
0:         }
0:     }
1:     
0:     public synchronized NamespaceHandler getNamespaceHandler(URI uri) {
0:         return handlers.get(uri);
0:     }
1: 
1:     public void destroy() {
1:         tracker.close();
0:     }
1: 
0:     public synchronized void addListener(Listener listener) {
0:         listeners.put(listener, Boolean.TRUE);
0:     }
1: 
0:     public synchronized void removeListener(Listener listener) {
0:         listeners.remove(listener);
0:     }
1: 
0:     public synchronized Schema getSchema(Set<URI> namespaces) throws IOException, SAXException {
0:         Schema schema = null;
0:         // Find a schema that can handle all the requested namespaces
0:         // If it contains additional namespaces, it should not be a problem since
0:         // they won't be used at all
0:         for (Set<URI> key : schemas.keySet()) {
0:             if (key.containsAll(namespaces)) {
0:                 schema = schemas.get(key).get();
0:                 break;
0:             }
0:         }
0:         if (schema == null) {
0:             List<StreamSource> schemaSources = new ArrayList<StreamSource>();
0:             try {
0:                 schemaSources.add(new StreamSource(getClass().getResourceAsStream("/org/apache/geronimo/blueprint/blueprint.xsd")));
0:                 // Create a schema for all namespaces known at this point
0:                 // It will speed things as it can be reused for all other blueprint containers
0:                 namespaces = new HashSet<URI>(handlers.keySet());
0:                 namespaces.add(BLUEPRINT_NAMESPACE);
0:                 for (URI ns : namespaces) {
0:                     if (!BLUEPRINT_NAMESPACE.equals(ns)) {
0:                         NamespaceHandler handler = getNamespaceHandler(ns);
0:                         if (handler == null) {
0:                             throw new IllegalArgumentException("No namespace handler has been registered for " + ns);
0:                         }
0:                         URL url = handler.getSchemaLocation(ns.toString());
0:                         if (url == null) {
0:                             LOGGER.warn("No URL is defined for schema " + ns + ". This schema will not be validated");
0:                         } else {
0:                             schemaSources.add(new StreamSource(url.openStream()));
0:                         }
0:                     }
0:                 }
0:                 schema = getSchemaFactory().newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
0:                 schemas.put(namespaces, new SoftReference<Schema>(schema));
0:             } finally {
0:                 for (StreamSource s : schemaSources) {
0:                     try {
0:                         s.getInputStream().close();
0:                     } catch (IOException e) {
0:                         // Ignore
0:                     }
0:                 }
0:             }
0:         }
0:         return schema;
0:     }
1: 
0:     protected synchronized void removeSchemasFor(List<URI> namespaces) {
0:         List<Set<URI>> keys = new ArrayList<Set<URI>>();
0:         for (URI ns : namespaces) {
0:             for (Set<URI> key : schemas.keySet()) {
0:                 if (key.contains(ns)) {
0:                     keys.add(key);
0:                 }
0:             }
0:         }
0:         for (Set<URI> key : keys) {
0:             schemas.remove(key);
0:         }
0:     }
1: 
0:     private SchemaFactory getSchemaFactory() {
0:         if (schemaFactory == null) {
0:             schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
0:         }
0:         return schemaFactory;
0:     }
1: 
1:     public static class LRUMap<K,V> extends AbstractMap<K,V> {
1: 
1:         private final int bound;
1:         private final LinkedList<Entry<K,V>> entries = new LinkedList<Entry<K,V>>();
1: 
1:         private static class LRUEntry<K,V> implements Entry<K,V> {
1:             private final K key;
1:             private final V value;
1: 
1:             private LRUEntry(K key, V value) {
1:                 this.key = key;
1:                 this.value = value;
0:             }
1: 
1:             public K getKey() {
1:                 return key;
0:             }
1: 
1:             public V getValue() {
1:                 return value;
0:             }
1: 
1:             public V setValue(V value) {
1:                 throw new UnsupportedOperationException();
0:             }
0:         }
1: 
1:         private LRUMap(int bound) {
1:             this.bound = bound;
0:         }
1: 
1:         public V get(Object key) {
1:             if (key == null) {
1:                 throw new NullPointerException();
0:             }
1:             for (Entry<K,V> e : entries) {
1:                 if (e.getKey().equals(key)) {
1:                     entries.remove(e);
1:                     entries.addFirst(e);
1:                     return e.getValue();
0:                 }
0:             }
0:             return null;
0:         }
1: 
1:         public V put(K key, V value) {
1:             if (key == null) {
1:                 throw new NullPointerException();
0:             }
1:             V old = null;
1:             for (Entry<K,V> e : entries) {
1:                 if (e.getKey().equals(key)) {
1:                     entries.remove(e);
1:                     old = e.getValue();
0:                     break;
0:                 }
0:             }
1:             if (value != null) {
1:                 entries.addFirst(new LRUEntry<K,V>(key, value));
1:                 while (entries.size() > bound) {
1:                     entries.removeLast();
0:                 }
0:             }
1:             return old;
0:         }
1: 
1:         public Set<Entry<K, V>> entrySet() {
1:             return new AbstractSet<Entry<K,V>>() {
1:                 public Iterator<Entry<K, V>> iterator() {
1:                     return entries.iterator();
0:                 }
1: 
1:                 public int size() {
1:                     return entries.size();
0:                 }
0:             };
0:         }
0:     }
1: 
0: }
author:John Ross
-------------------------------------------------------------------------------
commit:551db01
/////////////////////////////////////////////////////////////////////////
0: import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;
0: import static javax.xml.XMLConstants.XML_NS_URI;
0: import static org.apache.aries.blueprint.parser.Parser.BLUEPRINT_NAMESPACE;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         private class Loader implements LSResourceResolver, Closeable {
commit:68697bd
/////////////////////////////////////////////////////////////////////////
1:             handlers = new ConcurrentHashMap<URI, NamespaceHandler>();
author:Jean-Baptiste Onofr
-------------------------------------------------------------------------------
commit:29cac76
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.NamespaceHandler2;
/////////////////////////////////////////////////////////////////////////
0:             URI uri = URI.create(namespaceURI);
0:             Set<NamespaceHandler> hs = NamespaceHandlerRegistryImpl.this.handlers.get(uri);
0:             // first check registered handlers
0:             if (hs != null) {
0:                 for (NamespaceHandler h : hs) {
0:                     URL url = h.getSchemaLocation(namespaceURI);
0:                     if (url != null) {
0:                         return createLSInput(publicId, systemId, url);
0:                 }
0:             }
0:             // then check if some handler may resolve the namespace
0:             for (NamespaceHandler h : handlers.values()) {
0:                 if (h instanceof NamespaceHandler2 && ((NamespaceHandler2) h).mayResolve(namespaceURI)) {
0:                     URL url = h.getSchemaLocation(namespaceURI);
0:                     if (url != null) {
0:                         return createLSInput(publicId, systemId, url);
0: 
0: 
0:         private LSInput createLSInput(String publicId, String systemId, URL url) {
0:             // handling include-relative-path case
0:             if (systemId != null && !systemId.matches("^[a-z][-+.0-9a-z]*:.*")) {
0:                 try {
0:                     url = new URL(url, systemId);
0:                 } catch (Exception e) {
0:                     // ignore and use the given systemId
0:                 }
0:             }
0:             try {
0:                 final StreamSource source = new StreamSource(url.openStream(), url.toExternalForm());
0:                 schemaSources.add(source);
0:                 return new SourceLSInput(source, publicId, url);
0:             } catch (IOException e) {
0:                 throw new RuntimeException(e);
0:             }
0:         }
author:Holly Cummins
-------------------------------------------------------------------------------
commit:a0ef3e2
/////////////////////////////////////////////////////////////////////////
0:         for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:             if (key.values().contains(handler)) {
0:                 keys.add(key);
0:         for (Map<URI, NamespaceHandler> key : keys) {
0:             schemas.remove(key);
commit:664219a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.Reader;
0: 
0: import javax.xml.transform.stream.StreamSource;
0: import javax.xml.transform.Source;
0: import javax.xml.XMLConstants;
0: 
0: import org.w3c.dom.ls.LSInput;
0: import org.w3c.dom.ls.LSResourceResolver;
0: import org.apache.aries.blueprint.parser.NamespaceHandlerSet.Listener;
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.xml.sax.SAXParseException;
0:  * 
0:     
0:     private final Map<URI, Set<NamespaceHandler>> handlers;
0:     private final Map<Map<URI, NamespaceHandler>, Reference<Schema>> schemas = new LRUMap<Map<URI, NamespaceHandler>, Reference<Schema>>(10);
0:     private SchemaFactory schemaFactory;
0:     private List<NamespaceHandlerSetImpl> sets;
0:         handlers = new HashMap<URI, Set<NamespaceHandler>>();
0:         sets = new ArrayList<NamespaceHandlerSetImpl>();
0:         LOGGER.debug("Adding NamespaceHandler "+reference.toString());
0:         if(handler!=null){
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void registerHandler(NamespaceHandler handler, Map properties) {
0:             Set<NamespaceHandler> h = handlers.get(uri);
0:                 h = new HashSet<NamespaceHandler>();
0:                 handlers.put(uri, h);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void unregisterHandler(NamespaceHandler handler, Map properties) {
0:             Set<NamespaceHandler> h = handlers.get(uri);
0:             if (h == null || !h.remove(handler)) {
0:         removeSchemasFor(handler);
/////////////////////////////////////////////////////////////////////////
0:     
0:     public synchronized NamespaceHandlerSet getNamespaceHandlers(Set<URI> uris, Bundle bundle) {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Schema getSchema(Map<URI, NamespaceHandler> handlers)
0:         throws IOException, SAXException {
0:     private synchronized Schema getSchema(Map<URI, NamespaceHandler> handlers, 
0:                                           final Bundle bundle,
0:                                           final Properties schemaMap) throws IOException, SAXException {
0:         Schema schema = null;
0:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:                 boolean found = true;
0:                 for (URI uri : handlers.keySet()) {
0:                     if (!handlers.get(uri).equals(key.get(uri))) {
0:                         found = false;
0:                         break;
0:                     }
0:                 }
0:                 if (found) {
0:                     schema = schemas.get(key).get();
0:                     break;
0:         }
0:         if (schema == null) {
/////////////////////////////////////////////////////////////////////////
0:                 SchemaFactory factory = getSchemaFactory();
0:                 factory.setResourceResolver(new LSResourceResolver() {
0:                     public LSInput resolveResource(String type, 
0:                                                    final String namespaceURI, 
/////////////////////////////////////////////////////////////////////////
0:                                     StreamSource source 
0:                                         = new StreamSource(url.openStream(), url.toExternalForm());
/////////////////////////////////////////////////////////////////////////
0:                                 
0:                                 
0:                                     final StreamSource source 
0:                                         = new StreamSource(url.openStream(), url.toExternalForm());
/////////////////////////////////////////////////////////////////////////
0:                     
0:                 schema = factory.newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
0:                 // Remove schemas that are fully included
0:                 for (Iterator<Map<URI, NamespaceHandler>> iterator = schemas.keySet().iterator(); iterator.hasNext();) {
0:                     Map<URI, NamespaceHandler> key = iterator.next();
0:                     boolean found = true;
0:                     for (URI uri : key.keySet()) {
0:                         if (!key.get(uri).equals(handlers.get(uri))) {
0:                             found = false;
0:                     if (found) {
0:                         iterator.remove();
0:                         break;
0:                 }
0:                 // Add our new schema
0:                 if (schemaMap.isEmpty()) {
0:                     //only cache non-custom schemas
0:                     schemas.put(handlers, new SoftReference<Schema>(schema));
/////////////////////////////////////////////////////////////////////////
0:         return schema;
0:     
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void removeSchemasFor(NamespaceHandler handler) {
0:         List<Map<URI, NamespaceHandler>> keys = new ArrayList<Map<URI, NamespaceHandler>>();
0:         for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:             if (key.values().contains(handler)) {
0:                 keys.add(key);
0:             }
0:         }
0:         for (Map<URI, NamespaceHandler> key : keys) {
0:             schemas.remove(key);
0:         }
0:     }
0: 
0:     private SchemaFactory getSchemaFactory() {
0:         if (schemaFactory == null) {
0:             schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
0:         }
0:         return schemaFactory;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:             handlers = new HashMap<URI, NamespaceHandler>();
/////////////////////////////////////////////////////////////////////////
0:         public synchronized void addListener(Listener listener) {
0:         public synchronized void removeListener(Listener listener) {
commit:f2ddb07
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.Reader;
0: 
0: import javax.xml.transform.stream.StreamSource;
0: import javax.xml.transform.Source;
0: import javax.xml.XMLConstants;
0: 
0: import org.w3c.dom.ls.LSInput;
0: import org.w3c.dom.ls.LSResourceResolver;
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.xml.sax.SAXParseException;
0:  * 
0:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Schema getSchema(Map<URI, NamespaceHandler> handlers)
0:         throws IOException, SAXException {
0:     private synchronized Schema getSchema(Map<URI, NamespaceHandler> handlers, 
0:                                           final Bundle bundle,
0:                                           final Properties schemaMap) throws IOException, SAXException {
0:         Schema schema = null;
0:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:                 boolean found = true;
0:                 for (URI uri : handlers.keySet()) {
0:                     if (!handlers.get(uri).equals(key.get(uri))) {
0:                         found = false;
0:                         break;
0:                 if (found) {
0:                     schema = schemas.get(key).get();
0:                     break;
0:                 }
0:         if (schema == null) {
/////////////////////////////////////////////////////////////////////////
0:                     public LSInput resolveResource(String type, 
0:                                                    final String namespaceURI, 
/////////////////////////////////////////////////////////////////////////
0:                                     StreamSource source 
0:                                         = new StreamSource(url.openStream(), url.toExternalForm());
/////////////////////////////////////////////////////////////////////////
0:                                 
0:                                 
0:                                     final StreamSource source 
0:                                         = new StreamSource(url.openStream(), url.toExternalForm());
/////////////////////////////////////////////////////////////////////////
0:                     
0:                 schema = factory.newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return schema;
0:     
author:J. Daniel Kulp
-------------------------------------------------------------------------------
commit:a2c00f6
/////////////////////////////////////////////////////////////////////////
0:                             URL url = h.getSchemaLocation(namespaceURI);
0:                                 // handling include-relative-path case
0:                                 if (systemId != null && !systemId.matches("^[a-z][-+.0-9a-z]*:.*")) {
0:                                     try {
0:                                         url = new URL(url, systemId);
0:                                     } catch (Exception e) {
0:                                         // ignore and use the given systemId
0:                                     }
0:                                 }
0:                                 
0:                                 
commit:99193d2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:8f23124
/////////////////////////////////////////////////////////////////////////
1: import java.net.URISyntaxException;
/////////////////////////////////////////////////////////////////////////
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Schema getSchema(Map<URI, NamespaceHandler> handlers)
0:         throws IOException, SAXException {
0:         return getSchema(handlers, null, new Properties());
0:     }
0:     private synchronized Schema getSchema(Map<URI, NamespaceHandler> handlers, 
0:                                           final Bundle bundle,
0:                                           final Properties schemaMap) throws IOException, SAXException {
0:         if (schemaMap == null || schemaMap.isEmpty()) {
0:             for (Map<URI, NamespaceHandler> key : schemas.keySet()) {
0:                 boolean found = true;
0:                 for (URI uri : handlers.keySet()) {
0:                     if (!handlers.get(uri).equals(key.get(uri))) {
0:                         found = false;
0:                         break;
0:                     }
0:                 }
0:                 if (found) {
0:                     schema = schemas.get(key).get();
/////////////////////////////////////////////////////////////////////////
0:                 for (Object ns : schemaMap.values()) {
0:                     URL url = bundle.getResource(ns.toString());
0:                     if (url == null) {
0:                         LOGGER.warn("No URL is defined for schema " + ns + ". This schema will not be validated");
0:                     } else {
0:                         schemaSources.add(new StreamSource(url.openStream(), url.toExternalForm()));
0:                     }
0:                 }
0:                         String loc = null;
0:                         if (namespaceURI != null) {
0:                             loc = schemaMap.getProperty(namespaceURI);
0:                         }
0:                         if (loc == null && publicId != null) {
0:                             loc = schemaMap.getProperty(publicId);
0:                         }
0:                         if (loc == null && systemId != null) {
0:                             loc = schemaMap.getProperty(systemId);
0:                         }
0:                         if (loc != null) {
0:                             URL url = bundle.getResource(loc);
0:                             if (url != null) {
0:                                 try {
0:                                     StreamSource source 
0:                                         = new StreamSource(url.openStream(), url.toExternalForm());
0:                                     schemaSources.add(source);
0:                                     return new SourceLSInput(source, publicId, url);
0:                                 } catch (IOException e) {
0:                                     throw new RuntimeException(e);
0:                                 }
0:                             }
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                                     return new SourceLSInput(source, publicId, url);
/////////////////////////////////////////////////////////////////////////
0:                 if (schemaMap.isEmpty()) {
0:                     //only cache non-custom schemas
0:                     schemas.put(handlers, new SoftReference<Schema>(schema));
0:                 }
/////////////////////////////////////////////////////////////////////////
0:     
0:     private class SourceLSInput implements LSInput {
0:         StreamSource source;
0:         URL systemId;
0:         String publicId;
0:         public SourceLSInput(StreamSource src, String pid, URL sys) {
0:             source = src;
0:             publicId = pid;
0:             systemId = sys;
0:         }
1:         public Reader getCharacterStream() {
0:             return null;
0:         }
1:         public void setCharacterStream(Reader characterStream) {
0:         }
1:         public InputStream getByteStream() {
1:             return source.getInputStream();
0:         }
1:         public void setByteStream(InputStream byteStream) {
0:         }
1:         public String getStringData() {
0:             return null;
0:         }
1:         public void setStringData(String stringData) {
0:         }
1:         public String getSystemId() {
0:             return systemId.toExternalForm();
0:         }
1:         public void setSystemId(String systemId) {
0:         }
1:         public String getPublicId() {
0:             return publicId;
0:         }
1:         public void setPublicId(String publicId) {
0:         }
1:         public String getBaseURI() {
0:             return null;
0:         }
1:         public void setBaseURI(String baseURI) {
0:         }
1:         public String getEncoding() {
0:             return null;
0:         }
1:         public void setEncoding(String encoding) {
0:         }
1:         public boolean getCertifiedText() {
1:             return false;
0:         }
1:         public void setCertifiedText(boolean certifiedText) {
0:         }
0:     };
/////////////////////////////////////////////////////////////////////////
1:         private final Properties schemaMap = new Properties();
/////////////////////////////////////////////////////////////////////////
1:             URL url = bundle.getResource("OSGI-INF/blueprint/schema.map");
0:             System.out.println("MAP: " + url);
0:             if (url != null) {
1:                 InputStream ins = null;
0:                 try {
1:                     ins = url.openStream();
1:                     schemaMap.load(ins);
1:                 } catch (IOException ex) {
1:                     ex.printStackTrace();
1:                     //ignore
0:                 } finally {
0:                     if (ins != null) {
0:                         try {
0:                             ins.close();
0:                         } catch (IOException e) {
1:                             //ignore
0:                         }
0:                     }
0:                 }
0:             }
0:             System.out.println("MAP: " + schemaMap);
1:             for (Object ns : schemaMap.keySet()) {
0:                 try {
1:                     this.namespaces.remove(new URI(ns.toString()));
1:                 } catch (URISyntaxException e) {
1:                     //ignore
0:                 }
0:             }
0:             System.out.println("NS: " + namespaces);
/////////////////////////////////////////////////////////////////////////
0:                 schema = NamespaceHandlerRegistryImpl.this.getSchema(handlers, bundle, schemaMap);
commit:6be355e
/////////////////////////////////////////////////////////////////////////
0: import java.io.InputStream;
0: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
0: import org.w3c.dom.ls.LSInput;
0: import org.w3c.dom.ls.LSResourceResolver;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.xml.sax.SAXParseException;
/////////////////////////////////////////////////////////////////////////
0:             final List<StreamSource> schemaSources = new ArrayList<StreamSource>();
/////////////////////////////////////////////////////////////////////////
0:                 SchemaFactory factory = getSchemaFactory();
0:                 factory.setResourceResolver(new LSResourceResolver() {
0:                     public LSInput resolveResource(String type, 
0:                                                    final String namespaceURI, 
0:                                                    final String publicId,
0:                                                    String systemId, String baseURI) {
0:                         
0:                         URI uri = URI.create((String) namespaceURI);
0:                         Set<NamespaceHandler> hs = NamespaceHandlerRegistryImpl.this.handlers.get(uri);
0:                         if (hs == null) {
0:                             return null;
0:                         }
0:                         for (NamespaceHandler h : hs) {
0:                             final URL url = h.getSchemaLocation(namespaceURI);
0:                             if (url != null) {
0:                                 try {
0:                                     final StreamSource source 
0:                                         = new StreamSource(url.openStream(), url.toExternalForm());
0:                                     schemaSources.add(source);
0:                                     return new LSInput() {
0:                                         public Reader getCharacterStream() {
0:                                             return null;
0:                                         }
0:                                         public void setCharacterStream(Reader characterStream) {
0:                                         }
0:                                         public InputStream getByteStream() {
0:                                             return source.getInputStream();
0:                                         }
0:                                         public void setByteStream(InputStream byteStream) {
0:                                         }
0:                                         public String getStringData() {
0:                                             return null;
0:                                         }
0:                                         public void setStringData(String stringData) {
0:                                         }
0:                                         public String getSystemId() {
0:                                             return url.toExternalForm();
0:                                         }
0:                                         public void setSystemId(String systemId) {
0:                                         }
0:                                         public String getPublicId() {
0:                                             return publicId;
0:                                         }
0:                                         public void setPublicId(String publicId) {
0:                                         }
0:                                         public String getBaseURI() {
0:                                             return null;
0:                                         }
0:                                         public void setBaseURI(String baseURI) {
0:                                         }
0:                                         public String getEncoding() {
0:                                             return null;
0:                                         }
0:                                         public void setEncoding(String encoding) {
0:                                         }
0:                                         public boolean getCertifiedText() {
0:                                             return false;
0:                                         }
0:                                         public void setCertifiedText(boolean certifiedText) {
0:                                         }
0:                                     };
0:                                 } catch (IOException e) {
0:                                     throw new RuntimeException(e);
0:                                 }
0:                             }
0:                         }
0:                         return null;
0:                     }
0:                     
0:                 });
0:                 schema = factory.newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
/////////////////////////////////////////////////////////////////////////
commit:97c4493
/////////////////////////////////////////////////////////////////////////
0:                         schemaSources.add(new StreamSource(url.openStream(), url.toExternalForm()));
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.parser.NamespaceHandlerSet;
0: import org.apache.aries.blueprint.parser.NamespaceHandlerSet.Listener;
author:Andrew Osborne
-------------------------------------------------------------------------------
commit:21031e9
/////////////////////////////////////////////////////////////////////////
0:         LOGGER.debug("Adding NamespaceHandler "+reference.toString());
0:         if(handler!=null){
0:             try {
0:                 Map<String, Object> props = new HashMap<String, Object>();
0:                 for (String name : reference.getPropertyKeys()) {
0:                     props.put(name, reference.getProperty(name));
0:                 }
0:                 registerHandler(handler, props);
0:             } catch (Exception e) {
0:                 LOGGER.warn("Error registering NamespaceHandler", e);
0:         }else{
0:             LOGGER.warn("Error resolving NamespaceHandler, null Service obtained from tracked ServiceReference {} for bundle {}, ver {}", new Object[]{reference.toString(), reference.getBundle().getSymbolicName(), reference.getBundle().getVersion()});
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.namespace;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.NamespaceHandler;
1: import org.apache.aries.blueprint.container.NamespaceHandlerRegistry;
/////////////////////////////////////////////////////////////////////////
0:                 schemaSources.add(new StreamSource(getClass().getResourceAsStream("/org/apache/aries/blueprint/blueprint.xsd")));
============================================================================