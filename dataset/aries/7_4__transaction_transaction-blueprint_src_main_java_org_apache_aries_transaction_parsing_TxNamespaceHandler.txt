1:6f219fd: /*
1:6f219fd:  * Licensed to the Apache Software Foundation (ASF) under one
1:6f219fd:  * or more contributor license agreements.  See the NOTICE file
1:6f219fd:  * distributed with this work for additional information
1:6f219fd:  * regarding copyright ownership.  The ASF licenses this file
1:6f219fd:  * to you under the Apache License, Version 2.0 (the
1:6f219fd:  * "License"); you may not use this file except in compliance
1:6f219fd:  * with the License.  You may obtain a copy of the License at
1:6f219fd:  *
1:6f219fd:  *   http://www.apache.org/licenses/LICENSE-2.0
1:6f219fd:  *
1:6f219fd:  * Unless required by applicable law or agreed to in writing,
1:6f219fd:  * software distributed under the License is distributed on an
1:6f219fd:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6f219fd:  * KIND, either express or implied.  See the License for the
1:6f219fd:  * specific language governing permissions and limitations
1:6f219fd:  * under the License.
1:6f219fd:  */
1:6f219fd: package org.apache.aries.transaction.parsing;
1:e91e2c8: 
1:6f219fd: import java.net.URL;
1:2ad9527: import java.util.Collections;
1:0bfefd9: import java.util.HashMap;
1:4de6208: import java.util.Map;
1:6f219fd: import java.util.Set;
1:bd98451: 
1:bd98451: import javax.transaction.TransactionManager;
1:94cf93b: 
1:6f219fd: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:6f219fd: import org.apache.aries.blueprint.NamespaceHandler;
1:6f219fd: import org.apache.aries.blueprint.ParserContext;
1:94cf93b: import org.apache.aries.blueprint.mutable.MutableBeanMetadata;
1:fde93fc: import org.apache.aries.blueprint.mutable.MutablePassThroughMetadata;
1:6f219fd: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:6f219fd: import org.osgi.service.blueprint.reflect.Metadata;
1:bd98451: import org.osgi.service.coordinator.Coordinator;
1:6f219fd: import org.slf4j.Logger;
1:6f219fd: import org.slf4j.LoggerFactory;
1:6f219fd: import org.w3c.dom.Element;
1:6f219fd: import org.w3c.dom.Node;
1:94cf93b: 
1:0bfefd9: public class TxNamespaceHandler implements NamespaceHandler {
1:176b64c:     public static final String TX_NAMESPACE_URI = "http://aries.apache.org/xmlns/transactions/v2.0.0";
1:0bfefd9:     public static final String ANNOTATION_PARSER_BEAN_NAME = ".org_apache_aries_transaction_annotations";
1:0bfefd9:     private static final Logger LOGGER = LoggerFactory.getLogger(TxNamespaceHandler.class);
1:bd98451:     private TransactionManager tm;
1:bd98451:     private Coordinator coordinator;
1:94cf93b: 
1:0bfefd9:     private final Map<String, String> schemaMap;
1:94cf93b:     
1:0bfefd9:     public TxNamespaceHandler() {
1:0bfefd9:         schemaMap = new HashMap<String, String>();
1:176b64c:         schemaMap.put(TX_NAMESPACE_URI, "transactionv20.xsd");
1:0bfefd9:     }
1:e04c7d6: 
1:2ad9527:     private void parseElement(Element elt, ParserContext pc)
3:6f219fd:     {
1:bd98451:         LOGGER.debug("parser asked to parse element {} ", elt.getNodeName());
1:e04c7d6: 
1:76bff89:         ComponentDefinitionRegistry cdr = pc.getComponentDefinitionRegistry();
1:176b64c:         if ("enable".equals(elt.getLocalName())) {
1:76bff89:             Node n = elt.getChildNodes().item(0);
1:2ad9527:             if ((n == null || Boolean.parseBoolean(n.getNodeValue())) &&
1:2ad9527:                 !cdr.containsComponentDefinition(ANNOTATION_PARSER_BEAN_NAME)) {
1:2ad9527:                 LOGGER.debug("Enabling annotation based transactions");
1:2ad9527:                 MutableBeanMetadata meta = createAnnotationParserBean(pc, cdr);
1:2ad9527:                 cdr.registerComponentDefinition(meta);
1:e04c7d6:             }
1:e04c7d6:         }
1:e04c7d6:     }
1:e04c7d6: 
1:e04c7d6:     private MutableBeanMetadata createAnnotationParserBean(ParserContext pc, ComponentDefinitionRegistry cdr) {
1:e04c7d6:         MutableBeanMetadata meta = pc.createMetadata(MutableBeanMetadata.class);
1:e04c7d6:         meta.setId(ANNOTATION_PARSER_BEAN_NAME);
1:bd98451:         meta.setRuntimeClass(AnnotationProcessor.class);
1:e04c7d6:         meta.setProcessor(true);
1:bd98451:         meta.addArgument(passThrough(pc, cdr), ComponentDefinitionRegistry.class.getName(), 0);
1:bd98451:         meta.addArgument(passThrough(pc, tm), TransactionManager.class.getName(), 1);
1:bd98451:         meta.addArgument(passThrough(pc, coordinator), Coordinator.class.getName(), 1);
1:e04c7d6:         return meta;
1:e04c7d6:     }
1:e04c7d6: 
1:bd98451:     private MutablePassThroughMetadata passThrough(ParserContext pc, Object o) {
1:bd98451:         MutablePassThroughMetadata meta = pc.createMetadata(MutablePassThroughMetadata.class);
1:bd98451:         meta.setObject(o);
1:bd98451:         return meta;
1:e04c7d6:     }
1:e04c7d6: 
1:2ad9527:     @Override
1:6f219fd:     public ComponentMetadata decorate(Node node, ComponentMetadata cm, ParserContext pc)
1:6f219fd:     {
1:6f219fd:         if (node instanceof Element) {
1:2ad9527:             parseElement((Element) node, pc);
1:e04c7d6:         }
1:6f219fd:         return cm;
1:e04c7d6:     }
1:e04c7d6: 
1:2ad9527:     @Override
1:6f219fd:     public Metadata parse(Element elt, ParserContext pc)
1:6f219fd:     {
1:2ad9527:         parseElement(elt, pc);
1:76bff89:         return null;
1:e04c7d6:     }
1:e04c7d6: 
1:2ad9527:     @Override
1:0bfefd9:     public URL getSchemaLocation(String namespaceUri)
1:6f219fd:     {
1:0bfefd9:         String xsdPath = schemaMap.get(namespaceUri);
1:0bfefd9:         return xsdPath != null ? this.getClass().getResource(xsdPath) : null;
1:e04c7d6:     }
1:bd98451:     
1:bd98451:     public void setTm(TransactionManager tm) {
1:bd98451:         this.tm = tm;
1:e04c7d6:     }
1:bd98451:     
1:bd98451:     public void setCoordinator(Coordinator coordinator) {
1:bd98451:         this.coordinator = coordinator;
1:aa15c54:     }
1:e04c7d6: 
1:8047ebe:     @SuppressWarnings("rawtypes")
1:2ad9527:     @Override
1:6f219fd:     public Set<Class> getManagedClasses()
1:6f219fd:     {
1:2ad9527:         return Collections.emptySet();
1:76bff89:     }
1:e04c7d6:     
1:76bff89: }
============================================================================
author:Christian Schneider
-------------------------------------------------------------------------------
commit:2ad9527
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1:     private void parseElement(Element elt, ParserContext pc)
1:             if ((n == null || Boolean.parseBoolean(n.getNodeValue())) &&
1:                 !cdr.containsComponentDefinition(ANNOTATION_PARSER_BEAN_NAME)) {
1:                 LOGGER.debug("Enabling annotation based transactions");
1:                 MutableBeanMetadata meta = createAnnotationParserBean(pc, cdr);
1:                 cdr.registerComponentDefinition(meta);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             parseElement((Element) node, pc);
1:     @Override
1:         parseElement(elt, pc);
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         return Collections.emptySet();
commit:176b64c
/////////////////////////////////////////////////////////////////////////
1:     public static final String TX_NAMESPACE_URI = "http://aries.apache.org/xmlns/transactions/v2.0.0";
/////////////////////////////////////////////////////////////////////////
1:         schemaMap.put(TX_NAMESPACE_URI, "transactionv20.xsd");
/////////////////////////////////////////////////////////////////////////
1:         if ("enable".equals(elt.getLocalName())) {
commit:bd98451
/////////////////////////////////////////////////////////////////////////
1: 
1: import javax.transaction.TransactionManager;
1: import org.osgi.service.coordinator.Coordinator;
/////////////////////////////////////////////////////////////////////////
1:     private TransactionManager tm;
1:     private Coordinator coordinator;
/////////////////////////////////////////////////////////////////////////
1:         LOGGER.debug("parser asked to parse element {} ", elt.getNodeName());
0:         if ("enable-annotations".equals(elt.getLocalName())) {
0:             if (n == null || Boolean.parseBoolean(n.getNodeValue())) {
/////////////////////////////////////////////////////////////////////////
1:         meta.setRuntimeClass(AnnotationProcessor.class);
1:         meta.addArgument(passThrough(pc, cdr), ComponentDefinitionRegistry.class.getName(), 0);
1:         meta.addArgument(passThrough(pc, tm), TransactionManager.class.getName(), 1);
1:         meta.addArgument(passThrough(pc, coordinator), Coordinator.class.getName(), 1);
1:     private MutablePassThroughMetadata passThrough(ParserContext pc, Object o) {
1:         MutablePassThroughMetadata meta = pc.createMetadata(MutablePassThroughMetadata.class);
1:         meta.setObject(o);
1:         return meta;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void setTm(TransactionManager tm) {
1:         this.tm = tm;
1:     
1:     public void setCoordinator(Coordinator coordinator) {
1:         this.coordinator = coordinator;
/////////////////////////////////////////////////////////////////////////
commit:32aa11b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             LOGGER.error("An IOException occurred while loading the provider "
0:                          + "properties. Using the default provider.", e);
commit:e91e2c8
/////////////////////////////////////////////////////////////////////////
0:         LOGGER.debug("parser asked to parse element {} ", elt);
/////////////////////////////////////////////////////////////////////////
0:               String beanAttr = elt.getAttribute(BEAN);
0:                   registerComponentsWithInterceptor(cdr, beanAttr);
0:                   metaDataHelper.populateBundleWideTransactionData(cdr, txType, method, beanAttr);
1:                   
/////////////////////////////////////////////////////////////////////////
commit:e04c7d6
/////////////////////////////////////////////////////////////////////////
0: import java.io.Closeable;
/////////////////////////////////////////////////////////////////////////
0:         LOGGER.debug("parser asked to parse .. " + elt);
0:             LOGGER.debug("parser adding interceptor for " + elt);
0:             Bundle blueprintBundle = getBlueprintBundle(cdr);
0:               TransactionPropagationType txType = getType(elt.getAttribute(VALUE));
0:                   // if the enclosing component is null, then we assume this is the top element
0:                   metaDataHelper.populateBundleWideTransactionData(cdr, txType, method, bean);
0:                   LOGGER.debug("parser setting comp trans data for " + txType + "  " + method);
0:                   metaDataHelper.setComponentTransactionData(cdr, cm, txType, method);
/////////////////////////////////////////////////////////////////////////
0:                     LOGGER.debug("Enabling annotation based transactions");
0:                     MutableBeanMetadata meta = createAnnotationParserBean(pc, cdr);
0:         LOGGER.debug("parser done with " + elt);
1:     }
1: 
0:     private Bundle getBlueprintBundle(ComponentDefinitionRegistry cdr) {
0:         ComponentMetadata meta = cdr.getComponentDefinition("blueprintBundle");
0:         Bundle blueprintBundle = null;
0:         if (meta instanceof PassThroughMetadata) {
0:             blueprintBundle = (Bundle) ((PassThroughMetadata) meta).getObject();
1:         }
0:         return blueprintBundle;
1:     }
1: 
1:     private MutableBeanMetadata createAnnotationParserBean(ParserContext pc, ComponentDefinitionRegistry cdr) {
1:         MutableBeanMetadata meta = pc.createMetadata(MutableBeanMetadata.class);
1:         meta.setId(ANNOTATION_PARSER_BEAN_NAME);
0:         meta.setRuntimeClass(AnnotationParser.class);
1:         meta.setProcessor(true);
1: 
0:         MutablePassThroughMetadata cdrMeta = pc.createMetadata(MutablePassThroughMetadata.class);
0:         cdrMeta.setObject(cdr);
0:         meta.addArgument(cdrMeta, ComponentDefinitionRegistry.class.getName(), 0);
1: 
0:         MutablePassThroughMetadata interceptorMeta = pc.createMetadata(MutablePassThroughMetadata.class);
0:         interceptorMeta.setObject(interceptor);
0:         meta.addArgument(interceptorMeta, Interceptor.class.getName(), 1);
1: 
0:         MutablePassThroughMetadata helperMeta = pc.createMetadata(MutablePassThroughMetadata.class);
0:         helperMeta.setObject(metaDataHelper);
0:         meta.addArgument(helperMeta, TxComponentMetaDataHelper.class.getName(), 2);
1:         return meta;
/////////////////////////////////////////////////////////////////////////
0:         String id = getTxInterceptorId();
1: 
0:     private String getTxInterceptorId() {
0:         String id = DEFAULT_INTERCEPTOR_ID;
0:         InputStream is = TxNamespaceHandler.class.getResourceAsStream("/provider.properties");
0:         if (is == null) {
0:             return id;
1:         }
0:         try {
0:             Properties props = new Properties();
0:             props.load(is);
0:             if (props.containsKey(INTERCEPTOR_BLUEPRINT_ID)) {
0:                 id = props.getProperty(INTERCEPTOR_BLUEPRINT_ID);
1:             }
0:         } catch (IOException e) {
0:             LOGGER.error(Constants.MESSAGES.getMessage("unable.to.load.provider.props"), e);
0:         } finally {
0:             safeClose(is);
1:         }
0:         return id;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void registerComponentsWithInterceptor(ComponentDefinitionRegistry cdr, String bean) {
/////////////////////////////////////////////////////////////////////////
1:     
0:     private void safeClose(Closeable closeable) {
0:         if (closeable != null) {
0:             try {
0:                 closeable.close();
0:             } catch (IOException e) {
0:                 // Ignore
1:             }
1:         }
1:         
1:     }
commit:8047ebe
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("rawtypes")
commit:94cf93b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.mutable.MutableBeanMetadata;
/////////////////////////////////////////////////////////////////////////
0:                 if (!cdr.containsComponentDefinition(ANNOTATION_PARSER_BEAN_NAME)) {
0:                     MutableBeanMetadata meta = pc.createMetadata(MutableBeanMetadata.class);
0:                     meta.setId(ANNOTATION_PARSER_BEAN_NAME);
0:                     meta.setRuntimeClass(AnnotationParser.class);
0:                     meta.setProcessor(true);
1: 
0:                 	MutablePassThroughMetadata cdrMeta = pc.createMetadata(MutablePassThroughMetadata.class);
0:                     cdrMeta.setObject(cdr);
0:                     meta.addArgument(cdrMeta, ComponentDefinitionRegistry.class.getName(), 0);
1: 
0:                     MutablePassThroughMetadata interceptorMeta = pc.createMetadata(MutablePassThroughMetadata.class);
0:                     interceptorMeta.setObject(interceptor);
0:                     meta.addArgument(interceptorMeta, Interceptor.class.getName(), 1);
1: 
0:                     MutablePassThroughMetadata helperMeta = pc.createMetadata(MutablePassThroughMetadata.class);
0:                     helperMeta.setObject(metaDataHelper);
0:                     meta.addArgument(helperMeta, TxComponentMetaDataHelper.class.getName(), 2);
1: 
0:                     cdr.registerComponentDefinition(meta);
commit:0bfefd9
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1: public class TxNamespaceHandler implements NamespaceHandler {
1:     public static final String ANNOTATION_PARSER_BEAN_NAME = ".org_apache_aries_transaction_annotations";
0:     private static final String BEAN = "bean";
0:     private static final String VALUE = "value";
0:     private static final String METHOD = "method";
0:     private static final String INTERCEPTOR_BLUEPRINT_ID = "interceptor.blueprint.id";
1:     private static final Logger LOGGER = LoggerFactory.getLogger(TxNamespaceHandler.class);
1:     private final Map<String, String> schemaMap;
0:     
1:     public TxNamespaceHandler() {
1:         schemaMap = new HashMap<String, String>();
0:         schemaMap.put("http://aries.apache.org/xmlns/transactions/v1.0.0", "transactionv10.xsd");
0:         schemaMap.put("http://aries.apache.org/xmlns/transactions/v1.1.0", "transactionv11.xsd");
0:         schemaMap.put("http://aries.apache.org/xmlns/transactions/v1.2.0", "transactionv12.xsd");
1:     }
/////////////////////////////////////////////////////////////////////////
0:               TransactionPropagationType value = getType(elt.getAttribute(VALUE));
0:               String method = elt.getAttribute(METHOD);
0:                   String bean = elt.getAttribute(BEAN);
/////////////////////////////////////////////////////////////////////////
0:                 if(!!!cdr.containsComponentDefinition(ANNOTATION_PARSER_BEAN_NAME)) {
0:                 	mptmd.setId(ANNOTATION_PARSER_BEAN_NAME);
/////////////////////////////////////////////////////////////////////////
1:     public URL getSchemaLocation(String namespaceUri)
1:         String xsdPath = schemaMap.get(namespaceUri);
1:         return xsdPath != null ? this.getClass().getResource(xsdPath) : null;
/////////////////////////////////////////////////////////////////////////
0:         InputStream is = TxNamespaceHandler.class.getResourceAsStream("/provider.properties");
commit:aa15c54
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.transaction.annotations.TransactionPropagationType;
/////////////////////////////////////////////////////////////////////////
0:               TransactionPropagationType value = getType(elt.getAttribute(Constants.VALUE));
0:               String method = elt.getAttribute(Constants.METHOD);
/////////////////////////////////////////////////////////////////////////
0:                           value, method, bean);
0:                       LOGGER.debug("parser setting comp trans data for " + value + "  " + method);
0:                   metaDataHelper.setComponentTransactionData(cdr, cm, value, method);
/////////////////////////////////////////////////////////////////////////
0:     private TransactionPropagationType getType(String typeSt) {
0:         return typeSt == null || typeSt.length() == 0 ? null : TransactionPropagationType.valueOf(typeSt);
1:     }
0: 
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:fde93fc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.mutable.MutablePassThroughMetadata;
/////////////////////////////////////////////////////////////////////////
0:                 	
0:                 	MutablePassThroughMetadata mptmd = pc.createMetadata(MutablePassThroughMetadata.class);
0:                 	mptmd.setId(Constants.ANNOTATION_PARSER_BEAN_NAME);
0:                 	mptmd.setObject(new AnnotationParser(cdr, interceptor, metaDataHelper));
0:                     cdr.registerComponentDefinition(mptmd);
commit:76bff89
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.reflect.PassThroughMetadataImpl;
/////////////////////////////////////////////////////////////////////////
1:         ComponentDefinitionRegistry cdr = pc.getComponentDefinitionRegistry();
/////////////////////////////////////////////////////////////////////////
0:         } else if ("enable-annotations".equals(elt.getLocalName())) {
1:             Node n = elt.getChildNodes().item(0);
0:             if(n == null || Boolean.parseBoolean(n.getNodeValue())) {
0:                 //We need to register a bean processor to add annotation-based config
0:                 if(!!!cdr.containsComponentDefinition(Constants.ANNOTATION_PARSER_BEAN_NAME)) {
0:                     cdr.registerComponentDefinition(new PassThroughMetadataImpl(Constants.ANNOTATION_PARSER_BEAN_NAME,
0:                 	        new AnnotationParser(cdr, interceptor, metaDataHelper)));
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
0:     	if (Constants.TRANSACTION10URI.equals(arg0)) {
0:     	} else if (Constants.TRANSACTION11URI.equals(arg0)) {
0:     	} else if (Constants.TRANSACTION12URI.equals(arg0)) {
0:     		return this.getClass().getResource(Constants.TX12_SCHEMA);
1:     	return null;
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:d014f6c
/////////////////////////////////////////////////////////////////////////
0:                 LOGGER.error(Constants.MESSAGES.getMessage("unable.to.load.provider.props"), e);
0:                     LOGGER.error(Constants.MESSAGES.getMessage("exception.closing.stream"), e2);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:a0ebbc7
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentMap<ComponentDefinitionRegistry,Bundle> registered = new ConcurrentHashMap<ComponentDefinitionRegistry, Bundle>();
/////////////////////////////////////////////////////////////////////////
0:         if (bean == null || bean.length() == 0) {
commit:39da540
/////////////////////////////////////////////////////////////////////////
0:             // don't register components if we have no bundle (= dry parse)
0:             if (blueprintBundle != null) {
0:               registered.put(cdr, blueprintBundle);
0:               
0:               if (cm == null) {
0:                   // if the enclosing component is null, then we assume this is the top element                 
0:                   
0:                   String bean = elt.getAttribute(Constants.BEAN);
0:                   registerComponentsWithInterceptor(cdr, bean);
0:   
0:                   metaDataHelper.populateBundleWideTransactionData(pc.getComponentDefinitionRegistry(), 
0:                           elt.getAttribute(Constants.VALUE), elt.getAttribute(Constants.METHOD), bean);
0:               } else {
0:                   cdr.registerInterceptorWithComponent(cm, interceptor);
0:                   if (LOGGER.isDebugEnabled())
0:                       LOGGER.debug("parser setting comp trans data for " + elt.getAttribute(Constants.VALUE) + "  "
0:                               + elt.getAttribute(Constants.METHOD));
0:       
0:                   metaDataHelper.setComponentTransactionData(cdr, cm, elt.getAttribute(Constants.VALUE), elt
0:                           .getAttribute(Constants.METHOD));
0:               }
0:             }
commit:e2b3d87
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.transaction.BundleWideTxData;
/////////////////////////////////////////////////////////////////////////
0:             
0:             ComponentMetadata meta = cdr.getComponentDefinition("blueprintBundle");
0:             Bundle blueprintBundle = null;
0:             if (meta instanceof PassThroughMetadata) {
0:                 blueprintBundle = (Bundle) ((PassThroughMetadata) meta).getObject();
0:             }
0: 
0:             registered.put(cdr, blueprintBundle);
/////////////////////////////////////////////////////////////////////////
0:     private void registerComponentsWithInterceptor(ComponentDefinitionRegistry cdr, String bean) {        
0:         Set<String> ids = cdr.getComponentDefinitionNames();
0: 
0:         if (bean == null || bean.isEmpty()) {
0:             // in this case, let's attempt to register all components
0:             // if the component has already been registered with this interceptor,
0:             // the registration will be ignored.
0:             for (String id : ids) {
0:                 ComponentMetadata componentMetadata = cdr.getComponentDefinition(id);
0:                 cdr.registerInterceptorWithComponent(componentMetadata, interceptor);
0:         } else {
0:             //create a dummy bundle wide tx data, so we can get the bean patterns from it
0:             BundleWideTxData data = new BundleWideTxData(null, "*", bean);
0:             for (Pattern p : data.getBean()) {
0:               for (String id : ids) {
0:                   Matcher m = p.matcher(id);
0:                   if (m.matches()) {
0:                       ComponentMetadata componentMetadata = cdr.getComponentDefinition(id);
0:                       cdr.registerInterceptorWithComponent(componentMetadata, interceptor);
0:                   }
0:               }
0:             }
0:         }
commit:4de6208
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
1: import java.util.Map;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.PassThroughMetadata;
0: import org.osgi.framework.Bundle;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger LOGGER = LoggerFactory.getLogger(TxElementHandler.class);
0:     private ConcurrentMap<ComponentDefinitionRegistry,Bundle> registered = new ConcurrentHashMap<ComponentDefinitionRegistry, Bundle>();
/////////////////////////////////////////////////////////////////////////
0:                 // if the enclosing component is null, then we assume this is the top element                 
/////////////////////////////////////////////////////////////////////////
0:                 metaDataHelper.setComponentTransactionData(cdr, cm, elt.getAttribute(Constants.VALUE), elt
/////////////////////////////////////////////////////////////////////////
0:     	    return this.getClass().getResource(Constants.TX10_SCHEMA);
0:     	    return this.getClass().getResource(Constants.TX11_SCHEMA);
/////////////////////////////////////////////////////////////////////////
0:     public boolean isRegistered(ComponentDefinitionRegistry cdr) {
0:         return registered.containsKey(cdr);
0:     }
0:     
0:     public void unregister(Bundle blueprintBundle) {
0:         Iterator<Map.Entry<ComponentDefinitionRegistry, Bundle>> it = registered.entrySet().iterator();
0:         while (it.hasNext()) {
0:             Map.Entry<ComponentDefinitionRegistry, Bundle> e = it.next();
0:             if (blueprintBundle.equals(e.getValue())) {
0:                 metaDataHelper.unregister(e.getKey());
0:                 it.remove();
0:         ComponentMetadata meta = cdr.getComponentDefinition("blueprintBundle");
0:         Bundle blueprintBundle = null;
0:         if (meta instanceof PassThroughMetadata) {
0:             blueprintBundle = (Bundle) ((PassThroughMetadata) meta).getObject();
0:         // if it is already registered all components in the component definition registry, do nothing
0:         if (registered.putIfAbsent(cdr, blueprintBundle) == null) {
0:             Set<String> ids = cdr.getComponentDefinitionNames();
0:             
0:             if (bean == null || bean.isEmpty()) {
0:                 // in this case, let's attempt to register all components
0:                 // if the component has already been registered with this interceptor,
0:                 // the registration will be ignored.
0:                 for (String id : ids) {
0:             } else {
0:                 // register the beans specified
0:                 Pattern p = Pattern.compile(bean);
0:                 for (String id : ids) {
0:                     Matcher m = p.matcher(id);
0:                     if (m.matches()) {
0:                         ComponentMetadata componentMetadata = cdr.getComponentDefinition(id);
0:                         cdr.registerInterceptorWithComponent(componentMetadata, interceptor);
0:                     }
0:                 }
0:         }        
commit:c3c0e1b
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.blueprint.container.BlueprintContainer;
/////////////////////////////////////////////////////////////////////////
0:     public static final String DEFAULT_INTERCEPTOR_ID = "txinterceptor";
0:     public static final String INTERCEPTOR_BLUEPRINT_ID = "interceptor.blueprint.id";
0: 
/////////////////////////////////////////////////////////////////////////
0:     public final void setBlueprintContainer(BlueprintContainer container) 
0:         String id = DEFAULT_INTERCEPTOR_ID;
0:         InputStream is = TxElementHandler.class.getResourceAsStream("/provider.properties");
0:         if (is != null) {
0:             try {
0:                 Properties props = new Properties();
0:                 props.load(is);
0:                 if (props.containsKey(INTERCEPTOR_BLUEPRINT_ID)) {
0:                     id = props.getProperty(INTERCEPTOR_BLUEPRINT_ID);
0:                 }
0:             } catch (IOException e) {
0:                 LOGGER.error("IOException while loading provider properties. Using default provider", e);
0:             } finally {
0:                 try {
0:                     is.close();
0:                 } catch (IOException e2) {
0:                     LOGGER.error("Unexpected exception while closing stream", e2);
0:                 }
0:             }
0:         }
0:         
0:         this.interceptor = (Interceptor) container.getComponentInstance(id);
0:     
commit:5c15102
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger LOGGER =
0:         LoggerFactory.getLogger(TxElementHandler.class);
0:         if (LOGGER.isDebugEnabled())
0:             LOGGER.debug("parser asked to parse .. " + elt);
0:             if (LOGGER.isDebugEnabled())
0:                 LOGGER.debug("parser adding interceptor for " + elt);
0:             if (LOGGER.isDebugEnabled())
0:                 LOGGER.debug("parser setting comp trans data for " + elt.getAttribute("value") + "  "
0:         if (LOGGER.isDebugEnabled())
0:             LOGGER.debug("parser done with " + elt);
/////////////////////////////////////////////////////////////////////////
0:         if (LOGGER.isDebugEnabled())
0:             LOGGER.debug("parser having interceptor set " + itx);
author:Lin Sun
-------------------------------------------------------------------------------
commit:1b5422b
/////////////////////////////////////////////////////////////////////////
0:     	if (arg0.equals(Constants.TRANSACTION10URI)) {
0:     		return this.getClass().getResource(Constants.TX10_SCHEMA);
0:     	} else {
0:             return this.getClass().getResource(Constants.TX11_SCHEMA);
0:     	}
commit:c34631b
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.util.regex.Matcher;
0: import java.util.regex.Pattern;
0: import org.apache.aries.transaction.Constants;
/////////////////////////////////////////////////////////////////////////
0:     private Set<ComponentDefinitionRegistry> registered = new HashSet<ComponentDefinitionRegistry>();
0: 
/////////////////////////////////////////////////////////////////////////
0:             
0:             if (cm == null) {
0:                 // if the enclosing component is null, then we assume this is the top element 
0:                 
0:                 
0:                 String bean = elt.getAttribute(Constants.BEAN);
0:                 registerComponentsWithInterceptor(cdr, bean);
0:                 metaDataHelper.populateBundleWideTransactionData(pc.getComponentDefinitionRegistry(), 
0:                         elt.getAttribute(Constants.VALUE), elt.getAttribute(Constants.METHOD), bean);
0:             } else {
0:                 cdr.registerInterceptorWithComponent(cm, interceptor);
0:                 if (LOGGER.isDebugEnabled())
0:                     LOGGER.debug("parser setting comp trans data for " + elt.getAttribute(Constants.VALUE) + "  "
0:                             + elt.getAttribute(Constants.METHOD));
0:     
0:                 metaDataHelper.setComponentTransactionData(cm, elt.getAttribute(Constants.VALUE), elt
0:                         .getAttribute(Constants.METHOD));
0:             }
/////////////////////////////////////////////////////////////////////////
0:         return this.getClass().getResource(Constants.TX_SCHEMA);
/////////////////////////////////////////////////////////////////////////
0:     
0:     private boolean isRegistered(ComponentDefinitionRegistry cdr) {
0:         for (ComponentDefinitionRegistry compdr : registered) {
0:             if (compdr == cdr) {
0:                 return true;
0:             }
0:         }
0:         
0:         return false;
0:     }
0:     
0:     private void registerComponentsWithInterceptor(ComponentDefinitionRegistry cdr, String bean) {
0:         // if it is already registered all components in the component definition registry, do nothing
0:         if (isRegistered(cdr)) {
0:             return;
0:         }
0:         
0:         Set<String> ids = cdr.getComponentDefinitionNames();
0:         
0:         if (bean == null || bean.isEmpty()) {
0:             // in this case, let's attempt to register all components
0:             // if the component has already been registered with this interceptor,
0:             // the registration will be ignored.
0:             for (String id : ids) {
0:                 ComponentMetadata componentMetadata = cdr.getComponentDefinition(id);
0:                 cdr.registerInterceptorWithComponent(componentMetadata, interceptor);
0:             }
0:             synchronized (registered) {
0:                 registered.add(cdr);
0:             }
0:         } else {
0:             // register the beans specified
0:             Pattern p = Pattern.compile(bean);
0:             for (String id : ids) {
0:                 Matcher m = p.matcher(id);
0:                 if (m.matches()) {
0:                     ComponentMetadata componentMetadata = cdr.getComponentDefinition(id);
0:                     cdr.registerInterceptorWithComponent(componentMetadata, interceptor);
0:                 }
0:             }
0:         }
0:     }
0:     
0:     // check if the beans pattern includes the particular component/bean id
0:     /*private boolean includes(String beans, String id) {
0:         return Pattern.matches(beans, id);
0:     }*/
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:3fbf745
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:6f219fd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.transaction.parsing;
0: 
1: import java.net.URL;
1: import java.util.Set;
0: 
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
0: import org.apache.aries.blueprint.Interceptor;
1: import org.apache.aries.blueprint.NamespaceHandler;
1: import org.apache.aries.blueprint.ParserContext;
0: import org.apache.aries.transaction.TxComponentMetaDataHelper;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: import org.w3c.dom.Element;
1: import org.w3c.dom.Node;
0: 
0: public class TxElementHandler implements NamespaceHandler {
0:     private static final Logger _logger =
0:         LoggerFactory.getLogger("org.apache.aries.transaction.parsing");
0: 
0:     private TxComponentMetaDataHelper metaDataHelper;
0:     private Interceptor interceptor = null;
0: 
0:     private void parseElement(Element elt, ComponentMetadata cm, ParserContext pc)
1:     {
0:         if (_logger.isDebugEnabled())
0:             _logger.debug("parser asked to parse .. " + elt);
0: 
0:         if ("transaction".equals(elt.getLocalName())) {
0:             if (_logger.isDebugEnabled())
0:                 _logger.debug("parser adding interceptor for " + elt);
0: 
0:             ComponentDefinitionRegistry cdr = pc.getComponentDefinitionRegistry();
0:             cdr.registerInterceptorWithComponent(cm, interceptor);
0:             if (_logger.isDebugEnabled())
0:                 _logger.debug("parser setting comp trans data for " + elt.getAttribute("value") + "  "
0:                         + elt.getAttribute("method"));
0: 
0:             metaDataHelper.setComponentTransactionData(cm, elt.getAttribute("value"), elt
0:                     .getAttribute("method"));
0:         }
0:         
0:         if (_logger.isDebugEnabled())
0:             _logger.debug("parser done with " + elt);
0:     }
0: 
1:     public ComponentMetadata decorate(Node node, ComponentMetadata cm, ParserContext pc)
1:     {
1:         if (node instanceof Element) {
0:             Element elt = (Element) node;
0:             parseElement(elt, cm, pc);
0:         }
1:         return cm;
0:     }
0: 
1:     public Metadata parse(Element elt, ParserContext pc)
1:     {
0:         //really not sure here if using enclosing component is valid...
0:         //TODO: confirm if null may be better.
0:         parseElement(elt, pc.getEnclosingComponent(), pc);
0:         return null;
0:     }
0: 
0:     public URL getSchemaLocation(String arg0)
1:     {
0:         return this.getClass().getResource("transaction.xsd");
0:     }
0: 
0:     public final void setTxMetaDataHelper(TxComponentMetaDataHelper transactionEnhancer)
1:     {
0:         this.metaDataHelper = transactionEnhancer;
0:     }
0: 
0:     public final void setTransactionInterceptor(Interceptor itx)
1:     {
0:         if (_logger.isDebugEnabled())
0:             _logger.debug("parser having interceptor set " + itx);
0:         
0:         this.interceptor = itx;
0:     }
0: 
1:     public Set<Class> getManagedClasses()
1:     {
0:         // TODO Auto-generated method stub
0:         return null;
0:     }
0: }
============================================================================