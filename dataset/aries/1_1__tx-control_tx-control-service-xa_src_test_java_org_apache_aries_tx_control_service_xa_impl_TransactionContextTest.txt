1:593cb80: /*
1:593cb80:  * Licensed to the Apache Software Foundation (ASF) under one
1:593cb80:  * or more contributor license agreements.  See the NOTICE file
1:593cb80:  * distributed with this work for additional information
1:593cb80:  * regarding copyright ownership.  The ASF licenses this file
1:593cb80:  * to you under the Apache License, Version 2.0 (the
1:593cb80:  * "License"); you may not use this file except in compliance
1:593cb80:  * with the License.  You may obtain a copy of the License at
1:593cb80:  *
1:593cb80:  *   http://www.apache.org/licenses/LICENSE-2.0
1:593cb80:  *
1:593cb80:  * Unless required by applicable law or agreed to in writing,
1:593cb80:  * software distributed under the License is distributed on an
1:593cb80:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:593cb80:  * KIND, either express or implied.  See the License for the
1:593cb80:  * specific language governing permissions and limitations
1:593cb80:  * under the License.
1:593cb80:  */
1:78dd69f: package org.apache.aries.tx.control.service.xa.impl;
41:78dd69f: 
1:cc2f539: import static org.apache.aries.tx.control.service.xa.impl.LocalResourceSupport.DISABLED;
1:cc2f539: import static org.apache.aries.tx.control.service.xa.impl.LocalResourceSupport.ENABLED;
1:cc2f539: import static org.apache.aries.tx.control.service.xa.impl.LocalResourceSupport.ENFORCE_SINGLE;
1:78dd69f: import static org.junit.Assert.assertEquals;
1:78dd69f: import static org.junit.Assert.assertFalse;
1:78dd69f: import static org.junit.Assert.assertNotNull;
1:78dd69f: import static org.junit.Assert.assertNull;
1:78dd69f: import static org.junit.Assert.assertSame;
1:78dd69f: import static org.junit.Assert.assertTrue;
1:cc2f539: import static org.junit.Assert.fail;
1:78dd69f: import static org.osgi.service.transaction.control.TransactionStatus.ACTIVE;
1:78dd69f: import static org.osgi.service.transaction.control.TransactionStatus.COMMITTED;
1:78dd69f: import static org.osgi.service.transaction.control.TransactionStatus.COMMITTING;
1:78dd69f: import static org.osgi.service.transaction.control.TransactionStatus.MARKED_ROLLBACK;
1:78dd69f: import static org.osgi.service.transaction.control.TransactionStatus.ROLLED_BACK;
1:78dd69f: import static org.osgi.service.transaction.control.TransactionStatus.ROLLING_BACK;
1:78dd69f: 
1:78dd69f: import java.util.concurrent.atomic.AtomicInteger;
1:78dd69f: 
1:78dd69f: import javax.transaction.xa.XAException;
1:78dd69f: import javax.transaction.xa.XAResource;
1:78dd69f: import javax.transaction.xa.Xid;
1:78dd69f: 
1:78dd69f: import org.apache.aries.tx.control.service.common.impl.AbstractTransactionContextImpl;
1:47a70d3: import org.apache.geronimo.transaction.manager.RecoveryWorkAroundTransactionManager;
1:47a70d3: import org.apache.geronimo.transaction.manager.XidFactoryImpl;
1:78dd69f: import org.junit.Before;
1:78dd69f: import org.junit.Test;
1:78dd69f: import org.junit.runner.RunWith;
1:78dd69f: import org.mockito.ArgumentCaptor;
1:78dd69f: import org.mockito.InOrder;
1:78dd69f: import org.mockito.Mock;
1:78dd69f: import org.mockito.Mockito;
1:78dd69f: import org.mockito.runners.MockitoJUnitRunner;
1:78dd69f: import org.osgi.service.transaction.control.LocalResource;
1:78dd69f: import org.osgi.service.transaction.control.TransactionException;
1:78dd69f: 
1:78dd69f: @RunWith(MockitoJUnitRunner.class)
1:78dd69f: public class TransactionContextTest {
1:78dd69f: 
2:78dd69f: 	@Mock
1:78dd69f: 	XAResource xaResource;
1:78dd69f: 	@Mock
1:78dd69f: 	LocalResource localResource;
1:78dd69f: 	
1:78dd69f: 	AbstractTransactionContextImpl ctx;
1:78dd69f: 	
1:78dd69f: 	@Before
1:78dd69f: 	public void setUp() throws XAException {
1:47a70d3: 		ctx = new TransactionContextImpl(getTxMgr(), false, ENFORCE_SINGLE);
1:47a70d3: 	}
1:47a70d3: 
1:47a70d3: 	private RecoveryWorkAroundTransactionManager getTxMgr() throws XAException {
1:47a70d3: 		return new RecoveryWorkAroundTransactionManager(30, new XidFactoryImpl(), null);
8:78dd69f: 	}
1:78dd69f: 	
5:78dd69f: 	@Test
1:78dd69f: 	public void testGetRollbackOnly() {
1:78dd69f: 		assertFalse(ctx.getRollbackOnly());
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testSetRollbackOnly() {
1:78dd69f: 		ctx.setRollbackOnly();
1:78dd69f: 		assertTrue(ctx.getRollbackOnly());
1:78dd69f: 	}
1:661c406: 	
1:661c406: 	@Test
1:661c406: 	public void testisReadOnlyFalse() {
1:661c406: 		assertFalse(ctx.isReadOnly());
1:661c406: 	}
1:661c406: 
1:661c406: 	@Test
1:661c406: 	public void testisReadOnlyTrue() throws XAException {
1:47a70d3: 		ctx = new TransactionContextImpl(getTxMgr(), true, ENFORCE_SINGLE);
1:661c406: 		assertTrue(ctx.isReadOnly());
1:661c406: 	}
1:661c406: 
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testTransactionKey() {
1:78dd69f: 		assertNotNull(ctx.getTransactionKey());
1:78dd69f: 	}
1:78dd69f: 	
1:78dd69f: 	@Test
1:78dd69f: 	public void testTransactionStatus() {
1:78dd69f: 		assertEquals(ACTIVE, ctx.getTransactionStatus());
1:78dd69f: 		
1:78dd69f: 		ctx.setRollbackOnly();
1:78dd69f: 		
1:78dd69f: 		assertEquals(MARKED_ROLLBACK, ctx.getTransactionStatus());
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testLocalResourceSupport() {
1:78dd69f: 		assertTrue(ctx.supportsLocal());
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:cc2f539: 	public void testLocalResourceSupportEnabled() throws XAException {
1:47a70d3: 		ctx = new TransactionContextImpl(getTxMgr(), true, ENABLED);
1:cc2f539: 		assertTrue(ctx.supportsLocal());
1:cc2f539: 	}
1:cc2f539: 
1:cc2f539: 	@Test
1:cc2f539: 	public void testLocalResourceSupportDisabled() throws XAException {
1:47a70d3: 		ctx = new TransactionContextImpl(getTxMgr(), true, DISABLED);
1:cc2f539: 		assertFalse(ctx.supportsLocal());
1:cc2f539: 	}
1:cc2f539: 
1:cc2f539: 	@Test
1:78dd69f: 	public void testXAResourceSupport() {
1:78dd69f: 		assertTrue(ctx.supportsXA());
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testXAResourceRegistration() {
1:47a70d3: 		ctx.registerXAResource(xaResource, null);
1:47a70d3: 	}
1:47a70d3: 
1:47a70d3: 	@Test
1:47a70d3: 	public void testRecoverableXAResourceRegistration() {
1:47a70d3: 		ctx.registerXAResource(xaResource, "anId");
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testScopedValues() {
1:78dd69f: 		assertNull(ctx.getScopedValue("foo"));
1:78dd69f: 		
1:78dd69f: 		Object value = new Object();
1:78dd69f: 		
1:78dd69f: 		ctx.putScopedValue("foo", value);
1:78dd69f: 		
1:78dd69f: 		assertSame(value, ctx.getScopedValue("foo"));
1:78dd69f: 	}
1:78dd69f: 	
1:78dd69f: 	@Test
1:78dd69f: 	public void testPreCompletion() throws Exception {
1:78dd69f: 		
1:78dd69f: 		AtomicInteger value = new AtomicInteger(0);
1:78dd69f: 		
1:78dd69f: 		ctx.preCompletion(() -> {
1:78dd69f: 			assertEquals(ACTIVE, ctx.getTransactionStatus());
1:78dd69f: 			value.compareAndSet(1, 5);
1:78dd69f: 		});
1:78dd69f: 		
1:78dd69f: 		assertEquals(0, value.getAndSet(1));
1:78dd69f: 		
7:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		assertEquals(5, value.get());
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testPreCompletionFail() throws Exception {
1:78dd69f: 		
1:78dd69f: 		AtomicInteger value = new AtomicInteger(0);
1:78dd69f: 		
1:78dd69f: 		ctx.preCompletion(() -> {
1:78dd69f: 			assertEquals(MARKED_ROLLBACK, ctx.getTransactionStatus());
1:78dd69f: 			value.compareAndSet(1, 5);
1:78dd69f: 		});
1:78dd69f: 		
1:78dd69f: 		assertEquals(0, value.getAndSet(1));
1:78dd69f: 		
1:78dd69f: 		
1:f87416c: 		ctx.setRollbackOnly();
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 
1:78dd69f: 		assertEquals(5, value.get());
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testPostCompletion() throws Exception {
1:78dd69f: 		
1:78dd69f: 		AtomicInteger value = new AtomicInteger(0);
1:78dd69f: 		
1:78dd69f: 		ctx.postCompletion(status -> {
1:78dd69f: 				assertEquals(COMMITTED, status);
1:78dd69f: 				value.compareAndSet(1, 5);
1:78dd69f: 			});
1:78dd69f: 		
1:78dd69f: 		assertEquals(0, value.getAndSet(1));
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		assertEquals(5, value.get());
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testPostCompletionFail() throws Exception {
1:78dd69f: 		
1:78dd69f: 		AtomicInteger value = new AtomicInteger(0);
1:78dd69f: 		
1:78dd69f: 		ctx.postCompletion(status -> {
1:78dd69f: 			assertEquals(ROLLED_BACK, status);
1:78dd69f: 			value.compareAndSet(1, 5);
1:78dd69f: 		});
1:78dd69f: 		
1:78dd69f: 		assertEquals(0, value.getAndSet(1));
1:78dd69f: 		
1:f87416c: 		ctx.setRollbackOnly();
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		assertEquals(5, value.get());
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testPostCompletionIsAfterPreCompletion() throws Exception {
1:78dd69f: 		
1:78dd69f: 		AtomicInteger value = new AtomicInteger(0);
1:78dd69f: 		
1:78dd69f: 		ctx.preCompletion(() -> {
1:78dd69f: 			assertEquals(ACTIVE, ctx.getTransactionStatus());
1:78dd69f: 			value.compareAndSet(0, 3);
1:78dd69f: 		});
1:78dd69f: 		ctx.postCompletion(status -> {
1:78dd69f: 			assertEquals(COMMITTED, status);
1:78dd69f: 			value.compareAndSet(3, 5);
1:78dd69f: 		});
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		assertEquals(5, value.get());
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testPostCompletionIsStillCalledAfterPreCompletionException() throws Exception {
1:78dd69f: 		
1:78dd69f: 		AtomicInteger value = new AtomicInteger(0);
1:78dd69f: 		
1:78dd69f: 		ctx.preCompletion(() -> {
1:78dd69f: 				value.compareAndSet(0, 3);
1:78dd69f: 				throw new RuntimeException("Boom!");
1:78dd69f: 			});
1:78dd69f: 		ctx.postCompletion(status -> {
1:78dd69f: 			assertEquals(ROLLED_BACK, status);
1:78dd69f: 			value.compareAndSet(3, 5);
1:78dd69f: 		});
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		assertEquals(5, value.get());
1:78dd69f: 	}
1:78dd69f: 
3:78dd69f: 	@Test(expected=IllegalStateException.class)
1:78dd69f: 	public void testPreCompletionAfterEnd() throws Exception {
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
2:78dd69f: 		ctx.preCompletion(() -> {});
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test(expected=IllegalStateException.class)
1:78dd69f: 	public void testPostCompletionAfterEnd() throws Exception {
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
2:78dd69f: 		ctx.postCompletion(x -> {});
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testLocalResource() throws Exception {
3:78dd69f: 		ctx.registerLocalResource(localResource);
1:78dd69f: 		
5:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
5:78dd69f: 			return null;
1:78dd69f: 		}).when(localResource).commit();
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		Mockito.verify(localResource).commit();
1:78dd69f: 	}
1:78dd69f: 	
1:78dd69f: 	@Test
1:78dd69f: 	public void testLocalResourceRollbackOnly() throws Exception {
1:78dd69f: 		ctx.registerLocalResource(localResource);
1:78dd69f: 		ctx.setRollbackOnly();
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
5:78dd69f: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1:78dd69f: 			return null;
3:78dd69f: 		}).when(localResource).rollback();
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
3:78dd69f: 		Mockito.verify(localResource).rollback();
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testLocalResourcePreCommitException() throws Exception {
1:78dd69f: 		ctx.registerLocalResource(localResource);
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1:78dd69f: 			return null;
1:78dd69f: 		}).when(localResource).rollback();
1:78dd69f: 		
1:78dd69f: 		ctx.preCompletion(() -> { throw new IllegalArgumentException(); });
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		Mockito.verify(localResource).rollback();
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testLocalResourcePostCommitException() throws Exception {
1:78dd69f: 		ctx.registerLocalResource(localResource);
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1:78dd69f: 			return null;
1:78dd69f: 		}).when(localResource).commit();
1:78dd69f: 		
1:78dd69f: 		ctx.postCompletion(i -> { 
1:78dd69f: 				assertEquals(COMMITTED, ctx.getTransactionStatus());
1:78dd69f: 				throw new IllegalArgumentException(); 
1:78dd69f: 			});
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		Mockito.verify(localResource).commit();
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:cc2f539: 	public void testSecondLocalResourceCannotBeAdded() throws Exception {
1:cc2f539: 		
1:cc2f539: 		ctx.registerLocalResource(localResource);
1:cc2f539: 		
1:cc2f539: 		LocalResource localResource2 = Mockito.mock(LocalResource.class);
1:cc2f539: 		try {
1:cc2f539: 			ctx.registerLocalResource(localResource2);
1:cc2f539: 			fail("A second local resource should trigger a failure");
1:cc2f539: 		} catch (TransactionException te) {
1:cc2f539: 			
1:cc2f539: 		}
1:cc2f539: 	}
1:cc2f539: 
1:cc2f539: 	@Test
1:cc2f539: 	public void testNoLocalResourceCanBeAddedWhenDisabled() throws Exception {
1:47a70d3: 		ctx = new TransactionContextImpl(getTxMgr(), true, DISABLED);
1:cc2f539: 		
1:cc2f539: 		try {
1:cc2f539: 			ctx.registerLocalResource(localResource);
1:cc2f539: 			fail("A local resource should trigger a failure");
1:cc2f539: 		} catch (TransactionException te) {
1:cc2f539: 			
1:cc2f539: 		}
1:cc2f539: 	}
1:cc2f539: 	
1:cc2f539: 	@Test
1:cc2f539: 	public void testMultipleLocalResourcesFirstFailsSoRollback() throws Exception {
1:47a70d3: 		ctx = new TransactionContextImpl(getTxMgr(), true, ENABLED);
1:78dd69f: 		
1:78dd69f: 		ctx.registerLocalResource(localResource);
1:78dd69f: 
1:78dd69f: 		LocalResource localResource2 = Mockito.mock(LocalResource.class);
1:78dd69f: 		ctx.registerLocalResource(localResource2);
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1:78dd69f: 			throw new TransactionException("Unable to commit");
1:78dd69f: 		}).when(localResource).commit();
1:78dd69f: 
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1:78dd69f: 			return null;
1:78dd69f: 		}).when(localResource2).rollback();
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		Mockito.verify(localResource).commit();
1:78dd69f: 		Mockito.verify(localResource2).rollback();
1:78dd69f: 	}
1:78dd69f: 	
1:78dd69f: 	@Test
1:78dd69f: 	public void testSingleXAResource() throws Exception {
1:47a70d3: 		ctx.registerXAResource(xaResource, null);
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1:78dd69f: 			return null;
1:78dd69f: 		}).when(xaResource).commit(Mockito.any(Xid.class), Mockito.eq(true));
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
3:78dd69f: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1:78dd69f: 		
3:78dd69f: 		InOrder inOrder = Mockito.inOrder(xaResource);
1:78dd69f: 		
3:78dd69f: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
3:78dd69f: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1:78dd69f: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMSUCCESS));
1:78dd69f: 		inOrder.verify(xaResource).commit(Mockito.eq(captor.getValue()), Mockito.eq(true));
1:78dd69f: 		
3:78dd69f: 		Mockito.verifyNoMoreInteractions(xaResource);
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testXAResourceRollbackOnly() throws Exception {
1:47a70d3: 		ctx.registerXAResource(xaResource, null);
1:78dd69f: 		ctx.setRollbackOnly();
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1:78dd69f: 			return null;
3:78dd69f: 		}).when(xaResource).rollback(Mockito.any(Xid.class));
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1:78dd69f: 		
1:78dd69f: 		InOrder inOrder = Mockito.inOrder(xaResource);
1:78dd69f: 		
1:78dd69f: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1:78dd69f: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
3:78dd69f: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMFAIL));
3:78dd69f: 		inOrder.verify(xaResource).rollback(Mockito.eq(captor.getValue()));
1:78dd69f: 		
1:78dd69f: 		Mockito.verifyNoMoreInteractions(xaResource);
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testXAResourcePreCommitException() throws Exception {
1:47a70d3: 		ctx.registerXAResource(xaResource, null);
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1:78dd69f: 			return null;
1:78dd69f: 		}).when(xaResource).rollback(Mockito.any(Xid.class));
1:78dd69f: 		
1:78dd69f: 		ctx.preCompletion(() -> { throw new IllegalArgumentException(); });
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1:78dd69f: 		
1:78dd69f: 		InOrder inOrder = Mockito.inOrder(xaResource);
1:78dd69f: 		
1:78dd69f: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1:78dd69f: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1:78dd69f: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMFAIL));
1:78dd69f: 		inOrder.verify(xaResource).rollback(Mockito.eq(captor.getValue()));
1:78dd69f: 		
1:78dd69f: 		Mockito.verifyNoMoreInteractions(xaResource);
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testXAResourcePostCommitException() throws Exception {
1:47a70d3: 		ctx.registerXAResource(xaResource, null);
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1:78dd69f: 			return null;
1:78dd69f: 		}).when(xaResource).commit(Mockito.any(Xid.class), Mockito.eq(true));
1:78dd69f: 		
1:78dd69f: 		ctx.postCompletion(i -> { 
1:78dd69f: 			assertEquals(COMMITTED, ctx.getTransactionStatus());
1:78dd69f: 			throw new IllegalArgumentException(); 
1:78dd69f: 		});
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1:78dd69f: 		
1:78dd69f: 		InOrder inOrder = Mockito.inOrder(xaResource);
1:78dd69f: 		
1:78dd69f: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1:78dd69f: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1:78dd69f: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMSUCCESS));
1:78dd69f: 		inOrder.verify(xaResource).commit(Mockito.eq(captor.getValue()), Mockito.eq(true));
1:78dd69f: 		
1:78dd69f: 		Mockito.verifyNoMoreInteractions(xaResource);
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testLastParticipantSuccessSoCommit() throws Exception {
1:78dd69f: 		
1:78dd69f: 		ctx.registerLocalResource(localResource);
1:47a70d3: 		ctx.registerXAResource(xaResource, null);
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1:78dd69f: 			return null;
1:78dd69f: 		}).when(localResource).commit();
1:78dd69f: 
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1:78dd69f: 			return null;
1:78dd69f: 		}).when(xaResource).commit(Mockito.any(Xid.class), Mockito.eq(false));
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1:78dd69f: 		
1:78dd69f: 		InOrder inOrder = Mockito.inOrder(xaResource, localResource);
1:78dd69f: 		
1:78dd69f: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1:78dd69f: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1:78dd69f: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMSUCCESS));
1:78dd69f: 		inOrder.verify(xaResource).prepare(captor.getValue());
1:78dd69f: 		inOrder.verify(localResource).commit();
1:78dd69f: 		inOrder.verify(xaResource).commit(Mockito.eq(captor.getValue()), Mockito.eq(false));
1:78dd69f: 		
1:78dd69f: 		Mockito.verifyNoMoreInteractions(xaResource, localResource);
1:78dd69f: 	}
1:78dd69f: 
1:78dd69f: 	@Test
1:78dd69f: 	public void testLastParticipantFailsSoRollback() throws Exception {
1:78dd69f: 		
1:78dd69f: 		ctx.registerLocalResource(localResource);
1:47a70d3: 		ctx.registerXAResource(xaResource, null);
1:78dd69f: 		
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1:78dd69f: 			throw new TransactionException("Unable to commit");
1:78dd69f: 		}).when(localResource).commit();
1:78dd69f: 
1:78dd69f: 		Mockito.doAnswer(i -> {
1:78dd69f: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1:78dd69f: 			return null;
1:78dd69f: 		}).when(xaResource).rollback(Mockito.any(Xid.class));
1:78dd69f: 		
1:78dd69f: 		ctx.finish();
1:78dd69f: 		
1:78dd69f: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1:78dd69f: 		
1:78dd69f: 		InOrder inOrder = Mockito.inOrder(xaResource, localResource);
1:78dd69f: 		
1:78dd69f: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1:78dd69f: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1:78dd69f: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMSUCCESS));
1:78dd69f: 		inOrder.verify(xaResource).prepare(captor.getValue());
1:78dd69f: 		inOrder.verify(localResource).commit();
1:78dd69f: 		inOrder.verify(xaResource).rollback(Mockito.eq(captor.getValue()));
1:78dd69f: 		
1:78dd69f: 		Mockito.verifyNoMoreInteractions(xaResource, localResource);
1:78dd69f: 	}
1:78dd69f: 	
1:78dd69f: }
============================================================================
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:47a70d3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.geronimo.transaction.manager.RecoveryWorkAroundTransactionManager;
1: import org.apache.geronimo.transaction.manager.XidFactoryImpl;
/////////////////////////////////////////////////////////////////////////
1: 		ctx = new TransactionContextImpl(getTxMgr(), false, ENFORCE_SINGLE);
1: 	}
1: 
1: 	private RecoveryWorkAroundTransactionManager getTxMgr() throws XAException {
1: 		return new RecoveryWorkAroundTransactionManager(30, new XidFactoryImpl(), null);
/////////////////////////////////////////////////////////////////////////
1: 		ctx = new TransactionContextImpl(getTxMgr(), true, ENFORCE_SINGLE);
/////////////////////////////////////////////////////////////////////////
1: 		ctx = new TransactionContextImpl(getTxMgr(), true, ENABLED);
1: 		ctx = new TransactionContextImpl(getTxMgr(), true, DISABLED);
/////////////////////////////////////////////////////////////////////////
1: 		ctx.registerXAResource(xaResource, null);
1: 	}
1: 
1: 	@Test
1: 	public void testRecoverableXAResourceRegistration() {
1: 		ctx.registerXAResource(xaResource, "anId");
/////////////////////////////////////////////////////////////////////////
1: 		ctx = new TransactionContextImpl(getTxMgr(), true, DISABLED);
/////////////////////////////////////////////////////////////////////////
1: 		ctx = new TransactionContextImpl(getTxMgr(), true, ENABLED);
/////////////////////////////////////////////////////////////////////////
1: 		ctx.registerXAResource(xaResource, null);
/////////////////////////////////////////////////////////////////////////
1: 		ctx.registerXAResource(xaResource, null);
/////////////////////////////////////////////////////////////////////////
1: 		ctx.registerXAResource(xaResource, null);
/////////////////////////////////////////////////////////////////////////
1: 		ctx.registerXAResource(xaResource, null);
/////////////////////////////////////////////////////////////////////////
1: 		ctx.registerXAResource(xaResource, null);
/////////////////////////////////////////////////////////////////////////
1: 		ctx.registerXAResource(xaResource, null);
commit:cc2f539
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.aries.tx.control.service.xa.impl.LocalResourceSupport.DISABLED;
1: import static org.apache.aries.tx.control.service.xa.impl.LocalResourceSupport.ENABLED;
1: import static org.apache.aries.tx.control.service.xa.impl.LocalResourceSupport.ENFORCE_SINGLE;
1: import static org.junit.Assert.fail;
/////////////////////////////////////////////////////////////////////////
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), false, ENFORCE_SINGLE);
/////////////////////////////////////////////////////////////////////////
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), true, ENFORCE_SINGLE);
/////////////////////////////////////////////////////////////////////////
1: 	public void testLocalResourceSupportEnabled() throws XAException {
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), true, ENABLED);
1: 		assertTrue(ctx.supportsLocal());
1: 	}
1: 
1: 	@Test
1: 	public void testLocalResourceSupportDisabled() throws XAException {
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), true, DISABLED);
1: 		assertFalse(ctx.supportsLocal());
1: 	}
1: 
1: 	@Test
/////////////////////////////////////////////////////////////////////////
1: 	public void testSecondLocalResourceCannotBeAdded() throws Exception {
1: 		
1: 		ctx.registerLocalResource(localResource);
1: 		
1: 		LocalResource localResource2 = Mockito.mock(LocalResource.class);
1: 		try {
1: 			ctx.registerLocalResource(localResource2);
1: 			fail("A second local resource should trigger a failure");
1: 		} catch (TransactionException te) {
1: 			
1: 		}
1: 	}
1: 
1: 	@Test
1: 	public void testNoLocalResourceCanBeAddedWhenDisabled() throws Exception {
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), true, DISABLED);
1: 		
1: 		try {
1: 			ctx.registerLocalResource(localResource);
1: 			fail("A local resource should trigger a failure");
1: 		} catch (TransactionException te) {
1: 			
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testMultipleLocalResourcesFirstFailsSoRollback() throws Exception {
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), true, ENABLED);
commit:593cb80
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
commit:f87416c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), false);
/////////////////////////////////////////////////////////////////////////
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), true);
/////////////////////////////////////////////////////////////////////////
1: 		ctx.setRollbackOnly();
/////////////////////////////////////////////////////////////////////////
1: 		ctx.setRollbackOnly();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:661c406
/////////////////////////////////////////////////////////////////////////
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), coordination, false);
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	@Test
1: 	public void testisReadOnlyFalse() {
1: 		assertFalse(ctx.isReadOnly());
1: 	}
1: 
1: 	@Test
1: 	public void testisReadOnlyTrue() throws XAException {
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), coordination, true);
1: 		assertTrue(ctx.isReadOnly());
1: 	}
1: 
commit:78dd69f
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.tx.control.service.xa.impl;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertSame;
1: import static org.junit.Assert.assertTrue;
1: import static org.osgi.service.transaction.control.TransactionStatus.ACTIVE;
1: import static org.osgi.service.transaction.control.TransactionStatus.COMMITTED;
1: import static org.osgi.service.transaction.control.TransactionStatus.COMMITTING;
1: import static org.osgi.service.transaction.control.TransactionStatus.MARKED_ROLLBACK;
1: import static org.osgi.service.transaction.control.TransactionStatus.ROLLED_BACK;
1: import static org.osgi.service.transaction.control.TransactionStatus.ROLLING_BACK;
1: 
0: import java.util.HashMap;
0: import java.util.Map;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import javax.transaction.xa.XAException;
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: 
1: import org.apache.aries.tx.control.service.common.impl.AbstractTransactionContextImpl;
0: import org.apache.aries.tx.control.service.xa.impl.TransactionContextImpl;
0: import org.apache.geronimo.transaction.manager.GeronimoTransactionManager;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
1: import org.mockito.ArgumentCaptor;
1: import org.mockito.InOrder;
1: import org.mockito.Mock;
1: import org.mockito.Mockito;
1: import org.mockito.runners.MockitoJUnitRunner;
0: import org.osgi.service.coordinator.Coordination;
0: import org.osgi.service.coordinator.Participant;
1: import org.osgi.service.transaction.control.LocalResource;
1: import org.osgi.service.transaction.control.TransactionException;
1: 
1: @RunWith(MockitoJUnitRunner.class)
1: public class TransactionContextTest {
1: 
1: 	@Mock
0: 	Coordination coordination;
1: 	@Mock
1: 	XAResource xaResource;
1: 	@Mock
1: 	LocalResource localResource;
1: 	
0: 	Map<Class<?>, Object> variables;
1: 	
1: 	AbstractTransactionContextImpl ctx;
1: 	
1: 	@Before
1: 	public void setUp() throws XAException {
0: 		ctx = new TransactionContextImpl(new GeronimoTransactionManager(), coordination);
0: 		variables = new HashMap<>();
0: 		Mockito.when(coordination.getVariables()).thenReturn(variables);
1: 	}
1: 	
1: 	@Test
1: 	public void testGetRollbackOnly() {
1: 		assertFalse(ctx.getRollbackOnly());
1: 	}
1: 
1: 	@Test
1: 	public void testSetRollbackOnly() {
1: 		ctx.setRollbackOnly();
1: 		assertTrue(ctx.getRollbackOnly());
1: 	}
1: 
1: 	@Test
1: 	public void testTransactionKey() {
0: 		Mockito.when(coordination.getId()).thenReturn(42L);
1: 		
1: 		assertNotNull(ctx.getTransactionKey());
1: 	}
1: 	
1: 	@Test
1: 	public void testTransactionStatus() {
1: 		assertEquals(ACTIVE, ctx.getTransactionStatus());
1: 		
1: 		ctx.setRollbackOnly();
1: 		
1: 		assertEquals(MARKED_ROLLBACK, ctx.getTransactionStatus());
1: 	}
1: 
1: 	@Test
1: 	public void testLocalResourceSupport() {
1: 		assertTrue(ctx.supportsLocal());
1: 	}
1: 
1: 	@Test
1: 	public void testXAResourceSupport() {
1: 		assertTrue(ctx.supportsXA());
1: 	}
1: 
1: 	@Test
1: 	public void testXAResourceRegistration() {
0: 		ctx.registerXAResource(xaResource);
1: 	}
1: 
1: 	@Test
1: 	public void testScopedValues() {
1: 		assertNull(ctx.getScopedValue("foo"));
1: 		
1: 		Object value = new Object();
1: 		
1: 		ctx.putScopedValue("foo", value);
1: 		
1: 		assertSame(value, ctx.getScopedValue("foo"));
1: 	}
1: 	
1: 	@Test
1: 	public void testPreCompletion() throws Exception {
1: 		
1: 		AtomicInteger value = new AtomicInteger(0);
1: 		
1: 		ctx.preCompletion(() -> {
1: 			assertEquals(ACTIVE, ctx.getTransactionStatus());
1: 			value.compareAndSet(1, 5);
1: 		});
1: 		
1: 		assertEquals(0, value.getAndSet(1));
1: 		
1: 		ctx.finish();
1: 		
1: 		assertEquals(5, value.get());
1: 	}
1: 
1: 	@Test
1: 	public void testPreCompletionFail() throws Exception {
1: 		
1: 		AtomicInteger value = new AtomicInteger(0);
1: 		
1: 		ctx.preCompletion(() -> {
1: 			assertEquals(MARKED_ROLLBACK, ctx.getTransactionStatus());
1: 			value.compareAndSet(1, 5);
1: 		});
1: 		
1: 		assertEquals(0, value.getAndSet(1));
1: 		
1: 		
0: 		ArgumentCaptor<Participant> captor = ArgumentCaptor.forClass(Participant.class);
0: 		Mockito.verify(coordination).addParticipant(captor.capture());
1: 		
0: 		captor.getValue().failed(coordination);
1: 		
1: 		ctx.finish();
1: 
1: 		assertEquals(5, value.get());
1: 	}
1: 
1: 	@Test
1: 	public void testPostCompletion() throws Exception {
1: 		
1: 		AtomicInteger value = new AtomicInteger(0);
1: 		
1: 		ctx.postCompletion(status -> {
1: 				assertEquals(COMMITTED, status);
1: 				value.compareAndSet(1, 5);
1: 			});
1: 		
1: 		assertEquals(0, value.getAndSet(1));
1: 		
1: 		ctx.finish();
1: 		
1: 		assertEquals(5, value.get());
1: 	}
1: 
1: 	@Test
1: 	public void testPostCompletionFail() throws Exception {
1: 		
1: 		AtomicInteger value = new AtomicInteger(0);
1: 		
1: 		ctx.postCompletion(status -> {
1: 			assertEquals(ROLLED_BACK, status);
1: 			value.compareAndSet(1, 5);
1: 		});
1: 		
1: 		assertEquals(0, value.getAndSet(1));
1: 		
0: 		ArgumentCaptor<Participant> captor = ArgumentCaptor.forClass(Participant.class);
0: 		Mockito.verify(coordination).addParticipant(captor.capture());
1: 		
0: 		captor.getValue().failed(coordination);
1: 		
1: 		ctx.finish();
1: 		
1: 		assertEquals(5, value.get());
1: 	}
1: 
1: 	@Test
1: 	public void testPostCompletionIsAfterPreCompletion() throws Exception {
1: 		
1: 		AtomicInteger value = new AtomicInteger(0);
1: 		
1: 		ctx.preCompletion(() -> {
1: 			assertEquals(ACTIVE, ctx.getTransactionStatus());
1: 			value.compareAndSet(0, 3);
1: 		});
1: 		ctx.postCompletion(status -> {
1: 			assertEquals(COMMITTED, status);
1: 			value.compareAndSet(3, 5);
1: 		});
1: 		
1: 		ctx.finish();
1: 		
1: 		assertEquals(5, value.get());
1: 	}
1: 
1: 	@Test
1: 	public void testPostCompletionIsStillCalledAfterPreCompletionException() throws Exception {
1: 		
1: 		AtomicInteger value = new AtomicInteger(0);
1: 		
1: 		ctx.preCompletion(() -> {
1: 				value.compareAndSet(0, 3);
1: 				throw new RuntimeException("Boom!");
1: 			});
1: 		ctx.postCompletion(status -> {
1: 			assertEquals(ROLLED_BACK, status);
1: 			value.compareAndSet(3, 5);
1: 		});
1: 		
1: 		ctx.finish();
1: 		
1: 		assertEquals(5, value.get());
1: 	}
1: 
0: 	private Participant getParticipant() {
0: 		ArgumentCaptor<Participant> captor = ArgumentCaptor.forClass(Participant.class);
0: 		Mockito.verify(coordination).addParticipant(captor.capture());
1: 		
0: 		Participant participant = captor.getValue();
0: 		return participant;
1: 	}
1: 	
1: 	@Test(expected=IllegalStateException.class)
1: 	public void testPreCompletionAfterEnd() throws Exception {
1: 		
1: 		ctx.finish();
1: 		
1: 		ctx.preCompletion(() -> {});
1: 	}
1: 
1: 	@Test(expected=IllegalStateException.class)
0: 	public void testPreCompletionAfterFail() throws Exception {
1: 		
0: 		getParticipant().failed(coordination);
1: 		
1: 		ctx.finish();
1: 		
1: 		ctx.preCompletion(() -> {});
1: 	}
1: 
1: 	@Test(expected=IllegalStateException.class)
1: 	public void testPostCompletionAfterEnd() throws Exception {
1: 		
1: 		ctx.finish();
1: 		
1: 		ctx.postCompletion(x -> {});
1: 	}
1: 
1: 	@Test(expected=IllegalStateException.class)
0: 	public void testPostCompletionAfterFail() throws Exception {
1: 		
0: 		getParticipant().failed(coordination);
1: 		
1: 		ctx.finish();
1: 		
1: 		ctx.postCompletion(x -> {});
1: 	}
1: 
1: 	@Test
1: 	public void testLocalResource() throws Exception {
1: 		ctx.registerLocalResource(localResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(localResource).commit();
1: 		
1: 		ctx.finish();
1: 		
1: 		Mockito.verify(localResource).commit();
1: 	}
1: 	
1: 	@Test
0: 	public void testLocalResourceEarlyEnd() throws Exception {
1: 		ctx.registerLocalResource(localResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(localResource).rollback();
1: 		
0: 		getParticipant().ended(coordination);
1: 		
1: 		ctx.finish();
1: 		
1: 		Mockito.verify(localResource).rollback();
1: 	}
1: 
1: 	@Test
1: 	public void testLocalResourceRollbackOnly() throws Exception {
1: 		ctx.registerLocalResource(localResource);
1: 		ctx.setRollbackOnly();
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(localResource).rollback();
1: 		
1: 		ctx.finish();
1: 		
1: 		Mockito.verify(localResource).rollback();
1: 	}
1: 
1: 	@Test
0: 	public void testLocalResourceFail() throws Exception {
1: 		ctx.registerLocalResource(localResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(localResource).rollback();
1: 		
0: 		getParticipant().failed(coordination);
1: 		
1: 		ctx.finish();
1: 		
1: 		Mockito.verify(localResource).rollback();
1: 	}
1: 	
1: 	@Test
1: 	public void testLocalResourcePreCommitException() throws Exception {
1: 		ctx.registerLocalResource(localResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(localResource).rollback();
1: 		
1: 		ctx.preCompletion(() -> { throw new IllegalArgumentException(); });
1: 		
1: 		ctx.finish();
1: 		
1: 		Mockito.verify(localResource).rollback();
1: 	}
1: 
1: 	@Test
1: 	public void testLocalResourcePostCommitException() throws Exception {
1: 		ctx.registerLocalResource(localResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(localResource).commit();
1: 		
1: 		ctx.postCompletion(i -> { 
1: 				assertEquals(COMMITTED, ctx.getTransactionStatus());
1: 				throw new IllegalArgumentException(); 
1: 			});
1: 		
1: 		ctx.finish();
1: 		
1: 		Mockito.verify(localResource).commit();
1: 	}
1: 
1: 	@Test
0: 	public void testLocalResourcesFirstFailsSoRollback() throws Exception {
1: 		
1: 		ctx.registerLocalResource(localResource);
1: 
1: 		LocalResource localResource2 = Mockito.mock(LocalResource.class);
1: 		ctx.registerLocalResource(localResource2);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1: 			throw new TransactionException("Unable to commit");
1: 		}).when(localResource).commit();
1: 
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(localResource2).rollback();
1: 		
1: 		ctx.finish();
1: 		
1: 		Mockito.verify(localResource).commit();
1: 		Mockito.verify(localResource2).rollback();
1: 	}
1: 	
1: 	@Test
1: 	public void testSingleXAResource() throws Exception {
0: 		ctx.registerXAResource(xaResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(xaResource).commit(Mockito.any(Xid.class), Mockito.eq(true));
1: 		
1: 		ctx.finish();
1: 		
1: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1: 		
1: 		InOrder inOrder = Mockito.inOrder(xaResource);
1: 		
1: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMSUCCESS));
1: 		inOrder.verify(xaResource).commit(Mockito.eq(captor.getValue()), Mockito.eq(true));
1: 		
1: 		Mockito.verifyNoMoreInteractions(xaResource);
1: 	}
1: 	
1: 	@Test
0: 	public void testXAResourceEarlyEnd() throws Exception {
0: 		ctx.registerXAResource(xaResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(xaResource).rollback(Mockito.any(Xid.class));
1: 		
0: 		getParticipant().ended(coordination);
1: 		
1: 		ctx.finish();
1: 		
1: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1: 		
1: 		InOrder inOrder = Mockito.inOrder(xaResource);
1: 		
1: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMFAIL));
1: 		inOrder.verify(xaResource).rollback(Mockito.eq(captor.getValue()));
1: 		
1: 		Mockito.verifyNoMoreInteractions(xaResource);
1: 	}
1: 
1: 	@Test
1: 	public void testXAResourceRollbackOnly() throws Exception {
0: 		ctx.registerXAResource(xaResource);
1: 		ctx.setRollbackOnly();
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(xaResource).rollback(Mockito.any(Xid.class));
1: 		
1: 		ctx.finish();
1: 		
1: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1: 		
1: 		InOrder inOrder = Mockito.inOrder(xaResource);
1: 		
1: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMFAIL));
1: 		inOrder.verify(xaResource).rollback(Mockito.eq(captor.getValue()));
1: 		
1: 		Mockito.verifyNoMoreInteractions(xaResource);
1: 	}
1: 
1: 	@Test
0: 	public void testXAResourceFail() throws Exception {
0: 		ctx.registerXAResource(xaResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(xaResource).rollback(Mockito.any(Xid.class));
1: 		
0: 		getParticipant().failed(coordination);
1: 		
1: 		ctx.finish();
1: 		
1: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1: 		
1: 		InOrder inOrder = Mockito.inOrder(xaResource);
1: 		
1: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMFAIL));
1: 		inOrder.verify(xaResource).rollback(Mockito.eq(captor.getValue()));
1: 		
1: 		Mockito.verifyNoMoreInteractions(xaResource);
1: 	}
1: 	
1: 	@Test
1: 	public void testXAResourcePreCommitException() throws Exception {
0: 		ctx.registerXAResource(xaResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(xaResource).rollback(Mockito.any(Xid.class));
1: 		
1: 		ctx.preCompletion(() -> { throw new IllegalArgumentException(); });
1: 		
1: 		ctx.finish();
1: 		
1: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1: 		
1: 		InOrder inOrder = Mockito.inOrder(xaResource);
1: 		
1: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMFAIL));
1: 		inOrder.verify(xaResource).rollback(Mockito.eq(captor.getValue()));
1: 		
1: 		Mockito.verifyNoMoreInteractions(xaResource);
1: 	}
1: 
1: 	@Test
1: 	public void testXAResourcePostCommitException() throws Exception {
0: 		ctx.registerXAResource(xaResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(xaResource).commit(Mockito.any(Xid.class), Mockito.eq(true));
1: 		
1: 		ctx.postCompletion(i -> { 
1: 			assertEquals(COMMITTED, ctx.getTransactionStatus());
1: 			throw new IllegalArgumentException(); 
1: 		});
1: 		
1: 		ctx.finish();
1: 		
1: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1: 		
1: 		InOrder inOrder = Mockito.inOrder(xaResource);
1: 		
1: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMSUCCESS));
1: 		inOrder.verify(xaResource).commit(Mockito.eq(captor.getValue()), Mockito.eq(true));
1: 		
1: 		Mockito.verifyNoMoreInteractions(xaResource);
1: 	}
1: 
1: 	@Test
1: 	public void testLastParticipantSuccessSoCommit() throws Exception {
1: 		
1: 		ctx.registerLocalResource(localResource);
0: 		ctx.registerXAResource(xaResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(localResource).commit();
1: 
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(xaResource).commit(Mockito.any(Xid.class), Mockito.eq(false));
1: 		
1: 		ctx.finish();
1: 		
1: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1: 		
1: 		InOrder inOrder = Mockito.inOrder(xaResource, localResource);
1: 		
1: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMSUCCESS));
1: 		inOrder.verify(xaResource).prepare(captor.getValue());
1: 		inOrder.verify(localResource).commit();
1: 		inOrder.verify(xaResource).commit(Mockito.eq(captor.getValue()), Mockito.eq(false));
1: 		
1: 		Mockito.verifyNoMoreInteractions(xaResource, localResource);
1: 	}
1: 
1: 	@Test
1: 	public void testLastParticipantFailsSoRollback() throws Exception {
1: 		
1: 		ctx.registerLocalResource(localResource);
0: 		ctx.registerXAResource(xaResource);
1: 		
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(COMMITTING, ctx.getTransactionStatus());
1: 			throw new TransactionException("Unable to commit");
1: 		}).when(localResource).commit();
1: 
1: 		Mockito.doAnswer(i -> {
1: 			assertEquals(ROLLING_BACK, ctx.getTransactionStatus());
1: 			return null;
1: 		}).when(xaResource).rollback(Mockito.any(Xid.class));
1: 		
1: 		ctx.finish();
1: 		
1: 		ArgumentCaptor<Xid> captor = ArgumentCaptor.forClass(Xid.class);
1: 		
1: 		InOrder inOrder = Mockito.inOrder(xaResource, localResource);
1: 		
1: 		inOrder.verify(xaResource).start(captor.capture(), Mockito.eq(XAResource.TMNOFLAGS));
1: 		inOrder.verify(xaResource).setTransactionTimeout(Mockito.anyInt());
1: 		inOrder.verify(xaResource).end(Mockito.eq(captor.getValue()), Mockito.eq(XAResource.TMSUCCESS));
1: 		inOrder.verify(xaResource).prepare(captor.getValue());
1: 		inOrder.verify(localResource).commit();
1: 		inOrder.verify(xaResource).rollback(Mockito.eq(captor.getValue()));
1: 		
1: 		Mockito.verifyNoMoreInteractions(xaResource, localResource);
1: 	}
1: 	
1: }
============================================================================