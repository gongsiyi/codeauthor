1:fdf3952: /**
1:fdf3952:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:fdf3952:  *  contributor license agreements.  See the NOTICE file distributed with
1:fdf3952:  *  this work for additional information regarding copyright ownership.
1:fdf3952:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:fdf3952:  *  (the "License"); you may not use this file except in compliance with
1:fdf3952:  *  the License.  You may obtain a copy of the License at
1:fdf3952:  *
1:fdf3952:  *     http://www.apache.org/licenses/LICENSE-2.0
1:fdf3952:  *
1:fdf3952:  *  Unless required by applicable law or agreed to in writing, software
1:fdf3952:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:fdf3952:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fdf3952:  *  See the License for the specific language governing permissions and
1:fdf3952:  *  limitations under the License.
1:fdf3952:  */
1:fdf3952: package org.apache.aries.jmx.framework;
1:c13e6cc: 
1:c13e6cc: import static org.junit.Assert.assertEquals;
1:fdf3952: import static org.junit.Assert.assertNotNull;
1:fdf3952: import static org.junit.Assert.assertNull;
1:fdf3952: import static org.junit.Assert.assertTrue;
1:fdf3952: import static org.junit.Assert.fail;
1:c13e6cc: import static org.ops4j.pax.exam.CoreOptions.provision;
1:0a8778f: import static org.ops4j.pax.tinybundles.core.TinyBundles.bundle;
1:0a8778f: import static org.ops4j.pax.tinybundles.core.TinyBundles.withBnd;
1:bf5a863: 
1:c13e6cc: import java.io.ByteArrayInputStream;
1:c13e6cc: import java.io.ByteArrayOutputStream;
1:fdf3952: import java.io.File;
1:fdf3952: import java.io.FileOutputStream;
1:fdf3952: import java.io.IOException;
1:c13e6cc: import java.io.InputStream;
1:c13e6cc: import java.util.ArrayList;
1:c13e6cc: import java.util.Arrays;
1:f94132d: import java.util.Collection;
1:f94132d: import java.util.Collections;
1:7f6c067: import java.util.HashSet;
1:7186eab: import java.util.Hashtable;
1:c13e6cc: import java.util.List;
1:c13e6cc: import java.util.Map;
1:f94132d: import java.util.Set;
1:f94132d: import java.util.TreeSet;
1:c13e6cc: import java.util.jar.JarEntry;
1:fdf3952: import java.util.jar.JarOutputStream;
1:fdf3952: import java.util.jar.Manifest;
1:bf5a863: 
1:fdf3952: import javax.management.ObjectName;
1:fdf3952: import javax.management.openmbean.CompositeData;
14:fdf3952: 
1:fdf3952: import org.apache.aries.jmx.AbstractIntegrationTest;
1:fdf3952: import org.apache.aries.jmx.codec.BatchActionResult;
1:0a8778f: import org.junit.Before;
1:fdf3952: import org.junit.Test;
1:0a8778f: import org.ops4j.pax.exam.Configuration;
1:fdf3952: import org.ops4j.pax.exam.CoreOptions;
1:fdf3952: import org.ops4j.pax.exam.Option;
1:0a8778f: import org.ops4j.pax.exam.spi.reactors.ExamReactorStrategy;
1:0a8778f: import org.ops4j.pax.exam.spi.reactors.PerMethod;
1:c13e6cc: import org.osgi.framework.Bundle;
1:0a8778f: import org.osgi.framework.BundleException;
1:c13e6cc: import org.osgi.framework.Constants;
1:c13e6cc: import org.osgi.framework.Version;
1:c13e6cc: import org.osgi.framework.wiring.BundleRevision;
1:c13e6cc: import org.osgi.framework.wiring.BundleRevisions;
1:c13e6cc: import org.osgi.framework.wiring.BundleWire;
1:c13e6cc: import org.osgi.framework.wiring.BundleWiring;
1:f94132d: import org.osgi.framework.wiring.FrameworkWiring;
1:fdf3952: import org.osgi.jmx.framework.FrameworkMBean;
1:fdf3952: 
1:fdf3952: /**
1:fdf3952:  * @version $Rev$ $Date$
1:fdf3952:  */
1:0a8778f: @ExamReactorStrategy(PerMethod.class)
1:bf5a863: public class FrameworkMBeanTest extends AbstractIntegrationTest {
1:fdf3952: 
1:0a8778f:     private FrameworkMBean framework;
1:0a8778f: 
1:0a8778f: 	@Configuration
1:0a8778f:     public Option[] configuration() {
1:0a8778f:         return CoreOptions.options(
1:f94132d:             // new VMOption( "-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000" ),
1:f94132d:             // new TimeoutOption( 0 ),
1:c13e6cc: 
1:0a8778f:             jmxRuntime(),
1:0a8778f:             bundlea1(),
1:0a8778f:             bundleb1()
1:fdf3952:         );
1:fdf3952:     }
1:0a8778f:     
1:0a8778f: 	protected Option bundlea1() {
1:0a8778f: 		return provision(bundle()
1:0a8778f: 		        .add(org.apache.aries.jmx.test.bundlea.api.InterfaceA.class)
1:0a8778f: 		        .add(org.apache.aries.jmx.test.bundlea.impl.A2.class)
1:0a8778f: 		        .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea")
1:0a8778f: 		        .set(Constants.BUNDLE_VERSION, "1")
1:0a8778f: 		        .set(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api")
1:0a8778f: 		        .build(withBnd()));
1:0a8778f: 	}
1:0a8778f: 	
1:0a8778f: 	protected Option bundleb1() {
1:0a8778f: 		return provision(bundle()
1:0a8778f: 		        .add(org.apache.aries.jmx.test.bundleb.api.InterfaceB.class)
1:0a8778f: 		        .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundleb")
1:0a8778f: 		        .set(Constants.IMPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api," +
1:0a8778f: 		                "org.apache.aries.jmx.test.bundlea.impl;resolution:=optional")
1:0a8778f: 		        .build(withBnd()));
1:0a8778f: 	}
1:21be559: 
1:0a8778f:     @Before
1:0a8778f:     public void doSetUp() throws BundleException {
1:0a8778f:     	for (Bundle bundle : context().getBundles()) {
1:0a8778f: 			System.out.println(bundle.getBundleId() + " " + bundle.getSymbolicName() + " " + bundle.getState());
1:0a8778f: 		};
1:0a8778f:         waitForMBean(FrameworkMBean.OBJECTNAME);
1:0a8778f:         framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
1:fdf3952:     }
1:f94132d: 
1:21be559:     @Test
1:7186eab:     public void testObjectName() throws Exception {
1:7186eab:         Set<ObjectName> names = mbeanServer.queryNames(new ObjectName(FrameworkMBean.OBJECTNAME + ",*"), null);
1:7186eab:         assertEquals(1, names.size());
1:7186eab:         ObjectName name = names.iterator().next();
1:7186eab:         Hashtable<String, String> props = name.getKeyPropertyList();
1:7186eab:         assertEquals(context().getProperty(Constants.FRAMEWORK_UUID), props.get("uuid"));
1:7186eab:         assertEquals(context().getBundle(0).getSymbolicName(), props.get("framework"));
1:7186eab:     }
1:7186eab: 
1:7186eab:     @Test
1:21be559:     public void testGetProperty() throws Exception {
1:21be559:         String expectedVer = context().getProperty(Constants.FRAMEWORK_VERSION);
1:21be559:         String actualVer = framework.getProperty(Constants.FRAMEWORK_VERSION);
1:21be559:         assertEquals(expectedVer, actualVer);
1:21be559: 
1:21be559:         String expectedTmp = context().getProperty("java.io.tmpdir");
1:21be559:         String actualTmp = framework.getProperty("java.io.tmpdir");
1:21be559:         assertEquals(expectedTmp, actualTmp);
1:21be559:     }
1:af3b4b3: 
1:f94132d:     @Test
1:f94132d:     public void testGetDependencyClosure() throws Exception {
1:0a8778f:         Bundle bundleA = getBundleByName("org.apache.aries.jmx.test.bundlea");
1:0a8778f:         Bundle bundleB = getBundleByName("org.apache.aries.jmx.test.bundleb");
1:f94132d: 
1:988cc71:         BundleWiring bw = (BundleWiring) bundleB.adapt(BundleWiring.class);
1:f94132d: 
1:f94132d:         List<BundleWire> initialRequiredWires = bw.getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:f94132d:         assertEquals(1, initialRequiredWires.size());
1:f94132d:         BundleWire wire = initialRequiredWires.get(0);
1:f94132d:         Map<String, Object> capabilityAttributes = wire.getCapability().getAttributes();
1:f94132d:         assertEquals("Precondition", bundleA.getSymbolicName(), capabilityAttributes.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:f94132d:         assertEquals("Precondition", new Version("1.0"), capabilityAttributes.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:f94132d:         assertEquals("Precondition", "org.apache.aries.jmx.test.bundlea.api", capabilityAttributes.get(BundleRevision.PACKAGE_NAMESPACE));
1:f94132d: 
1:988cc71:         Collection<Bundle> expectedDC = ((FrameworkWiring) context().getBundle(0).adapt(FrameworkWiring.class)).getDependencyClosure(Collections.singleton(bundleA));
1:f94132d:         Set<Long> expectedClosure = new TreeSet<Long>();
1:f94132d:         for (Bundle b : expectedDC) {
1:f94132d:             expectedClosure.add(b.getBundleId());
1:f94132d:         }
1:f94132d: 
1:f94132d:         long[] actualDC = framework.getDependencyClosure(new long [] {bundleA.getBundleId()});
1:f94132d:         Set<Long> actualClosure = new TreeSet<Long>();
1:f94132d:         for (long l : actualDC) {
1:f94132d:             actualClosure.add(l);
1:f94132d:         }
1:f94132d: 
1:f94132d:         assertEquals(expectedClosure, actualClosure);
1:f94132d:     }
1:f94132d: 
1:af3b4b3:     @Test
1:af3b4b3:     public void testRefreshBundleAndWait() throws Exception {
1:988cc71:         FrameworkWiring frameworkWiring = (FrameworkWiring) context().getBundle(0).adapt(FrameworkWiring.class);
1:af3b4b3: 
1:0a8778f:         Bundle bundleA = getBundleByName("org.apache.aries.jmx.test.bundlea");
1:0a8778f:         Bundle bundleB = getBundleByName("org.apache.aries.jmx.test.bundleb");
1:c13e6cc: 
1:988cc71:         BundleWiring bw = (BundleWiring) bundleB.adapt(BundleWiring.class);
1:c13e6cc: 
1:af3b4b3:         List<BundleWire> initialRequiredWires = bw.getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:af3b4b3:         assertEquals(1, initialRequiredWires.size());
1:af3b4b3:         BundleWire wire = initialRequiredWires.get(0);
1:af3b4b3:         Map<String, Object> capabilityAttributes = wire.getCapability().getAttributes();
1:af3b4b3:         assertEquals("Precondition", bundleA.getSymbolicName(), capabilityAttributes.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:af3b4b3:         assertEquals("Precondition", new Version("1.0"), capabilityAttributes.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:af3b4b3:         assertEquals("Precondition", "org.apache.aries.jmx.test.bundlea.api", capabilityAttributes.get(BundleRevision.PACKAGE_NAMESPACE));
1:c13e6cc: 
1:af3b4b3:         // Create an updated version of Bundle A, which an extra export and version 1.1
1:af3b4b3:         Manifest manifest = new Manifest();
1:af3b4b3:         manifest.getMainAttributes().putValue("Manifest-Version", "1.0");
1:af3b4b3:         manifest.getMainAttributes().putValue(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea");
1:af3b4b3:         manifest.getMainAttributes().putValue(Constants.BUNDLE_VERSION, "1.1");
1:af3b4b3:         manifest.getMainAttributes().putValue(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api,org.apache.aries.jmx.test.bundlea.impl");
1:af3b4b3: 
1:af3b4b3:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:af3b4b3:         JarOutputStream jos = new JarOutputStream(baos, manifest);
1:af3b4b3:         addResourceToJar("org/apache/aries/jmx/test/bundlea/api/InterfaceA.class", jos, bundleA);
1:af3b4b3:         addResourceToJar("org/apache/aries/jmx/test/bundlea/impl/A2.class", jos, bundleA);
1:af3b4b3:         jos.close();
1:af3b4b3: 
1:f94132d:         assertEquals("Precondition", 0, frameworkWiring.getRemovalPendingBundles().size());
1:f94132d:         assertEquals(0, framework.getRemovalPendingBundles().length);
1:f94132d: 
1:988cc71:         assertEquals("Precondition", 1, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:af3b4b3:         bundleA.update(new ByteArrayInputStream(baos.toByteArray()));
1:988cc71:         assertEquals("There should be 2 revisions now", 2, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:af3b4b3:         assertEquals("No refresh called, the bundle wiring for B should still be the old one",
1:af3b4b3:                 bw, bundleB.adapt(BundleWiring.class));
1:af3b4b3: 
1:f94132d:         assertEquals("Precondition", 1, frameworkWiring.getRemovalPendingBundles().size());
1:f94132d:         assertEquals(1, framework.getRemovalPendingBundles().length);
1:988cc71:         assertEquals(((Bundle) frameworkWiring.getRemovalPendingBundles().iterator().next()).getBundleId(),
1:f94132d:                 framework.getRemovalPendingBundles()[0]);
1:f94132d: 
1:c13e6cc:         assertTrue(framework.refreshBundleAndWait(bundleB.getBundleId()));
1:c13e6cc: 
1:988cc71:         List<BundleWire> requiredWires = ((BundleWiring) bundleB.adapt(BundleWiring.class)).getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:c13e6cc:         assertEquals(2, requiredWires.size());
1:c13e6cc:         List<String> imported = new ArrayList<String>();
1:c13e6cc:         for (BundleWire w : requiredWires) {
1:c13e6cc:             Map<String, Object> ca = w.getCapability().getAttributes();
1:c13e6cc:             assertEquals(bundleA.getSymbolicName(), ca.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:c13e6cc:             imported.add(ca.get(BundleRevision.PACKAGE_NAMESPACE).toString());
1:c13e6cc: 
1:c13e6cc:             if ("org.apache.aries.jmx.test.bundlea.impl".equals(ca.get(BundleRevision.PACKAGE_NAMESPACE))) {
1:c13e6cc:                 // Came across an issue where equinox was reporting the other package as still coming from from the 1.0 bundle
1:c13e6cc:                 // not sure if this is a bug or not...
1:c13e6cc:                 assertEquals(new Version("1.1"), ca.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:c13e6cc:             }
1:c13e6cc:         }
1:c13e6cc:         assertEquals(Arrays.asList("org.apache.aries.jmx.test.bundlea.api", "org.apache.aries.jmx.test.bundlea.impl"), imported);
1:c13e6cc:     }
1:7f6c067: 
1:7f6c067:     @Test
1:af3b4b3:     public void testRefreshBundlesAndWait() throws Exception {
1:0a8778f:         Bundle bundleA = getBundleByName("org.apache.aries.jmx.test.bundlea");
1:0a8778f:         Bundle bundleB = getBundleByName("org.apache.aries.jmx.test.bundleb");
1:7f6c067: 
1:988cc71:         BundleWiring bw = (BundleWiring) bundleB.adapt(BundleWiring.class);
1:7f6c067: 
1:7f6c067:         List<BundleWire> initialRequiredWires = bw.getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:7f6c067:         assertEquals(1, initialRequiredWires.size());
1:7f6c067:         BundleWire wire = initialRequiredWires.get(0);
1:7f6c067:         Map<String, Object> capabilityAttributes = wire.getCapability().getAttributes();
1:7f6c067:         assertEquals("Precondition", bundleA.getSymbolicName(), capabilityAttributes.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:7f6c067:         assertEquals("Precondition", new Version("1.0"), capabilityAttributes.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:7f6c067:         assertEquals("Precondition", "org.apache.aries.jmx.test.bundlea.api", capabilityAttributes.get(BundleRevision.PACKAGE_NAMESPACE));
1:7f6c067: 
1:7f6c067:         // Create an updated version of Bundle A, which an extra export and version 1.1
1:7f6c067:         Manifest manifest = new Manifest();
1:7f6c067:         manifest.getMainAttributes().putValue("Manifest-Version", "1.0");
1:7f6c067:         manifest.getMainAttributes().putValue(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea");
1:7f6c067:         manifest.getMainAttributes().putValue(Constants.BUNDLE_VERSION, "1.1");
1:7f6c067:         manifest.getMainAttributes().putValue(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api,org.apache.aries.jmx.test.bundlea.impl");
1:7f6c067: 
1:7f6c067:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:7f6c067:         JarOutputStream jos = new JarOutputStream(baos, manifest);
1:7f6c067:         addResourceToJar("org/apache/aries/jmx/test/bundlea/api/InterfaceA.class", jos, bundleA);
1:7f6c067:         addResourceToJar("org/apache/aries/jmx/test/bundlea/impl/A2.class", jos, bundleA);
1:7f6c067:         jos.close();
1:7f6c067: 
1:988cc71:         assertEquals("Precondition", 1, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:7f6c067:         bundleA.update(new ByteArrayInputStream(baos.toByteArray()));
1:988cc71:         assertEquals("There should be 2 revisions now", 2, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:7f6c067:         assertEquals("No refresh called, the bundle wiring for B should still be the old one",
1:7f6c067:                 bw, bundleB.adapt(BundleWiring.class));
1:af3b4b3: 
1:7f6c067:         FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
1:af3b4b3:         CompositeData result = framework.refreshBundlesAndWait(new long[] {bundleB.getBundleId()});
1:7f6c067:         assertTrue((Boolean) result.get(FrameworkMBean.SUCCESS));
1:af3b4b3:         assertTrue(Arrays.equals(new Long[] {bundleB.getBundleId()}, (Long []) result.get(FrameworkMBean.COMPLETED)));
1:f94132d: 
1:988cc71:         List<BundleWire> requiredWires = ((BundleWiring) bundleB.adapt(BundleWiring.class)).getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:af3b4b3:         assertEquals(2, requiredWires.size());
1:af3b4b3:         List<String> imported = new ArrayList<String>();
1:af3b4b3:         for (BundleWire w : requiredWires) {
1:af3b4b3:             Map<String, Object> ca = w.getCapability().getAttributes();
1:af3b4b3:             assertEquals(bundleA.getSymbolicName(), ca.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:af3b4b3:             imported.add(ca.get(BundleRevision.PACKAGE_NAMESPACE).toString());
1:f94132d: 
1:af3b4b3:             if ("org.apache.aries.jmx.test.bundlea.impl".equals(ca.get(BundleRevision.PACKAGE_NAMESPACE))) {
1:af3b4b3:                 // Came across an issue where equinox was reporting the other package as still coming from from the 1.0 bundle
1:af3b4b3:                 // not sure if this is a bug or not...
1:af3b4b3:                 assertEquals(new Version("1.1"), ca.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:af3b4b3:             }
1:af3b4b3:         }
1:af3b4b3:         assertEquals(Arrays.asList("org.apache.aries.jmx.test.bundlea.api", "org.apache.aries.jmx.test.bundlea.impl"), imported);
1:af3b4b3:     }
1:af3b4b3: 
1:fdf3952:     @Test
1:7f6c067:     public void testRefreshBundlesAndWait2() throws Exception {
1:0a8778f:         Bundle bundleA = getBundleByName("org.apache.aries.jmx.test.bundlea");
1:0a8778f:         Bundle bundleB = getBundleByName("org.apache.aries.jmx.test.bundleb");
1:af3b4b3: 
1:988cc71:         BundleWiring bw = (BundleWiring) bundleB.adapt(BundleWiring.class);
1:af3b4b3: 
1:c13e6cc:         List<BundleWire> initialRequiredWires = bw.getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:c13e6cc:         assertEquals(1, initialRequiredWires.size());
1:c13e6cc:         BundleWire wire = initialRequiredWires.get(0);
1:c13e6cc:         Map<String, Object> capabilityAttributes = wire.getCapability().getAttributes();
1:c13e6cc:         assertEquals("Precondition", bundleA.getSymbolicName(), capabilityAttributes.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:c13e6cc:         assertEquals("Precondition", new Version("1.0"), capabilityAttributes.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:c13e6cc:         assertEquals("Precondition", "org.apache.aries.jmx.test.bundlea.api", capabilityAttributes.get(BundleRevision.PACKAGE_NAMESPACE));
1:c13e6cc: 
1:c13e6cc:         // Create an updated version of Bundle A, which an extra export and version 1.1
1:c13e6cc:         Manifest manifest = new Manifest();
1:c13e6cc:         manifest.getMainAttributes().putValue("Manifest-Version", "1.0");
1:c13e6cc:         manifest.getMainAttributes().putValue(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea");
1:c13e6cc:         manifest.getMainAttributes().putValue(Constants.BUNDLE_VERSION, "1.1");
1:c13e6cc:         manifest.getMainAttributes().putValue(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api,org.apache.aries.jmx.test.bundlea.impl");
1:c13e6cc: 
1:c13e6cc:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:c13e6cc:         JarOutputStream jos = new JarOutputStream(baos, manifest);
1:c13e6cc:         addResourceToJar("org/apache/aries/jmx/test/bundlea/api/InterfaceA.class", jos, bundleA);
1:c13e6cc:         addResourceToJar("org/apache/aries/jmx/test/bundlea/impl/A2.class", jos, bundleA);
1:c13e6cc:         jos.close();
1:c13e6cc: 
1:988cc71:         assertEquals("Precondition", 1, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:c13e6cc:         bundleA.update(new ByteArrayInputStream(baos.toByteArray()));
1:988cc71:         assertEquals("There should be 2 revisions now", 2, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:c13e6cc:         assertEquals("No refresh called, the bundle wiring for B should still be the old one",
1:988cc71:                 bw, ((BundleWiring) bundleB.adapt(BundleWiring.class)));
1:c13e6cc: 
1:21be559:         FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
1:7f6c067:         CompositeData result = framework.refreshBundlesAndWait(null);
1:7f6c067:         Set<Long> completed = new HashSet<Long>(Arrays.asList((Long []) result.get(FrameworkMBean.COMPLETED)));
1:7f6c067:         assertTrue(completed.contains(bundleA.getBundleId()));
1:7f6c067:         assertTrue(completed.contains(bundleB.getBundleId()));
1:7f6c067: 
1:988cc71:         List<BundleWire> requiredWires = ((BundleWiring) bundleB.adapt(BundleWiring.class)).getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:7f6c067:         assertEquals(2, requiredWires.size());
1:7f6c067:         List<String> imported = new ArrayList<String>();
1:7f6c067:         for (BundleWire w : requiredWires) {
1:7f6c067:             Map<String, Object> ca = w.getCapability().getAttributes();
1:7f6c067:             assertEquals(bundleA.getSymbolicName(), ca.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:7f6c067:             imported.add(ca.get(BundleRevision.PACKAGE_NAMESPACE).toString());
1:7f6c067: 
1:7f6c067:             if ("org.apache.aries.jmx.test.bundlea.impl".equals(ca.get(BundleRevision.PACKAGE_NAMESPACE))) {
1:7f6c067:                 // Came across an issue where equinox was reporting the other package as still coming from from the 1.0 bundle
1:7f6c067:                 // not sure if this is a bug or not...
1:7f6c067:                 assertEquals(new Version("1.1"), ca.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:7f6c067:             }
1:7f6c067:         }
1:7f6c067:         assertEquals(Arrays.asList("org.apache.aries.jmx.test.bundlea.api", "org.apache.aries.jmx.test.bundlea.impl"), imported);
1:7f6c067:     }
1:7f6c067: 
1:c13e6cc:     private void addResourceToJar(String resourceName, JarOutputStream jos, Bundle bundle) throws IOException {
1:c13e6cc:         InputStream intfIs = bundle.getResource("/" + resourceName).openStream();
1:c13e6cc:         JarEntry entry = new JarEntry(resourceName);
1:c13e6cc:         jos.putNextEntry(entry);
1:c13e6cc:         try {
1:c13e6cc:             Streams.pump(intfIs, jos);
1:c13e6cc:         } finally {
1:c13e6cc:             jos.closeEntry();
1:c13e6cc:         }
1:c13e6cc:     }
1:c13e6cc: 
1:c13e6cc:     @Test
1:fdf3952:     public void testMBeanInterface() throws IOException {
1:fdf3952:         long[] bundleIds = new long[]{1,2};
1:fdf3952:         int[] newlevels = new int[]{1,1};
1:fdf3952:         CompositeData compData = framework.setBundleStartLevels(bundleIds, newlevels);
1:fdf3952:         assertNotNull(compData);
1:bf5a863: 
1:fdf3952:         BatchActionResult batch2 = BatchActionResult.from(compData);
1:fdf3952:         assertNotNull(batch2.getCompleted());
1:fdf3952:         assertTrue(batch2.isSuccess());
1:fdf3952:         assertNull(batch2.getError());
1:fdf3952:         assertNull(batch2.getRemainingItems());
1:bf5a863: 
1:fdf3952:         File file = File.createTempFile("bundletest", ".jar");
1:bf5a863:         file.deleteOnExit();
1:fdf3952:         Manifest man = new Manifest();
1:fdf3952:         man.getMainAttributes().putValue("Manifest-Version", "1.0");
1:fdf3952:         JarOutputStream jaros = new JarOutputStream(new FileOutputStream(file), man);
1:fdf3952:         jaros.flush();
1:fdf3952:         jaros.close();
1:bf5a863: 
1:fdf3952:         long bundleId = 0;
1:fdf3952:         try {
1:fdf3952:             bundleId = framework.installBundleFromURL(file.getAbsolutePath(), file.toURI().toString());
1:fdf3952:         } catch (Exception e) {
1:fdf3952:             fail("Installation of test bundle shouldn't fail");
1:fdf3952:         }
1:bf5a863: 
1:fdf3952:         try{
1:fdf3952:             framework.uninstallBundle(bundleId);
1:fdf3952:         } catch (Exception e) {
1:fdf3952:             fail("Uninstallation of test bundle shouldn't fail");
1:fdf3952:         }
1:fdf3952:     }
1:fdf3952: }
============================================================================
author:Jean-Baptiste Onofre
-------------------------------------------------------------------------------
commit:988cc71
/////////////////////////////////////////////////////////////////////////
1:         BundleWiring bw = (BundleWiring) bundleB.adapt(BundleWiring.class);
/////////////////////////////////////////////////////////////////////////
1:         Collection<Bundle> expectedDC = ((FrameworkWiring) context().getBundle(0).adapt(FrameworkWiring.class)).getDependencyClosure(Collections.singleton(bundleA));
/////////////////////////////////////////////////////////////////////////
1:         FrameworkWiring frameworkWiring = (FrameworkWiring) context().getBundle(0).adapt(FrameworkWiring.class);
1:         BundleWiring bw = (BundleWiring) bundleB.adapt(BundleWiring.class);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Precondition", 1, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:         assertEquals("There should be 2 revisions now", 2, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:         assertEquals(((Bundle) frameworkWiring.getRemovalPendingBundles().iterator().next()).getBundleId(),
1:         List<BundleWire> requiredWires = ((BundleWiring) bundleB.adapt(BundleWiring.class)).getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
/////////////////////////////////////////////////////////////////////////
1:         BundleWiring bw = (BundleWiring) bundleB.adapt(BundleWiring.class);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Precondition", 1, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:         assertEquals("There should be 2 revisions now", 2, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
/////////////////////////////////////////////////////////////////////////
1:         List<BundleWire> requiredWires = ((BundleWiring) bundleB.adapt(BundleWiring.class)).getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
/////////////////////////////////////////////////////////////////////////
1:         BundleWiring bw = (BundleWiring) bundleB.adapt(BundleWiring.class);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Precondition", 1, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:         assertEquals("There should be 2 revisions now", 2, ((BundleRevisions) bundleA.adapt(BundleRevisions.class)).getRevisions().size());
1:                 bw, ((BundleWiring) bundleB.adapt(BundleWiring.class)));
/////////////////////////////////////////////////////////////////////////
1:         List<BundleWire> requiredWires = ((BundleWiring) bundleB.adapt(BundleWiring.class)).getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
author:Christian Schneider
-------------------------------------------------------------------------------
commit:0a8778f
/////////////////////////////////////////////////////////////////////////
1: import static org.ops4j.pax.tinybundles.core.TinyBundles.bundle;
1: import static org.ops4j.pax.tinybundles.core.TinyBundles.withBnd;
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Before;
1: import org.ops4j.pax.exam.Configuration;
1: import org.ops4j.pax.exam.spi.reactors.ExamReactorStrategy;
1: import org.ops4j.pax.exam.spi.reactors.PerMethod;
1: import org.osgi.framework.BundleException;
/////////////////////////////////////////////////////////////////////////
1: @ExamReactorStrategy(PerMethod.class)
1:     private FrameworkMBean framework;
1: 
1: 	@Configuration
1:     public Option[] configuration() {
1:         return CoreOptions.options(
1:             jmxRuntime(),
1:             bundlea1(),
1:             bundleb1()
1:     
1: 	protected Option bundlea1() {
1: 		return provision(bundle()
1: 		        .add(org.apache.aries.jmx.test.bundlea.api.InterfaceA.class)
1: 		        .add(org.apache.aries.jmx.test.bundlea.impl.A2.class)
1: 		        .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea")
1: 		        .set(Constants.BUNDLE_VERSION, "1")
1: 		        .set(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api")
1: 		        .build(withBnd()));
1: 	}
1: 	
1: 	protected Option bundleb1() {
1: 		return provision(bundle()
1: 		        .add(org.apache.aries.jmx.test.bundleb.api.InterfaceB.class)
1: 		        .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundleb")
1: 		        .set(Constants.IMPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api," +
1: 		                "org.apache.aries.jmx.test.bundlea.impl;resolution:=optional")
1: 		        .build(withBnd()));
1: 	}
1:     @Before
1:     public void doSetUp() throws BundleException {
1:     	for (Bundle bundle : context().getBundles()) {
1: 			System.out.println(bundle.getBundleId() + " " + bundle.getSymbolicName() + " " + bundle.getState());
1: 		};
1:         waitForMBean(FrameworkMBean.OBJECTNAME);
1:         framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Bundle bundleA = getBundleByName("org.apache.aries.jmx.test.bundlea");
1:         Bundle bundleB = getBundleByName("org.apache.aries.jmx.test.bundleb");
/////////////////////////////////////////////////////////////////////////
1:         Bundle bundleA = getBundleByName("org.apache.aries.jmx.test.bundlea");
1:         Bundle bundleB = getBundleByName("org.apache.aries.jmx.test.bundleb");
/////////////////////////////////////////////////////////////////////////
1:         Bundle bundleA = getBundleByName("org.apache.aries.jmx.test.bundlea");
1:         Bundle bundleB = getBundleByName("org.apache.aries.jmx.test.bundleb");
/////////////////////////////////////////////////////////////////////////
1:         Bundle bundleA = getBundleByName("org.apache.aries.jmx.test.bundlea");
1:         Bundle bundleB = getBundleByName("org.apache.aries.jmx.test.bundleb");
/////////////////////////////////////////////////////////////////////////
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:0273964
commit:bf86346
/////////////////////////////////////////////////////////////////////////
0:             CoreOptions.equinox().version("3.8.0.V20120529-1548"),
commit:af218d3
/////////////////////////////////////////////////////////////////////////
commit:7f6c067
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testRefreshBundlesAndWait2() throws Exception {
0:         Bundle bundleA = context().getBundleByName("org.apache.aries.jmx.test.bundlea");
0:         Bundle bundleB = context().getBundleByName("org.apache.aries.jmx.test.bundleb");
1: 
0:         BundleWiring bw = bundleB.adapt(BundleWiring.class);
1: 
1:         List<BundleWire> initialRequiredWires = bw.getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:         assertEquals(1, initialRequiredWires.size());
1:         BundleWire wire = initialRequiredWires.get(0);
1:         Map<String, Object> capabilityAttributes = wire.getCapability().getAttributes();
1:         assertEquals("Precondition", bundleA.getSymbolicName(), capabilityAttributes.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:         assertEquals("Precondition", new Version("1.0"), capabilityAttributes.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:         assertEquals("Precondition", "org.apache.aries.jmx.test.bundlea.api", capabilityAttributes.get(BundleRevision.PACKAGE_NAMESPACE));
1: 
1:         // Create an updated version of Bundle A, which an extra export and version 1.1
1:         Manifest manifest = new Manifest();
1:         manifest.getMainAttributes().putValue("Manifest-Version", "1.0");
1:         manifest.getMainAttributes().putValue(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea");
1:         manifest.getMainAttributes().putValue(Constants.BUNDLE_VERSION, "1.1");
1:         manifest.getMainAttributes().putValue(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api,org.apache.aries.jmx.test.bundlea.impl");
1: 
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         JarOutputStream jos = new JarOutputStream(baos, manifest);
1:         addResourceToJar("org/apache/aries/jmx/test/bundlea/api/InterfaceA.class", jos, bundleA);
1:         addResourceToJar("org/apache/aries/jmx/test/bundlea/impl/A2.class", jos, bundleA);
1:         jos.close();
1: 
0:         assertEquals("Precondition", 1, bundleA.adapt(BundleRevisions.class).getRevisions().size());
1:         bundleA.update(new ByteArrayInputStream(baos.toByteArray()));
0:         assertEquals("There should be 2 revisions now", 2, bundleA.adapt(BundleRevisions.class).getRevisions().size());
1:         assertEquals("No refresh called, the bundle wiring for B should still be the old one",
1:                 bw, bundleB.adapt(BundleWiring.class));
1: 
1:         FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
1:         CompositeData result = framework.refreshBundlesAndWait(null);
1:         assertTrue((Boolean) result.get(FrameworkMBean.SUCCESS));
1:         Set<Long> completed = new HashSet<Long>(Arrays.asList((Long []) result.get(FrameworkMBean.COMPLETED)));
1:         assertTrue(completed.contains(bundleA.getBundleId()));
1:         assertTrue(completed.contains(bundleB.getBundleId()));
1: 
0:         List<BundleWire> requiredWires = bundleB.adapt(BundleWiring.class).getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:         assertEquals(2, requiredWires.size());
1:         List<String> imported = new ArrayList<String>();
1:         for (BundleWire w : requiredWires) {
1:             Map<String, Object> ca = w.getCapability().getAttributes();
1:             assertEquals(bundleA.getSymbolicName(), ca.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:             imported.add(ca.get(BundleRevision.PACKAGE_NAMESPACE).toString());
1: 
1:             if ("org.apache.aries.jmx.test.bundlea.impl".equals(ca.get(BundleRevision.PACKAGE_NAMESPACE))) {
1:                 // Came across an issue where equinox was reporting the other package as still coming from from the 1.0 bundle
1:                 // not sure if this is a bug or not...
1:                 assertEquals(new Version("1.1"), ca.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:             }
1:         }
1:         assertEquals(Arrays.asList("org.apache.aries.jmx.test.bundlea.api", "org.apache.aries.jmx.test.bundlea.impl"), imported);
1:     }
1: 
commit:7186eab
/////////////////////////////////////////////////////////////////////////
1: import java.util.Hashtable;
/////////////////////////////////////////////////////////////////////////
1:     public void testObjectName() throws Exception {
1:         Set<ObjectName> names = mbeanServer.queryNames(new ObjectName(FrameworkMBean.OBJECTNAME + ",*"), null);
1:         assertEquals(1, names.size());
1:         ObjectName name = names.iterator().next();
1:         Hashtable<String, String> props = name.getKeyPropertyList();
1:         assertEquals(context().getProperty(Constants.FRAMEWORK_UUID), props.get("uuid"));
1:         assertEquals(context().getBundle(0).getSymbolicName(), props.get("framework"));
1:     }
1: 
1:     @Test
commit:21be559
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testGetProperty() throws Exception {
1:         FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
1: 
1:         String expectedVer = context().getProperty(Constants.FRAMEWORK_VERSION);
1:         String actualVer = framework.getProperty(Constants.FRAMEWORK_VERSION);
1:         assertEquals(expectedVer, actualVer);
1: 
1:         String expectedTmp = context().getProperty("java.io.tmpdir");
1:         String actualTmp = framework.getProperty("java.io.tmpdir");
1:         assertEquals(expectedTmp, actualTmp);
1:     }
commit:f94132d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Set;
1: import java.util.TreeSet;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.FrameworkWiring;
/////////////////////////////////////////////////////////////////////////
1:             // new VMOption( "-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000" ),
1:             // new TimeoutOption( 0 ),
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testGetDependencyClosure() throws Exception {
0:         FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
1: 
0:         Bundle bundleA = context().getBundleByName("org.apache.aries.jmx.test.bundlea");
0:         Bundle bundleB = context().getBundleByName("org.apache.aries.jmx.test.bundleb");
1: 
0:         BundleWiring bw = bundleB.adapt(BundleWiring.class);
1: 
1:         List<BundleWire> initialRequiredWires = bw.getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:         assertEquals(1, initialRequiredWires.size());
1:         BundleWire wire = initialRequiredWires.get(0);
1:         Map<String, Object> capabilityAttributes = wire.getCapability().getAttributes();
1:         assertEquals("Precondition", bundleA.getSymbolicName(), capabilityAttributes.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:         assertEquals("Precondition", new Version("1.0"), capabilityAttributes.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:         assertEquals("Precondition", "org.apache.aries.jmx.test.bundlea.api", capabilityAttributes.get(BundleRevision.PACKAGE_NAMESPACE));
1: 
0:         Collection<Bundle> expectedDC = context().getBundle(0).adapt(FrameworkWiring.class).getDependencyClosure(Collections.singleton(bundleA));
1:         Set<Long> expectedClosure = new TreeSet<Long>();
1:         for (Bundle b : expectedDC) {
1:             expectedClosure.add(b.getBundleId());
1:         }
1: 
1:         long[] actualDC = framework.getDependencyClosure(new long [] {bundleA.getBundleId()});
1:         Set<Long> actualClosure = new TreeSet<Long>();
1:         for (long l : actualDC) {
1:             actualClosure.add(l);
1:         }
1: 
1:         assertEquals(expectedClosure, actualClosure);
1:     }
1: 
0:         FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
0:         FrameworkWiring frameworkWiring = context().getBundle(0).adapt(FrameworkWiring.class);
1: 
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Precondition", 0, frameworkWiring.getRemovalPendingBundles().size());
1:         assertEquals(0, framework.getRemovalPendingBundles().length);
1: 
1:         assertEquals("Precondition", 1, frameworkWiring.getRemovalPendingBundles().size());
1:         assertEquals(1, framework.getRemovalPendingBundles().length);
0:         assertEquals(frameworkWiring.getRemovalPendingBundles().iterator().next().getBundleId(),
1:                 framework.getRemovalPendingBundles()[0]);
1: 
commit:af3b4b3
/////////////////////////////////////////////////////////////////////////
0:             //  new VMOption( "-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000" ),
0:             //  new TimeoutOption( 0 ),
/////////////////////////////////////////////////////////////////////////
1:     public void testRefreshBundleAndWait() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testRefreshBundlesAndWait() throws Exception {
0:         Bundle bundleA = context().getBundleByName("org.apache.aries.jmx.test.bundlea");
0:         Bundle bundleB = context().getBundleByName("org.apache.aries.jmx.test.bundleb");
1: 
0:         BundleWiring bw = bundleB.adapt(BundleWiring.class);
1: 
1:         List<BundleWire> initialRequiredWires = bw.getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:         assertEquals(1, initialRequiredWires.size());
1:         BundleWire wire = initialRequiredWires.get(0);
1:         Map<String, Object> capabilityAttributes = wire.getCapability().getAttributes();
1:         assertEquals("Precondition", bundleA.getSymbolicName(), capabilityAttributes.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:         assertEquals("Precondition", new Version("1.0"), capabilityAttributes.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:         assertEquals("Precondition", "org.apache.aries.jmx.test.bundlea.api", capabilityAttributes.get(BundleRevision.PACKAGE_NAMESPACE));
1: 
1:         // Create an updated version of Bundle A, which an extra export and version 1.1
1:         Manifest manifest = new Manifest();
1:         manifest.getMainAttributes().putValue("Manifest-Version", "1.0");
1:         manifest.getMainAttributes().putValue(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea");
1:         manifest.getMainAttributes().putValue(Constants.BUNDLE_VERSION, "1.1");
1:         manifest.getMainAttributes().putValue(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api,org.apache.aries.jmx.test.bundlea.impl");
1: 
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         JarOutputStream jos = new JarOutputStream(baos, manifest);
1:         addResourceToJar("org/apache/aries/jmx/test/bundlea/api/InterfaceA.class", jos, bundleA);
1:         addResourceToJar("org/apache/aries/jmx/test/bundlea/impl/A2.class", jos, bundleA);
1:         jos.close();
1: 
0:         assertEquals("Precondition", 1, bundleA.adapt(BundleRevisions.class).getRevisions().size());
1:         bundleA.update(new ByteArrayInputStream(baos.toByteArray()));
0:         assertEquals("There should be 2 revisions now", 2, bundleA.adapt(BundleRevisions.class).getRevisions().size());
1:         assertEquals("No refresh called, the bundle wiring for B should still be the old one",
1:                 bw, bundleB.adapt(BundleWiring.class));
1: 
0:         FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
1:         CompositeData result = framework.refreshBundlesAndWait(new long[] {bundleB.getBundleId()});
0:         assertTrue((Boolean) result.get(FrameworkMBean.SUCCESS));
1:         assertTrue(Arrays.equals(new Long[] {bundleB.getBundleId()}, (Long []) result.get(FrameworkMBean.COMPLETED)));
1: 
0:         List<BundleWire> requiredWires = bundleB.adapt(BundleWiring.class).getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:         assertEquals(2, requiredWires.size());
1:         List<String> imported = new ArrayList<String>();
1:         for (BundleWire w : requiredWires) {
1:             Map<String, Object> ca = w.getCapability().getAttributes();
1:             assertEquals(bundleA.getSymbolicName(), ca.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:             imported.add(ca.get(BundleRevision.PACKAGE_NAMESPACE).toString());
1: 
1:             if ("org.apache.aries.jmx.test.bundlea.impl".equals(ca.get(BundleRevision.PACKAGE_NAMESPACE))) {
1:                 // Came across an issue where equinox was reporting the other package as still coming from from the 1.0 bundle
1:                 // not sure if this is a bug or not...
1:                 assertEquals(new Version("1.1"), ca.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:             }
1:         }
1:         assertEquals(Arrays.asList("org.apache.aries.jmx.test.bundlea.api", "org.apache.aries.jmx.test.bundlea.impl"), imported);
1:     }
1: 
commit:c13e6cc
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.ops4j.pax.exam.CoreOptions.provision;
0: import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
0: import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.withBnd;
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.InputStream;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.jar.JarEntry;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.Version;
1: import org.osgi.framework.wiring.BundleRevision;
1: import org.osgi.framework.wiring.BundleRevisions;
1: import org.osgi.framework.wiring.BundleWire;
1: import org.osgi.framework.wiring.BundleWiring;
/////////////////////////////////////////////////////////////////////////
0: //                 new VMOption( "-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000" ),
0: //                 new TimeoutOption( 0 ),
1: 
/////////////////////////////////////////////////////////////////////////
0:             mavenBundle("org.apache.aries", "org.apache.aries.util"),
1: 
0:             provision(newBundle()
0:                     .add(org.apache.aries.jmx.test.bundlea.api.InterfaceA.class)
0:                     .add(org.apache.aries.jmx.test.bundlea.impl.A2.class)
0:                     .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea")
0:                     .set(Constants.BUNDLE_VERSION, "1")
0:                     .set(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api")
0:                     .build(withBnd())),
0:             provision(newBundle()
0:                     .add(org.apache.aries.jmx.test.bundleb.api.InterfaceB.class)
0:                     .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundleb")
0:                     .set(Constants.IMPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api," +
0:                             "org.apache.aries.jmx.test.bundlea.impl;resolution:=optional")
0:                     .build(withBnd()))
/////////////////////////////////////////////////////////////////////////
0:     public void testRefresh() throws Exception {
0:         Bundle bundleA = context().getBundleByName("org.apache.aries.jmx.test.bundlea");
0:         Bundle bundleB = context().getBundleByName("org.apache.aries.jmx.test.bundleb");
1: 
0:         BundleRevision br = bundleB.adapt(BundleRevision.class);
0:         BundleWiring bw = bundleB.adapt(BundleWiring.class);
1: 
1:         List<BundleWire> initialRequiredWires = bw.getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:         assertEquals(1, initialRequiredWires.size());
1:         BundleWire wire = initialRequiredWires.get(0);
1:         Map<String, Object> capabilityAttributes = wire.getCapability().getAttributes();
1:         assertEquals("Precondition", bundleA.getSymbolicName(), capabilityAttributes.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:         assertEquals("Precondition", new Version("1.0"), capabilityAttributes.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:         assertEquals("Precondition", "org.apache.aries.jmx.test.bundlea.api", capabilityAttributes.get(BundleRevision.PACKAGE_NAMESPACE));
1: 
1:         // Create an updated version of Bundle A, which an extra export and version 1.1
1:         Manifest manifest = new Manifest();
1:         manifest.getMainAttributes().putValue("Manifest-Version", "1.0");
1:         manifest.getMainAttributes().putValue(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea");
1:         manifest.getMainAttributes().putValue(Constants.BUNDLE_VERSION, "1.1");
1:         manifest.getMainAttributes().putValue(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api,org.apache.aries.jmx.test.bundlea.impl");
1: 
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         JarOutputStream jos = new JarOutputStream(baos, manifest);
1:         addResourceToJar("org/apache/aries/jmx/test/bundlea/api/InterfaceA.class", jos, bundleA);
1:         addResourceToJar("org/apache/aries/jmx/test/bundlea/impl/A2.class", jos, bundleA);
1:         jos.close();
1: 
0:         assertEquals("Precondition", 1, bundleA.adapt(BundleRevisions.class).getRevisions().size());
1:         bundleA.update(new ByteArrayInputStream(baos.toByteArray()));
0:         assertEquals("There should be 2 revisions now", 2, bundleA.adapt(BundleRevisions.class).getRevisions().size());
1:         assertEquals("No refresh called, the bundle wiring for B should still be the old one",
0:                 bw, bundleB.adapt(BundleWiring.class));
1: 
0:         FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
1:         assertTrue(framework.refreshBundleAndWait(bundleB.getBundleId()));
1: 
0:         List<BundleWire> requiredWires = bundleB.adapt(BundleWiring.class).getRequiredWires(BundleRevision.PACKAGE_NAMESPACE);
1:         assertEquals(2, requiredWires.size());
1:         List<String> imported = new ArrayList<String>();
1:         for (BundleWire w : requiredWires) {
1:             Map<String, Object> ca = w.getCapability().getAttributes();
1:             assertEquals(bundleA.getSymbolicName(), ca.get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE));
1:             imported.add(ca.get(BundleRevision.PACKAGE_NAMESPACE).toString());
1: 
1:             if ("org.apache.aries.jmx.test.bundlea.impl".equals(ca.get(BundleRevision.PACKAGE_NAMESPACE))) {
1:                 // Came across an issue where equinox was reporting the other package as still coming from from the 1.0 bundle
1:                 // not sure if this is a bug or not...
1:                 assertEquals(new Version("1.1"), ca.get(Constants.BUNDLE_VERSION_ATTRIBUTE));
1:             }
1:         }
1:         assertEquals(Arrays.asList("org.apache.aries.jmx.test.bundlea.api", "org.apache.aries.jmx.test.bundlea.impl"), imported);
1:     }
1: 
1:     private void addResourceToJar(String resourceName, JarOutputStream jos, Bundle bundle) throws IOException {
1:         InputStream intfIs = bundle.getResource("/" + resourceName).openStream();
1:         JarEntry entry = new JarEntry(resourceName);
1:         jos.putNextEntry(entry);
1:         try {
1:             Streams.pump(intfIs, jos);
1:         } finally {
1:             jos.closeEntry();
1:         }
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
commit:bf5a863
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.itest.ExtraOptions.mavenBundle;
0: import static org.apache.aries.itest.ExtraOptions.paxLogging;
0: import static org.apache.aries.itest.ExtraOptions.testOptions;
/////////////////////////////////////////////////////////////////////////
0: import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
1: public class FrameworkMBeanTest extends AbstractIntegrationTest {
0:             PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
0:             CoreOptions.equinox().version("3.7.0.v20110613"),
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1:         file.deleteOnExit();
1: 
1: 
commit:fdf3952
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
1: package org.apache.aries.jmx.framework;
1: 
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
0: import static org.apache.aries.itest.ExtraOptions.*;
1: 
1: import java.io.File;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.util.jar.JarOutputStream;
1: import java.util.jar.Manifest;
1: 
1: import javax.management.ObjectName;
1: import javax.management.openmbean.CompositeData;
1: 
1: import org.apache.aries.jmx.AbstractIntegrationTest;
1: import org.apache.aries.jmx.codec.BatchActionResult;
1: import org.junit.Test;
1: import org.ops4j.pax.exam.CoreOptions;
1: import org.ops4j.pax.exam.Option;
0: import org.ops4j.pax.exam.junit.Configuration;
1: import org.osgi.jmx.framework.FrameworkMBean;
1: 
1: /**
1:  * @version $Rev$ $Date$
1:  */
0: public class FrameworkMBeanTest extends AbstractIntegrationTest {    
1: 
0:     @Configuration
0:     public static Option[] configuration() {
0:         return testOptions(
0:             CoreOptions.equinox(),
0:             paxLogging("INFO"),
1: 
0:             mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx"),
0:             mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.api"),
0:             mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.whiteboard"),
0:             mavenBundle("org.apache.aries", "org.apache.aries.util")
1:         );
1:     }
1: 
0:     @Override
0:     public void doSetUp() throws Exception {
0:         waitForMBean(new ObjectName(FrameworkMBean.OBJECTNAME));
1:     }
1:     
1:     @Test
1:     public void testMBeanInterface() throws IOException {
0:         FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
0:         assertNotNull(framework);
1:         
1:         long[] bundleIds = new long[]{1,2};
1:         int[] newlevels = new int[]{1,1};
1:         CompositeData compData = framework.setBundleStartLevels(bundleIds, newlevels);
1:         assertNotNull(compData);
1:         
1:         BatchActionResult batch2 = BatchActionResult.from(compData);
1:         assertNotNull(batch2.getCompleted());
1:         assertTrue(batch2.isSuccess());
1:         assertNull(batch2.getError());
1:         assertNull(batch2.getRemainingItems());
1:                 
1:         File file = File.createTempFile("bundletest", ".jar");
0:         file.deleteOnExit();        
1:         Manifest man = new Manifest();
1:         man.getMainAttributes().putValue("Manifest-Version", "1.0");
1:         JarOutputStream jaros = new JarOutputStream(new FileOutputStream(file), man);
1:         jaros.flush();
1:         jaros.close();
1:         
1:         long bundleId = 0;
1:         try {
1:             bundleId = framework.installBundleFromURL(file.getAbsolutePath(), file.toURI().toString());
1:         } catch (Exception e) {
1:             fail("Installation of test bundle shouldn't fail");
1:         }
1:         
1:         try{
1:             framework.uninstallBundle(bundleId);
1:         } catch (Exception e) {
1:             fail("Uninstallation of test bundle shouldn't fail");
1:         }
1:     }
1: 
1: }
============================================================================