1:65e2deb: /*
1:65e2deb:  * Licensed to the Apache Software Foundation (ASF) under one
1:65e2deb:  * or more contributor license agreements.  See the NOTICE file
1:65e2deb:  * distributed with this work for additional information
1:65e2deb:  * regarding copyright ownership.  The ASF licenses this file
1:65e2deb:  * to you under the Apache License, Version 2.0 (the
1:65e2deb:  * "License"); you may not use this file except in compliance
1:65e2deb:  * with the License.  You may obtain a copy of the License at
1:65e2deb:  *
1:65e2deb:  *   http://www.apache.org/licenses/LICENSE-2.0
1:65e2deb:  *
1:65e2deb:  * Unless required by applicable law or agreed to in writing,
1:65e2deb:  * software distributed under the License is distributed on an
1:65e2deb:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:65e2deb:  * KIND, either express or implied.  See the License for the
1:65e2deb:  * specific language governing permissions and limitations
1:65e2deb:  * under the License.
1:65e2deb:  */
1:65e2deb: package org.apache.aries.application.deployment.management;
10:65e2deb: 
1:65e2deb: import static org.junit.Assert.assertEquals;
1:65e2deb: import static org.junit.Assert.assertFalse;
1:65e2deb: import static org.junit.Assert.assertTrue;
1:65e2deb: import static org.junit.Assert.fail;
1:65e2deb: 
1:65e2deb: import java.io.File;
1:65e2deb: import java.io.IOException;
1:65e2deb: import java.util.ArrayList;
1:65e2deb: import java.util.Arrays;
1:65e2deb: import java.util.Collection;
1:65e2deb: import java.util.Collections;
1:65e2deb: import java.util.Hashtable;
1:65e2deb: import java.util.List;
1:65e2deb: import java.util.Set;
1:65e2deb: import java.util.jar.Attributes;
1:65e2deb: import java.util.jar.Manifest;
1:65e2deb: 
1:65e2deb: import org.apache.aries.application.ApplicationMetadata;
1:65e2deb: import org.apache.aries.application.Content;
1:89f804e: import org.apache.aries.application.InvalidAttributeException;
1:65e2deb: import org.apache.aries.application.deployment.management.impl.DeploymentManifestManagerImpl;
1:65e2deb: import org.apache.aries.application.management.AriesApplication;
1:65e2deb: import org.apache.aries.application.management.BundleInfo;
1:65e2deb: import org.apache.aries.application.management.ResolveConstraint;
1:65e2deb: import org.apache.aries.application.management.ResolverException;
1:89f804e: import org.apache.aries.application.management.spi.resolve.AriesApplicationResolver;
1:e22d71c: import org.apache.aries.application.management.spi.resolve.PreResolveHook;
1:89f804e: import org.apache.aries.application.management.spi.runtime.LocalPlatform;
1:6fe82e7: import org.apache.aries.application.modelling.DeployedBundles;
1:65e2deb: import org.apache.aries.application.modelling.ExportedPackage;
1:65e2deb: import org.apache.aries.application.modelling.ModelledResource;
1:58f55bd: import org.apache.aries.application.modelling.ModellingManager;
1:58f55bd: import org.apache.aries.application.modelling.impl.ModellingManagerImpl;
1:58f55bd: import org.apache.aries.application.modelling.utils.ModellingHelper;
1:58f55bd: import org.apache.aries.application.modelling.utils.impl.ModellingHelperImpl;
1:65e2deb: import org.apache.aries.application.utils.AppConstants;
1:910fec0: import org.apache.aries.application.utils.manifest.ContentFactory;
1:65e2deb: import org.apache.aries.mocks.BundleContextMock;
1:65e2deb: import org.apache.aries.unittest.mocks.MethodCall;
1:65e2deb: import org.apache.aries.unittest.mocks.Skeleton;
1:910fec0: import org.apache.aries.util.VersionRange;
1:65e2deb: import org.junit.AfterClass;
1:65e2deb: import org.junit.Before;
1:65e2deb: import org.junit.BeforeClass;
1:65e2deb: import org.junit.Test;
1:65e2deb: import org.osgi.framework.BundleContext;
1:65e2deb: import org.osgi.framework.Constants;
1:65e2deb: import org.osgi.framework.Version;
1:65e2deb: 
1:65e2deb: 
1:65e2deb: /**
1:65e2deb:  * Tests to ensure we generate DEPLOYMENT.MF artifacts correctly. 
1:65e2deb:  */
1:65e2deb: public class DeploymentGeneratorTest
2:65e2deb: {
1:6fe82e7:   private DeploymentManifestManagerImpl deplMFMgr;
1:65e2deb:   private AriesApplication app;
1:65e2deb:   private ApplicationMetadata appMetadata;
1:6fe82e7:   
1:65e2deb:   private static class MockResolver implements AriesApplicationResolver {
1:65e2deb:     boolean returnAppContentNextTime = true;
1:65e2deb:     
1:6fe82e7:     @Override
1:65e2deb:     public Collection<ModelledResource> resolve(String appName, String appVersion,
1:65e2deb:         Collection<ModelledResource> byValueBundles, Collection<Content> inputs)
1:65e2deb:         throws ResolverException
1:65e2deb:     {
1:65e2deb:       if (_nextResults != null && !_nextResults.isEmpty()) { 
1:65e2deb:         Collection<ModelledResource> result = _nextResults.remove(0);
1:65e2deb:         return result;
2:65e2deb:       }
1:65e2deb:       Collection<ModelledResource> res = new ArrayList<ModelledResource>();
1:65e2deb:       if (returnAppContentNextTime) { 
1:65e2deb:         res.add(CAPABILITY_A.getBundle());
1:65e2deb:         res.add(CAPABILITY_B.getBundle());
1:65e2deb:       } 
1:65e2deb:       res.add(CAPABILITY_C.getBundle());
1:65e2deb:       res.add(CAPABILITY_E.getBundle());
1:65e2deb:       boolean addD = false;
1:65e2deb:       for(Content ib : inputs) {
1:d04041b:         if(ib.getContentName().equals("aries.test.d"))
1:65e2deb:           addD = true;
1:65e2deb:       }
1:65e2deb:       if(addD) {
1:65e2deb:         try {
1:d04041b:           res.add(createModelledResource("aries.test.d", "1.0.0", new ArrayList<String>(), new ArrayList<String>()));
1:65e2deb:         } catch (InvalidAttributeException e) {
1:65e2deb:           fail("Cannot resolve import for d");
1:65e2deb:         }
1:65e2deb:       }
1:2901df4:       
1:65e2deb:       //  deployment manifest manager calls resolve() an extra time, providing
1:65e2deb:       // just the shared bundles. 
1:65e2deb:       // If we added D, then the next resolve will be one trying to winnow D out: 
1:65e2deb:       // AppContent should be returned in that one. We should not return app content
1:65e2deb:       // next time if we did so last time, unless we just added D
1:65e2deb:       returnAppContentNextTime = !returnAppContentNextTime || addD;
1:65e2deb:       return res;
1:65e2deb:     }
1:65e2deb:     
1:65e2deb:     List<Collection<ModelledResource>> _nextResults = null;
1:65e2deb:     
1:65e2deb:     //  Some tests want to override the default behaviour of the resolve() method
1:65e2deb:     public void addResult (Collection<ModelledResource> result) { 
1:65e2deb:       if (_nextResults == null) { 
1:65e2deb:         _nextResults = new ArrayList<Collection<ModelledResource>>();
1:65e2deb:       }
1:65e2deb:       _nextResults.add(result);
1:2901df4:     }
1:2901df4: 
1:65e2deb:     public BundleInfo getBundleInfo(String bundleSymbolicName, Version bundleVersion)
1:2901df4:     {
1:65e2deb:       return null;
1:65e2deb:     }
1:65e2deb: 
1:65e2deb:     public Set<BundleInfo> resolve(AriesApplication app, ResolveConstraint... constraints)
1:65e2deb:         throws ResolverException
1:65e2deb:     {
1:65e2deb:       return null;
1:65e2deb:     }
1:65e2deb: 
1:cce7f7c:     @Override
1:cce7f7c:     public Collection<ModelledResource> resolveInIsolation(String appName,
1:cce7f7c:             String appVersion, Collection<ModelledResource> byValueBundles,
1:cce7f7c:             Collection<Content> inputs) throws ResolverException {
1:cce7f7c:         // TODO Auto-generated method stub
1:cce7f7c:         return null;
1:cce7f7c:     }
1:cce7f7c: 
1:65e2deb:     
1:65e2deb:   }
1:65e2deb:   
1:65e2deb:   static MockResolver _resolver = new MockResolver();
1:65e2deb: 
1:65e2deb:   static class DummyLocalPlatform implements LocalPlatform {
1:65e2deb:     public File getTemporaryDirectory() throws IOException {
1:65e2deb:       File f = File.createTempFile("ebaTmp", null);
1:65e2deb:       f.delete();
1:65e2deb:       f.mkdir();
1:65e2deb:       return f;
1:65e2deb:     } 
1:65e2deb:     public File getTemporaryFile () throws IOException { 
1:65e2deb:       // Not used
1:65e2deb:       return File.createTempFile("ebaTmp", null);
1:65e2deb:     }
1:65e2deb:   }
1:65e2deb:   static LocalPlatform localPlatform = new DummyLocalPlatform();
1:58f55bd:   static ModellingManager modellingManager = new ModellingManagerImpl();
1:58f55bd:   static ModellingHelper modellingHelper = new ModellingHelperImpl();
1:58f55bd:   
1:65e2deb:   @BeforeClass
1:65e2deb:   public static void classSetup() throws Exception
1:65e2deb:   {
1:65e2deb:     BundleContext bc = Skeleton.newMock(BundleContext.class);
1:65e2deb:     bc.registerService(AriesApplicationResolver.class.getName(), _resolver, new Hashtable<String, String>());
1:58f55bd:     bc.registerService(ModellingManager.class.getName(), modellingManager, new Hashtable<String, String>());
1:58f55bd:     bc.registerService(ModellingHelper.class.getName(), modellingHelper, new Hashtable<String, String>());
1:65e2deb:   }
1:65e2deb:   
1:65e2deb:   @AfterClass
1:65e2deb:   public static void afterClass() throws Exception { 
1:65e2deb:     BundleContextMock.clear();
1:65e2deb:   }
1:65e2deb:   
1:65e2deb:   @Before
1:65e2deb:   public void setup() throws Exception
1:65e2deb:   {
1:65e2deb:     appMetadata = Skeleton.newMock(ApplicationMetadata.class);
1:65e2deb:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:d04041b:         new MethodCall(ApplicationMetadata.class, "getApplicationSymbolicName"), "aries.test");
1:65e2deb:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:65e2deb:         new MethodCall(ApplicationMetadata.class, "getApplicationVersion"), new Version("1.0.0"));
1:2e105c1:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:2e105c1:         new MethodCall(ApplicationMetadata.class, "getUseBundles"), Collections.EMPTY_LIST);    
1:65e2deb:     
2:65e2deb:     app = Skeleton.newMock(AriesApplication.class);
2:65e2deb:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:65e2deb:     
1:6fe82e7:     deplMFMgr = new DeploymentManifestManagerImpl();
1:6fe82e7:     deplMFMgr.setResolver(_resolver);
1:6fe82e7:     deplMFMgr.setLocalPlatform(localPlatform);
1:6fe82e7:     deplMFMgr.setModellingManager(modellingManager);
1:6fe82e7:     deplMFMgr.setModellingHelper(modellingHelper);
1:e22d71c:     deplMFMgr.setPreResolveHooks(new ArrayList<PreResolveHook>());
1:65e2deb:   }
1:65e2deb:   
1:65e2deb:   private static ExportedPackage CAPABILITY_A;
1:65e2deb:   private static ExportedPackage CAPABILITY_B;
1:65e2deb:   private static ExportedPackage CAPABILITY_C;
1:65e2deb:   private static ExportedPackage CAPABILITY_E;
1:65e2deb: 
1:65e2deb:   
1:65e2deb:   // use bundle
1:65e2deb:   private static Content BUNDLE_C;
1:65e2deb:   private static Content BUNDLE_D;
1:65e2deb:   
1:65e2deb:   
1:65e2deb: 
1:65e2deb:   public static ExportedPackage createExportedPackage (String bundleName, String bundleVersion, 
1:65e2deb:       String[] exportedPackages, String[] importedPackages ) throws InvalidAttributeException { 
1:65e2deb:     ModelledResource mb = createModelledResource(bundleName, bundleVersion,
1:65e2deb:         Arrays.asList(importedPackages) , Arrays.asList(exportedPackages));
1:4d6a7ea:     
1:65e2deb:     
1:4d6a7ea:     return mb.getExportedPackages().iterator().next();
1:65e2deb:   }
1:4d6a7ea:   
1:65e2deb:   static {
1:65e2deb:     try {
1:d04041b:       CAPABILITY_A = createExportedPackage ("aries.test.a", "1.0.0", new String[] {"aries.test.a"}, 
1:d04041b:           new String[] {"aries.test.c"});
1:65e2deb:  
1:d04041b:       CAPABILITY_B = createExportedPackage("aries.test.b", "1.1.0", new String[] {"aries.test.b"}, new String[] {"aries.test.e"});
1:65e2deb:       
1:910fec0:       BUNDLE_C = ContentFactory.parseContent("aries.test.c","[1.0.0,1.1.0)");
1:65e2deb:       
1:d04041b:       CAPABILITY_C = createExportedPackage("aries.test.c", "1.0.5", new String[] {"aries.test.c"}, new String[] {});
1:65e2deb:       
1:910fec0:       BUNDLE_D = ContentFactory.parseContent("aries.test.d","1.0.0");
1:65e2deb:       
1:d04041b:      // = new ImportedBundleImpl("aries.test.e", "1.0.0");
1:65e2deb:       
1:d04041b:       CAPABILITY_E = createExportedPackage("aries.test.e", "1.0.0", new String[] {"aries.test.e"}, new String[] {});
1:65e2deb:       
1:65e2deb:     } catch (InvalidAttributeException iae) {
1:65e2deb:       throw new RuntimeException(iae);
1:65e2deb:     }
1:65e2deb:   }
1:65e2deb:   
1:65e2deb:   
1:4d6a7ea:   @Test
1:65e2deb:   public void testResolve() throws Exception
1:65e2deb:   {
1:65e2deb:     
1:d04041b:     Skeleton.getSkeleton(appMetadata).setReturnValue(new MethodCall(ApplicationMetadata.class, "getApplicationContents"), Arrays.asList(mockContent("aries.test.a", "1.0.0"), mockContent("aries.test.b", "[1.0.0, 2.0.0)" )));
1:2e105c1:     Skeleton.getSkeleton(appMetadata).setReturnValue(new MethodCall(ApplicationMetadata.class, "getUseBundles"), Arrays.asList(BUNDLE_C, BUNDLE_D));
1:6fe82e7:     
1:2e105c1:     DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:2e105c1:         new ArrayList<ModelledResource>(), Collections.<Content>emptyList()); 
1:6fe82e7:     Manifest man = deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:6fe82e7:         appMetadata.getApplicationVersion().toString(), deployedBundles);
1:6fe82e7:     
1:65e2deb:     Attributes attrs = man.getMainAttributes();
1:65e2deb:     
1:d04041b:     assertEquals("aries.test", attrs.getValue(AppConstants.APPLICATION_SYMBOLIC_NAME));
1:4d6a7ea:     assertEquals("1.0.0", attrs.getValue(AppConstants.APPLICATION_VERSION));
1:65e2deb:     
1:4d6a7ea:     String content = attrs.getValue(AppConstants.DEPLOYMENT_CONTENT);
1:4d6a7ea:     String useBundle = attrs.getValue(AppConstants.DEPLOYMENT_USE_BUNDLE);
1:4d6a7ea:     String provisioned =attrs.getValue(AppConstants.DEPLOYMENT_PROVISION_BUNDLE);
1:65e2deb:     
1:d04041b:     assertTrue(content.contains("aries.test.a;deployed-version=1.0.0"));
1:d04041b:     assertTrue(content.contains("aries.test.b;deployed-version=1.1.0"));
1:65e2deb:     
1:d04041b:     assertTrue(useBundle.contains("aries.test.c;deployed-version=1.0.5"));
1:d04041b:     assertFalse(useBundle.contains("aries.test.d"));
1:65e2deb:     
1:d04041b:     assertTrue(provisioned.contains("aries.test.e;deployed-version=1.0.0"));
1:65e2deb:   }
1:65e2deb:   
1:65e2deb:   @Test
1:65e2deb:   public void checkBasicCircularDependenciesDetected() throws Exception { 
1:65e2deb:     // Override Resolver behaviour. 
1:65e2deb:     //ImportedBundle isolated = new ImportedBundleImpl ("test.isolated" , "1.0.0"); 
1:65e2deb:     
1:65e2deb:     // When we resolve isolated, we're going to get another bundle which has a dependency on isolated. 
1:65e2deb:     Collection<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:65e2deb:     ExportedPackage testIsolatedPkg = createExportedPackage ("test.isolated", "1.0.0", 
1:65e2deb:         new String[] {"test.shared"}, new String[] {"test.isolated.pkg"});
1:65e2deb:     cmr.add (testIsolatedPkg.getBundle());
1:65e2deb:     
1:65e2deb:     ExportedPackage testSharedPkg = createExportedPackage ("test.shared", "1.0.0", 
1:65e2deb:         new String[] {"test.isolated.pkg"}, new String[] {"test.shared"});
1:65e2deb:     cmr.add (testSharedPkg.getBundle());
1:65e2deb:     _resolver.addResult(cmr);
1:65e2deb:     
1:65e2deb:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:65e2deb:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:65e2deb:     _resolver.addResult(cmr);
1:65e2deb:     Skeleton.getSkeleton(appMetadata).setReturnValue(new MethodCall(ApplicationMetadata.class, "getApplicationContents"), Arrays.asList(mockContent("test.isolated" , "1.0.0")));
1:65e2deb:     
1:65e2deb:     
1:65e2deb:     try { 
1:2e105c1:       DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:2e105c1:           new ArrayList<ModelledResource>(), new ArrayList<Content>());
1:6fe82e7:       deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:6fe82e7:           appMetadata.getApplicationVersion().toString(), deployedBundles);
1:65e2deb:     } catch (ResolverException rx) { 
1:65e2deb:       List<String> usr = rx.getUnsatisfiedRequirements();
1:65e2deb:       assertEquals ("One unsatisfied requirement expected, not " + usr.size(), usr.size(), 1);
1:65e2deb:       String chkMsg = "Shared bundle test.shared_1.0.0 has a dependency for package " +
1:c2918f4:       		"test.shared which is exported from application bundle [test.isolated_1.0.0]";
1:65e2deb:       assertTrue (chkMsg + " expected, not " + usr, usr.contains(chkMsg));
1:65e2deb:       return;
1:65e2deb:     }
1:65e2deb:     fail ("ResolverException expected");
1:65e2deb:   }
1:65e2deb:   
1:65e2deb:   /**
1:65e2deb:    * This method checks that the a more complicated circular dependency issues the correct error message
1:65e2deb:    * and checks that the details listed in the exception are correct. 
1:65e2deb:    * @throws Exception
1:65e2deb:    */
1:65e2deb:   @Test
1:65e2deb:   public void checkMultipleCircularDependenciesDetected() throws Exception { 
1:65e2deb:     
1:65e2deb:     Collection<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:65e2deb:     ExportedPackage testIsolated1 = createExportedPackage ("test.isolated1", "1.0.0", 
1:65e2deb:         new String[] {"test.isolated1","test.isolated2"}, new String[] {"test.shared1", "test.shared2"});
1:65e2deb:     cmr.add (testIsolated1.getBundle());
1:65e2deb:     
1:65e2deb:     ExportedPackage testIsolated2 = createExportedPackage ("test.isolated2", "1.0.0", 
1:65e2deb:         new String[] {"test.isolated1","test.isolated2"}, new String[] {"test.shared1", "test.shared2"});
1:65e2deb:     cmr.add (testIsolated2.getBundle());
1:65e2deb:     
1:65e2deb:     ExportedPackage testShared1 = createExportedPackage ("test.shared1", "1.0.0", 
1:65e2deb:         new String[] {"test.shared1", "test.shared2"}, new String[] {"test.isolated1","test.isolated2"});
1:65e2deb:     cmr.add (testShared1.getBundle());
1:65e2deb:     
1:65e2deb:     ExportedPackage testShared2 = createExportedPackage ("test.shared2", "1.0.0", 
1:65e2deb:         new String[] {"test.shared1", "test.shared2"}, new String[] {"test.isolated1","test.isolated2"});
1:65e2deb:     cmr.add (testShared2.getBundle());
1:65e2deb:     
1:65e2deb:     _resolver.addResult(cmr);
1:65e2deb:     
1:65e2deb:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:65e2deb:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:65e2deb:     _resolver.addResult(cmr);
1:65e2deb:     Skeleton.getSkeleton(appMetadata).setReturnValue(new MethodCall(ApplicationMetadata.class, "getApplicationContents"), Arrays.asList(mockContent("test.isolated1" , "1.0.0"), mockContent("test.isolated2" , "1.0.0")));
1:65e2deb:     
1:65e2deb:     app = Skeleton.newMock(AriesApplication.class);
1:65e2deb:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:65e2deb:     
1:65e2deb:     try {
1:2e105c1:       DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:6fe82e7:           Arrays.asList(new ModelledResource[] {testIsolated1.getBundle(), testIsolated2.getBundle()}), 
1:2e105c1:           new ArrayList<Content>());
1:6fe82e7:       deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:6fe82e7:           appMetadata.getApplicationVersion().toString(), deployedBundles);
1:65e2deb:     } catch (ResolverException rx) { 
1:65e2deb:       // Get the unsatisfied Requirements
1:65e2deb:       List<String> unsatisfiedReqs = rx.getUnsatisfiedRequirements();
1:65e2deb:       // Ensure we've got 4 unsatisfied Requirements
1:9da7040:       assertEquals ("4 unsatisfied requirements expected, but got " + Arrays.toString(unsatisfiedReqs.toArray()), 4, unsatisfiedReqs.size());
1:65e2deb:       List<String> checkMessages = new ArrayList<String>();
1:65e2deb:       // Now load an array with the expected messages.
1:65e2deb:       checkMessages.add("Shared bundle test.shared1_1.0.0 has a dependency for package test.isolated1 which " +
1:c2918f4:       "is exported from application bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:65e2deb:       checkMessages.add("Shared bundle test.shared1_1.0.0 has a dependency for package test.isolated2 which " +
1:c2918f4:       "is exported from application bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:65e2deb:       checkMessages.add("Shared bundle test.shared2_1.0.0 has a dependency for package test.isolated1 which " +
1:c2918f4:       "is exported from application bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:65e2deb:       checkMessages.add("Shared bundle test.shared2_1.0.0 has a dependency for package test.isolated2 which " +
1:c2918f4:       "is exported from application bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:4d6a7ea:       
1:65e2deb:       // Loop through the unsatisfied Requirements and compare them to the expected msgs. We trim the strings
1:65e2deb:       // because some unsatisfied reqs have spaces at the end of the string.
1:65e2deb:       for (String unsatisfiedReq : unsatisfiedReqs) {
1:65e2deb:         assertTrue(unsatisfiedReq + " is not an expected msg", checkMessages.contains(unsatisfiedReq.trim()));
1:65e2deb:       }
1:65e2deb:     }
1:65e2deb:   }
1:65e2deb:   
1:65e2deb:   @Test
1:4d6a7ea:   public void checkBundleInAppContentAndProvisionContent() throws Exception
1:4d6a7ea:   {
1:4d6a7ea:     List<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:4d6a7ea:     cmr.add(createModelledResource("test.api", "1.1.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.1.0")));
1:4d6a7ea:     cmr.add(createModelledResource("test.api", "1.0.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.0.0")));
1:4d6a7ea:     cmr.add(createModelledResource("test.consumer", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,2.0.0)\""), Collections.<String>emptyList()));
1:4d6a7ea:     cmr.add(createModelledResource("test.provider", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,1.1.0)\""), Collections.<String>emptyList()));
1:4d6a7ea: 
1:4d6a7ea:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:4d6a7ea:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:4d6a7ea:     _resolver.addResult(cmr);
1:4d6a7ea:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:4d6a7ea:         new MethodCall(ApplicationMetadata.class, "getApplicationContents"), 
1:4d6a7ea:         Arrays.asList(
1:4d6a7ea:             mockContent("test.api" , "1.1.0"),
1:4d6a7ea:             mockContent("test.consumer" , "1.0.0"),
1:4d6a7ea:             mockContent("test.provider", "1.0.0")));
1:4d6a7ea: 
1:4d6a7ea:     app = Skeleton.newMock(AriesApplication.class);
1:4d6a7ea:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:4d6a7ea:     
1:4d6a7ea:     try {
1:4d6a7ea:       DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:4d6a7ea:           Arrays.asList(new ModelledResource[] {cmr.get(0), cmr.get(2), cmr.get(3)}), 
1:4d6a7ea:           new ArrayList<Content>());
1:4d6a7ea:       deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:4d6a7ea:           appMetadata.getApplicationVersion().toString(), deployedBundles);
1:4d6a7ea:       
1:4d6a7ea:       fail("Expected exception because we can't provision an isolated bundle twice");
1:4d6a7ea:     } catch (ResolverException rx) {}
1:4d6a7ea:   }
1:4d6a7ea:   
1:4d6a7ea:   /**
1:4d6a7ea:    * Similar to the checkBundleInAppContentAndProvisionContent scenario. However, this time the provisioned bundle does not provide
1:4d6a7ea:    * a package or service to the isolated content, so there is no problem.
1:4d6a7ea:    * @throws Exception
1:4d6a7ea:    */
1:4d6a7ea:   @Test
1:4d6a7ea:   public void checkBundleInAppContentAndProvisionContentButNothingSharedToIsolatedContent() throws Exception
1:4d6a7ea:   {
1:4d6a7ea:     List<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:4d6a7ea:     cmr.add(createModelledResource("test.util", "1.1.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.1.0")));
1:4d6a7ea:     cmr.add(createModelledResource("test.bundle", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.1.0,2.0.0)\""), Collections.<String>emptyList()));
1:4d6a7ea:     cmr.add(createModelledResource("test.provisioned", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,1.1.0)\""), Collections.<String>emptyList()));
1:4d6a7ea:     cmr.add(createModelledResource("test.util", "1.0.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.0.0")));
1:4d6a7ea: 
1:4d6a7ea:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:4d6a7ea:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:4d6a7ea:     _resolver.addResult(cmr);
1:4d6a7ea:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:4d6a7ea:         new MethodCall(ApplicationMetadata.class, "getApplicationContents"), 
1:4d6a7ea:         Arrays.asList(
1:4d6a7ea:             mockContent("test.util" , "1.1.0"),
1:4d6a7ea:             mockContent("test.bundle", "1.0.0")));
1:4d6a7ea: 
1:4d6a7ea:     app = Skeleton.newMock(AriesApplication.class);
1:4d6a7ea:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:4d6a7ea:     
1:4d6a7ea:     DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:4d6a7ea:         Arrays.asList(new ModelledResource[] {cmr.get(0), cmr.get(1)}), 
1:4d6a7ea:         new ArrayList<Content>());
1:4d6a7ea:     Manifest mf = deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:4d6a7ea:         appMetadata.getApplicationVersion().toString(), deployedBundles);
1:4d6a7ea:     
1:4d6a7ea:     assertTrue(mf.getMainAttributes().getValue("Deployed-Content").contains("test.util;deployed-version=1.1.0"));
1:4d6a7ea:     assertTrue(mf.getMainAttributes().getValue("Provision-Bundle").contains("test.util;deployed-version=1.0.0"));
1:4d6a7ea:   }
1:4d6a7ea:   
1:4d6a7ea:   @Test
1:4d6a7ea:   public void checkBundleInAppContentAndUseContent() throws Exception
1:4d6a7ea:   {
1:4d6a7ea:     List<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:4d6a7ea:     cmr.add(createModelledResource("test.api", "1.1.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.1.0")));
1:4d6a7ea:     cmr.add(createModelledResource("test.api", "1.0.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.0.0")));
1:4d6a7ea:     cmr.add(createModelledResource("test.consumer", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,2.0.0)\""), Collections.<String>emptyList()));
1:4d6a7ea:     cmr.add(createModelledResource("test.provider", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,1.1.0)\""), Collections.<String>emptyList()));
1:4d6a7ea: 
1:4d6a7ea:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:4d6a7ea:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:4d6a7ea:     _resolver.addResult(cmr);
1:4d6a7ea:     
1:4d6a7ea:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:4d6a7ea:         new MethodCall(ApplicationMetadata.class, "getApplicationContents"), 
1:4d6a7ea:         Arrays.asList(
1:4d6a7ea:             mockContent("test.api" , "1.1.0"),
1:4d6a7ea:             mockContent("test.consumer" , "1.0.0"),
1:4d6a7ea:             mockContent("test.provider", "1.0.0")));
1:4d6a7ea:     
1:4d6a7ea:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:4d6a7ea:         new MethodCall(ApplicationMetadata.class, "getUseBundles"),
1:4d6a7ea:         Arrays.asList(mockContent("test.api", "1.0.0")));
1:4d6a7ea: 
1:4d6a7ea:     app = Skeleton.newMock(AriesApplication.class);
1:4d6a7ea:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:4d6a7ea:     
1:4d6a7ea:     DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:4d6a7ea:         Arrays.asList(new ModelledResource[] {cmr.get(0), cmr.get(2), cmr.get(3)}), 
1:4d6a7ea:         new ArrayList<Content>());
1:4d6a7ea:     
1:4d6a7ea:     Manifest mf = deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:4d6a7ea:         appMetadata.getApplicationVersion().toString(), deployedBundles);
1:65e2deb:     
1:4d6a7ea:     mf.write(System.out);
1:4d6a7ea:     assertTrue(mf.getMainAttributes().getValue("Deployed-Content").contains("test.api;deployed-version=1.1.0"));
1:4d6a7ea:     assertTrue(mf.getMainAttributes().getValue("Deployed-Use-Bundle").contains("test.api;deployed-version=1.0.0"));
1:4d6a7ea:   }
1:4d6a7ea:   
1:65e2deb:   public static ModelledResource createModelledResource(String bundleName, String bundleVersion, 
1:65e2deb:       Collection<String> importedPackages, Collection<String> exportedPackages) throws InvalidAttributeException {
1:65e2deb:     Attributes att = new Attributes();
1:65e2deb:     att.put(new Attributes.Name(Constants.BUNDLE_SYMBOLICNAME), bundleName);
1:65e2deb:     att.put(new Attributes.Name(Constants.BUNDLE_VERSION), bundleVersion);
1:65e2deb:     att.put(new Attributes.Name(Constants.BUNDLE_MANIFESTVERSION), "2");
1:65e2deb:     
1:65e2deb:     StringBuilder builder = new StringBuilder();
1:65e2deb:     for(String iPackage : importedPackages) {
1:65e2deb:       builder.append(iPackage).append(",");
1:65e2deb:     }
1:65e2deb:     if(builder.length() > 0) {
1:65e2deb:       builder.deleteCharAt(builder.length() - 1);
1:65e2deb:       att.put(new Attributes.Name(Constants.IMPORT_PACKAGE), builder.toString());
1:65e2deb:     }
1:65e2deb:     
1:65e2deb:     builder = new StringBuilder();
1:65e2deb:     for(String ePackage : exportedPackages) {
1:65e2deb:       builder.append(ePackage).append(",");
1:65e2deb:     }
1:65e2deb:     if(builder.length() > 0) {
1:65e2deb:       builder.deleteCharAt(builder.length() - 1);
1:65e2deb:       att.put(new Attributes.Name(Constants.EXPORT_PACKAGE), builder.toString());
1:65e2deb:     }
1:58f55bd:     return new ModellingManagerImpl().getModelledResource(null, att, null, null);
1:65e2deb:   }
1:65e2deb:   
1:65e2deb:   private Content mockContent(String symbolicName, String version) {
1:65e2deb:     Content bundle = Skeleton.newMock(Content.class);
1:910fec0:     VersionRange vr = new VersionRange(version);
1:65e2deb:     Skeleton.getSkeleton(bundle).setReturnValue(new MethodCall(Content.class, "getContentName"), symbolicName);
1:65e2deb:     Skeleton.getSkeleton(bundle).setReturnValue(new MethodCall(Content.class, "getVersion"), vr);
1:65e2deb:     
1:65e2deb:        return bundle;
1:65e2deb:   }
1:65e2deb: }
============================================================================
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:cce7f7c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public Collection<ModelledResource> resolveInIsolation(String appName,
1:             String appVersion, Collection<ModelledResource> byValueBundles,
1:             Collection<Content> inputs) throws ResolverException {
1:         // TODO Auto-generated method stub
1:         return null;
1:     }
1: 
commit:910fec0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.utils.manifest.ContentFactory;
1: import org.apache.aries.util.VersionRange;
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
/////////////////////////////////////////////////////////////////////////
1:       BUNDLE_C = ContentFactory.parseContent("aries.test.c","[1.0.0,1.1.0)");
1:       BUNDLE_D = ContentFactory.parseContent("aries.test.d","1.0.0");
/////////////////////////////////////////////////////////////////////////
1:     VersionRange vr = new VersionRange(version);
commit:4d6a7ea
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Array;
/////////////////////////////////////////////////////////////////////////
1:     
1:     return mb.getExportedPackages().iterator().next();
1:   
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("1.0.0", attrs.getValue(AppConstants.APPLICATION_VERSION));
1:     String content = attrs.getValue(AppConstants.DEPLOYMENT_CONTENT);
1:     String useBundle = attrs.getValue(AppConstants.DEPLOYMENT_USE_BUNDLE);
1:     String provisioned =attrs.getValue(AppConstants.DEPLOYMENT_PROVISION_BUNDLE);
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void checkBundleInAppContentAndProvisionContent() throws Exception
1:   {
1:     List<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:     cmr.add(createModelledResource("test.api", "1.1.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.1.0")));
1:     cmr.add(createModelledResource("test.api", "1.0.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.0.0")));
1:     cmr.add(createModelledResource("test.consumer", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,2.0.0)\""), Collections.<String>emptyList()));
1:     cmr.add(createModelledResource("test.provider", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,1.1.0)\""), Collections.<String>emptyList()));
1: 
1:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:     _resolver.addResult(cmr);
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:         new MethodCall(ApplicationMetadata.class, "getApplicationContents"), 
1:         Arrays.asList(
1:             mockContent("test.api" , "1.1.0"),
1:             mockContent("test.consumer" , "1.0.0"),
1:             mockContent("test.provider", "1.0.0")));
1: 
1:     app = Skeleton.newMock(AriesApplication.class);
1:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:     
1:     try {
1:       DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:           Arrays.asList(new ModelledResource[] {cmr.get(0), cmr.get(2), cmr.get(3)}), 
1:           new ArrayList<Content>());
1:       deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:           appMetadata.getApplicationVersion().toString(), deployedBundles);
1:       
1:       fail("Expected exception because we can't provision an isolated bundle twice");
1:     } catch (ResolverException rx) {}
1:   }
1:   
1:   /**
1:    * Similar to the checkBundleInAppContentAndProvisionContent scenario. However, this time the provisioned bundle does not provide
1:    * a package or service to the isolated content, so there is no problem.
1:    * @throws Exception
1:    */
1:   @Test
1:   public void checkBundleInAppContentAndProvisionContentButNothingSharedToIsolatedContent() throws Exception
1:   {
1:     List<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:     cmr.add(createModelledResource("test.util", "1.1.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.1.0")));
1:     cmr.add(createModelledResource("test.bundle", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.1.0,2.0.0)\""), Collections.<String>emptyList()));
1:     cmr.add(createModelledResource("test.provisioned", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,1.1.0)\""), Collections.<String>emptyList()));
1:     cmr.add(createModelledResource("test.util", "1.0.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.0.0")));
1: 
1:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:     _resolver.addResult(cmr);
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:         new MethodCall(ApplicationMetadata.class, "getApplicationContents"), 
1:         Arrays.asList(
1:             mockContent("test.util" , "1.1.0"),
1:             mockContent("test.bundle", "1.0.0")));
1: 
1:     app = Skeleton.newMock(AriesApplication.class);
1:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:     
1:     DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:         Arrays.asList(new ModelledResource[] {cmr.get(0), cmr.get(1)}), 
1:         new ArrayList<Content>());
1:     Manifest mf = deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:         appMetadata.getApplicationVersion().toString(), deployedBundles);
1:     
1:     assertTrue(mf.getMainAttributes().getValue("Deployed-Content").contains("test.util;deployed-version=1.1.0"));
1:     assertTrue(mf.getMainAttributes().getValue("Provision-Bundle").contains("test.util;deployed-version=1.0.0"));
1:   }
1:   
1:   @Test
1:   public void checkBundleInAppContentAndUseContent() throws Exception
1:   {
1:     List<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:     cmr.add(createModelledResource("test.api", "1.1.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.1.0")));
1:     cmr.add(createModelledResource("test.api", "1.0.0", Collections.<String>emptyList(), Arrays.asList("test.api.pack;version=1.0.0")));
1:     cmr.add(createModelledResource("test.consumer", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,2.0.0)\""), Collections.<String>emptyList()));
1:     cmr.add(createModelledResource("test.provider", "1.0.0", Arrays.asList("test.api.pack;version=\"[1.0.0,1.1.0)\""), Collections.<String>emptyList()));
1: 
1:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:     _resolver.addResult(cmr);
1:     
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:         new MethodCall(ApplicationMetadata.class, "getApplicationContents"), 
1:         Arrays.asList(
1:             mockContent("test.api" , "1.1.0"),
1:             mockContent("test.consumer" , "1.0.0"),
1:             mockContent("test.provider", "1.0.0")));
1:     
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:         new MethodCall(ApplicationMetadata.class, "getUseBundles"),
1:         Arrays.asList(mockContent("test.api", "1.0.0")));
1: 
1:     app = Skeleton.newMock(AriesApplication.class);
1:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:     
1:     DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:         Arrays.asList(new ModelledResource[] {cmr.get(0), cmr.get(2), cmr.get(3)}), 
1:         new ArrayList<Content>());
1:     
1:     Manifest mf = deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:         appMetadata.getApplicationVersion().toString(), deployedBundles);
1:     
1:     mf.write(System.out);
1:     assertTrue(mf.getMainAttributes().getValue("Deployed-Content").contains("test.api;deployed-version=1.1.0"));
1:     assertTrue(mf.getMainAttributes().getValue("Deployed-Use-Bundle").contains("test.api;deployed-version=1.0.0"));
1:   }
1:   
commit:89f804e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.InvalidAttributeException;
1: import org.apache.aries.application.management.spi.resolve.AriesApplicationResolver;
1: import org.apache.aries.application.management.spi.runtime.LocalPlatform;
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:e22d71c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.management.spi.resolve.PreResolveHook;
/////////////////////////////////////////////////////////////////////////
1:     deplMFMgr.setPreResolveHooks(new ArrayList<PreResolveHook>());
author:Holly Cummins
-------------------------------------------------------------------------------
commit:17170a0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9da7040
/////////////////////////////////////////////////////////////////////////
1:       assertEquals ("4 unsatisfied requirements expected, but got " + Arrays.toString(unsatisfiedReqs.toArray()), 4, unsatisfiedReqs.size());
commit:2901df4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.management.spi.repository.PlatformRepository;
/////////////////////////////////////////////////////////////////////////
0: 		public Collection<ModelledResource> resolve(String appName,
0: 				String appVersion, Collection<ModelledResource> byValueBundles,
0: 				Collection<Content> inputs,
0: 				PlatformRepository platformRepository) throws ResolverException 
1: 		{
1: 
0: 			return resolve(appName, appVersion, byValueBundles, inputs);
1: 		}
1: 
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:2e105c1
/////////////////////////////////////////////////////////////////////////
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:         new MethodCall(ApplicationMetadata.class, "getUseBundles"), Collections.EMPTY_LIST);    
/////////////////////////////////////////////////////////////////////////
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(new MethodCall(ApplicationMetadata.class, "getUseBundles"), Arrays.asList(BUNDLE_C, BUNDLE_D));
1:     DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:         new ArrayList<ModelledResource>(), Collections.<Content>emptyList()); 
/////////////////////////////////////////////////////////////////////////
1:       DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:           new ArrayList<ModelledResource>(), new ArrayList<Content>());
/////////////////////////////////////////////////////////////////////////
1:       DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata, 
1:           new ArrayList<Content>());
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:c2918f4
/////////////////////////////////////////////////////////////////////////
1:       		"test.shared which is exported from application bundle [test.isolated_1.0.0]";
/////////////////////////////////////////////////////////////////////////
1:       "is exported from application bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:       "is exported from application bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:       "is exported from application bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:       "is exported from application bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
commit:6fe82e7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.modelling.DeployedBundles;
/////////////////////////////////////////////////////////////////////////
1:   private DeploymentManifestManagerImpl deplMFMgr;
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     deplMFMgr = new DeploymentManifestManagerImpl();
1:     deplMFMgr.setResolver(_resolver);
1:     deplMFMgr.setLocalPlatform(localPlatform);
1:     deplMFMgr.setModellingManager(modellingManager);
1:     deplMFMgr.setModellingHelper(modellingHelper);
/////////////////////////////////////////////////////////////////////////
1:     
1:     
0:     DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata.getApplicationSymbolicName(),
0:         Arrays.asList(BUNDLE_C, BUNDLE_D), Collections.<Content>emptyList(), appMetadata.getApplicationImportServices());
1:     Manifest man = deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:         appMetadata.getApplicationVersion().toString(), deployedBundles);
1:     
/////////////////////////////////////////////////////////////////////////
0:       DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata.getApplicationSymbolicName(),
0:           new ArrayList<ModelledResource>(), 
0:           new ArrayList<Content>(), Collections.<Content>emptyList(), appMetadata.getApplicationImportServices());
1:       deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:           appMetadata.getApplicationVersion().toString(), deployedBundles);
/////////////////////////////////////////////////////////////////////////
0:       DeployedBundles deployedBundles = deplMFMgr.generateDeployedBundles (appMetadata.getApplicationSymbolicName(),
0:           appMetadata.getApplicationVersion().toString(), appMetadata.getApplicationContents(), 
1:           Arrays.asList(new ModelledResource[] {testIsolated1.getBundle(), testIsolated2.getBundle()}), 
0:           new ArrayList<Content>(), Collections.<Content>emptyList(), appMetadata.getApplicationImportServices());
1:       deplMFMgr.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(),
1:           appMetadata.getApplicationVersion().toString(), deployedBundles);
commit:58f55bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.modelling.ModellingManager;
1: import org.apache.aries.application.modelling.impl.ModellingManagerImpl;
1: import org.apache.aries.application.modelling.utils.ModellingHelper;
1: import org.apache.aries.application.modelling.utils.impl.ModellingHelperImpl;
/////////////////////////////////////////////////////////////////////////
1:   static ModellingManager modellingManager = new ModellingManagerImpl();
1:   static ModellingHelper modellingHelper = new ModellingHelperImpl();
1:   
1:     bc.registerService(ModellingManager.class.getName(), modellingManager, new Hashtable<String, String>());
1:     bc.registerService(ModellingHelper.class.getName(), modellingHelper, new Hashtable<String, String>());
/////////////////////////////////////////////////////////////////////////
0:     sut.setModellingManager(modellingManager);
0:     sut.setModellingHelper(modellingHelper);
/////////////////////////////////////////////////////////////////////////
1:     return new ModellingManagerImpl().getModelledResource(null, att, null, null);
commit:a1f07b5
/////////////////////////////////////////////////////////////////////////
0:     Manifest man = sut.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(), 
0:         appMetadata.getApplicationVersion().toString(), appMetadata.getApplicationContents(), 
0:         new ArrayList<ModelledResource>(), 
0:         Arrays.asList(BUNDLE_C, BUNDLE_D), Collections.<Content>emptyList(), 
0:         appMetadata.getApplicationImportServices());
/////////////////////////////////////////////////////////////////////////
0:       sut.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(), 
0:           appMetadata.getApplicationVersion().toString(), appMetadata.getApplicationContents(), 
0:           new ArrayList<ModelledResource>(), new ArrayList<Content>(), 
0:           Collections.<Content>emptyList(), 
0:           appMetadata.getApplicationImportServices());
/////////////////////////////////////////////////////////////////////////
0:            sut.generateDeploymentManifest(appMetadata.getApplicationSymbolicName(), 
0:                appMetadata.getApplicationVersion().toString(), 
0:                appMetadata.getApplicationContents(), 
0:                Arrays.asList(new ModelledResource[] {testIsolated1.getBundle(), testIsolated2.getBundle()}), new ArrayList<Content>(), Collections.<Content>emptyList(), 
0:                appMetadata.getApplicationImportServices());
commit:d04041b
/////////////////////////////////////////////////////////////////////////
1:         if(ib.getContentName().equals("aries.test.d"))
1:           res.add(createModelledResource("aries.test.d", "1.0.0", new ArrayList<String>(), new ArrayList<String>()));
/////////////////////////////////////////////////////////////////////////
1:         new MethodCall(ApplicationMetadata.class, "getApplicationSymbolicName"), "aries.test");
/////////////////////////////////////////////////////////////////////////
1:       CAPABILITY_A = createExportedPackage ("aries.test.a", "1.0.0", new String[] {"aries.test.a"}, 
1:           new String[] {"aries.test.c"});
1:       CAPABILITY_B = createExportedPackage("aries.test.b", "1.1.0", new String[] {"aries.test.b"}, new String[] {"aries.test.e"});
0:       BUNDLE_C = ManifestHeaderProcessor.parseContent("aries.test.c","[1.0.0,1.1.0)");
1:       CAPABILITY_C = createExportedPackage("aries.test.c", "1.0.5", new String[] {"aries.test.c"}, new String[] {});
0:       BUNDLE_D = ManifestHeaderProcessor.parseContent("aries.test.d","1.0.0");
1:      // = new ImportedBundleImpl("aries.test.e", "1.0.0");
1:       CAPABILITY_E = createExportedPackage("aries.test.e", "1.0.0", new String[] {"aries.test.e"}, new String[] {});
/////////////////////////////////////////////////////////////////////////
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(new MethodCall(ApplicationMetadata.class, "getApplicationContents"), Arrays.asList(mockContent("aries.test.a", "1.0.0"), mockContent("aries.test.b", "[1.0.0, 2.0.0)" )));
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("aries.test", attrs.getValue(AppConstants.APPLICATION_SYMBOLIC_NAME));
1:     assertTrue(content.contains("aries.test.a;deployed-version=1.0.0"));
1:     assertTrue(content.contains("aries.test.b;deployed-version=1.1.0"));
1:     assertTrue(useBundle.contains("aries.test.c;deployed-version=1.0.5"));
1:     assertFalse(useBundle.contains("aries.test.d"));
1:     assertTrue(provisioned.contains("aries.test.e;deployed-version=1.0.0"));
commit:65e2deb
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.application.deployment.management;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Hashtable;
1: import java.util.List;
1: import java.util.Set;
1: import java.util.jar.Attributes;
1: import java.util.jar.Manifest;
1: 
1: import org.apache.aries.application.ApplicationMetadata;
1: import org.apache.aries.application.Content;
0: import org.apache.aries.application.VersionRange;
1: import org.apache.aries.application.deployment.management.impl.DeploymentManifestManagerImpl;
1: import org.apache.aries.application.management.AriesApplication;
0: import org.apache.aries.application.management.AriesApplicationResolver;
1: import org.apache.aries.application.management.BundleInfo;
0: import org.apache.aries.application.management.InvalidAttributeException;
0: import org.apache.aries.application.management.LocalPlatform;
1: import org.apache.aries.application.management.ResolveConstraint;
1: import org.apache.aries.application.management.ResolverException;
1: import org.apache.aries.application.modelling.ExportedPackage;
1: import org.apache.aries.application.modelling.ModelledResource;
0: import org.apache.aries.application.modelling.utils.ModellingManager;
1: import org.apache.aries.application.utils.AppConstants;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor;
1: import org.apache.aries.mocks.BundleContextMock;
1: import org.apache.aries.unittest.mocks.MethodCall;
1: import org.apache.aries.unittest.mocks.Skeleton;
1: import org.junit.AfterClass;
1: import org.junit.Before;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.Version;
1: 
1: 
1: /**
1:  * Tests to ensure we generate DEPLOYMENT.MF artifacts correctly. 
1:  */
1: public class DeploymentGeneratorTest
1: {
0:   private DeploymentManifestManagerImpl sut;
1:   private AriesApplication app;
1:   private ApplicationMetadata appMetadata;
1:   
1:   private static class MockResolver implements AriesApplicationResolver {
1:     boolean returnAppContentNextTime = true;
1:     
1:     public Collection<ModelledResource> resolve(String appName, String appVersion,
1:         Collection<ModelledResource> byValueBundles, Collection<Content> inputs)
1:         throws ResolverException
1:     {
1:       if (_nextResults != null && !_nextResults.isEmpty()) { 
1:         Collection<ModelledResource> result = _nextResults.remove(0);
1:         return result;
1:       }
1:       Collection<ModelledResource> res = new ArrayList<ModelledResource>();
1:       if (returnAppContentNextTime) { 
1:         res.add(CAPABILITY_A.getBundle());
1:         res.add(CAPABILITY_B.getBundle());
1:       } 
1:       res.add(CAPABILITY_C.getBundle());
1:       res.add(CAPABILITY_E.getBundle());
1:       boolean addD = false;
1:       for(Content ib : inputs) {
0:         if(ib.getContentName().equals("com.ibm.test.d"))
1:           addD = true;
1:       }
1:       if(addD) {
1:         try {
0:           res.add(createModelledResource("com.ibm.test.d", "1.0.0", new ArrayList<String>(), new ArrayList<String>()));
1:         } catch (InvalidAttributeException e) {
1:           fail("Cannot resolve import for d");
1:         }
1:       }
1:       
1:       //  deployment manifest manager calls resolve() an extra time, providing
1:       // just the shared bundles. 
1:       // If we added D, then the next resolve will be one trying to winnow D out: 
1:       // AppContent should be returned in that one. We should not return app content
1:       // next time if we did so last time, unless we just added D
1:       returnAppContentNextTime = !returnAppContentNextTime || addD;
1:       return res;
1:     }
1:     
1:     List<Collection<ModelledResource>> _nextResults = null;
1:     
1:     //  Some tests want to override the default behaviour of the resolve() method
1:     public void addResult (Collection<ModelledResource> result) { 
1:       if (_nextResults == null) { 
1:         _nextResults = new ArrayList<Collection<ModelledResource>>();
1:       }
1:       _nextResults.add(result);
1:     }
1: 
1:     public BundleInfo getBundleInfo(String bundleSymbolicName, Version bundleVersion)
1:     {
1:       return null;
1:     }
1: 
1:     public Set<BundleInfo> resolve(AriesApplication app, ResolveConstraint... constraints)
1:         throws ResolverException
1:     {
1:       return null;
1:     }
1: 
1:     
1:   }
1:   
1:   static MockResolver _resolver = new MockResolver();
1: 
1:   static class DummyLocalPlatform implements LocalPlatform {
1:     public File getTemporaryDirectory() throws IOException {
1:       File f = File.createTempFile("ebaTmp", null);
1:       f.delete();
1:       f.mkdir();
1:       return f;
1:     } 
1:     public File getTemporaryFile () throws IOException { 
1:       // Not used
1:       return File.createTempFile("ebaTmp", null);
1:     }
1:   }
1:   static LocalPlatform localPlatform = new DummyLocalPlatform();
1:   @BeforeClass
1:   public static void classSetup() throws Exception
1:   {
1:     BundleContext bc = Skeleton.newMock(BundleContext.class);
1:     bc.registerService(AriesApplicationResolver.class.getName(), _resolver, new Hashtable<String, String>());
1:   }
1:   
1:   @AfterClass
1:   public static void afterClass() throws Exception { 
1:     BundleContextMock.clear();
1:   }
1:   
1:   @Before
1:   public void setup() throws Exception
1:   {
1:     appMetadata = Skeleton.newMock(ApplicationMetadata.class);
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(
0:         new MethodCall(ApplicationMetadata.class, "getApplicationSymbolicName"), "com.ibm.test");
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(
1:         new MethodCall(ApplicationMetadata.class, "getApplicationVersion"), new Version("1.0.0"));
1:     
1:     app = Skeleton.newMock(AriesApplication.class);
1:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:     
0:     sut = new DeploymentManifestManagerImpl();
0:     sut.setResolver(_resolver);
0:     sut.setLocalPlatform(localPlatform);
1:   }
1:   
1:   private static ExportedPackage CAPABILITY_A;
1:   private static ExportedPackage CAPABILITY_B;
1:   private static ExportedPackage CAPABILITY_C;
1:   private static ExportedPackage CAPABILITY_E;
1: 
1:   
1:   // use bundle
1:   private static Content BUNDLE_C;
1:   private static Content BUNDLE_D;
1:   
1:   
1: 
1:   public static ExportedPackage createExportedPackage (String bundleName, String bundleVersion, 
1:       String[] exportedPackages, String[] importedPackages ) throws InvalidAttributeException { 
1:     ModelledResource mb = createModelledResource(bundleName, bundleVersion,
1:         Arrays.asList(importedPackages) , Arrays.asList(exportedPackages));
1:     
0:    return mb.getExportedPackages().iterator().next();
1: 
1:   }
1:   static {
1:     try {
0:       CAPABILITY_A = createExportedPackage ("com.ibm.test.a", "1.0.0", new String[] {"com.ibm.test.a"}, 
0:           new String[] {"com.ibm.test.c"});
1:  
0:       CAPABILITY_B = createExportedPackage("com.ibm.test.b", "1.1.0", new String[] {"com.ibm.test.b"}, new String[] {"com.ibm.test.e"});
1:       
0:       BUNDLE_C = ManifestHeaderProcessor.parseContent("com.ibm.test.c","[1.0.0,1.1.0)");
1:       
0:       CAPABILITY_C = createExportedPackage("com.ibm.test.c", "1.0.5", new String[] {"com.ibm.test.c"}, new String[] {});
1:       
0:       BUNDLE_D = ManifestHeaderProcessor.parseContent("com.ibm.test.d","1.0.0");
1:       
0:      // = new ImportedBundleImpl("com.ibm.test.e", "1.0.0");
1:       
0:       CAPABILITY_E = createExportedPackage("com.ibm.test.e", "1.0.0", new String[] {"com.ibm.test.e"}, new String[] {});
1:       
1:     } catch (InvalidAttributeException iae) {
1:       throw new RuntimeException(iae);
1:     }
1:   }
1:   
1:   
1:   @Test
1:   public void testResolve() throws Exception
1:   {
1:     
0:     Skeleton.getSkeleton(appMetadata).setReturnValue(new MethodCall(ApplicationMetadata.class, "getApplicationContents"), Arrays.asList(mockContent("com.ibm.test.a", "1.0.0"), mockContent("com.ibm.test.b", "[1.0.0, 2.0.0)" )));
1:     
1:     app = Skeleton.newMock(AriesApplication.class);
1:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:     
0:     Manifest man = sut.generateDeploymentManifest(app, new ArrayList<ModelledResource>(), Arrays.asList(BUNDLE_C, BUNDLE_D), Collections.<Content>emptyList());
1:     
1:     Attributes attrs = man.getMainAttributes();
1:     
0:     assertEquals("com.ibm.test", attrs.getValue(AppConstants.APPLICATION_SYMBOLIC_NAME));
0:     assertEquals("1.0.0", (String)attrs.getValue(AppConstants.APPLICATION_VERSION));
1:     
0:     String content = (String)attrs.getValue(AppConstants.DEPLOYMENT_CONTENT);
0:     String useBundle = (String) attrs.getValue(AppConstants.DEPLOYMENT_USE_BUNDLE);
0:     String provisioned =(String)attrs.getValue(AppConstants.DEPLOYMENT_PROVISION_BUNDLE);
1:     
0:     assertTrue(content.contains("com.ibm.test.a;deployed-version=1.0.0"));
0:     assertTrue(content.contains("com.ibm.test.b;deployed-version=1.1.0"));
1:     
0:     assertTrue(useBundle.contains("com.ibm.test.c;deployed-version=1.0.5"));
0:     assertFalse(useBundle.contains("com.ibm.test.d"));
1:     
0:     assertTrue(provisioned.contains("com.ibm.test.e;deployed-version=1.0.0"));
1:   }
1:   
1:   @Test
1:   public void checkBasicCircularDependenciesDetected() throws Exception { 
1:     // Override Resolver behaviour. 
1:     //ImportedBundle isolated = new ImportedBundleImpl ("test.isolated" , "1.0.0"); 
1:     
1:     // When we resolve isolated, we're going to get another bundle which has a dependency on isolated. 
1:     Collection<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:     ExportedPackage testIsolatedPkg = createExportedPackage ("test.isolated", "1.0.0", 
1:         new String[] {"test.shared"}, new String[] {"test.isolated.pkg"});
1:     cmr.add (testIsolatedPkg.getBundle());
1:     
1:     ExportedPackage testSharedPkg = createExportedPackage ("test.shared", "1.0.0", 
1:         new String[] {"test.isolated.pkg"}, new String[] {"test.shared"});
1:     cmr.add (testSharedPkg.getBundle());
1:     _resolver.addResult(cmr);
1:     
1:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:     _resolver.addResult(cmr);
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(new MethodCall(ApplicationMetadata.class, "getApplicationContents"), Arrays.asList(mockContent("test.isolated" , "1.0.0")));
1:     
1:     
1:     try { 
1:       
0:       sut.generateDeploymentManifest(app, new ArrayList<ModelledResource>(), new ArrayList<Content>(), 
0:            Collections.<Content>emptyList());
1:     } catch (ResolverException rx) { 
1:       List<String> usr = rx.getUnsatisfiedRequirements();
1:       assertEquals ("One unsatisfied requirement expected, not " + usr.size(), usr.size(), 1);
1:       String chkMsg = "Shared bundle test.shared_1.0.0 has a dependency for package " +
0:       		"test.shared which is exported from isolated bundle [test.isolated_1.0.0]";
1:       assertTrue (chkMsg + " expected, not " + usr, usr.contains(chkMsg));
1:       return;
1:     }
1:     fail ("ResolverException expected");
1:   }
1:   
1:   /**
1:    * This method checks that the a more complicated circular dependency issues the correct error message
1:    * and checks that the details listed in the exception are correct. 
1:    * @throws Exception
1:    */
1:   @Test
1:   public void checkMultipleCircularDependenciesDetected() throws Exception { 
1:     
1:     Collection<ModelledResource> cmr = new ArrayList<ModelledResource>();
1:     ExportedPackage testIsolated1 = createExportedPackage ("test.isolated1", "1.0.0", 
1:         new String[] {"test.isolated1","test.isolated2"}, new String[] {"test.shared1", "test.shared2"});
1:     cmr.add (testIsolated1.getBundle());
1:     
1:     ExportedPackage testIsolated2 = createExportedPackage ("test.isolated2", "1.0.0", 
1:         new String[] {"test.isolated1","test.isolated2"}, new String[] {"test.shared1", "test.shared2"});
1:     cmr.add (testIsolated2.getBundle());
1:     
1:     ExportedPackage testShared1 = createExportedPackage ("test.shared1", "1.0.0", 
1:         new String[] {"test.shared1", "test.shared2"}, new String[] {"test.isolated1","test.isolated2"});
1:     cmr.add (testShared1.getBundle());
1:     
1:     ExportedPackage testShared2 = createExportedPackage ("test.shared2", "1.0.0", 
1:         new String[] {"test.shared1", "test.shared2"}, new String[] {"test.isolated1","test.isolated2"});
1:     cmr.add (testShared2.getBundle());
1:     
1:     _resolver.addResult(cmr);
1:     
1:     // The second time DeploymentGenerator calls the Resolver, it will provide just 
1:     // test.shared. The resolver will return test.shared _plus_ test.isolated. 
1:     _resolver.addResult(cmr);
1:     Skeleton.getSkeleton(appMetadata).setReturnValue(new MethodCall(ApplicationMetadata.class, "getApplicationContents"), Arrays.asList(mockContent("test.isolated1" , "1.0.0"), mockContent("test.isolated2" , "1.0.0")));
1:     
1:     app = Skeleton.newMock(AriesApplication.class);
1:     Skeleton.getSkeleton(app).setReturnValue(new MethodCall(AriesApplication.class, "getApplicationMetadata"), appMetadata);
1:     
1:     try {
0:            sut.generateDeploymentManifest(app, Arrays.asList(new ModelledResource[] {testIsolated1.getBundle(), testIsolated2.getBundle()}), new ArrayList<Content>(), Collections.<Content>emptyList());
1: 
1:     } catch (ResolverException rx) { 
1:       // Get the unsatisfied Requirements
1:       List<String> unsatisfiedReqs = rx.getUnsatisfiedRequirements();
1:       // Ensure we've got 4 unsatisfied Requirements
0:       assertEquals ("4 unsatisfied requirements expected, not " + unsatisfiedReqs.size(), unsatisfiedReqs.size(), 4);
1:       List<String> checkMessages = new ArrayList<String>();
1:       // Now load an array with the expected messages.
1:       checkMessages.add("Shared bundle test.shared1_1.0.0 has a dependency for package test.isolated1 which " +
0:       "is exported from isolated bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:       checkMessages.add("Shared bundle test.shared1_1.0.0 has a dependency for package test.isolated2 which " +
0:       "is exported from isolated bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:       checkMessages.add("Shared bundle test.shared2_1.0.0 has a dependency for package test.isolated1 which " +
0:       "is exported from isolated bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:       checkMessages.add("Shared bundle test.shared2_1.0.0 has a dependency for package test.isolated2 which " +
0:       "is exported from isolated bundles [test.isolated1_1.0.0, test.isolated2_1.0.0]");
1:       
1:       // Loop through the unsatisfied Requirements and compare them to the expected msgs. We trim the strings
1:       // because some unsatisfied reqs have spaces at the end of the string.
1:       for (String unsatisfiedReq : unsatisfiedReqs) {
1:         assertTrue(unsatisfiedReq + " is not an expected msg", checkMessages.contains(unsatisfiedReq.trim()));
1:       }
1:     }
1:   }
1:   
1:   public static ModelledResource createModelledResource(String bundleName, String bundleVersion, 
1:       Collection<String> importedPackages, Collection<String> exportedPackages) throws InvalidAttributeException {
1:     Attributes att = new Attributes();
1:     att.put(new Attributes.Name(Constants.BUNDLE_SYMBOLICNAME), bundleName);
1:     att.put(new Attributes.Name(Constants.BUNDLE_VERSION), bundleVersion);
1:     att.put(new Attributes.Name(Constants.BUNDLE_MANIFESTVERSION), "2");
1:     
1:     StringBuilder builder = new StringBuilder();
1:     for(String iPackage : importedPackages) {
1:       builder.append(iPackage).append(",");
1:     }
1:     if(builder.length() > 0) {
1:       builder.deleteCharAt(builder.length() - 1);
1:       att.put(new Attributes.Name(Constants.IMPORT_PACKAGE), builder.toString());
1:     }
1:     
1:     builder = new StringBuilder();
1:     for(String ePackage : exportedPackages) {
1:       builder.append(ePackage).append(",");
1:     }
1:     if(builder.length() > 0) {
1:       builder.deleteCharAt(builder.length() - 1);
1:       att.put(new Attributes.Name(Constants.EXPORT_PACKAGE), builder.toString());
1:     }
0:     return ModellingManager.getModelledResource(null, att, null, null);
1:   }
1:   
1:   private Content mockContent(String symbolicName, String version) {
1:     Content bundle = Skeleton.newMock(Content.class);
0:     VersionRange vr = Skeleton.newMock(VersionRange.class);
0:     Skeleton.getSkeleton(vr).setReturnValue(new MethodCall(VersionRange.class, "toString"), version);
1:     Skeleton.getSkeleton(bundle).setReturnValue(new MethodCall(Content.class, "getContentName"), symbolicName);
1:     Skeleton.getSkeleton(bundle).setReturnValue(new MethodCall(Content.class, "getVersion"), vr);
1:     
1:        return bundle;
1:   }
1: }
============================================================================