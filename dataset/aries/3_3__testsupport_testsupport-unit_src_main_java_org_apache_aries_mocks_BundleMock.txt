1:264011e: /*
1:264011e:  * Licensed to the Apache Software Foundation (ASF) under one
1:264011e:  * or more contributor license agreements.  See the NOTICE file
1:264011e:  * distributed with this work for additional information
1:264011e:  * regarding copyright ownership.  The ASF licenses this file
1:264011e:  * to you under the Apache License, Version 2.0 (the
1:264011e:  * "License"); you may not use this file except in compliance
1:264011e:  * with the License.  You may obtain a copy of the License at
1:264011e:  *
1:264011e:  *   http://www.apache.org/licenses/LICENSE-2.0
1:264011e:  *
1:264011e:  * Unless required by applicable law or agreed to in writing,
1:264011e:  * software distributed under the License is distributed on an
1:264011e:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:264011e:  * KIND, either express or implied.  See the License for the
1:264011e:  * specific language governing permissions and limitations
1:264011e:  * under the License.
1:264011e:  */
1:264011e: package org.apache.aries.mocks;
2:264011e: 
1:264011e: import java.io.File;
1:264011e: import java.io.FileFilter;
1:264011e: import java.io.IOException;
1:264011e: import java.net.MalformedURLException;
1:264011e: import java.net.URL;
1:264011e: import java.net.URLClassLoader;
1:264011e: import java.security.AccessController;
1:264011e: import java.security.PrivilegedAction;
1:264011e: import java.util.ArrayList;
1:264011e: import java.util.Arrays;
1:264011e: import java.util.Dictionary;
1:264011e: import java.util.Enumeration;
1:264011e: import java.util.List;
1:264011e: import java.util.Vector;
1:264011e: import java.util.regex.Pattern;
1:264011e: 
1:264011e: import junit.framework.AssertionFailedError;
1:264011e: 
1:264011e: import org.apache.aries.unittest.mocks.MethodCall;
1:264011e: import org.apache.aries.unittest.mocks.MethodCallHandler;
1:264011e: import org.apache.aries.unittest.mocks.Skeleton;
1:264011e: import org.apache.aries.unittest.mocks.annotations.Singleton;
1:29c4662: import org.osgi.framework.Bundle;
1:29c4662: import org.osgi.framework.BundleContext;
1:29c4662: import org.osgi.framework.BundleReference;
1:29c4662: import org.osgi.framework.Constants;
1:29c4662: import org.osgi.framework.InvalidSyntaxException;
1:29c4662: import org.osgi.framework.ServiceReference;
1:29c4662: import org.osgi.framework.Version;
1:264011e: 
1:264011e: @Singleton
1:264011e: public class BundleMock
1:264011e: {
1:264011e:   private final String symbolicName;
1:264011e:   private final Dictionary<?, ?> headers;
1:264011e:   private final BundleContext bc;
1:264011e:   private String location;
1:264011e:   private BundleClassLoader cl;
1:264011e:   
1:264011e:   private class BundleClassLoader extends URLClassLoader implements BundleReference
1:264011e:   {
1:264011e:     List<Bundle> otherBundlesToCheck = new ArrayList<Bundle>();
1:264011e:     
1:264011e:     public BundleClassLoader(URL[] urls)
1:264011e:     {
1:264011e:       super(urls);
1:264011e:     }
1:264011e: 
1:264011e:     public BundleClassLoader(URL[] urls, ClassLoader parent)
1:264011e:     {
1:264011e:       super(urls, parent);
1:264011e:     }
1:264011e:     
1:264011e:     public void addBundle(Bundle ... otherBundles)
1:264011e:     {
1:264011e:       otherBundlesToCheck.addAll(Arrays.asList(otherBundles));
1:264011e:     }
1:264011e:     
1:264011e:     public Bundle[] getBundles()
1:264011e:     {
1:264011e:       return otherBundlesToCheck.toArray(new Bundle[otherBundlesToCheck.size()]);
1:264011e:     }
1:264011e: 
1:264011e:     @Override
1:264011e:     protected Class<?> findClass(String name) throws ClassNotFoundException
1:264011e:     {
1:264011e:       Class<?> result = null;
1:264011e:       for (Bundle b : otherBundlesToCheck) {
1:264011e:         try {
1:264011e:           result = b.loadClass(name);
1:264011e:         } catch (ClassNotFoundException e) {
1:264011e:           // do nothing here.
1:264011e:         }
1:264011e:         
1:264011e:         if (result != null) return result;
1:264011e:       }
1:264011e:       
1:264011e:       return super.findClass(name);
1:264011e:     }
1:264011e: 
1:264011e:     public Bundle getBundle()
1:264011e:     {
1:264011e:       return Skeleton.newMock(BundleMock.this, Bundle.class);
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   public BundleMock(String name, Dictionary<?, ?> bundleHeaders)
1:264011e:   {
1:264011e:     symbolicName = name;
1:264011e:     headers = bundleHeaders;
1:264011e:     bc = Skeleton.newMock(new BundleContextMock(Skeleton.newMock(this, Bundle.class)), BundleContext.class);
1:264011e:     
1:264011e:     cl = AccessController.doPrivileged(new PrivilegedAction<BundleClassLoader>() {
1:264011e: 
1:264011e:       public BundleClassLoader run()
1:264011e:       {
1:264011e:         return new BundleClassLoader(new URL[0], this.getClass().getClassLoader());
1:264011e:       }
1:264011e:     });
1:264011e:   }
1:264011e:   
1:264011e:   public BundleMock(String name, Dictionary<?,?> bundleHeaders, boolean dummy)
1:264011e:   {
1:264011e:     this(name, bundleHeaders);
1:264011e:     
1:264011e:     cl = null;
1:264011e:   }
1:264011e:   
1:264011e:   public BundleMock(String name, Dictionary<?, ?> bundleHeaders, String location)
1:264011e:   {
1:264011e:     this(name, bundleHeaders);
1:264011e:     this.location = location;
1:264011e:         
1:264011e:     if (location != null) {
1:264011e:       String cp = (String)bundleHeaders.get(Constants.BUNDLE_CLASSPATH);
1:264011e:       
1:264011e:       if (cp == null) cp = ".";
1:264011e:       
1:264011e:       String[] cpEntries = cp.split(",");
1:264011e:       
1:264011e:       final List<URL> urls = new ArrayList<URL>();
1:264011e:       
1:264011e:       try {
1:264011e:         for (String cpEntry : cpEntries) {
1:264011e:           if (".".equals(cpEntry.trim())) {
1:264011e:             urls.add(new URL(location));
1:264011e:           } else {
1:264011e:             urls.add(new URL(location + "/" + cpEntry));
1:264011e:           }
1:264011e:         }
1:264011e:         
1:264011e:         cl = AccessController.doPrivileged(new PrivilegedAction<BundleClassLoader>() {
1:264011e:           public BundleClassLoader run()
1:264011e:           {
1:264011e:             return new BundleClassLoader(urls.toArray(new URL[urls.size()]));
1:264011e:           }
1:264011e:         });
1:264011e:       } catch (MalformedURLException e) {
1:264011e:         Error err = new AssertionFailedError("The location was not a valid url");
1:264011e:         err.initCause(e);
1:264011e:         throw err;
1:264011e:       }
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   private static class PrivateDataFileHandler implements MethodCallHandler
1:264011e:   {
1:264011e:     private final File location;
1:264011e:     
1:264011e:     public PrivateDataFileHandler(File f)
1:264011e:     {
1:264011e:       this.location = f;
1:264011e:     }
1:264011e:     
1:264011e:     public Object handle(MethodCall call, Skeleton parent)
1:264011e:     {
1:264011e:       File privateStorage = new File(location.getAbsolutePath(), "_private");
1:264011e:       if (!!!privateStorage.exists())
1:264011e:         privateStorage.mkdirs();
1:264011e:       
1:264011e:       return new File(privateStorage, (String) call.getArguments()[0]);
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   public BundleMock(String name, Dictionary<?, ?> properties, File location) throws Exception
1:264011e:   {
1:264011e:     this(name,properties,location.toURL().toExternalForm());
1:264011e:     
1:264011e:     Skeleton bcSkel = Skeleton.getSkeleton(bc);
1:264011e:     bcSkel.registerMethodCallHandler(
1:264011e:         new MethodCall(BundleContext.class,"getDataFile", new Object[] { String.class }),
1:264011e:         new PrivateDataFileHandler(location)
1:264011e:     );
1:264011e:   }
1:264011e:   
1:264011e:   public String getSymbolicName()
1:264011e:   {
1:264011e:     return symbolicName;
1:264011e:   }
1:264011e:   
1:264011e:   public Dictionary<?, ?> getHeaders()
1:264011e:   {
1:264011e:     return headers;
1:264011e:   }
1:264011e:   
1:264011e:   public Enumeration<URL> findEntries(String baseDir, String matchRule, boolean recurse)
1:264011e:   {
1:264011e:     System.err.println("findEntries: " + baseDir + ", " + matchRule + ", " + recurse);
1:264011e:     File base;
1:264011e:     try {
1:264011e:       base = new File(new File(new URL(location.replaceAll(" ", "%20")).toURI()), baseDir);
1:264011e:       System.err.println("Base dir: " + base);
1:264011e:     } catch (Exception e) {
1:264011e:       Error err = new AssertionFailedError("Unable to findEntries from " + location);
1:264011e:       err.initCause(e);
1:264011e:       throw err;
1:264011e:     }
1:264011e:     
1:264011e:     if (matchRule.equals("*.xml")) matchRule = ".*\\.xml";
1:264011e:     else matchRule = matchRule.replaceAll("\\*", ".*");
1:264011e:     
1:264011e:     System.err.println("matchrule: " + matchRule);
1:264011e:     
1:264011e:     final Pattern p = Pattern.compile(matchRule);
1:264011e:     
1:264011e:     File[] files = base.listFiles(new FileFilter(){
1:264011e:       public boolean accept(File pathname)
1:264011e:       {
1:264011e:         return pathname.isFile() &&
1:264011e:                p.matcher(pathname.getName()).matches();
1:264011e:       }
1:264011e:     });
1:264011e:     
1:264011e:     Vector<URL> v = new Vector<URL>();
1:264011e:     
1:264011e:     if (files != null) {
1:264011e:       for (File f : files) {
1:264011e:         try {
1:264011e:           v.add(f.toURL());
1:264011e:         } catch (MalformedURLException e) {
1:264011e:           // TODO Auto-generated catch block
1:264011e:           e.printStackTrace();
1:264011e:         }
1:264011e:       }
1:264011e:     } else {
1:264011e:       System.err.println("no matching files");
1:264011e:     }
1:264011e:     
1:264011e:     if (v.isEmpty()) {
1:264011e:       return null;
1:264011e:     } else {
1:264011e:       System.err.println(v);
1:264011e:       return v.elements();
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   public URL getResource(String name)
1:264011e:   {
1:264011e:     if (cl != null) return cl.getResource(name);
1:264011e:     
1:264011e:     try {
1:264011e:       File f = new File(name);
1:264011e:       if(f.exists() || "Entities.jar".equals(name)) return f.toURL();
1:264011e:       else return null;
1:264011e:     } catch (MalformedURLException e) {
1:264011e:       Error err = new AssertionFailedError("The resource " + name + " could not be found.");
1:264011e:       err.initCause(e);
1:264011e:       throw err;
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   public Enumeration<URL> getResources(String name)
1:264011e:   {
1:264011e:     if (cl != null)
1:264011e:     {
1:264011e:       try {
1:264011e:         return cl.getResources(name);
1:264011e:       } catch (IOException e) {
1:264011e:       // TODO Auto-generated catch block
1:264011e:         e.printStackTrace();
1:264011e:       }
1:264011e:     }
1:264011e:     else {
1:264011e:       final URL resource = getResource(name);
1:264011e:       
1:264011e:       if(resource != null) {
1:264011e:         return new Enumeration<URL>() {
1:264011e: 
1:264011e:           boolean hasMore = true;
1:264011e:           public boolean hasMoreElements()
1:264011e:           {
1:264011e:             return hasMore;
1:264011e:           }
1:264011e: 
1:264011e:           public URL nextElement()
1:264011e:           {
1:264011e:             hasMore = false;
1:264011e:             return resource;
1:264011e:           }
1:264011e:           
1:264011e:         };
1:264011e:       }
1:264011e:     }
1:264011e:     return new Enumeration<URL>(){
1:264011e:       public URL nextElement()
1:264011e:       {
1:264011e:         return null;
1:264011e:       }
1:264011e: 
1:264011e:       public boolean hasMoreElements()
1:264011e:       {
1:264011e:         return false;
1:264011e:       }
1:264011e:     };
1:264011e:     
1:264011e:   }
1:264011e:   
1:264011e:   public Class<?> loadClass(String name) throws ClassNotFoundException
1:264011e:   {
1:264011e:     if (cl != null) return Class.forName(name, false, cl);
1:264011e:     
1:264011e:     throw new ClassNotFoundException("Argh, things went horribly wrong trying to load " + name);
1:264011e:   }
1:264011e:   
1:264011e:   public String getLocation()
1:264011e:   {
1:264011e:     try {
1:264011e:       return (location == null) ? new File(symbolicName + ".jar").toURL().toString() : location;
1:264011e:     } catch (MalformedURLException e) {
1:264011e:       Error err = new AssertionFailedError("We could not generate a valid url for the bundle");
1:264011e:       err.initCause(e);
1:264011e:       throw err;
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   public BundleContext getBundleContext()
1:264011e:   {
1:264011e:     return bc;
1:264011e:   }
1:264011e: 
1:264011e:   public Version getVersion()
1:264011e:   {
1:264011e:     String res = (String) headers.get("Bundle-Version");
1:264011e:     if (res != null)
1:264011e:       return new Version(res);
1:264011e:     else
1:264011e:       return new Version("0.0.0");
1:264011e:   }
1:264011e:   
1:264011e:   public int getState()
1:264011e:   {
1:264011e:     return Bundle.ACTIVE;
1:264011e:   }
1:264011e: 
1:264011e:   public void addToClassPath(URL ... urls)
1:264011e:   {
1:264011e:     if (cl != null) {
1:264011e:       URL[] existingURLs = cl.getURLs();
1:264011e:       final URL[] mergedURLs = new URL[urls.length + existingURLs.length];
1:264011e:       int i = 0;
1:264011e:       for (; i < existingURLs.length; i++) {
1:264011e:         mergedURLs[i] = existingURLs[i];
1:264011e:       }
1:264011e:       
1:264011e:       for (int j = 0; j < urls.length; j++, i++) {
1:264011e:         mergedURLs[i] = urls[j];
1:264011e:       }
1:264011e:       
1:264011e:       BundleClassLoader newCl = AccessController.doPrivileged(new PrivilegedAction<BundleClassLoader>() {
1:264011e: 
1:264011e:         public BundleClassLoader run()
1:264011e:         {
1:264011e:           return new BundleClassLoader(mergedURLs, cl.getParent());
1:264011e:         }
1:264011e:         
1:264011e:       });
1:264011e:       newCl.addBundle(cl.getBundles());
1:264011e:       cl = newCl;
1:264011e:     }
1:264011e:   }
1:264011e:     
1:264011e:   public void addBundleToClassPath(Bundle ... bundles) {
1:264011e:     if (cl != null) {
1:264011e:       cl.addBundle(bundles);
1:264011e:     }
1:264011e:   }
1:264011e: 
1:264011e:   public ClassLoader getClassLoader()
1:264011e:   {
1:264011e:     return cl;
1:264011e:   }
1:29c4662:   
1:29c4662:   // This is good enough for Mocks' needs in unit test, but isn't how it works in the real world!
1:29c4662:   public ServiceReference[] getRegisteredServices() 
1:29c4662:   {
1:29c4662:     ServiceReference[] result = null;
1:29c4662:     try { 
1:7fd4794:       result = bc.getServiceReferences((String) null, null);
1:29c4662:     } catch (InvalidSyntaxException isx) { 
1:29c4662:       // no-op: Swallow exception
1:29c4662:     }
1:29c4662:     return result;
1:29c4662:   }
57:4e2fb0c: }
============================================================================
author:Jean-Baptiste Onofre
-------------------------------------------------------------------------------
commit:7fd4794
/////////////////////////////////////////////////////////////////////////
1:       result = bc.getServiceReferences((String) null, null);
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:29c4662
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleReference;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.framework.Version;
/////////////////////////////////////////////////////////////////////////
1:   
1:   // This is good enough for Mocks' needs in unit test, but isn't how it works in the real world!
1:   public ServiceReference[] getRegisteredServices() 
1:   {
1:     ServiceReference[] result = null;
1:     try { 
0:       result = bc.getServiceReferences(null, null);
1:     } catch (InvalidSyntaxException isx) { 
1:       // no-op: Swallow exception
1:     }
1:     return result;
1:   }
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:264011e
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.mocks;
1: 
1: import java.io.File;
1: import java.io.FileFilter;
1: import java.io.IOException;
1: import java.net.MalformedURLException;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.List;
1: import java.util.Vector;
1: import java.util.regex.Pattern;
1: 
1: import junit.framework.AssertionFailedError;
1: 
0: import org.osgi.framework.Bundle;
0: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.BundleReference;
0: import org.osgi.framework.Constants;
0: import org.osgi.framework.Version;
1: 
1: import org.apache.aries.unittest.mocks.MethodCall;
1: import org.apache.aries.unittest.mocks.MethodCallHandler;
1: import org.apache.aries.unittest.mocks.Skeleton;
1: import org.apache.aries.unittest.mocks.annotations.Singleton;
1: 
1: @Singleton
1: public class BundleMock
1: {
1:   private final String symbolicName;
1:   private final Dictionary<?, ?> headers;
1:   private final BundleContext bc;
1:   private String location;
1:   private BundleClassLoader cl;
1:   
1:   private class BundleClassLoader extends URLClassLoader implements BundleReference
1:   {
1:     List<Bundle> otherBundlesToCheck = new ArrayList<Bundle>();
1:     
1:     public BundleClassLoader(URL[] urls)
1:     {
1:       super(urls);
1:     }
1: 
1:     public BundleClassLoader(URL[] urls, ClassLoader parent)
1:     {
1:       super(urls, parent);
1:     }
1:     
1:     public void addBundle(Bundle ... otherBundles)
1:     {
1:       otherBundlesToCheck.addAll(Arrays.asList(otherBundles));
1:     }
1:     
1:     public Bundle[] getBundles()
1:     {
1:       return otherBundlesToCheck.toArray(new Bundle[otherBundlesToCheck.size()]);
1:     }
1: 
1:     @Override
1:     protected Class<?> findClass(String name) throws ClassNotFoundException
1:     {
1:       Class<?> result = null;
1:       for (Bundle b : otherBundlesToCheck) {
1:         try {
1:           result = b.loadClass(name);
1:         } catch (ClassNotFoundException e) {
1:           // do nothing here.
1:         }
1:         
1:         if (result != null) return result;
1:       }
1:       
1:       return super.findClass(name);
1:     }
1: 
1:     public Bundle getBundle()
1:     {
1:       return Skeleton.newMock(BundleMock.this, Bundle.class);
1:     }
1:   }
1:   
1:   public BundleMock(String name, Dictionary<?, ?> bundleHeaders)
1:   {
1:     symbolicName = name;
1:     headers = bundleHeaders;
1:     bc = Skeleton.newMock(new BundleContextMock(Skeleton.newMock(this, Bundle.class)), BundleContext.class);
1:     
1:     cl = AccessController.doPrivileged(new PrivilegedAction<BundleClassLoader>() {
1: 
1:       public BundleClassLoader run()
1:       {
1:         return new BundleClassLoader(new URL[0], this.getClass().getClassLoader());
1:       }
1:     });
1:   }
1:   
1:   public BundleMock(String name, Dictionary<?,?> bundleHeaders, boolean dummy)
1:   {
1:     this(name, bundleHeaders);
1:     
1:     cl = null;
1:   }
1:   
1:   public BundleMock(String name, Dictionary<?, ?> bundleHeaders, String location)
1:   {
1:     this(name, bundleHeaders);
1:     this.location = location;
1:         
1:     if (location != null) {
1:       String cp = (String)bundleHeaders.get(Constants.BUNDLE_CLASSPATH);
1:       
1:       if (cp == null) cp = ".";
1:       
1:       String[] cpEntries = cp.split(",");
1:       
1:       final List<URL> urls = new ArrayList<URL>();
1:       
1:       try {
1:         for (String cpEntry : cpEntries) {
1:           if (".".equals(cpEntry.trim())) {
1:             urls.add(new URL(location));
1:           } else {
1:             urls.add(new URL(location + "/" + cpEntry));
1:           }
1:         }
1:         
1:         cl = AccessController.doPrivileged(new PrivilegedAction<BundleClassLoader>() {
1:           public BundleClassLoader run()
1:           {
1:             return new BundleClassLoader(urls.toArray(new URL[urls.size()]));
1:           }
1:         });
1:       } catch (MalformedURLException e) {
1:         Error err = new AssertionFailedError("The location was not a valid url");
1:         err.initCause(e);
1:         throw err;
1:       }
1:     }
1:   }
1:   
1:   private static class PrivateDataFileHandler implements MethodCallHandler
1:   {
1:     private final File location;
1:     
1:     public PrivateDataFileHandler(File f)
1:     {
1:       this.location = f;
1:     }
1:     
1:     public Object handle(MethodCall call, Skeleton parent)
1:     {
1:       File privateStorage = new File(location.getAbsolutePath(), "_private");
1:       if (!!!privateStorage.exists())
1:         privateStorage.mkdirs();
1:       
1:       return new File(privateStorage, (String) call.getArguments()[0]);
1:     }
1:   }
1:   
1:   public BundleMock(String name, Dictionary<?, ?> properties, File location) throws Exception
1:   {
1:     this(name,properties,location.toURL().toExternalForm());
1:     
1:     Skeleton bcSkel = Skeleton.getSkeleton(bc);
1:     bcSkel.registerMethodCallHandler(
1:         new MethodCall(BundleContext.class,"getDataFile", new Object[] { String.class }),
1:         new PrivateDataFileHandler(location)
1:     );
1:   }
1:   
1:   public String getSymbolicName()
1:   {
1:     return symbolicName;
1:   }
1:   
1:   public Dictionary<?, ?> getHeaders()
1:   {
1:     return headers;
1:   }
1:   
1:   public Enumeration<URL> findEntries(String baseDir, String matchRule, boolean recurse)
1:   {
1:     System.err.println("findEntries: " + baseDir + ", " + matchRule + ", " + recurse);
1:     File base;
1:     try {
1:       base = new File(new File(new URL(location.replaceAll(" ", "%20")).toURI()), baseDir);
1:       System.err.println("Base dir: " + base);
1:     } catch (Exception e) {
1:       Error err = new AssertionFailedError("Unable to findEntries from " + location);
1:       err.initCause(e);
1:       throw err;
1:     }
1:     
1:     if (matchRule.equals("*.xml")) matchRule = ".*\\.xml";
1:     else matchRule = matchRule.replaceAll("\\*", ".*");
1:     
1:     System.err.println("matchrule: " + matchRule);
1:     
1:     final Pattern p = Pattern.compile(matchRule);
1:     
1:     File[] files = base.listFiles(new FileFilter(){
1:       public boolean accept(File pathname)
1:       {
1:         return pathname.isFile() &&
1:                p.matcher(pathname.getName()).matches();
1:       }
1:     });
1:     
1:     Vector<URL> v = new Vector<URL>();
1:     
1:     if (files != null) {
1:       for (File f : files) {
1:         try {
1:           v.add(f.toURL());
1:         } catch (MalformedURLException e) {
1:           // TODO Auto-generated catch block
1:           e.printStackTrace();
1:         }
1:       }
1:     } else {
1:       System.err.println("no matching files");
1:     }
1:     
1:     if (v.isEmpty()) {
1:       return null;
1:     } else {
1:       System.err.println(v);
1:       return v.elements();
1:     }
1:   }
1:   
1:   public URL getResource(String name)
1:   {
1:     if (cl != null) return cl.getResource(name);
1:     
1:     try {
1:       File f = new File(name);
1:       if(f.exists() || "Entities.jar".equals(name)) return f.toURL();
1:       else return null;
1:     } catch (MalformedURLException e) {
1:       Error err = new AssertionFailedError("The resource " + name + " could not be found.");
1:       err.initCause(e);
1:       throw err;
1:     }
1:   }
1:   
1:   public Enumeration<URL> getResources(String name)
1:   {
1:     if (cl != null)
1:     {
1:       try {
1:         return cl.getResources(name);
1:       } catch (IOException e) {
1:       // TODO Auto-generated catch block
1:         e.printStackTrace();
1:       }
1:     }
1:     else {
1:       final URL resource = getResource(name);
1:       
1:       if(resource != null) {
1:         return new Enumeration<URL>() {
1: 
1:           boolean hasMore = true;
1:           public boolean hasMoreElements()
1:           {
1:             return hasMore;
1:           }
1: 
1:           public URL nextElement()
1:           {
1:             hasMore = false;
1:             return resource;
1:           }
1:           
1:         };
1:       }
1:     }
1:     return new Enumeration<URL>(){
1:       public URL nextElement()
1:       {
1:         return null;
1:       }
1: 
1:       public boolean hasMoreElements()
1:       {
1:         return false;
1:       }
1:     };
1:     
1:   }
1:   
1:   public Class<?> loadClass(String name) throws ClassNotFoundException
1:   {
1:     if (cl != null) return Class.forName(name, false, cl);
1:     
1:     throw new ClassNotFoundException("Argh, things went horribly wrong trying to load " + name);
1:   }
1:   
1:   public String getLocation()
1:   {
1:     try {
1:       return (location == null) ? new File(symbolicName + ".jar").toURL().toString() : location;
1:     } catch (MalformedURLException e) {
1:       Error err = new AssertionFailedError("We could not generate a valid url for the bundle");
1:       err.initCause(e);
1:       throw err;
1:     }
1:   }
1:   
1:   public BundleContext getBundleContext()
1:   {
1:     return bc;
1:   }
1: 
1:   public Version getVersion()
1:   {
1:     String res = (String) headers.get("Bundle-Version");
1:     if (res != null)
1:       return new Version(res);
1:     else
1:       return new Version("0.0.0");
1:   }
1:   
1:   public int getState()
1:   {
1:     return Bundle.ACTIVE;
1:   }
1: 
1:   public void addToClassPath(URL ... urls)
1:   {
1:     if (cl != null) {
1:       URL[] existingURLs = cl.getURLs();
1:       final URL[] mergedURLs = new URL[urls.length + existingURLs.length];
1:       int i = 0;
1:       for (; i < existingURLs.length; i++) {
1:         mergedURLs[i] = existingURLs[i];
1:       }
1:       
1:       for (int j = 0; j < urls.length; j++, i++) {
1:         mergedURLs[i] = urls[j];
1:       }
1:       
1:       BundleClassLoader newCl = AccessController.doPrivileged(new PrivilegedAction<BundleClassLoader>() {
1: 
1:         public BundleClassLoader run()
1:         {
1:           return new BundleClassLoader(mergedURLs, cl.getParent());
1:         }
1:         
1:       });
1:       newCl.addBundle(cl.getBundles());
1:       cl = newCl;
1:     }
1:   }
1:     
1:   public void addBundleToClassPath(Bundle ... bundles) {
1:     if (cl != null) {
1:       cl.addBundle(bundles);
1:     }
1:   }
1: 
1:   public ClassLoader getClassLoader()
1:   {
1:     return cl;
1:   }
commit:4e2fb0c
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.mocks;
0: 
0: import java.io.File;
0: import java.io.FileFilter;
0: import java.io.IOException;
0: import java.net.MalformedURLException;
0: import java.net.URL;
0: import java.net.URLClassLoader;
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.Dictionary;
0: import java.util.Enumeration;
0: import java.util.List;
0: import java.util.Vector;
0: import java.util.regex.Pattern;
0: 
0: import junit.framework.AssertionFailedError;
0: 
0: import org.osgi.framework.Bundle;
0: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.BundleReference;
0: import org.osgi.framework.Constants;
0: import org.osgi.framework.Version;
0: 
0: import org.apache.aries.unittest.mocks.MethodCall;
0: import org.apache.aries.unittest.mocks.MethodCallHandler;
0: import org.apache.aries.unittest.mocks.Skeleton;
0: import org.apache.aries.unittest.mocks.annotations.Singleton;
0: 
0: @Singleton
0: public class BundleMock
0: {
0:   private final String symbolicName;
0:   private final Dictionary<?, ?> headers;
0:   private final BundleContext bc;
0:   private String location;
0:   private BundleClassLoader cl;
0:   
0:   private class BundleClassLoader extends URLClassLoader implements BundleReference
0:   {
0:     List<Bundle> otherBundlesToCheck = new ArrayList<Bundle>();
0:     
0:     public BundleClassLoader(URL[] urls)
0:     {
0:       super(urls);
1:     }
0: 
0:     public BundleClassLoader(URL[] urls, ClassLoader parent)
0:     {
0:       super(urls, parent);
1:     }
0:     
0:     public void addBundle(Bundle ... otherBundles)
0:     {
0:       otherBundlesToCheck.addAll(Arrays.asList(otherBundles));
1:     }
0:     
0:     public Bundle[] getBundles()
0:     {
0:       return otherBundlesToCheck.toArray(new Bundle[otherBundlesToCheck.size()]);
1:     }
0: 
0:     @Override
0:     protected Class<?> findClass(String name) throws ClassNotFoundException
0:     {
0:       Class<?> result = null;
0:       for (Bundle b : otherBundlesToCheck) {
0:         try {
0:           result = b.loadClass(name);
0:         } catch (ClassNotFoundException e) {
0:           // do nothing here.
1:         }
0:         
0:         if (result != null) return result;
1:       }
0:       
0:       return super.findClass(name);
1:     }
0: 
0:     public Bundle getBundle()
0:     {
0:       return Skeleton.newMock(BundleMock.this, Bundle.class);
1:     }
1:   }
0:   
0:   public BundleMock(String name, Dictionary<?, ?> bundleHeaders)
0:   {
0:     symbolicName = name;
0:     headers = bundleHeaders;
0:     bc = Skeleton.newMock(new BundleContextMock(Skeleton.newMock(this, Bundle.class)), BundleContext.class);
0:     
0:     cl = AccessController.doPrivileged(new PrivilegedAction<BundleClassLoader>() {
0: 
0:       public BundleClassLoader run()
0:       {
0:         return new BundleClassLoader(new URL[0], this.getClass().getClassLoader());
1:       }
0:     });
1:   }
0:   
0:   public BundleMock(String name, Dictionary<?,?> bundleHeaders, boolean dummy)
0:   {
0:     this(name, bundleHeaders);
0:     
0:     cl = null;
1:   }
0:   
0:   public BundleMock(String name, Dictionary<?, ?> bundleHeaders, String location)
0:   {
0:     this(name, bundleHeaders);
0:     this.location = location;
0:         
0:     if (location != null) {
0:       String cp = (String)bundleHeaders.get(Constants.BUNDLE_CLASSPATH);
0:       
0:       if (cp == null) cp = ".";
0:       
0:       String[] cpEntries = cp.split(",");
0:       
0:       final List<URL> urls = new ArrayList<URL>();
0:       
0:       try {
0:         for (String cpEntry : cpEntries) {
0:           if (".".equals(cpEntry.trim())) {
0:             urls.add(new URL(location));
0:           } else {
0:             urls.add(new URL(location + "/" + cpEntry));
1:           }
1:         }
0:         
0:         cl = AccessController.doPrivileged(new PrivilegedAction<BundleClassLoader>() {
0:           public BundleClassLoader run()
0:           {
0:             return new BundleClassLoader(urls.toArray(new URL[urls.size()]));
1:           }
0:         });
0:       } catch (MalformedURLException e) {
0:         Error err = new AssertionFailedError("The location was not a valid url");
0:         err.initCause(e);
0:         throw err;
1:       }
1:     }
1:   }
0:   
0:   private static class PrivateDataFileHandler implements MethodCallHandler
0:   {
0:     private final File location;
0:     
0:     public PrivateDataFileHandler(File f)
0:     {
0:       this.location = f;
1:     }
0:     
0:     public Object handle(MethodCall call, Skeleton parent)
0:     {
0:       File privateStorage = new File(location.getAbsolutePath(), "_private");
0:       if (!!!privateStorage.exists())
0:         privateStorage.mkdirs();
0:       
0:       return new File(privateStorage, (String) call.getArguments()[0]);
1:     }
1:   }
0:   
0:   public BundleMock(String name, Dictionary<?, ?> properties, File location) throws Exception
0:   {
0:     this(name,properties,location.toURL().toExternalForm());
0:     
0:     Skeleton bcSkel = Skeleton.getSkeleton(bc);
0:     bcSkel.registerMethodCallHandler(
0:         new MethodCall(BundleContext.class,"getDataFile", new Object[] { String.class }),
0:         new PrivateDataFileHandler(location)
0:     );
1:   }
0:   
0:   public String getSymbolicName()
0:   {
0:     return symbolicName;
1:   }
0:   
0:   public Dictionary<?, ?> getHeaders()
0:   {
0:     return headers;
1:   }
0:   
0:   public Enumeration<URL> findEntries(String baseDir, String matchRule, boolean recurse)
0:   {
0:     System.err.println("findEntries: " + baseDir + ", " + matchRule + ", " + recurse);
0:     File base;
0:     try {
0:       base = new File(new File(new URL(location.replaceAll(" ", "%20")).toURI()), baseDir);
0:       System.err.println("Base dir: " + base);
0:     } catch (Exception e) {
0:       Error err = new AssertionFailedError("Unable to findEntries from " + location);
0:       err.initCause(e);
0:       throw err;
1:     }
0:     
0:     if (matchRule.equals("*.xml")) matchRule = ".*\\.xml";
0:     else matchRule = matchRule.replaceAll("\\*", ".*");
0:     
0:     System.err.println("matchrule: " + matchRule);
0:     
0:     final Pattern p = Pattern.compile(matchRule);
0:     
0:     File[] files = base.listFiles(new FileFilter(){
0:       public boolean accept(File pathname)
0:       {
0:         return pathname.isFile() &&
0:                p.matcher(pathname.getName()).matches();
1:       }
0:     });
0:     
0:     Vector<URL> v = new Vector<URL>();
0:     
0:     if (files != null) {
0:       for (File f : files) {
0:         try {
0:           v.add(f.toURL());
0:         } catch (MalformedURLException e) {
0:           // TODO Auto-generated catch block
0:           e.printStackTrace();
1:         }
1:       }
0:     } else {
0:       System.err.println("no matching files");
1:     }
0:     
0:     if (v.isEmpty()) {
0:       return null;
0:     } else {
0:       System.err.println(v);
0:       return v.elements();
1:     }
1:   }
0:   
0:   public URL getResource(String name)
0:   {
0:     if (cl != null) return cl.getResource(name);
0:     
0:     try {
0:       File f = new File(name);
0:       if(f.exists() || "Entities.jar".equals(name)) return f.toURL();
0:       else return null;
0:     } catch (MalformedURLException e) {
0:       Error err = new AssertionFailedError("The resource " + name + " could not be found.");
0:       err.initCause(e);
0:       throw err;
1:     }
1:   }
0:   
0:   public Enumeration<URL> getResources(String name)
0:   {
0:     if (cl != null)
0:     {
0:       try {
0:         return cl.getResources(name);
0:       } catch (IOException e) {
0:       // TODO Auto-generated catch block
0:         e.printStackTrace();
1:       }
1:     }
0:     else {
0:       final URL resource = getResource(name);
0:       
0:       if(resource != null) {
0:         return new Enumeration<URL>() {
0: 
0:           boolean hasMore = true;
0:           public boolean hasMoreElements()
0:           {
0:             return hasMore;
1:           }
0: 
0:           public URL nextElement()
0:           {
0:             hasMore = false;
0:             return resource;
1:           }
0:           
0:         };
1:       }
1:     }
0:     return new Enumeration<URL>(){
0:       public URL nextElement()
0:       {
0:         return null;
1:       }
0: 
0:       public boolean hasMoreElements()
0:       {
0:         return false;
1:       }
0:     };
0:     
1:   }
0:   
0:   public Class<?> loadClass(String name) throws ClassNotFoundException
0:   {
0:     if (cl != null) return Class.forName(name, false, cl);
0:     
0:     throw new ClassNotFoundException("Argh, things went horribly wrong trying to load " + name);
1:   }
0:   
0:   public String getLocation()
0:   {
0:     try {
0:       return (location == null) ? new File(symbolicName + ".jar").toURL().toString() : location;
0:     } catch (MalformedURLException e) {
0:       Error err = new AssertionFailedError("We could not generate a valid url for the bundle");
0:       err.initCause(e);
0:       throw err;
1:     }
1:   }
0:   
0:   public BundleContext getBundleContext()
0:   {
0:     return bc;
1:   }
0: 
0:   public Version getVersion()
0:   {
0:     String res = (String) headers.get("Bundle-Version");
0:     if (res != null)
0:       return new Version(res);
0:     else
0:       return new Version("0.0.0");
1:   }
0:   
0:   public int getState()
0:   {
0:     return Bundle.ACTIVE;
1:   }
0: 
0:   public void addToClassPath(URL ... urls)
0:   {
0:     if (cl != null) {
0:       URL[] existingURLs = cl.getURLs();
0:       final URL[] mergedURLs = new URL[urls.length + existingURLs.length];
0:       int i = 0;
0:       for (; i < existingURLs.length; i++) {
0:         mergedURLs[i] = existingURLs[i];
1:       }
0:       
0:       for (int j = 0; j < urls.length; j++, i++) {
0:         mergedURLs[i] = urls[j];
1:       }
0:       
0:       BundleClassLoader newCl = AccessController.doPrivileged(new PrivilegedAction<BundleClassLoader>() {
0: 
0:         public BundleClassLoader run()
0:         {
0:           return new BundleClassLoader(mergedURLs, cl.getParent());
1:         }
0:         
0:       });
0:       newCl.addBundle(cl.getBundles());
0:       cl = newCl;
1:     }
1:   }
0:     
0:   public void addBundleToClassPath(Bundle ... bundles) {
0:     if (cl != null) {
0:       cl.addBundle(bundles);
1:     }
1:   }
0: 
0:   public ClassLoader getClassLoader()
0:   {
0:     return cl;
1:   }
1: }
============================================================================