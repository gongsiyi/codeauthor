1:14ceeb1: /*
1:14ceeb1:  * Licensed to the Apache Software Foundation (ASF) under one
1:14ceeb1:  * or more contributor license agreements.  See the NOTICE file
1:14ceeb1:  * distributed with this work for additional information
1:14ceeb1:  * regarding copyright ownership.  The ASF licenses this file
1:14ceeb1:  * to you under the Apache License, Version 2.0 (the
1:14ceeb1:  * "License"); you may not use this file except in compliance
1:14ceeb1:  * with the License.  You may obtain a copy of the License at
1:14ceeb1:  *
1:14ceeb1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:14ceeb1:  *
1:14ceeb1:  * Unless required by applicable law or agreed to in writing,
1:14ceeb1:  * software distributed under the License is distributed on an
1:14ceeb1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:14ceeb1:  * KIND, either express or implied.  See the License for the
1:14ceeb1:  * specific language governing permissions and limitations
1:14ceeb1:  * under the License.
1:14ceeb1:  */
1:0d3d319: package org.apache.aries.async.promise;
3:0d3d319: 
1:8b05938: import static java.util.concurrent.TimeUnit.MILLISECONDS;
1:8b05938: 
1:a038667: import java.lang.reflect.InvocationTargetException;
1:a038667: import java.util.ArrayList;
1:a038667: import java.util.List;
1:a038667: import java.util.NoSuchElementException;
1:a038667: import java.util.concurrent.CountDownLatch;
1:a038667: import java.util.concurrent.Executor;
1:a038667: import java.util.concurrent.Executors;
1:a038667: import java.util.concurrent.RejectedExecutionException;
1:8b05938: import java.util.concurrent.ScheduledExecutorService;
1:8b05938: import java.util.concurrent.TimeUnit;
1:a038667: 
1:8b05938: import org.osgi.util.function.Callback;
1:0d3d319: import org.osgi.util.function.Function;
1:0d3d319: import org.osgi.util.function.Predicate;
1:0d3d319: import org.osgi.util.promise.Failure;
1:0d3d319: import org.osgi.util.promise.Promise;
1:0d3d319: import org.osgi.util.promise.Success;
1:8b05938: import org.osgi.util.promise.TimeoutException;
1:0d3d319: 
1:0d3d319: public class PromiseImpl<T> implements Promise<T> {
1:0d3d319: 
1:a038667:     private final Executor exec;
1:8b05938:     private final ScheduledExecutorService ses;
1:0d3d319:     private final List<Runnable> tasks = new ArrayList<Runnable>();
1:0d3d319:     private final CountDownLatch resolved = new CountDownLatch(1);
1:0d3d319: 
1:0d3d319:     private List<PromiseImpl> chain;
1:0d3d319:     private Success onSuccess;
1:0d3d319:     private Failure onFailure;
1:0d3d319:     private Throwable failure;
1:0d3d319:     private T value;
1:0d3d319: 
1:0d3d319:     public PromiseImpl() {
1:a038667:         this(Executors.newSingleThreadExecutor());
1:a038667:     }
1:a038667: 
1:a038667:     public PromiseImpl(Executor executor) {
1:8b05938:     	this(executor, Executors.newSingleThreadScheduledExecutor());
1:8b05938:     }
1:8b05938: 
1:8b05938:     public PromiseImpl(Executor executor, ScheduledExecutorService ses) {
1:a038667:     	// Executor for onResolve() callbacks
1:a038667:     	// We could use an Executor that runs tasks in current thread
1:a038667:     	exec = executor;
1:8b05938:     	this.ses = ses;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     public void fail(Throwable failure) {
1:0d3d319:         if (failure == null)
1:0d3d319:             throw new NullPointerException();
1:0d3d319:         complete(null, failure);
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     public void resolve(T value) {
1:0d3d319:         complete(value, null);
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     public Promise<Void> resolveWith(final Promise<? extends T> with) {
1:0d3d319:         if (with == null)
1:0d3d319:             throw new NullPointerException();
1:8b05938:         final PromiseImpl<Void> result = new PromiseImpl<Void>(exec, ses);
1:0d3d319: 
1:0d3d319:         with.then(new Success<T, T>() {
1:0d3d319:             @Override
1:0d3d319:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:0d3d319:                 if (isDone()) {
1:0d3d319:                     result.fail(new IllegalStateException("associated Promise already resolved"));
1:0d3d319:                 }
1:0d3d319:                 PromiseImpl.this.resolve(resolved.getValue());
1:0d3d319:                 result.resolve(null);
1:0d3d319:                 return null;
1:0d3d319:             }
1:0d3d319:         }, new Failure() {
1:0d3d319:             @Override
1:0d3d319:             public void fail(Promise<?> resolved) throws Exception {
1:0d3d319:                 if (isDone()) {
1:0d3d319:                     result.fail(new IllegalStateException("associated Promise already resolved"));
1:0d3d319:                 }
1:0d3d319:                 PromiseImpl.this.fail(resolved.getFailure());
1:0d3d319:                 result.resolve(null);
1:0d3d319:             }
1:0d3d319:         });
1:0d3d319: 
1:0d3d319:         return result;
1:0d3d319:     }
1:8b05938: 
1:0d3d319:     private synchronized void complete(T value, Throwable failure) {
1:0d3d319:         if (isDone()) {
1:0d3d319:             throw new IllegalStateException("Promise is already resolved");
1:0d3d319:         }
1:0d3d319: 
1:0d3d319:         // mark this Promise as complete before invoking callbacks
1:0d3d319:         if (failure != null) {
1:0d3d319:             this.failure = failure;
1:0d3d319:         } else {
1:0d3d319:             this.value = value;
1:0d3d319:         }
1:0d3d319:         resolved.countDown();
1:0d3d319: 
1:0d3d319:         if (chain != null) {
1:0d3d319:             runChain();
1:0d3d319:         }
1:0d3d319: 
1:0d3d319:         // run onResolve() callbacks
1:0d3d319:         for (Runnable task : tasks) {
1:a038667:             try{
1:a038667:             	exec.execute(task);
1:a038667:             } catch (RejectedExecutionException ree) {
1:a038667:             	task.run();
1:a038667:             }
1:0d3d319:         }
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     // run chained success/failure callbacks
1:0d3d319:     @SuppressWarnings("unchecked")
1:0d3d319:     private void runChain() {
1:0d3d319:         while (!chain.isEmpty()) {
1:0d3d319:             PromiseImpl next = chain.remove(0);
1:0d3d319:             if (failure != null) {
1:a038667:                 try {
1:0d3d319:                     if (next.onFailure != null) {
1:0d3d319:                         // "This method is called if the Promise with which it is registered resolves with a failure."
1:0d3d319:                         next.onFailure.fail(this);
1:0d3d319:                     }
1:0d3d319:                     // "If this method completes normally, the chained Promise will be failed
1:0d3d319:                     // with the same exception which failed the resolved Promise."
1:0d3d319:                     next.fail(failure);
1:0d3d319:                 } catch (Exception e) {
1:0d3d319:                     // "If this method throws an exception, the chained Promise will be failed with the thrown exception."
1:0d3d319:                     next.fail(e);
1:0d3d319:                 }
1:0d3d319:             } else {
1:0d3d319:                 try {
1:0d3d319:                     // "This method is called if the Promise with which it is registered resolves successfully."
1:0d3d319:                     Promise<T> p = null;
1:0d3d319:                     if (next.onSuccess != null) {
1:0d3d319:                         p = next.onSuccess.call(this);
1:0d3d319:                     }
1:0d3d319:                     if (p == null) {
1:0d3d319:                         // "If the returned Promise is null then the chained Promise will resolve immediately with a successful value of null."
1:0d3d319:                         next.resolve(null);
1:0d3d319:                     } else {
1:0d3d319:                         // "If the returned Promise is not null then the chained Promise will be resolved when the returned Promise is resolved"
1:0d3d319:                         next.resolveWith(p);
1:0d3d319:                     }
1:0d3d319:                 } catch (InvocationTargetException e) {
1:0d3d319:                     next.fail(e.getCause());
1:0d3d319:                 } catch (Exception e) {
1:0d3d319:                     next.fail(e);
1:0d3d319:                 }
1:0d3d319:             }
1:0d3d319:         }
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     // Promise API methods
1:0d3d319: 
1:8b05938:     @Override
1:0d3d319:     public boolean isDone() {
1:0d3d319:         return resolved.getCount() == 0;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public T getValue() throws InvocationTargetException, InterruptedException {
1:0d3d319:         resolved.await();
1:0d3d319:         if (failure != null) {
1:0d3d319:             throw new InvocationTargetException(failure);
1:0d3d319:         }
1:0d3d319:         return value;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public Throwable getFailure() throws InterruptedException {
1:0d3d319:         resolved.await();
1:0d3d319:         return failure;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public synchronized Promise<T> onResolve(Runnable callback) {
1:0d3d319:         if (callback == null)
1:0d3d319:             throw new NullPointerException();
1:0d3d319: 
1:0d3d319:         if (isDone()) {
1:0d3d319:         	try {
1:a038667:         		exec.execute(callback);
1:a038667:         	} catch (RejectedExecutionException ree) {
1:a038667:         		callback.run();
1:a038667:         	}
1:0d3d319:         } else {
1:0d3d319:             tasks.add(callback);
1:0d3d319:         }
1:0d3d319:         return this;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public <R> Promise<R> then(Success<? super T, ? extends R> success, Failure failure) {
1:8b05938:         PromiseImpl<R> result = new PromiseImpl<R>(exec, ses);
1:0d3d319:         result.onSuccess = success;
1:0d3d319:         result.onFailure = failure;
1:0d3d319:         synchronized (this) {
1:0d3d319:             if (chain == null) {
1:0d3d319:                 chain = new ArrayList<PromiseImpl>();
1:0d3d319:             }
1:0d3d319:             chain.add(result);
1:0d3d319:             if (isDone()) {
1:0d3d319:                 runChain();
1:0d3d319:             }
1:0d3d319:         }
1:0d3d319:         return result;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public <R> Promise<R> then(Success<? super T, ? extends R> success) {
1:0d3d319:         return then(success, null);
1:0d3d319:     }
1:8b05938:     
1:0d3d319:     @Override
1:8b05938: 	public Promise<T> then(final Callback callback) {
1:8b05938:     	if (callback == null)
1:8b05938:             throw new NullPointerException();
1:8b05938:     	return then(new Success<T,T>() {
1:8b05938: 			@Override
1:8b05938: 			public Promise<T> call(Promise<T> resolved) throws Exception {
1:8b05938: 				callback.run();
1:8b05938: 				return resolved;
1:8b05938: 			}
1:8b05938:     	}, new Failure(){
1:8b05938: 			@Override
1:8b05938: 			public void fail(Promise<?> resolved) throws Exception {
1:8b05938: 				callback.run();
1:8b05938: 			}
1:8b05938:     	});
1:8b05938: 	}
1:8b05938: 
1:8b05938: 	@Override
1:0d3d319:     public Promise<T> filter(final Predicate<? super T> predicate) {
1:0d3d319:         if (predicate == null)
1:0d3d319:             throw new NullPointerException();
1:8b05938:         final PromiseImpl<T> result = new PromiseImpl<T>(exec, ses);
1:0d3d319: 
1:0d3d319:         then(new Success<T, T>() {
1:0d3d319:             @Override
1:0d3d319:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:0d3d319:                 try {
1:0d3d319:                     if (predicate.test(resolved.getValue())) {
1:0d3d319:                         result.resolve(resolved.getValue());
1:0d3d319:                     } else {
1:0d3d319:                         result.fail(new NoSuchElementException("predicate does not accept value"));
1:0d3d319:                     }
1:0d3d319:                 } catch (Throwable t) {
1:0d3d319:                     result.fail(t);
1:0d3d319:                 }
1:0d3d319:                 return null;
1:0d3d319:             }
1:0d3d319:         }, new Failure() {
1:0d3d319:             @Override
1:0d3d319:             public void fail(Promise<?> resolved) throws Exception {
1:0d3d319:                 result.fail(resolved.getFailure());
1:0d3d319:             }
1:0d3d319:         });
1:0d3d319: 
1:0d3d319:         return result;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public <R> Promise<R> map(final Function<? super T, ? extends R> mapper) {
1:0d3d319:         if (mapper == null)
1:0d3d319:             throw new NullPointerException();
1:8b05938:         final PromiseImpl<R> result = new PromiseImpl<R>(exec, ses);
1:0d3d319: 
1:0d3d319:         then(new Success<T, T>() {
1:0d3d319:             @Override
1:0d3d319:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:0d3d319:                 try {
1:0d3d319:                     R val = mapper.apply(resolved.getValue());
1:0d3d319:                     result.resolve(val);
1:0d3d319:                 } catch (Throwable t) {
1:0d3d319:                     result.fail(t);
1:0d3d319:                 }
1:0d3d319:                 return null;
1:0d3d319:             }
1:0d3d319:         }, new Failure() {
1:0d3d319:             @Override
1:0d3d319:             public void fail(Promise<?> resolved) throws Exception {
1:0d3d319:                 result.fail(resolved.getFailure());
1:0d3d319:             }
1:0d3d319:         });
1:0d3d319: 
1:0d3d319:         return result;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public <R> Promise<R> flatMap(final Function<? super T, Promise<? extends R>> mapper) {
1:0d3d319:         if (mapper == null)
1:0d3d319:             throw new NullPointerException();
1:8b05938:         final PromiseImpl<R> result = new PromiseImpl<R>(exec, ses);
1:0d3d319: 
1:0d3d319:         then(new Success<T, T>() {
1:0d3d319:             @Override
1:0d3d319:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:0d3d319:                 try {
1:0d3d319:                     Promise<? extends R> p = mapper.apply(resolved.getValue());
1:0d3d319:                     result.resolveWith(p);
1:0d3d319:                 } catch (Throwable t) {
1:0d3d319:                     result.fail(t);
1:0d3d319:                 }
1:0d3d319:                 return null;
1:0d3d319:             }
1:0d3d319:         }, new Failure() {
1:0d3d319:             @Override
1:0d3d319:             public void fail(Promise<?> resolved) throws Exception {
1:0d3d319:                 result.fail(resolved.getFailure());
1:0d3d319:             }
1:0d3d319:         });
1:0d3d319: 
1:0d3d319:         return result;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public Promise<T> recover(final Function<Promise<?>, ? extends T> recovery) {
1:0d3d319:         if (recovery == null)
1:0d3d319:             throw new NullPointerException();
1:0d3d319: 
1:8b05938:         final PromiseImpl<T> result = new PromiseImpl<T>(exec, ses);
1:0d3d319: 
1:0d3d319:         then(new Success<T, T>() {
1:0d3d319:             @Override
1:0d3d319:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:0d3d319:                 result.resolve(resolved.getValue());
1:0d3d319:                 return null;
1:0d3d319:             }
1:0d3d319:         }, new Failure() {
1:0d3d319:             @Override
1:0d3d319:             public void fail(Promise<?> resolved) throws Exception {
1:0d3d319:                 try {
1:0d3d319:                     T recover = recovery.apply(resolved);
1:0d3d319:                     if (recover != null) {
1:0d3d319:                         result.resolve(recover);
1:0d3d319:                     } else {
1:0d3d319:                         result.fail(resolved.getFailure());
1:0d3d319:                     }
1:0d3d319:                 } catch (Throwable t) {
1:0d3d319:                     result.fail(t);
1:0d3d319:                 }
1:0d3d319:             }
1:0d3d319:         });
1:0d3d319: 
1:0d3d319:         return result;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public Promise<T> recoverWith(final Function<Promise<?>, Promise<? extends T>> recovery) {
1:0d3d319:         if (recovery == null)
1:0d3d319:             throw new NullPointerException();
1:0d3d319: 
1:8b05938:         final PromiseImpl<T> result = new PromiseImpl<T>(exec, ses);
1:0d3d319: 
1:0d3d319:         then(new Success<T, T>() {
1:0d3d319:             @Override
1:0d3d319:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:0d3d319:                 result.resolve(resolved.getValue());
1:0d3d319:                 return null;
1:0d3d319:             }
1:0d3d319:         }, new Failure() {
1:0d3d319:             @Override
1:0d3d319:             public void fail(Promise<?> resolved) throws Exception {
1:0d3d319:                 try {
1:0d3d319:                     Promise<? extends T> recover = recovery.apply(resolved);
1:0d3d319:                     if (recover != null) {
1:0d3d319:                         result.resolveWith(recover);
1:0d3d319:                     } else {
1:0d3d319:                         result.fail(resolved.getFailure());
1:0d3d319:                     }
1:0d3d319:                 } catch (Throwable t) {
1:0d3d319:                     result.fail(t);
1:0d3d319:                 }
1:0d3d319:             }
1:0d3d319:         });
1:0d3d319: 
1:0d3d319:         return result;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319:     @Override
1:0d3d319:     public Promise<T> fallbackTo(final Promise<? extends T> fallback) {
1:0d3d319:         if (fallback == null)
1:0d3d319:             throw new NullPointerException();
1:0d3d319: 
1:8b05938:         final PromiseImpl<T> result = new PromiseImpl<T>(exec, ses);
1:0d3d319: 
1:0d3d319:         then(new Success<T, T>() {
1:0d3d319:             @Override
1:0d3d319:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:0d3d319:                 result.resolve(resolved.getValue());
1:0d3d319:                 return null;
1:0d3d319:             }
1:0d3d319:         }, new Failure() {
1:0d3d319:             @Override
1:0d3d319:             public void fail(Promise<?> resolved) throws Exception {
1:0d3d319:                 @SuppressWarnings({"not thrown", "all"})
1:0d3d319:                 Throwable fail = fallback.getFailure();
1:0d3d319:                 if (fail != null) {
1:0d3d319:                     result.fail(resolved.getFailure());
1:0d3d319:                 } else {
1:0d3d319:                     result.resolve(fallback.getValue());
1:0d3d319:                 }
1:0d3d319:             }
1:0d3d319:         });
1:0d3d319: 
1:0d3d319:         return result;
1:0d3d319:     }
1:0d3d319: 
1:0d3d319: 	@Override
1:8b05938: 	public Promise<T> timeout(long milliseconds) {
1:8b05938: 		final PromiseImpl<T> p = new PromiseImpl<T>();
1:8b05938: 		
1:8b05938: 		p.resolveWith(this);
1:8b05938: 		
1:8b05938: 		ses.schedule(new Runnable(){
1:8b05938: 			@Override
1:8b05938: 			public void run() {
1:8b05938: 				if(!p.isDone()) {
1:8b05938: 					try {
1:8b05938: 						p.fail(new TimeoutException());
1:8b05938: 					} catch (Exception e) {
1:8b05938: 						// Already resolved
1:8b05938: 					}
1:8b05938: 				}
1:8b05938: 			}
1:8b05938: 		}, milliseconds, MILLISECONDS);
1:8b05938: 		
1:8b05938: 		return p;
1:8b05938: 	}
1:8b05938: 
1:8b05938: 	@Override
1:8b05938: 	public Promise<T> delay(final long milliseconds) {
1:8b05938: 		final PromiseImpl<T> p = new PromiseImpl<T>();
1:8b05938: 		then(new Success<T,T>() {
1:8b05938: 			@Override
1:8b05938: 			public Promise<T> call(final Promise<T> resolved) throws Exception {
1:8b05938: 				ses.schedule(new Runnable(){
1:8b05938: 					@Override
1:8b05938: 					public void run() {
1:8b05938: 						try {
1:8b05938: 							p.resolve(resolved.getValue());
1:8b05938: 						} catch (IllegalStateException ise) {
1:8b05938: 							// Someone else resolved our promise?
1:8b05938: 						} catch (Exception e) {
1:8b05938: 							p.fail(e);
1:8b05938: 						}
1:8b05938: 					}
1:8b05938: 				}, milliseconds, MILLISECONDS);
1:8b05938: 				return null;
1:8b05938: 			}
1:8b05938:     	}, new Failure(){
1:8b05938: 			@Override
1:8b05938: 			public void fail(final Promise<?> resolved) throws Exception {
1:8b05938: 				ses.schedule(new Runnable(){
1:8b05938: 					@Override
1:8b05938: 					public void run() {
1:8b05938: 						try {
1:8b05938: 							p.fail(resolved.getFailure());
1:8b05938: 						} catch (Exception e) {
1:8b05938: 							p.fail(e);
1:8b05938: 						}
1:8b05938: 					}
1:8b05938: 				}, milliseconds, MILLISECONDS);
1:8b05938: 			}
1:8b05938:     	});
1:8b05938: 		return p;
1:8b05938: 	}
1:8b05938:     
1:8b05938:     
1:0d3d319: }
============================================================================
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:8b05938
/////////////////////////////////////////////////////////////////////////
1: import static java.util.concurrent.TimeUnit.MILLISECONDS;
1: 
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ScheduledExecutorService;
1: import java.util.concurrent.TimeUnit;
1: import org.osgi.util.function.Callback;
1: import org.osgi.util.promise.TimeoutException;
1:     private final ScheduledExecutorService ses;
/////////////////////////////////////////////////////////////////////////
1:     	this(executor, Executors.newSingleThreadScheduledExecutor());
1:     }
1: 
1:     public PromiseImpl(Executor executor, ScheduledExecutorService ses) {
1:     	this.ses = ses;
/////////////////////////////////////////////////////////////////////////
1:         final PromiseImpl<Void> result = new PromiseImpl<Void>(exec, ses);
/////////////////////////////////////////////////////////////////////////
1:         PromiseImpl<R> result = new PromiseImpl<R>(exec, ses);
/////////////////////////////////////////////////////////////////////////
1:     
1: 	public Promise<T> then(final Callback callback) {
1:     	if (callback == null)
1:             throw new NullPointerException();
1:     	return then(new Success<T,T>() {
1: 			@Override
1: 			public Promise<T> call(Promise<T> resolved) throws Exception {
1: 				callback.run();
1: 				return resolved;
1: 			}
1:     	}, new Failure(){
1: 			@Override
1: 			public void fail(Promise<?> resolved) throws Exception {
1: 				callback.run();
1: 			}
1:     	});
1: 	}
1: 
1: 	@Override
1:         final PromiseImpl<T> result = new PromiseImpl<T>(exec, ses);
/////////////////////////////////////////////////////////////////////////
1:         final PromiseImpl<R> result = new PromiseImpl<R>(exec, ses);
/////////////////////////////////////////////////////////////////////////
1:         final PromiseImpl<R> result = new PromiseImpl<R>(exec, ses);
/////////////////////////////////////////////////////////////////////////
1:         final PromiseImpl<T> result = new PromiseImpl<T>(exec, ses);
/////////////////////////////////////////////////////////////////////////
1:         final PromiseImpl<T> result = new PromiseImpl<T>(exec, ses);
/////////////////////////////////////////////////////////////////////////
1:         final PromiseImpl<T> result = new PromiseImpl<T>(exec, ses);
/////////////////////////////////////////////////////////////////////////
1: 
1: 	@Override
1: 	public Promise<T> timeout(long milliseconds) {
1: 		final PromiseImpl<T> p = new PromiseImpl<T>();
1: 		
1: 		p.resolveWith(this);
1: 		
1: 		ses.schedule(new Runnable(){
1: 			@Override
1: 			public void run() {
1: 				if(!p.isDone()) {
1: 					try {
1: 						p.fail(new TimeoutException());
1: 					} catch (Exception e) {
1: 						// Already resolved
1: 					}
1: 				}
1: 			}
1: 		}, milliseconds, MILLISECONDS);
1: 		
1: 		return p;
1: 	}
1: 
1: 	@Override
1: 	public Promise<T> delay(final long milliseconds) {
1: 		final PromiseImpl<T> p = new PromiseImpl<T>();
1: 		then(new Success<T,T>() {
1: 			@Override
1: 			public Promise<T> call(final Promise<T> resolved) throws Exception {
1: 				ses.schedule(new Runnable(){
1: 					@Override
1: 					public void run() {
1: 						try {
1: 							p.resolve(resolved.getValue());
1: 						} catch (IllegalStateException ise) {
1: 							// Someone else resolved our promise?
1: 						} catch (Exception e) {
1: 							p.fail(e);
1: 						}
1: 					}
1: 				}, milliseconds, MILLISECONDS);
1: 				return null;
1: 			}
1:     	}, new Failure(){
1: 			@Override
1: 			public void fail(final Promise<?> resolved) throws Exception {
1: 				ses.schedule(new Runnable(){
1: 					@Override
1: 					public void run() {
1: 						try {
1: 							p.fail(resolved.getFailure());
1: 						} catch (Exception e) {
1: 							p.fail(e);
1: 						}
1: 					}
1: 				}, milliseconds, MILLISECONDS);
1: 			}
1:     	});
1: 		return p;
1: 	}
1:     
1:     
commit:a038667
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.NoSuchElementException;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.Executor;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.RejectedExecutionException;
1: 
1:     private final Executor exec;
/////////////////////////////////////////////////////////////////////////
1:         this(Executors.newSingleThreadExecutor());
1:     }
1: 
1:     public PromiseImpl(Executor executor) {
1:     	// Executor for onResolve() callbacks
1:     	// We could use an Executor that runs tasks in current thread
1:     	exec = executor;
/////////////////////////////////////////////////////////////////////////
0:         final PromiseImpl<Void> result = new PromiseImpl<Void>(exec);
/////////////////////////////////////////////////////////////////////////
1:             try{
1:             	exec.execute(task);
1:             } catch (RejectedExecutionException ree) {
1:             	task.run();
1:             }
/////////////////////////////////////////////////////////////////////////
1:         	try {
1:         		exec.execute(callback);
1:         	} catch (RejectedExecutionException ree) {
1:         		callback.run();
1:         	}
/////////////////////////////////////////////////////////////////////////
0:         PromiseImpl<R> result = new PromiseImpl<R>(exec);
/////////////////////////////////////////////////////////////////////////
0:         final PromiseImpl<T> result = new PromiseImpl<T>(exec);
/////////////////////////////////////////////////////////////////////////
0:         final PromiseImpl<R> result = new PromiseImpl<R>(exec);
/////////////////////////////////////////////////////////////////////////
0:         final PromiseImpl<R> result = new PromiseImpl<R>(exec);
/////////////////////////////////////////////////////////////////////////
0:         final PromiseImpl<T> result = new PromiseImpl<T>(exec);
/////////////////////////////////////////////////////////////////////////
0:         final PromiseImpl<T> result = new PromiseImpl<T>(exec);
/////////////////////////////////////////////////////////////////////////
0:         final PromiseImpl<T> result = new PromiseImpl<T>(exec);
commit:14ceeb1
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
commit:0d3d319
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.async.promise;
1: 
1: import org.osgi.util.function.Function;
1: import org.osgi.util.function.Predicate;
1: import org.osgi.util.promise.Failure;
1: import org.osgi.util.promise.Promise;
1: import org.osgi.util.promise.Success;
1: 
0: import java.lang.reflect.InvocationTargetException;
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.NoSuchElementException;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
1: 
1: public class PromiseImpl<T> implements Promise<T> {
1: 
0:     private final ExecutorService exec;
1:     private final List<Runnable> tasks = new ArrayList<Runnable>();
1:     private final CountDownLatch resolved = new CountDownLatch(1);
1: 
1:     private List<PromiseImpl> chain;
1:     private Success onSuccess;
1:     private Failure onFailure;
1:     private Throwable failure;
1:     private T value;
1: 
1:     public PromiseImpl() {
0:         // Executor for onResolve() callbacks
0:         // We could use an Executor that runs tasks in current thread
0:         exec = Executors.newSingleThreadExecutor();
1:     }
1: 
1:     public void fail(Throwable failure) {
1:         if (failure == null)
1:             throw new NullPointerException();
1:         complete(null, failure);
1:     }
1: 
1:     public void resolve(T value) {
1:         complete(value, null);
1:     }
1: 
1:     public Promise<Void> resolveWith(final Promise<? extends T> with) {
1:         if (with == null)
1:             throw new NullPointerException();
0:         final PromiseImpl<Void> result = new PromiseImpl<Void>();
1: 
1:         with.then(new Success<T, T>() {
1:             @Override
1:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:                 if (isDone()) {
1:                     result.fail(new IllegalStateException("associated Promise already resolved"));
1:                 }
1:                 PromiseImpl.this.resolve(resolved.getValue());
1:                 result.resolve(null);
1:                 return null;
1:             }
1:         }, new Failure() {
1:             @Override
1:             public void fail(Promise<?> resolved) throws Exception {
1:                 if (isDone()) {
1:                     result.fail(new IllegalStateException("associated Promise already resolved"));
1:                 }
1:                 PromiseImpl.this.fail(resolved.getFailure());
1:                 result.resolve(null);
1:             }
1:         });
1: 
1:         return result;
1:     }
1: 
1:     private synchronized void complete(T value, Throwable failure) {
1:         if (isDone()) {
1:             throw new IllegalStateException("Promise is already resolved");
1:         }
1: 
1:         // mark this Promise as complete before invoking callbacks
1:         if (failure != null) {
1:             this.failure = failure;
1:         } else {
1:             this.value = value;
1:         }
1:         resolved.countDown();
1: 
1:         if (chain != null) {
1:             runChain();
1:         }
1: 
1:         // run onResolve() callbacks
1:         for (Runnable task : tasks) {
0:             exec.submit(task);
1:         }
1:     }
1: 
1:     // run chained success/failure callbacks
1:     @SuppressWarnings("unchecked")
1:     private void runChain() {
1:         while (!chain.isEmpty()) {
1:             PromiseImpl next = chain.remove(0);
1:             if (failure != null) {
1:                 try {
1:                     if (next.onFailure != null) {
1:                         // "This method is called if the Promise with which it is registered resolves with a failure."
1:                         next.onFailure.fail(this);
1:                     }
1:                     // "If this method completes normally, the chained Promise will be failed
1:                     // with the same exception which failed the resolved Promise."
1:                     next.fail(failure);
1:                 } catch (Exception e) {
1:                     // "If this method throws an exception, the chained Promise will be failed with the thrown exception."
1:                     next.fail(e);
1:                 }
1:             } else {
1:                 try {
1:                     // "This method is called if the Promise with which it is registered resolves successfully."
1:                     Promise<T> p = null;
1:                     if (next.onSuccess != null) {
1:                         p = next.onSuccess.call(this);
1:                     }
1:                     if (p == null) {
1:                         // "If the returned Promise is null then the chained Promise will resolve immediately with a successful value of null."
1:                         next.resolve(null);
1:                     } else {
1:                         // "If the returned Promise is not null then the chained Promise will be resolved when the returned Promise is resolved"
1:                         next.resolveWith(p);
1:                     }
1:                 } catch (InvocationTargetException e) {
1:                     next.fail(e.getCause());
1:                 } catch (Exception e) {
1:                     next.fail(e);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     // Promise API methods
1: 
1:     @Override
1:     public boolean isDone() {
1:         return resolved.getCount() == 0;
1:     }
1: 
1:     @Override
1:     public T getValue() throws InvocationTargetException, InterruptedException {
1:         resolved.await();
1:         if (failure != null) {
1:             throw new InvocationTargetException(failure);
1:         }
1:         return value;
1:     }
1: 
1:     @Override
1:     public Throwable getFailure() throws InterruptedException {
1:         resolved.await();
1:         return failure;
1:     }
1: 
1:     @Override
1:     public synchronized Promise<T> onResolve(Runnable callback) {
1:         if (callback == null)
1:             throw new NullPointerException();
1: 
1:         if (isDone()) {
0:             exec.submit(callback);
1:         } else {
1:             tasks.add(callback);
1:         }
1:         return this;
1:     }
1: 
1:     @Override
1:     public <R> Promise<R> then(Success<? super T, ? extends R> success, Failure failure) {
0:         PromiseImpl<R> result = new PromiseImpl<R>();
1:         result.onSuccess = success;
1:         result.onFailure = failure;
1:         synchronized (this) {
1:             if (chain == null) {
1:                 chain = new ArrayList<PromiseImpl>();
1:             }
1:             chain.add(result);
1:             if (isDone()) {
1:                 runChain();
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     @Override
1:     public <R> Promise<R> then(Success<? super T, ? extends R> success) {
1:         return then(success, null);
1:     }
1: 
1:     @Override
1:     public Promise<T> filter(final Predicate<? super T> predicate) {
1:         if (predicate == null)
1:             throw new NullPointerException();
0:         final PromiseImpl<T> result = new PromiseImpl<T>();
1: 
1:         then(new Success<T, T>() {
1:             @Override
1:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:                 try {
1:                     if (predicate.test(resolved.getValue())) {
1:                         result.resolve(resolved.getValue());
1:                     } else {
1:                         result.fail(new NoSuchElementException("predicate does not accept value"));
1:                     }
1:                 } catch (Throwable t) {
1:                     result.fail(t);
1:                 }
1:                 return null;
1:             }
1:         }, new Failure() {
1:             @Override
1:             public void fail(Promise<?> resolved) throws Exception {
1:                 result.fail(resolved.getFailure());
1:             }
1:         });
1: 
1:         return result;
1:     }
1: 
1:     @Override
1:     public <R> Promise<R> map(final Function<? super T, ? extends R> mapper) {
1:         if (mapper == null)
1:             throw new NullPointerException();
0:         final PromiseImpl<R> result = new PromiseImpl<R>();
1: 
1:         then(new Success<T, T>() {
1:             @Override
1:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:                 try {
1:                     R val = mapper.apply(resolved.getValue());
1:                     result.resolve(val);
1:                 } catch (Throwable t) {
1:                     result.fail(t);
1:                 }
1:                 return null;
1:             }
1:         }, new Failure() {
1:             @Override
1:             public void fail(Promise<?> resolved) throws Exception {
1:                 result.fail(resolved.getFailure());
1:             }
1:         });
1: 
1:         return result;
1:     }
1: 
1:     @Override
1:     public <R> Promise<R> flatMap(final Function<? super T, Promise<? extends R>> mapper) {
1:         if (mapper == null)
1:             throw new NullPointerException();
0:         final PromiseImpl<R> result = new PromiseImpl<R>();
1: 
1:         then(new Success<T, T>() {
1:             @Override
1:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:                 try {
1:                     Promise<? extends R> p = mapper.apply(resolved.getValue());
1:                     result.resolveWith(p);
1:                 } catch (Throwable t) {
1:                     result.fail(t);
1:                 }
1:                 return null;
1:             }
1:         }, new Failure() {
1:             @Override
1:             public void fail(Promise<?> resolved) throws Exception {
1:                 result.fail(resolved.getFailure());
1:             }
1:         });
1: 
1:         return result;
1:     }
1: 
1:     @Override
1:     public Promise<T> recover(final Function<Promise<?>, ? extends T> recovery) {
1:         if (recovery == null)
1:             throw new NullPointerException();
1: 
0:         final PromiseImpl<T> result = new PromiseImpl<T>();
1: 
1:         then(new Success<T, T>() {
1:             @Override
1:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:                 result.resolve(resolved.getValue());
1:                 return null;
1:             }
1:         }, new Failure() {
1:             @Override
1:             public void fail(Promise<?> resolved) throws Exception {
1:                 try {
1:                     T recover = recovery.apply(resolved);
1:                     if (recover != null) {
1:                         result.resolve(recover);
1:                     } else {
1:                         result.fail(resolved.getFailure());
1:                     }
1:                 } catch (Throwable t) {
1:                     result.fail(t);
1:                 }
1:             }
1:         });
1: 
1:         return result;
1:     }
1: 
1:     @Override
1:     public Promise<T> recoverWith(final Function<Promise<?>, Promise<? extends T>> recovery) {
1:         if (recovery == null)
1:             throw new NullPointerException();
1: 
0:         final PromiseImpl<T> result = new PromiseImpl<T>();
1: 
1:         then(new Success<T, T>() {
1:             @Override
1:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:                 result.resolve(resolved.getValue());
1:                 return null;
1:             }
1:         }, new Failure() {
1:             @Override
1:             public void fail(Promise<?> resolved) throws Exception {
1:                 try {
1:                     Promise<? extends T> recover = recovery.apply(resolved);
1:                     if (recover != null) {
1:                         result.resolveWith(recover);
1:                     } else {
1:                         result.fail(resolved.getFailure());
1:                     }
1:                 } catch (Throwable t) {
1:                     result.fail(t);
1:                 }
1:             }
1:         });
1: 
1:         return result;
1:     }
1: 
1:     @Override
1:     public Promise<T> fallbackTo(final Promise<? extends T> fallback) {
1:         if (fallback == null)
1:             throw new NullPointerException();
1: 
0:         final PromiseImpl<T> result = new PromiseImpl<T>();
1: 
1:         then(new Success<T, T>() {
1:             @Override
1:             public Promise<T> call(Promise<T> resolved) throws Exception {
1:                 result.resolve(resolved.getValue());
1:                 return null;
1:             }
1:         }, new Failure() {
1:             @Override
1:             public void fail(Promise<?> resolved) throws Exception {
1:                 @SuppressWarnings({"not thrown", "all"})
1:                 Throwable fail = fallback.getFailure();
1:                 if (fail != null) {
1:                     result.fail(resolved.getFailure());
1:                 } else {
1:                     result.resolve(fallback.getValue());
1:                 }
1:             }
1:         });
1: 
1:         return result;
1:     }
1: }
============================================================================