1:2d72200: /*
1:2d72200:  * Licensed to the Apache Software Foundation (ASF) under one
1:2d72200:  * or more contributor license agreements.  See the NOTICE file
1:2d72200:  * distributed with this work for additional information
1:2d72200:  * regarding copyright ownership.  The ASF licenses this file
1:2d72200:  * to you under the Apache License, Version 2.0 (the
1:2d72200:  * "License"); you may not use this file except in compliance
1:2d72200:  * with the License.  You may obtain a copy of the License at
2:2d72200:  *
1:2d72200:  *   http://www.apache.org/licenses/LICENSE-2.0
1:2d72200:  *
1:2d72200:  * Unless required by applicable law or agreed to in writing,
1:2d72200:  * software distributed under the License is distributed on an
1:2d72200:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:2d72200:  * KIND, either express or implied.  See the License for the
1:2d72200:  * specific language governing permissions and limitations
1:2d72200:  * under the License.
4:2d72200:  */
1:910fec0: package org.apache.aries.util.manifest;
18:2d72200: 
1:2d72200: import java.io.BufferedReader;
1:2d72200: import java.io.IOException;
1:2d72200: import java.io.InputStream;
1:2d72200: import java.io.InputStreamReader;
1:2d72200: import java.util.ArrayList;
1:2d72200: import java.util.HashMap;
1:2d72200: import java.util.List;
1:2d72200: import java.util.Map;
1:2d72200: import java.util.Map.Entry;
1:a1f07b5: import java.util.Set;
1:2d72200: import java.util.jar.Attributes;
1:2d72200: import java.util.jar.Manifest;
1:5297b83: 
1:910fec0: import org.apache.aries.util.filesystem.IDirectory;
1:910fec0: import org.apache.aries.util.filesystem.IFile;
1:c6cb34d: import org.apache.aries.util.io.IOUtils;
1:2d72200: 
4:2d72200: /**
1:2d72200:  * This class contains utilities for parsing manifests. It provides methods to
1:2d72200:  * parse the manifest, read a manifest into a map and to split an manifest
1:2d72200:  * entry that follows the Import-Package syntax.
1:a1f07b5:  */
1:2d72200: public class ManifestProcessor
1:a1f07b5: {
1:2d72200:   /**
1:2d72200:    * Reads a manifest's main attributes into a String->String map.
2:7de0b0c:    * <p>
1:2d72200:    * Will always return a map, empty if the manifest had no attributes.
1:2d72200:    * 
1:2d72200:    * @param mf The manifest to read.
1:2d72200:    * @return Map of manifest main attributes.
1:2d72200:    */
1:2d72200:   public static Map<String, String> readManifestIntoMap(Manifest mf){
1:2d72200: 
1:2d72200:     HashMap<String, String> props = new HashMap<String, String>();
1:2d72200:     
1:2d72200:     Attributes mainAttrs = mf.getMainAttributes();
1:2d72200:     if (mainAttrs!=null){
1:2d72200:       Set<Entry<Object, Object>> attributeSet =  mainAttrs.entrySet(); 
1:2d72200:       if (attributeSet != null){
1:2d72200:         // Copy all the manifest headers across. The entry set should be a set of
1:2d72200:         // Name to String mappings, by calling String.valueOf we do the conversion
1:2d72200:         // to a string and we do not NPE.
1:2d72200:         for (Map.Entry<Object, Object> entry : attributeSet) {
1:2d72200:           props.put(String.valueOf(entry.getKey()), String.valueOf(entry.getValue()));
1:a1f07b5:         }
1:7de0b0c:       }    
1:4095dd3:     }
1:7de0b0c:          
1:2d72200:     return props;
1:4095dd3:   }
1:4095dd3:   
1:2d72200:   /**
1:a1f07b5:    * mapToManifest
1:7de0b0c:    */
1:a1f07b5:   public static Manifest mapToManifest (Map<String,String> attributes)
1:7de0b0c:   {
1:a1f07b5:     Manifest man = new Manifest();
1:a1f07b5:     Attributes att = man.getMainAttributes();
1:910fec0:     att.putValue(Attributes.Name.MANIFEST_VERSION.toString(), Constants.MANIFEST_VERSION);
1:a1f07b5:     for (Map.Entry<String, String> entry : attributes.entrySet()) {
1:a1f07b5:       att.putValue(entry.getKey(),  entry.getValue());
1:4095dd3:     }
1:a1f07b5:     return man;
1:4095dd3:   }
1:4095dd3:   
1:a1f07b5:   /**
1:2d72200:    * This method parses the manifest using a custom manifest parsing routine.
1:2d72200:    * This means that we can avoid the 76 byte line length in a manifest providing
1:2d72200:    * a better developer experience.
1:2d72200:    * 
1:2d72200:    * @param in the input stream to read the manifest from.
1:2d72200:    * @return   the parsed manifest
2:2d72200:    * @throws IOException
1:4095dd3:    */
1:2d72200:   public static Manifest parseManifest(InputStream in) throws IOException
1:4095dd3:   {
1:2d72200:     Manifest man = new Manifest();
1:a1f07b5:     
1:80dea02:     try
1:80dea02:     {
1:80dea02:       // I'm assuming that we use UTF-8 here, but the jar spec doesn't say.
1:80dea02:       BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
1:80dea02:       
1:80dea02:       String line;
1:80dea02:       StringBuilder attribute = null;
1:80dea02:       
1:80dea02:       String namedAttribute = null;
1:80dea02:       
1:80dea02:       do {
1:80dea02:         line = reader.readLine();
1:80dea02:   
1:80dea02:         // if we get a blank line skip to the next one
1:80dea02:         if (line != null && line.trim().length() == 0) continue;
1:80dea02:         if (line != null && line.charAt(0) == ' ' && attribute != null) {
1:80dea02:           // we have a continuation line, so add to the builder, ignoring the
1:80dea02:           // first character
1:80dea02:           attribute.append(line.trim());
1:80dea02:         } else if (attribute == null) {
1:80dea02:           attribute = new StringBuilder(line.trim());
1:80dea02:         } else if (attribute != null) {
1:80dea02:           // We have fully parsed an attribute
1:80dea02:           int index = attribute.indexOf(":");
1:80dea02:           String attributeName = attribute.substring(0, index).trim();
1:80dea02:           // TODO cope with index + 1 being after the end of attribute
1:80dea02:           String attributeValue = attribute.substring(index + 1).trim();
1:80dea02:           
1:80dea02:           if ("Name".equals(attributeName)) {
1:80dea02:             man.getEntries().put(attributeValue, new Attributes());
1:80dea02:             namedAttribute = attributeValue;
1:7de0b0c:           } else {
1:be36ee1:         	Attributes.Name nameToAdd = new Attributes.Name(attributeName);
1:be36ee1:             if (namedAttribute == null || !man.getMainAttributes().containsKey(nameToAdd)) {
1:be36ee1:               man.getMainAttributes().put(nameToAdd, attributeValue);
1:80dea02:             } else {
1:be36ee1:               man.getAttributes(namedAttribute).put(nameToAdd, attributeValue);
1:80dea02:             }
1:7de0b0c:           }
1:80dea02:           
1:80dea02:           if (line != null) attribute = new StringBuilder(line.trim());
1:7de0b0c:         }
1:80dea02:       } while (line != null);
1:80dea02:     }
1:80dea02:     finally {
1:80dea02:       IOUtils.close(in);
1:80dea02:     }
2:2d72200:     return man;
1:7de0b0c:   }
1:7de0b0c:   
1:4095dd3:   /**
1:5297b83:    * Obtain a manifest from an IDirectory. 
1:5297b83:    * 
1:5297b83:    * @param appDir
1:5297b83:    * @param manifestName the name of manifest
1:5297b83:    * @return Manifest, or null if none found.
1:5297b83:    * @throws IOException
1:5297b83:    */
1:5297b83:   public static Manifest obtainManifestFromAppDir(IDirectory appDir, String manifestName) throws IOException{
1:5297b83:     IFile manifestFile = appDir.getFile(manifestName);
1:5297b83:     Manifest man = null;
1:5297b83:     if (manifestFile != null) {
1:bce26b9:       man = parseManifest(manifestFile.open());
1:7de0b0c:     }
1:5297b83:     return man;
1:7de0b0c:   }
1:7de0b0c: 
1:4095dd3:   
1:5297b83:   /**
1:2d72200:    * 
1:2d72200:    * Splits a delimiter separated string, tolerating presence of non separator commas
1:2d72200:    * within double quoted segments.
1:2d72200:    * 
1:2d72200:    * Eg.
1:2d72200:    * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]" &
1:2d72200:    * com.ibm.ws.eba.helloWorldService;version="1.0.0"
1:2d72200:    * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"
1:2d72200:    * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"
1:2d72200:    *  @param value          the value to be split
1:2d72200:    *  @param delimiter      the delimiter string such as ',' etc.
1:2d72200:    *  @return List<String>  the components of the split String in a list
1:2d72200:    */
1:2d72200:   public static List<String> split(String value, String delimiter)
3:2d72200:   {
1:4095dd3: 
1:2d72200:     List<String> result = new ArrayList<String>();
1:2d72200:     if (value != null) {
1:2d72200:       String[] packages = value.split(delimiter);
1:5297b83:       
1:2d72200:       for (int i = 0; i < packages.length; ) {
1:2d72200:         String tmp = packages[i++].trim();
1:2d72200:         // if there is a odd number of " in a string, we need to append
1:2d72200:         while (count(tmp, "\"") % 2 == 1) {
1:2d72200:           // check to see if we need to append the next package[i++]
1:2d72200:           tmp = tmp + delimiter + packages[i++].trim();
1:7de0b0c:         }
1:5297b83:         
1:2d72200:         result.add(tmp);
1:7de0b0c:       }
1:4095dd3:     }
1:2d72200: 
1:7de0b0c:     return result;
1:7de0b0c:   }  
1:7de0b0c:   
1:7de0b0c:   /**
1:2d72200:    * count the number of characters in a string
1:2d72200:    * @param parent The string to be searched
1:2d72200:    * @param subString The substring to be found
1:2d72200:    * @return the number of occurrence of the subString
1:2d72200:    */
1:2d72200:    private static int count(String parent, String subString) {
1:2d72200:      
1:2d72200:      int count = 0 ;
1:2d72200:      int i = parent.indexOf(subString);
1:2d72200:      while (i > -1) {
1:2d72200:        if (parent.length() >= i+1)
1:2d72200:          parent = parent.substring(i+1);
1:2d72200:        count ++;
1:2d72200:        i = parent.indexOf(subString);
1:4095dd3:      }
1:2d72200:      return count;
1:a1f07b5:    }  
1:4095dd3:    
2:5297b83: }
============================================================================
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:be36ee1
/////////////////////////////////////////////////////////////////////////
1:         	Attributes.Name nameToAdd = new Attributes.Name(attributeName);
1:             if (namedAttribute == null || !man.getMainAttributes().containsKey(nameToAdd)) {
1:               man.getMainAttributes().put(nameToAdd, attributeValue);
1:               man.getAttributes(namedAttribute).put(nameToAdd, attributeValue);
author:David Jencks
-------------------------------------------------------------------------------
commit:6df3ad3
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:c6cb34d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.io.IOUtils;
commit:910fec0
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.util.manifest;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.filesystem.IDirectory;
1: import org.apache.aries.util.filesystem.IFile;
0: import org.apache.aries.util.filesystem.IOUtils;
/////////////////////////////////////////////////////////////////////////
1:     att.putValue(Attributes.Name.MANIFEST_VERSION.toString(), Constants.MANIFEST_VERSION);
author:Chris Wilkinson
-------------------------------------------------------------------------------
commit:80dea02
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.utils.filesystem.IOUtils;
/////////////////////////////////////////////////////////////////////////
1:     try
1:     {
1:       // I'm assuming that we use UTF-8 here, but the jar spec doesn't say.
1:       BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
1:       
1:       String line;
1:       StringBuilder attribute = null;
1:       
1:       String namedAttribute = null;
1:       
1:       do {
1:         line = reader.readLine();
1:   
1:         // if we get a blank line skip to the next one
1:         if (line != null && line.trim().length() == 0) continue;
1:         if (line != null && line.charAt(0) == ' ' && attribute != null) {
1:           // we have a continuation line, so add to the builder, ignoring the
1:           // first character
1:           attribute.append(line.trim());
1:         } else if (attribute == null) {
1:           attribute = new StringBuilder(line.trim());
1:         } else if (attribute != null) {
1:           // We have fully parsed an attribute
1:           int index = attribute.indexOf(":");
1:           String attributeName = attribute.substring(0, index).trim();
1:           // TODO cope with index + 1 being after the end of attribute
1:           String attributeValue = attribute.substring(index + 1).trim();
1:           
1:           if ("Name".equals(attributeName)) {
1:             man.getEntries().put(attributeValue, new Attributes());
1:             namedAttribute = attributeValue;
0:             if (namedAttribute == null) {
0:               man.getMainAttributes().put(new Attributes.Name(attributeName), attributeValue);
1:             } else {
0:               man.getAttributes(namedAttribute).put(new Attributes.Name(attributeName), attributeValue);
1:             }
1:           
1:           if (line != null) attribute = new StringBuilder(line.trim());
1:       } while (line != null);
1:     }
1:     finally {
1:       IOUtils.close(in);
1:     }
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:bce26b9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       man = parseManifest(manifestFile.open());
/////////////////////////////////////////////////////////////////////////
commit:00042e6
/////////////////////////////////////////////////////////////////////////
0:       IOUtils.close(bais);
commit:fb708ef
/////////////////////////////////////////////////////////////////////////
0:       man = readSanitizedManifest(manifestFile.open());
commit:a301e7a
/////////////////////////////////////////////////////////////////////////
0:         // Search through for our entry by hand so we can be case-insensitive 
commit:7de0b0c
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
/////////////////////////////////////////////////////////////////////////
0:    * Retrieves an InputStream for the application manifest that guarantees a terminating new line
0:    * at the end, so that the manifest can be parsed by java.util.jar.Manifest.
1:    * <p>
0:    * Also guarantees line lengths are less than 72 bytes.
1:    * <p>
0:    * @param is  InputStream to the manifest file
0:    * @return Manifest read from the sanitized manifest file
1:    */
0:   public static Manifest readSanitizedManifest(InputStream is)
1:   {
0:     StringBuffer manifestContent = new StringBuffer();
0:     ByteArrayInputStream bais = null;
0:     BufferedReader r = new BufferedReader(new InputStreamReader(is));
1: 
0:     try {
0:       String line;
0:       while ((line = r.readLine()) != null) {
0:         //we check if the line length is >71 because we haven't included a line terminator
0:         if (line.length() > 71) {
0:           //if we have a line that is too long we split it
0:           //we split at 70 so we have room to add a new line
0:           //and a space for the continuation
0:           manifestContent.append(line.substring(0, 70));
0:           manifestContent.append('\n');
0:           line = line.substring(70, line.length());
0:           while (line.length() > 71) {
0:             manifestContent.append(' ');
0:             manifestContent.append(line.substring(0, 70));
0:             manifestContent.append('\n');
0:             line = line.substring(70, line.length());
1:           }
0:           manifestContent.append(' ');
0:           manifestContent.append(line);
0:           manifestContent.append('\n');
1:         } else {
0:           manifestContent.append(line);
0:           manifestContent.append('\n');
1:         }
1:       }
0:       //remember to close the input stream to avoid zip file locking
0:       is.close();
0:       r.close();
0:       bais = new ByteArrayInputStream(manifestContent.toString().getBytes());
0:     } catch (IOException e) {
0:       // NO-OP we will just return an empty set
0:       bais = null;
1:     }
1: 
0:     Manifest result = null;
0:     try {
0:       if (bais != null)
0:         result = new Manifest(bais);
0:     } catch (IOException e) {
0:       // NO-OP we will just return null
1:     }
0:     finally {
0:       if (bais != null) { 
0:         try { 
0:           bais.close(); 
0:         } catch (IOException e) {
0:           // NO-OP
1:         } 
1:       }
1:     }
1:     return result;
1:   }  
1:   
1:   
1:   /**
commit:4095dd3
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.net.URISyntaxException;
0: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
0: import java.util.zip.ZipEntry;
0: import java.util.zip.ZipInputStream;
0: import org.apache.aries.application.utils.filesystem.FileSystem;
0: import org.apache.aries.application.utils.filesystem.IOUtils;
/////////////////////////////////////////////////////////////////////////
0:    * Obtains a manifest from a file or directory at the given URL. The manifest name
0:    * can be arbitrary.
0:    * @param url the url of an archive file or directory 
0:    * @param fileName the name of the manifest to look for
0:    * @return
0:    * @throws IOException if the url can't be read
0:    * @throws URISyntaxException 
1:    */
0:   public static Manifest obtainManifest(URL url, String fileName) throws IOException, URISyntaxException
1:   {
1: 
0:     Manifest bundleManifest = null;
0:     // try read the compositeBundle Manifest from url
1:     
0:     ZipInputStream zipInputStream = null;
0:     try {
0:       File file = null;
0:       file = new File(url.toURI());
0:       if (file.isDirectory()) {
0:         IDirectory iDirectory = FileSystem.getFSRoot(file);
0:         bundleManifest = obtainManifestFromAppDir(iDirectory, fileName);
0:       } else {
0:         // We can't use a JarInputStream because that assumes the manifest name is MANIFEST.MF
0:         zipInputStream = new ZipInputStream(url.openStream());
0:         // Search through for our entry by hand so we can be case-insensitive (story 5399)
0:         ZipEntry manifestEntry = null;
0:         ZipEntry nextEntry = zipInputStream.getNextEntry();
0:         while (manifestEntry == null && nextEntry != null) {
0:           if (fileName.equalsIgnoreCase(nextEntry.getName())) {
0:             manifestEntry = nextEntry;
0:           } else {
0:             nextEntry = zipInputStream.getNextEntry();
1:           }
1:         }
0:         if (manifestEntry != null) {
0:           bundleManifest = parseManifest(zipInputStream);
1:         }
1:       }
0:     } finally {
0:       IOUtils.close(zipInputStream);
1:     }
1: 
0:     return bundleManifest;
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:    
commit:a1f07b5
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
0: import org.apache.aries.application.utils.AppConstants;
/////////////////////////////////////////////////////////////////////////
1:    * mapToManifest
1:    */
1:   public static Manifest mapToManifest (Map<String,String> attributes)
1:   {
1:     Manifest man = new Manifest();
1:     Attributes att = man.getMainAttributes();
0:     att.putValue(Attributes.Name.MANIFEST_VERSION.toString(), AppConstants.MANIFEST_VERSION);
1:     for (Map.Entry<String, String> entry : attributes.entrySet()) {
1:       att.putValue(entry.getKey(),  entry.getValue());
1:     }
1:     return man;
1:   }
1:   
1:   /**
commit:5297b83
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.filesystem.IDirectory;
0: import org.apache.aries.application.filesystem.IFile;
1: 
/////////////////////////////////////////////////////////////////////////
1:    * Obtain a manifest from an IDirectory. 
1:    * 
1:    * @param appDir
1:    * @param manifestName the name of manifest
1:    * @return Manifest, or null if none found.
1:    * @throws IOException
1:    */
1:   public static Manifest obtainManifestFromAppDir(IDirectory appDir, String manifestName) throws IOException{
1:     IFile manifestFile = appDir.getFile(manifestName);
1:     Manifest man = null;
1:     if (manifestFile != null) {
0:       man = parseManifest(manifestFile.open());
1:     }
1:     return man;
1:   }
1: 
1:   
1:   /**
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:2d72200
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.aries.application.utils.manifest;
1: import java.io.BufferedReader;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
0: import java.util.Set;
1: import java.util.Map.Entry;
1: import java.util.jar.Attributes;
1: import java.util.jar.Manifest;
1: 
0: import org.apache.aries.application.filesystem.IDirectory;
0: import org.apache.aries.application.filesystem.IFile;
1: 
1: /**
1:  * This class contains utilities for parsing manifests. It provides methods to
1:  * parse the manifest, read a manifest into a map and to split an manifest
1:  * entry that follows the Import-Package syntax.
1:  */
1: public class ManifestProcessor
1: {
1:   /**
1:    * Reads a manifest's main attributes into a String->String map.
0:    * <p>
1:    * Will always return a map, empty if the manifest had no attributes.
1:    * 
1:    * @param mf The manifest to read.
1:    * @return Map of manifest main attributes.
1:    */
1:   public static Map<String, String> readManifestIntoMap(Manifest mf){
1: 
1:     HashMap<String, String> props = new HashMap<String, String>();
1:     
1:     Attributes mainAttrs = mf.getMainAttributes();
1:     if (mainAttrs!=null){
1:       Set<Entry<Object, Object>> attributeSet =  mainAttrs.entrySet(); 
1:       if (attributeSet != null){
1:         // Copy all the manifest headers across. The entry set should be a set of
1:         // Name to String mappings, by calling String.valueOf we do the conversion
1:         // to a string and we do not NPE.
1:         for (Map.Entry<Object, Object> entry : attributeSet) {
1:           props.put(String.valueOf(entry.getKey()), String.valueOf(entry.getValue()));
0:         }
0:       }    
0:     }
1:          
1:     return props;
0:   }
1:   
1:   /**
1:    * This method parses the manifest using a custom manifest parsing routine.
1:    * This means that we can avoid the 76 byte line length in a manifest providing
1:    * a better developer experience.
1:    * 
1:    * @param in the input stream to read the manifest from.
1:    * @return   the parsed manifest
1:    * @throws IOException
1:    */
1:   public static Manifest parseManifest(InputStream in) throws IOException
1:   {
1:     Manifest man = new Manifest();
1:     
0:     // I'm assuming that we use UTF-8 here, but the jar spec doesn't say.
0:     BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
1:     
0:     String line;
0:     StringBuilder attribute = null;
1:     
0:     String namedAttribute = null;
1:     
0:     do {
0:       line = reader.readLine();
1: 
0:       // if we get a blank line skip to the next one
0:       if (line != null && line.trim().length() == 0) continue;
0:       if (line != null && line.charAt(0) == ' ' && attribute != null) {
0:         // we have a continuation line, so add to the builder, ignoring the
0:         // first character
0:         attribute.append(line.trim());
0:       } else if (attribute == null) {
0:         attribute = new StringBuilder(line.trim());
0:       } else if (attribute != null) {
0:         // We have fully parsed an attribute
0:         int index = attribute.indexOf(":");
0:         String attributeName = attribute.substring(0, index).trim();
0:         // TODO cope with index + 1 being after the end of attribute
0:         String attributeValue = attribute.substring(index + 1).trim();
1:         
0:         if ("Name".equals(attributeName)) {
0:           man.getEntries().put(attributeValue, new Attributes());
0:           namedAttribute = attributeValue;
0:         } else {
0:           if (namedAttribute == null) {
0:             man.getMainAttributes().put(new Attributes.Name(attributeName), attributeValue);
0:           } else {
0:             man.getAttributes(namedAttribute).put(new Attributes.Name(attributeName), attributeValue);
0:           }
0:         }
1:         
0:         if (line != null) attribute = new StringBuilder(line.trim());
0:       }
0:     } while (line != null);
1:     
1:     return man;
0:   }
1:   
1:   /**
0:    * Obtain a manifest from an IDirectory. 
1:    * 
0:    * @param appDir
0:    * @param manifestName the name of manifest
0:    * @return Manifest, or null if none found.
1:    * @throws IOException
1:    */
0:   public static Manifest obtainManifestFromAppDir(IDirectory appDir, String manifestName) throws IOException{
0:     IFile manifestFile = appDir.getFile(manifestName);
0:     Manifest man = null;
0:     if (manifestFile != null) {
0:       man = parseManifest(manifestFile.open());
0:     }
1:     return man;
0:   }
1: 
1:   
1:   /**
1:    * 
1:    * Splits a delimiter separated string, tolerating presence of non separator commas
1:    * within double quoted segments.
1:    * 
1:    * Eg.
1:    * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]" &
1:    * com.ibm.ws.eba.helloWorldService;version="1.0.0"
1:    * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"
1:    * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"
1:    *  @param value          the value to be split
1:    *  @param delimiter      the delimiter string such as ',' etc.
1:    *  @return List<String>  the components of the split String in a list
1:    */
1:   public static List<String> split(String value, String delimiter)
1:   {
1: 
1:     List<String> result = new ArrayList<String>();
1:     if (value != null) {
1:       String[] packages = value.split(delimiter);
1:       
1:       for (int i = 0; i < packages.length; ) {
1:         String tmp = packages[i++].trim();
1:         // if there is a odd number of " in a string, we need to append
1:         while (count(tmp, "\"") % 2 == 1) {
1:           // check to see if we need to append the next package[i++]
1:           tmp = tmp + delimiter + packages[i++].trim();
0:         }
1:         
1:         result.add(tmp);
0:       }
0:     }
1: 
0:     return result;
0:   }  
1:   
1:   /**
1:    * count the number of characters in a string
1:    * @param parent The string to be searched
1:    * @param subString The substring to be found
1:    * @return the number of occurrence of the subString
1:    */
1:    private static int count(String parent, String subString) {
1:      
1:      int count = 0 ;
1:      int i = parent.indexOf(subString);
1:      while (i > -1) {
1:        if (parent.length() >= i+1)
1:          parent = parent.substring(i+1);
1:        count ++;
1:        i = parent.indexOf(subString);
0:      }
1:      return count;
0:    }  
commit:8914925
commit:1ddafd3
/////////////////////////////////////////////////////////////////////////
0:       String trimmedLine = line.trim();
0:       if (trimmedLine.length() == 0) continue;
0:         attribute.append(trimmedLine);
0:         attribute = new StringBuilder(trimmedLine);
0:         attribute = new StringBuilder(trimmedLine);
commit:a52f908
/////////////////////////////////////////////////////////////////////////
0:         namedAttribute = setAttribute(man, namedAttribute, attribute);
0:     if (attribute != null) {
0:         setAttribute(man, namedAttribute, attribute);
0:     }
0:     
0:   private static String setAttribute(Manifest man, String namedAttribute, StringBuilder attribute) 
0:   {
0:       int index = attribute.indexOf(":");
0:       String attributeName = attribute.substring(0, index).trim();
0:       // TODO cope with index + 1 being after the end of attribute
0:       String attributeValue = attribute.substring(index + 1).trim();
0:       
0:       if ("Name".equals(attributeName)) {
0:         man.getEntries().put(attributeValue, new Attributes());
0:         namedAttribute = attributeValue;
0:       } else {
0:         if (namedAttribute == null) {
0:           man.getMainAttributes().put(new Attributes.Name(attributeName), attributeValue);
0:         } else {
0:           man.getAttributes(namedAttribute).put(new Attributes.Name(attributeName), attributeValue);
0:         }
0:       }
0:       
0:       return namedAttribute;
0:   }
0:   
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:3162c07
/////////////////////////////////////////////////////////////////////////
0:     do {
0:       line = reader.readLine();
0: 
0:       if (line != null && line.trim().length() == 0) continue;
0:       if (line != null && line.charAt(0) == ' ' && attribute != null) {
0:         attribute.append(line.trim());
0:         attribute = new StringBuilder(line.trim());
0:         int index = attribute.indexOf(":");
0:         String attributeName = attribute.substring(0, index).trim();
0:         // TODO cope with index + 1 being after the end of attribute
0:         String attributeValue = attribute.substring(index + 1).trim();
0:         if ("Name".equals(attributeName)) {
0:           man.getEntries().put(attributeValue, new Attributes());
0:           namedAttribute = attributeValue;
0:         } else {
0:           if (namedAttribute == null) {
0:             man.getMainAttributes().put(new Attributes.Name(attributeName), attributeValue);
0:           } else {
0:             man.getAttributes(namedAttribute).put(new Attributes.Name(attributeName), attributeValue);
0:           }
0:         }
0:         
0:         if (line != null) attribute = new StringBuilder(line.trim());
0:     } while (line != null);
commit:629b3bd
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedReader;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * This class contains utilities for parsing manifests. It provides methods to
0:  * parse the manifest, read a manifest into a map and to split an manifest
0:  * entry that follows the Import-Package syntax.
0:  */
/////////////////////////////////////////////////////////////////////////
0:    * This method parses the manifest using a custom manifest parsing routine.
0:    * This means that we can avoid the 76 byte line length in a manifest providing
0:    * a better developer experience.
0:    * 
0:    * @param in the input stream to read the manifest from.
0:    * @return   the parsed manifest
0:    * @throws IOException
0:    */
0:   public static Manifest parseManifest(InputStream in) throws IOException
0:   {
0:     Manifest man = new Manifest();
0:     
0:     // I'm assuming that we use UTF-8 here, but the jar spec doesn't say.
0:     BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
0:     
0:     String line;
0:     StringBuilder attribute = null;
0:     
0:     String namedAttribute = null;
0:     
0:     while ((line = reader.readLine()) != null) {
0:       line = line.trim();
0:       // if we get a blank line skip to the next one
0:       if (line.length() == 0) continue;
0:       if (line.charAt(0) == ' ' && attribute != null) {
0:         // we have a continuation line, so add to the builder, ignoring the
0:         // first character
0:         attribute.append(line.substring(1));
0:       } else if (attribute == null) {
0:         attribute = new StringBuilder(line);
0:       } else if (attribute != null) {
0:         // We have fully parsed an attribute
0:         int index = attribute.indexOf(":");
0:         String attributeName = attribute.substring(0, index).trim();
0:         // TODO cope with index + 1 being after the end of attribute
0:         String attributeValue = attribute.substring(index + 1).trim();
0:         
0:         if ("Name".equals(attributeName)) {
0:           man.getEntries().put(attributeValue, new Attributes());
0:           namedAttribute = attributeValue;
0:         } else {
0:           if (namedAttribute == null) {
0:             man.getMainAttributes().put(new Attributes.Name(attributeName), attributeValue);
0:           } else {
0:             man.getAttributes(namedAttribute).put(new Attributes.Name(attributeName), attributeValue);
0:           }
0:         }
0:         
0:         attribute = new StringBuilder(line);
0:       }
0:     }
0:     
0:     return man;
0:   }
0:   
0:   /**
/////////////////////////////////////////////////////////////////////////
0:           // check to see if we need to append the next package[i++]
0:           tmp = tmp + delimiter + packages[i++].trim();
author:Graham Charters
-------------------------------------------------------------------------------
commit:d77c519
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.application.utils.manifest;
0: 
0: import static org.apache.aries.application.utils.AppConstants.TRACE_GROUP;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.Map.Entry;
0: import java.util.jar.Attributes;
0: import java.util.jar.Manifest;
0: 
0: public class ManifestProcessor
0: {
0:   /**
0:    * Reads a manifest's main attributes into a String->String map.
0:    * <p>
0:    * Will always return a map, empty if the manifest had no attributes.
0:    * 
0:    * @param mf The manifest to read.
0:    * @return Map of manifest main attributes.
0:    */
0:   public static Map<String, String> readManifestIntoMap(Manifest mf){
0: 
0:     HashMap<String, String> props = new HashMap<String, String>();
0:     
0:     Attributes mainAttrs = mf.getMainAttributes();
0:     if (mainAttrs!=null){
0:       Set<Entry<Object, Object>> attributeSet =  mainAttrs.entrySet(); 
0:       if (attributeSet != null){
0:         // Copy all the manifest headers across. The entry set should be a set of
0:         // Name to String mappings, by calling String.valueOf we do the conversion
0:         // to a string and we do not NPE.
0:         for (Map.Entry<Object, Object> entry : attributeSet) {
0:           props.put(String.valueOf(entry.getKey()), String.valueOf(entry.getValue()));
0:         }
0:       }    
0:     }
0:          
0:     return props;
0:   }
0:   
0:   /**
0:    * 
0:    * Splits a delimiter separated string, tolerating presence of non separator commas
0:    * within double quoted segments.
0:    * 
0:    * Eg.
0:    * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]" &
0:    * com.ibm.ws.eba.helloWorldService;version="1.0.0"
0:    * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"
0:    * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"
0:    *  @param value          the value to be split
0:    *  @param delimiter      the delimiter string such as ',' etc.
0:    *  @return List<String>  the components of the split String in a list
0:    */
0:   public static List<String> split(String value, String delimiter)
0:   {
0: 
0:     List<String> result = new ArrayList<String>();
0:     if (value != null) {
0:       String[] packages = value.split(delimiter);
0:       
0:       for (int i = 0; i < packages.length; ) {
0:         String tmp = packages[i++].trim();
0:         // if there is a odd number of " in a string, we need to append
0:         while (count(tmp, "\"") % 2 == 1) {
0:           // check to see if we need to append the next package[i++]          
0:             tmp = tmp + delimiter + packages[i++].trim();          
0:         }
0:         
0:         result.add(tmp);
0:       }
0:     }
0: 
0:     return result;
0:   }  
0:   
0:   /**
0:    * count the number of characters in a string
0:    * @param parent The string to be searched
0:    * @param subString The substring to be found
0:    * @return the number of occurrence of the subString
0:    */
0:    private static int count(String parent, String subString) {
0:      
0:      int count = 0 ;
0:      int i = parent.indexOf(subString);
0:      while (i > -1) {
0:        if (parent.length() >= i+1)
0:          parent = parent.substring(i+1);
0:        count ++;
0:        i = parent.indexOf(subString);
0:      }
0:      return count;
0:    }  
0: }
============================================================================