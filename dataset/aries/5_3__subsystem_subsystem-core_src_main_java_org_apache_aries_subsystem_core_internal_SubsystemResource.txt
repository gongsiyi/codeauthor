1:a14f2fd: /*
1:8ad6b99:  * Licensed to the Apache Software Foundation (ASF) under one
1:8ad6b99:  * or more contributor license agreements.  See the NOTICE file
1:8ad6b99:  * distributed with this work for additional information
1:8ad6b99:  * regarding copyright ownership.  The ASF licenses this file
1:8ad6b99:  * to you under the Apache License, Version 2.0 (the
1:8ad6b99:  * "License"); you may not use this file except in compliance
1:8ad6b99:  * with the License.  You may obtain a copy of the License at
1:a14f2fd:  *
1:8ad6b99:  *   http://www.apache.org/licenses/LICENSE-2.0
1:a14f2fd:  *
1:8ad6b99:  * Unless required by applicable law or agreed to in writing,
1:8ad6b99:  * software distributed under the License is distributed on an
1:8ad6b99:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:8ad6b99:  * KIND, either express or implied.  See the License for the
1:8ad6b99:  * specific language governing permissions and limitations
1:8ad6b99:  * under the License.
1:a14f2fd:  */
1:67ef08f: package org.apache.aries.subsystem.core.internal;
18:67ef08f: 
1:225bcae: import java.io.File;
1:67ef08f: import java.io.IOException;
1:67ef08f: import java.net.URISyntaxException;
1:67ef08f: import java.util.ArrayList;
1:67ef08f: import java.util.Collection;
1:67ef08f: import java.util.Collections;
1:67ef08f: import java.util.HashSet;
1:67ef08f: import java.util.List;
1:67ef08f: import java.util.Map;
1:ab24f61: 
1:a990e32: import org.apache.aries.subsystem.core.archive.AriesSubsystemParentsHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.Attribute;
1:67ef08f: import org.apache.aries.subsystem.core.archive.DeployedContentHeader;
1:67ef08f: import org.apache.aries.subsystem.core.archive.DeploymentManifest;
1:777b216: import org.apache.aries.subsystem.core.archive.Header;
1:777b216: import org.apache.aries.subsystem.core.archive.ImportPackageHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.ImportPackageRequirement;
1:67ef08f: import org.apache.aries.subsystem.core.archive.ProvisionResourceHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.RequireBundleHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.RequireBundleRequirement;
1:777b216: import org.apache.aries.subsystem.core.archive.RequireCapabilityHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.RequireCapabilityRequirement;
1:67ef08f: import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
1:b75f264: import org.apache.aries.subsystem.core.archive.SubsystemExportServiceHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.SubsystemImportServiceHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.SubsystemImportServiceRequirement;
1:67ef08f: import org.apache.aries.subsystem.core.archive.SubsystemManifest;
1:777b216: import org.apache.aries.util.filesystem.FileSystem;
1:777b216: import org.apache.aries.util.filesystem.IDirectory;
1:777b216: import org.eclipse.equinox.region.Region;
1:777b216: import org.eclipse.equinox.region.RegionDigraph;
1:777b216: import org.eclipse.equinox.region.RegionFilter;
1:777b216: import org.eclipse.equinox.region.RegionFilterBuilder;
1:2b251bb: import org.osgi.framework.Bundle;
1:777b216: import org.osgi.framework.BundleException;
1:777b216: import org.osgi.framework.InvalidSyntaxException;
1:a6b79e8: import org.osgi.framework.namespace.ExecutionEnvironmentNamespace;
1:777b216: import org.osgi.framework.namespace.IdentityNamespace;
1:d6eb080: import org.osgi.framework.namespace.NativeNamespace;
1:67ef08f: import org.osgi.framework.wiring.BundleRevision;
1:d6eb080: import org.osgi.namespace.service.ServiceNamespace;
1:67ef08f: import org.osgi.resource.Capability;
1:d6eb080: import org.osgi.resource.Namespace;
1:67ef08f: import org.osgi.resource.Requirement;
1:67ef08f: import org.osgi.resource.Resource;
1:67ef08f: import org.osgi.resource.Wire;
1:777b216: import org.osgi.service.coordinator.Coordination;
1:777b216: import org.osgi.service.coordinator.Participant;
1:67ef08f: import org.osgi.service.resolver.ResolutionException;
1:67ef08f: import org.osgi.service.resolver.ResolveContext;
1:777b216: import org.osgi.service.subsystem.Subsystem;
1:67ef08f: import org.osgi.service.subsystem.SubsystemConstants;
1:67ef08f: import org.osgi.service.subsystem.SubsystemException;
1:67ef08f: 
1:67ef08f: public class SubsystemResource implements Resource {
1:777b216: 	private Region region;
1:777b216: 
1:b75f264: 	private final List<Capability> capabilities;
1:67ef08f: 	private final DeploymentManifest deploymentManifest;
1:67ef08f: 	private final Collection<Resource> installableContent = new HashSet<Resource>();
1:67ef08f: 	private final Collection<Resource> installableDependencies = new HashSet<Resource>();
1:67ef08f: 	private final Collection<Resource> mandatoryResources = new HashSet<Resource>();
1:2b251bb: 	private final Collection<DeployedContentHeader.Clause> missingResources = new HashSet<DeployedContentHeader.Clause>();
1:67ef08f: 	private final Collection<Resource> optionalResources = new HashSet<Resource>();
1:5bd3bf6: 	private final BasicSubsystem parent;
1:67ef08f: 	private final RawSubsystemResource resource;
1:67ef08f: 	private final Collection<Resource> sharedContent = new HashSet<Resource>();
1:67ef08f: 	private final Collection<Resource> sharedDependencies = new HashSet<Resource>();
1:67ef08f: 
1:b66ad7c: 	public SubsystemResource(String location, IDirectory content, BasicSubsystem parent, Coordination coordination) throws URISyntaxException, IOException, ResolutionException, BundleException, InvalidSyntaxException {
1:b66ad7c: 		this(new RawSubsystemResource(location, content, parent), parent, coordination);
1:ab24f61: 	}
1:445abc4: 
1:b66ad7c: 	public SubsystemResource(RawSubsystemResource resource, BasicSubsystem parent, Coordination coordination) throws IOException, BundleException, InvalidSyntaxException, URISyntaxException {
1:67ef08f: 		this.parent = parent;
1:67ef08f: 		this.resource = resource;
1:777b216: 		computeContentResources(resource.getDeploymentManifest());
1:b75f264: 		capabilities = computeCapabilities();
1:a990e32: 		if (this.getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective().isInstall()) {
1:a990e32: 		    /* compute dependencies now only if we intend to provision them during install */
1:b66ad7c: 	        computeDependencies(resource.getDeploymentManifest(), coordination);		    
1:a990e32: 		}
1:67ef08f: 		deploymentManifest = computeDeploymentManifest();
1:ed5f3dc: 	}
1:ed5f3dc: 
1:2b13b05: 	public SubsystemResource(File file) throws IOException, URISyntaxException, ResolutionException, BundleException, InvalidSyntaxException {
1:a990e32: 		this(null, FileSystem.getFSRoot(file));
1:ed5f3dc: 	}
1:ab24f61: 
1:a990e32: 	public SubsystemResource(BasicSubsystem subsystem, IDirectory directory) throws IOException, URISyntaxException, ResolutionException, BundleException, InvalidSyntaxException {
1:a990e32: 		if (subsystem == null) {
1:a990e32: 			// This is intended to only support the case where the root subsystem
1:a990e32: 			// is being initialized from a non-persistent state.
1:a990e32: 			parent = null;
1:a990e32: 		}
1:a990e32: 		else {
1:a990e32: 			parent = Utils.findScopedSubsystemInRegion(subsystem);
1:a990e32: 		}
1:79b20bc: 		resource = new RawSubsystemResource(directory, parent);
1:777b216: 		deploymentManifest = resource.getDeploymentManifest();
1:777b216: 		computeContentResources(deploymentManifest);
1:b75f264: 		capabilities = computeCapabilities();
1:a990e32:         if (getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective().isInstall()) {
1:a990e32:             /* compute dependencies if we intend to provision them during install */
1:b66ad7c:             computeDependencies(resource.getDeploymentManifest(), null);          
1:a990e32:         }
1:ed5f3dc: 	}
1:307d743: 
1:307d743: 	@Override
1:307d743: 	public boolean equals(Object o) {
1:307d743: 		if (o == this)
1:307d743: 			return true;
1:307d743: 		if (!(o instanceof SubsystemResource))
1:2b13b05: 			return false;
1:307d743: 		SubsystemResource that = (SubsystemResource)o;
1:307d743: 		return getLocation().equals(that.getLocation());
1:ab24f61: 	}
1:777b216: 
7:67ef08f: 	@Override
1:67ef08f: 	public List<Capability> getCapabilities(String namespace) {
1:b75f264: 		return Collections.unmodifiableList(capabilities);
1:b75f264: 	}
1:b75f264: 
1:b75f264: 	private List<Capability> computeCapabilities() throws InvalidSyntaxException {
1:b75f264: 		List<Capability> capabilities = new ArrayList<Capability>();
1:307d743: 		if (isScoped())
1:b75f264: 			computeScopedCapabilities(capabilities);
1:b75f264: 		else
1:b75f264: 			computeUnscopedCapabilities(capabilities);
1:b75f264: 		return capabilities;
1:ed5f3dc: 	}
1:b75f264: 
1:b75f264: 	private void computeUnscopedCapabilities(List<Capability> capabilities) {
1:b75f264: 		capabilities.addAll(resource.getCapabilities(null));
1:b75f264: 		for (Resource r : getContentResources())
1:b75f264: 			capabilities.addAll(r.getCapabilities(null));
1:b75f264: 	}
1:b75f264: 
1:b75f264: 	private void computeScopedCapabilities(List<Capability> capabilities) throws InvalidSyntaxException {
1:b75f264: 		capabilities.addAll(resource.getCapabilities(null));
1:b75f264: 		computeOsgiServiceCapabilities(capabilities);
1:b75f264: 	}
1:b75f264: 
1:6740c72: 	private void computeOsgiServiceCapabilities(List<Capability> capabilities) throws InvalidSyntaxException {
1:b75f264: 		SubsystemExportServiceHeader header = getSubsystemManifest().getSubsystemExportServiceHeader();
1:4693281: 		if (header == null)
1:4693281: 			return;
1:b75f264: 		for (Resource resource : getContentResources())
1:b75f264: 			capabilities.addAll(header.toCapabilities(resource));
1:b75f264: 	}
1:777b216: 
1:67ef08f: 	public DeploymentManifest getDeploymentManifest() {
1:67ef08f: 		return deploymentManifest;
1:307d743: 	}
1:225bcae: 
1:225bcae: 	public long getId() {
1:4fd3b7f: 		return resource.getId();
1:777b216: 	}
1:225bcae: 
1:67ef08f: 	public Collection<Resource> getInstallableContent() {
1:67ef08f: 		return installableContent;
1:777b216: 	}
1:67ef08f: 
1:67ef08f: 	public Collection<Resource> getInstallableDependencies() {
1:67ef08f: 		return installableDependencies;
1:225bcae: 	}
1:67ef08f: 
1:d6eb080: 	public org.apache.aries.subsystem.core.repository.Repository getLocalRepository() {
1:67ef08f: 		return resource.getLocalRepository();
1:225bcae: 	}
1:67ef08f: 
1:67ef08f: 	public String getLocation() {
1:67ef08f: 		return resource.getLocation().getValue();
30:67ef08f: 	}
1:67ef08f: 
1:d6eb080: 	Collection<Resource> getMandatoryResources() {
1:d6eb080: 		return mandatoryResources;
1:67ef08f: 	}
1:67ef08f: 	
1:2b251bb: 	public Collection<DeployedContentHeader.Clause> getMissingResources() {
1:2b251bb: 		return missingResources;
1:2b251bb: 	}
1:2b251bb: 
1:d6eb080: 	Collection<Resource> getOptionalResources() {
1:d6eb080: 		return optionalResources;
1:67ef08f: 	}
1:67ef08f: 	
1:5bd3bf6: 	public Collection<BasicSubsystem> getParents() {
1:777b216: 		if (parent == null) {
1:a990e32: 			AriesSubsystemParentsHeader header = getDeploymentManifest().getAriesSubsystemParentsHeader();
1:b75f264: 			if (header == null)
1:777b216: 				return Collections.emptyList();
1:a990e32: 			Collection<AriesSubsystemParentsHeader.Clause> clauses = header.getClauses();
1:a990e32: 			Collection<BasicSubsystem> result = new ArrayList<BasicSubsystem>(clauses.size());
1:a990e32: 			Subsystems subsystems = Activator.getInstance().getSubsystems();
1:a990e32: 			for (AriesSubsystemParentsHeader.Clause clause : clauses) {
1:a990e32: 				result.add(subsystems.getSubsystemById(clause.getId()));
1:a990e32: 			}
1:777b216: 			return result;
1:777b216: 		}
1:777b216: 		return Collections.singleton(parent);
1:777b216: 	}
1:777b216: 
1:777b216: 	public synchronized Region getRegion() throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:777b216: 		if (region == null) {
1:777b216: 			region = createRegion(getId());
1:777b216: 			Coordination coordination = Activator.getInstance().getCoordinator().peek();
1:777b216: 			coordination.addParticipant(new Participant() {
1:777b216: 				@Override
1:777b216: 				public void ended(Coordination arg0) throws Exception {
1:2b13b05: 					// Nothing.
1:777b216: 				}
1:777b216: 
1:777b216: 				@Override
1:777b216: 				public void failed(Coordination arg0) throws Exception {
1:2b13b05: 					if (isScoped())
1:2b13b05: 						region.getRegionDigraph().removeRegion(region);
1:777b216: 				}
1:777b216: 			});
1:d6eb080: 			if (!isApplication()) {
1:777b216: 				setImportIsolationPolicy();
1:777b216: 			}
1:777b216: 		}
1:777b216: 		return region;
1:67ef08f: 	}
1:777b216: 
1:67ef08f: 	@Override
1:67ef08f: 	public List<Requirement> getRequirements(String namespace) {
1:307d743: 		if (isScoped())
1:307d743: 			return resource.getRequirements(namespace);
1:ed5f3dc: 		else {
1:307d743: 			ArrayList<Requirement> result = new ArrayList<Requirement>();
1:307d743: 			result.addAll(resource.getRequirements(namespace));
1:307d743: 			for (Resource r : getContentResources())
1:307d743: 				result.addAll(r.getRequirements(namespace));
1:307d743: 			result.trimToSize();
1:307d743: 			return result;
1:307d743: 		}
1:307d743: 	}
1:67ef08f: 
1:67ef08f: 	public Collection<Resource> getSharedContent() {
1:67ef08f: 		return sharedContent;
1:67ef08f: 	}
1:67ef08f: 
1:67ef08f: 	public Collection<Resource> getSharedDependencies() {
1:67ef08f: 		return sharedDependencies;
1:67ef08f: 	}
1:67ef08f: 
1:67ef08f: 	public SubsystemManifest getSubsystemManifest() {
1:67ef08f: 		return resource.getSubsystemManifest();
1:67ef08f: 	}
1:67ef08f: 
1:d6eb080: 	public Collection<TranslationFile> getTranslations() {
1:d6eb080: 		return resource.getTranslations();
1:67ef08f: 	}
1:67ef08f: 	
1:307d743: 	@Override
1:307d743: 	public int hashCode() {
1:307d743: 		int result = 17;
1:307d743: 		result = 31 * result + getLocation().hashCode();
1:307d743: 		return result;
1:307d743: 	}
1:307d743: 
1:67ef08f: 	private void addContentResource(Resource resource) {
1:777b216: 		if (resource == null)
1:b75f264: 			return;
1:67ef08f: 		if (isMandatory(resource))
1:67ef08f: 			mandatoryResources.add(resource);
1:ed5f3dc: 		else
1:67ef08f: 			optionalResources.add(resource);
2:67ef08f: 		if (isInstallable(resource))
1:67ef08f: 			installableContent.add(resource);
1:777b216: 		else
1:67ef08f: 			sharedContent.add(resource);
1:777b216: 	}
1:67ef08f: 
1:2b251bb: 	private void addMissingResource(DeployedContentHeader.Clause resource) {
1:2b251bb: 		missingResources.add(resource);
1:777b216: 	}
1:67ef08f: 
1:777b216: 	private void addSubsystemServiceImportToSharingPolicy(
1:777b216: 			RegionFilterBuilder builder) throws InvalidSyntaxException, BundleException, IOException, URISyntaxException {
1:777b216: 		builder.allow(
1:777b216: 				RegionFilter.VISIBLE_SERVICE_NAMESPACE,
1:777b216: 				new StringBuilder("(&(")
1:777b216: 						.append(org.osgi.framework.Constants.OBJECTCLASS)
1:777b216: 						.append('=').append(Subsystem.class.getName())
1:777b216: 						.append(")(")
1:777b216: 						.append(Constants.SubsystemServicePropertyRegions)
1:777b216: 						.append('=').append(getRegion().getName())
1:777b216: 						.append("))").toString());
1:777b216: 	}
1:777b216: 
1:777b216: 	private void addSubsystemServiceImportToSharingPolicy(RegionFilterBuilder builder, Region to)
1:777b216: 			throws InvalidSyntaxException, BundleException, IOException, URISyntaxException {
1:ed5f3dc: 		Region root = Activator.getInstance().getSubsystems().getRootSubsystem().getRegion();
1:ed5f3dc: 		if (to.getName().equals(root.getName()))
1:777b216: 			addSubsystemServiceImportToSharingPolicy(builder);
1:307d743: 		else {
1:ed5f3dc: 			to = root;
1:777b216: 			builder = to.getRegionDigraph().createRegionFilterBuilder();
1:777b216: 			addSubsystemServiceImportToSharingPolicy(builder);
1:777b216: 			RegionFilter regionFilter = builder.build();
1:777b216: 			getRegion().connectRegion(to, regionFilter);
1:777b216: 		}
1:777b216: 	}
1:777b216: 
1:2b13b05: 	private void computeContentResources(DeploymentManifest manifest) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:777b216: 		if (manifest == null)
1:777b216: 			computeContentResources(getSubsystemManifest());
1:307d743: 		else {
1:777b216: 			DeployedContentHeader header = manifest.getDeployedContentHeader();
1:777b216: 			if (header == null)
1:777b216: 				return;
1:777b216: 			for (DeployedContentHeader.Clause clause : header.getClauses()) {
1:777b216: 				Resource resource = findContent(clause);
1:777b216: 				if (resource == null)
1:2b251bb: 					addMissingResource(clause);
1:2b251bb: 				else
1:2b251bb: 					addContentResource(resource);
1:777b216: 			}
1:777b216: 		}
1:777b216: 	}
1:777b216: 
1:2b13b05: 	private void computeContentResources(SubsystemManifest manifest) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:777b216: 		SubsystemContentHeader contentHeader = manifest.getSubsystemContentHeader();
1:67ef08f: 		if (contentHeader == null)
1:777b216: 			return;
1:547a8ce: 		for (SubsystemContentHeader.Clause clause : contentHeader.getClauses()) {
1:4b41d3d: 			Requirement requirement = clause.toRequirement(this);
1:67ef08f: 			Resource resource = findContent(requirement);
1:67ef08f: 			if (resource == null) {
1:547a8ce: 				if (clause.isMandatory())
1:f5193a6: 					throw new SubsystemException("A required content resource could not be found. This means the resource was either missing or not recognized as a supported resource format due to, for example, an invalid bundle manifest or blueprint XML file. Turn on debug logging for more information. The resource was: " + requirement);
1:67ef08f: 				continue;
1:7d27e24: 			}
1:777b216: 			addContentResource(resource);
1:7d27e24: 		}
1:7d27e24: 	}
1:7d27e24: 
1:b66ad7c: 	void computeDependencies(DeploymentManifest manifest, Coordination coordination) {
1:a990e32: 	    if (manifest == null) {
1:b66ad7c: 	        computeDependencies(getSubsystemManifest(), coordination);
1:a990e32: 	    }
1:a990e32: 	    else {
1:a990e32: 	        ProvisionResourceHeader header = manifest.getProvisionResourceHeader();
1:a990e32: 	        if (header == null)
1:a990e32: 	            return;
1:a990e32: 	        for (ProvisionResourceHeader.Clause clause : header.getClauses()) {
1:a990e32: 	            Resource resource = findDependency(clause);
1:a990e32: 	            if (resource == null)
1:a990e32: 	                throw new SubsystemException("A required dependency could not be found. This means the resource was either missing or not recognized as a supported resource format due to, for example, an invalid bundle manifest or blueprint XML file. Turn on debug logging for more information. The resource was: " + resource);
1:a990e32: 	            addDependency(resource);
1:a990e32: 	        }
1:a990e32: 	    }
1:777b216: 	}
1:777b216: 	
1:445abc4: 	private void addDependency(Resource resource) {
1:445abc4: 		if (resource == null)
1:445abc4: 			return;
1:445abc4: 		if (isInstallable(resource))
1:445abc4: 			installableDependencies.add(resource);
1:445abc4: 		else
1:445abc4: 			sharedDependencies.add(resource);
1:445abc4: 	}
1:2b251bb: 
1:b66ad7c: 	private void computeDependencies(SubsystemManifest manifest, Coordination coordination)  {
1:777b216: 		try {
1:b66ad7c: 			// The following line is necessary in order to ensure that the
1:b66ad7c: 			// export sharing policies of composites are in place for capability
1:b66ad7c: 			// validation.
1:b66ad7c: 			StartAction.setExportPolicyOfAllInstallingSubsystemsWithProvisionDependenciesResolve(coordination);
1:7d27e24: 			Map<Resource, List<Wire>> resolution = Activator.getInstance().getResolver().resolve(createResolveContext());
1:d6eb080: 			setImportIsolationPolicy(resolution);
1:445abc4: 			addDependencies(resolution);
1:2b251bb: 		}
1:d6eb080: 		catch (Exception e) {
1:445abc4: 			Utils.handleTrowable(e);
1:445abc4: 		}
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void addDependencies(Map<Resource, List<Wire>> resolution) {
1:445abc4: 		for (Map.Entry<Resource, List<Wire>> entry : resolution.entrySet()) {
1:445abc4: 			addDependencies(entry, resolution);
1:445abc4: 		}
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void addDependencies(Map.Entry<Resource, List<Wire>> entry, Map<Resource, List<Wire>> resolution) {
1:445abc4: 		addDependencies(entry.getKey(), entry, resolution);
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void addDependencies(Resource resource, Map.Entry<Resource, List<Wire>> entry, Map<Resource, List<Wire>> resolution) {
1:445abc4: 		String type = ResourceHelper.getTypeAttribute(resource);
1:445abc4: 		SubsystemContentHeader contentHeader = getSubsystemManifest().getSubsystemContentHeader();
1:445abc4: 		if (!Constants.ResourceTypeSynthesized.equals(type) // Do not include synthetic resources as dependencies.
1:445abc4: 				&& !contentHeader.contains(resource)) { // Do not include content as dependencies.
1:445abc4: 			addDependency(resource);
1:9f94bb4: 		}
1:7d27e24: 	}
1:7d27e24: 
1:7d27e24: 	private DeployedContentHeader computeDeployedContentHeader() {
1:7d27e24: 		Collection<Resource> content = getContentResources();
1:7d27e24: 		if (content.isEmpty())
1:7d27e24: 			return null;
1:7d27e24: 		return DeployedContentHeader.newInstance(content);
1:67ef08f: 	}
1:67ef08f: 
1:67ef08f: 	private DeploymentManifest computeDeploymentManifest() throws IOException {
1:67ef08f: 		DeploymentManifest result = computeExistingDeploymentManifest();
1:67ef08f: 		if (result != null)
1:307d743: 			return result;
1:67ef08f: 		result = new DeploymentManifest.Builder().manifest(resource.getSubsystemManifest())
1:67ef08f: 				.header(computeDeployedContentHeader())
1:67ef08f: 				.header(computeProvisionResourceHeader()).build();
3:777b216: 		return result;
1:67ef08f: 	}
1:67ef08f: 
1:7d27e24: 	private DeploymentManifest computeExistingDeploymentManifest() throws IOException {
1:7d27e24: 		return resource.getDeploymentManifest();
1:7d27e24: 	}
1:7d27e24: 
1:a990e32: 	ProvisionResourceHeader computeProvisionResourceHeader() {
1:3b4e485: 		Collection<Resource> dependencies = getDependencies();
1:7d27e24: 		if (dependencies.isEmpty())
3:67ef08f: 			return null;
1:7d27e24: 		return ProvisionResourceHeader.newInstance(dependencies);
1:67ef08f: 	}
1:67ef08f: 
1:777b216: 	private Region createRegion(long id) throws BundleException {
1:777b216: 		if (!isScoped())
1:777b216: 			return getParents().iterator().next().getRegion();
1:777b216: 		Activator activator = Activator.getInstance();
1:777b216: 		RegionDigraph digraph = activator.getRegionDigraph();
1:777b216: 		if (getParents().isEmpty())
1:8481849: 			// This is the root subsystem. Associate it with the region in which
1:8481849: 			// the subsystems implementation bundle was installed.
1:8481849: 			return digraph.getRegion(activator.getBundleContext().getBundle());
1:777b216: 		String name = getSubsystemManifest()
1:777b216: 				.getSubsystemSymbolicNameHeader().getSymbolicName()
1:777b216: 				+ ';'
1:777b216: 				+ getSubsystemManifest().getSubsystemVersionHeader()
1:777b216: 						.getVersion()
1:777b216: 				+ ';'
1:777b216: 				+ getSubsystemManifest().getSubsystemTypeHeader()
1:777b216: 						.getType() + ';' + Long.toString(id);
1:777b216: 		Region region = digraph.getRegion(name);
1:777b216: 		// TODO New regions need to be cleaned up if this subsystem fails to
1:777b216: 		// install, but there's no access to the coordination here.
1:777b216: 		if (region == null)
1:777b216: 			return digraph.createRegion(name);
1:777b216: 		return region;
1:777b216: 	}
1:777b216: 
1:67ef08f: 	private ResolveContext createResolveContext() {
1:d6eb080: 		return new org.apache.aries.subsystem.core.internal.ResolveContext(this);
1:777b216: 	}
1:67ef08f: 
1:2b13b05: 	private Resource findContent(Requirement requirement) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:67ef08f: 		Map<Requirement, Collection<Capability>> map;
1:c3ec212: 		// TODO System repository for scoped subsystems should be searched in
1:c3ec212: 		// the case of a persisted subsystem.
1:67ef08f: 		if (isUnscoped()) {
1:67ef08f: 			map = Activator.getInstance().getSystemRepository().findProviders(Collections.singleton(requirement));
2:67ef08f: 			if (map.containsKey(requirement)) {
2:67ef08f: 				Collection<Capability> capabilities = map.get(requirement);
1:67ef08f: 				for (Capability capability : capabilities) {
1:2b13b05: 					Resource provider = capability.getResource();
1:2b13b05: 					if (provider instanceof BundleRevision) {
1:2b13b05: 						if (getRegion().contains(((BundleRevision)provider).getBundle())) {
1:2b13b05: 							return provider;
1:2b13b05: 						}
1:2b13b05: 					}
1:5bd3bf6: 					else if (provider instanceof BasicSubsystem) {
1:5bd3bf6: 						if (getRegion().equals(((BasicSubsystem)provider).getRegion())) {
1:2b13b05: 							return provider;
1:2b13b05: 						}
1:2b13b05: 					}
1:777b216: 				}
1:67ef08f: 			}
1:67ef08f: 		}
1:3b4e485: 		// First search the local repository.
1:67ef08f: 		map = resource.getLocalRepository().findProviders(Collections.singleton(requirement));
1:3b4e485: 		Collection<Capability> capabilities = map.get(requirement);
1:3b4e485: 		if (capabilities.isEmpty()) {
1:3b4e485: 			// Nothing found in the local repository so search the repository services.
1:3b4e485: 			capabilities = new RepositoryServiceRepository().findProviders(requirement);
1:67ef08f: 		}
1:3b4e485: 		if (capabilities.isEmpty()) {
1:3b4e485: 			// Nothing found period.
1:3b4e485: 			return null;
1:3b4e485: 		}
1:3b4e485: 		for (Capability capability : capabilities) {
1:3b4e485: 			if (!IdentityNamespace.TYPE_FRAGMENT.equals(
1:3b4e485: 					capability.getAttributes().get(IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE))) {
1:3b4e485: 				// Favor the first resource that is not a fragment bundle.
1:3b4e485: 				// See ARIES-1425.
1:3b4e485: 				return capability.getResource();
1:3b4e485: 			}
1:3b4e485: 		}
1:3b4e485: 		// Nothing here but fragment bundles. Return the first one.
1:3b4e485: 		return capabilities.iterator().next().getResource();
1:67ef08f: 	}
1:67ef08f: 
1:2b13b05: 	private Resource findContent(DeployedContentHeader.Clause clause) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:777b216: 		Attribute attribute = clause.getAttribute(DeployedContentHeader.Clause.ATTRIBUTE_RESOURCEID);
1:777b216: 		long resourceId = attribute == null ? -1 : Long.parseLong(String.valueOf(attribute.getValue()));
1:777b216: 		if (resourceId != -1) {
1:777b216: 			String type = clause.getType();
1:777b216: 			if (IdentityNamespace.TYPE_BUNDLE.equals(type) || IdentityNamespace.TYPE_FRAGMENT.equals(type)) {
1:2b251bb: 				Bundle resource = Activator.getInstance().getBundleContext().getBundle(0).getBundleContext().getBundle(resourceId);
1:2b251bb: 				if (resource == null)
1:2b251bb: 					return null;
1:2b251bb: 				return resource.adapt(BundleRevision.class);
1:777b216: 			}
1:777b216: 			else
1:777b216: 				return Activator.getInstance().getSubsystems().getSubsystemById(resourceId);
1:777b216: 		}
1:4b41d3d: 		return findContent(clause.toRequirement(this));
1:777b216: 	}
1:777b216: 
1:e341c9b: 	private Resource findDependency(ProvisionResourceHeader.Clause clause) {
1:e341c9b: 		Attribute attribute = clause.getAttribute(DeployedContentHeader.Clause.ATTRIBUTE_RESOURCEID);
1:e341c9b: 		long resourceId = attribute == null ? -1 : Long.parseLong(String.valueOf(attribute.getValue()));
1:777b216: 		if (resourceId != -1) {
1:e341c9b: 			String type = clause.getType();
1:777b216: 			if (IdentityNamespace.TYPE_BUNDLE.equals(type) || IdentityNamespace.TYPE_FRAGMENT.equals(type))
2:777b216: 				return Activator.getInstance().getBundleContext().getBundle(0).getBundleContext().getBundle(resourceId).adapt(BundleRevision.class);
1:777b216: 			else
1:777b216: 				return Activator.getInstance().getSubsystems().getSubsystemById(resourceId);
1:777b216: 		}
2:777b216: 		OsgiIdentityRequirement requirement = new OsgiIdentityRequirement(
1:e341c9b: 				clause.getPath(), clause.getDeployedVersion(),
1:e341c9b: 				clause.getType(), true);
1:777b216: 		List<Capability> capabilities = createResolveContext().findProviders(requirement);
1:777b216: 		if (capabilities.isEmpty())
1:777b216: 			return null;
1:777b216: 		return capabilities.get(0).getResource();
1:777b216: 	}
1:777b216: 
1:7d27e24: 	private Collection<Resource> getContentResources() {
1:7d27e24: 		Collection<Resource> result = new ArrayList<Resource>(installableContent.size() + sharedContent.size());
1:7d27e24: 		result.addAll(installableContent);
1:7d27e24: 		result.addAll(sharedContent);
1:777b216: 		return result;
1:7d27e24: 	}
1:7d27e24: 
1:3b4e485: 	private Collection<Resource> getDependencies() {
1:7d27e24: 		Collection<Resource> result = new ArrayList<Resource>(installableDependencies.size() + sharedDependencies.size());
1:7d27e24: 		result.addAll(installableDependencies);
1:7d27e24: 		result.addAll(sharedDependencies);
1:777b216: 		return result;
1:7d27e24: 	}
1:7d27e24: 
1:d6eb080: 	boolean isApplication() {
1:67ef08f: 		String type = resource.getSubsystemManifest().getSubsystemTypeHeader().getType();
1:d6eb080: 		return SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type);
1:67ef08f: 	}
1:67ef08f: 
1:d6eb080: 	boolean isComposite() {
2:d6eb080: 		String type = resource.getSubsystemManifest().getSubsystemTypeHeader().getType();
1:d6eb080: 		return SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type);
1:67ef08f: 	}
1:67ef08f: 	
1:3f524ae: 	boolean isContent(Resource resource) {
1:a990e32: 		if (installableContent.contains(resource) || sharedContent.contains(resource)) {
1:a990e32: 			return true;
1:a990e32: 		}
1:a990e32: 		// Allow for implicit subsystem installations. An implicit installation
1:a990e32: 		// occurs when a subsystem containing other subsystems as content is
1:a990e32: 		// installed. When identifying the region to be used for validation
1:a990e32: 		// purposes during resolution, resources that are content of children
1:a990e32: 		// must be treated as content of this subsystem. See ResolveContext.isValid().
1:a990e32: 		for (Resource installableResource : installableContent) {
1:a990e32: 			if (installableResource instanceof RawSubsystemResource) {
1:a990e32: 				if (((RawSubsystemResource)installableResource).getSubsystemManifest().getSubsystemContentHeader().contains(resource)) {
1:a990e32: 					return true;
1:a990e32: 				}
1:a990e32: 			}
1:a990e32: 		}
1:a990e32: 		return false;
1:3f524ae: 	}
1:3f524ae: 	
1:67ef08f: 	private boolean isInstallable(Resource resource) {
1:67ef08f: 		return !isShared(resource);
1:67ef08f: 	}
1:67ef08f: 
1:67ef08f: 	private boolean isMandatory(Resource resource) {
1:67ef08f: 		SubsystemContentHeader header = this.resource.getSubsystemManifest().getSubsystemContentHeader();
1:777b216: 		if (header == null)
1:307d743: 			return false;
1:67ef08f: 		return header.isMandatory(resource);
1:777b216: 	}
1:777b216: 
1:d6eb080: 	boolean isRoot() {
1:5bd3bf6: 		return BasicSubsystem.ROOT_LOCATION.equals(getLocation());
1:67ef08f: 	}
1:67ef08f: 
1:67ef08f: 	private boolean isShared(Resource resource) {
1:777b216: 		return Utils.isSharedResource(resource);
1:67ef08f: 	}
1:67ef08f: 
1:67ef08f: 	private boolean isScoped() {
1:d6eb080: 		return isApplication() || isComposite();
1:67ef08f: 	}
1:67ef08f: 
1:67ef08f: 	private boolean isUnscoped() {
1:67ef08f: 		return !isScoped();
1:bfcd190: 	}
1:bfcd190: 
1:d6eb080: 	private void setImportIsolationPolicy(Map<Resource, List<Wire>> resolution) throws Exception {
1:d6eb080: 		if (!isApplication()) {
1:7d27e24: 			return;
1:777b216: 		}
1:d6eb080: 		SubsystemContentHeader contentHeader = getSubsystemManifest().getSubsystemContentHeader();
1:d6eb080: 		// Prepare the regions and filter builder to set the sharing policy.
1:d6eb080: 		Region from = getRegion();
1:5bd3bf6: 		Region to = ((BasicSubsystem)getParents().iterator().next()).getRegion();
1:d6eb080: 		RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
1:d6eb080: 		// Always provide visibility to this subsystem's service registration.
1:d6eb080: 		addSubsystemServiceImportToSharingPolicy(builder, to);
1:67ef08f: 		for (Resource resource : resolution.keySet()) {
1:d6eb080: 			// If the resource is content but the wire provider is not,
1:d6eb080: 			// the sharing policy must be updated.
1:d6eb080: 			List<Wire> wires = resolution.get(resource);
1:d6eb080: 			for (Wire wire : wires) {
1:9f94bb4: 				Resource provider = wire.getProvider();
1:c59073f: 				// First check: If the provider is content there is no need to
1:c59073f: 				// update the sharing policy because the capability is already
1:c59073f: 				// visible.
1:d6eb080: 				if (contentHeader.contains(provider)) {
1:d6eb080: 					continue;
1:9f94bb4: 				}
1:c59073f: 				// Second check: If the provider is synthesized but not offering
1:c59073f: 				// a MissingCapability, then the resource is acting as a
1:c59073f: 				// placeholder as part of the Application-ImportService header
1:c59073f: 				// functionality, and the sharing policy does not need to be
1:c59073f: 				// updated.
1:c59073f: 				// Do not exclude resources providing a MissingCapability
1:c59073f: 				// even though they are synthesized. These are added by the
1:c59073f: 				// resolve context to ensure that unsatisfied optional
1:c59073f: 				// requirements become part of the sharing policy.
1:c59073f: 				if (!(wire.getCapability() instanceof DependencyCalculator.MissingCapability)
1:c59073f: 						&& Constants.ResourceTypeSynthesized.equals(ResourceHelper.getTypeAttribute(provider))) {
1:c59073f: 					continue;
1:c59073f: 				}
1:c59073f: 				// The requirement must be added to the sharing policy.
1:d6eb080: 				Requirement requirement = wire.getRequirement();
1:5febd6a: 				List<String> namespaces = new ArrayList<String>(2);
1:5febd6a: 				namespaces.add(requirement.getNamespace());
1:5febd6a: 				if (ServiceNamespace.SERVICE_NAMESPACE.equals(namespaces.get(0))) {
1:5febd6a: 					// Both service capabilities and services must be visible.
1:5febd6a: 					namespaces.add(RegionFilter.VISIBLE_SERVICE_NAMESPACE);
1:9f94bb4: 				}
1:d6eb080: 				String filter = requirement.getDirectives().get(Namespace.REQUIREMENT_FILTER_DIRECTIVE);
1:d6eb080: 				if (filter == null) {
1:5febd6a: 					for (String namespace : namespaces)
1:5febd6a: 						builder.allowAll(namespace);
1:9f94bb4: 				}
2:777b216: 				else {
1:5febd6a: 					for (String namespace : namespaces)
1:5febd6a: 						builder.allow(namespace, filter);
1:777b216: 				}
1:67ef08f: 			}
1:67ef08f: 		}
1:d6eb080: 		// Always add access to osgi.ee and osgi.native namespaces
1:d6eb080: 		setImplicitAccessToNativeAndEECapabilities(builder);
1:d6eb080: 		// Now set the sharing policy, if the regions are different.
1:d6eb080: 		RegionFilter regionFilter = builder.build();
1:d6eb080: 		from.connectRegion(to, regionFilter);
1:67ef08f: 	}
1:777b216: 
1:777b216: 	private void setImportIsolationPolicy() throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:777b216: 		if (isRoot() || !isScoped())
1:777b216: 			return;
1:777b216: 		Region region = getRegion();
1:777b216: 		Region from = region;
1:777b216: 		RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
1:79b20bc: 		Region to = getParents().iterator().next().getRegion();
1:777b216: 		addSubsystemServiceImportToSharingPolicy(builder, to);
1:777b216: 		// TODO Is this check really necessary? Looks like it was done at the beginning of this method.
1:777b216: 		if (isScoped()) {
1:777b216: 			// Both applications and composites have Import-Package headers that require processing.
1:777b216: 			// In the case of applications, the header is generated.
1:777b216: 			Header<?> header = getSubsystemManifest().getImportPackageHeader();
1:777b216: 			setImportIsolationPolicy(builder, (ImportPackageHeader)header);
1:777b216: 			// Both applications and composites have Require-Capability headers that require processing.
1:777b216: 			// In the case of applications, the header is generated.
1:777b216: 			header = getSubsystemManifest().getRequireCapabilityHeader();
1:777b216: 			setImportIsolationPolicy(builder, (RequireCapabilityHeader)header);
1:777b216: 			// Both applications and composites have Subsystem-ImportService headers that require processing.
1:777b216: 			// In the case of applications, the header is generated.
1:777b216: 			header = getSubsystemManifest().getSubsystemImportServiceHeader();
1:777b216: 			setImportIsolationPolicy(builder, (SubsystemImportServiceHeader)header);
1:777b216: 			header = getSubsystemManifest().getRequireBundleHeader();
1:777b216: 			setImportIsolationPolicy(builder, (RequireBundleHeader)header);
1:a6b79e8: 			// Always add access to osgi.ee and osgi.native namespaces
1:a6b79e8: 			setImplicitAccessToNativeAndEECapabilities(builder);
1:777b216: 		}
1:777b216: 		RegionFilter regionFilter = builder.build();
1:777b216: 		from.connectRegion(to, regionFilter);
1:777b216: 	}
1:777b216: 
1:777b216: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, ImportPackageHeader header) throws InvalidSyntaxException {
1:777b216: 		String policy = RegionFilter.VISIBLE_PACKAGE_NAMESPACE;
1:777b216: 		if (header == null)
1:777b216: 			return;
1:4693281: 		for (ImportPackageHeader.Clause clause : header.getClauses()) {
1:4693281: 			ImportPackageRequirement requirement = new ImportPackageRequirement(clause, this);
1:4693281: 			String filter = requirement.getDirectives().get(ImportPackageRequirement.DIRECTIVE_FILTER);
1:4693281: 			builder.allow(policy, filter);
1:4693281: 		}
1:777b216: 	}
1:777b216: 	
1:777b216: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, RequireBundleHeader header) throws InvalidSyntaxException {
2:777b216: 		if (header == null)
1:777b216: 			return;
1:777b216: 		for (RequireBundleHeader.Clause clause : header.getClauses()) {
1:777b216: 			RequireBundleRequirement requirement = new RequireBundleRequirement(clause, this);
1:777b216: 			String policy = RegionFilter.VISIBLE_REQUIRE_NAMESPACE;
1:777b216: 			String filter = requirement.getDirectives().get(RequireBundleRequirement.DIRECTIVE_FILTER);
3:777b216: 			builder.allow(policy, filter);
1:777b216: 		}
1:777b216: 	}
1:777b216: 
1:777b216: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, RequireCapabilityHeader header) throws InvalidSyntaxException {
1:777b216: 		if (header == null)
1:777b216: 			return;
1:777b216: 		for (RequireCapabilityHeader.Clause clause : header.getClauses()) {
1:777b216: 			RequireCapabilityRequirement requirement = new RequireCapabilityRequirement(clause, this);
1:777b216: 			String policy = requirement.getNamespace();
1:777b216: 			String filter = requirement.getDirectives().get(RequireCapabilityRequirement.DIRECTIVE_FILTER);
1:392ea23: 			if (filter == null)
1:392ea23: 				// A null filter directive means the requirement matches any
1:392ea23: 				// capability from the same namespace.
1:392ea23: 				builder.allowAll(policy);
1:392ea23: 			else
1:392ea23: 				// Otherwise, the capabilities must be filtered accordingly.
1:392ea23: 				builder.allow(policy, filter);
1:777b216: 		}
1:777b216: 	}
1:777b216: 
1:a6b79e8: 	private void setImplicitAccessToNativeAndEECapabilities(RegionFilterBuilder builder) {
1:a6b79e8: 		builder.allowAll(ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE);
1:d6eb080: 		builder.allowAll(NativeNamespace.NATIVE_NAMESPACE);
1:777b216: 	}
1:67ef08f: 
1:777b216: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, SubsystemImportServiceHeader header) throws InvalidSyntaxException {
1:777b216: 		if (header == null)
1:777b216: 			return;
1:777b216: 		for (SubsystemImportServiceHeader.Clause clause : header.getClauses()) {
1:777b216: 			SubsystemImportServiceRequirement requirement = new SubsystemImportServiceRequirement(clause, this);
1:777b216: 			String policy = RegionFilter.VISIBLE_SERVICE_NAMESPACE;
1:777b216: 			String filter = requirement.getDirectives().get(SubsystemImportServiceRequirement.DIRECTIVE_FILTER);
1:777b216: 			builder.allow(policy, filter);
1:777b216: 		}
1:67ef08f: 	}
1:67ef08f: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:445abc4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	private void addDependency(Resource resource) {
1: 		if (resource == null)
1: 			return;
1: 		if (isInstallable(resource))
1: 			installableDependencies.add(resource);
1: 		else
1: 			sharedDependencies.add(resource);
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 			addDependencies(resolution);
1: 			Utils.handleTrowable(e);
1: 		}
1: 	}
1: 	
1: 	private void addDependencies(Map<Resource, List<Wire>> resolution) {
1: 		for (Map.Entry<Resource, List<Wire>> entry : resolution.entrySet()) {
1: 			addDependencies(entry, resolution);
1: 		}
1: 	}
1: 	
1: 	private void addDependencies(Map.Entry<Resource, List<Wire>> entry, Map<Resource, List<Wire>> resolution) {
1: 		addDependencies(entry.getKey(), entry, resolution);
1: 	}
1: 	
1: 	private void addDependencies(Resource resource, Map.Entry<Resource, List<Wire>> entry, Map<Resource, List<Wire>> resolution) {
1: 		String type = ResourceHelper.getTypeAttribute(resource);
1: 		SubsystemContentHeader contentHeader = getSubsystemManifest().getSubsystemContentHeader();
1: 		if (!Constants.ResourceTypeSynthesized.equals(type) // Do not include synthetic resources as dependencies.
1: 				&& !contentHeader.contains(resource)) { // Do not include content as dependencies.
1: 			addDependency(resource);
commit:b66ad7c
/////////////////////////////////////////////////////////////////////////
1: 	public SubsystemResource(String location, IDirectory content, BasicSubsystem parent, Coordination coordination) throws URISyntaxException, IOException, ResolutionException, BundleException, InvalidSyntaxException {
1: 		this(new RawSubsystemResource(location, content, parent), parent, coordination);
1: 	public SubsystemResource(RawSubsystemResource resource, BasicSubsystem parent, Coordination coordination) throws IOException, BundleException, InvalidSyntaxException, URISyntaxException {
1: 	        computeDependencies(resource.getDeploymentManifest(), coordination);		    
/////////////////////////////////////////////////////////////////////////
1:             computeDependencies(resource.getDeploymentManifest(), null);          
/////////////////////////////////////////////////////////////////////////
1: 	void computeDependencies(DeploymentManifest manifest, Coordination coordination) {
1: 	        computeDependencies(getSubsystemManifest(), coordination);
/////////////////////////////////////////////////////////////////////////
1: 	private void computeDependencies(SubsystemManifest manifest, Coordination coordination)  {
1: 			// The following line is necessary in order to ensure that the
1: 			// export sharing policies of composites are in place for capability
1: 			// validation.
1: 			StartAction.setExportPolicyOfAllInstallingSubsystemsWithProvisionDependenciesResolve(coordination);
commit:a990e32
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.AriesSubsystemParentsHeader;
/////////////////////////////////////////////////////////////////////////
1: 		if (this.getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective().isInstall()) {
1: 		    /* compute dependencies now only if we intend to provision them during install */
0: 	        computeDependencies(resource.getDeploymentManifest());		    
1: 		}
1: 		this(null, FileSystem.getFSRoot(file));
1: 	public SubsystemResource(BasicSubsystem subsystem, IDirectory directory) throws IOException, URISyntaxException, ResolutionException, BundleException, InvalidSyntaxException {
1: 		if (subsystem == null) {
1: 			// This is intended to only support the case where the root subsystem
1: 			// is being initialized from a non-persistent state.
1: 			parent = null;
1: 		}
1: 		else {
1: 			parent = Utils.findScopedSubsystemInRegion(subsystem);
1: 		}
1:         if (getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective().isInstall()) {
1:             /* compute dependencies if we intend to provision them during install */
0:             computeDependencies(resource.getDeploymentManifest());          
1:         }
/////////////////////////////////////////////////////////////////////////
1: 			AriesSubsystemParentsHeader header = getDeploymentManifest().getAriesSubsystemParentsHeader();
1: 			Collection<AriesSubsystemParentsHeader.Clause> clauses = header.getClauses();
1: 			Collection<BasicSubsystem> result = new ArrayList<BasicSubsystem>(clauses.size());
1: 			Subsystems subsystems = Activator.getInstance().getSubsystems();
1: 			for (AriesSubsystemParentsHeader.Clause clause : clauses) {
1: 				result.add(subsystems.getSubsystemById(clause.getId()));
1: 			}
/////////////////////////////////////////////////////////////////////////
0: 	void computeDependencies(DeploymentManifest manifest) {
1: 	    if (manifest == null) {
0: 	        computeDependencies(getSubsystemManifest());
1: 	    }
1: 	    else {
1: 	        ProvisionResourceHeader header = manifest.getProvisionResourceHeader();
1: 	        if (header == null)
1: 	            return;
1: 	        for (ProvisionResourceHeader.Clause clause : header.getClauses()) {
1: 	            Resource resource = findDependency(clause);
1: 	            if (resource == null)
1: 	                throw new SubsystemException("A required dependency could not be found. This means the resource was either missing or not recognized as a supported resource format due to, for example, an invalid bundle manifest or blueprint XML file. Turn on debug logging for more information. The resource was: " + resource);
1: 	            addDependency(resource);
1: 	        }
1: 	    }
/////////////////////////////////////////////////////////////////////////
1: 	ProvisionResourceHeader computeProvisionResourceHeader() {
/////////////////////////////////////////////////////////////////////////
1: 		if (installableContent.contains(resource) || sharedContent.contains(resource)) {
1: 			return true;
1: 		}
1: 		// Allow for implicit subsystem installations. An implicit installation
1: 		// occurs when a subsystem containing other subsystems as content is
1: 		// installed. When identifying the region to be used for validation
1: 		// purposes during resolution, resources that are content of children
1: 		// must be treated as content of this subsystem. See ResolveContext.isValid().
1: 		for (Resource installableResource : installableContent) {
1: 			if (installableResource instanceof RawSubsystemResource) {
1: 				if (((RawSubsystemResource)installableResource).getSubsystemManifest().getSubsystemContentHeader().contains(resource)) {
1: 					return true;
1: 				}
1: 			}
1: 		}
1: 		return false;
commit:c59073f
/////////////////////////////////////////////////////////////////////////
1: 				// First check: If the provider is content there is no need to
1: 				// update the sharing policy because the capability is already
1: 				// visible.
1: 				// Second check: If the provider is synthesized but not offering
1: 				// a MissingCapability, then the resource is acting as a
1: 				// placeholder as part of the Application-ImportService header
1: 				// functionality, and the sharing policy does not need to be
1: 				// updated.
1: 				// Do not exclude resources providing a MissingCapability
1: 				// even though they are synthesized. These are added by the
1: 				// resolve context to ensure that unsatisfied optional
1: 				// requirements become part of the sharing policy.
1: 				if (!(wire.getCapability() instanceof DependencyCalculator.MissingCapability)
1: 						&& Constants.ResourceTypeSynthesized.equals(ResourceHelper.getTypeAttribute(provider))) {
1: 					continue;
1: 				}
1: 				// The requirement must be added to the sharing policy.
commit:3b4e485
/////////////////////////////////////////////////////////////////////////
1: 		Collection<Resource> dependencies = getDependencies();
/////////////////////////////////////////////////////////////////////////
1: 		// First search the local repository.
1: 		Collection<Capability> capabilities = map.get(requirement);
1: 		if (capabilities.isEmpty()) {
1: 			// Nothing found in the local repository so search the repository services.
1: 			capabilities = new RepositoryServiceRepository().findProviders(requirement);
1: 		if (capabilities.isEmpty()) {
1: 			// Nothing found period.
1: 			return null;
1: 		}
1: 		for (Capability capability : capabilities) {
1: 			if (!IdentityNamespace.TYPE_FRAGMENT.equals(
1: 					capability.getAttributes().get(IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE))) {
1: 				// Favor the first resource that is not a fragment bundle.
1: 				// See ARIES-1425.
1: 				return capability.getResource();
1: 			}
1: 		}
1: 		// Nothing here but fragment bundles. Return the first one.
1: 		return capabilities.iterator().next().getResource();
/////////////////////////////////////////////////////////////////////////
1: 	private Collection<Resource> getDependencies() {
commit:5febd6a
/////////////////////////////////////////////////////////////////////////
1: 				List<String> namespaces = new ArrayList<String>(2);
1: 				namespaces.add(requirement.getNamespace());
1: 				if (ServiceNamespace.SERVICE_NAMESPACE.equals(namespaces.get(0))) {
1: 					// Both service capabilities and services must be visible.
1: 					namespaces.add(RegionFilter.VISIBLE_SERVICE_NAMESPACE);
1: 					for (String namespace : namespaces)
1: 						builder.allowAll(namespace);
1: 					for (String namespace : namespaces)
1: 						builder.allow(namespace, filter);
commit:d8cec40
/////////////////////////////////////////////////////////////////////////
0: 				String type = ResourceHelper.getTypeAttribute(key);
0: 				// Do not include synthetic resources in the dependencies.
0: 				if (!Constants.ResourceTypeSynthesized.equals(type)
0: 						&& !contentHeader.contains(key)) {
0: 					type = ResourceHelper.getTypeAttribute(provider);
0: 					// Do not include synthetic resources in the dependencies.
0: 					if (!Constants.ResourceTypeSynthesized.equals(type)
0: 							&& !contentHeader.contains(provider)) {
commit:3f524ae
/////////////////////////////////////////////////////////////////////////
1: 	boolean isContent(Resource resource) {
0: 	   return installableContent.contains(resource) || sharedContent.contains(resource); 
1: 	}
1: 	
commit:8ad6b99
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
/////////////////////////////////////////////////////////////////////////
commit:f5193a6
/////////////////////////////////////////////////////////////////////////
1: 					throw new SubsystemException("A required content resource could not be found. This means the resource was either missing or not recognized as a supported resource format due to, for example, an invalid bundle manifest or blueprint XML file. Turn on debug logging for more information. The resource was: " + requirement);
/////////////////////////////////////////////////////////////////////////
0: 					throw new SubsystemException("A required dependency could not be found. This means the resource was either missing or not recognized as a supported resource format due to, for example, an invalid bundle manifest or blueprint XML file. Turn on debug logging for more information. The resource was: " + resource);
commit:9f94bb4
/////////////////////////////////////////////////////////////////////////
0: 			for (Map.Entry<Resource, List<Wire>> entry : resolution.entrySet()) {
0: 				Resource key = entry.getKey();
0: 				if (!contentHeader.contains(key)) {
0: 					addDependency(key);
1: 				}
0: 				for (Wire wire : entry.getValue()) {
1: 					Resource provider = wire.getProvider();
0: 					if (!contentHeader.contains(provider)) {
0: 						addDependency(provider);
1: 					}
1: 				}
1: 			}
commit:4693281
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (header == null)
1: 			return;
1: 		for (ImportPackageHeader.Clause clause : header.getClauses()) {
1: 			ImportPackageRequirement requirement = new ImportPackageRequirement(clause, this);
1: 			String filter = requirement.getDirectives().get(ImportPackageRequirement.DIRECTIVE_FILTER);
1: 			builder.allow(policy, filter);
1: 		}
commit:bfcd190
/////////////////////////////////////////////////////////////////////////
0: 			addValidCapabilities(cc, capabilities, requirement);
/////////////////////////////////////////////////////////////////////////
0: 	private void addValidCapabilities(Collection<Capability> from, Collection<Capability> to, Requirement requirement) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 			if (isValid(c, requirement))
/////////////////////////////////////////////////////////////////////////
0: 	private boolean isValid(Capability capability, Requirement requirement) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 		Region from = findRegionForCapabilityValidation(capability.getResource());
0: 		Region to = findRegionForCapabilityValidation(requirement.getResource());
0: 		return new SharingPolicyValidator(from, to).isValid(capability);
1: 	}
1: 	
0: 	private Region findRegionForCapabilityValidation(Resource resource) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 				return getRegion();
0: 			return Utils.findFirstSubsystemAcceptingDependenciesStartingFrom(parent).getRegion();
/////////////////////////////////////////////////////////////////////////
0: 				return Activator.getInstance().getRegionDigraph().getRegion(((BundleRevision)resource).getBundle());
0: 				return Activator.getInstance().getSubsystems().getSubsystemsReferencing(resource).iterator().next().getRegion();
commit:6740c72
/////////////////////////////////////////////////////////////////////////
1: 	private void computeOsgiServiceCapabilities(List<Capability> capabilities) throws InvalidSyntaxException {
commit:4fd3b7f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		return resource.getId();
commit:5bd3bf6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private final BasicSubsystem parent;
0: 	public SubsystemResource(String location, IDirectory content, BasicSubsystem parent) throws URISyntaxException, IOException, ResolutionException, BundleException, InvalidSyntaxException, ModellerException {
0: 	public SubsystemResource(RawSubsystemResource resource, BasicSubsystem parent) throws IOException, BundleException, InvalidSyntaxException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 	public Collection<BasicSubsystem> getParents() {
0: 			Collection<BasicSubsystem> result = new ArrayList<BasicSubsystem>(parentIds.length);
/////////////////////////////////////////////////////////////////////////
0: 				for (BasicSubsystem subsystem : Activator.getInstance().getSubsystems().getSubsystems())
/////////////////////////////////////////////////////////////////////////
1: 					else if (provider instanceof BasicSubsystem) {
1: 						if (getRegion().equals(((BasicSubsystem)provider).getRegion())) {
/////////////////////////////////////////////////////////////////////////
1: 		return BasicSubsystem.ROOT_LOCATION.equals(getLocation());
/////////////////////////////////////////////////////////////////////////
1: 		Region to = ((BasicSubsystem)getParents().iterator().next()).getRegion();
commit:47cea41
/////////////////////////////////////////////////////////////////////////
commit:ed5f3dc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.internal.BundleResourceInstaller.BundleConstituent;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.wiring.BundleWiring;
/////////////////////////////////////////////////////////////////////////
1: 		Region root = Activator.getInstance().getSubsystems().getRootSubsystem().getRegion();
1: 		if (to.getName().equals(root.getName()))
1: 			to = root;
/////////////////////////////////////////////////////////////////////////
0: 						addWiring(constituent, wirings);
0: 			private void addWiring(Resource resource, Map<Resource, Wiring> wirings) {
0: 				if (resource instanceof BundleConstituent) {
0: 					BundleConstituent bc = (BundleConstituent)resource;
0: 					wirings.put(bc.getBundle().adapt(BundleRevision.class), bc.getWiring());
1: 				}
0: 				else if (resource instanceof BundleRevision) {
0: 					BundleRevision br = (BundleRevision)resource;
0: 					wirings.put(br, br.getWiring());
1: 				}
1: 			}
1: 			
/////////////////////////////////////////////////////////////////////////
0: 		Resource resource = capability.getResource();
0: 		if (isInstallable(resource)) {
0: 			if (isContent(resource))
1: 		else {
0: 			// This is an already installed resource from the system repository.
0: 			if (Utils.isBundle(resource))
0: 				// If it's a bundle, use region digraph to get the region in order
0: 				// to account for bundles in isolated regions outside of the
0: 				// subsystems API.
0: 				region = Activator.getInstance().getRegionDigraph().getRegion(((BundleRevision)resource).getBundle());
1: 			else
0: 				// If it's anything else, get the region from one of the
0: 				// subsystems referencing it.
0: 				region = Activator.getInstance().getSubsystems().getSubsystemsReferencing(capability.getResource()).iterator().next().getRegion();
1: 		}
commit:8481849
/////////////////////////////////////////////////////////////////////////
1: 			// This is the root subsystem. Associate it with the region in which
1: 			// the subsystems implementation bundle was installed.
1: 			return digraph.getRegion(activator.getBundleContext().getBundle());
commit:ab24f61
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0: 			private final Map<Resource, Wiring> wirings = computeWirings();
1: 			
0: 			private Map<Resource, Wiring> computeWirings() {
0: 				Map<Resource, Wiring> wirings = new HashMap<Resource, Wiring>();
0: 				for (AriesSubsystem subsystem : Activator.getInstance().getSubsystems().getSubsystems())
0: 					for (Resource constituent : subsystem.getConstituents())
0: 						if (constituent instanceof BundleRevision) {
0: 							BundleRevision revision = (BundleRevision)constituent;
0: 							wirings.put(revision, revision.getWiring());
1: 						}
0: 				return Collections.unmodifiableMap(wirings);
1: 			}
1: 			
/////////////////////////////////////////////////////////////////////////
0: 			public synchronized Map<Resource, Wiring> getWirings() {
0: 				return wirings;
commit:b75f264
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.modelling.ModellerException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.SubsystemExportServiceHeader;
/////////////////////////////////////////////////////////////////////////
1: 	private final List<Capability> capabilities;
/////////////////////////////////////////////////////////////////////////
0: 	public SubsystemResource(String location, InputStream content, AriesSubsystem parent) throws URISyntaxException, IOException, ResolutionException, BundleException, InvalidSyntaxException, ModellerException {
/////////////////////////////////////////////////////////////////////////
1: 		capabilities = computeCapabilities();
/////////////////////////////////////////////////////////////////////////
1: 		capabilities = computeCapabilities();
/////////////////////////////////////////////////////////////////////////
1: 		return Collections.unmodifiableList(capabilities);
1: 	}
1: 	
1: 	private List<Capability> computeCapabilities() throws InvalidSyntaxException {
1: 		List<Capability> capabilities = new ArrayList<Capability>();
1: 			computeScopedCapabilities(capabilities);
1: 		else
1: 			computeUnscopedCapabilities(capabilities);
1: 		return capabilities;
1: 	}
1: 	
1: 	private void computeUnscopedCapabilities(List<Capability> capabilities) {
1: 		capabilities.addAll(resource.getCapabilities(null));
1: 		for (Resource r : getContentResources())
1: 			capabilities.addAll(r.getCapabilities(null));
1: 	}
1: 	
1: 	private void computeScopedCapabilities(List<Capability> capabilities) throws InvalidSyntaxException {
1: 		capabilities.addAll(resource.getCapabilities(null));
1: 		computeOsgiServiceCapabilities(capabilities);
1: 	}
1: 	
0: 	public void computeOsgiServiceCapabilities(List<Capability> capabilities) throws InvalidSyntaxException {
1: 		SubsystemExportServiceHeader header = getSubsystemManifest().getSubsystemExportServiceHeader();
1: 		if (header == null)
1: 			return;
1: 		for (Resource resource : getContentResources())
1: 			capabilities.addAll(header.toCapabilities(resource));
/////////////////////////////////////////////////////////////////////////
0: 			String[] parentIds = header.getValue().split(",");
0: 			Collection<AriesSubsystem> result = new ArrayList<AriesSubsystem>(parentIds.length);
0: 			for (String parentId : parentIds)
0: 				result.add(Activator.getInstance().getSubsystems().getSubsystemById(Long.valueOf(parentId)));
commit:2b251bb
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Bundle;
/////////////////////////////////////////////////////////////////////////
1: 	private final Collection<DeployedContentHeader.Clause> missingResources = new HashSet<DeployedContentHeader.Clause>();
/////////////////////////////////////////////////////////////////////////
1: 	public Collection<DeployedContentHeader.Clause> getMissingResources() {
1: 		return missingResources;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	private void addMissingResource(DeployedContentHeader.Clause resource) {
1: 		missingResources.add(resource);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 					addMissingResource(clause);
1: 				else
1: 					addContentResource(resource);
/////////////////////////////////////////////////////////////////////////
1: 				Bundle resource = Activator.getInstance().getBundleContext().getBundle(0).getBundleContext().getBundle(resourceId);
1: 				if (resource == null)
1: 					return null;
1: 				return resource.adapt(BundleRevision.class);
commit:a68e051
/////////////////////////////////////////////////////////////////////////
0: 		// TODO Why create this with each method call? What not cache it as an instance variable?
commit:392ea23
/////////////////////////////////////////////////////////////////////////
1: 			if (filter == null)
1: 				// A null filter directive means the requirement matches any
1: 				// capability from the same namespace.
1: 				builder.allowAll(policy);
1: 			else
1: 				// Otherwise, the capabilities must be filtered accordingly.
1: 				builder.allow(policy, filter);
commit:a14f2fd
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
commit:e341c9b
/////////////////////////////////////////////////////////////////////////
0: 			for (ProvisionResourceHeader.Clause clause : header.getClauses()) {
0: 				Resource resource = findDependency(clause);
0: 					throw new SubsystemException("Resource does not exist: " + clause);
/////////////////////////////////////////////////////////////////////////
1: 	private Resource findDependency(ProvisionResourceHeader.Clause clause) {
1: 		Attribute attribute = clause.getAttribute(DeployedContentHeader.Clause.ATTRIBUTE_RESOURCEID);
1: 		long resourceId = attribute == null ? -1 : Long.parseLong(String.valueOf(attribute.getValue()));
1: 			String type = clause.getType();
1: 				clause.getPath(), clause.getDeployedVersion(),
1: 				clause.getType(), true);
commit:2b13b05
/////////////////////////////////////////////////////////////////////////
0: 	public SubsystemResource(String location, InputStream content, AriesSubsystem parent) throws URISyntaxException, IOException, ResolutionException, UnsupportedOperationException, BundleException, InvalidSyntaxException {
0: 	public SubsystemResource(RawSubsystemResource resource, AriesSubsystem parent) throws IOException, BundleException, InvalidSyntaxException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 	public SubsystemResource(File file) throws IOException, URISyntaxException, ResolutionException, BundleException, InvalidSyntaxException {
0: 	public SubsystemResource(IDirectory directory) throws IOException, URISyntaxException, ResolutionException, BundleException, InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 					// Nothing.
1: 					if (isScoped())
1: 						region.getRegionDigraph().removeRegion(region);
/////////////////////////////////////////////////////////////////////////
0: 		if (repository == null)
1: 			return false;
/////////////////////////////////////////////////////////////////////////
1: 	private void computeContentResources(DeploymentManifest manifest) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 	private void computeContentResources(SubsystemManifest manifest) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 	private Resource findContent(Requirement requirement) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 					Resource provider = capability.getResource();
1: 					if (provider instanceof BundleRevision) {
1: 						if (getRegion().contains(((BundleRevision)provider).getBundle())) {
1: 							return provider;
1: 						}
1: 					}
0: 					else if (provider instanceof AriesSubsystem) {
0: 						if (getRegion().equals(((AriesSubsystem)provider).getRegion())) {
1: 							return provider;
1: 						}
1: 					}
/////////////////////////////////////////////////////////////////////////
1: 	private Resource findContent(DeployedContentHeader.Clause clause) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
commit:4b41d3d
/////////////////////////////////////////////////////////////////////////
1: 			Requirement requirement = clause.toRequirement(this);
/////////////////////////////////////////////////////////////////////////
0: 	private Resource findContent(Requirement requirement) {
/////////////////////////////////////////////////////////////////////////
1: 		return findContent(clause.toRequirement(this));
commit:307d743
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	@Override
1: 	public boolean equals(Object o) {
1: 		if (o == this)
1: 			return true;
1: 		if (!(o instanceof SubsystemResource))
1: 			return false;
1: 		SubsystemResource that = (SubsystemResource)o;
1: 		return getLocation().equals(that.getLocation());
1: 	}
1: 		if (isScoped())
0: 			return resource.getCapabilities(namespace);
1: 		else {
0: 			ArrayList<Capability> result = new ArrayList<Capability>();
0: 			result.addAll(resource.getCapabilities(namespace));
1: 			for (Resource r : getContentResources())
0: 				result.addAll(r.getCapabilities(namespace));
1: 			result.trimToSize();
1: 			return result;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		if (isScoped())
1: 			return resource.getRequirements(namespace);
1: 		else {
1: 			ArrayList<Requirement> result = new ArrayList<Requirement>();
1: 			result.addAll(resource.getRequirements(namespace));
0: 			for (Resource r : getContentResources())
1: 				result.addAll(r.getRequirements(namespace));
0: 			result.trimToSize();
1: 			return result;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 	@Override
1: 	public int hashCode() {
1: 		int result = 17;
1: 		result = 31 * result + getLocation().hashCode();
1: 		return result;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:547a8ce
/////////////////////////////////////////////////////////////////////////
1: 		for (SubsystemContentHeader.Clause clause : contentHeader.getClauses()) {
0: 					clause.getSymbolicName(), clause.getVersionRange(),
0: 					clause.getType(), false);
1: 				if (clause.isMandatory())
commit:777b216
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.Attribute;
1: import org.apache.aries.subsystem.core.archive.Header;
1: import org.apache.aries.subsystem.core.archive.ImportPackageHeader;
1: import org.apache.aries.subsystem.core.archive.ImportPackageRequirement;
1: import org.apache.aries.subsystem.core.archive.RequireBundleHeader;
1: import org.apache.aries.subsystem.core.archive.RequireBundleRequirement;
1: import org.apache.aries.subsystem.core.archive.RequireCapabilityHeader;
1: import org.apache.aries.subsystem.core.archive.RequireCapabilityRequirement;
1: import org.apache.aries.subsystem.core.archive.SubsystemImportServiceHeader;
1: import org.apache.aries.subsystem.core.archive.SubsystemImportServiceRequirement;
1: import org.apache.aries.util.filesystem.FileSystem;
1: import org.apache.aries.util.filesystem.IDirectory;
1: import org.eclipse.equinox.region.Region;
1: import org.eclipse.equinox.region.RegionDigraph;
1: import org.eclipse.equinox.region.RegionFilter;
1: import org.eclipse.equinox.region.RegionFilterBuilder;
1: import org.osgi.framework.BundleException;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.namespace.IdentityNamespace;
1: import org.osgi.service.coordinator.Coordination;
1: import org.osgi.service.coordinator.Participant;
1: import org.osgi.service.subsystem.Subsystem;
1: 	private Region region;
1: 	
0: 	private final long id;
/////////////////////////////////////////////////////////////////////////
0: 		id = SubsystemIdentifier.getNextId();
1: 		computeContentResources(resource.getDeploymentManifest());
0: 		computeDependencies(resource.getDeploymentManifest());
1: 	
0: 	public SubsystemResource(File file) throws IOException, URISyntaxException, ResolutionException {
0: 		this(FileSystem.getFSRoot(file));
1: 	}
1: 	
0: 	public SubsystemResource(IDirectory directory) throws IOException, URISyntaxException, ResolutionException {
0: 		parent = null;
0: 		resource = new RawSubsystemResource(directory);
0: 		preferredProviderRepository = null;
1: 		deploymentManifest = resource.getDeploymentManifest();
0: 		id = Long.parseLong(deploymentManifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_ID).getValue());
1: 		computeContentResources(deploymentManifest);
0: 		computeDependencies(deploymentManifest);
1: 	}
/////////////////////////////////////////////////////////////////////////
0: 		return id;
/////////////////////////////////////////////////////////////////////////
0: 	public Collection<AriesSubsystem> getParents() {
1: 		if (parent == null) {
0: 			Header<?> header = getDeploymentManifest().getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_PARENTS);
1: 			if (header == null)
1: 				return Collections.emptyList();
0: 			String[] parents = header.getValue().split(",");
0: 			Collection<AriesSubsystem> result = new ArrayList<AriesSubsystem>(parents.length);
0: 			for (String parent : parents)
0: 				result.add(Activator.getInstance().getSubsystems().getSubsystemById(Long.valueOf(parent)));
1: 			return result;
1: 		}
1: 		return Collections.singleton(parent);
1: 	}
1: 	
1: 	public synchronized Region getRegion() throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		if (region == null) {
1: 			region = createRegion(getId());
1: 			Coordination coordination = Activator.getInstance().getCoordinator().peek();
1: 			coordination.addParticipant(new Participant() {
1: 				@Override
1: 				public void ended(Coordination arg0) throws Exception {
0: //					region.getRegionDigraph().removeRegion(region);
1: 				}
1: 
1: 				@Override
1: 				public void failed(Coordination arg0) throws Exception {
0: 					region.getRegionDigraph().removeRegion(region);
1: 				}
1: 			});
1: 			setImportIsolationPolicy();
1: 		}
1: 		return region;
/////////////////////////////////////////////////////////////////////////
0: 	private boolean addDependencies(Repository repository, Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
0: 	private boolean addDependenciesFromContentRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 	private boolean addDependenciesFromLocalRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 	private boolean addDependenciesFromPreferredProviderRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 	private boolean addDependenciesFromRepositoryServiceRepositories(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 	private boolean addDependenciesFromSystemRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
0: 	private void addValidCapabilities(Collection<Capability> from, Collection<Capability> to) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 	private void addSubsystemServiceImportToSharingPolicy(
1: 			RegionFilterBuilder builder) throws InvalidSyntaxException, BundleException, IOException, URISyntaxException {
1: 		builder.allow(
1: 				RegionFilter.VISIBLE_SERVICE_NAMESPACE,
1: 				new StringBuilder("(&(")
1: 						.append(org.osgi.framework.Constants.OBJECTCLASS)
1: 						.append('=').append(Subsystem.class.getName())
1: 						.append(")(")
1: 						.append(Constants.SubsystemServicePropertyRegions)
1: 						.append('=').append(getRegion().getName())
1: 						.append("))").toString());
1: 	}
1: 	
1: 	private void addSubsystemServiceImportToSharingPolicy(RegionFilterBuilder builder, Region to)
1: 			throws InvalidSyntaxException, BundleException, IOException, URISyntaxException {
0: 		if (to.getName().equals(AriesSubsystem.ROOT_REGION))
1: 			addSubsystemServiceImportToSharingPolicy(builder);
1: 		else {
0: 			to = Activator.getInstance().getSubsystems().getRootSubsystem().getRegion();
1: 			builder = to.getRegionDigraph().createRegionFilterBuilder();
1: 			addSubsystemServiceImportToSharingPolicy(builder);
1: 			RegionFilter regionFilter = builder.build();
1: 			getRegion().connectRegion(to, regionFilter);
1: 		}
1: 	}
1: 	
0: 	private void computeContentResources(DeploymentManifest manifest) {
1: 		if (manifest == null)
1: 			computeContentResources(getSubsystemManifest());
1: 		else {
1: 			DeployedContentHeader header = manifest.getDeployedContentHeader();
1: 			if (header == null)
1: 				return;
1: 			for (DeployedContentHeader.Clause clause : header.getClauses()) {
1: 				Resource resource = findContent(clause);
1: 				if (resource == null)
0: 					throw new SubsystemException("Resource does not exist: " + clause);
1: 				addContentResource(resource);
1: 			}
1: 		}
0: //		if (parent == null) {
0: //			if (deploymentManifest == null)
0: //				return;
0: //			computeContentResourcesFromDeploymentManifest();
0: //		}
0: //		else {
0: //			computeContentResourcesFromSubsystemManifest();
0: //		}
1: 	}
1: 	
0: 	private void computeContentResources(SubsystemManifest manifest) {
1: 		SubsystemContentHeader contentHeader = manifest.getSubsystemContentHeader();
/////////////////////////////////////////////////////////////////////////
0: 	private void computeDependencies(DeploymentManifest manifest) {
0: 		if (manifest == null)
0: 			computeDependencies(getSubsystemManifest());
0: 		else {
0: 			ProvisionResourceHeader header = manifest.getProvisionResourceHeader();
1: 			if (header == null)
1: 				return;
0: 			for (ProvisionResourceHeader.ProvisionedResource provisionedResource : header.getProvisionedResources()) {
0: 				Resource resource = findDependency(provisionedResource);
1: 				if (resource == null)
0: 					throw new SubsystemException("Resource does not exist: " + provisionedResource);
0: 				addDependency(resource);
1: 			}
1: 		}	
0: //		if (parent == null) {
0: //			if (deploymentManifest == null)
0: //				return;
0: //			ProvisionResourceHeader header = deploymentManifest.getProvisionResourceHeader();
0: //			if (header == null)
0: //				return;
0: //			for (ProvisionResourceHeader.ProvisionedResource provisionedResource : header.getProvisionedResources()) {
0: //				Resource resource = findDependency(provisionedResource);
0: //				if (resource == null)
0: //					throw new SubsystemException("Resource does not exist: " + provisionedResource);
0: //				addContentResource(resource);
0: //			}
0: //		}
0: //		else {
0: //			SubsystemContentHeader contentHeader = resource.getSubsystemManifest().getSubsystemContentHeader();
0: //			try {
0: //				Map<Resource, List<Wire>> resolution = Activator.getInstance().getResolver().resolve(createResolveContext());
0: //				for (Resource resource : resolution.keySet())
0: //					if (!contentHeader.contains(resource))
0: //						addDependency(resource);
0: //			}
0: //			catch (ResolutionException e) {
0: //				throw new SubsystemException(e);
0: //			}
0: //		}
1: 	}
1: 	
0: 	private void computeDependencies(SubsystemManifest manifest) {
0: 		SubsystemContentHeader contentHeader = manifest.getSubsystemContentHeader();
/////////////////////////////////////////////////////////////////////////
1: 	private Region createRegion(long id) throws BundleException {
1: 		if (!isScoped())
1: 			return getParents().iterator().next().getRegion();
1: 		Activator activator = Activator.getInstance();
1: 		RegionDigraph digraph = activator.getRegionDigraph();
1: 		if (getParents().isEmpty())
0: 			return digraph.getRegion(AriesSubsystem.ROOT_REGION);
1: 		String name = getSubsystemManifest()
1: 				.getSubsystemSymbolicNameHeader().getSymbolicName()
1: 				+ ';'
1: 				+ getSubsystemManifest().getSubsystemVersionHeader()
1: 						.getVersion()
1: 				+ ';'
1: 				+ getSubsystemManifest().getSubsystemTypeHeader()
1: 						.getType() + ';' + Long.toString(id);
1: 		Region region = digraph.getRegion(name);
1: 		// TODO New regions need to be cleaned up if this subsystem fails to
1: 		// install, but there's no access to the coordination here.
1: 		if (region == null)
1: 			return digraph.createRegion(name);
1: 		return region;
1: 	}
1: 	
1: 				try {
0: 					if (addDependenciesFromContentRepository(requirement, result))
1: 						return result;
0: 					if (addDependenciesFromPreferredProviderRepository(requirement, result))
1: 						return result;
0: 					if (addDependenciesFromSystemRepository(requirement, result))
1: 						return result;
0: 					if (addDependenciesFromLocalRepository(requirement, result))
1: 						return result;
0: 					if (addDependenciesFromRepositoryServiceRepositories(requirement, result))
1: 						return result;
1: 				}
0: 				catch (Throwable t) {
0: 					if (t instanceof SubsystemException)
0: 						throw (SubsystemException)t;
0: 					if (t instanceof SecurityException)
0: 						throw (SecurityException)t;
0: 					throw new SubsystemException(t);
1: 				}
/////////////////////////////////////////////////////////////////////////
0: 	private Resource findContent(DeployedContentHeader.Clause clause) {
1: 		Attribute attribute = clause.getAttribute(DeployedContentHeader.Clause.ATTRIBUTE_RESOURCEID);
1: 		long resourceId = attribute == null ? -1 : Long.parseLong(String.valueOf(attribute.getValue()));
1: 		if (resourceId != -1) {
1: 			String type = clause.getType();
1: 			if (IdentityNamespace.TYPE_BUNDLE.equals(type) || IdentityNamespace.TYPE_FRAGMENT.equals(type)) {
1: 				return Activator.getInstance().getBundleContext().getBundle(0).getBundleContext().getBundle(resourceId).adapt(BundleRevision.class);
1: 			}
1: 			else
1: 				return Activator.getInstance().getSubsystems().getSubsystemById(resourceId);
1: 		}
1: 		OsgiIdentityRequirement requirement = new OsgiIdentityRequirement(
0: 				clause.getPath(), clause.getDeployedVersion(),
0: 				clause.getType(), false);
0: 		return findContent(requirement);
1: 	}
1: 	
0: 	private Resource findDependency(ProvisionResourceHeader.ProvisionedResource provisionedResource) {
0: 		long resourceId = provisionedResource.getResourceId();
1: 		if (resourceId != -1) {
0: 			String type = provisionedResource.getNamespace();
1: 			if (IdentityNamespace.TYPE_BUNDLE.equals(type) || IdentityNamespace.TYPE_FRAGMENT.equals(type))
1: 				return Activator.getInstance().getBundleContext().getBundle(0).getBundleContext().getBundle(resourceId).adapt(BundleRevision.class);
1: 			else
1: 				return Activator.getInstance().getSubsystems().getSubsystemById(resourceId);
1: 		}
1: 		OsgiIdentityRequirement requirement = new OsgiIdentityRequirement(
0: 				provisionedResource.getName(), provisionedResource.getDeployedVersion(),
0: 				provisionedResource.getNamespace(), false);
1: 		List<Capability> capabilities = createResolveContext().findProviders(requirement);
1: 		if (capabilities.isEmpty())
1: 			return null;
1: 		return capabilities.get(0).getResource();
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 	private boolean isContent(Resource resource) {
0: 		return getSubsystemManifest().getSubsystemContentHeader().contains(resource);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 	private boolean isRoot() {
0: 		return AriesSubsystem.ROOT_LOCATION.equals(getLocation());
1: 	}
1: 	
1: 		return Utils.isSharedResource(resource);
/////////////////////////////////////////////////////////////////////////
0: 	private boolean isValid(Capability capability) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 		if (IdentityNamespace.IDENTITY_NAMESPACE.equals(capability.getNamespace()))
0: 			return true;
0: 		Region region;
0: 		if (isInstallable(capability.getResource())) {
0: 			if (isContent(capability.getResource()))
0: 				region = getRegion();
1: 			else
0: 				region = Utils.findFirstSubsystemAcceptingDependenciesStartingFrom(parent).getRegion();
1: 		}
0: 			region = Activator.getInstance().getSubsystems().getSubsystemsReferencing(capability.getResource()).iterator().next().getRegion();
0: 		return new SharingPolicyValidator(region, getRegion()).isValid(capability);
1: 	}
1: 	
1: 	private void setImportIsolationPolicy() throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		if (isRoot() || !isScoped())
1: 			return;
1: 		Region region = getRegion();
1: 		Region from = region;
1: 		RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
0: 		Region to = ((AriesSubsystem)getParents().iterator().next()).getRegion();
1: 		addSubsystemServiceImportToSharingPolicy(builder, to);
1: 		// TODO Is this check really necessary? Looks like it was done at the beginning of this method.
1: 		if (isScoped()) {
1: 			// Both applications and composites have Import-Package headers that require processing.
1: 			// In the case of applications, the header is generated.
1: 			Header<?> header = getSubsystemManifest().getImportPackageHeader();
1: 			setImportIsolationPolicy(builder, (ImportPackageHeader)header);
1: 			// Both applications and composites have Require-Capability headers that require processing.
1: 			// In the case of applications, the header is generated.
1: 			header = getSubsystemManifest().getRequireCapabilityHeader();
1: 			setImportIsolationPolicy(builder, (RequireCapabilityHeader)header);
1: 			// Both applications and composites have Subsystem-ImportService headers that require processing.
1: 			// In the case of applications, the header is generated.
1: 			header = getSubsystemManifest().getSubsystemImportServiceHeader();
1: 			setImportIsolationPolicy(builder, (SubsystemImportServiceHeader)header);
1: 			header = getSubsystemManifest().getRequireBundleHeader();
1: 			setImportIsolationPolicy(builder, (RequireBundleHeader)header);
1: 		}
1: 		RegionFilter regionFilter = builder.build();
1: 		from.connectRegion(to, regionFilter);
1: 	}
1: 	
1: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, ImportPackageHeader header) throws InvalidSyntaxException {
1: 		if (header == null)
1: 			return;
1: 		String policy = RegionFilter.VISIBLE_PACKAGE_NAMESPACE;
0: 		for (ImportPackageHeader.Clause clause : header.getClauses()) {
0: 			ImportPackageRequirement requirement = new ImportPackageRequirement(clause, this);
0: 			String filter = requirement.getDirectives().get(ImportPackageRequirement.DIRECTIVE_FILTER);
1: 			builder.allow(policy, filter);
1: 		}
1: 	}
1: 	
1: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, RequireBundleHeader header) throws InvalidSyntaxException {
1: 		if (header == null)
1: 			return;
1: 		for (RequireBundleHeader.Clause clause : header.getClauses()) {
1: 			RequireBundleRequirement requirement = new RequireBundleRequirement(clause, this);
1: 			String policy = RegionFilter.VISIBLE_REQUIRE_NAMESPACE;
1: 			String filter = requirement.getDirectives().get(RequireBundleRequirement.DIRECTIVE_FILTER);
1: 			builder.allow(policy, filter);
1: 		}
1: 	}
1: 	
1: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, RequireCapabilityHeader header) throws InvalidSyntaxException {
1: 		if (header == null)
1: 			return;
1: 		for (RequireCapabilityHeader.Clause clause : header.getClauses()) {
1: 			RequireCapabilityRequirement requirement = new RequireCapabilityRequirement(clause, this);
1: 			String policy = requirement.getNamespace();
1: 			String filter = requirement.getDirectives().get(RequireCapabilityRequirement.DIRECTIVE_FILTER);
1: 			builder.allow(policy, filter);
1: 		}
1: 	}
1: 	
1: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, SubsystemImportServiceHeader header) throws InvalidSyntaxException {
1: 		if (header == null)
1: 			return;
1: 		for (SubsystemImportServiceHeader.Clause clause : header.getClauses()) {
1: 			SubsystemImportServiceRequirement requirement = new SubsystemImportServiceRequirement(clause, this);
1: 			String policy = RegionFilter.VISIBLE_SERVICE_NAMESPACE;
1: 			String filter = requirement.getDirectives().get(SubsystemImportServiceRequirement.DIRECTIVE_FILTER);
1: 			builder.allow(policy, filter);
1: 		}
commit:c3ec212
/////////////////////////////////////////////////////////////////////////
1: 		// TODO System repository for scoped subsystems should be searched in
1: 		// the case of a persisted subsystem.
commit:225bcae
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
0: 	public File getDirectory() {
0: 		return resource.getDirectory();
1: 	}
1: 	
1: 	public long getId() {
0: 		return resource.getId();
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 					Collection<AriesSubsystem> subsystems = Activator.getInstance().getSubsystems().getSubsystemsReferencing(capability.getResource());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			subsystem = Utils.findFirstSubsystemAcceptingDependenciesStartingFrom(parent);
0: 			subsystem = Activator.getInstance().getSubsystems().getSubsystemsReferencing(capability.getResource()).iterator().next();
commit:7d27e24
/////////////////////////////////////////////////////////////////////////
0: 		computeContentResources();
0: 		computeDependencies();
/////////////////////////////////////////////////////////////////////////
0: 	private void computeContentResources() {
1: 			return;
/////////////////////////////////////////////////////////////////////////
1: 	}
1: 	
0: 	private void computeDependencies() {
0: 		SubsystemContentHeader contentHeader = resource.getSubsystemManifest().getSubsystemContentHeader();
0: 		try {
1: 			Map<Resource, List<Wire>> resolution = Activator.getInstance().getResolver().resolve(createResolveContext());
0: 			for (Resource resource : resolution.keySet())
0: 				if (!contentHeader.contains(resource))
0: 					addDependency(resource);
1: 		}
0: 		catch (ResolutionException e) {
0: 			throw new SubsystemException(e);
1: 		}
1: 	}
1: 	
1: 	private DeployedContentHeader computeDeployedContentHeader() {
1: 		Collection<Resource> content = getContentResources();
1: 		if (content.isEmpty())
1: 			return null;
1: 		return DeployedContentHeader.newInstance(content);
/////////////////////////////////////////////////////////////////////////
1: 	private DeploymentManifest computeExistingDeploymentManifest() throws IOException {
1: 		return resource.getDeploymentManifest();
1: 	}
1: 	
0: 		Collection<Resource> dependencies = getDepedencies();
1: 		if (dependencies.isEmpty())
1: 		return ProvisionResourceHeader.newInstance(dependencies);
/////////////////////////////////////////////////////////////////////////
1: 	private Collection<Resource> getContentResources() {
1: 		Collection<Resource> result = new ArrayList<Resource>(installableContent.size() + sharedContent.size());
1: 		result.addAll(installableContent);
1: 		result.addAll(sharedContent);
0: 		return result;
1: 	}
1: 	
0: 	private Collection<Resource> getDepedencies() {
1: 		Collection<Resource> result = new ArrayList<Resource>(installableDependencies.size() + sharedDependencies.size());
1: 		result.addAll(installableDependencies);
1: 		result.addAll(sharedDependencies);
0: 		return result;
1: 	}
1: 	
commit:dc5d52f
/////////////////////////////////////////////////////////////////////////
0: 	public SubsystemResource(String location, InputStream content, AriesSubsystem parent) throws URISyntaxException, IOException, ResolutionException {
commit:67ef08f
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.subsystem.core.internal;
1: 
1: import java.io.IOException;
0: import java.io.InputStream;
1: import java.net.URISyntaxException;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Map;
1: 
1: import org.apache.aries.subsystem.core.archive.DeployedContentHeader;
1: import org.apache.aries.subsystem.core.archive.DeploymentManifest;
1: import org.apache.aries.subsystem.core.archive.ProvisionResourceHeader;
1: import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
1: import org.apache.aries.subsystem.core.archive.SubsystemManifest;
1: import org.osgi.framework.wiring.BundleRevision;
1: import org.osgi.resource.Capability;
1: import org.osgi.resource.Requirement;
1: import org.osgi.resource.Resource;
1: import org.osgi.resource.Wire;
0: import org.osgi.resource.Wiring;
0: import org.osgi.service.repository.Repository;
0: import org.osgi.service.resolver.HostedCapability;
1: import org.osgi.service.resolver.ResolutionException;
1: import org.osgi.service.resolver.ResolveContext;
1: import org.osgi.service.subsystem.SubsystemConstants;
1: import org.osgi.service.subsystem.SubsystemException;
1: 
1: public class SubsystemResource implements Resource {
1: 	private final DeploymentManifest deploymentManifest;
1: 	private final Collection<Resource> installableContent = new HashSet<Resource>();
1: 	private final Collection<Resource> installableDependencies = new HashSet<Resource>();
1: 	private final Collection<Resource> mandatoryResources = new HashSet<Resource>();
1: 	private final Collection<Resource> optionalResources = new HashSet<Resource>();
0: 	private final AriesSubsystem parent;
0: 	private final Repository preferredProviderRepository;
1: 	private final RawSubsystemResource resource;
1: 	private final Collection<Resource> sharedContent = new HashSet<Resource>();
1: 	private final Collection<Resource> sharedDependencies = new HashSet<Resource>();
1: 	
0: 	public SubsystemResource(String location, InputStream content, AriesSubsystem parent) throws UnsupportedOperationException, URISyntaxException, IOException, ResolutionException {
0: 		this(new RawSubsystemResource(location, content), parent);
1: 	}
1: 	
0: 	public SubsystemResource(RawSubsystemResource resource, AriesSubsystem parent) throws IOException {
1: 		this.parent = parent;
1: 		this.resource = resource;
0: 		preferredProviderRepository = new PreferredProviderRepository(this);
1: 		deploymentManifest = computeDeploymentManifest();
1: 	}
1: 
1: 	@Override
1: 	public List<Capability> getCapabilities(String namespace) {
0: 		return resource.getCapabilities(namespace);
1: 	}
1: 	
1: 	public DeploymentManifest getDeploymentManifest() {
1: 		return deploymentManifest;
1: 	}
1: 	
1: 	public Collection<Resource> getInstallableContent() {
1: 		return installableContent;
1: 	}
1: 	
1: 	public Collection<Resource> getInstallableDependencies() {
1: 		return installableDependencies;
1: 	}
1: 	
0: 	public Repository getLocalRepository() {
1: 		return resource.getLocalRepository();
1: 	}
1: 	
1: 	public String getLocation() {
1: 		return resource.getLocation().getValue();
1: 	}
1: 	
0: 	public AriesSubsystem getParent() {
0: 		return parent;
1: 	}
1: 
1: 	@Override
1: 	public List<Requirement> getRequirements(String namespace) {
0: 		return resource.getRequirements(namespace);
1: 	}
1: 	
0: 	public Collection<Resource> getResources() {
0: 		return resource.getResources();
1: 	}
1: 	
1: 	public Collection<Resource> getSharedContent() {
1: 		return sharedContent;
1: 	}
1: 	
1: 	public Collection<Resource> getSharedDependencies() {
1: 		return sharedDependencies;
1: 	}
1: 	
1: 	public SubsystemManifest getSubsystemManifest() {
1: 		return resource.getSubsystemManifest();
1: 	}
1: 	
1: 	private void addContentResource(Resource resource) {
0: 		if (resource == null)
0: 			return;
1: 		if (isMandatory(resource))
1: 			mandatoryResources.add(resource);
0: 		else
1: 			optionalResources.add(resource);
1: 		if (isInstallable(resource))
1: 			installableContent.add(resource);
0: 		else
1: 			sharedContent.add(resource);
1: 	}
1: 	
0: 	private boolean addDependencies(Repository repository, Requirement requirement, List<Capability> capabilities) {
0: 		Map<Requirement, Collection<Capability>> m = repository.findProviders(Collections.singleton(requirement));
0: 		if (m.containsKey(requirement)) {
0: 			Collection<Capability> cc = m.get(requirement);
0: 			// TODO The following check only needs to be done on capabilities from the system repository.
0: 			addValidCapabilities(cc, capabilities);
1: 		}
0: 		return !capabilities.isEmpty();
1: 	}
1: 	
0: 	private boolean addDependenciesFromContentRepository(Requirement requirement, List<Capability> capabilities) {
0: 		Repository repository = new ContentRepository(installableContent, sharedContent);
0: 		return addDependencies(repository, requirement, capabilities);
1: 	}
1: 	
0: 	private boolean addDependenciesFromLocalRepository(Requirement requirement, List<Capability> capabilities) {
0: 		Repository repository = resource.getLocalRepository();
0: 		return addDependencies(repository, requirement, capabilities);
1: 	}
1: 	
0: 	private boolean addDependenciesFromPreferredProviderRepository(Requirement requirement, List<Capability> capabilities) {
0: 		return addDependencies(preferredProviderRepository, requirement, capabilities);
1: 	}
1: 	
0: 	private boolean addDependenciesFromRepositoryServiceRepositories(Requirement requirement, List<Capability> capabilities) {
0: 		Repository repository = new RepositoryServiceRepository();
0: 		return addDependencies(repository, requirement, capabilities);
1: 	}
1: 	
0: 	private boolean addDependenciesFromSystemRepository(Requirement requirement, List<Capability> capabilities) {
0: 		Repository repository = Activator.getInstance().getSystemRepository();
0: 		return addDependencies(repository, requirement, capabilities);
1: 	}
1: 	
0: 	private void addDependency(Resource resource) {
0: 		if (resource == null)
0: 			return;
1: 		if (isInstallable(resource))
0: 			installableDependencies.add(resource);
0: 		else
0: 			sharedDependencies.add(resource);
1: 	}
1: 	
0: 	private void addValidCapabilities(Collection<Capability> from, Collection<Capability> to) {
0: 		for (Capability c : from)
0: 			if (isValid(c))
0: 				to.add(c);
1: 	}
1: 	
0: 	private DeploymentManifest computeExistingDeploymentManifest() throws IOException {
0: 		return resource.getDeploymentManifest();
1: 	}
1: 	
0: 	private DeployedContentHeader computeDeployedContentHeader() {
0: 		Collection<Resource> resources = new HashSet<Resource>();
0: 		SubsystemContentHeader contentHeader = resource.getSubsystemManifest().getSubsystemContentHeader();
1: 		if (contentHeader == null)
1: 			return null;
0: 		for (SubsystemContentHeader.Content content : contentHeader.getContents()) {
0: 			OsgiIdentityRequirement requirement = new OsgiIdentityRequirement(
0: 					content.getName(), content.getVersionRange(),
0: 					content.getType(), false);
1: 			Resource resource = findContent(requirement);
1: 			if (resource == null) {
0: 				if (content.isMandatory())
0: 					throw new SubsystemException("Resource does not exist: "+ requirement);
1: 				continue;
1: 			}
0: 			resources.add(resource);
0: 			addContentResource(resource);
1: 		}
0: 		return DeployedContentHeader.newInstance(resources);
1: 	}
1: 	
1: 	private DeploymentManifest computeDeploymentManifest() throws IOException {
1: 		DeploymentManifest result = computeExistingDeploymentManifest();
1: 		if (result != null)
0: 			return result;
1: 		result = new DeploymentManifest.Builder().manifest(resource.getSubsystemManifest())
1: 				.header(computeDeployedContentHeader())
1: 				.header(computeProvisionResourceHeader()).build();
0: 		return result;
1: 	}
1: 	
0: 	private ProvisionResourceHeader computeProvisionResourceHeader() {
0: 		SubsystemContentHeader contentHeader = resource.getSubsystemManifest().getSubsystemContentHeader();
0: 		// TODO This does not validate that all content bundles were found.
0: 		Map<Resource, List<Wire>> resolution;
0: 		try {
0: 			resolution = Activator.getInstance().getResolver().resolve(createResolveContext());
1: 		}
0: 		catch (ResolutionException e) {
0: 			throw new SubsystemException(e);
1: 		}
0: 		Collection<Resource> provisionResource = new HashSet<Resource>();
1: 		for (Resource resource : resolution.keySet()) {
0: 			if (!contentHeader.contains(resource)) {
0: 				provisionResource.add(resource);
0: 				addDependency(resource);
1: 			}
1: 		}
0: 		if (provisionResource.isEmpty())
1: 			return null;
0: 		return ProvisionResourceHeader.newInstance(provisionResource);
1: 	}
1: 	
1: 	private ResolveContext createResolveContext() {
0: 		return new ResolveContext() {
1: 			@Override
0: 			public List<Capability> findProviders(Requirement requirement) {
0: 				List<Capability> result = new ArrayList<Capability>();
0: 				if (addDependenciesFromContentRepository(requirement, result))
0: 					return result;
0: 				if (addDependenciesFromPreferredProviderRepository(requirement, result))
0: 					return result;
0: 				if (addDependenciesFromSystemRepository(requirement, result))
0: 					return result;
0: 				if (addDependenciesFromLocalRepository(requirement, result))
0: 					return result;
0: 				if (addDependenciesFromRepositoryServiceRepositories(requirement, result))
0: 					return result;
0: 				return result;
1: 			}
1: 			
1: 			@Override
0: 			public Collection<Resource> getMandatoryResources() {
0: 				return SubsystemResource.this.mandatoryResources;
1: 			}
1: 			
1: 			@Override
0: 			public Collection<Resource> getOptionalResources() {
0: 				return SubsystemResource.this.optionalResources;
1: 			}
1: 
1: 			@Override
0: 			public int insertHostedCapability(List<Capability> capabilities,
0: 					HostedCapability hostedCapability) {
0: 				capabilities.add(hostedCapability);
0: 				return capabilities.size() - 1;
1: 			}
1: 
1: 			@Override
0: 			public boolean isEffective(Requirement requirement) {
0: 				return true;
1: 			}
1: 
1: 			@Override
0: 			public Map<Resource, Wiring> getWirings() {
0: 				return Collections.emptyMap();
1: 			}
0: 		};
1: 	}
1: 	
0: 	private Resource findContent(OsgiIdentityRequirement requirement) {
1: 		Map<Requirement, Collection<Capability>> map;
1: 		if (isUnscoped()) {
1: 			map = Activator.getInstance().getSystemRepository().findProviders(Collections.singleton(requirement));
1: 			if (map.containsKey(requirement)) {
1: 				Collection<Capability> capabilities = map.get(requirement);
1: 				for (Capability capability : capabilities) {
0: 					Collection<AriesSubsystem> subsystems = AriesSubsystem.getSubsystems(capability.getResource());
0: 					if (!subsystems.isEmpty())
0: 						if (subsystems.iterator().next().getRegion().equals(parent.getRegion()))
0: 							return capability.getResource();
1: 				}
1: 			}
1: 		}
1: 		map = resource.getLocalRepository().findProviders(Collections.singleton(requirement));
1: 		if (map.containsKey(requirement)) {
1: 			Collection<Capability> capabilities = map.get(requirement);
0: 			if (!capabilities.isEmpty())
0: 				return capabilities.iterator().next().getResource();
1: 		}
0: 		Collection<Capability> capabilities = new RepositoryServiceRepository().findProviders(requirement);
0: 		if (!capabilities.isEmpty())
0: 			return capabilities.iterator().next().getResource();
1: 		return null;
1: 	}
1: 	
0: 	private AriesSubsystem findFirstSubsystemAcceptingDependencies() {
0: 		AriesSubsystem subsystem = parent;
0: 		while (!isAcceptDependencies(subsystem))
0: 			subsystem = (AriesSubsystem)subsystem.getParents().iterator().next();
0: 		return subsystem;
1: 	}
1: 	
0: 	private boolean isAcceptDependencies(AriesSubsystem subsystem) {
0: 		return subsystem.getArchive().getSubsystemManifest().getSubsystemTypeHeader().getProvisionPolicyDirective().isAcceptDependencies();
1: 	}
1: 	
1: 	private boolean isInstallable(Resource resource) {
1: 		return !isShared(resource);
1: 	}
1: 	
1: 	private boolean isMandatory(Resource resource) {
1: 		SubsystemContentHeader header = this.resource.getSubsystemManifest().getSubsystemContentHeader();
0: 		if (header == null)
0: 			return false;
1: 		return header.isMandatory(resource);
1: 	}
1: 	
1: 	private boolean isShared(Resource resource) {
0: 		return resource instanceof AriesSubsystem || resource instanceof BundleRevision;
1: 	}
1: 	
1: 	private boolean isScoped() {
1: 		String type = resource.getSubsystemManifest().getSubsystemTypeHeader().getType();
0: 		return SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type) ||
0: 				SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type);
1: 	}
1: 	
1: 	private boolean isUnscoped() {
1: 		return !isScoped();
1: 	}
1: 	
0: 	private boolean isValid(Capability capability) {
0: 		AriesSubsystem subsystem;
0: 		if (isInstallable(capability.getResource()))
0: 			subsystem = findFirstSubsystemAcceptingDependencies();
0: 		else
0: 			subsystem = AriesSubsystem.getSubsystems(capability.getResource()).iterator().next();
0: 		return new SharingPolicyValidator(subsystem.getRegion(), parent.getRegion()).isValid(capability);
1: 	}
1: }
author:Tom Watson
-------------------------------------------------------------------------------
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.namespace.NativeNamespace;
1: import org.osgi.namespace.service.ServiceNamespace;
1: import org.osgi.resource.Namespace;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public org.apache.aries.subsystem.core.repository.Repository getLocalRepository() {
/////////////////////////////////////////////////////////////////////////
1: 	Collection<Resource> getMandatoryResources() {
1: 		return mandatoryResources;
0: 	}
0: 	
1: 	Collection<Resource> getOptionalResources() {
1: 		return optionalResources;
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
1: 			if (!isApplication()) {
0: 				setImportIsolationPolicy();
0: 			}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public Collection<TranslationFile> getTranslations() {
1: 		return resource.getTranslations();
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private void computeDependencies(SubsystemManifest manifest)  {
1: 			setImportIsolationPolicy(resolution);
/////////////////////////////////////////////////////////////////////////
1: 		catch (Exception e) {
0: 			if (e instanceof SubsystemException) {
0: 				throw (SubsystemException)e;
0: 			}
0: 			if (e instanceof SecurityException) {
0: 				throw (SecurityException)e;
0: 			}
0: 			throw new SubsystemException(e);
0: 		}
/////////////////////////////////////////////////////////////////////////
1: 		return new org.apache.aries.subsystem.core.internal.ResolveContext(this);
/////////////////////////////////////////////////////////////////////////
1: 	boolean isApplication() {
1: 		String type = resource.getSubsystemManifest().getSubsystemTypeHeader().getType();
1: 		return SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type);
1: 	boolean isComposite() {
1: 		String type = resource.getSubsystemManifest().getSubsystemTypeHeader().getType();
1: 		return SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type);
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
1: 	boolean isRoot() {
/////////////////////////////////////////////////////////////////////////
1: 		return isApplication() || isComposite();
1: 	private void setImportIsolationPolicy(Map<Resource, List<Wire>> resolution) throws Exception {
1: 		if (!isApplication()) {
0: 			return;
1: 		SubsystemContentHeader contentHeader = getSubsystemManifest().getSubsystemContentHeader();
1: 		// Prepare the regions and filter builder to set the sharing policy.
1: 		Region from = getRegion();
0: 		Region to = ((BasicSubsystem)getParents().iterator().next()).getRegion();
1: 		RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
1: 		// Always provide visibility to this subsystem's service registration.
1: 		addSubsystemServiceImportToSharingPolicy(builder, to);
0: 		for (Resource resource : resolution.keySet()) {
1: 			// If the resource is content but the wire provider is not,
1: 			// the sharing policy must be updated.
1: 			List<Wire> wires = resolution.get(resource);
1: 			for (Wire wire : wires) {
0: 				Resource provider = wire.getProvider();
1: 				if (contentHeader.contains(provider)) {
0: 					// The provider is content so the requirement does
0: 					// not need to become part of the sharing policy.
1: 					continue;
0: 				}
0: 				// The provider is not content, so the requirement must
0: 				// be added to the sharing policy.
1: 				Requirement requirement = wire.getRequirement();
0: 				String namespace = requirement.getNamespace();
0: 				if (ServiceNamespace.SERVICE_NAMESPACE.equals(namespace)) {
0: 					// The osgi.service namespace must be translated to one
0: 					// that region digraph understands.
0: 					namespace = RegionFilter.VISIBLE_SERVICE_NAMESPACE;
0: 				}
1: 				String filter = requirement.getDirectives().get(Namespace.REQUIREMENT_FILTER_DIRECTIVE);
1: 				if (filter == null) {
0: 					builder.allowAll(namespace);
0: 				}
0: 				else {
0: 					builder.allow(namespace, filter);
0: 				}
0: 			}
1: 		// Always add access to osgi.ee and osgi.native namespaces
1: 		setImplicitAccessToNativeAndEECapabilities(builder);
1: 		// Now set the sharing policy, if the regions are different.
1: 		RegionFilter regionFilter = builder.build();
1: 		from.connectRegion(to, regionFilter);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	
/////////////////////////////////////////////////////////////////////////
1: 		builder.allowAll(NativeNamespace.NATIVE_NAMESPACE);
commit:a6b79e8
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.namespace.ExecutionEnvironmentNamespace;
/////////////////////////////////////////////////////////////////////////
0: 					// Only check the system repository for osgi.ee and osgi.native
0: 					if (ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE.equals(requirement.getNamespace()) 
0: 							|| DependencyCalculator.NATIVE_NAMESPACE.equals(requirement.getNamespace())) {
0: 						addDependenciesFromSystemRepository(requirement, result);
0: 						return result;
0: 					}
/////////////////////////////////////////////////////////////////////////
1: 			// Always add access to osgi.ee and osgi.native namespaces
1: 			setImplicitAccessToNativeAndEECapabilities(builder);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1: 	private void setImplicitAccessToNativeAndEECapabilities(RegionFilterBuilder builder) {
1: 		builder.allowAll(ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE);
0: 		builder.allowAll(DependencyCalculator.NATIVE_NAMESPACE);
0: 	}
0: 
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:79b20bc
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 		this(new RawSubsystemResource(location, content, parent), parent);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1: 		resource = new RawSubsystemResource(directory, parent);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 		}
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 					if (ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE.equals(requirement.getNamespace())
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1: 		Region to = getParents().iterator().next().getRegion();
/////////////////////////////////////////////////////////////////////////
0: 
0: 		// work around https://www.osgi.org/bugzilla/show_bug.cgi?id=144
0: 		// In the first instance, what if the various weaving services were to have a property,
0: 		// osgi.woven.packages, that was a comma separated list of packages that might be woven
0: 		// by that hook.
0: 		for (String pkg : wovenPackages) {
/////////////////////////////////////////////////////////////////////////
0: 
0: 	// First pass at this: really just a sketch.
0: 		for (ServiceReference<WeavingHook> sr : weavers) {
0: 			if (someWovenPackages != null) {
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:9bba779
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public SubsystemResource(String location, IDirectory content, BasicSubsystem parent) throws URISyntaxException, IOException, ResolutionException, BundleException, InvalidSyntaxException {
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:87c258f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
0: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.ServiceReference;
0: import org.osgi.framework.hooks.weaving.WeavingHook;
/////////////////////////////////////////////////////////////////////////
0: 		
0: 		// work around https://www.osgi.org/bugzilla/show_bug.cgi?id=144 
0: 		// In the first instance, what if the various weaving services were to have a property, 
0: 		// osgi.woven.packages, that was a comma separated list of packages that might be woven 
0: 		// by that hook. 
0: 		Collection<String> wovenPackages = getWovenPackages();
0: 		for (String pkg : wovenPackages) { 
0: 			builder.allow(policy, "(osgi.wiring.package=" + pkg + ")");
0: 		}
0: 	}
0: 	
0: 	// First pass at this: really just a sketch. 
0: 	private Collection<String> getWovenPackages() throws InvalidSyntaxException
0: 	{
0: 		// Find all weaving services in our region
0: 		BundleContext bc = Activator.getInstance().getBundleContext();
0: 		Collection<ServiceReference<WeavingHook>> weavers = bc.getServiceReferences(WeavingHook.class, null);
0: 		Collection<String> wovenPackages = new ArrayList<String>();
0: 		for (ServiceReference<WeavingHook> sr : weavers) { 
0: 			String someWovenPackages = (String) sr.getProperty("osgi.woven.packages");
0: 			if (someWovenPackages != null) { 
0: 				wovenPackages.addAll(ManifestHeaderProcessor.split(someWovenPackages, ","));
0: 			}
0: 		}
0: 		return wovenPackages;
============================================================================