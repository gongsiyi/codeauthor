1:9b1f38a: package org.apache.aries.plugin.esa;
1:1c02b36: 
1:edce8a5: /*
1:9b1f38a:  * Licensed to the Apache Software Foundation (ASF) under one
1:9b1f38a:  * or more contributor license agreements.  See the NOTICE file
1:9b1f38a:  * distributed with this work for additional information
1:9b1f38a:  * regarding copyright ownership.  The ASF licenses this file
1:9b1f38a:  * to you under the Apache License, Version 2.0 (the
1:9b1f38a:  * "License"); you may not use this file except in compliance
1:9b1f38a:  * with the License.  You may obtain a copy of the License at
1:9b1f38a:  *
1:9b1f38a:  *  http://www.apache.org/licenses/LICENSE-2.0
1:9b1f38a:  *
1:9b1f38a:  * Unless required by applicable law or agreed to in writing,
1:9b1f38a:  * software distributed under the License is distributed on an
1:9b1f38a:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:9b1f38a:  * KIND, either express or implied.  See the License for the
1:9b1f38a:  * specific language governing permissions and limitations
1:9b1f38a:  * under the License.
3:9b1f38a:  */
7:9b1f38a: 
1:9b1f38a: import org.apache.maven.archiver.PomPropertiesUtil;
1:9b1f38a: import org.apache.maven.artifact.Artifact;
1:9b1f38a: import org.apache.maven.plugin.AbstractMojo;
1:9b1f38a: import org.apache.maven.plugin.MojoExecutionException;
1:9b1f38a: import org.apache.maven.project.MavenProject;
1:9b1f38a: import org.codehaus.plexus.archiver.ArchiverException;
1:9b1f38a: import org.codehaus.plexus.archiver.zip.ZipArchiver;
1:9b1f38a: import org.codehaus.plexus.util.DirectoryScanner;
1:9b1f38a: import org.codehaus.plexus.util.FileUtils;
1:9b1f38a: import java.io.File;
1:9b1f38a: import java.io.IOException;
1:9b1f38a: import java.util.Iterator;
1:9b1f38a: import java.util.LinkedHashMap;
1:9b1f38a: import java.util.LinkedHashSet;
1:1c02b36: import java.util.HashSet;
1:9b1f38a: import java.util.Map;
1:9b1f38a: import java.util.Set;
1:9b1f38a: 
3:9b1f38a: /**
1:9b1f38a:  * Builds OSGi Enterprise Subsystem Archive (esa) files.
1:9b1f38a:  *
1:9b1f38a:  * @version $Id: $
1:9b1f38a:  * @goal esa
1:9b1f38a:  * @phase package
1:9b1f38a:  * @requiresDependencyResolution test
1:9b1f38a:  */
1:9b1f38a: public class EsaMojo
1:9b1f38a:     extends AbstractMojo
1:9b1f38a: {
1:9b1f38a: 
1:a551336:     public enum EsaContent {none, all, content};
1:9b1f38a:     
1:a551336:     public static final String SUBSYSTEM_MF_URI = "OSGI-INF/SUBSYSTEM.MF";
1:9b1f38a: 
1:9b1f38a:     private static final String[] DEFAULT_INCLUDES = {"**/**"};
1:9b1f38a: 
1:1c02b36:     private static final Set<String> SKIP_INSTRUCTIONS = new HashSet<String>();
1:1c02b36: 
1:1c02b36:     static {
1:f2a8ed5:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_MANIFESTVERSION);
1:f2a8ed5:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_SYMBOLICNAME);
1:f2a8ed5:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_VERSION);
1:f2a8ed5:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_NAME);
1:f2a8ed5:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_DESCRIPTION);
1:f2a8ed5:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_CONTENT);
1:1c02b36:     }
1:1c02b36: 
1:9b1f38a:     /**
1:9b1f38a:      * Single directory for extra files to include in the esa.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${basedir}/src/main/esa"
1:9b1f38a:      * @required
1:9b1f38a:      */
1:9b1f38a:     private File esaSourceDirectory;
1:1c02b36: 
1:9b1f38a:     /**
1:9b1f38a:      * The location of the SUBSYSTEM.MF file to be used within the esa file.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${basedir}/src/main/esa/OSGI-INF/SUBSYSTEM.MF"
1:9b1f38a:      */
1:9b1f38a:     private File subsystemManifestFile;
1:9b1f38a: 
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * The location of the manifest file to be used within the esa file.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${basedir}/src/main/esa/META-INF/MANIFEST.MF"
1:9b1f38a:      */
1:9b1f38a:     private File manifestFile;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * Directory that resources are copied to during the build.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${project.build.directory}/${project.build.finalName}"
1:9b1f38a:      * @required
1:9b1f38a:      */
1:9b1f38a:     private String workDirectory;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * Directory that remote-resources puts legal files.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${project.build.directory}/maven-shared-archive-resources"
1:9b1f38a:      * @required
1:9b1f38a:      */
1:9b1f38a:     private String sharedResources;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * The directory for the generated esa.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${project.build.directory}"
1:9b1f38a:      * @required
1:9b1f38a:      */
1:9b1f38a:     private String outputDirectory;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * The name of the esa file to generate.
1:9b1f38a:      *
1:9b1f38a:      * @parameter alias="esaName" expression="${project.build.finalName}"
1:9b1f38a:      * @required
1:9b1f38a:      */
1:9b1f38a:     private String finalName;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * The maven project.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${project}"
1:9b1f38a:      * @required
1:9b1f38a:      * @readonly
1:9b1f38a:      */
1:9b1f38a:     private MavenProject project;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * The Jar archiver.
1:9b1f38a:      *
1:9b1f38a:      * @component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
1:9b1f38a:      * @required
1:9b1f38a:      */
1:9b1f38a:     private ZipArchiver zipArchiver;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * Whether to generate a manifest based on maven configuration.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${generateManifest}" default-value="false"
1:9b1f38a:      */
1:9b1f38a:     private boolean generateManifest;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * Configuration for the plugin.
1:9b1f38a:      *
1:9b1f38a:      * @parameter
1:9b1f38a:      */
1:1c02b36:     private Map instructions = new LinkedHashMap();
1:9b1f38a:     
1:9b1f38a:     /**
1:9b1f38a:      * Adding pom.xml and pom.properties to the archive.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${addMavenDescriptor}" default-value="true"
1:9b1f38a:      */
1:9b1f38a:     private boolean addMavenDescriptor;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * Include or not empty directories
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${includeEmptyDirs}" default-value="true"
1:9b1f38a:      */
1:9b1f38a:     private boolean includeEmptyDirs;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * Whether creating the archive should be forced.
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${forceCreation}" default-value="false"
1:9b1f38a:      */
1:9b1f38a:     private boolean forceCreation;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * Define which bundles to include in the archive.
1:9b1f38a:      *   none - no bundles are included 
1:9b1f38a:      *   subsystemContent - direct dependencies go into the content
1:9b1f38a:      *   all - direct and transitive dependencies go into the content 
1:9b1f38a:      *
1:9b1f38a:      * @parameter expression="${archiveContent}" default-value="content"
1:9b1f38a:      */
1:9b1f38a:     private String archiveContent;
1:9b1f38a: 
1:edce8a5:     /**
1:edce8a5:      * Define the start order for content bundles.
1:edce8a5:      *   none - no start orders are added
1:edce8a5:      *   dependencies - start order based on pom dependency order
1:edce8a5:      *
1:edce8a5:      * @parameter expression="${startOrder}" default-value="none"
1:edce8a5:      */
1:edce8a5:     private String startOrder;
1:9b1f38a: 
1:9b1f38a:     private File buildDir;
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * add the dependencies to the archive depending on the configuration of <archiveContent />
1:9b1f38a:      */
1:9b1f38a:     private void addDependenciesToArchive() throws MojoExecutionException {
1:9b1f38a:         try
1:9b1f38a:         {
1:9b1f38a:             Set<Artifact> artifacts = null;
1:9b1f38a:             switch (EsaContent.valueOf(archiveContent)) {
1:9b1f38a:             case none:
1:a551336:                 getLog().info("archiveContent=none: subsystem archive will not contain any bundles.");                  
1:9b1f38a:                 break;
1:9b1f38a:             case content:
1:9b1f38a:                 // only include the direct dependencies in the archive
1:9b1f38a:                 artifacts = project.getDependencyArtifacts();                   
1:9b1f38a:                 break;
1:9b1f38a:             case all:
1:9b1f38a:                 // include direct and transitive dependencies in the archive
1:9b1f38a:                 artifacts = project.getArtifacts();                 
1:9b1f38a:                 break;
1:9b1f38a:             default:
1:9b1f38a:                 throw new MojoExecutionException("Invalid configuration for <archiveContent/>.  Valid values are none, content and all." );                    
1:edce8a5:             }
1:9b1f38a:               
1:9b1f38a:             if (artifacts != null) {
1:a551336:                 // Explicitly add self to bundle set (used when pom packaging
1:a551336:                 // type != "esa" AND a file is present (no point to add to
1:a551336:                 // zip archive without file)
1:a551336:                 final Artifact selfArtifact = project.getArtifact();
1:a551336:                 if (!"esa".equals(selfArtifact.getType()) && selfArtifact.getFile() != null) {
1:a551336:                     getLog().info("Explicitly adding artifact[" + selfArtifact.getGroupId() + ", " + selfArtifact.getId() + ", " + selfArtifact.getScope() + "]");
1:a551336:                     artifacts.add(project.getArtifact());
1:a551336:                 }
1:a551336:                 
1:9b1f38a:                 artifacts = selectArtifacts(artifacts);
1:a551336:                 int cnt = 0;
1:f2a8ed5:                 for (Artifact artifact : artifacts) {                    
1:9b1f38a:                     if (!artifact.isOptional() /*&& filter.include(artifact)*/) {
1:9b1f38a:                         getLog().info("Copying artifact[" + artifact.getGroupId() + ", " + artifact.getId() + ", " +
1:9b1f38a:                                 artifact.getScope() + "]");
1:9b1f38a:                         zipArchiver.addFile(artifact.getFile(), artifact.getArtifactId() + "-" + artifact.getVersion() + "." + (artifact.getType() == null ? "jar" : artifact.getType()));
1:a551336:                         cnt++;
4:9b1f38a:                     }
1:9b1f38a:                 }               
1:a551336:                 getLog().info(String.format("Added %s artifacts to subsystem subsystem archive.", cnt));
1:9b1f38a:             }
1:9b1f38a:         }
1:9b1f38a:         catch ( ArchiverException e )
1:9b1f38a:         {
1:9b1f38a:             throw new MojoExecutionException( "Error copying esa dependencies", e );
1:9b1f38a:         }
1:9b1f38a: 
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a:     /**
1:9b1f38a:      * 
1:9b1f38a:      * Copies source files to the esa
1:9b1f38a:      * 
1:9b1f38a:      * @throws MojoExecutionException
1:9b1f38a:      */
1:9b1f38a:     private void copyEsaSourceFiles() throws MojoExecutionException {
1:9b1f38a:         try
1:9b1f38a:         {
1:9b1f38a:             File esaSourceDir = esaSourceDirectory;
1:9b1f38a:             if ( esaSourceDir.exists() )
1:9b1f38a:             {
1:9b1f38a:                 getLog().info( "Copy esa resources to " + getBuildDir().getAbsolutePath() );
1:9b1f38a: 
1:9b1f38a:                 DirectoryScanner scanner = new DirectoryScanner();
1:9b1f38a:                 scanner.setBasedir( esaSourceDir.getAbsolutePath() );
1:9b1f38a:                 scanner.setIncludes( DEFAULT_INCLUDES );
1:9b1f38a:                 scanner.addDefaultExcludes();
1:9b1f38a:                 scanner.scan();
1:9b1f38a: 
1:9b1f38a:                 String[] dirs = scanner.getIncludedDirectories();
1:9b1f38a: 
1:9b1f38a:                 for ( int j = 0; j < dirs.length; j++ )
1:9b1f38a:                 {
1:9b1f38a:                     new File( getBuildDir(), dirs[j] ).mkdirs();
1:9b1f38a:                 }
1:9b1f38a: 
1:9b1f38a:                 String[] files = scanner.getIncludedFiles();
1:9b1f38a: 
1:9b1f38a:                 for ( int j = 0; j < files.length; j++ )
1:9b1f38a:                 {
1:9b1f38a:                     File targetFile = new File( getBuildDir(), files[j] );
1:9b1f38a: 
1:9b1f38a:                     targetFile.getParentFile().mkdirs();
1:9b1f38a: 
1:9b1f38a:                     File file = new File( esaSourceDir, files[j] );
1:9b1f38a:                     FileUtils.copyFileToDirectory( file, targetFile.getParentFile() );
1:9b1f38a:                 }
1:9b1f38a:             }
1:9b1f38a:         }
1:9b1f38a:         catch ( Exception e )
1:9b1f38a:         {
1:9b1f38a:             throw new MojoExecutionException( "Error copying esa resources", e );
1:9b1f38a:         }
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a:     private void includeCustomManifest() throws MojoExecutionException {
1:9b1f38a:         try
1:9b1f38a:         {
1:9b1f38a:             if (!generateManifest) {
1:9b1f38a:                 includeCustomSubsystemManifestFile();
1:9b1f38a:             }
1:9b1f38a:         }
1:9b1f38a:         catch ( IOException e )
1:9b1f38a:         {
1:9b1f38a:             throw new MojoExecutionException( "Error copying SUBSYSTEM.MF file", e );
1:9b1f38a:         }
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a:     private void generateSubsystemManifest() throws MojoExecutionException {
1:9b1f38a:         if (generateManifest) {
1:9b1f38a:             String fileName = new String(getBuildDir() + "/"
1:9b1f38a:                     + SUBSYSTEM_MF_URI);
1:9b1f38a:             File appMfFile = new File(fileName);
1:9b1f38a: 
1:9b1f38a:             try {
1:9b1f38a:                 // Delete any old manifest
1:9b1f38a:                 if (appMfFile.exists()) {
1:9b1f38a:                     FileUtils.fileDelete(fileName);
1:9b1f38a:                 }
1:9b1f38a: 
1:9b1f38a:                 appMfFile.getParentFile().mkdirs();
1:9b1f38a:                 if (appMfFile.createNewFile()) {
1:9b1f38a:                     writeSubsystemManifest(fileName);
1:9b1f38a:                 }
1:9b1f38a:             } catch (java.io.IOException e) {
1:9b1f38a:                 throw new MojoExecutionException(
1:9b1f38a:                         "Error generating SUBSYSTEM.MF file: " + fileName, e);
1:9b1f38a:             }
1:9b1f38a:         }
1:9b1f38a:         
1:9b1f38a:         // Check the manifest exists
1:9b1f38a:         File ddFile = new File( getBuildDir(), SUBSYSTEM_MF_URI);
1:9b1f38a:         if ( !ddFile.exists() )
1:9b1f38a:         {
1:9b1f38a:             getLog().warn(
1:9b1f38a:                 "Subsystem manifest: " + ddFile.getAbsolutePath() + " does not exist." );
1:9b1f38a:         }
1:9b1f38a: 
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a:     private void addMavenDescriptor() throws MojoExecutionException {
1:9b1f38a:         try {
1:9b1f38a: 
1:9b1f38a:             if (addMavenDescriptor) {
1:9b1f38a:                 if (project.getArtifact().isSnapshot()) {
1:9b1f38a:                     project.setVersion(project.getArtifact().getVersion());
1:9b1f38a:                 }
1:9b1f38a: 
1:9b1f38a:                 String groupId = project.getGroupId();
1:9b1f38a: 
1:9b1f38a:                 String artifactId = project.getArtifactId();
1:9b1f38a: 
1:9b1f38a:                 zipArchiver.addFile(project.getFile(), "META-INF/maven/"
1:9b1f38a:                         + groupId + "/" + artifactId + "/pom.xml");
1:9b1f38a:                 PomPropertiesUtil pomPropertiesUtil = new PomPropertiesUtil();
1:9b1f38a:                 File dir = new File(project.getBuild().getDirectory(),
1:9b1f38a:                         "maven-zip-plugin");
1:9b1f38a:                 File pomPropertiesFile = new File(dir, "pom.properties");
1:9b1f38a:                 pomPropertiesUtil.createPomProperties(project, zipArchiver,
1:9b1f38a:                         pomPropertiesFile, forceCreation);
1:9b1f38a:             }
1:9b1f38a:         } catch (Exception e) {
1:9b1f38a:             throw new MojoExecutionException("Error assembling esa", e);
1:9b1f38a:         }
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a:     
1:9b1f38a:     private void init() {
1:9b1f38a:         getLog().debug( " ======= esaMojo settings =======" );
1:9b1f38a:         getLog().debug( "esaSourceDirectory[" + esaSourceDirectory + "]" );
1:9b1f38a:         getLog().debug( "manifestFile[" + manifestFile + "]" );
1:9b1f38a:         getLog().debug( "subsystemManifestFile[" + subsystemManifestFile + "]" );
1:9b1f38a:         getLog().debug( "workDirectory[" + workDirectory + "]" );
1:9b1f38a:         getLog().debug( "outputDirectory[" + outputDirectory + "]" );
1:9b1f38a:         getLog().debug( "finalName[" + finalName + "]" );
1:9b1f38a:         getLog().debug( "generateManifest[" + generateManifest + "]" );
1:9b1f38a: 
1:9b1f38a:         if (archiveContent == null) {
1:9b1f38a:             archiveContent = new String("content");
1:9b1f38a:         }
1:9b1f38a:         
1:9b1f38a:         getLog().debug( "archiveContent[" + archiveContent + "]" );        
1:9b1f38a:         getLog().info( "archiveContent[" + archiveContent + "]" );        
1:9b1f38a:         
1:9b1f38a:         zipArchiver.setIncludeEmptyDirs( includeEmptyDirs );
1:9b1f38a:         zipArchiver.setCompress( true );
1:9b1f38a:         zipArchiver.setForced( forceCreation );        
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a: 
1:9b1f38a:     private void writeSubsystemManifest(String fileName)
1:9b1f38a:             throws MojoExecutionException {
1:9b1f38a:         try {
1:9b1f38a:             // TODO: add support for dependency version ranges. Need to pick
1:9b1f38a:             // them up from the pom and convert them to OSGi version ranges.
1:f2a8ed5:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_MANIFESTVERSION + ": " + "1" + "\n");
1:f2a8ed5:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_SYMBOLICNAME + ": "
1:9b1f38a:                     + getSubsystemSymbolicName(project.getArtifact()) + "\n");
1:f2a8ed5:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_VERSION + ": "
1:9b1f38a:                     + getSubsystemVersion() + "\n");
1:f2a8ed5:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_NAME + ": " + getSubsystemName() + "\n");
1:5302dea:             String description = getSubsystemDescription();
1:5302dea:             if (description != null) {
1:f2a8ed5:                 FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_DESCRIPTION + ": " + description + "\n");
1:5302dea:             }
1:9b1f38a: 
1:9b1f38a:             // Write the SUBSYSTEM-CONTENT
1:9b1f38a:             // TODO: check that the dependencies are bundles (currently, the converter
1:9b1f38a:             // will throw an exception)
1:9b1f38a:             Set<Artifact> artifacts = null;
1:9b1f38a:             // only include the direct dependencies in the content
1:9b1f38a:             artifacts = project.getDependencyArtifacts();                   
1:9b1f38a:             
1:9b1f38a:             artifacts = selectArtifacts(artifacts);
1:9b1f38a:             Iterator<Artifact> iter = artifacts.iterator();
1:9b1f38a: 
1:f2a8ed5:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_CONTENT + ": ");
1:f2a8ed5:             int order = 0;
1:9b1f38a:             while (iter.hasNext()) {
1:edce8a5:                 Artifact artifact = iter.next();
1:edce8a5:                 order++;
1:f2a8ed5:                 ContentInfo info = ContentInfo.create(artifact, getLog());
1:f2a8ed5:                 if (info == null) {
1:f2a8ed5:                     continue;
1:f2a8ed5:                 }
1:f2a8ed5:                 String entry = info.getContentLine();
2:edce8a5:                 if ("dependencies".equals(startOrder)) {
1:f137dd1:                     entry += ";start-order:=\"" + order + "\"";                  
1:9b1f38a:                 }
1:f2a8ed5:                 if (iter.hasNext()) {
1:f2a8ed5:                     entry += ",\n ";
1:f2a8ed5:                 }
2:edce8a5:                 FileUtils.fileAppend(fileName, entry);
1:edce8a5:             }
1:9b1f38a: 
1:9b1f38a:             FileUtils.fileAppend(fileName, "\n");
1:9b1f38a: 
1:1c02b36:             Iterator<Map.Entry<?, ?>> instructionIter = instructions.entrySet().iterator();
1:1c02b36:             while(instructionIter.hasNext()) {
1:1c02b36:                 Map.Entry<?, ?> entry = instructionIter.next();
1:1c02b36:                 String header = entry.getKey().toString();
1:1c02b36:                 if (SKIP_INSTRUCTIONS.contains(header)) {
1:1c02b36:                     continue;
1:1c02b36:                 }
1:1c02b36:                 getLog().debug("Adding header: " + header);
1:1c02b36:                 FileUtils.fileAppend(fileName, header + ": " + entry.getValue() + "\n");
1:9b1f38a:             }
1:9b1f38a: 
1:9b1f38a:         } catch (Exception e) {
1:9b1f38a:             throw new MojoExecutionException(
1:9b1f38a:                     "Error writing dependencies into SUBSYSTEM.MF", e);
1:9b1f38a:         }
1:9b1f38a: 
1:9b1f38a:     }
1:9b1f38a: 
1:9b1f38a:     // The maven2OsgiConverter assumes the artifact is a jar so we need our own
1:9b1f38a:     // This uses the same fallback scheme as the converter
1:9b1f38a:     private String getSubsystemSymbolicName(Artifact artifact) {
1:f2a8ed5:         if (instructions.containsKey(Constants.SUBSYSTEM_SYMBOLICNAME)) {
1:f2a8ed5:             return instructions.get(Constants.SUBSYSTEM_SYMBOLICNAME).toString();
1:9b1f38a:         }
1:9b1f38a:         return artifact.getGroupId() + "." + artifact.getArtifactId();
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a:     private String getSubsystemVersion() {
1:f2a8ed5:         if (instructions.containsKey(Constants.SUBSYSTEM_VERSION)) {
1:f2a8ed5:             return instructions.get(Constants.SUBSYSTEM_VERSION).toString();
1:9b1f38a:         }
1:9b1f38a:         return aQute.lib.osgi.Analyzer.cleanupVersion(project.getVersion());
1:9b1f38a:     }
1:9b1f38a:     
1:5302dea:     private String getSubsystemName() {
1:f2a8ed5:         if (instructions.containsKey(Constants.SUBSYSTEM_NAME)) {
1:f2a8ed5:             return instructions.get(Constants.SUBSYSTEM_NAME).toString();
1:5302dea:         }
1:5302dea:         return project.getName();
1:5302dea:     }
1:5302dea:     
1:5302dea:     private String getSubsystemDescription() {
1:f2a8ed5:         if (instructions.containsKey(Constants.SUBSYSTEM_DESCRIPTION)) {
1:f2a8ed5:             return instructions.get(Constants.SUBSYSTEM_DESCRIPTION).toString();
1:5302dea:         }
1:5302dea:         return project.getDescription();
1:5302dea:     }
1:5302dea:     
1:9b1f38a:     private File getBuildDir() {
1:9b1f38a:         if (buildDir == null) {
1:9b1f38a:             buildDir = new File(workDirectory);
1:9b1f38a:         }
1:9b1f38a:         return buildDir;
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a:     private void addBuildDir() throws MojoExecutionException {
1:9b1f38a:         try {
1:9b1f38a:             if (buildDir.isDirectory()) {
1:9b1f38a:                 zipArchiver.addDirectory(buildDir);
1:9b1f38a:             }
1:9b1f38a: 
1:9b1f38a:         } catch (Exception e) {
1:9b1f38a:             throw new MojoExecutionException(
1:9b1f38a:                     "Error writing dependencies into SUBSYSTEM.MF", e);
1:9b1f38a:         }
1:9b1f38a:     }
1:9b1f38a: 
1:9b1f38a:     private void includeCustomSubsystemManifestFile()
1:9b1f38a:         throws IOException
1:9b1f38a:     {
1:9b1f38a:         if (subsystemManifestFile == null) {
1:9b1f38a:             throw new NullPointerException("Subsystem manifest file location not set.  Use <generateManifest>true</generateManifest> if you want it to be generated.");
1:9b1f38a:         }
1:9b1f38a:         File appMfFile = subsystemManifestFile;
1:9b1f38a:         if (appMfFile.exists()) {
1:9b1f38a:             getLog().info( "Using SUBSYSTEM.MF "+ subsystemManifestFile);
1:9b1f38a:             File osgiInfDir = new File(getBuildDir(), "OSGI-INF");
1:9b1f38a:             FileUtils.copyFileToDirectory( appMfFile, osgiInfDir);
1:9b1f38a:         }
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a:     /**
1:9b1f38a:      * Return artifacts in 'compile' or 'runtime' scope only.   
1:9b1f38a:      */
1:9b1f38a:     private Set<Artifact> selectArtifacts(Set<Artifact> artifacts) 
1:9b1f38a:     {
1:9b1f38a:         Set<Artifact> selected = new LinkedHashSet<Artifact>();
2:9b1f38a:         for (Artifact artifact : artifacts) {
1:9b1f38a:             String scope = artifact.getScope();
1:9b1f38a:             if (scope == null 
1:9b1f38a:                 || Artifact.SCOPE_COMPILE.equals(scope)
1:9b1f38a:                 || Artifact.SCOPE_RUNTIME.equals(scope)) {
1:9b1f38a:                 selected.add(artifact);
1:9b1f38a:             }
1:9b1f38a:         }
1:9b1f38a:         return selected;
1:9b1f38a:     }
1:9b1f38a: 
1:9b1f38a:     private void includeSharedResources() throws MojoExecutionException {
1:9b1f38a:         try
1:9b1f38a:         {
1:9b1f38a:             //include legal files if any
1:9b1f38a:             File sharedResourcesDir = new File(sharedResources);
1:9b1f38a:             if (sharedResourcesDir.isDirectory()) {
1:9b1f38a:                 zipArchiver.addDirectory(sharedResourcesDir);
1:9b1f38a:             }
1:9b1f38a:         }
1:9b1f38a:         catch ( Exception e )
1:9b1f38a:         {
1:9b1f38a:             throw new MojoExecutionException( "Error assembling esa", e );
1:9b1f38a:         }
1:9b1f38a:     }
1:9b1f38a: 
1:9b1f38a:     /**
1:9b1f38a:      * Creates the final archive.
1:9b1f38a:      * 
1:9b1f38a:      * @throws MojoExecutionException
1:9b1f38a:      */
1:9b1f38a:     private void createEsaFile() throws MojoExecutionException {
1:9b1f38a:         try
1:9b1f38a:         {
1:9b1f38a:             File esaFile = new File( outputDirectory, finalName + ".esa" );
1:9b1f38a:             zipArchiver.setDestFile(esaFile);
1:9b1f38a: 
1:9b1f38a: 
1:9b1f38a:             zipArchiver.createArchive();
1:9b1f38a: 
1:9b1f38a:             project.getArtifact().setFile( esaFile );
1:9b1f38a:         }
1:9b1f38a:         catch ( Exception e )
1:9b1f38a:         {
1:9b1f38a:             throw new MojoExecutionException( "Error assembling esa", e );
1:9b1f38a:         }
1:9b1f38a: 
1:9b1f38a:     }
1:9b1f38a:     
1:9b1f38a:     public void execute()
1:9b1f38a:         throws MojoExecutionException
1:9b1f38a:     {
1:9b1f38a:         init();
1:9b1f38a: 
1:9b1f38a:         addDependenciesToArchive();
1:9b1f38a:         
1:9b1f38a:         copyEsaSourceFiles();
1:9b1f38a: 
1:9b1f38a:         includeCustomManifest();
1:9b1f38a:         
1:9b1f38a:         generateSubsystemManifest();
1:9b1f38a: 
1:9b1f38a:         addMavenDescriptor();
1:9b1f38a:         
1:9b1f38a:         addBuildDir();
1:9b1f38a:         
1:9b1f38a:         includeSharedResources();
1:9b1f38a:         
1:9b1f38a:         createEsaFile();
1:9b1f38a:     }
1:9b1f38a: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:f137dd1
/////////////////////////////////////////////////////////////////////////
1:                     entry += ";start-order:=\"" + order + "\"";                  
commit:a551336
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public enum EsaContent {none, all, content};
1:     public static final String SUBSYSTEM_MF_URI = "OSGI-INF/SUBSYSTEM.MF";
/////////////////////////////////////////////////////////////////////////
1:                 getLog().info("archiveContent=none: subsystem archive will not contain any bundles.");                  
/////////////////////////////////////////////////////////////////////////
1:                 // Explicitly add self to bundle set (used when pom packaging
1:                 // type != "esa" AND a file is present (no point to add to
1:                 // zip archive without file)
1:                 final Artifact selfArtifact = project.getArtifact();
1:                 if (!"esa".equals(selfArtifact.getType()) && selfArtifact.getFile() != null) {
1:                     getLog().info("Explicitly adding artifact[" + selfArtifact.getGroupId() + ", " + selfArtifact.getId() + ", " + selfArtifact.getScope() + "]");
1:                     artifacts.add(project.getArtifact());
1:                 }
1:                 
1:                 int cnt = 0;
1:                         cnt++;
1:                 getLog().info(String.format("Added %s artifacts to subsystem subsystem archive.", cnt));
/////////////////////////////////////////////////////////////////////////
0:                         maven2OsgiConverter.getBundleSymbolicName(artifact)
0:                     entry += ";start-order=\"" + order + "\"";                  
/////////////////////////////////////////////////////////////////////////
0:                     entry += ";start-order=\"" + order + "\"";                  
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:f2a8ed5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_MANIFESTVERSION);
1:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_SYMBOLICNAME);
1:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_VERSION);
1:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_NAME);
1:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_DESCRIPTION);
1:         SKIP_INSTRUCTIONS.add(Constants.SUBSYSTEM_CONTENT);
/////////////////////////////////////////////////////////////////////////
1:                 for (Artifact artifact : artifacts) {                    
/////////////////////////////////////////////////////////////////////////
1:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_MANIFESTVERSION + ": " + "1" + "\n");
1:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_SYMBOLICNAME + ": "
1:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_VERSION + ": "
1:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_NAME + ": " + getSubsystemName() + "\n");
1:                 FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_DESCRIPTION + ": " + description + "\n");
/////////////////////////////////////////////////////////////////////////
1:             FileUtils.fileAppend(fileName, Constants.SUBSYSTEM_CONTENT + ": ");
1:             int order = 0;
1:                 ContentInfo info = ContentInfo.create(artifact, getLog());
1:                 if (info == null) {
1:                     continue;
1:                 }
1:                 String entry = info.getContentLine();
1:                 if (iter.hasNext()) {
1:                     entry += ",\n ";
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         if (instructions.containsKey(Constants.SUBSYSTEM_SYMBOLICNAME)) {
1:             return instructions.get(Constants.SUBSYSTEM_SYMBOLICNAME).toString();
1:         if (instructions.containsKey(Constants.SUBSYSTEM_VERSION)) {
1:             return instructions.get(Constants.SUBSYSTEM_VERSION).toString();
1:         if (instructions.containsKey(Constants.SUBSYSTEM_NAME)) {
1:             return instructions.get(Constants.SUBSYSTEM_NAME).toString();
1:         if (instructions.containsKey(Constants.SUBSYSTEM_DESCRIPTION)) {
1:             return instructions.get(Constants.SUBSYSTEM_DESCRIPTION).toString();
commit:5302dea
/////////////////////////////////////////////////////////////////////////
0:             FileUtils.fileAppend(fileName, SUBSYSTEM_NAME + ": " + getSubsystemName() + "\n");
1:             String description = getSubsystemDescription();
1:             if (description != null) {
0:                 FileUtils.fileAppend(fileName, SUBSYSTEM_DESCRIPTION + ": " + description + "\n");
1:             }
/////////////////////////////////////////////////////////////////////////
1:     private String getSubsystemName() {
0:         if (instructions.containsKey(SUBSYSTEM_NAME)) {
0:             return instructions.get(SUBSYSTEM_NAME).toString();
1:         }
1:         return project.getName();
1:     }
1:     
1:     private String getSubsystemDescription() {
0:         if (instructions.containsKey(SUBSYSTEM_DESCRIPTION)) {
0:             return instructions.get(SUBSYSTEM_DESCRIPTION).toString();
1:         }
1:         return project.getDescription();
1:     }
1:     
commit:1c02b36
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static final Set<String> SKIP_INSTRUCTIONS = new HashSet<String>();
1: 
1:     static {
0:         SKIP_INSTRUCTIONS.add(SUBSYSTEM_MANIFESTVERSION);
0:         SKIP_INSTRUCTIONS.add(SUBSYSTEM_SYMBOLICNAME);
0:         SKIP_INSTRUCTIONS.add(SUBSYSTEM_VERSION);
0:         SKIP_INSTRUCTIONS.add(SUBSYSTEM_NAME);
0:         SKIP_INSTRUCTIONS.add(SUBSYSTEM_DESCRIPTION);
0:         SKIP_INSTRUCTIONS.add(SUBSYSTEM_CONTENT);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private Map instructions = new LinkedHashMap();
/////////////////////////////////////////////////////////////////////////
1:             Iterator<Map.Entry<?, ?>> instructionIter = instructions.entrySet().iterator();
1:             while(instructionIter.hasNext()) {
1:                 Map.Entry<?, ?> entry = instructionIter.next();
1:                 String header = entry.getKey().toString();
1:                 if (SKIP_INSTRUCTIONS.contains(header)) {
1:                     continue;
1:                 }
1:                 getLog().debug("Adding header: " + header);
1:                 FileUtils.fileAppend(fileName, header + ": " + entry.getValue() + "\n");
/////////////////////////////////////////////////////////////////////////
1: 
author:Graham Charters
-------------------------------------------------------------------------------
commit:edce8a5
/////////////////////////////////////////////////////////////////////////
1:     /*
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Define the start order for content bundles.
1:      *   none - no start orders are added
1:      *   dependencies - start order based on pom dependency order
1:      *
1:      * @parameter expression="${startOrder}" default-value="none"
1:      */
1:     private String startOrder;
/////////////////////////////////////////////////////////////////////////
0:             int order = 1;
1:                 Artifact artifact = iter.next(); 
0:                 String entry = new String(
0:                 		maven2OsgiConverter.getBundleSymbolicName(artifact)
1:                 if ("dependencies".equals(startOrder)) {
0:                 	entry += ";start-order=\"" + order + "\"";                	
1:                 }
1:                 FileUtils.fileAppend(fileName, entry);
1:                 order++;
0:                 String entry = new String(",\n "
1:                 if ("dependencies".equals(startOrder)) {
0:                 	entry += ";start-order=\"" + order + "\"";                	
1:                 }
1:                 FileUtils.fileAppend(fileName, entry);
commit:9b1f38a
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.plugin.esa;
1: 
0: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *  http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: import org.apache.maven.archiver.PomPropertiesUtil;
1: import org.apache.maven.artifact.Artifact;
0: import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
1: import org.apache.maven.plugin.AbstractMojo;
1: import org.apache.maven.plugin.MojoExecutionException;
1: import org.apache.maven.project.MavenProject;
1: import org.codehaus.plexus.archiver.ArchiverException;
1: import org.codehaus.plexus.archiver.zip.ZipArchiver;
1: import org.codehaus.plexus.util.DirectoryScanner;
1: import org.codehaus.plexus.util.FileUtils;
0: import org.apache.maven.shared.osgi.DefaultMaven2OsgiConverter;
0: import org.apache.maven.shared.osgi.Maven2OsgiConverter;
0: import aQute.lib.osgi.Analyzer;
1: import java.io.File;
1: import java.io.IOException;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.LinkedHashSet;
1: import java.util.Map;
1: import java.util.Set;
1: 
1: /**
1:  * Builds OSGi Enterprise Subsystem Archive (esa) files.
1:  *
1:  * @version $Id: $
1:  * @goal esa
1:  * @phase package
1:  * @requiresDependencyResolution test
1:  */
1: public class EsaMojo
1:     extends AbstractMojo
1: {
1: 
0: 	public enum EsaContent {none, all, content};
1:     
0: 	public static final String SUBSYSTEM_MF_URI = "OSGI-INF/SUBSYSTEM.MF";
1: 
1:     private static final String[] DEFAULT_INCLUDES = {"**/**"};
1: 
1:     /**
0:      * Subsystem manifest headers
1:      */
0:     private static final String SUBSYSTEM_MANIFESTVERSION = "Subsystem-ManifestVersion";
0:     private static final String SUBSYSTEM_SYMBOLICNAME = "Subsystem-SymbolicName";
0:     private static final String SUBSYSTEM_VERSION = "Subsystem-Version";
0:     private static final String SUBSYSTEM_NAME = "Subsystem-Name";
0:     private static final String SUBSYSTEM_DESCRIPTION = "Subsystem-Description";
0:     private static final String SUBSYSTEM_CONTENT = "Subsystem-Content";
0:     private static final String SUBSYSTEM_USEBUNDLE = "Use-Bundle";
0:     private static final String SUBSYSTEM_TYPE = "Subsystem-Type";
1:     
1:     /**
0:      * Coverter for maven pom values to OSGi manifest values (pulled in from the maven-bundle-plugin)
1:      */
0:     private Maven2OsgiConverter maven2OsgiConverter = new DefaultMaven2OsgiConverter();
1:     
1:     /**
1:      * Single directory for extra files to include in the esa.
1:      *
1:      * @parameter expression="${basedir}/src/main/esa"
1:      * @required
1:      */
1:     private File esaSourceDirectory;
1: 
1:     /**
1:      * The location of the SUBSYSTEM.MF file to be used within the esa file.
1:      *
1:      * @parameter expression="${basedir}/src/main/esa/OSGI-INF/SUBSYSTEM.MF"
1:      */
1:     private File subsystemManifestFile;
1: 
1: 
1:     /**
1:      * The location of the manifest file to be used within the esa file.
1:      *
1:      * @parameter expression="${basedir}/src/main/esa/META-INF/MANIFEST.MF"
1:      */
1:     private File manifestFile;
1: 
1:     /**
1:      * Directory that resources are copied to during the build.
1:      *
1:      * @parameter expression="${project.build.directory}/${project.build.finalName}"
1:      * @required
1:      */
1:     private String workDirectory;
1: 
1:     /**
1:      * Directory that remote-resources puts legal files.
1:      *
1:      * @parameter expression="${project.build.directory}/maven-shared-archive-resources"
1:      * @required
1:      */
1:     private String sharedResources;
1: 
1:     /**
1:      * The directory for the generated esa.
1:      *
1:      * @parameter expression="${project.build.directory}"
1:      * @required
1:      */
1:     private String outputDirectory;
1: 
1:     /**
1:      * The name of the esa file to generate.
1:      *
1:      * @parameter alias="esaName" expression="${project.build.finalName}"
1:      * @required
1:      */
1:     private String finalName;
1: 
1:     /**
1:      * The maven project.
1:      *
1:      * @parameter expression="${project}"
1:      * @required
1:      * @readonly
1:      */
1:     private MavenProject project;
1: 
1:     /**
1:      * The Jar archiver.
1:      *
1:      * @component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
1:      * @required
1:      */
1:     private ZipArchiver zipArchiver;
1: 
1:     /**
1:      * Whether to generate a manifest based on maven configuration.
1:      *
1:      * @parameter expression="${generateManifest}" default-value="false"
1:      */
1:     private boolean generateManifest;
1: 
1:     /**
1:      * Configuration for the plugin.
1:      *
1:      * @parameter
1:      */
0:     private Map instructions = new LinkedHashMap();;    
1:     
1:     /**
1:      * Adding pom.xml and pom.properties to the archive.
1:      *
1:      * @parameter expression="${addMavenDescriptor}" default-value="true"
1:      */
1:     private boolean addMavenDescriptor;
1: 
1:     /**
1:      * Include or not empty directories
1:      *
1:      * @parameter expression="${includeEmptyDirs}" default-value="true"
1:      */
1:     private boolean includeEmptyDirs;
1: 
1:     /**
1:      * Whether creating the archive should be forced.
1:      *
1:      * @parameter expression="${forceCreation}" default-value="false"
1:      */
1:     private boolean forceCreation;
1: 
1:     /**
1:      * Define which bundles to include in the archive.
1:      *   none - no bundles are included 
1:      *   subsystemContent - direct dependencies go into the content
1:      *   all - direct and transitive dependencies go into the content 
1:      *
1:      * @parameter expression="${archiveContent}" default-value="content"
1:      */
1:     private String archiveContent;
1: 
1: 
1:     private File buildDir;
1: 
1:     /**
1:      * add the dependencies to the archive depending on the configuration of <archiveContent />
1:      */
1:     private void addDependenciesToArchive() throws MojoExecutionException {
1:         try
1:         {
1:             Set<Artifact> artifacts = null;
1:             switch (EsaContent.valueOf(archiveContent)) {
1:             case none:
0:                 getLog().info("archiveContent=none: subsystem arvhive will not contain any bundles.");                  
1:                 break;
1:             case content:
1:                 // only include the direct dependencies in the archive
1:                 artifacts = project.getDependencyArtifacts();                   
1:                 break;
1:             case all:
1:                 // include direct and transitive dependencies in the archive
1:                 artifacts = project.getArtifacts();                 
1:                 break;
1:             default:
1:                 throw new MojoExecutionException("Invalid configuration for <archiveContent/>.  Valid values are none, content and all." );                    
1:             }
1:               
1:             if (artifacts != null) {
1:                 artifacts = selectArtifacts(artifacts);
1:                 for (Artifact artifact : artifacts) {
1: 
1:                     if (!artifact.isOptional() /*&& filter.include(artifact)*/) {
1:                         getLog().info("Copying artifact[" + artifact.getGroupId() + ", " + artifact.getId() + ", " +
1:                                 artifact.getScope() + "]");
1:                         zipArchiver.addFile(artifact.getFile(), artifact.getArtifactId() + "-" + artifact.getVersion() + "." + (artifact.getType() == null ? "jar" : artifact.getType()));
1:                     }
1:                 }               
1:             }
1:         }
1:         catch ( ArchiverException e )
1:         {
1:             throw new MojoExecutionException( "Error copying esa dependencies", e );
1:         }
1: 
1:     }
1:     
1:     /**
1:      * 
1:      * Copies source files to the esa
1:      * 
1:      * @throws MojoExecutionException
1:      */
1:     private void copyEsaSourceFiles() throws MojoExecutionException {
1:         try
1:         {
1:             File esaSourceDir = esaSourceDirectory;
1:             if ( esaSourceDir.exists() )
1:             {
1:                 getLog().info( "Copy esa resources to " + getBuildDir().getAbsolutePath() );
1: 
1:                 DirectoryScanner scanner = new DirectoryScanner();
1:                 scanner.setBasedir( esaSourceDir.getAbsolutePath() );
1:                 scanner.setIncludes( DEFAULT_INCLUDES );
1:                 scanner.addDefaultExcludes();
1:                 scanner.scan();
1: 
1:                 String[] dirs = scanner.getIncludedDirectories();
1: 
1:                 for ( int j = 0; j < dirs.length; j++ )
1:                 {
1:                     new File( getBuildDir(), dirs[j] ).mkdirs();
1:                 }
1: 
1:                 String[] files = scanner.getIncludedFiles();
1: 
1:                 for ( int j = 0; j < files.length; j++ )
1:                 {
1:                     File targetFile = new File( getBuildDir(), files[j] );
1: 
1:                     targetFile.getParentFile().mkdirs();
1: 
1:                     File file = new File( esaSourceDir, files[j] );
1:                     FileUtils.copyFileToDirectory( file, targetFile.getParentFile() );
1:                 }
1:             }
1:         }
1:         catch ( Exception e )
1:         {
1:             throw new MojoExecutionException( "Error copying esa resources", e );
1:         }
1:     }
1:     
1:     private void includeCustomManifest() throws MojoExecutionException {
1:         try
1:         {
1:             if (!generateManifest) {
1:                 includeCustomSubsystemManifestFile();
1:             }
1:         }
1:         catch ( IOException e )
1:         {
1:             throw new MojoExecutionException( "Error copying SUBSYSTEM.MF file", e );
1:         }
1:     }
1:     
1:     private void generateSubsystemManifest() throws MojoExecutionException {
1:         if (generateManifest) {
1:             String fileName = new String(getBuildDir() + "/"
1:                     + SUBSYSTEM_MF_URI);
1:             File appMfFile = new File(fileName);
1: 
1:             try {
1:                 // Delete any old manifest
1:                 if (appMfFile.exists()) {
1:                     FileUtils.fileDelete(fileName);
1:                 }
1: 
1:                 appMfFile.getParentFile().mkdirs();
1:                 if (appMfFile.createNewFile()) {
1:                     writeSubsystemManifest(fileName);
1:                 }
1:             } catch (java.io.IOException e) {
1:                 throw new MojoExecutionException(
1:                         "Error generating SUBSYSTEM.MF file: " + fileName, e);
1:             }
1:         }
1:         
1:         // Check the manifest exists
1:         File ddFile = new File( getBuildDir(), SUBSYSTEM_MF_URI);
1:         if ( !ddFile.exists() )
1:         {
1:             getLog().warn(
1:                 "Subsystem manifest: " + ddFile.getAbsolutePath() + " does not exist." );
1:         }
1: 
1:     }
1:     
1:     private void addMavenDescriptor() throws MojoExecutionException {
1:         try {
1: 
1:             if (addMavenDescriptor) {
1:                 if (project.getArtifact().isSnapshot()) {
1:                     project.setVersion(project.getArtifact().getVersion());
1:                 }
1: 
1:                 String groupId = project.getGroupId();
1: 
1:                 String artifactId = project.getArtifactId();
1: 
1:                 zipArchiver.addFile(project.getFile(), "META-INF/maven/"
1:                         + groupId + "/" + artifactId + "/pom.xml");
1:                 PomPropertiesUtil pomPropertiesUtil = new PomPropertiesUtil();
1:                 File dir = new File(project.getBuild().getDirectory(),
1:                         "maven-zip-plugin");
1:                 File pomPropertiesFile = new File(dir, "pom.properties");
1:                 pomPropertiesUtil.createPomProperties(project, zipArchiver,
1:                         pomPropertiesFile, forceCreation);
1:             }
1:         } catch (Exception e) {
1:             throw new MojoExecutionException("Error assembling esa", e);
1:         }
1:     }
1:     
1:     
1:     private void init() {
1:         getLog().debug( " ======= esaMojo settings =======" );
1:         getLog().debug( "esaSourceDirectory[" + esaSourceDirectory + "]" );
1:         getLog().debug( "manifestFile[" + manifestFile + "]" );
1:         getLog().debug( "subsystemManifestFile[" + subsystemManifestFile + "]" );
1:         getLog().debug( "workDirectory[" + workDirectory + "]" );
1:         getLog().debug( "outputDirectory[" + outputDirectory + "]" );
1:         getLog().debug( "finalName[" + finalName + "]" );
1:         getLog().debug( "generateManifest[" + generateManifest + "]" );
1: 
1:         if (archiveContent == null) {
1:             archiveContent = new String("content");
1:         }
1:         
1:         getLog().debug( "archiveContent[" + archiveContent + "]" );        
1:         getLog().info( "archiveContent[" + archiveContent + "]" );        
1:         
1:         zipArchiver.setIncludeEmptyDirs( includeEmptyDirs );
1:         zipArchiver.setCompress( true );
1:         zipArchiver.setForced( forceCreation );        
1:     }
1:     
1: 
1:     private void writeSubsystemManifest(String fileName)
1:             throws MojoExecutionException {
1:         try {
1:             // TODO: add support for dependency version ranges. Need to pick
1:             // them up from the pom and convert them to OSGi version ranges.
0:             FileUtils.fileAppend(fileName, SUBSYSTEM_MANIFESTVERSION + ": " + "1" + "\n");
0:             FileUtils.fileAppend(fileName, SUBSYSTEM_SYMBOLICNAME + ": "
1:                     + getSubsystemSymbolicName(project.getArtifact()) + "\n");
0:             FileUtils.fileAppend(fileName, SUBSYSTEM_VERSION + ": "
1:                     + getSubsystemVersion() + "\n");
0:             FileUtils.fileAppend(fileName, SUBSYSTEM_NAME + ": " + project.getName() + "\n");
0:             FileUtils.fileAppend(fileName, SUBSYSTEM_DESCRIPTION + ": "
0:                     + project.getDescription() + "\n");
1: 
1:             // Write the SUBSYSTEM-CONTENT
1:             // TODO: check that the dependencies are bundles (currently, the converter
1:             // will throw an exception)
1:             Set<Artifact> artifacts = null;
1:             // only include the direct dependencies in the content
1:             artifacts = project.getDependencyArtifacts();                   
1:             
1:             artifacts = selectArtifacts(artifacts);
1:             Iterator<Artifact> iter = artifacts.iterator();
1: 
0:             FileUtils.fileAppend(fileName, SUBSYSTEM_CONTENT + ": ");
0:             if (iter.hasNext()) {
0:                 Artifact artifact = iter.next();
0:                 FileUtils.fileAppend(fileName, maven2OsgiConverter
0:                         .getBundleSymbolicName(artifact)
0:                         + ";version=\""
0:                         + Analyzer.cleanupVersion(artifact.getVersion())
0: //                      + maven2OsgiConverter.getVersion(artifact.getVersion())
0:                         + "\"");
1:             }
1:             while (iter.hasNext()) {
0:                 Artifact artifact = iter.next();
0:                 FileUtils.fileAppend(fileName, ",\n "
0:                         + maven2OsgiConverter.getBundleSymbolicName(artifact)
0:                         + ";version=\""
0:                         + Analyzer.cleanupVersion(artifact.getVersion())
0: //                      + maven2OsgiConverter.getVersion(artifact.getVersion())
0:                         + "\"");
1:             }
1: 
1:             FileUtils.fileAppend(fileName, "\n");
1: 
0:             // Add any use bundle entry
0:             if (instructions.containsKey(SUBSYSTEM_USEBUNDLE)) {
0:                 FileUtils.fileAppend(fileName, SUBSYSTEM_USEBUNDLE + ": "
0:                         + instructions.get(SUBSYSTEM_USEBUNDLE) + "\n");
1:             }
1: 
0:             // Add any subsystem type
0:             if (instructions.containsKey(SUBSYSTEM_TYPE)) {
0:                 FileUtils.fileAppend(fileName, SUBSYSTEM_TYPE + ": "
0:                         + instructions.get(SUBSYSTEM_TYPE) + "\n");
1:             }
1: 
1:         } catch (Exception e) {
1:             throw new MojoExecutionException(
1:                     "Error writing dependencies into SUBSYSTEM.MF", e);
1:         }
1: 
1:     }
1:     
1:     // The maven2OsgiConverter assumes the artifact is a jar so we need our own
1:     // This uses the same fallback scheme as the converter
1:     private String getSubsystemSymbolicName(Artifact artifact) {
0:         if (instructions.containsKey(SUBSYSTEM_SYMBOLICNAME)) {
0:             return instructions.get(SUBSYSTEM_SYMBOLICNAME).toString();
1:         }
1:         return artifact.getGroupId() + "." + artifact.getArtifactId();
1:     }
1:     
1:     private String getSubsystemVersion() {
0:         if (instructions.containsKey(SUBSYSTEM_VERSION)) {
0:             return instructions.get(SUBSYSTEM_VERSION).toString();
1:         }
1:         return aQute.lib.osgi.Analyzer.cleanupVersion(project.getVersion());
1:     }
1:     
1:     private File getBuildDir() {
1:         if (buildDir == null) {
1:             buildDir = new File(workDirectory);
1:         }
1:         return buildDir;
1:     }
1:     
1:     private void addBuildDir() throws MojoExecutionException {
1:         try {
1:             if (buildDir.isDirectory()) {
1:                 zipArchiver.addDirectory(buildDir);
1:             }
1: 
1:         } catch (Exception e) {
1:             throw new MojoExecutionException(
1:                     "Error writing dependencies into SUBSYSTEM.MF", e);
1:         }
1:     }
1: 
1:     private void includeCustomSubsystemManifestFile()
1:         throws IOException
1:     {
1:         if (subsystemManifestFile == null) {
1:             throw new NullPointerException("Subsystem manifest file location not set.  Use <generateManifest>true</generateManifest> if you want it to be generated.");
1:         }
1:         File appMfFile = subsystemManifestFile;
1:         if (appMfFile.exists()) {
1:             getLog().info( "Using SUBSYSTEM.MF "+ subsystemManifestFile);
1:             File osgiInfDir = new File(getBuildDir(), "OSGI-INF");
1:             FileUtils.copyFileToDirectory( appMfFile, osgiInfDir);
1:         }
1:     }
1:     
1:     /**
1:      * Return artifacts in 'compile' or 'runtime' scope only.   
1:      */
1:     private Set<Artifact> selectArtifacts(Set<Artifact> artifacts) 
1:     {
1:         Set<Artifact> selected = new LinkedHashSet<Artifact>();
1:         for (Artifact artifact : artifacts) {
1:             String scope = artifact.getScope();
1:             if (scope == null 
1:                 || Artifact.SCOPE_COMPILE.equals(scope)
1:                 || Artifact.SCOPE_RUNTIME.equals(scope)) {
1:                 selected.add(artifact);
1:             }
1:         }
1:         return selected;
1:     }
1: 
1:     private void includeSharedResources() throws MojoExecutionException {
1:         try
1:         {
1:             //include legal files if any
1:             File sharedResourcesDir = new File(sharedResources);
1:             if (sharedResourcesDir.isDirectory()) {
1:                 zipArchiver.addDirectory(sharedResourcesDir);
1:             }
1:         }
1:         catch ( Exception e )
1:         {
1:             throw new MojoExecutionException( "Error assembling esa", e );
1:         }
1:     }
1: 
1:     /**
1:      * Creates the final archive.
1:      * 
1:      * @throws MojoExecutionException
1:      */
1:     private void createEsaFile() throws MojoExecutionException {
1:         try
1:         {
1:             File esaFile = new File( outputDirectory, finalName + ".esa" );
1:             zipArchiver.setDestFile(esaFile);
1: 
1: 
1:             zipArchiver.createArchive();
1: 
1:             project.getArtifact().setFile( esaFile );
1:         }
1:         catch ( Exception e )
1:         {
1:             throw new MojoExecutionException( "Error assembling esa", e );
1:         }
1: 
1:     }
1:     
1:     public void execute()
1:         throws MojoExecutionException
1:     {
1:         init();
1: 
1:         addDependenciesToArchive();
1:         
1:         copyEsaSourceFiles();
1: 
1:         includeCustomManifest();
1:         
1:         generateSubsystemManifest();
1: 
1:         addMavenDescriptor();
1:         
1:         addBuildDir();
1:         
1:         includeSharedResources();
1:         
1:         createEsaFile();
1:     }
1: }
============================================================================