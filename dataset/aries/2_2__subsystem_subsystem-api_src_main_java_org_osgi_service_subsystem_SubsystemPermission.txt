1:1c9c28b: /*
1:d6eb080:  * Copyright (c) OSGi Alliance (2000, 2013). All Rights Reserved.
29:1c9c28b:  *
1:1c9c28b:  * Licensed under the Apache License, Version 2.0 (the "License");
1:1c9c28b:  * you may not use this file except in compliance with the License.
1:1c9c28b:  * You may obtain a copy of the License at
1:1c9c28b:  *
1:1c9c28b:  *      http://www.apache.org/licenses/LICENSE-2.0
1:1c9c28b:  *
1:1c9c28b:  * Unless required by applicable law or agreed to in writing, software
1:1c9c28b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1c9c28b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1c9c28b:  * See the License for the specific language governing permissions and
1:1c9c28b:  * limitations under the License.
1:1c9c28b:  */
7:1c9c28b: 
1:1c9c28b: package org.osgi.service.subsystem;
1:1c9c28b: 
1:1c9c28b: import java.io.IOException;
1:1c9c28b: import java.io.NotSerializableException;
1:1c9c28b: import java.io.ObjectInputStream;
1:1c9c28b: import java.io.ObjectOutputStream;
1:1c9c28b: import java.io.ObjectStreamField;
1:1c9c28b: import java.security.AccessController;
1:1c9c28b: import java.security.BasicPermission;
1:1c9c28b: import java.security.Permission;
1:1c9c28b: import java.security.PermissionCollection;
1:1c9c28b: import java.security.PrivilegedAction;
1:1c9c28b: import java.util.ArrayList;
1:1c9c28b: import java.util.Collection;
1:1c9c28b: import java.util.Collections;
1:1c9c28b: import java.util.Enumeration;
1:1c9c28b: import java.util.HashMap;
1:1c9c28b: import java.util.List;
1:1c9c28b: import java.util.Map;
1:1c9c28b: import org.osgi.framework.Filter;
1:1c9c28b: import org.osgi.framework.FrameworkUtil;
1:1c9c28b: import org.osgi.framework.InvalidSyntaxException;
1:1c9c28b: 
1:1c9c28b: /**
1:1c9c28b:  * A bundle's authority to perform specific privileged administrative operations
1:1c9c28b:  * on or to get sensitive information about a subsystem. The actions for this
1:1c9c28b:  * permission are:
1:452554c:  * 
1:1c9c28b:  * <pre>
1:452554c:  * Action    Methods
1:452554c:  * context   Subsystem.getBundleContext
1:452554c:  * execute   Subsystem.start
1:452554c:  *           Subsystem.stop
1:452554c:  * lifecycle Subsystem.install
1:452554c:  *           Subsystem.uninstall
1:d6eb080:  * metadata  Subsystem.getSubsystemHeaders
1:452554c:  *           Subsystem.getLocation
1:1c9c28b:  * </pre>
1:452554c:  * 
1:1c9c28b:  * <p>
1:1c9c28b:  * The name of this permission is a filter expression. The filter gives access
1:1c9c28b:  * to the following attributes:
1:1c9c28b:  * <ul>
1:1c9c28b:  * <li>location - The location of a subsystem.</li>
1:1c9c28b:  * <li>id - The subsystem ID of the designated subsystem.</li>
1:1c9c28b:  * <li>name - The symbolic name of a subsystem.</li>
1:1c9c28b:  * </ul>
1:1c9c28b:  * Filter attribute names are processed in a case sensitive manner.
1:452554c:  * 
1:1c9c28b:  * @ThreadSafe
1:d6eb080:  * @author $Id: 5c71d73cc6a3e8b2c2a7a3f188ebcf79b5ef7888 $
1:1c9c28b:  */
1:1c9c28b: 
1:1c9c28b: public final class SubsystemPermission extends BasicPermission {
1:452554c: 	static final long								serialVersionUID	= 307051004521261705L;
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * The action string {@code execute}.
1:1c9c28b: 	 */
1:452554c: 	public final static String						EXECUTE				= "execute";
1:1c9c28b: 	/**
1:1c9c28b: 	 * The action string {@code lifecycle}.
1:1c9c28b: 	 */
1:452554c: 	public final static String						LIFECYCLE			= "lifecycle";
1:1c9c28b: 	/**
1:1c9c28b: 	 * The action string {@code metadata}.
1:1c9c28b: 	 */
1:452554c: 	public final static String						METADATA			= "metadata";
1:1c9c28b: 	/**
1:1c9c28b: 	 * The action string {@code context}.
1:1c9c28b: 	 */
1:452554c: 	public final static String						CONTEXT				= "context";
1:1c9c28b: 
1:452554c: 	private final static int						ACTION_EXECUTE		= 0x00000001;
1:452554c: 	private final static int						ACTION_LIFECYCLE	= 0x00000002;
1:452554c: 	private final static int						ACTION_METADATA		= 0x00000004;
1:452554c: 	private final static int						ACTION_CONTEXT		= 0x00000008;
1:452554c: 	private final static int						ACTION_ALL			= ACTION_EXECUTE | ACTION_LIFECYCLE | ACTION_METADATA | ACTION_CONTEXT;
1:452554c: 	final static int								ACTION_NONE			= 0;
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * The actions in canonical form.
1:452554c: 	 * 
1:1c9c28b: 	 * @serial
1:1c9c28b: 	 */
1:452554c: 	private volatile String							actions				= null;
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * The actions mask.
1:1c9c28b: 	 */
1:452554c: 	transient int									action_mask;
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * If this SubsystemPermission was constructed with a filter, this holds a
1:1c9c28b: 	 * Filter matching object used to evaluate the filter in implies.
1:1c9c28b: 	 */
1:452554c: 	transient Filter								filter;
1:1c9c28b: 
1:1c9c28b: 	/**
1:452554c: 	 * The subsystem governed by this SubsystemPermission - only used if filter
1:452554c: 	 * == null
1:1c9c28b: 	 */
1:452554c: 	transient final Subsystem						subsystem;
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * This map holds the properties of the permission, used to match a filter
1:1c9c28b: 	 * in implies. This is not initialized until necessary, and then cached in
1:1c9c28b: 	 * this object.
1:1c9c28b: 	 */
1:1c9c28b: 	private transient volatile Map<String, Object>	properties;
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * ThreadLocal used to determine if we have recursively called
1:1c9c28b: 	 * getProperties.
1:1c9c28b: 	 */
1:452554c: 	private static final ThreadLocal<Subsystem>		recurse				= new ThreadLocal<Subsystem>();
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Create a new SubsystemPermission.
1:452554c: 	 * 
1:1c9c28b: 	 * This constructor must only be used to create a permission that is going
1:1c9c28b: 	 * to be checked.
1:1c9c28b: 	 * <p>
1:1c9c28b: 	 * Examples:
1:452554c: 	 * 
1:1c9c28b: 	 * <pre>
1:1c9c28b: 	 * (name=com.acme.*)(location=http://www.acme.com/subsystems/*))
1:1c9c28b: 	 * (id&gt;=1)
1:1c9c28b: 	 * </pre>
1:452554c: 	 * 
1:1c9c28b: 	 * @param filter A filter expression that can use, location, id, and name
1:1c9c28b: 	 *        keys. Filter attribute names are processed in a case sensitive
1:1c9c28b: 	 *        manner. A special value of {@code "*"} can be used to match all
1:1c9c28b: 	 *        subsystems.
1:1c9c28b: 	 * @param actions {@code execute}, {@code lifecycle}, {@code metadata}, or
1:1c9c28b: 	 *        {@code context}.
1:1c9c28b: 	 * @throws IllegalArgumentException If the filter has an invalid syntax.
1:1c9c28b: 	 */
1:1c9c28b: 	public SubsystemPermission(String filter, String actions) {
1:1c9c28b: 		this(parseFilter(filter), parseActions(actions));
8:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:452554c: 	 * Creates a new requested {@code SubsystemPermission} object to be used by
1:452554c: 	 * the code that must perform {@code checkPermission}.
1:452554c: 	 * {@code SubsystemPermission} objects created with this constructor cannot
1:452554c: 	 * be added to an {@code SubsystemPermission} permission collection.
1:452554c: 	 * 
1:1c9c28b: 	 * @param subsystem A subsystem.
1:1c9c28b: 	 * @param actions {@code execute}, {@code lifecycle}, {@code metadata}, or
1:1c9c28b: 	 *        {@code context}.
1:1c9c28b: 	 */
1:1c9c28b: 	public SubsystemPermission(Subsystem subsystem, String actions) {
1:1c9c28b: 		super(createName(subsystem));
1:1c9c28b: 		setTransients(null, parseActions(actions));
1:1c9c28b: 		this.subsystem = subsystem;
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Create a permission name from a Subsystem
1:452554c: 	 * 
1:1c9c28b: 	 * @param subsystem Subsystem to use to create permission name.
1:1c9c28b: 	 * @return permission name.
1:1c9c28b: 	 */
1:1c9c28b: 	private static String createName(Subsystem subsystem) {
1:1c9c28b: 		if (subsystem == null) {
1:1c9c28b: 			throw new IllegalArgumentException("subsystem must not be null");
1:1c9c28b: 		}
1:1c9c28b: 		StringBuffer sb = new StringBuffer("(id=");
1:1c9c28b: 		sb.append(subsystem.getSubsystemId());
1:1c9c28b: 		sb.append(")");
1:1c9c28b: 		return sb.toString();
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Package private constructor used by SubsystemPermissionCollection.
1:452554c: 	 * 
1:1c9c28b: 	 * @param filter name filter or {@code null} for wildcard.
1:1c9c28b: 	 * @param mask action mask
1:1c9c28b: 	 */
1:1c9c28b: 	SubsystemPermission(Filter filter, int mask) {
1:1c9c28b: 		super((filter == null) ? "*" : filter.toString());
1:1c9c28b: 		setTransients(filter, mask);
1:1c9c28b: 		this.subsystem = null;
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Called by constructors and when deserialized.
1:452554c: 	 * 
1:1c9c28b: 	 * @param filter Permission's filter or {@code null} for wildcard.
1:1c9c28b: 	 * @param mask action mask
1:1c9c28b: 	 */
1:1c9c28b: 	private void setTransients(Filter filter, int mask) {
1:1c9c28b: 		this.filter = filter;
1:1c9c28b: 		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {
1:1c9c28b: 			throw new IllegalArgumentException("invalid action string");
1:1c9c28b: 		}
1:1c9c28b: 		this.action_mask = mask;
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Parse action string into action mask.
1:452554c: 	 * 
1:1c9c28b: 	 * @param actions Action string.
1:1c9c28b: 	 * @return action mask.
1:1c9c28b: 	 */
1:1c9c28b: 	private static int parseActions(String actions) {
1:1c9c28b: 		boolean seencomma = false;
1:1c9c28b: 
1:1c9c28b: 		int mask = ACTION_NONE;
1:1c9c28b: 
1:1c9c28b: 		if (actions == null) {
1:1c9c28b: 			return mask;
1:1c9c28b: 		}
1:1c9c28b: 
1:1c9c28b: 		char[] a = actions.toCharArray();
1:1c9c28b: 
1:1c9c28b: 		int i = a.length - 1;
1:1c9c28b: 		if (i < 0)
1:1c9c28b: 			return mask;
1:1c9c28b: 
1:1c9c28b: 		while (i != -1) {
1:1c9c28b: 			char c;
1:1c9c28b: 
1:1c9c28b: 			// skip whitespace
1:452554c: 			while ((i != -1) && ((c = a[i]) == ' ' || c == '\r' || c == '\n' || c == '\f' || c == '\t'))
1:1c9c28b: 				i--;
1:1c9c28b: 
1:1c9c28b: 			// check for the known strings
1:1c9c28b: 			int matchlen;
1:1c9c28b: 
1:452554c: 			if (i >= 6 && (a[i - 6] == 'e' || a[i - 6] == 'E')
1:452554c: 					&& (a[i - 5] == 'x' || a[i - 5] == 'X')
1:452554c: 					&& (a[i - 4] == 'e' || a[i - 4] == 'E')
1:452554c: 					&& (a[i - 3] == 'c' || a[i - 3] == 'C')
1:452554c: 					&& (a[i - 2] == 'u' || a[i - 2] == 'U')
1:452554c: 					&& (a[i - 1] == 't' || a[i - 1] == 'T')
1:452554c: 					&& (a[i] == 'e' || a[i] == 'E')) {
1:452554c: 				matchlen = 7;
1:452554c: 				mask |= ACTION_EXECUTE;
1:452554c: 			} else
1:452554c: 				if (i >= 8 && (a[i - 8] == 'l' || a[i - 8] == 'L')
1:452554c: 						&& (a[i - 7] == 'i' || a[i - 7] == 'I')
1:452554c: 						&& (a[i - 6] == 'f' || a[i - 6] == 'F')
1:452554c: 						&& (a[i - 5] == 'e' || a[i - 5] == 'E')
1:452554c: 						&& (a[i - 4] == 'c' || a[i - 4] == 'C')
1:452554c: 						&& (a[i - 3] == 'y' || a[i - 3] == 'Y')
1:452554c: 						&& (a[i - 2] == 'c' || a[i - 2] == 'C')
1:452554c: 						&& (a[i - 1] == 'l' || a[i - 1] == 'L')
2:1c9c28b: 						&& (a[i] == 'e' || a[i] == 'E')) {
1:452554c: 					matchlen = 9;
1:452554c: 					mask |= ACTION_LIFECYCLE;
1:452554c: 				} else
1:452554c: 					if (i >= 7
1:452554c: 							&& (a[i - 7] == 'm' || a[i - 7] == 'M')
1:452554c: 							&& (a[i - 6] == 'e' || a[i - 6] == 'E')
1:452554c: 							&& (a[i - 5] == 't' || a[i - 5] == 'T')
1:452554c: 							&& (a[i - 4] == 'a' || a[i - 4] == 'A')
1:452554c: 							&& (a[i - 3] == 'd' || a[i - 3] == 'D')
1:452554c: 							&& (a[i - 2] == 'a' || a[i - 2] == 'A')
1:452554c: 							&& (a[i - 1] == 't' || a[i - 1] == 'T')
1:452554c: 							&& (a[i] == 'a' || a[i] == 'A')) {
1:452554c: 						matchlen = 8;
1:452554c: 						mask |= ACTION_METADATA;
1:452554c: 					} else
1:452554c: 						if (i >= 6
1:452554c: 								&& (a[i - 6] == 'c' || a[i - 6] == 'C')
1:452554c: 								&& (a[i - 5] == 'o' || a[i - 5] == 'O')
1:452554c: 								&& (a[i - 4] == 'n' || a[i - 4] == 'N')
1:452554c: 								&& (a[i - 3] == 't' || a[i - 3] == 'T')
1:452554c: 								&& (a[i - 2] == 'e' || a[i - 2] == 'E')
1:452554c: 								&& (a[i - 1] == 'x' || a[i - 1] == 'X')
1:452554c: 								&& (a[i] == 't' || a[i] == 'T')) {
1:452554c: 							matchlen = 7;
1:452554c: 							mask |= ACTION_CONTEXT;
1:452554c: 						} else {
1:1c9c28b: 							// parse error
1:452554c: 							throw new IllegalArgumentException("invalid permission: " + actions);
1:1c9c28b: 						}
1:1c9c28b: 
1:1c9c28b: 			// make sure we didn't just match the tail of a word
1:452554c: 			// like "ackbarfexecute". Also, skip to the comma.
1:1c9c28b: 			seencomma = false;
1:1c9c28b: 			while (i >= matchlen && !seencomma) {
1:1c9c28b: 				switch (a[i - matchlen]) {
1:1c9c28b: 					case ',' :
1:1c9c28b: 						seencomma = true;
1:1c9c28b: 						/* FALLTHROUGH */
1:1c9c28b: 					case ' ' :
1:1c9c28b: 					case '\r' :
1:1c9c28b: 					case '\n' :
1:1c9c28b: 					case '\f' :
1:1c9c28b: 					case '\t' :
1:1c9c28b: 						break;
1:1c9c28b: 					default :
1:452554c: 						throw new IllegalArgumentException("invalid permission: " + actions);
1:1c9c28b: 				}
1:1c9c28b: 				i--;
1:1c9c28b: 			}
1:1c9c28b: 
1:1c9c28b: 			// point i at the location of the comma minus one (or -1).
1:1c9c28b: 			i -= matchlen;
1:1c9c28b: 		}
1:1c9c28b: 
1:1c9c28b: 		if (seencomma) {
1:452554c: 			throw new IllegalArgumentException("invalid permission: " + actions);
1:1c9c28b: 		}
1:1c9c28b: 
1:1c9c28b: 		return mask;
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Parse filter string into a Filter object.
1:1c9c28b: 	 * 
1:1c9c28b: 	 * @param filterString The filter string to parse.
1:1c9c28b: 	 * @return a Filter for this subsystem. If the specified filterString equals
1:1c9c28b: 	 *         "*", then {@code null} is returned to indicate a wildcard.
1:1c9c28b: 	 * @throws IllegalArgumentException If the filter syntax is invalid.
1:1c9c28b: 	 */
1:1c9c28b: 	private static Filter parseFilter(String filterString) {
1:1c9c28b: 		filterString = filterString.trim();
1:1c9c28b: 		if (filterString.equals("*")) {
1:1c9c28b: 			return null;
1:1c9c28b: 		}
1:1c9c28b: 
1:1c9c28b: 		try {
1:1c9c28b: 			return FrameworkUtil.createFilter(filterString);
1:452554c: 		} catch (InvalidSyntaxException e) {
1:452554c: 			IllegalArgumentException iae = new IllegalArgumentException("invalid filter");
1:1c9c28b: 			iae.initCause(e);
1:1c9c28b: 			throw iae;
1:1c9c28b: 		}
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Determines if the specified permission is implied by this object. This
1:1c9c28b: 	 * method throws an exception if the specified permission was not
1:1c9c28b: 	 * constructed with a subsystem.
1:452554c: 	 * 
1:1c9c28b: 	 * <p>
1:1c9c28b: 	 * This method returns {@code true} if the specified permission is a
1:1c9c28b: 	 * SubsystemPermission AND
1:1c9c28b: 	 * <ul>
1:1c9c28b: 	 * <li>this object's filter matches the specified permission's subsystem ID,
1:1c9c28b: 	 * subsystem symbolic name, and subsystem location OR</li>
1:1c9c28b: 	 * <li>this object's filter is "*"</li>
1:1c9c28b: 	 * </ul>
1:1c9c28b: 	 * AND this object's actions include all of the specified permission's
1:1c9c28b: 	 * actions.
1:1c9c28b: 	 * <p>
1:1c9c28b: 	 * Special case: if the specified permission was constructed with "*"
1:452554c: 	 * filter, then this method returns {@code true} if this object's filter is
1:452554c: 	 * "*" and this object's actions include all of the specified permission's
1:452554c: 	 * actions
1:452554c: 	 * 
1:1c9c28b: 	 * @param p The requested permission.
1:1c9c28b: 	 * @return {@code true} if the specified permission is implied by this
1:1c9c28b: 	 *         object; {@code false} otherwise.
1:1c9c28b: 	 */
1:d6eb080: 	@Override
1:1c9c28b: 	public boolean implies(Permission p) {
1:1c9c28b: 		if (!(p instanceof SubsystemPermission)) {
1:1c9c28b: 			return false;
1:1c9c28b: 		}
1:1c9c28b: 		SubsystemPermission requested = (SubsystemPermission) p;
1:1c9c28b: 		if (subsystem != null) {
1:1c9c28b: 			return false;
1:1c9c28b: 		}
1:1c9c28b: 		// if requested permission has a filter, then it is an invalid argument
1:1c9c28b: 		if (requested.filter != null) {
1:1c9c28b: 			return false;
1:1c9c28b: 		}
1:1c9c28b: 		return implies0(requested, ACTION_NONE);
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Internal implies method. Used by the implies and the permission
1:1c9c28b: 	 * collection implies methods.
1:452554c: 	 * 
1:1c9c28b: 	 * @param requested The requested SubsystemPermision which has already been
1:452554c: 	 *        validated as a proper argument. The requested SubsystemPermission
1:452554c: 	 *        must not have a filter expression.
1:1c9c28b: 	 * @param effective The effective actions with which to start.
1:1c9c28b: 	 * @return {@code true} if the specified permission is implied by this
1:1c9c28b: 	 *         object; {@code false} otherwise.
1:1c9c28b: 	 */
1:1c9c28b: 	boolean implies0(SubsystemPermission requested, int effective) {
1:1c9c28b: 		/* check actions first - much faster */
1:1c9c28b: 		effective |= action_mask;
1:1c9c28b: 		final int desired = requested.action_mask;
1:1c9c28b: 		if ((effective & desired) != desired) {
1:1c9c28b: 			return false;
1:1c9c28b: 		}
1:1c9c28b: 
1:1c9c28b: 		/* Get our filter */
1:1c9c28b: 		Filter f = filter;
1:1c9c28b: 		if (f == null) {
1:1c9c28b: 			// it's "*"
1:1c9c28b: 			return true;
1:1c9c28b: 		}
1:1c9c28b: 		/* is requested a wildcard filter? */
1:1c9c28b: 		if (requested.subsystem == null) {
1:1c9c28b: 			return false;
1:1c9c28b: 		}
1:452554c: 		Map<String, Object> requestedProperties = requested.getProperties();
1:1c9c28b: 		if (requestedProperties == null) {
1:1c9c28b: 			/*
1:1c9c28b: 			 * If the requested properties are null, then we have detected a
1:1c9c28b: 			 * recursion getting the subsystem location. So we return true to
1:452554c: 			 * permit the subsystem location request in the SubsystemPermission
1:452554c: 			 * check up the stack to succeed.
1:1c9c28b: 			 */
1:1c9c28b: 			return true;
1:1c9c28b: 		}
1:1c9c28b: 		return f.matches(requestedProperties);
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Returns the canonical string representation of the
1:1c9c28b: 	 * {@code SubsystemPermission} actions.
1:452554c: 	 * 
1:1c9c28b: 	 * <p>
1:452554c: 	 * Always returns present {@code SubsystemPermission} actions in the
1:452554c: 	 * following order: {@code execute}, {@code lifecycle}, {@code metadata},
1:1c9c28b: 	 * {@code context}.
1:452554c: 	 * 
1:452554c: 	 * @return Canonical string representation of the
1:452554c: 	 *         {@code SubsystemPermission} actions.
1:1c9c28b: 	 */
1:d6eb080: 	@Override
1:1c9c28b: 	public String getActions() {
1:1c9c28b: 		String result = actions;
1:1c9c28b: 		if (result == null) {
1:1c9c28b: 			StringBuffer sb = new StringBuffer();
1:1c9c28b: 
1:1c9c28b: 			int mask = action_mask;
1:1c9c28b: 
1:1c9c28b: 			if ((mask & ACTION_EXECUTE) == ACTION_EXECUTE) {
1:1c9c28b: 				sb.append(EXECUTE);
1:1c9c28b: 				sb.append(',');
1:1c9c28b: 			}
1:1c9c28b: 
1:1c9c28b: 			if ((mask & ACTION_LIFECYCLE) == ACTION_LIFECYCLE) {
1:1c9c28b: 				sb.append(LIFECYCLE);
1:1c9c28b: 				sb.append(',');
1:1c9c28b: 			}
1:1c9c28b: 
1:1c9c28b: 			if ((mask & ACTION_METADATA) == ACTION_METADATA) {
1:1c9c28b: 				sb.append(METADATA);
1:1c9c28b: 				sb.append(',');
1:1c9c28b: 			}
1:1c9c28b: 
1:1c9c28b: 			if ((mask & ACTION_CONTEXT) == ACTION_CONTEXT) {
1:1c9c28b: 				sb.append(CONTEXT);
1:1c9c28b: 				sb.append(',');
1:1c9c28b: 			}
1:1c9c28b: 
1:1c9c28b: 			// remove trailing comma
1:1c9c28b: 			if (sb.length() > 0) {
1:1c9c28b: 				sb.setLength(sb.length() - 1);
1:1c9c28b: 			}
1:1c9c28b: 
1:1c9c28b: 			actions = result = sb.toString();
1:1c9c28b: 		}
1:1c9c28b: 		return result;
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:452554c: 	 * Returns a new {@code PermissionCollection} object suitable for storing
1:452554c: 	 * {@code SubsystemPermission}s.
1:452554c: 	 * 
1:1c9c28b: 	 * @return A new {@code PermissionCollection} object.
1:1c9c28b: 	 */
1:d6eb080: 	@Override
1:1c9c28b: 	public PermissionCollection newPermissionCollection() {
1:1c9c28b: 		return new SubsystemPermissionCollection();
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Determines the equality of two {@code SubsystemPermission} objects.
1:452554c: 	 * 
1:1c9c28b: 	 * @param obj The object being compared for equality with this object.
1:1c9c28b: 	 * @return {@code true} if {@code obj} is equivalent to this
1:1c9c28b: 	 *         {@code SubsystemPermission}; {@code false} otherwise.
1:1c9c28b: 	 */
1:d6eb080: 	@Override
1:1c9c28b: 	public boolean equals(Object obj) {
1:1c9c28b: 		if (obj == this) {
1:1c9c28b: 			return true;
1:1c9c28b: 		}
1:1c9c28b: 
1:1c9c28b: 		if (!(obj instanceof SubsystemPermission)) {
1:1c9c28b: 			return false;
1:1c9c28b: 		}
1:1c9c28b: 
1:1c9c28b: 		SubsystemPermission sp = (SubsystemPermission) obj;
1:1c9c28b: 
1:452554c: 		return (action_mask == sp.action_mask) && ((subsystem == sp.subsystem) || ((subsystem != null) && subsystem.equals(sp.subsystem)))
1:452554c: 				&& (filter == null ? sp.filter == null : filter.equals(sp.filter));
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Returns the hash code value for this object.
1:452554c: 	 * 
1:1c9c28b: 	 * @return Hash code value for this object.
1:1c9c28b: 	 */
1:d6eb080: 	@Override
1:1c9c28b: 	public int hashCode() {
1:1c9c28b: 		int h = 31 * 17 + getName().hashCode();
1:1c9c28b: 		h = 31 * h + getActions().hashCode();
1:1c9c28b: 		if (subsystem != null) {
1:1c9c28b: 			h = 31 * h + subsystem.hashCode();
1:1c9c28b: 		}
1:1c9c28b: 		return h;
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * WriteObject is called to save the state of this permission object to a
1:1c9c28b: 	 * stream. The actions are serialized, and the superclass takes care of the
1:1c9c28b: 	 * name.
1:1c9c28b: 	 */
1:452554c: 	private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException {
1:1c9c28b: 		if (subsystem != null) {
1:1c9c28b: 			throw new NotSerializableException("cannot serialize");
1:1c9c28b: 		}
1:1c9c28b: 		// Write out the actions. The superclass takes care of the name
1:1c9c28b: 		// call getActions to make sure actions field is initialized
1:1c9c28b: 		if (actions == null)
1:1c9c28b: 			getActions();
1:1c9c28b: 		s.defaultWriteObject();
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * readObject is called to restore the state of this permission from a
1:1c9c28b: 	 * stream.
1:1c9c28b: 	 */
1:452554c: 	private synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
1:1c9c28b: 		// Read in the data, then initialize the transients
1:1c9c28b: 		s.defaultReadObject();
1:1c9c28b: 		setTransients(parseFilter(getName()), parseActions(actions));
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:452554c: 	 * Called by {@code implies0} on an SubsystemPermission which was
1:452554c: 	 * constructed with a Subsystem. This method loads a map with the
1:452554c: 	 * filter-matchable properties of this subsystem. The map is cached so this
1:452554c: 	 * lookup only happens once.
1:452554c: 	 * 
1:1c9c28b: 	 * This method should only be called on an SubsystemPermission which was
1:1c9c28b: 	 * constructed with a subsystem
1:452554c: 	 * 
1:1c9c28b: 	 * @return a map of properties for this subsystem
1:1c9c28b: 	 */
1:1c9c28b: 	private Map<String, Object> getProperties() {
1:1c9c28b: 		Map<String, Object> result = properties;
1:1c9c28b: 		if (result != null) {
1:1c9c28b: 			return result;
1:1c9c28b: 		}
1:1c9c28b: 		/*
1:452554c: 		 * We may have recursed here due to the Subsystem.getLocation call in
1:452554c: 		 * the doPrivileged below. If this is the case, return null to allow
1:452554c: 		 * implies to return true.
1:1c9c28b: 		 */
1:1c9c28b: 		final Object mark = recurse.get();
1:1c9c28b: 		if (mark == subsystem) {
1:1c9c28b: 			return null;
1:1c9c28b: 		}
1:1c9c28b: 		recurse.set(subsystem);
1:1c9c28b: 		try {
1:1c9c28b: 			final Map<String, Object> map = new HashMap<String, Object>(4);
1:d6eb080: 			AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:d6eb080: 				public Void run() {
1:1c9c28b: 					map.put("id", new Long(subsystem.getSubsystemId()));
1:1c9c28b: 					map.put("location", subsystem.getLocation());
1:1c9c28b: 					map.put("name", subsystem.getSymbolicName());
1:1c9c28b: 					return null;
1:1c9c28b: 				}
1:1c9c28b: 			});
1:1c9c28b: 			return properties = map;
1:452554c: 		} finally {
1:1c9c28b: 			recurse.set(null);
1:1c9c28b: 		}
1:1c9c28b: 	}
1:1c9c28b: }
1:1c9c28b: 
1:1c9c28b: /**
1:1c9c28b:  * Stores a collection of {@code SubsystemPermission}s.
1:1c9c28b:  */
1:1c9c28b: final class SubsystemPermissionCollection extends PermissionCollection {
1:452554c: 	private static final long							serialVersionUID	= 3906372644575328048L;
1:1c9c28b: 	/**
1:1c9c28b: 	 * Collection of permissions.
1:452554c: 	 * 
1:1c9c28b: 	 * @GuardedBy this
1:1c9c28b: 	 */
1:1c9c28b: 	private transient Map<String, SubsystemPermission>	permissions;
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Boolean saying if "*" is in the collection.
1:452554c: 	 * 
1:1c9c28b: 	 * @serial
1:1c9c28b: 	 * @GuardedBy this
1:1c9c28b: 	 */
1:452554c: 	private boolean										all_allowed;
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Create an empty SubsystemPermissionCollection object.
1:452554c: 	 * 
1:1c9c28b: 	 */
1:1c9c28b: 	public SubsystemPermissionCollection() {
1:1c9c28b: 		permissions = new HashMap<String, SubsystemPermission>();
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Adds a permission to this permission collection.
1:452554c: 	 * 
1:1c9c28b: 	 * @param permission The {@code SubsystemPermission} object to add.
1:1c9c28b: 	 * @throws IllegalArgumentException If the specified permission is not an
1:1c9c28b: 	 *         {@code SubsystemPermission} instance or was constructed with a
1:1c9c28b: 	 *         Subsystem object.
1:1c9c28b: 	 * @throws SecurityException If this {@code SubsystemPermissionCollection}
1:1c9c28b: 	 *         object has been marked read-only.
1:1c9c28b: 	 */
1:d6eb080: 	@Override
1:1c9c28b: 	public void add(Permission permission) {
1:1c9c28b: 		if (!(permission instanceof SubsystemPermission)) {
1:452554c: 			throw new IllegalArgumentException("invalid permission: " + permission);
1:1c9c28b: 		}
1:1c9c28b: 		if (isReadOnly()) {
1:452554c: 			throw new SecurityException("attempt to add a Permission to a " + "readonly PermissionCollection");
1:1c9c28b: 		}
1:1c9c28b: 		final SubsystemPermission sp = (SubsystemPermission) permission;
1:1c9c28b: 		if (sp.subsystem != null) {
1:452554c: 			throw new IllegalArgumentException("cannot add to collection: " + sp);
1:1c9c28b: 		}
1:1c9c28b: 		final String name = sp.getName();
1:1c9c28b: 		synchronized (this) {
1:1c9c28b: 			Map<String, SubsystemPermission> pc = permissions;
1:1c9c28b: 			SubsystemPermission existing = pc.get(name);
1:1c9c28b: 			if (existing != null) {
1:1c9c28b: 				int oldMask = existing.action_mask;
1:1c9c28b: 				int newMask = sp.action_mask;
1:1c9c28b: 
1:1c9c28b: 				if (oldMask != newMask) {
1:452554c: 					pc.put(name, new SubsystemPermission(existing.filter, oldMask | newMask));
1:1c9c28b: 				}
1:452554c: 			} else {
1:1c9c28b: 				pc.put(name, sp);
1:1c9c28b: 			}
1:1c9c28b: 			if (!all_allowed) {
1:1c9c28b: 				if (name.equals("*")) {
1:1c9c28b: 					all_allowed = true;
1:1c9c28b: 				}
1:1c9c28b: 			}
1:1c9c28b: 		}
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Determines if the specified permissions implies the permissions expressed
1:1c9c28b: 	 * in {@code permission}.
1:452554c: 	 * 
1:1c9c28b: 	 * @param permission The Permission object to compare with the
1:1c9c28b: 	 *        {@code SubsystemPermission} objects in this collection.
1:1c9c28b: 	 * @return {@code true} if {@code permission} is implied by an
1:452554c: 	 *         {@code SubsystemPermission} in this collection, {@code false}
1:452554c: 	 *         otherwise.
1:1c9c28b: 	 */
1:d6eb080: 	@Override
1:1c9c28b: 	public boolean implies(Permission permission) {
1:1c9c28b: 		if (!(permission instanceof SubsystemPermission)) {
1:1c9c28b: 			return false;
1:1c9c28b: 		}
1:1c9c28b: 
1:1c9c28b: 		SubsystemPermission requested = (SubsystemPermission) permission;
1:1c9c28b: 		// if requested permission has a filter, then it is an invalid argument
1:1c9c28b: 		if (requested.filter != null) {
1:1c9c28b: 			return false;
1:1c9c28b: 		}
1:1c9c28b: 		int effective = SubsystemPermission.ACTION_NONE;
1:1c9c28b: 		Collection<SubsystemPermission> perms;
1:1c9c28b: 		synchronized (this) {
1:1c9c28b: 			Map<String, SubsystemPermission> pc = permissions;
1:1c9c28b: 			// short circuit if the "*" Permission was added
1:1c9c28b: 			if (all_allowed) {
1:1c9c28b: 				SubsystemPermission sp = pc.get("*");
1:1c9c28b: 				if (sp != null) {
1:1c9c28b: 					effective |= sp.action_mask;
1:1c9c28b: 					final int desired = requested.action_mask;
1:1c9c28b: 					if ((effective & desired) == desired) {
1:1c9c28b: 						return true;
1:1c9c28b: 					}
1:1c9c28b: 				}
1:1c9c28b: 			}
1:1c9c28b: 			perms = pc.values();
1:1c9c28b: 		}
1:1c9c28b: 
1:1c9c28b: 		// just iterate one by one
1:1c9c28b: 		for (SubsystemPermission perm : perms) {
1:1c9c28b: 			if (perm.implies0(requested, effective)) {
1:1c9c28b: 				return true;
1:1c9c28b: 			}
1:1c9c28b: 		}
1:1c9c28b: 		return false;
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Returns an enumeration of all {@code SubsystemPermission} objects in the
1:1c9c28b: 	 * container.
1:452554c: 	 * 
1:1c9c28b: 	 * @return Enumeration of all {@code SubsystemPermission} objects.
1:1c9c28b: 	 */
1:d6eb080: 	@Override
1:1c9c28b: 	public synchronized Enumeration<Permission> elements() {
1:1c9c28b: 		List<Permission> all = new ArrayList<Permission>(permissions.values());
1:1c9c28b: 		return Collections.enumeration(all);
1:1c9c28b: 	}
1:1c9c28b: 
1:1c9c28b: 	/* serialization logic */
1:452554c: 	private static final ObjectStreamField[]	serialPersistentFields	= {new ObjectStreamField("permissions", HashMap.class), new ObjectStreamField("all_allowed", Boolean.TYPE)};
1:1c9c28b: 
1:452554c: 	private synchronized void writeObject(ObjectOutputStream out) throws IOException {
1:1c9c28b: 		ObjectOutputStream.PutField pfields = out.putFields();
1:1c9c28b: 		pfields.put("permissions", permissions);
1:1c9c28b: 		pfields.put("all_allowed", all_allowed);
1:1c9c28b: 		out.writeFields();
1:1c9c28b: 	}
1:1c9c28b: 
1:452554c: 	private synchronized void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
1:1c9c28b: 		ObjectInputStream.GetField gfields = in.readFields();
1:d6eb080: 		@SuppressWarnings("unchecked")
1:452554c: 		HashMap<String, SubsystemPermission> p = (HashMap<String, SubsystemPermission>) gfields.get("permissions", null);
1:1c9c28b: 		permissions = p;
1:1c9c28b: 		all_allowed = gfields.get("all_allowed", false);
1:1c9c28b: 	}
1:1c9c28b: }
============================================================================
author:Tom Watson
-------------------------------------------------------------------------------
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
1:  * Copyright (c) OSGi Alliance (2000, 2013). All Rights Reserved.
/////////////////////////////////////////////////////////////////////////
1:  * metadata  Subsystem.getSubsystemHeaders
/////////////////////////////////////////////////////////////////////////
1:  * @author $Id: 5c71d73cc6a3e8b2c2a7a3f188ebcf79b5ef7888 $
/////////////////////////////////////////////////////////////////////////
1: 	@Override
/////////////////////////////////////////////////////////////////////////
1: 	@Override
/////////////////////////////////////////////////////////////////////////
1: 	@Override
/////////////////////////////////////////////////////////////////////////
1: 	@Override
/////////////////////////////////////////////////////////////////////////
1: 	@Override
/////////////////////////////////////////////////////////////////////////
1: 			AccessController.doPrivileged(new PrivilegedAction<Void>() {
1: 				public Void run() {
/////////////////////////////////////////////////////////////////////////
1: 	@Override
/////////////////////////////////////////////////////////////////////////
1: 	@Override
/////////////////////////////////////////////////////////////////////////
1: 	@Override
/////////////////////////////////////////////////////////////////////////
1: 		@SuppressWarnings("unchecked")
author:John Ross
-------------------------------------------------------------------------------
commit:452554c
/////////////////////////////////////////////////////////////////////////
0:  * Copyright (c) OSGi Alliance (2000, 2012). All Rights Reserved.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * 
1:  * Action    Methods
1:  * context   Subsystem.getBundleContext
1:  * execute   Subsystem.start
1:  *           Subsystem.stop
1:  * lifecycle Subsystem.install
1:  *           Subsystem.uninstall
0:  * metadata  Subsystem.getHeaders
1:  *           Subsystem.getLocation
1:  * 
/////////////////////////////////////////////////////////////////////////
1:  * 
0:  * @version $Id: 6674ee12cbc60cedd5392edc39793df91aac4a1e $
1: 	static final long								serialVersionUID	= 307051004521261705L;
1: 	public final static String						EXECUTE				= "execute";
1: 	public final static String						LIFECYCLE			= "lifecycle";
1: 	public final static String						METADATA			= "metadata";
1: 	public final static String						CONTEXT				= "context";
1: 	private final static int						ACTION_EXECUTE		= 0x00000001;
1: 	private final static int						ACTION_LIFECYCLE	= 0x00000002;
1: 	private final static int						ACTION_METADATA		= 0x00000004;
1: 	private final static int						ACTION_CONTEXT		= 0x00000008;
1: 	private final static int						ACTION_ALL			= ACTION_EXECUTE | ACTION_LIFECYCLE | ACTION_METADATA | ACTION_CONTEXT;
1: 	final static int								ACTION_NONE			= 0;
1: 	 * 
1: 	private volatile String							actions				= null;
1: 	transient int									action_mask;
1: 	transient Filter								filter;
1: 	 * The subsystem governed by this SubsystemPermission - only used if filter
1: 	 * == null
1: 	transient final Subsystem						subsystem;
/////////////////////////////////////////////////////////////////////////
1: 	private static final ThreadLocal<Subsystem>		recurse				= new ThreadLocal<Subsystem>();
1: 	 * 
1: 	 * 
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	 * Creates a new requested {@code SubsystemPermission} object to be used by
1: 	 * the code that must perform {@code checkPermission}.
1: 	 * {@code SubsystemPermission} objects created with this constructor cannot
1: 	 * be added to an {@code SubsystemPermission} permission collection.
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 			while ((i != -1) && ((c = a[i]) == ' ' || c == '\r' || c == '\n' || c == '\f' || c == '\t'))
1: 			if (i >= 6 && (a[i - 6] == 'e' || a[i - 6] == 'E')
1: 					&& (a[i - 5] == 'x' || a[i - 5] == 'X')
1: 					&& (a[i - 4] == 'e' || a[i - 4] == 'E')
1: 					&& (a[i - 3] == 'c' || a[i - 3] == 'C')
1: 					&& (a[i - 2] == 'u' || a[i - 2] == 'U')
1: 					&& (a[i - 1] == 't' || a[i - 1] == 'T')
1: 					&& (a[i] == 'e' || a[i] == 'E')) {
1: 				matchlen = 7;
1: 				mask |= ACTION_EXECUTE;
1: 			} else
1: 				if (i >= 8 && (a[i - 8] == 'l' || a[i - 8] == 'L')
1: 						&& (a[i - 7] == 'i' || a[i - 7] == 'I')
1: 						&& (a[i - 6] == 'f' || a[i - 6] == 'F')
1: 						&& (a[i - 5] == 'e' || a[i - 5] == 'E')
1: 						&& (a[i - 4] == 'c' || a[i - 4] == 'C')
1: 						&& (a[i - 3] == 'y' || a[i - 3] == 'Y')
1: 						&& (a[i - 2] == 'c' || a[i - 2] == 'C')
1: 						&& (a[i - 1] == 'l' || a[i - 1] == 'L')
1: 					matchlen = 9;
1: 					mask |= ACTION_LIFECYCLE;
1: 				} else
1: 					if (i >= 7
1: 							&& (a[i - 7] == 'm' || a[i - 7] == 'M')
1: 							&& (a[i - 6] == 'e' || a[i - 6] == 'E')
1: 							&& (a[i - 5] == 't' || a[i - 5] == 'T')
1: 							&& (a[i - 4] == 'a' || a[i - 4] == 'A')
1: 							&& (a[i - 3] == 'd' || a[i - 3] == 'D')
1: 							&& (a[i - 2] == 'a' || a[i - 2] == 'A')
1: 							&& (a[i - 1] == 't' || a[i - 1] == 'T')
1: 							&& (a[i] == 'a' || a[i] == 'A')) {
1: 						matchlen = 8;
1: 						mask |= ACTION_METADATA;
1: 					} else
1: 						if (i >= 6
1: 								&& (a[i - 6] == 'c' || a[i - 6] == 'C')
1: 								&& (a[i - 5] == 'o' || a[i - 5] == 'O')
1: 								&& (a[i - 4] == 'n' || a[i - 4] == 'N')
1: 								&& (a[i - 3] == 't' || a[i - 3] == 'T')
1: 								&& (a[i - 2] == 'e' || a[i - 2] == 'E')
1: 								&& (a[i - 1] == 'x' || a[i - 1] == 'X')
1: 								&& (a[i] == 't' || a[i] == 'T')) {
1: 							matchlen = 7;
1: 							mask |= ACTION_CONTEXT;
1: 						} else {
1: 							throw new IllegalArgumentException("invalid permission: " + actions);
1: 			// like "ackbarfexecute". Also, skip to the comma.
/////////////////////////////////////////////////////////////////////////
1: 						throw new IllegalArgumentException("invalid permission: " + actions);
/////////////////////////////////////////////////////////////////////////
1: 			throw new IllegalArgumentException("invalid permission: " + actions);
/////////////////////////////////////////////////////////////////////////
1: 		} catch (InvalidSyntaxException e) {
1: 			IllegalArgumentException iae = new IllegalArgumentException("invalid filter");
/////////////////////////////////////////////////////////////////////////
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	 * filter, then this method returns {@code true} if this object's filter is
1: 	 * "*" and this object's actions include all of the specified permission's
1: 	 * actions
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 *        validated as a proper argument. The requested SubsystemPermission
1: 	 *        must not have a filter expression.
/////////////////////////////////////////////////////////////////////////
1: 		Map<String, Object> requestedProperties = requested.getProperties();
1: 			 * permit the subsystem location request in the SubsystemPermission
1: 			 * check up the stack to succeed.
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * Always returns present {@code SubsystemPermission} actions in the
1: 	 * following order: {@code execute}, {@code lifecycle}, {@code metadata},
1: 	 * 
1: 	 * @return Canonical string representation of the
1: 	 *         {@code SubsystemPermission} actions.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns a new {@code PermissionCollection} object suitable for storing
1: 	 * {@code SubsystemPermission}s.
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 		return (action_mask == sp.action_mask) && ((subsystem == sp.subsystem) || ((subsystem != null) && subsystem.equals(sp.subsystem)))
1: 				&& (filter == null ? sp.filter == null : filter.equals(sp.filter));
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException {
/////////////////////////////////////////////////////////////////////////
1: 	private synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
1: 	 * Called by {@code implies0} on an SubsystemPermission which was
1: 	 * constructed with a Subsystem. This method loads a map with the
1: 	 * filter-matchable properties of this subsystem. The map is cached so this
1: 	 * lookup only happens once.
1: 	 * 
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 		 * We may have recursed here due to the Subsystem.getLocation call in
1: 		 * the doPrivileged below. If this is the case, return null to allow
1: 		 * implies to return true.
/////////////////////////////////////////////////////////////////////////
1: 		} finally {
/////////////////////////////////////////////////////////////////////////
1: 	private static final long							serialVersionUID	= 3906372644575328048L;
1: 	 * 
1: 	 * 
1: 	private boolean										all_allowed;
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 			throw new IllegalArgumentException("invalid permission: " + permission);
1: 			throw new SecurityException("attempt to add a Permission to a " + "readonly PermissionCollection");
1: 			throw new IllegalArgumentException("cannot add to collection: " + sp);
/////////////////////////////////////////////////////////////////////////
1: 					pc.put(name, new SubsystemPermission(existing.filter, oldMask | newMask));
1: 			} else {
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 *         {@code SubsystemPermission} in this collection, {@code false}
1: 	 *         otherwise.
/////////////////////////////////////////////////////////////////////////
1: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 	private static final ObjectStreamField[]	serialPersistentFields	= {new ObjectStreamField("permissions", HashMap.class), new ObjectStreamField("all_allowed", Boolean.TYPE)};
1: 	private synchronized void writeObject(ObjectOutputStream out) throws IOException {
1: 	private synchronized void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
1: 		HashMap<String, SubsystemPermission> p = (HashMap<String, SubsystemPermission>) gfields.get("permissions", null);
commit:1c9c28b
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Copyright (c) OSGi Alliance (2000, 2011). All Rights Reserved.
1:  *
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.osgi.service.subsystem;
1: 
1: import java.io.IOException;
1: import java.io.NotSerializableException;
1: import java.io.ObjectInputStream;
1: import java.io.ObjectOutputStream;
1: import java.io.ObjectStreamField;
1: import java.security.AccessController;
1: import java.security.BasicPermission;
1: import java.security.Permission;
1: import java.security.PermissionCollection;
1: import java.security.PrivilegedAction;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: 
1: import org.osgi.framework.Filter;
1: import org.osgi.framework.FrameworkUtil;
1: import org.osgi.framework.InvalidSyntaxException;
1: 
1: /**
1:  * A bundle's authority to perform specific privileged administrative operations
1:  * on or to get sensitive information about a subsystem. The actions for this
1:  * permission are:
1:  *
1:  * <pre>
0:  *  Action               Methods
0:  *  context              Subsystem.getBundleContext
0:  *  execute              Subsystem.start
0:  *                       Subsystem.stop
0:  *  lifecycle            Subsystem.install
0:  *                       Subsystem.uninstall
0:  *  metadata             Subsystem.getHeaders
0:  *                       Subsystem.getLocation
1:  * </pre>
1:  *
1:  * <p>
1:  * The name of this permission is a filter expression. The filter gives access
1:  * to the following attributes:
1:  * <ul>
1:  * <li>location - The location of a subsystem.</li>
1:  * <li>id - The subsystem ID of the designated subsystem.</li>
1:  * <li>name - The symbolic name of a subsystem.</li>
1:  * </ul>
1:  * Filter attribute names are processed in a case sensitive manner.
1:  *
1:  * @ThreadSafe
0:  * @version $Id: 54ab1f9f1c80794d27dcf8c72e8720a4c582d229 $
1:  */
1: 
1: public final class SubsystemPermission extends BasicPermission {
0: 	static final long						serialVersionUID			= 307051004521261705L;
1: 
1: 	/**
1: 	 * The action string {@code execute}.
1: 	 */
0: 	public final static String	EXECUTE						= "execute";
1: 	/**
1: 	 * The action string {@code lifecycle}.
1: 	 */
0: 	public final static String	LIFECYCLE					= "lifecycle";
1: 	/**
1: 	 * The action string {@code metadata}.
1: 	 */
0: 	public final static String	METADATA					= "metadata";
1: 	/**
1: 	 * The action string {@code context}.
1: 	 */
0: 	public final static String	CONTEXT						= "context";
1: 
0: 	private final static int	ACTION_EXECUTE				= 0x00000002;
0: 	private final static int	ACTION_LIFECYCLE			= 0x00000004;
0: 	private final static int	ACTION_METADATA				= 0x00000010;
0: 	private final static int	ACTION_CONTEXT				= 0x00000400;
0: 	private final static int	ACTION_ALL					= ACTION_EXECUTE
0: 																	| ACTION_LIFECYCLE
0: 																	| ACTION_METADATA
0: 																	| ACTION_CONTEXT;
0: 	final static int						ACTION_NONE					= 0;
1: 
1: 	/**
1: 	 * The actions in canonical form.
1: 	 *
1: 	 * @serial
1: 	 */
0: 	private volatile String		actions						= null;
1: 
1: 	/**
1: 	 * The actions mask.
1: 	 */
0: 	transient int							action_mask;
1: 
1: 	/**
1: 	 * If this SubsystemPermission was constructed with a filter, this holds a
1: 	 * Filter matching object used to evaluate the filter in implies.
1: 	 */
0: 	transient Filter						filter;
1: 
1: 	/**
0: 	 * The subsystem governed by this SubsystemPermission - only used if filter == null
1: 	 */
0: 	transient final Subsystem					subsystem;
1: 
1: 	/**
1: 	 * This map holds the properties of the permission, used to match a filter
1: 	 * in implies. This is not initialized until necessary, and then cached in
1: 	 * this object.
1: 	 */
1: 	private transient volatile Map<String, Object>	properties;
1: 
1: 	/**
1: 	 * ThreadLocal used to determine if we have recursively called
1: 	 * getProperties.
1: 	 */
0: 	private static final ThreadLocal<Subsystem>	recurse						= new ThreadLocal<Subsystem>();
1: 
1: 	/**
1: 	 * Create a new SubsystemPermission.
1: 	 *
1: 	 * This constructor must only be used to create a permission that is going
1: 	 * to be checked.
1: 	 * <p>
1: 	 * Examples:
1: 	 *
1: 	 * <pre>
1: 	 * (name=com.acme.*)(location=http://www.acme.com/subsystems/*))
1: 	 * (id&gt;=1)
1: 	 * </pre>
1: 	 *
1: 	 * @param filter A filter expression that can use, location, id, and name
1: 	 *        keys. Filter attribute names are processed in a case sensitive
1: 	 *        manner. A special value of {@code "*"} can be used to match all
1: 	 *        subsystems.
1: 	 * @param actions {@code execute}, {@code lifecycle}, {@code metadata}, or
1: 	 *        {@code context}.
1: 	 * @throws IllegalArgumentException If the filter has an invalid syntax.
1: 	 */
1: 	public SubsystemPermission(String filter, String actions) {
1: 		this(parseFilter(filter), parseActions(actions));
1: 	}
1: 
1: 	/**
0: 	 * Creates a new requested {@code SubsystemPermission} object to be used by the
0: 	 * code that must perform {@code checkPermission}. {@code SubsystemPermission}
0: 	 * objects created with this constructor cannot be added to an
0: 	 * {@code SubsystemPermission} permission collection.
1: 	 *
1: 	 * @param subsystem A subsystem.
1: 	 * @param actions {@code execute}, {@code lifecycle}, {@code metadata}, or
1: 	 *        {@code context}.
1: 	 */
1: 	public SubsystemPermission(Subsystem subsystem, String actions) {
1: 		super(createName(subsystem));
1: 		setTransients(null, parseActions(actions));
1: 		this.subsystem = subsystem;
1: 	}
1: 
1: 	/**
1: 	 * Create a permission name from a Subsystem
1: 	 *
1: 	 * @param subsystem Subsystem to use to create permission name.
1: 	 * @return permission name.
1: 	 */
1: 	private static String createName(Subsystem subsystem) {
1: 		if (subsystem == null) {
1: 			throw new IllegalArgumentException("subsystem must not be null");
1: 		}
1: 		StringBuffer sb = new StringBuffer("(id=");
1: 		sb.append(subsystem.getSubsystemId());
1: 		sb.append(")");
1: 		return sb.toString();
1: 	}
1: 
1: 	/**
1: 	 * Package private constructor used by SubsystemPermissionCollection.
1: 	 *
1: 	 * @param filter name filter or {@code null} for wildcard.
1: 	 * @param mask action mask
1: 	 */
1: 	SubsystemPermission(Filter filter, int mask) {
1: 		super((filter == null) ? "*" : filter.toString());
1: 		setTransients(filter, mask);
1: 		this.subsystem = null;
1: 	}
1: 
1: 	/**
1: 	 * Called by constructors and when deserialized.
1: 	 *
1: 	 * @param filter Permission's filter or {@code null} for wildcard.
1: 	 * @param mask action mask
1: 	 */
1: 	private void setTransients(Filter filter, int mask) {
1: 		this.filter = filter;
1: 		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {
1: 			throw new IllegalArgumentException("invalid action string");
1: 		}
1: 		this.action_mask = mask;
1: 	}
1: 
1: 	/**
1: 	 * Parse action string into action mask.
1: 	 *
1: 	 * @param actions Action string.
1: 	 * @return action mask.
1: 	 */
1: 	private static int parseActions(String actions) {
1: 		boolean seencomma = false;
1: 
1: 		int mask = ACTION_NONE;
1: 
1: 		if (actions == null) {
1: 			return mask;
1: 		}
1: 
1: 		char[] a = actions.toCharArray();
1: 
1: 		int i = a.length - 1;
1: 		if (i < 0)
1: 			return mask;
1: 
1: 		while (i != -1) {
1: 			char c;
1: 
1: 			// skip whitespace
0: 			while ((i != -1)
0: 					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n'
0: 							|| c == '\f' || c == '\t'))
1: 				i--;
1: 
1: 			// check for the known strings
1: 			int matchlen;
1: 
0: 				if (i >= 6 && (a[i - 6] == 'e' || a[i - 6] == 'E')
0: 						&& (a[i - 5] == 'x' || a[i - 5] == 'X')
0: 						&& (a[i - 4] == 'e' || a[i - 4] == 'E')
0: 						&& (a[i - 3] == 'c' || a[i - 3] == 'C')
0: 						&& (a[i - 2] == 'u' || a[i - 2] == 'U')
0: 						&& (a[i - 1] == 't' || a[i - 1] == 'T')
1: 						&& (a[i] == 'e' || a[i] == 'E')) {
0: 					matchlen = 7;
0: 					mask |= ACTION_EXECUTE;
1: 
1: 				}
0: 				else
0: 					if (i >= 8 && (a[i - 8] == 'l' || a[i - 8] == 'L')
0: 							&& (a[i - 7] == 'i' || a[i - 7] == 'I')
0: 							&& (a[i - 6] == 'f' || a[i - 6] == 'F')
0: 							&& (a[i - 5] == 'e' || a[i - 5] == 'E')
0: 							&& (a[i - 4] == 'c' || a[i - 4] == 'C')
0: 							&& (a[i - 3] == 'y' || a[i - 3] == 'Y')
0: 							&& (a[i - 2] == 'c' || a[i - 2] == 'C')
0: 							&& (a[i - 1] == 'l' || a[i - 1] == 'L')
1: 							&& (a[i] == 'e' || a[i] == 'E')) {
0: 						matchlen = 9;
0: 						mask |= ACTION_LIFECYCLE;
1: 
1: 					}
0: 					else
0: 						if (i >= 7
0: 								&& (a[i - 7] == 'm' || a[i - 7] == 'M')
0: 								&& (a[i - 6] == 'e' || a[i - 6] == 'E')
0: 								&& (a[i - 5] == 't' || a[i - 5] == 'T')
0: 								&& (a[i - 4] == 'a' || a[i - 4] == 'A')
0: 								&& (a[i - 3] == 'd' || a[i - 3] == 'D')
0: 								&& (a[i - 2] == 'a' || a[i - 2] == 'A')
0: 								&& (a[i - 1] == 't' || a[i - 1] == 'T')
0: 								&& (a[i] == 'a' || a[i] == 'A')) {
0: 							matchlen = 8;
0: 							mask |= ACTION_METADATA;
1: 
1: 						}
0: 						else
0: 							if (i >= 6
0: 									&& (a[i - 6] == 'c' || a[i - 6] == 'C')
0: 									&& (a[i - 5] == 'o' || a[i - 5] == 'O')
0: 									&& (a[i - 4] == 'n' || a[i - 4] == 'N')
0: 									&& (a[i - 3] == 't' || a[i - 3] == 'T')
0: 									&& (a[i - 2] == 'e' || a[i - 2] == 'E')
0: 									&& (a[i - 1] == 'x' || a[i - 1] == 'X')
0: 									&& (a[i] == 't' || a[i] == 'T')) {
0: 								matchlen = 7;
0: 								mask |= ACTION_CONTEXT;
1: 
1: 							}
0: 						else {
1: 							// parse error
0: 							throw new IllegalArgumentException(
0: 									"invalid permission: " + actions);
1: 						}
1: 
1: 			// make sure we didn't just match the tail of a word
0: 			// like "ackbarfstartlevel". Also, skip to the comma.
1: 			seencomma = false;
1: 			while (i >= matchlen && !seencomma) {
1: 				switch (a[i - matchlen]) {
1: 					case ',' :
1: 						seencomma = true;
1: 						/* FALLTHROUGH */
1: 					case ' ' :
1: 					case '\r' :
1: 					case '\n' :
1: 					case '\f' :
1: 					case '\t' :
1: 						break;
1: 					default :
0: 						throw new IllegalArgumentException(
0: 								"invalid permission: " + actions);
1: 				}
1: 				i--;
1: 			}
1: 
1: 			// point i at the location of the comma minus one (or -1).
1: 			i -= matchlen;
1: 		}
1: 
1: 		if (seencomma) {
0: 			throw new IllegalArgumentException("invalid permission: " +
0: 					actions);
1: 		}
1: 
1: 		return mask;
1: 	}
1: 
1: 	/**
1: 	 * Parse filter string into a Filter object.
1: 	 * 
1: 	 * @param filterString The filter string to parse.
1: 	 * @return a Filter for this subsystem. If the specified filterString equals
1: 	 *         "*", then {@code null} is returned to indicate a wildcard.
1: 	 * @throws IllegalArgumentException If the filter syntax is invalid.
1: 	 */
1: 	private static Filter parseFilter(String filterString) {
1: 		filterString = filterString.trim();
1: 		if (filterString.equals("*")) {
1: 			return null;
1: 		}
1: 
1: 		try {
1: 			return FrameworkUtil.createFilter(filterString);
1: 		}
0: 		catch (InvalidSyntaxException e) {
0: 			IllegalArgumentException iae = new IllegalArgumentException(
0: 					"invalid filter");
1: 			iae.initCause(e);
1: 			throw iae;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Determines if the specified permission is implied by this object. This
1: 	 * method throws an exception if the specified permission was not
1: 	 * constructed with a subsystem.
1: 	 *
1: 	 * <p>
1: 	 * This method returns {@code true} if the specified permission is a
1: 	 * SubsystemPermission AND
1: 	 * <ul>
1: 	 * <li>this object's filter matches the specified permission's subsystem ID,
1: 	 * subsystem symbolic name, and subsystem location OR</li>
1: 	 * <li>this object's filter is "*"</li>
1: 	 * </ul>
1: 	 * AND this object's actions include all of the specified permission's
1: 	 * actions.
1: 	 * <p>
1: 	 * Special case: if the specified permission was constructed with "*"
0: 	 * filter, then this method returns {@code true} if this object's
0: 	 * filter is "*" and this object's actions include all of the specified
0: 	 * permission's actions
1: 	 *
1: 	 * @param p The requested permission.
1: 	 * @return {@code true} if the specified permission is implied by this
1: 	 *         object; {@code false} otherwise.
1: 	 */
1: 	public boolean implies(Permission p) {
1: 		if (!(p instanceof SubsystemPermission)) {
1: 			return false;
1: 		}
1: 		SubsystemPermission requested = (SubsystemPermission) p;
1: 		if (subsystem != null) {
1: 			return false;
1: 		}
1: 		// if requested permission has a filter, then it is an invalid argument
1: 		if (requested.filter != null) {
1: 			return false;
1: 		}
1: 		return implies0(requested, ACTION_NONE);
1: 	}
1: 
1: 	/**
1: 	 * Internal implies method. Used by the implies and the permission
1: 	 * collection implies methods.
1: 	 *
1: 	 * @param requested The requested SubsystemPermision which has already been
0: 	 *        validated as a proper argument. The requested SubsystemPermission must
0: 	 *        not have a filter expression.
1: 	 * @param effective The effective actions with which to start.
1: 	 * @return {@code true} if the specified permission is implied by this
1: 	 *         object; {@code false} otherwise.
1: 	 */
1: 	boolean implies0(SubsystemPermission requested, int effective) {
1: 		/* check actions first - much faster */
1: 		effective |= action_mask;
1: 		final int desired = requested.action_mask;
1: 		if ((effective & desired) != desired) {
1: 			return false;
1: 		}
1: 
1: 		/* Get our filter */
1: 		Filter f = filter;
1: 		if (f == null) {
1: 			// it's "*"
1: 			return true;
1: 		}
1: 		/* is requested a wildcard filter? */
1: 		if (requested.subsystem == null) {
1: 			return false;
1: 		}
0: 		Map<String, Object> requestedProperties = requested
0: 				.getProperties();
1: 		if (requestedProperties == null) {
1: 			/*
1: 			 * If the requested properties are null, then we have detected a
1: 			 * recursion getting the subsystem location. So we return true to
0: 			 * permit the subsystem location request in the SubsystemPermission check
0: 			 * up the stack to succeed.
1: 			 */
1: 			return true;
1: 		}
1: 		return f.matches(requestedProperties);
1: 	}
1: 
1: 	/**
1: 	 * Returns the canonical string representation of the
1: 	 * {@code SubsystemPermission} actions.
1: 	 *
1: 	 * <p>
0: 	 * Always returns present {@code SubsystemPermission} actions in the following
0: 	 * order: {@code execute}, {@code lifecycle}, {@code metadata},
1: 	 * {@code context}.
1: 	 *
0: 	 * @return Canonical string representation of the {@code SubsystemPermission}
0: 	 *         actions.
1: 	 */
1: 	public String getActions() {
1: 		String result = actions;
1: 		if (result == null) {
1: 			StringBuffer sb = new StringBuffer();
1: 
1: 			int mask = action_mask;
1: 
1: 			if ((mask & ACTION_EXECUTE) == ACTION_EXECUTE) {
1: 				sb.append(EXECUTE);
1: 				sb.append(',');
1: 			}
1: 
1: 			if ((mask & ACTION_LIFECYCLE) == ACTION_LIFECYCLE) {
1: 				sb.append(LIFECYCLE);
1: 				sb.append(',');
1: 			}
1: 
1: 
1: 			if ((mask & ACTION_METADATA) == ACTION_METADATA) {
1: 				sb.append(METADATA);
1: 				sb.append(',');
1: 			}
1: 
1: 			if ((mask & ACTION_CONTEXT) == ACTION_CONTEXT) {
1: 				sb.append(CONTEXT);
1: 				sb.append(',');
1: 			}
1: 
1: 			// remove trailing comma
1: 			if (sb.length() > 0) {
1: 				sb.setLength(sb.length() - 1);
1: 			}
1: 
1: 			actions = result = sb.toString();
1: 		}
1: 		return result;
1: 	}
1: 
1: 	/**
0: 	 * Returns a new {@code PermissionCollection} object suitable for
0: 	 * storing {@code SubsystemPermission}s.
1: 	 *
1: 	 * @return A new {@code PermissionCollection} object.
1: 	 */
1: 	public PermissionCollection newPermissionCollection() {
1: 		return new SubsystemPermissionCollection();
1: 	}
1: 
1: 	/**
1: 	 * Determines the equality of two {@code SubsystemPermission} objects.
1: 	 *
1: 	 * @param obj The object being compared for equality with this object.
1: 	 * @return {@code true} if {@code obj} is equivalent to this
1: 	 *         {@code SubsystemPermission}; {@code false} otherwise.
1: 	 */
1: 	public boolean equals(Object obj) {
1: 		if (obj == this) {
1: 			return true;
1: 		}
1: 
1: 		if (!(obj instanceof SubsystemPermission)) {
1: 			return false;
1: 		}
1: 
1: 		SubsystemPermission sp = (SubsystemPermission) obj;
1: 
0: 		return (action_mask == sp.action_mask)
0: 				&& ((subsystem == sp.subsystem) || ((subsystem != null) && subsystem
0: 						.equals(sp.subsystem)))
0: 				&& (filter == null ? sp.filter == null : filter
0: 						.equals(sp.filter));
1: 	}
1: 
1: 	/**
1: 	 * Returns the hash code value for this object.
1: 	 *
1: 	 * @return Hash code value for this object.
1: 	 */
1: 	public int hashCode() {
1: 		int h = 31 * 17 + getName().hashCode();
1: 		h = 31 * h + getActions().hashCode();
1: 		if (subsystem != null) {
1: 			h = 31 * h + subsystem.hashCode();
1: 		}
1: 		return h;
1: 	}
1: 
1: 	/**
1: 	 * WriteObject is called to save the state of this permission object to a
1: 	 * stream. The actions are serialized, and the superclass takes care of the
1: 	 * name.
1: 	 */
0: 	private synchronized void writeObject(java.io.ObjectOutputStream s)
0: 			throws IOException {
1: 		if (subsystem != null) {
1: 			throw new NotSerializableException("cannot serialize");
1: 		}
1: 		// Write out the actions. The superclass takes care of the name
1: 		// call getActions to make sure actions field is initialized
1: 		if (actions == null)
1: 			getActions();
1: 		s.defaultWriteObject();
1: 	}
1: 
1: 	/**
1: 	 * readObject is called to restore the state of this permission from a
1: 	 * stream.
1: 	 */
0: 	private synchronized void readObject(java.io.ObjectInputStream s)
0: 			throws IOException, ClassNotFoundException {
1: 		// Read in the data, then initialize the transients
1: 		s.defaultReadObject();
1: 		setTransients(parseFilter(getName()), parseActions(actions));
1: 	}
1: 
1: 	/**
0: 	 * Called by {@code implies0} on an SubsystemPermission which was constructed
0: 	 * with a Subsystem. This method loads a map with the filter-matchable
0: 	 * properties of this subsystem. The map is cached so this lookup only happens
0: 	 * once.
1: 	 *
1: 	 * This method should only be called on an SubsystemPermission which was
1: 	 * constructed with a subsystem
1: 	 *
1: 	 * @return a map of properties for this subsystem
1: 	 */
1: 	private Map<String, Object> getProperties() {
1: 		Map<String, Object> result = properties;
1: 		if (result != null) {
1: 			return result;
1: 		}
1: 		/*
0: 		 * We may have recursed here due to the Subsystem.getLocation call in the
0: 		 * doPrivileged below. If this is the case, return null to allow implies
0: 		 * to return true.
1: 		 */
1: 		final Object mark = recurse.get();
1: 		if (mark == subsystem) {
1: 			return null;
1: 		}
1: 		recurse.set(subsystem);
1: 		try {
1: 			final Map<String, Object> map = new HashMap<String, Object>(4);
0: 			AccessController.doPrivileged(new PrivilegedAction<Object>() {
0: 				public Object run() {
1: 					map.put("id", new Long(subsystem.getSubsystemId()));
1: 					map.put("location", subsystem.getLocation());
1: 					map.put("name", subsystem.getSymbolicName());
1: 					return null;
1: 				}
1: 			});
1: 			return properties = map;
1: 		}
0: 		finally {
1: 			recurse.set(null);
1: 		}
1: 	}
1: }
1: 
1: /**
1:  * Stores a collection of {@code SubsystemPermission}s.
1:  */
1: final class SubsystemPermissionCollection extends PermissionCollection {
0: 	private static final long	serialVersionUID	= 3906372644575328048L;
1: 	/**
1: 	 * Collection of permissions.
1: 	 *
1: 	 * @GuardedBy this
1: 	 */
1: 	private transient Map<String, SubsystemPermission>	permissions;
1: 
1: 	/**
1: 	 * Boolean saying if "*" is in the collection.
1: 	 *
1: 	 * @serial
1: 	 * @GuardedBy this
1: 	 */
0: 	private boolean				all_allowed;
1: 
1: 	/**
1: 	 * Create an empty SubsystemPermissionCollection object.
1: 	 *
1: 	 */
1: 	public SubsystemPermissionCollection() {
1: 		permissions = new HashMap<String, SubsystemPermission>();
1: 	}
1: 
1: 	/**
1: 	 * Adds a permission to this permission collection.
1: 	 *
1: 	 * @param permission The {@code SubsystemPermission} object to add.
1: 	 * @throws IllegalArgumentException If the specified permission is not an
1: 	 *         {@code SubsystemPermission} instance or was constructed with a
1: 	 *         Subsystem object.
1: 	 * @throws SecurityException If this {@code SubsystemPermissionCollection}
1: 	 *         object has been marked read-only.
1: 	 */
1: 	public void add(Permission permission) {
1: 		if (!(permission instanceof SubsystemPermission)) {
0: 			throw new IllegalArgumentException("invalid permission: "
0: 					+ permission);
1: 		}
1: 		if (isReadOnly()) {
0: 			throw new SecurityException("attempt to add a Permission to a "
0: 					+ "readonly PermissionCollection");
1: 		}
1: 		final SubsystemPermission sp = (SubsystemPermission) permission;
1: 		if (sp.subsystem != null) {
0: 			throw new IllegalArgumentException("cannot add to collection: "
0: 					+ sp);
1: 		}
1: 		final String name = sp.getName();
1: 		synchronized (this) {
1: 			Map<String, SubsystemPermission> pc = permissions;
1: 			SubsystemPermission existing = pc.get(name);
1: 			if (existing != null) {
1: 				int oldMask = existing.action_mask;
1: 				int newMask = sp.action_mask;
1: 
1: 				if (oldMask != newMask) {
0: 					pc.put(name, new SubsystemPermission(existing.filter, oldMask
0: 							| newMask));
1: 				}
1: 			}
0: 			else {
1: 				pc.put(name, sp);
1: 			}
1: 			if (!all_allowed) {
1: 				if (name.equals("*")) {
1: 					all_allowed = true;
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Determines if the specified permissions implies the permissions expressed
1: 	 * in {@code permission}.
1: 	 *
1: 	 * @param permission The Permission object to compare with the
1: 	 *        {@code SubsystemPermission} objects in this collection.
1: 	 * @return {@code true} if {@code permission} is implied by an
0: 	 *         {@code SubsystemPermission} in this collection,
0: 	 *         {@code false} otherwise.
1: 	 */
1: 	public boolean implies(Permission permission) {
1: 		if (!(permission instanceof SubsystemPermission)) {
1: 			return false;
1: 		}
1: 
1: 		SubsystemPermission requested = (SubsystemPermission) permission;
1: 		// if requested permission has a filter, then it is an invalid argument
1: 		if (requested.filter != null) {
1: 			return false;
1: 		}
1: 		int effective = SubsystemPermission.ACTION_NONE;
1: 		Collection<SubsystemPermission> perms;
1: 		synchronized (this) {
1: 			Map<String, SubsystemPermission> pc = permissions;
1: 			// short circuit if the "*" Permission was added
1: 			if (all_allowed) {
1: 				SubsystemPermission sp = pc.get("*");
1: 				if (sp != null) {
1: 					effective |= sp.action_mask;
1: 					final int desired = requested.action_mask;
1: 					if ((effective & desired) == desired) {
1: 						return true;
1: 					}
1: 				}
1: 			}
1: 			perms = pc.values();
1: 		}
1: 
1: 		// just iterate one by one
1: 		for (SubsystemPermission perm : perms) {
1: 			if (perm.implies0(requested, effective)) {
1: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Returns an enumeration of all {@code SubsystemPermission} objects in the
1: 	 * container.
1: 	 *
1: 	 * @return Enumeration of all {@code SubsystemPermission} objects.
1: 	 */
1: 	public synchronized Enumeration<Permission> elements() {
1: 		List<Permission> all = new ArrayList<Permission>(permissions.values());
1: 		return Collections.enumeration(all);
1: 	}
1: 
1: 	/* serialization logic */
0:     private static final ObjectStreamField[]	serialPersistentFields	= {
0: 			new ObjectStreamField("permissions", HashMap.class),
0: 			new ObjectStreamField("all_allowed", Boolean.TYPE)			};
1: 
0:     private synchronized void writeObject(ObjectOutputStream out)
0: 			throws IOException {
1: 		ObjectOutputStream.PutField pfields = out.putFields();
1: 		pfields.put("permissions", permissions);
1: 		pfields.put("all_allowed", all_allowed);
1: 		out.writeFields();
1: 	}
1: 
0: 	private synchronized void readObject(java.io.ObjectInputStream in)
0: 			throws IOException,
0: 			ClassNotFoundException {
1: 		ObjectInputStream.GetField gfields = in.readFields();
0: 		HashMap<String, SubsystemPermission> p = (HashMap<String, SubsystemPermission>) gfields
0: 				.get("permissions", null);
1: 		permissions = p;
1: 		all_allowed = gfields.get("all_allowed", false);
1: 	}
1: }
============================================================================