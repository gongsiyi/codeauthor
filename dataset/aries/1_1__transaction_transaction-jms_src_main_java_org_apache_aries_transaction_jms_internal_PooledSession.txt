2:4243a2b: /**
1:4243a2b:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:4243a2b:  * contributor license agreements.  See the NOTICE file distributed with
1:4243a2b:  * this work for additional information regarding copyright ownership.
1:4243a2b:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:4243a2b:  * (the "License"); you may not use this file except in compliance with
1:4243a2b:  * the License.  You may obtain a copy of the License at
2:4243a2b:  *
1:4243a2b:  *      http://www.apache.org/licenses/LICENSE-2.0
1:4243a2b:  *
1:4243a2b:  * Unless required by applicable law or agreed to in writing, software
1:4243a2b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4243a2b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4243a2b:  * See the License for the specific language governing permissions and
1:4243a2b:  * limitations under the License.
2:4243a2b:  */
1:4243a2b: package org.apache.aries.transaction.jms.internal;
4:4243a2b: 
1:4243a2b: import java.io.Serializable;
1:4243a2b: import java.lang.IllegalStateException;
1:4243a2b: import java.util.Iterator;
1:4243a2b: import java.util.concurrent.CopyOnWriteArrayList;
1:4243a2b: import javax.jms.*;
1:4243a2b: import javax.transaction.xa.XAResource;
1:4243a2b: 
1:4c2ef4a: import org.apache.commons.pool.KeyedObjectPool;
1:4243a2b: import org.slf4j.Logger;
1:4243a2b: import org.slf4j.LoggerFactory;
1:4243a2b: 
1:4c2ef4a: public class PooledSession implements Session, TopicSession, QueueSession, XASession {
1:4243a2b:     private static final transient Logger LOG = LoggerFactory.getLogger(PooledSession.class);
1:4243a2b: 
1:4c2ef4a:     private final SessionKey key;
1:4c2ef4a:     private final KeyedObjectPool<SessionKey, PooledSession> sessionPool;
1:4243a2b:     private final CopyOnWriteArrayList<MessageConsumer> consumers = new CopyOnWriteArrayList<MessageConsumer>();
1:4243a2b:     private final CopyOnWriteArrayList<QueueBrowser> browsers = new CopyOnWriteArrayList<QueueBrowser>();
1:4c2ef4a:     private final CopyOnWriteArrayList<PooledSessionEventListener> sessionEventListeners = new CopyOnWriteArrayList<PooledSessionEventListener>();
1:4243a2b: 
1:4c2ef4a:     private MessageProducer producer;
1:4c2ef4a:     private TopicPublisher publisher;
1:4c2ef4a:     private QueueSender sender;
1:4c2ef4a: 
1:4c2ef4a:     private Session session;
1:4c2ef4a:     private boolean transactional = true;
1:4c2ef4a:     private boolean ignoreClose;
1:4c2ef4a:     private boolean isXa;
1:4c2ef4a:     private boolean useAnonymousProducers = true;
1:4c2ef4a: 
1:4c2ef4a:     public PooledSession(SessionKey key, Session session, KeyedObjectPool<SessionKey, PooledSession> sessionPool, boolean transactional, boolean anonymous) {
1:4c2ef4a:         this.key = key;
1:4243a2b:         this.session = session;
1:4243a2b:         this.sessionPool = sessionPool;
1:4243a2b:         this.transactional = transactional;
1:4c2ef4a:         this.useAnonymousProducers = anonymous;
2:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     public void addSessionEventListener(PooledSessionEventListener listener) {
1:4c2ef4a:         // only add if really needed
1:4c2ef4a:         if (!sessionEventListeners.contains(listener)) {
1:4c2ef4a:             this.sessionEventListeners.add(listener);
1:4c2ef4a:         }
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     protected boolean isIgnoreClose() {
1:4243a2b:         return ignoreClose;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     protected void setIgnoreClose(boolean ignoreClose) {
1:4243a2b:         this.ignoreClose = ignoreClose;
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public void close() throws JMSException {
1:4243a2b:         if (!ignoreClose) {
1:4243a2b:             boolean invalidate = false;
1:4243a2b:             try {
1:4243a2b:                 // lets reset the session
1:4243a2b:                 getInternalSession().setMessageListener(null);
1:4243a2b: 
1:4243a2b:                 // Close any consumers and browsers that may have been created.
1:4243a2b:                 for (Iterator<MessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:4243a2b:                     MessageConsumer consumer = iter.next();
1:4243a2b:                     consumer.close();
1:4243a2b:                 }
1:4243a2b: 
1:4243a2b:                 for (Iterator<QueueBrowser> iter = browsers.iterator(); iter.hasNext();) {
1:4243a2b:                     QueueBrowser browser = iter.next();
1:4243a2b:                     browser.close();
1:4243a2b:                 }
1:4243a2b: 
1:4243a2b:                 if (transactional && !isXa) {
1:4243a2b:                     try {
1:4243a2b:                         getInternalSession().rollback();
1:4243a2b:                     } catch (JMSException e) {
1:4243a2b:                         invalidate = true;
1:4243a2b:                         LOG.warn("Caught exception trying rollback() when putting session back into the pool, will invalidate. " + e, e);
1:4243a2b:                     }
1:4243a2b:                 }
1:4243a2b:             } catch (JMSException ex) {
1:4243a2b:                 invalidate = true;
1:4243a2b:                 LOG.warn("Caught exception trying close() when putting session back into the pool, will invalidate. " + ex, ex);
1:4243a2b:             } finally {
1:4243a2b:                 consumers.clear();
1:4243a2b:                 browsers.clear();
1:4c2ef4a:                 for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:4c2ef4a:                     listener.onSessionClosed(this);
1:4c2ef4a:                 }
1:4c2ef4a:                 sessionEventListeners.clear();
1:4243a2b:             }
1:4243a2b: 
1:4243a2b:             if (invalidate) {
1:4c2ef4a:                 // lets close the session and not put the session back into the pool
1:4c2ef4a:                 // instead invalidate it so the pool can create a new one on demand.
1:4243a2b:                 if (session != null) {
1:4243a2b:                     try {
1:4243a2b:                         session.close();
1:4243a2b:                     } catch (JMSException e1) {
1:4243a2b:                         LOG.trace("Ignoring exception on close as discarding session: " + e1, e1);
1:4243a2b:                     }
1:4243a2b:                     session = null;
1:4243a2b:                 }
1:4c2ef4a:                 try {
1:4c2ef4a:                     sessionPool.invalidateObject(key, this);
1:4c2ef4a:                 } catch (Exception e) {
1:4c2ef4a:                     LOG.trace("Ignoring exception on invalidateObject as discarding session: " + e, e);
1:4c2ef4a:                 }
1:4243a2b:             } else {
1:4c2ef4a:                 try {
1:4c2ef4a:                     sessionPool.returnObject(key, this);
1:4c2ef4a:                 } catch (Exception e) {
1:4c2ef4a:                     javax.jms.IllegalStateException illegalStateException = new javax.jms.IllegalStateException(e.toString());
1:4c2ef4a:                     illegalStateException.initCause(e);
1:4c2ef4a:                     throw illegalStateException;
1:4c2ef4a:                 }
1:4243a2b:             }
1:4243a2b:         }
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public void commit() throws JMSException {
1:4243a2b:         getInternalSession().commit();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public BytesMessage createBytesMessage() throws JMSException {
1:4243a2b:         return getInternalSession().createBytesMessage();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public MapMessage createMapMessage() throws JMSException {
1:4243a2b:         return getInternalSession().createMapMessage();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public Message createMessage() throws JMSException {
1:4243a2b:         return getInternalSession().createMessage();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public ObjectMessage createObjectMessage() throws JMSException {
1:4243a2b:         return getInternalSession().createObjectMessage();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public ObjectMessage createObjectMessage(Serializable serializable) throws JMSException {
1:4243a2b:         return getInternalSession().createObjectMessage(serializable);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public Queue createQueue(String s) throws JMSException {
1:4243a2b:         return getInternalSession().createQueue(s);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public StreamMessage createStreamMessage() throws JMSException {
1:4243a2b:         return getInternalSession().createStreamMessage();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public TemporaryQueue createTemporaryQueue() throws JMSException {
1:4243a2b:         TemporaryQueue result;
1:4243a2b: 
1:4243a2b:         result = getInternalSession().createTemporaryQueue();
1:4243a2b: 
1:4243a2b:         // Notify all of the listeners of the created temporary Queue.
1:4c2ef4a:         for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:4243a2b:             listener.onTemporaryQueueCreate(result);
1:4243a2b:         }
1:4243a2b: 
1:4243a2b:         return result;
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public TemporaryTopic createTemporaryTopic() throws JMSException {
1:4243a2b:         TemporaryTopic result;
1:4243a2b: 
1:4243a2b:         result = getInternalSession().createTemporaryTopic();
1:4243a2b: 
1:4243a2b:         // Notify all of the listeners of the created temporary Topic.
1:4c2ef4a:         for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:4243a2b:             listener.onTemporaryTopicCreate(result);
1:4243a2b:         }
1:4243a2b: 
1:4243a2b:         return result;
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public void unsubscribe(String s) throws JMSException {
1:4243a2b:         getInternalSession().unsubscribe(s);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public TextMessage createTextMessage() throws JMSException {
1:4243a2b:         return getInternalSession().createTextMessage();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public TextMessage createTextMessage(String s) throws JMSException {
1:4243a2b:         return getInternalSession().createTextMessage(s);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public Topic createTopic(String s) throws JMSException {
1:4243a2b:         return getInternalSession().createTopic(s);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public int getAcknowledgeMode() throws JMSException {
1:4243a2b:         return getInternalSession().getAcknowledgeMode();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public boolean getTransacted() throws JMSException {
1:4243a2b:         return getInternalSession().getTransacted();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public void recover() throws JMSException {
1:4243a2b:         getInternalSession().recover();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public void rollback() throws JMSException {
1:4243a2b:         getInternalSession().rollback();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public XAResource getXAResource() {
1:4c2ef4a:         if (session instanceof XASession) {
1:4c2ef4a:             return ((XASession) session).getXAResource();
1:4243a2b:         }
1:4c2ef4a:         return null;
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public Session getSession() {
1:4243a2b:         return this;
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public void run() {
1:4243a2b:         if (session != null) {
1:4243a2b:             session.run();
1:4243a2b:         }
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     // Consumer related methods
1:4243a2b:     // -------------------------------------------------------------------------
1:4c2ef4a:     @Override
1:4243a2b:     public QueueBrowser createBrowser(Queue queue) throws JMSException {
1:4243a2b:         return addQueueBrowser(getInternalSession().createBrowser(queue));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public QueueBrowser createBrowser(Queue queue, String selector) throws JMSException {
1:4243a2b:         return addQueueBrowser(getInternalSession().createBrowser(queue, selector));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public MessageConsumer createConsumer(Destination destination) throws JMSException {
1:4243a2b:         return addConsumer(getInternalSession().createConsumer(destination));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public MessageConsumer createConsumer(Destination destination, String selector) throws JMSException {
1:4243a2b:         return addConsumer(getInternalSession().createConsumer(destination, selector));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public MessageConsumer createConsumer(Destination destination, String selector, boolean noLocal) throws JMSException {
1:4243a2b:         return addConsumer(getInternalSession().createConsumer(destination, selector, noLocal));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public TopicSubscriber createDurableSubscriber(Topic topic, String selector) throws JMSException {
1:4243a2b:         return addTopicSubscriber(getInternalSession().createDurableSubscriber(topic, selector));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public TopicSubscriber createDurableSubscriber(Topic topic, String name, String selector, boolean noLocal) throws JMSException {
1:4243a2b:         return addTopicSubscriber(getInternalSession().createDurableSubscriber(topic, name, selector, noLocal));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public MessageListener getMessageListener() throws JMSException {
1:4243a2b:         return getInternalSession().getMessageListener();
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public void setMessageListener(MessageListener messageListener) throws JMSException {
1:4243a2b:         getInternalSession().setMessageListener(messageListener);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public TopicSubscriber createSubscriber(Topic topic) throws JMSException {
1:4243a2b:         return addTopicSubscriber(((TopicSession) getInternalSession()).createSubscriber(topic));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public TopicSubscriber createSubscriber(Topic topic, String selector, boolean local) throws JMSException {
1:4243a2b:         return addTopicSubscriber(((TopicSession) getInternalSession()).createSubscriber(topic, selector, local));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public QueueReceiver createReceiver(Queue queue) throws JMSException {
1:4243a2b:         return addQueueReceiver(((QueueSession) getInternalSession()).createReceiver(queue));
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public QueueReceiver createReceiver(Queue queue, String selector) throws JMSException {
1:4243a2b:         return addQueueReceiver(((QueueSession) getInternalSession()).createReceiver(queue, selector));
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     // Producer related methods
1:4243a2b:     // -------------------------------------------------------------------------
1:4c2ef4a:     @Override
1:4243a2b:     public MessageProducer createProducer(Destination destination) throws JMSException {
1:4c2ef4a:         return new PooledProducer(getMessageProducer(destination), destination);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public QueueSender createSender(Queue queue) throws JMSException {
1:4c2ef4a:         return new PooledQueueSender(getQueueSender(queue), queue);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public TopicPublisher createPublisher(Topic topic) throws JMSException {
1:4c2ef4a:         return new PooledTopicPublisher(getTopicPublisher(topic), topic);
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     public Session getInternalSession() throws IllegalStateException {
2:4243a2b:         if (session == null) {
1:4c2ef4a:             throw new IllegalStateException("The session has already been closed");
1:4243a2b:         }
1:4243a2b:         return session;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     public MessageProducer getMessageProducer() throws JMSException {
1:4c2ef4a:         return getMessageProducer(null);
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     public MessageProducer getMessageProducer(Destination destination) throws JMSException {
1:4c2ef4a:         MessageProducer result = null;
1:4c2ef4a: 
1:4c2ef4a:         if (useAnonymousProducers) {
1:4c2ef4a:             if (producer == null) {
1:4c2ef4a:                 // Don't allow for duplicate anonymous producers.
1:4c2ef4a:                 synchronized (this) {
1:4c2ef4a:                     if (producer == null) {
1:4c2ef4a:                         producer = getInternalSession().createProducer(null);
1:4c2ef4a:                     }
1:4c2ef4a:                 }
1:4c2ef4a:             }
1:4c2ef4a: 
1:4c2ef4a:             result = producer;
1:4c2ef4a:         } else {
1:4c2ef4a:             result = getInternalSession().createProducer(destination);
1:4243a2b:         }
1:4c2ef4a: 
1:4c2ef4a:         return result;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     public QueueSender getQueueSender() throws JMSException {
1:4c2ef4a:         return getQueueSender(null);
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     public QueueSender getQueueSender(Queue destination) throws JMSException {
1:4c2ef4a:         QueueSender result = null;
1:4c2ef4a: 
1:4c2ef4a:         if (useAnonymousProducers) {
1:4c2ef4a:             if (sender == null) {
1:4c2ef4a:                 // Don't allow for duplicate anonymous producers.
1:4c2ef4a:                 synchronized (this) {
1:4c2ef4a:                     if (sender == null) {
1:4c2ef4a:                         sender = ((QueueSession) getInternalSession()).createSender(null);
1:4c2ef4a:                     }
1:4c2ef4a:                 }
1:4c2ef4a:             }
1:4c2ef4a: 
1:4c2ef4a:             result = sender;
1:4c2ef4a:         } else {
1:4c2ef4a:             result = ((QueueSession) getInternalSession()).createSender(destination);
1:4243a2b:         }
1:4c2ef4a: 
1:4c2ef4a:         return result;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     public TopicPublisher getTopicPublisher() throws JMSException {
1:4c2ef4a:         return getTopicPublisher(null);
1:4c2ef4a:     }
1:4c2ef4a: 
1:4c2ef4a:     public TopicPublisher getTopicPublisher(Topic destination) throws JMSException {
1:4c2ef4a:         TopicPublisher result = null;
1:4c2ef4a: 
1:4c2ef4a:         if (useAnonymousProducers) {
1:4c2ef4a:             if (publisher == null) {
1:4c2ef4a:                 // Don't allow for duplicate anonymous producers.
1:4c2ef4a:                 synchronized (this) {
1:4c2ef4a:                     if (publisher == null) {
1:4c2ef4a:                         publisher = ((TopicSession) getInternalSession()).createPublisher(null);
1:4c2ef4a:                     }
1:4c2ef4a:                 }
1:4c2ef4a:             }
1:4c2ef4a: 
1:4c2ef4a:             result = publisher;
1:4c2ef4a:         } else {
1:4c2ef4a:             result = ((TopicSession) getInternalSession()).createPublisher(destination);
1:4243a2b:         }
1:4c2ef4a: 
1:4c2ef4a:         return result;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     private QueueBrowser addQueueBrowser(QueueBrowser browser) {
1:4243a2b:         browsers.add(browser);
1:4243a2b:         return browser;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     private MessageConsumer addConsumer(MessageConsumer consumer) {
1:4243a2b:         consumers.add(consumer);
1:4243a2b:         // must wrap in PooledMessageConsumer to ensure the onConsumerClose
1:4c2ef4a:         // method is invoked when the returned consumer is closed, to avoid memory
1:4c2ef4a:         // leak in this session class in case many consumers is created
1:4243a2b:         return new PooledMessageConsumer(this, consumer);
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     private TopicSubscriber addTopicSubscriber(TopicSubscriber subscriber) {
1:4243a2b:         consumers.add(subscriber);
1:4243a2b:         return subscriber;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     private QueueReceiver addQueueReceiver(QueueReceiver receiver) {
1:4243a2b:         consumers.add(receiver);
1:4243a2b:         return receiver;
1:4243a2b:     }
1:4243a2b: 
1:4243a2b:     public void setIsXa(boolean isXa) {
1:4243a2b:         this.isXa = isXa;
1:4243a2b:     }
1:4243a2b: 
1:4c2ef4a:     @Override
1:4243a2b:     public String toString() {
1:4243a2b:         return "PooledSession { " + session + " }";
1:4243a2b:     }
1:4c2ef4a: 
1:4c2ef4a:     /**
1:4c2ef4a:      * Callback invoked when the consumer is closed.
1:4c2ef4a:      * <p/>
1:4c2ef4a:      * This is used to keep track of an explicit closed consumer created by this
1:4c2ef4a:      * session, by which we know do not need to keep track of the consumer, as
1:4c2ef4a:      * its already closed.
1:4c2ef4a:      *
1:4c2ef4a:      * @param consumer
1:4c2ef4a:      *            the consumer which is being closed
1:4c2ef4a:      */
1:4c2ef4a:     protected void onConsumerClose(MessageConsumer consumer) {
1:4c2ef4a:         consumers.remove(consumer);
1:4c2ef4a:     }
1:4243a2b: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:4c2ef4a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.pool.KeyedObjectPool;
1: public class PooledSession implements Session, TopicSession, QueueSession, XASession {
1:     private final SessionKey key;
1:     private final KeyedObjectPool<SessionKey, PooledSession> sessionPool;
1:     private final CopyOnWriteArrayList<PooledSessionEventListener> sessionEventListeners = new CopyOnWriteArrayList<PooledSessionEventListener>();
1:     private MessageProducer producer;
1:     private TopicPublisher publisher;
1:     private QueueSender sender;
1: 
1:     private Session session;
1:     private boolean transactional = true;
1:     private boolean ignoreClose;
1:     private boolean isXa;
1:     private boolean useAnonymousProducers = true;
1: 
1:     public PooledSession(SessionKey key, Session session, KeyedObjectPool<SessionKey, PooledSession> sessionPool, boolean transactional, boolean anonymous) {
1:         this.key = key;
1:         this.useAnonymousProducers = anonymous;
1:     public void addSessionEventListener(PooledSessionEventListener listener) {
1:         // only add if really needed
1:         if (!sessionEventListeners.contains(listener)) {
1:             this.sessionEventListeners.add(listener);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:                     listener.onSessionClosed(this);
1:                 }
1:                 sessionEventListeners.clear();
1:                 // lets close the session and not put the session back into the pool
1:                 // instead invalidate it so the pool can create a new one on demand.
/////////////////////////////////////////////////////////////////////////
1:                 try {
1:                     sessionPool.invalidateObject(key, this);
1:                 } catch (Exception e) {
1:                     LOG.trace("Ignoring exception on invalidateObject as discarding session: " + e, e);
1:                 }
1:                 try {
1:                     sessionPool.returnObject(key, this);
1:                 } catch (Exception e) {
1:                     javax.jms.IllegalStateException illegalStateException = new javax.jms.IllegalStateException(e.toString());
1:                     illegalStateException.initCause(e);
1:                     throw illegalStateException;
1:                 }
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:         for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:     @Override
1:         for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:         if (session instanceof XASession) {
1:             return ((XASession) session).getXAResource();
1:         return null;
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:         return new PooledProducer(getMessageProducer(destination), destination);
1:     @Override
1:         return new PooledQueueSender(getQueueSender(queue), queue);
1:     @Override
1:         return new PooledTopicPublisher(getTopicPublisher(topic), topic);
1:     public Session getInternalSession() throws IllegalStateException {
1:             throw new IllegalStateException("The session has already been closed");
1:         return getMessageProducer(null);
1:     }
1: 
1:     public MessageProducer getMessageProducer(Destination destination) throws JMSException {
1:         MessageProducer result = null;
1: 
1:         if (useAnonymousProducers) {
1:             if (producer == null) {
1:                 // Don't allow for duplicate anonymous producers.
1:                 synchronized (this) {
1:                     if (producer == null) {
1:                         producer = getInternalSession().createProducer(null);
1:                     }
1:                 }
1:             }
1: 
1:             result = producer;
1:         } else {
1:             result = getInternalSession().createProducer(destination);
1: 
1:         return result;
1:         return getQueueSender(null);
1:     }
1: 
1:     public QueueSender getQueueSender(Queue destination) throws JMSException {
1:         QueueSender result = null;
1: 
1:         if (useAnonymousProducers) {
1:             if (sender == null) {
1:                 // Don't allow for duplicate anonymous producers.
1:                 synchronized (this) {
1:                     if (sender == null) {
1:                         sender = ((QueueSession) getInternalSession()).createSender(null);
1:                     }
1:                 }
1:             }
1: 
1:             result = sender;
1:         } else {
1:             result = ((QueueSession) getInternalSession()).createSender(destination);
1: 
1:         return result;
1:         return getTopicPublisher(null);
1:     }
1: 
1:     public TopicPublisher getTopicPublisher(Topic destination) throws JMSException {
1:         TopicPublisher result = null;
1: 
1:         if (useAnonymousProducers) {
1:             if (publisher == null) {
1:                 // Don't allow for duplicate anonymous producers.
1:                 synchronized (this) {
1:                     if (publisher == null) {
1:                         publisher = ((TopicSession) getInternalSession()).createPublisher(null);
1:                     }
1:                 }
1:             }
1: 
1:             result = publisher;
1:         } else {
1:             result = ((TopicSession) getInternalSession()).createPublisher(destination);
1: 
1:         return result;
/////////////////////////////////////////////////////////////////////////
1:         // method is invoked when the returned consumer is closed, to avoid memory
1:         // leak in this session class in case many consumers is created
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
1:     /**
1:      * Callback invoked when the consumer is closed.
1:      * <p/>
1:      * This is used to keep track of an explicit closed consumer created by this
1:      * session, by which we know do not need to keep track of the consumer, as
1:      * its already closed.
1:      *
1:      * @param consumer
1:      *            the consumer which is being closed
1:      */
1:     protected void onConsumerClose(MessageConsumer consumer) {
1:         consumers.remove(consumer);
1:     }
commit:4243a2b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.aries.transaction.jms.internal;
1: 
1: import java.io.Serializable;
1: import java.lang.IllegalStateException;
1: import java.util.Iterator;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import javax.jms.*;
1: import javax.transaction.xa.XAResource;
1: 
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: public class PooledSession implements Session, TopicSession, QueueSession {
1:     private static final transient Logger LOG = LoggerFactory.getLogger(PooledSession.class);
1: 
0:     private Session session;
0:     private SessionPool sessionPool;
0:     private MessageProducer messageProducer;
0:     private QueueSender queueSender;
0:     private TopicPublisher topicPublisher;
0:     private boolean transactional = true;
0:     private boolean ignoreClose;
1: 
1:     private final CopyOnWriteArrayList<MessageConsumer> consumers = new CopyOnWriteArrayList<MessageConsumer>();
1:     private final CopyOnWriteArrayList<QueueBrowser> browsers = new CopyOnWriteArrayList<QueueBrowser>();
0:     private final CopyOnWriteArrayList<PooledSessionEventListener> tempDestEventListeners =
0:         new CopyOnWriteArrayList<PooledSessionEventListener>();
0:     private boolean isXa;
1: 
0:     public PooledSession(Session session, SessionPool sessionPool, boolean transactional) {
1:         this.session = session;
1:         this.sessionPool = sessionPool;
1:         this.transactional = transactional;
1:     }
1: 
0:     public void addTempDestEventListener(PooledSessionEventListener listener) {
0:         this.tempDestEventListeners.add(listener);
1:     }
1: 
1:     protected boolean isIgnoreClose() {
1:         return ignoreClose;
1:     }
1: 
1:     protected void setIgnoreClose(boolean ignoreClose) {
1:         this.ignoreClose = ignoreClose;
1:     }
1: 
1:     public void close() throws JMSException {
1:         if (!ignoreClose) {
0:             // TODO a cleaner way to reset??
1: 
1:             boolean invalidate = false;
1:             try {
1:                 // lets reset the session
1:                 getInternalSession().setMessageListener(null);
1: 
1:                 // Close any consumers and browsers that may have been created.
1:                 for (Iterator<MessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:                     MessageConsumer consumer = iter.next();
1:                     consumer.close();
1:                 }
1: 
1:                 for (Iterator<QueueBrowser> iter = browsers.iterator(); iter.hasNext();) {
1:                     QueueBrowser browser = iter.next();
1:                     browser.close();
1:                 }
1: 
1:                 if (transactional && !isXa) {
1:                     try {
1:                         getInternalSession().rollback();
1:                     } catch (JMSException e) {
1:                         invalidate = true;
1:                         LOG.warn("Caught exception trying rollback() when putting session back into the pool, will invalidate. " + e, e);
1:                     }
1:                 }
1:             } catch (JMSException ex) {
1:                 invalidate = true;
1:                 LOG.warn("Caught exception trying close() when putting session back into the pool, will invalidate. " + ex, ex);
1:             } finally {
1:                 consumers.clear();
1:                 browsers.clear();
1:             }
1: 
1:             if (invalidate) {
0:                 // lets close the session and not put the session back into
0:                 // the pool
1:                 if (session != null) {
1:                     try {
1:                         session.close();
1:                     } catch (JMSException e1) {
1:                         LOG.trace("Ignoring exception on close as discarding session: " + e1, e1);
1:                     }
1:                     session = null;
1:                 }
0:                 sessionPool.invalidateSession(this);
1:             } else {
0:                 sessionPool.returnSession(this);
1:             }
1:         }
1:     }
1: 
1:     public void commit() throws JMSException {
1:         getInternalSession().commit();
1:     }
1: 
1:     public BytesMessage createBytesMessage() throws JMSException {
1:         return getInternalSession().createBytesMessage();
1:     }
1: 
1:     public MapMessage createMapMessage() throws JMSException {
1:         return getInternalSession().createMapMessage();
1:     }
1: 
1:     public Message createMessage() throws JMSException {
1:         return getInternalSession().createMessage();
1:     }
1: 
1:     public ObjectMessage createObjectMessage() throws JMSException {
1:         return getInternalSession().createObjectMessage();
1:     }
1: 
1:     public ObjectMessage createObjectMessage(Serializable serializable) throws JMSException {
1:         return getInternalSession().createObjectMessage(serializable);
1:     }
1: 
1:     public Queue createQueue(String s) throws JMSException {
1:         return getInternalSession().createQueue(s);
1:     }
1: 
1:     public StreamMessage createStreamMessage() throws JMSException {
1:         return getInternalSession().createStreamMessage();
1:     }
1: 
1:     public TemporaryQueue createTemporaryQueue() throws JMSException {
1:         TemporaryQueue result;
1: 
1:         result = getInternalSession().createTemporaryQueue();
1: 
1:         // Notify all of the listeners of the created temporary Queue.
0:         for (PooledSessionEventListener listener : this.tempDestEventListeners) {
1:             listener.onTemporaryQueueCreate(result);
1:         }
1: 
1:         return result;
1:     }
1: 
1:     public TemporaryTopic createTemporaryTopic() throws JMSException {
1:         TemporaryTopic result;
1: 
1:         result = getInternalSession().createTemporaryTopic();
1: 
1:         // Notify all of the listeners of the created temporary Topic.
0:         for (PooledSessionEventListener listener : this.tempDestEventListeners) {
1:             listener.onTemporaryTopicCreate(result);
1:         }
1: 
1:         return result;
1:     }
1: 
1:     public void unsubscribe(String s) throws JMSException {
1:         getInternalSession().unsubscribe(s);
1:     }
1: 
1:     public TextMessage createTextMessage() throws JMSException {
1:         return getInternalSession().createTextMessage();
1:     }
1: 
1:     public TextMessage createTextMessage(String s) throws JMSException {
1:         return getInternalSession().createTextMessage(s);
1:     }
1: 
1:     public Topic createTopic(String s) throws JMSException {
1:         return getInternalSession().createTopic(s);
1:     }
1: 
1:     public int getAcknowledgeMode() throws JMSException {
1:         return getInternalSession().getAcknowledgeMode();
1:     }
1: 
1:     public boolean getTransacted() throws JMSException {
1:         return getInternalSession().getTransacted();
1:     }
1: 
1:     public void recover() throws JMSException {
1:         getInternalSession().recover();
1:     }
1: 
1:     public void rollback() throws JMSException {
1:         getInternalSession().rollback();
1:     }
1: 
1:     public XAResource getXAResource() {
1:         if (session == null) {
0:             throw new IllegalStateException("Session is closed");
1:         }
0:         return ((XASession) session).getXAResource();
1:     }
1: 
1:     public Session getSession() {
1:         return this;
1:     }
1: 
1:     public void run() {
1:         if (session != null) {
1:             session.run();
1:         }
1:     }
1: 
1:     // Consumer related methods
1:     // -------------------------------------------------------------------------
1:     public QueueBrowser createBrowser(Queue queue) throws JMSException {
1:         return addQueueBrowser(getInternalSession().createBrowser(queue));
1:     }
1: 
1:     public QueueBrowser createBrowser(Queue queue, String selector) throws JMSException {
1:         return addQueueBrowser(getInternalSession().createBrowser(queue, selector));
1:     }
1: 
1:     public MessageConsumer createConsumer(Destination destination) throws JMSException {
1:         return addConsumer(getInternalSession().createConsumer(destination));
1:     }
1: 
1:     public MessageConsumer createConsumer(Destination destination, String selector) throws JMSException {
1:         return addConsumer(getInternalSession().createConsumer(destination, selector));
1:     }
1: 
1:     public MessageConsumer createConsumer(Destination destination, String selector, boolean noLocal) throws JMSException {
1:         return addConsumer(getInternalSession().createConsumer(destination, selector, noLocal));
1:     }
1: 
1:     public TopicSubscriber createDurableSubscriber(Topic topic, String selector) throws JMSException {
1:         return addTopicSubscriber(getInternalSession().createDurableSubscriber(topic, selector));
1:     }
1: 
1:     public TopicSubscriber createDurableSubscriber(Topic topic, String name, String selector, boolean noLocal) throws JMSException {
1:         return addTopicSubscriber(getInternalSession().createDurableSubscriber(topic, name, selector, noLocal));
1:     }
1: 
1:     public MessageListener getMessageListener() throws JMSException {
1:         return getInternalSession().getMessageListener();
1:     }
1: 
1:     public void setMessageListener(MessageListener messageListener) throws JMSException {
1:         getInternalSession().setMessageListener(messageListener);
1:     }
1: 
1:     public TopicSubscriber createSubscriber(Topic topic) throws JMSException {
1:         return addTopicSubscriber(((TopicSession) getInternalSession()).createSubscriber(topic));
1:     }
1: 
1:     public TopicSubscriber createSubscriber(Topic topic, String selector, boolean local) throws JMSException {
1:         return addTopicSubscriber(((TopicSession) getInternalSession()).createSubscriber(topic, selector, local));
1:     }
1: 
1:     public QueueReceiver createReceiver(Queue queue) throws JMSException {
1:         return addQueueReceiver(((QueueSession) getInternalSession()).createReceiver(queue));
1:     }
1: 
1:     public QueueReceiver createReceiver(Queue queue, String selector) throws JMSException {
1:         return addQueueReceiver(((QueueSession) getInternalSession()).createReceiver(queue, selector));
1:     }
1: 
1:     // Producer related methods
1:     // -------------------------------------------------------------------------
1:     public MessageProducer createProducer(Destination destination) throws JMSException {
0:         return new PooledProducer(getMessageProducer(), destination);
1:     }
1: 
1:     public QueueSender createSender(Queue queue) throws JMSException {
0:         return new PooledQueueSender(getQueueSender(), queue);
1:     }
1: 
1:     public TopicPublisher createPublisher(Topic topic) throws JMSException {
0:         return new PooledTopicPublisher(getTopicPublisher(), topic);
1:     }
1: 
1:     /**
0:      * Callback invoked when the consumer is closed.
0:      * <p/>
0:      * This is used to keep track of an explicit closed consumer created by this
0:      * session, by which we know do not need to keep track of the consumer, as
0:      * its already closed.
1:      *
0:      * @param consumer
0:      *            the consumer which is being closed
1:      */
0:     protected void onConsumerClose(MessageConsumer consumer) {
0:         consumers.remove(consumer);
1:     }
1: 
0:     public Session getInternalSession() throws JMSException {
1:         if (session == null) {
0:             throw new JMSException("The session has already been closed");
1:         }
1:         return session;
1:     }
1: 
1:     public MessageProducer getMessageProducer() throws JMSException {
0:         if (messageProducer == null) {
0:             messageProducer = getInternalSession().createProducer(null);
1:         }
0:         return messageProducer;
1:     }
1: 
1:     public QueueSender getQueueSender() throws JMSException {
0:         if (queueSender == null) {
0:             queueSender = ((QueueSession) getInternalSession()).createSender(null);
1:         }
0:         return queueSender;
1:     }
1: 
1:     public TopicPublisher getTopicPublisher() throws JMSException {
0:         if (topicPublisher == null) {
0:             topicPublisher = ((TopicSession) getInternalSession()).createPublisher(null);
1:         }
0:         return topicPublisher;
1:     }
1: 
1:     private QueueBrowser addQueueBrowser(QueueBrowser browser) {
1:         browsers.add(browser);
1:         return browser;
1:     }
1: 
1:     private MessageConsumer addConsumer(MessageConsumer consumer) {
1:         consumers.add(consumer);
1:         // must wrap in PooledMessageConsumer to ensure the onConsumerClose
0:         // method is invoked
0:         // when the returned consumer is closed, to avoid memory leak in this
0:         // session class
0:         // in case many consumers is created
1:         return new PooledMessageConsumer(this, consumer);
1:     }
1: 
1:     private TopicSubscriber addTopicSubscriber(TopicSubscriber subscriber) {
1:         consumers.add(subscriber);
1:         return subscriber;
1:     }
1: 
1:     private QueueReceiver addQueueReceiver(QueueReceiver receiver) {
1:         consumers.add(receiver);
1:         return receiver;
1:     }
1: 
1:     public void setIsXa(boolean isXa) {
1:         this.isXa = isXa;
1:     }
1: 
1:     public String toString() {
1:         return "PooledSession { " + session + " }";
1:     }
1: }
============================================================================