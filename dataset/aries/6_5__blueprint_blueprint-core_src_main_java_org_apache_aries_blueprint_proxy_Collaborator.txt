1:d54488c: /*
1:d54488c:  * Licensed to the Apache Software Foundation (ASF) under one
1:d54488c:  * or more contributor license agreements.  See the NOTICE file
1:d54488c:  * distributed with this work for additional information
1:d54488c:  * regarding copyright ownership.  The ASF licenses this file
1:d54488c:  * to you under the Apache License, Version 2.0 (the
1:d54488c:  * "License"); you may not use this file except in compliance
1:d54488c:  * with the License.  You may obtain a copy of the License at
3:d54488c:  *
1:d54488c:  *   http://www.apache.org/licenses/LICENSE-2.0
1:d54488c:  *
1:d54488c:  * Unless required by applicable law or agreed to in writing,
1:d54488c:  * software distributed under the License is distributed on an
1:d54488c:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:d54488c:  * KIND, either express or implied.  See the License for the
1:d54488c:  * specific language governing permissions and limitations
1:d54488c:  * under the License.
1:d54488c:  */
1:d54488c: package org.apache.aries.blueprint.proxy;
13:d54488c: 
1:d54488c: import java.io.Serializable;
1:d54488c: import java.lang.reflect.Method;
1:285f3a8: import java.util.ArrayDeque;
1:285f3a8: import java.util.Deque;
1:d54488c: import java.util.List;
1:d54488c: 
1:d54488c: import org.apache.aries.blueprint.Interceptor;
1:69e59b8: import org.apache.aries.proxy.InvocationListener;
1:d54488c: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:d54488c: import org.slf4j.Logger;
1:d54488c: import org.slf4j.LoggerFactory;
1:d54488c: 
1:d54488c: /**
1:d54488c:  * A collaborator which ensures preInvoke and postInvoke occur before and after
1:d54488c:  * method invocation
1:d54488c:  */
1:69e59b8: public class Collaborator implements InvocationListener, Serializable {
1:d54488c: 
1:d54488c:     /** Serial version UID for this class */
1:d54488c:     private static final long serialVersionUID = -58189302118314469L;
1:d54488c: 
1:d54488c:     private static final Logger LOGGER = LoggerFactory
1:d54488c:             .getLogger(Collaborator.class);
1:d54488c: 
1:d54488c:     private transient List<Interceptor> interceptors = null;
1:d54488c:     private transient ComponentMetadata cm = null;
1:d54488c: 
1:24455ce:     public Collaborator(ComponentMetadata cm, List<Interceptor> interceptors) {
1:d54488c:         this.cm = cm;
1:d54488c:         this.interceptors = interceptors;
18:d54488c:     }
1:071e3fe: 
1:d54488c:     /**
1:d54488c:      * Invoke the preCall method on the interceptor
1:d54488c:      * 
1:69e59b8:      * @param o
1:69e59b8:      *            : The Object being invoked
1:d54488c:      * @param m
3:d54488c:      *            : method
1:d54488c:      * @param parameters
1:d54488c:      *            : method paramters
2:d54488c:      * @throws Throwable
1:d54488c:      */
1:69e59b8:     public Object preInvoke(Object o, Method m, Object[] parameters)
5:d54488c:             throws Throwable {
1:285f3a8:         Deque<StackElement> stack = new ArrayDeque<StackElement>(interceptors.size());
1:69e59b8:         if (interceptors != null) {
1:69e59b8:           try{
1:69e59b8:             for (Interceptor im : interceptors) {
1:d54488c:                 Collaborator.StackElement se = new StackElement(im);
1:6a4e3c8: 
1:d54488c:                 // should we do this before or after the preCall ?
1:69e59b8:                 stack.push(se);
1:d54488c: 
1:d54488c:                 // allow exceptions to propagate
1:d54488c:                 se.setPreCallToken(im.preCall(cm, m, parameters));
1:24455ce:             }
1:69e59b8:           } catch (Throwable t) {
1:69e59b8:             postInvokeExceptionalReturn(stack, o, m, t);
1:69e59b8:             throw t;
1:69e59b8:           }
1:d54488c:         }
1:69e59b8:         return stack;
1:d54488c:     }
1:d54488c: 
1:d54488c:     /**
1:d54488c:      * Called when the method is called and returned normally
1:d54488c:      */
1:69e59b8:     public void postInvoke(Object token, Object o, Method method, 
1:69e59b8:          Object returnType) throws Throwable {
1:69e59b8:         
1:285f3a8:         Deque<StackElement> calledInterceptors =
1:285f3a8:                     (Deque<StackElement>) token;
1:69e59b8:         if(calledInterceptors != null) {
1:69e59b8:             while (!calledInterceptors.isEmpty()) {
1:69e59b8:                 Collaborator.StackElement se = calledInterceptors.pop();
1:69e59b8:                 try {
1:69e59b8:                     se.interceptor.postCallWithReturn(cm, method, returnType, se
1:69e59b8:                             .getPreCallToken());
1:69e59b8:                 } catch (Throwable t) {
1:69e59b8:                     LOGGER.debug("postCallInterceptorWithReturn", t);
1:69e59b8:                     // propagate this to invoke ... further interceptors will be
1:69e59b8:                     // called via the postCallInterceptorWithException method
1:69e59b8:                     throw t;
1:69e59b8:                 }
1:69e59b8:             } // end while
1:69e59b8:         }
1:24455ce:     }
1:24455ce: 
1:d54488c:     /**
1:d54488c:      * Called when the method is called and returned with an exception
1:d54488c:      */
1:69e59b8:     public void postInvokeExceptionalReturn(Object token, Object o, Method method,
1:69e59b8:                  Throwable exception) throws Throwable {
1:d54488c:         Throwable tobeRethrown = null;
1:285f3a8:         Deque<StackElement> calledInterceptors =
1:285f3a8:           (Deque<StackElement>) token;
2:d54488c:         while (!calledInterceptors.isEmpty()) {
2:d54488c:             Collaborator.StackElement se = calledInterceptors.pop();
1:24455ce: 
1:24455ce:             try {
1:d54488c:                 se.interceptor.postCallWithException(cm, method, exception, se
2:d54488c:                         .getPreCallToken());
2:d54488c:             } catch (Throwable t) {
1:d54488c:                 // log the exception
1:8b7b630:                 LOGGER.debug("postCallInterceptorWithException", t);
1:8b7b630:                 if (tobeRethrown == null) {
1:d54488c:                     tobeRethrown = t;
1:24455ce:                 } else {
1:8b7b630:                   LOGGER.warn("Discarding post-call with interceptor exception", t);
1:24455ce:                 }
1:8b7b630:             }
1:d54488c: 
2:d54488c:         } // end while
1:d54488c: 
1:d54488c:         if (tobeRethrown != null)
1:d54488c:             throw tobeRethrown;
1:d54488c:     }
1:d54488c: 
1:d54488c:     // info to store on interceptor stack during invoke
1:d54488c:     private static class StackElement {
1:67afa4f:         private final Interceptor interceptor;
1:d54488c:         private Object preCallToken;
1:d54488c: 
1:d54488c:         private StackElement(Interceptor i) {
1:d54488c:             interceptor = i;
1:d54488c:         }
1:d54488c: 
1:d54488c:         private void setPreCallToken(Object preCallToken) {
1:d54488c:             this.preCallToken = preCallToken;
1:d54488c:         }
1:d54488c: 
1:d54488c:         private Object getPreCallToken() {
1:d54488c:             return preCallToken;
1:d54488c:         }
1:d54488c: 
1:d54488c:     }
1:d54488c: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:8980414
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:285f3a8
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayDeque;
1: import java.util.Deque;
/////////////////////////////////////////////////////////////////////////
1:         Deque<StackElement> stack = new ArrayDeque<StackElement>(interceptors.size());
/////////////////////////////////////////////////////////////////////////
1:         Deque<StackElement> calledInterceptors =
1:                     (Deque<StackElement>) token;
/////////////////////////////////////////////////////////////////////////
1:         Deque<StackElement> calledInterceptors =
1:           (Deque<StackElement>) token;
commit:46b3454
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Proxy;
/////////////////////////////////////////////////////////////////////////
0:             if (AsmInterceptorWrapper.isProxyClass(args[0].getClass())
0:                     || Proxy.isProxyClass(args[0].getClass())) {
commit:071e3fe
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Callable;
/////////////////////////////////////////////////////////////////////////
0:     final Callable<?> object;
0:             final Callable<?> delegateObj) {
/////////////////////////////////////////////////////////////////////////
0:                     result = method.invoke(object.call(), args);
/////////////////////////////////////////////////////////////////////////
0:             if (AsmInterceptorWrapper.isProxyClass(args[0].getClass())) {
/////////////////////////////////////////////////////////////////////////
1: 
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:69e59b8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.InvocationListener;
/////////////////////////////////////////////////////////////////////////
1: public class Collaborator implements InvocationListener, Serializable {
/////////////////////////////////////////////////////////////////////////
1:      * @param o
1:      *            : The Object being invoked
1:     public Object preInvoke(Object o, Method m, Object[] parameters)
0:         Stack<Collaborator.StackElement> stack = new Stack<Collaborator.StackElement>();
1:         if (interceptors != null) {
1:           try{
1:             for (Interceptor im : interceptors) {
1:                 stack.push(se);
1:           } catch (Throwable t) {
1:             postInvokeExceptionalReturn(stack, o, m, t);
1:             throw t;
1:           }
1:         return stack;
/////////////////////////////////////////////////////////////////////////
1:     public void postInvoke(Object token, Object o, Method method, 
1:          Object returnType) throws Throwable {
1:         
0:         Stack<Collaborator.StackElement> calledInterceptors = 
0:                     (Stack<Collaborator.StackElement>) token;
1:         if(calledInterceptors != null) {
1:             while (!calledInterceptors.isEmpty()) {
1:                 Collaborator.StackElement se = calledInterceptors.pop();
1:                 try {
1:                     se.interceptor.postCallWithReturn(cm, method, returnType, se
1:                             .getPreCallToken());
1:                 } catch (Throwable t) {
1:                     LOGGER.debug("postCallInterceptorWithReturn", t);
1:                     // propagate this to invoke ... further interceptors will be
1:                     // called via the postCallInterceptorWithException method
1:                     throw t;
1:                 }
1:             } // end while
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public void postInvokeExceptionalReturn(Object token, Object o, Method method,
1:                  Throwable exception) throws Throwable {
0:         Stack<Collaborator.StackElement> calledInterceptors = 
0:           (Stack<Collaborator.StackElement>) token;
/////////////////////////////////////////////////////////////////////////
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:24455ce
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.proxy.InvocationHandlerWrapper;
/////////////////////////////////////////////////////////////////////////
0: public class Collaborator implements InvocationHandlerWrapper, Serializable {
/////////////////////////////////////////////////////////////////////////
1:     public Collaborator(ComponentMetadata cm, List<Interceptor> interceptors) {
/////////////////////////////////////////////////////////////////////////
0:     public Object invoke(Object proxy, Method method, Object[] args, InvocationHandler target)
0:         Stack<Collaborator.StackElement> calledInterceptors = new Stack<Collaborator.StackElement>();
0:         boolean inInvoke = false;
1:         try {
0:             preCallInterceptor(interceptors, cm, method, args,
0:                     calledInterceptors);
0:             inInvoke = true;
0:             toReturn = target.invoke(proxy, method, args);
0:             inInvoke = false;
0:             postCallInterceptorWithReturn(cm, method, toReturn,
0:                     calledInterceptors);
1: 
0:         } catch (Throwable e) {
0:             // whether the the exception is an error is an application decision
0:             LOGGER.debug("invoke", e);
1: 
0:             // if we catch an exception we decide carefully which one to
0:             // throw onwards
0:             Throwable exceptionToRethrow = null;
0:             // if the exception came from a precall or postcall interceptor
0:             // we will rethrow it
0:             // after we cycle through the rest of the interceptors using
0:             // postCallInterceptorWithException
0:             if (!inInvoke) {
0:                 exceptionToRethrow = e;
0:             // if the exception didn't come from precall or postcall then it
0:             // came from invoke
0:             // we will rethrow this exception if it is not a runtime
0:             // exception
0:             else {
0:                 if (!(e instanceof RuntimeException)) {
0:                     exceptionToRethrow = e;
1:                 }
1:             }
0:                 postCallInterceptorWithException(cm, method, e,
0:             } catch (Exception f) {
0:                 // we caught an exception from
0:                 // logger.catching("invoke", f);
0:                 // if we haven't already chosen an exception to rethrow then
0:                 // we will throw this exception
0:                     exceptionToRethrow = f;
1:                 } else {
0:                   LOGGER.warn("Discarding post-call with interceptor exception", f);
0:             // if we made it this far without choosing an exception we
0:             // should throw e
0:             if (exceptionToRethrow == null) {
0:                 exceptionToRethrow = e;
0:             } else if (exceptionToRethrow != e) {
0:               LOGGER.warn("Discarding initial exception", e);
1:             }
0:             throw exceptionToRethrow;
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:1f39e3c
/////////////////////////////////////////////////////////////////////////
0:                 } else if (exceptionToRethrow != e) {
commit:8b7b630
/////////////////////////////////////////////////////////////////////////
0:                     } else {
0:                       LOGGER.warn("Discarding post-call with interceptor exception", f);
0:                 } else {
0:                   LOGGER.warn("Discarding initial exception", e);
/////////////////////////////////////////////////////////////////////////
1:                 LOGGER.debug("postCallInterceptorWithException", t);
1:                 if (tobeRethrown == null) {
0:                 } else {
1:                   LOGGER.warn("Discarding post-call with interceptor exception", t);
1:                 }
commit:67afa4f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 // whether the the exception is an error is an application decision
0:                 LOGGER.debug("invoke", e);
/////////////////////////////////////////////////////////////////////////
0:                 LOGGER.debug("postCallInterceptorWithReturn", t);
/////////////////////////////////////////////////////////////////////////
0:      *            : exception thrown
/////////////////////////////////////////////////////////////////////////
1:         private final Interceptor interceptor;
commit:dcf950a
/////////////////////////////////////////////////////////////////////////
0:         } else if (method.getName().equals("finalize") && method.getParameterTypes().length == 0) {
0:             // special case finalize, don't route through to delegate because that will get its own call
0:             toReturn = null;
commit:b664100
/////////////////////////////////////////////////////////////////////////
0:             } catch (Throwable e) {
0:                 Throwable exceptionToRethrow = null;
/////////////////////////////////////////////////////////////////////////
0:             Method method, Throwable exception,
author:Andrew Osborne
-------------------------------------------------------------------------------
commit:6a4e3c8
/////////////////////////////////////////////////////////////////////////
1:         
0:         // Unwrap calls for equals
0:             // replace the wrapper with the unwrapped object, to
0:             // enable object identity etc to function.
0:                 // unwrap in the WrapperedObject case
0:             } else if (AsmInterceptorWrapper.isProxyClass(args[0].getClass())) {
0:                 // unwrap in the asm case
0:                 args[0] = AsmInterceptorWrapper.unwrapObject(args[0]);
commit:70c6870
/////////////////////////////////////////////////////////////////////////
0:         if (method.getName().equals("unwrapObject")
commit:d54488c
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.blueprint.proxy;
1: 
1: import java.io.Serializable;
0: import java.lang.reflect.InvocationHandler;
0: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.util.List;
0: import java.util.Stack;
1: 
1: import org.apache.aries.blueprint.Interceptor;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A collaborator which ensures preInvoke and postInvoke occur before and after
1:  * method invocation
1:  */
0: class Collaborator implements InvocationHandler, Serializable {
1: 
1:     /** Serial version UID for this class */
1:     private static final long serialVersionUID = -58189302118314469L;
1: 
1:     private static final Logger LOGGER = LoggerFactory
1:             .getLogger(Collaborator.class);
1: 
0:     /** The invocation handler to call */
0:     final InvocationHandler delegate;
0:     final Object object;
1: 
1:     private transient List<Interceptor> interceptors = null;
1:     private transient ComponentMetadata cm = null;
0:     private transient boolean sorted = false;
1: 
0:     Collaborator(ComponentMetadata cm, List<Interceptor> interceptors,
0:             final Object delegateObj) {
1:         this.cm = cm;
0:         this.object = delegateObj;
0:         this.delegate = new InvocationHandler() {
0:             private void onUnexpectedException(Throwable cause) {
0:                 throw new Error("Unreachable catch statement reached", cause);
1:             }
1: 
0:             public Object invoke(Object proxy, Method method, Object[] args)
1:                     throws Throwable {
0:                 Object result;
0:                 try {
0:                     result = method.invoke(object, args);
0:                 } catch (InvocationTargetException ite) {
0:                     // We are invisible, so unwrap and throw the cause as
0:                     // though we called the method directly.
0:                     throw ite.getCause();
0:                 } catch (IllegalAccessException e) {
0:                     onUnexpectedException(e);
0:                     return null;
0:                 } catch (IllegalArgumentException e) {
0:                     onUnexpectedException(e);
0:                     return null;
0:                 } catch (SecurityException e) {
0:                     onUnexpectedException(e);
0:                     return null;
1:                 }
1: 
0:                 return result;
1:             }
0:         };
1:         this.interceptors = interceptors;
1:     }
1: 
1:     /**
1:      * Invoke the preCall method on the interceptor
1:      * 
0:      * @param cm
0:      *            : component Metadata
1:      * @param m
1:      *            : method
1:      * @param parameters
1:      *            : method paramters
1:      * @throws Throwable
1:      */
0:     private void preCallInterceptor(List<Interceptor> interceptorList,
0:             ComponentMetadata cm, Method m, Object[] parameters,
0:             Stack<Collaborator.StackElement> calledInterceptors)
1:             throws Throwable {
0:         if ((interceptors != null) && !(interceptors.isEmpty())) {
0:             for (Interceptor im : interceptorList) {
1:                 Collaborator.StackElement se = new StackElement(im);
1: 
1:                 // should we do this before or after the preCall ?
0:                 calledInterceptors.push(se);
1: 
1:                 // allow exceptions to propagate
1:                 se.setPreCallToken(im.preCall(cm, m, parameters));
1:             }
1:         }
1:     }
1: 
0:     public Object invoke(Object proxy, Method method, Object[] args)
1:             throws Throwable {
0:         Object toReturn = null;
1: 
0:         // Added method to unwrap from the collaborator.
0:         if (method.getName().equals("getWrappedObject")
0:                 && method.getDeclaringClass() == WrapperedObject.class) {
0:             toReturn = object;
0:         } else
0:         // Unwrap calls for equals 
0:         if (method.getName().equals("equals")
0:                 && method.getDeclaringClass() == Object.class) {
0:             if (args[0] instanceof WrapperedObject) {
0:                 //replace the wrapper with the unwrapped object, to 
0:                 //enable object identity etc to function.
0:                 args[0] = ((WrapperedObject) args[0]).unwrapObject();
1:             }
0:             toReturn = delegate.invoke(proxy, method, args);
0:         } else 
0:         // Proxy the call through to the delegate, wrapping call in 
0:         // interceptor invocations.
0:         {
0:             Stack<Collaborator.StackElement> calledInterceptors = new Stack<Collaborator.StackElement>();
0:             boolean inInvoke = false;
0:             try {
0:                 preCallInterceptor(interceptors, cm, method, args,
0:                         calledInterceptors);
0:                 inInvoke = true;
0:                 toReturn = delegate.invoke(proxy, method, args);
0:                 inInvoke = false;
0:                 postCallInterceptorWithReturn(cm, method, toReturn,
0:                         calledInterceptors);
1: 
0:             } catch (Exception e) {
0:                 // log the exception e
0:                 LOGGER.error("invoke", e);
1: 
0:                 // if we catch an exception we decide carefully which one to
0:                 // throw onwards
0:                 Exception exceptionToRethrow = null;
0:                 // if the exception came from a precall or postcall interceptor
0:                 // we will rethrow it
0:                 // after we cycle through the rest of the interceptors using
0:                 // postCallInterceptorWithException
0:                 if (!inInvoke) {
0:                     exceptionToRethrow = e;
1:                 }
0:                 // if the exception didn't come from precall or postcall then it
0:                 // came from invoke
0:                 // we will rethrow this exception if it is not a runtime
0:                 // exception
0:                 else {
0:                     if (!(e instanceof RuntimeException)) {
0:                         exceptionToRethrow = e;
1:                     }
1:                 }
0:                 try {
0:                     postCallInterceptorWithException(cm, method, e,
0:                             calledInterceptors);
0:                 } catch (Exception f) {
0:                     // we caught an exception from
0:                     // postCallInterceptorWithException
0:                     // logger.catching("invoke", f);
0:                     // if we haven't already chosen an exception to rethrow then
0:                     // we will throw this exception
0:                     if (exceptionToRethrow == null) {
0:                         exceptionToRethrow = f;
1:                     }
1:                 }
0:                 // if we made it this far without choosing an exception we
0:                 // should throw e
0:                 if (exceptionToRethrow == null) {
0:                     exceptionToRethrow = e;
1:                 }
0:                 throw exceptionToRethrow;
1:             }
1:         }
0:         return toReturn;
1:     }
1: 
1:     /**
1:      * Called when the method is called and returned normally
1:      * 
0:      * @param cm
0:      *            : component metadata
0:      * @param method
1:      *            : method
0:      * @param returnType
0:      *            : return type
1:      * @throws Throwable
1:      */
0:     private void postCallInterceptorWithReturn(ComponentMetadata cm,
0:             Method method, Object returnType,
0:             Stack<Collaborator.StackElement> calledInterceptors)
1:             throws Throwable {
1: 
1:         while (!calledInterceptors.isEmpty()) {
1:             Collaborator.StackElement se = calledInterceptors.pop();
0:             try {
0:                 se.interceptor.postCallWithReturn(cm, method, returnType, se
1:                         .getPreCallToken());
1:             } catch (Throwable t) {
0:                 LOGGER.error("postCallInterceptorWithReturn", t);
0:                 // propagate this to invoke ... further interceptors will be
0:                 // called via the postCallInterceptorWithException method
0:                 throw t;
1:             }
1:         } // end while
1:     }
1: 
1:     /**
1:      * Called when the method is called and returned with an exception
1:      * 
0:      * @param cm
0:      *            : component metadata
0:      * @param method
1:      *            : method
0:      * @param exception
0:      *            : exception throwed
1:      */
0:     private void postCallInterceptorWithException(ComponentMetadata cm,
0:             Method method, Exception exception,
0:             Stack<Collaborator.StackElement> calledInterceptors)
1:             throws Throwable {
1:         Throwable tobeRethrown = null;
1:         while (!calledInterceptors.isEmpty()) {
1:             Collaborator.StackElement se = calledInterceptors.pop();
1: 
0:             try {
1:                 se.interceptor.postCallWithException(cm, method, exception, se
1:                         .getPreCallToken());
1:             } catch (Throwable t) {
1:                 // log the exception
0:                 LOGGER.error("postCallInterceptorWithException", t);
0:                 if (tobeRethrown == null)
1:                     tobeRethrown = t;
1:             }
1: 
1:         } // end while
1: 
1:         if (tobeRethrown != null)
1:             throw tobeRethrown;
1:     }
1: 
1:     // info to store on interceptor stack during invoke
1:     private static class StackElement {
0:         private Interceptor interceptor;
1:         private Object preCallToken;
1: 
1:         private StackElement(Interceptor i) {
1:             interceptor = i;
1:         }
1: 
1:         private void setPreCallToken(Object preCallToken) {
1:             this.preCallToken = preCallToken;
1:         }
1: 
1:         private Object getPreCallToken() {
1:             return preCallToken;
1:         }
1: 
1:     }
1: }
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.blueprint.proxy;
0: 
0: import java.io.Serializable;
0: import java.lang.reflect.InvocationHandler;
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Method;
0: import java.util.List;
0: import java.util.Stack;
0: 
0: import org.apache.aries.blueprint.Interceptor;
0: import org.osgi.service.blueprint.reflect.ComponentMetadata;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: /**
0:  * A collaborator which ensures preInvoke and postInvoke occur before and after
0:  * method invocation
0:  */
0: class Collaborator implements InvocationHandler, Serializable {
0: 
0:     /** Serial version UID for this class */
0:     private static final long serialVersionUID = -58189302118314469L;
0: 
0:     private static final Logger LOGGER = LoggerFactory
0:             .getLogger(Collaborator.class);
0: 
0:     /** The invocation handler to call */
0:     final InvocationHandler delegate;
0:     final Object object;
0: 
0:     private transient List<Interceptor> interceptors = null;
0:     private transient ComponentMetadata cm = null;
0:     private transient boolean sorted = false;
0: 
0:     Collaborator(ComponentMetadata cm, List<Interceptor> interceptors,
0:             final Object delegateObj) {
0:         this.cm = cm;
0:         this.object = delegateObj;
0:         this.delegate = new InvocationHandler() {
0:             private void onUnexpectedException(Throwable cause) {
0:                 throw new Error("Unreachable catch statement reached", cause);
0:             }
0: 
0:             public Object invoke(Object proxy, Method method, Object[] args)
0:                     throws Throwable {
0:                 Object result;
0:                 try {
0:                     result = method.invoke(object, args);
0:                 } catch (InvocationTargetException ite) {
0:                     // We are invisible, so unwrap and throw the cause as
0:                     // though we called the method directly.
0:                     throw ite.getCause();
0:                 } catch (IllegalAccessException e) {
0:                     onUnexpectedException(e);
0:                     return null;
0:                 } catch (IllegalArgumentException e) {
0:                     onUnexpectedException(e);
0:                     return null;
0:                 } catch (SecurityException e) {
0:                     onUnexpectedException(e);
0:                     return null;
0:                 }
0: 
0:                 return result;
0:             }
0:         };
0:         this.interceptors = interceptors;
0:     }
0: 
0:     /**
0:      * Invoke the preCall method on the interceptor
0:      * 
0:      * @param cm
0:      *            : component Metadata
0:      * @param m
0:      *            : method
0:      * @param parameters
0:      *            : method paramters
0:      * @throws Throwable
0:      */
0:     private void preCallInterceptor(List<Interceptor> interceptorList,
0:             ComponentMetadata cm, Method m, Object[] parameters,
0:             Stack<Collaborator.StackElement> calledInterceptors)
0:             throws Throwable {
0:         if ((interceptors != null) && !(interceptors.isEmpty())) {
0:             for (Interceptor im : interceptorList) {
0:                 Collaborator.StackElement se = new StackElement(im);
0: 
0:                 // should we do this before or after the preCall ?
0:                 calledInterceptors.push(se);
0: 
0:                 // allow exceptions to propagate
0:                 se.setPreCallToken(im.preCall(cm, m, parameters));
0:             }
0:         }
0:     }
0: 
0:     public Object invoke(Object proxy, Method method, Object[] args)
0:             throws Throwable {
0:         Object toReturn = null;
0: 
0:         // Added method to unwrap from the collaborator.
0:         if (method.getName().equals("unwrapObject")
0:                 && method.getDeclaringClass() == WrapperedObject.class) {
0:             toReturn = object;
0:         } else
0:         // Unwrap calls for equals 
0:         if (method.getName().equals("equals")
0:                 && method.getDeclaringClass() == Object.class) {
0:             if (args[0] instanceof WrapperedObject) {
0:                 //replace the wrapper with the unwrapped object, to 
0:                 //enable object identity etc to function.
0:                 args[0] = ((WrapperedObject) args[0]).unwrapObject();
0:             }
0:             toReturn = delegate.invoke(proxy, method, args);
0:         } else 
0:         // Proxy the call through to the delegate, wrapping call in 
0:         // interceptor invocations.
0:         {
0:             Stack<Collaborator.StackElement> calledInterceptors = new Stack<Collaborator.StackElement>();
0:             boolean inInvoke = false;
0:             try {
0:                 preCallInterceptor(interceptors, cm, method, args,
0:                         calledInterceptors);
0:                 inInvoke = true;
0:                 toReturn = delegate.invoke(proxy, method, args);
0:                 inInvoke = false;
0:                 postCallInterceptorWithReturn(cm, method, toReturn,
0:                         calledInterceptors);
0: 
0:             } catch (Exception e) {
0:                 // log the exception e
0:                 LOGGER.error("invoke", e);
0: 
0:                 // if we catch an exception we decide carefully which one to
0:                 // throw onwards
0:                 Exception exceptionToRethrow = null;
0:                 // if the exception came from a precall or postcall interceptor
0:                 // we will rethrow it
0:                 // after we cycle through the rest of the interceptors using
0:                 // postCallInterceptorWithException
0:                 if (!inInvoke) {
0:                     exceptionToRethrow = e;
0:                 }
0:                 // if the exception didn't come from precall or postcall then it
0:                 // came from invoke
0:                 // we will rethrow this exception if it is not a runtime
0:                 // exception
0:                 else {
0:                     if (!(e instanceof RuntimeException)) {
0:                         exceptionToRethrow = e;
0:                     }
0:                 }
0:                 try {
0:                     postCallInterceptorWithException(cm, method, e,
0:                             calledInterceptors);
0:                 } catch (Exception f) {
0:                     // we caught an exception from
0:                     // postCallInterceptorWithException
0:                     // logger.catching("invoke", f);
0:                     // if we haven't already chosen an exception to rethrow then
0:                     // we will throw this exception
0:                     if (exceptionToRethrow == null) {
0:                         exceptionToRethrow = f;
0:                     }
0:                 }
0:                 // if we made it this far without choosing an exception we
0:                 // should throw e
0:                 if (exceptionToRethrow == null) {
0:                     exceptionToRethrow = e;
0:                 }
0:                 throw exceptionToRethrow;
0:             }
0:         }
0:         return toReturn;
0:     }
0: 
0:     /**
0:      * Called when the method is called and returned normally
0:      * 
0:      * @param cm
0:      *            : component metadata
0:      * @param method
0:      *            : method
0:      * @param returnType
0:      *            : return type
0:      * @throws Throwable
0:      */
0:     private void postCallInterceptorWithReturn(ComponentMetadata cm,
0:             Method method, Object returnType,
0:             Stack<Collaborator.StackElement> calledInterceptors)
0:             throws Throwable {
0: 
0:         while (!calledInterceptors.isEmpty()) {
0:             Collaborator.StackElement se = calledInterceptors.pop();
0:             try {
0:                 se.interceptor.postCallWithReturn(cm, method, returnType, se
0:                         .getPreCallToken());
0:             } catch (Throwable t) {
0:                 LOGGER.error("postCallInterceptorWithReturn", t);
0:                 // propagate this to invoke ... further interceptors will be
0:                 // called via the postCallInterceptorWithException method
0:                 throw t;
0:             }
0:         } // end while
0:     }
0: 
0:     /**
0:      * Called when the method is called and returned with an exception
0:      * 
0:      * @param cm
0:      *            : component metadata
0:      * @param method
0:      *            : method
0:      * @param exception
0:      *            : exception throwed
0:      */
0:     private void postCallInterceptorWithException(ComponentMetadata cm,
0:             Method method, Exception exception,
0:             Stack<Collaborator.StackElement> calledInterceptors)
0:             throws Throwable {
0:         Throwable tobeRethrown = null;
0:         while (!calledInterceptors.isEmpty()) {
0:             Collaborator.StackElement se = calledInterceptors.pop();
0: 
0:             try {
0:                 se.interceptor.postCallWithException(cm, method, exception, se
0:                         .getPreCallToken());
0:             } catch (Throwable t) {
0:                 // log the exception
0:                 LOGGER.error("postCallInterceptorWithException", t);
0:                 if (tobeRethrown == null)
0:                     tobeRethrown = t;
0:             }
0: 
0:         } // end while
0: 
0:         if (tobeRethrown != null)
0:             throw tobeRethrown;
0:     }
0: 
0:     // info to store on interceptor stack during invoke
0:     private static class StackElement {
0:         private Interceptor interceptor;
0:         private Object preCallToken;
0: 
0:         private StackElement(Interceptor i) {
0:             interceptor = i;
0:         }
0: 
0:         private void setPreCallToken(Object preCallToken) {
0:             this.preCallToken = preCallToken;
0:         }
0: 
0:         private Object getPreCallToken() {
0:             return preCallToken;
0:         }
0: 
0:     }
============================================================================