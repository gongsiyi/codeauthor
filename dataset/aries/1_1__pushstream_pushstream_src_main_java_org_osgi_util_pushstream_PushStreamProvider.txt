1:7fa86e8: /*
1:7fa86e8:  * Copyright (c) OSGi Alliance (2015). All Rights Reserved.
1:7fa86e8:  * 
1:7fa86e8:  * Licensed under the Apache License, Version 2.0 (the "License");
1:7fa86e8:  * you may not use this file except in compliance with the License.
1:7fa86e8:  * You may obtain a copy of the License at
1:7fa86e8:  *
1:7fa86e8:  *      http://www.apache.org/licenses/LICENSE-2.0
1:7fa86e8:  *
1:7fa86e8:  * Unless required by applicable law or agreed to in writing, software
1:7fa86e8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7fa86e8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7fa86e8:  * See the License for the specific language governing permissions and
1:7fa86e8:  * limitations under the License.
1:7fa86e8:  */
1:7fa86e8: 
1:7fa86e8: package org.osgi.util.pushstream;
1:7fa86e8: 
1:7fa86e8: import static java.util.concurrent.TimeUnit.MILLISECONDS;
1:7fa86e8: import static org.apache.aries.pushstream.AbstractPushStreamImpl.State.CLOSED;
1:7fa86e8: import static org.osgi.util.pushstream.PushEvent.data;
1:7fa86e8: import static org.osgi.util.pushstream.PushEvent.error;
1:7fa86e8: import static org.osgi.util.pushstream.PushbackPolicyOption.LINEAR;
1:7fa86e8: import static org.osgi.util.pushstream.QueuePolicyOption.FAIL;
1:7fa86e8: 
1:7fa86e8: import java.util.Iterator;
1:7fa86e8: import java.util.concurrent.ArrayBlockingQueue;
1:7fa86e8: import java.util.concurrent.BlockingQueue;
1:7fa86e8: import java.util.concurrent.Executor;
1:7fa86e8: import java.util.concurrent.ExecutorService;
1:7fa86e8: import java.util.concurrent.Executors;
1:7fa86e8: import java.util.concurrent.ScheduledExecutorService;
1:7fa86e8: import java.util.concurrent.atomic.AtomicBoolean;
1:7fa86e8: import java.util.concurrent.locks.Lock;
1:7fa86e8: import java.util.concurrent.locks.ReentrantLock;
1:7fa86e8: import java.util.function.Function;
1:7fa86e8: import java.util.stream.Stream;
1:7fa86e8: 
1:7fa86e8: import org.apache.aries.pushstream.BufferedPushStreamImpl;
1:7fa86e8: import org.apache.aries.pushstream.SimplePushEventSourceImpl;
1:7fa86e8: import org.apache.aries.pushstream.UnbufferedPushStreamImpl;
1:7fa86e8: 
1:7fa86e8: /**
1:7fa86e8:  * A factory for {@link PushStream} instances, and utility methods for handling
1:7fa86e8:  * {@link PushEventSource}s and {@link PushEventConsumer}s
1:7fa86e8:  */
1:7fa86e8: public final class PushStreamProvider {
1:7fa86e8: 
1:7fa86e8: 	private final Lock					lock	= new ReentrantLock(true);
1:7fa86e8: 
1:7fa86e8: 	private int							schedulerReferences;
1:7fa86e8: 
1:7fa86e8: 	private ScheduledExecutorService	scheduler;
1:7fa86e8: 
1:7fa86e8: 	private ScheduledExecutorService acquireScheduler() {
1:7fa86e8: 		try {
1:7fa86e8: 			lock.lockInterruptibly();
1:7fa86e8: 			try {
1:7fa86e8: 				schedulerReferences += 1;
1:7fa86e8: 
1:7fa86e8: 				if (schedulerReferences == 1) {
1:7fa86e8: 					scheduler = Executors.newSingleThreadScheduledExecutor();
1:7fa86e8: 				}
1:7fa86e8: 				return scheduler;
1:7fa86e8: 			} finally {
1:7fa86e8: 				lock.unlock();
1:7fa86e8: 			}
1:7fa86e8: 		} catch (InterruptedException e) {
1:7fa86e8: 			throw new IllegalStateException("Unable to acquire the Scheduler",
1:7fa86e8: 					e);
1:7fa86e8: 		}
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	private void releaseScheduler() {
1:7fa86e8: 		try {
1:7fa86e8: 			lock.lockInterruptibly();
1:7fa86e8: 			try {
1:7fa86e8: 				schedulerReferences -= 1;
1:7fa86e8: 
1:7fa86e8: 				if (schedulerReferences == 0) {
1:7fa86e8: 					scheduler.shutdown();
1:7fa86e8: 					scheduler = null;
1:7fa86e8: 				}
1:7fa86e8: 			} finally {
1:7fa86e8: 				lock.unlock();
1:7fa86e8: 			}
1:7fa86e8: 		} catch (InterruptedException e) {
1:7fa86e8: 			// TODO Auto-generated catch block
1:7fa86e8: 			e.printStackTrace();
1:7fa86e8: 		}
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Create a stream with the default configured buffer, executor size, queue,
1:7fa86e8: 	 * queue policy and pushback policy. This is equivalent to calling
1:7fa86e8: 	 * 
1:7fa86e8: 	 * <code>
1:7fa86e8: 	 *   buildStream(source).create();
1:7fa86e8: 	 * </code>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This stream will be buffered from the event producer, and will honour
1:7fa86e8: 	 * back pressure even if the source does not.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * Buffered streams are useful for "bursty" event sources which produce a
1:7fa86e8: 	 * number of events close together, then none for some time. These bursts
1:7fa86e8: 	 * can sometimes overwhelm downstream processors. Buffering will not,
1:7fa86e8: 	 * however, protect downstream components from a source which produces
1:7fa86e8: 	 * events faster (on average) than they can be consumed.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * Event delivery will not begin until a terminal operation is reached on
1:7fa86e8: 	 * the chain of AsyncStreams. Once a terminal operation is reached the
1:7fa86e8: 	 * stream will be connected to the event source.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param eventSource
1:7fa86e8: 	 * @return A {@link PushStream} with a default initial buffer
1:7fa86e8: 	 */
1:7fa86e8: 	public <T> PushStream<T> createStream(PushEventSource<T> eventSource) {
1:7fa86e8: 		return createStream(eventSource, 1, null, new ArrayBlockingQueue<>(32),
1:7fa86e8: 				FAIL.getPolicy(), LINEAR.getPolicy(1000));
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	/**
1:7fa86e8: 	 * Builds a push stream with custom configuration.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * The resulting {@link PushStream} may be buffered or unbuffered depending
1:7fa86e8: 	 * on how it is configured.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param eventSource The source of the events
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return A {@link PushStreamBuilder} for the stream
1:7fa86e8: 	 */
1:7fa86e8: 	public <T, U extends BlockingQueue<PushEvent< ? extends T>>> PushStreamBuilder<T,U> buildStream(
1:7fa86e8: 			PushEventSource<T> eventSource) {
1:7fa86e8: 		return new PushStreamBuilderImpl<T,U>(this, null, eventSource);
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	@SuppressWarnings({
1:7fa86e8: 			"rawtypes", "unchecked"
1:7fa86e8: 	})
1:7fa86e8: 	<T, U extends BlockingQueue<PushEvent< ? extends T>>> PushStream<T> createStream(
1:7fa86e8: 			PushEventSource<T> eventSource, int parallelism, Executor executor,
1:7fa86e8: 			U queue, QueuePolicy<T,U> queuePolicy,
1:7fa86e8: 			PushbackPolicy<T,U> pushbackPolicy) {
1:7fa86e8: 
1:7fa86e8: 		if (eventSource == null) {
1:7fa86e8: 			throw new NullPointerException("There is no source of events");
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		if (parallelism < 0) {
1:7fa86e8: 			throw new IllegalArgumentException(
1:7fa86e8: 					"The supplied parallelism cannot be less than zero. It was "
1:7fa86e8: 							+ parallelism);
1:7fa86e8: 		} else if (parallelism == 0) {
1:7fa86e8: 			parallelism = 1;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		boolean closeExecutorOnClose;
1:7fa86e8: 		Executor toUse;
1:7fa86e8: 		if (executor == null) {
1:7fa86e8: 			toUse = Executors.newFixedThreadPool(parallelism);
1:7fa86e8: 			closeExecutorOnClose = true;
1:7fa86e8: 		} else {
1:7fa86e8: 			toUse = executor;
1:7fa86e8: 			closeExecutorOnClose = false;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		if (queue == null) {
1:7fa86e8: 			queue = (U) new ArrayBlockingQueue(32);
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		if (queuePolicy == null) {
1:7fa86e8: 			queuePolicy = FAIL.getPolicy();
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		if (pushbackPolicy == null) {
1:7fa86e8: 			pushbackPolicy = LINEAR.getPolicy(1000);
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		@SuppressWarnings("resource")
1:7fa86e8: 		PushStream<T> stream = new BufferedPushStreamImpl<>(this,
1:7fa86e8: 				acquireScheduler(), queue, parallelism, toUse, queuePolicy,
1:7fa86e8: 				pushbackPolicy, aec -> {
1:7fa86e8: 					try {
1:7fa86e8: 						return eventSource.open(aec);
1:7fa86e8: 					} catch (Exception e) {
1:7fa86e8: 						throw new RuntimeException(
1:7fa86e8: 								"Unable to connect to event source", e);
1:7fa86e8: 					}
1:7fa86e8: 				});
1:7fa86e8: 
1:7fa86e8: 		stream = stream.onClose(() -> {
1:7fa86e8: 			if (closeExecutorOnClose) {
1:7fa86e8: 				((ExecutorService) toUse).shutdown();
1:7fa86e8: 			}
1:7fa86e8: 			releaseScheduler();
1:7fa86e8: 		}).map(Function.identity());
1:7fa86e8: 		return stream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	<T> PushStream<T> createUnbufferedStream(PushEventSource<T> eventSource,
1:7fa86e8: 			Executor executor) {
1:7fa86e8: 
1:7fa86e8: 		boolean closeExecutorOnClose;
1:7fa86e8: 		Executor toUse;
1:7fa86e8: 		if (executor == null) {
1:7fa86e8: 			toUse = Executors.newFixedThreadPool(2);
1:7fa86e8: 			closeExecutorOnClose = true;
1:7fa86e8: 		} else {
1:7fa86e8: 			toUse = executor;
1:7fa86e8: 			closeExecutorOnClose = false;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		@SuppressWarnings("resource")
1:7fa86e8: 		PushStream<T> stream = new UnbufferedPushStreamImpl<>(this, toUse,
1:7fa86e8: 				acquireScheduler(), aec -> {
1:7fa86e8: 					try {
1:7fa86e8: 						return eventSource.open(aec);
1:7fa86e8: 					} catch (Exception e) {
1:7fa86e8: 						throw new RuntimeException(
1:7fa86e8: 								"Unable to connect to event source", e);
1:7fa86e8: 					}
1:7fa86e8: 				});
1:7fa86e8: 
1:7fa86e8: 		stream = stream.onClose(() -> {
1:7fa86e8: 			if (closeExecutorOnClose) {
1:7fa86e8: 				((ExecutorService) toUse).shutdown();
1:7fa86e8: 			}
1:7fa86e8: 			releaseScheduler();
1:7fa86e8: 		}).map(Function.identity());
1:7fa86e8: 
1:7fa86e8: 		return stream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Convert an {@link PushStream} into an {@link PushEventSource}. The first
1:7fa86e8: 	 * call to {@link PushEventSource#open(PushEventConsumer)} will begin event
1:7fa86e8: 	 * processing.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * The {@link PushEventSource} will remain active until the backing stream
1:7fa86e8: 	 * is closed, and permits multiple consumers to
1:7fa86e8: 	 * {@link PushEventSource#open(PushEventConsumer)} it.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * This is equivalent to: <code>
1:7fa86e8: 	 *   buildEventSourceFromStream(stream).create();
1:7fa86e8: 	 * </code>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param stream
1:7fa86e8: 	 * @return a {@link PushEventSource} backed by the {@link PushStream}
1:7fa86e8: 	 */
1:7fa86e8: 	public <T> PushEventSource<T> createEventSourceFromStream(
1:7fa86e8: 			PushStream<T> stream) {
1:7fa86e8: 		return buildEventSourceFromStream(stream).create();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Convert an {@link PushStream} into an {@link PushEventSource}. The first
1:7fa86e8: 	 * call to {@link PushEventSource#open(PushEventConsumer)} will begin event
1:7fa86e8: 	 * processing.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * The {@link PushEventSource} will remain active until the backing stream
1:7fa86e8: 	 * is closed, and permits multiple consumers to
1:7fa86e8: 	 * {@link PushEventSource#open(PushEventConsumer)} it.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param stream
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return a {@link PushEventSource} backed by the {@link PushStream}
1:7fa86e8: 	 */
1:7fa86e8: 	public <T, U extends BlockingQueue<PushEvent< ? extends T>>> BufferBuilder<PushEventSource<T>,T,U> buildEventSourceFromStream(
1:7fa86e8: 			PushStream<T> stream) {
1:7fa86e8: 		return new AbstractBufferBuilder<PushEventSource<T>,T,U>() {
1:7fa86e8: 			@Override
1:7fa86e8: 			public PushEventSource<T> create() {
1:7fa86e8: 				SimplePushEventSource<T> spes = createSimplePushEventSource(
1:7fa86e8: 						concurrency, worker, buffer, bufferingPolicy, () -> {
1:7fa86e8: 							try {
1:7fa86e8: 								stream.close();
1:7fa86e8: 							} catch (Exception e) {
1:7fa86e8: 								// TODO Auto-generated catch block
1:7fa86e8: 								e.printStackTrace();
1:7fa86e8: 							}
1:7fa86e8: 						});
1:7fa86e8: 				spes.connectPromise()
1:7fa86e8: 						.then(p -> stream.forEach(t -> spes.publish(t))
1:7fa86e8: 								.onResolve(() -> spes.close()));
1:7fa86e8: 				return spes;
1:7fa86e8: 			}
1:7fa86e8: 		};
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Create a {@link SimplePushEventSource} with the supplied type and default
1:7fa86e8: 	 * buffering behaviours. The SimplePushEventSource will respond to back
1:7fa86e8: 	 * pressure requests from the consumers connected to it.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * This is equivalent to: <code>
1:7fa86e8: 	 *   buildSimpleEventSource(type).create();
1:7fa86e8: 	 * </code>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param type
1:7fa86e8: 	 * @return a {@link SimplePushEventSource}
1:7fa86e8: 	 */
1:7fa86e8: 	public <T> SimplePushEventSource<T> createSimpleEventSource(Class<T> type) {
1:7fa86e8: 		return createSimplePushEventSource(1, null,
1:7fa86e8: 				new ArrayBlockingQueue<>(32),
1:7fa86e8: 				FAIL.getPolicy(), () -> { /* Nothing else to do */ });
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	/**
1:7fa86e8: 	 * 
1:7fa86e8: 	 * Build a {@link SimplePushEventSource} with the supplied type and custom
1:7fa86e8: 	 * buffering behaviours. The SimplePushEventSource will respond to back
1:7fa86e8: 	 * pressure requests from the consumers connected to it.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param type
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return a {@link SimplePushEventSource}
1:7fa86e8: 	 */
1:7fa86e8: 
1:7fa86e8: 	public <T, U extends BlockingQueue<PushEvent< ? extends T>>> BufferBuilder<SimplePushEventSource<T>,T,U> buildSimpleEventSource(
1:7fa86e8: 			Class<T> type) {
1:7fa86e8: 		return new AbstractBufferBuilder<SimplePushEventSource<T>,T,U>() {
1:7fa86e8: 			@Override
1:7fa86e8: 			public SimplePushEventSource<T> create() {
1:7fa86e8: 				return createSimplePushEventSource(concurrency, worker, buffer,
1:7fa86e8: 						bufferingPolicy, () -> { /* Nothing else to do */ });
1:7fa86e8: 			}
1:7fa86e8: 		};
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	@SuppressWarnings({
1:7fa86e8: 			"unchecked", "rawtypes"
1:7fa86e8: 	})
1:7fa86e8: 	<T, U extends BlockingQueue<PushEvent< ? extends T>>> SimplePushEventSource<T> createSimplePushEventSource(
1:7fa86e8: 			int parallelism, Executor executor, U queue,
1:7fa86e8: 			QueuePolicy<T,U> queuePolicy, Runnable onClose) {
1:7fa86e8: 
1:7fa86e8: 		if (parallelism < 0) {
1:7fa86e8: 			throw new IllegalArgumentException(
1:7fa86e8: 					"The supplied parallelism cannot be less than zero. It was "
1:7fa86e8: 							+ parallelism);
1:7fa86e8: 		} else if (parallelism == 0) {
1:7fa86e8: 			parallelism = 1;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		boolean closeExecutorOnClose;
1:7fa86e8: 		Executor toUse;
1:7fa86e8: 		if (executor == null) {
1:7fa86e8: 			toUse = Executors.newFixedThreadPool(2);
1:7fa86e8: 			closeExecutorOnClose = true;
1:7fa86e8: 		} else {
1:7fa86e8: 			toUse = executor;
1:7fa86e8: 			closeExecutorOnClose = false;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		if (queue == null) {
1:7fa86e8: 			queue = (U) new ArrayBlockingQueue(32);
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		if (queuePolicy == null) {
1:7fa86e8: 			queuePolicy = FAIL.getPolicy();
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		SimplePushEventSourceImpl<T,U> spes = new SimplePushEventSourceImpl<T,U>(
1:7fa86e8: 				toUse, acquireScheduler(), queuePolicy, queue, parallelism,
1:7fa86e8: 				() -> {
1:7fa86e8: 					try {
1:7fa86e8: 						onClose.run();
1:7fa86e8: 					} catch (Exception e) {
1:7fa86e8: 						// TODO log this?
1:7fa86e8: 					}
1:7fa86e8: 					if (closeExecutorOnClose) {
1:7fa86e8: 						((ExecutorService) toUse).shutdown();
1:7fa86e8: 					}
1:7fa86e8: 					releaseScheduler();
1:7fa86e8: 				});
1:7fa86e8: 		return spes;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Create a buffered {@link PushEventConsumer} with the default configured
1:7fa86e8: 	 * buffer, executor size, queue, queue policy and pushback policy. This is
1:7fa86e8: 	 * equivalent to calling
1:7fa86e8: 	 * 
1:7fa86e8: 	 * <code>
1:7fa86e8: 	 *   buildBufferedConsumer(delegate).create();
1:7fa86e8: 	 * </code>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * The returned consumer will be buffered from the event source, and will
1:7fa86e8: 	 * honour back pressure requests from its delegate even if the event source
1:7fa86e8: 	 * does not.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * Buffered consumers are useful for "bursty" event sources which produce a
1:7fa86e8: 	 * number of events close together, then none for some time. These bursts
1:7fa86e8: 	 * can sometimes overwhelm the consumer. Buffering will not, however,
1:7fa86e8: 	 * protect downstream components from a source which produces events faster
1:7fa86e8: 	 * than they can be consumed.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param delegate
1:7fa86e8: 	 * @return a {@link PushEventConsumer} with a buffer directly before it
1:7fa86e8: 	 */
1:7fa86e8: 	public <T> PushEventConsumer<T> createBufferedConsumer(
1:7fa86e8: 			PushEventConsumer<T> delegate) {
1:7fa86e8: 		return buildBufferedConsumer(delegate).create();
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	/**
1:7fa86e8: 	 * Build a buffered {@link PushEventConsumer} with custom configuration.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * The returned consumer will be buffered from the event source, and will
1:7fa86e8: 	 * honour back pressure requests from its delegate even if the event source
1:7fa86e8: 	 * does not.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * Buffered consumers are useful for "bursty" event sources which produce a
1:7fa86e8: 	 * number of events close together, then none for some time. These bursts
1:7fa86e8: 	 * can sometimes overwhelm the consumer. Buffering will not, however,
1:7fa86e8: 	 * protect downstream components from a source which produces events faster
1:7fa86e8: 	 * than they can be consumed.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * Buffers are also useful as "circuit breakers". If a
1:7fa86e8: 	 * {@link QueuePolicyOption#FAIL} is used then a full buffer will request
1:7fa86e8: 	 * that the stream close, preventing an event storm from reaching the
1:7fa86e8: 	 * client.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * Note that this buffered consumer will close when it receives a terminal
1:7fa86e8: 	 * event, or if the delegate returns negative backpressure. No further
1:7fa86e8: 	 * events will be propagated after this time.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param delegate
1:7fa86e8: 	 * @return a {@link PushEventConsumer} with a buffer directly before it
1:7fa86e8: 	 */
1:7fa86e8: 	public <T, U extends BlockingQueue<PushEvent< ? extends T>>> BufferBuilder<PushEventConsumer<T>,T,U> buildBufferedConsumer(
1:7fa86e8: 			PushEventConsumer<T> delegate) {
1:7fa86e8: 		return new AbstractBufferBuilder<PushEventConsumer<T>,T,U>() {
1:7fa86e8: 			@Override
1:7fa86e8: 			public PushEventConsumer<T> create() {
1:7fa86e8: 				PushEventPipe<T> pipe = new PushEventPipe<>();
1:7fa86e8: 				
1:7fa86e8: 				createStream(pipe, concurrency, worker, buffer, bufferingPolicy, backPressure)
1:7fa86e8: 					.forEachEvent(delegate);
1:7fa86e8: 				
1:7fa86e8: 				return pipe;
1:7fa86e8: 			}
1:7fa86e8: 		};
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	static final class PushEventPipe<T>
1:7fa86e8: 			implements PushEventConsumer<T>, PushEventSource<T> {
1:7fa86e8: 
1:7fa86e8: 		volatile PushEventConsumer< ? super T> delegate;
1:7fa86e8: 
1:7fa86e8: 		@Override
1:7fa86e8: 		public AutoCloseable open(PushEventConsumer< ? super T> pec)
1:7fa86e8: 				throws Exception {
1:7fa86e8: 			return () -> { /* Nothing else to do */ };
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		@Override
1:7fa86e8: 		public long accept(PushEvent< ? extends T> event) throws Exception {
1:7fa86e8: 			return delegate.accept(event);
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Create an Unbuffered {@link PushStream} from a Java {@link Stream} The
1:7fa86e8: 	 * data from the stream will be pushed into the PushStream synchronously as
1:7fa86e8: 	 * it is opened. This may make terminal operations blocking unless a buffer
1:7fa86e8: 	 * has been added to the {@link PushStream}. Care should be taken with
1:7fa86e8: 	 * infinite {@link Stream}s to avoid blocking indefinitely.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param items The items to push into the PushStream
1:7fa86e8: 	 * @return A PushStream containing the items from the Java Stream
1:7fa86e8: 	 */
1:7fa86e8: 	public <T> PushStream<T> streamOf(Stream<T> items) {
1:7fa86e8: 		PushEventSource<T> pes = aec -> {
1:7fa86e8: 			AtomicBoolean closed = new AtomicBoolean(false);
1:7fa86e8: 
1:7fa86e8: 			items.mapToLong(i -> {
1:7fa86e8: 				try {
1:7fa86e8: 					long returnValue = closed.get() ? -1 : aec.accept(data(i));
1:7fa86e8: 					if (returnValue < 0) {
1:7fa86e8: 						aec.accept(PushEvent.<T>close());
1:7fa86e8: 					}
1:7fa86e8: 					return returnValue;
1:7fa86e8: 				} catch (Exception e) {
1:7fa86e8: 					try {
1:7fa86e8: 						aec.accept(PushEvent.<T>error(e));
1:7fa86e8: 					} catch (Exception e2) {/* No further events needed */}
1:7fa86e8: 					return -1;
1:7fa86e8: 				}
1:7fa86e8: 			}).filter(i -> i < 0).findFirst().orElseGet(() -> {
1:7fa86e8: 				try {
1:7fa86e8: 					return aec.accept(PushEvent.<T>close());
1:7fa86e8: 				} catch (Exception e) {
1:7fa86e8: 					return -1;
1:7fa86e8: 				}
1:7fa86e8: 			});
1:7fa86e8: 
1:7fa86e8: 			return () -> closed.set(true);
1:7fa86e8: 		};
1:7fa86e8: 
1:7fa86e8: 		return this.<T> createUnbufferedStream(pes, null);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Create an Unbuffered {@link PushStream} from a Java {@link Stream} The
1:7fa86e8: 	 * data from the stream will be pushed into the PushStream asynchronously
1:7fa86e8: 	 * using the supplied Executor.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param executor The worker to use to push items from the Stream into the
1:7fa86e8: 	 *            PushStream
1:7fa86e8: 	 * @param items The items to push into the PushStream
1:7fa86e8: 	 * @return A PushStream containing the items from the Java Stream
1:7fa86e8: 	 */
1:7fa86e8: 	public <T> PushStream<T> streamOf(Executor executor, Stream<T> items) {
1:7fa86e8: 
1:7fa86e8: 		boolean closeExecutorOnClose;
1:7fa86e8: 		Executor toUse;
1:7fa86e8: 		if (executor == null) {
1:7fa86e8: 			toUse = Executors.newFixedThreadPool(2);
1:7fa86e8: 			closeExecutorOnClose = true;
1:7fa86e8: 		} else {
1:7fa86e8: 			toUse = executor;
1:7fa86e8: 			closeExecutorOnClose = false;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		@SuppressWarnings("resource")
1:7fa86e8: 		PushStream<T> stream = new UnbufferedPushStreamImpl<T,BlockingQueue<PushEvent< ? extends T>>>(
1:7fa86e8: 				this, toUse, acquireScheduler(), aec -> {
1:7fa86e8: 					return () -> { /* No action to take */ };
1:7fa86e8: 				}) {
1:7fa86e8: 
1:7fa86e8: 			@Override
1:7fa86e8: 			protected boolean begin() {
1:7fa86e8: 				if (super.begin()) {
1:7fa86e8: 					Iterator<T> it = items.iterator();
1:7fa86e8: 
1:7fa86e8: 					toUse.execute(() -> pushData(it));
1:7fa86e8: 
1:7fa86e8: 					return true;
1:7fa86e8: 				}
1:7fa86e8: 				return false;
1:7fa86e8: 			}
1:7fa86e8: 
1:7fa86e8: 			private void pushData(Iterator<T> it) {
1:7fa86e8: 				while (it.hasNext()) {
1:7fa86e8: 					try {
1:7fa86e8: 						long returnValue = closed.get() == CLOSED ? -1
1:7fa86e8: 								: handleEvent(data(it.next()));
1:7fa86e8: 						if (returnValue != 0) {
1:7fa86e8: 							if (returnValue < 0) {
1:7fa86e8: 								close();
1:7fa86e8: 								return;
1:7fa86e8: 							} else {
1:7fa86e8: 								scheduler.schedule(
1:7fa86e8: 										() -> toUse.execute(() -> pushData(it)),
1:7fa86e8: 										returnValue, MILLISECONDS);
1:7fa86e8: 								return;
1:7fa86e8: 							}
1:7fa86e8: 						}
1:7fa86e8: 					} catch (Exception e) {
1:7fa86e8: 						close(error(e));
1:7fa86e8: 					}
1:7fa86e8: 				}
1:7fa86e8: 				close();
1:7fa86e8: 			}
1:7fa86e8: 		};
1:7fa86e8: 
1:7fa86e8: 		stream = stream.onClose(() -> {
1:7fa86e8: 			if (closeExecutorOnClose) {
1:7fa86e8: 				((ExecutorService) toUse).shutdown();
1:7fa86e8: 			}
1:7fa86e8: 			releaseScheduler();
1:7fa86e8: 		}).map(Function.identity());
1:7fa86e8: 
1:7fa86e8: 		return stream;
1:7fa86e8: 	}
1:7fa86e8: }
============================================================================
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:7fa86e8
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Copyright (c) OSGi Alliance (2015). All Rights Reserved.
1:  * 
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.osgi.util.pushstream;
1: 
1: import static java.util.concurrent.TimeUnit.MILLISECONDS;
1: import static org.apache.aries.pushstream.AbstractPushStreamImpl.State.CLOSED;
1: import static org.osgi.util.pushstream.PushEvent.data;
1: import static org.osgi.util.pushstream.PushEvent.error;
1: import static org.osgi.util.pushstream.PushbackPolicyOption.LINEAR;
1: import static org.osgi.util.pushstream.QueuePolicyOption.FAIL;
1: 
1: import java.util.Iterator;
1: import java.util.concurrent.ArrayBlockingQueue;
1: import java.util.concurrent.BlockingQueue;
1: import java.util.concurrent.Executor;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.ScheduledExecutorService;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.locks.Lock;
1: import java.util.concurrent.locks.ReentrantLock;
1: import java.util.function.Function;
1: import java.util.stream.Stream;
1: 
1: import org.apache.aries.pushstream.BufferedPushStreamImpl;
1: import org.apache.aries.pushstream.SimplePushEventSourceImpl;
1: import org.apache.aries.pushstream.UnbufferedPushStreamImpl;
1: 
1: /**
1:  * A factory for {@link PushStream} instances, and utility methods for handling
1:  * {@link PushEventSource}s and {@link PushEventConsumer}s
1:  */
1: public final class PushStreamProvider {
1: 
1: 	private final Lock					lock	= new ReentrantLock(true);
1: 
1: 	private int							schedulerReferences;
1: 
1: 	private ScheduledExecutorService	scheduler;
1: 
1: 	private ScheduledExecutorService acquireScheduler() {
1: 		try {
1: 			lock.lockInterruptibly();
1: 			try {
1: 				schedulerReferences += 1;
1: 
1: 				if (schedulerReferences == 1) {
1: 					scheduler = Executors.newSingleThreadScheduledExecutor();
1: 				}
1: 				return scheduler;
1: 			} finally {
1: 				lock.unlock();
1: 			}
1: 		} catch (InterruptedException e) {
1: 			throw new IllegalStateException("Unable to acquire the Scheduler",
1: 					e);
1: 		}
1: 	}
1: 
1: 	private void releaseScheduler() {
1: 		try {
1: 			lock.lockInterruptibly();
1: 			try {
1: 				schedulerReferences -= 1;
1: 
1: 				if (schedulerReferences == 0) {
1: 					scheduler.shutdown();
1: 					scheduler = null;
1: 				}
1: 			} finally {
1: 				lock.unlock();
1: 			}
1: 		} catch (InterruptedException e) {
1: 			// TODO Auto-generated catch block
1: 			e.printStackTrace();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Create a stream with the default configured buffer, executor size, queue,
1: 	 * queue policy and pushback policy. This is equivalent to calling
1: 	 * 
1: 	 * <code>
1: 	 *   buildStream(source).create();
1: 	 * </code>
1: 	 * 
1: 	 * <p>
1: 	 * This stream will be buffered from the event producer, and will honour
1: 	 * back pressure even if the source does not.
1: 	 * 
1: 	 * <p>
1: 	 * Buffered streams are useful for "bursty" event sources which produce a
1: 	 * number of events close together, then none for some time. These bursts
1: 	 * can sometimes overwhelm downstream processors. Buffering will not,
1: 	 * however, protect downstream components from a source which produces
1: 	 * events faster (on average) than they can be consumed.
1: 	 * 
1: 	 * <p>
1: 	 * Event delivery will not begin until a terminal operation is reached on
1: 	 * the chain of AsyncStreams. Once a terminal operation is reached the
1: 	 * stream will be connected to the event source.
1: 	 * 
1: 	 * @param eventSource
1: 	 * @return A {@link PushStream} with a default initial buffer
1: 	 */
1: 	public <T> PushStream<T> createStream(PushEventSource<T> eventSource) {
1: 		return createStream(eventSource, 1, null, new ArrayBlockingQueue<>(32),
1: 				FAIL.getPolicy(), LINEAR.getPolicy(1000));
1: 	}
1: 	
1: 	/**
1: 	 * Builds a push stream with custom configuration.
1: 	 * 
1: 	 * <p>
1: 	 * 
1: 	 * The resulting {@link PushStream} may be buffered or unbuffered depending
1: 	 * on how it is configured.
1: 	 * 
1: 	 * @param eventSource The source of the events
1: 	 * 
1: 	 * @return A {@link PushStreamBuilder} for the stream
1: 	 */
1: 	public <T, U extends BlockingQueue<PushEvent< ? extends T>>> PushStreamBuilder<T,U> buildStream(
1: 			PushEventSource<T> eventSource) {
1: 		return new PushStreamBuilderImpl<T,U>(this, null, eventSource);
1: 	}
1: 	
1: 	@SuppressWarnings({
1: 			"rawtypes", "unchecked"
1: 	})
1: 	<T, U extends BlockingQueue<PushEvent< ? extends T>>> PushStream<T> createStream(
1: 			PushEventSource<T> eventSource, int parallelism, Executor executor,
1: 			U queue, QueuePolicy<T,U> queuePolicy,
1: 			PushbackPolicy<T,U> pushbackPolicy) {
1: 
1: 		if (eventSource == null) {
1: 			throw new NullPointerException("There is no source of events");
1: 		}
1: 
1: 		if (parallelism < 0) {
1: 			throw new IllegalArgumentException(
1: 					"The supplied parallelism cannot be less than zero. It was "
1: 							+ parallelism);
1: 		} else if (parallelism == 0) {
1: 			parallelism = 1;
1: 		}
1: 
1: 		boolean closeExecutorOnClose;
1: 		Executor toUse;
1: 		if (executor == null) {
1: 			toUse = Executors.newFixedThreadPool(parallelism);
1: 			closeExecutorOnClose = true;
1: 		} else {
1: 			toUse = executor;
1: 			closeExecutorOnClose = false;
1: 		}
1: 
1: 		if (queue == null) {
1: 			queue = (U) new ArrayBlockingQueue(32);
1: 		}
1: 
1: 		if (queuePolicy == null) {
1: 			queuePolicy = FAIL.getPolicy();
1: 		}
1: 
1: 		if (pushbackPolicy == null) {
1: 			pushbackPolicy = LINEAR.getPolicy(1000);
1: 		}
1: 
1: 		@SuppressWarnings("resource")
1: 		PushStream<T> stream = new BufferedPushStreamImpl<>(this,
1: 				acquireScheduler(), queue, parallelism, toUse, queuePolicy,
1: 				pushbackPolicy, aec -> {
1: 					try {
1: 						return eventSource.open(aec);
1: 					} catch (Exception e) {
1: 						throw new RuntimeException(
1: 								"Unable to connect to event source", e);
1: 					}
1: 				});
1: 
1: 		stream = stream.onClose(() -> {
1: 			if (closeExecutorOnClose) {
1: 				((ExecutorService) toUse).shutdown();
1: 			}
1: 			releaseScheduler();
1: 		}).map(Function.identity());
1: 		return stream;
1: 	}
1: 
1: 	<T> PushStream<T> createUnbufferedStream(PushEventSource<T> eventSource,
1: 			Executor executor) {
1: 
1: 		boolean closeExecutorOnClose;
1: 		Executor toUse;
1: 		if (executor == null) {
1: 			toUse = Executors.newFixedThreadPool(2);
1: 			closeExecutorOnClose = true;
1: 		} else {
1: 			toUse = executor;
1: 			closeExecutorOnClose = false;
1: 		}
1: 
1: 		@SuppressWarnings("resource")
1: 		PushStream<T> stream = new UnbufferedPushStreamImpl<>(this, toUse,
1: 				acquireScheduler(), aec -> {
1: 					try {
1: 						return eventSource.open(aec);
1: 					} catch (Exception e) {
1: 						throw new RuntimeException(
1: 								"Unable to connect to event source", e);
1: 					}
1: 				});
1: 
1: 		stream = stream.onClose(() -> {
1: 			if (closeExecutorOnClose) {
1: 				((ExecutorService) toUse).shutdown();
1: 			}
1: 			releaseScheduler();
1: 		}).map(Function.identity());
1: 
1: 		return stream;
1: 	}
1: 
1: 	/**
1: 	 * Convert an {@link PushStream} into an {@link PushEventSource}. The first
1: 	 * call to {@link PushEventSource#open(PushEventConsumer)} will begin event
1: 	 * processing.
1: 	 * 
1: 	 * The {@link PushEventSource} will remain active until the backing stream
1: 	 * is closed, and permits multiple consumers to
1: 	 * {@link PushEventSource#open(PushEventConsumer)} it.
1: 	 * 
1: 	 * This is equivalent to: <code>
1: 	 *   buildEventSourceFromStream(stream).create();
1: 	 * </code>
1: 	 * 
1: 	 * @param stream
1: 	 * @return a {@link PushEventSource} backed by the {@link PushStream}
1: 	 */
1: 	public <T> PushEventSource<T> createEventSourceFromStream(
1: 			PushStream<T> stream) {
1: 		return buildEventSourceFromStream(stream).create();
1: 	}
1: 
1: 	/**
1: 	 * Convert an {@link PushStream} into an {@link PushEventSource}. The first
1: 	 * call to {@link PushEventSource#open(PushEventConsumer)} will begin event
1: 	 * processing.
1: 	 * 
1: 	 * The {@link PushEventSource} will remain active until the backing stream
1: 	 * is closed, and permits multiple consumers to
1: 	 * {@link PushEventSource#open(PushEventConsumer)} it.
1: 	 * 
1: 	 * @param stream
1: 	 * 
1: 	 * @return a {@link PushEventSource} backed by the {@link PushStream}
1: 	 */
1: 	public <T, U extends BlockingQueue<PushEvent< ? extends T>>> BufferBuilder<PushEventSource<T>,T,U> buildEventSourceFromStream(
1: 			PushStream<T> stream) {
1: 		return new AbstractBufferBuilder<PushEventSource<T>,T,U>() {
1: 			@Override
1: 			public PushEventSource<T> create() {
1: 				SimplePushEventSource<T> spes = createSimplePushEventSource(
1: 						concurrency, worker, buffer, bufferingPolicy, () -> {
1: 							try {
1: 								stream.close();
1: 							} catch (Exception e) {
1: 								// TODO Auto-generated catch block
1: 								e.printStackTrace();
1: 							}
1: 						});
1: 				spes.connectPromise()
1: 						.then(p -> stream.forEach(t -> spes.publish(t))
1: 								.onResolve(() -> spes.close()));
1: 				return spes;
1: 			}
1: 		};
1: 	}
1: 	
1: 
1: 	/**
1: 	 * Create a {@link SimplePushEventSource} with the supplied type and default
1: 	 * buffering behaviours. The SimplePushEventSource will respond to back
1: 	 * pressure requests from the consumers connected to it.
1: 	 * 
1: 	 * This is equivalent to: <code>
1: 	 *   buildSimpleEventSource(type).create();
1: 	 * </code>
1: 	 * 
1: 	 * @param type
1: 	 * @return a {@link SimplePushEventSource}
1: 	 */
1: 	public <T> SimplePushEventSource<T> createSimpleEventSource(Class<T> type) {
1: 		return createSimplePushEventSource(1, null,
1: 				new ArrayBlockingQueue<>(32),
1: 				FAIL.getPolicy(), () -> { /* Nothing else to do */ });
1: 	}
1: 	
1: 	/**
1: 	 * 
1: 	 * Build a {@link SimplePushEventSource} with the supplied type and custom
1: 	 * buffering behaviours. The SimplePushEventSource will respond to back
1: 	 * pressure requests from the consumers connected to it.
1: 	 * 
1: 	 * @param type
1: 	 * 
1: 	 * @return a {@link SimplePushEventSource}
1: 	 */
1: 
1: 	public <T, U extends BlockingQueue<PushEvent< ? extends T>>> BufferBuilder<SimplePushEventSource<T>,T,U> buildSimpleEventSource(
1: 			Class<T> type) {
1: 		return new AbstractBufferBuilder<SimplePushEventSource<T>,T,U>() {
1: 			@Override
1: 			public SimplePushEventSource<T> create() {
1: 				return createSimplePushEventSource(concurrency, worker, buffer,
1: 						bufferingPolicy, () -> { /* Nothing else to do */ });
1: 			}
1: 		};
1: 	}
1: 	
1: 	@SuppressWarnings({
1: 			"unchecked", "rawtypes"
1: 	})
1: 	<T, U extends BlockingQueue<PushEvent< ? extends T>>> SimplePushEventSource<T> createSimplePushEventSource(
1: 			int parallelism, Executor executor, U queue,
1: 			QueuePolicy<T,U> queuePolicy, Runnable onClose) {
1: 
1: 		if (parallelism < 0) {
1: 			throw new IllegalArgumentException(
1: 					"The supplied parallelism cannot be less than zero. It was "
1: 							+ parallelism);
1: 		} else if (parallelism == 0) {
1: 			parallelism = 1;
1: 		}
1: 
1: 		boolean closeExecutorOnClose;
1: 		Executor toUse;
1: 		if (executor == null) {
1: 			toUse = Executors.newFixedThreadPool(2);
1: 			closeExecutorOnClose = true;
1: 		} else {
1: 			toUse = executor;
1: 			closeExecutorOnClose = false;
1: 		}
1: 
1: 		if (queue == null) {
1: 			queue = (U) new ArrayBlockingQueue(32);
1: 		}
1: 
1: 		if (queuePolicy == null) {
1: 			queuePolicy = FAIL.getPolicy();
1: 		}
1: 
1: 		SimplePushEventSourceImpl<T,U> spes = new SimplePushEventSourceImpl<T,U>(
1: 				toUse, acquireScheduler(), queuePolicy, queue, parallelism,
1: 				() -> {
1: 					try {
1: 						onClose.run();
1: 					} catch (Exception e) {
1: 						// TODO log this?
1: 					}
1: 					if (closeExecutorOnClose) {
1: 						((ExecutorService) toUse).shutdown();
1: 					}
1: 					releaseScheduler();
1: 				});
1: 		return spes;
1: 	}
1: 
1: 	/**
1: 	 * Create a buffered {@link PushEventConsumer} with the default configured
1: 	 * buffer, executor size, queue, queue policy and pushback policy. This is
1: 	 * equivalent to calling
1: 	 * 
1: 	 * <code>
1: 	 *   buildBufferedConsumer(delegate).create();
1: 	 * </code>
1: 	 * 
1: 	 * <p>
1: 	 * The returned consumer will be buffered from the event source, and will
1: 	 * honour back pressure requests from its delegate even if the event source
1: 	 * does not.
1: 	 * 
1: 	 * <p>
1: 	 * Buffered consumers are useful for "bursty" event sources which produce a
1: 	 * number of events close together, then none for some time. These bursts
1: 	 * can sometimes overwhelm the consumer. Buffering will not, however,
1: 	 * protect downstream components from a source which produces events faster
1: 	 * than they can be consumed.
1: 	 * 
1: 	 * @param delegate
1: 	 * @return a {@link PushEventConsumer} with a buffer directly before it
1: 	 */
1: 	public <T> PushEventConsumer<T> createBufferedConsumer(
1: 			PushEventConsumer<T> delegate) {
1: 		return buildBufferedConsumer(delegate).create();
1: 	}
1: 	
1: 	/**
1: 	 * Build a buffered {@link PushEventConsumer} with custom configuration.
1: 	 * <p>
1: 	 * The returned consumer will be buffered from the event source, and will
1: 	 * honour back pressure requests from its delegate even if the event source
1: 	 * does not.
1: 	 * <p>
1: 	 * Buffered consumers are useful for "bursty" event sources which produce a
1: 	 * number of events close together, then none for some time. These bursts
1: 	 * can sometimes overwhelm the consumer. Buffering will not, however,
1: 	 * protect downstream components from a source which produces events faster
1: 	 * than they can be consumed.
1: 	 * <p>
1: 	 * Buffers are also useful as "circuit breakers". If a
1: 	 * {@link QueuePolicyOption#FAIL} is used then a full buffer will request
1: 	 * that the stream close, preventing an event storm from reaching the
1: 	 * client.
1: 	 * <p>
1: 	 * Note that this buffered consumer will close when it receives a terminal
1: 	 * event, or if the delegate returns negative backpressure. No further
1: 	 * events will be propagated after this time.
1: 	 * 
1: 	 * @param delegate
1: 	 * @return a {@link PushEventConsumer} with a buffer directly before it
1: 	 */
1: 	public <T, U extends BlockingQueue<PushEvent< ? extends T>>> BufferBuilder<PushEventConsumer<T>,T,U> buildBufferedConsumer(
1: 			PushEventConsumer<T> delegate) {
1: 		return new AbstractBufferBuilder<PushEventConsumer<T>,T,U>() {
1: 			@Override
1: 			public PushEventConsumer<T> create() {
1: 				PushEventPipe<T> pipe = new PushEventPipe<>();
1: 				
1: 				createStream(pipe, concurrency, worker, buffer, bufferingPolicy, backPressure)
1: 					.forEachEvent(delegate);
1: 				
1: 				return pipe;
1: 			}
1: 		};
1: 	}
1: 
1: 	static final class PushEventPipe<T>
1: 			implements PushEventConsumer<T>, PushEventSource<T> {
1: 
1: 		volatile PushEventConsumer< ? super T> delegate;
1: 
1: 		@Override
1: 		public AutoCloseable open(PushEventConsumer< ? super T> pec)
1: 				throws Exception {
1: 			return () -> { /* Nothing else to do */ };
1: 		}
1: 
1: 		@Override
1: 		public long accept(PushEvent< ? extends T> event) throws Exception {
1: 			return delegate.accept(event);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Create an Unbuffered {@link PushStream} from a Java {@link Stream} The
1: 	 * data from the stream will be pushed into the PushStream synchronously as
1: 	 * it is opened. This may make terminal operations blocking unless a buffer
1: 	 * has been added to the {@link PushStream}. Care should be taken with
1: 	 * infinite {@link Stream}s to avoid blocking indefinitely.
1: 	 * 
1: 	 * @param items The items to push into the PushStream
1: 	 * @return A PushStream containing the items from the Java Stream
1: 	 */
1: 	public <T> PushStream<T> streamOf(Stream<T> items) {
1: 		PushEventSource<T> pes = aec -> {
1: 			AtomicBoolean closed = new AtomicBoolean(false);
1: 
1: 			items.mapToLong(i -> {
1: 				try {
1: 					long returnValue = closed.get() ? -1 : aec.accept(data(i));
1: 					if (returnValue < 0) {
1: 						aec.accept(PushEvent.<T>close());
1: 					}
1: 					return returnValue;
1: 				} catch (Exception e) {
1: 					try {
1: 						aec.accept(PushEvent.<T>error(e));
1: 					} catch (Exception e2) {/* No further events needed */}
1: 					return -1;
1: 				}
1: 			}).filter(i -> i < 0).findFirst().orElseGet(() -> {
1: 				try {
1: 					return aec.accept(PushEvent.<T>close());
1: 				} catch (Exception e) {
1: 					return -1;
1: 				}
1: 			});
1: 
1: 			return () -> closed.set(true);
1: 		};
1: 
1: 		return this.<T> createUnbufferedStream(pes, null);
1: 	}
1: 
1: 	/**
1: 	 * Create an Unbuffered {@link PushStream} from a Java {@link Stream} The
1: 	 * data from the stream will be pushed into the PushStream asynchronously
1: 	 * using the supplied Executor.
1: 	 * 
1: 	 * @param executor The worker to use to push items from the Stream into the
1: 	 *            PushStream
1: 	 * @param items The items to push into the PushStream
1: 	 * @return A PushStream containing the items from the Java Stream
1: 	 */
1: 	public <T> PushStream<T> streamOf(Executor executor, Stream<T> items) {
1: 
1: 		boolean closeExecutorOnClose;
1: 		Executor toUse;
1: 		if (executor == null) {
1: 			toUse = Executors.newFixedThreadPool(2);
1: 			closeExecutorOnClose = true;
1: 		} else {
1: 			toUse = executor;
1: 			closeExecutorOnClose = false;
1: 		}
1: 
1: 		@SuppressWarnings("resource")
1: 		PushStream<T> stream = new UnbufferedPushStreamImpl<T,BlockingQueue<PushEvent< ? extends T>>>(
1: 				this, toUse, acquireScheduler(), aec -> {
1: 					return () -> { /* No action to take */ };
1: 				}) {
1: 
1: 			@Override
1: 			protected boolean begin() {
1: 				if (super.begin()) {
1: 					Iterator<T> it = items.iterator();
1: 
1: 					toUse.execute(() -> pushData(it));
1: 
1: 					return true;
1: 				}
1: 				return false;
1: 			}
1: 
1: 			private void pushData(Iterator<T> it) {
1: 				while (it.hasNext()) {
1: 					try {
1: 						long returnValue = closed.get() == CLOSED ? -1
1: 								: handleEvent(data(it.next()));
1: 						if (returnValue != 0) {
1: 							if (returnValue < 0) {
1: 								close();
1: 								return;
1: 							} else {
1: 								scheduler.schedule(
1: 										() -> toUse.execute(() -> pushData(it)),
1: 										returnValue, MILLISECONDS);
1: 								return;
1: 							}
1: 						}
1: 					} catch (Exception e) {
1: 						close(error(e));
1: 					}
1: 				}
1: 				close();
1: 			}
1: 		};
1: 
1: 		stream = stream.onClose(() -> {
1: 			if (closeExecutorOnClose) {
1: 				((ExecutorService) toUse).shutdown();
1: 			}
1: 			releaseScheduler();
1: 		}).map(Function.identity());
1: 
1: 		return stream;
1: 	}
1: }
============================================================================