1:f13c6ac: /**
1:f13c6ac:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:f13c6ac:  *  contributor license agreements.  See the NOTICE file distributed with
1:f13c6ac:  *  this work for additional information regarding copyright ownership.
1:f13c6ac:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:f13c6ac:  *  (the "License"); you may not use this file except in compliance with
1:f13c6ac:  *  the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *     http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  *  Unless required by applicable law or agreed to in writing, software
1:f13c6ac:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:f13c6ac:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f13c6ac:  *  See the License for the specific language governing permissions and
1:f13c6ac:  *  limitations under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
1:f13c6ac: 
1:f13c6ac: import java.io.ByteArrayInputStream;
1:f13c6ac: import java.lang.reflect.Array;
1:f13c6ac: import java.lang.reflect.Constructor;
1:f13c6ac: import java.lang.reflect.Modifier;
1:224d200: import java.lang.reflect.ParameterizedType;
1:f13c6ac: import java.lang.reflect.Type;
1:224d200: import java.lang.reflect.TypeVariable;
1:1ef5bcf: import java.math.BigDecimal;
1:1ef5bcf: import java.math.BigInteger;
1:f13c6ac: import java.security.AccessControlContext;
1:f13c6ac: import java.security.AccessController;
1:f13c6ac: import java.security.PrivilegedAction;
1:f13c6ac: import java.security.PrivilegedExceptionAction;
1:f13c6ac: import java.util.ArrayList;
1:f13c6ac: import java.util.Collection;
1:1ef5bcf: import java.util.Dictionary;
1:1ef5bcf: import java.util.Enumeration;
1:f13c6ac: import java.util.HashMap;
1:1ef5bcf: import java.util.Hashtable;
1:f13c6ac: import java.util.List;
1:f13c6ac: import java.util.Locale;
1:f13c6ac: import java.util.Map;
1:f13c6ac: import java.util.Properties;
1:f13c6ac: import java.util.concurrent.atomic.AtomicInteger;
1:f13c6ac: import java.util.concurrent.atomic.AtomicLong;
1:f13c6ac: import java.util.regex.Pattern;
1:f13c6ac: 
1:5e2bd49: import org.apache.aries.blueprint.container.BeanRecipe.UnwrapperedBeanHolder;
1:c290cc1: import org.apache.aries.blueprint.container.GenericType.BoundType;
1:6414875: import org.apache.aries.blueprint.di.CollectionRecipe;
1:6414875: import org.apache.aries.blueprint.di.MapRecipe;
1:1ef5bcf: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:6414875: import org.apache.aries.blueprint.utils.ReflectionUtils;
1:1ef5bcf: import org.osgi.service.blueprint.container.Converter;
1:1ef5bcf: import org.osgi.service.blueprint.container.ReifiedType;
1:f13c6ac: 
1:6414875: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * Implementation of the Converter.
1:f13c6ac:  *
1:f13c6ac:  * This object contains all the registered Converters which can be registered
1:f13c6ac:  * by using {@link #registerConverter(Converter)}
1:f13c6ac:  * and unregistered using {@link #unregisterConverter(Converter)}.
1:f13c6ac:  *
1:f13c6ac:  * Each {@link org.osgi.service.blueprint.container.BlueprintContainer} has its own AggregateConverter
1:f13c6ac:  * used to register converters defined by the related blueprint bundle.
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:f13c6ac: public class AggregateConverter implements Converter {
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Objects implementing this interface will bypass the default conversion rules
1:f13c6ac:      * and be called directly to transform into the expected type.
1:f13c6ac:      */
1:f13c6ac:     public static interface Convertible {
1:f13c6ac: 
1:f13c6ac:         Object convert(ReifiedType type) throws Exception;
3:f13c6ac:     }
1:f13c6ac: 
1:fc8fba6:     private static class ConversionResult {
1:fc8fba6: 
1:fc8fba6:         public final Converter converter;
1:fc8fba6:         public final Object value;
1:fc8fba6: 
1:fc8fba6:         public ConversionResult(Converter converter, Object value) {
1:fc8fba6:             this.converter = converter;
1:fc8fba6:             this.value = value;
1:f13c6ac:         }
1:f13c6ac:     }
1:fc8fba6: 
1:f13c6ac:     private ExtendedBlueprintContainer blueprintContainer;
1:f13c6ac:     private List<Converter> converters = new ArrayList<Converter>();
1:f13c6ac: 
1:f13c6ac:     public AggregateConverter(ExtendedBlueprintContainer blueprintContainer) {
1:f13c6ac:         this.blueprintContainer = blueprintContainer;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void registerConverter(Converter converter) {
1:f13c6ac:         converters.add(converter);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void unregisterConverter(Converter converter) {
1:f13c6ac:         converters.remove(converter);
1:f13c6ac:     }
1:f13c6ac: 
1:5e2bd49:     public boolean canConvert(Object fromValue, final ReifiedType toType) {
1:f13c6ac:         if (fromValue == null) {
3:f13c6ac:             return true;
1:5e2bd49:         } else if (fromValue instanceof UnwrapperedBeanHolder) {
1:5e2bd49:         	fromValue = ((UnwrapperedBeanHolder) fromValue).unwrapperedBean;
1:f13c6ac:         }
1:f13c6ac:         if (isAssignable(fromValue, toType)) {
1:f13c6ac:             return true;
1:f13c6ac:         }
1:f13c6ac:         
1:5e2bd49:         final Object toTest = fromValue;
1:f13c6ac:         boolean canConvert = false;
1:f13c6ac:         AccessControlContext acc = blueprintContainer.getAccessControlContext();
1:f13c6ac:         if (acc == null) {
1:5e2bd49:             canConvert = canConvertWithConverters(toTest, toType);
1:224d200:         } else {
1:f13c6ac:             canConvert = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:f13c6ac:                 public Boolean run() {
1:5e2bd49:                     return canConvertWithConverters(toTest, toType);
1:f13c6ac:                 }            
1:f13c6ac:             }, acc);
1:f13c6ac:         }
1:f13c6ac:         if (canConvert) {
1:1ef5bcf:             return true;
1:f13c6ac:         }
1:f13c6ac:         
1:cab8bfe:         // TODO implement better logic ?!
1:cab8bfe:         try {
1:5e2bd49:             convert(toTest, toType);
1:1ef5bcf:             return true;
1:cab8bfe:         } catch (Exception e) {
2:f13c6ac:             return false;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:5e2bd49:     public Object convert(Object fromValue, final ReifiedType type) throws Exception {
1:f13c6ac:         // Discard null values
1:f13c6ac:         if (fromValue == null) {
1:f13c6ac:             return null;
1:f13c6ac:         }
1:f13c6ac:         // First convert service proxies
1:f13c6ac:         if (fromValue instanceof Convertible) {
1:f13c6ac:             return ((Convertible) fromValue).convert(type);
1:5e2bd49:         } else if (fromValue instanceof UnwrapperedBeanHolder) {
1:5e2bd49:         	UnwrapperedBeanHolder holder = (UnwrapperedBeanHolder) fromValue;
1:5e2bd49:         	if (isAssignable(holder.unwrapperedBean, type)) {
1:5e2bd49:                 return BeanRecipe.wrap(holder, type.getRawClass());
1:f13c6ac:             } else {
1:5e2bd49:             	fromValue = BeanRecipe.wrap(holder, Object.class);
1:f13c6ac:             }
1:5e2bd49:         } else if (isAssignable(fromValue, type)) {
1:f13c6ac:         	 // If the object is an instance of the type, just return it
1:f13c6ac:             return fromValue;
1:f13c6ac:         }
1:5e2bd49:         
1:5e2bd49:         final Object finalFromValue = fromValue;
1:fc8fba6:         ConversionResult result = null;
1:f13c6ac:         AccessControlContext acc = blueprintContainer.getAccessControlContext();
1:f13c6ac:         if (acc == null) {
1:fc8fba6:             result = convertWithConverters(fromValue, type);
1:f13c6ac:         } else {
1:fc8fba6:             result = AccessController.doPrivileged(new PrivilegedExceptionAction<ConversionResult>() {
1:fc8fba6:                 public ConversionResult run() throws Exception {
1:5e2bd49:                     return convertWithConverters(finalFromValue, type);
1:f13c6ac:                 }            
1:f13c6ac:             }, acc);
1:f13c6ac:         }
1:fc8fba6:         if (result == null) {
1:f13c6ac:             if (fromValue instanceof Number && Number.class.isAssignableFrom(unwrap(toClass(type)))) {
1:f13c6ac:                 return convertToNumber((Number) fromValue, toClass(type));
1:f13c6ac:             } else if (fromValue instanceof String) {
1:f13c6ac:                 return convertFromString((String) fromValue, toClass(type), blueprintContainer);
1:f13c6ac:             } else if (toClass(type).isArray() && (fromValue instanceof Collection || fromValue.getClass().isArray())) {
1:f13c6ac:                 return convertToArray(fromValue, type);
1:f13c6ac:             } else if (Map.class.isAssignableFrom(toClass(type)) && (fromValue instanceof Map || fromValue instanceof Dictionary)) {
1:f13c6ac:                 return convertToMap(fromValue, type);
1:f13c6ac:             } else if (Dictionary.class.isAssignableFrom(toClass(type)) && (fromValue instanceof Map || fromValue instanceof Dictionary)) {
1:f13c6ac:                 return convertToDictionary(fromValue, type);
1:f13c6ac:             } else if (Collection.class.isAssignableFrom(toClass(type)) && (fromValue instanceof Collection || fromValue.getClass().isArray())) {
1:f13c6ac:                 return convertToCollection(fromValue, type);
1:f13c6ac:             } else {
1:f13c6ac:                 throw new Exception("Unable to convert value " + fromValue + " to type " + type);
1:f13c6ac:             }
1:f13c6ac:         }
1:fc8fba6:         return result.value;
1:f13c6ac:     }
1:f13c6ac: 
1:fc8fba6:     private Converter selectMatchingConverter(Object source, ReifiedType type) {
2:f13c6ac:         for (Converter converter : converters) {
2:f13c6ac:             if (converter.canConvert(source, type)) {
1:fc8fba6:                 return converter;
1:f13c6ac:             }
1:f13c6ac:         }
1:fc8fba6:         return null;
1:f13c6ac:     }
1:fc8fba6: 
1:f13c6ac:     private boolean canConvertWithConverters(Object source, ReifiedType type) {
1:fc8fba6:         return selectMatchingConverter(source,type) != null;
1:f13c6ac:     }
1:f13c6ac:     
1:fc8fba6:     private ConversionResult convertWithConverters(Object source, ReifiedType type) throws Exception {
1:f13c6ac: 
1:fc8fba6:         Converter converter = selectMatchingConverter(source,type);
1:fc8fba6: 
1:fc8fba6:         if (converter == null)  return null;
1:fc8fba6: 
1:fc8fba6:         Object value = converter.convert(source, type);
1:fc8fba6:         return new ConversionResult(converter,value);
1:f13c6ac:     }
1:fc8fba6:     
1:f13c6ac:     public Object convertToNumber(Number value, Class toType) throws Exception {
1:f13c6ac:         toType = unwrap(toType);
1:f13c6ac:         if (AtomicInteger.class == toType) {
1:f13c6ac:             return new AtomicInteger((Integer) convertToNumber(value, Integer.class));
1:f13c6ac:         } else if (AtomicLong.class == toType) {
1:f13c6ac:             return new AtomicLong((Long) convertToNumber(value, Long.class));
1:f13c6ac:         } else if (Integer.class == toType) {
1:f13c6ac:             return value.intValue();
1:f13c6ac:         } else if (Short.class == toType) {
1:f13c6ac:             return value.shortValue();
1:f13c6ac:         } else if (Long.class == toType) {
1:f13c6ac:             return value.longValue();
1:f13c6ac:         } else if (Float.class == toType) {
1:f13c6ac:             return value.floatValue();
1:f13c6ac:         } else if (Double.class == toType) {
1:f13c6ac:             return value.doubleValue();
1:f13c6ac:         } else if (Byte.class == toType) {
1:f13c6ac:             return value.byteValue();
1:f13c6ac:         } else if (BigInteger.class == toType) {
1:f13c6ac:             return new BigInteger(value.toString());
1:f13c6ac:         } else if (BigDecimal.class == toType) {
1:f13c6ac:             return new BigDecimal(value.toString());
1:f13c6ac:         } else {
1:f13c6ac:             throw new Exception("Unable to convert number " + value + " to " + toType);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Object convertFromString(String value, Class toType, Object loader) throws Exception {
1:f13c6ac:         toType = unwrap(toType);
1:f13c6ac:         if (ReifiedType.class == toType) {
1:f13c6ac:             try {
1:f13c6ac:                 return GenericType.parse(value, loader);
1:f13c6ac:             } catch (ClassNotFoundException e) {
1:f13c6ac:                 throw new Exception("Unable to convert", e);
1:f13c6ac:             }
1:f13c6ac:         } else if (Class.class == toType) {
1:f13c6ac:             try {
1:f13c6ac:                 return GenericType.parse(value, loader).getRawClass();
1:f13c6ac:             } catch (ClassNotFoundException e) {
1:f13c6ac:                 throw new Exception("Unable to convert", e);
1:f13c6ac:             }
1:f13c6ac:         } else if (Locale.class == toType) {
1:f13c6ac:             String[] tokens = value.split("_");
1:f13c6ac:             if (tokens.length == 1) {
1:f13c6ac:                 return new Locale(tokens[0]);
1:f13c6ac:             } else if (tokens.length == 2) {
1:f13c6ac:                 return new Locale(tokens[0], tokens[1]);
1:f13c6ac:             } else if (tokens.length == 3) {
1:f13c6ac:                 return new Locale(tokens[0], tokens[1], tokens[2]);
1:f13c6ac:             } else {
1:f13c6ac:                 throw new Exception("Invalid locale string:" + value);
1:f13c6ac:             }
1:f13c6ac:         } else if (Pattern.class == toType) {
1:f13c6ac:             return Pattern.compile(value);
1:f13c6ac:         } else if (Properties.class == toType) {
1:f13c6ac:             Properties props = new Properties();
1:f13c6ac:             ByteArrayInputStream in = new ByteArrayInputStream(value.getBytes("UTF8"));
1:f13c6ac:             props.load(in);
1:f13c6ac:             return props;
1:f13c6ac:         } else if (Boolean.class == toType) {
1:f13c6ac:             if ("yes".equalsIgnoreCase(value) || "true".equalsIgnoreCase(value) || "on".equalsIgnoreCase(value)) {
1:f13c6ac:                 return Boolean.TRUE;
1:f13c6ac:             } else if ("no".equalsIgnoreCase(value) || "false".equalsIgnoreCase(value) || "off".equalsIgnoreCase(value)) {
1:f13c6ac:                 return Boolean.FALSE;
1:f13c6ac:             } else {
1:f13c6ac:                 throw new RuntimeException("Invalid boolean value: " + value);
1:f13c6ac:             }
1:f13c6ac:         } else if (Integer.class == toType) {
1:f13c6ac:             return Integer.valueOf(value);
1:f13c6ac:         } else if (Short.class == toType) {
1:f13c6ac:             return Short.valueOf(value);
1:f13c6ac:         } else if (Long.class == toType) {
1:f13c6ac:             return Long.valueOf(value);
1:f13c6ac:         } else if (Float.class == toType) {
1:f13c6ac:             return Float.valueOf(value);
1:f13c6ac:         } else if (Double.class == toType) {
1:f13c6ac:             return Double.valueOf(value);
1:f13c6ac:         } else if (Character.class == toType) {
1:f13c6ac:             if (value.length() == 6 && value.startsWith("\\u")) {
1:f13c6ac:                 int code = Integer.parseInt(value.substring(2), 16);
1:f13c6ac:                 return (char)code;
1:f13c6ac:             } else if (value.length() == 1) {
1:f13c6ac:                 return value.charAt(0);
1:f13c6ac:             } else {
1:f13c6ac:                 throw new Exception("Invalid value for character type: " + value);
1:f13c6ac:             }
1:f13c6ac:         } else if (Byte.class == toType) {
1:f13c6ac:             return Byte.valueOf(value);
1:f13c6ac:         } else if (Enum.class.isAssignableFrom(toType)) {
1:f13c6ac:             return Enum.valueOf((Class<Enum>) toType, value);
1:f13c6ac:         } else {
1:f13c6ac:             return createObject(value, toType);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Object createObject(String value, Class type) throws Exception {
1:f13c6ac:         if (type.isInterface() || Modifier.isAbstract(type.getModifiers())) {
1:f13c6ac:             throw new Exception("Unable to convert value " + value + " to type " + type + ". Type " + type + " is an interface or an abstract class");
1:f13c6ac:         }
1:f13c6ac:         Constructor constructor = null;
1:f13c6ac:         try {
1:f13c6ac:             constructor = type.getConstructor(String.class);
1:f13c6ac:         } catch (NoSuchMethodException e) {
1:f13c6ac:             throw new RuntimeException("Unable to convert to " + type);
1:f13c6ac:         }
1:f13c6ac:         try {
1:f13c6ac:             return ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), constructor, value);
1:f13c6ac:         } catch (Exception e) {
1:f13c6ac:             throw new Exception("Unable to convert ", getRealCause(e));
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private Object convertToCollection(Object obj, ReifiedType type) throws Exception {
1:f13c6ac:         ReifiedType valueType = type.getActualTypeArgument(0);
1:f13c6ac:         Collection newCol = (Collection) ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), 
1:f13c6ac:                                                                      CollectionRecipe.getCollection(toClass(type)));
1:f13c6ac:         if (obj.getClass().isArray()) {
1:f13c6ac:             for (int i = 0; i < Array.getLength(obj); i++) {
1:f13c6ac:                 try {
1:a9612e5:                     Object ov = Array.get(obj, i);
1:a9612e5:                     Object cv = convert(ov, valueType);
1:a9612e5:                     newCol.add(cv);
1:f13c6ac:                 } catch (Exception t) {
1:f13c6ac:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting array element)", t);
1:f13c6ac:                 }
1:f13c6ac:             }
1:a9612e5:             return newCol;
1:f13c6ac:         } else {
1:a9612e5:             boolean converted = !toClass(type).isAssignableFrom(obj.getClass());
1:f13c6ac:             for (Object item : (Collection) obj) {
1:f13c6ac:                 try {
1:a9612e5:                     Object cv = convert(item, valueType);
1:a9612e5:                     converted |= item != cv;
1:a9612e5:                     newCol.add(cv);
1:f13c6ac:                 } catch (Exception t) {
1:f13c6ac:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting collection entry)", t);
1:f13c6ac:                 }
1:f13c6ac:             }
1:a9612e5:             return converted ? newCol : obj;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Object convertToDictionary(Object obj, ReifiedType type) throws Exception {
1:f13c6ac:         ReifiedType keyType = type.getActualTypeArgument(0);
1:f13c6ac:         ReifiedType valueType = type.getActualTypeArgument(1);
1:f13c6ac:         if (obj instanceof Dictionary) {
1:a9612e5:             Dictionary newDic = new Hashtable();
1:f13c6ac:             Dictionary dic = (Dictionary) obj;
1:a9612e5:             boolean converted = false;
1:f13c6ac:             for (Enumeration keyEnum = dic.keys(); keyEnum.hasMoreElements();) {
1:f13c6ac:                 Object key = keyEnum.nextElement();
1:f13c6ac:                 try {
1:a9612e5:                     Object nk = convert(key, keyType);
1:a9612e5:                     Object ov = dic.get(key);
1:a9612e5:                     Object nv = convert(ov, valueType);
1:a9612e5:                     newDic.put(nk, nv);
1:a9612e5:                     converted |= nk != key || nv != ov;
1:f13c6ac:                 } catch (Exception t) {
1:f13c6ac:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting map entry)", t);
1:f13c6ac:                 }
1:f13c6ac:             }
1:a9612e5:             return converted ? newDic : obj;
1:f13c6ac:         } else {
1:a9612e5:             Dictionary newDic = new Hashtable();
1:f13c6ac:             for (Map.Entry e : ((Map<Object,Object>) obj).entrySet()) {
1:f13c6ac:                 try {
1:f13c6ac:                     newDic.put(convert(e.getKey(), keyType), convert(e.getValue(), valueType));
1:f13c6ac:                 } catch (Exception t) {
1:f13c6ac:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting map entry)", t);
1:f13c6ac:                 }
1:f13c6ac:             }
1:a9612e5:             return newDic;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Object convertToMap(Object obj, ReifiedType type) throws Exception {
1:f13c6ac:         ReifiedType keyType = type.getActualTypeArgument(0);
1:f13c6ac:         ReifiedType valueType = type.getActualTypeArgument(1);
1:f13c6ac:         Map newMap = (Map) ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), 
1:f13c6ac:                                                        MapRecipe.getMap(toClass(type)));
1:f13c6ac:         if (obj instanceof Dictionary) {
1:f13c6ac:             Dictionary dic = (Dictionary) obj;
1:f13c6ac:             for (Enumeration keyEnum = dic.keys(); keyEnum.hasMoreElements();) {
1:f13c6ac:                 Object key = keyEnum.nextElement();
1:f13c6ac:                 try {
1:f13c6ac:                     newMap.put(convert(key, keyType), convert(dic.get(key), valueType));
1:f13c6ac:                 } catch (Exception t) {
1:f13c6ac:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting map entry)", t);
1:f13c6ac:                 }
1:f13c6ac:             }
1:a9612e5:             return newMap;
1:f13c6ac:         } else {
1:a9612e5:             boolean converted = false;
1:f13c6ac:             for (Map.Entry e : ((Map<Object,Object>) obj).entrySet()) {
1:f13c6ac:                 try {
1:a9612e5:                     Object nk = convert(e.getKey(), keyType);
1:a9612e5:                     Object nv = convert(e.getValue(), valueType);
1:a9612e5:                     converted |= nk != e.getKey() || nv != e.getValue();
1:a9612e5:                     newMap.put(nk, nv);
1:f13c6ac:                 } catch (Exception t) {
1:f13c6ac:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting map entry)", t);
1:f13c6ac:                 }
1:f13c6ac:             }
1:a9612e5:             return converted ? newMap : obj;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Object convertToArray(Object obj, ReifiedType type) throws Exception {
1:f13c6ac:         if (obj instanceof Collection) {
1:f13c6ac:             obj = ((Collection) obj).toArray();
1:f13c6ac:         }
1:f13c6ac:         if (!obj.getClass().isArray()) {
1:f13c6ac:             throw new Exception("Unable to convert from " + obj + " to " + type);
1:f13c6ac:         }
1:f13c6ac:         ReifiedType componentType;
1:f13c6ac:         if (type.size() > 0) {
1:f13c6ac:             componentType = type.getActualTypeArgument(0);
1:f13c6ac:         } else {
1:f13c6ac:             componentType = new GenericType(type.getRawClass().getComponentType());
1:f13c6ac:         }
1:f13c6ac:         Object array = Array.newInstance(toClass(componentType), Array.getLength(obj));
1:a9612e5:         boolean converted = array.getClass() != obj.getClass();
1:f13c6ac:         for (int i = 0; i < Array.getLength(obj); i++) {
1:f13c6ac:             try {
1:a9612e5:                 Object ov = Array.get(obj, i);
1:a9612e5:                 Object nv = convert(ov, componentType);
1:a9612e5:                 converted |= nv != ov;
1:a9612e5:                 Array.set(array, i, nv);
1:f13c6ac:             } catch (Exception t) {
1:f13c6ac:                 throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting array element)", t);
1:f13c6ac:             }
1:f13c6ac:         }
1:a9612e5:         return converted ? array : obj;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public static boolean isAssignable(Object source, ReifiedType target) {
1:1ef5bcf:         if (source == null) {
1:1ef5bcf:             return true;
1:1ef5bcf:         }
1:1ef5bcf:         if (target.size() == 0) {
1:1ef5bcf:             return unwrap(target.getRawClass()).isAssignableFrom(unwrap(source.getClass()));
1:1ef5bcf:         } else {
1:0a21aab:             return isTypeAssignable(getType(source), target);
1:0a21aab:         }
1:0a21aab:     }
1:0a21aab: 
1:0a21aab:     private static ReifiedType getType(Object source) {
1:0a21aab:         if (source instanceof Class) {
1:0a21aab:             return new GenericType(Class.class, new GenericType((Class) source));
1:0a21aab:         } else {
1:0a21aab:             return new GenericType(source.getClass());
1:1ef5bcf:         }
1:1ef5bcf:     }
1:1ef5bcf: 
1:1ef5bcf:     public static boolean isTypeAssignable(ReifiedType from, ReifiedType to) {
1:1ef5bcf:         if (from.equals(to)) {
1:1ef5bcf:             return true;
1:1ef5bcf:         }
1:c290cc1:         if (from.getRawClass() == to.getRawClass()) {
1:c049af2:             if (to.size() == 0) {
1:c049af2:                 return true;
1:c049af2:             }
1:c290cc1:             if (from.size() == to.size()) {
1:c290cc1:                 boolean ok = true;
1:c290cc1:                 for (int i = 0; i < from.size(); i++) {
1:c290cc1:                     ReifiedType tf = from.getActualTypeArgument(i);
1:c290cc1:                     ReifiedType tt = to.getActualTypeArgument(i);
1:c290cc1:                     if (!isWildcardCompatible(tf, tt)) {
1:c290cc1:                         ok = false;
1:c290cc1:                         break;
1:c290cc1:                     }
1:c290cc1:                 }
1:c290cc1:                 if (ok) {
1:c290cc1:                     return true;
1:c290cc1:                 }
1:c290cc1:             }
1:5e2bd49:         } else {
1:224d200:             ReifiedType t = getExactSuperType(from, to.getRawClass());
1:224d200:             if (t != null) {
1:224d200:                 return isTypeAssignable(t, to);
1:c290cc1:             }
1:1ef5bcf:         }
1:1ef5bcf:         return false;
1:1ef5bcf:     }
1:f13c6ac: 
1:224d200:     private static ReifiedType getExactSuperType(ReifiedType from, Class<?> to) {
1:224d200:         if (from.getRawClass() == to) {
1:224d200:             return from;
1:224d200:         }
1:224d200:         if (!to.isAssignableFrom(from.getRawClass())) {
1:224d200:             return null;
1:224d200:         }
1:224d200:         for (ReifiedType superType: getExactDirectSuperTypes(from)) {
1:224d200:             ReifiedType result = getExactSuperType(superType, to);
1:224d200:             if (result != null)
1:224d200:                 return result;
1:224d200:         }
1:224d200:         return null;
1:224d200:     }
1:224d200: 
1:224d200:     public static ReifiedType[] getExactDirectSuperTypes(ReifiedType type) {
1:224d200:         Class<?> clazz = type.getRawClass();
1:224d200:         Type[] superInterfaces = clazz.getGenericInterfaces();
1:224d200:         Type superClass = clazz.getGenericSuperclass();
1:224d200:         // the only supertype of an interface without superinterfaces is Object
1:224d200:         if (superClass == null && superInterfaces.length == 0 && clazz.isInterface()) {
1:224d200:             return new ReifiedType[] { new GenericType(Object.class) };
1:224d200:         }
1:224d200:         ReifiedType[] result;
1:224d200:         int resultIndex;
1:224d200:         if (superClass == null) {
1:224d200:             result = new ReifiedType[superInterfaces.length];
1:224d200:             resultIndex = 0;
1:224d200:         } else {
1:224d200:             result = new ReifiedType[superInterfaces.length + 1];
1:224d200:             resultIndex = 1;
1:224d200:             result[0] = mapTypeParameters(superClass, type);
1:224d200:         }
1:224d200:         for (Type superInterface : superInterfaces) {
1:224d200:             result[resultIndex++] = mapTypeParameters(superInterface, type);
1:224d200:         }
1:224d200:         return result;
1:224d200:     }
1:224d200: 
1:224d200:     private static ReifiedType mapTypeParameters(Type toMapType, ReifiedType typeAndParams) {
1:224d200:         if (typeAndParams.size() == 0 && typeAndParams.getRawClass().getTypeParameters().length > 0) {
1:224d200:             // Missing generics information, return erased type
1:224d200:             return new GenericType(new GenericType(toMapType).getRawClass());
1:224d200:         }
1:224d200:         if (toMapType instanceof Class) {
1:224d200:             return new GenericType(toMapType);
1:224d200:         }
1:224d200:         Map<TypeVariable<?>, GenericType> map = new HashMap<TypeVariable<?>, GenericType>();
1:224d200:         for (int i = 0; i < typeAndParams.size(); i++) {
1:224d200:             map.put(typeAndParams.getRawClass().getTypeParameters()[i], (GenericType) typeAndParams.getActualTypeArgument(i));
1:224d200:         }
1:224d200:         return map(map, toMapType);
1:224d200:     }
1:224d200: 
1:224d200: 
1:224d200:     private static GenericType map(Map<TypeVariable<?>, GenericType> map, Type type) {
1:224d200:         if (type instanceof Class) {
1:224d200:             return new GenericType(type);
1:224d200:         }
1:224d200:         if (type instanceof TypeVariable) {
1:224d200:             TypeVariable<?> tv = (TypeVariable<?>) type;
1:224d200:             if (!map.containsKey(type)) {
1:224d200:                 throw new IllegalArgumentException("Unable to resolve TypeVariable: " + tv);
1:224d200:             }
1:224d200:             return map.get(type);
1:224d200:         }
1:224d200:         if (type instanceof ParameterizedType) {
1:224d200:             ParameterizedType pType = (ParameterizedType) type;
1:224d200:             GenericType[] args = new GenericType[pType.getActualTypeArguments().length];
1:224d200:             for (int i = 0; i < args.length; i++) {
1:224d200:                 args[i] = map(map, pType.getActualTypeArguments()[i]);
1:224d200:             }
1:224d200:             return new GenericType((Class<?>) pType.getRawType(), args);
1:224d200:         }
1:224d200:         throw new RuntimeException("not implemented: mapping " + type.getClass() + " (" + type + ")");
1:224d200:     }
1:224d200: 
1:c290cc1:     private static boolean isWildcardCompatible(ReifiedType from, ReifiedType to) {
1:c290cc1:         BoundType fromBoundType = GenericType.boundType(from);
1:c290cc1:         BoundType toBoundType = GenericType.boundType(to);
1:c290cc1:         if (toBoundType == BoundType.Extends) {
1:c290cc1:             return fromBoundType != BoundType.Super && isTypeAssignable(from, GenericType.bound(to));
1:c290cc1:         } else if (toBoundType == BoundType.Super) {
1:c290cc1:             return fromBoundType != BoundType.Extends && isTypeAssignable(GenericType.bound(to), from);
1:c290cc1:         } else {
1:c290cc1:             return fromBoundType == BoundType.Exact && GenericType.bound(from).equals(GenericType.bound(to));
1:c290cc1:         }
1:c290cc1:     }
1:c290cc1: 
1:f13c6ac:     private static Class unwrap(Class c) {
1:f13c6ac:         Class u = primitives.get(c);
1:f13c6ac:         return u != null ? u : c;
1:1ef5bcf:     }
1:f13c6ac:     
1:f13c6ac:     private static final Map<Class, Class> primitives;
1:f13c6ac:     static {
1:f13c6ac:         primitives = new HashMap<Class, Class>();
1:f13c6ac:         primitives.put(byte.class, Byte.class);
1:f13c6ac:         primitives.put(short.class, Short.class);
1:f13c6ac:         primitives.put(char.class, Character.class);
1:f13c6ac:         primitives.put(int.class, Integer.class);
1:f13c6ac:         primitives.put(long.class, Long.class);
1:f13c6ac:         primitives.put(float.class, Float.class);
1:f13c6ac:         primitives.put(double.class, Double.class);
1:f13c6ac:         primitives.put(boolean.class, Boolean.class);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Object convert(Object source, Type target) throws Exception {
1:f13c6ac:         return convert( source, new GenericType(target));
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Class toClass(ReifiedType type) {
1:f13c6ac:         return type.getRawClass();
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:0a21aab
/////////////////////////////////////////////////////////////////////////
1:             return isTypeAssignable(getType(source), target);
1:         }
1:     }
1: 
1:     private static ReifiedType getType(Object source) {
1:         if (source instanceof Class) {
1:             return new GenericType(Class.class, new GenericType((Class) source));
1:         } else {
1:             return new GenericType(source.getClass());
commit:c049af2
/////////////////////////////////////////////////////////////////////////
1:             if (to.size() == 0) {
1:                 return true;
1:             }
commit:224d200
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.ParameterizedType;
1: import java.lang.reflect.TypeVariable;
/////////////////////////////////////////////////////////////////////////
1:         } else {
1:             ReifiedType t = getExactSuperType(from, to.getRawClass());
1:             if (t != null) {
1:                 return isTypeAssignable(t, to);
1:     private static ReifiedType getExactSuperType(ReifiedType from, Class<?> to) {
1:         if (from.getRawClass() == to) {
1:             return from;
1:         }
1:         if (!to.isAssignableFrom(from.getRawClass())) {
1:             return null;
1:         }
1:         for (ReifiedType superType: getExactDirectSuperTypes(from)) {
1:             ReifiedType result = getExactSuperType(superType, to);
1:             if (result != null)
1:                 return result;
1:         }
1:         return null;
1:     }
1: 
1:     public static ReifiedType[] getExactDirectSuperTypes(ReifiedType type) {
1:         Class<?> clazz = type.getRawClass();
1:         Type[] superInterfaces = clazz.getGenericInterfaces();
1:         Type superClass = clazz.getGenericSuperclass();
1:         // the only supertype of an interface without superinterfaces is Object
1:         if (superClass == null && superInterfaces.length == 0 && clazz.isInterface()) {
1:             return new ReifiedType[] { new GenericType(Object.class) };
1:         }
1:         ReifiedType[] result;
1:         int resultIndex;
1:         if (superClass == null) {
1:             result = new ReifiedType[superInterfaces.length];
1:             resultIndex = 0;
1:         } else {
1:             result = new ReifiedType[superInterfaces.length + 1];
1:             resultIndex = 1;
1:             result[0] = mapTypeParameters(superClass, type);
1:         }
1:         for (Type superInterface : superInterfaces) {
1:             result[resultIndex++] = mapTypeParameters(superInterface, type);
1:         }
1:         return result;
1:     }
1: 
1:     private static ReifiedType mapTypeParameters(Type toMapType, ReifiedType typeAndParams) {
1:         if (typeAndParams.size() == 0 && typeAndParams.getRawClass().getTypeParameters().length > 0) {
1:             // Missing generics information, return erased type
1:             return new GenericType(new GenericType(toMapType).getRawClass());
1:         }
1:         if (toMapType instanceof Class) {
1:             return new GenericType(toMapType);
1:         }
1:         Map<TypeVariable<?>, GenericType> map = new HashMap<TypeVariable<?>, GenericType>();
1:         for (int i = 0; i < typeAndParams.size(); i++) {
1:             map.put(typeAndParams.getRawClass().getTypeParameters()[i], (GenericType) typeAndParams.getActualTypeArgument(i));
1:         }
1:         return map(map, toMapType);
1:     }
1: 
1: 
1:     private static GenericType map(Map<TypeVariable<?>, GenericType> map, Type type) {
1:         if (type instanceof Class) {
1:             return new GenericType(type);
1:         }
1:         if (type instanceof TypeVariable) {
1:             TypeVariable<?> tv = (TypeVariable<?>) type;
1:             if (!map.containsKey(type)) {
1:                 throw new IllegalArgumentException("Unable to resolve TypeVariable: " + tv);
1:             }
1:             return map.get(type);
1:         }
1:         if (type instanceof ParameterizedType) {
1:             ParameterizedType pType = (ParameterizedType) type;
1:             GenericType[] args = new GenericType[pType.getActualTypeArguments().length];
1:             for (int i = 0; i < args.length; i++) {
1:                 args[i] = map(map, pType.getActualTypeArguments()[i]);
1:             }
1:             return new GenericType((Class<?>) pType.getRawType(), args);
1:         }
1:         throw new RuntimeException("not implemented: mapping " + type.getClass() + " (" + type + ")");
1:     }
1: 
commit:c290cc1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.container.GenericType.BoundType;
/////////////////////////////////////////////////////////////////////////
1:         if (from.getRawClass() == to.getRawClass()) {
1:             if (from.size() == to.size()) {
1:                 boolean ok = true;
1:                 for (int i = 0; i < from.size(); i++) {
1:                     ReifiedType tf = from.getActualTypeArgument(i);
1:                     ReifiedType tt = to.getActualTypeArgument(i);
1:                     if (!isWildcardCompatible(tf, tt)) {
1:                         ok = false;
1:                         break;
1:                     }
1:                 }
1:                 if (ok) {
1:                     return true;
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private static boolean isWildcardCompatible(ReifiedType from, ReifiedType to) {
1:         BoundType fromBoundType = GenericType.boundType(from);
1:         BoundType toBoundType = GenericType.boundType(to);
1:         if (toBoundType == BoundType.Extends) {
1:             return fromBoundType != BoundType.Super && isTypeAssignable(from, GenericType.bound(to));
1:         } else if (toBoundType == BoundType.Super) {
1:             return fromBoundType != BoundType.Extends && isTypeAssignable(GenericType.bound(to), from);
1:         } else {
1:             return fromBoundType == BoundType.Exact && GenericType.bound(from).equals(GenericType.bound(to));
1:         }
1:     }
1: 
commit:a9612e5
/////////////////////////////////////////////////////////////////////////
1:                     Object ov = Array.get(obj, i);
1:                     Object cv = convert(ov, valueType);
1:                     newCol.add(cv);
1:             return newCol;
1:             boolean converted = !toClass(type).isAssignableFrom(obj.getClass());
1:                     Object cv = convert(item, valueType);
1:                     converted |= item != cv;
1:                     newCol.add(cv);
1:             return converted ? newCol : obj;
1:             Dictionary newDic = new Hashtable();
1:             boolean converted = false;
1:                     Object nk = convert(key, keyType);
1:                     Object ov = dic.get(key);
1:                     Object nv = convert(ov, valueType);
1:                     newDic.put(nk, nv);
1:                     converted |= nk != key || nv != ov;
1:             return converted ? newDic : obj;
1:             Dictionary newDic = new Hashtable();
/////////////////////////////////////////////////////////////////////////
1:             return newDic;
/////////////////////////////////////////////////////////////////////////
1:             return newMap;
1:             boolean converted = false;
1:                     Object nk = convert(e.getKey(), keyType);
1:                     Object nv = convert(e.getValue(), valueType);
1:                     converted |= nk != e.getKey() || nv != e.getValue();
1:                     newMap.put(nk, nv);
1:             return converted ? newMap : obj;
/////////////////////////////////////////////////////////////////////////
1:         boolean converted = array.getClass() != obj.getClass();
1:                 Object ov = Array.get(obj, i);
1:                 Object nv = convert(ov, componentType);
1:                 converted |= nv != ov;
1:                 Array.set(array, i, nv);
1:         return converted ? array : obj;
commit:1ef5bcf
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
1: import java.math.BigInteger;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.Hashtable;
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1: import org.osgi.service.blueprint.container.Converter;
1: import org.osgi.service.blueprint.container.ReifiedType;
/////////////////////////////////////////////////////////////////////////
1:         if (source == null) {
1:             return true;
1:         }
1:         if (target.size() == 0) {
1:             return unwrap(target.getRawClass()).isAssignableFrom(unwrap(source.getClass()));
1:         } else {
0:             return isTypeAssignable(new GenericType(source.getClass()), target);
1:         }
1:     }
1: 
1:     public static boolean isTypeAssignable(ReifiedType from, ReifiedType to) {
1:         if (from.equals(to)) {
1:             return true;
1:         }
0:         Type t = from.getRawClass().getGenericSuperclass();
0:         if (t != null && isTypeAssignable(new GenericType(t), to)) {
1:             return true;
1:         }
0:         for (Type ti : from.getRawClass().getGenericInterfaces()) {
0:             if (ti != null && isTypeAssignable(new GenericType(ti), to)) {
1:                 return true;
1:             }
1:         }
1:         return false;
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.lang.reflect.Array;
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.Modifier;
1: import java.lang.reflect.Type;
1: import java.security.AccessControlContext;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.security.PrivilegedExceptionAction;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Locale;
1: import java.util.Map;
1: import java.util.Properties;
0: import java.util.Hashtable;
0: import java.util.Dictionary;
0: import java.util.Enumeration;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.atomic.AtomicLong;
1: import java.util.regex.Pattern;
0: import java.math.BigInteger;
0: import java.math.BigDecimal;
1: 
0: import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
0: import org.apache.geronimo.blueprint.di.CollectionRecipe;
0: import org.apache.geronimo.blueprint.di.MapRecipe;
0: import org.apache.geronimo.blueprint.utils.ReflectionUtils;
1: 
0: import static org.apache.geronimo.blueprint.utils.ReflectionUtils.getRealCause;
0: import org.osgi.service.blueprint.container.ReifiedType;
0: import org.osgi.service.blueprint.container.Converter;
1: 
1: /**
1:  * Implementation of the Converter.
1:  *
1:  * This object contains all the registered Converters which can be registered
1:  * by using {@link #registerConverter(Converter)}
1:  * and unregistered using {@link #unregisterConverter(Converter)}.
1:  *
1:  * Each {@link org.osgi.service.blueprint.container.BlueprintContainer} has its own AggregateConverter
1:  * used to register converters defined by the related blueprint bundle.
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 760378 $, $Date: 2009-03-31 11:31:38 +0200 (Tue, 31 Mar 2009) $
1:  */
1: public class AggregateConverter implements Converter {
1: 
1:     /**
1:      * Objects implementing this interface will bypass the default conversion rules
1:      * and be called directly to transform into the expected type.
1:      */
1:     public static interface Convertible {
1: 
1:         Object convert(ReifiedType type) throws Exception;
1:     }
1: 
1:     private ExtendedBlueprintContainer blueprintContainer;
1:     private List<Converter> converters = new ArrayList<Converter>();
1: 
1:     public AggregateConverter(ExtendedBlueprintContainer blueprintContainer) {
1:         this.blueprintContainer = blueprintContainer;
1:     }
1: 
1:     public void registerConverter(Converter converter) {
1:         converters.add(converter);
1:     }
1: 
1:     public void unregisterConverter(Converter converter) {
1:         converters.remove(converter);
1:     }
1: 
0:     public boolean canConvert(final Object fromValue, final ReifiedType toType) {
1:         if (fromValue == null) {
1:             return true;
1:         }
1:         if (isAssignable(fromValue, toType)) {
1:             return true;
1:         }
1:         
1:         boolean canConvert = false;
1:         AccessControlContext acc = blueprintContainer.getAccessControlContext();
1:         if (acc == null) {
0:             canConvert = canConvertWithConverters(fromValue, toType);
1:         } else {
1:             canConvert = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:                 public Boolean run() {
0:                     return canConvertWithConverters(fromValue, toType);
1:                 }            
1:             }, acc);
1:         }
1:         if (canConvert) {
1:             return true;
1:         }
1:         
0:         // TODO
0:         if (fromValue instanceof String) {
0:             //
1:         }
1:         return false;
1:     }
1: 
0:     public Object convert(final Object fromValue, final ReifiedType type) throws Exception {
1:         // Discard null values
1:         if (fromValue == null) {
1:             return null;
1:         }
1:         // First convert service proxies
1:         if (fromValue instanceof Convertible) {
1:             return ((Convertible) fromValue).convert(type);
1:         }
1:         // If the object is an instance of the type, just return it
0:         if (isAssignable(fromValue, type)) {
1:             return fromValue;
1:         }
0:         Object value = null;
1:         AccessControlContext acc = blueprintContainer.getAccessControlContext();
1:         if (acc == null) {
0:             value = convertWithConverters(fromValue, type);
1:         } else {
0:             value = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
0:                 public Object run() throws Exception {
0:                     return convertWithConverters(fromValue, type);
1:                 }            
1:             }, acc);
1:         }
0:         if (value == null) {
1:             if (fromValue instanceof Number && Number.class.isAssignableFrom(unwrap(toClass(type)))) {
1:                 return convertToNumber((Number) fromValue, toClass(type));
1:             } else if (fromValue instanceof String) {
1:                 return convertFromString((String) fromValue, toClass(type), blueprintContainer);
1:             } else if (toClass(type).isArray() && (fromValue instanceof Collection || fromValue.getClass().isArray())) {
1:                 return convertToArray(fromValue, type);
1:             } else if (Map.class.isAssignableFrom(toClass(type)) && (fromValue instanceof Map || fromValue instanceof Dictionary)) {
1:                 return convertToMap(fromValue, type);
1:             } else if (Dictionary.class.isAssignableFrom(toClass(type)) && (fromValue instanceof Map || fromValue instanceof Dictionary)) {
1:                 return convertToDictionary(fromValue, type);
1:             } else if (Collection.class.isAssignableFrom(toClass(type)) && (fromValue instanceof Collection || fromValue.getClass().isArray())) {
1:                 return convertToCollection(fromValue, type);
1:             } else {
1:                 throw new Exception("Unable to convert value " + fromValue + " to type " + type);
1:             }
1:         }
0:         return value;
1:     }
1: 
1:     private boolean canConvertWithConverters(Object source, ReifiedType type) {
1:         for (Converter converter : converters) {
1:             if (converter.canConvert(source, type)) {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
1:     
0:     private Object convertWithConverters(Object source, ReifiedType type) throws Exception {
0:         Object value = null;
1:         for (Converter converter : converters) {
1:             if (converter.canConvert(source, type)) {
0:                 value = converter.convert(source, type);
0:                 if (value != null) {
0:                     return value;
1:                 }
1:             }
1:         }
0:         return value;
1:     }
1: 
1:     public Object convertToNumber(Number value, Class toType) throws Exception {
1:         toType = unwrap(toType);
1:         if (AtomicInteger.class == toType) {
1:             return new AtomicInteger((Integer) convertToNumber(value, Integer.class));
1:         } else if (AtomicLong.class == toType) {
1:             return new AtomicLong((Long) convertToNumber(value, Long.class));
1:         } else if (Integer.class == toType) {
1:             return value.intValue();
1:         } else if (Short.class == toType) {
1:             return value.shortValue();
1:         } else if (Long.class == toType) {
1:             return value.longValue();
1:         } else if (Float.class == toType) {
1:             return value.floatValue();
1:         } else if (Double.class == toType) {
1:             return value.doubleValue();
1:         } else if (Byte.class == toType) {
1:             return value.byteValue();
1:         } else if (BigInteger.class == toType) {
1:             return new BigInteger(value.toString());
1:         } else if (BigDecimal.class == toType) {
1:             return new BigDecimal(value.toString());
1:         } else {
1:             throw new Exception("Unable to convert number " + value + " to " + toType);
1:         }
1:     }
1: 
1:     public Object convertFromString(String value, Class toType, Object loader) throws Exception {
1:         toType = unwrap(toType);
1:         if (ReifiedType.class == toType) {
1:             try {
1:                 return GenericType.parse(value, loader);
1:             } catch (ClassNotFoundException e) {
1:                 throw new Exception("Unable to convert", e);
1:             }
1:         } else if (Class.class == toType) {
1:             try {
1:                 return GenericType.parse(value, loader).getRawClass();
1:             } catch (ClassNotFoundException e) {
1:                 throw new Exception("Unable to convert", e);
1:             }
1:         } else if (Locale.class == toType) {
1:             String[] tokens = value.split("_");
1:             if (tokens.length == 1) {
1:                 return new Locale(tokens[0]);
1:             } else if (tokens.length == 2) {
1:                 return new Locale(tokens[0], tokens[1]);
1:             } else if (tokens.length == 3) {
1:                 return new Locale(tokens[0], tokens[1], tokens[2]);
1:             } else {
1:                 throw new Exception("Invalid locale string:" + value);
1:             }
1:         } else if (Pattern.class == toType) {
1:             return Pattern.compile(value);
1:         } else if (Properties.class == toType) {
1:             Properties props = new Properties();
1:             ByteArrayInputStream in = new ByteArrayInputStream(value.getBytes("UTF8"));
1:             props.load(in);
1:             return props;
1:         } else if (Boolean.class == toType) {
1:             if ("yes".equalsIgnoreCase(value) || "true".equalsIgnoreCase(value) || "on".equalsIgnoreCase(value)) {
1:                 return Boolean.TRUE;
1:             } else if ("no".equalsIgnoreCase(value) || "false".equalsIgnoreCase(value) || "off".equalsIgnoreCase(value)) {
1:                 return Boolean.FALSE;
1:             } else {
1:                 throw new RuntimeException("Invalid boolean value: " + value);
1:             }
1:         } else if (Integer.class == toType) {
1:             return Integer.valueOf(value);
1:         } else if (Short.class == toType) {
1:             return Short.valueOf(value);
1:         } else if (Long.class == toType) {
1:             return Long.valueOf(value);
1:         } else if (Float.class == toType) {
1:             return Float.valueOf(value);
1:         } else if (Double.class == toType) {
1:             return Double.valueOf(value);
1:         } else if (Character.class == toType) {
1:             if (value.length() == 6 && value.startsWith("\\u")) {
1:                 int code = Integer.parseInt(value.substring(2), 16);
1:                 return (char)code;
1:             } else if (value.length() == 1) {
1:                 return value.charAt(0);
1:             } else {
1:                 throw new Exception("Invalid value for character type: " + value);
1:             }
1:         } else if (Byte.class == toType) {
1:             return Byte.valueOf(value);
1:         } else if (Enum.class.isAssignableFrom(toType)) {
1:             return Enum.valueOf((Class<Enum>) toType, value);
1:         } else {
1:             return createObject(value, toType);
1:         }
1:     }
1: 
1:     private Object createObject(String value, Class type) throws Exception {
1:         if (type.isInterface() || Modifier.isAbstract(type.getModifiers())) {
1:             throw new Exception("Unable to convert value " + value + " to type " + type + ". Type " + type + " is an interface or an abstract class");
1:         }
1:         Constructor constructor = null;
1:         try {
1:             constructor = type.getConstructor(String.class);
1:         } catch (NoSuchMethodException e) {
1:             throw new RuntimeException("Unable to convert to " + type);
1:         }
1:         try {
1:             return ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), constructor, value);
1:         } catch (Exception e) {
1:             throw new Exception("Unable to convert ", getRealCause(e));
1:         }
1:     }
1:     
1:     private Object convertToCollection(Object obj, ReifiedType type) throws Exception {
1:         ReifiedType valueType = type.getActualTypeArgument(0);
1:         Collection newCol = (Collection) ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), 
1:                                                                      CollectionRecipe.getCollection(toClass(type)));
1:         if (obj.getClass().isArray()) {
1:             for (int i = 0; i < Array.getLength(obj); i++) {
1:                 try {
0:                     newCol.add(convert(Array.get(obj, i), valueType));
1:                 } catch (Exception t) {
1:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting array element)", t);
1:                 }
1:             }
1:         } else {
1:             for (Object item : (Collection) obj) {
1:                 try {
0:                     newCol.add(convert(item, valueType));
1:                 } catch (Exception t) {
1:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting collection entry)", t);
1:                 }
1:             }
1:         }
0:         return newCol;
1:     }
1: 
1:     private Object convertToDictionary(Object obj, ReifiedType type) throws Exception {
1:         ReifiedType keyType = type.getActualTypeArgument(0);
1:         ReifiedType valueType = type.getActualTypeArgument(1);
0:         Dictionary newDic = new Hashtable();
1:         if (obj instanceof Dictionary) {
1:             Dictionary dic = (Dictionary) obj;
1:             for (Enumeration keyEnum = dic.keys(); keyEnum.hasMoreElements();) {
1:                 Object key = keyEnum.nextElement();
1:                 try {
0:                     newDic.put(convert(key, keyType), convert(dic.get(key), valueType));
1:                 } catch (Exception t) {
1:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting map entry)", t);
1:                 }
1:             }
1:         } else {
1:             for (Map.Entry e : ((Map<Object,Object>) obj).entrySet()) {
1:                 try {
1:                     newDic.put(convert(e.getKey(), keyType), convert(e.getValue(), valueType));
1:                 } catch (Exception t) {
1:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting map entry)", t);
1:                 }
1:             }
1:         }
0:         return newDic;
1:     }
1: 
1:     private Object convertToMap(Object obj, ReifiedType type) throws Exception {
1:         ReifiedType keyType = type.getActualTypeArgument(0);
1:         ReifiedType valueType = type.getActualTypeArgument(1);
1:         Map newMap = (Map) ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), 
1:                                                        MapRecipe.getMap(toClass(type)));
1:         if (obj instanceof Dictionary) {
1:             Dictionary dic = (Dictionary) obj;
1:             for (Enumeration keyEnum = dic.keys(); keyEnum.hasMoreElements();) {
1:                 Object key = keyEnum.nextElement();
1:                 try {
1:                     newMap.put(convert(key, keyType), convert(dic.get(key), valueType));
1:                 } catch (Exception t) {
1:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting map entry)", t);
1:                 }
1:             }
1:         } else {
1:             for (Map.Entry e : ((Map<Object,Object>) obj).entrySet()) {
1:                 try {
0:                     newMap.put(convert(e.getKey(), keyType), convert(e.getValue(), valueType));
1:                 } catch (Exception t) {
1:                     throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting map entry)", t);
1:                 }
1:             }
1:         }
0:         return newMap;
1:     }
1: 
1:     private Object convertToArray(Object obj, ReifiedType type) throws Exception {
1:         if (obj instanceof Collection) {
1:             obj = ((Collection) obj).toArray();
1:         }
1:         if (!obj.getClass().isArray()) {
1:             throw new Exception("Unable to convert from " + obj + " to " + type);
1:         }
1:         ReifiedType componentType;
1:         if (type.size() > 0) {
1:             componentType = type.getActualTypeArgument(0);
1:         } else {
1:             componentType = new GenericType(type.getRawClass().getComponentType());
1:         }
1:         Object array = Array.newInstance(toClass(componentType), Array.getLength(obj));
1:         for (int i = 0; i < Array.getLength(obj); i++) {
1:             try {
0:                 Array.set(array, i, convert(Array.get(obj, i), componentType));
1:             } catch (Exception t) {
1:                 throw new Exception("Unable to convert from " + obj + " to " + type + "(error converting array element)", t);
1:             }
1:         }
0:         return array;
1:     }
1: 
1:     public static boolean isAssignable(Object source, ReifiedType target) {
0:         return source == null
0:                 || (target.size() == 0
0:                     && unwrap(target.getRawClass()).isAssignableFrom(unwrap(source.getClass())));
1:     }
1: 
1:     private static Class unwrap(Class c) {
1:         Class u = primitives.get(c);
1:         return u != null ? u : c;
1:     }
1:     
1:     private static final Map<Class, Class> primitives;
1:     static {
1:         primitives = new HashMap<Class, Class>();
1:         primitives.put(byte.class, Byte.class);
1:         primitives.put(short.class, Short.class);
1:         primitives.put(char.class, Character.class);
1:         primitives.put(int.class, Integer.class);
1:         primitives.put(long.class, Long.class);
1:         primitives.put(float.class, Float.class);
1:         primitives.put(double.class, Double.class);
1:         primitives.put(boolean.class, Boolean.class);
1:     }
1: 
1:     public Object convert(Object source, Type target) throws Exception {
1:         return convert( source, new GenericType(target));
1:     }
1: 
1:     private Class toClass(ReifiedType type) {
1:         return type.getRawClass();
1:     }
1:     
1: }
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:5e2bd49
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.container.BeanRecipe.UnwrapperedBeanHolder;
/////////////////////////////////////////////////////////////////////////
1:     public boolean canConvert(Object fromValue, final ReifiedType toType) {
1:         } else if (fromValue instanceof UnwrapperedBeanHolder) {
1:         	fromValue = ((UnwrapperedBeanHolder) fromValue).unwrapperedBean;
1:         final Object toTest = fromValue;
1:             canConvert = canConvertWithConverters(toTest, toType);
1:                     return canConvertWithConverters(toTest, toType);
/////////////////////////////////////////////////////////////////////////
1:             convert(toTest, toType);
1:     public Object convert(Object fromValue, final ReifiedType type) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         } else if (fromValue instanceof UnwrapperedBeanHolder) {
1:         	UnwrapperedBeanHolder holder = (UnwrapperedBeanHolder) fromValue;
1:         	if (isAssignable(holder.unwrapperedBean, type)) {
1:                 return BeanRecipe.wrap(holder, type.getRawClass());
1:             } else {
1:             	fromValue = BeanRecipe.wrap(holder, Object.class);
0:             }
1:         } else if (isAssignable(fromValue, type)) {
0:         	 // If the object is an instance of the type, just return it
1:         
1:         final Object finalFromValue = fromValue;
/////////////////////////////////////////////////////////////////////////
1:                     return convertWithConverters(finalFromValue, type);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
commit:fc8fba6
/////////////////////////////////////////////////////////////////////////
1:     private static class ConversionResult {
1: 
1:         public final Converter converter;
1:         public final Object value;
1: 
1:         public ConversionResult(Converter converter, Object value) {
1:             this.converter = converter;
1:             this.value = value;
0:         }
0:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         ConversionResult result = null;
1:             result = convertWithConverters(fromValue, type);
1:             result = AccessController.doPrivileged(new PrivilegedExceptionAction<ConversionResult>() {
1:                 public ConversionResult run() throws Exception {
1:         if (result == null) {
/////////////////////////////////////////////////////////////////////////
1:         return result.value;
0:     }
1: 
1:     private Converter selectMatchingConverter(Object source, ReifiedType type) {
0:         for (Converter converter : converters) {
0:             if (converter.canConvert(source, type)) {
1:                 return converter;
0:             }
0:         }
1:         return null;
1:         return selectMatchingConverter(source,type) != null;
1:     private ConversionResult convertWithConverters(Object source, ReifiedType type) throws Exception {
1:         Converter converter = selectMatchingConverter(source,type);
1: 
1:         if (converter == null)  return null;
1: 
1:         Object value = converter.convert(source, type);
1:         return new ConversionResult(converter,value);
0:     }
1:     
commit:cab8bfe
/////////////////////////////////////////////////////////////////////////
1:         // TODO implement better logic ?!
1:         try {
0:             convert(fromValue, toType);
0:             return true;
1:         } catch (Exception e) {
0:             return false;
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.di.CollectionRecipe;
1: import org.apache.aries.blueprint.di.MapRecipe;
1: import org.apache.aries.blueprint.utils.ReflectionUtils;
1: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
============================================================================