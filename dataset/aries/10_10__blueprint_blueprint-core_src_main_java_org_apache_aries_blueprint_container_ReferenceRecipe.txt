1:f13c6ac: /*
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
1:f13c6ac: 
1:4377012: import java.lang.ref.WeakReference;
1:f13c6ac: import java.util.ArrayList;
1:4377012: import java.util.Collection;
1:774ce31: import java.util.HashSet;
1:4377012: import java.util.Iterator;
1:f13c6ac: import java.util.List;
1:774ce31: import java.util.Set;
1:f13c6ac: import java.util.concurrent.Callable;
1:f13c6ac: 
1:e104a3b: import org.apache.aries.blueprint.ExtendedReferenceMetadata;
1:6414875: import org.apache.aries.blueprint.di.CollectionRecipe;
1:6ae3afa: import org.apache.aries.blueprint.di.Recipe;
1:d46274e: import org.apache.aries.blueprint.di.ValueRecipe;
1:6ae3afa: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:f13c6ac: import org.osgi.framework.ServiceReference;
1:f13c6ac: import org.osgi.service.blueprint.container.BlueprintEvent;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:6ae3afa: import org.osgi.service.blueprint.container.ReifiedType;
1:f13c6ac: import org.osgi.service.blueprint.container.ServiceUnavailableException;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1:6163557: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * A recipe to create an unary OSGi service reference.
1:f13c6ac:  *
1:f13c6ac:  * TODO: check synchronization / thread safety
1:f13c6ac:  *
1:f13c6ac:  * TODO: looks there is a potential problem if the service is unregistered between a call
1:f13c6ac:  *        to ServiceDispatcher#loadObject() and when the actual invocation finish
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:9728962: @SuppressWarnings("rawtypes")
1:f13c6ac: public class ReferenceRecipe extends AbstractServiceReferenceRecipe {
1:f13c6ac: 
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(ReferenceRecipe.class);
1:f13c6ac: 
1:f13c6ac:     private final ReferenceMetadata metadata;
1:f13c6ac:     private Object proxy;
1:f13c6ac: 
1:b5f484e:     private final Object monitor = new Object();
1:f13c6ac:     private volatile ServiceReference trackedServiceReference;
1:f13c6ac:     private volatile Object trackedService;
1:e104a3b:     private Object defaultBean;
1:f13c6ac: 
1:4377012:     private final Collection<Class<?>> proxyChildBeanClasses;
1:4377012:     private final Collection<WeakReference<Voidable>> proxiedChildren;
1:4377012:     
1:f13c6ac:     public ReferenceRecipe(String name,
1:f13c6ac:                            ExtendedBlueprintContainer blueprintContainer,
1:f13c6ac:                            ReferenceMetadata metadata,
1:d46274e:                            ValueRecipe filterRecipe,
1:f13c6ac:                            CollectionRecipe listenersRecipe,
1:f13c6ac:                            List<Recipe> explicitDependencies) {
1:d46274e:         super(name, blueprintContainer, metadata, filterRecipe, listenersRecipe, explicitDependencies);
1:f13c6ac:         this.metadata = metadata;
1:4377012:         if(metadata instanceof ExtendedReferenceMetadata) 
1:4377012:             proxyChildBeanClasses = ((ExtendedReferenceMetadata) metadata).getProxyChildBeanClasses();
1:4377012:         else 
1:4377012:             proxyChildBeanClasses = null;
1:4377012:         
1:4377012:         if (proxyChildBeanClasses != null)
1:4377012:             proxiedChildren = new ArrayList<WeakReference<Voidable>>();
1:4377012:         else
1:4377012:             proxiedChildren = null;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     @Override
1:f13c6ac:     protected Object internalCreate() throws ComponentDefinitionException {
1:f13c6ac:         try {
1:f13c6ac:             if (explicitDependencies != null) {
1:f13c6ac:                 for (Recipe recipe : explicitDependencies) {
1:f13c6ac:                     recipe.create();
1:774ce31:                 }
1:f13c6ac:             }
1:f13c6ac:             // Create the proxy
1:24455ce:             Set<Class<?>> interfaces = new HashSet<Class<?>>();
1:24455ce:             Class<?> clz = getInterfaceClass();
1:2a55096:             if (clz != null) interfaces.add(clz);
1:ae7707a:             
1:ae7707a:             if (metadata instanceof ExtendedReferenceMetadata) {
1:ae7707a:                 interfaces.addAll(loadAllClasses(((ExtendedReferenceMetadata)metadata).getExtraInterfaces()));
1:ae7707a:             }
1:774ce31: 
1:f13c6ac:             proxy = createProxy(new ServiceDispatcher(), interfaces);
1:f13c6ac: 
1:f13c6ac:             // Add partially created proxy to the context
1:f13c6ac:             ServiceProxyWrapper wrapper = new ServiceProxyWrapper();
1:f13c6ac: 
1:f13c6ac:             addPartialObject(wrapper);
1:f13c6ac: 
1:f13c6ac:             // Handle initial references
1:f13c6ac:             createListeners();
1:f13c6ac:             updateListeners();            
1:f13c6ac: 
1:f13c6ac:             // Return a ServiceProxy that can injection of references or proxies can be done correctly
1:f13c6ac:             return wrapper;
1:f13c6ac:         } catch (ComponentDefinitionException e) {
1:f13c6ac:             throw e;
1:f13c6ac:         } catch (Throwable t) {
1:f13c6ac:             throw new ComponentDefinitionException(t);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected void doStop() {
1:f13c6ac:         synchronized (monitor) {
1:f13c6ac:             unbind();
1:f13c6ac:             monitor.notifyAll();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected void retrack() {
1:f13c6ac:         ServiceReference ref = getBestServiceReference();
1:f13c6ac:         if (ref != null) {
1:f13c6ac:             bind(ref);
1:f13c6ac:         } else {
1:f13c6ac:             unbind();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected void track(ServiceReference ref) {
1:f13c6ac:         // TODO: make this behavior configurable through a custom attribute
1:f13c6ac:         // TODO:      policy = sticky | replace
1:f13c6ac:         synchronized (monitor) {
1:f13c6ac:             if (trackedServiceReference == null) {
1:f13c6ac:                 retrack();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected void untrack(ServiceReference ref) {
1:f13c6ac:         // TODO: make this behavior configurable through a custom attribute
1:f13c6ac:         // TODO:      policy = sticky | replace
1:f13c6ac:         synchronized (monitor) {
1:f13c6ac:             if (trackedServiceReference == ref) {
1:f13c6ac:                 retrack();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void bind(ServiceReference ref) {
1:f13c6ac:         LOGGER.debug("Binding reference {} to {}", getName(), ref);
1:f13c6ac:         synchronized (monitor) {
1:4377012:             ServiceReference oldReference = trackedServiceReference;
1:f13c6ac:             trackedServiceReference = ref;
1:4377012:             voidProxiedChildren();
1:f13c6ac:             bind(trackedServiceReference, proxy);
1:035911e:             if (ref != oldReference) {
1:035911e:               if (oldReference != null && trackedService != null) {
1:035911e:                 try {
1:035911e:                   blueprintContainer.getBundleContext().ungetService(oldReference);
1:035911e:                 } catch (IllegalStateException ise) {
1:035911e:                   // In case the service no longer exists lets just cope and ignore.
1:035911e:                 }
1:f13c6ac:               }
1:035911e:               trackedService = null;
1:f13c6ac:             }
1:f13c6ac:             monitor.notifyAll();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void unbind() {
1:f13c6ac:         LOGGER.debug("Unbinding reference {}", getName());
1:f13c6ac:         synchronized (monitor) {
2:f13c6ac:             if (trackedServiceReference != null) {
1:f13c6ac:                 unbind(trackedServiceReference, proxy);
1:4377012:                 ServiceReference oldReference = trackedServiceReference;
1:f13c6ac:                 trackedServiceReference = null;
1:4377012:                 voidProxiedChildren();
1:6ae3afa:                 if(trackedService != null){
1:6ae3afa:                   try {
1:6ae3afa:                     getBundleContextForServiceLookup().ungetService(oldReference);
1:6ae3afa:                   } catch (IllegalStateException ise) {
1:6ae3afa:                     // In case the service no longer exists lets just cope and ignore.
1:6ae3afa:                   }
1:6ae3afa:                   trackedService = null;
1:f13c6ac:                 }
1:f13c6ac:                 monitor.notifyAll();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Object getService() throws InterruptedException {
1:f13c6ac:         synchronized (monitor) {
1:6163557:             if (isStarted() && trackedServiceReference == null && metadata.getTimeout() > 0
1:6163557:                     && metadata.getAvailability() == ServiceReferenceMetadata.AVAILABILITY_MANDATORY) {
1:b13e703:                 //Here we want to get the blueprint bundle itself, so don't use #getBundleContextForServiceLookup()
1:9728962:                 blueprintContainer.getEventDispatcher().blueprintEvent(createWaitingevent());
1:f13c6ac:                 monitor.wait(metadata.getTimeout());
1:f13c6ac:             }
1:e104a3b:             Object result = null;
1:f13c6ac:             if (trackedServiceReference == null) {
1:f13c6ac:                 if (isStarted()) {
1:e104a3b:                   boolean failed = true;
1:e104a3b:                   if (metadata.getAvailability() == ReferenceMetadata.AVAILABILITY_OPTIONAL && 
1:e104a3b:                       metadata instanceof ExtendedReferenceMetadata) {
1:e104a3b:                      if (defaultBean == null) {
1:e104a3b:                          String defaultBeanId = ((ExtendedReferenceMetadata)metadata).getDefaultBean();
1:e104a3b:                          if (defaultBeanId != null) {
1:e104a3b:                            defaultBean = blueprintContainer.getComponentInstance(defaultBeanId);
1:e104a3b:                            failed = false;
1:f13c6ac:                          }
1:f13c6ac:                      } else {
1:e104a3b:                          failed = false;
1:f13c6ac:                      }
1:e104a3b:                      result = defaultBean;
1:0186986:                   } 
1:e104a3b:                   
1:e104a3b:                   if (failed) {
1:26c3a96:                     if (metadata.getAvailability() == ServiceReferenceMetadata.AVAILABILITY_MANDATORY) {
1:26c3a96:                         LOGGER.info("Timeout expired when waiting for mandatory OSGi service reference {}", getOsgiFilter());
1:26c3a96:                         throw new ServiceUnavailableException("Timeout expired when waiting for mandatory OSGi service reference: " + getOsgiFilter(), getOsgiFilter());
1:26c3a96:                     } else {
1:26c3a96:                         LOGGER.info("No matching service for optional OSGi service reference {}", getOsgiFilter());
1:26c3a96:                         throw new ServiceUnavailableException("No matching service for optional OSGi service reference: " + getOsgiFilter(), getOsgiFilter());
1:26c3a96:                     }
1:0186986:                   }
1:e104a3b:                 } else {
1:26c3a96:                     throw new ServiceUnavailableException("The Blueprint container is being or has been destroyed: " + getOsgiFilter(), getOsgiFilter());
1:e104a3b:                 }
1:e104a3b:             } else {
1:e104a3b:             
1:f13c6ac:               if (trackedService == null) {
1:e3bd874:             	  trackedService = getServiceSecurely(trackedServiceReference);
1:f13c6ac:               }
1:e104a3b:               
1:f13c6ac:               if (trackedService == null) {
1:f13c6ac:                   throw new IllegalStateException("getService() returned null for " + trackedServiceReference);
1:f13c6ac:               }
1:f13c6ac:               
1:e104a3b:               result = trackedService;
1:f13c6ac:             }
1:e104a3b:             return result;
1:f13c6ac:         }
1:e104a3b:     }
1:e104a3b: 
1:9728962:     private BlueprintEvent createWaitingevent() {
1:9728962:         return new BlueprintEvent(BlueprintEvent.WAITING, 
1:9728962:                                   blueprintContainer.getBundleContext().getBundle(), 
1:9728962:                                   blueprintContainer.getExtenderBundle(), 
1:9728962:                                   new String[] { getOsgiFilter() });
1:9728962:     }
1:9728962: 
1:f13c6ac:     private ServiceReference getServiceReference() throws InterruptedException {
1:f13c6ac:         synchronized (monitor) {
1:f13c6ac:             if (!optional) {
1:f13c6ac:                 getService();
1:f13c6ac:             }
1:f13c6ac:             return trackedServiceReference;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:4377012:     private void voidProxiedChildren() {
1:4377012:         if(proxyChildBeanClasses != null) {
1:4377012:             synchronized(proxiedChildren) {
1:4377012:                 for(Iterator<WeakReference<Voidable>> it = proxiedChildren.iterator(); it.hasNext();) {
1:4377012:                     Voidable v = it.next().get();
1:4377012:                     if(v == null)
1:4377012:                         it.remove();
1:4377012:                     else
1:4377012:                       v.voidReference();
1:e104a3b:                 }
1:e104a3b:             }
1:e104a3b:         }
1:e104a3b:     }
1:4377012:     
1:4377012:     public void addVoidableChild(Voidable v) {
1:4377012:         if(proxyChildBeanClasses != null) {
1:4377012:             synchronized (proxiedChildren) {
1:4377012:                 proxiedChildren.add(new WeakReference<Voidable>(v));
1:324f059:             }
1:4377012:         } else {
1:4377012:             throw new IllegalStateException("Proxying of child beans is disabled for this recipe");
1:4377012:         }
7:4377012:     }
1:4377012:     
1:4377012:     public Collection<Class<?>> getProxyChildBeanClasses() {
1:4377012:         return proxyChildBeanClasses;
1:4377012:     }
1:4377012: 
1:f13c6ac:     public class ServiceDispatcher implements Callable<Object> {
1:f13c6ac: 
1:f13c6ac:         public Object call() throws Exception {
1:f13c6ac:             return getService();
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public class ServiceProxyWrapper implements AggregateConverter.Convertible {
1:f13c6ac: 
1:f13c6ac:         public Object convert(ReifiedType type) throws Exception {
1:f13c6ac:             if (type.getRawClass() == ServiceReference.class) {
1:f13c6ac:                 return getServiceReference();
1:f13c6ac:             } else if (type.getRawClass().isInstance(proxy)) {
1:f13c6ac:                 return proxy;
1:f13c6ac:             } else {
1:f13c6ac:                 throw new ComponentDefinitionException("Unable to convert to " + type);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac: }
============================================================================
author:Christian Schneider
-------------------------------------------------------------------------------
commit:9728962
/////////////////////////////////////////////////////////////////////////
1: @SuppressWarnings("rawtypes")
/////////////////////////////////////////////////////////////////////////
1:                 blueprintContainer.getEventDispatcher().blueprintEvent(createWaitingevent());
/////////////////////////////////////////////////////////////////////////
1:     private BlueprintEvent createWaitingevent() {
1:         return new BlueprintEvent(BlueprintEvent.WAITING, 
1:                                   blueprintContainer.getBundleContext().getBundle(), 
1:                                   blueprintContainer.getExtenderBundle(), 
1:                                   new String[] { getOsgiFilter() });
1:     }
1: 
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:ae7707a
/////////////////////////////////////////////////////////////////////////
1:             
1:             if (metadata instanceof ExtendedReferenceMetadata) {
1:                 interfaces.addAll(loadAllClasses(((ExtendedReferenceMetadata)metadata).getExtraInterfaces()));
1:             }
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:b5f484e
/////////////////////////////////////////////////////////////////////////
1:     private final Object monitor = new Object();
commit:d46274e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.di.ValueRecipe;
/////////////////////////////////////////////////////////////////////////
1:                            ValueRecipe filterRecipe,
1:         super(name, blueprintContainer, metadata, filterRecipe, listenersRecipe, explicitDependencies);
commit:b069aa4
/////////////////////////////////////////////////////////////////////////
commit:035911e
/////////////////////////////////////////////////////////////////////////
1:             if (ref != oldReference) {
1:               if (oldReference != null && trackedService != null) {
1:                 try {
1:                   blueprintContainer.getBundleContext().ungetService(oldReference);
1:                 } catch (IllegalStateException ise) {
1:                   // In case the service no longer exists lets just cope and ignore.
1:                 }
1:               trackedService = null;
commit:6ae3afa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1: import org.osgi.service.blueprint.container.ReifiedType;
/////////////////////////////////////////////////////////////////////////
0:             if (oldReference != null && trackedService != null) {
1:             trackedService = null;
/////////////////////////////////////////////////////////////////////////
1:                 if(trackedService != null){
1:                   try {
1:                     getBundleContextForServiceLookup().ungetService(oldReference);
1:                   } catch (IllegalStateException ise) {
1:                     // In case the service no longer exists lets just cope and ignore.
1:                   }
0:                   trackedService = null;
commit:26c3a96
/////////////////////////////////////////////////////////////////////////
1:                     if (metadata.getAvailability() == ServiceReferenceMetadata.AVAILABILITY_MANDATORY) {
1:                         LOGGER.info("Timeout expired when waiting for mandatory OSGi service reference {}", getOsgiFilter());
1:                         throw new ServiceUnavailableException("Timeout expired when waiting for mandatory OSGi service reference: " + getOsgiFilter(), getOsgiFilter());
1:                     } else {
1:                         LOGGER.info("No matching service for optional OSGi service reference {}", getOsgiFilter());
1:                         throw new ServiceUnavailableException("No matching service for optional OSGi service reference: " + getOsgiFilter(), getOsgiFilter());
1:                     }
1:                     throw new ServiceUnavailableException("The Blueprint container is being or has been destroyed: " + getOsgiFilter(), getOsgiFilter());
commit:071e3fe
/////////////////////////////////////////////////////////////////////////
commit:774ce31
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
0: import org.apache.aries.blueprint.ExtendedServiceReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
0:             Set<Class> interfaces = new HashSet<Class>();
0:                 interfaces.add(loadClass(this.metadata.getInterface()));
0:             if (this.metadata instanceof ExtendedServiceReferenceMetadata && ((ExtendedServiceReferenceMetadata) this.metadata).getRuntimeInterface() != null) {
0:                 interfaces.add(((ExtendedServiceReferenceMetadata) this.metadata).getRuntimeInterface());
1:             }
1: 
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
0: import java.util.Collections;
1: import java.util.List;
1: import java.util.ArrayList;
1: import java.util.concurrent.Callable;
1: 
0: import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
0: import org.apache.geronimo.blueprint.di.Recipe;
0: import org.apache.geronimo.blueprint.di.CollectionRecipe;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.service.blueprint.container.BlueprintEvent;
0: import org.osgi.service.blueprint.container.ReifiedType;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.container.ServiceUnavailableException;
1: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A recipe to create an unary OSGi service reference.
1:  *
1:  * TODO: check synchronization / thread safety
1:  *
1:  * TODO: looks there is a potential problem if the service is unregistered between a call
1:  *        to ServiceDispatcher#loadObject() and when the actual invocation finish
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 760378 $, $Date: 2009-03-31 11:31:38 +0200 (Tue, 31 Mar 2009) $
1:  */
1: public class ReferenceRecipe extends AbstractServiceReferenceRecipe {
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(ReferenceRecipe.class);
1: 
1:     private final ReferenceMetadata metadata;
1:     private Object proxy;
1: 
1:     private volatile ServiceReference trackedServiceReference;
1:     private volatile Object trackedService;
0:     private final Object monitor = new Object();
1: 
1:     public ReferenceRecipe(String name,
1:                            ExtendedBlueprintContainer blueprintContainer,
1:                            ReferenceMetadata metadata,
1:                            CollectionRecipe listenersRecipe,
1:                            List<Recipe> explicitDependencies) {
0:         super(name, blueprintContainer, metadata, listenersRecipe, explicitDependencies);
1:         this.metadata = metadata;
1:     }
1: 
1:     @Override
1:     protected Object internalCreate() throws ComponentDefinitionException {
1:         try {
1:             if (explicitDependencies != null) {
1:                 for (Recipe recipe : explicitDependencies) {
1:                     recipe.create();
1:                 }
1:             }
1:             // Create the proxy
0:             List<String> interfaces = new ArrayList<String>();
0:             if (this.metadata.getInterface() != null) {
0:                 interfaces.add(this.metadata.getInterface());
1:             }
1:             proxy = createProxy(new ServiceDispatcher(), interfaces);
1: 
1:             // Add partially created proxy to the context
1:             ServiceProxyWrapper wrapper = new ServiceProxyWrapper();
1: 
1:             addPartialObject(wrapper);
1: 
1:             // Handle initial references
1:             createListeners();
1:             updateListeners();            
1: 
1:             // Return a ServiceProxy that can injection of references or proxies can be done correctly
1:             return wrapper;
1:         } catch (ComponentDefinitionException e) {
1:             throw e;
1:         } catch (Throwable t) {
1:             throw new ComponentDefinitionException(t);
1:         }
1:     }
1: 
1:     protected void doStop() {
1:         synchronized (monitor) {
1:             unbind();
1:             monitor.notifyAll();
1:         }
1:     }
1: 
1:     protected void retrack() {
1:         ServiceReference ref = getBestServiceReference();
1:         if (ref != null) {
1:             bind(ref);
1:         } else {
1:             unbind();
1:         }
1:     }
1: 
1:     protected void track(ServiceReference ref) {
1:         // TODO: make this behavior configurable through a custom attribute
1:         // TODO:      policy = sticky | replace
1:         synchronized (monitor) {
1:             if (trackedServiceReference == null) {
1:                 retrack();
1:             }
1:         }
1:     }
1: 
1:     protected void untrack(ServiceReference ref) {
1:         // TODO: make this behavior configurable through a custom attribute
1:         // TODO:      policy = sticky | replace
1:         synchronized (monitor) {
1:             if (trackedServiceReference == ref) {
1:                 retrack();
1:             }
1:         }
1:     }
1: 
1:     private void bind(ServiceReference ref) {
1:         LOGGER.debug("Binding reference {} to {}", getName(), ref);
1:         synchronized (monitor) {
1:             if (trackedServiceReference != null) {
0:                 blueprintContainer.getBundleContext().ungetService(trackedServiceReference);
1:             }
1:             trackedServiceReference = ref;
0:             trackedService = null;
1:             monitor.notifyAll();
1:             bind(trackedServiceReference, proxy);
1:         }
1:     }
1: 
1:     private void unbind() {
1:         LOGGER.debug("Unbinding reference {}", getName());
1:         synchronized (monitor) {
1:             if (trackedServiceReference != null) {
1:                 unbind(trackedServiceReference, proxy);
0:                 blueprintContainer.getBundleContext().ungetService(trackedServiceReference);
1:                 trackedServiceReference = null;
0:                 trackedService = null;
1:                 monitor.notifyAll();
1:             }
1:         }
1:     }
1: 
1:     private Object getService() throws InterruptedException {
1:         synchronized (monitor) {
0:             if (isStarted() && trackedServiceReference == null && metadata.getTimeout() > 0) {
0:                 blueprintContainer.getEventDispatcher().blueprintEvent(new BlueprintEvent(BlueprintEvent.WAITING, blueprintContainer.getBundleContext().getBundle(), blueprintContainer.getExtenderBundle(), new String[] { getOsgiFilter() }));
1:                 monitor.wait(metadata.getTimeout());
1:             }
1:             if (trackedServiceReference == null) {
1:                 if (isStarted()) {
0:                     LOGGER.info("Timeout expired when waiting for OSGi service {}", getOsgiFilter());
0:                     throw new ServiceUnavailableException("Timeout expired when waiting for OSGi service", getOsgiFilter());
1:                 } else {
0:                     throw new ServiceUnavailableException("The Blueprint container is being or has been destroyed", getOsgiFilter());
1:                 }
1:             }
1:             if (trackedService == null) {
0:                 trackedService = blueprintContainer.getService(trackedServiceReference);
1:             }
1:             if (trackedService == null) {
1:                 throw new IllegalStateException("getService() returned null for " + trackedServiceReference);
1:             }
0:             return trackedService;
1:         }
1:     }
1: 
1:     private ServiceReference getServiceReference() throws InterruptedException {
1:         synchronized (monitor) {
1:             if (!optional) {
1:                 getService();
1:             }
1:             return trackedServiceReference;
1:         }
1:     }
1: 
1:     public class ServiceDispatcher implements Callable<Object> {
1: 
1:         public Object call() throws Exception {
1:             return getService();
1:         }
1: 
1:     }
1: 
1:     public class ServiceProxyWrapper implements AggregateConverter.Convertible {
1: 
1:         public Object convert(ReifiedType type) throws Exception {
1:             if (type.getRawClass() == ServiceReference.class) {
1:                 return getServiceReference();
1:             } else if (type.getRawClass().isInstance(proxy)) {
1:                 return proxy;
1:             } else {
1:                 throw new ComponentDefinitionException("Unable to convert to " + type);
1:             }
1:         }
1: 
1:     }
1: 
1: }
author:Holly Cummins
-------------------------------------------------------------------------------
commit:e3bd874
/////////////////////////////////////////////////////////////////////////
1:             	  trackedService = getServiceSecurely(trackedServiceReference);
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:0186986
/////////////////////////////////////////////////////////////////////////
0:               try {
0:               } catch (IllegalStateException ise) {
0:                 // In case the service no longer exists lets just cope and ignore.
1:               }
/////////////////////////////////////////////////////////////////////////
0:                 try {
0:                   getBundleContextForServiceLookup().ungetService(oldReference);
0:                 } catch (IllegalStateException ise) {
0:                   // In case the service no longer exists lets just cope and ignore.
1:                 }
commit:e104a3b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ExtendedReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
1:     private Object defaultBean;
/////////////////////////////////////////////////////////////////////////
1:             Object result = null;
1:                   boolean failed = true;
1:                   if (metadata.getAvailability() == ReferenceMetadata.AVAILABILITY_OPTIONAL && 
1:                       metadata instanceof ExtendedReferenceMetadata) {
1:                      if (defaultBean == null) {
1:                          String defaultBeanId = ((ExtendedReferenceMetadata)metadata).getDefaultBean();
1:                          if (defaultBeanId != null) {
1:                            defaultBean = blueprintContainer.getComponentInstance(defaultBeanId);
1:                            failed = false;
1:                          }
1:                      } else {
1:                          failed = false;
1:                      }
1:                      result = defaultBean;
1:                   } 
1:                   
1:                   if (failed) {
1:                   }
1:             } else {
1:             
0:               if (trackedService == null) {
0:                   trackedService = blueprintContainer.getService(trackedServiceReference);
1:               }
1:               
0:               if (trackedService == null) {
0:                   throw new IllegalStateException("getService() returned null for " + trackedServiceReference);
1:               }
1:               
1:               result = trackedService;
1:             return result;
commit:24455ce
/////////////////////////////////////////////////////////////////////////
1:             Set<Class<?>> interfaces = new HashSet<Class<?>>();
1:             Class<?> clz = getInterfaceClass();
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:324f059
/////////////////////////////////////////////////////////////////////////
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
0:             	  trackedService = AccessController.doPrivileged(new PrivilegedAction<Object>() {
0:             	    public Object run() {
0:             		  return getBundleContextForServiceLookup().getService(trackedServiceReference);
1:             		}
0:             	  });
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:4377012
/////////////////////////////////////////////////////////////////////////
1: import java.lang.ref.WeakReference;
0: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     private final Collection<Class<?>> proxyChildBeanClasses;
1:     private final Collection<WeakReference<Voidable>> proxiedChildren;
1:     
/////////////////////////////////////////////////////////////////////////
1:         if(metadata instanceof ExtendedReferenceMetadata) 
1:             proxyChildBeanClasses = ((ExtendedReferenceMetadata) metadata).getProxyChildBeanClasses();
1:         else 
1:             proxyChildBeanClasses = null;
1:         
1:         if (proxyChildBeanClasses != null)
1:             proxiedChildren = new ArrayList<WeakReference<Voidable>>();
1:         else
1:             proxiedChildren = null;
/////////////////////////////////////////////////////////////////////////
1:             ServiceReference oldReference = trackedServiceReference;
1:             voidProxiedChildren();
0:             if (oldReference != null) {
0:                 getBundleContextForServiceLookup().ungetService(oldReference);
1:             }
0:             monitor.notifyAll();
/////////////////////////////////////////////////////////////////////////
1:                 ServiceReference oldReference = trackedServiceReference;
1:                 voidProxiedChildren();
0:                 getBundleContextForServiceLookup().ungetService(oldReference);
/////////////////////////////////////////////////////////////////////////
1:     
1:     private void voidProxiedChildren() {
1:         if(proxyChildBeanClasses != null) {
1:             synchronized(proxiedChildren) {
1:                 for(Iterator<WeakReference<Voidable>> it = proxiedChildren.iterator(); it.hasNext();) {
1:                     Voidable v = it.next().get();
1:                     if(v == null)
1:                         it.remove();
1:                     else
1:                       v.voidReference();
1:                 }
1:             }
1:         }
1:     }
1:     
1:     public void addVoidableChild(Voidable v) {
1:         if(proxyChildBeanClasses != null) {
1:             synchronized (proxiedChildren) {
1:                 proxiedChildren.add(new WeakReference<Voidable>(v));
1:             }
1:         } else {
1:             throw new IllegalStateException("Proxying of child beans is disabled for this recipe");
1:         }
1:     }
1:     
1:     public Collection<Class<?>> getProxyChildBeanClasses() {
1:         return proxyChildBeanClasses;
1:     }
commit:b13e703
/////////////////////////////////////////////////////////////////////////
0:                 getBundleContextForServiceLookup().ungetService(trackedServiceReference);
/////////////////////////////////////////////////////////////////////////
0:                 getBundleContextForServiceLookup().ungetService(trackedServiceReference);
/////////////////////////////////////////////////////////////////////////
1:                 //Here we want to get the blueprint bundle itself, so don't use #getBundleContextForServiceLookup()
/////////////////////////////////////////////////////////////////////////
0:                   trackedService = getBundleContextForServiceLookup().getService(trackedServiceReference);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
commit:6163557
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
1:             if (isStarted() && trackedServiceReference == null && metadata.getTimeout() > 0
1:                     && metadata.getAvailability() == ServiceReferenceMetadata.AVAILABILITY_MANDATORY) {
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:2a55096
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             Class clz = getInterfaceClass();
1:             if (clz != null) interfaces.add(clz);
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
0: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.di.CollectionRecipe;
============================================================================