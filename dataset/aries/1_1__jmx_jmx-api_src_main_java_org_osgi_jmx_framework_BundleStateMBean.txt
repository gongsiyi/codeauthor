1:fdf3952: /*
1:fdf3952:  * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
1:a928ee9:  *
1:fdf3952:  * Licensed under the Apache License, Version 2.0 (the "License");
1:fdf3952:  * you may not use this file except in compliance with the License.
1:fdf3952:  * You may obtain a copy of the License at
24:fdf3952:  *
1:fdf3952:  *      http://www.apache.org/licenses/LICENSE-2.0
1:fdf3952:  *
1:fdf3952:  * Unless required by applicable law or agreed to in writing, software
1:fdf3952:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fdf3952:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fdf3952:  * See the License for the specific language governing permissions and
1:fdf3952:  * limitations under the License.
1:fdf3952:  */
2:fdf3952: 
1:fdf3952: package org.osgi.jmx.framework;
1:fdf3952: 
1:fdf3952: import java.io.IOException;
1:fdf3952: 
1:a928ee9: import javax.management.openmbean.CompositeData;
1:fdf3952: import javax.management.openmbean.CompositeType;
1:fdf3952: import javax.management.openmbean.SimpleType;
1:fdf3952: import javax.management.openmbean.TabularData;
1:fdf3952: import javax.management.openmbean.TabularType;
1:fdf3952: 
1:fdf3952: import org.osgi.jmx.Item;
1:fdf3952: import org.osgi.jmx.JmxConstants;
1:fdf3952: 
1:fdf3952: /**
1:fdf3952:  * This MBean represents the Bundle state of the framework. This MBean also
1:fdf3952:  * emits events that clients can use to get notified of the changes in the
1:fdf3952:  * bundle state of the framework.
1:a928ee9:  *
1:bf76d9d:  * @version $Id: f5d5197fdabb4e0c420bc47812d38fd14edb61d0 $
1:fdf3952:  * @ThreadSafe
1:fdf3952:  */
1:fdf3952: public interface BundleStateMBean {
1:fdf3952: 	/**
1:fdf3952: 	 * The Object Name for a Bundle State MBean.
1:fdf3952: 	 */
1:fdf3952: 	String OBJECTNAME = JmxConstants.OSGI_CORE
1:8c01963: 			+ ":type=bundleState,version=1.7";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key KEY, used in {@link #KEY_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String KEY = "Key";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item describing the key of a bundle header entry. The key is
1:fdf3952: 	 * {@link #KEY} and the type is {@link SimpleType#STRING}.
1:fdf3952: 	 */
1:fdf3952: 	Item KEY_ITEM = new Item(KEY, "The bundle header key", SimpleType.STRING);
1:fdf3952: 	/**
1:fdf3952: 	 * The key VALUE, used in {@link #VALUE_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String VALUE = "Value";
1:fdf3952: 	/**
1:fdf3952: 	 * The item describing the value of a bundle header entry. The key is
1:fdf3952: 	 * {@link #VALUE} and the type is {@link SimpleType#STRING}.
1:fdf3952: 	 */
1:fdf3952: 	Item VALUE_ITEM = new Item(VALUE, "The bundle header value",
1:fdf3952: 			SimpleType.STRING);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The Composite Type describing an entry in bundle headers. It consists of
1:fdf3952: 	 * {@link #KEY_ITEM} and {@link #VALUE_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	CompositeType HEADER_TYPE = Item.compositeType("HEADER",
1:fdf3952: 			"This type encapsulates OSGi bundle header key/value pairs",
1:fdf3952: 			KEY_ITEM, VALUE_ITEM);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The Tabular Type describing the type of the Tabular Data value that is
1:fdf3952: 	 * returned from {@link #getHeaders(long)} method. The primary item is
1:fdf3952: 	 * {@link #KEY_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	TabularType HEADERS_TYPE = Item.tabularType("HEADERS",
1:fdf3952: 																"The table of bundle headers",
1:fdf3952: 																HEADER_TYPE,
1:fdf3952: 																KEY);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key LOCATION, used in {@link #LOCATION_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String LOCATION = "Location";
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the bundle location in {@link #BUNDLE_TYPE}. The key
1:fdf3952: 	 * is {@link #LOCATION} and the the type is {@link SimpleType#STRING}.
1:fdf3952: 	 */
1:fdf3952: 	Item LOCATION_ITEM = new Item(LOCATION, "The location of the bundle",
1:fdf3952: 			SimpleType.STRING);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key IDENTIFIER, used in {@link #IDENTIFIER_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String IDENTIFIER = "Identifier";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the bundle identifier in {@link #BUNDLE_TYPE}. The
1:fdf3952: 	 * key is {@link #IDENTIFIER} and the the type is {@link SimpleType#LONG}.
1:fdf3952: 	 */
1:fdf3952: 	Item IDENTIFIER_ITEM = new Item(IDENTIFIER, "The id of the bundle",
1:fdf3952: 			SimpleType.LONG);
1:fdf3952: 	/**
1:fdf3952: 	 * The key SYMBOLIC_NAME, used in {@link #SYMBOLIC_NAME_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String SYMBOLIC_NAME = "SymbolicName";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the symbolic name in {@link #BUNDLE_TYPE}. The key is
1:fdf3952: 	 * {@link #SYMBOLIC_NAME} and the the type is {@link SimpleType#STRING}.
1:fdf3952: 	 */
1:fdf3952: 	Item SYMBOLIC_NAME_ITEM = new Item(SYMBOLIC_NAME,
1:fdf3952: 			"The symbolic name of the bundle", SimpleType.STRING);
1:fdf3952: 	/**
1:fdf3952: 	 * The key VERSION, used in {@link #VERSION_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String VERSION = "Version";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the symbolic name in {@link #BUNDLE_TYPE}. The key is
1:fdf3952: 	 * {@link #SYMBOLIC_NAME} and the the type is {@link SimpleType#STRING}.
1:fdf3952: 	 */
1:fdf3952: 	Item VERSION_ITEM = new Item(VERSION, "The version of the bundle",
1:fdf3952: 			SimpleType.STRING);
1:fdf3952: 	/**
1:fdf3952: 	 * The key START_LEVEL, used in {@link #START_LEVEL_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String START_LEVEL = "StartLevel";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the start level in {@link #BUNDLE_TYPE}. The key is
1:fdf3952: 	 * {@link #START_LEVEL} and the the type is {@link SimpleType#INTEGER}.
1:fdf3952: 	 */
1:fdf3952: 	Item START_LEVEL_ITEM = new Item(START_LEVEL,
1:fdf3952: 			"The start level of the bundle", SimpleType.INTEGER);
1:fdf3952: 	/**
1:fdf3952: 	 * The key STATE, used in {@link #STATE_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String STATE = "State";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Constant INSTALLED for the {@link #STATE}
1:fdf3952: 	 */
1:fdf3952: 	String INSTALLED = "INSTALLED";
1:fdf3952: 	/**
1:fdf3952: 	 * Constant RESOLVED for the {@link #STATE}
1:fdf3952: 	 */
1:fdf3952: 	String RESOLVED = "RESOLVED";
1:fdf3952: 	/**
1:fdf3952: 	 * Constant STARTING for the {@link #STATE}
1:fdf3952: 	 */
1:fdf3952: 	String STARTING = "STARTING";
1:fdf3952: 	/**
1:fdf3952: 	 * Constant ACTIVE for the {@link #STATE}
1:fdf3952: 	 */
1:fdf3952: 	String ACTIVE = "ACTIVE";
1:fdf3952: 	/**
1:fdf3952: 	 * Constant STOPPING for the {@link #STATE}
1:fdf3952: 	 */
1:fdf3952: 	String STOPPING = "STOPPING";
1:fdf3952: 	/**
1:fdf3952: 	 * Constant UNINSTALLED for the {@link #STATE}
1:fdf3952: 	 */
1:fdf3952: 	String UNINSTALLED = "UNINSTALLED";
1:fdf3952: 	/**
1:fdf3952: 	 * Constant UNKNOWN for the {@link #STATE}
1:fdf3952: 	 */
1:fdf3952: 	String UNKNOWN = "UNKNOWN";
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the bundle state in {@link #BUNDLE_TYPE}. The key is
1:fdf3952: 	 * {@link #STATE} and the the type is {@link SimpleType#STRING}. The
1:fdf3952: 	 * returned values must be one of the following strings:
1:fdf3952: 	 * <ul>
1:fdf3952: 	 * <li>{@link #INSTALLED}</li>
1:fdf3952: 	 * <li>{@link #RESOLVED}</li>
1:fdf3952: 	 * <li>{@link #STARTING}</li>
1:fdf3952: 	 * <li>{@link #ACTIVE}</li>
1:fdf3952: 	 * <li>{@link #STOPPING}</li>
1:fdf3952: 	 * <li>{@link #UNINSTALLED}</li>
1:fdf3952: 	 * <li>{@link #UNKNOWN}</li>
1:fdf3952: 	 * </ul>
1:fdf3952: 	 */
1:fdf3952: 	Item STATE_ITEM = new Item(STATE, "The state of the bundle",
1:fdf3952: 			SimpleType.STRING, INSTALLED, RESOLVED, STARTING, ACTIVE, STOPPING,
1:fdf3952: 			UNINSTALLED, UNKNOWN);
1:fdf3952: 	/**
1:fdf3952: 	 * The key LAST_MODIFIED, used in {@link #LAST_MODIFIED_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String LAST_MODIFIED = "LastModified";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the last modified time in the {@link #BUNDLE_TYPE}.
1:fdf3952: 	 * The key is {@link #LAST_MODIFIED} and the the type is
1:fdf3952: 	 * {@link SimpleType#LONG}.
1:fdf3952: 	 */
1:fdf3952: 	Item LAST_MODIFIED_ITEM = new Item(LAST_MODIFIED,
1:fdf3952: 			"The last modification time of the bundle", SimpleType.LONG);
1:8020538: 
1:8020538: 	/**
1:8020538: 	 * The key ACTIVATION_POLICY_USED, used in {@link #ACTIVATION_POLICY_USED_ITEM}.
1:8020538: 	 */
1:8020538: 	String ACTIVATION_POLICY_USED = "ActivationPolicyUsed";
1:8020538: 
1:8020538: 	/**
1:8020538: 	 * The item containing the indication whether the bundle activation policy
1:8020538: 	 * must be used in {@link #BUNDLE_TYPE}. The key is {@link #ACTIVATION_POLICY_USED} and
1:8020538: 	 * the type is {@link SimpleType#BOOLEAN}.
1:8020538: 	 */
1:8020538: 	Item ACTIVATION_POLICY_USED_ITEM = new Item(ACTIVATION_POLICY_USED,
1:8020538: 	        "Whether the bundle activation policy must be used", SimpleType.BOOLEAN);
1:8020538: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key PERSISTENTLY_STARTED, used in {@link #PERSISTENTLY_STARTED_ITEM}.
1:fdf3952: 	 */
1:8020538: 	String PERSISTENTLY_STARTED = "PersistentlyStarted";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the indication of persistently started in
1:fdf3952: 	 * {@link #BUNDLE_TYPE}. The key is {@link #PERSISTENTLY_STARTED} and the
1:fdf3952: 	 * the type is {@link SimpleType#BOOLEAN}.
1:fdf3952: 	 */
1:fdf3952: 	Item PERSISTENTLY_STARTED_ITEM = new Item(PERSISTENTLY_STARTED,
1:fdf3952: 			"Whether the bundle is persistently started", SimpleType.BOOLEAN);
1:fdf3952: 	/**
1:fdf3952: 	 * The key REMOVAL_PENDING, used in {@link #REMOVAL_PENDING_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String REMOVAL_PENDING = "RemovalPending";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the indication of removal pending in
1:fdf3952: 	 * {@link #BUNDLE_TYPE}. The key is {@link #REMOVAL_PENDING} and the type is
1:fdf3952: 	 * {@link SimpleType#BOOLEAN}.
1:fdf3952: 	 */
1:fdf3952: 	Item REMOVAL_PENDING_ITEM = new Item(REMOVAL_PENDING,
1:fdf3952: 			"Whether the bundle is pending removal", SimpleType.BOOLEAN);
1:fdf3952: 	/**
1:fdf3952: 	 * The key REQUIRED, used in {@link #REQUIRED_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String REQUIRED = "Required";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the required status in {@link #BUNDLE_TYPE}. The key
1:fdf3952: 	 * is {@link #REQUIRED} and the the type is {@link SimpleType#BOOLEAN}.
1:fdf3952: 	 */
1:fdf3952: 	Item REQUIRED_ITEM = new Item(REQUIRED, "Whether the bundle is required",
1:fdf3952: 			SimpleType.BOOLEAN);
1:fdf3952: 	/**
1:fdf3952: 	 * The key FRAGMENT, used in {@link #FRAGMENT_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String FRAGMENT = "Fragment";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the fragment status in {@link #BUNDLE_TYPE}. The key
1:fdf3952: 	 * is {@link #FRAGMENT} and the the type is {@link SimpleType#BOOLEAN}.
1:fdf3952: 	 */
1:fdf3952: 	Item FRAGMENT_ITEM = new Item(FRAGMENT, "Whether the bundle is a fragment",
1:fdf3952: 			SimpleType.BOOLEAN);
1:fdf3952: 	/**
1:fdf3952: 	 * The key REGISTERED_SERVICES, used in {@link #REGISTERED_SERVICES_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String REGISTERED_SERVICES = "RegisteredServices";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the registered services of the bundle in
1:fdf3952: 	 * {@link #BUNDLE_TYPE}. The key is {@link #REGISTERED_SERVICES} and the the
1:fdf3952: 	 * type is {@link JmxConstants#LONG_ARRAY_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item REGISTERED_SERVICES_ITEM = new Item(REGISTERED_SERVICES,
1:fdf3952: 			"The registered services of the bundle",
1:fdf3952: 			JmxConstants.LONG_ARRAY_TYPE);
1:fdf3952: 	/**
1:fdf3952: 	 * The key SERVICES_IN_USE, used in {@link #SERVICES_IN_USE_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String SERVICES_IN_USE = "ServicesInUse";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the services in use by this bundle in
1:fdf3952: 	 * {@link #BUNDLE_TYPE}. The key is {@link #SERVICES_IN_USE} and the the
1:fdf3952: 	 * type is {@link JmxConstants#LONG_ARRAY_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item SERVICES_IN_USE_ITEM = new Item(SERVICES_IN_USE,
1:fdf3952: 			"The services in use by the bundle", JmxConstants.LONG_ARRAY_TYPE);
1:fdf3952: 	/**
1:fdf3952: 	 * The key HEADERS, used in {@link #HEADERS_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String HEADERS = "Headers";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the bundle headers in {@link #BUNDLE_TYPE}. The key
1:fdf3952: 	 * is {@link #HEADERS} and the the type is {@link #HEADERS_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item HEADERS_ITEM = new Item(HEADERS, "The headers of the bundle",
1:fdf3952: 			HEADERS_TYPE);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key EXPORTED_PACKAGES, used in {@link #EXPORTED_PACKAGES_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String EXPORTED_PACKAGES = "ExportedPackages";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the exported package names in {@link #BUNDLE_TYPE}
1:fdf3952: 	 * .The key is {@link #EXPORTED_PACKAGES} and the the type is
1:fdf3952: 	 * {@link JmxConstants#STRING_ARRAY_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item EXPORTED_PACKAGES_ITEM = new Item(EXPORTED_PACKAGES,
1:fdf3952: 			"The exported packages of the bundle",
1:fdf3952: 			JmxConstants.STRING_ARRAY_TYPE);
1:fdf3952: 	/**
1:fdf3952: 	 * The key IMPORTED_PACKAGES, used in {@link #EXPORTED_PACKAGES_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String IMPORTED_PACKAGES = "ImportedPackages";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the imported package names in {@link #BUNDLE_TYPE}
1:fdf3952: 	 * .The key is {@link #IMPORTED_PACKAGES} and the the type is
1:fdf3952: 	 * {@link JmxConstants#STRING_ARRAY_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item IMPORTED_PACKAGES_ITEM = new Item(IMPORTED_PACKAGES,
1:fdf3952: 			"The imported packages of the bundle",
1:fdf3952: 			JmxConstants.STRING_ARRAY_TYPE);
1:fdf3952: 	/**
1:fdf3952: 	 * The key FRAGMENTS, used in {@link #FRAGMENTS_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String FRAGMENTS = "Fragments";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the list of fragments the bundle is host to in
1:fdf3952: 	 * {@link #BUNDLE_TYPE}. The key is {@link #FRAGMENTS} and the type is
1:fdf3952: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item FRAGMENTS_ITEM = new Item(FRAGMENTS,
1:fdf3952: 			"The fragments of which the bundle is host",
1:fdf3952: 			JmxConstants.LONG_ARRAY_TYPE);
1:fdf3952: 	/**
1:fdf3952: 	 * The key HOSTS, used in {@link #HOSTS_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String HOSTS = "Hosts";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the bundle identifiers representing the hosts in
1:fdf3952: 	 * {@link #BUNDLE_TYPE}. The key is {@link #HOSTS} and the type is
1:fdf3952: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}
1:fdf3952: 	 */
1:fdf3952: 	Item HOSTS_ITEM = new Item(HOSTS,
1:fdf3952: 			"The fragments of which the bundle is host",
1:fdf3952: 			JmxConstants.LONG_ARRAY_TYPE);
1:fdf3952: 	/**
1:fdf3952: 	 * The key REQUIRED_BUNDLES, used in {@link #REQUIRED_BUNDLES_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String REQUIRED_BUNDLES = "RequiredBundles";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the required bundles in {@link #BUNDLE_TYPE}. The key
1:fdf3952: 	 * is {@link #REQUIRED_BUNDLES} and the type is
1:fdf3952: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}
1:fdf3952: 	 */
1:fdf3952: 	Item REQUIRED_BUNDLES_ITEM = new Item(REQUIRED_BUNDLES,
1:fdf3952: 			"The required bundles the bundle", JmxConstants.LONG_ARRAY_TYPE);
1:fdf3952: 	/**
1:fdf3952: 	 * The key REQUIRING_BUNDLES, used in {@link #REQUIRING_BUNDLES_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String REQUIRING_BUNDLES = "RequiringBundles";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the bundles requiring this bundle in
1:fdf3952: 	 * {@link #BUNDLE_TYPE}. The key is {@link #REQUIRING_BUNDLES} and the type
1:fdf3952: 	 * is {@link JmxConstants#LONG_ARRAY_TYPE}
1:fdf3952: 	 */
1:fdf3952: 	Item REQUIRING_BUNDLES_ITEM = new Item(REQUIRING_BUNDLES,
1:fdf3952: 			"The bundles requiring the bundle", JmxConstants.LONG_ARRAY_TYPE);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key EVENT, used in {@link #EVENT_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String EVENT = "BundleEvent";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the event type.  The key is {@link #EVENT} and the type is {@link SimpleType#INTEGER}
1:fdf3952: 	 */
1:fdf3952: 	Item EVENT_ITEM = new Item(
1:fdf3952: 			EVENT,
1:fdf3952: 			"The type of the event: {INSTALLED=1, STARTED=2, STOPPED=4, UPDATED=8, UNINSTALLED=16}",
1:fdf3952: 			SimpleType.INTEGER);
1:a928ee9: 
1:fdf3952: 	/**
1:fdf3952: 	 * The Composite Type that represents a bundle event.  This composite consists of:
1:fdf3952: 	 * <ul>
1:fdf3952: 	 * <li>{@link #IDENTIFIER}</li>
1:fdf3952: 	 * <li>{@link #LOCATION}</li>
1:fdf3952: 	 * <li>{@link #SYMBOLIC_NAME}</li>
1:fdf3952: 	 * <li>{@link #EVENT}</li>
1:fdf3952: 	 * </ul>
1:fdf3952: 	 */
1:fdf3952: 	CompositeType BUNDLE_EVENT_TYPE = Item.compositeType("BUNDLE_EVENT",
1:fdf3952: 			"This type encapsulates OSGi bundle events", IDENTIFIER_ITEM,
1:fdf3952: 			LOCATION_ITEM, SYMBOLIC_NAME_ITEM, EVENT_ITEM);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The Composite Type that represents a bundle. This composite consist of:
1:fdf3952: 	 * <ul>
1:fdf3952: 	 * <li>{@link #EXPORTED_PACKAGES}</li>
1:fdf3952: 	 * <li>{@link #FRAGMENT}</li>
1:fdf3952: 	 * <li>{@link #FRAGMENTS}</li>
1:fdf3952: 	 * <li>{@link #HEADERS}</li>
1:fdf3952: 	 * <li>{@link #HOSTS}</li>
1:fdf3952: 	 * <li>{@link #IDENTIFIER}</li>
1:fdf3952: 	 * <li>{@link #IMPORTED_PACKAGES}</li>
1:fdf3952: 	 * <li>{@link #LAST_MODIFIED}</li>
1:fdf3952: 	 * <li>{@link #LOCATION}</li>
1:8020538: 	 * <li>{@link #ACTIVATION_POLICY_USED}</li>
1:fdf3952: 	 * <li>{@link #PERSISTENTLY_STARTED}</li>
1:fdf3952: 	 * <li>{@link #REGISTERED_SERVICES}</li>
1:fdf3952: 	 * <li>{@link #REMOVAL_PENDING}</li>
1:fdf3952: 	 * <li>{@link #REQUIRED}</li>
1:fdf3952: 	 * <li>{@link #REQUIRED_BUNDLES}</li>
1:fdf3952: 	 * <li>{@link #REQUIRING_BUNDLES}</li>
1:fdf3952: 	 * <li>{@link #START_LEVEL}</li>
1:fdf3952: 	 * <li>{@link #STATE}</li>
1:fdf3952: 	 * <li>{@link #SERVICES_IN_USE}</li>
1:fdf3952: 	 * <li>{@link #SYMBOLIC_NAME}</li>
1:fdf3952: 	 * <li>{@link #VERSION}</li>
1:fdf3952: 	 * </ul>
1:fdf3952: 	 * It is used by {@link #BUNDLES_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	CompositeType BUNDLE_TYPE = Item.compositeType("BUNDLE",
1:fdf3952: 			"This type encapsulates OSGi bundles", EXPORTED_PACKAGES_ITEM,
1:fdf3952: 			FRAGMENT_ITEM, FRAGMENTS_ITEM, HEADERS_ITEM, HOSTS_ITEM,
1:fdf3952: 			IDENTIFIER_ITEM, IMPORTED_PACKAGES_ITEM, LAST_MODIFIED_ITEM,
1:8020538: 			LOCATION_ITEM, ACTIVATION_POLICY_USED_ITEM,
1:8020538: 			PERSISTENTLY_STARTED_ITEM, REGISTERED_SERVICES_ITEM,
1:fdf3952: 			REMOVAL_PENDING_ITEM, REQUIRED_ITEM, REQUIRED_BUNDLES_ITEM,
1:fdf3952: 			REQUIRING_BUNDLES_ITEM, START_LEVEL_ITEM, STATE_ITEM,
1:fdf3952: 			SERVICES_IN_USE_ITEM, SYMBOLIC_NAME_ITEM, VERSION_ITEM);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The Tabular Type for a list of bundles. The row type is
1:fdf3952: 	 * {@link #BUNDLE_TYPE} and the index is {@link #IDENTIFIER}.
1:fdf3952: 	 */
1:fdf3952: 	TabularType BUNDLES_TYPE = Item.tabularType("BUNDLES", "A list of bundles",
1:fdf3952: 																BUNDLE_TYPE,
1:fdf3952: 																IDENTIFIER);
1:fdf3952: 
1:bf76d9d: 	/** New!!
1:bf76d9d: 	 * @param id The Bundle ID
1:bf76d9d: 	 * @return The Bundle Data
1:bf76d9d: 	 * @throws IOException
1:bf76d9d: 	 */
1:bf76d9d: 	CompositeData getBundle(long id) throws IOException;
1:a928ee9: 
1:c4c8b5b: 	long[] getBundleIds() throws IOException;
1:c4c8b5b: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the list of identifiers of the bundles this bundle depends upon
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleIdentifier
1:fdf3952: 	 *            the bundle identifier
1:fdf3952: 	 * @return the list of bundle identifiers
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	long[] getRequiredBundles(long bundleIdentifier) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the bundle state of the system in tabular form.
1:a928ee9: 	 *
1:fdf3952: 	 * Each row of the returned table represents a single bundle. The Tabular
1:fdf3952: 	 * Data consists of Composite Data that is type by {@link #BUNDLES_TYPE}.
1:a928ee9: 	 *
1:fdf3952: 	 * @return the tabular representation of the bundle state
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 */
1:fdf3952: 	TabularData listBundles() throws IOException;
1:fdf3952: 
1:a928ee9: 	TabularData listBundles(String ... items) throws IOException;
1:a928ee9: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the list of exported packages for this bundle.
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 * @return the array of package names, combined with their version in the
1:fdf3952: 	 *         format &lt;packageName;version&gt;
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	String[] getExportedPackages(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the list of the bundle ids of the fragments associated with this
1:fdf3952: 	 * bundle
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 * @return the array of bundle identifiers
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	long[] getFragments(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the headers for the bundle uniquely identified by the bundle id.
1:fdf3952: 	 * The Tabular Data is typed by the {@link #HEADERS_TYPE}.
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the unique identifier of the bundle
1:fdf3952: 	 * @return the table of associated header key and values
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	TabularData getHeaders(long bundleId) throws IOException;
1:bf76d9d:     TabularData getHeaders(long bundleId, String locale) throws IOException;
1:a928ee9:     String getHeader(long bundleId, String key) throws IOException;
1:bf76d9d:     String getHeader(long bundleId, String key, String locale) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the list of bundle ids of the bundles which host a fragment
1:a928ee9: 	 *
1:fdf3952: 	 * @param fragment
1:fdf3952: 	 *            the bundle id of the fragment
1:fdf3952: 	 * @return the array of bundle identifiers
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	long[] getHosts(long fragment) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the array of the packages imported by this bundle
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the bundle identifier
1:fdf3952: 	 * @return the array of package names, combined with their version in the
1:fdf3952: 	 *         format &lt;packageName;version&gt;
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	String[] getImportedPackages(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the last modified time of a bundle
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the unique identifier of a bundle
1:fdf3952: 	 * @return the last modified time
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	long getLastModified(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the list of service identifiers representing the services this
1:fdf3952: 	 * bundle exports
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the bundle identifier
1:fdf3952: 	 * @return the list of service identifiers
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	long[] getRegisteredServices(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the list of identifiers of the bundles which require this bundle
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleIdentifier
1:fdf3952: 	 *            the bundle identifier
1:fdf3952: 	 * @return the list of bundle identifiers
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	long[] getRequiringBundles(long bundleIdentifier) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the list of service identifiers which refer to the the services
1:fdf3952: 	 * this bundle is using
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleIdentifier
1:fdf3952: 	 *            the bundle identifier
1:fdf3952: 	 * @return the list of service identifiers
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	long[] getServicesInUse(long bundleIdentifier) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the start level of the bundle
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the identifier of the bundle
1:fdf3952: 	 * @return the start level
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	int getStartLevel(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the symbolic name of the state of the bundle
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the identifier of the bundle
1:fdf3952: 	 * @return the string name of the bundle state
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	String getState(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the symbolic name of the bundle
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the identifier of the bundle
1:fdf3952: 	 * @return the symbolic name
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	String getSymbolicName(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:8020538: 	 * Answer whether the specified bundle's autostart setting indicates that
1:8020538: 	 * the activation policy declared in the bundle's manifest must be used.
1:8020538: 	 *
1:8020538: 	 * @param bundleId
1:8020538:      *            the identifier of the bundle
1:8020538: 	 * @return true if the bundle's autostart setting indicates the activation policy
1:8020538: 	 * declared in the manifest must be used. false if the bundle must be eagerly activated.
1:8020538:      * @throws IOException
1:8020538:      *             if the operation fails
1:8020538:      * @throws IllegalArgumentException
1:8020538:      *             if the bundle indicated does not exist
1:8020538: 	 */
1:8020538: 	boolean isActivationPolicyUsed(long bundleId) throws IOException;
1:8020538: 
1:8020538: 	/**
1:fdf3952: 	 * Answer if the bundle is persistently started when its start level is
1:fdf3952: 	 * reached
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the identifier of the bundle
1:fdf3952: 	 * @return true if the bundle is persistently started
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	boolean isPersistentlyStarted(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer whether the bundle is a fragment or not
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the identifier of the bundle
1:fdf3952: 	 * @return true if the bundle is a fragment
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	boolean isFragment(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer true if the bundle is pending removal
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the identifier of the bundle
1:fdf3952: 	 * @return true if the bundle is pending removal
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	boolean isRemovalPending(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer true if the bundle is required by another bundle
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the identifier of the bundle
1:fdf3952: 	 * @return true if the bundle is required by another bundle
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	boolean isRequired(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the location of the bundle.
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the identifier of the bundle
1:fdf3952: 	 * @return The location string of this bundle
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	String getLocation(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the location of the bundle.
1:a928ee9: 	 *
1:fdf3952: 	 * @param bundleId
1:fdf3952: 	 *            the identifier of the bundle
1:fdf3952: 	 * @return The location string of this bundle
1:fdf3952: 	 * @throws IOException
1:fdf3952: 	 *             if the operation fails
1:fdf3952: 	 * @throws IllegalArgumentException
1:fdf3952: 	 *             if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	String getVersion(long bundleId) throws IOException;
1:fdf3952: 
1:fdf3952: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:0273964
commit:c4c8b5b
/////////////////////////////////////////////////////////////////////////
1: 	long[] getBundleIds() throws IOException;
1: 
commit:8020538
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * The key ACTIVATION_POLICY_USED, used in {@link #ACTIVATION_POLICY_USED_ITEM}.
1: 	 */
1: 	String ACTIVATION_POLICY_USED = "ActivationPolicyUsed";
1: 
1: 	/**
1: 	 * The item containing the indication whether the bundle activation policy
1: 	 * must be used in {@link #BUNDLE_TYPE}. The key is {@link #ACTIVATION_POLICY_USED} and
1: 	 * the type is {@link SimpleType#BOOLEAN}.
1: 	 */
1: 	Item ACTIVATION_POLICY_USED_ITEM = new Item(ACTIVATION_POLICY_USED,
1: 	        "Whether the bundle activation policy must be used", SimpleType.BOOLEAN);
1: 
1: 	String PERSISTENTLY_STARTED = "PersistentlyStarted";
/////////////////////////////////////////////////////////////////////////
1: 	 * <li>{@link #ACTIVATION_POLICY_USED}</li>
/////////////////////////////////////////////////////////////////////////
1: 			LOCATION_ITEM, ACTIVATION_POLICY_USED_ITEM,
1: 			PERSISTENTLY_STARTED_ITEM, REGISTERED_SERVICES_ITEM,
/////////////////////////////////////////////////////////////////////////
1: 	 * Answer whether the specified bundle's autostart setting indicates that
1: 	 * the activation policy declared in the bundle's manifest must be used.
1: 	 *
1: 	 * @param bundleId
1:      *            the identifier of the bundle
1: 	 * @return true if the bundle's autostart setting indicates the activation policy
1: 	 * declared in the manifest must be used. false if the bundle must be eagerly activated.
1:      * @throws IOException
1:      *             if the operation fails
1:      * @throws IllegalArgumentException
1:      *             if the bundle indicated does not exist
1: 	 */
1: 	boolean isActivationPolicyUsed(long bundleId) throws IOException;
1: 
1: 	/**
commit:bf76d9d
/////////////////////////////////////////////////////////////////////////
1:  * @version $Id: f5d5197fdabb4e0c420bc47812d38fd14edb61d0 $
/////////////////////////////////////////////////////////////////////////
1: 	/** New!!
1: 	 * @param id The Bundle ID
1: 	 * @return The Bundle Data
1: 	 * @throws IOException
1: 	 */
1: 	CompositeData getBundle(long id) throws IOException;
/////////////////////////////////////////////////////////////////////////
1:     TabularData getHeaders(long bundleId, String locale) throws IOException;
1:     String getHeader(long bundleId, String key, String locale) throws IOException;
commit:8c01963
/////////////////////////////////////////////////////////////////////////
1: 			+ ":type=bundleState,version=1.7";
commit:a928ee9
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1: import javax.management.openmbean.CompositeData;
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     CompositeData getBundle(long id) throws IOException;
1: 
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
1: 	TabularData listBundles(String ... items) throws IOException;
1: 
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1:     String getHeader(long bundleId, String key) throws IOException;
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
commit:fdf3952
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
1:  * 
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.osgi.jmx.framework;
1: 
1: import java.io.IOException;
1: 
1: import javax.management.openmbean.CompositeType;
1: import javax.management.openmbean.SimpleType;
1: import javax.management.openmbean.TabularData;
1: import javax.management.openmbean.TabularType;
1: 
1: import org.osgi.jmx.Item;
1: import org.osgi.jmx.JmxConstants;
1: 
1: /**
1:  * This MBean represents the Bundle state of the framework. This MBean also
1:  * emits events that clients can use to get notified of the changes in the
1:  * bundle state of the framework.
1:  * 
0:  * @version $Revision$
1:  * @ThreadSafe
1:  */
1: public interface BundleStateMBean {
1: 	/**
1: 	 * The Object Name for a Bundle State MBean.
1: 	 */
1: 	String OBJECTNAME = JmxConstants.OSGI_CORE
0: 			+ ":type=bundleState,version=1.5";
1: 
1: 	/**
1: 	 * The key KEY, used in {@link #KEY_ITEM}.
1: 	 */
1: 	String KEY = "Key";
1: 
1: 	/**
1: 	 * The item describing the key of a bundle header entry. The key is
1: 	 * {@link #KEY} and the type is {@link SimpleType#STRING}.
1: 	 */
1: 	Item KEY_ITEM = new Item(KEY, "The bundle header key", SimpleType.STRING);
1: 	/**
1: 	 * The key VALUE, used in {@link #VALUE_ITEM}.
1: 	 */
1: 	String VALUE = "Value";
1: 	/**
1: 	 * The item describing the value of a bundle header entry. The key is
1: 	 * {@link #VALUE} and the type is {@link SimpleType#STRING}.
1: 	 */
1: 	Item VALUE_ITEM = new Item(VALUE, "The bundle header value",
1: 			SimpleType.STRING);
1: 
1: 	/**
1: 	 * The Composite Type describing an entry in bundle headers. It consists of
1: 	 * {@link #KEY_ITEM} and {@link #VALUE_ITEM}.
1: 	 */
1: 	CompositeType HEADER_TYPE = Item.compositeType("HEADER",
1: 			"This type encapsulates OSGi bundle header key/value pairs",
1: 			KEY_ITEM, VALUE_ITEM);
1: 
1: 	/**
1: 	 * The Tabular Type describing the type of the Tabular Data value that is
1: 	 * returned from {@link #getHeaders(long)} method. The primary item is
1: 	 * {@link #KEY_ITEM}.
1: 	 */
1: 	TabularType HEADERS_TYPE = Item.tabularType("HEADERS",
1: 																"The table of bundle headers",
1: 																HEADER_TYPE,
1: 																KEY);
1: 
1: 	/**
1: 	 * The key LOCATION, used in {@link #LOCATION_ITEM}.
1: 	 */
1: 	String LOCATION = "Location";
1: 	/**
1: 	 * The item containing the bundle location in {@link #BUNDLE_TYPE}. The key
1: 	 * is {@link #LOCATION} and the the type is {@link SimpleType#STRING}.
1: 	 */
1: 	Item LOCATION_ITEM = new Item(LOCATION, "The location of the bundle",
1: 			SimpleType.STRING);
1: 
1: 	/**
1: 	 * The key IDENTIFIER, used in {@link #IDENTIFIER_ITEM}.
1: 	 */
1: 	String IDENTIFIER = "Identifier";
1: 
1: 	/**
1: 	 * The item containing the bundle identifier in {@link #BUNDLE_TYPE}. The
1: 	 * key is {@link #IDENTIFIER} and the the type is {@link SimpleType#LONG}.
1: 	 */
1: 	Item IDENTIFIER_ITEM = new Item(IDENTIFIER, "The id of the bundle",
1: 			SimpleType.LONG);
1: 	/**
1: 	 * The key SYMBOLIC_NAME, used in {@link #SYMBOLIC_NAME_ITEM}.
1: 	 */
1: 	String SYMBOLIC_NAME = "SymbolicName";
1: 
1: 	/**
1: 	 * The item containing the symbolic name in {@link #BUNDLE_TYPE}. The key is
1: 	 * {@link #SYMBOLIC_NAME} and the the type is {@link SimpleType#STRING}.
1: 	 */
1: 	Item SYMBOLIC_NAME_ITEM = new Item(SYMBOLIC_NAME,
1: 			"The symbolic name of the bundle", SimpleType.STRING);
1: 	/**
1: 	 * The key VERSION, used in {@link #VERSION_ITEM}.
1: 	 */
1: 	String VERSION = "Version";
1: 
1: 	/**
1: 	 * The item containing the symbolic name in {@link #BUNDLE_TYPE}. The key is
1: 	 * {@link #SYMBOLIC_NAME} and the the type is {@link SimpleType#STRING}.
1: 	 */
1: 	Item VERSION_ITEM = new Item(VERSION, "The version of the bundle",
1: 			SimpleType.STRING);
1: 	/**
1: 	 * The key START_LEVEL, used in {@link #START_LEVEL_ITEM}.
1: 	 */
1: 	String START_LEVEL = "StartLevel";
1: 
1: 	/**
1: 	 * The item containing the start level in {@link #BUNDLE_TYPE}. The key is
1: 	 * {@link #START_LEVEL} and the the type is {@link SimpleType#INTEGER}.
1: 	 */
1: 	Item START_LEVEL_ITEM = new Item(START_LEVEL,
1: 			"The start level of the bundle", SimpleType.INTEGER);
1: 	/**
1: 	 * The key STATE, used in {@link #STATE_ITEM}.
1: 	 */
1: 	String STATE = "State";
1: 
1: 	/**
1: 	 * Constant INSTALLED for the {@link #STATE}
1: 	 */
1: 	String INSTALLED = "INSTALLED";
1: 	/**
1: 	 * Constant RESOLVED for the {@link #STATE}
1: 	 */
1: 	String RESOLVED = "RESOLVED";
1: 	/**
1: 	 * Constant STARTING for the {@link #STATE}
1: 	 */
1: 	String STARTING = "STARTING";
1: 	/**
1: 	 * Constant ACTIVE for the {@link #STATE}
1: 	 */
1: 	String ACTIVE = "ACTIVE";
1: 	/**
1: 	 * Constant STOPPING for the {@link #STATE}
1: 	 */
1: 	String STOPPING = "STOPPING";
1: 	/**
1: 	 * Constant UNINSTALLED for the {@link #STATE}
1: 	 */
1: 	String UNINSTALLED = "UNINSTALLED";
1: 	/**
1: 	 * Constant UNKNOWN for the {@link #STATE}
1: 	 */
1: 	String UNKNOWN = "UNKNOWN";
1: 	/**
1: 	 * The item containing the bundle state in {@link #BUNDLE_TYPE}. The key is
1: 	 * {@link #STATE} and the the type is {@link SimpleType#STRING}. The
1: 	 * returned values must be one of the following strings:
1: 	 * <ul>
1: 	 * <li>{@link #INSTALLED}</li>
1: 	 * <li>{@link #RESOLVED}</li>
1: 	 * <li>{@link #STARTING}</li>
1: 	 * <li>{@link #ACTIVE}</li>
1: 	 * <li>{@link #STOPPING}</li>
1: 	 * <li>{@link #UNINSTALLED}</li>
1: 	 * <li>{@link #UNKNOWN}</li>
1: 	 * </ul>
1: 	 */
1: 	Item STATE_ITEM = new Item(STATE, "The state of the bundle",
1: 			SimpleType.STRING, INSTALLED, RESOLVED, STARTING, ACTIVE, STOPPING,
1: 			UNINSTALLED, UNKNOWN);
1: 	/**
1: 	 * The key LAST_MODIFIED, used in {@link #LAST_MODIFIED_ITEM}.
1: 	 */
1: 	String LAST_MODIFIED = "LastModified";
1: 
1: 	/**
1: 	 * The item containing the last modified time in the {@link #BUNDLE_TYPE}.
1: 	 * The key is {@link #LAST_MODIFIED} and the the type is
1: 	 * {@link SimpleType#LONG}.
1: 	 */
1: 	Item LAST_MODIFIED_ITEM = new Item(LAST_MODIFIED,
1: 			"The last modification time of the bundle", SimpleType.LONG);
1: 	/**
1: 	 * The key PERSISTENTLY_STARTED, used in {@link #PERSISTENTLY_STARTED_ITEM}.
1: 	 */
0: 	String			PERSISTENTLY_STARTED		= "PersistentlyStarted";
1: 
1: 	/**
1: 	 * The item containing the indication of persistently started in
1: 	 * {@link #BUNDLE_TYPE}. The key is {@link #PERSISTENTLY_STARTED} and the
1: 	 * the type is {@link SimpleType#BOOLEAN}.
1: 	 */
1: 	Item PERSISTENTLY_STARTED_ITEM = new Item(PERSISTENTLY_STARTED,
1: 			"Whether the bundle is persistently started", SimpleType.BOOLEAN);
1: 	/**
1: 	 * The key REMOVAL_PENDING, used in {@link #REMOVAL_PENDING_ITEM}.
1: 	 */
1: 	String REMOVAL_PENDING = "RemovalPending";
1: 
1: 	/**
1: 	 * The item containing the indication of removal pending in
1: 	 * {@link #BUNDLE_TYPE}. The key is {@link #REMOVAL_PENDING} and the type is
1: 	 * {@link SimpleType#BOOLEAN}.
1: 	 */
1: 	Item REMOVAL_PENDING_ITEM = new Item(REMOVAL_PENDING,
1: 			"Whether the bundle is pending removal", SimpleType.BOOLEAN);
1: 	/**
1: 	 * The key REQUIRED, used in {@link #REQUIRED_ITEM}.
1: 	 */
1: 	String REQUIRED = "Required";
1: 
1: 	/**
1: 	 * The item containing the required status in {@link #BUNDLE_TYPE}. The key
1: 	 * is {@link #REQUIRED} and the the type is {@link SimpleType#BOOLEAN}.
1: 	 */
1: 	Item REQUIRED_ITEM = new Item(REQUIRED, "Whether the bundle is required",
1: 			SimpleType.BOOLEAN);
1: 	/**
1: 	 * The key FRAGMENT, used in {@link #FRAGMENT_ITEM}.
1: 	 */
1: 	String FRAGMENT = "Fragment";
1: 
1: 	/**
1: 	 * The item containing the fragment status in {@link #BUNDLE_TYPE}. The key
1: 	 * is {@link #FRAGMENT} and the the type is {@link SimpleType#BOOLEAN}.
1: 	 */
1: 	Item FRAGMENT_ITEM = new Item(FRAGMENT, "Whether the bundle is a fragment",
1: 			SimpleType.BOOLEAN);
1: 	/**
1: 	 * The key REGISTERED_SERVICES, used in {@link #REGISTERED_SERVICES_ITEM}.
1: 	 */
1: 	String REGISTERED_SERVICES = "RegisteredServices";
1: 
1: 	/**
1: 	 * The item containing the registered services of the bundle in
1: 	 * {@link #BUNDLE_TYPE}. The key is {@link #REGISTERED_SERVICES} and the the
1: 	 * type is {@link JmxConstants#LONG_ARRAY_TYPE}.
1: 	 */
1: 	Item REGISTERED_SERVICES_ITEM = new Item(REGISTERED_SERVICES,
1: 			"The registered services of the bundle",
1: 			JmxConstants.LONG_ARRAY_TYPE);
1: 	/**
1: 	 * The key SERVICES_IN_USE, used in {@link #SERVICES_IN_USE_ITEM}.
1: 	 */
1: 	String SERVICES_IN_USE = "ServicesInUse";
1: 
1: 	/**
1: 	 * The item containing the services in use by this bundle in
1: 	 * {@link #BUNDLE_TYPE}. The key is {@link #SERVICES_IN_USE} and the the
1: 	 * type is {@link JmxConstants#LONG_ARRAY_TYPE}.
1: 	 */
1: 	Item SERVICES_IN_USE_ITEM = new Item(SERVICES_IN_USE,
1: 			"The services in use by the bundle", JmxConstants.LONG_ARRAY_TYPE);
1: 	/**
1: 	 * The key HEADERS, used in {@link #HEADERS_ITEM}.
1: 	 */
1: 	String HEADERS = "Headers";
1: 
1: 	/**
1: 	 * The item containing the bundle headers in {@link #BUNDLE_TYPE}. The key
1: 	 * is {@link #HEADERS} and the the type is {@link #HEADERS_TYPE}.
1: 	 */
1: 	Item HEADERS_ITEM = new Item(HEADERS, "The headers of the bundle",
1: 			HEADERS_TYPE);
1: 
1: 	/**
1: 	 * The key EXPORTED_PACKAGES, used in {@link #EXPORTED_PACKAGES_ITEM}.
1: 	 */
1: 	String EXPORTED_PACKAGES = "ExportedPackages";
1: 
1: 	/**
1: 	 * The item containing the exported package names in {@link #BUNDLE_TYPE}
1: 	 * .The key is {@link #EXPORTED_PACKAGES} and the the type is
1: 	 * {@link JmxConstants#STRING_ARRAY_TYPE}.
1: 	 */
1: 	Item EXPORTED_PACKAGES_ITEM = new Item(EXPORTED_PACKAGES,
1: 			"The exported packages of the bundle",
1: 			JmxConstants.STRING_ARRAY_TYPE);
1: 	/**
1: 	 * The key IMPORTED_PACKAGES, used in {@link #EXPORTED_PACKAGES_ITEM}.
1: 	 */
1: 	String IMPORTED_PACKAGES = "ImportedPackages";
1: 
1: 	/**
1: 	 * The item containing the imported package names in {@link #BUNDLE_TYPE}
1: 	 * .The key is {@link #IMPORTED_PACKAGES} and the the type is
1: 	 * {@link JmxConstants#STRING_ARRAY_TYPE}.
1: 	 */
1: 	Item IMPORTED_PACKAGES_ITEM = new Item(IMPORTED_PACKAGES,
1: 			"The imported packages of the bundle",
1: 			JmxConstants.STRING_ARRAY_TYPE);
1: 	/**
1: 	 * The key FRAGMENTS, used in {@link #FRAGMENTS_ITEM}.
1: 	 */
1: 	String FRAGMENTS = "Fragments";
1: 
1: 	/**
1: 	 * The item containing the list of fragments the bundle is host to in
1: 	 * {@link #BUNDLE_TYPE}. The key is {@link #FRAGMENTS} and the type is
1: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}.
1: 	 */
1: 	Item FRAGMENTS_ITEM = new Item(FRAGMENTS,
1: 			"The fragments of which the bundle is host",
1: 			JmxConstants.LONG_ARRAY_TYPE);
1: 	/**
1: 	 * The key HOSTS, used in {@link #HOSTS_ITEM}.
1: 	 */
1: 	String HOSTS = "Hosts";
1: 
1: 	/**
1: 	 * The item containing the bundle identifiers representing the hosts in
1: 	 * {@link #BUNDLE_TYPE}. The key is {@link #HOSTS} and the type is
1: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}
1: 	 */
1: 	Item HOSTS_ITEM = new Item(HOSTS,
1: 			"The fragments of which the bundle is host",
1: 			JmxConstants.LONG_ARRAY_TYPE);
1: 	/**
1: 	 * The key REQUIRED_BUNDLES, used in {@link #REQUIRED_BUNDLES_ITEM}.
1: 	 */
1: 	String REQUIRED_BUNDLES = "RequiredBundles";
1: 
1: 	/**
1: 	 * The item containing the required bundles in {@link #BUNDLE_TYPE}. The key
1: 	 * is {@link #REQUIRED_BUNDLES} and the type is
1: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}
1: 	 */
1: 	Item REQUIRED_BUNDLES_ITEM = new Item(REQUIRED_BUNDLES,
1: 			"The required bundles the bundle", JmxConstants.LONG_ARRAY_TYPE);
1: 	/**
1: 	 * The key REQUIRING_BUNDLES, used in {@link #REQUIRING_BUNDLES_ITEM}.
1: 	 */
1: 	String REQUIRING_BUNDLES = "RequiringBundles";
1: 
1: 	/**
1: 	 * The item containing the bundles requiring this bundle in
1: 	 * {@link #BUNDLE_TYPE}. The key is {@link #REQUIRING_BUNDLES} and the type
1: 	 * is {@link JmxConstants#LONG_ARRAY_TYPE}
1: 	 */
1: 	Item REQUIRING_BUNDLES_ITEM = new Item(REQUIRING_BUNDLES,
1: 			"The bundles requiring the bundle", JmxConstants.LONG_ARRAY_TYPE);
1: 
1: 	/**
1: 	 * The key EVENT, used in {@link #EVENT_ITEM}.
1: 	 */
1: 	String EVENT = "BundleEvent";
1: 
1: 	/**
1: 	 * The item containing the event type.  The key is {@link #EVENT} and the type is {@link SimpleType#INTEGER}
1: 	 */
1: 	Item EVENT_ITEM = new Item(
1: 			EVENT,
1: 			"The type of the event: {INSTALLED=1, STARTED=2, STOPPED=4, UPDATED=8, UNINSTALLED=16}",
1: 			SimpleType.INTEGER);
1: 	
1: 	/**
1: 	 * The Composite Type that represents a bundle event.  This composite consists of:
1: 	 * <ul>
1: 	 * <li>{@link #IDENTIFIER}</li>
1: 	 * <li>{@link #LOCATION}</li>
1: 	 * <li>{@link #SYMBOLIC_NAME}</li>
1: 	 * <li>{@link #EVENT}</li>
1: 	 * </ul>
1: 	 */
1: 	CompositeType BUNDLE_EVENT_TYPE = Item.compositeType("BUNDLE_EVENT",
1: 			"This type encapsulates OSGi bundle events", IDENTIFIER_ITEM,
1: 			LOCATION_ITEM, SYMBOLIC_NAME_ITEM, EVENT_ITEM);
1: 
1: 	/**
1: 	 * The Composite Type that represents a bundle. This composite consist of:
1: 	 * <ul>
1: 	 * <li>{@link #EXPORTED_PACKAGES}</li>
1: 	 * <li>{@link #FRAGMENT}</li>
1: 	 * <li>{@link #FRAGMENTS}</li>
1: 	 * <li>{@link #HEADERS}</li>
1: 	 * <li>{@link #HOSTS}</li>
1: 	 * <li>{@link #IDENTIFIER}</li>
1: 	 * <li>{@link #IMPORTED_PACKAGES}</li>
1: 	 * <li>{@link #LAST_MODIFIED}</li>
1: 	 * <li>{@link #LOCATION}</li>
1: 	 * <li>{@link #PERSISTENTLY_STARTED}</li>
1: 	 * <li>{@link #REGISTERED_SERVICES}</li>
1: 	 * <li>{@link #REMOVAL_PENDING}</li>
1: 	 * <li>{@link #REQUIRED}</li>
1: 	 * <li>{@link #REQUIRED_BUNDLES}</li>
1: 	 * <li>{@link #REQUIRING_BUNDLES}</li>
1: 	 * <li>{@link #START_LEVEL}</li>
1: 	 * <li>{@link #STATE}</li>
1: 	 * <li>{@link #SERVICES_IN_USE}</li>
1: 	 * <li>{@link #SYMBOLIC_NAME}</li>
1: 	 * <li>{@link #VERSION}</li>
1: 	 * </ul>
1: 	 * It is used by {@link #BUNDLES_TYPE}.
1: 	 */
1: 	CompositeType BUNDLE_TYPE = Item.compositeType("BUNDLE",
1: 			"This type encapsulates OSGi bundles", EXPORTED_PACKAGES_ITEM,
1: 			FRAGMENT_ITEM, FRAGMENTS_ITEM, HEADERS_ITEM, HOSTS_ITEM,
1: 			IDENTIFIER_ITEM, IMPORTED_PACKAGES_ITEM, LAST_MODIFIED_ITEM,
0: 			LOCATION_ITEM, PERSISTENTLY_STARTED_ITEM, REGISTERED_SERVICES_ITEM,
1: 			REMOVAL_PENDING_ITEM, REQUIRED_ITEM, REQUIRED_BUNDLES_ITEM,
1: 			REQUIRING_BUNDLES_ITEM, START_LEVEL_ITEM, STATE_ITEM,
1: 			SERVICES_IN_USE_ITEM, SYMBOLIC_NAME_ITEM, VERSION_ITEM);
1: 
1: 	/**
1: 	 * The Tabular Type for a list of bundles. The row type is
1: 	 * {@link #BUNDLE_TYPE} and the index is {@link #IDENTIFIER}.
1: 	 */
1: 	TabularType BUNDLES_TYPE = Item.tabularType("BUNDLES", "A list of bundles",
1: 																BUNDLE_TYPE,
1: 																IDENTIFIER);
1: 
1: 	/**
1: 	 * Answer the list of identifiers of the bundles this bundle depends upon
1: 	 * 
1: 	 * @param bundleIdentifier
1: 	 *            the bundle identifier
1: 	 * @return the list of bundle identifiers
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	long[] getRequiredBundles(long bundleIdentifier) throws IOException;
1: 
1: 	/**
1: 	 * Answer the bundle state of the system in tabular form.
1: 	 * 
1: 	 * Each row of the returned table represents a single bundle. The Tabular
1: 	 * Data consists of Composite Data that is type by {@link #BUNDLES_TYPE}.
1: 	 * 
1: 	 * @return the tabular representation of the bundle state
1: 	 * @throws IOException
1: 	 */
1: 	TabularData listBundles() throws IOException;
1: 
1: 	/**
1: 	 * Answer the list of exported packages for this bundle.
1: 	 * 
1: 	 * @param bundleId
1: 	 * @return the array of package names, combined with their version in the
1: 	 *         format &lt;packageName;version&gt;
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	String[] getExportedPackages(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the list of the bundle ids of the fragments associated with this
1: 	 * bundle
1: 	 * 
1: 	 * @param bundleId
1: 	 * @return the array of bundle identifiers
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	long[] getFragments(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the headers for the bundle uniquely identified by the bundle id.
1: 	 * The Tabular Data is typed by the {@link #HEADERS_TYPE}.
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the unique identifier of the bundle
1: 	 * @return the table of associated header key and values
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	TabularData getHeaders(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the list of bundle ids of the bundles which host a fragment
1: 	 * 
1: 	 * @param fragment
1: 	 *            the bundle id of the fragment
1: 	 * @return the array of bundle identifiers
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	long[] getHosts(long fragment) throws IOException;
1: 
1: 	/**
1: 	 * Answer the array of the packages imported by this bundle
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the bundle identifier
1: 	 * @return the array of package names, combined with their version in the
1: 	 *         format &lt;packageName;version&gt;
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	String[] getImportedPackages(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the last modified time of a bundle
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the unique identifier of a bundle
1: 	 * @return the last modified time
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	long getLastModified(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the list of service identifiers representing the services this
1: 	 * bundle exports
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the bundle identifier
1: 	 * @return the list of service identifiers
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	long[] getRegisteredServices(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the list of identifiers of the bundles which require this bundle
1: 	 * 
1: 	 * @param bundleIdentifier
1: 	 *            the bundle identifier
1: 	 * @return the list of bundle identifiers
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	long[] getRequiringBundles(long bundleIdentifier) throws IOException;
1: 
1: 	/**
1: 	 * Answer the list of service identifiers which refer to the the services
1: 	 * this bundle is using
1: 	 * 
1: 	 * @param bundleIdentifier
1: 	 *            the bundle identifier
1: 	 * @return the list of service identifiers
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	long[] getServicesInUse(long bundleIdentifier) throws IOException;
1: 
1: 	/**
1: 	 * Answer the start level of the bundle
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the identifier of the bundle
1: 	 * @return the start level
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	int getStartLevel(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the symbolic name of the state of the bundle
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the identifier of the bundle
1: 	 * @return the string name of the bundle state
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	String getState(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the symbolic name of the bundle
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the identifier of the bundle
1: 	 * @return the symbolic name
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	String getSymbolicName(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer if the bundle is persistently started when its start level is
1: 	 * reached
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the identifier of the bundle
1: 	 * @return true if the bundle is persistently started
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	boolean isPersistentlyStarted(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer whether the bundle is a fragment or not
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the identifier of the bundle
1: 	 * @return true if the bundle is a fragment
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	boolean isFragment(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer true if the bundle is pending removal
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the identifier of the bundle
1: 	 * @return true if the bundle is pending removal
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	boolean isRemovalPending(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer true if the bundle is required by another bundle
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the identifier of the bundle
1: 	 * @return true if the bundle is required by another bundle
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	boolean isRequired(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the location of the bundle.
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the identifier of the bundle
1: 	 * @return The location string of this bundle
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	String getLocation(long bundleId) throws IOException;
1: 
1: 	/**
1: 	 * Answer the location of the bundle.
1: 	 * 
1: 	 * @param bundleId
1: 	 *            the identifier of the bundle
1: 	 * @return The location string of this bundle
1: 	 * @throws IOException
1: 	 *             if the operation fails
1: 	 * @throws IllegalArgumentException
1: 	 *             if the bundle indicated does not exist
1: 	 */
1: 	String getVersion(long bundleId) throws IOException;
1: 
1: }
============================================================================