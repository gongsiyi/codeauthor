1:79b20bc: /*
1:79b20bc:  * Licensed to the Apache Software Foundation (ASF) under one
1:79b20bc:  * or more contributor license agreements.  See the NOTICE file
1:79b20bc:  * distributed with this work for additional information
1:79b20bc:  * regarding copyright ownership.  The ASF licenses this file
1:79b20bc:  * to you under the Apache License, Version 2.0 (the
1:79b20bc:  * "License"); you may not use this file except in compliance
1:79b20bc:  * with the License.  You may obtain a copy of the License at
1:79b20bc:  *
1:79b20bc:  *   http://www.apache.org/licenses/LICENSE-2.0
1:79b20bc:  *
1:79b20bc:  * Unless required by applicable law or agreed to in writing,
1:79b20bc:  * software distributed under the License is distributed on an
1:79b20bc:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:79b20bc:  * KIND, either express or implied.  See the License for the
1:79b20bc:  * specific language governing permissions and limitations
1:79b20bc:  * under the License.
1:79b20bc:  */
1:79b20bc: package org.apache.aries.subsystem.core.content;
1:79b20bc: 
1:79b20bc: 
1:79b20bc: import java.io.BufferedReader;
1:79b20bc: import java.io.BufferedWriter;
1:79b20bc: import java.io.IOException;
1:79b20bc: import java.io.InputStream;
1:79b20bc: import java.io.InputStreamReader;
1:79b20bc: import java.io.OutputStream;
1:79b20bc: import java.io.OutputStreamWriter;
1:79b20bc: import java.io.PushbackReader;
1:79b20bc: import java.io.Writer;
1:79b20bc: import java.lang.reflect.Array;
1:79b20bc: import java.util.ArrayList;
1:79b20bc: import java.util.BitSet;
1:79b20bc: import java.util.Collection;
1:79b20bc: import java.util.Dictionary;
1:79b20bc: import java.util.Enumeration;
1:79b20bc: import java.util.HashMap;
1:79b20bc: import java.util.Hashtable;
1:79b20bc: import java.util.Iterator;
1:79b20bc: import java.util.List;
1:79b20bc: import java.util.Map;
1:79b20bc: 
1:79b20bc: 
1:79b20bc: /* This class was taken from the Felix Codebase to read Felix ConfigAdmin .config files. */
1:79b20bc: 
1:79b20bc: /**
1:79b20bc:  * The <code>ConfigurationHandler</code> class implements configuration reading
1:79b20bc:  * form a <code>java.io.InputStream</code> and writing to a
1:79b20bc:  * <code>java.io.OutputStream</code> on behalf of the
1:79b20bc:  * {@link FilePersistenceManager} class.
1:79b20bc:  *
1:79b20bc:  * <pre>
1:79b20bc:  * cfg = prop &quot;=&quot; value .
1:79b20bc:  *  prop = symbolic-name . // 1.4.2 of OSGi Core Specification
1:79b20bc:  *  symbolic-name = token { &quot;.&quot; token } .
1:79b20bc:  *  token = { [ 0..9 ] | [ a..z ] | [ A..Z ] | '_' | '-' } .
1:79b20bc:  *  value = [ type ] ( &quot;[&quot; values &quot;]&quot; | &quot;(&quot; values &quot;)&quot; | simple ) .
1:79b20bc:  *  values = simple { &quot;,&quot; simple } .
1:79b20bc:  *  simple = &quot;&quot;&quot; stringsimple &quot;&quot;&quot; .
1:79b20bc:  *  type = // 1-char type code .
1:79b20bc:  *  stringsimple = // quoted string representation of the value .
1:79b20bc:  * </pre>
1:79b20bc:  */
1:79b20bc: public class ConfigurationHandler
1:79b20bc: {
1:79b20bc:     protected static final String ENCODING = "UTF-8";
1:79b20bc: 
1:79b20bc:     protected static final int TOKEN_NAME = 'N';
1:79b20bc:     protected static final int TOKEN_EQ = '=';
1:79b20bc:     protected static final int TOKEN_ARR_OPEN = '[';
1:79b20bc:     protected static final int TOKEN_ARR_CLOS = ']';
1:79b20bc:     protected static final int TOKEN_VEC_OPEN = '(';
1:79b20bc:     protected static final int TOKEN_VEC_CLOS = ')';
1:79b20bc:     protected static final int TOKEN_COMMA = ',';
1:79b20bc:     protected static final int TOKEN_VAL_OPEN = '"'; // '{';
1:79b20bc:     protected static final int TOKEN_VAL_CLOS = '"'; // '}';
1:79b20bc: 
1:79b20bc:     // simple types (string & primitive wrappers)
1:79b20bc:     protected static final int TOKEN_SIMPLE_STRING = 'T';
1:79b20bc:     protected static final int TOKEN_SIMPLE_INTEGER = 'I';
1:79b20bc:     protected static final int TOKEN_SIMPLE_LONG = 'L';
1:79b20bc:     protected static final int TOKEN_SIMPLE_FLOAT = 'F';
1:79b20bc:     protected static final int TOKEN_SIMPLE_DOUBLE = 'D';
1:79b20bc:     protected static final int TOKEN_SIMPLE_BYTE = 'X';
1:79b20bc:     protected static final int TOKEN_SIMPLE_SHORT = 'S';
1:79b20bc:     protected static final int TOKEN_SIMPLE_CHARACTER = 'C';
1:79b20bc:     protected static final int TOKEN_SIMPLE_BOOLEAN = 'B';
1:79b20bc: 
1:79b20bc:     // primitives
1:79b20bc:     protected static final int TOKEN_PRIMITIVE_INT = 'i';
1:79b20bc:     protected static final int TOKEN_PRIMITIVE_LONG = 'l';
1:79b20bc:     protected static final int TOKEN_PRIMITIVE_FLOAT = 'f';
1:79b20bc:     protected static final int TOKEN_PRIMITIVE_DOUBLE = 'd';
1:79b20bc:     protected static final int TOKEN_PRIMITIVE_BYTE = 'x';
1:79b20bc:     protected static final int TOKEN_PRIMITIVE_SHORT = 's';
1:79b20bc:     protected static final int TOKEN_PRIMITIVE_CHAR = 'c';
1:79b20bc:     protected static final int TOKEN_PRIMITIVE_BOOLEAN = 'b';
1:79b20bc: 
1:79b20bc:     protected static final String CRLF = "\r\n";
1:79b20bc: 
1:79b20bc:     protected static final Map code2Type;
1:79b20bc:     protected static final Map type2Code;
1:79b20bc: 
1:79b20bc:     // set of valid characters for "symblic-name"
1:79b20bc:     private static final BitSet NAME_CHARS;
1:79b20bc:     private static final BitSet TOKEN_CHARS;
1:79b20bc: 
1:79b20bc:     static
1:79b20bc:     {
1:79b20bc:         type2Code = new HashMap();
1:79b20bc: 
1:79b20bc:         // simple (exclusive String whose type code is not written)
1:79b20bc:         type2Code.put( Integer.class, new Integer( TOKEN_SIMPLE_INTEGER ) );
1:79b20bc:         type2Code.put( Long.class, new Integer( TOKEN_SIMPLE_LONG ) );
1:79b20bc:         type2Code.put( Float.class, new Integer( TOKEN_SIMPLE_FLOAT ) );
1:79b20bc:         type2Code.put( Double.class, new Integer( TOKEN_SIMPLE_DOUBLE ) );
1:79b20bc:         type2Code.put( Byte.class, new Integer( TOKEN_SIMPLE_BYTE ) );
1:79b20bc:         type2Code.put( Short.class, new Integer( TOKEN_SIMPLE_SHORT ) );
1:79b20bc:         type2Code.put( Character.class, new Integer( TOKEN_SIMPLE_CHARACTER ) );
1:79b20bc:         type2Code.put( Boolean.class, new Integer( TOKEN_SIMPLE_BOOLEAN ) );
1:79b20bc: 
1:79b20bc:         // primitives
1:79b20bc:         type2Code.put( Integer.TYPE, new Integer( TOKEN_PRIMITIVE_INT ) );
1:79b20bc:         type2Code.put( Long.TYPE, new Integer( TOKEN_PRIMITIVE_LONG ) );
1:79b20bc:         type2Code.put( Float.TYPE, new Integer( TOKEN_PRIMITIVE_FLOAT ) );
1:79b20bc:         type2Code.put( Double.TYPE, new Integer( TOKEN_PRIMITIVE_DOUBLE ) );
1:79b20bc:         type2Code.put( Byte.TYPE, new Integer( TOKEN_PRIMITIVE_BYTE ) );
1:79b20bc:         type2Code.put( Short.TYPE, new Integer( TOKEN_PRIMITIVE_SHORT ) );
1:79b20bc:         type2Code.put( Character.TYPE, new Integer( TOKEN_PRIMITIVE_CHAR ) );
1:79b20bc:         type2Code.put( Boolean.TYPE, new Integer( TOKEN_PRIMITIVE_BOOLEAN ) );
1:79b20bc: 
1:79b20bc:         // reverse map to map type codes to classes, string class mapping
1:79b20bc:         // to be added manually, as the string type code is not written and
1:79b20bc:         // hence not included in the type2Code map
1:79b20bc:         code2Type = new HashMap();
1:79b20bc:         for ( Iterator ti = type2Code.entrySet().iterator(); ti.hasNext(); )
1:79b20bc:         {
1:79b20bc:             Map.Entry entry = ( Map.Entry ) ti.next();
1:79b20bc:             code2Type.put( entry.getValue(), entry.getKey() );
1:79b20bc:         }
1:79b20bc:         code2Type.put( new Integer( TOKEN_SIMPLE_STRING ), String.class );
1:79b20bc: 
1:79b20bc:         NAME_CHARS = new BitSet();
1:79b20bc:         for ( int i = '0'; i <= '9'; i++ )
1:79b20bc:             NAME_CHARS.set( i );
1:79b20bc:         for ( int i = 'a'; i <= 'z'; i++ )
1:79b20bc:             NAME_CHARS.set( i );
1:79b20bc:         for ( int i = 'A'; i <= 'Z'; i++ )
1:79b20bc:             NAME_CHARS.set( i );
1:79b20bc:         NAME_CHARS.set( '_' );
1:79b20bc:         NAME_CHARS.set( '-' );
1:79b20bc:         NAME_CHARS.set( '.' );
1:79b20bc:         NAME_CHARS.set( '\\' );
1:79b20bc: 
1:79b20bc:         TOKEN_CHARS = new BitSet();
1:79b20bc:         TOKEN_CHARS.set( TOKEN_EQ );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_ARR_OPEN );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_ARR_CLOS );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_VEC_OPEN );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_VEC_CLOS );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_COMMA );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_VAL_OPEN );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_VAL_CLOS );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_SIMPLE_STRING );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_SIMPLE_INTEGER );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_SIMPLE_LONG );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_SIMPLE_FLOAT );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_SIMPLE_DOUBLE );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_SIMPLE_BYTE );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_SIMPLE_SHORT );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_SIMPLE_CHARACTER );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_SIMPLE_BOOLEAN );
1:79b20bc: 
1:79b20bc:         // primitives
1:79b20bc:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_INT );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_LONG );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_FLOAT );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_DOUBLE );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_BYTE );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_SHORT );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_CHAR );
1:79b20bc:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_BOOLEAN );
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     /**
1:79b20bc:      * Writes the configuration data from the <code>Dictionary</code> to the
1:79b20bc:      * given <code>OutputStream</code>.
1:79b20bc:      * <p>
1:79b20bc:      * This method writes at the current location in the stream and does not
1:79b20bc:      * close the outputstream.
1:79b20bc:      *
1:79b20bc:      * @param out
1:79b20bc:      *            The <code>OutputStream</code> to write the configurtion data
1:79b20bc:      *            to.
1:79b20bc:      * @param properties
1:79b20bc:      *            The <code>Dictionary</code> to write.
1:79b20bc:      * @throws IOException
1:79b20bc:      *             If an error occurrs writing to the output stream.
1:79b20bc:      */
1:79b20bc:     public static void write( OutputStream out, Dictionary properties ) throws IOException
1:79b20bc:     {
1:79b20bc:         BufferedWriter bw = new BufferedWriter( new OutputStreamWriter( out, ENCODING ) );
1:79b20bc: 
1:79b20bc:         for ( Enumeration ce = properties.keys(); ce.hasMoreElements(); )
1:79b20bc:         {
1:79b20bc:             String key = ( String ) ce.nextElement();
1:79b20bc: 
1:79b20bc:             // cfg = prop "=" value "." .
1:79b20bc:             writeQuoted( bw, key );
1:79b20bc:             bw.write( TOKEN_EQ );
1:79b20bc:             writeValue( bw, properties.get( key ) );
1:79b20bc:             bw.write( CRLF );
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         bw.flush();
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     /**
1:79b20bc:      * Reads configuration data from the given <code>InputStream</code> and
1:79b20bc:      * returns a new <code>Dictionary</code> object containing the data.
1:79b20bc:      * <p>
1:79b20bc:      * This method reads from the current location in the stream upto the end of
1:79b20bc:      * the stream but does not close the stream at the end.
1:79b20bc:      *
1:79b20bc:      * @param ins
1:79b20bc:      *            The <code>InputStream</code> from which to read the
1:79b20bc:      *            configuration data.
1:79b20bc:      * @return A <code>Dictionary</code> object containing the configuration
1:79b20bc:      *         data. This object may be empty if the stream contains no
1:79b20bc:      *         configuration data.
1:79b20bc:      * @throws IOException
1:79b20bc:      *             If an error occurrs reading from the stream. This exception
1:79b20bc:      *             is also thrown if a syntax error is encountered.
1:79b20bc:      */
1:79b20bc:     public static Dictionary read( InputStream ins ) throws IOException
1:79b20bc:     {
1:79b20bc:         return new ConfigurationHandler().readInternal( ins );
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     // private constructor, this class is not to be instantiated from the
1:79b20bc:     // outside
1:79b20bc:     private ConfigurationHandler()
1:79b20bc:     {
1:79b20bc:     }
1:79b20bc: 
1:79b20bc:     // ---------- Configuration Input Implementation ---------------------------
1:79b20bc: 
1:79b20bc:     private int token;
1:79b20bc:     private String tokenValue;
1:79b20bc:     private int line;
1:79b20bc:     private int pos;
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private Dictionary readInternal( InputStream ins ) throws IOException
1:79b20bc:     {
1:79b20bc:         BufferedReader br = new BufferedReader( new InputStreamReader( ins, ENCODING ) );
1:79b20bc:         PushbackReader pr = new PushbackReader( br, 1 );
1:79b20bc: 
1:79b20bc:         token = 0;
1:79b20bc:         tokenValue = null;
1:79b20bc:         line = 0;
1:79b20bc:         pos = 0;
1:79b20bc: 
1:79b20bc:         Hashtable configuration = new Hashtable();
1:79b20bc:         token = 0;
1:79b20bc:         while ( nextToken( pr ) == TOKEN_NAME )
1:79b20bc:         {
1:79b20bc:             String key = tokenValue;
1:79b20bc: 
1:79b20bc:             // expect equal sign
1:79b20bc:             if ( nextToken( pr ) != TOKEN_EQ )
1:79b20bc:             {
1:79b20bc:                 throw readFailure( token, TOKEN_EQ );
1:79b20bc:             }
1:79b20bc: 
1:79b20bc:             // expect the token value
1:79b20bc:             Object value = readValue( pr );
1:79b20bc:             if ( value != null )
1:79b20bc:             {
1:79b20bc:                 configuration.put( key, value );
1:79b20bc:             }
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         return configuration;
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     /**
1:79b20bc:      * value = type ( "[" values "]" | "(" values ")" | simple ) . values =
1:79b20bc:      * value { "," value } . simple = "{" stringsimple "}" . type = // 1-char
1:79b20bc:      * type code . stringsimple = // quoted string representation of the value .
1:79b20bc:      *
1:79b20bc:      * @param pr
1:79b20bc:      * @return
1:79b20bc:      * @throws IOException
1:79b20bc:      */
1:79b20bc:     private Object readValue( PushbackReader pr ) throws IOException
1:79b20bc:     {
1:79b20bc:         // read (optional) type code
1:79b20bc:         int type = read( pr );
1:79b20bc: 
1:79b20bc:         // read value kind code if type code is not a value kinde code
1:79b20bc:         int code;
1:79b20bc:         if ( code2Type.containsKey( new Integer( type ) ) )
1:79b20bc:         {
1:79b20bc:             code = read( pr );
1:79b20bc:         }
1:79b20bc:         else
1:79b20bc:         {
1:79b20bc:             code = type;
1:79b20bc:             type = TOKEN_SIMPLE_STRING;
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         switch ( code )
1:79b20bc:         {
1:79b20bc:             case TOKEN_ARR_OPEN:
1:79b20bc:                 return readArray( type, pr );
1:79b20bc: 
1:79b20bc:             case TOKEN_VEC_OPEN:
1:79b20bc:                 return readCollection( type, pr );
1:79b20bc: 
1:79b20bc:             case TOKEN_VAL_OPEN:
1:79b20bc:                 Object value = readSimple( type, pr );
1:79b20bc:                 ensureNext( pr, TOKEN_VAL_CLOS );
1:79b20bc:                 return value;
1:79b20bc: 
1:79b20bc:             default:
1:79b20bc:                 return null;
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private Object readArray( int typeCode, PushbackReader pr ) throws IOException
1:79b20bc:     {
1:79b20bc:         List list = new ArrayList();
1:79b20bc:         for ( ;; )
1:79b20bc:         {
1:79b20bc:             int c = read(pr);
1:79b20bc:             if ( c == TOKEN_VAL_OPEN )
1:79b20bc:             {
1:79b20bc:                 Object value = readSimple( typeCode, pr );
1:79b20bc:                 if ( value == null )
1:79b20bc:                 {
1:79b20bc:                     // abort due to error
1:79b20bc:                     return null;
1:79b20bc:                 }
1:79b20bc: 
1:79b20bc:                 ensureNext( pr, TOKEN_VAL_CLOS );
1:79b20bc: 
1:79b20bc:                 list.add( value );
1:79b20bc: 
1:79b20bc:                 c = read( pr );
1:79b20bc:             }
1:79b20bc: 
1:79b20bc:             if ( c == TOKEN_ARR_CLOS )
1:79b20bc:             {
1:79b20bc:                 Class type = ( Class ) code2Type.get( new Integer( typeCode ) );
1:79b20bc:                 Object array = Array.newInstance( type, list.size() );
1:79b20bc:                 for ( int i = 0; i < list.size(); i++ )
1:79b20bc:                 {
1:79b20bc:                     Array.set( array, i, list.get( i ) );
1:79b20bc:                 }
1:79b20bc:                 return array;
1:79b20bc:             }
1:79b20bc:             else if ( c < 0 )
1:79b20bc:             {
1:79b20bc:                 return null;
1:79b20bc:             }
1:79b20bc:             else if ( c != TOKEN_COMMA )
1:79b20bc:             {
1:79b20bc:                 return null;
1:79b20bc:             }
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private Collection readCollection( int typeCode, PushbackReader pr ) throws IOException
1:79b20bc:     {
1:79b20bc:         Collection collection = new ArrayList();
1:79b20bc:         for ( ;; )
1:79b20bc:         {
1:79b20bc:             int c = read( pr );
1:79b20bc:             if ( c == TOKEN_VAL_OPEN )
1:79b20bc:             {
1:79b20bc:                 Object value = readSimple( typeCode, pr );
1:79b20bc:                 if ( value == null )
1:79b20bc:                 {
1:79b20bc:                     // abort due to error
1:79b20bc:                     return null;
1:79b20bc:                 }
1:79b20bc: 
1:79b20bc:                 ensureNext( pr, TOKEN_VAL_CLOS );
1:79b20bc: 
1:79b20bc:                 collection.add( value );
1:79b20bc: 
1:79b20bc:                 c = read( pr );
1:79b20bc:             }
1:79b20bc: 
1:79b20bc:             if ( c == TOKEN_VEC_CLOS )
1:79b20bc:             {
1:79b20bc:                 return collection;
1:79b20bc:             }
1:79b20bc:             else if ( c < 0 )
1:79b20bc:             {
1:79b20bc:                 return null;
1:79b20bc:             }
1:79b20bc:             else if ( c != TOKEN_COMMA )
1:79b20bc:             {
1:79b20bc:                 return null;
1:79b20bc:             }
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private Object readSimple( int code, PushbackReader pr ) throws IOException
1:79b20bc:     {
1:79b20bc:         switch ( code )
1:79b20bc:         {
1:79b20bc:             case -1:
1:79b20bc:                 return null;
1:79b20bc: 
1:79b20bc:             case TOKEN_SIMPLE_STRING:
1:79b20bc:                 return readQuoted( pr );
1:79b20bc: 
1:79b20bc:                 // Simple/Primitive, only use wrapper classes
1:79b20bc:             case TOKEN_SIMPLE_INTEGER:
1:79b20bc:             case TOKEN_PRIMITIVE_INT:
1:79b20bc:                 return Integer.valueOf( readQuoted( pr ) );
1:79b20bc: 
1:79b20bc:             case TOKEN_SIMPLE_LONG:
1:79b20bc:             case TOKEN_PRIMITIVE_LONG:
1:79b20bc:                 return Long.valueOf( readQuoted( pr ) );
1:79b20bc: 
1:79b20bc:             case TOKEN_SIMPLE_FLOAT:
1:79b20bc:             case TOKEN_PRIMITIVE_FLOAT:
1:79b20bc:                 int fBits = Integer.parseInt( readQuoted( pr ) );
1:79b20bc:                 return new Float( Float.intBitsToFloat( fBits ) );
1:79b20bc: 
1:79b20bc:             case TOKEN_SIMPLE_DOUBLE:
1:79b20bc:             case TOKEN_PRIMITIVE_DOUBLE:
1:79b20bc:                 long dBits = Long.parseLong( readQuoted( pr ) );
1:79b20bc:                 return new Double( Double.longBitsToDouble( dBits ) );
1:79b20bc: 
1:79b20bc:             case TOKEN_SIMPLE_BYTE:
1:79b20bc:             case TOKEN_PRIMITIVE_BYTE:
1:79b20bc:                 return Byte.valueOf( readQuoted( pr ) );
1:79b20bc: 
1:79b20bc:             case TOKEN_SIMPLE_SHORT:
1:79b20bc:             case TOKEN_PRIMITIVE_SHORT:
1:79b20bc:                 return Short.valueOf( readQuoted( pr ) );
1:79b20bc: 
1:79b20bc:             case TOKEN_SIMPLE_CHARACTER:
1:79b20bc:             case TOKEN_PRIMITIVE_CHAR:
1:79b20bc:                 String cString = readQuoted( pr );
1:79b20bc:                 if ( cString != null && cString.length() > 0 )
1:79b20bc:                 {
1:79b20bc:                     return new Character( cString.charAt( 0 ) );
1:79b20bc:                 }
1:79b20bc:                 return null;
1:79b20bc: 
1:79b20bc:             case TOKEN_SIMPLE_BOOLEAN:
1:79b20bc:             case TOKEN_PRIMITIVE_BOOLEAN:
1:79b20bc:                 return Boolean.valueOf( readQuoted( pr ) );
1:79b20bc: 
1:79b20bc:                 // unknown type code
1:79b20bc:             default:
1:79b20bc:                 return null;
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private void ensureNext( PushbackReader pr, int expected ) throws IOException
1:79b20bc:     {
1:79b20bc:         int next = read( pr );
1:79b20bc:         if ( next != expected )
1:79b20bc:         {
1:79b20bc:             readFailure( next, expected );
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private boolean checkNext( PushbackReader pr, int expected ) throws IOException
1:79b20bc:     {
1:79b20bc:         int next = read( pr );
1:79b20bc:         if ( next < 0 )
1:79b20bc:         {
1:79b20bc:             return false;
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         if ( next == expected )
1:79b20bc:         {
1:79b20bc:             return true;
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         return false;
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private String readQuoted( PushbackReader pr ) throws IOException
1:79b20bc:     {
1:79b20bc:         StringBuffer buf = new StringBuffer();
1:79b20bc:         for ( ;; )
1:79b20bc:         {
1:79b20bc:             int c = read( pr );
1:79b20bc:             switch ( c )
1:79b20bc:             {
1:79b20bc:                 // escaped character
1:79b20bc:                 case '\\':
1:79b20bc:                     c = read( pr );
1:79b20bc:                     switch ( c )
1:79b20bc:                     {
1:79b20bc:                         // well known escapes
1:79b20bc:                         case 'b':
1:79b20bc:                             buf.append( '\b' );
1:79b20bc:                             break;
1:79b20bc:                         case 't':
1:79b20bc:                             buf.append( '\t' );
1:79b20bc:                             break;
1:79b20bc:                         case 'n':
1:79b20bc:                             buf.append( '\n' );
1:79b20bc:                             break;
1:79b20bc:                         case 'f':
1:79b20bc:                             buf.append( '\f' );
1:79b20bc:                             break;
1:79b20bc:                         case 'r':
1:79b20bc:                             buf.append( '\r' );
1:79b20bc:                             break;
1:79b20bc:                         case 'u':// need 4 characters !
1:79b20bc:                             char[] cbuf = new char[4];
1:79b20bc:                             if ( read( pr, cbuf ) == 4 )
1:79b20bc:                             {
1:79b20bc:                                 c = Integer.parseInt( new String( cbuf ), 16 );
1:79b20bc:                                 buf.append( ( char ) c );
1:79b20bc:                             }
1:79b20bc:                             break;
1:79b20bc: 
1:79b20bc:                         // just an escaped character, unescape
1:79b20bc:                         default:
1:79b20bc:                             buf.append( ( char ) c );
1:79b20bc:                     }
1:79b20bc:                     break;
1:79b20bc: 
1:79b20bc:                 // eof
1:79b20bc:                 case -1: // fall through
1:79b20bc: 
1:79b20bc:                 // separator token
1:79b20bc:                 case TOKEN_EQ:
1:79b20bc:                 case TOKEN_VAL_CLOS:
1:79b20bc:                     pr.unread( c );
1:79b20bc:                     return buf.toString();
1:79b20bc: 
1:79b20bc:                 // no escaping
1:79b20bc:                 default:
1:79b20bc:                     buf.append( ( char ) c );
1:79b20bc:             }
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private int nextToken( PushbackReader pr ) throws IOException
1:79b20bc:     {
1:79b20bc:         int c = ignorableWhiteSpace( pr );
1:79b20bc: 
1:79b20bc:         // immediately return EOF
1:79b20bc:         if ( c < 0 )
1:79b20bc:         {
1:79b20bc:             return ( token = c );
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         // check whether there is a name
1:79b20bc:         if ( NAME_CHARS.get( c ) || !TOKEN_CHARS.get( c ) )
1:79b20bc:         {
1:79b20bc:             // read the property name
1:79b20bc:             pr.unread( c );
1:79b20bc:             tokenValue = readQuoted( pr );
1:79b20bc:             return ( token = TOKEN_NAME );
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         // check another token
1:79b20bc:         if ( TOKEN_CHARS.get( c ) )
1:79b20bc:         {
1:79b20bc:             return ( token = c );
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         // unexpected character -> so what ??
1:79b20bc:         return ( token = -1 );
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private int ignorableWhiteSpace( PushbackReader pr ) throws IOException
1:79b20bc:     {
1:79b20bc:         int c = read( pr );
1:79b20bc:         while ( c >= 0 && Character.isWhitespace( ( char ) c ) )
1:79b20bc:         {
1:79b20bc:             c = read( pr );
1:79b20bc:         }
1:79b20bc:         return c;
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private int read( PushbackReader pr ) throws IOException
1:79b20bc:     {
1:79b20bc:         int c = pr.read();
1:79b20bc:         if ( c == '\r' )
1:79b20bc:         {
1:79b20bc:             int c1 = pr.read();
1:79b20bc:             if ( c1 != '\n' )
1:79b20bc:             {
1:79b20bc:                 pr.unread( c1 );
1:79b20bc:             }
1:79b20bc:             c = '\n';
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         if ( c == '\n' )
1:79b20bc:         {
1:79b20bc:             line++;
1:79b20bc:             pos = 0;
1:79b20bc:         }
1:79b20bc:         else
1:79b20bc:         {
1:79b20bc:             pos++;
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         return c;
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private int read( PushbackReader pr, char[] buf ) throws IOException
1:79b20bc:     {
1:79b20bc:         for ( int i = 0; i < buf.length; i++ )
1:79b20bc:         {
1:79b20bc:             int c = read( pr );
1:79b20bc:             if ( c >= 0 )
1:79b20bc:             {
1:79b20bc:                 buf[i] = ( char ) c;
1:79b20bc:             }
1:79b20bc:             else
1:79b20bc:             {
1:79b20bc:                 return i;
1:79b20bc:             }
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         return buf.length;
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private IOException readFailure( int current, int expected )
1:79b20bc:     {
1:79b20bc:         return new IOException( "Unexpected token " + current + "; expected: " + expected + " (line=" + line + ", pos="
1:79b20bc:             + pos + ")" );
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     // ---------- Configuration Output Implementation --------------------------
1:79b20bc: 
1:79b20bc:     private static void writeValue( Writer out, Object value ) throws IOException
1:79b20bc:     {
1:79b20bc:         Class clazz = value.getClass();
1:79b20bc:         if ( clazz.isArray() )
1:79b20bc:         {
1:79b20bc:             writeArray( out, value );
1:79b20bc:         }
1:79b20bc:         else if ( value instanceof Collection )
1:79b20bc:         {
1:79b20bc:             writeCollection( out, ( Collection ) value );
1:79b20bc:         }
1:79b20bc:         else
1:79b20bc:         {
1:79b20bc:             writeType( out, clazz );
1:79b20bc:             writeSimple( out, value );
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private static void writeArray( Writer out, Object arrayValue ) throws IOException
1:79b20bc:     {
1:79b20bc:         int size = Array.getLength( arrayValue );
1:79b20bc:         writeType( out, arrayValue.getClass().getComponentType() );
1:79b20bc:         out.write( TOKEN_ARR_OPEN );
1:79b20bc:         for ( int i = 0; i < size; i++ )
1:79b20bc:         {
1:79b20bc:             if ( i > 0 )
1:79b20bc:                 out.write( TOKEN_COMMA );
1:79b20bc:             writeSimple( out, Array.get( arrayValue, i ) );
1:79b20bc:         }
1:79b20bc:         out.write( TOKEN_ARR_CLOS );
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private static void writeCollection( Writer out, Collection collection ) throws IOException
1:79b20bc:     {
1:79b20bc:         if ( collection.isEmpty() )
1:79b20bc:         {
1:79b20bc:             out.write( TOKEN_VEC_OPEN );
1:79b20bc:             out.write( TOKEN_VEC_CLOS );
1:79b20bc:         }
1:79b20bc:         else
1:79b20bc:         {
1:79b20bc:             Iterator ci = collection.iterator();
1:79b20bc:             Object firstElement = ci.next();
1:79b20bc: 
1:79b20bc:             writeType( out, firstElement.getClass() );
1:79b20bc:             out.write( TOKEN_VEC_OPEN );
1:79b20bc:             writeSimple( out, firstElement );
1:79b20bc: 
1:79b20bc:             while ( ci.hasNext() )
1:79b20bc:             {
1:79b20bc:                 out.write( TOKEN_COMMA );
1:79b20bc:                 writeSimple( out, ci.next() );
1:79b20bc:             }
1:79b20bc:             out.write( TOKEN_VEC_CLOS );
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private static void writeType( Writer out, Class valueType ) throws IOException
1:79b20bc:     {
1:79b20bc:         Integer code = ( Integer ) type2Code.get( valueType );
1:79b20bc:         if ( code != null )
1:79b20bc:         {
1:79b20bc:             out.write( ( char ) code.intValue() );
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private static void writeSimple( Writer out, Object value ) throws IOException
1:79b20bc:     {
1:79b20bc:         if ( value instanceof Double )
1:79b20bc:         {
1:79b20bc:             double dVal = ( ( Double ) value ).doubleValue();
1:79b20bc:             value = new Long( Double.doubleToRawLongBits( dVal ) );
1:79b20bc:         }
1:79b20bc:         else if ( value instanceof Float )
1:79b20bc:         {
1:79b20bc:             float fVal = ( ( Float ) value ).floatValue();
1:79b20bc:             value = new Integer( Float.floatToRawIntBits( fVal ) );
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         out.write( TOKEN_VAL_OPEN );
1:79b20bc:         writeQuoted( out, String.valueOf( value ) );
1:79b20bc:         out.write( TOKEN_VAL_CLOS );
1:79b20bc:     }
1:79b20bc: 
1:79b20bc: 
1:79b20bc:     private static void writeQuoted( Writer out, String simple ) throws IOException
1:79b20bc:     {
1:79b20bc:         if ( simple == null || simple.length() == 0 )
1:79b20bc:         {
1:79b20bc:             return;
1:79b20bc:         }
1:79b20bc: 
1:79b20bc:         char c = 0;
1:79b20bc:         int len = simple.length();
1:79b20bc:         for ( int i = 0; i < len; i++ )
1:79b20bc:         {
1:79b20bc:             c = simple.charAt( i );
1:79b20bc:             switch ( c )
1:79b20bc:             {
1:79b20bc:                 case '\\':
1:79b20bc:                 case TOKEN_VAL_CLOS:
1:79b20bc:                 case ' ':
1:79b20bc:                 case TOKEN_EQ:
1:79b20bc:                     out.write( '\\' );
1:79b20bc:                     out.write( c );
1:79b20bc:                     break;
1:79b20bc: 
1:79b20bc:                 // well known escapes
1:79b20bc:                 case '\b':
1:79b20bc:                     out.write( "\\b" );
1:79b20bc:                     break;
1:79b20bc:                 case '\t':
1:79b20bc:                     out.write( "\\t" );
1:79b20bc:                     break;
1:79b20bc:                 case '\n':
1:79b20bc:                     out.write( "\\n" );
1:79b20bc:                     break;
1:79b20bc:                 case '\f':
1:79b20bc:                     out.write( "\\f" );
1:79b20bc:                     break;
1:79b20bc:                 case '\r':
1:79b20bc:                     out.write( "\\r" );
1:79b20bc:                     break;
1:79b20bc: 
1:79b20bc:                 // other escaping
1:79b20bc:                 default:
1:79b20bc:                     if ( c < ' ' )
1:79b20bc:                     {
1:79b20bc:                         String t = "000" + Integer.toHexString( c );
1:79b20bc:                         out.write( "\\u" + t.substring( t.length() - 4 ) );
1:79b20bc:                     }
1:79b20bc:                     else
1:79b20bc:                     {
1:79b20bc:                         out.write( c );
1:79b20bc:                     }
1:79b20bc:             }
1:79b20bc:         }
1:79b20bc:     }
1:79b20bc: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:79b20bc
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.subsystem.core.content;
1: 
1: 
1: import java.io.BufferedReader;
1: import java.io.BufferedWriter;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.io.OutputStream;
1: import java.io.OutputStreamWriter;
1: import java.io.PushbackReader;
1: import java.io.Writer;
1: import java.lang.reflect.Array;
1: import java.util.ArrayList;
1: import java.util.BitSet;
1: import java.util.Collection;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.Hashtable;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: 
1: 
1: /* This class was taken from the Felix Codebase to read Felix ConfigAdmin .config files. */
1: 
1: /**
1:  * The <code>ConfigurationHandler</code> class implements configuration reading
1:  * form a <code>java.io.InputStream</code> and writing to a
1:  * <code>java.io.OutputStream</code> on behalf of the
1:  * {@link FilePersistenceManager} class.
1:  *
1:  * <pre>
1:  * cfg = prop &quot;=&quot; value .
1:  *  prop = symbolic-name . // 1.4.2 of OSGi Core Specification
1:  *  symbolic-name = token { &quot;.&quot; token } .
1:  *  token = { [ 0..9 ] | [ a..z ] | [ A..Z ] | '_' | '-' } .
1:  *  value = [ type ] ( &quot;[&quot; values &quot;]&quot; | &quot;(&quot; values &quot;)&quot; | simple ) .
1:  *  values = simple { &quot;,&quot; simple } .
1:  *  simple = &quot;&quot;&quot; stringsimple &quot;&quot;&quot; .
1:  *  type = // 1-char type code .
1:  *  stringsimple = // quoted string representation of the value .
1:  * </pre>
1:  */
1: public class ConfigurationHandler
1: {
1:     protected static final String ENCODING = "UTF-8";
1: 
1:     protected static final int TOKEN_NAME = 'N';
1:     protected static final int TOKEN_EQ = '=';
1:     protected static final int TOKEN_ARR_OPEN = '[';
1:     protected static final int TOKEN_ARR_CLOS = ']';
1:     protected static final int TOKEN_VEC_OPEN = '(';
1:     protected static final int TOKEN_VEC_CLOS = ')';
1:     protected static final int TOKEN_COMMA = ',';
1:     protected static final int TOKEN_VAL_OPEN = '"'; // '{';
1:     protected static final int TOKEN_VAL_CLOS = '"'; // '}';
1: 
1:     // simple types (string & primitive wrappers)
1:     protected static final int TOKEN_SIMPLE_STRING = 'T';
1:     protected static final int TOKEN_SIMPLE_INTEGER = 'I';
1:     protected static final int TOKEN_SIMPLE_LONG = 'L';
1:     protected static final int TOKEN_SIMPLE_FLOAT = 'F';
1:     protected static final int TOKEN_SIMPLE_DOUBLE = 'D';
1:     protected static final int TOKEN_SIMPLE_BYTE = 'X';
1:     protected static final int TOKEN_SIMPLE_SHORT = 'S';
1:     protected static final int TOKEN_SIMPLE_CHARACTER = 'C';
1:     protected static final int TOKEN_SIMPLE_BOOLEAN = 'B';
1: 
1:     // primitives
1:     protected static final int TOKEN_PRIMITIVE_INT = 'i';
1:     protected static final int TOKEN_PRIMITIVE_LONG = 'l';
1:     protected static final int TOKEN_PRIMITIVE_FLOAT = 'f';
1:     protected static final int TOKEN_PRIMITIVE_DOUBLE = 'd';
1:     protected static final int TOKEN_PRIMITIVE_BYTE = 'x';
1:     protected static final int TOKEN_PRIMITIVE_SHORT = 's';
1:     protected static final int TOKEN_PRIMITIVE_CHAR = 'c';
1:     protected static final int TOKEN_PRIMITIVE_BOOLEAN = 'b';
1: 
1:     protected static final String CRLF = "\r\n";
1: 
1:     protected static final Map code2Type;
1:     protected static final Map type2Code;
1: 
1:     // set of valid characters for "symblic-name"
1:     private static final BitSet NAME_CHARS;
1:     private static final BitSet TOKEN_CHARS;
1: 
1:     static
1:     {
1:         type2Code = new HashMap();
1: 
1:         // simple (exclusive String whose type code is not written)
1:         type2Code.put( Integer.class, new Integer( TOKEN_SIMPLE_INTEGER ) );
1:         type2Code.put( Long.class, new Integer( TOKEN_SIMPLE_LONG ) );
1:         type2Code.put( Float.class, new Integer( TOKEN_SIMPLE_FLOAT ) );
1:         type2Code.put( Double.class, new Integer( TOKEN_SIMPLE_DOUBLE ) );
1:         type2Code.put( Byte.class, new Integer( TOKEN_SIMPLE_BYTE ) );
1:         type2Code.put( Short.class, new Integer( TOKEN_SIMPLE_SHORT ) );
1:         type2Code.put( Character.class, new Integer( TOKEN_SIMPLE_CHARACTER ) );
1:         type2Code.put( Boolean.class, new Integer( TOKEN_SIMPLE_BOOLEAN ) );
1: 
1:         // primitives
1:         type2Code.put( Integer.TYPE, new Integer( TOKEN_PRIMITIVE_INT ) );
1:         type2Code.put( Long.TYPE, new Integer( TOKEN_PRIMITIVE_LONG ) );
1:         type2Code.put( Float.TYPE, new Integer( TOKEN_PRIMITIVE_FLOAT ) );
1:         type2Code.put( Double.TYPE, new Integer( TOKEN_PRIMITIVE_DOUBLE ) );
1:         type2Code.put( Byte.TYPE, new Integer( TOKEN_PRIMITIVE_BYTE ) );
1:         type2Code.put( Short.TYPE, new Integer( TOKEN_PRIMITIVE_SHORT ) );
1:         type2Code.put( Character.TYPE, new Integer( TOKEN_PRIMITIVE_CHAR ) );
1:         type2Code.put( Boolean.TYPE, new Integer( TOKEN_PRIMITIVE_BOOLEAN ) );
1: 
1:         // reverse map to map type codes to classes, string class mapping
1:         // to be added manually, as the string type code is not written and
1:         // hence not included in the type2Code map
1:         code2Type = new HashMap();
1:         for ( Iterator ti = type2Code.entrySet().iterator(); ti.hasNext(); )
1:         {
1:             Map.Entry entry = ( Map.Entry ) ti.next();
1:             code2Type.put( entry.getValue(), entry.getKey() );
1:         }
1:         code2Type.put( new Integer( TOKEN_SIMPLE_STRING ), String.class );
1: 
1:         NAME_CHARS = new BitSet();
1:         for ( int i = '0'; i <= '9'; i++ )
1:             NAME_CHARS.set( i );
1:         for ( int i = 'a'; i <= 'z'; i++ )
1:             NAME_CHARS.set( i );
1:         for ( int i = 'A'; i <= 'Z'; i++ )
1:             NAME_CHARS.set( i );
1:         NAME_CHARS.set( '_' );
1:         NAME_CHARS.set( '-' );
1:         NAME_CHARS.set( '.' );
1:         NAME_CHARS.set( '\\' );
1: 
1:         TOKEN_CHARS = new BitSet();
1:         TOKEN_CHARS.set( TOKEN_EQ );
1:         TOKEN_CHARS.set( TOKEN_ARR_OPEN );
1:         TOKEN_CHARS.set( TOKEN_ARR_CLOS );
1:         TOKEN_CHARS.set( TOKEN_VEC_OPEN );
1:         TOKEN_CHARS.set( TOKEN_VEC_CLOS );
1:         TOKEN_CHARS.set( TOKEN_COMMA );
1:         TOKEN_CHARS.set( TOKEN_VAL_OPEN );
1:         TOKEN_CHARS.set( TOKEN_VAL_CLOS );
1:         TOKEN_CHARS.set( TOKEN_SIMPLE_STRING );
1:         TOKEN_CHARS.set( TOKEN_SIMPLE_INTEGER );
1:         TOKEN_CHARS.set( TOKEN_SIMPLE_LONG );
1:         TOKEN_CHARS.set( TOKEN_SIMPLE_FLOAT );
1:         TOKEN_CHARS.set( TOKEN_SIMPLE_DOUBLE );
1:         TOKEN_CHARS.set( TOKEN_SIMPLE_BYTE );
1:         TOKEN_CHARS.set( TOKEN_SIMPLE_SHORT );
1:         TOKEN_CHARS.set( TOKEN_SIMPLE_CHARACTER );
1:         TOKEN_CHARS.set( TOKEN_SIMPLE_BOOLEAN );
1: 
1:         // primitives
1:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_INT );
1:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_LONG );
1:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_FLOAT );
1:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_DOUBLE );
1:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_BYTE );
1:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_SHORT );
1:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_CHAR );
1:         TOKEN_CHARS.set( TOKEN_PRIMITIVE_BOOLEAN );
1:     }
1: 
1: 
1:     /**
1:      * Writes the configuration data from the <code>Dictionary</code> to the
1:      * given <code>OutputStream</code>.
1:      * <p>
1:      * This method writes at the current location in the stream and does not
1:      * close the outputstream.
1:      *
1:      * @param out
1:      *            The <code>OutputStream</code> to write the configurtion data
1:      *            to.
1:      * @param properties
1:      *            The <code>Dictionary</code> to write.
1:      * @throws IOException
1:      *             If an error occurrs writing to the output stream.
1:      */
1:     public static void write( OutputStream out, Dictionary properties ) throws IOException
1:     {
1:         BufferedWriter bw = new BufferedWriter( new OutputStreamWriter( out, ENCODING ) );
1: 
1:         for ( Enumeration ce = properties.keys(); ce.hasMoreElements(); )
1:         {
1:             String key = ( String ) ce.nextElement();
1: 
1:             // cfg = prop "=" value "." .
1:             writeQuoted( bw, key );
1:             bw.write( TOKEN_EQ );
1:             writeValue( bw, properties.get( key ) );
1:             bw.write( CRLF );
1:         }
1: 
1:         bw.flush();
1:     }
1: 
1: 
1:     /**
1:      * Reads configuration data from the given <code>InputStream</code> and
1:      * returns a new <code>Dictionary</code> object containing the data.
1:      * <p>
1:      * This method reads from the current location in the stream upto the end of
1:      * the stream but does not close the stream at the end.
1:      *
1:      * @param ins
1:      *            The <code>InputStream</code> from which to read the
1:      *            configuration data.
1:      * @return A <code>Dictionary</code> object containing the configuration
1:      *         data. This object may be empty if the stream contains no
1:      *         configuration data.
1:      * @throws IOException
1:      *             If an error occurrs reading from the stream. This exception
1:      *             is also thrown if a syntax error is encountered.
1:      */
1:     public static Dictionary read( InputStream ins ) throws IOException
1:     {
1:         return new ConfigurationHandler().readInternal( ins );
1:     }
1: 
1: 
1:     // private constructor, this class is not to be instantiated from the
1:     // outside
1:     private ConfigurationHandler()
1:     {
1:     }
1: 
1:     // ---------- Configuration Input Implementation ---------------------------
1: 
1:     private int token;
1:     private String tokenValue;
1:     private int line;
1:     private int pos;
1: 
1: 
1:     private Dictionary readInternal( InputStream ins ) throws IOException
1:     {
1:         BufferedReader br = new BufferedReader( new InputStreamReader( ins, ENCODING ) );
1:         PushbackReader pr = new PushbackReader( br, 1 );
1: 
1:         token = 0;
1:         tokenValue = null;
1:         line = 0;
1:         pos = 0;
1: 
1:         Hashtable configuration = new Hashtable();
1:         token = 0;
1:         while ( nextToken( pr ) == TOKEN_NAME )
1:         {
1:             String key = tokenValue;
1: 
1:             // expect equal sign
1:             if ( nextToken( pr ) != TOKEN_EQ )
1:             {
1:                 throw readFailure( token, TOKEN_EQ );
1:             }
1: 
1:             // expect the token value
1:             Object value = readValue( pr );
1:             if ( value != null )
1:             {
1:                 configuration.put( key, value );
1:             }
1:         }
1: 
1:         return configuration;
1:     }
1: 
1: 
1:     /**
1:      * value = type ( "[" values "]" | "(" values ")" | simple ) . values =
1:      * value { "," value } . simple = "{" stringsimple "}" . type = // 1-char
1:      * type code . stringsimple = // quoted string representation of the value .
1:      *
1:      * @param pr
1:      * @return
1:      * @throws IOException
1:      */
1:     private Object readValue( PushbackReader pr ) throws IOException
1:     {
1:         // read (optional) type code
1:         int type = read( pr );
1: 
1:         // read value kind code if type code is not a value kinde code
1:         int code;
1:         if ( code2Type.containsKey( new Integer( type ) ) )
1:         {
1:             code = read( pr );
1:         }
1:         else
1:         {
1:             code = type;
1:             type = TOKEN_SIMPLE_STRING;
1:         }
1: 
1:         switch ( code )
1:         {
1:             case TOKEN_ARR_OPEN:
1:                 return readArray( type, pr );
1: 
1:             case TOKEN_VEC_OPEN:
1:                 return readCollection( type, pr );
1: 
1:             case TOKEN_VAL_OPEN:
1:                 Object value = readSimple( type, pr );
1:                 ensureNext( pr, TOKEN_VAL_CLOS );
1:                 return value;
1: 
1:             default:
1:                 return null;
1:         }
1:     }
1: 
1: 
1:     private Object readArray( int typeCode, PushbackReader pr ) throws IOException
1:     {
1:         List list = new ArrayList();
1:         for ( ;; )
1:         {
1:             int c = read(pr);
1:             if ( c == TOKEN_VAL_OPEN )
1:             {
1:                 Object value = readSimple( typeCode, pr );
1:                 if ( value == null )
1:                 {
1:                     // abort due to error
1:                     return null;
1:                 }
1: 
1:                 ensureNext( pr, TOKEN_VAL_CLOS );
1: 
1:                 list.add( value );
1: 
1:                 c = read( pr );
1:             }
1: 
1:             if ( c == TOKEN_ARR_CLOS )
1:             {
1:                 Class type = ( Class ) code2Type.get( new Integer( typeCode ) );
1:                 Object array = Array.newInstance( type, list.size() );
1:                 for ( int i = 0; i < list.size(); i++ )
1:                 {
1:                     Array.set( array, i, list.get( i ) );
1:                 }
1:                 return array;
1:             }
1:             else if ( c < 0 )
1:             {
1:                 return null;
1:             }
1:             else if ( c != TOKEN_COMMA )
1:             {
1:                 return null;
1:             }
1:         }
1:     }
1: 
1: 
1:     private Collection readCollection( int typeCode, PushbackReader pr ) throws IOException
1:     {
1:         Collection collection = new ArrayList();
1:         for ( ;; )
1:         {
1:             int c = read( pr );
1:             if ( c == TOKEN_VAL_OPEN )
1:             {
1:                 Object value = readSimple( typeCode, pr );
1:                 if ( value == null )
1:                 {
1:                     // abort due to error
1:                     return null;
1:                 }
1: 
1:                 ensureNext( pr, TOKEN_VAL_CLOS );
1: 
1:                 collection.add( value );
1: 
1:                 c = read( pr );
1:             }
1: 
1:             if ( c == TOKEN_VEC_CLOS )
1:             {
1:                 return collection;
1:             }
1:             else if ( c < 0 )
1:             {
1:                 return null;
1:             }
1:             else if ( c != TOKEN_COMMA )
1:             {
1:                 return null;
1:             }
1:         }
1:     }
1: 
1: 
1:     private Object readSimple( int code, PushbackReader pr ) throws IOException
1:     {
1:         switch ( code )
1:         {
1:             case -1:
1:                 return null;
1: 
1:             case TOKEN_SIMPLE_STRING:
1:                 return readQuoted( pr );
1: 
1:                 // Simple/Primitive, only use wrapper classes
1:             case TOKEN_SIMPLE_INTEGER:
1:             case TOKEN_PRIMITIVE_INT:
1:                 return Integer.valueOf( readQuoted( pr ) );
1: 
1:             case TOKEN_SIMPLE_LONG:
1:             case TOKEN_PRIMITIVE_LONG:
1:                 return Long.valueOf( readQuoted( pr ) );
1: 
1:             case TOKEN_SIMPLE_FLOAT:
1:             case TOKEN_PRIMITIVE_FLOAT:
1:                 int fBits = Integer.parseInt( readQuoted( pr ) );
1:                 return new Float( Float.intBitsToFloat( fBits ) );
1: 
1:             case TOKEN_SIMPLE_DOUBLE:
1:             case TOKEN_PRIMITIVE_DOUBLE:
1:                 long dBits = Long.parseLong( readQuoted( pr ) );
1:                 return new Double( Double.longBitsToDouble( dBits ) );
1: 
1:             case TOKEN_SIMPLE_BYTE:
1:             case TOKEN_PRIMITIVE_BYTE:
1:                 return Byte.valueOf( readQuoted( pr ) );
1: 
1:             case TOKEN_SIMPLE_SHORT:
1:             case TOKEN_PRIMITIVE_SHORT:
1:                 return Short.valueOf( readQuoted( pr ) );
1: 
1:             case TOKEN_SIMPLE_CHARACTER:
1:             case TOKEN_PRIMITIVE_CHAR:
1:                 String cString = readQuoted( pr );
1:                 if ( cString != null && cString.length() > 0 )
1:                 {
1:                     return new Character( cString.charAt( 0 ) );
1:                 }
1:                 return null;
1: 
1:             case TOKEN_SIMPLE_BOOLEAN:
1:             case TOKEN_PRIMITIVE_BOOLEAN:
1:                 return Boolean.valueOf( readQuoted( pr ) );
1: 
1:                 // unknown type code
1:             default:
1:                 return null;
1:         }
1:     }
1: 
1: 
1:     private void ensureNext( PushbackReader pr, int expected ) throws IOException
1:     {
1:         int next = read( pr );
1:         if ( next != expected )
1:         {
1:             readFailure( next, expected );
1:         }
1:     }
1: 
1: 
1:     private boolean checkNext( PushbackReader pr, int expected ) throws IOException
1:     {
1:         int next = read( pr );
1:         if ( next < 0 )
1:         {
1:             return false;
1:         }
1: 
1:         if ( next == expected )
1:         {
1:             return true;
1:         }
1: 
1:         return false;
1:     }
1: 
1: 
1:     private String readQuoted( PushbackReader pr ) throws IOException
1:     {
1:         StringBuffer buf = new StringBuffer();
1:         for ( ;; )
1:         {
1:             int c = read( pr );
1:             switch ( c )
1:             {
1:                 // escaped character
1:                 case '\\':
1:                     c = read( pr );
1:                     switch ( c )
1:                     {
1:                         // well known escapes
1:                         case 'b':
1:                             buf.append( '\b' );
1:                             break;
1:                         case 't':
1:                             buf.append( '\t' );
1:                             break;
1:                         case 'n':
1:                             buf.append( '\n' );
1:                             break;
1:                         case 'f':
1:                             buf.append( '\f' );
1:                             break;
1:                         case 'r':
1:                             buf.append( '\r' );
1:                             break;
1:                         case 'u':// need 4 characters !
1:                             char[] cbuf = new char[4];
1:                             if ( read( pr, cbuf ) == 4 )
1:                             {
1:                                 c = Integer.parseInt( new String( cbuf ), 16 );
1:                                 buf.append( ( char ) c );
1:                             }
1:                             break;
1: 
1:                         // just an escaped character, unescape
1:                         default:
1:                             buf.append( ( char ) c );
1:                     }
1:                     break;
1: 
1:                 // eof
1:                 case -1: // fall through
1: 
1:                 // separator token
1:                 case TOKEN_EQ:
1:                 case TOKEN_VAL_CLOS:
1:                     pr.unread( c );
1:                     return buf.toString();
1: 
1:                 // no escaping
1:                 default:
1:                     buf.append( ( char ) c );
1:             }
1:         }
1:     }
1: 
1: 
1:     private int nextToken( PushbackReader pr ) throws IOException
1:     {
1:         int c = ignorableWhiteSpace( pr );
1: 
1:         // immediately return EOF
1:         if ( c < 0 )
1:         {
1:             return ( token = c );
1:         }
1: 
1:         // check whether there is a name
1:         if ( NAME_CHARS.get( c ) || !TOKEN_CHARS.get( c ) )
1:         {
1:             // read the property name
1:             pr.unread( c );
1:             tokenValue = readQuoted( pr );
1:             return ( token = TOKEN_NAME );
1:         }
1: 
1:         // check another token
1:         if ( TOKEN_CHARS.get( c ) )
1:         {
1:             return ( token = c );
1:         }
1: 
1:         // unexpected character -> so what ??
1:         return ( token = -1 );
1:     }
1: 
1: 
1:     private int ignorableWhiteSpace( PushbackReader pr ) throws IOException
1:     {
1:         int c = read( pr );
1:         while ( c >= 0 && Character.isWhitespace( ( char ) c ) )
1:         {
1:             c = read( pr );
1:         }
1:         return c;
1:     }
1: 
1: 
1:     private int read( PushbackReader pr ) throws IOException
1:     {
1:         int c = pr.read();
1:         if ( c == '\r' )
1:         {
1:             int c1 = pr.read();
1:             if ( c1 != '\n' )
1:             {
1:                 pr.unread( c1 );
1:             }
1:             c = '\n';
1:         }
1: 
1:         if ( c == '\n' )
1:         {
1:             line++;
1:             pos = 0;
1:         }
1:         else
1:         {
1:             pos++;
1:         }
1: 
1:         return c;
1:     }
1: 
1: 
1:     private int read( PushbackReader pr, char[] buf ) throws IOException
1:     {
1:         for ( int i = 0; i < buf.length; i++ )
1:         {
1:             int c = read( pr );
1:             if ( c >= 0 )
1:             {
1:                 buf[i] = ( char ) c;
1:             }
1:             else
1:             {
1:                 return i;
1:             }
1:         }
1: 
1:         return buf.length;
1:     }
1: 
1: 
1:     private IOException readFailure( int current, int expected )
1:     {
1:         return new IOException( "Unexpected token " + current + "; expected: " + expected + " (line=" + line + ", pos="
1:             + pos + ")" );
1:     }
1: 
1: 
1:     // ---------- Configuration Output Implementation --------------------------
1: 
1:     private static void writeValue( Writer out, Object value ) throws IOException
1:     {
1:         Class clazz = value.getClass();
1:         if ( clazz.isArray() )
1:         {
1:             writeArray( out, value );
1:         }
1:         else if ( value instanceof Collection )
1:         {
1:             writeCollection( out, ( Collection ) value );
1:         }
1:         else
1:         {
1:             writeType( out, clazz );
1:             writeSimple( out, value );
1:         }
1:     }
1: 
1: 
1:     private static void writeArray( Writer out, Object arrayValue ) throws IOException
1:     {
1:         int size = Array.getLength( arrayValue );
1:         writeType( out, arrayValue.getClass().getComponentType() );
1:         out.write( TOKEN_ARR_OPEN );
1:         for ( int i = 0; i < size; i++ )
1:         {
1:             if ( i > 0 )
1:                 out.write( TOKEN_COMMA );
1:             writeSimple( out, Array.get( arrayValue, i ) );
1:         }
1:         out.write( TOKEN_ARR_CLOS );
1:     }
1: 
1: 
1:     private static void writeCollection( Writer out, Collection collection ) throws IOException
1:     {
1:         if ( collection.isEmpty() )
1:         {
1:             out.write( TOKEN_VEC_OPEN );
1:             out.write( TOKEN_VEC_CLOS );
1:         }
1:         else
1:         {
1:             Iterator ci = collection.iterator();
1:             Object firstElement = ci.next();
1: 
1:             writeType( out, firstElement.getClass() );
1:             out.write( TOKEN_VEC_OPEN );
1:             writeSimple( out, firstElement );
1: 
1:             while ( ci.hasNext() )
1:             {
1:                 out.write( TOKEN_COMMA );
1:                 writeSimple( out, ci.next() );
1:             }
1:             out.write( TOKEN_VEC_CLOS );
1:         }
1:     }
1: 
1: 
1:     private static void writeType( Writer out, Class valueType ) throws IOException
1:     {
1:         Integer code = ( Integer ) type2Code.get( valueType );
1:         if ( code != null )
1:         {
1:             out.write( ( char ) code.intValue() );
1:         }
1:     }
1: 
1: 
1:     private static void writeSimple( Writer out, Object value ) throws IOException
1:     {
1:         if ( value instanceof Double )
1:         {
1:             double dVal = ( ( Double ) value ).doubleValue();
1:             value = new Long( Double.doubleToRawLongBits( dVal ) );
1:         }
1:         else if ( value instanceof Float )
1:         {
1:             float fVal = ( ( Float ) value ).floatValue();
1:             value = new Integer( Float.floatToRawIntBits( fVal ) );
1:         }
1: 
1:         out.write( TOKEN_VAL_OPEN );
1:         writeQuoted( out, String.valueOf( value ) );
1:         out.write( TOKEN_VAL_CLOS );
1:     }
1: 
1: 
1:     private static void writeQuoted( Writer out, String simple ) throws IOException
1:     {
1:         if ( simple == null || simple.length() == 0 )
1:         {
1:             return;
1:         }
1: 
1:         char c = 0;
1:         int len = simple.length();
1:         for ( int i = 0; i < len; i++ )
1:         {
1:             c = simple.charAt( i );
1:             switch ( c )
1:             {
1:                 case '\\':
1:                 case TOKEN_VAL_CLOS:
1:                 case ' ':
1:                 case TOKEN_EQ:
1:                     out.write( '\\' );
1:                     out.write( c );
1:                     break;
1: 
1:                 // well known escapes
1:                 case '\b':
1:                     out.write( "\\b" );
1:                     break;
1:                 case '\t':
1:                     out.write( "\\t" );
1:                     break;
1:                 case '\n':
1:                     out.write( "\\n" );
1:                     break;
1:                 case '\f':
1:                     out.write( "\\f" );
1:                     break;
1:                 case '\r':
1:                     out.write( "\\r" );
1:                     break;
1: 
1:                 // other escaping
1:                 default:
1:                     if ( c < ' ' )
1:                     {
1:                         String t = "000" + Integer.toHexString( c );
1:                         out.write( "\\u" + t.substring( t.length() - 4 ) );
1:                     }
1:                     else
1:                     {
1:                         out.write( c );
1:                     }
1:             }
1:         }
1:     }
1: }
============================================================================