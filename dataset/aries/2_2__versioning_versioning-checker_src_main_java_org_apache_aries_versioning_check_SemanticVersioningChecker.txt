1:6aa0635: /*
1:6aa0635:  * Licensed to the Apache Software Foundation (ASF) under one
1:6aa0635:  * or more contributor license agreements.  See the NOTICE file
1:6aa0635:  * distributed with this work for additional information
1:6aa0635:  * regarding copyright ownership.  The ASF licenses this file
1:6aa0635:  * to you under the Apache License, Version 2.0 (the
1:6aa0635:  * "License"); you may not use this file except in compliance
1:6aa0635:  * with the License.  You may obtain a copy of the License at
2:9822203:  *
1:6aa0635:  *   http://www.apache.org/licenses/LICENSE-2.0
1:9822203:  *
1:6aa0635:  * Unless required by applicable law or agreed to in writing,
1:6aa0635:  * software distributed under the License is distributed on an
1:6aa0635:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6aa0635:  * KIND, either express or implied.  See the License for the
1:6aa0635:  * specific language governing permissions and limitations
1:6aa0635:  * under the License.
3:9822203:  */
39:9822203: 
1:6aa0635: package org.apache.aries.versioning.check;
1:9822203: 
1:6aa0635: import java.io.File;
1:6aa0635: import java.io.FileWriter;
1:6aa0635: import java.io.IOException;
1:490f397: import java.lang.String;
1:6aa0635: import java.net.MalformedURLException;
1:6aa0635: import java.net.URISyntaxException;
1:6aa0635: import java.net.URL;
1:6aa0635: import java.net.URLClassLoader;
1:6aa0635: import java.util.Collection;
1:6aa0635: import java.util.HashMap;
1:6aa0635: import java.util.HashSet;
1:6aa0635: import java.util.List;
1:6aa0635: import java.util.Map;
1:9822203: 
1:9822203: 
1:6aa0635: import org.apache.aries.util.filesystem.FileSystem;
1:6aa0635: import org.apache.aries.util.filesystem.IDirectory;
1:6aa0635: import org.apache.aries.util.filesystem.IFile;
1:6aa0635: import org.apache.aries.util.io.IOUtils;
1:6aa0635: import org.apache.aries.util.manifest.BundleManifest;
1:6aa0635: import org.apache.aries.versioning.utils.SemanticVersioningUtils;
1:6aa0635: import org.slf4j.Logger;
1:6aa0635: import org.slf4j.LoggerFactory;
1:9822203: 
1:6aa0635: public class SemanticVersioningChecker {
1:9822203: 
1:9822203:     private static final Logger _logger = LoggerFactory.getLogger(SemanticVersioningChecker.class);
1:9822203:     private URLClassLoader newJarsLoader;
1:9822203:     private URLClassLoader oldJarsLoader;
1:9822203:     private static final String xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>";
1:9822203: 
4:9822203:     /**
1:9822203:      * This method is to scan the current location against base and process each individual jars
1:9822203:      * in the current location against the jar with the same symbolic names in the base and produce a xml report specified by versioningReport.
1:9822203:      *
1:9822203:      * @param base             baseline jars
1:9822203:      * @param current          current version of jars
1:9822203:      * @param versioningReport the validation reports
1:9822203:      */
1:9822203:     public static void checkSemanticVersioning(URL base, URL current, File versioningReport) {
1:9822203:         //For each jar under the current location, open the jar and then use ASM to
1:9822203:         //work out whether there are binary incompatible changes against the base location.
2:9822203:         try {
1:9822203:             File baseDir = new File(base.toURI());
1:9822203:             File currentDir = new File(current.toExternalForm());
1:9822203:             if (baseDir.exists() && currentDir.exists()) {
1:9822203:                 new SemanticVersioningChecker().performVersioningCheck(FileSystem.getFSRoot(baseDir), FileSystem.getFSRoot(currentDir), versioningReport);
12:9822203:             } else {
1:9822203:                 _logger.debug("No bundles found to process.");
1:490f397:             }
1:9822203:         } catch (URISyntaxException use) {
1:9822203:             _logger.error(use.getMessage());
70:9822203:         }
1:9822203:     }
1:9822203: 
1:9822203:     // for each jar, open its manifest and found the packages
1:9822203:     private void performVersioningCheck(IDirectory baseDir, IDirectory currentDir, File versionStatusFile) {
1:9822203: 
1:9822203:         FileWriter versionStatusFileWriter = null;
1:9822203:         try {
1:9822203:             versionStatusFileWriter = new FileWriter(versionStatusFile, false);
1:490f397:             Map<String, BundleInfo> baseBundles;
1:490f397:             Map<String, BundleInfo> currentBundles;
1:9822203: 
1:9822203:             //scan each individual bundle and find the corresponding bundle in the baseline and verify the version changes
1:9822203:             currentBundles = getBundles(currentDir);
1:9822203:             baseBundles = getBundles(baseDir);
1:9822203:             URL[] newJarURLs = getListURLs(currentBundles.values()).toArray(new URL[0]);
1:9822203:             newJarsLoader = new URLClassLoader(newJarURLs);
1:9822203: 
1:9822203:             URL[] oldJarURLs = getListURLs(baseBundles.values()).toArray(new URL[0]);
1:9822203: 
1:9822203:             oldJarsLoader = new URLClassLoader(oldJarURLs);
1:9822203: 
1:9822203:             //Write the xml header
1:9822203:             writeRecordToWriter(versionStatusFileWriter, xmlHeader + "\r\n");
1:9822203: 
1:9822203:             // write the comparison base and current level into the file
1:490f397:             writeRecordToWriter(versionStatusFileWriter, "<semanticVersioning currentDir= \"" + currentDir + "\" baseDir = \"" + baseDir + "\">");
1:9822203:             for (Map.Entry<String, BundleInfo> entry : currentBundles.entrySet()) {
1:9822203:                 String bundleSymbolicName = entry.getKey();
1:9822203: 
1:9822203:                 String bundleElement = null;
1:9822203:                 boolean bundleVersionCorrect = true;
1:9822203:                 // find the same bundle in the base and check whether all the versions are correct
1:9822203:                 BundleInfo currentBundle = entry.getValue();
1:9822203:                 BundleInfo baseBundle = baseBundles.get(bundleSymbolicName);
1:9822203:                 StringBuilder pkgElements = new StringBuilder();
1:9822203:                 if (baseBundle == null) {
1:490f397:                     _logger.debug("The bundle " + bundleSymbolicName + " has no counterpart in the base. The semantic version validation does not apply to this bundle.");
1:9822203:                 } else {
1:cee3393:                     BundleCompatibility bundleCompatibility = new BundleCompatibility(bundleSymbolicName, currentBundle, baseBundle, oldJarsLoader, newJarsLoader).invoke();
1:e305ed5:                     bundleVersionCorrect = bundleCompatibility.isBundleVersionCorrect();
1:e305ed5:                     bundleElement = bundleCompatibility.getBundleElement();
1:cee3393:                     pkgElements = bundleCompatibility.getPkgElements();
1:9822203:                 }
1:9822203:                 // Need to write bundle element and then package elements
1:9822203:                 if ((!!!bundleVersionCorrect) || ((pkgElements.length() > 0))) {
1:9822203:                     writeRecordToWriter(versionStatusFileWriter, bundleElement);
1:9822203:                     writeRecordToWriter(versionStatusFileWriter, pkgElements.toString());
1:9822203:                     writeRecordToWriter(versionStatusFileWriter, "</bundle>");
1:9822203:                 }
1:9822203:             }
1:490f397:             writeRecordToWriter(versionStatusFileWriter, "</semanticVersioning>");
1:9822203: 
2:9822203:         } catch (IOException ioe) {
1:9822203:             ioe.printStackTrace();
1:9822203:         } catch (Exception e) {
1:9822203:             e.printStackTrace();
1:9822203:         } finally {
1:9822203:             IOUtils.close(versionStatusFileWriter);
1:9822203:         }
1:9822203: 
1:9822203:         return;
1:9822203:     }
1:9822203: 
1:9822203: 
1:9822203:     private void writeRecordToWriter(FileWriter fileWriter, String stringToWrite) throws IOException {
1:9822203:         if (fileWriter != null) {
1:9822203:             fileWriter.append(stringToWrite);
1:9822203:             fileWriter.append("\r\n");
1:9822203:         }
1:9822203:     }
1:9822203: 
1:9822203:     private Map<String, BundleInfo> getBundles(IDirectory ds) {
1:9822203:         Map<String, BundleInfo> bundles = new HashMap<String, BundleInfo>();
1:9822203:         List<IFile> includedFiles = ds.listAllFiles();
1:9822203: 
1:9822203:         for (IFile ifile : includedFiles) {
1:9822203: 
1:9822203: 
1:9822203:             if (ifile.getName().endsWith(SemanticVersioningUtils.jarExt)) {
1:9822203:                 // scan its manifest
1:9822203:                 try {
1:9822203:                     BundleManifest manifest = BundleManifest.fromBundle(ifile.open());
1:9822203:                     // find the bundle symbolic name, store them in a map with bundle symbolic name as key, bundleInfo as value
1:9822203:                     if (manifest.getSymbolicName() != null) {
1:9822203: 
1:9822203:                         bundles.put(manifest.getSymbolicName(), new BundleInfo(manifest, new File(ifile.toURL().getPath())));
1:9822203: 
1:9822203:                     }
1:9822203:                 } catch (MalformedURLException mue) {
1:9822203:                     _logger.debug("Exception thrown when processing" + ifile.getName(), mue);
1:9822203:                 } catch (IOException ioe) {
1:9822203:                     _logger.debug("Exception thrown when processing" + ifile.getName(), ioe);
1:9822203:                 }
1:9822203:             }
1:9822203:         }
1:9822203:         return bundles;
1:9822203:     }
1:9822203: 
1:9822203:     private Collection<URL> getListURLs(Collection<BundleInfo> bundles) {
1:9822203:         Collection<URL> urls = new HashSet<URL>();
1:9822203:         try {
1:9822203:             for (BundleInfo bundle : bundles) {
1:9822203: 
1:9822203:                 URL url = bundle.getBundle().toURI().toURL();
1:9822203:                 urls.add(url);
1:9822203: 
1:9822203:             }
1:9822203: 
1:9822203:         } catch (MalformedURLException e) {
1:9822203:             _logger.debug(e.getMessage());
1:9822203:         }
1:9822203:         return urls;
1:9822203:     }
1:9822203: 
1:9822203: }
============================================================================
author:David Jencks
-------------------------------------------------------------------------------
commit:cee3393
/////////////////////////////////////////////////////////////////////////
1:                     BundleCompatibility bundleCompatibility = new BundleCompatibility(bundleSymbolicName, currentBundle, baseBundle, oldJarsLoader, newJarsLoader).invoke();
1:                     pkgElements = bundleCompatibility.getPkgElements();
commit:e305ed5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     BundleCompatibility bundleCompatibility = new BundleCompatibility(bundleSymbolicName, bundleElement, bundleVersionCorrect, currentBundle, baseBundle, pkgElements, oldJarsLoader, newJarsLoader).invoke();
1:                     bundleVersionCorrect = bundleCompatibility.isBundleVersionCorrect();
1:                     bundleElement = bundleCompatibility.getBundleElement();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:490f397
/////////////////////////////////////////////////////////////////////////
1: import java.lang.String;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.htmlTwoLineBreaks;
/////////////////////////////////////////////////////////////////////////
1:             Map<String, BundleInfo> baseBundles;
1:             Map<String, BundleInfo> currentBundles;
/////////////////////////////////////////////////////////////////////////
1:             writeRecordToWriter(versionStatusFileWriter, "<semanticVersioning currentDir= \"" + currentDir + "\" baseDir = \"" + baseDir + "\">");
/////////////////////////////////////////////////////////////////////////
1:                     _logger.debug("The bundle " + bundleSymbolicName + " has no counterpart in the base. The semantic version validation does not apply to this bundle.");
0:                     Map<String, PackageContent> baseBundleExpPkgContents;
/////////////////////////////////////////////////////////////////////////
1:             writeRecordToWriter(versionStatusFileWriter, "</semanticVersioning>");
/////////////////////////////////////////////////////////////////////////
0:                         major_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following changes have been made since the last release.");
0:                         for (String reason: bcs) {
0:                             major_reason.append(htmlOneLineBreak).append(reason);
1:                         }
commit:9822203
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     private static final Logger _logger = LoggerFactory.getLogger(SemanticVersioningChecker.class);
1:     private URLClassLoader newJarsLoader;
1:     private URLClassLoader oldJarsLoader;
1:     private static final String xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>";
1:     /**
1:      * This method is to scan the current location against base and process each individual jars
1:      * in the current location against the jar with the same symbolic names in the base and produce a xml report specified by versioningReport.
1:      *
1:      * @param base             baseline jars
1:      * @param current          current version of jars
1:      * @param versioningReport the validation reports
1:      */
1:     public static void checkSemanticVersioning(URL base, URL current, File versioningReport) {
1:         //For each jar under the current location, open the jar and then use ASM to
1:         //work out whether there are binary incompatible changes against the base location.
1:             File baseDir = new File(base.toURI());
1:             File currentDir = new File(current.toExternalForm());
1:             if (baseDir.exists() && currentDir.exists()) {
1:                 new SemanticVersioningChecker().performVersioningCheck(FileSystem.getFSRoot(baseDir), FileSystem.getFSRoot(currentDir), versioningReport);
1:             } else {
1:                 _logger.debug("No bundles found to process.");
1:             }
1:         } catch (URISyntaxException use) {
1:             _logger.error(use.getMessage());
1:     }
1: 
1:     // for each jar, open its manifest and found the packages
1:     private void performVersioningCheck(IDirectory baseDir, IDirectory currentDir, File versionStatusFile) {
1: 
1:         FileWriter versionStatusFileWriter = null;
1:         try {
1:             versionStatusFileWriter = new FileWriter(versionStatusFile, false);
0:             Map<String, BundleInfo> baseBundles = new HashMap<String, BundleInfo>();
0:             Map<String, BundleInfo> currentBundles = new HashMap<String, BundleInfo>();
1: 
1:             //scan each individual bundle and find the corresponding bundle in the baseline and verify the version changes
1:             currentBundles = getBundles(currentDir);
1:             baseBundles = getBundles(baseDir);
1:             URL[] newJarURLs = getListURLs(currentBundles.values()).toArray(new URL[0]);
1:             newJarsLoader = new URLClassLoader(newJarURLs);
1: 
1:             URL[] oldJarURLs = getListURLs(baseBundles.values()).toArray(new URL[0]);
1: 
1:             oldJarsLoader = new URLClassLoader(oldJarURLs);
1: 
1:             //Write the xml header
1:             writeRecordToWriter(versionStatusFileWriter, xmlHeader + "\r\n");
1: 
1:             // write the comparison base and current level into the file
0:             writeRecordToWriter(versionStatusFileWriter, "<semanaticVersioning currentDir= \"" + currentDir + "\" baseDir = \"" + baseDir + "\">");
1:             for (Map.Entry<String, BundleInfo> entry : currentBundles.entrySet()) {
1:                 String bundleSymbolicName = entry.getKey();
1: 
1:                 String bundleElement = null;
1:                 boolean bundleVersionCorrect = true;
1:                 // find the same bundle in the base and check whether all the versions are correct
1:                 BundleInfo currentBundle = entry.getValue();
1:                 BundleInfo baseBundle = baseBundles.get(bundleSymbolicName);
1:                 StringBuilder pkgElements = new StringBuilder();
0:                 String reason = null;
1:                 if (baseBundle == null) {
0:                     _logger.debug("The bundle " + bundleSymbolicName + " has no counterpart in the base. The semanit version validation does not apply to this bundle.");
1:                 } else {
0:                     // open the manifest and scan the export package and find the package name and exported version
0:                     // The tool assume the one particular package just exports under one version
0:                     Map<String, PackageContent> currBundleExpPkgContents = getAllExportedPkgContents(currentBundle);
0:                     Map<String, PackageContent> baseBundleExpPkgContents = new HashMap<String, PackageContent>();
0:                     boolean pkg_major_change = false;
0:                     boolean pkg_minor_change = false;
0:                     String fatal_package = null;
0:                     if (!!!currBundleExpPkgContents.isEmpty()) {
0:                         baseBundleExpPkgContents = getAllExportedPkgContents(baseBundle);
0:                         // compare each class right now
0:                         for (Map.Entry<String, PackageContent> pkg : baseBundleExpPkgContents.entrySet()) {
0:                             String pkgName = pkg.getKey();
0:                             Map<String, IFile> baseClazz = pkg.getValue().getClasses();
0:                             Map<String, IFile> baseXsds = pkg.getValue().getXsds();
0:                             PackageContent currPkgContents = currBundleExpPkgContents.get(pkgName);
0:                             if (currPkgContents == null) {
0:                                 // The package is no longer exported any more. This should lead to bundle major version change.
0:                                 pkg_major_change = true;
0:                                 fatal_package = pkgName;
0:                                 _logger.debug("The package " + pkgName + " in the bundle of " + bundleSymbolicName + " is no longer to be exported. Major change.");
1:                             } else {
0:                                 Map<String, IFile> curClazz = currPkgContents.getClasses();
0:                                 Map<String, IFile> curXsds = currPkgContents.getXsds();
0:                                 //check whether there should be major change/minor change/micro change in this package.
0:                                 //1. Use ASM to visit all classes in the package
0:                                 VersionChange majorChange = new VersionChange();
0:                                 VersionChange minorChange = new VersionChange();
0:                                 // check all classes to see whether there are minor or major changes
0:                                 visitPackage(pkgName, baseClazz, curClazz, majorChange, minorChange);
0:                                 // If there is no binary compatibility changes, check whether xsd files have been added, changed or deleted
0:                                 if (!!!majorChange.isChange()) {
0:                                     checkXsdChangesInPkg(pkgName, baseXsds, curXsds, majorChange);
0:                                     // If everything is ok with the existing classes. Need to find out whether there are more API (abstract classes) in the current bundle.
0:                                     // loop through curClazz and visit it and find out whether one of them is abstract.
0:                                     // check whether there are more xsd or abstract classes added
0:                                     if (!!!(majorChange.isChange() || minorChange.isChange())) {
0:                                         checkAdditionalClassOrXsds(pkgName, curClazz, curXsds, minorChange);
1:                                     }
1:                                 }
0:                                 // We have scanned the whole packages, report the result
0:                                 if (majorChange.isChange() || minorChange.isChange()) {
0:                                     String oldVersion = pkg.getValue().getPackageVersion();
0:                                     String newVersion = currPkgContents.getPackageVersion();
0:                                     if (majorChange.isChange()) {
0:                                         pkg_major_change = true;
0:                                         fatal_package = pkgName;
0:                                         if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion)) {
0:                                             pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, majorChange.getReason(), majorChange.getChangeClass()));
1:                                         }
0:                                     } else if (minorChange.isChange()) {
0:                                         pkg_minor_change = true;
0:                                         if (fatal_package == null) fatal_package = pkgName;
0:                                         if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion)) {
0:                                             pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MINOR_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), minorChange.getReason(), minorChange.getChangeClass()));
1:                                         }
1:                                     }
0:                                     pkgElements.append("\r\n");
1:                                 }
1:                             }
1:                         }
0:                         // If there is a package version change, the bundle version needs to be updated.
0:                         // If there is a major change in one of the packages, the bundle major version needs to be increased.
0:                         // If there is a minor change in one of the packages, the bundle minor version needs to be increased.
0:                         String oldVersion = baseBundle.getBundleManifest().getVersion().toString();
0:                         String newVersion = currentBundle.getBundleManifest().getVersion().toString();
1: 
1: 
0:                         if (pkg_major_change || pkg_minor_change) {
1: 
0:                             if (pkg_major_change) {
0:                                 // The bundle version's major value should be increased.
0:                                 reason = "Some packages have major changes. For an instance, the package " + fatal_package + " has major version changes.";
0:                                 bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, reason);
0:                                 bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion);
0:                             } else if (pkg_minor_change) {
0:                                 reason = "Some packages have minor changes. For an instance, the package " + fatal_package + " has minor version changes.";
0:                                 bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion, reason);
0:                                 bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion);
1:                             }
1:                         } else {
0:                             reason = "The bundle has no version changes.";
0:                             bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion, reason);
0:                             bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion);
1:                         }
1:                     }
1:                 }
1:                 // Need to write bundle element and then package elements
1:                 if ((!!!bundleVersionCorrect) || ((pkgElements.length() > 0))) {
1:                     writeRecordToWriter(versionStatusFileWriter, bundleElement);
1:                     writeRecordToWriter(versionStatusFileWriter, pkgElements.toString());
1:                     writeRecordToWriter(versionStatusFileWriter, "</bundle>");
1:                 }
1:             }
0:             writeRecordToWriter(versionStatusFileWriter, "</semanaticVersioning>");
1: 
1:             ioe.printStackTrace();
1:         } catch (Exception e) {
1:             e.printStackTrace();
1:         } finally {
1:             IOUtils.close(versionStatusFileWriter);
1:         return;
1:     /**
0:      * Check whether the package has gained additional class or xsd files. If yes, log a minor change.
1:      *
0:      * @param pkgName
0:      * @param curClazz
0:      * @param curXsds
0:      * @param minorChange
1:      */
0:     private void checkAdditionalClassOrXsds(String pkgName, Map<String, IFile> curClazz,
0:                                             Map<String, IFile> curXsds, VersionChange minorChange) {
0:         String reason;
0:         Collection<IFile> ifiles = curClazz.values();
0:         Iterator<IFile> iterator = ifiles.iterator();
0:         while (iterator.hasNext()) {
0:             IFile ifile = iterator.next();
0:             String changeClass = ifile.getName();
0:             SemanticVersioningClassVisitor cv = getVisitor(ifile, newJarsLoader);
0:             if (cv.getClassDeclaration() != null) {
0:                 // If this is a public/protected class, it will need to increase the minor version of the package.
0:                 minorChange.setChange(true);
0:                 if (minorChange.isChange()) {
0:                     reason = "The package " + pkgName + " has gained at least one class : " + getClassName(changeClass) + ".";
0:                     minorChange.update(reason, changeClass, false);
0:                     break;
1:                 }
1:             }
1:         }
0:         if (!!!(minorChange.isChange() || curXsds.isEmpty())) {
0:             /// a new xsd file was added, it is a minor change
0:             IFile firstXsd = null;
0:             Iterator<IFile> xsdIterator = curXsds.values().iterator();
0:             firstXsd = xsdIterator.next();
0:             reason = "In the package " + pkgName + ", The schema file(s) are added: " + curXsds.keySet() + ".";
0:             minorChange.update(reason, firstXsd.getName(), false);
1:         }
1:     /**
0:      * Check whether the package has xsd file changes or deleted. If yes, log a minor change.
1:      *
0:      * @param pkgName
0:      * @param baseXsds
0:      * @param curXsds
0:      * @param majorChange
0:      * @throws IOException
1:      */
0:     private void checkXsdChangesInPkg(String pkgName, Map<String, IFile> baseXsds,
0:                                       Map<String, IFile> curXsds, VersionChange majorChange) throws IOException {
0:         String reason;
0:         for (Map.Entry<String, IFile> file : baseXsds.entrySet()) {
0:             // scan the latest version of the class
0:             IFile curXsd = curXsds.get(file.getKey());
0:             String changeClass = file.getValue().getName();
0:             // check whether the xsd have been deleted or changed or added
0:             if (curXsd == null) {
0:                 reason = "In the package " + pkgName + ", The schema file has been deleted: " + file.getKey() + ".";
0:                 majorChange.update(reason, changeClass, false);
0:                 break;
1:             } else {
0:                 // check whether it is the same
0:                 //read the current xsd file
0:                 curXsds.remove(file.getKey());
0:                 String curFileContent = readXsdFile(curXsd.open());
0:                 String oldFileContent = readXsdFile(file.getValue().open());
0:                 if (!!!(curFileContent.equals(oldFileContent))) {
0:                     reason = "In the package " + pkgName + ", The schema file has been updated: " + file.getKey() + ".";
0:                     majorChange.update(reason, changeClass, false);
0:                     break;
1:                 }
1:             }
1:         }
1:     /**
0:      * Visit the whole package to scan each class to see whether we need to log minor or major changes.
1:      *
0:      * @param pkgName
0:      * @param baseClazz
0:      * @param curClazz
0:      * @param majorChange
0:      * @param minorChange
1:      */
0:     private void visitPackage(String pkgName, Map<String, IFile> baseClazz,
0:                               Map<String, IFile> curClazz, VersionChange majorChange, VersionChange minorChange) {
0:         StringBuilder major_reason = new StringBuilder();
0:         StringBuilder minor_reason = new StringBuilder();
0:         boolean is_major_change = false;
0:         boolean is_minor_change = false;
0:         String fatal_class = null;
0:         boolean foundNewAbstract = false;
0:         for (Map.Entry<String, IFile> file : baseClazz.entrySet()) {
0:             // scan the latest version of the class
0:             IFile curFile = curClazz.get(file.getKey());
0:             String changeClass = file.getValue().getName();
0:             //Scan the base version
0:             SemanticVersioningClassVisitor oldcv = getVisitor(file.getValue(), oldJarsLoader);
0:             // skip the property files as they are compiled as class file as well
0:             ClassDeclaration cd = oldcv.getClassDeclaration();
0:             if ((cd != null) && (!SemanticVersioningUtils.isPropertyFile(cd))) {
0:                 if (curFile == null) {
0:                     // the class we are scanning has been deleted from the current version of WAS
0:                     // This should be a major increase
0:                     major_reason.append(htmlTwoLineBreaks + "The class/interface " + getClassName(changeClass) + " has been deleted from the package.");
0:                     //majorChange.update(reason, changeClass);
0:                     is_major_change = true;
0:                     // only replace the fatal class if not set as the class won't be found in cmvc due to the fact it has been deleted.
0:                     if (fatal_class == null) {
0:                         fatal_class = changeClass;
1:                     }
1:                 } else {
0:                     // check for binary compatibility
0:                     // load the class from the current version of WAS
0:                     // remove it from the curClazz collection as we would like to know whether there are more classes added
0:                     curClazz.remove(file.getKey());
0:                     SemanticVersioningClassVisitor newcv = getVisitor(curFile, newJarsLoader);
0:                     // check for binary compatibility
0:                     ClassDeclaration newcd = newcv.getClassDeclaration();
0:                     BinaryCompatibilityStatus bcs = newcd.getBinaryCompatibleStatus(oldcv.getClassDeclaration());
1: 
0:                     if (!bcs.isCompatible()) {
0:                         major_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following changes have been made since the last release of WAS.");
0:                         // break binary compatibility
0:                         major_reason.append(bcs.getReason());
0:                         is_major_change = true;
0:                         fatal_class = changeClass;
1:                     } else {
0:                         //check to see whether more methods are added
0:                         ClassDeclaration oldcd = oldcv.getClassDeclaration();
0:                         Collection<MethodDeclaration> extraMethods = newcd.getExtraMethods(oldcd);
1: 
0:                         boolean containsConcrete = false;
0:                         boolean containsAbstract = false;
1: 
0:                         boolean abstractClass = newcd.isAbstract();
1: 
0:                         StringBuilder subRemarks = new StringBuilder();
0:                         String concreteSubRemarks = null;
0:                         for (MethodDeclaration extraMethod : extraMethods) {
0:                             //only interested in the visible methods not the system generated ones
0:                             if (!extraMethod.getName().contains("$")) {
0:                                 if (abstractClass) {
0:                                     if (extraMethod.isAbstract()) {
0:                                         foundNewAbstract = true;
0:                                         containsAbstract = true;
0:                                         subRemarks.append(htmlOneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc()));
1:                                     } else {
0:                                         //only list one abstract method, no need to list all
0:                                         containsConcrete = true;
0:                                         concreteSubRemarks = htmlOneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
1:                                     }
1:                                 } else {
0:                                     containsConcrete = true;
0:                                     concreteSubRemarks = htmlOneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
0:                                     break;
1:                                 }
1:                             }
1:                         }
1: 
0:                         if (containsConcrete || containsAbstract) {
0:                             is_minor_change = true;
0:                             if (!is_major_change) {
0:                                 fatal_class = changeClass;
1:                             }
0:                             if (containsAbstract) {
1: 
0:                                 minor_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following abstract methods have been added since the last release of WAS.");
0:                                 minor_reason.append(subRemarks);
1:                             } else {
0:                                 minor_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following method has been added since the last release of WAS.");
0:                                 minor_reason.append(concreteSubRemarks);
1:                             }
1:                         }
0:                         //check to see whether there are extra public/protected fields if there is no additional methods
1: 
0:                         if (!is_minor_change) {
0:                             for (FieldDeclaration field : newcd.getExtraFields(oldcd)) {
0:                                 if (field.isPublic() || field.isProtected()) {
0:                                     is_minor_change = true;
0:                                     String extraFieldRemarks = htmlOneLineBreak + " " + SemanticVersioningUtils.transform(field.getDesc()) + " " + field.getName();
0:                                     if (!is_major_change) {
0:                                         fatal_class = changeClass;
1:                                     }
0:                                     minor_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following fields have been added since the last release of WAS.");
0:                                     minor_reason.append(extraFieldRemarks);
0:                                     break;
1:                                 }
1:                             }
1: 
1:                         }
1: 
1:                     }
1:                 }
1:             }
1:         }
0:         if (is_major_change) {
0:             majorChange.update(major_reason.toString(), fatal_class, false);
1:         }
0:         if (is_minor_change) {
0:             minorChange.update(minor_reason.toString(), fatal_class, (foundNewAbstract ? true : false));
1:         }
0:     private String readXsdFile(InputStream is) {
0:         BufferedReader br = new BufferedReader(new InputStreamReader(is));
0:         StringBuilder sb = new StringBuilder();
0:         String line = null;
1:         try {
0:             while ((line = br.readLine()) != null) {
0:                 sb.append(line);
1:             }
1:         } catch (IOException ioe) {
0:             IOUtils.close(br);
1:         }
0:         return sb.toString();
1:     }
1:     private void writeRecordToWriter(FileWriter fileWriter, String stringToWrite) throws IOException {
1:         if (fileWriter != null) {
1:             fileWriter.append(stringToWrite);
1:             fileWriter.append("\r\n");
1:         }
1:     }
1: 
0:     private Map<String, PackageContent> getAllExportedPkgContents(BundleInfo currentBundle) {
0:         String packageExports = currentBundle.getBundleManifest().getRawAttributes().getValue(Constants.EXPORT_PACKAGE);
0:         List<NameValuePair> exportPackageLists = ManifestHeaderProcessor.parseExportString(packageExports);
0:         // only perform validation if there are some packages exported. Otherwise, not interested.
0:         Map<String, PackageContent> exportedPackages = new HashMap<String, PackageContent>();
0:         if (!!!exportPackageLists.isEmpty()) {
0:             File bundleFile = currentBundle.getBundle();
0:             IDirectory bundleDir = FileSystem.getFSRoot(bundleFile);
0:             for (NameValuePair exportedPackage : exportPackageLists) {
0:                 String packageName = exportedPackage.getName();
0:                 String packageVersion = exportedPackage.getAttributes().get(Constants.VERSION_ATTRIBUTE);
0:                 // need to go through each package and scan every class
0:                 exportedPackages.put(packageName, new PackageContent(packageName, packageVersion));
1:             }
0:             // scan the jar and list all the files under each package
0:             List<IFile> allFiles = bundleDir.listAllFiles();
0:             for (IFile file : allFiles) {
0:                 String directoryFullPath = file.getName();
0:                 String directoryName = null;
0:                 String fileName = null;
0:                 if (file.isFile() && ((file.getName().endsWith(SemanticVersioningUtils.classExt) || (file.getName().endsWith(SemanticVersioningUtils.schemaExt))))) {
0:                     if (directoryFullPath.lastIndexOf("/") != -1) {
0:                         directoryName = directoryFullPath.substring(0, directoryFullPath.lastIndexOf("/"));
0:                         fileName = directoryFullPath.substring(directoryFullPath.lastIndexOf("/") + 1);
1:                     }
1:                 }
1: 
0:                 if (directoryName != null) {
0:                     String pkgName = directoryName.replaceAll("/", ".");
0:                     PackageContent pkgContent = exportedPackages.get(pkgName);
0:                     if (pkgContent != null) {
0:                         if (file.getName().endsWith(SemanticVersioningUtils.classExt)) {
0:                             pkgContent.addClass(fileName, file);
1:                         } else {
0:                             pkgContent.addXsd(fileName, file);
1:                         }
0:                         exportedPackages.put(pkgName, pkgContent);
1:                     }
1:                 }
1:             }
1:         }
0:         return exportedPackages;
1:     }
1: 
1:     private Map<String, BundleInfo> getBundles(IDirectory ds) {
1:         Map<String, BundleInfo> bundles = new HashMap<String, BundleInfo>();
1:         List<IFile> includedFiles = ds.listAllFiles();
1: 
1:         for (IFile ifile : includedFiles) {
1: 
1: 
1:             if (ifile.getName().endsWith(SemanticVersioningUtils.jarExt)) {
1:                 // scan its manifest
1:                 try {
1:                     BundleManifest manifest = BundleManifest.fromBundle(ifile.open());
1:                     // find the bundle symbolic name, store them in a map with bundle symbolic name as key, bundleInfo as value
1:                     if (manifest.getSymbolicName() != null) {
1: 
1:                         bundles.put(manifest.getSymbolicName(), new BundleInfo(manifest, new File(ifile.toURL().getPath())));
1: 
1:                     }
1:                 } catch (MalformedURLException mue) {
1:                     _logger.debug("Exception thrown when processing" + ifile.getName(), mue);
1:                 } catch (IOException ioe) {
1:                     _logger.debug("Exception thrown when processing" + ifile.getName(), ioe);
1:                 }
1:             }
1:         }
1:         return bundles;
1:     }
1: 
0:     private String getStatusText(VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr) {
1: 
0:         Version oldVersion = Version.parseVersion(oldVersionStr);
0:         Version newVersion = Version.parseVersion(newVersionStr);
0:         Version recommendedVersion = Version.parseVersion(oldVersionStr);
0:         if (status == VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
0:             recommendedVersion = new Version(oldVersion.getMajor() + 1, 0, 0);
0:         } else if (status == VERSION_CHANGE_TYPE.MINOR_CHANGE) {
0:             recommendedVersion = new Version(oldVersion.getMajor(), oldVersion.getMinor() + 1, 0);
1:         } else {
0:             recommendedVersion = oldVersion;
1:         }
0:         return " oldVersion=\"" + oldVersion
0:                 + "\" currentVersion=\"" + newVersion +
0:                 "\" recommendedVersion=\"" + recommendedVersion + "\" correct=\"" + isVersionCorrect(status, oldVersionStr, newVersionStr);
1:     }
1: 
0:     private String transformForXml(String str) {
0:         str = str.replaceAll("<", "&lt;");
0:         str = str.replaceAll(">", "&gt;");
0:         return str;
1:     }
1: 
0:     private boolean isVersionCorrect(VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr) {
0:         boolean versionCorrect = false;
1: 
0:         Version oldVersion = Version.parseVersion(oldVersionStr);
0:         Version newVersion = Version.parseVersion(newVersionStr);
1: 
0:         if (status == VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
0:             if (newVersion.getMajor() > oldVersion.getMajor()) {
0:                 versionCorrect = true;
1:             }
0:         } else if (status == VERSION_CHANGE_TYPE.MINOR_CHANGE) {
0:             if ((newVersion.getMajor() > oldVersion.getMajor()) || (newVersion.getMinor() > oldVersion.getMinor())) {
0:                 versionCorrect = true;
1:             }
1:         } else {
0:             if ((newVersion.getMajor() == oldVersion.getMajor()) && (newVersion.getMinor() == oldVersion.getMinor())) {
0:                 versionCorrect = true;
1:             }
1:         }
0:         return versionCorrect;
1:     }
1: 
0:     private String getPkgStatusText(String pkgName, VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr, String reason, String key_class) {
1: 
0:         String modified_key_class = key_class;
0:         if (key_class.endsWith(SemanticVersioningUtils.classExt)) {
0:             modified_key_class = key_class.substring(0, key_class.lastIndexOf(SemanticVersioningUtils.classExt)) + SemanticVersioningUtils.javaExt;
1:         }
1: 
0:         return "<package name=\"" + pkgName + "\"" + getStatusText(status, oldVersionStr, newVersionStr) + "\" reason=\"" + transformForXml(reason) + "\" key_class=\"" + modified_key_class + "\" change=\"" + status.text() + "\"/>";
1:     }
1: 
0:     private String getBundleStatusText(String bundleFileName, String bundleSymbolicName, VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr, String reason) {
0:         return "<bundle fileName=\"" + bundleFileName + "\" bundleSymbolicName =\"" + bundleSymbolicName + "\"" + getStatusText(status, oldVersionStr, newVersionStr) + "\" reason=\"" + transformForXml(reason) + "\" change=\"" + status.text() + "\">";
1:     }
1: 
0:     private SemanticVersioningClassVisitor getVisitor(IFile file, URLClassLoader loader) {
0:         SemanticVersioningClassVisitor oldcv = new SemanticVersioningClassVisitor(loader);
1:         try {
0:             ClassReader cr = new ClassReader(file.open());
0:             cr.accept(oldcv, 0);
1:         } catch (IOException ioe) {
0:             _logger.debug("The file " + file + "cannot be opened.");
1:         }
0:         return oldcv;
1:     }
1: 
1:     private Collection<URL> getListURLs(Collection<BundleInfo> bundles) {
1:         Collection<URL> urls = new HashSet<URL>();
1:         try {
1:             for (BundleInfo bundle : bundles) {
1: 
1:                 URL url = bundle.getBundle().toURI().toURL();
1:                 urls.add(url);
1: 
1:             }
1: 
1:         } catch (MalformedURLException e) {
1:             _logger.debug(e.getMessage());
1:         }
1:         return urls;
1:     }
1: 
0:     private String getClassName(String fullClassPath) {
0:         String[] chunks = fullClassPath.split("/");
0:         String className = chunks[chunks.length - 1];
0:         className = className.replace(SemanticVersioningUtils.classExt, SemanticVersioningUtils.javaExt);
0:         return className;
1:     }
1: 
0:     private class BundleInfo {
0:         private final BundleManifest bundleManifest;
0:         private final File bundle;
1: 
0:         BundleInfo(BundleManifest bm, File bundle) {
0:             this.bundleManifest = bm;
0:             this.bundle = bundle;
1:         }
1: 
0:         public BundleManifest getBundleManifest() {
0:             return bundleManifest;
1:         }
1: 
0:         public File getBundle() {
0:             return bundle;
1:         }
1:     }
1: 
0:     enum VERSION_CHANGE_TYPE {
0:         MAJOR_CHANGE("major"), MINOR_CHANGE("minor"), NO_CHANGE("no");
0:         private final String text;
0:         VERSION_CHANGE_TYPE(String text)
0:         {
0:             this.text = text;
1:         }
1: 
0:     public String text() {
0:         return this.text;
1:     }
1: 
0: };
1: 
0: private class PackageContent {
0:     private final String packageName;
1: 
0:         packageName = pkgName;
0:         packageVersion = pkgVersion;
1: 
0:         classes.put(className, file);
1: 
0:         xsds.put(className, file);
0:     public Map<String, IFile> getClasses() {
0:         return classes;
1: 
0:     public Map<String, IFile> getXsds() {
0:         return xsds;
1:     }
1: 
0:     public String getPackageVersion() {
0:         return packageVersion;
1:     }
1: 
0:         return packageName;
1: }
0: private class VersionChange {
0:     String reason = null;
1: 
1: 
0:     public boolean isMoreAbstractMethod() {
0:         return moreAbstractMethod;
1: 
0:     public boolean isChange() {
0:         return change;
1: 
0:     public void setChange(boolean change) {
0:         this.change = change;
1: 
0:     public String getReason() {
0:         return reason;
1: 
0:     public String getChangeClass() {
0:         return changeClass;
1: 
0:         this.change = true;
0:         this.reason = reason;
0:         this.changeClass = changeClass;
0:         this.moreAbstractMethod = moreAbstractMethod;
1: }
author:Emily Jiang
-------------------------------------------------------------------------------
commit:f9b43fb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.versioning.utils.ClassDeclaration;
0: import org.apache.aries.versioning.utils.FieldDeclaration;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.htmlOneLineBreak;
0: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.htmlTwoLineBreaks;;
0:   private static final String xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>";
/////////////////////////////////////////////////////////////////////////
0:           minorChange.update(reason, changeClass, false);
/////////////////////////////////////////////////////////////////////////
0:       minorChange.update(reason, firstXsd.getName(), false);
/////////////////////////////////////////////////////////////////////////
0:         majorChange.update(reason, changeClass, false);
/////////////////////////////////////////////////////////////////////////
0:           majorChange.update(reason, changeClass, false);
/////////////////////////////////////////////////////////////////////////
0:     StringBuilder major_reason = new StringBuilder();
0:     StringBuilder minor_reason = new StringBuilder();
0:     boolean is_major_change = false;
0:     boolean is_minor_change = false;
0:     String fatal_class = null;
0:     boolean foundNewAbstract = false;
0:       // skip the property files as they are compiled as class file as well
0:       ClassDeclaration cd = oldcv.getClassDeclaration();
0:       if ((cd != null) && (!SemanticVersioningUtils.isPropertyFile(cd))) {
0:         
0:           major_reason.append(htmlTwoLineBreaks + "The class/interface " + getClassName(changeClass) + " has been deleted from the package." );
0:           //majorChange.update(reason, changeClass);
0:           is_major_change = true;
0:           // only replace the fatal class if not set as the class won't be found in cmvc due to the fact it has been deleted.
0:           if (fatal_class == null) {
0:             fatal_class = changeClass;
0:           }
/////////////////////////////////////////////////////////////////////////
0:           ClassDeclaration newcd = newcv.getClassDeclaration();
0:           BinaryCompatibilityStatus bcs = newcd.getBinaryCompatibleStatus(oldcv.getClassDeclaration());
0: 
0:           if (!bcs.isCompatible()) {
0:             major_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass)+ " class or its supers, the following changes have been made since the last release of WAS.");
0:             // break binary compatibility
0:             major_reason.append( bcs.getReason());
0:             is_major_change = true;
0:             fatal_class = changeClass;
0:             //check to see whether more methods are added
0:             ClassDeclaration oldcd = oldcv.getClassDeclaration();
0:             Collection<MethodDeclaration> extraMethods = newcd.getExtraMethods(oldcd);
0: 
0:             boolean containsConcrete = false;
0:             boolean containsAbstract = false;
0: 
0:             boolean abstractClass = newcd.isAbstract();
0: 
0:             StringBuilder subRemarks = new StringBuilder();
0:             String concreteSubRemarks = null;
0:             for (MethodDeclaration extraMethod : extraMethods) {
0:               //only interested in the visible methods not the system generated ones
0:               if (!extraMethod.getName().contains("$")) {
0:                 if (abstractClass ) {
0:                   if (extraMethod.isAbstract()) {
0:                     foundNewAbstract = true;
0:                     containsAbstract = true;
0:                     subRemarks.append(htmlOneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc()));
0:                   } else {
0:                     //only list one abstract method, no need to list all
0:                     containsConcrete = true;
0:                     concreteSubRemarks=htmlOneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
0:                   }
0:                 }
0:                 else {
0:                   containsConcrete = true;
0:                   concreteSubRemarks=htmlOneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
0:                   break;
0:                 }
0:               }
0:             }
0:             
0:             if (containsConcrete || containsAbstract) {
0:               is_minor_change = true;
0:               if (!is_major_change) {
0:                 fatal_class = changeClass;
0:               }
0:               if ( containsAbstract) {
0: 
0:                 minor_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass)+ " class or its supers, the following abstract methods have been added since the last release of WAS.");
0:                 minor_reason.append(subRemarks);
0:               } else {
0:                 minor_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass)+ " class or its supers, the following method has been added since the last release of WAS.");
0:                 minor_reason.append(concreteSubRemarks);
0:               }
0:             }
0:             //check to see whether there are extra public/protected fields if there is no additional methods
0:               
0:               if (!is_minor_change){
0:                 for (FieldDeclaration field : newcd.getExtraFields(oldcd)) {
0:                   if (field.isPublic() || field.isProtected()) {
0:                     is_minor_change = true;
0:                     String extraFieldRemarks = htmlOneLineBreak + " " + SemanticVersioningUtils.transform(field.getDesc()) + " "+ field.getName() ;
0:                     if (!is_major_change) {
0:                       fatal_class = changeClass;
0:                     }
0:                     minor_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass)+ " class or its supers, the following fields have been added since the last release of WAS.");
0:                     minor_reason.append(extraFieldRemarks);
0:                     break;
0:                   }
0:                 }
0:                 
0:               }
0:             
0:     if (is_major_change) {
0:       majorChange.update(major_reason.toString(), fatal_class, false);
0:     }
0:     if (is_minor_change) {
0:       minorChange.update(minor_reason.toString(), fatal_class, (foundNewAbstract? true: false));
0:     }
/////////////////////////////////////////////////////////////////////////
0:     boolean moreAbstractMethod = false;
0:     
0:     
0:     public boolean isMoreAbstractMethod()
0:     {
0:       return moreAbstractMethod;
0:     }
/////////////////////////////////////////////////////////////////////////
0:     public void update(String reason, String changeClass, boolean moreAbstractMethod) {
0:       this.moreAbstractMethod = moreAbstractMethod;
commit:6aa0635
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  */
0: 
1: package org.apache.aries.versioning.check;
0: 
0: import java.io.BufferedReader;
1: import java.io.File;
1: import java.io.FileWriter;
1: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
1: import java.net.MalformedURLException;
1: import java.net.URISyntaxException;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.HashSet;
0: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
0: 
0: 
0: 
1: import org.apache.aries.util.filesystem.FileSystem;
1: import org.apache.aries.util.filesystem.IDirectory;
1: import org.apache.aries.util.filesystem.IFile;
1: import org.apache.aries.util.io.IOUtils;
1: import org.apache.aries.util.manifest.BundleManifest;
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
0: import org.apache.aries.versioning.utils.BinaryCompatibilityStatus;
0: import org.apache.aries.versioning.utils.MethodDeclaration;
0: import org.apache.aries.versioning.utils.SemanticVersioningClassVisitor;
1: import org.apache.aries.versioning.utils.SemanticVersioningUtils;
0: import org.objectweb.asm.ClassReader;
0: import org.osgi.framework.Constants;
0: import org.osgi.framework.Version;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: 
1: public class SemanticVersioningChecker {
0: 
0:   private static final Logger _logger = LoggerFactory.getLogger(SemanticVersioningChecker.class);
0:   private URLClassLoader newJarsLoader;
0:   private URLClassLoader oldJarsLoader;
0:   private final String xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>";
0:   /**
0:    * This method is to scan the current location against base and process each individual jars 
0:    * in the current location against the jar with the same symbolic names in the base and produce a xml report specified by versioningReport.
0:    * @param base baseline jars
0:    * @param current current version of jars
0:    * @param versioningReport the validation reports
0:    */
0:   public static void checkSemanticVersioning(URL base, URL current, File versioningReport) {
0:     //For each jar under the current location, open the jar and then use ASM to 
0:     //work out whether there are binary incompatible changes against the base location.
0:     try {
0:       File baseDir = new File(base.toURI());
0:       File currentDir = new File(current.toExternalForm());
0:       if ( baseDir.exists() && currentDir.exists()) {
0:         new SemanticVersioningChecker().performVersioningCheck(FileSystem.getFSRoot(baseDir), FileSystem.getFSRoot(currentDir), versioningReport);
0:       } else {
0:         _logger.debug("No bundles found to process.");
0:       }
0:     } catch (URISyntaxException use) {
0:       _logger.error(use.getMessage());
0:     }
0:   }
0: 
0:   // for each jar, open its manifest and found the packages
0:   private  void  performVersioningCheck(IDirectory  baseDir, IDirectory currentDir, File versionStatusFile)  {
0:     
0:     FileWriter versionStatusFileWriter = null;
0:     try {
0:       versionStatusFileWriter = new FileWriter(versionStatusFile, false);
0:       Map<String, BundleInfo> baseBundles = new HashMap<String, BundleInfo>();
0:       Map<String, BundleInfo> currentBundles = new HashMap<String, BundleInfo>();
0:       
0:         //scan each individual bundle and find the corresponding bundle in the baseline and verify the version changes
0:         currentBundles = getBundles(currentDir);
0:         baseBundles = getBundles(baseDir);
0:         URL[] newJarURLs = getListURLs(currentBundles.values()).toArray(new URL[0]);
0:         newJarsLoader = new URLClassLoader(newJarURLs);
0: 
0:         URL[] oldJarURLs = getListURLs(baseBundles.values()).toArray(new URL[0]);
0: 
0:         oldJarsLoader = new URLClassLoader(oldJarURLs);
0: 
0:         //Write the xml header
0:         writeRecordToWriter(versionStatusFileWriter, xmlHeader + "\r\n");
0:         
0:         // write the comparison base and current level into the file
0:         writeRecordToWriter(versionStatusFileWriter, "<semanaticVersioning currentDir= \"" + currentDir + "\" baseDir = \"" + baseDir + "\">");
0:         for (Map.Entry<String, BundleInfo> entry : currentBundles.entrySet()) {
0:           String bundleSymbolicName = entry.getKey();
0: 
0:           String bundleElement = null;
0:           boolean bundleVersionCorrect = true;
0:           // find the same bundle in the base and check whether all the versions are correct
0:           BundleInfo currentBundle = entry.getValue();
0:           BundleInfo baseBundle = baseBundles.get(bundleSymbolicName);
0:           StringBuilder pkgElements = new StringBuilder();
0:           String reason = null;
0:           if (baseBundle == null) {
0:             _logger.debug("The bundle " + bundleSymbolicName + " has no counterpart in the base. The semanit version validation does not apply to this bundle.");
0:           } else {
0:             // open the manifest and scan the export package and find the package name and exported version
0:             // The tool assume the one particular package just exports under one version
0:             Map<String, PackageContent> currBundleExpPkgContents = getAllExportedPkgContents(currentBundle);
0:             Map<String, PackageContent> baseBundleExpPkgContents = new HashMap<String, PackageContent>();
0:             boolean pkg_major_change = false;
0:             boolean pkg_minor_change = false;
0:             String fatal_package = null;
0:             if (!!!currBundleExpPkgContents.isEmpty()) {
0:               baseBundleExpPkgContents =  getAllExportedPkgContents(baseBundle);
0:               // compare each class right now
0:               for (Map.Entry<String, PackageContent> pkg : baseBundleExpPkgContents.entrySet()) {
0:                 String pkgName = pkg.getKey();
0:                 Map<String, IFile> baseClazz = pkg.getValue().getClasses();
0:                 Map<String, IFile> baseXsds = pkg.getValue().getXsds();
0:                 PackageContent currPkgContents = currBundleExpPkgContents.get(pkgName);
0:                 if (currPkgContents == null) {
0:                   // The package is no longer exported any more. This should lead to bundle major version change.
0:                   pkg_major_change = true;
0:                   fatal_package = pkgName;
0:                   _logger.debug("The package " + pkgName + " in the bundle of " + bundleSymbolicName + " is no longer to be exported. Major change.");
0:                 } else {
0:                   Map<String, IFile> curClazz = currPkgContents.getClasses();
0:                   Map<String, IFile> curXsds = currPkgContents.getXsds();
0:                   //check whether there should be major change/minor change/micro change in this package.
0:                   //1. Use ASM to visit all classes in the package 
0:                   VersionChange majorChange = new VersionChange();
0:                   VersionChange minorChange = new VersionChange();
0:                   // check all classes to see whether there are minor or major changes
0:                   visitPackage(pkgName, baseClazz, curClazz, majorChange, minorChange);
0:                   // If there is no binary compatibility changes, check whether xsd files have been added, changed or deleted
0:                   if (!!!majorChange.isChange()) {
0:                     checkXsdChangesInPkg(pkgName, baseXsds, curXsds, majorChange);
0:                     // If everything is ok with the existing classes. Need to find out whether there are more API (abstract classes) in the current bundle.
0:                     // loop through curClazz and visit it and find out whether one of them is abstract.
0:                     // check whether there are more xsd or abstract classes added
0:                     if (!!!(majorChange.isChange() || minorChange.isChange())){
0:                       checkAdditionalClassOrXsds(pkgName, curClazz, curXsds, minorChange);
0:                     }
0:                   }
0:                   // We have scanned the whole packages, report the result
0:                   if (majorChange.isChange() || minorChange.isChange()) {
0:                     String oldVersion = pkg.getValue().getPackageVersion();
0:                     String newVersion = currPkgContents.getPackageVersion();
0:                     if (majorChange.isChange()) {
0:                       pkg_major_change = true;
0:                       fatal_package = pkgName;
0:                       if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion)) {                      
0:                         pkgElements.append(getPkgStatusText( pkgName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, majorChange.getReason(), majorChange.getChangeClass()));                      
0:                       }
0:                     } else if (minorChange.isChange()) {
0:                       pkg_minor_change = true;
0:                       if (fatal_package == null) fatal_package = pkgName;
0:                       if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion)) {
0:                         pkgElements.append(getPkgStatusText( pkgName, VERSION_CHANGE_TYPE.MINOR_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), minorChange.getReason(), minorChange.getChangeClass()));
0:                       }
0:                     }
0:                     pkgElements.append("\r\n");
0:                   }
0:                 }
0:               }
0:               // If there is a package version change, the bundle version needs to be updated.
0:               // If there is a major change in one of the packages, the bundle major version needs to be increased.
0:               // If there is a minor change in one of the packages, the bundle minor version needs to be increased.
0:               String oldVersion = baseBundle.getBundleManifest().getVersion().toString();
0:               String newVersion = currentBundle.getBundleManifest().getVersion().toString();
0: 
0: 
0:               if (pkg_major_change || pkg_minor_change) {
0: 
0:                 if (pkg_major_change) {
0:                   // The bundle version's major value should be increased.
0:                   reason = "Some packages have major changes. For an instance, the package " + fatal_package + " has major version changes.";
0:                   bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, reason);
0:                   bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion);
0:                 } else if (pkg_minor_change) {
0:                   reason = "Some packages have minor changes. For an instance, the package " + fatal_package + " has minor version changes.";
0:                   bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion, reason);
0:                   bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion);
0:                 } 
0:               } else {
0:                 reason = "The bundle has no version changes.";
0:                 bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion, reason);
0:                 bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion);
0:               }
0:             }
0:           }
0:           // Need to write bundle element and then package elements
0:           if ((!!!bundleVersionCorrect) || ((pkgElements.length() > 0) )) {
0:             writeRecordToWriter(versionStatusFileWriter, bundleElement);
0:             writeRecordToWriter(versionStatusFileWriter, pkgElements.toString());
0:             writeRecordToWriter(versionStatusFileWriter, "</bundle>");
0:           }
0:         }
0:         writeRecordToWriter(versionStatusFileWriter, "</semanaticVersioning>");
0:       
0:     } catch (IOException ioe) {
0:       ioe.printStackTrace();
0:     } catch (Exception e) {
0:       e.printStackTrace();
0:     }
0:     finally {
0:       IOUtils.close(versionStatusFileWriter);
0:     }
0:     
0:     return ;
0:   }
0:   /**
0:    * Check whether the package has gained additional class or xsd files. If yes, log a minor change.
0:    * @param pkgName
0:    * @param curClazz
0:    * @param curXsds
0:    * @param minorChange
0:    */
0:   private void checkAdditionalClassOrXsds(String pkgName, Map<String, IFile> curClazz,
0:       Map<String, IFile> curXsds, VersionChange minorChange)
0:   {
0:     String reason;
0:     Collection<IFile> ifiles = curClazz.values();
0:     Iterator<IFile> iterator = ifiles.iterator();
0:     while (iterator.hasNext()) {
0:       IFile ifile = iterator.next();
0:       String changeClass = ifile.getName();
0:       SemanticVersioningClassVisitor cv = getVisitor(ifile, newJarsLoader);
0:       if (cv.getClassDeclaration() != null) {
0:         // If this is a public/protected class, it will need to increase the minor version of the package.
0:         minorChange.setChange(true);
0:         if (minorChange.isChange()) {
0:           reason = "The package " + pkgName + " has gained at least one class : " + getClassName(changeClass)+ ".";
0:           minorChange.update(reason, changeClass);
0:           break;
0:         }
0:       }
0:     }
0:     if (!!!(minorChange.isChange() || curXsds.isEmpty())) {
0:       /// a new xsd file was added, it is a minor change
0:       IFile firstXsd = null;
0:       Iterator<IFile> xsdIterator = curXsds.values().iterator();
0:       firstXsd = xsdIterator.next();
0: 
0:       reason = "In the package " + pkgName + ", The schema file(s) are added: " + curXsds.keySet()+ ".";
0:       minorChange.update(reason, firstXsd.getName());
0:     }
0:   }
0: 
0: 
0:   /**
0:    * Check whether the package has xsd file changes or deleted. If yes, log a minor change.
0:    * @param pkgName
0:    * @param baseXsds
0:    * @param curXsds
0:    * @param majorChange
0:    * @throws IOException
0:    */
0: 
0:   private void checkXsdChangesInPkg(String pkgName, Map<String, IFile> baseXsds,
0:       Map<String, IFile> curXsds, VersionChange majorChange) throws IOException
0:       {
0:     String reason;
0:     for (Map.Entry<String, IFile> file : baseXsds.entrySet()) {
0:       // scan the latest version of the class
0:       IFile curXsd = curXsds.get(file.getKey());
0:       String changeClass = file.getValue().getName();
0:       // check whether the xsd have been deleted or changed or added
0:       if (curXsd == null) {  
0:         reason = "In the package " + pkgName + ", The schema file has been deleted: " + file.getKey()+ ".";
0:         majorChange.update(reason, changeClass);
0:         break;                      
0:       } else {
0:         // check whether it is the same
0:         //read the current xsd file
0:         curXsds.remove(file.getKey());
0:         String curFileContent = readXsdFile(curXsd.open());
0:         String oldFileContent = readXsdFile(file.getValue().open());
0:         if (!!!(curFileContent.equals(oldFileContent))) {
0: 
0:           reason = "In the package " + pkgName + ", The schema file has been updated: " + file.getKey()+ ".";
0:           majorChange.update(reason, changeClass);
0:           break;
0:         }
0:       }
0:     }
0:       }
0: 
0:   /**
0:    * Visit the whole package to scan each class to see whether we need to log minor or major changes.
0:    * @param pkgName
0:    * @param baseClazz
0:    * @param curClazz
0:    * @param majorChange
0:    * @param minorChange
0:    */
0:   private void visitPackage(String pkgName, Map<String, IFile> baseClazz,
0:       Map<String, IFile> curClazz, VersionChange majorChange, VersionChange minorChange)
0:   {
0:     String reason;
0:     for (Map.Entry<String, IFile> file : baseClazz.entrySet()) {
0:       // scan the latest version of the class
0:       IFile curFile = curClazz.get(file.getKey());
0:       String changeClass = file.getValue().getName();
0:       //Scan the base version
0:       SemanticVersioningClassVisitor oldcv = getVisitor(file.getValue(), oldJarsLoader);
0:       if ((oldcv.getClassDeclaration() != null)) {
0:         if (curFile == null) {
0:           // the class we are scanning has been deleted from the current version of WAS
0:           // This should be a major increase
0:           reason = "In the package " + pkgName + ", The class/interface has been deleted: " + getClassName(changeClass) + ".";
0:           majorChange.update(reason, changeClass);
0: 
0:           break;
0:         } else {
0:           // check for binary compatibility
0:           // load the class from the current version of WAS
0:           // remove it from the curClazz collection as we would like to know whether there are more classes added
0:           curClazz.remove(file.getKey());
0:           SemanticVersioningClassVisitor newcv = getVisitor(curFile, newJarsLoader);
0:           // check for binary compatibility
0:           BinaryCompatibilityStatus bcs = newcv.getClassDeclaration().getBinaryCompatibleStatus(oldcv.getClassDeclaration());
0:           if (bcs.isCompatible()) {
0:             // check to see whether there are extra methods
0:             MethodDeclaration extraMethod = newcv.getClassDeclaration().getExtraMethods(oldcv.getClassDeclaration());
0:             if (extraMethod != null) {
0:               // This should be a minor increase
0:               reason = "In the package " + pkgName + ", the " + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc()) + " has been added to the class or its super classes/interfaces " + getClassName(changeClass) + ".";
0:               minorChange.update(reason, changeClass);
0:             }
0:           } else {
0:             // break binary compatibility 
0:             reason = "In the package " + pkgName + ", binary incompatibility occurred in the class " + getClassName(changeClass)+ ". " + bcs.getReason();
0:             majorChange.update(reason, changeClass);
0:             break; 
0:           }
0:         }
0:       }
0:     }
0:   }
0: 
0:   private String readXsdFile(InputStream is) {
0:     BufferedReader br = new BufferedReader( new InputStreamReader(is));
0:     StringBuilder sb = new StringBuilder();
0:     String line = null;
0:     try {
0:       while(( line = br.readLine()) != null) {
0:         sb.append(line);
0:       }
0:     } catch (IOException ioe) {
0:       IOUtils.close(br);
0:     }
0:     return sb.toString();
0:   }
0:   private void writeRecordToWriter(FileWriter fileWriter, String stringToWrite) throws IOException {
0:     if (fileWriter != null) {
0:       fileWriter.append(stringToWrite);
0:       fileWriter.append("\r\n");
0:     }
0:   }
0:   private Map<String, PackageContent> getAllExportedPkgContents(BundleInfo currentBundle)
0:   {
0:     String packageExports = currentBundle.getBundleManifest().getRawAttributes().getValue(Constants.EXPORT_PACKAGE);
0:     List<NameValuePair> exportPackageLists = ManifestHeaderProcessor.parseExportString(packageExports);
0:     // only perform validation if there are some packages exported. Otherwise, not interested.
0:     Map<String, PackageContent> exportedPackages = new HashMap<String, PackageContent>();
0:     if (!!!exportPackageLists.isEmpty()) {
0:       File bundleFile = currentBundle.getBundle();
0:       IDirectory bundleDir = FileSystem.getFSRoot(bundleFile);
0:       for (NameValuePair exportedPackage : exportPackageLists) {
0:         String packageName = exportedPackage.getName();
0:         String packageVersion = exportedPackage.getAttributes().get(Constants.VERSION_ATTRIBUTE);
0:         // need to go through each package and scan every class
0:         exportedPackages.put(packageName, new PackageContent(packageName, packageVersion));
0:       }
0:       // scan the jar and list all the files under each package
0:       List<IFile> allFiles = bundleDir.listAllFiles();
0:       for (IFile file : allFiles) {
0:         String directoryFullPath = file.getName(); 
0:         String directoryName = null;
0:         String fileName = null;
0:         if (file.isFile() && ((file.getName().endsWith(SemanticVersioningUtils.classExt) ||(file.getName().endsWith(SemanticVersioningUtils.schemaExt))))) {
0:           if (directoryFullPath.lastIndexOf("/") != -1) {
0:             directoryName = directoryFullPath.substring(0, directoryFullPath.lastIndexOf("/"));
0:             fileName = directoryFullPath.substring(directoryFullPath.lastIndexOf("/") + 1);
0:           }
0:         } 
0: 
0:         if (directoryName != null) {
0:           String pkgName = directoryName.replaceAll("/", ".") ;
0:           PackageContent pkgContent = exportedPackages.get(pkgName);
0:           if (pkgContent != null) {
0:             if (file.getName().endsWith(SemanticVersioningUtils.classExt)) {
0:               pkgContent.addClass(fileName, file);
0:             } else {
0:               pkgContent.addXsd(fileName, file);
0:             }
0:             exportedPackages.put(pkgName, pkgContent);
0:           }
0:         }
0:       }
0:     }
0:     return exportedPackages;
0:   }
0: 
0:   private Map<String, BundleInfo> getBundles(IDirectory ds)
0:   {
0:     Map<String, BundleInfo> bundles = new HashMap<String, BundleInfo>();
0:     List<IFile> includedFiles = ds.listAllFiles();
0: 
0:     for (IFile ifile : includedFiles) {
0: 
0: 
0:       
0:       if (ifile.getName().endsWith(SemanticVersioningUtils.jarExt)) {
0:         // scan its manifest
0:         try {
0:         BundleManifest manifest = BundleManifest.fromBundle(ifile.open());
0:         // find the bundle symbolic name, store them in a map with bundle symbolic name as key, bundleInfo as value
0:         if (manifest.getSymbolicName() != null) {
0:           
0:           bundles.put(manifest.getSymbolicName(), new BundleInfo(manifest, new File(ifile.toURL().getPath())));
0:           
0:         }
0:         } catch (MalformedURLException mue) {
0:           _logger.debug("Exception thrown when processing" + ifile.getName(), mue);
0:         } catch (IOException ioe) {
0:           _logger.debug("Exception thrown when processing" + ifile.getName(), ioe);
0:         }
0:       }
0:     }
0:     return bundles;
0:   }
0: 
0:   private String getStatusText( VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr) {
0: 
0:     Version oldVersion = Version.parseVersion(oldVersionStr);
0:     Version newVersion = Version.parseVersion(newVersionStr);
0:     Version recommendedVersion = Version.parseVersion(oldVersionStr);
0:     if (status == VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
0:       recommendedVersion = new Version(oldVersion.getMajor() + 1, 0, 0);
0:     } else if (status == VERSION_CHANGE_TYPE.MINOR_CHANGE) {
0:       recommendedVersion = new Version(oldVersion.getMajor(), oldVersion.getMinor() + 1,  0);
0:     } else {
0:       recommendedVersion = oldVersion;
0:     }
0:     return " oldVersion=\"" + oldVersion 
0:     + "\" currentVersion=\"" + newVersion +
0:     "\" recommendedVersion=\"" + recommendedVersion + "\" correct=\"" + isVersionCorrect(status, oldVersionStr, newVersionStr);
0:   }
0: 
0:   private String transformForXml(String str){
0:     str = str.replaceAll("<", "&lt;");
0:     str = str.replaceAll(">", "&gt;");
0:     return str;
0:   }
0:   private boolean isVersionCorrect(VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr) {
0:     boolean versionCorrect = false;
0: 
0:     Version oldVersion = Version.parseVersion(oldVersionStr);
0:     Version newVersion = Version.parseVersion(newVersionStr);
0: 
0:     if (status == VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
0:       if (newVersion.getMajor() > oldVersion.getMajor()) {
0:         versionCorrect = true;
0:       }
0:     } else if (status == VERSION_CHANGE_TYPE.MINOR_CHANGE){
0:       if ((newVersion.getMajor() > oldVersion.getMajor()) || ( newVersion.getMinor() > oldVersion.getMinor())) {
0:         versionCorrect = true;
0:       }
0:     } else {
0:       if ((newVersion.getMajor() == oldVersion.getMajor()) && (newVersion.getMinor() == oldVersion.getMinor())) {
0:         versionCorrect = true;
0:       }
0:     }
0:     return versionCorrect;
0:   }
0: 
0:   private String getPkgStatusText(String pkgName,  VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr,  String reason, String key_class) {
0: 
0:     String modified_key_class = key_class;
0:     if (key_class.endsWith(SemanticVersioningUtils.classExt)) {
0:       modified_key_class = key_class.substring(0, key_class.lastIndexOf(SemanticVersioningUtils.classExt)) + SemanticVersioningUtils.javaExt;
0:     }
0: 
0:     return   "<package name=\"" + pkgName + "\"" +  getStatusText(status, oldVersionStr, newVersionStr) + "\" reason=\""  +transformForXml(reason) + "\" key_class=\"" + modified_key_class +  "\" change=\"" + status.text() + "\"/>";
0:   }
0: 
0:   private String getBundleStatusText(String bundleFileName, String bundleSymbolicName, VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr, String reason) {
0:     return "<bundle fileName=\"" + bundleFileName + "\" bundleSymbolicName =\"" + bundleSymbolicName + "\"" + getStatusText(status, oldVersionStr, newVersionStr) + "\" reason=\"" + transformForXml(reason) + "\" change=\"" + status.text() + "\">";
0:   }
0: 
0:   private SemanticVersioningClassVisitor getVisitor(IFile file, URLClassLoader loader ) {
0:     SemanticVersioningClassVisitor oldcv = new SemanticVersioningClassVisitor(loader);
0:     try {
0:       ClassReader cr = new ClassReader(file.open());
0:       cr.accept(oldcv, 0);
0:     } catch (IOException ioe) {
0:       _logger.debug("The file " + file + "cannot be opened.");
0:     }
0:     return oldcv; 
0:   }
0: 
0:   private Collection<URL> getListURLs(Collection<BundleInfo> bundles){
0:     Collection<URL> urls = new HashSet<URL>();
0:     try {
0:       for (BundleInfo bundle : bundles) {
0: 
0:         URL url = bundle.getBundle().toURI().toURL();
0:         urls.add(url);
0: 
0:       }
0: 
0:     } catch (MalformedURLException e) {
0:       _logger.debug(e.getMessage());
0:     }
0:     return urls;
0:   }
0: 
0:   private String getClassName(String fullClassPath) {
0:     String[] chunks = fullClassPath.split("/");
0:     String className = chunks[chunks.length - 1];
0:     className = className.replace(SemanticVersioningUtils.classExt, SemanticVersioningUtils.javaExt);
0:     return className;
0:   }
0: 
0:   private class BundleInfo {
0:     private final BundleManifest bundleManifest;
0:     private final File bundle;
0:     BundleInfo(BundleManifest bm, File bundle) {
0:       this.bundleManifest =bm;
0:       this.bundle = bundle;
0:     }
0:     public BundleManifest getBundleManifest()
0:     {
0:       return bundleManifest;
0:     }
0:     public File getBundle()
0:     {
0:       return bundle;
0:     }
0:   }
0:   enum VERSION_CHANGE_TYPE { MAJOR_CHANGE("major"), MINOR_CHANGE("minor"), NO_CHANGE("no");
0:   private final String text;
0:   VERSION_CHANGE_TYPE(String text) {
0:     this.text = text;
0:   }
0:   public String text() {
0:     return this.text;
0:   }
0: 
0:   };
0: 
0:   private class PackageContent {
0:     private final String  packageName;
0:     private final String packageVersion;
0:     private final Map<String, IFile> classes = new HashMap<String, IFile>();
0:     private final Map<String, IFile> xsds = new HashMap<String, IFile>();
0:     PackageContent(String pkgName, String pkgVersion) {
0:       packageName = pkgName;
0:       packageVersion = pkgVersion;
0:     }
0:     public void addClass(String className, IFile file) {
0:       classes.put(className, file);
0:     }
0:     public void addXsd(String className, IFile file) {
0:       xsds.put(className, file);
0:     }
0:     public Map<String, IFile> getClasses () {
0:       return classes;
0:     }
0:     public Map<String, IFile> getXsds () {
0:       return xsds;
0:     }
0: 
0:     public String getPackageVersion()
0:     {
0:       return packageVersion;
0:     }
0:     public String getPackageName() {
0:       return packageName;
0:     }
0:   }
0: 
0:   private class VersionChange {
0:     boolean change = false;
0:     String reason= null;
0:     String changeClass = null;
0:     public boolean isChange()
0:     {
0:       return change;
0:     }
0:     public void setChange(boolean change)
0:     {
0:       this.change = change;
0:     }
0:     public String getReason()
0:     {
0:       return reason;
0:     }
0:     public String getChangeClass()
0:     {
0:       return changeClass;
0:     }
0:     public void update(String reason, String changeClass) {
0:       this.change = true;
0:       this.reason = reason;
0:       this.changeClass = changeClass;
0:     }
0:   }
0: 
0: }
============================================================================