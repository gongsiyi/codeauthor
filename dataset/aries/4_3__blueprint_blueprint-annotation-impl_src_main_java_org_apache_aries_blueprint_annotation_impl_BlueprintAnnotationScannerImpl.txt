1:dd9325e: /**
1:dd9325e:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:dd9325e:  *  contributor license agreements.  See the NOTICE file distributed with
1:dd9325e:  *  this work for additional information regarding copyright ownership.
1:dd9325e:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:dd9325e:  *  (the "License"); you may not use this file except in compliance with
1:dd9325e:  *  the License.  You may obtain a copy of the License at
1:dd9325e:  *
1:dd9325e:  *     http://www.apache.org/licenses/LICENSE-2.0
1:dd9325e:  *
1:dd9325e:  *  Unless required by applicable law or agreed to in writing, software
1:dd9325e:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:dd9325e:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:dd9325e:  *  See the License for the specific language governing permissions and
1:dd9325e:  *  limitations under the License.
1:dd9325e:  */
1:dd9325e: package org.apache.aries.blueprint.annotation.impl;
12:dd9325e: 
1:dd9325e: import java.io.File;
1:dd9325e: import java.io.IOException;
1:dd9325e: import java.lang.reflect.Field;
1:dd9325e: import java.lang.reflect.Method;
1:dd9325e: import java.math.BigInteger;
1:dd9325e: import java.net.MalformedURLException;
1:dd9325e: import java.net.URL;
1:dd9325e: import java.util.Arrays;
1:15ff7ec: import java.util.HashMap;
1:069f06d: import java.util.HashSet;
1:069f06d: import java.util.LinkedHashSet;
1:dd9325e: import java.util.List;
1:15ff7ec: import java.util.Map;
1:069f06d: import java.util.Set;
1:dd9325e: 
1:dd9325e: import javax.xml.bind.JAXBContext;
1:dd9325e: import javax.xml.bind.JAXBException;
1:dd9325e: import javax.xml.bind.Marshaller;
1:dd9325e: 
1:be22f12: import org.apache.aries.blueprint.annotation.Arg;
1:dd9325e: import org.apache.aries.blueprint.annotation.Bean;
1:15ff7ec: import org.apache.aries.blueprint.annotation.Bind;
1:dd9325e: import org.apache.aries.blueprint.annotation.Blueprint;
1:dd9325e: import org.apache.aries.blueprint.annotation.Destroy;
1:dd9325e: import org.apache.aries.blueprint.annotation.Init;
1:dd9325e: import org.apache.aries.blueprint.annotation.Inject;
1:dd9325e: import org.apache.aries.blueprint.annotation.Reference;
1:dd9325e: import org.apache.aries.blueprint.annotation.ReferenceList;
1:dd9325e: import org.apache.aries.blueprint.annotation.ReferenceListener;
1:15ff7ec: import org.apache.aries.blueprint.annotation.Register;
1:dd9325e: import org.apache.aries.blueprint.annotation.RegistrationListener;
1:dd9325e: import org.apache.aries.blueprint.annotation.Service;
1:68e20e6: import org.apache.aries.blueprint.annotation.ServiceProperty;
1:15ff7ec: import org.apache.aries.blueprint.annotation.Unbind;
1:15ff7ec: import org.apache.aries.blueprint.annotation.Unregister;
1:dd9325e: import org.apache.aries.blueprint.annotation.service.BlueprintAnnotationScanner;
1:dd9325e: import org.apache.aries.blueprint.jaxb.Targument;
1:dd9325e: import org.apache.aries.blueprint.jaxb.Tbean;
1:dd9325e: import org.apache.aries.blueprint.jaxb.Tblueprint;
1:dd9325e: import org.apache.aries.blueprint.jaxb.Tdescription;
1:dd9325e: import org.apache.aries.blueprint.jaxb.Tinterfaces;
1:dd9325e: import org.apache.aries.blueprint.jaxb.Tproperty;
1:dd9325e: import org.apache.aries.blueprint.jaxb.Treference;
1:dd9325e: import org.apache.aries.blueprint.jaxb.TreferenceList;
1:dd9325e: import org.apache.aries.blueprint.jaxb.TreferenceListener;
1:dd9325e: import org.apache.aries.blueprint.jaxb.TregistrationListener;
1:dd9325e: import org.apache.aries.blueprint.jaxb.Tservice;
1:68e20e6: import org.apache.aries.blueprint.jaxb.TservicePropertyEntry;
1:dd9325e: import org.apache.aries.blueprint.jaxb.TtypeConverters;
1:dd9325e: import org.apache.aries.blueprint.jaxb.Tvalue;
1:dd9325e: import org.apache.xbean.finder.BundleAnnotationFinder;
1:dd9325e: import org.osgi.framework.Bundle;
1:dd9325e: import org.osgi.framework.BundleContext;
1:dd9325e: import org.osgi.framework.ServiceReference;
1:dd9325e: import org.osgi.service.blueprint.container.Converter;
1:dd9325e: import org.osgi.service.packageadmin.PackageAdmin;
1:dd9325e: 
1:dd9325e: public class BlueprintAnnotationScannerImpl implements
1:dd9325e:         BlueprintAnnotationScanner {
1:069f06d:     private final BundleContext context;
1:dd9325e: 
1:dd9325e:     public BlueprintAnnotationScannerImpl(BundleContext bc) {
1:dd9325e:         this.context = bc;
11:dd9325e:     }
1:dd9325e: 
1:dd9325e:     private BundleContext getBlueprintExtenderContext() {
1:dd9325e:         Bundle[] bundles = this.context.getBundles();
1:dd9325e:         for (Bundle b : bundles) {
1:dd9325e:             if (b.getSymbolicName().equals("org.apache.aries.blueprint.core")) {
1:dd9325e:                 return b.getBundleContext();
1:dd9325e:             }
1:dd9325e:         }
1:dd9325e: 
1:dd9325e:         return null;
1:dd9325e:     }
1:dd9325e: 
1:dd9325e:     private BundleAnnotationFinder createBundleAnnotationFinder(Bundle bundle) {
1:dd9325e:         ServiceReference sr = this.context.getServiceReference(PackageAdmin.class.getName());
1:dd9325e:         PackageAdmin pa = (PackageAdmin) this.context.getService(sr);
1:dd9325e:         BundleAnnotationFinder baf = null;
1:dd9325e:         try {
1:dd9325e:             baf = new BundleAnnotationFinder(pa, bundle);
1:dd9325e:         } catch (Exception e) {
1:dd9325e:             // TODO Auto-generated catch block
1:dd9325e:             e.printStackTrace();
1:dd9325e:         }
1:dd9325e: 
1:dd9325e:         this.context.ungetService(sr);
1:dd9325e:         
1:dd9325e:         return baf;
1:dd9325e:     }
1:dd9325e:     
1:dd9325e:     public URL createBlueprintModel(Bundle bundle) {
1:dd9325e: 
1:dd9325e:         Tblueprint tblueprint = generateBlueprintModel(bundle);
1:dd9325e: 
1:dd9325e:         if (tblueprint != null) {
1:dd9325e:             // create the generated blueprint xml file in bundle storage
1:dd9325e:             // area
1:dd9325e:             BundleContext ctx = getBlueprintExtenderContext();
1:dd9325e: 
1:dd9325e:             if (ctx == null) {
1:dd9325e:                 // blueprint extender doesn't exist, let' still generate the
1:dd9325e:                 // bundle, using the bundle's bundle context
1:dd9325e:                 ctx = bundle.getBundleContext();
1:dd9325e:             }
1:dd9325e: 
1:dd9325e:             File dir = ctx.getDataFile(bundle.getSymbolicName() + "/"
1:dd9325e:                     + bundle.getVersion() + "/");
1:dd9325e:             if (!dir.exists()) {
1:dd9325e:                 dir.mkdirs();
1:dd9325e:             }
1:dd9325e:             String blueprintPath = cachePath(bundle,
1:dd9325e:                     "annotation-generated-blueprint.xml");
1:dd9325e:             File file = ctx.getDataFile(blueprintPath);
1:dd9325e:             if (!file.exists()) {
1:dd9325e:                 try {
1:dd9325e:                     file.createNewFile();
1:dd9325e:                 } catch (IOException e) {
1:dd9325e:                     // TODO Auto-generated catch block
1:dd9325e:                     e.printStackTrace();
1:dd9325e:                 }
1:dd9325e:             }
1:dd9325e:             try {
1:dd9325e:                 marshallOBRModel(tblueprint, file);
1:dd9325e:             } catch (JAXBException e) {
1:dd9325e:                 // TODO Auto-generated catch block
1:dd9325e:                 e.printStackTrace();
1:dd9325e:             }
1:dd9325e:             try {
1:3f864fa:                 return file.toURI().toURL();
1:dd9325e:             } catch (MalformedURLException e) {
1:dd9325e:                 // TODO Auto-generated catch block
1:dd9325e:                 e.printStackTrace();
1:dd9325e:             }
1:dd9325e:         }
1:dd9325e: 
1:dd9325e:         return null;
1:dd9325e: 
1:dd9325e:     }
1:dd9325e: 
1:dd9325e:     private void marshallOBRModel(Tblueprint tblueprint, File blueprintFile)
1:dd9325e:             throws JAXBException {
1:dd9325e:         JAXBContext context = JAXBContext.newInstance(Tblueprint.class);
1:dd9325e:         Marshaller marshaller = context.createMarshaller();
1:dd9325e:         marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
1:dd9325e:         marshaller.marshal(tblueprint, blueprintFile);
1:dd9325e: 
1:dd9325e:     }
1:dd9325e: 
1:dd9325e:     private Tblueprint generateBlueprintModel(Bundle bundle) {
1:dd9325e:         BundleAnnotationFinder baf = createBundleAnnotationFinder(bundle);
1:dd9325e: 
1:069f06d:         // we don't trust baf when it comes to returning classes just once (ARIES-654)
1:069f06d:         Set<Class> blueprintClasses = new LinkedHashSet<Class>(baf.findAnnotatedClasses(Blueprint.class));
1:069f06d:         Set<Class> beanClasses = new HashSet<Class>(baf.findAnnotatedClasses(Bean.class));
1:069f06d:         Set<Class> refListenerClasses = new HashSet<Class>(baf.findAnnotatedClasses(ReferenceListener.class));
1:069f06d:         Set<Class> regListenerClasses = new HashSet<Class>(baf.findAnnotatedClasses(RegistrationListener.class));
1:15ff7ec:         Map<String, TreferenceListener> reflMap = new HashMap<String, TreferenceListener>();
1:15ff7ec:         Map<String, TregistrationListener> reglMap = new HashMap<String, TregistrationListener>();
1:dd9325e:         
1:dd9325e:         Tblueprint tblueprint = new Tblueprint();
1:dd9325e:         
1:dd9325e:         
1:dd9325e:         if (!blueprintClasses.isEmpty()) {
1:dd9325e:             // use the first annotated blueprint annotation
1:069f06d:             Blueprint blueprint = (Blueprint)blueprintClasses.iterator().next().getAnnotation(Blueprint.class);
1:dd9325e:             tblueprint.setDefaultActivation(blueprint.defaultActivation());
1:dd9325e:             tblueprint.setDefaultAvailability(blueprint.defaultAvailability());
1:dd9325e:             tblueprint.setDefaultTimeout(convertToBigInteger(blueprint.defaultTimeout()));
1:dd9325e:         }
1:dd9325e: 
1:dd9325e:         List<Object> components = tblueprint.getServiceOrReferenceListOrBean();
1:dd9325e:         
1:15ff7ec:         // try to process classes that have @ReferenceListener or @RegistrationLister first
1:15ff7ec:         // as we want the refl and regl maps populated before processing @Bean annotation.
1:15ff7ec:         for (Class refListener : refListenerClasses) {
1:15ff7ec:             Bean bean = (Bean) refListener.getAnnotation(Bean.class);
1:15ff7ec:                        
1:15ff7ec:             // register the treference with its id
1:15ff7ec:             TreferenceListener tref = generateTrefListener(refListener);
1:15ff7ec:             
1:15ff7ec:             if (bean.id().length() > 0) {
1:15ff7ec:                 reflMap.put(bean.id(), tref);
1:15ff7ec:             } else {
1:15ff7ec:                 throw new BlueprintAnnotationException("Unable to find the id for the @ReferenceListener annotated class " + refListener.getName());
1:15ff7ec:             }
1:15ff7ec:         }
1:15ff7ec:         
1:15ff7ec:         
1:15ff7ec:         for (Class regListener : regListenerClasses) {
1:15ff7ec:             Bean bean = (Bean) regListener.getAnnotation(Bean.class);
1:15ff7ec:             
1:15ff7ec:             // register the tregistrationListener with its id
1:15ff7ec:             TregistrationListener tref = generateTregListener(regListener);
1:15ff7ec:             
1:15ff7ec:             if (bean.id().length() > 0) {
1:15ff7ec:                 reglMap.put(bean.id(), tref);
1:15ff7ec:             } else {
1:15ff7ec:                 throw new BlueprintAnnotationException("Unable to find the id for the @RegistrationListener annotated class " + regListener.getName());
1:15ff7ec:             }   
1:15ff7ec:         }
1:15ff7ec:         
1:dd9325e:         for (Class clazz : beanClasses) {
1:dd9325e:             // @Bean annotation detected
1:dd9325e:             Bean bean = (Bean)clazz.getAnnotation(Bean.class);
1:dd9325e:             Tbean tbean = new Tbean();
1:dd9325e:             
1:dd9325e:             // process depends-on property
1:dd9325e:             String[] dependsOn = bean.dependsOn();
1:dd9325e:             if (!containsValid(dependsOn)) {
1:dd9325e:                 tbean.setDependsOn(null);
5:dd9325e:             } else {
1:dd9325e:                 List<String> dons = Arrays.asList(dependsOn);
1:dd9325e:                 tbean.setDependsOn(dons);
1:dd9325e:             }
1:dd9325e:             
1:dd9325e:             // process id property
1:dd9325e:             String id = bean.id();
1:dd9325e:             if (id.length() > 0) {
1:dd9325e:                 tbean.setId(id);
1:dd9325e:             } else {
1:dd9325e:                 // should we auto generate an id, based on the class name?
1:dd9325e:                 tbean.setId(clazz.getSimpleName());
1:dd9325e:             }
1:dd9325e: 
1:dd9325e:             // process the clazz property
1:dd9325e:             tbean.setClazz(clazz.getName());
1:dd9325e:             
1:dd9325e:             // process activation
1:dd9325e:             String activation = bean.activation();
1:dd9325e:             if (activation.length() > 0) {
1:dd9325e:                 if (activation.equalsIgnoreCase("eager") || activation.equalsIgnoreCase("lazy")) {
1:dd9325e:                     tbean.setActivation(bean.activation());
1:dd9325e:                 } else {
1:dd9325e:                     throw new BlueprintAnnotationException("Invalid bean activation value " + activation + " for " + clazz.getName());
1:dd9325e:                 }
1:dd9325e:             }
1:dd9325e:             
1:dd9325e:             // process description
1:dd9325e:             if (bean.description().length() > 0) {
1:dd9325e:                 Tdescription desp = new Tdescription();
1:dd9325e:                 desp.getContent().add(bean.description());
1:dd9325e:                 tbean.setDescription(desp);
1:dd9325e:             }
1:dd9325e:             
1:dd9325e:             // process scope
1:dd9325e:             String scope = bean.scope();
1:dd9325e:             if (scope.length() > 0) {
1:dd9325e:                 if (scope.equalsIgnoreCase("singleton") || scope.equalsIgnoreCase("prototype")) {
1:dd9325e:                     tbean.setScope(scope);
1:dd9325e:                 } else {
1:dd9325e:                     throw new BlueprintAnnotationException("Invalid bean scope value " + scope + " for " + clazz.getName());
1:dd9325e:                 }
1:dd9325e:             }
1:dd9325e:             
1:be22f12:             // process factory ref
1:be22f12:             String factoryRef = bean.factoryRef();
1:be22f12:             if (factoryRef.length() > 0) {
1:be22f12:                 tbean.setFactoryRef(factoryRef);
1:be22f12:             }
1:be22f12:             
1:be22f12:             // process factory method
1:be22f12:             String factoryMethod = bean.factoryMethod();
1:be22f12:             if (factoryMethod.length() > 0) {
1:be22f12:                 tbean.setFactoryMethod(factoryMethod);
1:be22f12:             }
1:be22f12:             
1:be22f12: 
1:dd9325e:             List<Object> props = tbean.getArgumentOrPropertyOrAny();
1:dd9325e: 
1:be22f12:             // process args 
1:be22f12:             Arg[] args = bean.args();
1:be22f12:             
1:be22f12:             if (args.length > 0) {
1:be22f12:                 for (int i = 0; i < args.length; i++) {
1:be22f12:                     Targument targ = createTargument(args[i]);
1:be22f12:                     if (targ != null) {
1:be22f12:                         props.add(targ);
1:be22f12:                     }
1:be22f12:                 }
1:be22f12:             }
1:be22f12:             
1:dd9325e:             Field[] fields = clazz.getDeclaredFields();
1:dd9325e:             for (int i = 0; i < fields.length; i++) {
1:15ff7ec:                 if (fields[i].isAnnotationPresent(Inject.class)) { 
1:15ff7ec:                     if (fields[i].isAnnotationPresent(Reference.class)) {
1:15ff7ec:                         // the field is also annotated with @Reference
1:069f06d:                         Reference ref = fields[i].getAnnotation(Reference.class);
1:15ff7ec:                         Treference tref = generateTref(ref, reflMap);
1:15ff7ec:                         components.add(tref);
1:15ff7ec:                     } else if (fields[i].isAnnotationPresent(ReferenceList.class)) {
1:15ff7ec:                         // the field is also annotated with @ReferenceList
1:069f06d:                         ReferenceList ref = fields[i].getAnnotation(ReferenceList.class);
1:15ff7ec:                         TreferenceList tref = generateTrefList(ref, reflMap);
1:15ff7ec:                         components.add(tref);
1:15ff7ec:                         
1:15ff7ec:                     } else {
1:15ff7ec:                         Tproperty tp = createTproperty(fields[i].getName(), fields[i].getAnnotation(Inject.class));
1:15ff7ec:                         props.add(tp);
1:15ff7ec:                     }
1:dd9325e:                 }
1:dd9325e:             }
1:dd9325e:                     
1:be22f12:             // check if the bean also declares init, destroy or inject annotation on methods
1:dd9325e:             Method[] methods = clazz.getDeclaredMethods();
1:dd9325e:             for (int i = 0; i < methods.length; i++) {
1:dd9325e:                 if (methods[i].isAnnotationPresent(Init.class)) {
1:dd9325e:                     tbean.setInitMethod(methods[i].getName());
1:dd9325e:                 } else if (methods[i].isAnnotationPresent(Destroy.class)) {
1:dd9325e:                     tbean.setDestroyMethod(methods[i].getName());
1:dd9325e:                 } else if (methods[i].isAnnotationPresent(Inject.class)) {
1:dd9325e:                     String propertyName = convertFromMethodName(methods[i].getName());
1:dd9325e:                     Tproperty tp = createTproperty(propertyName, methods[i].getAnnotation(Inject.class));
1:15ff7ec:                     props.add(tp);  
1:be22f12:                 } else if (methods[i].isAnnotationPresent(Arg.class)) {
1:be22f12:                     Targument targ = createTargument(methods[i].getAnnotation(Arg.class));
1:be22f12:                     props.add(targ);     
1:dd9325e:                 }
1:dd9325e:             }
1:dd9325e:             
1:dd9325e:             // check if the bean also declares service
1:dd9325e:             if (clazz.getAnnotation(Service.class) != null) {
1:15ff7ec:                 Tservice tservice = generateTservice(clazz, id, reglMap);
1:dd9325e:                 components.add(tservice);
1:dd9325e:             }
1:dd9325e:             
1:dd9325e:             // check if the clazz implement Converter, if so, it is Converter
1:dd9325e:             boolean isConverter = isConverter(clazz);
1:dd9325e:             if (isConverter) {
1:dd9325e:                 TtypeConverters converters = tblueprint.getTypeConverters(); 
1:dd9325e:                 List<Object> objects = converters.getBeanOrReferenceOrRef();
1:dd9325e:                 objects.add(tbean);
1:dd9325e:             } else {
1:dd9325e:                 components.add(tbean);
1:dd9325e:             }
1:dd9325e:         }
1:dd9325e: 
1:dd9325e:         return tblueprint;
1:dd9325e:     }
1:dd9325e: 
1:15ff7ec:     private TreferenceListener generateTrefListener(Class refListener) {
1:15ff7ec:         ReferenceListener rl = (ReferenceListener) refListener.getAnnotation(ReferenceListener.class);
1:15ff7ec:         
1:15ff7ec:         String ref = rl.ref();
1:15ff7ec:         String bind = null;
1:15ff7ec:         String unbind = null;
1:15ff7ec:         
1:15ff7ec:         // also check bind/unbind method
1:15ff7ec:         Method[] methods = refListener.getDeclaredMethods();
1:15ff7ec:         for (int i = 0; i < methods.length; i++) {
1:15ff7ec:             if (methods[i].isAnnotationPresent(Bind.class)) {
1:15ff7ec:                 if (bind == null) {
1:15ff7ec:                     bind = methods[i].getName();
1:15ff7ec:                 } else if (!bind.equals(methods[i].getName())) {
1:15ff7ec:                     throw new BlueprintAnnotationException("@Bind annottaed method for reference listener " + refListener.getName() + " are not consistent");       
1:15ff7ec:                 }
1:15ff7ec:                 continue;
1:15ff7ec:             }
1:15ff7ec:             if (methods[i].isAnnotationPresent(Unbind.class)) {
1:15ff7ec:                 if (unbind == null) {
1:15ff7ec:                   unbind = methods[i].getName();
1:15ff7ec:                 } else if (!unbind.equals(methods[i].getName())) {
1:15ff7ec:                     throw new BlueprintAnnotationException("@Unbind annotated method for reference listener " + refListener.getName() + " are not consistent");       
1:15ff7ec:                 }
1:15ff7ec:                 continue;
1:15ff7ec:             }
1:15ff7ec:         }
1:15ff7ec:         
1:15ff7ec:         TreferenceListener trl = new TreferenceListener();
1:15ff7ec:         if (bind != null) {
1:15ff7ec:             trl.setBindMethod(bind);
1:15ff7ec:         }
1:15ff7ec:         if (unbind != null) {
1:15ff7ec:             trl.setUnbindMethod(unbind);
1:15ff7ec:         }
1:15ff7ec:         
1:15ff7ec:         if (ref != null) {
1:15ff7ec:             trl.setRefAttribute(ref);
1:15ff7ec:         }
1:15ff7ec:         
1:15ff7ec:         return trl;
1:15ff7ec:     }
1:15ff7ec:     
1:15ff7ec:     private TregistrationListener generateTregListener(Class regListener) {
1:15ff7ec:         RegistrationListener rl = (RegistrationListener) regListener.getAnnotation(RegistrationListener.class);
1:15ff7ec:         
1:15ff7ec:         String register = null;
1:15ff7ec:         String unregister = null;
1:15ff7ec:         
1:15ff7ec:         // also check bind/unbind method
1:15ff7ec:         Method[] methods = regListener.getDeclaredMethods();
1:15ff7ec:         for (int i = 0; i < methods.length; i++) {
1:15ff7ec:             if (methods[i].isAnnotationPresent(Register.class)) {
1:15ff7ec:                 if (register == null) {
1:15ff7ec:                     register = methods[i].getName();
1:15ff7ec:                 } else if (!register.equals(methods[i].getName())) {
1:15ff7ec:                     throw new BlueprintAnnotationException("@Register annottaed method for registration listener " + regListener.getName() + " are not consistent");       
1:15ff7ec:                 }
1:15ff7ec:                 continue;
1:15ff7ec:             }
1:15ff7ec:             if (methods[i].isAnnotationPresent(Unregister.class)) {
1:15ff7ec:                 if (unregister == null) {
1:15ff7ec:                   unregister = methods[i].getName();
1:15ff7ec:                 } else if (!unregister.equals(methods[i].getName())) {
1:15ff7ec:                     throw new BlueprintAnnotationException("@Unregister annotated method for registration listener " + regListener.getName() + " are not consistent");       
1:15ff7ec:                 }
1:15ff7ec:                 continue;
1:15ff7ec:             }
1:15ff7ec:         }
1:15ff7ec:         
1:15ff7ec:         TregistrationListener trl = new TregistrationListener();
1:15ff7ec:         if (register != null) {
1:15ff7ec:             trl.setRegistrationMethod(register);
1:15ff7ec:         }
1:15ff7ec:         if (unregister != null) {
1:15ff7ec:             trl.setUnregistrationMethod(unregister);
1:15ff7ec:         }
1:15ff7ec:         
1:15ff7ec:         return trl;
1:15ff7ec:     }
1:15ff7ec: 
1:be22f12:     private Targument createTargument(Arg arg) {
1:be22f12:         String value = arg.value();
1:be22f12:         String ref = arg.ref();
1:be22f12:         Targument targ = null;
1:be22f12:         if (value.length() > 0) {
1:be22f12:             targ = new Targument();
1:be22f12:             targ.setValueAttribute(value);
1:be22f12:         }
1:be22f12:         
1:be22f12:         if (ref.length() > 0) {
1:be22f12:             if (targ == null) {
1:be22f12:                 targ = new Targument();
1:be22f12:             }
1:be22f12:             
1:be22f12:             targ.setRefAttribute(ref);
1:be22f12:         }
1:be22f12:         
1:be22f12:         // TODO process description, index of Arg annotation
1:be22f12:         return targ;
1:be22f12:     }
1:be22f12: 
1:dd9325e:     private String convertFromMethodName(String name) {
1:dd9325e:         if (name.length() > 3) {
1:dd9325e:             name = name.substring(3);
1:dd9325e:         } else {
1:dd9325e:             throw new BlueprintAnnotationException("The annotated method name " + name + " is invalid");
1:dd9325e:         }
1:dd9325e:         String firstChar = name.substring(0, 1).toLowerCase();
1:dd9325e:         
1:dd9325e:         if (name.length() == 1) {
1:dd9325e:             return firstChar;
1:dd9325e:         } else {
1:dd9325e:             return firstChar + name.substring(1);
1:dd9325e:         }
1:dd9325e:     }
1:dd9325e: 
1:dd9325e:     /**
1:dd9325e:      * @param nm    method or field name
1:dd9325e:      * @param inj   inject annotation
1:dd9325e:      * @return
1:dd9325e:      */
1:dd9325e:     private Tproperty createTproperty(String nm, Inject inj) {
1:dd9325e:         String value = inj.value();
1:dd9325e:         String ref = inj.ref();
1:dd9325e:         String name = inj.name();
1:dd9325e:         String desp = inj.description();
1:dd9325e:                          
1:dd9325e:         Tproperty tp = new Tproperty();
1:dd9325e:         if (value.length() > 0) {
1:dd9325e:             Tvalue tvalue = new Tvalue();
1:dd9325e:             tvalue.setContent(value);
1:dd9325e:             tp.setValue(tvalue);
1:dd9325e:         }
1:dd9325e:         
1:dd9325e:         if (ref.length() > 0) {
1:dd9325e:             tp.setRefAttribute(ref);
1:dd9325e:         }
1:dd9325e:         
1:dd9325e:         if (name.length() > 0) {
1:dd9325e:             tp.setName(name);
1:dd9325e:         } else {
1:dd9325e:             tp.setName(nm);
1:dd9325e:         }
1:dd9325e:         
1:dd9325e:         if (desp.length() > 0) {
1:dd9325e:             Tdescription tdesp = new Tdescription();
1:dd9325e:             tdesp.getContent().add(desp);
1:dd9325e:             tp.setDescription(tdesp);
1:dd9325e:             
1:dd9325e:         }
1:dd9325e:         
1:dd9325e:         return tp;
1:dd9325e:     }
1:dd9325e: 
1:dd9325e:     private boolean isConverter(Class clazz) {
1:dd9325e:         Class[] classes = clazz.getInterfaces();
1:dd9325e:         for (int i = 0; i < classes.length; i++) {
1:dd9325e:             if (classes[i].getName().equals(Converter.class.getName())) {
1:dd9325e:                 return true;
1:dd9325e:             }
1:dd9325e:         
1:dd9325e:         }
1:dd9325e:         return false;
1:dd9325e: 
1:dd9325e:     }
1:dd9325e:    
1:dd9325e:     private BigInteger convertToBigInteger(int timeout) {
1:dd9325e:         return BigInteger.valueOf(timeout * 1000);
1:dd9325e:     }
1:dd9325e: 
1:dd9325e:     private boolean containsValid(String[] dependsOn) {
1:dd9325e:         for (int i = 0; i < dependsOn.length; i++) {
1:dd9325e:             if (dependsOn[i].length() != 0) {
1:dd9325e:                 return true;
1:dd9325e:             }
1:dd9325e:         }
1:dd9325e:         return false;
1:dd9325e:     }
1:dd9325e: 
1:dd9325e:     // copy from blueprint extender
1:dd9325e:     private String cachePath(Bundle bundle, String filePath) {
1:dd9325e:         return bundle.getSymbolicName() + "/" + bundle.getVersion() + "/"
1:dd9325e:                 + filePath;
1:dd9325e:     }
1:dd9325e:     
1:15ff7ec:     private Treference generateTref(Reference ref, Map<String, TreferenceListener> reflMap) {
1:15ff7ec: 
1:dd9325e:         String id = ref.id();
1:dd9325e:         String availability = ref.availability();
1:dd9325e:         String compName = ref.componentName();
1:dd9325e:         String desp = ref.description();
1:dd9325e:         String filter = ref.filter();
1:dd9325e:         Class<?> serviceInterface = ref.serviceInterface();
1:15ff7ec:         ReferenceListener[] refListeners = ref.referenceListeners();
1:dd9325e:         int timeout = ref.timeout();
1:dd9325e:         Treference tref = new Treference();
1:dd9325e:         
1:dd9325e:         // can not think of configuring depends on for reference
1:dd9325e:         tref.setDependsOn(null);
1:dd9325e:         
1:dd9325e:         if (id.length() > 0) {
1:dd9325e:             tref.setId(id);
1:dd9325e:         }
1:dd9325e:         
1:dd9325e:         if (availability.length() > 0) {
1:dd9325e:             tref.setAvailability(availability);
1:dd9325e:         }
1:dd9325e:         if (compName.length() > 0) {
1:dd9325e:             tref.setComponentName(compName);
1:dd9325e:         }
1:dd9325e:         if (desp.length() > 0) {
1:dd9325e:             Tdescription value = new Tdescription();
1:dd9325e:             value.getContent().add(desp);
1:dd9325e:             tref.setDescription(value);
1:dd9325e:         }
1:dd9325e:         if (filter.length() > 0) {
1:dd9325e:             tref.setFilter(filter);
1:dd9325e:         }
1:dd9325e:         if (serviceInterface != Object.class) {
1:dd9325e:             tref.setInterface(serviceInterface.getName());
1:15ff7ec:         }
1:dd9325e:         
1:dd9325e:         if (timeout > 0) {
1:dd9325e:             tref.setTimeout(convertToBigInteger(timeout));
1:dd9325e:         }
1:dd9325e:         for (ReferenceListener rl : refListeners) {
1:dd9325e:             String rf = rl.ref();
1:15ff7ec:             TreferenceListener trl = reflMap.get(rf);
1:15ff7ec:             if (trl != null) {
1:15ff7ec:                 trl.setRefAttribute(rf);
1:15ff7ec:                 tref.getReferenceListener().add(trl);
1:15ff7ec:             } else {
1:15ff7ec:                 throw new BlueprintAnnotationException("Unable to find the ReferenceListener ref " + rf);
1:15ff7ec:             }
1:dd9325e:         }
1:dd9325e:         
1:dd9325e:         return tref;
1:dd9325e:     }
1:dd9325e:     
1:15ff7ec:     private TreferenceList generateTrefList(ReferenceList ref, Map<String, TreferenceListener> reflMap) {
1:dd9325e:         String id = ref.id();
1:dd9325e:         String availability = ref.availability();
1:dd9325e:         String compName = ref.componentName();
1:dd9325e:         String desp = ref.description();
1:dd9325e:         String filter = ref.filter();
1:dd9325e:         Class<?> serviceInterface = ref.serviceInterface();
1:15ff7ec:         ReferenceListener[] refListeners = ref.referenceListeners();
1:dd9325e:         TreferenceList tref = new TreferenceList();
1:dd9325e:         
1:dd9325e:         // can not think of configuring depends on for referencelist
1:dd9325e:         tref.setDependsOn(null);
1:dd9325e:         
1:dd9325e:         if (id.length() > 0) {
1:dd9325e:             tref.setId(id);
1:dd9325e:         }
1:dd9325e:         
1:dd9325e:         if (availability.length() > 0) {
1:dd9325e:             tref.setAvailability(availability);
1:dd9325e:         }
1:dd9325e:         if (compName.length() > 0) {
1:dd9325e:             tref.setComponentName(compName);
1:dd9325e:         }
1:dd9325e:         if (desp.length() > 0) {
1:dd9325e:             Tdescription value = new Tdescription();
1:dd9325e:             value.getContent().add(desp);
1:dd9325e:             tref.setDescription(value);
1:dd9325e:         }
1:dd9325e:         if (filter.length() > 0) {
1:dd9325e:             tref.setFilter(filter);
1:dd9325e:         }
1:dd9325e:         if (serviceInterface  != Object.class) {
1:dd9325e:             tref.setInterface(serviceInterface.getName());
1:15ff7ec:         } 
1:15ff7ec:         
1:dd9325e:         for (ReferenceListener rl : refListeners) {
1:dd9325e:             String rf = rl.ref();
1:15ff7ec:             TreferenceListener trl = reflMap.get(rf);
1:15ff7ec:             if (trl != null) {
1:15ff7ec:                 trl.setRefAttribute(rf);
1:15ff7ec:                 tref.getReferenceListener().add(trl);
1:15ff7ec:             } else {
1:15ff7ec:                 throw new BlueprintAnnotationException("Unable to find the ReferenceListener ref " + rf);
1:dd9325e:             }
1:dd9325e:         }
1:dd9325e:         
1:dd9325e:         return tref;
1:dd9325e:     }
1:dd9325e:     
1:15ff7ec:     private Tservice generateTservice(Class clazz, String id, Map<String, TregistrationListener> reglMap) {
1:dd9325e:         Service service = (Service) clazz.getAnnotation(Service.class);
1:dd9325e:         Class<?>[] interfaces = service.interfaces();
1:dd9325e:         int ranking = service.ranking();
1:dd9325e:         String autoExport = service.autoExport();
1:68e20e6:         ServiceProperty[] serviceProperties = service.serviceProperties();
1:15ff7ec:         RegistrationListener[] regListeners = service.registerationListeners();
1:dd9325e:         
1:dd9325e:         Tservice tservice = new Tservice();
1:dd9325e:         
1:dd9325e:         // can not think of configuring depends on for service
1:dd9325e:         tservice.setDependsOn(null);
1:dd9325e:         
1:dd9325e:         // use the bean id as the ref value since we are exposing service for the bean
1:dd9325e:         tservice.setRefAttribute(id);
1:dd9325e:         
1:dd9325e:         if (autoExport.length() > 0) {
1:dd9325e:             tservice.setAutoExport(autoExport);
1:dd9325e:         }
1:dd9325e:         if (ranking > 0) {
1:dd9325e:             tservice.setRanking(ranking);
1:dd9325e:         }
1:dd9325e:         for (Class<?> interf : interfaces) {
1:dd9325e:             Tinterfaces tInterfaces = new Tinterfaces();
1:dd9325e:             if (interf != null) {
1:dd9325e:                 tInterfaces.getValue().add(interf.getName());
1:dd9325e:             }
1:dd9325e:             tservice.setInterfaces(tInterfaces);
1:dd9325e:         }
1:dd9325e:         
1:68e20e6:         // process service property.  only key value as string are supported for now
1:68e20e6:         for (ServiceProperty sp : serviceProperties) {
1:68e20e6:             if (sp != null) {
1:68e20e6:                 String key = sp.key();
1:68e20e6:                 String value = sp.value();
1:68e20e6:                 if (key.length() > 0 && value.length() > 0) {
1:68e20e6:                     TservicePropertyEntry tsp = new TservicePropertyEntry();
1:68e20e6:                     tsp.setKey(key);
1:68e20e6:                     tsp.setValueAttribute(value);
1:68e20e6:                     tservice.getServiceProperties().getEntry().add(tsp);
1:68e20e6:                 }
1:68e20e6:                 
1:68e20e6:             }
1:68e20e6:         }
1:68e20e6:         
1:dd9325e:         for (RegistrationListener regListener : regListeners) {
1:15ff7ec:             String ref = regListener.ref();
1:15ff7ec:             if (ref.length() > 0) {
1:15ff7ec:                 TregistrationListener tregListener = reglMap.get(ref);
1:15ff7ec:                 tregListener.setRefAttribute(ref);
1:dd9325e:                 tservice.getRegistrationListener().add(tregListener);
1:dd9325e:                 
1:dd9325e:             } else {
1:dd9325e:                 throw new BlueprintAnnotationException("No ref id for service registration listener " + " for " + clazz.getName());
1:dd9325e:             }
1:dd9325e:         }
1:dd9325e:         
1:dd9325e:         return tservice;
1:dd9325e:     }
1:dd9325e: }
============================================================================
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:3f864fa
/////////////////////////////////////////////////////////////////////////
1:                 return file.toURI().toURL();
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:069f06d
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.LinkedHashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final BundleContext context;
/////////////////////////////////////////////////////////////////////////
1:         // we don't trust baf when it comes to returning classes just once (ARIES-654)
1:         Set<Class> blueprintClasses = new LinkedHashSet<Class>(baf.findAnnotatedClasses(Blueprint.class));
1:         Set<Class> beanClasses = new HashSet<Class>(baf.findAnnotatedClasses(Bean.class));
1:         Set<Class> refListenerClasses = new HashSet<Class>(baf.findAnnotatedClasses(ReferenceListener.class));
1:         Set<Class> regListenerClasses = new HashSet<Class>(baf.findAnnotatedClasses(RegistrationListener.class));
/////////////////////////////////////////////////////////////////////////
1:             Blueprint blueprint = (Blueprint)blueprintClasses.iterator().next().getAnnotation(Blueprint.class);
/////////////////////////////////////////////////////////////////////////
1:                         Reference ref = fields[i].getAnnotation(Reference.class);
1:                         ReferenceList ref = fields[i].getAnnotation(ReferenceList.class);
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:caaf291
/////////////////////////////////////////////////////////////////////////
author:Lin Sun
-------------------------------------------------------------------------------
commit:68e20e6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.annotation.ServiceProperty;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.jaxb.TserviceProperties;
1: import org.apache.aries.blueprint.jaxb.TservicePropertyEntry;
/////////////////////////////////////////////////////////////////////////
1:         ServiceProperty[] serviceProperties = service.serviceProperties();
/////////////////////////////////////////////////////////////////////////
1:         // process service property.  only key value as string are supported for now
1:         for (ServiceProperty sp : serviceProperties) {
1:             if (sp != null) {
1:                 String key = sp.key();
1:                 String value = sp.value();
1:                 if (key.length() > 0 && value.length() > 0) {
1:                     TservicePropertyEntry tsp = new TservicePropertyEntry();
1:                     tsp.setKey(key);
1:                     tsp.setValueAttribute(value);
1:                     tservice.getServiceProperties().getEntry().add(tsp);
1:                 }
1:                 
1:             }
1:         }
1:         
commit:15ff7ec
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.annotation.Bind;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.annotation.Register;
1: import org.apache.aries.blueprint.annotation.Unbind;
1: import org.apache.aries.blueprint.annotation.Unregister;
/////////////////////////////////////////////////////////////////////////
0:         List<Class> refListenerClasses = baf.findAnnotatedClasses(ReferenceListener.class);
0:         List<Class> regListenerClasses = baf.findAnnotatedClasses(RegistrationListener.class);
1:         Map<String, TreferenceListener> reflMap = new HashMap<String, TreferenceListener>();
1:         Map<String, TregistrationListener> reglMap = new HashMap<String, TregistrationListener>();
/////////////////////////////////////////////////////////////////////////
1:         // try to process classes that have @ReferenceListener or @RegistrationLister first
1:         // as we want the refl and regl maps populated before processing @Bean annotation.
1:         for (Class refListener : refListenerClasses) {
1:             Bean bean = (Bean) refListener.getAnnotation(Bean.class);
1:                        
1:             // register the treference with its id
1:             TreferenceListener tref = generateTrefListener(refListener);
1:             
1:             if (bean.id().length() > 0) {
1:                 reflMap.put(bean.id(), tref);
1:             } else {
1:                 throw new BlueprintAnnotationException("Unable to find the id for the @ReferenceListener annotated class " + refListener.getName());
1:             }
1:         }
1:         
1:         
1:         for (Class regListener : regListenerClasses) {
1:             Bean bean = (Bean) regListener.getAnnotation(Bean.class);
1:             
1:             // register the tregistrationListener with its id
1:             TregistrationListener tref = generateTregListener(regListener);
1:             
1:             if (bean.id().length() > 0) {
1:                 reglMap.put(bean.id(), tref);
1:             } else {
1:                 throw new BlueprintAnnotationException("Unable to find the id for the @RegistrationListener annotated class " + regListener.getName());
1:             }   
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:                 if (fields[i].isAnnotationPresent(Inject.class)) { 
1:                     if (fields[i].isAnnotationPresent(Reference.class)) {
1:                         // the field is also annotated with @Reference
0:                         Reference ref = (Reference)fields[i].getAnnotation(Reference.class);
1:                         Treference tref = generateTref(ref, reflMap);
1:                         components.add(tref);
1:                     } else if (fields[i].isAnnotationPresent(ReferenceList.class)) {
1:                         // the field is also annotated with @ReferenceList
0:                         ReferenceList ref = (ReferenceList)fields[i].getAnnotation(ReferenceList.class);
1:                         TreferenceList tref = generateTrefList(ref, reflMap);
1:                         components.add(tref);
1:                         
1:                     } else {
1:                         Tproperty tp = createTproperty(fields[i].getName(), fields[i].getAnnotation(Inject.class));
1:                         props.add(tp);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                     props.add(tp);  
/////////////////////////////////////////////////////////////////////////
1:                 Tservice tservice = generateTservice(clazz, id, reglMap);
/////////////////////////////////////////////////////////////////////////
1:     private TreferenceListener generateTrefListener(Class refListener) {
1:         ReferenceListener rl = (ReferenceListener) refListener.getAnnotation(ReferenceListener.class);
1:         
1:         String ref = rl.ref();
1:         String bind = null;
1:         String unbind = null;
1:         
1:         // also check bind/unbind method
1:         Method[] methods = refListener.getDeclaredMethods();
1:         for (int i = 0; i < methods.length; i++) {
1:             if (methods[i].isAnnotationPresent(Bind.class)) {
1:                 if (bind == null) {
1:                     bind = methods[i].getName();
1:                 } else if (!bind.equals(methods[i].getName())) {
1:                     throw new BlueprintAnnotationException("@Bind annottaed method for reference listener " + refListener.getName() + " are not consistent");       
1:                 }
1:                 continue;
1:             }
1:             if (methods[i].isAnnotationPresent(Unbind.class)) {
1:                 if (unbind == null) {
1:                   unbind = methods[i].getName();
1:                 } else if (!unbind.equals(methods[i].getName())) {
1:                     throw new BlueprintAnnotationException("@Unbind annotated method for reference listener " + refListener.getName() + " are not consistent");       
1:                 }
1:                 continue;
1:             }
1:         }
1:         
1:         TreferenceListener trl = new TreferenceListener();
1:         if (bind != null) {
1:             trl.setBindMethod(bind);
1:         }
1:         if (unbind != null) {
1:             trl.setUnbindMethod(unbind);
1:         }
1:         
1:         if (ref != null) {
1:             trl.setRefAttribute(ref);
1:         }
1:         
1:         return trl;
1:     }
1:     
1:     private TregistrationListener generateTregListener(Class regListener) {
1:         RegistrationListener rl = (RegistrationListener) regListener.getAnnotation(RegistrationListener.class);
1:         
1:         String register = null;
1:         String unregister = null;
1:         
1:         // also check bind/unbind method
1:         Method[] methods = regListener.getDeclaredMethods();
1:         for (int i = 0; i < methods.length; i++) {
1:             if (methods[i].isAnnotationPresent(Register.class)) {
1:                 if (register == null) {
1:                     register = methods[i].getName();
1:                 } else if (!register.equals(methods[i].getName())) {
1:                     throw new BlueprintAnnotationException("@Register annottaed method for registration listener " + regListener.getName() + " are not consistent");       
1:                 }
1:                 continue;
1:             }
1:             if (methods[i].isAnnotationPresent(Unregister.class)) {
1:                 if (unregister == null) {
1:                   unregister = methods[i].getName();
1:                 } else if (!unregister.equals(methods[i].getName())) {
1:                     throw new BlueprintAnnotationException("@Unregister annotated method for registration listener " + regListener.getName() + " are not consistent");       
1:                 }
1:                 continue;
1:             }
1:         }
1:         
1:         TregistrationListener trl = new TregistrationListener();
1:         if (register != null) {
1:             trl.setRegistrationMethod(register);
1:         }
1:         if (unregister != null) {
1:             trl.setUnregistrationMethod(unregister);
1:         }
1:         
1:         return trl;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private Treference generateTref(Reference ref, Map<String, TreferenceListener> reflMap) {
1: 
1:         ReferenceListener[] refListeners = ref.referenceListeners();
/////////////////////////////////////////////////////////////////////////
1:             TreferenceListener trl = reflMap.get(rf);
1:             if (trl != null) {
1:                 trl.setRefAttribute(rf);
1:                 tref.getReferenceListener().add(trl);
1:             } else {
1:                 throw new BlueprintAnnotationException("Unable to find the ReferenceListener ref " + rf);
1:             }
1:     private TreferenceList generateTrefList(ReferenceList ref, Map<String, TreferenceListener> reflMap) {
1:         ReferenceListener[] refListeners = ref.referenceListeners();
/////////////////////////////////////////////////////////////////////////
1:         } 
1:         
1:             TreferenceListener trl = reflMap.get(rf);
1:             if (trl != null) {
1:                 trl.setRefAttribute(rf);
1:                 tref.getReferenceListener().add(trl);
1:             } else {
1:                 throw new BlueprintAnnotationException("Unable to find the ReferenceListener ref " + rf);
1:             }
1:     private Tservice generateTservice(Class clazz, String id, Map<String, TregistrationListener> reglMap) {
1:         RegistrationListener[] regListeners = service.registerationListeners();
/////////////////////////////////////////////////////////////////////////
1:             String ref = regListener.ref();
1:             if (ref.length() > 0) {
1:                 TregistrationListener tregListener = reglMap.get(ref);
1:                 tregListener.setRefAttribute(ref);
commit:be22f12
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.annotation.Arg;
/////////////////////////////////////////////////////////////////////////
1:             // process factory ref
1:             String factoryRef = bean.factoryRef();
1:             if (factoryRef.length() > 0) {
1:                 tbean.setFactoryRef(factoryRef);
1:             }
1:             
1:             // process factory method
1:             String factoryMethod = bean.factoryMethod();
1:             if (factoryMethod.length() > 0) {
1:                 tbean.setFactoryMethod(factoryMethod);
1:             }
1:             
1: 
1:             // process args 
1:             Arg[] args = bean.args();
1:             
1:             if (args.length > 0) {
1:                 for (int i = 0; i < args.length; i++) {
1:                     Targument targ = createTargument(args[i]);
1:                     if (targ != null) {
1:                         props.add(targ);
1:                     }
1:                 }
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
1:             // check if the bean also declares init, destroy or inject annotation on methods
/////////////////////////////////////////////////////////////////////////
0:                     props.add(tp);     
1:                 } else if (methods[i].isAnnotationPresent(Arg.class)) {
1:                     Targument targ = createTargument(methods[i].getAnnotation(Arg.class));
1:                     props.add(targ);     
/////////////////////////////////////////////////////////////////////////
1:     private Targument createTargument(Arg arg) {
1:         String value = arg.value();
1:         String ref = arg.ref();
1:         Targument targ = null;
1:         if (value.length() > 0) {
1:             targ = new Targument();
1:             targ.setValueAttribute(value);
1:         }
1:         
1:         if (ref.length() > 0) {
1:             if (targ == null) {
1:                 targ = new Targument();
1:             }
1:             
1:             targ.setRefAttribute(ref);
1:         }
1:         
1:         // TODO process description, index of Arg annotation
1:         return targ;
1:     }
1: 
commit:dd9325e
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
1: package org.apache.aries.blueprint.annotation.impl;
1: 
1: import java.io.File;
1: import java.io.IOException;
0: import java.lang.reflect.Constructor;
1: import java.lang.reflect.Field;
1: import java.lang.reflect.Method;
1: import java.math.BigInteger;
1: import java.net.MalformedURLException;
1: import java.net.URL;
1: import java.util.Arrays;
1: import java.util.List;
1: 
1: import javax.xml.bind.JAXBContext;
1: import javax.xml.bind.JAXBException;
1: import javax.xml.bind.Marshaller;
1: 
1: import org.apache.aries.blueprint.annotation.Bean;
1: import org.apache.aries.blueprint.annotation.Blueprint;
1: import org.apache.aries.blueprint.annotation.Destroy;
0: import org.apache.aries.blueprint.annotation.FactoryMethod;
1: import org.apache.aries.blueprint.annotation.Init;
1: import org.apache.aries.blueprint.annotation.Inject;
1: import org.apache.aries.blueprint.annotation.Reference;
1: import org.apache.aries.blueprint.annotation.ReferenceList;
1: import org.apache.aries.blueprint.annotation.ReferenceListener;
1: import org.apache.aries.blueprint.annotation.RegistrationListener;
1: import org.apache.aries.blueprint.annotation.Service;
1: import org.apache.aries.blueprint.annotation.service.BlueprintAnnotationScanner;
1: import org.apache.aries.blueprint.jaxb.Targument;
1: import org.apache.aries.blueprint.jaxb.Tbean;
1: import org.apache.aries.blueprint.jaxb.Tblueprint;
1: import org.apache.aries.blueprint.jaxb.Tdescription;
1: import org.apache.aries.blueprint.jaxb.Tinterfaces;
1: import org.apache.aries.blueprint.jaxb.Tproperty;
1: import org.apache.aries.blueprint.jaxb.Treference;
1: import org.apache.aries.blueprint.jaxb.TreferenceList;
1: import org.apache.aries.blueprint.jaxb.TreferenceListener;
1: import org.apache.aries.blueprint.jaxb.TregistrationListener;
1: import org.apache.aries.blueprint.jaxb.Tservice;
1: import org.apache.aries.blueprint.jaxb.TtypeConverters;
1: import org.apache.aries.blueprint.jaxb.Tvalue;
1: import org.apache.xbean.finder.BundleAnnotationFinder;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.service.blueprint.container.Converter;
1: import org.osgi.service.packageadmin.PackageAdmin;
1: 
1: public class BlueprintAnnotationScannerImpl implements
1:         BlueprintAnnotationScanner {
0:     private BundleContext context;
1: 
1:     public BlueprintAnnotationScannerImpl(BundleContext bc) {
1:         this.context = bc;
1:     }
1: 
1:     private BundleContext getBlueprintExtenderContext() {
1:         Bundle[] bundles = this.context.getBundles();
1:         for (Bundle b : bundles) {
1:             if (b.getSymbolicName().equals("org.apache.aries.blueprint.core")) {
1:                 return b.getBundleContext();
1:             }
1:         }
1: 
1:         return null;
1:     }
1: 
1:     private BundleAnnotationFinder createBundleAnnotationFinder(Bundle bundle) {
1:         ServiceReference sr = this.context.getServiceReference(PackageAdmin.class.getName());
1:         PackageAdmin pa = (PackageAdmin) this.context.getService(sr);
1:         BundleAnnotationFinder baf = null;
1:         try {
1:             baf = new BundleAnnotationFinder(pa, bundle);
1:         } catch (Exception e) {
1:             // TODO Auto-generated catch block
1:             e.printStackTrace();
1:         }
1: 
1:         this.context.ungetService(sr);
1:         
1:         return baf;
1:     }
1:     
1:     public URL createBlueprintModel(Bundle bundle) {
1: 
1:         Tblueprint tblueprint = generateBlueprintModel(bundle);
1: 
1:         if (tblueprint != null) {
1:             // create the generated blueprint xml file in bundle storage
1:             // area
1:             BundleContext ctx = getBlueprintExtenderContext();
1: 
1:             if (ctx == null) {
1:                 // blueprint extender doesn't exist, let' still generate the
1:                 // bundle, using the bundle's bundle context
1:                 ctx = bundle.getBundleContext();
1:             }
1: 
1:             File dir = ctx.getDataFile(bundle.getSymbolicName() + "/"
1:                     + bundle.getVersion() + "/");
1:             if (!dir.exists()) {
1:                 dir.mkdirs();
1:             }
1:             String blueprintPath = cachePath(bundle,
1:                     "annotation-generated-blueprint.xml");
1:             File file = ctx.getDataFile(blueprintPath);
1:             if (!file.exists()) {
1:                 try {
1:                     file.createNewFile();
1:                 } catch (IOException e) {
1:                     // TODO Auto-generated catch block
1:                     e.printStackTrace();
1:                 }
1:             }
1:             try {
1:                 marshallOBRModel(tblueprint, file);
1:             } catch (JAXBException e) {
1:                 // TODO Auto-generated catch block
1:                 e.printStackTrace();
1:             }
1:             
0:             System.out.println("generated annotation xml is located " + file.getAbsolutePath());
1:             try {
0:                 return file.toURL();
1:             } catch (MalformedURLException e) {
1:                 // TODO Auto-generated catch block
1:                 e.printStackTrace();
1:             }
1:         }
1: 
1:         return null;
1: 
1:     }
1: 
1:     private void marshallOBRModel(Tblueprint tblueprint, File blueprintFile)
1:             throws JAXBException {
1:         JAXBContext context = JAXBContext.newInstance(Tblueprint.class);
1:         Marshaller marshaller = context.createMarshaller();
1:         marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
1:         marshaller.marshal(tblueprint, blueprintFile);
1: 
1:     }
1: 
1:     private Tblueprint generateBlueprintModel(Bundle bundle) {
1:         BundleAnnotationFinder baf = createBundleAnnotationFinder(bundle);
1: 
0:         List<Class> blueprintClasses = baf.findAnnotatedClasses(Blueprint.class);
0:         List<Class> beanClasses = baf.findAnnotatedClasses(Bean.class);
0:         List<Class> refClasses = baf.findAnnotatedClasses(Reference.class);
0:         List<Class> refListClasses = baf.findAnnotatedClasses(ReferenceList.class);
1:         
1:         Tblueprint tblueprint = new Tblueprint();
1:         
1:         
1:         if (!blueprintClasses.isEmpty()) {
1:             // use the first annotated blueprint annotation
0:             Blueprint blueprint = (Blueprint)blueprintClasses.get(0).getAnnotation(Blueprint.class);
1:             tblueprint.setDefaultActivation(blueprint.defaultActivation());
1:             tblueprint.setDefaultAvailability(blueprint.defaultAvailability());
1:             tblueprint.setDefaultTimeout(convertToBigInteger(blueprint.defaultTimeout()));
1:         }
1: 
1:         List<Object> components = tblueprint.getServiceOrReferenceListOrBean();
1:         
1:         for (Class clazz : beanClasses) {
1:             // @Bean annotation detected
1:             Bean bean = (Bean)clazz.getAnnotation(Bean.class);
1:             Tbean tbean = new Tbean();
1:             
1:             // process depends-on property
1:             String[] dependsOn = bean.dependsOn();
1:             if (!containsValid(dependsOn)) {
1:                 tbean.setDependsOn(null);
1:             } else {
1:                 List<String> dons = Arrays.asList(dependsOn);
1:                 tbean.setDependsOn(dons);
1:             }
1:             
1:             // process id property
1:             String id = bean.id();
1:             if (id.length() > 0) {
1:                 tbean.setId(id);
1:             } else {
1:                 // should we auto generate an id, based on the class name?
1:                 tbean.setId(clazz.getSimpleName());
1:             }
1: 
1:             // process the clazz property
1:             tbean.setClazz(clazz.getName());
1:             
1:             // process activation
1:             String activation = bean.activation();
1:             if (activation.length() > 0) {
1:                 if (activation.equalsIgnoreCase("eager") || activation.equalsIgnoreCase("lazy")) {
1:                     tbean.setActivation(bean.activation());
1:                 } else {
1:                     throw new BlueprintAnnotationException("Invalid bean activation value " + activation + " for " + clazz.getName());
1:                 }
1:             }
1:             
1:             // process description
1:             if (bean.description().length() > 0) {
1:                 Tdescription desp = new Tdescription();
1:                 desp.getContent().add(bean.description());
1:                 tbean.setDescription(desp);
1:             }
1:             
1:             // process scope
1:             String scope = bean.scope();
1:             if (scope.length() > 0) {
1:                 if (scope.equalsIgnoreCase("singleton") || scope.equalsIgnoreCase("prototype")) {
1:                     tbean.setScope(scope);
1:                 } else {
1:                     throw new BlueprintAnnotationException("Invalid bean scope value " + scope + " for " + clazz.getName());
1:                 }
1:             }
1:             
1:             List<Object> props = tbean.getArgumentOrPropertyOrAny();
1: 
1:             Field[] fields = clazz.getDeclaredFields();
1:             for (int i = 0; i < fields.length; i++) {
0:                 if (fields[i].isAnnotationPresent(Inject.class)) {          
0:                     Tproperty tp = createTproperty(fields[i].getName(), fields[i].getAnnotation(Inject.class));
0:                     props.add(tp);
1:                 }
1:             }
1:                     
0:             // check if the bean also declares init, destroy or inject or factoryMethod annotation on methods
1:             Method[] methods = clazz.getDeclaredMethods();
1:             for (int i = 0; i < methods.length; i++) {
1:                 if (methods[i].isAnnotationPresent(Init.class)) {
1:                     tbean.setInitMethod(methods[i].getName());
1:                 } else if (methods[i].isAnnotationPresent(Destroy.class)) {
1:                     tbean.setDestroyMethod(methods[i].getName());
1:                 } else if (methods[i].isAnnotationPresent(Inject.class)) {
1:                     String propertyName = convertFromMethodName(methods[i].getName());
1:                     Tproperty tp = createTproperty(propertyName, methods[i].getAnnotation(Inject.class));
0:                     props.add(tp);
0:                 } else if (methods[i].isAnnotationPresent(FactoryMethod.class)) {
0:                     FactoryMethod fm = (FactoryMethod)methods[i].getAnnotation(FactoryMethod.class);
0:                     tbean.setFactoryMethod(methods[i].getName());
0:                     String[] values = fm.values();
0:                     for (int j = 0; j < fm.values().length; j++) {
0:                         Targument targument = new Targument();
0:                         targument.setValueAttribute(fm.values()[j]);
0:                         props.add(targument);
1:                     }
1:                     
1:                     
1:                     
1:                 }
1:                 
1:             }
1:             
0:             // check if the bean also declared inject annotation on constructors
0:             Constructor[] constructors = clazz.getConstructors();
0:             for (int i = 0; i < constructors.length; i++) {
0:                 if (constructors[i].isAnnotationPresent(Inject.class)) {
0:                     Inject inj = (Inject)constructors[i].getAnnotation(Inject.class);
1:                     
0:                     if (inj.value().length() > 0) {
0:                         Targument targument = new Targument();
0:                         targument.setValueAttribute(inj.value());
0:                         props.add(targument);
0:                     } else if (inj.values().length > 0) {
0:                         for (int j = 0; j < inj.values().length; j++) {
0:                             Targument targument = new Targument();
0:                             targument.setValueAttribute(inj.values()[j]);
0:                             props.add(targument);
1:                         }
1:                     }
1:                 } 
1:             }
1:             
1:             // check if the bean also declares service
1:             if (clazz.getAnnotation(Service.class) != null) {
0:                 Tservice tservice = generateTservice(clazz, id);
1:                 components.add(tservice);
1:             }
1:             
1:             // check if the clazz implement Converter, if so, it is Converter
1:             boolean isConverter = isConverter(clazz);
1:             if (isConverter) {
1:                 TtypeConverters converters = tblueprint.getTypeConverters(); 
1:                 List<Object> objects = converters.getBeanOrReferenceOrRef();
1:                 objects.add(tbean);
1:             } else {
1:                 components.add(tbean);
1:             }
1:         }
1:         
0:         for (Class refClass : refClasses) {
0:             Treference tref = generateTref(refClass);
0:             components.add(tref);
1:         }
1: 
0:         for (Class refListClass : refListClasses) {
0:             TreferenceList trefList = generateTrefList(refListClass);
0:             components.add(trefList);
1:         }
1: 
1:         return tblueprint;
1:     }
1: 
1:     private String convertFromMethodName(String name) {
1:         if (name.length() > 3) {
1:             name = name.substring(3);
1:         } else {
1:             throw new BlueprintAnnotationException("The annotated method name " + name + " is invalid");
1:         }
1:         String firstChar = name.substring(0, 1).toLowerCase();
1:         
1:         if (name.length() == 1) {
1:             return firstChar;
1:         } else {
1:             return firstChar + name.substring(1);
1:         }
1:     }
1: 
1:     /**
1:      * @param nm    method or field name
1:      * @param inj   inject annotation
1:      * @return
1:      */
1:     private Tproperty createTproperty(String nm, Inject inj) {
1:         String value = inj.value();
1:         String ref = inj.ref();
1:         String name = inj.name();
1:         String desp = inj.description();
1:                          
1:         Tproperty tp = new Tproperty();
1:         if (value.length() > 0) {
1:             Tvalue tvalue = new Tvalue();
1:             tvalue.setContent(value);
1:             tp.setValue(tvalue);
1:         }
1:         
1:         if (ref.length() > 0) {
1:             tp.setRefAttribute(ref);
1:         }
1:         
1:         if (name.length() > 0) {
1:             tp.setName(name);
1:         } else {
1:             tp.setName(nm);
1:         }
1:         
1:         if (desp.length() > 0) {
1:             Tdescription tdesp = new Tdescription();
1:             tdesp.getContent().add(desp);
1:             tp.setDescription(tdesp);
1:             
1:         }
1:         
1:         return tp;
1:     }
1: 
1:     private boolean isConverter(Class clazz) {
1:         Class[] classes = clazz.getInterfaces();
1:         for (int i = 0; i < classes.length; i++) {
1:             if (classes[i].getName().equals(Converter.class.getName())) {
1:                 return true;
1:             }
1:         
1:         }
1:         return false;
1: 
1:     }
1:    
1:     private BigInteger convertToBigInteger(int timeout) {
1:         return BigInteger.valueOf(timeout * 1000);
1:     }
1: 
1:     private boolean containsValid(String[] dependsOn) {
1:         for (int i = 0; i < dependsOn.length; i++) {
1:             if (dependsOn[i].length() != 0) {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     // copy from blueprint extender
1:     private String cachePath(Bundle bundle, String filePath) {
1:         return bundle.getSymbolicName() + "/" + bundle.getVersion() + "/"
1:                 + filePath;
1:     }
1:     
0:     private Treference generateTref(Class refClass) {
0:         // @Reference annotation detected
0:         Reference ref = (Reference)refClass.getAnnotation(Reference.class);
1:         
1:         String id = ref.id();
1:         String availability = ref.availability();
1:         String compName = ref.componentName();
1:         String desp = ref.description();
1:         String filter = ref.filter();
1:         Class<?> serviceInterface = ref.serviceInterface();
0:         ReferenceListener[] refListeners = ref.referenceListener();
1:         int timeout = ref.timeout();
1:         Treference tref = new Treference();
1:         
1:         // can not think of configuring depends on for reference
1:         tref.setDependsOn(null);
1:         
1:         if (id.length() > 0) {
1:             tref.setId(id);
1:         }
1:         
1:         if (availability.length() > 0) {
1:             tref.setAvailability(availability);
1:         }
1:         if (compName.length() > 0) {
1:             tref.setComponentName(compName);
1:         }
1:         if (desp.length() > 0) {
1:             Tdescription value = new Tdescription();
1:             value.getContent().add(desp);
1:             tref.setDescription(value);
1:         }
1:         if (filter.length() > 0) {
1:             tref.setFilter(filter);
1:         }
1:         if (serviceInterface != Object.class) {
1:             tref.setInterface(serviceInterface.getName());
1:         } else {
0:             boolean isInterface =  refClass.isInterface();
0:             if (isInterface) {
0:                 tref.setInterface(refClass.getName());
1:             } else {
0:                 // should we throw an exception?  
1:             }
1:         }
1:         
1:         if (timeout > 0) {
1:             tref.setTimeout(convertToBigInteger(timeout));
1:         }
1:         for (ReferenceListener rl : refListeners) {
0:             TreferenceListener trl = new TreferenceListener();
1:             String rf = rl.ref();
0:             String bindMethod = rl.bind();
0:             String unbindMethod = rl.unbind();
0:             trl.setRefAttribute(rf);
0:             trl.setBindMethod(bindMethod);
0:             trl.setUnbindMethod(unbindMethod);
0:             tref.getReferenceListener().add(trl);
1:         }
1:         
1:         return tref;
1:     }
1:     
0:     private TreferenceList generateTrefList(Class refClass) {
0:         // @ReferenceList annotation detected
0:         ReferenceList ref = (ReferenceList)refClass.getAnnotation(ReferenceList.class);
1:         
1:         String id = ref.id();
1:         String availability = ref.availability();
1:         String compName = ref.componentName();
1:         String desp = ref.description();
1:         String filter = ref.filter();
1:         Class<?> serviceInterface = ref.serviceInterface();
0:         ReferenceListener[] refListeners = ref.referenceListener();
1:         TreferenceList tref = new TreferenceList();
1:         
1:         // can not think of configuring depends on for referencelist
1:         tref.setDependsOn(null);
1:         
1:         if (id.length() > 0) {
1:             tref.setId(id);
1:         }
1:         
1:         if (availability.length() > 0) {
1:             tref.setAvailability(availability);
1:         }
1:         if (compName.length() > 0) {
1:             tref.setComponentName(compName);
1:         }
1:         if (desp.length() > 0) {
1:             Tdescription value = new Tdescription();
1:             value.getContent().add(desp);
1:             tref.setDescription(value);
1:         }
1:         if (filter.length() > 0) {
1:             tref.setFilter(filter);
1:         }
1:         if (serviceInterface  != Object.class) {
1:             tref.setInterface(serviceInterface.getName());
1:         } else {
0:             boolean isInterface =  refClass.isInterface();
0:             if (isInterface) {
0:                 tref.setInterface(refClass.getName());
1:             } else {
0:                 // should we throw an exception?  
1:             }
1:         }
1:         for (ReferenceListener rl : refListeners) {
0:             TreferenceListener trl = new TreferenceListener();
1:             String rf = rl.ref();
0:             String bindMethod = rl.bind();
0:             String unbindMethod = rl.unbind();
0:             trl.setRefAttribute(rf);
0:             trl.setBindMethod(bindMethod);
0:             trl.setUnbindMethod(unbindMethod);
0:             tref.getReferenceListener().add(trl);
1:         }
1:         
1:         return tref;
1:     }
1:     
0:     private Tservice generateTservice(Class clazz, String id) {
1:         Service service = (Service) clazz.getAnnotation(Service.class);
1:         Class<?>[] interfaces = service.interfaces();
1:         int ranking = service.ranking();
1:         String autoExport = service.autoExport();
0:         RegistrationListener[] regListeners = service.registerationListener();
1:         
1:         Tservice tservice = new Tservice();
1:         
1:         // can not think of configuring depends on for service
1:         tservice.setDependsOn(null);
1:         
1:         // use the bean id as the ref value since we are exposing service for the bean
1:         tservice.setRefAttribute(id);
1:         
1:         if (autoExport.length() > 0) {
1:             tservice.setAutoExport(autoExport);
1:         }
1:         if (ranking > 0) {
1:             tservice.setRanking(ranking);
1:         }
1:         for (Class<?> interf : interfaces) {
1:             Tinterfaces tInterfaces = new Tinterfaces();
1:             if (interf != null) {
1:                 tInterfaces.getValue().add(interf.getName());
1:             }
1:             tservice.setInterfaces(tInterfaces);
1:         }
1:         
1:         for (RegistrationListener regListener : regListeners) {
0:             String regListenerId = regListener.id();
0:             if (regListenerId.length() > 0) {
0:                 TregistrationListener tregListener = new TregistrationListener();
0:                 tregListener.setRefAttribute(regListenerId);
0:                 tregListener.setRegistrationMethod(regListener.register());
0:                 tregListener.setUnregistrationMethod(regListener.unregister());
1:                 tservice.getRegistrationListener().add(tregListener);
1:                 
1:             } else {
1:                 throw new BlueprintAnnotationException("No ref id for service registration listener " + " for " + clazz.getName());
1:             }
1:         }
1:         
1:         return tservice;
1:     }
1: }
============================================================================