1:fdf3952: /**
1:fdf3952:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:fdf3952:  *  contributor license agreements.  See the NOTICE file distributed with
1:fdf3952:  *  this work for additional information regarding copyright ownership.
1:fdf3952:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:fdf3952:  *  (the "License"); you may not use this file except in compliance with
1:fdf3952:  *  the License.  You may obtain a copy of the License at
2:fdf3952:  *
1:fdf3952:  *     http://www.apache.org/licenses/LICENSE-2.0
1:fdf3952:  *
1:fdf3952:  *  Unless required by applicable law or agreed to in writing, software
1:fdf3952:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:fdf3952:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fdf3952:  *  See the License for the specific language governing permissions and
1:fdf3952:  *  limitations under the License.
1:fdf3952:  */
1:fdf3952: package org.apache.aries.jmx.framework;
3:fdf3952: 
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleDependencies;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleExportedPackages;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleImportedPackages;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleState;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getDependentBundles;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getFragmentIds;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getHostIds;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getRegisteredServiceIds;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getServicesInUseByBundle;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.isBundlePendingRemoval;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.isBundleRequiredByOthers;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.resolveBundle;
1:fdf3952: 
1:fdf3952: import java.io.IOException;
1:fdf3952: import java.util.ArrayList;
1:a928ee9: import java.util.Arrays;
1:a928ee9: import java.util.Collection;
1:ade4709: import java.util.Collections;
1:fdf3952: import java.util.Dictionary;
1:fdf3952: import java.util.Enumeration;
1:fdf3952: import java.util.List;
1:fdf3952: import java.util.concurrent.ExecutorService;
1:fdf3952: import java.util.concurrent.Executors;
1:fdf3952: import java.util.concurrent.RejectedExecutionException;
1:fdf3952: import java.util.concurrent.atomic.AtomicInteger;
1:fdf3952: import java.util.concurrent.locks.Lock;
1:fdf3952: import java.util.concurrent.locks.ReentrantLock;
1:fdf3952: 
1:ade4709: import javax.management.AttributeChangeNotification;
1:fdf3952: import javax.management.MBeanNotificationInfo;
1:fdf3952: import javax.management.MBeanRegistration;
1:fdf3952: import javax.management.MBeanServer;
1:fdf3952: import javax.management.Notification;
1:fdf3952: import javax.management.NotificationBroadcasterSupport;
1:fdf3952: import javax.management.ObjectName;
1:a928ee9: import javax.management.openmbean.CompositeData;
1:fdf3952: import javax.management.openmbean.TabularData;
1:fdf3952: import javax.management.openmbean.TabularDataSupport;
1:fdf3952: 
1:fdf3952: import org.apache.aries.jmx.JMXThreadFactory;
1:fdf3952: import org.apache.aries.jmx.Logger;
1:fdf3952: import org.apache.aries.jmx.codec.BundleData;
1:fdf3952: import org.apache.aries.jmx.codec.BundleData.Header;
1:a928ee9: import org.apache.aries.jmx.codec.BundleEventData;
1:fdf3952: import org.osgi.framework.Bundle;
1:fdf3952: import org.osgi.framework.BundleContext;
1:fdf3952: import org.osgi.framework.BundleEvent;
1:fdf3952: import org.osgi.framework.BundleListener;
1:fdf3952: import org.osgi.jmx.framework.BundleStateMBean;
1:fdf3952: import org.osgi.service.log.LogService;
1:fdf3952: import org.osgi.service.packageadmin.PackageAdmin;
1:fdf3952: import org.osgi.service.startlevel.StartLevel;
1:fdf3952: 
1:fdf3952: /**
1:fdf3952:  * Implementation of <code>BundleStateMBean</code> which emits JMX <code>Notification</code> on <code>Bundle</code>
1:bf5a863:  * state changes.
1:a928ee9:  *
1:fdf3952:  * @version $Rev$ $Date$
1:fdf3952:  */
1:fdf3952: public class BundleState extends NotificationBroadcasterSupport implements BundleStateMBean, MBeanRegistration {
1:fdf3952: 
1:fdf3952:     protected Logger logger;
1:fdf3952:     protected BundleContext bundleContext;
1:fdf3952:     protected PackageAdmin packageAdmin;
1:fdf3952:     protected StartLevel startLevel;
1:a0df2a3:     protected StateConfig stateConfig;
1:fdf3952: 
1:fdf3952:     protected ExecutorService eventDispatcher;
1:fdf3952:     protected BundleListener bundleListener;
1:fdf3952:     private AtomicInteger notificationSequenceNumber = new AtomicInteger(1);
1:ade4709:     private AtomicInteger attributeChangeNotificationSequenceNumber = new AtomicInteger(1);
1:fdf3952:     private Lock lock = new ReentrantLock();
1:fdf3952:     private AtomicInteger registrations = new AtomicInteger(0);
1:fdf3952: 
1:fdf3952:     // notification type description
1:fdf3952:     public static String BUNDLE_EVENT = "org.osgi.bundle.event";
1:fdf3952: 
1:a0df2a3:     public BundleState(BundleContext bundleContext, PackageAdmin packageAdmin, StartLevel startLevel, StateConfig stateConfig, Logger logger) {
1:fdf3952:         this.bundleContext = bundleContext;
1:fdf3952:         this.packageAdmin = packageAdmin;
1:fdf3952:         this.startLevel = startLevel;
1:a0df2a3:         this.stateConfig = stateConfig;
1:fdf3952:         this.logger = logger;
3:fdf3952:     }
1:a928ee9: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getExportedPackages(long)
1:fdf3952:      */
1:fdf3952:     public String[] getExportedPackages(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return getBundleExportedPackages(bundle, packageAdmin);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getFragments(long)
1:fdf3952:      */
1:fdf3952:     public long[] getFragments(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return getFragmentIds(bundle, packageAdmin);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getHeaders(long)
1:fdf3952:      */
1:fdf3952:     public TabularData getHeaders(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         Dictionary<String, String> bundleHeaders = bundle.getHeaders();
1:bf76d9d:         return getHeaders(bundleHeaders);
1:bf76d9d:     }
1:bf76d9d: 
1:bf76d9d:     /**
1:bf76d9d:      * @see org.osgi.jmx.framework.BundleStateMBean#getHeaders(long, java.lang.String)
1:bf76d9d:      */
1:bf76d9d:     public TabularData getHeaders(long bundleId, String locale) throws IOException, IllegalArgumentException {
1:bf76d9d:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:bf76d9d:         Dictionary<String, String> bundleHeaders = bundle.getHeaders(locale);
1:bf76d9d:         return getHeaders(bundleHeaders);
1:bf76d9d:     }
1:bf76d9d: 
1:bf76d9d:     private TabularData getHeaders(Dictionary<String, String> bundleHeaders) {
1:bf76d9d:         List<Header> headers = new ArrayList<Header>();
1:fdf3952:         Enumeration<String> keys = bundleHeaders.keys();
1:fdf3952:         while (keys.hasMoreElements()) {
1:fdf3952:             String key = keys.nextElement();
1:fdf3952:             headers.add(new Header(key, bundleHeaders.get(key)));
1:fdf3952:         }
1:fdf3952:         TabularData headerTable = new TabularDataSupport(HEADERS_TYPE);
1:fdf3952:         for (Header header : headers) {
1:fdf3952:             headerTable.put(header.toCompositeData());
1:fdf3952:         }
1:fdf3952:         return headerTable;
1:fdf3952:     }
1:fdf3952: 
1:bf76d9d:     /**
1:bf76d9d:      * @see org.osgi.jmx.framework.BundleStateMBean#getHeader(long, java.lang.String)
1:bf76d9d:      */
1:a928ee9:     public String getHeader(long bundleId, String key) throws IOException {
1:a928ee9:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:a928ee9:         return bundle.getHeaders().get(key);
1:a928ee9:     }
1:a928ee9: 
1:fdf3952:     /**
1:bf76d9d:      * @see org.osgi.jmx.framework.BundleStateMBean#getHeader(long, java.lang.String, java.lang.String)
1:bf76d9d:      */
1:bf76d9d:     public String getHeader(long bundleId, String key, String locale) throws IOException {
1:bf76d9d:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:bf76d9d:         return bundle.getHeaders(locale).get(key);
1:bf76d9d:     }
1:bf76d9d: 
1:bf76d9d:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getHosts(long)
1:fdf3952:      */
1:fdf3952:     public long[] getHosts(long fragmentId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle fragment = resolveBundle(bundleContext, fragmentId);
1:fdf3952:         return getHostIds(fragment, packageAdmin);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getImportedPackages(long)
1:fdf3952:      */
1:fdf3952:     public String[] getImportedPackages(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return getBundleImportedPackages(bundleContext, bundle, packageAdmin);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getLastModified(long)
1:fdf3952:      */
1:fdf3952:     public long getLastModified(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return bundle.getLastModified();
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getLocation(long)
1:fdf3952:      */
1:fdf3952:     public String getLocation(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return bundle.getLocation();
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getRegisteredServices(long)
1:fdf3952:      */
1:fdf3952:     public long[] getRegisteredServices(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return getRegisteredServiceIds(bundle);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getRequiredBundles(long)
1:fdf3952:      */
1:fdf3952:     public long[] getRequiredBundles(long bundleIdentifier) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleIdentifier);
1:fdf3952:         return getBundleDependencies(bundleContext, bundle, packageAdmin);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getRequiringBundles(long)
1:fdf3952:      */
1:fdf3952:     public long[] getRequiringBundles(long bundleIdentifier) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleIdentifier);
1:fdf3952:         return getDependentBundles(bundle, packageAdmin);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getServicesInUse(long)
1:fdf3952:      */
1:fdf3952:     public long[] getServicesInUse(long bundleIdentifier) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleIdentifier);
1:fdf3952:         return getServicesInUseByBundle(bundle);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getStartLevel(long)
1:fdf3952:      */
1:fdf3952:     public int getStartLevel(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return startLevel.getBundleStartLevel(bundle);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getState(long)
1:fdf3952:      */
1:fdf3952:     public String getState(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return getBundleState(bundle);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getSymbolicName(long)
1:fdf3952:      */
1:fdf3952:     public String getSymbolicName(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return bundle.getSymbolicName();
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#getVersion(long)
1:fdf3952:      */
1:fdf3952:     public String getVersion(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return bundle.getVersion().toString();
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#isFragment(long)
1:fdf3952:      */
1:fdf3952:     public boolean isFragment(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return (PackageAdmin.BUNDLE_TYPE_FRAGMENT == packageAdmin.getBundleType(bundle));
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:8020538:      * @see org.osgi.jmx.framework.BundleStateMBean#isActivationPolicyUsed(long)
1:8020538:      */
1:8020538:     public boolean isActivationPolicyUsed(long bundleId) throws IOException {
1:8020538:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:8020538:         return startLevel.isBundleActivationPolicyUsed(bundle);
1:8020538:     }
1:8020538: 
1:8020538:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#isPersistentlyStarted(long)
1:fdf3952:      */
1:fdf3952:     public boolean isPersistentlyStarted(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return startLevel.isBundlePersistentlyStarted(bundle);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#isRemovalPending(long)
1:fdf3952:      */
1:fdf3952:     public boolean isRemovalPending(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return isBundlePendingRemoval(bundle, packageAdmin);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#isRequired(long)
1:fdf3952:      */
1:fdf3952:     public boolean isRequired(long bundleId) throws IOException, IllegalArgumentException {
1:fdf3952:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:fdf3952:         return isBundleRequiredByOthers(bundle, packageAdmin);
1:fdf3952:     }
1:a928ee9: 
1:a928ee9:     public CompositeData getBundle(long id) throws IOException {
1:a928ee9:         Bundle bundle = bundleContext.getBundle(id);
1:a928ee9:         if (bundle == null)
1:a928ee9:             return null;
1:a928ee9: 
1:a928ee9:         BundleData data = new BundleData(bundleContext, bundle, packageAdmin, startLevel);
1:a928ee9:         return data.toCompositeData();
1:a928ee9:     }
1:a928ee9: 
1:c4c8b5b:     public long[] getBundleIds() throws IOException {
1:c4c8b5b:         Bundle[] bundles = bundleContext.getBundles();
1:c4c8b5b:         long[] ids = new long[bundles.length];
1:c4c8b5b:         for (int i=0; i < bundles.length; i++) {
1:c4c8b5b:             ids[i] = bundles[i].getBundleId();
1:c4c8b5b:         }
1:ade4709: 
1:ade4709:         // The IDs are sorted here. It's not required by the spec but it's nice
1:ade4709:         // to have an ordered list returned.
1:ade4709:         Arrays.sort(ids);
1:ade4709: 
1:c4c8b5b:         return ids;
1:c4c8b5b:     }
1:c4c8b5b: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.BundleStateMBean#listBundles()
1:fdf3952:      */
1:fdf3952:     public TabularData listBundles() throws IOException {
1:a928ee9:         return listBundles(BundleStateMBean.BUNDLE_TYPE.keySet());
1:a928ee9:     }
1:a928ee9: 
1:a928ee9:     public TabularData listBundles(String ... items) throws IOException {
1:a928ee9:         return listBundles(Arrays.asList(items));
1:a928ee9:     }
1:a928ee9: 
1:a928ee9:     private TabularData listBundles(Collection<String> items) throws IOException {
1:fdf3952:         Bundle[] containerBundles = bundleContext.getBundles();
1:fdf3952:         List<BundleData> bundleDatas = new ArrayList<BundleData>();
1:fdf3952:         if (containerBundles != null) {
1:fdf3952:             for (Bundle containerBundle : containerBundles) {
1:fdf3952:                 bundleDatas.add(new BundleData(bundleContext, containerBundle, packageAdmin, startLevel));
1:a928ee9:             }
1:fdf3952:         }
1:fdf3952:         TabularData bundleTable = new TabularDataSupport(BUNDLES_TYPE);
1:fdf3952:         for (BundleData bundleData : bundleDatas) {
1:a928ee9:             bundleTable.put(bundleData.toCompositeData(items));
1:fdf3952:         }
1:fdf3952:         return bundleTable;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see javax.management.NotificationBroadcasterSupport#getNotificationInfo()
1:fdf3952:      */
1:fdf3952:     public MBeanNotificationInfo[] getNotificationInfo() {
1:ade4709:         MBeanNotificationInfo eventInfo = new MBeanNotificationInfo(
1:ade4709:                 new String[] { BUNDLE_EVENT },
1:ade4709:                 Notification.class.getName(),
1:ade4709:                 "A BundleEvent issued from the Framework describing a bundle lifecycle change");
1:ade4709: 
1:ade4709:         MBeanNotificationInfo attributeChangeInfo = new MBeanNotificationInfo(
1:ade4709:                 new String [] {AttributeChangeNotification.ATTRIBUTE_CHANGE },
1:ade4709:                 AttributeChangeNotification.class.getName(),
1:ade4709:                 "An attribute of this MBean has changed");
1:ade4709: 
1:ade4709:         return new MBeanNotificationInfo[] { eventInfo, attributeChangeInfo };
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see javax.management.MBeanRegistration#postDeregister()
1:fdf3952:      */
1:fdf3952:     public void postDeregister() {
1:fdf3952:         if (registrations.decrementAndGet() < 1) {
1:fdf3952:             shutDownDispatcher();
1:fdf3952:         }
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see javax.management.MBeanRegistration#postRegister(java.lang.Boolean)
1:fdf3952:      */
1:fdf3952:     public void postRegister(Boolean registrationDone) {
1:fdf3952:         if (registrationDone && registrations.incrementAndGet() == 1) {
1:fdf3952:             eventDispatcher = Executors.newSingleThreadExecutor(new JMXThreadFactory("JMX OSGi Bundle State Event Dispatcher"));
1:fdf3952:             bundleContext.addBundleListener(bundleListener);
1:fdf3952:         }
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see javax.management.MBeanRegistration#preDeregister()
1:fdf3952:      */
1:fdf3952:     public void preDeregister() throws Exception {
1:fdf3952:         // No action
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see javax.management.MBeanRegistration#preRegister(javax.management.MBeanServer, javax.management.ObjectName)
1:fdf3952:      */
1:fdf3952:     public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
1:fdf3952:         lock.lock();
1:fdf3952:         try {
1:fdf3952:             if (bundleListener == null) {
1:fdf3952:                 bundleListener = new BundleListener() {
1:fdf3952:                     public void bundleChanged(BundleEvent event) {
1:1570712:                         if (stateConfig != null && !stateConfig.isBundleChangeNotificationEnabled()) {
1:1570712:                             return;
1:1570712:                         }
1:fdf3952:                         try {
1:ade4709:                             final Notification notification = new Notification(EVENT, OBJECTNAME,
1:ade4709:                                     notificationSequenceNumber.getAndIncrement());
1:fdf3952:                             notification.setUserData(new BundleEventData(event).toCompositeData());
1:ade4709: 
1:ade4709:                             // also send notifications to the bundleIDs attribute listeners, if a bundle was added or removed
1:ade4709:                             final AttributeChangeNotification attributeChangeNotification =
1:ade4709:                                     getAttributeChangeNotification(event);
1:ade4709: 
1:fdf3952:                             eventDispatcher.submit(new Runnable() {
1:fdf3952:                                 public void run() {
1:fdf3952:                                     sendNotification(notification);
1:ade4709:                                     if (attributeChangeNotification != null)
1:ade4709:                                         sendNotification(attributeChangeNotification);
1:fdf3952:                                 }
1:fdf3952:                             });
1:fdf3952:                         } catch (RejectedExecutionException re) {
1:fdf3952:                             logger.log(LogService.LOG_WARNING, "Task rejected for JMX Notification dispatch of event ["
1:fdf3952:                                     + event + "] - Dispatcher may have been shutdown");
1:fdf3952:                         } catch (Exception e) {
1:fdf3952:                             logger.log(LogService.LOG_WARNING,
1:fdf3952:                                     "Exception occured on JMX Notification dispatch for event [" + event + "]", e);
1:fdf3952:                         }
1:fdf3952:                     }
1:fdf3952:                 };
1:fdf3952:             }
1:fdf3952:         } finally {
1:fdf3952:             lock.unlock();
1:fdf3952:         }
1:fdf3952:         return name;
1:fdf3952:     }
1:fdf3952: 
1:ade4709:     protected AttributeChangeNotification getAttributeChangeNotification(BundleEvent event) throws IOException {
1:a0df2a3:         if (stateConfig != null && !stateConfig.isAttributeChangeNotificationEnabled()) {
1:a0df2a3:             return null;
1:a0df2a3:         }
1:a0df2a3: 
1:ade4709:         int eventType = event.getType();
1:ade4709:         switch (eventType) {
1:ade4709:         case BundleEvent.INSTALLED:
1:ade4709:         case BundleEvent.UNINSTALLED:
1:ade4709:             long bundleID = event.getBundle().getBundleId();
1:ade4709:             long[] ids = getBundleIds();
1:ade4709: 
1:ade4709:             List<Long> without = new ArrayList<Long>();
1:ade4709:             for (long id : ids) {
1:ade4709:                 if (id != bundleID)
1:ade4709:                     without.add(id);
1:ade4709:             }
1:ade4709:             List<Long> with = new ArrayList<Long>(without);
1:ade4709:             with.add(bundleID);
1:ade4709: 
1:ade4709:             // Sorting is not mandatory, but its nice for the user, note that getBundleIds() also returns a sorted array
1:ade4709:             Collections.sort(with);
1:ade4709: 
1:ade4709:             List<Long> oldList = eventType == BundleEvent.INSTALLED ? without : with;
1:ade4709:             List<Long> newList = eventType == BundleEvent.INSTALLED ? with : without;
1:ade4709: 
1:ade4709:             long[] oldIDs = new long[oldList.size()];
1:ade4709:             for (int i = 0; i < oldIDs.length; i++) {
1:ade4709:                 oldIDs[i] = oldList.get(i);
1:ade4709:             }
1:ade4709: 
1:ade4709:             long[] newIDs = new long[newList.size()];
1:ade4709:             for (int i = 0; i < newIDs.length; i++) {
1:ade4709:                 newIDs[i] = newList.get(i);
1:ade4709:             }
1:ade4709: 
1:ade4709:             return new AttributeChangeNotification(OBJECTNAME, attributeChangeNotificationSequenceNumber.getAndIncrement(),
1:ade4709:                     System.currentTimeMillis(), "BundleIds changed", "BundleIds", "Array of long", oldIDs, newIDs);
1:ade4709:         default:
1:ade4709:             return null;
1:ade4709:         }
1:ade4709:     }
1:ade4709: 
1:fdf3952:     /*
1:fdf3952:      * Shuts down the notification dispatcher
1:fdf3952:      * [ARIES-259] MBeans not getting unregistered reliably
1:fdf3952:      */
1:fdf3952:     protected void shutDownDispatcher() {
1:fdf3952:         if (bundleListener != null) {
1:fdf3952:             try {
1:fdf3952:                bundleContext.removeBundleListener(bundleListener);
1:fdf3952:             }
1:fdf3952:             catch (Exception e) {
1:fdf3952:                // ignore
1:a928ee9:             }
1:fdf3952:         }
1:fdf3952:         if (eventDispatcher != null) {
1:a928ee9:             eventDispatcher.shutdown();
1:fdf3952:         }
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /*
1:fdf3952:      * Returns the ExecutorService used to dispatch Notifications
1:fdf3952:      */
1:fdf3952:     protected ExecutorService getEventDispatcher() {
1:fdf3952:         return eventDispatcher;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:1570712
/////////////////////////////////////////////////////////////////////////
1:                         if (stateConfig != null && !stateConfig.isBundleChangeNotificationEnabled()) {
1:                             return;
1:                         }
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:a0df2a3
/////////////////////////////////////////////////////////////////////////
1:     protected StateConfig stateConfig;
/////////////////////////////////////////////////////////////////////////
1:     public BundleState(BundleContext bundleContext, PackageAdmin packageAdmin, StartLevel startLevel, StateConfig stateConfig, Logger logger) {
1:         this.stateConfig = stateConfig;
/////////////////////////////////////////////////////////////////////////
1:         if (stateConfig != null && !stateConfig.isAttributeChangeNotificationEnabled()) {
1:             return null;
1:         }
1: 
commit:0273964
commit:ade4709
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1: import javax.management.AttributeChangeNotification;
/////////////////////////////////////////////////////////////////////////
1:     private AtomicInteger attributeChangeNotificationSequenceNumber = new AtomicInteger(1);
/////////////////////////////////////////////////////////////////////////
1: 
1:         // The IDs are sorted here. It's not required by the spec but it's nice
1:         // to have an ordered list returned.
1:         Arrays.sort(ids);
1: 
/////////////////////////////////////////////////////////////////////////
1:         MBeanNotificationInfo eventInfo = new MBeanNotificationInfo(
1:                 new String[] { BUNDLE_EVENT },
1:                 Notification.class.getName(),
1:                 "A BundleEvent issued from the Framework describing a bundle lifecycle change");
1: 
1:         MBeanNotificationInfo attributeChangeInfo = new MBeanNotificationInfo(
1:                 new String [] {AttributeChangeNotification.ATTRIBUTE_CHANGE },
1:                 AttributeChangeNotification.class.getName(),
1:                 "An attribute of this MBean has changed");
1: 
1:         return new MBeanNotificationInfo[] { eventInfo, attributeChangeInfo };
/////////////////////////////////////////////////////////////////////////
1:                             final Notification notification = new Notification(EVENT, OBJECTNAME,
1:                                     notificationSequenceNumber.getAndIncrement());
1: 
1:                             // also send notifications to the bundleIDs attribute listeners, if a bundle was added or removed
1:                             final AttributeChangeNotification attributeChangeNotification =
1:                                     getAttributeChangeNotification(event);
1: 
1:                                     if (attributeChangeNotification != null)
1:                                         sendNotification(attributeChangeNotification);
/////////////////////////////////////////////////////////////////////////
1:     protected AttributeChangeNotification getAttributeChangeNotification(BundleEvent event) throws IOException {
1:         int eventType = event.getType();
1:         switch (eventType) {
1:         case BundleEvent.INSTALLED:
1:         case BundleEvent.UNINSTALLED:
1:             long bundleID = event.getBundle().getBundleId();
1:             long[] ids = getBundleIds();
1: 
1:             List<Long> without = new ArrayList<Long>();
1:             for (long id : ids) {
1:                 if (id != bundleID)
1:                     without.add(id);
1:             }
1:             List<Long> with = new ArrayList<Long>(without);
1:             with.add(bundleID);
1: 
1:             // Sorting is not mandatory, but its nice for the user, note that getBundleIds() also returns a sorted array
1:             Collections.sort(with);
1: 
1:             List<Long> oldList = eventType == BundleEvent.INSTALLED ? without : with;
1:             List<Long> newList = eventType == BundleEvent.INSTALLED ? with : without;
1: 
1:             long[] oldIDs = new long[oldList.size()];
1:             for (int i = 0; i < oldIDs.length; i++) {
1:                 oldIDs[i] = oldList.get(i);
1:             }
1: 
1:             long[] newIDs = new long[newList.size()];
1:             for (int i = 0; i < newIDs.length; i++) {
1:                 newIDs[i] = newList.get(i);
1:             }
1: 
1:             return new AttributeChangeNotification(OBJECTNAME, attributeChangeNotificationSequenceNumber.getAndIncrement(),
1:                     System.currentTimeMillis(), "BundleIds changed", "BundleIds", "Array of long", oldIDs, newIDs);
1:         default:
1:             return null;
1:         }
1:     }
1: 
commit:c4c8b5b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public long[] getBundleIds() throws IOException {
1:         Bundle[] bundles = bundleContext.getBundles();
1:         long[] ids = new long[bundles.length];
1:         for (int i=0; i < bundles.length; i++) {
1:             ids[i] = bundles[i].getBundleId();
1:         }
1:         return ids;
1:     }
1: 
commit:8020538
/////////////////////////////////////////////////////////////////////////
1:      * @see org.osgi.jmx.framework.BundleStateMBean#isActivationPolicyUsed(long)
1:      */
1:     public boolean isActivationPolicyUsed(long bundleId) throws IOException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return startLevel.isBundleActivationPolicyUsed(bundle);
1:     }
1: 
1:     /**
commit:bf76d9d
/////////////////////////////////////////////////////////////////////////
1:         return getHeaders(bundleHeaders);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getHeaders(long, java.lang.String)
1:      */
1:     public TabularData getHeaders(long bundleId, String locale) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         Dictionary<String, String> bundleHeaders = bundle.getHeaders(locale);
1:         return getHeaders(bundleHeaders);
1:     }
1: 
1:     private TabularData getHeaders(Dictionary<String, String> bundleHeaders) {
1:         List<Header> headers = new ArrayList<Header>();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getHeader(long, java.lang.String)
1:      */
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getHeader(long, java.lang.String, java.lang.String)
1:      */
1:     public String getHeader(long bundleId, String key, String locale) throws IOException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return bundle.getHeaders(locale).get(key);
1:     }
1: 
1:     /**
commit:bf5a863
/////////////////////////////////////////////////////////////////////////
1:  * state changes.
commit:a928ee9
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1: import javax.management.openmbean.CompositeData;
1: import org.apache.aries.jmx.codec.BundleEventData;
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:     public String getHeader(long bundleId, String key) throws IOException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return bundle.getHeaders().get(key);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public CompositeData getBundle(long id) throws IOException {
1:         Bundle bundle = bundleContext.getBundle(id);
1:         if (bundle == null)
1:             return null;
1: 
1:         BundleData data = new BundleData(bundleContext, bundle, packageAdmin, startLevel);
1:         return data.toCompositeData();
1:     }
1: 
1:         return listBundles(BundleStateMBean.BUNDLE_TYPE.keySet());
1:     }
1: 
1:     public TabularData listBundles(String ... items) throws IOException {
1:         return listBundles(Arrays.asList(items));
1:     }
1: 
1:     private TabularData listBundles(Collection<String> items) throws IOException {
1:             }
1:             bundleTable.put(bundleData.toCompositeData(items));
/////////////////////////////////////////////////////////////////////////
1:             }
1:             eventDispatcher.shutdown();
commit:fdf3952
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
1: package org.apache.aries.jmx.framework;
1: 
1: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleDependencies;
1: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleExportedPackages;
1: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleImportedPackages;
1: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleState;
1: import static org.apache.aries.jmx.util.FrameworkUtils.getDependentBundles;
1: import static org.apache.aries.jmx.util.FrameworkUtils.getFragmentIds;
1: import static org.apache.aries.jmx.util.FrameworkUtils.getHostIds;
1: import static org.apache.aries.jmx.util.FrameworkUtils.getRegisteredServiceIds;
1: import static org.apache.aries.jmx.util.FrameworkUtils.getServicesInUseByBundle;
1: import static org.apache.aries.jmx.util.FrameworkUtils.isBundlePendingRemoval;
1: import static org.apache.aries.jmx.util.FrameworkUtils.isBundleRequiredByOthers;
1: import static org.apache.aries.jmx.util.FrameworkUtils.resolveBundle;
1: 
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.List;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.RejectedExecutionException;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.locks.Lock;
1: import java.util.concurrent.locks.ReentrantLock;
1: 
1: import javax.management.MBeanNotificationInfo;
1: import javax.management.MBeanRegistration;
1: import javax.management.MBeanServer;
1: import javax.management.Notification;
1: import javax.management.NotificationBroadcasterSupport;
1: import javax.management.ObjectName;
1: import javax.management.openmbean.TabularData;
1: import javax.management.openmbean.TabularDataSupport;
1: 
1: import org.apache.aries.jmx.JMXThreadFactory;
1: import org.apache.aries.jmx.Logger;
1: import org.apache.aries.jmx.codec.BundleData;
0: import org.apache.aries.jmx.codec.BundleEventData;
1: import org.apache.aries.jmx.codec.BundleData.Header;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleEvent;
1: import org.osgi.framework.BundleListener;
1: import org.osgi.jmx.framework.BundleStateMBean;
1: import org.osgi.service.log.LogService;
1: import org.osgi.service.packageadmin.PackageAdmin;
1: import org.osgi.service.startlevel.StartLevel;
1: 
1: /**
1:  * Implementation of <code>BundleStateMBean</code> which emits JMX <code>Notification</code> on <code>Bundle</code>
0:  * state changes
1:  * 
1:  * @version $Rev$ $Date$
1:  */
1: public class BundleState extends NotificationBroadcasterSupport implements BundleStateMBean, MBeanRegistration {
1: 
1:     protected Logger logger;
1:     protected BundleContext bundleContext;
1:     protected PackageAdmin packageAdmin;
1:     protected StartLevel startLevel;
1: 
1:     protected ExecutorService eventDispatcher;
1:     protected BundleListener bundleListener;
1:     private AtomicInteger notificationSequenceNumber = new AtomicInteger(1);
1:     private Lock lock = new ReentrantLock();
1:     private AtomicInteger registrations = new AtomicInteger(0);
1: 
1:     // notification type description
1:     public static String BUNDLE_EVENT = "org.osgi.bundle.event";
1: 
0:     public BundleState(BundleContext bundleContext, PackageAdmin packageAdmin, StartLevel startLevel, Logger logger) {
1:         this.bundleContext = bundleContext;
1:         this.packageAdmin = packageAdmin;
1:         this.startLevel = startLevel;
1:         this.logger = logger;
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getExportedPackages(long)
1:      */
1:     public String[] getExportedPackages(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return getBundleExportedPackages(bundle, packageAdmin);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getFragments(long)
1:      */
1:     public long[] getFragments(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return getFragmentIds(bundle, packageAdmin);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getHeaders(long)
1:      */
0:     @SuppressWarnings("unchecked")
1:     public TabularData getHeaders(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
0:         List<Header> headers = new ArrayList<Header>();
1:         Dictionary<String, String> bundleHeaders = bundle.getHeaders();
1:         Enumeration<String> keys = bundleHeaders.keys();
1:         while (keys.hasMoreElements()) {
1:             String key = keys.nextElement();
1:             headers.add(new Header(key, bundleHeaders.get(key)));
1:         }
1:         TabularData headerTable = new TabularDataSupport(HEADERS_TYPE);
1:         for (Header header : headers) {
1:             headerTable.put(header.toCompositeData());
1:         }
1:         return headerTable;
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getHosts(long)
1:      */
1:     public long[] getHosts(long fragmentId) throws IOException, IllegalArgumentException {
1:         Bundle fragment = resolveBundle(bundleContext, fragmentId);
1:         return getHostIds(fragment, packageAdmin);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getImportedPackages(long)
1:      */
1:     public String[] getImportedPackages(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return getBundleImportedPackages(bundleContext, bundle, packageAdmin);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getLastModified(long)
1:      */
1:     public long getLastModified(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return bundle.getLastModified();
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getLocation(long)
1:      */
1:     public String getLocation(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return bundle.getLocation();
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getRegisteredServices(long)
1:      */
1:     public long[] getRegisteredServices(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return getRegisteredServiceIds(bundle);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getRequiredBundles(long)
1:      */
1:     public long[] getRequiredBundles(long bundleIdentifier) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleIdentifier);
1:         return getBundleDependencies(bundleContext, bundle, packageAdmin);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getRequiringBundles(long)
1:      */
1:     public long[] getRequiringBundles(long bundleIdentifier) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleIdentifier);
1:         return getDependentBundles(bundle, packageAdmin);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getServicesInUse(long)
1:      */
1:     public long[] getServicesInUse(long bundleIdentifier) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleIdentifier);
1:         return getServicesInUseByBundle(bundle);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getStartLevel(long)
1:      */
1:     public int getStartLevel(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return startLevel.getBundleStartLevel(bundle);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getState(long)
1:      */
1:     public String getState(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return getBundleState(bundle);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getSymbolicName(long)
1:      */
1:     public String getSymbolicName(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return bundle.getSymbolicName();
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#getVersion(long)
1:      */
1:     public String getVersion(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return bundle.getVersion().toString();
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#isFragment(long)
1:      */
1:     public boolean isFragment(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return (PackageAdmin.BUNDLE_TYPE_FRAGMENT == packageAdmin.getBundleType(bundle));
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#isPersistentlyStarted(long)
1:      */
1:     public boolean isPersistentlyStarted(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return startLevel.isBundlePersistentlyStarted(bundle);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#isRemovalPending(long)
1:      */
1:     public boolean isRemovalPending(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return isBundlePendingRemoval(bundle, packageAdmin);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#isRequired(long)
1:      */
1:     public boolean isRequired(long bundleId) throws IOException, IllegalArgumentException {
1:         Bundle bundle = resolveBundle(bundleContext, bundleId);
1:         return isBundleRequiredByOthers(bundle, packageAdmin);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.BundleStateMBean#listBundles()
1:      */
1:     public TabularData listBundles() throws IOException {
1:         Bundle[] containerBundles = bundleContext.getBundles();
1:         List<BundleData> bundleDatas = new ArrayList<BundleData>();
1:         if (containerBundles != null) {
1:             for (Bundle containerBundle : containerBundles) {
1:                 bundleDatas.add(new BundleData(bundleContext, containerBundle, packageAdmin, startLevel));
1:             } 
1:         }
1:         TabularData bundleTable = new TabularDataSupport(BUNDLES_TYPE);
1:         for (BundleData bundleData : bundleDatas) {
0:             bundleTable.put(bundleData.toCompositeData());
1:         }
1:         return bundleTable;
1:     }
1: 
1:     /**
1:      * @see javax.management.NotificationBroadcasterSupport#getNotificationInfo()
1:      */
1:     public MBeanNotificationInfo[] getNotificationInfo() {
0:         String[] types = new String[] { BUNDLE_EVENT };
0:         String name = Notification.class.getName();
0:         String description = "A BundleEvent issued from the Framework describing a bundle lifecycle change";
0:         MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description);
0:         return new MBeanNotificationInfo[] { info };
1:     }
1: 
1:     /**
1:      * @see javax.management.MBeanRegistration#postDeregister()
1:      */
1:     public void postDeregister() {
1:         if (registrations.decrementAndGet() < 1) {
1:             shutDownDispatcher();
1:         }
1:     }
1: 
1:     /**
1:      * @see javax.management.MBeanRegistration#postRegister(java.lang.Boolean)
1:      */
1:     public void postRegister(Boolean registrationDone) {
1:         if (registrationDone && registrations.incrementAndGet() == 1) {
1:             eventDispatcher = Executors.newSingleThreadExecutor(new JMXThreadFactory("JMX OSGi Bundle State Event Dispatcher"));
1:             bundleContext.addBundleListener(bundleListener);
1:         }
1:     }
1: 
1:     /**
1:      * @see javax.management.MBeanRegistration#preDeregister()
1:      */
1:     public void preDeregister() throws Exception {
1:         // No action
1:     }
1: 
1:     /**
1:      * @see javax.management.MBeanRegistration#preRegister(javax.management.MBeanServer, javax.management.ObjectName)
1:      */
1:     public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
1:         lock.lock();
1:         try {
1:             if (bundleListener == null) {
1:                 bundleListener = new BundleListener() {
1:                     public void bundleChanged(BundleEvent event) {
0:                         final Notification notification = new Notification(EVENT, OBJECTNAME,
0:                                 notificationSequenceNumber.getAndIncrement());
1:                         try {
1:                             notification.setUserData(new BundleEventData(event).toCompositeData());
1:                             eventDispatcher.submit(new Runnable() {
1:                                 public void run() {
1:                                     sendNotification(notification);
1:                                 }
1:                             });
1:                         } catch (RejectedExecutionException re) {
1:                             logger.log(LogService.LOG_WARNING, "Task rejected for JMX Notification dispatch of event ["
1:                                     + event + "] - Dispatcher may have been shutdown");
1:                         } catch (Exception e) {
1:                             logger.log(LogService.LOG_WARNING,
1:                                     "Exception occured on JMX Notification dispatch for event [" + event + "]", e);
1:                         }
1:                     }
1:                 };
1:             }
1:         } finally {
1:             lock.unlock();
1:         }
1:         return name;
1:     }
1: 
1:     /*
1:      * Shuts down the notification dispatcher
1:      * [ARIES-259] MBeans not getting unregistered reliably
1:      */
1:     protected void shutDownDispatcher() {
1:         if (bundleListener != null) {
1:             try {
1:                bundleContext.removeBundleListener(bundleListener);
1:             }
1:             catch (Exception e) {
1:                // ignore
1:             }  
1:         }
1:         if (eventDispatcher != null) {
0:             eventDispatcher.shutdown(); 
1:         }
1:     }
1: 
1:     /*
1:      * Returns the ExecutorService used to dispatch Notifications
1:      */
1:     protected ExecutorService getEventDispatcher() {
1:         return eventDispatcher;
1:     }
1: 
1: }
============================================================================