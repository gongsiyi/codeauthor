1:c1f1260: /**
1:c1f1260:  * Licensed to the Apache Software Foundation (ASF) under one
1:c1f1260:  * or more contributor license agreements.  See the NOTICE file
1:c1f1260:  * distributed with this work for additional information
1:c1f1260:  * regarding copyright ownership.  The ASF licenses this file
1:c1f1260:  * to you under the Apache License, Version 2.0 (the
1:c1f1260:  * "License"); you may not use this file except in compliance
1:c1f1260:  * with the License.  You may obtain a copy of the License at
1:c1f1260:  *
1:c1f1260:  *   http://www.apache.org/licenses/LICENSE-2.0
1:c1f1260:  *
1:c1f1260:  * Unless required by applicable law or agreed to in writing,
1:c1f1260:  * software distributed under the License is distributed on an
1:c1f1260:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:c1f1260:  * KIND, either express or implied.  See the License for the
1:c1f1260:  * specific language governing permissions and limitations
1:c1f1260:  * under the License.
1:c1f1260:  */
1:a8ccbc9: package org.apache.aries.spifly.dynamic;
47:c1f1260: 
1:a8ccbc9: import java.io.BufferedReader;
1:5ed7a90: import java.io.File;
1:a8ccbc9: import java.io.FileReader;
1:c1f1260: import java.io.IOException;
1:c1f1260: import java.lang.reflect.Field;
1:c1f1260: import java.lang.reflect.Method;
1:c1f1260: import java.net.URL;
1:c1f1260: import java.net.URLClassLoader;
1:c1f1260: import java.security.ProtectionDomain;
1:c1f1260: import java.util.ArrayList;
1:c1f1260: import java.util.Arrays;
1:a8ccbc9: import java.util.Collection;
1:a8ccbc9: import java.util.Collections;
1:c1f1260: import java.util.Dictionary;
1:c1f1260: import java.util.Enumeration;
1:7158c23: import java.util.HashMap;
1:11803af: import java.util.HashSet;
1:c1f1260: import java.util.Hashtable;
1:c1f1260: import java.util.List;
1:c144094: import java.util.Map;
1:11803af: import java.util.Set;
1:c144094: import java.util.concurrent.ConcurrentHashMap;
1:c1f1260: 
1:67d07ab: import javax.xml.parsers.DocumentBuilderFactory;
1:c1f1260: 
1:a8ccbc9: import org.apache.aries.spifly.BaseActivator;
1:e9a5257: import org.apache.aries.spifly.SpiFlyConstants;
1:a8ccbc9: import org.apache.aries.spifly.Streams;
1:c1f1260: import org.easymock.EasyMock;
1:a8ccbc9: import org.easymock.IAnswer;
1:c1f1260: import org.junit.After;
1:c1f1260: import org.junit.Assert;
1:c1f1260: import org.junit.Before;
1:c1f1260: import org.junit.Test;
1:c1f1260: import org.osgi.framework.Bundle;
1:c1f1260: import org.osgi.framework.BundleContext;
1:c1f1260: import org.osgi.framework.BundleReference;
1:c1f1260: import org.osgi.framework.Version;
1:c1f1260: import org.osgi.framework.hooks.weaving.WeavingHook;
1:c1f1260: import org.osgi.framework.hooks.weaving.WovenClass;
1:7dabe8c: import org.osgi.framework.wiring.BundleRevision;
1:c1f1260: import org.osgi.framework.wiring.BundleWiring;
1:c1f1260: 
1:c1f1260: public class ClientWeavingHookTest {
1:a8ccbc9:     DynamicWeavingActivator activator;
1:a8ccbc9: 
1:67d07ab:     private static final String thisJVMsDBF = DocumentBuilderFactory.newInstance().getClass().getName();
1:c1f1260: 
1:c1f1260:     @Before
1:c1f1260:     public void setUp() {
1:a8ccbc9:         activator = new DynamicWeavingActivator();
1:a8ccbc9:         BaseActivator.activator = activator;
4:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     @After
1:c1f1260:     public void tearDown() {
1:a8ccbc9:         BaseActivator.activator = null;
1:a8ccbc9:         activator = null;
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     @Test
1:c7183ef:     public void testBasicServiceLoaderUsage() throws Exception {
1:c1f1260:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
1:4376217:         consumerHeaders.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1:64b99d8: 
1:c1f1260:         // Register the bundle that provides the SPI implementation.
1:a8ccbc9:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1:a8ccbc9: 
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:c1f1260: 
1:a8ccbc9:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:a8ccbc9: 
1:c1f1260:         // Weave the TestClient class.
1:c1f1260:         URL clsUrl = getClass().getResource("TestClient.class");
1:c1f1260:         Assert.assertNotNull("Precondition", clsUrl);
1:a8ccbc9: 
1:a8ccbc9:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:a8ccbc9:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:c1f1260:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:c1f1260:         wh.weave(wc);
1:c1f1260:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:c1f1260:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:c1f1260:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:c1f1260:         String di = wc.getDynamicImports().get(0);
1:a8ccbc9:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1:a8ccbc9: 
1:64b99d8:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:c1f1260:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {String.class});
1:c1f1260:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Assert.assertEquals(Collections.singleton("olleh"), result);
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     @Test
1:64b99d8:     public void testTCCLResetting() throws Exception {
1:64b99d8:         ClassLoader cl = new URLClassLoader(new URL [] {});
1:64b99d8:         Thread.currentThread().setContextClassLoader(cl);
1:64b99d8:         Assert.assertSame("Precondition", cl, Thread.currentThread().getContextClassLoader());
1:64b99d8: 
1:64b99d8:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
1:64b99d8:         consumerHeaders.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1:64b99d8: 
1:64b99d8:         // Register the bundle that provides the SPI implementation.
1:64b99d8:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1:64b99d8: 
1:64b99d8:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
1:64b99d8:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:64b99d8: 
1:64b99d8:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:64b99d8:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:64b99d8: 
1:64b99d8:         // Weave the TestClient class.
1:64b99d8:         URL clsUrl = getClass().getResource("TestClient.class");
1:64b99d8:         Assert.assertNotNull("Precondition", clsUrl);
1:64b99d8: 
1:64b99d8:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:64b99d8:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:64b99d8:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:64b99d8:         wh.weave(wc);
1:64b99d8:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:64b99d8:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:64b99d8:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:64b99d8:         String di = wc.getDynamicImports().get(0);
1:64b99d8:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1:c1f1260: 
1:64b99d8:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:64b99d8:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:64b99d8:         Class<?> cls = wc.getDefinedClass();
1:64b99d8:         Method method = cls.getMethod("test", new Class [] {String.class});
1:64b99d8:         method.invoke(cls.newInstance(), "hi there");
1:64b99d8: 
1:64b99d8:         Assert.assertSame(cl, Thread.currentThread().getContextClassLoader());
1:64b99d8:     }
1:64b99d8: 
1:64b99d8:     @Test
1:64b99d8:     public void testTCCLResettingOnException() {
1:64b99d8:         // TODO
1:64b99d8:     }
1:64b99d8: 
1:64b99d8:     @Test
1:64b99d8:     public void testAltServiceLoaderLoadUnprocessed() throws Exception {
1:a8ccbc9:         Bundle spiFlyBundle = mockSpiFlyBundle();
1:a8ccbc9: 
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:4376217:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, spiFlyBundle);
1:c144094: 
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:a8ccbc9: 
1:c1f1260:         // Weave the TestClient class.
1:c1f1260:         URL clsUrl = getClass().getResource("UnaffectedTestClient.class");
1:c1f1260:         Assert.assertNotNull("Precondition", clsUrl);
1:c144094:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.UnaffectedTestClient", consumerBundle);
1:c1f1260:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:c1f1260:         wh.weave(wc);
1:c1f1260: 
1:a8ccbc9:         Assert.assertEquals("The client is not affected so no additional imports should have been added",
1:c1f1260:             0, wc.getDynamicImports().size());
1:a8ccbc9: 
1:c1f1260:         // ok the weaving is done, now prepare the registry for the call
1:a8ccbc9:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1:a8ccbc9: 
1:a8ccbc9:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:c1f1260:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {String.class});
1:c1f1260:         Object result = method.invoke(cls.newInstance(), "hello");
1:c1f1260:         Assert.assertEquals("impl4", result);
1:c1f1260:     }
1:c1f1260: 
1:c1f1260:     @Test
1:64b99d8:     public void testMultipleProviders() throws Exception {
2:c1f1260:         Bundle spiFlyBundle = mockSpiFlyBundle();
1:c1f1260: 
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:4376217:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1:c1f1260: 
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, spiFlyBundle);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:c1f1260: 
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:c1f1260: 
1:c1f1260:         // Weave the TestClient class.
1:c1f1260:         URL clsUrl = getClass().getResource("TestClient.class");
1:3aef914:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:c1f1260: 
1:c1f1260:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:c1f1260:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:a8ccbc9: 
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:11803af:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:c1f1260: 
1:a8ccbc9:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:c1f1260:         // META-INF/services/org.apache.aries.mytest.MySPI files from impl1 and impl2 are visible.
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {String.class});
1:c1f1260:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "HELLO", "5"));
1:11803af:         Assert.assertEquals("All three services should be invoked", expected, result);
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     @Test
1:c1f1260:     public void testClientSpecifyingProvider() throws Exception {
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:c1f1260:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "java.util.ServiceLoader#load(java.lang.Class);bundle=impl2");
1:c1f1260: 
1:c1f1260:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:c1f1260:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:c1f1260: 
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:f886534: 
1:a8ccbc9:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2);
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:c1f1260: 
1:c1f1260:         // Weave the TestClient class.
1:c1f1260:         URL clsUrl = getClass().getResource("TestClient.class");
1:f886534:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:c1f1260: 
1:a8ccbc9:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:c1f1260:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {String.class});
1:c1f1260:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Set<String> expected = new HashSet<String>(Arrays.asList("HELLO", "5"));
1:11803af:         Assert.assertEquals("Only the services from bundle impl2 should be selected", expected, result);
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     @Test
1:c1f1260:     public void testClientSpecifyingProviderVersion() throws Exception {
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:c1f1260:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "java.util.ServiceLoader#load(java.lang.Class);bundle=impl2:version=1.2.3");
1:c1f1260: 
1:c1f1260:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:c1f1260:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:c1f1260:         Bundle providerBundle3 = mockProviderBundle("impl2_123", 3, new Version(1, 2, 3));
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle3, new HashMap<String, Object>());
1:c1f1260: 
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle3);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:a8ccbc9:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle3);
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:c1f1260: 
1:c1f1260:         // Weave the TestClient class.
1:c1f1260:         URL clsUrl = getClass().getResource("TestClient.class");
1:f886534:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:c1f1260: 
1:a8ccbc9:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:c1f1260:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {String.class});
1:c1f1260:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Assert.assertEquals("Only the services from bundle impl2 should be selected", Collections.singleton("Updated!hello!Updated"), result);
1:c1f1260:     }
1:c1f1260: 
1:c1f1260:     @Test
1:c1f1260:     public void testClientMultipleTargetBundles() throws Exception {
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:a8ccbc9:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
1:c1f1260:                 "java.util.ServiceLoader#load(java.lang.Class);bundle=impl1|impl4");
1:c1f1260: 
1:c1f1260:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:c1f1260:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:c1f1260:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
1:c1f1260: 
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:a8ccbc9:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:5023775: 
1:c1f1260:         // Weave the TestClient class.
1:c1f1260:         URL clsUrl = getClass().getResource("TestClient.class");
1:f886534:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:a8ccbc9: 
1:a8ccbc9:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:c1f1260:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {String.class});
1:c1f1260:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "impl4"));
1:11803af:         Assert.assertEquals("All providers should be selected for this one", expected, result);
1:c1f1260:     }
1:c1f1260: 
1:c1f1260:     @Test
1:c1f1260:     public void testClientMultipleTargetBundles2() throws Exception {
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:a8ccbc9:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
1:c1f1260:                 "java.util.ServiceLoader#load(java.lang.Class);bundleId=1|4");
1:c1f1260: 
1:c1f1260:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:c1f1260:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:c1f1260:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
1:c1f1260: 
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:a8ccbc9:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:c1f1260: 
1:c1f1260:         // Weave the TestClient class.
1:c1f1260:         URL clsUrl = getClass().getResource("TestClient.class");
1:f886534:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:c1f1260: 
1:a8ccbc9:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:c1f1260:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {String.class});
1:c1f1260:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "impl4"));
1:11803af:         Assert.assertEquals("All providers should be selected for this one", expected, result);
1:c1f1260:     }
1:c1f1260: 
1:c1f1260:     @Test
1:c1f1260:     public void testClientSpecificProviderLoadArgument() throws Exception {
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:a8ccbc9:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
1:c1f1260:                 "java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.MySPI])," +
1:c1f1260:                 "java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.AltSPI]);bundle=impl4");
1:c1f1260: 
1:c1f1260:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:c1f1260:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:c1f1260:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
1:c1f1260: 
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:c1f1260: 
1:a8ccbc9:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:c1f1260: 
1:c1f1260:         // Weave the TestClient class.
1:c1f1260:         URL clsUrl = getClass().getResource("TestClient.class");
1:f886534:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:c1f1260: 
1:a8ccbc9:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:c1f1260:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {String.class});
1:c1f1260:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "impl4", "HELLO", "5"));
1:11803af:         Assert.assertEquals("All providers should be selected for this one", expected, result);
1:c1f1260: 
1:c1f1260:         // Weave the AltTestClient class.
1:c1f1260:         URL cls2Url = getClass().getResource("AltTestClient.class");
1:3aef914:         WovenClass wc2 = new MyWovenClass(cls2Url, "org.apache.aries.spifly.dynamic.AltTestClient", consumerBundle);
1:c1f1260:         wh.weave(wc2);
1:c1f1260: 
1:c1f1260:         // Invoke the AltTestClient
1:c1f1260:         Class<?> cls2 = wc2.getDefinedClass();
1:c1f1260:         Method method2 = cls2.getMethod("test", new Class [] {long.class});
1:c1f1260:         Object result2 = method2.invoke(cls2.newInstance(), 4096);
1:a166d95:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L, result2);
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     @Test
1:c1f1260:     public void testClientSpecifyingDifferentMethodsLimitedToDifferentProviders() throws Exception {
1:c1f1260:         Dictionary<String, String> headers1 = new Hashtable<String, String>();
1:a8ccbc9:         headers1.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
1:c1f1260:                 "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundle=impl3," +
1:c1f1260:                 "java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.MySPI]);bundle=impl4");
1:c1f1260: 
1:c1f1260:         Dictionary<String, String> headers2 = new Hashtable<String, String>();
1:a8ccbc9:         headers2.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
1:c1f1260:                 "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundle=system.bundle," +
1:c1f1260:                 "java.util.ServiceLoader#load;bundle=impl1");
1:c1f1260: 
1:c1f1260:         Dictionary<String, String> headers3 = new Hashtable<String, String>();
1:a8ccbc9:         headers3.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
1:c1f1260:                 "org.acme.blah#someMethod();bundle=mybundle");
1:c1f1260: 
1:c1f1260:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:c1f1260:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:c1f1260:         Bundle providerBundle3 = mockProviderBundle("impl3", 3);
1:c1f1260:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle3, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
1:a8ccbc9: 
1:c1f1260:         Bundle consumerBundle1 = mockConsumerBundle(headers1, providerBundle1, providerBundle2, providerBundle3, providerBundle4);
1:f886534:         activator.addConsumerWeavingData(consumerBundle1, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:c1f1260:         Bundle consumerBundle2 = mockConsumerBundle(headers2, providerBundle1, providerBundle2, providerBundle3, providerBundle4);
1:f886534:         activator.addConsumerWeavingData(consumerBundle2, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:c1f1260:         Bundle consumerBundle3 = mockConsumerBundle(headers3, providerBundle1, providerBundle2, providerBundle3, providerBundle4);
1:f886534:         activator.addConsumerWeavingData(consumerBundle3, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:c1f1260:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle1, consumerBundle2, consumerBundle3,
1:c1f1260:                 providerBundle1, providerBundle2, providerBundle3, providerBundle4);
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:a8ccbc9: 
1:11803af:         testConsumerBundleWeaving(consumerBundle1, wh, Collections.singleton("impl4"), "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory");
1:11803af:         testConsumerBundleWeaving(consumerBundle2, wh, Collections.singleton("olleh"), thisJVMsDBF);
1:11803af:         testConsumerBundleWeaving(consumerBundle3, wh, Collections.<String>emptySet(), thisJVMsDBF);
1:c1f1260:     }
1:c1f1260: 
1:11803af:     private void testConsumerBundleWeaving(Bundle consumerBundle, WeavingHook wh, Set<String> testClientResult, String jaxpClientResult) throws Exception {
1:c1f1260:         // Weave the TestClient class.
1:c1f1260:         URL clsUrl = getClass().getResource("TestClient.class");
1:35182c2:         WovenClass wc = new MyWovenClass(clsUrl, TestClient.class.getName(), consumerBundle);
1:c1f1260:         wh.weave(wc);
1:c1f1260: 
1:a8ccbc9:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:c1f1260:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {String.class});
1:c1f1260:         Object result = method.invoke(cls.newInstance(), "hello");
1:a8ccbc9:         Assert.assertEquals(testClientResult, result);
1:a8ccbc9: 
1:c1f1260:         URL clsUrl2 = getClass().getResource("JaxpClient.class");
1:35182c2:         WovenClass wc2 = new MyWovenClass(clsUrl2, JaxpClient.class.getName(), consumerBundle);
1:c1f1260:         wh.weave(wc2);
1:a8ccbc9: 
1:c1f1260:         Class<?> cls2 = wc2.getDefinedClass();
1:c1f1260:         Method method2 = cls2.getMethod("test", new Class [] {});
1:c1f1260:         Class<?> result2 = (Class<?>) method2.invoke(cls2.newInstance());
1:c1f1260:         Assert.assertEquals(jaxpClientResult, result2.getName());
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     @Test
1:c1f1260:     public void testJAXPClientWantsJREImplementation1() throws Exception {
1:c1f1260:         Bundle systembundle = mockSystemBundle();
1:c1f1260: 
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:c1f1260:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance()");
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, systembundle);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:c1f1260: 
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, systembundle).getBundleContext(), activator);
1:c1f1260: 
1:c1f1260:         URL clsUrl = getClass().getResource("JaxpClient.class");
1:1e227e5:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:a8ccbc9: 
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {});
1:c1f1260:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
1:67d07ab:         Assert.assertEquals("JAXP implementation from JRE", thisJVMsDBF, result.getName());
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     // If there is an alternate implementation it should always be favoured over the JRE one
1:c1f1260:     @Test
1:c1f1260:     public void testJAXPClientWantsAltImplementation1() throws Exception {
1:c1f1260:         Bundle systembundle = mockSystemBundle();
1:c1f1260: 
1:c1f1260:         Bundle providerBundle = mockProviderBundle("impl3", 1);
1:7158c23:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle, new HashMap<String, Object>());
1:c1f1260: 
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:c1f1260:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance()");
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle, systembundle);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:c1f1260: 
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext(), activator);
1:a8ccbc9: 
1:c1f1260:         URL clsUrl = getClass().getResource("JaxpClient.class");
1:1e227e5:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:c1f1260: 
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {});
1:c1f1260:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
1:fe27003:         Assert.assertEquals("JAXP implementation from JRE", "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory", result.getName());
1:c1f1260:     }
1:c1f1260: 
1:c1f1260:     @Test
1:c1f1260:     public void testJAXPClientWantsJREImplementation2() throws Exception {
1:c1f1260:         Bundle systembundle = mockSystemBundle();
1:a8ccbc9: 
1:c1f1260:         Bundle providerBundle = mockProviderBundle("impl3", 1);
1:7158c23:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle, new HashMap<String, Object>());
1:c1f1260: 
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:c1f1260:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundleId=0");
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle, systembundle);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:a8ccbc9: 
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext(), activator);
1:c1f1260: 
1:c1f1260:         URL clsUrl = getClass().getResource("JaxpClient.class");
1:1e227e5:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:c1f1260: 
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {});
1:c1f1260:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
1:67d07ab:         Assert.assertEquals("JAXP implementation from JRE", thisJVMsDBF, result.getName());
1:c1f1260:     }
1:c1f1260: 
1:c1f1260:     @Test
1:c1f1260:     public void testJAXPClientWantsAltImplementation2() throws Exception {
1:c1f1260:         Bundle systembundle = mockSystemBundle();
1:c1f1260: 
1:c1f1260:         Bundle providerBundle = mockProviderBundle("impl3", 1);
1:7158c23:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle, new HashMap<String, Object>());
1:c1f1260: 
1:c1f1260:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:c1f1260:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundle=impl3");
1:c1f1260:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle, systembundle);
1:f886534:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:a8ccbc9: 
1:a8ccbc9:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext(), activator);
1:a8ccbc9: 
1:c1f1260:         URL clsUrl = getClass().getResource("JaxpClient.class");
1:1e227e5:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
1:c1f1260:         wh.weave(wc);
1:a8ccbc9: 
1:c1f1260:         Class<?> cls = wc.getDefinedClass();
1:c1f1260:         Method method = cls.getMethod("test", new Class [] {});
1:c1f1260:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
1:fe27003:         Assert.assertEquals("JAXP implementation from alternative bundle", "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory", result.getName());
1:c1f1260:     }
1:c1f1260: 
1:c1f1260:     private Bundle mockSpiFlyBundle(Bundle ... bundles) throws Exception {
1:c1f1260:         return mockSpiFlyBundle("spifly", new Version(1, 0, 0), bundles);
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     private Bundle mockSpiFlyBundle(String bsn, Version version, Bundle ... bundles) throws Exception {
1:c1f1260:         Bundle spiFlyBundle = EasyMock.createMock(Bundle.class);
1:c1f1260: 
1:c1f1260:         BundleContext spiFlyBundleContext = EasyMock.createMock(BundleContext.class);
1:c1f1260:         EasyMock.expect(spiFlyBundleContext.getBundle()).andReturn(spiFlyBundle).anyTimes();
1:c1f1260:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(bundles));
1:c1f1260:         allBundles.add(spiFlyBundle);
1:c1f1260:         EasyMock.expect(spiFlyBundleContext.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:c1f1260:         EasyMock.replay(spiFlyBundleContext);
1:c1f1260: 
1:c1f1260:         EasyMock.expect(spiFlyBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:c1f1260:         EasyMock.expect(spiFlyBundle.getVersion()).andReturn(version).anyTimes();
1:f886534:         EasyMock.expect(spiFlyBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:c1f1260:         EasyMock.expect(spiFlyBundle.getBundleContext()).andReturn(spiFlyBundleContext).anyTimes();
1:c1f1260:         EasyMock.replay(spiFlyBundle);
1:c1f1260: 
1:c1f1260:         // Set the bundle context for testing purposes
1:a8ccbc9:         Field bcField = BaseActivator.class.getDeclaredField("bundleContext");
1:c1f1260:         bcField.setAccessible(true);
1:a8ccbc9:         bcField.set(activator, spiFlyBundle.getBundleContext());
1:a8ccbc9: 
1:c1f1260:         return spiFlyBundle;
1:c1f1260:     }
1:5ed7a90: 
1:5ed7a90:     private Bundle mockProviderBundle(String subdir, long id) throws Exception {
1:c1f1260:         return mockProviderBundle(subdir, id, Version.emptyVersion);
1:c1f1260:     }
1:a8ccbc9: 
1:5ed7a90:     private Bundle mockProviderBundle(String subdir, long id, Version version) throws Exception {
1:5ed7a90:         URL url = getClass().getResource("/" + getClass().getName().replace('.', '/') + ".class");
1:5ed7a90:         File classFile = new File(url.getFile());
1:5ed7a90:         File baseDir = new File(classFile.getParentFile(), subdir);
1:5ed7a90:         File directory = new File(baseDir, "/META-INF/services");
1:a8ccbc9:         final List<String> classNames = new ArrayList<String>();
1:5ed7a90: 
1:5ed7a90:         // Do a directory listing of the applicable META-INF/services directory
1:5ed7a90:         List<String> resources = new ArrayList<String>();
1:5ed7a90:         for (File f : directory.listFiles()) {
1:5ed7a90:             String fileName = f.getName();
1:5ed7a90:             if (fileName.startsWith(".") || fileName.endsWith("."))
1:5ed7a90:                 continue;
1:a8ccbc9: 
1:a8ccbc9:             classNames.addAll(getClassNames(f));
1:a8ccbc9: 
1:5ed7a90:             // Needs to be something like: META-INF/services/org.apache.aries.mytest.MySPI
1:5ed7a90:             String path = f.getAbsolutePath().substring(baseDir.getAbsolutePath().length());
1:5ed7a90:             path = path.replace('\\', '/');
1:5ed7a90:             if (path.startsWith("/")) {
1:5ed7a90:                 path = path.substring(1);
1:c1f1260:             }
1:5ed7a90:             resources.add(path);
1:c1f1260:         }
1:a8ccbc9: 
1:a8ccbc9:         // Set up the classloader that will be used by the ASM-generated code as the TCCL.
1:c1f1260:         // It can load a META-INF/services file
1:c144094:         final ClassLoader cl = new TestProviderBundleClassLoader(subdir, resources.toArray(new String [] {}));
1:a8ccbc9: 
1:35182c2:         final List<String> classResources = new ArrayList<String>();
1:a8ccbc9:         for(String className : classNames) {
1:a8ccbc9:             classResources.add("/" + className.replace('.', '/') + ".class");
1:a8ccbc9:         }
1:0a02617: 
1:0a02617:         BundleContext bc = EasyMock.createNiceMock(BundleContext.class);
1:0a02617:         EasyMock.replay(bc);
1:0a02617: 
1:c1f1260:         Bundle providerBundle = EasyMock.createMock(Bundle.class);
1:c1f1260:         String bsn = subdir;
1:c1f1260:         int idx = bsn.indexOf('_');
1:c1f1260:         if (idx > 0) {
1:c1f1260:             bsn = bsn.substring(0, idx);
1:c1f1260:         }
1:c1f1260:         EasyMock.expect(providerBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:c1f1260:         EasyMock.expect(providerBundle.getBundleId()).andReturn(id).anyTimes();
1:0a02617:         EasyMock.expect(providerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:c1f1260:         EasyMock.expect(providerBundle.getVersion()).andReturn(version).anyTimes();
1:35182c2:         EasyMock.expect(providerBundle.getEntryPaths("/")).andAnswer(new IAnswer<Enumeration<String>>() {
1:35182c2:             @Override
1:35182c2:             public Enumeration<String> answer() throws Throwable {
1:35182c2:                 return Collections.enumeration(classResources);
1:35182c2:             }
1:35182c2:         }).anyTimes();
1:a8ccbc9:         EasyMock.<Class<?>>expect(providerBundle.loadClass(EasyMock.anyObject(String.class))).andAnswer(new IAnswer<Class<?>>() {
1:a8ccbc9:             @Override
1:a8ccbc9:             public Class<?> answer() throws Throwable {
1:a8ccbc9:                 String  name = (String) EasyMock.getCurrentArguments()[0];
1:a8ccbc9:                 if (!classNames.contains(name)) {
1:a8ccbc9:                     throw new ClassCastException(name);
1:a8ccbc9:                 }
1:a8ccbc9:                 return cl.loadClass(name);
1:a8ccbc9:             }
1:a8ccbc9:         }).anyTimes();
1:c1f1260:         EasyMock.replay(providerBundle);
1:c1f1260:         return providerBundle;
1:c1f1260:     }
1:5ed7a90: 
1:a8ccbc9:     private Collection<String> getClassNames(File f) throws IOException {
1:a8ccbc9:         List<String> names = new ArrayList<String>();
1:a8ccbc9: 
1:a8ccbc9:         BufferedReader br = new BufferedReader(new FileReader(f));
1:a8ccbc9:         try {
1:a8ccbc9:             String line = null;
1:a8ccbc9:             while((line = br.readLine()) != null) {
1:a8ccbc9:                 names.add(line.trim());
1:a8ccbc9:             }
1:a8ccbc9:         } finally {
1:a8ccbc9:             br.close();
1:a8ccbc9:         }
1:a8ccbc9:         return names;
1:a8ccbc9:     }
1:a8ccbc9: 
1:c1f1260:     private Bundle mockConsumerBundle(Dictionary<String, String> headers, Bundle ... otherBundles) {
1:a8ccbc9:         // Create a mock object for the client bundle which holds the code that uses ServiceLoader.load()
1:c1f1260:         // or another SPI invocation.
1:c1f1260:         BundleContext bc = EasyMock.createMock(BundleContext.class);
1:a8ccbc9: 
1:c1f1260:         Bundle consumerBundle = EasyMock.createMock(Bundle.class);
1:c1f1260:         EasyMock.expect(consumerBundle.getSymbolicName()).andReturn("testConsumer").anyTimes();
1:c1f1260:         EasyMock.expect(consumerBundle.getHeaders()).andReturn(headers).anyTimes();
1:c1f1260:         EasyMock.expect(consumerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:c1f1260:         EasyMock.expect(consumerBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:7dabe8c:         EasyMock.expect(consumerBundle.adapt(BundleRevision.class)).andReturn(null).anyTimes();
1:a8ccbc9:         EasyMock.replay(consumerBundle);
1:5ed7a90: 
1:c1f1260:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(otherBundles));
1:c1f1260:         allBundles.add(consumerBundle);
1:c1f1260:         EasyMock.expect(bc.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:c1f1260:         EasyMock.replay(bc);
1:c1f1260: 
1:c1f1260:         return consumerBundle;
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     private Bundle mockSystemBundle() {
1:c1f1260:         Bundle systemBundle = EasyMock.createMock(Bundle.class);
1:c1f1260:         EasyMock.expect(systemBundle.getBundleId()).andReturn(0L).anyTimes();
1:c1f1260:         EasyMock.expect(systemBundle.getSymbolicName()).andReturn("system.bundle").anyTimes();
1:c1f1260:         EasyMock.replay(systemBundle);
1:a8ccbc9: 
1:c1f1260:         return systemBundle;
1:c1f1260:     }
1:a8ccbc9: 
1:c144094:     // A classloader that loads anything starting with org.apache.aries.spifly.dynamic.impl1 from it
1:c144094:     // and the rest from the parent. This is to mimic a bundle that holds a specific SPI implementation.
1:c144094:     public static class TestProviderBundleClassLoader extends URLClassLoader {
1:c1f1260:         private final List<String> resources;
1:c1f1260:         private final String prefix;
1:c144094:         private final String classPrefix;
1:c144094:         private final Map<String, Class<?>> loadedClasses = new ConcurrentHashMap<String, Class<?>>();
1:a8ccbc9: 
1:c144094:         public TestProviderBundleClassLoader(String subdir, String ... resources) {
1:c144094:             super(new URL [] {}, TestProviderBundleClassLoader.class.getClassLoader());
1:a8ccbc9: 
1:c144094:             this.prefix = TestProviderBundleClassLoader.class.getPackage().getName().replace('.', '/') + "/" + subdir + "/";
1:c144094:             this.classPrefix = prefix.replace('/', '.');
1:c1f1260:             this.resources = Arrays.asList(resources);
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c144094:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:c144094:             if (name.startsWith(classPrefix))
1:c144094:                 return loadClassLocal(name);
1:c144094: 
1:c144094:             return super.loadClass(name);
1:c144094:         }
1:c144094: 
1:c144094:         @Override
1:c144094:         protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
1:c144094:             if (name.startsWith(classPrefix)) {
1:c144094:                 Class<?> cls = loadClassLocal(name);
1:c144094:                 if (resolve)
1:c144094:                     resolveClass(cls);
1:c144094: 
1:c144094:                 return cls;
1:c144094:             }
1:c144094: 
1:c144094:             return super.loadClass(name, resolve);
1:c144094:         }
1:c144094: 
1:c144094:         protected Class<?> loadClassLocal(String name) throws ClassNotFoundException {
1:c144094:             Class<?> prevLoaded = loadedClasses.get(name);
1:c144094:             if (prevLoaded != null)
1:c144094:                 return prevLoaded;
1:c144094: 
1:c144094:             URL res = TestProviderBundleClassLoader.class.getClassLoader().getResource(name.replace('.', '/') + ".class");
1:c144094:             try {
1:c144094:                 byte[] bytes = Streams.suck(res.openStream());
1:c144094:                 Class<?> cls = defineClass(name, bytes, 0, bytes.length);
1:c144094:                 loadedClasses.put(name, cls);
1:c144094:                 return cls;
1:c144094:             } catch (Exception e) {
1:c144094:                 throw new ClassNotFoundException(name, e);
1:c144094:             }
1:c144094:         }
1:c144094: 
1:c144094:         @Override
1:c1f1260:         public URL findResource(String name) {
1:c1f1260:             if (resources.contains(name)) {
1:c1f1260:                 return getClass().getClassLoader().getResource(prefix + name);
1:c1f1260:             } else {
1:c1f1260:                 return super.findResource(name);
1:c1f1260:             }
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public Enumeration<URL> findResources(String name) throws IOException {
1:c1f1260:             if (resources.contains(name)) {
1:c1f1260:                 return getClass().getClassLoader().getResources(prefix + name);
1:c1f1260:             } else {
1:c1f1260:                 return super.findResources(name);
1:a8ccbc9:             }
1:c1f1260:         }
1:c1f1260:     }
1:c1f1260: 
1:c1f1260:     private static class MyWovenClass implements WovenClass {
1:c1f1260:         byte [] bytes;
1:c1f1260:         final String className;
1:c1f1260:         final Bundle bundleContainingOriginalClass;
1:c1f1260:         List<String> dynamicImports = new ArrayList<String>();
1:c1f1260:         boolean weavingComplete = false;
1:a8ccbc9: 
1:c1f1260:         private MyWovenClass(URL clazz, String name, Bundle bundle) throws Exception {
1:c1f1260:             bytes = Streams.suck(clazz.openStream());
1:c1f1260:             className = name;
1:c1f1260:             bundleContainingOriginalClass = bundle;
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public byte[] getBytes() {
1:c1f1260:             return bytes;
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public void setBytes(byte[] newBytes) {
1:c1f1260:             bytes = newBytes;
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public List<String> getDynamicImports() {
1:c1f1260:             return dynamicImports;
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public boolean isWeavingComplete() {
1:c1f1260:             return weavingComplete;
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public String getClassName() {
1:c1f1260:             return className;
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public ProtectionDomain getProtectionDomain() {
1:c1f1260:             return null;
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public Class<?> getDefinedClass() {
1:c1f1260:             try {
1:c1f1260:                 weavingComplete = true;
1:c1f1260:                 return new MyWovenClassClassLoader(className, getBytes(), getClass().getClassLoader(), bundleContainingOriginalClass).loadClass(className);
1:c1f1260:             } catch (ClassNotFoundException e) {
1:c1f1260:                 e.printStackTrace();
1:c1f1260:                 return null;
1:c1f1260:             }
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public BundleWiring getBundleWiring() {
2:c1f1260:             BundleWiring bw = EasyMock.createMock(BundleWiring.class);
1:c1f1260:             EasyMock.expect(bw.getBundle()).andReturn(bundleContainingOriginalClass);
1:c7183ef:             EasyMock.expect(bw.getClassLoader()).andReturn(getClass().getClassLoader());
2:c1f1260:             EasyMock.replay(bw);
1:c1f1260:             return bw;
1:c1f1260:         }
1:c1f1260:     }
1:a8ccbc9: 
1:c1f1260:     private static class MyWovenClassClassLoader extends ClassLoader implements BundleReference {
1:c1f1260:         private final String className;
1:c1f1260:         private final Bundle bundle;
1:c1f1260:         private final byte [] bytes;
1:3aef914:         private Class<?> wovenClass;
1:a8ccbc9: 
1:c1f1260:         public MyWovenClassClassLoader(String className, byte[] bytes, ClassLoader parent, Bundle bundle) {
1:c1f1260:             super(parent);
1:a8ccbc9: 
1:c1f1260:             this.className = className;
1:c1f1260:             this.bundle = bundle;
1:a8ccbc9:             this.bytes = bytes;
1:c1f1260:         }
1:a8ccbc9: 
1:c1f1260:         @Override
1:c1f1260:         protected synchronized Class<?> loadClass(String name, boolean resolve)
1:c1f1260:                 throws ClassNotFoundException {
1:c1f1260:             if (name.equals(className)) {
1:3aef914:                 if (wovenClass == null)
1:3aef914:                     wovenClass = defineClass(className, bytes, 0, bytes.length);
1:3aef914: 
1:3aef914:                 return wovenClass;
1:c1f1260:             } else {
1:c1f1260:                 return super.loadClass(name, resolve);
1:c1f1260:             }
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:c1f1260:             return loadClass(name, false);
1:c1f1260:         }
1:c1f1260: 
1:c1f1260:         @Override
1:c1f1260:         public Bundle getBundle() {
1:c1f1260:             return bundle;
1:a8ccbc9:         }
1:c1f1260:     }
1:c1f1260: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:7dabe8c
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.BundleRevision;
/////////////////////////////////////////////////////////////////////////
1:         EasyMock.expect(consumerBundle.adapt(BundleRevision.class)).andReturn(null).anyTimes();
commit:11803af
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals(Collections.singleton("olleh"), result);
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "HELLO", "5"));
1:         Assert.assertEquals("All three services should be invoked", expected, result);
/////////////////////////////////////////////////////////////////////////
1:         Set<String> expected = new HashSet<String>(Arrays.asList("HELLO", "5"));
1:         Assert.assertEquals("Only the services from bundle impl2 should be selected", expected, result);
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("Only the services from bundle impl2 should be selected", Collections.singleton("Updated!hello!Updated"), result);
/////////////////////////////////////////////////////////////////////////
1:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "impl4"));
1:         Assert.assertEquals("All providers should be selected for this one", expected, result);
/////////////////////////////////////////////////////////////////////////
1:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "impl4"));
1:         Assert.assertEquals("All providers should be selected for this one", expected, result);
/////////////////////////////////////////////////////////////////////////
1:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "impl4", "HELLO", "5"));
1:         Assert.assertEquals("All providers should be selected for this one", expected, result);
/////////////////////////////////////////////////////////////////////////
1:         testConsumerBundleWeaving(consumerBundle1, wh, Collections.singleton("impl4"), "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory");
1:         testConsumerBundleWeaving(consumerBundle2, wh, Collections.singleton("olleh"), thisJVMsDBF);
1:         testConsumerBundleWeaving(consumerBundle3, wh, Collections.<String>emptySet(), thisJVMsDBF);
1:     private void testConsumerBundleWeaving(Bundle consumerBundle, WeavingHook wh, Set<String> testClientResult, String jaxpClientResult) throws Exception {
commit:e9a5257
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.spifly.SpiFlyConstants;
commit:a166d95
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L, result2);
commit:c7183ef
/////////////////////////////////////////////////////////////////////////
1:     public void testBasicServiceLoaderUsage() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             EasyMock.expect(bw.getClassLoader()).andReturn(getClass().getClassLoader());
commit:0a02617
/////////////////////////////////////////////////////////////////////////
1: 
1:         BundleContext bc = EasyMock.createNiceMock(BundleContext.class);
1:         EasyMock.replay(bc);
1: 
/////////////////////////////////////////////////////////////////////////
1:         EasyMock.expect(providerBundle.getBundleContext()).andReturn(bc).anyTimes();
commit:7158c23
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle3, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle3, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle, new HashMap<String, Object>());
commit:64b99d8
/////////////////////////////////////////////////////////////////////////
0:     public void testBasicServiveLoaderUsage() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         // Invoke the woven class and check that it properly sets the TCCL so that the
/////////////////////////////////////////////////////////////////////////
1:     public void testTCCLResetting() throws Exception {
1:         ClassLoader cl = new URLClassLoader(new URL [] {});
1:         Thread.currentThread().setContextClassLoader(cl);
1:         Assert.assertSame("Precondition", cl, Thread.currentThread().getContextClassLoader());
1: 
1:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
1:         consumerHeaders.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1: 
1:         // Register the bundle that provides the SPI implementation.
1:         Bundle providerBundle = mockProviderBundle("impl1", 1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         Assert.assertNotNull("Precondition", clsUrl);
1: 
1:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:         wh.weave(wc);
1:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:         String di = wc.getDynamicImports().get(0);
1:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1: 
1:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         method.invoke(cls.newInstance(), "hi there");
1: 
1:         Assert.assertSame(cl, Thread.currentThread().getContextClassLoader());
1:     }
1: 
1:     @Test
1:     public void testTCCLResettingOnException() {
1:         // TODO
1:     }
1: 
1:     @Test
1:     public void testAltServiceLoaderLoadUnprocessed() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testMultipleProviders() throws Exception {
commit:5023775
/////////////////////////////////////////////////////////////////////////
1: 
commit:fe27003
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("JAXP implementation from JRE", "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory", result.getName());
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("JAXP implementation from alternative bundle", "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory", result.getName());
commit:35182c2
/////////////////////////////////////////////////////////////////////////
1:         WovenClass wc = new MyWovenClass(clsUrl, TestClient.class.getName(), consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         WovenClass wc2 = new MyWovenClass(clsUrl2, JaxpClient.class.getName(), consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         final List<String> classResources = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         EasyMock.expect(providerBundle.getEntryPaths("/")).andAnswer(new IAnswer<Enumeration<String>>() {
1:             @Override
1:             public Enumeration<String> answer() throws Throwable {
1:                 return Collections.enumeration(classResources);
1:             }
1:         }).anyTimes();
commit:1e227e5
/////////////////////////////////////////////////////////////////////////
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
commit:3aef914
/////////////////////////////////////////////////////////////////////////
1:         WovenClass wc2 = new MyWovenClass(cls2Url, "org.apache.aries.spifly.dynamic.AltTestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
0:         testConsumerBundleWeaving(consumerBundle1, wh, "impl4", "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory");
/////////////////////////////////////////////////////////////////////////
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
0:         WovenClass wc2 = new MyWovenClass(clsUrl2, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         private Class<?> wovenClass;
/////////////////////////////////////////////////////////////////////////
1:                 if (wovenClass == null)
1:                     wovenClass = defineClass(className, bytes, 0, bytes.length);
1: 
1:                 return wovenClass;
commit:f886534
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle1, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         activator.addConsumerWeavingData(consumerBundle2, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         activator.addConsumerWeavingData(consumerBundle3, SpiFlyConstants.SPI_CONSUMER_HEADER);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
/////////////////////////////////////////////////////////////////////////
1:         EasyMock.expect(spiFlyBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
commit:c144094
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.UnaffectedTestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1: 
0:         activator.addWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
1:         final ClassLoader cl = new TestProviderBundleClassLoader(subdir, resources.toArray(new String [] {}));
/////////////////////////////////////////////////////////////////////////
1:     // A classloader that loads anything starting with org.apache.aries.spifly.dynamic.impl1 from it
1:     // and the rest from the parent. This is to mimic a bundle that holds a specific SPI implementation.
1:     public static class TestProviderBundleClassLoader extends URLClassLoader {
1:         private final String classPrefix;
1:         private final Map<String, Class<?>> loadedClasses = new ConcurrentHashMap<String, Class<?>>();
1:         public TestProviderBundleClassLoader(String subdir, String ... resources) {
1:             super(new URL [] {}, TestProviderBundleClassLoader.class.getClassLoader());
1:             this.prefix = TestProviderBundleClassLoader.class.getPackage().getName().replace('.', '/') + "/" + subdir + "/";
1:             this.classPrefix = prefix.replace('/', '.');
1:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:             if (name.startsWith(classPrefix))
1:                 return loadClassLocal(name);
1: 
1:             return super.loadClass(name);
1:         }
1: 
1:         @Override
1:         protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
1:             if (name.startsWith(classPrefix)) {
1:                 Class<?> cls = loadClassLocal(name);
1:                 if (resolve)
1:                     resolveClass(cls);
1: 
1:                 return cls;
1:             }
1: 
1:             return super.loadClass(name, resolve);
1:         }
1: 
1:         protected Class<?> loadClassLocal(String name) throws ClassNotFoundException {
1:             Class<?> prevLoaded = loadedClasses.get(name);
1:             if (prevLoaded != null)
1:                 return prevLoaded;
1: 
1:             URL res = TestProviderBundleClassLoader.class.getClassLoader().getResource(name.replace('.', '/') + ".class");
1:             try {
1:                 byte[] bytes = Streams.suck(res.openStream());
1:                 Class<?> cls = defineClass(name, bytes, 0, bytes.length);
1:                 loadedClasses.put(name, cls);
1:                 return cls;
1:             } catch (Exception e) {
1:                 throw new ClassNotFoundException(name, e);
1:             }
1:         }
1: 
1:         @Override
commit:a8ccbc9
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.spifly.dynamic;
1: import java.io.BufferedReader;
1: import java.io.FileReader;
1: import java.util.Collection;
1: import java.util.Collections;
1: import org.apache.aries.spifly.BaseActivator;
1: import org.apache.aries.spifly.Streams;
1: import org.easymock.IAnswer;
/////////////////////////////////////////////////////////////////////////
1:     DynamicWeavingActivator activator;
1: 
1:         activator = new DynamicWeavingActivator();
1:         BaseActivator.activator = activator;
1: 
1:         BaseActivator.activator = null;
1:         activator = null;
1: 
1:         Bundle providerBundle = mockProviderBundle("impl1", 1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle);
0:         activator.addWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1: 
1:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
/////////////////////////////////////////////////////////////////////////
1:         Bundle spiFlyBundle = mockSpiFlyBundle();
1: 
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("The client is not affected so no additional imports should have been added",
1: 
1:         Bundle providerBundle = mockProviderBundle("impl1", 1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
/////////////////////////////////////////////////////////////////////////
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
/////////////////////////////////////////////////////////////////////////
0:         // Register in reverse order to make sure the order in which bundles are sorted is correct
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
0:         Assert.assertEquals("All three services should be invoked in the correct order", "ollehHELLO5", result);
1: 
/////////////////////////////////////////////////////////////////////////
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
0:         Assert.assertEquals("Only the services from bundle impl2 should be selected", "HELLO5", result);
1: 
/////////////////////////////////////////////////////////////////////////
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle3);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle3);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
0:         Assert.assertEquals("Only the services from bundle impl2 should be selected", "Updated!hello!Updated", result);
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
0:         Assert.assertEquals("All providers should be selected for this one", "ollehimpl4", result);
1: 
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
0:         Assert.assertEquals("All providers should be selected for this one", "ollehimpl4", result);
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
0:         Assert.assertEquals("All providers should be selected for this one", "ollehHELLO5impl4", result);
/////////////////////////////////////////////////////////////////////////
0:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L*4096L, result2);
1: 
1:         headers1.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
1:         headers2.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
1:         headers3.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle3);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1: 
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
0:         testConsumerBundleWeaving(consumerBundle1, wh, "impl4", "org.apache.aries.spifly.impl3.MyAltDocumentBuilderFactory");
0:         testConsumerBundleWeaving(consumerBundle2, wh, "olleh", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");
0:         testConsumerBundleWeaving(consumerBundle3, wh, "", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");
/////////////////////////////////////////////////////////////////////////
1: 
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         Assert.assertEquals(testClientResult, result);
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, systembundle).getBundleContext(), activator);
1: 
0:         Assert.assertEquals("JAXP implementation from JRE", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl", result.getName());
1: 
0:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle);
1:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext(), activator);
1: 
0:         Assert.assertEquals("JAXP implementation from JRE", "org.apache.aries.spifly.impl3.MyAltDocumentBuilderFactory", result.getName());
1: 
0:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle);
1:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext(), activator);
1: 
0:         Assert.assertEquals("JAXP implementation from JRE", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl", result.getName());
/////////////////////////////////////////////////////////////////////////
0:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle);
1: 
1:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext(), activator);
1: 
0:         Assert.assertEquals("JAXP implementation from alternative bundle", "org.apache.aries.spifly.impl3.MyAltDocumentBuilderFactory", result.getName());
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         Field bcField = BaseActivator.class.getDeclaredField("bundleContext");
1:         bcField.set(activator, spiFlyBundle.getBundleContext());
1: 
1: 
1:         final List<String> classNames = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1: 
1:             classNames.addAll(getClassNames(f));
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Set up the classloader that will be used by the ASM-generated code as the TCCL.
0:         final ClassLoader cl = new TestImplClassLoader(subdir, resources.toArray(new String [] {}));
1: 
1: 
0:         List<String> classResources = new ArrayList<String>();
1:         for(String className : classNames) {
1:             classResources.add("/" + className.replace('.', '/') + ".class");
1:         }
/////////////////////////////////////////////////////////////////////////
0:         EasyMock.expect(providerBundle.getEntryPaths("/")).andReturn(Collections.enumeration(classResources)).anyTimes();
1:         EasyMock.<Class<?>>expect(providerBundle.loadClass(EasyMock.anyObject(String.class))).andAnswer(new IAnswer<Class<?>>() {
1:             @Override
1:             public Class<?> answer() throws Throwable {
1:                 String  name = (String) EasyMock.getCurrentArguments()[0];
1:                 if (!classNames.contains(name)) {
1:                     throw new ClassCastException(name);
1:                 }
1:                 return cl.loadClass(name);
1:             }
1:         }).anyTimes();
1:     private Collection<String> getClassNames(File f) throws IOException {
1:         List<String> names = new ArrayList<String>();
1: 
1:         BufferedReader br = new BufferedReader(new FileReader(f));
1:         try {
1:             String line = null;
1:             while((line = br.readLine()) != null) {
1:                 names.add(line.trim());
1:             }
1:         } finally {
1:             br.close();
1:         }
1:         return names;
1:     }
1: 
1:         // Create a mock object for the client bundle which holds the code that uses ServiceLoader.load()
1: 
1:         EasyMock.replay(consumerBundle);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:             this.bytes = bytes;
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
commit:b1379cb
commit:4376217
/////////////////////////////////////////////////////////////////////////
1:         consumerHeaders.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
/////////////////////////////////////////////////////////////////////////
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
/////////////////////////////////////////////////////////////////////////
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
commit:5ed7a90
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
0: import java.net.MalformedURLException;
/////////////////////////////////////////////////////////////////////////
1:     private Bundle mockProviderBundle(String subdir, long id) throws Exception {
1:     private Bundle mockProviderBundle(String subdir, long id, Version version) throws Exception {
1:         URL url = getClass().getResource("/" + getClass().getName().replace('.', '/') + ".class");
1:         File classFile = new File(url.getFile());
1:         File baseDir = new File(classFile.getParentFile(), subdir);
1:         File directory = new File(baseDir, "/META-INF/services");
1: 
1:         // Do a directory listing of the applicable META-INF/services directory
1:         List<String> resources = new ArrayList<String>();
1:         for (File f : directory.listFiles()) {
1:             String fileName = f.getName();
1:             if (fileName.startsWith(".") || fileName.endsWith("."))
1:                 continue;
1:             
1:             
1:             // Needs to be something like: META-INF/services/org.apache.aries.mytest.MySPI
1:             String path = f.getAbsolutePath().substring(baseDir.getAbsolutePath().length());
1:             path = path.replace('\\', '/');
1:             if (path.startsWith("/")) {
1:                 path = path.substring(1);
1:             resources.add(path);
1:             
commit:c1f1260
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.aries.spifly;
1: 
1: import java.io.IOException;
1: import java.lang.reflect.Field;
1: import java.lang.reflect.Method;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.security.ProtectionDomain;
1: import java.util.ArrayList;
1: import java.util.Arrays;
0: import java.util.Collections;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
0: import java.util.HashSet;
1: import java.util.Hashtable;
1: import java.util.List;
0: import java.util.Set;
1: 
0: import org.apache.aries.spifly.api.SpiFlyConstants;
1: import org.easymock.EasyMock;
1: import org.junit.After;
1: import org.junit.Assert;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleReference;
1: import org.osgi.framework.Version;
1: import org.osgi.framework.hooks.weaving.WeavingHook;
1: import org.osgi.framework.hooks.weaving.WovenClass;
1: import org.osgi.framework.wiring.BundleWiring;
1: 
1: public class ClientWeavingHookTest {
1:     @Before
1:     public void setUp() {
0:         Activator.activator = new Activator();
1:     }
1:     
1:     @After
1:     public void tearDown() {
0:         Activator.activator = null;
1:     }
1:         
1:     @Test
0:     public void testClientWeavingHookBasicServiveLoaderUsage() throws Exception {
1:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
0:         consumerHeaders.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "true");
1: 
1:         // Register the bundle that provides the SPI implementation.
0:         Bundle providerBundle = mockProviderBundle("impl1", 1);        
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
0:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);                      
1: 
0:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext());
1:         
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         Assert.assertNotNull("Precondition", clsUrl);
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.TestClient", consumerBundle);
1:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:         wh.weave(wc);
1:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:         String di = wc.getDynamicImports().get(0);
0:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));        
1:                         
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the 
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("olleh", result);
1:     }
1: 
1:     @Test
0:     public void testClientWeavingHookAltServiceLoaderLoadUnprocessed() throws Exception {
1:         Bundle spiFlyBundle = mockSpiFlyBundle();               
1:        
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "true");
1:         Bundle consumerBundle = mockConsumerBundle(headers, spiFlyBundle);
1: 
0:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext());
1:         
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("UnaffectedTestClient.class");
1:         Assert.assertNotNull("Precondition", clsUrl);
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.UnaffectedTestClient", consumerBundle);
1:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:         wh.weave(wc);
1: 
0:         Assert.assertEquals("The client is not affected so no additional imports should have been added", 
1:             0, wc.getDynamicImports().size());
1:                 
1:         // ok the weaving is done, now prepare the registry for the call
0:         Bundle providerBundle = mockProviderBundle("impl1", 1);        
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle);
1:         
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the 
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
1:         Assert.assertEquals("impl4", result);
1:     }
1: 
1:     @Test
0:     public void testClientWeavingHookMultipleProviders() throws Exception {
1:         Bundle spiFlyBundle = mockSpiFlyBundle();
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "true");
1:         Bundle consumerBundle = mockConsumerBundle(headers, spiFlyBundle);
1: 
0:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext());
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         
0:         // Register in reverse order to make sure the order in which bundles are sorted is correct
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
1: 
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the 
1:         // META-INF/services/org.apache.aries.mytest.MySPI files from impl1 and impl2 are visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("All three services should be invoked in the correct order", "ollehHELLO5", result);        
1:     }
1:     
1:     @Test
1:     public void testClientSpecifyingProvider() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "java.util.ServiceLoader#load(java.lang.Class);bundle=impl2");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2);
0:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2);        
0:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext());
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the 
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("Only the services from bundle impl2 should be selected", "HELLO5", result);        
1:     }
1:     
1:     @Test
1:     public void testClientSpecifyingProviderVersion() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "java.util.ServiceLoader#load(java.lang.Class);bundle=impl2:version=1.2.3");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle3 = mockProviderBundle("impl2_123", 3, new Version(1, 2, 3));
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle3);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle3);
0:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle3);        
0:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext());
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the 
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("Only the services from bundle impl2 should be selected", "Updated!hello!Updated", result);        
1:     }
1: 
1:     @Test
1:     public void testClientMultipleTargetBundles() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, 
1:                 "java.util.ServiceLoader#load(java.lang.Class);bundle=impl1|impl4");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);        
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);        
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
0:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);        
0:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext());
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the 
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("All providers should be selected for this one", "ollehimpl4", result);        
1:     }
1:     
1:     @Test
1:     public void testClientMultipleTargetBundles2() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, 
1:                 "java.util.ServiceLoader#load(java.lang.Class);bundleId=1|4");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);        
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);        
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
0:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);        
0:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext());
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the 
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("All providers should be selected for this one", "ollehimpl4", result);        
1:     }
1: 
1:     @Test
1:     public void testClientSpecificProviderLoadArgument() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, 
1:                 "java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.MySPI])," +
1:                 "java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.AltSPI]);bundle=impl4");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);        
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);        
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
0:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);        
0:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext());
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the 
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("All providers should be selected for this one", "ollehHELLO5impl4", result);        
1: 
1:         // Weave the AltTestClient class.
1:         URL cls2Url = getClass().getResource("AltTestClient.class");
0:         WovenClass wc2 = new MyWovenClass(cls2Url, "org.apache.aries.spifly.AltTestClient", consumerBundle);
1:         wh.weave(wc2);
1: 
1:         // Invoke the AltTestClient
1:         Class<?> cls2 = wc2.getDefinedClass();
1:         Method method2 = cls2.getMethod("test", new Class [] {long.class});
1:         Object result2 = method2.invoke(cls2.newInstance(), 4096);
0:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L*4096L, result2);        
1:     }
1:     
1:     @Test
1:     public void testClientSpecifyingDifferentMethodsLimitedToDifferentProviders() throws Exception {
1:         Dictionary<String, String> headers1 = new Hashtable<String, String>();
0:         headers1.put(SpiFlyConstants.SPI_CONSUMER_HEADER, 
1:                 "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundle=impl3," +
1:                 "java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.MySPI]);bundle=impl4");
1: 
1:         Dictionary<String, String> headers2 = new Hashtable<String, String>();
0:         headers2.put(SpiFlyConstants.SPI_CONSUMER_HEADER, 
1:                 "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundle=system.bundle," +
1:                 "java.util.ServiceLoader#load;bundle=impl1");
1: 
1:         Dictionary<String, String> headers3 = new Hashtable<String, String>();
0:         headers3.put(SpiFlyConstants.SPI_CONSUMER_HEADER, 
1:                 "org.acme.blah#someMethod();bundle=mybundle");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle3 = mockProviderBundle("impl3", 3);
1:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         Activator.activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle3);
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);        
0:         Activator.activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1:         
1:         Bundle consumerBundle1 = mockConsumerBundle(headers1, providerBundle1, providerBundle2, providerBundle3, providerBundle4);
1:         Bundle consumerBundle2 = mockConsumerBundle(headers2, providerBundle1, providerBundle2, providerBundle3, providerBundle4);
1:         Bundle consumerBundle3 = mockConsumerBundle(headers3, providerBundle1, providerBundle2, providerBundle3, providerBundle4);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle1, consumerBundle2, consumerBundle3,
1:                 providerBundle1, providerBundle2, providerBundle3, providerBundle4);
0:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext());
1:         
0:         testConsumerBundleWeaving(consumerBundle1, wh, "impl4", "org.apache.aries.spifly.impl3.MyAltDocumentBuilderFactory");                
0:         testConsumerBundleWeaving(consumerBundle2, wh, "olleh", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");                
0:         testConsumerBundleWeaving(consumerBundle3, wh, "", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");                
1:     }
1: 
0:     private void testConsumerBundleWeaving(Bundle consumerBundle, WeavingHook wh, String testClientResult, String jaxpClientResult) throws Exception {
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.TestClient", consumerBundle);
1:         wh.weave(wc);
1:         
0:         // Invoke the woven class and check that it propertly sets the TCCL so that the 
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals(testClientResult, result);        
1:         
1:         URL clsUrl2 = getClass().getResource("JaxpClient.class");
0:         WovenClass wc2 = new MyWovenClass(clsUrl2, "org.apache.aries.spifly.JaxpClient", consumerBundle);
1:         wh.weave(wc2);
1:         
1:         Class<?> cls2 = wc2.getDefinedClass();
1:         Method method2 = cls2.getMethod("test", new Class [] {});
1:         Class<?> result2 = (Class<?>) method2.invoke(cls2.newInstance());
1:         Assert.assertEquals(jaxpClientResult, result2.getName());
1:     }
1:         
1:     @Test
1:     public void testJAXPClientWantsJREImplementation1() throws Exception {
1:         Bundle systembundle = mockSystemBundle();
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance()");
1:         Bundle consumerBundle = mockConsumerBundle(headers, systembundle);
1: 
0:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, systembundle).getBundleContext());
1: 
1:         URL clsUrl = getClass().getResource("JaxpClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.JaxpClient", consumerBundle);
1:         wh.weave(wc);
1:         
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {});
1:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
0:         Assert.assertEquals("JAXP implementation from JRE", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl", result.getName());                
1:     }
1:     
1:     // If there is an alternate implementation it should always be favoured over the JRE one
1:     @Test
1:     public void testJAXPClientWantsAltImplementation1() throws Exception {
1:         Bundle systembundle = mockSystemBundle();
1: 
1:         Bundle providerBundle = mockProviderBundle("impl3", 1);
0:         Activator.activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle);
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance()");
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle, systembundle);
1: 
0:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext());
1: 
1:         URL clsUrl = getClass().getResource("JaxpClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.JaxpClient", consumerBundle);
1:         wh.weave(wc);
1:         
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {});
1:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
0:         Assert.assertEquals("JAXP implementation from JRE", "org.apache.aries.spifly.impl3.MyAltDocumentBuilderFactory", result.getName());                
1:     }
1: 
1:     @Test
1:     public void testJAXPClientWantsJREImplementation2() throws Exception {
1:         Bundle systembundle = mockSystemBundle();
1:         
1:         Bundle providerBundle = mockProviderBundle("impl3", 1);
0:         Activator.activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle);
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundleId=0");
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle, systembundle);
1: 
0:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext());
1: 
1:         URL clsUrl = getClass().getResource("JaxpClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.JaxpClient", consumerBundle);
1:         wh.weave(wc);
1:         
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {});
1:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
0:         Assert.assertEquals("JAXP implementation from JRE", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl", result.getName());                
1:     }
1: 
1:     @Test
1:     public void testJAXPClientWantsAltImplementation2() throws Exception {
1:         Bundle systembundle = mockSystemBundle();
1: 
1:         Bundle providerBundle = mockProviderBundle("impl3", 1);
0:         Activator.activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle);
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundle=impl3");
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle, systembundle);
1:         
0:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext());
1: 
1:         URL clsUrl = getClass().getResource("JaxpClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.JaxpClient", consumerBundle);
1:         wh.weave(wc);
1:         
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {});
1:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
0:         Assert.assertEquals("JAXP implementation from alternative bundle", "org.apache.aries.spifly.impl3.MyAltDocumentBuilderFactory", result.getName());                        
1:     }
1:     
1:     private Bundle mockSpiFlyBundle(Bundle ... bundles) throws Exception {
1:         return mockSpiFlyBundle("spifly", new Version(1, 0, 0), bundles);
1:     }
1:     
1:     private Bundle mockSpiFlyBundle(String bsn, Version version, Bundle ... bundles) throws Exception {
1:         Bundle spiFlyBundle = EasyMock.createMock(Bundle.class);
1: 
1:         BundleContext spiFlyBundleContext = EasyMock.createMock(BundleContext.class);
1:         EasyMock.expect(spiFlyBundleContext.getBundle()).andReturn(spiFlyBundle).anyTimes();
1:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(bundles));
1:         allBundles.add(spiFlyBundle);
1:         EasyMock.expect(spiFlyBundleContext.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:         EasyMock.replay(spiFlyBundleContext);
1: 
1:         EasyMock.expect(spiFlyBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:         EasyMock.expect(spiFlyBundle.getVersion()).andReturn(version).anyTimes();
1:         EasyMock.expect(spiFlyBundle.getBundleContext()).andReturn(spiFlyBundleContext).anyTimes();
1:         EasyMock.replay(spiFlyBundle);
1: 
1:         // Set the bundle context for testing purposes
0:         Field bcField = Activator.class.getDeclaredField("bundleContext");
1:         bcField.setAccessible(true);
0:         bcField.set(Activator.activator, spiFlyBundle.getBundleContext());
1:         
1:         return spiFlyBundle;
1:     }
1: 
0:     private Bundle mockProviderBundle(String subdir, long id) {
1:         return mockProviderBundle(subdir, id, Version.emptyVersion);
1:     }
1:     
0:     private Bundle mockProviderBundle(String subdir, long id, Version version) {
0:         // Discover all the relevant resources in the META-INF/services directory of specified subdir
0:         String location = getClass().getPackage().getName().replace('.', '/') + "/" + subdir + "/META-INF/services";
0:         Bundle testBundle = ((BundleReference) getClass().getClassLoader()).getBundle();
1:         
0:         Set<String> resources = new HashSet<String>(); // findEntries happens to sometimes return duplicates in Eclipse
0:         // This findEntries call is quite slow, can we do something that's a bit faster?
0:         Enumeration<URL> entries = testBundle.findEntries("/", null, true);
0:         for (URL entry : Collections.list(entries)) {
0:             String s = entry.toExternalForm();
0:             if (s.contains(location)) {
0:                 int idx = s.lastIndexOf("META-INF/services");
0:                 String resource = s.substring(idx);
0:                 if (!resource.endsWith("META-INF/services") && !resource.endsWith("META-INF/services/") && 
0:                     !resource.substring("META-INF/services/".length()).contains("/")) {
0:                     resources.add(resource);
1:                 }
1:             }
1:         }
0:         // Set up the classloader that will be used by the ASM-generated code as the TCCL. 
1:         // It can load a META-INF/services file
0:         ClassLoader cl = new TestImplClassLoader(subdir, resources.toArray(new String [] {}));
1:         
0:         // The BundleWiring API is used on the bundle by the generated code to obtain its classloader
1:         BundleWiring bw = EasyMock.createMock(BundleWiring.class);
0:         EasyMock.expect(bw.getClassLoader()).andReturn(cl).anyTimes();
1:         EasyMock.replay(bw);
1:         
1:         Bundle providerBundle = EasyMock.createMock(Bundle.class);
0:         EasyMock.expect(providerBundle.adapt(BundleWiring.class)).andReturn(bw).anyTimes();
1:         String bsn = subdir;
1:         int idx = bsn.indexOf('_');
1:         if (idx > 0) {
1:             bsn = bsn.substring(0, idx);
1:         }
1:         EasyMock.expect(providerBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:         EasyMock.expect(providerBundle.getBundleId()).andReturn(id).anyTimes();
1:         EasyMock.expect(providerBundle.getVersion()).andReturn(version).anyTimes();
1:         EasyMock.replay(providerBundle);
1:         return providerBundle;
1:     }
1: 
1:     private Bundle mockConsumerBundle(Dictionary<String, String> headers, Bundle ... otherBundles) {
0:         // Create a mock object for the client bundle which holds the code that uses ServiceLoader.load() 
1:         // or another SPI invocation.
1:         BundleContext bc = EasyMock.createMock(BundleContext.class);
1:         
1:         Bundle consumerBundle = EasyMock.createMock(Bundle.class);
1:         EasyMock.expect(consumerBundle.getSymbolicName()).andReturn("testConsumer").anyTimes();
1:         EasyMock.expect(consumerBundle.getHeaders()).andReturn(headers).anyTimes();
1:         EasyMock.expect(consumerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:         EasyMock.expect(consumerBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
0:         EasyMock.replay(consumerBundle);        
1: 
1:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(otherBundles));
1:         allBundles.add(consumerBundle);
1:         EasyMock.expect(bc.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:         EasyMock.replay(bc);
1: 
1:         return consumerBundle;
1:     }
1:     
1:     private Bundle mockSystemBundle() {
1:         Bundle systemBundle = EasyMock.createMock(Bundle.class);
1:         EasyMock.expect(systemBundle.getBundleId()).andReturn(0L).anyTimes();
1:         EasyMock.expect(systemBundle.getSymbolicName()).andReturn("system.bundle").anyTimes();
1:         EasyMock.replay(systemBundle);
1:         
1:         return systemBundle;
1:     }
1:             
0:     public static class TestImplClassLoader extends URLClassLoader {
1:         private final List<String> resources;
1:         private final String prefix;
1:         
0:         public TestImplClassLoader(String subdir, String ... resources) {
0:             super(new URL [] {}, TestImplClassLoader.class.getClassLoader());
1:             
0:             this.prefix = TestImplClassLoader.class.getPackage().getName().replace('.', '/') + "/" + subdir + "/";
1:             this.resources = Arrays.asList(resources);
1:         }
1: 
1:         @Override
1:         public URL findResource(String name) {
1:             if (resources.contains(name)) {
1:                 return getClass().getClassLoader().getResource(prefix + name);
1:             } else {
1:                 return super.findResource(name);
1:             }
1:         }
1: 
1:         @Override
1:         public Enumeration<URL> findResources(String name) throws IOException {
1:             if (resources.contains(name)) {
1:                 return getClass().getClassLoader().getResources(prefix + name);
1:             } else {
1:                 return super.findResources(name);
1:             }
1:         }
1:     }    
1: 
1:     private static class MyWovenClass implements WovenClass {
1:         byte [] bytes;
1:         final String className;
1:         final Bundle bundleContainingOriginalClass;
1:         List<String> dynamicImports = new ArrayList<String>();
1:         boolean weavingComplete = false;
1:         
1:         private MyWovenClass(URL clazz, String name, Bundle bundle) throws Exception {
1:             bytes = Streams.suck(clazz.openStream());
1:             className = name;
1:             bundleContainingOriginalClass = bundle;
1:         }
1: 
1:         @Override
1:         public byte[] getBytes() {
1:             return bytes;
1:         }
1: 
1:         @Override
1:         public void setBytes(byte[] newBytes) {
1:             bytes = newBytes;
1:         }
1: 
1:         @Override
1:         public List<String> getDynamicImports() {
1:             return dynamicImports;
1:         }
1: 
1:         @Override
1:         public boolean isWeavingComplete() {
1:             return weavingComplete;
1:         }
1: 
1:         @Override
1:         public String getClassName() {
1:             return className;
1:         }
1: 
1:         @Override
1:         public ProtectionDomain getProtectionDomain() {
1:             return null;
1:         }
1: 
1:         @Override
1:         public Class<?> getDefinedClass() {
1:             try {
1:                 weavingComplete = true;
1:                 return new MyWovenClassClassLoader(className, getBytes(), getClass().getClassLoader(), bundleContainingOriginalClass).loadClass(className);
1:             } catch (ClassNotFoundException e) {
1:                 e.printStackTrace();
1:                 return null;
1:             }
1:         }
1: 
1:         @Override
1:         public BundleWiring getBundleWiring() {
1:             BundleWiring bw = EasyMock.createMock(BundleWiring.class);
1:             EasyMock.expect(bw.getBundle()).andReturn(bundleContainingOriginalClass);
1:             EasyMock.replay(bw);
1:             return bw;
1:         }
1:     }
1:     
1:     private static class MyWovenClassClassLoader extends ClassLoader implements BundleReference {
1:         private final String className;
1:         private final Bundle bundle;
1:         private final byte [] bytes;
1:         
1:         public MyWovenClassClassLoader(String className, byte[] bytes, ClassLoader parent, Bundle bundle) {
1:             super(parent);
1:             
1:             this.className = className;
1:             this.bundle = bundle;
0:             this.bytes = bytes;            
1:         }
1:         
1:         @Override
1:         protected synchronized Class<?> loadClass(String name, boolean resolve)
1:                 throws ClassNotFoundException {
1:             if (name.equals(className)) {
0:                 return defineClass(className, bytes, 0, bytes.length);
1:             } else {
1:                 return super.loadClass(name, resolve);
1:             }
1:         }
1: 
1:         @Override
1:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:             return loadClass(name, false);
1:         }
1: 
1:         @Override
1:         public Bundle getBundle() {
1:             return bundle;
1:         }
1:     }    
1: }
author:Jeremy Hughes
-------------------------------------------------------------------------------
commit:67d07ab
/////////////////////////////////////////////////////////////////////////
1: import javax.xml.parsers.DocumentBuilderFactory;
0: 
/////////////////////////////////////////////////////////////////////////
1:     private static final String thisJVMsDBF = DocumentBuilderFactory.newInstance().getClass().getName();
0: 
/////////////////////////////////////////////////////////////////////////
0:         testConsumerBundleWeaving(consumerBundle2, wh, "olleh", thisJVMsDBF);
0:         testConsumerBundleWeaving(consumerBundle3, wh, "", thisJVMsDBF);
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("JAXP implementation from JRE", thisJVMsDBF, result.getName());
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("JAXP implementation from JRE", thisJVMsDBF, result.getName());
============================================================================