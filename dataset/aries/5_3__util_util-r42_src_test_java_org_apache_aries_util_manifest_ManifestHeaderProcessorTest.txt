1:8914925: /*
1:8914925:  * Licensed to the Apache Software Foundation (ASF) under one
1:8914925:  * or more contributor license agreements.  See the NOTICE file
1:8914925:  * distributed with this work for additional information
1:8914925:  * regarding copyright ownership.  The ASF licenses this file
1:8914925:  * to you under the Apache License, Version 2.0 (the
1:8914925:  * "License"); you may not use this file except in compliance
1:8914925:  * with the License.  You may obtain a copy of the License at
1:8914925:  *
1:8914925:  *   http://www.apache.org/licenses/LICENSE-2.0
1:8914925:  *
1:8914925:  * Unless required by applicable law or agreed to in writing,
1:8914925:  * software distributed under the License is distributed on an
1:8914925:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:8914925:  * KIND, either express or implied.  See the License for the
1:8914925:  * specific language governing permissions and limitations
1:8914925:  * under the License.
1:8914925:  */
105:8914925: 
1:910fec0: package org.apache.aries.util.manifest;
1:de5b346: 
1:8914925: import static org.junit.Assert.assertEquals;
1:8914925: import static org.junit.Assert.assertFalse;
1:8914925: import static org.junit.Assert.assertNotSame;
1:8914925: import static org.junit.Assert.assertNull;
1:8914925: import static org.junit.Assert.assertTrue;
1:8914925: import static org.junit.Assert.fail;
1:de5b346: 
1:8914925: import java.util.ArrayList;
1:109ef40: import java.util.Arrays;
1:de5b346: import java.util.HashMap;
1:8914925: import java.util.List;
1:8914925: import java.util.Map;
1:8914925: 
1:910fec0: import org.apache.aries.util.VersionRange;
1:109ef40: import org.apache.aries.util.manifest.ManifestHeaderProcessor.GenericMetadata;
1:910fec0: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
1:8914925: import org.junit.Test;
1:109ef40: import org.osgi.framework.Version;
1:8914925: 
1:8914925: public class ManifestHeaderProcessorTest
1:8914925: {
1:8914925:   @Test
1:8914925:   public void testNameValuePair() throws Exception {
1:de5b346: 	HashMap<String, String> attrs = new HashMap<String, String>();
1:de5b346: 	attrs.put("some", "value");
1:de5b346:     NameValuePair nvp = new NameValuePair("key", attrs);
1:109ef40: 
1:de5b346:     assertEquals("The name value pair is not set properly.", nvp.getName(), "key");
1:de5b346:     assertEquals("The value is not set properly.", nvp.getAttributes().get("some"), "value");
1:109ef40: 
1:de5b346: 	attrs = new HashMap<String, String>();
1:de5b346: 	attrs.put("some", "value");
1:de5b346:     NameValuePair anotherNvp = new NameValuePair("key", attrs);
1:de5b346:     assertEquals("The two objects of NameValuePair is not equal.", nvp, anotherNvp);
1:de5b346: 
1:de5b346:     nvp.setName("newKey");
1:de5b346:     attrs = new HashMap<String, String>();
1:de5b346: 	attrs.put("some", "newValue");
1:de5b346:     nvp.setAttributes(attrs);
1:de5b346:     assertEquals("The name value pair is not set properly.", nvp.getName(), "newKey");
1:de5b346:     assertEquals("The value is not set properly.", nvp.getAttributes().get("some"), "newValue");
1:109ef40: 
1:de5b346:     Map<String,String> nvm1 = new HashMap<String,String>();
1:8914925:     nvm1.put("a","b");
1:8914925:     nvm1.put("c","d");
1:109ef40: 
1:de5b346:     Map<String,String> nvm2 = new HashMap<String,String>();
1:8914925:     nvm2.put("c","d");
1:8914925:     nvm2.put("a","b");
1:8914925:     assertEquals("The maps are not equal.", nvm1, nvm2);
1:8914925:     nvm2.put("e","f");
1:8914925:     assertNotSame("The maps are the same.", nvm1, nvm2);
1:109ef40: 
1:de5b346:     NameValuePair nvp1 = new NameValuePair("one",nvm1);
1:de5b346:     NameValuePair nvp2 = new NameValuePair("one",nvm2);
1:109ef40: 
1:8914925:     assertNotSame("The pairs are identical ",nvp1,nvp2);
1:8914925:     nvm1.put("e","f");
1:8914925:     assertEquals("The pairs are not equal.", nvp1,nvp2);
1:109ef40: 
1:de5b346:     List<NameValuePair> bundleInfoList1 = new ArrayList<NameValuePair>();
1:8914925:     bundleInfoList1.add(nvp1);
1:de5b346: 
1:de5b346:     List<NameValuePair> bundleInfoList2 = new ArrayList<NameValuePair>();
1:8914925:     bundleInfoList2.add(nvp1);
1:109ef40: 
1:8914925:     bundleInfoList1.removeAll(bundleInfoList2);
1:8914925:     assertEquals("The List should be empty", bundleInfoList1.isEmpty(), true);
1:109ef40: 
1:109ef40: 
1:8914925:     assertNotSame("The two objects of NameValuePair is not equal.", nvp, anotherNvp);
4:8914925:   }
1:109ef40: 
1:de5b346: 
1:8914925:   /**
1:8914925:    * Test the Bundle manifest header entry of
1:8914925:    * Bundle-SymbolicName: com.acme.foo;singleton:=true
1:8914925:    */
1:8914925:   @Test
1:109ef40:   public void testParseBundleSymbolicName()
1:8914925:   {
1:8914925:     String bundleSymbolicNameEntry = "com.acme.foo;singleton:=true;fragment-attachment:=always";
1:de5b346:     NameValuePair nvp = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry);
1:8914925:     assertEquals("The symbolic name is wrong.", nvp.getName(), "com.acme.foo");
1:de5b346:     assertEquals("The value is wrong.", "true", nvp.getAttributes().get("singleton:") );
1:de5b346:     assertEquals("The directive is wrong.", "always", nvp.getAttributes().get("fragment-attachment:") );
1:109ef40: 
1:8914925:     String bundleSymbolicNameEntry2 = "com.acme.foo";
1:de5b346:     NameValuePair nvp2 = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry2);
1:8914925:     assertEquals("The symbolic name is wrong.", nvp2.getName(), "com.acme.foo");
1:8914925:   }
1:109ef40: 
1:109ef40: 
1:8914925: 
1:8914925:   /**
1:8914925:    * Test the import package and import service
1:8914925:    * Import-Package: com.acme.foo;come.acm,e.bar;version="[1.23,1.24.5]";resolution:=mandatory
1:8914925:    */
1:8914925:   @Test
1:8914925:   public void testParseImportString()
1:8914925:   {
1:8914925:     String importPackage = "com.acme.foo,come.acm.e.bar;version=\"[1.23,1.24.5]\";resolution:=mandatory;company=\"ACME\",a.b.c;version=1.2.3;company=com";
1:109ef40: 
1:de5b346:     Map<String, Map<String, String>> importPackageReturn = ManifestHeaderProcessor.parseImportString(importPackage);
1:109ef40: 
1:8914925:     assertTrue("The package is not set.", importPackageReturn.containsKey("com.acme.foo"));
1:8914925:     assertTrue("The package is not set.", importPackageReturn.containsKey("come.acm.e.bar"));
1:8914925:     assertTrue("The package is not set.", importPackageReturn.containsKey("come.acm.e.bar"));
1:8914925:     assertTrue("The package is not set.", importPackageReturn.containsKey("a.b.c"));
1:8914925:     assertTrue("The package should not contain any attributes.", importPackageReturn.get("com.acme.foo").isEmpty());
1:8914925:     assertEquals("The directive is not set correctly.", "[1.23,1.24.5]", importPackageReturn.get("come.acm.e.bar").get("version"));
1:8914925:     assertEquals("The directive is not set correctly.", "mandatory", importPackageReturn.get("come.acm.e.bar").get("resolution:"));
1:8914925:     assertEquals("The directive is not set correctly.", "ACME", importPackageReturn.get("come.acm.e.bar").get("company"));
1:8914925:     assertEquals("The directive is not set correctly.", "1.2.3", importPackageReturn.get("a.b.c").get("version"));
1:8914925:     assertEquals("The directive is not set correctly.", "com", importPackageReturn.get("a.b.c").get("company"));
1:109ef40: 
1:8914925:     importPackage="com.acme.foo";
1:109ef40: 
1:8914925:     assertTrue("The package is not set.", importPackageReturn.containsKey("com.acme.foo"));
1:8914925:     assertTrue("The package should not contain any attributes.", importPackageReturn.get("com.acme.foo").isEmpty());
1:109ef40: 
1:8914925:     importPackage="com.acme.foo;com.acme.bar;version=2";
1:de5b346:     Map<String, Map<String, String>> importPackageReturn2 = ManifestHeaderProcessor.parseImportString(importPackage);
1:8914925:     assertTrue("The package is not set.", importPackageReturn2.containsKey("com.acme.foo"));
1:8914925:     assertTrue("The package is not set.", importPackageReturn2.containsKey("com.acme.bar"));
1:8914925:     assertEquals("The directive is not set correctly.", "2", importPackageReturn2.get("com.acme.foo").get("version"));
1:8914925:     assertEquals("The directive is not set correctly.", "2", importPackageReturn2.get("com.acme.bar").get("version"));
1:8914925:   }
1:109ef40: 
1:8914925:   @Test
1:8914925:   public void testParseExportString()
1:8914925:   {
1:8914925:     String exportPackage = "com.acme.foo,com.acme.bar;version=1,com.acme.bar;version=2;uses:=\"a.b.c,d.e.f\";security=false;mandatory:=security";
1:109ef40: 
1:de5b346:     List<NameValuePair> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:109ef40: 
1:8914925:     int i =0;
1:8914925:     assertEquals("The number of the packages is wrong.", 3, exportPackageReturn.size());
1:de5b346:     for (NameValuePair nvp : exportPackageReturn) {
1:8914925:       if (nvp.getName().equals("com.acme.foo")) {
1:8914925:         i++;
1:109ef40: 
1:de5b346:         assertTrue("The directive or attribute should not be set.", nvp.getAttributes().isEmpty() );
1:de5b346:       } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getAttributes().get("version")))) {
1:109ef40: 
1:109ef40: 
1:8914925:         i++;
1:de5b346:         assertEquals("The directive is wrong.", "a.b.c,d.e.f", nvp.getAttributes().get("uses:"));
1:de5b346:         assertEquals("The directive is wrong.", "false", nvp.getAttributes().get("security"));
1:de5b346:         assertEquals("The directive is wrong.", "security", nvp.getAttributes().get("mandatory:"));
1:de5b346:       } else if ((nvp.getName().equals("com.acme.bar")) && ("1".equals(nvp.getAttributes().get("version")))) {
1:8914925:         i++;
1:109ef40: 
1:de5b346:         assertNull("The directive is wrong.", nvp.getAttributes().get("uses:"));
1:de5b346:         assertNull("The directive is wrong.", nvp.getAttributes().get("security"));
1:de5b346:         assertNull("The directive is wrong.", nvp.getAttributes().get("mandatory:"));
1:8914925:       }
1:8914925:     }
1:8914925:     // make sure all three packages stored
1:8914925:     assertEquals("The names of the packages are wrong.", 3, i);
1:109ef40: 
1:8914925:     exportPackage = "com.acme.foo";
1:109ef40: 
1:8914925:     exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:109ef40: 
1:8914925:     int k =0;
1:8914925:     assertEquals("The number of the packages is wrong.", 1, exportPackageReturn.size());
1:de5b346:     for (NameValuePair nvp : exportPackageReturn) {
1:8914925:       if (nvp.getName().equals("com.acme.foo")) {
1:8914925:         k++;
1:109ef40: 
1:de5b346:         assertTrue("The directive or attribute should not be set.", nvp.getAttributes().isEmpty() );
1:109ef40:       }
1:8914925:     }
1:8914925:     assertEquals("The names of the packages are wrong.", 1, k);
1:109ef40: 
1:8914925:     // test multiple packages separated by ;
1:109ef40: 
1:8914925:     exportPackage = "com.acme.foo;com.acme.bar;version=\"2\";resolution:=optional";
1:109ef40: 
1:8914925:     exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:109ef40: 
1:8914925:     k =0;
1:8914925:     assertEquals("The number of the packages is wrong.", 2, exportPackageReturn.size());
1:de5b346:     for (NameValuePair nvp : exportPackageReturn) {
1:8914925:       if (nvp.getName().equals("com.acme.foo")) {
1:8914925:         k++;
1:109ef40: 
1:de5b346:         assertEquals("The attribute is wrong.", "2", nvp.getAttributes().get("version") );
1:de5b346:         assertEquals("The attribute is wrong.", "optional", nvp.getAttributes().get("resolution:"));
1:8914925:       } else if (nvp.getName().equals("com.acme.bar")) {
1:8914925:         k++;
1:109ef40: 
1:de5b346:         assertEquals("The attribute is wrong.", "2", nvp.getAttributes().get("version") );
1:de5b346:         assertEquals("The attribute is wrong.", "optional", nvp.getAttributes().get("resolution:"));
1:8914925:       }
1:8914925:     }
1:8914925:     assertEquals("The names of the packages are wrong.", 2, k);
1:109ef40: 
1:449792b:     exportPackageReturn = ManifestHeaderProcessor.parseExportString("some.export.with.space.in;directive := spacey");
1:de5b346:     assertEquals(exportPackageReturn.toString(), "spacey", exportPackageReturn.get(0).getAttributes().get("directive:"));
1:449792b:   }
1:109ef40: 
1:8914925:     @Test
1:8914925:     public void testExportMandatoryAttributes() {
1:8914925:       String exportPackage = "com.acme.foo,com.acme.bar;version=2;company=dodo;security=false;mandatory:=\"security,company\"";
1:109ef40: 
1:de5b346:       List<NameValuePair> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:109ef40: 
1:8914925:       int i =0;
1:8914925:       assertEquals("The number of the packages is wrong.", 2, exportPackageReturn.size());
1:de5b346:       for (NameValuePair nvp : exportPackageReturn) {
1:8914925:         if (nvp.getName().equals("com.acme.foo")) {
1:8914925:           i++;
1:109ef40: 
1:de5b346:           assertTrue("The directive or attribute should not be set.", nvp.getAttributes().isEmpty() );
1:de5b346:         } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getAttributes().get("version")))) {
1:109ef40: 
1:109ef40: 
1:8914925:           i++;
1:de5b346:           assertEquals("The directive is wrong.", "dodo", nvp.getAttributes().get("company"));
1:de5b346:           assertEquals("The directive is wrong.", "false", nvp.getAttributes().get("security"));
1:de5b346:           assertEquals("The directive is wrong.", "security,company", nvp.getAttributes().get("mandatory:"));
1:109ef40:         }
1:8914925:       }
1:8914925:       // make sure all three packages stored
1:8914925:       assertEquals("The names of the packages are wrong.", 2, i);
1:109ef40: 
1:8914925:     }
1:109ef40: 
1:de5b346:     private String createExpectedFilter(Map<String, String> values, String ... parts)
1:8914925:     {
1:8914925:       StringBuilder builder = new StringBuilder(parts[0]);
1:109ef40: 
1:8914925:       for (Map.Entry<String, String> entry : values.entrySet()) {
1:8914925:         if ("version".equals(entry.getKey())) builder.append(parts[2]);
1:8914925:         else if ("company".equals(entry.getKey())) builder.append(parts[1]);
1:8914925:       }
1:109ef40: 
1:8914925:       builder.append(parts[3]);
1:109ef40: 
1:8914925:       return builder.toString();
1:8914925:     }
1:109ef40: 
1:8914925:     /**
1:8914925:      * Test the filter generated correctly
1:8914925:      * @throws Exception
1:8914925:      */
1:8914925:     @Test
1:8914925:     public void testGenerateFilter() throws Exception {
1:de5b346:       Map<String, String> valueMap = new HashMap<String, String>();
1:de5b346:       valueMap.put("version", "[1.2, 2.3]");
1:de5b346:       valueMap.put("resulution:", "mandatory");
1:de5b346:       valueMap.put("company", "com");
1:8914925:       String filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:8914925:       String expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)", "(mandatory:<*company))");
1:8914925:       assertEquals("The filter is wrong.", expected, filter );
1:109ef40: 
1:109ef40: 
1:8914925:       valueMap.clear();
1:109ef40: 
1:de5b346:       valueMap.put("version", "(1.2, 2.3]");
1:de5b346:       valueMap.put("resulution:", "mandatory");
1:de5b346:       valueMap.put("company", "com");
1:8914925:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:8914925:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))", "(mandatory:<*company))");
1:8914925:       assertEquals("The filter is wrong.", expected, filter );
1:109ef40: 
1:8914925:       valueMap.clear();
1:109ef40: 
1:de5b346:       valueMap.put("version", "(1.2, 2.3)");
1:de5b346:       valueMap.put("resulution:", "mandatory");
1:de5b346:       valueMap.put("company", "com");
1:8914925:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:8914925:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))(!(version=2.3.0))", "(mandatory:<*company))");
1:8914925:       assertEquals("The filter is wrong.", expected, filter );
1:109ef40: 
1:8914925:       valueMap.clear();
1:109ef40: 
1:de5b346:       valueMap.put("version", "1.2");
1:de5b346:       valueMap.put("resulution:", "mandatory");
1:de5b346:       valueMap.put("company", "com");
1:8914925:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:8914925:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)", "(mandatory:<*company))");
1:8914925:       assertEquals("The filter is wrong.", expected, filter );
1:109ef40: 
1:8914925:       valueMap.clear();
1:109ef40: 
1:de5b346:       valueMap.put("resulution:", "mandatory");
1:de5b346:       valueMap.put("company", "com");
1:8914925:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:8914925:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "", "(mandatory:<*company))");
1:8914925:       assertEquals("The filter is wrong.", expected, filter );
1:8914925:     }
1:109ef40: 
1:8914925:     /**
1:8914925:      * Test the version range created correctly
1:8914925:      * @throws Exception
1:8914925:      */
1:109ef40: 
1:8914925:     @Test
1:8914925:     public void testVersionRange() throws Exception {
1:8914925:       String version1 = "[1.2.3, 4.5.6]";
1:8914925:       String version2="(1, 2]";
1:8914925:       String version3="[2,4)";
1:8914925:       String version4="(1,2)";
1:8914925:       String version5="2";
1:8914925:       String version6 = "2.3";
1:8914925:       String version7="[1.2.3.q, 2.3.4.p)";
1:8914925:       String version8="1.2.2.5";
1:8914925:       String version9="a.b.c";
1:8914925:       String version10=null;
1:8914925:       String version11="";
1:8914925:       String version12="\"[1.2.3, 4.5.6]\"";
1:109ef40: 
1:8914925:       VersionRange vr = ManifestHeaderProcessor.parseVersionRange(version1);
1:8914925:       assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
1:8914925:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:8914925:       assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
2:8914925:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange(version2);
1:8914925:       assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
1:8914925:       assertTrue("The value is wrong", vr.isMinimumExclusive());
1:8914925:       assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
1:8914925:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange(version3);
1:109ef40: 
1:8914925:       assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
1:8914925:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:8914925:       assertEquals("The value is wrong", "4.0.0", vr.getMaximumVersion().toString());
1:8914925:       assertTrue("The value is wrong", vr.isMaximumExclusive());
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange(version4);
1:109ef40: 
1:8914925:       assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
1:8914925:       assertTrue("The value is wrong", vr.isMinimumExclusive());
1:8914925:       assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
1:8914925:       assertTrue("The value is wrong", vr.isMaximumExclusive());
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange(version5);
1:8914925:       assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
1:8914925:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:8914925:       assertNull("The value is wrong", vr.getMaximumVersion());
1:8914925:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange(version6);
1:8914925:       assertEquals("The value is wrong", "2.3.0", vr.getMinimumVersion().toString());
1:8914925:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:8914925:       assertNull("The value is wrong", vr.getMaximumVersion());
1:8914925:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange(version7);
1:8914925:       assertEquals("The value is wrong", "1.2.3.q", vr.getMinimumVersion().toString());
1:8914925:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:8914925:       assertEquals("The value is wrong", "2.3.4.p", vr.getMaximumVersion().toString());
1:8914925:       assertTrue("The value is wrong", vr.isMaximumExclusive());
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange(version8);
1:8914925:       assertEquals("The value is wrong", "1.2.2.5", vr.getMinimumVersion().toString());
1:8914925:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:8914925:       assertNull("The value is wrong", vr.getMaximumVersion());
1:8914925:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:8914925:       boolean exception = false;
1:8914925:       try {
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange(version9);
1:8914925:       } catch (Exception e){
1:8914925:         exception = true;
1:8914925:       }
1:109ef40: 
1:8914925:       assertTrue("The value is wrong", exception);
1:8914925:       boolean exceptionNull = false;
1:8914925:       try {
1:8914925:         vr = ManifestHeaderProcessor.parseVersionRange(version10);
1:8914925:         } catch (Exception e){
1:8914925:           exceptionNull = true;
1:8914925:         }
1:8914925:         assertTrue("The value is wrong", exceptionNull);
1:8914925:         // empty version should be defaulted to >=0.0.0
1:8914925:         vr = ManifestHeaderProcessor.parseVersionRange(version11);
1:8914925:         assertEquals("The value is wrong", "0.0.0", vr.getMinimumVersion().toString());
1:8914925:         assertFalse("The value is wrong", vr.isMinimumExclusive());
1:8914925:         assertNull("The value is wrong", vr.getMaximumVersion());
1:8914925:         assertFalse("The value is wrong", vr.isMaximumExclusive());
1:109ef40: 
1:109ef40: 
1:8914925:           vr = ManifestHeaderProcessor.parseVersionRange(version12);
1:8914925:           assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
1:8914925:           assertFalse("The value is wrong", vr.isMinimumExclusive());
1:8914925:           assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
1:109ef40:           assertFalse("The value is wrong", vr.isMaximumExclusive());
1:8914925:     }
1:109ef40: 
1:8914925:     @Test
1:8914925:     public void testInvalidVersions() throws Exception
1:8914925:     {
1:8914925:       try {
1:8914925:         ManifestHeaderProcessor.parseVersionRange("a");
1:8914925:         assertTrue("Should have thrown an exception", false);
1:8914925:       } catch (IllegalArgumentException e) {
1:f7e5f7f:         // assertEquals(MessageUtil.getMessage("APPUTILS0009E", "a"), e.getMessage());
1:8914925:       }
1:109ef40: 
1:8914925:       try {
1:8914925:         ManifestHeaderProcessor.parseVersionRange("[1.0.0,1.0.1]", true);
1:8914925:         assertTrue("Should have thrown an exception", false);
1:8914925:       } catch (IllegalArgumentException e) {
1:f7e5f7f:         // assertEquals(MessageUtil.getMessage("APPUTILS0011E", "[1.0.0,1.0.1]"), e.getMessage());
1:8914925:       }
1:8914925: 
1:8914925:     }
1:8914925: 
1:8914925:     @Test
1:8914925:     public void testSplit() throws Exception {
1:8914925:       String export = "com.ibm.ws.eba.obr.fep.bundle122;version=\"3\";company=mood;local=yes;security=yes;mandatory:=\"mood,security\"";
1:8914925:       List<String> result = ManifestHeaderProcessor.split(export, ",");
1:8914925:       assertEquals("The result is wrong.", export, result.get(0));
1:8914925:       assertEquals("The result is wrong.", 1, result.size());
1:109ef40: 
1:8914925:       String aString = "com.acme.foo;weirdAttr=\"one;two;three\";weirdDir:=\"1;2;3\"";
1:8914925:       result = ManifestHeaderProcessor.split(aString, ";");
1:8914925:       assertEquals("The result is wrong.", "com.acme.foo", result.get(0));
1:8914925:       assertEquals("The result is wrong.", "weirdAttr=\"one;two;three\"", result.get(1));
1:8914925:       assertEquals("The result is wrong.", "weirdDir:=\"1;2;3\"", result.get(2));
1:109ef40: 
1:8914925:       assertEquals("The result is wrong.", 3, result.size());
1:109ef40: 
1:109ef40: 
1:109ef40: 
1:109ef40: 
1:8914925:       String pkg1 = "com.ibm.ws.eba.example.helloIsolation;version=\"1.0.0\" ";
1:8914925:       String pkg2 = "com.ibm.ws.eba.helloWorldService;version=\"[1.0.0,1.0.0]\"";
1:8914925:       String pkg3 = " com.ibm.ws.eba.helloWorldService;version=\"1.0.0\"";
1:8914925:       String pkg4 = "com.ibm.ws.eba.helloWorldService;version=\"[1.0.0,1.0.0]\";sharing:=shared" ;
1:8914925:       String pkg5 = "com.ibm.ws.eba.helloWorldService;sharing:=shared;version=\"[1.0.0,1.0.0]\"";
1:8914925:       String appContent1 = pkg1 + ", " + pkg2 + ", " + pkg3;
1:8914925:       String appContent2 = pkg2 + ", " + pkg1 + ", " + pkg3;
1:8914925:       String appContent3 = pkg1 + ", " + pkg3 + ", " + pkg2;
1:8914925:       String appContent4 = pkg1 + ", " + pkg3 + ", " + pkg4;
1:8914925:       String appContent5 = pkg1 + ", " + pkg3 + ", " + pkg5;
1:109ef40: 
1:8914925:       List<String> splitList = ManifestHeaderProcessor.split(appContent1, ",");
1:8914925:       assertEquals(pkg1.trim(), splitList.get(0));
1:8914925:       assertEquals(pkg2.trim(), splitList.get(1));
1:8914925:       assertEquals(pkg3.trim(), splitList.get(2));
1:109ef40: 
1:8914925:       splitList = ManifestHeaderProcessor.split(appContent2, ",");
1:8914925:       assertEquals(pkg2.trim(), splitList.get(0));
1:8914925:       assertEquals(pkg1.trim(), splitList.get(1));
1:8914925:       assertEquals(pkg3.trim(), splitList.get(2));
1:109ef40: 
1:8914925:       splitList = ManifestHeaderProcessor.split(appContent3, ",");
1:8914925:       assertEquals(pkg1.trim(), splitList.get(0));
1:8914925:       assertEquals(pkg3.trim(), splitList.get(1));
1:8914925:       assertEquals(pkg2.trim(), splitList.get(2));
1:109ef40: 
1:8914925:       splitList = ManifestHeaderProcessor.split(appContent4, ",");
1:8914925:       assertEquals(pkg1.trim(), splitList.get(0));
1:8914925:       assertEquals(pkg3.trim(), splitList.get(1));
1:8914925:       assertEquals(pkg4.trim(), splitList.get(2));
1:109ef40: 
1:8914925:       splitList = ManifestHeaderProcessor.split(appContent5, ",");
1:8914925:       assertEquals(pkg1.trim(), splitList.get(0));
1:8914925:       assertEquals(pkg3.trim(), splitList.get(1));
1:109ef40:       assertEquals(pkg5.trim(), splitList.get(2));
1:8914925:     }
1:109ef40: 
1:8914925:     @Test
1:8914925:     public void testParseFilter()
1:8914925:     {
1:8914925:       Map<String,String> attrs = ManifestHeaderProcessor.parseFilter("(package=com.ibm.test)");
1:8914925:       assertEquals("com.ibm.test", attrs.get("package"));
1:109ef40: 
1:8914925:       attrs = ManifestHeaderProcessor.parseFilter("(&(package=com.ibm.test)(attr=value))");
1:8914925:       assertEquals("com.ibm.test", attrs.get("package"));
1:8914925:       assertEquals("value", attrs.get("attr"));
1:8914925:       assertEquals(2, attrs.size());
1:109ef40: 
1:8914925:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0))");
1:8914925:       assertEquals("1.0.0", attrs.get("version"));
1:109ef40: 
1:8914925:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0))");
1:8914925:       assertEquals("[1.0.0,2.0.0]", attrs.get("version"));
1:8914925: 
1:8914925:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0)(!(version=1.0.0)))");
1:8914925:       assertEquals("(1.0.0,2.0.0]", attrs.get("version"));
1:8914925: 
1:8914925:       attrs = ManifestHeaderProcessor.parseFilter("(&(!(version=2.0.0))(!(version=1.0.0))(version>=1.0.0)(version<=2.0.0))");
1:8914925:       assertEquals("(1.0.0,2.0.0)", attrs.get("version"));
1:8914925:     }
1:109ef40: 
1:8914925:     @Test
1:109ef40:     public void testExactVersion() throws Exception
1:8914925:     {
1:8914925:       VersionRange vr;
1:8914925:       try {
1:8914925:         vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 2.0.0]", true);
1:8914925:         fail("should not get here 1");
1:8914925:       } catch (IllegalArgumentException e) {
1:8914925:         // expected
1:8914925:       }
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0]", true);
1:8914925:       assertTrue(vr.isExactVersion());
1:109ef40: 
1:8914925:       try {
1:8914925:         vr = ManifestHeaderProcessor.parseVersionRange("(1.0.0, 1.0.0]", true);
1:8914925:         fail("should not get here 2");
1:8914925:       } catch (IllegalArgumentException e) {
1:8914925:         // expected
1:8914925:       }
1:109ef40: 
1:8914925:       try {
1:8914925:         vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0)", true);
1:8914925:         fail("should not get here 3");
1:8914925:       } catch (IllegalArgumentException e) {
1:8914925:         // expected
1:8914925:       }
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 2.0.0]");
1:8914925:       assertFalse(vr.isExactVersion());
1:109ef40: 
1:8914925:       vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0]");
1:8914925:       assertTrue(vr.isExactVersion());
1:109ef40: 
1:109ef40: 
1:109ef40:     }
1:109ef40: 
1:109ef40:     @Test
1:109ef40:     public void testCapabilityHeader() throws Exception {
1:109ef40:       String s =
1:109ef40:           "com.acme.dictionary; effective:=resolve; from:String=nl; to=de; version:Version=3.4.0.test;somedir:=test, " +
1:109ef40:           "com.acme.dictionary; filter:=\"(&(width>=1000)(height>=1000))\", " +
1:a2357dc:           "com.acme.ip2location;country:List<String>=\"nl,be,fr,uk\";version:Version=1.3;long:Long=" + Long.MAX_VALUE + ";d:Double=\"3.141592653589793\"";
1:109ef40: 
1:109ef40:       List<GenericMetadata> capabilities = ManifestHeaderProcessor.parseCapabilityString(s);
1:109ef40:       testCapabilitiesOrRequirements(capabilities);
1:109ef40:     }
1:109ef40: 
1:109ef40:     @Test
1:109ef40:     public void testRequirementHeader() throws Exception {
1:109ef40:       String s =
1:109ef40:           "com.acme.dictionary; effective:=resolve; from:String=nl; to=de; version:Version=3.4.0.test;somedir:=test, " +
1:109ef40:           "com.acme.dictionary; filter:=\"(&(width>=1000)(height>=1000))\", " +
1:a2357dc:           "com.acme.ip2location;country:List<String>=\"nl,be,fr,uk\";version:Version=1.3;long:Long=" + Long.MAX_VALUE + ";d:Double=\"3.141592653589793\"";
1:109ef40: 
1:109ef40:       List<GenericMetadata> capabilities = ManifestHeaderProcessor.parseRequirementString(s);
1:109ef40:       testCapabilitiesOrRequirements(capabilities);
1:109ef40:     }
1:109ef40: 
1:109ef40:     private void testCapabilitiesOrRequirements(List<GenericMetadata> metadata) {
1:109ef40:       assertEquals(3, metadata.size());
1:109ef40: 
1:109ef40:       boolean found1 = false, found2 = false, found3 = false;
1:109ef40:       for (GenericMetadata cap : metadata) {
1:109ef40:         if ("com.acme.dictionary".equals(cap.getNamespace()) && cap.getDirectives().containsKey("effective")) {
1:109ef40:           testDictionaryCapability1(cap);
1:109ef40:           found1 = true;
1:109ef40:         } else if ("com.acme.dictionary".equals(cap.getNamespace()) && cap.getDirectives().containsKey("filter")) {
1:109ef40:           testDictionaryCapability2(cap);
1:109ef40:           found2 = true;
1:109ef40:         } else if ("com.acme.ip2location".equals(cap.getNamespace())) {
1:109ef40:           testIP2LocationCapability(cap);
1:109ef40:           found3 = true;
1:109ef40:         }
1:109ef40:       }
1:109ef40: 
1:109ef40:       assertTrue(found1);
1:109ef40:       assertTrue(found2);
1:109ef40:       assertTrue(found3);
1:109ef40:     }
1:109ef40: 
1:109ef40:     private void testDictionaryCapability1(GenericMetadata cap) {
1:109ef40:       assertEquals(2, cap.getDirectives().size());
1:109ef40:       assertEquals("resolve", cap.getDirectives().get("effective"));
1:109ef40:       assertEquals("test", cap.getDirectives().get("somedir"));
1:109ef40: 
1:109ef40:       assertEquals(3, cap.getAttributes().size());
1:109ef40:       assertEquals("nl", cap.getAttributes().get("from"));
1:109ef40:       assertEquals("de", cap.getAttributes().get("to"));
1:109ef40:       assertEquals(new Version(3, 4, 0, "test"), cap.getAttributes().get("version"));
1:109ef40:     }
1:109ef40: 
1:109ef40:     private void testDictionaryCapability2(GenericMetadata cap) {
1:109ef40:       assertEquals(1, cap.getDirectives().size());
1:109ef40:       assertEquals("(&(width>=1000)(height>=1000))", cap.getDirectives().get("filter"));
1:109ef40: 
1:109ef40:       assertEquals(0, cap.getAttributes().size());
1:109ef40:     }
1:109ef40: 
1:109ef40:     private void testIP2LocationCapability(GenericMetadata cap) {
1:109ef40:       assertEquals(0, cap.getDirectives().size());
1:109ef40:       assertEquals(4, cap.getAttributes().size());
1:109ef40: 
1:109ef40:       assertEquals(new Version(1, 3, 0), cap.getAttributes().get("version"));
1:109ef40:       assertEquals(Arrays.asList("nl", "be", "fr", "uk"), cap.getAttributes().get("country"));
1:109ef40:       assertEquals(Long.MAX_VALUE, cap.getAttributes().get("long"));
1:a2357dc:       assertEquals(0, new Double("3.141592653589793").compareTo((Double) cap.getAttributes().get("d")));
1:8914925:     }
1:8914925: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:a2357dc
/////////////////////////////////////////////////////////////////////////
1:           "com.acme.ip2location;country:List<String>=\"nl,be,fr,uk\";version:Version=1.3;long:Long=" + Long.MAX_VALUE + ";d:Double=\"3.141592653589793\"";
/////////////////////////////////////////////////////////////////////////
1:           "com.acme.ip2location;country:List<String>=\"nl,be,fr,uk\";version:Version=1.3;long:Long=" + Long.MAX_VALUE + ";d:Double=\"3.141592653589793\"";
/////////////////////////////////////////////////////////////////////////
1:       assertEquals(0, new Double("3.141592653589793").compareTo((Double) cap.getAttributes().get("d")));
commit:109ef40
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor.GenericMetadata;
1: import org.osgi.framework.Version;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1:   public void testParseBundleSymbolicName()
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1:       }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1:         }
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:           assertFalse("The value is wrong", vr.isMaximumExclusive());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1:       assertEquals(pkg5.trim(), splitList.get(2));
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testExactVersion() throws Exception
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1:     }
1: 
1:     @Test
1:     public void testCapabilityHeader() throws Exception {
1:       String s =
1:           "com.acme.dictionary; effective:=resolve; from:String=nl; to=de; version:Version=3.4.0.test;somedir:=test, " +
1:           "com.acme.dictionary; filter:=\"(&(width>=1000)(height>=1000))\", " +
0:           "com.acme.ip2location;country:List<String>=\"nl,be,fr,uk\";version:Version=1.3;long:Long=" + Long.MAX_VALUE + ";d:Double=\"2.2250738585072012e-308\"";
1: 
1:       List<GenericMetadata> capabilities = ManifestHeaderProcessor.parseCapabilityString(s);
1:       testCapabilitiesOrRequirements(capabilities);
1:     }
1: 
1:     @Test
1:     public void testRequirementHeader() throws Exception {
1:       String s =
1:           "com.acme.dictionary; effective:=resolve; from:String=nl; to=de; version:Version=3.4.0.test;somedir:=test, " +
1:           "com.acme.dictionary; filter:=\"(&(width>=1000)(height>=1000))\", " +
0:           "com.acme.ip2location;country:List<String>=\"nl,be,fr,uk\";version:Version=1.3;long:Long=" + Long.MAX_VALUE + ";d:Double=\"2.2250738585072012e-308\"";
1: 
1:       List<GenericMetadata> capabilities = ManifestHeaderProcessor.parseRequirementString(s);
1:       testCapabilitiesOrRequirements(capabilities);
1:     }
1: 
1:     private void testCapabilitiesOrRequirements(List<GenericMetadata> metadata) {
1:       assertEquals(3, metadata.size());
1: 
1:       boolean found1 = false, found2 = false, found3 = false;
1:       for (GenericMetadata cap : metadata) {
1:         if ("com.acme.dictionary".equals(cap.getNamespace()) && cap.getDirectives().containsKey("effective")) {
1:           testDictionaryCapability1(cap);
1:           found1 = true;
1:         } else if ("com.acme.dictionary".equals(cap.getNamespace()) && cap.getDirectives().containsKey("filter")) {
1:           testDictionaryCapability2(cap);
1:           found2 = true;
1:         } else if ("com.acme.ip2location".equals(cap.getNamespace())) {
1:           testIP2LocationCapability(cap);
1:           found3 = true;
1:         }
1:       }
1: 
1:       assertTrue(found1);
1:       assertTrue(found2);
1:       assertTrue(found3);
1:     }
1: 
1:     private void testDictionaryCapability1(GenericMetadata cap) {
1:       assertEquals(2, cap.getDirectives().size());
1:       assertEquals("resolve", cap.getDirectives().get("effective"));
1:       assertEquals("test", cap.getDirectives().get("somedir"));
1: 
1:       assertEquals(3, cap.getAttributes().size());
1:       assertEquals("nl", cap.getAttributes().get("from"));
1:       assertEquals("de", cap.getAttributes().get("to"));
1:       assertEquals(new Version(3, 4, 0, "test"), cap.getAttributes().get("version"));
1:     }
1: 
1:     private void testDictionaryCapability2(GenericMetadata cap) {
1:       assertEquals(1, cap.getDirectives().size());
1:       assertEquals("(&(width>=1000)(height>=1000))", cap.getDirectives().get("filter"));
1: 
1:       assertEquals(0, cap.getAttributes().size());
1:     }
1: 
1:     private void testIP2LocationCapability(GenericMetadata cap) {
1:       assertEquals(0, cap.getDirectives().size());
1:       assertEquals(4, cap.getAttributes().size());
1: 
1:       assertEquals(new Version(1, 3, 0), cap.getAttributes().get("version"));
1:       assertEquals(Arrays.asList("nl", "be", "fr", "uk"), cap.getAttributes().get("country"));
1:       assertEquals(Long.MAX_VALUE, cap.getAttributes().get("long"));
0:       assertEquals(0, new Double("2.2250738585072012e-308").compareTo((Double) cap.getAttributes().get("d")));
author:David Jencks
-------------------------------------------------------------------------------
commit:6df3ad3
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:de5b346
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1: 	HashMap<String, String> attrs = new HashMap<String, String>();
1: 	attrs.put("some", "value");
1:     NameValuePair nvp = new NameValuePair("key", attrs);
1:     assertEquals("The name value pair is not set properly.", nvp.getName(), "key");
1:     assertEquals("The value is not set properly.", nvp.getAttributes().get("some"), "value");
1:     
1: 	attrs = new HashMap<String, String>();
1: 	attrs.put("some", "value");
1:     NameValuePair anotherNvp = new NameValuePair("key", attrs);
1:     assertEquals("The two objects of NameValuePair is not equal.", nvp, anotherNvp);
1: 
1:     nvp.setName("newKey");
1:     attrs = new HashMap<String, String>();
1: 	attrs.put("some", "newValue");
1:     nvp.setAttributes(attrs);
1:     assertEquals("The name value pair is not set properly.", nvp.getName(), "newKey");
1:     assertEquals("The value is not set properly.", nvp.getAttributes().get("some"), "newValue");
1:     
1:     Map<String,String> nvm1 = new HashMap<String,String>();
1:     
1:     Map<String,String> nvm2 = new HashMap<String,String>();
1:     NameValuePair nvp1 = new NameValuePair("one",nvm1);
1:     NameValuePair nvp2 = new NameValuePair("one",nvm2);
1:     List<NameValuePair> bundleInfoList1 = new ArrayList<NameValuePair>();
1:     List<NameValuePair> bundleInfoList2 = new ArrayList<NameValuePair>();
/////////////////////////////////////////////////////////////////////////
1:     NameValuePair nvp = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry);
1:     assertEquals("The value is wrong.", "true", nvp.getAttributes().get("singleton:") );
1:     assertEquals("The directive is wrong.", "always", nvp.getAttributes().get("fragment-attachment:") );
1:     NameValuePair nvp2 = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry2);
/////////////////////////////////////////////////////////////////////////
1:     Map<String, Map<String, String>> importPackageReturn = ManifestHeaderProcessor.parseImportString(importPackage);
/////////////////////////////////////////////////////////////////////////
1:     Map<String, Map<String, String>> importPackageReturn2 = ManifestHeaderProcessor.parseImportString(importPackage);
1:   
1:     List<NameValuePair> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:     for (NameValuePair nvp : exportPackageReturn) {
1:         assertTrue("The directive or attribute should not be set.", nvp.getAttributes().isEmpty() );
1:       } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getAttributes().get("version")))) {
1:         assertEquals("The directive is wrong.", "a.b.c,d.e.f", nvp.getAttributes().get("uses:"));
1:         assertEquals("The directive is wrong.", "false", nvp.getAttributes().get("security"));
1:         assertEquals("The directive is wrong.", "security", nvp.getAttributes().get("mandatory:"));
1:       } else if ((nvp.getName().equals("com.acme.bar")) && ("1".equals(nvp.getAttributes().get("version")))) {
1:         assertNull("The directive is wrong.", nvp.getAttributes().get("uses:"));
1:         assertNull("The directive is wrong.", nvp.getAttributes().get("security"));
1:         assertNull("The directive is wrong.", nvp.getAttributes().get("mandatory:"));
/////////////////////////////////////////////////////////////////////////
1:     for (NameValuePair nvp : exportPackageReturn) {
1:         assertTrue("The directive or attribute should not be set.", nvp.getAttributes().isEmpty() );
/////////////////////////////////////////////////////////////////////////
1:     for (NameValuePair nvp : exportPackageReturn) {
1:         assertEquals("The attribute is wrong.", "2", nvp.getAttributes().get("version") );
1:         assertEquals("The attribute is wrong.", "optional", nvp.getAttributes().get("resolution:"));
1:         assertEquals("The attribute is wrong.", "2", nvp.getAttributes().get("version") );
1:         assertEquals("The attribute is wrong.", "optional", nvp.getAttributes().get("resolution:"));
1:     assertEquals(exportPackageReturn.toString(), "spacey", exportPackageReturn.get(0).getAttributes().get("directive:"));
1:       List<NameValuePair> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:       for (NameValuePair nvp : exportPackageReturn) {
1:           assertTrue("The directive or attribute should not be set.", nvp.getAttributes().isEmpty() );
1:         } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getAttributes().get("version")))) {
1:           assertEquals("The directive is wrong.", "dodo", nvp.getAttributes().get("company"));
1:           assertEquals("The directive is wrong.", "false", nvp.getAttributes().get("security"));
1:           assertEquals("The directive is wrong.", "security,company", nvp.getAttributes().get("mandatory:"));
/////////////////////////////////////////////////////////////////////////
1:     private String createExpectedFilter(Map<String, String> values, String ... parts)
/////////////////////////////////////////////////////////////////////////
1:       Map<String, String> valueMap = new HashMap<String, String>();
1:       valueMap.put("version", "[1.2, 2.3]");
1:       valueMap.put("resulution:", "mandatory");
1:       valueMap.put("company", "com");
/////////////////////////////////////////////////////////////////////////
1:       valueMap.put("version", "(1.2, 2.3]");
1:       valueMap.put("resulution:", "mandatory");
1:       valueMap.put("company", "com");
1:       valueMap.put("version", "(1.2, 2.3)");
1:       valueMap.put("resulution:", "mandatory");
1:       valueMap.put("company", "com");
1:       valueMap.put("version", "1.2");
1:       valueMap.put("resulution:", "mandatory");
1:       valueMap.put("company", "com");
1:       valueMap.put("resulution:", "mandatory");
1:       valueMap.put("company", "com");
commit:910fec0
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.util.manifest;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.VersionRange;
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValueMap;
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
commit:449792b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     exportPackageReturn = ManifestHeaderProcessor.parseExportString("some.export.with.space.in;directive := spacey");
0:     assertEquals(exportPackageReturn.toString(), "spacey", exportPackageReturn.get(0).getValue().get("directive:"));
1:   }
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:f7e5f7f
/////////////////////////////////////////////////////////////////////////
1:         // assertEquals(MessageUtil.getMessage("APPUTILS0009E", "a"), e.getMessage());
1:         // assertEquals(MessageUtil.getMessage("APPUTILS0011E", "[1.0.0,1.0.1]"), e.getMessage());
commit:8914925
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
0: package org.apache.aries.application.utils.manifest;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNotSame;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.Map;
1: 
0: import org.apache.aries.application.VersionRange;
0: import org.apache.aries.application.utils.internal.MessageUtil;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor.NameValueMap;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor.NameValuePair;
1: import org.junit.Test;
1: 
1: public class ManifestHeaderProcessorTest
1: {
1:   @Test
1:   public void testNameValuePair() throws Exception {
0:     NameValuePair<String, String> nvp = new NameValuePair<String, String>("key", "value");
0:     assertEquals("The name value pair is not set properly.", nvp.getName(), "key");
0:     assertEquals("The value is not set properly.", nvp.getValue(), "value");
0:     NameValuePair<String, String> anotherNvp = new NameValuePair<String, String>("key", "value");
0:     assertEquals("The two objects of NameValuePair is not equal.", nvp, anotherNvp);
0:     nvp.setName("newKey");
0:     nvp.setValue("newValue");
0:     assertEquals("The name value pair is not set properly.", nvp.getName(), "newKey");
0:     assertEquals("The value is not set properly.", nvp.getValue(), "newValue");
1:     
0:     NameValueMap<String,String> nvm1 = new NameValueMap<String,String>();
1:     nvm1.put("a","b");
1:     nvm1.put("c","d");
0:     NameValueMap<String,String> nvm2 = new NameValueMap<String,String>();
1:     nvm2.put("c","d");
1:     nvm2.put("a","b");
1:     assertEquals("The maps are not equal.", nvm1, nvm2);
1:     nvm2.put("e","f");
1:     assertNotSame("The maps are the same.", nvm1, nvm2);
1:     
0:     NameValuePair<String, NameValueMap<String,String>> nvp1 = new NameValuePair<String,NameValueMap<String,String>>("one",nvm1);
0:     NameValuePair<String, NameValueMap<String,String>> nvp2 = new NameValuePair<String,NameValueMap<String,String>>("one",nvm2);
1:     
1:     assertNotSame("The pairs are identical ",nvp1,nvp2);
1:     nvm1.put("e","f");
1:     assertEquals("The pairs are not equal.", nvp1,nvp2);
1:     
0:     List<NameValuePair<String, NameValueMap<String,String>>> bundleInfoList1 = new ArrayList<NameValuePair<String, NameValueMap<String,String>>>();
1:     bundleInfoList1.add(nvp1);
1: 
0:     List<NameValuePair<String, NameValueMap<String,String>>> bundleInfoList2 = new ArrayList<NameValuePair<String, NameValueMap<String,String>>>();
1:     bundleInfoList2.add(nvp1);
1:     
1:     bundleInfoList1.removeAll(bundleInfoList2);
1:     assertEquals("The List should be empty", bundleInfoList1.isEmpty(), true);
1:    
1:    
1:     assertNotSame("The two objects of NameValuePair is not equal.", nvp, anotherNvp);
1:   }
1: 
1:   
1:   /**
1:    * Test the Bundle manifest header entry of
1:    * Bundle-SymbolicName: com.acme.foo;singleton:=true
1:    */
1:   @Test
0:   public void testParseBundleSymbolicName() 
1:   {
1:     String bundleSymbolicNameEntry = "com.acme.foo;singleton:=true;fragment-attachment:=always";
0:     NameValuePair<String, NameValueMap<String, String>> nvp = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry);
1:     assertEquals("The symbolic name is wrong.", nvp.getName(), "com.acme.foo");
0:     assertEquals("The value is wrong.", "true", nvp.getValue().get("singleton:") );
0:     assertEquals("The directive is wrong.", "always", nvp.getValue().get("fragment-attachment:") );
1:   
1:     String bundleSymbolicNameEntry2 = "com.acme.foo";
0:     NameValuePair<String, NameValueMap<String, String>> nvp2 = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry2);
1:     assertEquals("The symbolic name is wrong.", nvp2.getName(), "com.acme.foo");
1:     
1:     
1:   
1:   
1:   }
1:   
1:  
1: 
1:   /**
1:    * Test the import package and import service
1:    * Import-Package: com.acme.foo;come.acm,e.bar;version="[1.23,1.24.5]";resolution:=mandatory
1:    */
1:   @Test
1:   public void testParseImportString()
1:   {
1:     String importPackage = "com.acme.foo,come.acm.e.bar;version=\"[1.23,1.24.5]\";resolution:=mandatory;company=\"ACME\",a.b.c;version=1.2.3;company=com";
1:   
0:     Map<String, NameValueMap<String, String>> importPackageReturn = ManifestHeaderProcessor.parseImportString(importPackage);
1:   
1:     assertTrue("The package is not set.", importPackageReturn.containsKey("com.acme.foo"));
1:     assertTrue("The package is not set.", importPackageReturn.containsKey("come.acm.e.bar"));
1:     assertTrue("The package is not set.", importPackageReturn.containsKey("come.acm.e.bar"));
1:     assertTrue("The package is not set.", importPackageReturn.containsKey("a.b.c"));
1:     assertTrue("The package should not contain any attributes.", importPackageReturn.get("com.acme.foo").isEmpty());
1:     assertEquals("The directive is not set correctly.", "[1.23,1.24.5]", importPackageReturn.get("come.acm.e.bar").get("version"));
1:     assertEquals("The directive is not set correctly.", "mandatory", importPackageReturn.get("come.acm.e.bar").get("resolution:"));
1:     assertEquals("The directive is not set correctly.", "ACME", importPackageReturn.get("come.acm.e.bar").get("company"));
1:     assertEquals("The directive is not set correctly.", "1.2.3", importPackageReturn.get("a.b.c").get("version"));
1:     assertEquals("The directive is not set correctly.", "com", importPackageReturn.get("a.b.c").get("company"));
1:     
1:     importPackage="com.acme.foo";
1:     
1:     assertTrue("The package is not set.", importPackageReturn.containsKey("com.acme.foo"));
1:     assertTrue("The package should not contain any attributes.", importPackageReturn.get("com.acme.foo").isEmpty());
1:     
1:     importPackage="com.acme.foo;com.acme.bar;version=2";
0:     Map<String, NameValueMap<String, String>> importPackageReturn2 = ManifestHeaderProcessor.parseImportString(importPackage);
1:     assertTrue("The package is not set.", importPackageReturn2.containsKey("com.acme.foo"));
1:     assertTrue("The package is not set.", importPackageReturn2.containsKey("com.acme.bar"));
1:     assertEquals("The directive is not set correctly.", "2", importPackageReturn2.get("com.acme.foo").get("version"));
1:     assertEquals("The directive is not set correctly.", "2", importPackageReturn2.get("com.acme.bar").get("version"));
1:   }
1:   @Test
1:   public void testParseExportString()
1:   {
1:     String exportPackage = "com.acme.foo,com.acme.bar;version=1,com.acme.bar;version=2;uses:=\"a.b.c,d.e.f\";security=false;mandatory:=security";
1:   
0:     List<NameValuePair<String, NameValueMap<String, String>>> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:     
1:     int i =0;
1:     assertEquals("The number of the packages is wrong.", 3, exportPackageReturn.size());
0:     for (NameValuePair<String, NameValueMap<String, String>> nvp : exportPackageReturn) {
1:       if (nvp.getName().equals("com.acme.foo")) {
1:         i++;
1:         
0:         assertTrue("The directive or attribute should not be set.", nvp.getValue().isEmpty() );
0:       } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getValue().get("version")))) {
1:       
1:         
1:         i++;
0:         assertEquals("The directive is wrong.", "a.b.c,d.e.f", nvp.getValue().get("uses:"));
0:         assertEquals("The directive is wrong.", "false", nvp.getValue().get("security"));
0:         assertEquals("The directive is wrong.", "security", nvp.getValue().get("mandatory:"));
0:       } else if ((nvp.getName().equals("com.acme.bar")) && ("1".equals(nvp.getValue().get("version")))) {
1:         i++;
1:         
0:         assertNull("The directive is wrong.", nvp.getValue().get("uses:"));
0:         assertNull("The directive is wrong.", nvp.getValue().get("security"));
0:         assertNull("The directive is wrong.", nvp.getValue().get("mandatory:"));
1:       }
1:     }
1:     // make sure all three packages stored
1:     assertEquals("The names of the packages are wrong.", 3, i);
1:     
1:     exportPackage = "com.acme.foo";
1:     
1:     exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:     
1:     int k =0;
1:     assertEquals("The number of the packages is wrong.", 1, exportPackageReturn.size());
0:     for (NameValuePair<String, NameValueMap<String, String>> nvp : exportPackageReturn) {
1:       if (nvp.getName().equals("com.acme.foo")) {
1:         k++;
1:         
0:         assertTrue("The directive or attribute should not be set.", nvp.getValue().isEmpty() );
1:       } 
1:     }
1:     assertEquals("The names of the packages are wrong.", 1, k);
1:     
1:     // test multiple packages separated by ;
1:     
1:     exportPackage = "com.acme.foo;com.acme.bar;version=\"2\";resolution:=optional";
1:     
1:     exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:     
1:     k =0;
1:     assertEquals("The number of the packages is wrong.", 2, exportPackageReturn.size());
0:     for (NameValuePair<String, NameValueMap<String, String>> nvp : exportPackageReturn) {
1:       if (nvp.getName().equals("com.acme.foo")) {
1:         k++;
1:         
0:         assertEquals("The attribute is wrong.", "2", nvp.getValue().get("version") );
0:         assertEquals("The attribute is wrong.", "optional", nvp.getValue().get("resolution:"));
1:       } else if (nvp.getName().equals("com.acme.bar")) {
1:         k++;
1:         
0:         assertEquals("The attribute is wrong.", "2", nvp.getValue().get("version") );
0:         assertEquals("The attribute is wrong.", "optional", nvp.getValue().get("resolution:"));
1:       }
1:     }
1:     assertEquals("The names of the packages are wrong.", 2, k);
1:     
1:     
1:     
1:     }
1:     
1:     @Test
1:     public void testExportMandatoryAttributes() {
1:       String exportPackage = "com.acme.foo,com.acme.bar;version=2;company=dodo;security=false;mandatory:=\"security,company\"";
1:       
0:       List<NameValuePair<String, NameValueMap<String, String>>> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
1:       
1:       int i =0;
1:       assertEquals("The number of the packages is wrong.", 2, exportPackageReturn.size());
0:       for (NameValuePair<String, NameValueMap<String, String>> nvp : exportPackageReturn) {
1:         if (nvp.getName().equals("com.acme.foo")) {
1:           i++;
1:           
0:           assertTrue("The directive or attribute should not be set.", nvp.getValue().isEmpty() );
0:         } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getValue().get("version")))) {
1:         
1:           
1:           i++;
0:           assertEquals("The directive is wrong.", "dodo", nvp.getValue().get("company"));
0:           assertEquals("The directive is wrong.", "false", nvp.getValue().get("security"));
0:           assertEquals("The directive is wrong.", "security,company", nvp.getValue().get("mandatory:"));
1:         } 
1:       }
1:       // make sure all three packages stored
1:       assertEquals("The names of the packages are wrong.", 2, i);
1:       
1:     }
1:     
0:     private String createExpectedFilter(NameValueMap<String, String> values, String ... parts)
1:     {
1:       StringBuilder builder = new StringBuilder(parts[0]);
1:       
1:       for (Map.Entry<String, String> entry : values.entrySet()) {
1:         if ("version".equals(entry.getKey())) builder.append(parts[2]);
1:         else if ("company".equals(entry.getKey())) builder.append(parts[1]);
1:       }
1:       
1:       builder.append(parts[3]);
1:       
1:       return builder.toString();
1:     }
1:     
1:     /**
1:      * Test the filter generated correctly
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testGenerateFilter() throws Exception {
0:       NameValueMap<String, String> valueMap = new NameValueMap<String, String>();
0:       valueMap.addToCollection("version", "[1.2, 2.3]");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
1:       String filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:       String expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)", "(mandatory:<*company))");
1:       assertEquals("The filter is wrong.", expected, filter );
1:       
1:       
1:       valueMap.clear();
1:       
0:       valueMap.addToCollection("version", "(1.2, 2.3]");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
1:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))", "(mandatory:<*company))");
1:       assertEquals("The filter is wrong.", expected, filter );
1:       
1:       valueMap.clear();
1:       
0:       valueMap.addToCollection("version", "(1.2, 2.3)");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
1:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))(!(version=2.3.0))", "(mandatory:<*company))");
1:       assertEquals("The filter is wrong.", expected, filter );
1:       
1:       valueMap.clear();
1:       
0:       valueMap.addToCollection("version", "1.2");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
1:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)", "(mandatory:<*company))");
1:       assertEquals("The filter is wrong.", expected, filter );
1:       
1:       valueMap.clear();
1:       
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
1:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
1:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "", "(mandatory:<*company))");
1:       assertEquals("The filter is wrong.", expected, filter );
1:     }
1:     
1:     /**
1:      * Test the version range created correctly
1:      * @throws Exception
1:      */
1:     
1:     @Test
1:     public void testVersionRange() throws Exception {
1:       String version1 = "[1.2.3, 4.5.6]";
1:       String version2="(1, 2]";
1:       String version3="[2,4)";
1:       String version4="(1,2)";
1:       String version5="2";
1:       String version6 = "2.3";
1:       String version7="[1.2.3.q, 2.3.4.p)";
1:       String version8="1.2.2.5";
1:       String version9="a.b.c";
1:       String version10=null;
1:       String version11="";
1:       String version12="\"[1.2.3, 4.5.6]\"";
1:       
1:       VersionRange vr = ManifestHeaderProcessor.parseVersionRange(version1);
1:       assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
1:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:       assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
1:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange(version2);
1:       assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
1:       assertTrue("The value is wrong", vr.isMinimumExclusive());
1:       assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
1:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange(version3);
1:       
1:       assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
1:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:       assertEquals("The value is wrong", "4.0.0", vr.getMaximumVersion().toString());
1:       assertTrue("The value is wrong", vr.isMaximumExclusive());
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange(version4);
1:       
1:       assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
1:       assertTrue("The value is wrong", vr.isMinimumExclusive());
1:       assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
1:       assertTrue("The value is wrong", vr.isMaximumExclusive());
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange(version5);
1:       assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
1:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:       assertNull("The value is wrong", vr.getMaximumVersion());
1:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange(version6);
1:       assertEquals("The value is wrong", "2.3.0", vr.getMinimumVersion().toString());
1:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:       assertNull("The value is wrong", vr.getMaximumVersion());
1:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange(version7);
1:       assertEquals("The value is wrong", "1.2.3.q", vr.getMinimumVersion().toString());
1:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:       assertEquals("The value is wrong", "2.3.4.p", vr.getMaximumVersion().toString());
1:       assertTrue("The value is wrong", vr.isMaximumExclusive());
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange(version8);
1:       assertEquals("The value is wrong", "1.2.2.5", vr.getMinimumVersion().toString());
1:       assertFalse("The value is wrong", vr.isMinimumExclusive());
1:       assertNull("The value is wrong", vr.getMaximumVersion());
1:       assertFalse("The value is wrong", vr.isMaximumExclusive());
1:       boolean exception = false;
1:       try {
1:       vr = ManifestHeaderProcessor.parseVersionRange(version9);
1:       } catch (Exception e){
1:         exception = true;
1:       }
1:       
1:       assertTrue("The value is wrong", exception);
1:       boolean exceptionNull = false;
1:       try {
1:         vr = ManifestHeaderProcessor.parseVersionRange(version10);
1:         } catch (Exception e){
1:           exceptionNull = true;
1:         }
1:         assertTrue("The value is wrong", exceptionNull);
1:         // empty version should be defaulted to >=0.0.0
1:         vr = ManifestHeaderProcessor.parseVersionRange(version11);
1:         assertEquals("The value is wrong", "0.0.0", vr.getMinimumVersion().toString());
1:         assertFalse("The value is wrong", vr.isMinimumExclusive());
1:         assertNull("The value is wrong", vr.getMaximumVersion());
1:         assertFalse("The value is wrong", vr.isMaximumExclusive());
1:           
1:           
1:           vr = ManifestHeaderProcessor.parseVersionRange(version12);
1:           assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
1:           assertFalse("The value is wrong", vr.isMinimumExclusive());
1:           assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
1:           assertFalse("The value is wrong", vr.isMaximumExclusive());  
1:     }
1:     
1:     @Test
1:     public void testInvalidVersions() throws Exception
1:     {
1:       try {
1:         ManifestHeaderProcessor.parseVersionRange("a");
1:         assertTrue("Should have thrown an exception", false);
1:       } catch (IllegalArgumentException e) {
0:         assertEquals(MessageUtil.getMessage("APPUTILS0009E", "a"), e.getMessage());
1:       }
1:       
1:       try {
1:         ManifestHeaderProcessor.parseVersionRange("[1.0.0,1.0.1]", true);
1:         assertTrue("Should have thrown an exception", false);
1:       } catch (IllegalArgumentException e) {
0:         assertEquals(MessageUtil.getMessage("APPUTILS0011E", "[1.0.0,1.0.1]"), e.getMessage());
1:       }
1: 
1:     }
1: 
1:     @Test
1:     public void testSplit() throws Exception {
1:       String export = "com.ibm.ws.eba.obr.fep.bundle122;version=\"3\";company=mood;local=yes;security=yes;mandatory:=\"mood,security\"";
1:       List<String> result = ManifestHeaderProcessor.split(export, ",");
1:       assertEquals("The result is wrong.", export, result.get(0));
1:       assertEquals("The result is wrong.", 1, result.size());
1:       
1:       String aString = "com.acme.foo;weirdAttr=\"one;two;three\";weirdDir:=\"1;2;3\"";
1:       result = ManifestHeaderProcessor.split(aString, ";");
1:       assertEquals("The result is wrong.", "com.acme.foo", result.get(0));
1:       assertEquals("The result is wrong.", "weirdAttr=\"one;two;three\"", result.get(1));
1:       assertEquals("The result is wrong.", "weirdDir:=\"1;2;3\"", result.get(2));
1:       
1:       assertEquals("The result is wrong.", 3, result.size());
1:       
1:       
1:       
1:       
1:       String pkg1 = "com.ibm.ws.eba.example.helloIsolation;version=\"1.0.0\" ";
1:       String pkg2 = "com.ibm.ws.eba.helloWorldService;version=\"[1.0.0,1.0.0]\"";
1:       String pkg3 = " com.ibm.ws.eba.helloWorldService;version=\"1.0.0\"";
1:       String pkg4 = "com.ibm.ws.eba.helloWorldService;version=\"[1.0.0,1.0.0]\";sharing:=shared" ;
1:       String pkg5 = "com.ibm.ws.eba.helloWorldService;sharing:=shared;version=\"[1.0.0,1.0.0]\"";
1:       String appContent1 = pkg1 + ", " + pkg2 + ", " + pkg3;
1:       String appContent2 = pkg2 + ", " + pkg1 + ", " + pkg3;
1:       String appContent3 = pkg1 + ", " + pkg3 + ", " + pkg2;
1:       String appContent4 = pkg1 + ", " + pkg3 + ", " + pkg4;
1:       String appContent5 = pkg1 + ", " + pkg3 + ", " + pkg5;
1:       
1:       List<String> splitList = ManifestHeaderProcessor.split(appContent1, ",");
1:       assertEquals(pkg1.trim(), splitList.get(0));
1:       assertEquals(pkg2.trim(), splitList.get(1));
1:       assertEquals(pkg3.trim(), splitList.get(2));
1:       
1:       splitList = ManifestHeaderProcessor.split(appContent2, ",");
1:       assertEquals(pkg2.trim(), splitList.get(0));
1:       assertEquals(pkg1.trim(), splitList.get(1));
1:       assertEquals(pkg3.trim(), splitList.get(2));
1:       
1:       splitList = ManifestHeaderProcessor.split(appContent3, ",");
1:       assertEquals(pkg1.trim(), splitList.get(0));
1:       assertEquals(pkg3.trim(), splitList.get(1));
1:       assertEquals(pkg2.trim(), splitList.get(2));
1:       
1:       splitList = ManifestHeaderProcessor.split(appContent4, ",");
1:       assertEquals(pkg1.trim(), splitList.get(0));
1:       assertEquals(pkg3.trim(), splitList.get(1));
1:       assertEquals(pkg4.trim(), splitList.get(2));
1:       
1:       splitList = ManifestHeaderProcessor.split(appContent5, ",");
1:       assertEquals(pkg1.trim(), splitList.get(0));
1:       assertEquals(pkg3.trim(), splitList.get(1));
0:       assertEquals(pkg5.trim(), splitList.get(2));   
1:     }
1:     
1:     @Test
1:     public void testParseFilter()
1:     {
1:       Map<String,String> attrs = ManifestHeaderProcessor.parseFilter("(package=com.ibm.test)");
1:       assertEquals("com.ibm.test", attrs.get("package"));
1:       
1:       attrs = ManifestHeaderProcessor.parseFilter("(&(package=com.ibm.test)(attr=value))");
1:       assertEquals("com.ibm.test", attrs.get("package"));
1:       assertEquals("value", attrs.get("attr"));
1:       assertEquals(2, attrs.size());
1:       
1:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0))");
1:       assertEquals("1.0.0", attrs.get("version"));
1:       
1:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0))");
1:       assertEquals("[1.0.0,2.0.0]", attrs.get("version"));
1: 
1:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0)(!(version=1.0.0)))");
1:       assertEquals("(1.0.0,2.0.0]", attrs.get("version"));
1: 
1:       attrs = ManifestHeaderProcessor.parseFilter("(&(!(version=2.0.0))(!(version=1.0.0))(version>=1.0.0)(version<=2.0.0))");
1:       assertEquals("(1.0.0,2.0.0)", attrs.get("version"));
1:     }
1:     
1:     @Test
0:     public void testExactVersion() throws Exception 
1:     {
1:       VersionRange vr;
1:       try {
1:         vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 2.0.0]", true);
1:         fail("should not get here 1");
1:       } catch (IllegalArgumentException e) {
1:         // expected
1:       }
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0]", true);
1:       assertTrue(vr.isExactVersion());
1:       
1:       try {
1:         vr = ManifestHeaderProcessor.parseVersionRange("(1.0.0, 1.0.0]", true);
1:         fail("should not get here 2");
1:       } catch (IllegalArgumentException e) {
1:         // expected
1:       }
1:       
1:       try {
1:         vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0)", true);
1:         fail("should not get here 3");
1:       } catch (IllegalArgumentException e) {
1:         // expected
1:       }
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 2.0.0]");
1:       assertFalse(vr.isExactVersion());
1:       
1:       vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0]");
1:       assertTrue(vr.isExactVersion());
1:       
1:       
1:     }
1: }
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:5959a0a
/////////////////////////////////////////////////////////////////////////
0:     private String createExpectedFilter(NameValueMap<String, String> values, String ... parts)
0:     {
0:       StringBuilder builder = new StringBuilder(parts[0]);
0:       
0:       for (Map.Entry<String, String> entry : values.entrySet()) {
0:         if ("version".equals(entry.getKey())) builder.append(parts[2]);
0:         else if ("company".equals(entry.getKey())) builder.append(parts[1]);
0:       }
0:       
0:       builder.append(parts[3]);
0:       
0:       return builder.toString();
0:     }
0:     
0:     /**
0:      * Test the filter generated correctly
0:      * @throws Exception
0:      */
0:     @Test
0:     public void testGenerateFilter() throws Exception {
0:       NameValueMap<String, String> valueMap = new NameValueMap<String, String>();
0:       valueMap.addToCollection("version", "[1.2, 2.3]");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       String filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       String expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)", "(mandatory:<*company))");
0:       assertEquals("The filter is wrong.", expected, filter );
0:       
0:       
0:       valueMap.clear();
0:       
0:       valueMap.addToCollection("version", "(1.2, 2.3]");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))", "(mandatory:<*company))");
0:       assertEquals("The filter is wrong.", expected, filter );
0:       
0:       valueMap.clear();
0:       
0:       valueMap.addToCollection("version", "(1.2, 2.3)");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))(!(version=2.3.0))", "(mandatory:<*company))");
0:       assertEquals("The filter is wrong.", expected, filter );
0:       
0:       valueMap.clear();
0:       
0:       valueMap.addToCollection("version", "1.2");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)", "(mandatory:<*company))");
0:       assertEquals("The filter is wrong.", expected, filter );
0:       
0:       valueMap.clear();
0:       
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "", "(mandatory:<*company))");
0:       assertEquals("The filter is wrong.", expected, filter );
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
0:     @Test
0:     public void testParseFilter()
0:     {
0:       Map<String,String> attrs = ManifestHeaderProcessor.parseFilter("(package=com.ibm.test)");
0:       assertEquals("com.ibm.test", attrs.get("package"));
0:       
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(package=com.ibm.test)(attr=value))");
0:       assertEquals("com.ibm.test", attrs.get("package"));
0:       assertEquals("value", attrs.get("attr"));
0:       assertEquals(2, attrs.size());
0:       
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0))");
0:       assertEquals("1.0.0", attrs.get("version"));
0:       
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0))");
0:       assertEquals("[1.0.0,2.0.0]", attrs.get("version"));
0: 
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0)(!(version=1.0.0)))");
0:       assertEquals("(1.0.0,2.0.0]", attrs.get("version"));
0: 
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(!(version=2.0.0))(!(version=1.0.0))(version>=1.0.0)(version<=2.0.0))");
0:       assertEquals("(1.0.0,2.0.0)", attrs.get("version"));
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0: }
commit:2227f26
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: package org.apache.aries.application.utils.manifest;
0: 
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertFalse;
0: import static org.junit.Assert.assertNotSame;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.fail;
0: 
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.Map;
0: 
0: import org.apache.aries.application.VersionRange;
0: import org.apache.aries.application.utils.internal.MessageUtil;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor.NameValueMap;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor.NameValuePair;
0: import org.junit.Test;
0: 
0: public class ManifestHeaderProcessorTest
0: {
0:   @Test
0:   public void testNameValuePair() throws Exception {
0:     NameValuePair<String, String> nvp = new NameValuePair<String, String>("key", "value");
0:     assertEquals("The name value pair is not set properly.", nvp.getName(), "key");
0:     assertEquals("The value is not set properly.", nvp.getValue(), "value");
0:     NameValuePair<String, String> anotherNvp = new NameValuePair<String, String>("key", "value");
0:     assertEquals("The two objects of NameValuePair is not equal.", nvp, anotherNvp);
0:     nvp.setName("newKey");
0:     nvp.setValue("newValue");
0:     assertEquals("The name value pair is not set properly.", nvp.getName(), "newKey");
0:     assertEquals("The value is not set properly.", nvp.getValue(), "newValue");
0:     
0:     NameValueMap<String,String> nvm1 = new NameValueMap<String,String>();
0:     nvm1.put("a","b");
0:     nvm1.put("c","d");
0:     NameValueMap<String,String> nvm2 = new NameValueMap<String,String>();
0:     nvm2.put("c","d");
0:     nvm2.put("a","b");
0:     assertEquals("The maps are not equal.", nvm1, nvm2);
0:     nvm2.put("e","f");
0:     assertNotSame("The maps are the same.", nvm1, nvm2);
0:     
0:     NameValuePair<String, NameValueMap<String,String>> nvp1 = new NameValuePair<String,NameValueMap<String,String>>("one",nvm1);
0:     NameValuePair<String, NameValueMap<String,String>> nvp2 = new NameValuePair<String,NameValueMap<String,String>>("one",nvm2);
0:     
0:     assertNotSame("The pairs are identical ",nvp1,nvp2);
0:     nvm1.put("e","f");
0:     assertEquals("The pairs are not equal.", nvp1,nvp2);
0:     
0:     List<NameValuePair<String, NameValueMap<String,String>>> bundleInfoList1 = new ArrayList<NameValuePair<String, NameValueMap<String,String>>>();
0:     bundleInfoList1.add(nvp1);
0: 
0:     List<NameValuePair<String, NameValueMap<String,String>>> bundleInfoList2 = new ArrayList<NameValuePair<String, NameValueMap<String,String>>>();
0:     bundleInfoList2.add(nvp1);
0:     
0:     bundleInfoList1.removeAll(bundleInfoList2);
0:     assertEquals("The List should be empty", bundleInfoList1.isEmpty(), true);
0:    
0:    
0:     assertNotSame("The two objects of NameValuePair is not equal.", nvp, anotherNvp);
0:   }
0: 
0:   
0:   /**
0:    * Test the Bundle manifest header entry of
0:    * Bundle-SymbolicName: com.acme.foo;singleton:=true
0:    */
0:   @Test
0:   public void testParseBundleSymbolicName() 
0:   {
0:     String bundleSymbolicNameEntry = "com.acme.foo;singleton:=true;fragment-attachment:=always";
0:     NameValuePair<String, NameValueMap<String, String>> nvp = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry);
0:     assertEquals("The symbolic name is wrong.", nvp.getName(), "com.acme.foo");
0:     assertEquals("The value is wrong.", "true", nvp.getValue().get("singleton:") );
0:     assertEquals("The directive is wrong.", "always", nvp.getValue().get("fragment-attachment:") );
0:   
0:     String bundleSymbolicNameEntry2 = "com.acme.foo";
0:     NameValuePair<String, NameValueMap<String, String>> nvp2 = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry2);
0:     assertEquals("The symbolic name is wrong.", nvp2.getName(), "com.acme.foo");
0:     
0:     
0:   
0:   
0:   }
0:   
0:  
0: 
0:   /**
0:    * Test the import package and import service
0:    * Import-Package: com.acme.foo;come.acm,e.bar;version="[1.23,1.24.5]";resolution:=mandatory
0:    */
0:   @Test
0:   public void testParseImportString()
0:   {
0:     String importPackage = "com.acme.foo,come.acm.e.bar;version=\"[1.23,1.24.5]\";resolution:=mandatory;company=\"ACME\",a.b.c;version=1.2.3;company=com";
0:   
0:     Map<String, NameValueMap<String, String>> importPackageReturn = ManifestHeaderProcessor.parseImportString(importPackage);
0:   
0:     assertTrue("The package is not set.", importPackageReturn.containsKey("com.acme.foo"));
0:     assertTrue("The package is not set.", importPackageReturn.containsKey("come.acm.e.bar"));
0:     assertTrue("The package is not set.", importPackageReturn.containsKey("come.acm.e.bar"));
0:     assertTrue("The package is not set.", importPackageReturn.containsKey("a.b.c"));
0:     assertTrue("The package should not contain any attributes.", importPackageReturn.get("com.acme.foo").isEmpty());
0:     assertEquals("The directive is not set correctly.", "[1.23,1.24.5]", importPackageReturn.get("come.acm.e.bar").get("version"));
0:     assertEquals("The directive is not set correctly.", "mandatory", importPackageReturn.get("come.acm.e.bar").get("resolution:"));
0:     assertEquals("The directive is not set correctly.", "ACME", importPackageReturn.get("come.acm.e.bar").get("company"));
0:     assertEquals("The directive is not set correctly.", "1.2.3", importPackageReturn.get("a.b.c").get("version"));
0:     assertEquals("The directive is not set correctly.", "com", importPackageReturn.get("a.b.c").get("company"));
0:     
0:     importPackage="com.acme.foo";
0:     
0:     assertTrue("The package is not set.", importPackageReturn.containsKey("com.acme.foo"));
0:     assertTrue("The package should not contain any attributes.", importPackageReturn.get("com.acme.foo").isEmpty());
0:     
0:     importPackage="com.acme.foo;com.acme.bar;version=2";
0:     Map<String, NameValueMap<String, String>> importPackageReturn2 = ManifestHeaderProcessor.parseImportString(importPackage);
0:     assertTrue("The package is not set.", importPackageReturn2.containsKey("com.acme.foo"));
0:     assertTrue("The package is not set.", importPackageReturn2.containsKey("com.acme.bar"));
0:     assertEquals("The directive is not set correctly.", "2", importPackageReturn2.get("com.acme.foo").get("version"));
0:     assertEquals("The directive is not set correctly.", "2", importPackageReturn2.get("com.acme.bar").get("version"));
0:   }
0:   @Test
0:   public void testParseExportString()
0:   {
0:     String exportPackage = "com.acme.foo,com.acme.bar;version=1,com.acme.bar;version=2;uses:=\"a.b.c,d.e.f\";security=false;mandatory:=security";
0:   
0:     List<NameValuePair<String, NameValueMap<String, String>>> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
0:     
0:     int i =0;
0:     assertEquals("The number of the packages is wrong.", 3, exportPackageReturn.size());
0:     for (NameValuePair<String, NameValueMap<String, String>> nvp : exportPackageReturn) {
0:       if (nvp.getName().equals("com.acme.foo")) {
0:         i++;
0:         
0:         assertTrue("The directive or attribute should not be set.", nvp.getValue().isEmpty() );
0:       } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getValue().get("version")))) {
0:       
0:         
0:         i++;
0:         assertEquals("The directive is wrong.", "a.b.c,d.e.f", nvp.getValue().get("uses:"));
0:         assertEquals("The directive is wrong.", "false", nvp.getValue().get("security"));
0:         assertEquals("The directive is wrong.", "security", nvp.getValue().get("mandatory:"));
0:       } else if ((nvp.getName().equals("com.acme.bar")) && ("1".equals(nvp.getValue().get("version")))) {
0:         i++;
0:         
0:         assertNull("The directive is wrong.", nvp.getValue().get("uses:"));
0:         assertNull("The directive is wrong.", nvp.getValue().get("security"));
0:         assertNull("The directive is wrong.", nvp.getValue().get("mandatory:"));
0:       }
0:     }
0:     // make sure all three packages stored
0:     assertEquals("The names of the packages are wrong.", 3, i);
0:     
0:     exportPackage = "com.acme.foo";
0:     
0:     exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
0:     
0:     int k =0;
0:     assertEquals("The number of the packages is wrong.", 1, exportPackageReturn.size());
0:     for (NameValuePair<String, NameValueMap<String, String>> nvp : exportPackageReturn) {
0:       if (nvp.getName().equals("com.acme.foo")) {
0:         k++;
0:         
0:         assertTrue("The directive or attribute should not be set.", nvp.getValue().isEmpty() );
0:       } 
0:     }
0:     assertEquals("The names of the packages are wrong.", 1, k);
0:     
0:     // test multiple packages separated by ;
0:     
0:     exportPackage = "com.acme.foo;com.acme.bar;version=\"2\";resolution:=optional";
0:     
0:     exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
0:     
0:     k =0;
0:     assertEquals("The number of the packages is wrong.", 2, exportPackageReturn.size());
0:     for (NameValuePair<String, NameValueMap<String, String>> nvp : exportPackageReturn) {
0:       if (nvp.getName().equals("com.acme.foo")) {
0:         k++;
0:         
0:         assertEquals("The attribute is wrong.", "2", nvp.getValue().get("version") );
0:         assertEquals("The attribute is wrong.", "optional", nvp.getValue().get("resolution:"));
0:       } else if (nvp.getName().equals("com.acme.bar")) {
0:         k++;
0:         
0:         assertEquals("The attribute is wrong.", "2", nvp.getValue().get("version") );
0:         assertEquals("The attribute is wrong.", "optional", nvp.getValue().get("resolution:"));
0:       }
0:     }
0:     assertEquals("The names of the packages are wrong.", 2, k);
0:     
0:     
0:     
0:     }
0:     
0:     @Test
0:     public void testExportMandatoryAttributes() {
0:       String exportPackage = "com.acme.foo,com.acme.bar;version=2;company=dodo;security=false;mandatory:=\"security,company\"";
0:       
0:       List<NameValuePair<String, NameValueMap<String, String>>> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
0:       
0:       int i =0;
0:       assertEquals("The number of the packages is wrong.", 2, exportPackageReturn.size());
0:       for (NameValuePair<String, NameValueMap<String, String>> nvp : exportPackageReturn) {
0:         if (nvp.getName().equals("com.acme.foo")) {
0:           i++;
0:           
0:           assertTrue("The directive or attribute should not be set.", nvp.getValue().isEmpty() );
0:         } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getValue().get("version")))) {
0:         
0:           
0:           i++;
0:           assertEquals("The directive is wrong.", "dodo", nvp.getValue().get("company"));
0:           assertEquals("The directive is wrong.", "false", nvp.getValue().get("security"));
0:           assertEquals("The directive is wrong.", "security,company", nvp.getValue().get("mandatory:"));
0:         } 
0:       }
0:       // make sure all three packages stored
0:       assertEquals("The names of the packages are wrong.", 2, i);
0:       
0:     }
0:     
0:     /**
0:      * Test the version range created correctly
0:      * @throws Exception
0:      */
0:     
0:     @Test
0:     public void testVersionRange() throws Exception {
0:       String version1 = "[1.2.3, 4.5.6]";
0:       String version2="(1, 2]";
0:       String version3="[2,4)";
0:       String version4="(1,2)";
0:       String version5="2";
0:       String version6 = "2.3";
0:       String version7="[1.2.3.q, 2.3.4.p)";
0:       String version8="1.2.2.5";
0:       String version9="a.b.c";
0:       String version10=null;
0:       String version11="";
0:       String version12="\"[1.2.3, 4.5.6]\"";
0:       
0:       VersionRange vr = ManifestHeaderProcessor.parseVersionRange(version1);
0:       assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
0:       assertFalse("The value is wrong", vr.isMinimumExclusive());
0:       assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
0:       assertFalse("The value is wrong", vr.isMaximumExclusive());
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange(version2);
0:       assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
0:       assertTrue("The value is wrong", vr.isMinimumExclusive());
0:       assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
0:       assertFalse("The value is wrong", vr.isMaximumExclusive());
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange(version3);
0:       
0:       assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
0:       assertFalse("The value is wrong", vr.isMinimumExclusive());
0:       assertEquals("The value is wrong", "4.0.0", vr.getMaximumVersion().toString());
0:       assertTrue("The value is wrong", vr.isMaximumExclusive());
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange(version4);
0:       
0:       assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
0:       assertTrue("The value is wrong", vr.isMinimumExclusive());
0:       assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
0:       assertTrue("The value is wrong", vr.isMaximumExclusive());
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange(version5);
0:       assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
0:       assertFalse("The value is wrong", vr.isMinimumExclusive());
0:       assertNull("The value is wrong", vr.getMaximumVersion());
0:       assertFalse("The value is wrong", vr.isMaximumExclusive());
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange(version6);
0:       assertEquals("The value is wrong", "2.3.0", vr.getMinimumVersion().toString());
0:       assertFalse("The value is wrong", vr.isMinimumExclusive());
0:       assertNull("The value is wrong", vr.getMaximumVersion());
0:       assertFalse("The value is wrong", vr.isMaximumExclusive());
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange(version7);
0:       assertEquals("The value is wrong", "1.2.3.q", vr.getMinimumVersion().toString());
0:       assertFalse("The value is wrong", vr.isMinimumExclusive());
0:       assertEquals("The value is wrong", "2.3.4.p", vr.getMaximumVersion().toString());
0:       assertTrue("The value is wrong", vr.isMaximumExclusive());
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange(version8);
0:       assertEquals("The value is wrong", "1.2.2.5", vr.getMinimumVersion().toString());
0:       assertFalse("The value is wrong", vr.isMinimumExclusive());
0:       assertNull("The value is wrong", vr.getMaximumVersion());
0:       assertFalse("The value is wrong", vr.isMaximumExclusive());
0:       boolean exception = false;
0:       try {
0:       vr = ManifestHeaderProcessor.parseVersionRange(version9);
0:       } catch (Exception e){
0:         exception = true;
0:       }
0:       
0:       assertTrue("The value is wrong", exception);
0:       boolean exceptionNull = false;
0:       try {
0:         vr = ManifestHeaderProcessor.parseVersionRange(version10);
0:         } catch (Exception e){
0:           exceptionNull = true;
0:         }
0:         assertTrue("The value is wrong", exceptionNull);
0:         // empty version should be defaulted to >=0.0.0
0:         vr = ManifestHeaderProcessor.parseVersionRange(version11);
0:         assertEquals("The value is wrong", "0.0.0", vr.getMinimumVersion().toString());
0:         assertFalse("The value is wrong", vr.isMinimumExclusive());
0:         assertNull("The value is wrong", vr.getMaximumVersion());
0:         assertFalse("The value is wrong", vr.isMaximumExclusive());
0:           
0:           
0:           vr = ManifestHeaderProcessor.parseVersionRange(version12);
0:           assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
0:           assertFalse("The value is wrong", vr.isMinimumExclusive());
0:           assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
0:           assertFalse("The value is wrong", vr.isMaximumExclusive());  
0:     }
0:     
0:     @Test
0:     public void testInvalidVersions() throws Exception
0:     {
0:       try {
0:         ManifestHeaderProcessor.parseVersionRange("a");
0:         assertTrue("Should have thrown an exception", false);
0:       } catch (IllegalArgumentException e) {
0:         assertEquals(MessageUtil.getMessage("APPUTILS0009E", "a"), e.getMessage());
0:       }
0:       
0:       try {
0:         ManifestHeaderProcessor.parseVersionRange("[1.0.0,1.0.1]", true);
0:         assertTrue("Should have thrown an exception", false);
0:       } catch (IllegalArgumentException e) {
0:         assertEquals(MessageUtil.getMessage("APPUTILS0011E", "[1.0.0,1.0.1]"), e.getMessage());
0:       }
0: 
0:     }
0:     
0:     /**
0:      * Test the filter generated correctly
0:      * @throws Exception
0:      */
0:   
0:     @Test
0:     public void testGenerateFilter() throws Exception {
0:       NameValueMap<String, String> valueMap = new NameValueMap<String, String>();
0:       valueMap.addToCollection("version", "[1.2, 2.3]");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       String filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       assertEquals("The filter is wrong.","(&(symbolic-name=com.ibm.foo)(version>=1.2.0)(version<=2.3.0)(company=com)(mandatory:<*company))", filter );
0:       
0:       
0:       valueMap.clear();
0:       
0:       valueMap.addToCollection("version", "(1.2, 2.3]");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       assertEquals("The filter is wrong.","(&(symbolic-name=com.ibm.foo)(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))(company=com)(mandatory:<*company))", filter );
0:       
0:       valueMap.clear();
0:       
0:       valueMap.addToCollection("version", "(1.2, 2.3)");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       assertEquals("The filter is wrong.","(&(symbolic-name=com.ibm.foo)(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))(!(version=2.3.0))(company=com)(mandatory:<*company))", filter );
0:       
0:       
0:       valueMap.clear();
0:       
0:       valueMap.addToCollection("version", "1.2");
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       assertEquals("The filter is wrong.","(&(symbolic-name=com.ibm.foo)(version>=1.2.0)(company=com)(mandatory:<*company))", filter );
0:       
0:       valueMap.clear();
0:       
0:       
0:       valueMap.addToCollection("resulution:", "mandatory");
0:       valueMap.addToCollection("company", "com");
0:       filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
0:       assertEquals("The filter is wrong.","(&(symbolic-name=com.ibm.foo)(company=com)(mandatory:<*company))", filter );
0:     }
0:     
0:     @Test
0:     public void testParseFilter()
0:     {
0:       Map<String,String> attrs = ManifestHeaderProcessor.parseFilter("(package=com.ibm.test)");
0:       assertEquals("com.ibm.test", attrs.get("package"));
0:       
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(package=com.ibm.test)(attr=value))");
0:       assertEquals("com.ibm.test", attrs.get("package"));
0:       assertEquals("value", attrs.get("attr"));
0:       assertEquals(2, attrs.size());
0:       
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0))");
0:       assertEquals("1.0.0", attrs.get("version"));
0:       
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0))");
0:       assertEquals("[1.0.0,2.0.0]", attrs.get("version"));
0: 
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0)(!(version=1.0.0)))");
0:       assertEquals("(1.0.0,2.0.0]", attrs.get("version"));
0: 
0:       attrs = ManifestHeaderProcessor.parseFilter("(&(!(version=2.0.0))(!(version=1.0.0))(version>=1.0.0)(version<=2.0.0))");
0:       assertEquals("(1.0.0,2.0.0)", attrs.get("version"));
0:     }
0:     
0:     @Test
0:     public void testSplit() throws Exception {
0:       String export = "com.ibm.ws.eba.obr.fep.bundle122;version=\"3\";company=mood;local=yes;security=yes;mandatory:=\"mood,security\"";
0:       List<String> result = ManifestHeaderProcessor.split(export, ",");
0:       assertEquals("The result is wrong.", export, result.get(0));
0:       assertEquals("The result is wrong.", 1, result.size());
0:       
0:       String aString = "com.acme.foo;weirdAttr=\"one;two;three\";weirdDir:=\"1;2;3\"";
0:       result = ManifestHeaderProcessor.split(aString, ";");
0:       assertEquals("The result is wrong.", "com.acme.foo", result.get(0));
0:       assertEquals("The result is wrong.", "weirdAttr=\"one;two;three\"", result.get(1));
0:       assertEquals("The result is wrong.", "weirdDir:=\"1;2;3\"", result.get(2));
0:       
0:       assertEquals("The result is wrong.", 3, result.size());
0:       
0:       
0:       
0:       
0:       String pkg1 = "com.ibm.ws.eba.example.helloIsolation;version=\"1.0.0\" ";
0:       String pkg2 = "com.ibm.ws.eba.helloWorldService;version=\"[1.0.0,1.0.0]\"";
0:       String pkg3 = " com.ibm.ws.eba.helloWorldService;version=\"1.0.0\"";
0:       String pkg4 = "com.ibm.ws.eba.helloWorldService;version=\"[1.0.0,1.0.0]\";sharing:=shared" ;
0:       String pkg5 = "com.ibm.ws.eba.helloWorldService;sharing:=shared;version=\"[1.0.0,1.0.0]\"";
0:       String appContent1 = pkg1 + ", " + pkg2 + ", " + pkg3;
0:       String appContent2 = pkg2 + ", " + pkg1 + ", " + pkg3;
0:       String appContent3 = pkg1 + ", " + pkg3 + ", " + pkg2;
0:       String appContent4 = pkg1 + ", " + pkg3 + ", " + pkg4;
0:       String appContent5 = pkg1 + ", " + pkg3 + ", " + pkg5;
0:       
0:       List<String> splitList = ManifestHeaderProcessor.split(appContent1, ",");
0:       assertEquals(pkg1.trim(), splitList.get(0));
0:       assertEquals(pkg2.trim(), splitList.get(1));
0:       assertEquals(pkg3.trim(), splitList.get(2));
0:       
0:       splitList = ManifestHeaderProcessor.split(appContent2, ",");
0:       assertEquals(pkg2.trim(), splitList.get(0));
0:       assertEquals(pkg1.trim(), splitList.get(1));
0:       assertEquals(pkg3.trim(), splitList.get(2));
0:       
0:       splitList = ManifestHeaderProcessor.split(appContent3, ",");
0:       assertEquals(pkg1.trim(), splitList.get(0));
0:       assertEquals(pkg3.trim(), splitList.get(1));
0:       assertEquals(pkg2.trim(), splitList.get(2));
0:       
0:       splitList = ManifestHeaderProcessor.split(appContent4, ",");
0:       assertEquals(pkg1.trim(), splitList.get(0));
0:       assertEquals(pkg3.trim(), splitList.get(1));
0:       assertEquals(pkg4.trim(), splitList.get(2));
0:       
0:       splitList = ManifestHeaderProcessor.split(appContent5, ",");
0:       assertEquals(pkg1.trim(), splitList.get(0));
0:       assertEquals(pkg3.trim(), splitList.get(1));
0:       assertEquals(pkg5.trim(), splitList.get(2));   
0:     }
0:  
0:     @Test
0:     public void testExactVersion() throws Exception 
0:     {
0:       VersionRange vr;
0:       try {
0:         vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 2.0.0]", true);
0:         fail("should not get here 1");
0:       } catch (IllegalArgumentException e) {
0:         // expected
0:       }
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0]", true);
0:       assertTrue(vr.isExactVersion());
0:       
0:       try {
0:         vr = ManifestHeaderProcessor.parseVersionRange("(1.0.0, 1.0.0]", true);
0:         fail("should not get here 2");
0:       } catch (IllegalArgumentException e) {
0:         // expected
0:       }
0:       
0:       try {
0:         vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0)", true);
0:         fail("should not get here 3");
0:       } catch (IllegalArgumentException e) {
0:         // expected
0:       }
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 2.0.0]");
0:       assertFalse(vr.isExactVersion());
0:       
0:       vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0]");
0:       assertTrue(vr.isExactVersion());
0:       
0:       
0:     }
0:   
0:     
0: 
0:   }
0: 
0: 
============================================================================