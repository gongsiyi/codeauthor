1:f13c6ac: /*
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
1:f13c6ac: 
1:f13c6ac: import java.util.ArrayList;
1:f13c6ac: import java.util.Collections;
1:f13c6ac: import java.util.HashMap;
1:f13c6ac: import java.util.HashSet;
1:f13c6ac: import java.util.List;
1:f13c6ac: import java.util.Properties;
1:f13c6ac: import java.util.Set;
1:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:6414875: import org.apache.aries.blueprint.ExtendedBeanMetadata;
1:d46274e: import org.apache.aries.blueprint.ExtendedReferenceMetadata;
1:d46274e: import org.apache.aries.blueprint.ExtendedServiceReferenceMetadata;
1:09a7647: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:e2445d0: import org.apache.aries.blueprint.utils.ServiceListener;
1:2f55d71: import org.apache.aries.blueprint.PassThroughMetadata;
1:6414875: import org.apache.aries.blueprint.di.ArrayRecipe;
1:6414875: import org.apache.aries.blueprint.di.CollectionRecipe;
1:1cfd24a: import org.apache.aries.blueprint.di.ComponentFactoryRecipe;
1:1cfd24a: import org.apache.aries.blueprint.di.DependentComponentFactoryRecipe;
1:6414875: import org.apache.aries.blueprint.di.IdRefRecipe;
1:6414875: import org.apache.aries.blueprint.di.MapRecipe;
1:2f55d71: import org.apache.aries.blueprint.di.PassThroughRecipe;
1:6414875: import org.apache.aries.blueprint.di.Recipe;
1:6414875: import org.apache.aries.blueprint.di.RefRecipe;
1:6414875: import org.apache.aries.blueprint.di.ValueRecipe;
1:1cfd24a: import org.apache.aries.blueprint.ext.ComponentFactoryMetadata;
1:1cfd24a: import org.apache.aries.blueprint.ext.DependentComponentFactoryMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableMapMetadata;
1:6414875: import org.apache.aries.blueprint.reflect.MetadataUtil;
1:5e2bd49: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanArgument;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanProperty;
1:f13c6ac: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.IdRefMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.MapEntry;
1:f13c6ac: import org.osgi.service.blueprint.reflect.MapMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Metadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.NullMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.PropsMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RefMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RegistrationListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ValueMetadata;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * TODO: javadoc
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:f13c6ac: public class RecipeBuilder {
1:f13c6ac: 
1:9f9d944:     private final Set<String> names = new HashSet<String>();
1:4bdcda3:     private final BlueprintContainerImpl blueprintContainer;
1:9f9d944:     private final ComponentDefinitionRegistry registry;
1:9f9d944:     private final IdSpace recipeIdSpace;
1:f13c6ac: 
1:4bdcda3:     public RecipeBuilder(BlueprintContainerImpl blueprintContainer, IdSpace recipeIdSpace) {
1:9f9d944:         this.recipeIdSpace = recipeIdSpace;
1:f13c6ac:         this.blueprintContainer = blueprintContainer;
1:f13c6ac:         this.registry = blueprintContainer.getComponentDefinitionRegistry();
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public BlueprintRepository createRepository() {
1:f13c6ac:         BlueprintRepository repository = new BlueprintRepository(blueprintContainer);
1:f13c6ac:         // Create component recipes
1:f13c6ac:         for (String name : registry.getComponentDefinitionNames()) {
1:f13c6ac:             ComponentMetadata component = registry.getComponentDefinition(name);
1:f13c6ac:             Recipe recipe = createRecipe(component);
1:f13c6ac:             repository.putRecipe(recipe.getName(), recipe);
1:f13c6ac:         }
1:f13c6ac:         repository.validate();
1:f13c6ac:         return repository;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Recipe createRecipe(ComponentMetadata component) {
1:1cfd24a: 
1:1cfd24a:         // Custom components should be handled before built-in ones
1:1cfd24a:         // in case we have a custom component that also implements a built-in metadata
1:1cfd24a:         
1:1cfd24a:         if (component instanceof DependentComponentFactoryMetadata) { 
1:1cfd24a:             return createDependentComponentFactoryMetadata((DependentComponentFactoryMetadata) component);
1:1cfd24a:         } else if (component instanceof ComponentFactoryMetadata) {
1:1cfd24a:             return createComponentFactoryMetadata((ComponentFactoryMetadata) component);
1:1cfd24a:         } else if (component instanceof BeanMetadata) {
1:f13c6ac:             return createBeanRecipe((BeanMetadata) component);
1:f13c6ac:         } else if (component instanceof ServiceMetadata) {
1:f13c6ac:             return createServiceRecipe((ServiceMetadata) component);
1:f13c6ac:         } else if (component instanceof ReferenceMetadata) {
1:f13c6ac:             return createReferenceRecipe((ReferenceMetadata) component);
1:f13c6ac:         } else if (component instanceof ReferenceListMetadata) {
1:f13c6ac:             return createReferenceListRecipe((ReferenceListMetadata) component);
1:2f55d71:         } else if (component instanceof PassThroughMetadata) {
1:2f55d71:             return createPassThroughRecipe((PassThroughMetadata) component);
1:f13c6ac:         } else {
1:f13c6ac:             throw new IllegalStateException("Unsupported component type " + component.getClass());
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:1cfd24a:     private Recipe createComponentFactoryMetadata(ComponentFactoryMetadata metadata) {
1:1cfd24a:         return new ComponentFactoryRecipe<ComponentFactoryMetadata>(
1:1cfd24a:                 metadata.getId(), metadata, blueprintContainer, getDependencies(metadata));
1:f13c6ac:     }
1:f13c6ac:     
1:1cfd24a:     private Recipe createDependentComponentFactoryMetadata(DependentComponentFactoryMetadata metadata) {
1:1cfd24a:         return new DependentComponentFactoryRecipe(
1:1cfd24a:                 metadata.getId(), metadata, blueprintContainer, getDependencies(metadata));
1:f13c6ac:     }
1:f13c6ac:     
1:1cfd24a:     private List<Recipe> getDependencies(ComponentMetadata metadata) {
4:f13c6ac:         List<Recipe> deps = new ArrayList<Recipe>();
2:f13c6ac:         for (String name : metadata.getDependsOn()) {
4:f13c6ac:             deps.add(new RefRecipe(getName(null), name));
1:f13c6ac:         }
1:1cfd24a:         return deps;
1:f13c6ac:     }
2:1cfd24a: 
1:2f55d71:     private Recipe createPassThroughRecipe(PassThroughMetadata passThroughMetadata) {
1:793c92a:         return new PassThroughRecipe(getName(passThroughMetadata.getId()), 
1:793c92a:             passThroughMetadata.getObject());
1:d08aba3:     }
1:1cfd24a: 
1:f13c6ac:     private Recipe createReferenceListRecipe(ReferenceListMetadata metadata) {
1:d46274e:         ValueRecipe filterRecipe = null;
1:d46274e:         if (metadata instanceof ExtendedReferenceMetadata) {
1:d46274e:             ValueMetadata filterMetadata = ((ExtendedServiceReferenceMetadata) metadata).getExtendedFilter();
1:d46274e:             if (filterMetadata != null) {
1:d46274e:                 filterRecipe = (ValueRecipe) getValue(filterMetadata, null);
1:d46274e:             }
1:d46274e:         }
1:f13c6ac:         CollectionRecipe listenersRecipe = null;
1:f13c6ac:         if (metadata.getReferenceListeners() != null) {
1:5e2bd49:             listenersRecipe = new CollectionRecipe(getName(null), ArrayList.class, Object.class.getName());
1:f13c6ac:             for (ReferenceListener listener : metadata.getReferenceListeners()) {
1:f13c6ac:                 listenersRecipe.add(createRecipe(listener));
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         ReferenceListRecipe recipe = new ReferenceListRecipe(getName(metadata.getId()),
1:f13c6ac:                                                  blueprintContainer,
1:f13c6ac:                                                  metadata,
1:d46274e:                                                  filterRecipe,
1:f13c6ac:                                                  listenersRecipe,
1:1cfd24a:                                                  getDependencies(metadata));
1:f13c6ac:         return recipe;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private ReferenceRecipe createReferenceRecipe(ReferenceMetadata metadata) {
1:d46274e:         ValueRecipe filterRecipe = null;
1:d46274e:         if (metadata instanceof ExtendedReferenceMetadata) {
1:d46274e:             ValueMetadata filterMetadata = ((ExtendedServiceReferenceMetadata) metadata).getExtendedFilter();
1:d46274e:             if (filterMetadata != null) {
1:d46274e:                 filterRecipe = (ValueRecipe) getValue(filterMetadata, null);
1:d46274e:             }
1:d46274e:         }
1:f13c6ac:         CollectionRecipe listenersRecipe = null;
1:f13c6ac:         if (metadata.getReferenceListeners() != null) {
1:5e2bd49:             listenersRecipe = new CollectionRecipe(getName(null), ArrayList.class, Object.class.getName());
1:f13c6ac:             for (ReferenceListener listener : metadata.getReferenceListeners()) {
1:f13c6ac:                 listenersRecipe.add(createRecipe(listener));
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         ReferenceRecipe recipe = new ReferenceRecipe(getName(metadata.getId()),
1:f13c6ac:                                                      blueprintContainer,
1:f13c6ac:                                                      metadata,
1:d46274e:                                                      filterRecipe,
1:f13c6ac:                                                      listenersRecipe,
1:1cfd24a:                                                      getDependencies(metadata));
1:f13c6ac:         return recipe;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Recipe createServiceRecipe(ServiceMetadata serviceExport) {
1:5e2bd49:         CollectionRecipe listenersRecipe = new CollectionRecipe(getName(null), ArrayList.class, Object.class.getName());
1:f13c6ac:         if (serviceExport.getRegistrationListeners() != null) {
1:f13c6ac:             for (RegistrationListener listener : serviceExport.getRegistrationListeners()) {
1:f13c6ac:                 listenersRecipe.add(createRecipe(listener));
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         ServiceRecipe recipe = new ServiceRecipe(getName(serviceExport.getId()),
1:f13c6ac:                                                  blueprintContainer,
1:f13c6ac:                                                  serviceExport,
1:f13c6ac:                                                  getValue(serviceExport.getServiceComponent(), null),
1:f13c6ac:                                                  listenersRecipe,
1:f13c6ac:                                                  getServicePropertiesRecipe(serviceExport),
1:1cfd24a:                                                  getDependencies(serviceExport));
1:f13c6ac:         return recipe;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected MapRecipe getServicePropertiesRecipe(ServiceMetadata metadata) {
1:f13c6ac:         List<MapEntry> properties = metadata.getServiceProperties();
1:f13c6ac:         if (properties != null) {
1:f13c6ac:             MutableMapMetadata map = MetadataUtil.createMetadata(MutableMapMetadata.class);
1:f13c6ac:             for (MapEntry e : properties) {
1:f13c6ac:                 map.addEntry(e);
1:f13c6ac:             }
1:f13c6ac:             return createMapRecipe(map);
1:f13c6ac:         } else {
1:f13c6ac:             return null;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private Object getBeanClass(BeanMetadata beanMetadata) {
1:f13c6ac:         if (beanMetadata instanceof ExtendedBeanMetadata) {
1:f13c6ac:             ExtendedBeanMetadata extBeanMetadata = (ExtendedBeanMetadata) beanMetadata;
1:f13c6ac:             if (extBeanMetadata.getRuntimeClass() != null) {
1:f13c6ac:                 return extBeanMetadata.getRuntimeClass();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return beanMetadata.getClassName();        
1:f13c6ac:     }
1:f13c6ac:     
1:d08aba3:     private boolean allowsFieldInjection(BeanMetadata beanMetadata) {
1:d08aba3:         if (beanMetadata instanceof ExtendedBeanMetadata) {
1:d08aba3:             return ((ExtendedBeanMetadata) beanMetadata).getFieldInjection();
1:f13c6ac:         }
1:d08aba3:         return false;
1:d08aba3:     }
1:d08aba3:     
1:f13c6ac:     private BeanRecipe createBeanRecipe(BeanMetadata beanMetadata) {
1:f13c6ac:         BeanRecipe recipe = new BeanRecipe(
1:f13c6ac:                 getName(beanMetadata.getId()),
1:f13c6ac:                 blueprintContainer,
1:d08aba3:                 getBeanClass(beanMetadata),
1:d08aba3:                 allowsFieldInjection(beanMetadata));
1:f13c6ac:         // Create refs for explicit dependencies
1:1cfd24a:         recipe.setExplicitDependencies(getDependencies(beanMetadata));
1:b4fc651:         recipe.setPrototype(MetadataUtil.isPrototypeScope(beanMetadata) || MetadataUtil.isCustomScope(beanMetadata));
1:f13c6ac:         recipe.setInitMethod(beanMetadata.getInitMethod());
1:f13c6ac:         recipe.setDestroyMethod(beanMetadata.getDestroyMethod());
1:f0b2b91:         recipe.setInterceptorLookupKey(beanMetadata);
1:f13c6ac:         List<BeanArgument> beanArguments = beanMetadata.getArguments();
1:f13c6ac:         if (beanArguments != null && !beanArguments.isEmpty()) {
1:f13c6ac:             boolean hasIndex = (beanArguments.get(0).getIndex() >= 0);
1:f13c6ac:             if (hasIndex) {
1:f13c6ac:                 List<BeanArgument> beanArgumentsCopy = new ArrayList<BeanArgument>(beanArguments);
1:f13c6ac:                 Collections.sort(beanArgumentsCopy, MetadataUtil.BEAN_COMPARATOR);
1:f13c6ac:                 beanArguments = beanArgumentsCopy;
1:f13c6ac:             }
1:f13c6ac:             List<Object> arguments = new ArrayList<Object>();
1:f13c6ac:             List<String> argTypes = new ArrayList<String>();
1:f13c6ac:             for (BeanArgument argument : beanArguments) {
1:f13c6ac:                 Recipe value = getValue(argument.getValue(), null);
1:f13c6ac:                 arguments.add(value);
1:f13c6ac:                 argTypes.add(argument.getValueType());
1:f13c6ac:             }
1:f13c6ac:             recipe.setArguments(arguments);
1:f13c6ac:             recipe.setArgTypes(argTypes);
1:f13c6ac:             recipe.setReorderArguments(!hasIndex);
1:f13c6ac:         }
1:f13c6ac:         recipe.setFactoryMethod(beanMetadata.getFactoryMethod());
1:f13c6ac:         if (beanMetadata.getFactoryComponent() != null) {
1:f13c6ac:             recipe.setFactoryComponent(getValue(beanMetadata.getFactoryComponent(), null));
1:f13c6ac:         }
1:f13c6ac:         for (BeanProperty property : beanMetadata.getProperties()) {
1:f13c6ac:             Recipe value = getValue(property.getValue(), null);
1:f13c6ac:             recipe.setProperty(property.getName(), value);
1:f13c6ac:         }
1:f13c6ac:         return recipe;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Recipe createRecipe(RegistrationListener listener) {
1:d08aba3:         BeanRecipe recipe = new BeanRecipe(getName(null), blueprintContainer, ServiceListener.class, false);
1:f13c6ac:         recipe.setProperty("listener", getValue(listener.getListenerComponent(), null));
1:f13c6ac:         if (listener.getRegistrationMethod() != null) {
1:f13c6ac:             recipe.setProperty("registerMethod", listener.getRegistrationMethod());
1:f13c6ac:         }
1:f13c6ac:         if (listener.getUnregistrationMethod() != null) {
1:f13c6ac:             recipe.setProperty("unregisterMethod", listener.getUnregistrationMethod());
1:f13c6ac:         }
1:f13c6ac:         recipe.setProperty("blueprintContainer", blueprintContainer);
1:f13c6ac:         return recipe;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Recipe createRecipe(ReferenceListener listener) {
1:d08aba3:         BeanRecipe recipe = new BeanRecipe(getName(null), blueprintContainer, AbstractServiceReferenceRecipe.Listener.class, false);
1:f13c6ac:         recipe.setProperty("listener", getValue(listener.getListenerComponent(), null));
1:f13c6ac:         recipe.setProperty("metadata", listener);
1:f13c6ac:         recipe.setProperty("blueprintContainer", blueprintContainer);
1:f13c6ac:         return recipe;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Recipe getValue(Metadata v, Object groupingType) {
1:f13c6ac:         if (v instanceof NullMetadata) {
1:f13c6ac:             return null;
1:f13c6ac:         } else if (v instanceof ComponentMetadata) {
1:f13c6ac:             return createRecipe((ComponentMetadata) v);
1:f13c6ac:         } else if (v instanceof ValueMetadata) {
1:f13c6ac:             ValueMetadata stringValue = (ValueMetadata) v;
1:f13c6ac:             Object type = stringValue.getType();
1:f13c6ac:             type = (type == null) ? groupingType : type;
1:f13c6ac:             ValueRecipe vr = new ValueRecipe(getName(null), stringValue, type);
1:f13c6ac:             return vr;
1:f13c6ac:         } else if (v instanceof RefMetadata) {
1:f13c6ac:             // TODO: make it work with property-placeholders?
1:f13c6ac:             String componentName = ((RefMetadata) v).getComponentId();
1:f13c6ac:             RefRecipe rr = new RefRecipe(getName(null), componentName);
1:f13c6ac:             return rr;
1:f13c6ac:         } else if (v instanceof CollectionMetadata) {
1:f13c6ac:             CollectionMetadata collectionMetadata = (CollectionMetadata) v;
1:5e2bd49:             Class<?> cl = collectionMetadata.getCollectionClass();
1:5e2bd49:             String type = collectionMetadata.getValueType();
1:f13c6ac:             if (cl == Object[].class) {
1:f13c6ac:                 ArrayRecipe ar = new ArrayRecipe(getName(null), type);
1:f13c6ac:                 for (Metadata lv : collectionMetadata.getValues()) {
1:f13c6ac:                     ar.add(getValue(lv, type));
1:f13c6ac:                 }
1:f13c6ac:                 return ar;
1:f13c6ac:             } else {
1:5e2bd49:                 CollectionRecipe cr = new CollectionRecipe(getName(null), cl != null ? cl : ArrayList.class, type);
1:f13c6ac:                 for (Metadata lv : collectionMetadata.getValues()) {
1:f13c6ac:                     cr.add(getValue(lv, type));
1:f13c6ac:                 }
1:f13c6ac:                 return cr;
1:f13c6ac:             }
1:f13c6ac:         } else if (v instanceof MapMetadata) {
1:f13c6ac:             return createMapRecipe((MapMetadata) v);
1:f13c6ac:         } else if (v instanceof PropsMetadata) {
1:f13c6ac:             PropsMetadata mapValue = (PropsMetadata) v;
1:5e2bd49:             MapRecipe mr = new MapRecipe(getName(null), Properties.class, String.class, String.class);
1:f13c6ac:             for (MapEntry entry : mapValue.getEntries()) {
1:f13c6ac:                 Recipe key = getValue(entry.getKey(), String.class);
1:f13c6ac:                 Recipe val = getValue(entry.getValue(), String.class);
1:f13c6ac:                 mr.put(key, val);
1:f13c6ac:             }
1:f13c6ac:             return mr;
1:f13c6ac:         } else if (v instanceof IdRefMetadata) {
1:f13c6ac:             // TODO: make it work with property-placeholders?
1:f13c6ac:             String componentName = ((IdRefMetadata) v).getComponentId();
1:f13c6ac:             IdRefRecipe rnr = new IdRefRecipe(getName(null), componentName);
1:f13c6ac:             return rnr;
1:f13c6ac:         } else {
1:ecf9aab:             throw new IllegalStateException("Unsupported value: " + (v != null ? v.getClass().getName() : "null"));
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private MapRecipe createMapRecipe(MapMetadata mapValue) {
1:f13c6ac:         String keyType = mapValue.getKeyType();
1:f13c6ac:         String valueType = mapValue.getValueType();
1:5e2bd49:         MapRecipe mr = new MapRecipe(getName(null), HashMap.class, keyType, valueType);
1:f13c6ac:         for (MapEntry entry : mapValue.getEntries()) {
1:f13c6ac:             Recipe key = getValue(entry.getKey(), keyType);
1:f13c6ac:             Recipe val = getValue(entry.getValue(), valueType);
1:f13c6ac:             mr.put(key, val);
1:f13c6ac:         }
1:f13c6ac:         return mr;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private String getName(String name) {
1:f13c6ac:         if (name == null) {
1:f13c6ac:             do {
1:9f9d944:                 name = "#recipe-" + recipeIdSpace.nextId();
1:f13c6ac:             } while (names.contains(name) || registry.containsComponentDefinition(name));
1:f13c6ac:         }
1:f13c6ac:         names.add(name);
1:f13c6ac:         return name;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:ecf9aab
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalStateException("Unsupported value: " + (v != null ? v.getClass().getName() : "null"));
commit:d46274e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ExtendedReferenceMetadata;
1: import org.apache.aries.blueprint.ExtendedServiceReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
1:         ValueRecipe filterRecipe = null;
1:         if (metadata instanceof ExtendedReferenceMetadata) {
1:             ValueMetadata filterMetadata = ((ExtendedServiceReferenceMetadata) metadata).getExtendedFilter();
1:             if (filterMetadata != null) {
1:                 filterRecipe = (ValueRecipe) getValue(filterMetadata, null);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:                                                  filterRecipe,
1:         ValueRecipe filterRecipe = null;
1:         if (metadata instanceof ExtendedReferenceMetadata) {
1:             ValueMetadata filterMetadata = ((ExtendedServiceReferenceMetadata) metadata).getExtendedFilter();
1:             if (filterMetadata != null) {
1:                 filterRecipe = (ValueRecipe) getValue(filterMetadata, null);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:                                                      filterRecipe,
commit:2f55d71
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.PassThroughMetadata;
1: import org.apache.aries.blueprint.di.PassThroughRecipe;
/////////////////////////////////////////////////////////////////////////
1:         } else if (component instanceof PassThroughMetadata) {
1:             return createPassThroughRecipe((PassThroughMetadata) component);
1:     private Recipe createPassThroughRecipe(PassThroughMetadata passThroughMetadata) {
0:         return new PassThroughRecipe(passThroughMetadata.getId(), passThroughMetadata.getObject());
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Properties;
1: import java.util.Set;
1: 
0: import org.apache.geronimo.blueprint.ComponentDefinitionRegistry;
0: import org.apache.geronimo.blueprint.ExtendedBeanMetadata;
0: import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
0: import org.apache.geronimo.blueprint.di.ArrayRecipe;
0: import org.apache.geronimo.blueprint.di.CollectionRecipe;
0: import org.apache.geronimo.blueprint.di.IdRefRecipe;
0: import org.apache.geronimo.blueprint.di.MapRecipe;
0: import org.apache.geronimo.blueprint.di.Recipe;
0: import org.apache.geronimo.blueprint.di.RefRecipe;
0: import org.apache.geronimo.blueprint.di.ValueRecipe;
0: import org.apache.geronimo.blueprint.di.EnvironmentRecipe;
0: import org.apache.geronimo.blueprint.mutable.MutableMapMetadata;
0: import org.apache.geronimo.blueprint.reflect.MetadataUtil;
0: import org.apache.geronimo.blueprint.reflect.EnvironmentMetadataImpl;
1: import org.osgi.service.blueprint.reflect.BeanArgument;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.BeanProperty;
1: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.IdRefMetadata;
1: import org.osgi.service.blueprint.reflect.MapEntry;
1: import org.osgi.service.blueprint.reflect.MapMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.osgi.service.blueprint.reflect.NullMetadata;
1: import org.osgi.service.blueprint.reflect.PropsMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1: import org.osgi.service.blueprint.reflect.RefMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListener;
1: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.RegistrationListener;
1: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1: import org.osgi.service.blueprint.reflect.ValueMetadata;
1: 
1: /**
1:  * TODO: javadoc
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 760378 $, $Date: 2009-03-31 11:31:38 +0200 (Tue, 31 Mar 2009) $
1:  */
1: public class RecipeBuilder {
1: 
0:     private Set<String> names = new HashSet<String>();
0:     private int nameCounter;
0:     private ExtendedBlueprintContainer blueprintContainer;
0:     private ComponentDefinitionRegistry registry;
1: 
0:     public RecipeBuilder(ExtendedBlueprintContainer blueprintContainer) {
1:         this.blueprintContainer = blueprintContainer;
1:         this.registry = blueprintContainer.getComponentDefinitionRegistry();
1:     }
1:     
1:     public BlueprintRepository createRepository() {
1:         BlueprintRepository repository = new BlueprintRepository(blueprintContainer);
1:         // Create component recipes
1:         for (String name : registry.getComponentDefinitionNames()) {
1:             ComponentMetadata component = registry.getComponentDefinition(name);
1:             Recipe recipe = createRecipe(component);
1:             repository.putRecipe(recipe.getName(), recipe);
1:         }
1:         repository.validate();
1:         return repository;
1:     }
1: 
1:     public Recipe createRecipe(ComponentMetadata component) {
0:         if (component instanceof BeanMetadata) {
1:             return createBeanRecipe((BeanMetadata) component);
1:         } else if (component instanceof ServiceMetadata) {
1:             return createServiceRecipe((ServiceMetadata) component);
1:         } else if (component instanceof ReferenceMetadata) {
1:             return createReferenceRecipe((ReferenceMetadata) component);
1:         } else if (component instanceof ReferenceListMetadata) {
1:             return createReferenceListRecipe((ReferenceListMetadata) component);
0:         } else if (component instanceof EnvironmentMetadataImpl) {
0:             return createEnvironmentRecipe((EnvironmentMetadataImpl) component);
1:         } else {
1:             throw new IllegalStateException("Unsupported component type " + component.getClass());
1:         }
1:     }
1: 
0:     private Recipe createEnvironmentRecipe(EnvironmentMetadataImpl environmentMetadata) {
0:         return new EnvironmentRecipe(environmentMetadata.getId(), environmentMetadata.getObject());
1:     }
1: 
1: 
1:     private Recipe createReferenceListRecipe(ReferenceListMetadata metadata) {
1:         CollectionRecipe listenersRecipe = null;
1:         if (metadata.getReferenceListeners() != null) {
0:             listenersRecipe = new CollectionRecipe(getName(null), ArrayList.class);
1:             for (ReferenceListener listener : metadata.getReferenceListeners()) {
1:                 listenersRecipe.add(createRecipe(listener));
1:             }
1:         }
1:         List<Recipe> deps = new ArrayList<Recipe>();
1:         for (String name : metadata.getDependsOn()) {
1:             deps.add(new RefRecipe(getName(null), name));
1:         }
1:         ReferenceListRecipe recipe = new ReferenceListRecipe(getName(metadata.getId()),
1:                                                  blueprintContainer,
1:                                                  metadata,
1:                                                  listenersRecipe,
0:                                                  deps);
1:         return recipe;
1:     }
1: 
1:     private ReferenceRecipe createReferenceRecipe(ReferenceMetadata metadata) {
1:         CollectionRecipe listenersRecipe = null;
1:         if (metadata.getReferenceListeners() != null) {
0:             listenersRecipe = new CollectionRecipe(getName(null), ArrayList.class);
1:             for (ReferenceListener listener : metadata.getReferenceListeners()) {
1:                 listenersRecipe.add(createRecipe(listener));
1:             }
1:         }
1:         List<Recipe> deps = new ArrayList<Recipe>();
1:         for (String name : metadata.getDependsOn()) {
1:             deps.add(new RefRecipe(getName(null), name));
1:         }
1:         ReferenceRecipe recipe = new ReferenceRecipe(getName(metadata.getId()),
1:                                                      blueprintContainer,
1:                                                      metadata,
1:                                                      listenersRecipe,
0:                                                      deps);
1:         return recipe;
1:     }
1: 
1:     private Recipe createServiceRecipe(ServiceMetadata serviceExport) {
0:         CollectionRecipe listenersRecipe = new CollectionRecipe(getName(null), ArrayList.class);
1:         if (serviceExport.getRegistrationListeners() != null) {
1:             for (RegistrationListener listener : serviceExport.getRegistrationListeners()) {
1:                 listenersRecipe.add(createRecipe(listener));
1:             }
1:         }
1:         List<Recipe> deps = new ArrayList<Recipe>();
0:         for (String name : serviceExport.getDependsOn()) {
1:             deps.add(new RefRecipe(getName(null), name));
1:         }
1:         ServiceRecipe recipe = new ServiceRecipe(getName(serviceExport.getId()),
1:                                                  blueprintContainer,
1:                                                  serviceExport,
1:                                                  getValue(serviceExport.getServiceComponent(), null),
1:                                                  listenersRecipe,
1:                                                  getServicePropertiesRecipe(serviceExport),
0:                                                  deps);
1:         return recipe;
1:     }
1: 
1:     protected MapRecipe getServicePropertiesRecipe(ServiceMetadata metadata) {
1:         List<MapEntry> properties = metadata.getServiceProperties();
1:         if (properties != null) {
1:             MutableMapMetadata map = MetadataUtil.createMetadata(MutableMapMetadata.class);
1:             for (MapEntry e : properties) {
1:                 map.addEntry(e);
1:             }
1:             return createMapRecipe(map);
1:         } else {
1:             return null;
1:         }
1:     }
1:     
1:     private Object getBeanClass(BeanMetadata beanMetadata) {
1:         if (beanMetadata instanceof ExtendedBeanMetadata) {
1:             ExtendedBeanMetadata extBeanMetadata = (ExtendedBeanMetadata) beanMetadata;
1:             if (extBeanMetadata.getRuntimeClass() != null) {
1:                 return extBeanMetadata.getRuntimeClass();
1:             }
1:         }
1:         return beanMetadata.getClassName();        
1:     }
1:     
1:     private BeanRecipe createBeanRecipe(BeanMetadata beanMetadata) {
1:         BeanRecipe recipe = new BeanRecipe(
1:                 getName(beanMetadata.getId()),
1:                 blueprintContainer,
0:                 getBeanClass(beanMetadata));
1:         // Create refs for explicit dependencies
1:         List<Recipe> deps = new ArrayList<Recipe>();
0:         for (String name : beanMetadata.getDependsOn()) {
1:             deps.add(new RefRecipe(getName(null), name));
1:         }
0:         recipe.setExplicitDependencies(deps);
0:         recipe.setPrototype(MetadataUtil.isPrototypeScope(beanMetadata));
1:         recipe.setInitMethod(beanMetadata.getInitMethod());
1:         recipe.setDestroyMethod(beanMetadata.getDestroyMethod());
1:         List<BeanArgument> beanArguments = beanMetadata.getArguments();
1:         if (beanArguments != null && !beanArguments.isEmpty()) {
1:             boolean hasIndex = (beanArguments.get(0).getIndex() >= 0);
1:             if (hasIndex) {
1:                 List<BeanArgument> beanArgumentsCopy = new ArrayList<BeanArgument>(beanArguments);
1:                 Collections.sort(beanArgumentsCopy, MetadataUtil.BEAN_COMPARATOR);
1:                 beanArguments = beanArgumentsCopy;
1:             }
1:             List<Object> arguments = new ArrayList<Object>();
1:             List<String> argTypes = new ArrayList<String>();
1:             for (BeanArgument argument : beanArguments) {
1:                 Recipe value = getValue(argument.getValue(), null);
1:                 arguments.add(value);
1:                 argTypes.add(argument.getValueType());
1:             }
1:             recipe.setArguments(arguments);
1:             recipe.setArgTypes(argTypes);
1:             recipe.setReorderArguments(!hasIndex);
1:         }
1:         recipe.setFactoryMethod(beanMetadata.getFactoryMethod());
1:         if (beanMetadata.getFactoryComponent() != null) {
1:             recipe.setFactoryComponent(getValue(beanMetadata.getFactoryComponent(), null));
1:         }
1:         for (BeanProperty property : beanMetadata.getProperties()) {
1:             Recipe value = getValue(property.getValue(), null);
1:             recipe.setProperty(property.getName(), value);
1:         }
1:         return recipe;
1:     }
1: 
1:     private Recipe createRecipe(RegistrationListener listener) {
0:         BeanRecipe recipe = new BeanRecipe(getName(null), blueprintContainer, ServiceListener.class);
1:         recipe.setProperty("listener", getValue(listener.getListenerComponent(), null));
1:         if (listener.getRegistrationMethod() != null) {
1:             recipe.setProperty("registerMethod", listener.getRegistrationMethod());
1:         }
1:         if (listener.getUnregistrationMethod() != null) {
1:             recipe.setProperty("unregisterMethod", listener.getUnregistrationMethod());
1:         }
1:         recipe.setProperty("blueprintContainer", blueprintContainer);
1:         return recipe;
1:     }
1: 
1:     private Recipe createRecipe(ReferenceListener listener) {
0:         BeanRecipe recipe = new BeanRecipe(getName(null), blueprintContainer, AbstractServiceReferenceRecipe.Listener.class);
1:         recipe.setProperty("listener", getValue(listener.getListenerComponent(), null));
1:         recipe.setProperty("metadata", listener);
1:         recipe.setProperty("blueprintContainer", blueprintContainer);
1:         return recipe;
1:     }
1: 
1:     private Recipe getValue(Metadata v, Object groupingType) {
1:         if (v instanceof NullMetadata) {
1:             return null;
1:         } else if (v instanceof ComponentMetadata) {
1:             return createRecipe((ComponentMetadata) v);
1:         } else if (v instanceof ValueMetadata) {
1:             ValueMetadata stringValue = (ValueMetadata) v;
1:             Object type = stringValue.getType();
1:             type = (type == null) ? groupingType : type;
1:             ValueRecipe vr = new ValueRecipe(getName(null), stringValue, type);
1:             return vr;
1:         } else if (v instanceof RefMetadata) {
1:             // TODO: make it work with property-placeholders?
1:             String componentName = ((RefMetadata) v).getComponentId();
1:             RefRecipe rr = new RefRecipe(getName(null), componentName);
1:             return rr;
1:         } else if (v instanceof CollectionMetadata) {
1:             CollectionMetadata collectionMetadata = (CollectionMetadata) v;
0:             Class cl = collectionMetadata.getCollectionClass();
0:             Object type = collectionMetadata.getValueType();
1:             if (cl == Object[].class) {
1:                 ArrayRecipe ar = new ArrayRecipe(getName(null), type);
1:                 for (Metadata lv : collectionMetadata.getValues()) {
1:                     ar.add(getValue(lv, type));
1:                 }
1:                 return ar;
1:             } else {
0:                 CollectionRecipe cr = new CollectionRecipe(getName(null), cl != null ? cl : ArrayList.class);
1:                 for (Metadata lv : collectionMetadata.getValues()) {
1:                     cr.add(getValue(lv, type));
1:                 }
1:                 return cr;
1:             }
1:         } else if (v instanceof MapMetadata) {
1:             return createMapRecipe((MapMetadata) v);
1:         } else if (v instanceof PropsMetadata) {
1:             PropsMetadata mapValue = (PropsMetadata) v;
0:             MapRecipe mr = new MapRecipe(getName(null), Properties.class);
1:             for (MapEntry entry : mapValue.getEntries()) {
1:                 Recipe key = getValue(entry.getKey(), String.class);
1:                 Recipe val = getValue(entry.getValue(), String.class);
1:                 mr.put(key, val);
1:             }
1:             return mr;
1:         } else if (v instanceof IdRefMetadata) {
1:             // TODO: make it work with property-placeholders?
1:             String componentName = ((IdRefMetadata) v).getComponentId();
1:             IdRefRecipe rnr = new IdRefRecipe(getName(null), componentName);
1:             return rnr;
1:         } else {
0:             throw new IllegalStateException("Unsupported value: " + v.getClass().getName());
1:         }
1:     }
1: 
1:     private MapRecipe createMapRecipe(MapMetadata mapValue) {
1:         String keyType = mapValue.getKeyType();
1:         String valueType = mapValue.getValueType();
0:         MapRecipe mr = new MapRecipe(getName(null), HashMap.class);
1:         for (MapEntry entry : mapValue.getEntries()) {
1:             Recipe key = getValue(entry.getKey(), keyType);
1:             Recipe val = getValue(entry.getValue(), valueType);
1:             mr.put(key, val);
1:         }
1:         return mr;
1:     }
1: 
1:     private String getName(String name) {
1:         if (name == null) {
1:             do {
0:                 name = "#recipe-" + ++nameCounter;
1:             } while (names.contains(name) || registry.containsComponentDefinition(name));
1:         }
1:         names.add(name);
1:         return name;
1:     }
1: 
1: }
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:5e2bd49
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
/////////////////////////////////////////////////////////////////////////
1:             listenersRecipe = new CollectionRecipe(getName(null), ArrayList.class, Object.class.getName());
/////////////////////////////////////////////////////////////////////////
1:             listenersRecipe = new CollectionRecipe(getName(null), ArrayList.class, Object.class.getName());
/////////////////////////////////////////////////////////////////////////
1:         CollectionRecipe listenersRecipe = new CollectionRecipe(getName(null), ArrayList.class, Object.class.getName());
/////////////////////////////////////////////////////////////////////////
1:             Class<?> cl = collectionMetadata.getCollectionClass();
1:             String type = collectionMetadata.getValueType();
/////////////////////////////////////////////////////////////////////////
1:                 CollectionRecipe cr = new CollectionRecipe(getName(null), cl != null ? cl : ArrayList.class, type);
/////////////////////////////////////////////////////////////////////////
1:             MapRecipe mr = new MapRecipe(getName(null), Properties.class, String.class, String.class);
/////////////////////////////////////////////////////////////////////////
1:         MapRecipe mr = new MapRecipe(getName(null), HashMap.class, keyType, valueType);
commit:e2445d0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.utils.ServiceListener;
commit:b4fc651
/////////////////////////////////////////////////////////////////////////
1:         recipe.setPrototype(MetadataUtil.isPrototypeScope(beanMetadata) || MetadataUtil.isCustomScope(beanMetadata));
commit:793c92a
/////////////////////////////////////////////////////////////////////////
1:         return new PassThroughRecipe(getName(passThroughMetadata.getId()), 
1:             passThroughMetadata.getObject());
author:J. Daniel Kulp
-------------------------------------------------------------------------------
commit:4bdcda3
/////////////////////////////////////////////////////////////////////////
1:     private final BlueprintContainerImpl blueprintContainer;
1:     public RecipeBuilder(BlueprintContainerImpl blueprintContainer, IdSpace recipeIdSpace) {
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
commit:f0b2b91
/////////////////////////////////////////////////////////////////////////
1:         recipe.setInterceptorLookupKey(beanMetadata);
commit:9f9d944
/////////////////////////////////////////////////////////////////////////
1:     private final Set<String> names = new HashSet<String>();
0:     private final ExtendedBlueprintContainer blueprintContainer;
1:     private final ComponentDefinitionRegistry registry;
1:     private final IdSpace recipeIdSpace;
0:     public RecipeBuilder(ExtendedBlueprintContainer blueprintContainer, IdSpace recipeIdSpace) {
1:         this.recipeIdSpace = recipeIdSpace;
/////////////////////////////////////////////////////////////////////////
1:                 name = "#recipe-" + recipeIdSpace.nextId();
commit:d08aba3
/////////////////////////////////////////////////////////////////////////
1:     private boolean allowsFieldInjection(BeanMetadata beanMetadata) {
1:         if (beanMetadata instanceof ExtendedBeanMetadata) {
1:             return ((ExtendedBeanMetadata) beanMetadata).getFieldInjection();
1:         }
1:         return false;
1:     }
1:     
1:                 getBeanClass(beanMetadata),
1:                 allowsFieldInjection(beanMetadata));
/////////////////////////////////////////////////////////////////////////
1:         BeanRecipe recipe = new BeanRecipe(getName(null), blueprintContainer, ServiceListener.class, false);
/////////////////////////////////////////////////////////////////////////
1:         BeanRecipe recipe = new BeanRecipe(getName(null), blueprintContainer, AbstractServiceReferenceRecipe.Listener.class, false);
commit:1cfd24a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.di.ComponentFactoryRecipe;
1: import org.apache.aries.blueprint.di.DependentComponentFactoryRecipe;
1: import org.apache.aries.blueprint.ext.ComponentFactoryMetadata;
1: import org.apache.aries.blueprint.ext.DependentComponentFactoryMetadata;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Custom components should be handled before built-in ones
1:         // in case we have a custom component that also implements a built-in metadata
1:         
1:         if (component instanceof DependentComponentFactoryMetadata) { 
1:             return createDependentComponentFactoryMetadata((DependentComponentFactoryMetadata) component);
1:         } else if (component instanceof ComponentFactoryMetadata) {
1:             return createComponentFactoryMetadata((ComponentFactoryMetadata) component);
1:         } else if (component instanceof BeanMetadata) {
/////////////////////////////////////////////////////////////////////////
1:     private Recipe createComponentFactoryMetadata(ComponentFactoryMetadata metadata) {
1:         return new ComponentFactoryRecipe<ComponentFactoryMetadata>(
1:                 metadata.getId(), metadata, blueprintContainer, getDependencies(metadata));
0:     }
1:     
1:     private Recipe createDependentComponentFactoryMetadata(DependentComponentFactoryMetadata metadata) {
1:         return new DependentComponentFactoryRecipe(
1:                 metadata.getId(), metadata, blueprintContainer, getDependencies(metadata));
0:     }
1:     
1:     private List<Recipe> getDependencies(ComponentMetadata metadata) {
0:         List<Recipe> deps = new ArrayList<Recipe>();
0:         for (String name : metadata.getDependsOn()) {
0:             deps.add(new RefRecipe(getName(null), name));
0:         }
1:         return deps;
0:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                                                  getDependencies(metadata));
/////////////////////////////////////////////////////////////////////////
1:                                                      getDependencies(metadata));
/////////////////////////////////////////////////////////////////////////
1:                                                  getDependencies(serviceExport));
/////////////////////////////////////////////////////////////////////////
1:         recipe.setExplicitDependencies(getDependencies(beanMetadata));
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1: import org.apache.aries.blueprint.ExtendedBeanMetadata;
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.di.ArrayRecipe;
1: import org.apache.aries.blueprint.di.CollectionRecipe;
1: import org.apache.aries.blueprint.di.IdRefRecipe;
1: import org.apache.aries.blueprint.di.MapRecipe;
1: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.di.RefRecipe;
1: import org.apache.aries.blueprint.di.ValueRecipe;
0: import org.apache.aries.blueprint.di.EnvironmentRecipe;
1: import org.apache.aries.blueprint.mutable.MutableMapMetadata;
1: import org.apache.aries.blueprint.reflect.MetadataUtil;
0: import org.apache.aries.blueprint.reflect.EnvironmentMetadataImpl;
============================================================================