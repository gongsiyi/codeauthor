1:f13c6ac: /*
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
2:f13c6ac: 
1:774ce31: import java.util.*;
1:f13c6ac: import java.util.concurrent.Callable;
1:f13c6ac: 
1:d46274e: import org.apache.aries.blueprint.di.ValueRecipe;
1:09a7647: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:6414875: import org.apache.aries.blueprint.ExtendedReferenceListMetadata;
1:6414875: import org.apache.aries.blueprint.di.Recipe;
1:6414875: import org.apache.aries.blueprint.di.CollectionRecipe;
1:6414875: import org.apache.aries.blueprint.utils.DynamicCollection;
1:e93dfea: import org.osgi.framework.Bundle;
1:e93dfea: import org.osgi.framework.BundleContext;
1:f13c6ac: import org.osgi.framework.Constants;
1:f13c6ac: import org.osgi.framework.ServiceReference;
1:f13c6ac: import org.osgi.service.blueprint.container.ReifiedType;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.container.ServiceUnavailableException;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * A recipe to create a managed collection of service references
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:f13c6ac: public class ReferenceListRecipe extends AbstractServiceReferenceRecipe {
1:f13c6ac: 
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(ReferenceListRecipe.class);
1:f13c6ac: 
1:f13c6ac:     private final ReferenceListMetadata metadata;
1:f13c6ac:     private final List<ManagedCollection> collections = new ArrayList<ManagedCollection>();
1:f13c6ac:     private final DynamicCollection<ServiceDispatcher> storage = new DynamicCollection<ServiceDispatcher>();
1:f13c6ac:     private final List<ServiceDispatcher> unboundDispatchers = new ArrayList<ServiceDispatcher>();
1:b5f484e:     private final Object monitor = new Object();
1:b069aa4: 
1:f13c6ac:     public ReferenceListRecipe(String name,
1:f13c6ac:                          ExtendedBlueprintContainer blueprintContainer,
1:f13c6ac:                          ReferenceListMetadata metadata,
1:d46274e:                          ValueRecipe filterRecipe,
1:f13c6ac:                          CollectionRecipe listenersRecipe,
1:f13c6ac:                          List<Recipe> explicitDependencies) {
1:d46274e:         super(name, blueprintContainer, metadata, filterRecipe, listenersRecipe, explicitDependencies);
1:f13c6ac:         this.metadata = metadata;
2:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     @Override
1:f13c6ac:     protected Object internalCreate() throws ComponentDefinitionException {
1:f13c6ac:         try {
1:f13c6ac:             if (explicitDependencies != null) {
1:f13c6ac:                 for (Recipe recipe : explicitDependencies) {
1:f13c6ac:                     recipe.create();
1:774ce31:                 }
1:f13c6ac:             }
1:f13c6ac:             ProvidedObject object = new ProvidedObject();
1:f13c6ac:             addPartialObject(object);
1:f13c6ac:             // Handle initial references
1:f13c6ac:             createListeners();
1:f13c6ac:             updateListeners();
1:f13c6ac:            
1:f13c6ac:             return object;
1:f13c6ac:         } catch (ComponentDefinitionException t) {
1:f13c6ac:             throw t;
1:f13c6ac:         } catch (Throwable t) {
1:f13c6ac:             throw new ComponentDefinitionException(t);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected void retrack() {
1:f13c6ac:         List<ServiceReference> refs = getServiceReferences();
1:f13c6ac:         if (refs != null) {
1:f13c6ac:             for (ServiceReference ref : refs) {
1:f13c6ac:                 track(ref);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected void track(ServiceReference reference) {
1:f13c6ac:         synchronized (monitor) {
1:f13c6ac:             try {
1:f13c6ac:                 // ServiceReferences may be tracked at multiple points:
1:f13c6ac:                 //  * first after the collection creation in #internalCreate()
1:f13c6ac:                 //  * in #postCreate() after listeners are created
1:f13c6ac:                 //  * after creation time if a new reference shows up
1:f13c6ac:                 //
1:f13c6ac:                 // In the first step, listeners are not created, so we add
1:f13c6ac:                 // the dispatcher to the unboundDispatchers list.  In the second
1:f13c6ac:                 // step, the dispatcher has already been added to the collection
1:f13c6ac:                 // so we just call the listener.
1:f13c6ac:                 //
1:f13c6ac:                 ServiceDispatcher dispatcher = findDispatcher(reference);
1:f13c6ac:                 if (dispatcher != null) {
1:f13c6ac:                     if (!unboundDispatchers.remove(dispatcher)) {
1:f13c6ac:                         return;
1:f13c6ac:                     }
1:f13c6ac:                 } else {
1:f13c6ac:                     dispatcher = new ServiceDispatcher(reference);
1:24455ce:                     Set<Class<?>> interfaces = new HashSet<Class<?>>();
1:24455ce:                     Class<?> clz = getInterfaceClass();
1:2a55096:                     if (clz != null) interfaces.add(clz);
1:f13c6ac:                     if (metadata instanceof ExtendedReferenceListMetadata) {
1:f13c6ac:                         boolean greedy = (((ExtendedReferenceListMetadata) metadata).getProxyMethod() & ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY) != 0;
1:f13c6ac:                         if (greedy) {
1:774ce31:                             List<String> ifs = Arrays.asList((String[]) reference.getProperty(Constants.OBJECTCLASS));
1:774ce31:                             interfaces.addAll(loadAllClasses(ifs));
1:f13c6ac:                         }
1:f13c6ac:                     }
1:f13c6ac:                     dispatcher.proxy = createProxy(dispatcher, interfaces);
1:f13c6ac:                     if (!storage.add(dispatcher)) {
1:f13c6ac:                         dispatcher.destroy();
1:f13c6ac:                         return;
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:                 if (listeners != null) {
1:f13c6ac:                     bind(dispatcher.reference, dispatcher.proxy);                   
1:f13c6ac:                 } else {
1:f13c6ac:                     unboundDispatchers.add(dispatcher);
1:f13c6ac:                 }
1:f13c6ac:             } catch (Throwable t) {
1:f13c6ac:                 LOGGER.info("Error tracking new service reference", t);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected void untrack(ServiceReference reference) {
1:f13c6ac:         synchronized (monitor) {
1:f13c6ac:             ServiceDispatcher dispatcher = findDispatcher(reference);
1:f13c6ac:             if (dispatcher != null) {
1:f13c6ac:                 unbind(dispatcher.reference, dispatcher.proxy);
1:f13c6ac:                 storage.remove(dispatcher);
1:f13c6ac:                 dispatcher.destroy();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected ServiceDispatcher findDispatcher(ServiceReference reference) {
1:f13c6ac:         for (ServiceDispatcher dispatcher : storage) {
1:f13c6ac:             if (dispatcher.reference == reference) {
1:f13c6ac:                 return dispatcher;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return null;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected ManagedCollection getManagedCollection(boolean useReferences) {
1:f13c6ac:         for (ManagedCollection col : collections) {
1:f13c6ac:             if (col.references == useReferences) {
1:f13c6ac:                 return col;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         ManagedCollection collection = new ManagedCollection(useReferences, storage);
1:f13c6ac:         collections.add(collection);
1:f13c6ac:         return collection;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * The ServiceDispatcher is used when creating the cglib proxy.
1:f13c6ac:      * Thic class is responsible for getting the actual service that will be used.
1:f13c6ac:      */
1:f13c6ac:     public class ServiceDispatcher implements Callable<Object> {
1:f13c6ac: 
1:f13c6ac:         public ServiceReference reference;
1:f13c6ac:         public Object service;
1:f13c6ac:         public Object proxy;
1:f13c6ac:         
1:f13c6ac:         public ServiceDispatcher(ServiceReference reference) throws Exception {
1:f13c6ac:             this.reference = reference;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public synchronized void destroy() {
1:f13c6ac:             if (reference != null) {
1:5646642:                 ServiceReference ref = reference;
1:f13c6ac:                 reference = null;
1:f13c6ac:                 service = null;
1:f13c6ac:                 proxy = null;
1:5646642:                 Bundle bundle = ref.getBundle();
1:5646642:                 if (bundle != null) {
1:0186986:                     BundleContext ctx = getBundleContextForServiceLookup();
1:5646642:                     if (ctx != null) {
1:0186986:                       try {
1:0186986:                           ctx.ungetService(ref);
1:0186986:                       } catch (IllegalStateException ise) {
1:0186986:                         // we don't care it doesn't exist so, shrug.
1:5646642:                       }
1:5646642:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public synchronized Object call() throws Exception {
1:546f50f:             if (service == null && reference != null) {
1:546f50f:                 service = getServiceSecurely(reference);
1:f13c6ac:             }
1:f13c6ac:             if (service == null) {
1:546f50f:                 throw new ServiceUnavailableException("Service is unavailable", getOsgiFilter());
1:f13c6ac:             }
1:f13c6ac:             return service;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public class ProvidedObject implements AggregateConverter.Convertible {
1:f13c6ac: 
1:f13c6ac:         public Object convert(ReifiedType type) {
1:f13c6ac:             LOGGER.debug("Converting ManagedCollection to {}", type);
1:f13c6ac:             if (!type.getRawClass().isAssignableFrom(List.class)) {
1:29a5ea1:                 throw new ComponentDefinitionException("<reference-list/> can only be converted to a List, not " + type);
1:f13c6ac:             }
1:f13c6ac:             int memberType = metadata.getMemberType();            
1:f13c6ac:             boolean useRef = false;
1:f13c6ac:             if (type.size() == 1) {
1:f13c6ac:                 useRef = (type.getActualTypeArgument(0).getRawClass() == ServiceReference.class);
1:f13c6ac:                 if ( (useRef && memberType == ReferenceListMetadata.USE_SERVICE_OBJECT) ||
1:f13c6ac:                      (!useRef && memberType == ReferenceListMetadata.USE_SERVICE_REFERENCE)) {
1:f13c6ac:                     throw new ComponentDefinitionException("The memeber-type specified is incompatible with generic injection type");
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             boolean references;
1:f13c6ac:             if (memberType == ReferenceListMetadata.USE_SERVICE_REFERENCE) {                
1:f13c6ac:                 references = true;
1:f13c6ac:             } else if (memberType == ReferenceListMetadata.USE_SERVICE_OBJECT) {
1:f13c6ac:                 references = false;
1:f13c6ac:             } else {
1:f13c6ac:                 references = useRef;
1:f13c6ac:             }
1:f13c6ac:             LOGGER.debug("ManagedCollection references={}", references);
1:f13c6ac:             return getManagedCollection(references);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Base class for managed collections.
1:f13c6ac:      *
1:f13c6ac:      * TODO: list iterators should not be supported
1:f13c6ac:      * TODO: rework the iteration so that if hasNext() has returned false, it will always return false
1:f13c6ac:      * TODO: implement subList()
1:f13c6ac:      */
1:f13c6ac:     public static class ManagedCollection extends AbstractCollection implements List, RandomAccess {
1:f13c6ac: 
1:f13c6ac:         protected final DynamicCollection<ServiceDispatcher> dispatchers;
1:f13c6ac:         protected boolean references;
1:f13c6ac: 
1:f13c6ac:         public ManagedCollection(boolean references, DynamicCollection<ServiceDispatcher> dispatchers) {
1:f13c6ac:             this.references = references;
1:f13c6ac:             this.dispatchers = dispatchers;
1:f13c6ac:             LOGGER.debug("ManagedCollection references={}", references);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public boolean addDispatcher(ServiceDispatcher dispatcher) {
1:f13c6ac:             return dispatchers.add(dispatcher);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public boolean removeDispatcher(ServiceDispatcher dispatcher) {
1:f13c6ac:             return dispatchers.remove(dispatcher);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public DynamicCollection<ServiceDispatcher> getDispatchers() {
1:f13c6ac:             return dispatchers;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public Iterator iterator() {
1:f13c6ac:             return new ManagedListIterator(dispatchers.iterator());
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public int size() {
1:f13c6ac:             return dispatchers.size();
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         @Override
1:f13c6ac:         public boolean add(Object o) {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         @Override
1:f13c6ac:         public boolean remove(Object o) {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         @Override
1:f13c6ac:         public boolean addAll(Collection c) {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         @Override
1:f13c6ac:         public void clear() {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         @Override
1:f13c6ac:         public boolean retainAll(Collection c) {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         @Override
1:f13c6ac:         public boolean removeAll(Collection c) {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public Object get(int index) {
1:f13c6ac:             return references ? dispatchers.get(index).reference : dispatchers.get(index).proxy;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public int indexOf(Object o) {
1:f13c6ac:             if (o == null) {
1:f13c6ac:                 throw new NullPointerException();
1:f13c6ac:             }
1:f13c6ac:             ListIterator e = listIterator();
1:f13c6ac:             while (e.hasNext()) {
1:f13c6ac:                 if (o.equals(e.next())) {
1:f13c6ac:                     return e.previousIndex();
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             return -1;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public int lastIndexOf(Object o) {
1:f13c6ac:             if (o == null) {
1:f13c6ac:                 throw new NullPointerException();
1:f13c6ac:             }
1:f13c6ac:             ListIterator e = listIterator(size());
1:f13c6ac:             while (e.hasPrevious()) {
1:f13c6ac:                 if (o.equals(e.previous())) {
1:f13c6ac:                     return e.nextIndex();
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             return -1;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public ListIterator listIterator() {
1:f13c6ac:             return listIterator(0);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public ListIterator listIterator(int index) {
1:f13c6ac:             return new ManagedListIterator(dispatchers.iterator(index));
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public List<ServiceDispatcher> subList(int fromIndex, int toIndex) {
1:f13c6ac:             throw new UnsupportedOperationException("Not implemented");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public Object set(int index, Object element) {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public void add(int index, Object element) {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public Object remove(int index) {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public boolean addAll(int index, Collection c) {
1:f13c6ac:             throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public class ManagedListIterator implements ListIterator {
1:f13c6ac: 
1:f13c6ac:             protected final ListIterator<ServiceDispatcher> iterator;
1:f13c6ac: 
1:f13c6ac:             public ManagedListIterator(ListIterator<ServiceDispatcher> iterator) {
1:f13c6ac:                 this.iterator = iterator;
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             public boolean hasNext() {
1:f13c6ac:                 return iterator.hasNext();
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             public Object next() {
1:f13c6ac:                 return references ? iterator.next().reference : iterator.next().proxy;
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             public boolean hasPrevious() {
1:f13c6ac:                 return iterator.hasPrevious();
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             public Object previous() {
1:f13c6ac:                 return references ? iterator.previous().reference : iterator.previous().proxy;
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             public int nextIndex() {
1:f13c6ac:                 return iterator.nextIndex();
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             public int previousIndex() {
1:f13c6ac:                 return iterator.previousIndex();
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             public void remove() {
1:f13c6ac:                 throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             public void set(Object o) {
1:f13c6ac:                 throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             public void add(Object o) {
1:f13c6ac:                 throw new UnsupportedOperationException("This collection is read only");
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac: 
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:b5f484e
/////////////////////////////////////////////////////////////////////////
1:     private final Object monitor = new Object();
commit:d46274e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.di.ValueRecipe;
/////////////////////////////////////////////////////////////////////////
1:                          ValueRecipe filterRecipe,
1:         super(name, blueprintContainer, metadata, filterRecipe, listenersRecipe, explicitDependencies);
commit:b069aa4
/////////////////////////////////////////////////////////////////////////
1: 
commit:546f50f
/////////////////////////////////////////////////////////////////////////
1:             if (service == null && reference != null) {
1:                 service = getServiceSecurely(reference);
1:                 throw new ServiceUnavailableException("Service is unavailable", getOsgiFilter());
commit:5646642
/////////////////////////////////////////////////////////////////////////
1:                 ServiceReference ref = reference;
1:                 Bundle bundle = ref.getBundle();
1:                 if (bundle != null) {
0:                     BundleContext ctx = bundle.getBundleContext();
1:                     if (ctx != null) {
0:                         ctx.ungetService(reference);
1:                     }
1:                 }
commit:774ce31
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
0: import org.apache.aries.blueprint.ExtendedServiceReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
0:                     Set<Class> interfaces = new HashSet<Class>();
0:                         interfaces.add(loadClass(metadata.getInterface()));
0:                         if (((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface() != null) {
0:                             interfaces.add(((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface());
1:                         }
1:                             List<String> ifs = Arrays.asList((String[]) reference.getProperty(Constants.OBJECTCLASS));
1:                             interfaces.addAll(loadAllClasses(ifs));
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
0: import java.util.AbstractCollection;
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.Collection;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.ListIterator;
0: import java.util.RandomAccess;
1: import java.util.concurrent.Callable;
1: 
0: import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
0: import org.apache.geronimo.blueprint.ExtendedReferenceListMetadata;
0: import org.apache.geronimo.blueprint.di.Recipe;
0: import org.apache.geronimo.blueprint.di.CollectionRecipe;
0: import org.apache.geronimo.blueprint.utils.DynamicCollection;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.service.blueprint.container.ReifiedType;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.container.ServiceUnavailableException;
1: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A recipe to create a managed collection of service references
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 760378 $, $Date: 2009-03-31 11:31:38 +0200 (Tue, 31 Mar 2009) $
1:  */
1: public class ReferenceListRecipe extends AbstractServiceReferenceRecipe {
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(ReferenceListRecipe.class);
1: 
1:     private final ReferenceListMetadata metadata;
1:     private final List<ManagedCollection> collections = new ArrayList<ManagedCollection>();
1:     private final DynamicCollection<ServiceDispatcher> storage = new DynamicCollection<ServiceDispatcher>();
1:     private final List<ServiceDispatcher> unboundDispatchers = new ArrayList<ServiceDispatcher>();
0:     private final Object monitor = new Object();
1:     
1:     public ReferenceListRecipe(String name,
1:                          ExtendedBlueprintContainer blueprintContainer,
1:                          ReferenceListMetadata metadata,
1:                          CollectionRecipe listenersRecipe,
1:                          List<Recipe> explicitDependencies) {
0:         super(name, blueprintContainer, metadata, listenersRecipe, explicitDependencies);
1:         this.metadata = metadata;
1:     }
1: 
1:     @Override
1:     protected Object internalCreate() throws ComponentDefinitionException {
1:         try {
1:             if (explicitDependencies != null) {
1:                 for (Recipe recipe : explicitDependencies) {
1:                     recipe.create();
1:                 }
1:             }
1:             ProvidedObject object = new ProvidedObject();
1:             addPartialObject(object);
1:             // Handle initial references
1:             createListeners();
1:             updateListeners();
1:            
1:             return object;
1:         } catch (ComponentDefinitionException t) {
1:             throw t;
1:         } catch (Throwable t) {
1:             throw new ComponentDefinitionException(t);
1:         }
1:     }
1: 
1:     protected void retrack() {
1:         List<ServiceReference> refs = getServiceReferences();
1:         if (refs != null) {
1:             for (ServiceReference ref : refs) {
1:                 track(ref);
1:             }
1:         }
1:     }
1: 
1:     protected void track(ServiceReference reference) {
1:         synchronized (monitor) {
1:             try {
1:                 // ServiceReferences may be tracked at multiple points:
1:                 //  * first after the collection creation in #internalCreate()
1:                 //  * in #postCreate() after listeners are created
1:                 //  * after creation time if a new reference shows up
1:                 //
1:                 // In the first step, listeners are not created, so we add
1:                 // the dispatcher to the unboundDispatchers list.  In the second
1:                 // step, the dispatcher has already been added to the collection
1:                 // so we just call the listener.
1:                 //
1:                 ServiceDispatcher dispatcher = findDispatcher(reference);
1:                 if (dispatcher != null) {
1:                     if (!unboundDispatchers.remove(dispatcher)) {
1:                         return;
1:                     }
1:                 } else {
1:                     dispatcher = new ServiceDispatcher(reference);
0:                     List<String> interfaces = new ArrayList<String>();
0:                     if (metadata.getInterface() != null) {
0:                         interfaces.add(metadata.getInterface());
1:                     }
1:                     if (metadata instanceof ExtendedReferenceListMetadata) {
1:                         boolean greedy = (((ExtendedReferenceListMetadata) metadata).getProxyMethod() & ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY) != 0;
1:                         if (greedy) {
0:                             interfaces = Arrays.asList((String[]) reference.getProperty(Constants.OBJECTCLASS));
1:                         }
1:                     }
1:                     dispatcher.proxy = createProxy(dispatcher, interfaces);
1:                     if (!storage.add(dispatcher)) {
1:                         dispatcher.destroy();
1:                         return;
1:                     }
1:                 }
1:                 if (listeners != null) {
1:                     bind(dispatcher.reference, dispatcher.proxy);                   
1:                 } else {
1:                     unboundDispatchers.add(dispatcher);
1:                 }
1:             } catch (Throwable t) {
1:                 LOGGER.info("Error tracking new service reference", t);
1:             }
1:         }
1:     }
1: 
1:     protected void untrack(ServiceReference reference) {
1:         synchronized (monitor) {
1:             ServiceDispatcher dispatcher = findDispatcher(reference);
1:             if (dispatcher != null) {
1:                 unbind(dispatcher.reference, dispatcher.proxy);
1:                 storage.remove(dispatcher);
1:                 dispatcher.destroy();
1:             }
1:         }
1:     }
1: 
1:     protected ServiceDispatcher findDispatcher(ServiceReference reference) {
1:         for (ServiceDispatcher dispatcher : storage) {
1:             if (dispatcher.reference == reference) {
1:                 return dispatcher;
1:             }
1:         }
1:         return null;
1:     }
1: 
1:     protected ManagedCollection getManagedCollection(boolean useReferences) {
1:         for (ManagedCollection col : collections) {
1:             if (col.references == useReferences) {
1:                 return col;
1:             }
1:         }
1:         ManagedCollection collection = new ManagedCollection(useReferences, storage);
1:         collections.add(collection);
1:         return collection;
1:     }
1: 
1:     /**
1:      * The ServiceDispatcher is used when creating the cglib proxy.
1:      * Thic class is responsible for getting the actual service that will be used.
1:      */
1:     public class ServiceDispatcher implements Callable<Object> {
1: 
1:         public ServiceReference reference;
1:         public Object service;
1:         public Object proxy;
1:         
1:         public ServiceDispatcher(ServiceReference reference) throws Exception {
1:             this.reference = reference;
1:         }
1: 
1:         public synchronized void destroy() {
1:             if (reference != null) {
0:                 reference.getBundle().getBundleContext().ungetService(reference);
1:                 reference = null;
1:                 service = null;
1:                 proxy = null;
1:             }
1:         }
1: 
1:         public synchronized Object call() throws Exception {
0:             if (reference == null) {
0:                 throw new ServiceUnavailableException("Service is unavailable", getOsgiFilter());
1:             }
1:             if (service == null) {
0:                 service = blueprintContainer.getService(reference);
1:             }
1:             return service;
1:         }
1: 
1:     }
1: 
1:     public class ProvidedObject implements AggregateConverter.Convertible {
1: 
1:         public Object convert(ReifiedType type) {
1:             LOGGER.debug("Converting ManagedCollection to {}", type);
1:             if (!type.getRawClass().isAssignableFrom(List.class)) {
0:                 throw new ComponentDefinitionException("<ref-list/> can only be converted to a List, not " + type);
1:             }
1:             int memberType = metadata.getMemberType();            
1:             boolean useRef = false;
1:             if (type.size() == 1) {
1:                 useRef = (type.getActualTypeArgument(0).getRawClass() == ServiceReference.class);
1:                 if ( (useRef && memberType == ReferenceListMetadata.USE_SERVICE_OBJECT) ||
1:                      (!useRef && memberType == ReferenceListMetadata.USE_SERVICE_REFERENCE)) {
1:                     throw new ComponentDefinitionException("The memeber-type specified is incompatible with generic injection type");
1:                 }
1:             }
1:             boolean references;
1:             if (memberType == ReferenceListMetadata.USE_SERVICE_REFERENCE) {                
1:                 references = true;
1:             } else if (memberType == ReferenceListMetadata.USE_SERVICE_OBJECT) {
1:                 references = false;
1:             } else {
1:                 references = useRef;
1:             }
1:             LOGGER.debug("ManagedCollection references={}", references);
1:             return getManagedCollection(references);
1:         }
1: 
1:     }
1: 
1:     /**
1:      * Base class for managed collections.
1:      *
1:      * TODO: list iterators should not be supported
1:      * TODO: rework the iteration so that if hasNext() has returned false, it will always return false
1:      * TODO: implement subList()
1:      */
1:     public static class ManagedCollection extends AbstractCollection implements List, RandomAccess {
1: 
1:         protected final DynamicCollection<ServiceDispatcher> dispatchers;
1:         protected boolean references;
1: 
1:         public ManagedCollection(boolean references, DynamicCollection<ServiceDispatcher> dispatchers) {
1:             this.references = references;
1:             this.dispatchers = dispatchers;
1:             LOGGER.debug("ManagedCollection references={}", references);
1:         }
1: 
1:         public boolean addDispatcher(ServiceDispatcher dispatcher) {
1:             return dispatchers.add(dispatcher);
1:         }
1: 
1:         public boolean removeDispatcher(ServiceDispatcher dispatcher) {
1:             return dispatchers.remove(dispatcher);
1:         }
1: 
1:         public DynamicCollection<ServiceDispatcher> getDispatchers() {
1:             return dispatchers;
1:         }
1: 
1:         public Iterator iterator() {
1:             return new ManagedListIterator(dispatchers.iterator());
1:         }
1: 
1:         public int size() {
1:             return dispatchers.size();
1:         }
1: 
1:         @Override
1:         public boolean add(Object o) {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         @Override
1:         public boolean remove(Object o) {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         @Override
1:         public boolean addAll(Collection c) {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         @Override
1:         public void clear() {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         @Override
1:         public boolean retainAll(Collection c) {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         @Override
1:         public boolean removeAll(Collection c) {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         public Object get(int index) {
1:             return references ? dispatchers.get(index).reference : dispatchers.get(index).proxy;
1:         }
1: 
1:         public int indexOf(Object o) {
1:             if (o == null) {
1:                 throw new NullPointerException();
1:             }
1:             ListIterator e = listIterator();
1:             while (e.hasNext()) {
1:                 if (o.equals(e.next())) {
1:                     return e.previousIndex();
1:                 }
1:             }
1:             return -1;
1:         }
1: 
1:         public int lastIndexOf(Object o) {
1:             if (o == null) {
1:                 throw new NullPointerException();
1:             }
1:             ListIterator e = listIterator(size());
1:             while (e.hasPrevious()) {
1:                 if (o.equals(e.previous())) {
1:                     return e.nextIndex();
1:                 }
1:             }
1:             return -1;
1:         }
1: 
1:         public ListIterator listIterator() {
1:             return listIterator(0);
1:         }
1: 
1:         public ListIterator listIterator(int index) {
1:             return new ManagedListIterator(dispatchers.iterator(index));
1:         }
1: 
1:         public List<ServiceDispatcher> subList(int fromIndex, int toIndex) {
1:             throw new UnsupportedOperationException("Not implemented");
1:         }
1: 
1:         public Object set(int index, Object element) {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         public void add(int index, Object element) {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         public Object remove(int index) {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         public boolean addAll(int index, Collection c) {
1:             throw new UnsupportedOperationException("This collection is read only");
1:         }
1: 
1:         public class ManagedListIterator implements ListIterator {
1: 
1:             protected final ListIterator<ServiceDispatcher> iterator;
1: 
1:             public ManagedListIterator(ListIterator<ServiceDispatcher> iterator) {
1:                 this.iterator = iterator;
1:             }
1: 
1:             public boolean hasNext() {
1:                 return iterator.hasNext();
1:             }
1: 
1:             public Object next() {
1:                 return references ? iterator.next().reference : iterator.next().proxy;
1:             }
1: 
1:             public boolean hasPrevious() {
1:                 return iterator.hasPrevious();
1:             }
1: 
1:             public Object previous() {
1:                 return references ? iterator.previous().reference : iterator.previous().proxy;
1:             }
1: 
1:             public int nextIndex() {
1:                 return iterator.nextIndex();
1:             }
1: 
1:             public int previousIndex() {
1:                 return iterator.previousIndex();
1:             }
1: 
1:             public void remove() {
1:                 throw new UnsupportedOperationException("This collection is read only");
1:             }
1: 
1:             public void set(Object o) {
1:                 throw new UnsupportedOperationException("This collection is read only");
1:             }
1: 
1:             public void add(Object o) {
1:                 throw new UnsupportedOperationException("This collection is read only");
1:             }
1:         }
1: 
1:     }
1: 
1: 
1: }
author:Holly Cummins
-------------------------------------------------------------------------------
commit:e3bd874
/////////////////////////////////////////////////////////////////////////
0:                 service = getServiceSecurely(reference);
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:0186986
/////////////////////////////////////////////////////////////////////////
1:                     BundleContext ctx = getBundleContextForServiceLookup();
1:                       try {
1:                           ctx.ungetService(ref);
1:                       } catch (IllegalStateException ise) {
1:                         // we don't care it doesn't exist so, shrug.
0:                       }
commit:24455ce
/////////////////////////////////////////////////////////////////////////
1:                     Set<Class<?>> interfaces = new HashSet<Class<?>>();
1:                     Class<?> clz = getInterfaceClass();
author:J. Daniel Kulp
-------------------------------------------------------------------------------
commit:66c2215
/////////////////////////////////////////////////////////////////////////
0:                         ctx.ungetService(ref);
commit:e93dfea
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:b13e703
/////////////////////////////////////////////////////////////////////////
0:                 service = getBundleContextForServiceLookup().getService(reference);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:2a55096
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     Class clz = getInterfaceClass();
1:                     if (clz != null) interfaces.add(clz);
author:Lin Sun
-------------------------------------------------------------------------------
commit:29a5ea1
/////////////////////////////////////////////////////////////////////////
1:                 throw new ComponentDefinitionException("<reference-list/> can only be converted to a List, not " + type);
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.ExtendedReferenceListMetadata;
1: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.di.CollectionRecipe;
1: import org.apache.aries.blueprint.utils.DynamicCollection;
============================================================================