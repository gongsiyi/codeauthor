1:a14f2fd: /*
1:a14f2fd:  * Licensed under the Apache License, Version 2.0 (the "License");
1:a14f2fd:  * you may not use this file except in compliance with the License.
1:a14f2fd:  * You may obtain a copy of the License at
1:a14f2fd:  *
1:a14f2fd:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a14f2fd:  *
1:a14f2fd:  * Unless required by applicable law or agreed to in writing, software
1:a14f2fd:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a14f2fd:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a14f2fd:  * See the License for the specific language governing permissions and
1:a14f2fd:  * limitations under the License.
1:a14f2fd:  */
1:dc5d52f: package org.apache.aries.subsystem.core.internal;
1:dc5d52f: 
1:777b216: import java.io.IOException;
1:a990e32: import java.security.AccessController;
1:dc5d52f: import java.util.ArrayList;
1:777b216: import java.util.Collection;
1:dc5d52f: import java.util.Collections;
1:391a1aa: import java.util.EnumSet;
1:b66ad7c: import java.util.LinkedHashSet;
1:dc5d52f: import java.util.List;
1:777b216: import java.util.Map.Entry;
1:a990e32: import java.util.Set;
1:391a1aa: 
1:79b20bc: import org.apache.aries.subsystem.ContentHandler;
1:777b216: import org.apache.aries.subsystem.core.archive.ExportPackageCapability;
1:777b216: import org.apache.aries.subsystem.core.archive.ExportPackageHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.ProvideCapabilityCapability;
1:777b216: import org.apache.aries.subsystem.core.archive.ProvideCapabilityHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.SubsystemExportServiceCapability;
1:777b216: import org.apache.aries.subsystem.core.archive.SubsystemExportServiceHeader;
1:a990e32: import org.apache.aries.subsystem.core.internal.BundleResourceInstaller.BundleConstituent;
1:777b216: import org.eclipse.equinox.region.Region;
1:777b216: import org.eclipse.equinox.region.RegionFilter;
1:777b216: import org.eclipse.equinox.region.RegionFilterBuilder;
1:777b216: import org.osgi.framework.Bundle;
1:777b216: import org.osgi.framework.BundleException;
1:777b216: import org.osgi.framework.InvalidSyntaxException;
1:79b20bc: import org.osgi.framework.ServiceReference;
1:777b216: import org.osgi.framework.namespace.IdentityNamespace;
1:9bcf4ce: import org.osgi.framework.startlevel.BundleStartLevel;
1:d89d3d4: import org.osgi.framework.startlevel.FrameworkStartLevel;
1:777b216: import org.osgi.framework.wiring.BundleRevision;
1:777b216: import org.osgi.framework.wiring.FrameworkWiring;
1:dc5d52f: import org.osgi.resource.Resource;
1:dc5d52f: import org.osgi.service.coordinator.Coordination;
1:dc5d52f: import org.osgi.service.coordinator.CoordinationException;
1:777b216: import org.osgi.service.coordinator.Participant;
1:777b216: import org.osgi.service.subsystem.Subsystem;
1:dc5d52f: import org.osgi.service.subsystem.Subsystem.State;
1:777b216: import org.osgi.service.subsystem.SubsystemConstants;
1:777b216: import org.osgi.service.subsystem.SubsystemException;
1:777b216: import org.slf4j.Logger;
1:777b216: import org.slf4j.LoggerFactory;
1:777b216: 
1:777b216: public class StartAction extends AbstractAction {
1:b66ad7c: 	public static enum Restriction {
1:b66ad7c: 		NONE,
1:b66ad7c: 		INSTALL_ONLY,
1:b66ad7c: 		RESOLVE_ONLY
1:b66ad7c: 	}
1:a990e32: 	
1:b66ad7c: 	private static final Logger logger = LoggerFactory.getLogger(StartAction.class);
1:a990e32: 
1:3c826b1: 	private final Coordination coordination;
1:5bd3bf6: 	private final BasicSubsystem instigator;
1:b66ad7c: 	private final Restriction restriction;
1:a990e32: 
1:5bd3bf6: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target) {
1:b66ad7c: 		this(instigator, requestor, target, Restriction.NONE);
1:d6eb080: 	}
1:d6eb080: 
1:b66ad7c: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target, Restriction restriction) {
1:b66ad7c: 		this(instigator, requestor, target, null, restriction);
1:a990e32: 	}
1:3c826b1: 	
1:3c826b1: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target, Coordination coordination) {
1:b66ad7c: 		this(instigator, requestor, target, coordination, Restriction.NONE);
1:d6eb080: 	}
1:d6eb080: 	
1:b66ad7c: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target, Coordination coordination, Restriction restriction) {
1:391a1aa: 		super(requestor, target, false);
1:391a1aa: 		this.instigator = instigator;
1:3c826b1: 		this.coordination = coordination;
1:b66ad7c: 		this.restriction = restriction;
1:a990e32: 	}
1:a990e32: 	
1:b66ad7c: 	private static boolean isTargetStartable(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target) {
1:b66ad7c: 		State state = target.getState();
1:b66ad7c: 	    // The following states are illegal.
1:b66ad7c: 	    if (EnumSet.of(State.INSTALL_FAILED, State.UNINSTALLED).contains(state))
1:b66ad7c: 	        throw new SubsystemException("Cannot start from state " + state);
1:b66ad7c: 	    // The following states mean the requested state has already been attained.
1:b66ad7c: 	    if (State.ACTIVE.equals(state))
1:b66ad7c: 	        return false;
1:b66ad7c: 		// Always start if target is content of requestor.
1:b66ad7c: 	    if (!Utils.isContent(requestor, target)) {
1:e7c948c: 	        // Always start if target is a dependency of requestor.
1:b66ad7c: 	        if (!Utils.isDependency(requestor, target)) {
1:b66ad7c: 	            // Always start if instigator equals target (explicit start).
1:b66ad7c: 	            if (!instigator.equals(target)) {
1:b66ad7c: 	                // Don't start if instigator is root (restart) and target is not ready.
1:b66ad7c: 	                if (instigator.isRoot() && !target.isReadyToStart()) {
1:b66ad7c: 	                    return false;
1:b66ad7c: 	                }
1:b66ad7c: 	            }
1:b66ad7c: 	        }
1:b66ad7c: 	    }
1:b66ad7c: 	    return true;
1:b66ad7c: 	}
1:b66ad7c: 	
1:b66ad7c: 	private void installDependencies(BasicSubsystem target, Coordination coordination) throws Exception {
1:b66ad7c: 		for (Subsystem parent : target.getParents()) {
1:b66ad7c: 			AccessController.doPrivileged(new StartAction(instigator, target, (BasicSubsystem)parent, coordination, Restriction.INSTALL_ONLY));
1:b66ad7c: 		}
1:b66ad7c: 		installDependencies(Collections.<Subsystem>singletonList(target), coordination);
1:b66ad7c: 		for (Subsystem child : Activator.getInstance().getSubsystems().getChildren(target)) {
1:b66ad7c: 			AccessController.doPrivileged(new StartAction(instigator, target, (BasicSubsystem)child, coordination, Restriction.INSTALL_ONLY));
1:b66ad7c: 		}
1:b66ad7c: 	}
1:b66ad7c: 	
1:b66ad7c: 	private static void installDependencies(Collection<Subsystem> subsystems, Coordination coordination) throws Exception {
1:b66ad7c: 		for (Subsystem subsystem : subsystems) {
1:b66ad7c: 			if (State.INSTALLING.equals(subsystem.getState())) {
1:b66ad7c: 				BasicSubsystem bs = (BasicSubsystem)subsystem;
1:b66ad7c: 				bs.computeDependenciesPostInstallation(coordination);
1:b66ad7c: 				new InstallDependencies().install(bs, null, coordination);
1:b66ad7c: 				bs.setState(State.INSTALLED);
1:b66ad7c: 			}
1:b66ad7c: 		}
1:b66ad7c: 	}
1:b66ad7c: 	
1:b66ad7c: 	private Coordination createCoordination() {
1:b66ad7c: 		Coordination coordination = this.coordination;
1:b66ad7c: 	    if (coordination == null) {
1:b66ad7c: 	        coordination = Utils.createCoordination(target);
1:b66ad7c: 	    }
1:b66ad7c: 	    return coordination;
1:b66ad7c: 	}
1:b66ad7c: 	
1:1fca6d0: 	private static class AffectedResources {
1:1fca6d0: 		private final List<Resource> resources;
1:1fca6d0: 		private final Collection<BasicSubsystem> subsystemResources;
1:1fca6d0: 		
1:1fca6d0: 		AffectedResources(BasicSubsystem target) {
1:1fca6d0: 			LinkedHashSet<Resource> resources = new LinkedHashSet<Resource>();
1:1fca6d0: 			LinkedHashSet<BasicSubsystem> subsystemResources = new LinkedHashSet<BasicSubsystem>();
1:1fca6d0: 			Subsystems subsystems = Activator.getInstance().getSubsystems();
1:1fca6d0: 			for (Resource dep : subsystems.getResourcesReferencedBy(target)) {
1:1fca6d0: 				if (dep instanceof BasicSubsystem 
1:1fca6d0: 						&& !subsystems.getChildren(target).contains(dep)) {
1:1fca6d0: 					subsystemResources.add((BasicSubsystem)dep);
1:1fca6d0: 				}
1:1fca6d0: 				else if (dep instanceof BundleRevision) {
1:1fca6d0: 					BundleConstituent constituent = new BundleConstituent(null, (BundleRevision)dep);
1:1fca6d0: 					if (!target.getConstituents().contains(constituent)) {
1:1fca6d0: 						for (BasicSubsystem constituentOf : subsystems.getSubsystemsByConstituent(
1:1fca6d0: 								new BundleConstituent(null, (BundleRevision)dep))) {
1:1fca6d0: 							subsystemResources.add(constituentOf);
1:1fca6d0: 						}
1:b66ad7c: 					}
1:b66ad7c: 				}
1:1fca6d0: 				resources.add(dep);
1:b66ad7c: 			}
1:1fca6d0: 			for (Subsystem child : subsystems.getChildren(target)) {
1:1fca6d0: 				subsystemResources.add((BasicSubsystem)child);
1:1fca6d0: 				resources.add((BasicSubsystem)child);
1:b66ad7c: 			}
1:1fca6d0: 			for (Resource resource : target.getResource().getSharedContent()) {
1:1fca6d0: 				for (BasicSubsystem constituentOf : subsystems.getSubsystemsByConstituent(
1:1fca6d0: 						resource instanceof BundleRevision ? new BundleConstituent(null, (BundleRevision)resource) : resource)) {
1:1fca6d0: 					subsystemResources.add(constituentOf);
1:1fca6d0: 				}
1:1fca6d0: 				resources.add(resource);
1:1fca6d0: 			}
1:1fca6d0: 			subsystemResources.add(target);
1:1fca6d0: 			this.resources = new ArrayList<Resource>(resources);
1:1fca6d0: 			this.subsystemResources = subsystemResources;
1:b66ad7c: 		}
1:1fca6d0: 		
1:1fca6d0: 		List<Resource> resources() {
1:1fca6d0: 			return resources;
1:1fca6d0: 		}
1:1fca6d0: 		
1:1fca6d0: 		Collection<BasicSubsystem> subsystems() {
1:1fca6d0: 			return subsystemResources;
1:1fca6d0: 		}
1:1fca6d0: 	}
1:1fca6d0: 	
1:1fca6d0: 	private static AffectedResources computeAffectedResources(BasicSubsystem target) {
1:1fca6d0: 		return new AffectedResources(target);
1:b66ad7c: 	}
1:777b216: 
1:a990e32: 	@Override
1:dc5d52f: 	public Object run() {
1:b66ad7c: 		// Protect against re-entry now that cycles are supported.
1:279dba5: 		if (!Activator.getInstance().getLockingStrategy().set(State.STARTING, target)) {
1:b66ad7c: 			return null;
1:b66ad7c: 		}
1:b66ad7c: 		try {
1:1fca6d0: 			AffectedResources affectedResources;
1:b66ad7c: 			// We are now protected against re-entry.
1:b66ad7c: 			// If necessary, install the dependencies.
1:b66ad7c: 	    	if (State.INSTALLING.equals(target.getState()) && !Utils.isProvisionDependenciesInstall(target)) {
1:b66ad7c: 	    		// Acquire the global write lock while installing dependencies.
1:279dba5: 				Activator.getInstance().getLockingStrategy().writeLock();
1:b66ad7c: 				try {
1:b66ad7c: 					// We are now protected against installs, starts, stops, and uninstalls.
1:b66ad7c: 		    		// We need a separate coordination when installing 
1:b66ad7c: 					// dependencies because cleaning up the temporary export 
1:b66ad7c: 					// sharing policies must be done while holding the write lock.
1:b66ad7c: 		    		Coordination c = Utils.createCoordination(target);
1:b66ad7c: 		    		try {
1:b66ad7c: 		    			installDependencies(target, c);
1:b66ad7c: 		    			// Associated subsystems must be computed after all dependencies 
1:b66ad7c: 						// are installed because some of the dependencies may be 
1:b66ad7c: 						// subsystems. This is safe to do while only holding the read
1:b66ad7c: 						// lock since we know that nothing can be added or removed.
1:1fca6d0: 		    			affectedResources = computeAffectedResources(target);
1:1fca6d0: 						for (BasicSubsystem subsystem : affectedResources.subsystems()) {
1:b66ad7c: 							if (State.INSTALLING.equals(subsystem.getState())
1:b66ad7c: 									&& !Utils.isProvisionDependenciesInstall(subsystem)) {
1:b66ad7c: 								installDependencies(subsystem, c);
1:b66ad7c: 							}
1:b66ad7c: 						}
1:b66ad7c: 						// Downgrade to the read lock in order to prevent 
1:b66ad7c: 		    			// installs and uninstalls but allow starts and stops.
1:279dba5: 						Activator.getInstance().getLockingStrategy().readLock();
1:b66ad7c: 		    		}
1:b66ad7c: 		    		catch (Throwable t) {
1:b66ad7c: 		    			c.fail(t);
1:b66ad7c: 		    		}
1:b66ad7c: 		    		finally {
1:b66ad7c: 		    			// This will clean up the temporary export sharing
1:b66ad7c: 		    			// policies. Must be done while holding the write lock.
1:b66ad7c: 		    			c.end();
1:b66ad7c: 		    		}
1:b66ad7c: 				}
1:b66ad7c: 				finally {
1:b66ad7c: 					// Release the global write lock as soon as possible.
1:279dba5: 					Activator.getInstance().getLockingStrategy().writeUnlock();
1:b66ad7c: 				}
1:b66ad7c: 	    	}
1:b66ad7c: 	    	else {
1:b66ad7c: 	    		// Acquire the read lock in order to prevent installs and
1:b66ad7c: 	    		// uninstalls but allow starts and stops.
1:279dba5: 	    		Activator.getInstance().getLockingStrategy().readLock();
1:b66ad7c: 	    	}
1:b66ad7c: 	    	try {
1:b66ad7c: 	    		// We now hold the read lock and are protected against installs
1:b66ad7c: 	    		// and uninstalls.
1:b66ad7c: 	    		if (Restriction.INSTALL_ONLY.equals(restriction)) {
1:b66ad7c: 					return null;
1:b66ad7c: 				}
1:b66ad7c: 	    		// Compute associated subsystems here in case (1) they weren't
1:b66ad7c: 	    		// computed previously while holding the write lock or (2) they
1:b66ad7c: 	    		// were computed previously and more were subsequently added. 
1:b66ad7c: 				// This is safe to do while only holding the read lock since we
1:b66ad7c: 				// know that nothing can be added or removed.
1:1fca6d0: 	    		affectedResources = computeAffectedResources(target);
1:b66ad7c: 				// Acquire the global mutual exclusion lock while acquiring the
1:b66ad7c: 				// state change locks of affected subsystems.
1:279dba5: 				Activator.getInstance().getLockingStrategy().lock();
1:b66ad7c: 				try {
1:b66ad7c: 					// We are now protected against cycles.
1:b66ad7c: 					// Acquire the state change locks of affected subsystems.
1:279dba5: 					Activator.getInstance().getLockingStrategy().lock(affectedResources.subsystems());
1:b66ad7c: 				}
1:b66ad7c: 				finally {
1:b66ad7c: 					// Release the global mutual exclusion lock as soon as possible.
1:279dba5: 					Activator.getInstance().getLockingStrategy().unlock();
1:b66ad7c: 				}
1:b66ad7c: 				Coordination coordination = this.coordination;
1:b66ad7c: 				try {
1:b66ad7c: 					coordination = createCoordination();
1:b66ad7c: 					// We are now protected against other starts and stops of the affected subsystems.
1:b66ad7c: 					if (!isTargetStartable(instigator, requestor, target)) {
1:b66ad7c: 						return null;
1:b66ad7c: 					}
1:b66ad7c: 					
1:b66ad7c: 					// Resolve if necessary.
1:b66ad7c: 					if (State.INSTALLED.equals(target.getState()))
1:1fca6d0: 						resolve(instigator, target, target, coordination, affectedResources.subsystems());
1:b66ad7c: 					if (Restriction.RESOLVE_ONLY.equals(restriction))
1:d6eb080: 						return null;
1:b66ad7c: 					target.setState(State.STARTING);
1:b66ad7c: 					// Be sure to set the state back to RESOLVED if starting fails.
1:b66ad7c: 					coordination.addParticipant(new Participant() {
1:b66ad7c: 						@Override
1:b66ad7c: 						public void ended(Coordination coordination) throws Exception {
1:b66ad7c: 							// Nothing.
1:b66ad7c: 						}
1:b66ad7c: 
1:b66ad7c: 						@Override
1:b66ad7c: 						public void failed(Coordination coordination) throws Exception {
1:b66ad7c: 							target.setState(State.RESOLVED);
1:b66ad7c: 						}
1:b66ad7c: 					});
1:b66ad7c: 					SubsystemContentHeader header = target.getSubsystemManifest().getSubsystemContentHeader();
1:b66ad7c: 					if (header != null)
1:1fca6d0: 						Collections.sort(affectedResources.resources(), new StartResourceComparator(header));
1:1fca6d0: 					for (Resource resource : affectedResources.resources())
1:b66ad7c: 						startResource(resource, coordination);
1:b66ad7c: 					target.setState(State.ACTIVE);
1:b66ad7c: 					
1:b66ad7c: 				}
1:b66ad7c: 				catch (Throwable t) {
1:b66ad7c: 					// We catch exceptions and fail the coordination here to
1:b66ad7c: 					// ensure we are still holding the state change locks when
1:b66ad7c: 					// the participant sets the state to RESOLVED.
1:b66ad7c: 					coordination.fail(t);
1:b66ad7c: 				}
1:b66ad7c: 				finally {
1:b66ad7c: 					try {
1:b66ad7c: 						// Don't end a coordination that was not begun as part
1:b66ad7c: 						// of this start action.
1:b66ad7c: 						if (coordination.getName().equals(Utils.computeCoordinationName(target))) {
1:b66ad7c: 							coordination.end();
1:b66ad7c: 						}
1:b66ad7c: 					}
1:b66ad7c: 					finally {
1:b66ad7c: 						// Release the state change locks of affected subsystems.
1:279dba5: 						Activator.getInstance().getLockingStrategy().unlock(affectedResources.subsystems());
1:b66ad7c: 					}
1:b66ad7c: 				}
1:b66ad7c: 	    	}
1:b66ad7c: 	    	finally {
1:b66ad7c: 				// Release the read lock.
1:279dba5: 				Activator.getInstance().getLockingStrategy().readUnlock();
1:b66ad7c: 			}
1:b66ad7c: 		}
1:b66ad7c: 		catch (CoordinationException e) {
1:b66ad7c: 			Throwable t = e.getCause();
1:b66ad7c: 			if (t == null) {
1:b66ad7c: 				throw new SubsystemException(e);
1:b66ad7c: 			}
1:b66ad7c: 			if (t instanceof SecurityException) {
1:b66ad7c: 				throw (SecurityException)t;
1:b66ad7c: 			}
1:b66ad7c: 			if (t instanceof SubsystemException) {
1:b66ad7c: 				throw (SubsystemException)t;
1:b66ad7c: 			}
1:b66ad7c: 			throw new SubsystemException(t);
1:b66ad7c: 		}
1:b66ad7c: 		finally {
1:b66ad7c: 			// Protection against re-entry no longer required.
1:279dba5: 			Activator.getInstance().getLockingStrategy().unset(State.STARTING, target);
1:a990e32: 		}
1:b66ad7c: 		return null;
1:a990e32: 	}
1:a990e32: 
1:5bd3bf6: 	private static Collection<Bundle> getBundles(BasicSubsystem subsystem) {
1:777b216: 		Collection<Resource> constituents = Activator.getInstance().getSubsystems().getConstituents(subsystem);
1:777b216: 		ArrayList<Bundle> result = new ArrayList<Bundle>(constituents.size());
1:777b216: 		for (Resource resource : constituents) {
1:777b216: 			if (resource instanceof BundleRevision)
1:777b216: 				result.add(((BundleRevision)resource).getBundle());
1:a990e32: 		}
1:777b216: 		result.trimToSize();
1:b66ad7c: 		return result;
1:a990e32: 	}
1:777b216: 	
1:a990e32: 	private static void emitResolvingEvent(BasicSubsystem subsystem) {
1:391a1aa: 		// Don't propagate a RESOLVING event if this is a persisted subsystem
1:391a1aa: 		// that is already RESOLVED.
1:391a1aa: 		if (State.INSTALLED.equals(subsystem.getState()))
1:391a1aa: 			subsystem.setState(State.RESOLVING);
1:a990e32: 	}
1:777b216: 	
1:a990e32: 	private static void emitResolvedEvent(BasicSubsystem subsystem) {
1:a990e32: 		// No need to propagate a RESOLVED event if this is a persisted
1:a990e32: 		// subsystem already in the RESOLVED state.
1:a990e32: 		if (State.RESOLVING.equals(subsystem.getState()))
1:a990e32: 			subsystem.setState(State.RESOLVED);
1:a990e32: 	}
1:a990e32: 	
1:b66ad7c: 	private static void resolveSubsystems(BasicSubsystem instigator, BasicSubsystem target, Coordination coordination, Collection<BasicSubsystem> subsystems) throws Exception {
2:b66ad7c: 		for (BasicSubsystem subsystem : subsystems) {
1:b66ad7c: 			resolveSubsystem(instigator, target, subsystem, coordination);
1:b66ad7c: 		}
1:b66ad7c: 	}
1:a990e32: 	
1:b66ad7c: 	private static void resolveSubsystem(BasicSubsystem instigator, BasicSubsystem target, BasicSubsystem subsystem, Coordination coordination) throws Exception {
1:a990e32: 		State state = subsystem.getState();
1:a990e32: 		if (State.INSTALLED.equals(state)) {
1:b66ad7c: 			if (target.equals(subsystem)) {
1:b66ad7c: 				resolve(instigator, target, subsystem, coordination, Collections.<BasicSubsystem>emptyList());
1:b66ad7c: 			}
1:b66ad7c: 			else {
1:b66ad7c: 				AccessController.doPrivileged(new StartAction(instigator, target, subsystem, coordination, Restriction.RESOLVE_ONLY));
1:b66ad7c: 			}
1:b66ad7c: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private static void resolveBundles(BasicSubsystem subsystem) {
1:a990e32: 		FrameworkWiring frameworkWiring = Activator.getInstance().getBundleContext().getBundle(0)
1:a990e32: 				.adapt(FrameworkWiring.class);
1:a990e32: 		// TODO I think this is insufficient. Do we need both
1:a990e32: 		// pre-install and post-install environments for the Resolver?
1:a990e32: 		Collection<Bundle> bundles = getBundles(subsystem);
1:a990e32: 		if (!frameworkWiring.resolveBundles(bundles)) {
1:a990e32: 			handleFailedResolution(subsystem, bundles, frameworkWiring);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 
1:b66ad7c: 	private static void resolve(BasicSubsystem instigator, BasicSubsystem target, BasicSubsystem subsystem, Coordination coordination, Collection<BasicSubsystem> subsystems) {
1:a990e32: 		emitResolvingEvent(subsystem);
2:a990e32: 		try {
1:b548bb2: 			// The root subsystem should follow the same event pattern for
1:b548bb2: 			// state transitions as other subsystems. However, an unresolvable
1:b548bb2: 			// root subsystem should have no effect, so there's no point in
1:b548bb2: 			// actually doing the resolution work.
1:b548bb2: 			if (!subsystem.isRoot()) {
1:a990e32: 				setExportIsolationPolicy(subsystem, coordination);
1:b66ad7c: 				resolveSubsystems(instigator, target, coordination, subsystems);
1:a990e32: 				resolveBundles(subsystem);
1:e7c948c: 			}
1:a990e32: 			emitResolvedEvent(subsystem);
1:e7c948c: 		}
1:777b216: 		catch (Throwable t) {
1:777b216: 			subsystem.setState(State.INSTALLED);
1:a990e32: 			if (t instanceof SubsystemException)
1:a990e32: 				throw (SubsystemException)t;
1:a990e32: 			throw new SubsystemException(t);
1:e7c948c: 		}
1:e7c948c: 	}
1:e7c948c: 
1:afe81b7: 	private static void setExportIsolationPolicy(final BasicSubsystem subsystem, Coordination coordination) throws InvalidSyntaxException {
1:2b13b05: 		if (!subsystem.isComposite())
3:777b216: 			return;
1:a990e32: 		final Region from = ((BasicSubsystem)subsystem.getParents().iterator().next()).getRegion();
1:a990e32: 		final Region to = subsystem.getRegion();
1:777b216: 		RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
1:2b13b05: 		setExportIsolationPolicy(builder, subsystem.getDeploymentManifest().getExportPackageHeader(), subsystem);
1:2b13b05: 		setExportIsolationPolicy(builder, subsystem.getDeploymentManifest().getProvideCapabilityHeader(), subsystem);
1:2b13b05: 		setExportIsolationPolicy(builder, subsystem.getDeploymentManifest().getSubsystemExportServiceHeader(), subsystem);
1:777b216: 		RegionFilter regionFilter = builder.build();
1:2b13b05: 		if (regionFilter.getSharingPolicy().isEmpty())
1:2b13b05: 			return;
2:777b216: 		if (logger.isDebugEnabled())
1:777b216: 			logger.debug("Establishing region connection: from=" + from
1:777b216: 					+ ", to=" + to + ", filter=" + regionFilter);
1:afe81b7: 		try {
1:afe81b7: 			from.connectRegion(to, regionFilter);
1:afe81b7: 		}
1:afe81b7: 		catch (BundleException e) {
1:afe81b7: 			// TODO Assume this means that the export sharing policy has already
1:afe81b7: 			// been set. Bad assumption?
1:afe81b7: 			return;
1:afe81b7: 		}
1:a990e32: 		coordination.addParticipant(new Participant() {
1:a990e32: 			@Override
1:a990e32: 			public void ended(Coordination coordination) throws Exception {
1:afe81b7: 				// It may be necessary to rollback the export sharing policy
1:afe81b7: 				// even when the coordination did not fail. For example, this
1:afe81b7: 				// might have been a subsystem whose export sharing policy was
1:afe81b7: 				// set just in case it offered dependencies for some other
1:afe81b7: 				// subsystem.
1:afe81b7: 				unsetExportIsolationPolicyIfNecessary();
1:a990e32: 			}
1:a990e32: 
1:a990e32: 			@Override
1:a990e32: 			public void failed(Coordination coordination) throws Exception {
1:afe81b7: 				// Nothing to do because a coordination is always ended.
1:afe81b7: 			}
1:afe81b7: 			
1:afe81b7: 			private void unsetExportIsolationPolicyIfNecessary() throws BundleException, InvalidSyntaxException {
1:afe81b7: 				if (!EnumSet.of(State.INSTALLING, State.INSTALLED).contains(subsystem.getState())) {
1:afe81b7: 					// The subsystem is either RESOLVED or ACTIVE and therefore
1:afe81b7: 					// does not require a rollback.
1:afe81b7: 					return;
1:afe81b7: 				}
1:afe81b7: 				// The subsystem is either INSTALLING or INSTALLED and therefore
1:afe81b7: 				// requires a rollback since the export sharing policy must only
1:afe81b7: 				// be set upon entering the RESOLVED state.
1:a990e32: 				RegionUpdater updater = new RegionUpdater(from, to);
1:a990e32: 				updater.addRequirements(null);
1:a990e32: 			}
1:a990e32: 		});
1:a990e32: 	}
1:777b216: 
1:5bd3bf6: 	private static void setExportIsolationPolicy(RegionFilterBuilder builder, ExportPackageHeader header, BasicSubsystem subsystem) throws InvalidSyntaxException {
1:777b216: 		if (header == null)
1:777b216: 			return;
1:777b216: 		String policy = RegionFilter.VISIBLE_PACKAGE_NAMESPACE;
1:777b216: 		for (ExportPackageCapability capability : header.toCapabilities(subsystem)) {
2:777b216: 			StringBuilder filter = new StringBuilder("(&");
2:777b216: 			for (Entry<String, Object> attribute : capability.getAttributes().entrySet())
1:777b216: 				filter.append('(').append(attribute.getKey()).append('=').append(attribute.getValue()).append(')');
2:777b216: 			filter.append(')');
1:777b216: 			if (logger.isDebugEnabled())
2:777b216: 				logger.debug("Allowing " + policy + " of " + filter);
3:777b216: 			builder.allow(policy, filter.toString());
1:a990e32: 		}
1:a990e32: 	}
1:3c826b1: 
1:5bd3bf6: 	private static void setExportIsolationPolicy(RegionFilterBuilder builder, ProvideCapabilityHeader header, BasicSubsystem subsystem) throws InvalidSyntaxException {
1:777b216: 		if (header == null)
1:777b216: 			return;
1:777b216: 		for (ProvideCapabilityHeader.Clause clause : header.getClauses()) {
1:777b216: 			ProvideCapabilityCapability capability = new ProvideCapabilityCapability(clause, subsystem);
1:777b216: 			String policy = capability.getNamespace();
1:645a92b: 			Set<Entry<String, Object>> entrySet = capability.getAttributes().entrySet();
1:645a92b: 			StringBuilder filter = new StringBuilder();
1:645a92b: 			if (entrySet.size() > 1) {
1:645a92b: 				filter.append("(&");
1:645a92b: 			}
1:645a92b: 			for (Entry<String, Object> attribute : capability.getAttributes().entrySet()) {
1:777b216: 				filter.append('(').append(attribute.getKey()).append('=').append(attribute.getValue()).append(')');
1:645a92b: 			}
1:645a92b: 			if (entrySet.size() > 1) {
1:645a92b: 				filter.append(')');
1:645a92b: 			}
1:645a92b: 			if (logger.isDebugEnabled()) {
1:645a92b: 				logger.debug("Allowing policy {} with filter {}", policy, filter);
1:645a92b: 			}
1:645a92b: 			if (filter.length() == 0) {
1:645a92b: 				builder.allowAll(policy);
1:645a92b: 			}
1:645a92b: 			else {
1:645a92b: 				builder.allow(policy, filter.toString());
1:645a92b: 			}
1:a990e32: 		}
1:a990e32: 	}
1:777b216: 
1:5bd3bf6: 	private static void setExportIsolationPolicy(RegionFilterBuilder builder, SubsystemExportServiceHeader header, BasicSubsystem subsystem) throws InvalidSyntaxException {
1:777b216: 		if (header == null)
1:777b216: 			return;
1:777b216: 		String policy = RegionFilter.VISIBLE_SERVICE_NAMESPACE;
1:777b216: 		for (SubsystemExportServiceHeader.Clause clause : header.getClauses()) {
1:777b216: 			SubsystemExportServiceCapability capability = new SubsystemExportServiceCapability(clause, subsystem);
1:777b216: 			String filter = capability.getDirectives().get(SubsystemExportServiceCapability.DIRECTIVE_FILTER);
1:777b216: 			if (logger.isDebugEnabled())
1:777b216: 				logger.debug("Allowing " + policy + " of " + filter);
1:d6eb080: 			builder.allow(policy, filter);
1:a990e32: 		}
1:a990e32: 	}
1:777b216: 
1:777b216: 	private void startBundleResource(Resource resource, Coordination coordination) throws BundleException {
1:f9e608f: 		if (target.isRoot())
1:4556ca7: 			// Starting the root subsystem should not affect bundles within the
1:4556ca7: 			// root region.
1:f9e608f: 			return;
1:5b9ff63: 		if (Utils.isRegionContextBundle(resource))
1:5b9ff63: 			// The region context bundle was persistently started elsewhere.
1:5b9ff63: 			return;
1:777b216: 		final Bundle bundle = ((BundleRevision)resource).getBundle();
1:dc5d52f: 
1:777b216: 		if ((bundle.getState() & (Bundle.STARTING | Bundle.ACTIVE)) != 0)
1:777b216: 			return;
1:dc5d52f: 
1:79b20bc: 		if (logger.isDebugEnabled()) {
1:d89d3d4: 			int bundleStartLevel = bundle.adapt(BundleStartLevel.class).getStartLevel();
1:ab21913: 			Bundle systemBundle=Activator.getInstance().getBundleContext().getBundle(0);
1:d290f20: 			int fwStartLevel = systemBundle.adapt(FrameworkStartLevel.class).getStartLevel();
1:9bcf4ce: 			logger.debug("StartAction: starting bundle " + bundle.getSymbolicName()
1:9bcf4ce: 				+ " " + bundle.getVersion().toString()
1:d89d3d4: 				+ " bundleStartLevel=" + bundleStartLevel
1:d89d3d4: 				+ " frameworkStartLevel=" + fwStartLevel);
1:a990e32: 		}
1:dc5d52f: 
1:777b216: 		bundle.start(Bundle.START_TRANSIENT | Bundle.START_ACTIVATION_POLICY);
1:dc5d52f: 
1:79b20bc: 		if (logger.isDebugEnabled()) {
1:d89d3d4: 			logger.debug("StartAction: bundle " + bundle.getSymbolicName()
1:d89d3d4: 				+ " " + bundle.getVersion().toString()
1:d89d3d4: 				+ " started correctly");
1:a990e32: 		}
2:79b20bc: 
1:3c826b1: 		if (coordination == null)
1:777b216: 			return;
1:777b216: 		coordination.addParticipant(new Participant() {
1:777b216: 			public void ended(Coordination coordination) throws Exception {
1:777b216: 				// noop
1:a990e32: 			}
1:777b216: 
1:777b216: 			public void failed(Coordination coordination) throws Exception {
1:777b216: 				bundle.stop();
1:a990e32: 			}
1:777b216: 		});
1:a990e32: 	}
1:777b216: 
1:777b216: 	private void startResource(Resource resource, Coordination coordination) throws BundleException, IOException {
1:777b216: 		String type = ResourceHelper.getTypeAttribute(resource);
1:777b216: 		if (SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type)
1:777b216: 				|| SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type)
1:79b20bc: 				|| SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(type)) {
1:777b216: 			startSubsystemResource(resource, coordination);
1:79b20bc: 	    } else if (IdentityNamespace.TYPE_BUNDLE.equals(type)) {
1:777b216: 			startBundleResource(resource, coordination);
1:79b20bc: 	    } else if (IdentityNamespace.TYPE_FRAGMENT.equals(type)) {
1:777b216: 			// Fragments are not started.
1:79b20bc: 		} else {
1:79b20bc: 		    if (!startCustomHandler(resource, type, coordination))
1:777b216: 		        throw new SubsystemException("Unsupported resource type: " + type);
1:a990e32: 		}
1:a990e32: 	}
1:777b216: 
1:79b20bc:     private boolean startCustomHandler(Resource resource, String type, Coordination coordination) {
1:79b20bc:         ServiceReference<ContentHandler> customHandlerRef = CustomResources.getCustomContentHandler(target, type);
1:79b20bc:         if (customHandlerRef != null) {
1:79b20bc:             ContentHandler customHandler = target.getBundleContext().getService(customHandlerRef);
1:79b20bc:             if (customHandler != null) {
1:a990e32:                 try {
1:79b20bc:                     customHandler.start(ResourceHelper.getSymbolicNameAttribute(resource), type, target, coordination);
1:79b20bc:                     return true;
1:a990e32:                 } finally {
1:79b20bc:                     target.getBundleContext().ungetService(customHandlerRef);
1:a990e32:                 }
1:a990e32:             }
1:a990e32:         }
1:79b20bc:         return false;
1:a990e32:     }
1:777b216: 
1:b66ad7c: 	private void startSubsystemResource(Resource resource, final Coordination coordination) throws IOException {
1:5bd3bf6: 		final BasicSubsystem subsystem = (BasicSubsystem)resource;
1:b66ad7c: 		if (!isTargetStartable(instigator, target, subsystem)) {
1:b66ad7c: 			 return;
1:b66ad7c: 		}
1:391a1aa: 		// Subsystems that are content resources of another subsystem must have
1:391a1aa: 		// their autostart setting set to started.
1:391a1aa: 		if (Utils.isContent(this.target, subsystem))
1:391a1aa: 			subsystem.setAutostart(true);
1:3c826b1: 		new StartAction(instigator, target, subsystem, coordination).run();
2:777b216: 		if (coordination == null)
1:777b216: 			return;
1:777b216: 		coordination.addParticipant(new Participant() {
1:777b216: 			public void ended(Coordination coordination) throws Exception {
1:777b216: 				// noop
1:a990e32: 			}
1:79b20bc: 
1:777b216: 			public void failed(Coordination coordination) throws Exception {
1:391a1aa: 				new StopAction(target, subsystem, !subsystem.isRoot()).run();
1:a990e32: 			}
1:777b216: 		});
1:a990e32: 	}
1:79b20bc: 	
1:a990e32: 	private static void handleFailedResolution(BasicSubsystem subsystem, Collection<Bundle> bundles, FrameworkWiring wiring) {
1:a990e32: 			logFailedResolution(subsystem, bundles);
1:a990e32: 			throw new SubsystemException("Framework could not resolve the bundles: " + bundles);
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private static void logFailedResolution(BasicSubsystem subsystem, Collection<Bundle> bundles) {
1:a990e32: 		//work out which bundles could not be resolved
1:a990e32: 		Collection<Bundle> unresolved = new ArrayList<Bundle>();
1:a990e32: 		StringBuilder diagnostics = new StringBuilder();
1:a990e32: 		diagnostics.append(String.format("Unable to resolve bundles for subsystem/version/id %s/%s/%s:\n", 
1:a990e32: 				subsystem.getSymbolicName(), subsystem.getVersion(), subsystem.getSubsystemId()));
1:a990e32: 		String fmt = "%d : STATE %s : %s : %s : %s";
1:a990e32: 		for(Bundle bundle:bundles){
1:a990e32: 			if((bundle.getState() & Bundle.RESOLVED) != Bundle.RESOLVED) {
1:a990e32: 				unresolved.add(bundle);
1:a990e32: 			}
1:a990e32: 			String state = null;
1:a990e32: 			switch(bundle.getState()) {
1:a990e32: 				case Bundle.ACTIVE :
1:a990e32: 					state = "ACTIVE";
1:a990e32: 					break;
1:a990e32: 				case Bundle.INSTALLED :
1:a990e32: 					state = "INSTALLED";
1:a990e32: 					break;
1:a990e32: 				case Bundle.RESOLVED :
1:a990e32: 					state = "RESOLVED";
1:a990e32: 					break;
1:a990e32: 				case Bundle.STARTING :
1:a990e32: 					state = "STARTING";
1:a990e32: 					break;
1:a990e32: 				case Bundle.STOPPING :
1:a990e32: 					state = "STOPPING";
1:a990e32: 					break;
1:a990e32: 				case Bundle.UNINSTALLED :
1:a990e32: 					state = "UNINSTALLED";
1:a990e32: 					break;
1:a990e32: 				default :
1:a990e32: 					//convert common states to text otherwise default to just showing the ID
1:a990e32: 					state = "[" + Integer.toString(bundle.getState()) + "]";
1:a990e32: 					break;
1:a990e32: 			}
1:a990e32: 			diagnostics.append(String.format(fmt, bundle.getBundleId(), state, 
1:a990e32: 					bundle.getSymbolicName(), bundle.getVersion().toString(), 
1:a990e32: 					bundle.getLocation()));
1:a990e32: 			diagnostics.append("\n");
1:a990e32: 		}
1:a990e32: 		logger.error(diagnostics.toString());
1:a990e32: 	}
1:afe81b7: 	
1:b66ad7c: 	static void setExportPolicyOfAllInstallingSubsystemsWithProvisionDependenciesResolve(Coordination coordination) throws InvalidSyntaxException {
1:afe81b7: 		for (BasicSubsystem subsystem : Activator.getInstance().getSubsystems().getSubsystems()) {
1:afe81b7: 			if (!State.INSTALLING.equals(subsystem.getState())
1:afe81b7: 					|| Utils.isProvisionDependenciesInstall(subsystem)) {
1:afe81b7: 				continue;
1:afe81b7: 			}
1:afe81b7: 			setExportIsolationPolicy(subsystem, coordination);
1:afe81b7: 		}
1:afe81b7: 	}
1:a457340: }
============================================================================
author:Tom Watson
-------------------------------------------------------------------------------
commit:279dba5
/////////////////////////////////////////////////////////////////////////
1: 		if (!Activator.getInstance().getLockingStrategy().set(State.STARTING, target)) {
/////////////////////////////////////////////////////////////////////////
1: 				Activator.getInstance().getLockingStrategy().writeLock();
/////////////////////////////////////////////////////////////////////////
1: 						Activator.getInstance().getLockingStrategy().readLock();
/////////////////////////////////////////////////////////////////////////
1: 					Activator.getInstance().getLockingStrategy().writeUnlock();
1: 	    		Activator.getInstance().getLockingStrategy().readLock();
/////////////////////////////////////////////////////////////////////////
1: 				Activator.getInstance().getLockingStrategy().lock();
1: 					Activator.getInstance().getLockingStrategy().lock(affectedResources.subsystems());
1: 					Activator.getInstance().getLockingStrategy().unlock();
/////////////////////////////////////////////////////////////////////////
1: 						Activator.getInstance().getLockingStrategy().unlock(affectedResources.subsystems());
1: 				Activator.getInstance().getLockingStrategy().readUnlock();
/////////////////////////////////////////////////////////////////////////
1: 			Activator.getInstance().getLockingStrategy().unset(State.STARTING, target);
commit:e7c948c
/////////////////////////////////////////////////////////////////////////
1: 			// Always start if target is a dependency of requestor.
/////////////////////////////////////////////////////////////////////////
0: 				//resolve dependencies to ensure framework resolution succeeds
0: 				for (Resource dep : Activator.getInstance().getSubsystems().getResourcesReferencedBy(subsystem)) {
0: 					if (dep instanceof BasicSubsystem &&
0: 						!Activator.getInstance().getSubsystems().getChildren(subsystem).contains(dep)) {
0: 						if (State.INSTALLED == (((BasicSubsystem) dep).getState())) {
0: 						    resolve((BasicSubsystem) dep);
1: 						}
1: 					}
1: 				}
1: 				
0: 				for (Subsystem child : Activator.getInstance().getSubsystems().getChildren(subsystem)) {
1: 				}
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
0: 	private final boolean resolveOnly;
0: 		this(instigator, requestor, target, false);
0: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target, boolean resolveOnly) {
0: 		this(instigator, requestor, target, null, resolveOnly);
1: 	}
1: 	
0: 		this(instigator, requestor, target, coordination, false);
1: 	}
1: 	
0: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target, Coordination coordination, boolean resolveOnly) {
0: 		this.resolveOnly = resolveOnly;
/////////////////////////////////////////////////////////////////////////
0: 			if (resolveOnly)
1: 				return null;
/////////////////////////////////////////////////////////////////////////
1: 			builder.allow(policy, filter);
author:John Ross
-------------------------------------------------------------------------------
commit:1fca6d0
/////////////////////////////////////////////////////////////////////////
1: 	private static class AffectedResources {
1: 		private final List<Resource> resources;
1: 		private final Collection<BasicSubsystem> subsystemResources;
1: 		
1: 		AffectedResources(BasicSubsystem target) {
1: 			LinkedHashSet<Resource> resources = new LinkedHashSet<Resource>();
1: 			LinkedHashSet<BasicSubsystem> subsystemResources = new LinkedHashSet<BasicSubsystem>();
1: 			Subsystems subsystems = Activator.getInstance().getSubsystems();
1: 			for (Resource dep : subsystems.getResourcesReferencedBy(target)) {
1: 				if (dep instanceof BasicSubsystem 
1: 						&& !subsystems.getChildren(target).contains(dep)) {
1: 					subsystemResources.add((BasicSubsystem)dep);
1: 				}
1: 				else if (dep instanceof BundleRevision) {
1: 					BundleConstituent constituent = new BundleConstituent(null, (BundleRevision)dep);
1: 					if (!target.getConstituents().contains(constituent)) {
1: 						for (BasicSubsystem constituentOf : subsystems.getSubsystemsByConstituent(
1: 								new BundleConstituent(null, (BundleRevision)dep))) {
1: 							subsystemResources.add(constituentOf);
1: 						}
1: 				resources.add(dep);
1: 			for (Subsystem child : subsystems.getChildren(target)) {
1: 				subsystemResources.add((BasicSubsystem)child);
1: 				resources.add((BasicSubsystem)child);
1: 			for (Resource resource : target.getResource().getSharedContent()) {
1: 				for (BasicSubsystem constituentOf : subsystems.getSubsystemsByConstituent(
1: 						resource instanceof BundleRevision ? new BundleConstituent(null, (BundleRevision)resource) : resource)) {
1: 					subsystemResources.add(constituentOf);
1: 				}
1: 				resources.add(resource);
1: 			}
1: 			subsystemResources.add(target);
1: 			this.resources = new ArrayList<Resource>(resources);
1: 			this.subsystemResources = subsystemResources;
1: 		
1: 		List<Resource> resources() {
1: 			return resources;
1: 		}
1: 		
1: 		Collection<BasicSubsystem> subsystems() {
1: 			return subsystemResources;
1: 		}
1: 	}
1: 	
1: 	private static AffectedResources computeAffectedResources(BasicSubsystem target) {
1: 		return new AffectedResources(target);
/////////////////////////////////////////////////////////////////////////
1: 			AffectedResources affectedResources;
/////////////////////////////////////////////////////////////////////////
1: 		    			affectedResources = computeAffectedResources(target);
1: 						for (BasicSubsystem subsystem : affectedResources.subsystems()) {
/////////////////////////////////////////////////////////////////////////
1: 	    		affectedResources = computeAffectedResources(target);
0: 					LockingStrategy.lock(affectedResources.subsystems());
/////////////////////////////////////////////////////////////////////////
1: 						resolve(instigator, target, target, coordination, affectedResources.subsystems());
/////////////////////////////////////////////////////////////////////////
1: 						Collections.sort(affectedResources.resources(), new StartResourceComparator(header));
1: 					for (Resource resource : affectedResources.resources())
/////////////////////////////////////////////////////////////////////////
0: 						LockingStrategy.unlock(affectedResources.subsystems());
commit:b66ad7c
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedHashSet;
/////////////////////////////////////////////////////////////////////////
1: 	public static enum Restriction {
1: 		NONE,
1: 		INSTALL_ONLY,
1: 		RESOLVE_ONLY
1: 	}
1: 	private static final Logger logger = LoggerFactory.getLogger(StartAction.class);
1: 	private final Restriction restriction;
1: 		this(instigator, requestor, target, Restriction.NONE);
1: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target, Restriction restriction) {
1: 		this(instigator, requestor, target, null, restriction);
1: 		this(instigator, requestor, target, coordination, Restriction.NONE);
1: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target, Coordination coordination, Restriction restriction) {
1: 		this.restriction = restriction;
1: 	private static boolean isTargetStartable(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target) {
1: 		State state = target.getState();
1: 	    // The following states are illegal.
1: 	    if (EnumSet.of(State.INSTALL_FAILED, State.UNINSTALLED).contains(state))
1: 	        throw new SubsystemException("Cannot start from state " + state);
1: 	    // The following states mean the requested state has already been attained.
1: 	    if (State.ACTIVE.equals(state))
1: 	        return false;
1: 		// Always start if target is content of requestor.
1: 	    if (!Utils.isContent(requestor, target)) {
0: 	        // Always start if target is a dependency of requestor.
1: 	        if (!Utils.isDependency(requestor, target)) {
1: 	            // Always start if instigator equals target (explicit start).
1: 	            if (!instigator.equals(target)) {
1: 	                // Don't start if instigator is root (restart) and target is not ready.
1: 	                if (instigator.isRoot() && !target.isReadyToStart()) {
1: 	                    return false;
1: 	                }
1: 	            }
1: 	        }
1: 	    }
1: 	    return true;
1: 	}
1: 	
1: 	private void installDependencies(BasicSubsystem target, Coordination coordination) throws Exception {
1: 		for (Subsystem parent : target.getParents()) {
1: 			AccessController.doPrivileged(new StartAction(instigator, target, (BasicSubsystem)parent, coordination, Restriction.INSTALL_ONLY));
1: 		installDependencies(Collections.<Subsystem>singletonList(target), coordination);
1: 		for (Subsystem child : Activator.getInstance().getSubsystems().getChildren(target)) {
1: 			AccessController.doPrivileged(new StartAction(instigator, target, (BasicSubsystem)child, coordination, Restriction.INSTALL_ONLY));
1: 		}
1: 	}
1: 	
1: 	private static void installDependencies(Collection<Subsystem> subsystems, Coordination coordination) throws Exception {
1: 		for (Subsystem subsystem : subsystems) {
1: 			if (State.INSTALLING.equals(subsystem.getState())) {
1: 				BasicSubsystem bs = (BasicSubsystem)subsystem;
1: 				bs.computeDependenciesPostInstallation(coordination);
1: 				new InstallDependencies().install(bs, null, coordination);
1: 				bs.setState(State.INSTALLED);
1: 			}
1: 		}
1: 	}
1: 	
1: 	private Coordination createCoordination() {
1: 		Coordination coordination = this.coordination;
1: 	    if (coordination == null) {
1: 	        coordination = Utils.createCoordination(target);
1: 	    }
1: 	    return coordination;
1: 	}
1: 	
0: 	private static LinkedHashSet<BasicSubsystem> computeAffectedSubsystems(BasicSubsystem target) {
0: 		LinkedHashSet<BasicSubsystem> result = new LinkedHashSet<BasicSubsystem>();
0: 		Subsystems subsystems = Activator.getInstance().getSubsystems();
0: 		for (Resource dep : subsystems.getResourcesReferencedBy(target)) {
0: 			if (dep instanceof BasicSubsystem 
0: 					&& !subsystems.getChildren(target).contains(dep)) {
0: 				result.add((BasicSubsystem)dep);
1: 			}
0: 			else if (dep instanceof BundleRevision) {
0: 				BundleConstituent constituent = new BundleConstituent(null, (BundleRevision)dep);
0: 				if (!target.getConstituents().contains(constituent)) {
0: 					for (BasicSubsystem constituentOf : subsystems.getSubsystemsByConstituent(
0: 							new BundleConstituent(null, (BundleRevision)dep))) {
0: 						result.add(constituentOf);
1: 					}
1: 				}
1: 			}
1: 		}
0: 		for (Subsystem child : subsystems.getChildren(target)) {
0: 			result.add((BasicSubsystem)child);
1: 		}
0: 		for (Resource resource : target.getResource().getSharedContent()) {
0: 			for (BasicSubsystem constituentOf : subsystems.getSubsystemsByConstituent(
0: 					resource instanceof BundleRevision ? new BundleConstituent(null, (BundleRevision)resource) : resource)) {
0: 				result.add(constituentOf);
1: 			}
1: 		}
0: 		result.add(target);
1: 		return result;
1: 		// Protect against re-entry now that cycles are supported.
0: 		if (!LockingStrategy.set(State.STARTING, target)) {
1: 		try {
0: 			Collection<BasicSubsystem> subsystems;
1: 			// We are now protected against re-entry.
1: 			// If necessary, install the dependencies.
1: 	    	if (State.INSTALLING.equals(target.getState()) && !Utils.isProvisionDependenciesInstall(target)) {
1: 	    		// Acquire the global write lock while installing dependencies.
0: 				LockingStrategy.writeLock();
1: 				try {
1: 					// We are now protected against installs, starts, stops, and uninstalls.
1: 		    		// We need a separate coordination when installing 
1: 					// dependencies because cleaning up the temporary export 
1: 					// sharing policies must be done while holding the write lock.
1: 		    		Coordination c = Utils.createCoordination(target);
1: 		    		try {
1: 		    			installDependencies(target, c);
1: 		    			// Associated subsystems must be computed after all dependencies 
1: 						// are installed because some of the dependencies may be 
1: 						// subsystems. This is safe to do while only holding the read
1: 						// lock since we know that nothing can be added or removed.
0: 						subsystems = computeAffectedSubsystems(target);
1: 						for (BasicSubsystem subsystem : subsystems) {
1: 							if (State.INSTALLING.equals(subsystem.getState())
1: 									&& !Utils.isProvisionDependenciesInstall(subsystem)) {
1: 								installDependencies(subsystem, c);
1: 							}
1: 						}
1: 						// Downgrade to the read lock in order to prevent 
1: 		    			// installs and uninstalls but allow starts and stops.
0: 						LockingStrategy.readLock();
1: 		    		}
1: 		    		catch (Throwable t) {
1: 		    			c.fail(t);
1: 		    		}
1: 		    		finally {
1: 		    			// This will clean up the temporary export sharing
1: 		    			// policies. Must be done while holding the write lock.
1: 		    			c.end();
1: 		    		}
1: 				}
1: 				finally {
1: 					// Release the global write lock as soon as possible.
0: 					LockingStrategy.writeUnlock();
1: 				}
1: 	    	}
1: 	    	else {
1: 	    		// Acquire the read lock in order to prevent installs and
1: 	    		// uninstalls but allow starts and stops.
0: 	    		LockingStrategy.readLock();
1: 	    	}
1: 	    	try {
1: 	    		// We now hold the read lock and are protected against installs
1: 	    		// and uninstalls.
1: 	    		if (Restriction.INSTALL_ONLY.equals(restriction)) {
1: 					return null;
1: 				}
1: 	    		// Compute associated subsystems here in case (1) they weren't
1: 	    		// computed previously while holding the write lock or (2) they
1: 	    		// were computed previously and more were subsequently added. 
1: 				// This is safe to do while only holding the read lock since we
1: 				// know that nothing can be added or removed.
0: 				subsystems = computeAffectedSubsystems(target);
1: 				// Acquire the global mutual exclusion lock while acquiring the
1: 				// state change locks of affected subsystems.
0: 				LockingStrategy.lock();
1: 				try {
1: 					// We are now protected against cycles.
1: 					// Acquire the state change locks of affected subsystems.
0: 					LockingStrategy.lock(subsystems);
1: 				}
1: 				finally {
1: 					// Release the global mutual exclusion lock as soon as possible.
0: 					LockingStrategy.unlock();
1: 				}
1: 				Coordination coordination = this.coordination;
1: 				try {
1: 					coordination = createCoordination();
1: 					// We are now protected against other starts and stops of the affected subsystems.
1: 					if (!isTargetStartable(instigator, requestor, target)) {
1: 						return null;
1: 					}
1: 					
1: 					// Resolve if necessary.
1: 					if (State.INSTALLED.equals(target.getState()))
0: 						resolve(instigator, target, target, coordination, subsystems);
1: 					if (Restriction.RESOLVE_ONLY.equals(restriction))
1: 						return null;
1: 					target.setState(State.STARTING);
1: 					// Be sure to set the state back to RESOLVED if starting fails.
1: 					coordination.addParticipant(new Participant() {
1: 						@Override
1: 						public void ended(Coordination coordination) throws Exception {
1: 							// Nothing.
1: 						}
1: 
1: 						@Override
1: 						public void failed(Coordination coordination) throws Exception {
1: 							target.setState(State.RESOLVED);
1: 						}
1: 					});
1: 					for (BasicSubsystem subsystem : subsystems) {
0: 						if (!target.equals(subsystem)) {
0: 							startSubsystemResource(subsystem, coordination);
1: 						}
1: 					}
0: 					List<Resource> resources = new ArrayList<Resource>(Activator.getInstance().getSubsystems().getResourcesReferencedBy(target));
1: 					SubsystemContentHeader header = target.getSubsystemManifest().getSubsystemContentHeader();
1: 					if (header != null)
0: 						Collections.sort(resources, new StartResourceComparator(header));
0: 					for (Resource resource : resources)
1: 						startResource(resource, coordination);
1: 					target.setState(State.ACTIVE);
1: 					
1: 				}
1: 				catch (Throwable t) {
1: 					// We catch exceptions and fail the coordination here to
1: 					// ensure we are still holding the state change locks when
1: 					// the participant sets the state to RESOLVED.
1: 					coordination.fail(t);
1: 				}
1: 				finally {
1: 					try {
1: 						// Don't end a coordination that was not begun as part
1: 						// of this start action.
1: 						if (coordination.getName().equals(Utils.computeCoordinationName(target))) {
1: 							coordination.end();
1: 						}
1: 					}
1: 					finally {
1: 						// Release the state change locks of affected subsystems.
0: 						LockingStrategy.unlock(subsystems);
1: 					}
1: 				}
1: 	    	}
1: 	    	finally {
1: 				// Release the read lock.
0: 				LockingStrategy.readUnlock();
1: 			}
1: 		}
1: 		catch (CoordinationException e) {
1: 			Throwable t = e.getCause();
1: 			if (t == null) {
1: 				throw new SubsystemException(e);
1: 			}
1: 			if (t instanceof SecurityException) {
1: 				throw (SecurityException)t;
1: 			}
1: 			if (t instanceof SubsystemException) {
1: 				throw (SubsystemException)t;
1: 			}
1: 			throw new SubsystemException(t);
1: 		}
1: 		finally {
1: 			// Protection against re-entry no longer required.
0: 			LockingStrategy.unset(State.STARTING, target);
1: 		}
1: 		return null;
/////////////////////////////////////////////////////////////////////////
1: 	private static void resolveSubsystems(BasicSubsystem instigator, BasicSubsystem target, Coordination coordination, Collection<BasicSubsystem> subsystems) throws Exception {
0: 		for (BasicSubsystem subsystem : subsystems) {
1: 			resolveSubsystem(instigator, target, subsystem, coordination);
1: 	private static void resolveSubsystem(BasicSubsystem instigator, BasicSubsystem target, BasicSubsystem subsystem, Coordination coordination) throws Exception {
1: 			if (target.equals(subsystem)) {
1: 				resolve(instigator, target, subsystem, coordination, Collections.<BasicSubsystem>emptyList());
1: 			}
1: 			else {
1: 				AccessController.doPrivileged(new StartAction(instigator, target, subsystem, coordination, Restriction.RESOLVE_ONLY));
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 	private static void resolve(BasicSubsystem instigator, BasicSubsystem target, BasicSubsystem subsystem, Coordination coordination, Collection<BasicSubsystem> subsystems) {
/////////////////////////////////////////////////////////////////////////
1: 				resolveSubsystems(instigator, target, coordination, subsystems);
/////////////////////////////////////////////////////////////////////////
1: 	private void startSubsystemResource(Resource resource, final Coordination coordination) throws IOException {
1: 		if (!isTargetStartable(instigator, target, subsystem)) {
1: 			 return;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 	static void setExportPolicyOfAllInstallingSubsystemsWithProvisionDependenciesResolve(Coordination coordination) throws InvalidSyntaxException {
commit:afe81b7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		    		// The following line is necessary in order to ensure that
0: 		    		// the export sharing policies of composites are in place
0: 		    		// for capability validation.
0: 		    		setExportPolicyOfAllInstallingSubsystemsWithProvisionDependenciesResolve(coordination);
/////////////////////////////////////////////////////////////////////////
1: 	private static void setExportIsolationPolicy(final BasicSubsystem subsystem, Coordination coordination) throws InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 		try {
1: 			from.connectRegion(to, regionFilter);
1: 		}
1: 		catch (BundleException e) {
1: 			// TODO Assume this means that the export sharing policy has already
1: 			// been set. Bad assumption?
1: 			return;
1: 		}
1: 				// It may be necessary to rollback the export sharing policy
1: 				// even when the coordination did not fail. For example, this
1: 				// might have been a subsystem whose export sharing policy was
1: 				// set just in case it offered dependencies for some other
1: 				// subsystem.
1: 				unsetExportIsolationPolicyIfNecessary();
1: 				// Nothing to do because a coordination is always ended.
1: 			}
1: 			
1: 			private void unsetExportIsolationPolicyIfNecessary() throws BundleException, InvalidSyntaxException {
1: 				if (!EnumSet.of(State.INSTALLING, State.INSTALLED).contains(subsystem.getState())) {
1: 					// The subsystem is either RESOLVED or ACTIVE and therefore
1: 					// does not require a rollback.
1: 					return;
1: 				}
1: 				// The subsystem is either INSTALLING or INSTALLED and therefore
1: 				// requires a rollback since the export sharing policy must only
1: 				// be set upon entering the RESOLVED state.
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private static void setExportPolicyOfAllInstallingSubsystemsWithProvisionDependenciesResolve(Coordination coordination) throws InvalidSyntaxException {
1: 		for (BasicSubsystem subsystem : Activator.getInstance().getSubsystems().getSubsystems()) {
1: 			if (!State.INSTALLING.equals(subsystem.getState())
1: 					|| Utils.isProvisionDependenciesInstall(subsystem)) {
1: 				continue;
1: 			}
1: 			setExportIsolationPolicy(subsystem, coordination);
1: 		}
1: 	}
commit:645a92b
/////////////////////////////////////////////////////////////////////////
1: 			Set<Entry<String, Object>> entrySet = capability.getAttributes().entrySet();
1: 			StringBuilder filter = new StringBuilder();
1: 			if (entrySet.size() > 1) {
1: 				filter.append("(&");
1: 			}
1: 			for (Entry<String, Object> attribute : capability.getAttributes().entrySet()) {
1: 			}
1: 			if (entrySet.size() > 1) {
1: 				filter.append(')');
1: 			}
1: 			if (logger.isDebugEnabled()) {
1: 				logger.debug("Allowing policy {} with filter {}", policy, filter);
1: 			}
1: 			if (filter.length() == 0) {
1: 				builder.allowAll(policy);
1: 			}
1: 			else {
1: 				builder.allow(policy, filter.toString());
1: 			}
commit:a990e32
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
0: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.internal.BundleResourceInstaller.BundleConstituent;
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private static final ThreadLocal<Set<Subsystem>> subsystemsStartingOnCurrentThread = new ThreadLocal<Set<Subsystem>>() {
1: 		@Override
0: 		protected Set<Subsystem> initialValue() {
0: 			return new HashSet<Subsystem>();
1: 		}
0: 	};
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private Object doRun() {
0: 		// TODO We now support circular dependencies so a sane locking strategy
0: 		// is required now more than ever before. Needs to be much more granular
0: 		// (and complex) than this. Perhaps something along the lines of a state
0: 		// change lock per subsystem then use a global lock only while acquiring
0: 		// the necessary state change locks.
0: 		synchronized (StartAction.class) {
0: 			State state = target.getState();
0: 		    // The following states are illegal.
0: 		    if (EnumSet.of(State.INSTALL_FAILED, State.UNINSTALLED, State.UNINSTALLING).contains(state))
0: 		        throw new SubsystemException("Cannot start from state " + state);
0: 		    // The following states must wait with the exception of INSTALLING
0: 		    // combined with apache-aries-provision-dependencies:=resolve.
0: 		    if ((State.INSTALLING.equals(state) 
0: 		    		&& Utils.isProvisionDependenciesInstall(target))
0: 		    	            || EnumSet.of(State.RESOLVING, State.STARTING, State.STOPPING).contains(state)) {
0: 		        waitForStateChange(state);
0: 		        return new StartAction(instigator, requestor, target, coordination).run();
1: 		    }
0: 		    // The following states mean the requested state has already been attained.
0: 		    if (State.ACTIVE.equals(state))
0: 		        return null;
0: 		    // Always start if target is content of requestor.
0: 		    if (!Utils.isContent(requestor, target)) {
0: 		        // Always start if target is a dependency of requestor.
0: 		        if (!Utils.isDependency(requestor, target)) {
0: 		            // Always start if instigator equals target (explicit start).
0: 		            if (!instigator.equals(target)) {
0: 		                // Don't start if instigator is root (restart) and target is not ready.
0: 		                if (instigator.isRoot() && !target.isReadyToStart()) {
0: 		                    return null;
1: 		                }
1: 		            }
1: 		        }
1: 		    }
0: 		    Coordination coordination = this.coordination;
0: 		    if (coordination == null) {
0: 		        coordination = Utils.createCoordination(target);
1: 		    }
1: 		    try {
0: 		    	// If necessary, install the dependencies.
0: 		    	if (State.INSTALLING.equals(target.getState()) && 
0: 		    			!Utils.isProvisionDependenciesInstall(target)) {
0: 		    		Collection<Subsystem> subsystems = new ArrayList<Subsystem>();
0: 		    		subsystems.addAll(Activator.getInstance().getSubsystems().getChildren(target));
0: 		    		subsystems.addAll(target.getParents());
0: 		    		for (Subsystem subsystem : subsystems) {
0: 		    			if (State.INSTALLING.equals(subsystem.getState())) {
0: 		    				BasicSubsystem bs = (BasicSubsystem)subsystem;
0: 		    				bs.computeDependenciesPostInstallation();
0: 		    	            new InstallDependencies().install(bs, null, coordination);
0: 		    	            bs.setState(State.INSTALLED);
1: 		    			}
1: 		    		}
0: 		    		target.computeDependenciesPostInstallation();
0: 		            new InstallDependencies().install(target, null, coordination);
0: 		            target.setState(State.INSTALLED);
1: 		    	}
0: 		        // Resolve if necessary.
0: 		        if (State.INSTALLED.equals(target.getState()))
0: 		            resolve(target, coordination);
0: 		        if (resolveOnly)
0: 		            return null;
0: 		        target.setState(State.STARTING);
0: 		        // TODO Need to hold a lock here to guarantee that another start
0: 		        // operation can't occur when the state goes to RESOLVED.
0: 		        // Start the subsystem.
0: 		        List<Resource> resources = new ArrayList<Resource>(Activator.getInstance().getSubsystems().getResourcesReferencedBy(target));
0: 		        SubsystemContentHeader header = target.getSubsystemManifest().getSubsystemContentHeader();
0: 		        if (header != null)
0: 		            Collections.sort(resources, new StartResourceComparator(header));
0: 		        for (Resource resource : resources)
0: 		            startResource(resource, coordination);
0: 		        target.setState(State.ACTIVE);
0: 		    } catch (Throwable t) {
0: 		        coordination.fail(t);
0: 		        // TODO Need to reinstate complete isolation by disconnecting the
0: 		        // region and transition to INSTALLED.
1: 		    } finally {
1: 		        try {
0: 		            // Don't end the coordination if the subsystem being started
0: 		            // (i.e. the target) did not begin it.
0: 		            if (coordination.getName().equals(Utils.computeCoordinationName(target)))
0: 		                coordination.end();
0: 		        } catch (CoordinationException e) {
0: 		        	// If the target's state is INSTALLING then installing the
0: 		        	// dependencies failed, in which case we want to leave it as is.
0: 		        	if (!State.INSTALLING.equals(target.getState())) {
0: 		        		target.setState(State.RESOLVED);
1: 		        	}
0: 		            Throwable t = e.getCause();
1: 		            if (t instanceof SubsystemException)
1: 		                throw (SubsystemException)t;
1: 		            throw new SubsystemException(t);
1: 		        }
1: 		    }
0: 		    return null;
1: 		}
1: 	}
0: 		Set<Subsystem> subsystems = subsystemsStartingOnCurrentThread.get();
0: 		if (subsystems.contains(target)) {
0: 		subsystems.add(target);
1: 	    try {
0: 	    	return doRun();
1: 	    }
0: 	    finally {
0: 	    	subsystems.remove(target);
1: 	    }
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	private static void emitResolvingEvent(BasicSubsystem subsystem) {
1: 	}
1: 	
1: 	private static void emitResolvedEvent(BasicSubsystem subsystem) {
1: 		// No need to propagate a RESOLVED event if this is a persisted
1: 		// subsystem already in the RESOLVED state.
1: 		if (State.RESOLVING.equals(subsystem.getState()))
1: 			subsystem.setState(State.RESOLVED);
1: 	}
1: 	
0: 	private static void resolveSubsystems(BasicSubsystem subsystem, Coordination coordination) {
0: 		//resolve dependencies to ensure framework resolution succeeds
0: 		Subsystems subsystems = Activator.getInstance().getSubsystems();
0: 		for (Resource dep : subsystems.getResourcesReferencedBy(subsystem)) {
0: 			if (dep instanceof BasicSubsystem 
0: 					&& !subsystems.getChildren(subsystem).contains(dep)) {
0: 				resolveSubsystem((BasicSubsystem)dep, coordination);
1: 			}
0: 			else if (dep instanceof BundleRevision
0: 					&& !subsystem.getConstituents().contains(dep)) {
0: 				for (BasicSubsystem constituentOf : subsystems.getSubsystemsByConstituent(
0: 						new BundleConstituent(null, (BundleRevision)dep))) {
0: 					resolveSubsystem(constituentOf, coordination);
1: 				}
1: 			}
1: 		}
0: 		for (Subsystem child : subsystems.getChildren(subsystem)) {
0: 			resolveSubsystem((BasicSubsystem)child, coordination);
1: 		}
0: 		for (Resource resource : subsystem.getResource().getSharedContent()) {
0: 			for (BasicSubsystem constituentOf : subsystems.getSubsystemsByConstituent(
0: 					resource instanceof BundleRevision ? new BundleConstituent(null, (BundleRevision)resource) : resource)) {
0: 				resolveSubsystem(constituentOf, coordination);
1: 			}
1: 		}
1: 	}
1: 	
0: 	private static void resolveSubsystem(BasicSubsystem subsystem, Coordination coordination) {
1: 		State state = subsystem.getState();
1: 		if (State.INSTALLED.equals(state)) {
0: 			AccessController.doPrivileged(new StartAction(subsystem, subsystem, subsystem, coordination, true));
1: 		}
0: 		else if (State.INSTALLING.equals(state)
0: 				&& !Utils.isProvisionDependenciesInstall(subsystem)) {
0: 			AccessController.doPrivileged(new StartAction(subsystem, subsystem, subsystem, coordination, true));
1: 		}
1: 	}
1: 	
1: 	private static void resolveBundles(BasicSubsystem subsystem) {
1: 		FrameworkWiring frameworkWiring = Activator.getInstance().getBundleContext().getBundle(0)
1: 				.adapt(FrameworkWiring.class);
1: 		// TODO I think this is insufficient. Do we need both
1: 		// pre-install and post-install environments for the Resolver?
1: 		Collection<Bundle> bundles = getBundles(subsystem);
1: 		if (!frameworkWiring.resolveBundles(bundles)) {
1: 			handleFailedResolution(subsystem, bundles, frameworkWiring);
1: 		}
1: 	}
1: 
0: 	private static void resolve(BasicSubsystem subsystem, Coordination coordination) {
1: 		emitResolvingEvent(subsystem);
1: 				setExportIsolationPolicy(subsystem, coordination);
0: 				resolveSubsystems(subsystem, coordination);
1: 				resolveBundles(subsystem);
1: 			emitResolvedEvent(subsystem);
/////////////////////////////////////////////////////////////////////////
0: 	private static void setExportIsolationPolicy(BasicSubsystem subsystem, Coordination coordination) throws InvalidSyntaxException, IOException, BundleException, URISyntaxException, ResolutionException {
1: 		final Region from = ((BasicSubsystem)subsystem.getParents().iterator().next()).getRegion();
1: 		final Region to = subsystem.getRegion();
/////////////////////////////////////////////////////////////////////////
1: 		coordination.addParticipant(new Participant() {
1: 			@Override
1: 			public void ended(Coordination coordination) throws Exception {
0: 				// Nothing.
1: 			}
1: 
1: 			@Override
1: 			public void failed(Coordination coordination) throws Exception {
1: 				RegionUpdater updater = new RegionUpdater(from, to);
1: 				updater.addRequirements(null);
1: 			}
1: 		});
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	private static void handleFailedResolution(BasicSubsystem subsystem, Collection<Bundle> bundles, FrameworkWiring wiring) {
1: 			logFailedResolution(subsystem, bundles);
1: 			throw new SubsystemException("Framework could not resolve the bundles: " + bundles);
1: 	}
1: 	
1: 	private static void logFailedResolution(BasicSubsystem subsystem, Collection<Bundle> bundles) {
1: 		//work out which bundles could not be resolved
1: 		Collection<Bundle> unresolved = new ArrayList<Bundle>();
1: 		StringBuilder diagnostics = new StringBuilder();
1: 		diagnostics.append(String.format("Unable to resolve bundles for subsystem/version/id %s/%s/%s:\n", 
1: 				subsystem.getSymbolicName(), subsystem.getVersion(), subsystem.getSubsystemId()));
1: 		String fmt = "%d : STATE %s : %s : %s : %s";
1: 		for(Bundle bundle:bundles){
1: 			if((bundle.getState() & Bundle.RESOLVED) != Bundle.RESOLVED) {
1: 				unresolved.add(bundle);
1: 			}
1: 			String state = null;
1: 			switch(bundle.getState()) {
1: 				case Bundle.ACTIVE :
1: 					state = "ACTIVE";
1: 					break;
1: 				case Bundle.INSTALLED :
1: 					state = "INSTALLED";
1: 					break;
1: 				case Bundle.RESOLVED :
1: 					state = "RESOLVED";
1: 					break;
1: 				case Bundle.STARTING :
1: 					state = "STARTING";
1: 					break;
1: 				case Bundle.STOPPING :
1: 					state = "STOPPING";
1: 					break;
1: 				case Bundle.UNINSTALLED :
1: 					state = "UNINSTALLED";
1: 					break;
1: 				default :
1: 					//convert common states to text otherwise default to just showing the ID
1: 					state = "[" + Integer.toString(bundle.getState()) + "]";
1: 					break;
1: 			}
1: 			diagnostics.append(String.format(fmt, bundle.getBundleId(), state, 
1: 					bundle.getSymbolicName(), bundle.getVersion().toString(), 
1: 					bundle.getLocation()));
1: 			diagnostics.append("\n");
1: 		}
1: 		logger.error(diagnostics.toString());
1: 	}
commit:a457340
/////////////////////////////////////////////////////////////////////////
0: 					if (State.INSTALLED.equals(child.getState())) {
0: 						resolve((BasicSubsystem)child);
1: 					}
commit:3c826b1
/////////////////////////////////////////////////////////////////////////
1: 	private final Coordination coordination;
0: 		this(instigator, requestor, target, null);
0: 	}
1: 	
1: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target, Coordination coordination) {
1: 		this.coordination = coordination;
/////////////////////////////////////////////////////////////////////////
0: 			return new StartAction(instigator, requestor, target, coordination).run();
/////////////////////////////////////////////////////////////////////////
0: 		Coordination coordination = this.coordination;
1: 		if (coordination == null)
0: 			coordination = Utils.createCoordination(target);
0: 			// Resolve if necessary.
0: 			if (State.INSTALLED.equals(state))
0: 				resolve(target);
0: 			target.setState(State.STARTING);
0: 			// TODO Need to hold a lock here to guarantee that another start
0: 			// operation can't occur when the state goes to RESOLVED.
0: 			// Start the subsystem.
/////////////////////////////////////////////////////////////////////////
0: 				// Don't end the coordination if the subsystem being started 
0: 				// (i.e. the target) did not begin it.
0: 				if (coordination.getName().equals(Utils.computeCoordinationName(target)))
0: 					coordination.end();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 		new StartAction(instigator, target, subsystem, coordination).run();
commit:171067b
/////////////////////////////////////////////////////////////////////////
0: 			waitForStateChange(state);
commit:5bd3bf6
/////////////////////////////////////////////////////////////////////////
0: 	private static final Logger logger = LoggerFactory.getLogger(BasicSubsystem.class);
1: 	private final BasicSubsystem instigator;
1: 	public StartAction(BasicSubsystem instigator, BasicSubsystem requestor, BasicSubsystem target) {
/////////////////////////////////////////////////////////////////////////
1: 	private static Collection<Bundle> getBundles(BasicSubsystem subsystem) {
/////////////////////////////////////////////////////////////////////////
0: 	private static void resolve(BasicSubsystem subsystem) {
/////////////////////////////////////////////////////////////////////////
0: 					resolve((BasicSubsystem)child);
/////////////////////////////////////////////////////////////////////////
0: 	private static void setExportIsolationPolicy(BasicSubsystem subsystem) throws InvalidSyntaxException, IOException, BundleException, URISyntaxException, ResolutionException {
0: 		Region from = ((BasicSubsystem)subsystem.getParents().iterator().next()).getRegion();
/////////////////////////////////////////////////////////////////////////
1: 	private static void setExportIsolationPolicy(RegionFilterBuilder builder, ExportPackageHeader header, BasicSubsystem subsystem) throws InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 	private static void setExportIsolationPolicy(RegionFilterBuilder builder, ProvideCapabilityHeader header, BasicSubsystem subsystem) throws InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 	private static void setExportIsolationPolicy(RegionFilterBuilder builder, SubsystemExportServiceHeader header, BasicSubsystem subsystem) throws InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 		final BasicSubsystem subsystem = (BasicSubsystem)resource;
commit:5b9ff63
/////////////////////////////////////////////////////////////////////////
1: 		if (Utils.isRegionContextBundle(resource))
1: 			// The region context bundle was persistently started elsewhere.
1: 			return;
commit:4556ca7
/////////////////////////////////////////////////////////////////////////
1: 			// Starting the root subsystem should not affect bundles within the
1: 			// root region.
commit:f9e608f
/////////////////////////////////////////////////////////////////////////
1: 		if (target.isRoot())
1: 			return;
commit:391a1aa
/////////////////////////////////////////////////////////////////////////
1: import java.util.EnumSet;
/////////////////////////////////////////////////////////////////////////
0: 	private final AriesSubsystem instigator;
1: 	
0: 	public StartAction(AriesSubsystem instigator, AriesSubsystem requestor, AriesSubsystem target) {
1: 		super(requestor, target, false);
1: 		this.instigator = instigator;
0: 		State state = target.getState();
0: 		// The following states are illegal.
0: 		if (EnumSet.of(State.INSTALL_FAILED, State.UNINSTALLED, State.UNINSTALLING).contains(state))
0: 		// The following states must wait.
0: 		if (EnumSet.of(State.INSTALLING, State.RESOLVING, State.STARTING, State.STOPPING).contains(state)) {
0: 			return new StartAction(instigator, requestor, target).run();
0: 		// The following states mean the requested state has already been attained.
0: 		if (State.ACTIVE.equals(state))
0: 		// Always start if target is content of requestor.
0: 		if (!Utils.isContent(requestor, target)) {
0: 			// Aways start if target is a dependency of requestor.
0: 			if (!Utils.isDependency(requestor, target)) {
0: 				// Always start if instigator equals target (explicit start).
0: 				if (!instigator.equals(target)) {
0: 					// Don't start if instigator is root (restart) and target is not ready.
0: 					if (instigator.isRoot() && !target.isReadyToStart()) {
0: 						return null;
0: 					}
0: 				}
0: 			}
0: 		}
0: 		// Resolve if necessary.
0: 		if (State.INSTALLED.equals(state))
0: 			resolve(target);
0: 		target.setState(State.STARTING);
0: 				.create(target.getSymbolicName() + '-' + target.getSubsystemId(), 0);
0: 			List<Resource> resources = new ArrayList<Resource>(Activator.getInstance().getSubsystems().getResourcesReferencedBy(target));
0: 			SubsystemContentHeader header = target.getSubsystemManifest().getSubsystemContentHeader();
0: 			for (Resource resource : resources)
0: 				startResource(resource, coordination);
0: 			target.setState(State.ACTIVE);
/////////////////////////////////////////////////////////////////////////
0: 				target.setState(State.RESOLVED);
/////////////////////////////////////////////////////////////////////////
0: 	private static Collection<Bundle> getBundles(AriesSubsystem subsystem) {
/////////////////////////////////////////////////////////////////////////
0: 	private static void resolve(AriesSubsystem subsystem) {
1: 		// Don't propagate a RESOLVING event if this is a persisted subsystem
1: 		// that is already RESOLVED.
1: 		if (State.INSTALLED.equals(subsystem.getState()))
1: 			subsystem.setState(State.RESOLVING);
/////////////////////////////////////////////////////////////////////////
0: 			// No need to propagate a RESOLVED event if this is a persisted
0: 			// subsystem already in the RESOLVED state.
0: 			if (State.RESOLVING.equals(subsystem.getState()))
0: 				subsystem.setState(State.RESOLVED);
/////////////////////////////////////////////////////////////////////////
0: 	private static void setExportIsolationPolicy(AriesSubsystem subsystem) throws InvalidSyntaxException, IOException, BundleException, URISyntaxException, ResolutionException {
/////////////////////////////////////////////////////////////////////////
0: 	private static void setExportIsolationPolicy(RegionFilterBuilder builder, ExportPackageHeader header, AriesSubsystem subsystem) throws InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
0: 	private static void setExportIsolationPolicy(RegionFilterBuilder builder, ProvideCapabilityHeader header, AriesSubsystem subsystem) throws InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
0: 	private static void setExportIsolationPolicy(RegionFilterBuilder builder, SubsystemExportServiceHeader header, AriesSubsystem subsystem) throws InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 		// Subsystems that are content resources of another subsystem must have
1: 		// their autostart setting set to started.
1: 		if (Utils.isContent(this.target, subsystem))
1: 			subsystem.setAutostart(true);
0: 		new StartAction(instigator, target, subsystem).run();
/////////////////////////////////////////////////////////////////////////
1: 				new StopAction(target, subsystem, !subsystem.isRoot()).run();
commit:b548bb2
/////////////////////////////////////////////////////////////////////////
1: 			// The root subsystem should follow the same event pattern for
1: 			// state transitions as other subsystems. However, an unresolvable
1: 			// root subsystem should have no effect, so there's no point in
1: 			// actually doing the resolution work.
1: 			if (!subsystem.isRoot()) {
0: 				for (Subsystem child : Activator.getInstance().getSubsystems().getChildren(subsystem))
0: 					resolve((AriesSubsystem)child);
0: 				// TODO I think this is insufficient. Do we need both
0: 				// pre-install and post-install environments for the Resolver?
0: 				Collection<Bundle> bundles = getBundles(subsystem);
0: 				if (!Activator.getInstance().getBundleContext().getBundle(0)
0: 						.adapt(FrameworkWiring.class).resolveBundles(bundles)) {
0: 					logger.error(
0: 							"Unable to resolve bundles for subsystem/version/id {}/{}/{}: {}",
0: 							new Object[] { subsystem.getSymbolicName(), subsystem.getVersion(),
0: 									subsystem.getSubsystemId(), bundles });
0: 					throw new SubsystemException("Framework could not resolve the bundles");
0: 				}
0: 				setExportIsolationPolicy(subsystem);
commit:a14f2fd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
commit:2b13b05
/////////////////////////////////////////////////////////////////////////
0: 	public StartAction(AriesSubsystem subsystem, boolean explicit) {
0: 		super(subsystem, false, explicit);
/////////////////////////////////////////////////////////////////////////
0: 			return new StartAction(subsystem, explicit).run();
0: 		if (explicit)
0: 			subsystem.setAutostart(true);
/////////////////////////////////////////////////////////////////////////
0: 			if (header != null)
0: 			if (!subsystem.isRoot())
0: 				for (Resource resource : resources)
0: 					startResource(resource, coordination);
/////////////////////////////////////////////////////////////////////////
1: 		if (!subsystem.isComposite())
1: 		setExportIsolationPolicy(builder, subsystem.getDeploymentManifest().getExportPackageHeader(), subsystem);
1: 		setExportIsolationPolicy(builder, subsystem.getDeploymentManifest().getProvideCapabilityHeader(), subsystem);
1: 		setExportIsolationPolicy(builder, subsystem.getDeploymentManifest().getSubsystemExportServiceHeader(), subsystem);
1: 		if (regionFilter.getSharingPolicy().isEmpty())
1: 			return;
/////////////////////////////////////////////////////////////////////////
0: 		new StartAction(subsystem, false).run();
/////////////////////////////////////////////////////////////////////////
0: 				new StopAction(subsystem, !subsystem.isRoot(), false).run();
commit:777b216
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
0: import java.net.URISyntaxException;
1: import java.util.Collection;
1: import java.util.Map.Entry;
1: import org.apache.aries.subsystem.core.archive.ExportPackageCapability;
1: import org.apache.aries.subsystem.core.archive.ExportPackageHeader;
1: import org.apache.aries.subsystem.core.archive.ProvideCapabilityCapability;
1: import org.apache.aries.subsystem.core.archive.ProvideCapabilityHeader;
1: import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
1: import org.apache.aries.subsystem.core.archive.SubsystemExportServiceCapability;
1: import org.apache.aries.subsystem.core.archive.SubsystemExportServiceHeader;
1: import org.eclipse.equinox.region.Region;
1: import org.eclipse.equinox.region.RegionFilter;
1: import org.eclipse.equinox.region.RegionFilterBuilder;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleException;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.namespace.IdentityNamespace;
1: import org.osgi.framework.wiring.BundleRevision;
1: import org.osgi.framework.wiring.FrameworkWiring;
1: import org.osgi.service.coordinator.Participant;
0: import org.osgi.service.resolver.ResolutionException;
1: import org.osgi.service.subsystem.Subsystem;
1: import org.osgi.service.subsystem.SubsystemConstants;
1: import org.osgi.service.subsystem.SubsystemException;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: public class StartAction extends AbstractAction {
0: 	private static final Logger logger = LoggerFactory.getLogger(AriesSubsystem.class);
0: 		super(subsystem);
/////////////////////////////////////////////////////////////////////////
0: 			waitForStateChange();
0: 		resolve(subsystem);
0: 		subsystem.setAutostart(true);
/////////////////////////////////////////////////////////////////////////
0: 			SubsystemContentHeader header = subsystem.getSubsystemManifest().getSubsystemContentHeader();
0: 			if (header != null && !subsystem.isRoot())
0: 				Collections.sort(resources, new StartResourceComparator(header));
0: 				startResource(resource, coordination);
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private Collection<Bundle> getBundles(AriesSubsystem subsystem) {
1: 		Collection<Resource> constituents = Activator.getInstance().getSubsystems().getConstituents(subsystem);
1: 		ArrayList<Bundle> result = new ArrayList<Bundle>(constituents.size());
1: 		for (Resource resource : constituents) {
1: 			if (resource instanceof BundleRevision)
1: 				result.add(((BundleRevision)resource).getBundle());
0: 		}
1: 		result.trimToSize();
0: 		return result;
0: 	}
1: 	
0: 	private void resolve(AriesSubsystem subsystem) {
0: 		if (subsystem.getState() != State.INSTALLED)
1: 			return;
0: 		subsystem.setState(State.RESOLVING);
0: 		try {
0: 			for (Subsystem child : Activator.getInstance().getSubsystems().getChildren(subsystem))
0: 				resolve((AriesSubsystem)child);
0: 			// TODO I think this is insufficient. Do we need both
0: 			// pre-install and post-install environments for the Resolver?
0: 			Collection<Bundle> bundles = getBundles(subsystem);
0: 			if (!Activator.getInstance().getBundleContext().getBundle(0)
0: 					.adapt(FrameworkWiring.class).resolveBundles(bundles)) {
0: 				logger.error(
0: 						"Unable to resolve bundles for subsystem/version/id {}/{}/{}: {}",
0: 						new Object[] { subsystem.getSymbolicName(), subsystem.getVersion(),
0: 								subsystem.getSubsystemId(), bundles });
0: 				throw new SubsystemException("Framework could not resolve the bundles");
0: 			}
0: 			setExportIsolationPolicy(subsystem);
0: 			// TODO Could avoid calling setState (and notifyAll) here and
0: 			// avoid the need for a lock.
0: 			subsystem.setState(State.RESOLVED);
0: 		}
1: 		catch (Throwable t) {
1: 			subsystem.setState(State.INSTALLED);
0: 			if (t instanceof SubsystemException)
0: 				throw (SubsystemException)t;
0: 			throw new SubsystemException(t);
0: 		}
0: 	}
1: 	
0: 	private void setExportIsolationPolicy(AriesSubsystem subsystem) throws InvalidSyntaxException, IOException, BundleException, URISyntaxException, ResolutionException {
0: 		if (subsystem.isRoot())
0: 			// Nothing to do if this is the root subsystem.
1: 			return;
0: 		if (!subsystem.isScoped())
0: 			// Features share the same isolation as that of their scoped parent.
1: 			return;
0: 		Region from = ((AriesSubsystem)subsystem.getParents().iterator().next()).getRegion();
0: 		Region to = subsystem.getRegion();
1: 		RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
0: 		if (subsystem.isComposite()) {
0: 			setExportIsolationPolicy(builder, subsystem.getDeploymentManifest().getExportPackageHeader(), subsystem);
0: 			setExportIsolationPolicy(builder, subsystem.getDeploymentManifest().getProvideCapabilityHeader(), subsystem);
0: 			setExportIsolationPolicy(builder, subsystem.getDeploymentManifest().getSubsystemExportServiceHeader(), subsystem);
0: 			// TODO Implement export isolation policy for composites.
0: 		}
1: 		RegionFilter regionFilter = builder.build();
1: 		if (logger.isDebugEnabled())
1: 			logger.debug("Establishing region connection: from=" + from
1: 					+ ", to=" + to + ", filter=" + regionFilter);
0: 		from.connectRegion(to, regionFilter);
0: 	}
1: 	
0: 	private void setExportIsolationPolicy(RegionFilterBuilder builder, ExportPackageHeader header, AriesSubsystem subsystem) throws InvalidSyntaxException {
1: 		if (header == null)
1: 			return;
1: 		String policy = RegionFilter.VISIBLE_PACKAGE_NAMESPACE;
1: 		for (ExportPackageCapability capability : header.toCapabilities(subsystem)) {
1: 			StringBuilder filter = new StringBuilder("(&");
1: 			for (Entry<String, Object> attribute : capability.getAttributes().entrySet())
1: 				filter.append('(').append(attribute.getKey()).append('=').append(attribute.getValue()).append(')');
1: 			filter.append(')');
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Allowing " + policy + " of " + filter);
1: 			builder.allow(policy, filter.toString());
0: 		}
0: 	}
1: 	
0: 	private void setExportIsolationPolicy(RegionFilterBuilder builder, ProvideCapabilityHeader header, AriesSubsystem subsystem) throws InvalidSyntaxException {
1: 		if (header == null)
1: 			return;
1: 		for (ProvideCapabilityHeader.Clause clause : header.getClauses()) {
1: 			ProvideCapabilityCapability capability = new ProvideCapabilityCapability(clause, subsystem);
1: 			String policy = capability.getNamespace();
1: 			StringBuilder filter = new StringBuilder("(&");
1: 			for (Entry<String, Object> attribute : capability.getAttributes().entrySet())
1: 				filter.append('(').append(attribute.getKey()).append('=').append(attribute.getValue()).append(')');
1: 			filter.append(')');
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Allowing " + policy + " of " + filter);
1: 			builder.allow(policy, filter.toString());
0: 		}
0: 	}
1: 	
0: 	private void setExportIsolationPolicy(RegionFilterBuilder builder, SubsystemExportServiceHeader header, AriesSubsystem subsystem) throws InvalidSyntaxException {
1: 		if (header == null)
1: 			return;
1: 		String policy = RegionFilter.VISIBLE_SERVICE_NAMESPACE;
1: 		for (SubsystemExportServiceHeader.Clause clause : header.getClauses()) {
1: 			SubsystemExportServiceCapability capability = new SubsystemExportServiceCapability(clause, subsystem);
1: 			String filter = capability.getDirectives().get(SubsystemExportServiceCapability.DIRECTIVE_FILTER);
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Allowing " + policy + " of " + filter);
1: 			builder.allow(policy, filter.toString());
0: 		}
0: 	}
1: 	
1: 	private void startBundleResource(Resource resource, Coordination coordination) throws BundleException {
1: 		final Bundle bundle = ((BundleRevision)resource).getBundle();
1: 		if ((bundle.getState() & (Bundle.STARTING | Bundle.ACTIVE)) != 0)
1: 			return;
1: 		bundle.start(Bundle.START_TRANSIENT | Bundle.START_ACTIVATION_POLICY);
1: 		if (coordination == null)
1: 			return;
1: 		coordination.addParticipant(new Participant() {
1: 			public void ended(Coordination coordination) throws Exception {
1: 				// noop
0: 			}
1: 	
1: 			public void failed(Coordination coordination) throws Exception {
1: 				bundle.stop();
0: 			}
1: 		});
0: 	}
1: 	
1: 	private void startResource(Resource resource, Coordination coordination) throws BundleException, IOException {
1: 		String type = ResourceHelper.getTypeAttribute(resource);
1: 		if (SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type)
1: 				|| SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(type))
1: 			startSubsystemResource(resource, coordination);
0: 		else if (IdentityNamespace.TYPE_BUNDLE.equals(type))
1: 			startBundleResource(resource, coordination);
0: 		else if (IdentityNamespace.TYPE_FRAGMENT.equals(type)) {
1: 			// Fragments are not started.
0: 		}
0: 		else
1: 			throw new SubsystemException("Unsupported resource type: " + type);
0: 	}
1: 
0: 	private void startSubsystemResource(Resource resource, Coordination coordination) throws IOException {
0: 		final AriesSubsystem subsystem = (AriesSubsystem)resource;
0: 		subsystem.start();
1: 		if (coordination == null)
1: 			return;
1: 		coordination.addParticipant(new Participant() {
1: 			public void ended(Coordination coordination) throws Exception {
1: 				// noop
0: 			}
1: 	
1: 			public void failed(Coordination coordination) throws Exception {
0: 				subsystem.stop();
0: 			}
1: 		});
0: 	}
commit:c3ec212
/////////////////////////////////////////////////////////////////////////
0: 			if (!subsystem.isRoot())
0: 				Collections.sort(resources, new StartResourceComparator(subsystem.getSubsystemManifest().getSubsystemContentHeader()));
commit:225bcae
/////////////////////////////////////////////////////////////////////////
0: 			List<Resource> resources = new ArrayList<Resource>(Activator.getInstance().getSubsystems().getResourcesReferencedBy(subsystem));
commit:dc5d52f
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.subsystem.core.internal;
1: 
0: import java.security.PrivilegedAction;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.List;
1: 
1: import org.osgi.resource.Resource;
1: import org.osgi.service.coordinator.Coordination;
1: import org.osgi.service.coordinator.CoordinationException;
0: import org.osgi.service.subsystem.SubsystemException;
1: import org.osgi.service.subsystem.Subsystem.State;
1: 
0: public class StartAction implements PrivilegedAction<Object> {
0: 	private final AriesSubsystem subsystem;
1: 	
0: 	public StartAction(AriesSubsystem subsystem) {
0: 		this.subsystem = subsystem;
0: 	}
1: 	
0: 	@Override
1: 	public Object run() {
0: 		State state = subsystem.getState();
0: 		if (state == State.UNINSTALLING || state == State.UNINSTALLED)
0: 			throw new SubsystemException("Cannot stop from state " + state);
0: 		if (state == State.INSTALLING || state == State.RESOLVING || state == State.STOPPING) {
0: 			subsystem.waitForStateChange();
0: 			subsystem.start();
0: 			return null;
0: 		}
0: 		// TODO Should we wait on STARTING to see if the outcome is ACTIVE?
0: 		if (state == State.STARTING || state == State.ACTIVE)
0: 			return null;
0: 		subsystem.resolve();
0: 		subsystem.setState(State.STARTING);
0: 		subsystem.autostart = true;
0: 		// TODO Need to hold a lock here to guarantee that another start
0: 		// operation can't occur when the state goes to RESOLVED.
0: 		// Start the subsystem.
0: 		Coordination coordination = Activator.getInstance()
0: 				.getCoordinator()
0: 				.create(subsystem.getSymbolicName() + '-' + subsystem.getSubsystemId(), 0);
0: 		try {
0: 			List<Resource> resources = new ArrayList<Resource>(AriesSubsystem.resourceReferences.getResources(subsystem));
0: 			if (subsystem.resource != null)
0: 				Collections.sort(resources, new StartResourceComparator(subsystem.resource.getSubsystemManifest().getSubsystemContentHeader()));
0: 			for (Resource resource : resources)
0: 				subsystem.startResource(resource, coordination);
0: 			subsystem.setState(State.ACTIVE);
0: 		} catch (Throwable t) {
0: 			coordination.fail(t);
0: 			// TODO Need to reinstate complete isolation by disconnecting the
0: 			// region and transition to INSTALLED.
0: 		} finally {
0: 			try {
0: 				coordination.end();
0: 			} catch (CoordinationException e) {
0: 				subsystem.setState(State.RESOLVED);
0: 				Throwable t = e.getCause();
0: 				if (t instanceof SubsystemException)
0: 					throw (SubsystemException)t;
0: 				throw new SubsystemException(t);
0: 			}
0: 		}
0: 		return null;
0: 	}
0: }
author:Jeremy Hughes
-------------------------------------------------------------------------------
commit:7f57ec7
/////////////////////////////////////////////////////////////////////////
0: 					StringBuilder diagnostics = new StringBuilder();
0: 					diagnostics.append(String.format("Unable to resolve bundles for subsystem/version/id %s/%s/%s:\n", 
0: 							subsystem.getSymbolicName(), subsystem.getVersion(), subsystem.getSubsystemId()));
0: 					String fmt = "%d : STATE %s : %s : %s : %s";
0: 						if((bundle.getState() & Bundle.RESOLVED) != Bundle.RESOLVED) {
0: 						String state = null;
0: 						switch(bundle.getState()) {
0: 							case Bundle.ACTIVE :
0: 								state = "ACTIVE";
0: 								break;
0: 							case Bundle.INSTALLED :
0: 								state = "INSTALLED";
0: 								break;
0: 							case Bundle.RESOLVED :
0: 								state = "RESOLVED";
0: 								break;
0: 							case Bundle.STARTING :
0: 								state = "STARTING";
0: 								break;
0: 							case Bundle.STOPPING :
0: 								state = "STOPPING";
0: 								break;
0: 							case Bundle.UNINSTALLED :
0: 								state = "UNINSTALLED";
0: 								break;
0: 							default :
0: 								//convert common states to text otherwise default to just showing the ID
0: 								state = "[" + Integer.toString(bundle.getState()) + "]";
0: 								break;
0: 						}
0: 						diagnostics.append(String.format(fmt, bundle.getBundleId(), state, 
0: 								bundle.getSymbolicName(), bundle.getVersion().toString(), 
0: 								bundle.getLocation()));
0: 						diagnostics.append("\n");
0: 					logger.error(diagnostics.toString());
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:79b20bc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.ContentHandler;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.ServiceReference;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0: 				// Don't end the coordination if the subsystem being started
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1: 		if (logger.isDebugEnabled()) {
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1: 		if (logger.isDebugEnabled()) {
0: 
0: 
0: 
1: 				|| SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(type)) {
1: 	    } else if (IdentityNamespace.TYPE_BUNDLE.equals(type)) {
1: 	    } else if (IdentityNamespace.TYPE_FRAGMENT.equals(type)) {
1: 		} else {
1: 		    if (!startCustomHandler(resource, type, coordination))
0: 		        throw new SubsystemException("Unsupported resource type: " + type);
1:     private boolean startCustomHandler(Resource resource, String type, Coordination coordination) {
1:         ServiceReference<ContentHandler> customHandlerRef = CustomResources.getCustomContentHandler(target, type);
1:         if (customHandlerRef != null) {
1:             ContentHandler customHandler = target.getBundleContext().getService(customHandlerRef);
1:             if (customHandler != null) {
0:                 try {
1:                     customHandler.start(ResourceHelper.getSymbolicNameAttribute(resource), type, target, coordination);
1:                     return true;
0:                 } finally {
1:                     target.getBundleContext().ungetService(customHandlerRef);
0:                 }
0:             }
0:         }
1:         return false;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:f4797e6
/////////////////////////////////////////////////////////////////////////
0: 				
0: 				FrameworkWiring frameworkWiring = Activator.getInstance().getBundleContext().getBundle(0)
0: 						.adapt(FrameworkWiring.class);
0: 
0: 				if (!frameworkWiring.resolveBundles(bundles)) {
0: 					//work out which bundles could not be resolved
0: 					Collection<Bundle> unresolved = new ArrayList<Bundle>();
0: 					for(Bundle bundle:bundles){
0: 						if((bundle.getState() & Bundle.RESOLVED) != Bundle.RESOLVED){
0: 							unresolved.add(bundle);
0: 						}
0: 					}
0: 									subsystem.getSubsystemId(), unresolved });
0: 					throw new SubsystemException("Framework could not resolve the bundles: " + unresolved);
commit:ab21913
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			Bundle systemBundle=Activator.getInstance().getBundleContext().getBundle(0);
commit:d290f20
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.launch.Framework;
/////////////////////////////////////////////////////////////////////////
0: 			Bundle systemBundle = bundle.getBundleContext().getBundle(0);
1: 			int fwStartLevel = systemBundle.adapt(FrameworkStartLevel.class).getStartLevel();
commit:d89d3d4
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.startlevel.FrameworkStartLevel;
/////////////////////////////////////////////////////////////////////////
1: 			int bundleStartLevel = bundle.adapt(BundleStartLevel.class).getStartLevel();
0: 			int fwStartLevel = bundle.adapt(FrameworkStartLevel.class).getStartLevel();
1: 				+ " bundleStartLevel=" + bundleStartLevel
1: 				+ " frameworkStartLevel=" + fwStartLevel);
0: 		
0: 		if (logger.isDebugEnabled()) { 
1: 			logger.debug("StartAction: bundle " + bundle.getSymbolicName()
1: 				+ " " + bundle.getVersion().toString()
1: 				+ " started correctly");
0: 		}
0: 		
commit:9bcf4ce
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.startlevel.BundleStartLevel;
/////////////////////////////////////////////////////////////////////////
0: 	private static final Logger logger = LoggerFactory.getLogger(StartAction.class);
/////////////////////////////////////////////////////////////////////////
0: 		
0: 		
0: 		if (logger.isDebugEnabled()) { 
0: 			int startLevel = bundle.adapt(BundleStartLevel.class).getStartLevel();
1: 			logger.debug("StartAction: starting bundle " + bundle.getSymbolicName()
1: 				+ " " + bundle.getVersion().toString()
0: 				+ " startLevel=" + startLevel);
0: 		}
0: 		
============================================================================