1:96d4e06: /*
1:96d4e06:  * Licensed to the Apache Software Foundation (ASF) under one
1:96d4e06:  * or more contributor license agreements.  See the NOTICE file
1:96d4e06:  * distributed with this work for additional information
1:96d4e06:  * regarding copyright ownership.  The ASF licenses this file
1:96d4e06:  * to you under the Apache License, Version 2.0 (the
1:96d4e06:  * "License"); you may not use this file except in compliance
1:96d4e06:  * with the License.  You may obtain a copy of the License at
1:96d4e06:  *
1:96d4e06:  *   http://www.apache.org/licenses/LICENSE-2.0
1:96d4e06:  *
1:96d4e06:  * Unless required by applicable law or agreed to in writing,
1:96d4e06:  * software distributed under the License is distributed on an
1:96d4e06:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:96d4e06:  * KIND, either express or implied.  See the License for the
1:96d4e06:  * specific language governing permissions and limitations
1:96d4e06:  * under the License.
1:96d4e06:  */
1:96d4e06: package org.apache.aries.blueprint.proxy;
5:96d4e06: 
1:96d4e06: import static org.junit.Assert.assertEquals;
1:0ac1890: import static org.junit.Assert.assertFalse;
1:96d4e06: import static org.junit.Assert.assertNotNull;
1:96d4e06: import static org.junit.Assert.assertTrue;
1:88359ce: import static org.junit.Assert.fail;
1:96d4e06: 
1:96d4e06: import java.io.ByteArrayOutputStream;
1:96d4e06: import java.io.InputStream;
1:8f4b919: import java.io.ObjectOutputStream;
1:96d4e06: import java.lang.reflect.Method;
1:2d7219c: import java.net.URL;
1:96d4e06: import java.util.ArrayList;
1:14c07d5: import java.util.Arrays;
1:d014a6c: import java.util.Collection;
1:96d4e06: import java.util.HashMap;
1:96d4e06: import java.util.List;
1:96d4e06: import java.util.Map;
1:96d4e06: import java.util.concurrent.Callable;
1:96d4e06: 
1:88359ce: import org.apache.aries.blueprint.proxy.ProxyTestClassInnerClasses.ProxyTestClassInner;
1:88359ce: import org.apache.aries.blueprint.proxy.ProxyTestClassInnerClasses.ProxyTestClassStaticInner;
1:88359ce: import org.apache.aries.blueprint.proxy.ProxyTestClassInnerClasses.ProxyTestClassUnweavableInnerChild;
1:96d4e06: import org.apache.aries.blueprint.proxy.pkg.ProxyTestClassUnweavableSuperWithDefaultMethodWrongPackageParent;
1:96d4e06: import org.apache.aries.proxy.FinalModifierException;
1:96d4e06: import org.apache.aries.proxy.InvocationListener;
1:96d4e06: import org.apache.aries.proxy.UnableToProxyException;
1:d014a6c: import org.apache.aries.proxy.impl.AsmProxyManager;
1:96d4e06: import org.apache.aries.proxy.impl.SingleInstanceDispatcher;
1:0737543: import org.apache.aries.proxy.impl.SystemModuleClassLoader;
1:96d4e06: import org.apache.aries.proxy.impl.gen.ProxySubclassMethodHashSet;
1:96d4e06: import org.apache.aries.proxy.impl.weaving.WovenProxyGenerator;
1:96d4e06: import org.apache.aries.proxy.weaving.WovenProxy;
1:d014a6c: import org.apache.aries.unittest.mocks.MethodCall;
1:d014a6c: import org.apache.aries.unittest.mocks.Skeleton;
1:d014a6c: import org.apache.aries.util.ClassLoaderProxy;
1:96d4e06: import org.junit.BeforeClass;
1:96d4e06: import org.junit.Test;
1:d014a6c: import org.osgi.framework.Bundle;
1:760dac8: import org.osgi.framework.wiring.BundleWiring;
1:96d4e06: 
1:96d4e06: 
1:96d4e06: public class WovenProxyGeneratorTest extends AbstractProxyTest
1:96d4e06: {
1:96d4e06:   private static final String hexPattern = "[0-9_a-f]";
1:96d4e06:   private static final int[] uuid_pattern = new int[] {8,4,4,4,12};
1:96d4e06:   private static final String regexp;
1:96d4e06:   
1:96d4e06:   static {
1:96d4e06:     StringBuilder sb = new StringBuilder(".*");
1:96d4e06:     for(int i : uuid_pattern) {
1:96d4e06:       for(int j = 0; j < i; j++){
1:96d4e06:         sb.append(hexPattern);
1:96d4e06:       }
1:96d4e06:       sb.append("_");
1:96d4e06:     }
1:96d4e06:     sb.deleteCharAt(sb.length() -1);
1:96d4e06:     sb.append("\\d*");
1:96d4e06:     regexp = sb.toString();
1:96d4e06:   }
1:96d4e06:   
1:88359ce:   /** An array of classes that will be woven - note no UnweavableParents should be in here! */
1:8f852b6:   private static final List<Class<?>> CLASSES = Arrays.asList(new Class<?>[]{ProxyTestClassGeneral.class, ProxyTestClassSuper.class,
1:96d4e06:     ProxyTestClassFinalMethod.class, ProxyTestClassFinal.class, ProxyTestClassGeneric.class,
1:96d4e06:     ProxyTestClassGenericSuper.class, ProxyTestClassCovariant.class, ProxyTestClassCovariantOverride.class,
1:88359ce:     ProxyTestClassUnweavableChild.class, ProxyTestClassUnweavableSibling.class, ProxyTestClassInner.class, 
1:88359ce:     ProxyTestClassStaticInner.class, ProxyTestClassUnweavableInnerChild.class, 
1:88359ce:     ProxyTestClassUnweavableChildWithFinalMethodParent.class, 
1:0ac1890:     ProxyTestClassUnweavableChildWithDefaultMethodWrongPackageParent.class, 
1:0857a0e:     ProxyTestClassSerializable.class, ProxyTestClassSerializableWithSVUID.class,
1:14c07d5:     ProxyTestClassSerializableChild.class, ProxyTestClassSerializableInterface.class,
1:d014a6c:     ProxyTestClassStaticInitOfChild.class, ProxyTestClassAbstract.class});
1:14c07d5:   
1:14c07d5:   /** An array of classes that are loaded by the WeavingLoader, but not actually woven **/
1:8f852b6:   private static final List<Class<?>> OTHER_CLASSES = Arrays.asList(new Class<?>[] {ProxyTestClassUnweavableSuper.class,
1:8f852b6: 		  ProxyTestClassStaticInitOfChildParent.class, ProxyTestClassChildOfAbstract.class});
1:96d4e06:  
1:96d4e06:   private static final Map<String, byte[]> rawClasses = new HashMap<String, byte[]>();
1:96d4e06:   
1:0737543:   protected static final ClassLoader weavingLoader = new SystemModuleClassLoader() {
1:96d4e06:     public Class<?> loadClass(String className)  throws ClassNotFoundException
1:96d4e06:     {
1:96d4e06:       return loadClass(className, false);
1:96d4e06:     }
1:96d4e06:     public Class<?> loadClass(String className, boolean b) throws ClassNotFoundException
1:96d4e06:     {
1:96d4e06:       if (!!!className.startsWith("org.apache.aries.blueprint.proxy.ProxyTest")){
1:96d4e06:         return Class.forName(className);
1:96d4e06:       }
1:96d4e06:       
1:96d4e06:       Class<?> clazz = findLoadedClass(className);
1:96d4e06:       if(clazz != null)
1:96d4e06:         return clazz;
1:96d4e06:       
1:96d4e06:       byte[] bytes = rawClasses.get(className);
1:96d4e06:       if(bytes == null)
1:96d4e06:         return super.loadClass(className, b);
1:96d4e06:       
1:14c07d5:       boolean weave = false;
1:14c07d5:       
1:14c07d5:       for(Class<?> c : CLASSES) {
1:14c07d5:         if(c.getName().equals(className)) {
1:14c07d5:           weave = true;
1:14c07d5:           break;
1:14c07d5:         }
1:14c07d5:       }
1:14c07d5:       if(weave)
1:f80358e:         bytes = WovenProxyGenerator.getWovenProxy(bytes, this);
1:96d4e06:       
1:96d4e06:       return defineClass(className, bytes, 0, bytes.length);
1:96d4e06:     }
1:2d7219c:     
1:2d7219c:     protected URL findResource(String resName) {
1:2d7219c:       return WovenProxyGeneratorTest.class.getResource(resName);
1:2d7219c:     }
1:96d4e06:   };
1:96d4e06:    
1:96d4e06:   /**
1:96d4e06:    * @throws java.lang.Exception
1:96d4e06:    */
1:96d4e06:   @BeforeClass
1:96d4e06:   public static void setUp() throws Exception
1:96d4e06:   {
1:14c07d5:     List<Class<?>> classes = new ArrayList(CLASSES.size() + OTHER_CLASSES.size());
1:14c07d5:     
1:14c07d5:     classes.addAll(CLASSES);
1:14c07d5:     classes.addAll(OTHER_CLASSES);
1:14c07d5:     
1:14c07d5:     for(Class<?> clazz : classes) {
1:96d4e06:       InputStream is = clazz.getClassLoader().getResourceAsStream(
1:96d4e06:           clazz.getName().replace('.', '/') + ".class");
1:96d4e06:       ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:96d4e06:       
1:96d4e06:       byte[] buffer = new byte[2048];
1:96d4e06:       int read = is.read(buffer);
1:96d4e06:       while(read != -1) {
1:96d4e06:         baos.write(buffer, 0, read);
1:96d4e06:         read = is.read(buffer);
1:96d4e06:       }
1:96d4e06:       rawClasses.put(clazz.getName(), baos.toByteArray());
1:96d4e06:     }
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:8f852b6:    * This test uses the WovenProxyGenerator to generate and load the specified getTestClass().
1:96d4e06:    * 
1:96d4e06:    * Once the subclass is generated we check that it wasn't null. 
1:96d4e06:    * 
1:96d4e06:    * Test method for
1:96d4e06:    * {@link WovenProxyGenerator#getProxySubclass(byte[], String)}.
1:96d4e06:    */
1:8f4b919:   @Test
1:96d4e06:   public void testGenerateAndLoadProxy() throws Exception
1:96d4e06:   {
1:96d4e06:     super.testGenerateAndLoadProxy();
1:8f852b6:     assertTrue("Should be a WovenProxy", WovenProxy.class.isAssignableFrom(getProxyClass(getTestClass())));
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Test that the methods found declared on the generated proxy are
1:96d4e06:    * the ones that we expect.
1:96d4e06:    */
1:88359ce:   @Test
1:96d4e06:   public void testExpectedMethods() throws Exception
1:96d4e06:   {
1:8f852b6:     ProxySubclassMethodHashSet<String> originalMethods = getMethods(getTestClass());
1:96d4e06: 
1:96d4e06:     ProxySubclassMethodHashSet<String> generatedMethods = getMethods(weavingLoader.
1:8f852b6:         loadClass(getTestClass().getName()));
1:96d4e06: 
1:96d4e06:     // check that all the methods we have generated were expected
1:96d4e06:     for (String gen : generatedMethods) {
1:96d4e06:       assertTrue("Unexpected method: " + gen, originalMethods.contains(gen));
1:96d4e06:     }
1:96d4e06:     // check that all the expected methods were generated
1:96d4e06:     for (String exp : originalMethods) {
1:96d4e06:       assertTrue("Method was not generated: " + exp, generatedMethods.contains(exp));
1:96d4e06:     }
1:96d4e06:     // check the sets were the same
1:96d4e06:     assertEquals("Sets were not the same", originalMethods, generatedMethods);
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   private ProxySubclassMethodHashSet<String> getMethods(Class<?> clazz) {
1:96d4e06:     
1:96d4e06:     ProxySubclassMethodHashSet<String> foundMethods = 
1:96d4e06:       new ProxySubclassMethodHashSet<String>(12);
1:96d4e06:     do {
1:96d4e06:       Method[] declaredMethods = clazz.getDeclaredMethods();
1:96d4e06:       List<Method> listOfDeclaredMethods = new ArrayList<Method>();
1:96d4e06:       for (Method m : declaredMethods) {
1:96d4e06:         if(m.getName().startsWith(WovenProxy.class.getName().replace('.', '_')) ||
1:96d4e06:             m.getName().startsWith("getListener") || m.getName().startsWith("getInvocationTarget") ||
1:96d4e06:             //four hex digits
1:96d4e06:             m.getName().matches(regexp))
1:96d4e06:           continue;
1:96d4e06:         
1:96d4e06:         listOfDeclaredMethods.add(m);
1:96d4e06:       }
1:96d4e06:       declaredMethods = listOfDeclaredMethods.toArray(new Method[] {});
1:96d4e06:       foundMethods.addMethodArray(declaredMethods);
1:96d4e06:       clazz = clazz.getSuperclass();
1:96d4e06:     } while (clazz != null);
1:96d4e06:     return foundMethods;
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Test a method marked final
1:96d4e06:    */
1:96d4e06:   @Test
1:96d4e06:   public void testFinalMethod() throws Exception
1:96d4e06:   {
1:96d4e06:     assertNotNull(weavingLoader.loadClass(ProxyTestClassFinalMethod.class
1:96d4e06:         .getName()));
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Test a class marked final
1:96d4e06:    */
1:96d4e06:   @Test
1:96d4e06:   public void testFinalClass() throws Exception
1:96d4e06:   {
1:96d4e06:     assertNotNull(weavingLoader.loadClass(ProxyTestClassFinal.class
1:96d4e06:         .getName()));
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Test a private constructor
1:96d4e06:    */
1:96d4e06:   @Test
1:96d4e06:   public void testPrivateConstructor() throws Exception
1:96d4e06:   {
1:96d4e06:     assertNotNull(weavingLoader.loadClass(ProxyTestClassFinal.class
1:96d4e06:         .getName()));
1:96d4e06:   }
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    * Test a class whose super couldn't be woven
1:96d4e06:    */
1:96d4e06:   @Test
1:96d4e06:   public void testUnweavableSuper() throws Exception
1:96d4e06:   {
1:96d4e06:     Class<?> woven = getProxyClass(ProxyTestClassUnweavableChild.class);
1:96d4e06:     
1:96d4e06:     assertNotNull(woven);
1:96d4e06:     assertNotNull(getProxyInstance(woven));
1:96d4e06:     
1:96d4e06:     TestListener tl = new TestListener();
1:8f852b6:     Object ptcuc = getProxyInstance(woven, tl);
1:96d4e06:     assertCalled(tl, false, false, false);
1:96d4e06:     
1:8f852b6:     Method m = ptcuc.getClass().getMethod("doStuff");
1:8f852b6:     
1:8f852b6:     assertEquals("Hi!", m.invoke(ptcuc));
1:96d4e06:     
1:96d4e06:     assertCalled(tl, true, true, false);
1:96d4e06:     
1:96d4e06:     assertEquals(ProxyTestClassUnweavableGrandParent.class.getMethod("doStuff"), 
1:96d4e06:         tl.getLastMethod());
1:96d4e06:     
1:8f852b6:     tl.clear();
1:96d4e06: 
1:96d4e06:     //Because default access works on the package, and we are defined on a different classloader
1:8f852b6:     //we have to call setAccessible...
1:96d4e06:     
1:8f852b6:     m = getDeclaredMethod(ProxyTestClassUnweavableChild.class, "doStuff2");
1:8f852b6:     m.setAccessible(true);
1:8f852b6:     assertEquals("Hello!", m.invoke(ptcuc));
1:8f852b6:     
1:8f852b6:     assertCalled(tl, true, true, false);
1:8f852b6:     
1:8f852b6:     assertEquals(weavingLoader.loadClass(ProxyTestClassUnweavableSuper.class.getName()).getDeclaredMethod("doStuff2"),
1:8f852b6:     		tl.getLastMethod());
1:96d4e06:   }
1:96d4e06:   
1:96d4e06:   @Test
1:bef949f:   public void testUnweavableSuperWithNoNoargsAllTheWay() throws Exception
1:bef949f:   {
1:88359ce:     try {
1:0ac1890:       getProxyClass(ProxyTestClassUnweavableSibling.class);
1:88359ce:       fail();
1:88359ce:     } catch (RuntimeException re) {
1:88359ce:       assertTrue(re.getCause() instanceof UnableToProxyException);
1:88359ce:       assertEquals(ProxyTestClassUnweavableSibling.class.getName(),
1:88359ce:           ((UnableToProxyException)re.getCause()).getClassName());
1:88359ce:     }
1:bef949f:   }  
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    * Test a class whose super couldn't be woven
1:96d4e06:    */
1:96d4e06:   @Test
1:96d4e06:   public void testUnweavableSuperWithFinalMethod() throws Exception
1:96d4e06:   {
1:96d4e06:     try{
1:96d4e06:       getProxyClass(ProxyTestClassUnweavableChildWithFinalMethodParent.class);
1:88359ce:       fail();
1:96d4e06:     } catch (RuntimeException re) {
1:96d4e06:       assertTrue(re.getCause() instanceof FinalModifierException);
1:96d4e06:       assertEquals(ProxyTestClassUnweavableSuperWithFinalMethod.class.getName(),
1:96d4e06:           ((FinalModifierException)re.getCause()).getClassName());
1:96d4e06:       assertEquals("doStuff2", ((FinalModifierException)re.getCause())
1:96d4e06:           .getFinalMethods());
1:96d4e06:     }
1:96d4e06:   }
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    * Test a class whose super couldn't be woven
1:96d4e06:    */
1:96d4e06:   @Test
1:96d4e06:   public void testUnweavableSuperWithDefaultMethodInWrongPackage() throws Exception
1:96d4e06:   {
1:96d4e06:     try{
1:96d4e06:       getProxyClass(ProxyTestClassUnweavableChildWithDefaultMethodWrongPackageParent.class);
1:88359ce:       fail();
1:96d4e06:     } catch (RuntimeException re) {
1:96d4e06:       assertTrue(re.getCause() instanceof UnableToProxyException);
1:96d4e06:       assertEquals(ProxyTestClassUnweavableSuperWithDefaultMethodWrongPackageParent
1:96d4e06:           .class.getName(), ((UnableToProxyException)re.getCause()).getClassName());
1:96d4e06:     }
1:96d4e06:   }
1:96d4e06:   
1:96d4e06:   @Test
1:88359ce:   public void testInnerWithNoParentNoArgs() throws Exception {
1:88359ce:     //An inner class has no no-args (the parent gets added as an arg) so we can't
1:88359ce:     //get an instance
1:88359ce:     try{
1:88359ce:       getProxyClass(ProxyTestClassUnweavableInnerChild.class);
1:88359ce:       fail();
1:88359ce:     } catch (RuntimeException re) {
1:88359ce:       assertTrue(re.getCause() instanceof UnableToProxyException);
1:88359ce:       assertEquals(ProxyTestClassUnweavableInnerChild.class.getName(), 
1:88359ce:           ((UnableToProxyException)re.getCause()).getClassName());
1:88359ce:     }
1:88359ce:   }
1:88359ce:   
1:f43b433:   @Test(expected=NoSuchFieldException.class)
1:f43b433:   public void testNonSerializableClassHasNoGeneratedSerialVersionUID() throws Exception {
1:8f852b6:     Class<?> woven = getProxyClass(getTestClass());
1:f43b433:     woven.getDeclaredField("serialVersionUID");
1:f43b433:   }
1:f43b433:   
1:bef949f:   @Test
1:8f4b919:   public void testSerialization() throws Exception {
1:8f4b919:     
1:8f4b919:     ProxyTestClassSerializable in = new ProxyTestClassSerializable();
1:8f4b919:     in.value = 5;
1:8f4b919:     
1:8f4b919:     ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:8f4b919:     ObjectOutputStream oos = new ObjectOutputStream(baos);
1:8f4b919:     oos.writeObject(in);
1:8f4b919:     
1:8f4b919:     ProxyTestClassSerializable.checkDeserialization(baos.toByteArray(), 5);
1:8f4b919: 
1:8f4b919:     Class<?> woven = getProxyClass(ProxyTestClassSerializable.class);
1:8f4b919:     
1:8f4b919:     woven.getMethod("checkDeserialization", byte[].class, int.class).invoke(null, baos.toByteArray(), 5);
1:8f4b919:   }
1:0ac1890:   
1:0ac1890:   @Test
1:0857a0e:   public void testInheritedSerialization() throws Exception {
1:0857a0e:     
1:0857a0e:     ProxyTestClassSerializableChild in = new ProxyTestClassSerializableChild();
1:0857a0e:     in.value = 4;
1:0857a0e:     
1:0857a0e:     ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:0857a0e:     ObjectOutputStream oos = new ObjectOutputStream(baos);
1:0857a0e:     oos.writeObject(in);
1:0857a0e:     
1:0857a0e:     ProxyTestClassSerializable.checkDeserialization(baos.toByteArray(), 4);
1:0857a0e: 
1:0857a0e:     Class<?> woven = getProxyClass(ProxyTestClassSerializable.class);
1:0857a0e:     
1:0857a0e:     woven.getMethod("checkDeserialization", byte[].class, int.class).invoke(null, baos.toByteArray(), 4);
1:0857a0e:   }
1:0857a0e:   
1:0857a0e:   @Test
1:0857a0e:   public void testInterfaceInheritedSerialization() throws Exception {
1:0857a0e:     
1:0857a0e:     ProxyTestClassSerializableInterface in = new ProxyTestClassSerializableInterface();
1:0857a0e:     in.value = 3;
1:0857a0e:     
1:0857a0e:     ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:0857a0e:     ObjectOutputStream oos = new ObjectOutputStream(baos);
1:0857a0e:     oos.writeObject(in);
1:0857a0e:     
1:0857a0e:     ProxyTestClassSerializableInterface.checkDeserialization(baos.toByteArray(), 3);
1:0857a0e: 
1:0857a0e:     Class<?> woven = getProxyClass(ProxyTestClassSerializableInterface.class);
1:0857a0e:     
1:0857a0e:     woven.getMethod("checkDeserialization", byte[].class, int.class).invoke(null, baos.toByteArray(), 3);
1:0857a0e:   }
1:0857a0e:   
1:0857a0e:   @Test
1:0ac1890:   public void testGeneratedSVUIDisSynthetic() throws Exception {
1:0ac1890:     
1:0ac1890:     Class<?> woven = getProxyClass(ProxyTestClassSerializable.class);
1:8f4b919:     
1:0ac1890:     assertTrue(woven.getDeclaredField("serialVersionUID").isSynthetic());
1:0ac1890:     
1:0ac1890:     woven = getProxyClass(ProxyTestClassSerializableWithSVUID.class);
1:0ac1890:     
1:0ac1890:     assertFalse(woven.getDeclaredField("serialVersionUID").isSynthetic());
1:0ac1890:   }
1:0ac1890:   
1:14c07d5:   /**
1:14c07d5:    * This test covers a weird case on Mac VMs where we sometimes
1:14c07d5:    * get a ClassCircularityError if a static initializer in a
1:14c07d5:    * non-woven superclass references a subclass that's being
1:14c07d5:    * woven, and gets triggered by the weaving process. Not known
1:14c07d5:    * to fail on IBM or Sun/Oracle VMs
1:14c07d5:    */
1:14c07d5:   @Test
1:14c07d5:   public void testSuperStaticInitOfChild() throws Exception {
1:14c07d5:     Class<?> parent = weavingLoader.loadClass(ProxyTestClassStaticInitOfChildParent.class.getName());
1:14c07d5:     parent.getMethod("doStuff").invoke(null);
1:14c07d5:   }
1:48caea3: 
1:96d4e06:   @Override
1:96d4e06:   protected Object getProxyInstance(Class<?> proxyClass) {
1:96d4e06:     try {
1:d014a6c:       if(proxyClass.getName().equals(ProxyTestClassAbstract.class.getName())) {
1:d014a6c:         Collection<Class<?>> coll = new ArrayList<Class<?>>();
1:d014a6c:         coll.add(proxyClass);
1:d014a6c:         return new AsmProxyManager().createNewProxy(null, coll, new Callable() {
1:d014a6c:           public Object call() throws Exception {
1:d014a6c:             return null;
1:d014a6c:           }}, null);
1:d014a6c:       }
1:96d4e06:       return proxyClass.newInstance();
1:96d4e06:     } catch (Exception e) {
1:96d4e06:       return null;
1:96d4e06:     }
1:96d4e06:   }
1:d014a6c: 
1:96d4e06:   @Override
1:96d4e06:   protected Class<?> getProxyClass(Class<?> clazz) {
1:96d4e06:     try {
1:96d4e06:       return weavingLoader.loadClass(clazz.getName());
1:96d4e06:     } catch (ClassNotFoundException e) {
1:96d4e06:       return null;
1:96d4e06:     }
1:96d4e06:   }
1:14c07d5: 
1:96d4e06:   @Override
1:96d4e06:   protected Object setDelegate(Object proxy, Callable<Object> dispatcher) {
1:96d4e06:     return ((WovenProxy) proxy).
1:96d4e06:     org_apache_aries_proxy_weaving_WovenProxy_createNewProxyInstance(
1:96d4e06:         dispatcher, null);
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   @Override
1:96d4e06:   protected Object getProxyInstance(Class<?> proxyClass,
1:96d4e06:       InvocationListener listener) {
1:96d4e06:     WovenProxy proxy = (WovenProxy) getProxyInstance(proxyClass);
1:96d4e06:     proxy = proxy.org_apache_aries_proxy_weaving_WovenProxy_createNewProxyInstance(
1:96d4e06:         new SingleInstanceDispatcher(proxy), listener);
1:96d4e06:     return proxy;
1:96d4e06:   }
1:96d4e06:   
1:96d4e06:   protected Object getP3() {
1:8f852b6:     return getProxyInstance(getProxyClass(getTestClass()));
1:96d4e06:   }
1:c23df57:   
1:c23df57:   /**
1:c23df57:    * This tests that the Synthesizer ran correctly and the packaged
1:c23df57:    * WovenProxy class has been modified with the synthetic modifier
1:c23df57:    */
1:c23df57:   @Test
1:c23df57:   public void testWovenProxyIsSynthetic(){
1:c23df57:     assertTrue(WovenProxy.class.isSynthetic());
1:c23df57:   }
1:d014a6c:   
1:d014a6c:   /**
1:d014a6c:    * This test checks that we can add interfaces to classes that don't implement
1:d014a6c:    * them using dynamic subclassing. This is a little odd, but it came for
1:d014a6c:    * free with support for proxying abstract classes!
1:d014a6c:    * @throws Exception 
1:d014a6c:    */
1:d014a6c:   @Test
1:d014a6c:   public void testWovenClassPlusInterfaces() throws Exception {
1:d014a6c:     Bundle b = (Bundle) Skeleton.newMock(new Class<?>[] {Bundle.class, ClassLoaderProxy.class});
1:760dac8:     BundleWiring bw = (BundleWiring) Skeleton.newMock(BundleWiring.class);
1:760dac8: 
1:d014a6c:     Skeleton.getSkeleton(b).setReturnValue(new MethodCall(
1:d014a6c:         ClassLoaderProxy.class, "getClassLoader"), weavingLoader);
1:760dac8:     Skeleton.getSkeleton(b).setReturnValue(new MethodCall(
1:760dac8:         ClassLoaderProxy.class, "adapt", BundleWiring.class), bw);
1:760dac8: 
1:d014a6c:     Object toCall = new AsmProxyManager().createDelegatingProxy(b, Arrays.asList(
1:d014a6c:         getProxyClass(ProxyTestClassAbstract.class), Callable.class), new Callable() {
1:d014a6c: 
1:d014a6c:           public Object call() throws Exception {
1:d014a6c:             return weavingLoader.loadClass(ProxyTestClassChildOfAbstract.class.getName()).newInstance();
1:d014a6c:           }
1:d014a6c:       
1:d014a6c:     }, null);
1:d014a6c:     
1:d014a6c:     //Should proxy the abstract method on the class
1:d014a6c:     Method m = getProxyClass(ProxyTestClassAbstract.class).getMethod("getMessage");
1:d014a6c:     assertEquals("Working", m.invoke(toCall));
1:d014a6c:     
1:d014a6c:     //Should be a callable too!
1:d014a6c:     assertEquals("Callable Works too!", ((Callable)toCall).call());
1:d014a6c:     
1:d014a6c:   }
1:96d4e06: }
1:d014a6c: 
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:0737543
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.impl.SystemModuleClassLoader;
/////////////////////////////////////////////////////////////////////////
1:   protected static final ClassLoader weavingLoader = new SystemModuleClassLoader() {
commit:760dac8
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.BundleWiring;
/////////////////////////////////////////////////////////////////////////
1:     BundleWiring bw = (BundleWiring) Skeleton.newMock(BundleWiring.class);
1: 
1:     Skeleton.getSkeleton(b).setReturnValue(new MethodCall(
1:         ClassLoaderProxy.class, "adapt", BundleWiring.class), bw);
1: 
commit:48caea3
/////////////////////////////////////////////////////////////////////////
1: 
author:David Jencks
-------------------------------------------------------------------------------
commit:f80358e
/////////////////////////////////////////////////////////////////////////
1:         bytes = WovenProxyGenerator.getWovenProxy(bytes, this);
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:8f852b6
/////////////////////////////////////////////////////////////////////////
1:   private static final List<Class<?>> CLASSES = Arrays.asList(new Class<?>[]{ProxyTestClassGeneral.class, ProxyTestClassSuper.class,
/////////////////////////////////////////////////////////////////////////
1:   private static final List<Class<?>> OTHER_CLASSES = Arrays.asList(new Class<?>[] {ProxyTestClassUnweavableSuper.class,
1: 		  ProxyTestClassStaticInitOfChildParent.class, ProxyTestClassChildOfAbstract.class});
0:   protected static final ClassLoader weavingLoader = new ClassLoader() {
/////////////////////////////////////////////////////////////////////////
1:    * This test uses the WovenProxyGenerator to generate and load the specified getTestClass().
/////////////////////////////////////////////////////////////////////////
1:     assertTrue("Should be a WovenProxy", WovenProxy.class.isAssignableFrom(getProxyClass(getTestClass())));
/////////////////////////////////////////////////////////////////////////
1:     ProxySubclassMethodHashSet<String> originalMethods = getMethods(getTestClass());
1:         loadClass(getTestClass().getName()));
/////////////////////////////////////////////////////////////////////////
1:     Object ptcuc = getProxyInstance(woven, tl);
1:     Method m = ptcuc.getClass().getMethod("doStuff");
1:     
1:     assertEquals("Hi!", m.invoke(ptcuc));
1:     tl.clear();
1:     //we have to call setAccessible...
1:     m = getDeclaredMethod(ProxyTestClassUnweavableChild.class, "doStuff2");
1:     m.setAccessible(true);
1:     assertEquals("Hello!", m.invoke(ptcuc));
1:     
1:     assertCalled(tl, true, true, false);
1:     
1:     assertEquals(weavingLoader.loadClass(ProxyTestClassUnweavableSuper.class.getName()).getDeclaredMethod("doStuff2"),
1:     		tl.getLastMethod());
/////////////////////////////////////////////////////////////////////////
1:     Class<?> woven = getProxyClass(getTestClass());
/////////////////////////////////////////////////////////////////////////
1:     return getProxyInstance(getProxyClass(getTestClass()));
commit:d014a6c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.impl.AsmProxyManager;
1: import org.apache.aries.unittest.mocks.MethodCall;
1: import org.apache.aries.unittest.mocks.Skeleton;
1: import org.apache.aries.util.ClassLoaderProxy;
1: import org.osgi.framework.Bundle;
/////////////////////////////////////////////////////////////////////////
1:     ProxyTestClassStaticInitOfChild.class, ProxyTestClassAbstract.class});
0:   private static final List<Class<?>> OTHER_CLASSES = Arrays.asList(new Class<?>[] {ProxyTestClassStaticInitOfChildParent.class, ProxyTestClassChildOfAbstract.class});
/////////////////////////////////////////////////////////////////////////
1:       if(proxyClass.getName().equals(ProxyTestClassAbstract.class.getName())) {
1:         Collection<Class<?>> coll = new ArrayList<Class<?>>();
1:         coll.add(proxyClass);
1:         return new AsmProxyManager().createNewProxy(null, coll, new Callable() {
1:           public Object call() throws Exception {
1:             return null;
1:           }}, null);
1:       }
/////////////////////////////////////////////////////////////////////////
1:   
1:   /**
1:    * This test checks that we can add interfaces to classes that don't implement
1:    * them using dynamic subclassing. This is a little odd, but it came for
1:    * free with support for proxying abstract classes!
1:    * @throws Exception 
1:    */
1:   @Test
1:   public void testWovenClassPlusInterfaces() throws Exception {
1:     Bundle b = (Bundle) Skeleton.newMock(new Class<?>[] {Bundle.class, ClassLoaderProxy.class});
1:     
1:     Skeleton.getSkeleton(b).setReturnValue(new MethodCall(
1:         ClassLoaderProxy.class, "getClassLoader"), weavingLoader);
1:     
1:     Object toCall = new AsmProxyManager().createDelegatingProxy(b, Arrays.asList(
1:         getProxyClass(ProxyTestClassAbstract.class), Callable.class), new Callable() {
1: 
1:           public Object call() throws Exception {
1:             return weavingLoader.loadClass(ProxyTestClassChildOfAbstract.class.getName()).newInstance();
1:           }
1:       
1:     }, null);
1:     
1:     //Should proxy the abstract method on the class
1:     Method m = getProxyClass(ProxyTestClassAbstract.class).getMethod("getMessage");
1:     assertEquals("Working", m.invoke(toCall));
1:     
1:     //Should be a callable too!
1:     assertEquals("Callable Works too!", ((Callable)toCall).call());
1:     
1:   }
commit:14c07d5
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:   private static final List<Class<?>> CLASSES = Arrays.asList(new Class<?>[]{TEST_CLASS, ProxyTestClassSuper.class,
/////////////////////////////////////////////////////////////////////////
1:     ProxyTestClassSerializableChild.class, ProxyTestClassSerializableInterface.class,
0:     ProxyTestClassStaticInitOfChild.class});
1:   
1:   /** An array of classes that are loaded by the WeavingLoader, but not actually woven **/
0:   private static final List<Class<?>> OTHER_CLASSES = Arrays.asList(new Class<?>[] {ProxyTestClassStaticInitOfChildParent.class});
/////////////////////////////////////////////////////////////////////////
1:       boolean weave = false;
1:       
1:       for(Class<?> c : CLASSES) {
1:         if(c.getName().equals(className)) {
1:           weave = true;
1:           break;
1:         }
1:       }
1:       if(weave)
0:         bytes = WovenProxyGenerator.getWovenProxy(bytes, className, this);
/////////////////////////////////////////////////////////////////////////
1:     List<Class<?>> classes = new ArrayList(CLASSES.size() + OTHER_CLASSES.size());
1:     
1:     classes.addAll(CLASSES);
1:     classes.addAll(OTHER_CLASSES);
1:     
1:     for(Class<?> clazz : classes) {
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * This test covers a weird case on Mac VMs where we sometimes
1:    * get a ClassCircularityError if a static initializer in a
1:    * non-woven superclass references a subclass that's being
1:    * woven, and gets triggered by the weaving process. Not known
1:    * to fail on IBM or Sun/Oracle VMs
1:    */
1:   @Test
1:   public void testSuperStaticInitOfChild() throws Exception {
1:     Class<?> parent = weavingLoader.loadClass(ProxyTestClassStaticInitOfChildParent.class.getName());
1:     parent.getMethod("doStuff").invoke(null);
1:   }
1:   
commit:0857a0e
/////////////////////////////////////////////////////////////////////////
1:     ProxyTestClassSerializable.class, ProxyTestClassSerializableWithSVUID.class,
0:     ProxyTestClassSerializableChild.class, ProxyTestClassSerializableInterface.class};
/////////////////////////////////////////////////////////////////////////
1:   public void testInheritedSerialization() throws Exception {
1:     
1:     ProxyTestClassSerializableChild in = new ProxyTestClassSerializableChild();
1:     in.value = 4;
1:     
1:     ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:     ObjectOutputStream oos = new ObjectOutputStream(baos);
1:     oos.writeObject(in);
1:     
1:     ProxyTestClassSerializable.checkDeserialization(baos.toByteArray(), 4);
1: 
1:     Class<?> woven = getProxyClass(ProxyTestClassSerializable.class);
1:     
1:     woven.getMethod("checkDeserialization", byte[].class, int.class).invoke(null, baos.toByteArray(), 4);
1:   }
1:   
1:   @Test
1:   public void testInterfaceInheritedSerialization() throws Exception {
1:     
1:     ProxyTestClassSerializableInterface in = new ProxyTestClassSerializableInterface();
1:     in.value = 3;
1:     
1:     ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:     ObjectOutputStream oos = new ObjectOutputStream(baos);
1:     oos.writeObject(in);
1:     
1:     ProxyTestClassSerializableInterface.checkDeserialization(baos.toByteArray(), 3);
1: 
1:     Class<?> woven = getProxyClass(ProxyTestClassSerializableInterface.class);
1:     
1:     woven.getMethod("checkDeserialization", byte[].class, int.class).invoke(null, baos.toByteArray(), 3);
1:   }
1:   
1:   @Test
commit:f43b433
/////////////////////////////////////////////////////////////////////////
1:   @Test(expected=NoSuchFieldException.class)
1:   public void testNonSerializableClassHasNoGeneratedSerialVersionUID() throws Exception {
0:     Class<?> woven = getProxyClass(TEST_CLASS);
1:     woven.getDeclaredField("serialVersionUID");
1:   }
1:   
commit:c23df57
/////////////////////////////////////////////////////////////////////////
1:   
1:   /**
1:    * This tests that the Synthesizer ran correctly and the packaged
1:    * WovenProxy class has been modified with the synthetic modifier
1:    */
1:   @Test
1:   public void testWovenProxyIsSynthetic(){
1:     assertTrue(WovenProxy.class.isSynthetic());
1:   }
commit:0ac1890
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertFalse;
/////////////////////////////////////////////////////////////////////////
1:     ProxyTestClassUnweavableChildWithDefaultMethodWrongPackageParent.class, 
0:     ProxyTestClassSerializable.class, ProxyTestClassSerializableWithSVUID.class};
/////////////////////////////////////////////////////////////////////////
1:       getProxyClass(ProxyTestClassUnweavableSibling.class);
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testGeneratedSVUIDisSynthetic() throws Exception {
1:     
1:     Class<?> woven = getProxyClass(ProxyTestClassSerializable.class);
1:     
1:     assertTrue(woven.getDeclaredField("serialVersionUID").isSynthetic());
1:     
1:     woven = getProxyClass(ProxyTestClassSerializableWithSVUID.class);
1:     
1:     assertFalse(woven.getDeclaredField("serialVersionUID").isSynthetic());
1:   }
1:   
commit:8f4b919
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
0: import java.io.IOException;
0: import java.io.ObjectInputStream;
1: import java.io.ObjectOutputStream;
/////////////////////////////////////////////////////////////////////////
0:     ProxyTestClassUnweavableChildWithDefaultMethodWrongPackageParent.class, ProxyTestClassSerializable.class};
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testSerialization() throws Exception {
1:     
1:     ProxyTestClassSerializable in = new ProxyTestClassSerializable();
1:     in.value = 5;
1:     
1:     ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:     ObjectOutputStream oos = new ObjectOutputStream(baos);
1:     oos.writeObject(in);
1:     
1:     ProxyTestClassSerializable.checkDeserialization(baos.toByteArray(), 5);
1: 
1:     Class<?> woven = getProxyClass(ProxyTestClassSerializable.class);
1:     
1:     woven.getMethod("checkDeserialization", byte[].class, int.class).invoke(null, baos.toByteArray(), 5);
1:   }
1:   
commit:88359ce
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.fail;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.proxy.ProxyTestClassInnerClasses.ProxyTestClassInner;
1: import org.apache.aries.blueprint.proxy.ProxyTestClassInnerClasses.ProxyTestClassStaticInner;
1: import org.apache.aries.blueprint.proxy.ProxyTestClassInnerClasses.ProxyTestClassUnweavableInnerChild;
/////////////////////////////////////////////////////////////////////////
1:   /** An array of classes that will be woven - note no UnweavableParents should be in here! */
1:     ProxyTestClassUnweavableChild.class, ProxyTestClassUnweavableSibling.class, ProxyTestClassInner.class, 
1:     ProxyTestClassStaticInner.class, ProxyTestClassUnweavableInnerChild.class, 
1:     ProxyTestClassUnweavableChildWithFinalMethodParent.class, 
0:     ProxyTestClassUnweavableChildWithDefaultMethodWrongPackageParent.class};
/////////////////////////////////////////////////////////////////////////
1:     try {
0:       Class<?> woven = getProxyClass(ProxyTestClassUnweavableSibling.class);
1:       fail();
1:     } catch (RuntimeException re) {
1:       assertTrue(re.getCause() instanceof UnableToProxyException);
1:       assertEquals(ProxyTestClassUnweavableSibling.class.getName(),
1:           ((UnableToProxyException)re.getCause()).getClassName());
1:     }
/////////////////////////////////////////////////////////////////////////
1:       fail();
/////////////////////////////////////////////////////////////////////////
1:       fail();
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testInnerWithNoParentNoArgs() throws Exception {
1:     //An inner class has no no-args (the parent gets added as an arg) so we can't
1:     //get an instance
1:     try{
1:       getProxyClass(ProxyTestClassUnweavableInnerChild.class);
1:       fail();
1:     } catch (RuntimeException re) {
1:       assertTrue(re.getCause() instanceof UnableToProxyException);
1:       assertEquals(ProxyTestClassUnweavableInnerChild.class.getName(), 
1:           ((UnableToProxyException)re.getCause()).getClassName());
1:     }
1:   }
1:   
commit:2d7219c
/////////////////////////////////////////////////////////////////////////
1: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected URL findResource(String resName) {
1:       return WovenProxyGeneratorTest.class.getResource(resName);
1:     }
commit:96d4e06
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.blueprint.proxy;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertTrue;
1: 
1: import java.io.ByteArrayOutputStream;
1: import java.io.InputStream;
1: import java.lang.reflect.Method;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.Callable;
1: 
1: import org.apache.aries.blueprint.proxy.pkg.ProxyTestClassUnweavableSuperWithDefaultMethodWrongPackageParent;
1: import org.apache.aries.proxy.FinalModifierException;
1: import org.apache.aries.proxy.InvocationListener;
1: import org.apache.aries.proxy.UnableToProxyException;
1: import org.apache.aries.proxy.impl.SingleInstanceDispatcher;
1: import org.apache.aries.proxy.impl.gen.ProxySubclassMethodHashSet;
1: import org.apache.aries.proxy.impl.weaving.WovenProxyGenerator;
1: import org.apache.aries.proxy.weaving.WovenProxy;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: 
1: 
1: public class WovenProxyGeneratorTest extends AbstractProxyTest
1: {
1:   private static final String hexPattern = "[0-9_a-f]";
1:   private static final int[] uuid_pattern = new int[] {8,4,4,4,12};
1:   private static final String regexp;
1:   
1:   static {
1:     StringBuilder sb = new StringBuilder(".*");
1:     for(int i : uuid_pattern) {
1:       for(int j = 0; j < i; j++){
1:         sb.append(hexPattern);
1:       }
1:       sb.append("_");
1:     }
1:     sb.deleteCharAt(sb.length() -1);
1:     sb.append("\\d*");
1:     regexp = sb.toString();
1:   }
1:   
1: 
0:   private static final Class<?>[] CLASSES = new Class<?>[]{TEST_CLASS, ProxyTestClassSuper.class,
1:     ProxyTestClassFinalMethod.class, ProxyTestClassFinal.class, ProxyTestClassGeneric.class,
1:     ProxyTestClassGenericSuper.class, ProxyTestClassCovariant.class, ProxyTestClassCovariantOverride.class,
0:     ProxyTestClassUnweavableChild.class, ProxyTestClassUnweavableSuperWithFinalMethod.class,
0:     ProxyTestClassUnweavableChildWithDefaultMethodWrongPackageParent.class};
1:  
1:   private static final Map<String, byte[]> rawClasses = new HashMap<String, byte[]>();
1:   
0:   private static Class<?> WOVEN_TEST_CLASS;
1:   
0:   private static final ClassLoader weavingLoader = new ClassLoader() {
1:     public Class<?> loadClass(String className)  throws ClassNotFoundException
1:     {
1:       return loadClass(className, false);
1:     }
1:     public Class<?> loadClass(String className, boolean b) throws ClassNotFoundException
1:     {
1:       if (!!!className.startsWith("org.apache.aries.blueprint.proxy.ProxyTest")){
1:         return Class.forName(className);
1:       }
1:       
1:       Class<?> clazz = findLoadedClass(className);
1:       if(clazz != null)
1:         return clazz;
1:       
1:       byte[] bytes = rawClasses.get(className);
1:       if(bytes == null)
1:         return super.loadClass(className, b);
1:       
0:       bytes = WovenProxyGenerator.getWovenProxy(bytes, className, this);
1:       
1:       return defineClass(className, bytes, 0, bytes.length);
1:     }
1:   };
1:    
1:   /**
1:    * @throws java.lang.Exception
1:    */
1:   @BeforeClass
1:   public static void setUp() throws Exception
1:   {
0:     for(Class<?> clazz : CLASSES) {
1:       InputStream is = clazz.getClassLoader().getResourceAsStream(
1:           clazz.getName().replace('.', '/') + ".class");
1:       ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:       
1:       byte[] buffer = new byte[2048];
1:       int read = is.read(buffer);
1:       while(read != -1) {
1:         baos.write(buffer, 0, read);
1:         read = is.read(buffer);
1:       }
1:       rawClasses.put(clazz.getName(), baos.toByteArray());
1:     }
0:     WOVEN_TEST_CLASS = weavingLoader.loadClass(TEST_CLASS.getName());
1:   }
1: 
1:   /**
0:    * This test uses the WovenProxyGenerator to generate and load the specified TEST_CLASS.
1:    * 
1:    * Once the subclass is generated we check that it wasn't null. 
1:    * 
1:    * Test method for
1:    * {@link WovenProxyGenerator#getProxySubclass(byte[], String)}.
1:    */
1:   @Test
1:   public void testGenerateAndLoadProxy() throws Exception
1:   {
1:     super.testGenerateAndLoadProxy();
0:     assertTrue("Should be a WovenProxy", WovenProxy.class.isAssignableFrom(getProxyClass(TEST_CLASS)));
1:   }
1: 
1:   /**
1:    * Test that the methods found declared on the generated proxy are
1:    * the ones that we expect.
1:    */
1:   @Test
1:   public void testExpectedMethods() throws Exception
1:   {
0:     ProxySubclassMethodHashSet<String> originalMethods = getMethods(TEST_CLASS);
1: 
1:     ProxySubclassMethodHashSet<String> generatedMethods = getMethods(weavingLoader.
0:         loadClass(TEST_CLASS.getName()));
1: 
1:     // check that all the methods we have generated were expected
1:     for (String gen : generatedMethods) {
1:       assertTrue("Unexpected method: " + gen, originalMethods.contains(gen));
1:     }
1:     // check that all the expected methods were generated
1:     for (String exp : originalMethods) {
1:       assertTrue("Method was not generated: " + exp, generatedMethods.contains(exp));
1:     }
1:     // check the sets were the same
1:     assertEquals("Sets were not the same", originalMethods, generatedMethods);
1:   }
1: 
1:   private ProxySubclassMethodHashSet<String> getMethods(Class<?> clazz) {
1:     
1:     ProxySubclassMethodHashSet<String> foundMethods = 
1:       new ProxySubclassMethodHashSet<String>(12);
1:     do {
1:       Method[] declaredMethods = clazz.getDeclaredMethods();
1:       List<Method> listOfDeclaredMethods = new ArrayList<Method>();
1:       for (Method m : declaredMethods) {
1:         if(m.getName().startsWith(WovenProxy.class.getName().replace('.', '_')) ||
1:             m.getName().startsWith("getListener") || m.getName().startsWith("getInvocationTarget") ||
1:             //four hex digits
1:             m.getName().matches(regexp))
1:           continue;
1:         
1:         listOfDeclaredMethods.add(m);
1:       }
1:       declaredMethods = listOfDeclaredMethods.toArray(new Method[] {});
1:       foundMethods.addMethodArray(declaredMethods);
1:       clazz = clazz.getSuperclass();
1:     } while (clazz != null);
1:     return foundMethods;
1:   }
1: 
1:   /**
1:    * Test a method marked final
1:    */
1:   @Test
1:   public void testFinalMethod() throws Exception
1:   {
1:     assertNotNull(weavingLoader.loadClass(ProxyTestClassFinalMethod.class
1:         .getName()));
1:   }
1: 
1:   /**
1:    * Test a class marked final
1:    */
1:   @Test
1:   public void testFinalClass() throws Exception
1:   {
1:     assertNotNull(weavingLoader.loadClass(ProxyTestClassFinal.class
1:         .getName()));
1:   }
1: 
1:   /**
1:    * Test a private constructor
1:    */
1:   @Test
1:   public void testPrivateConstructor() throws Exception
1:   {
1:     assertNotNull(weavingLoader.loadClass(ProxyTestClassFinal.class
1:         .getName()));
1:   }
1:   
1:   /**
1:    * Test a class whose super couldn't be woven
1:    */
1:   @Test
1:   public void testUnweavableSuper() throws Exception
1:   {
1:     Class<?> woven = getProxyClass(ProxyTestClassUnweavableChild.class);
1:     
1:     assertNotNull(woven);
1:     assertNotNull(getProxyInstance(woven));
1:     
1:     TestListener tl = new TestListener();
0:     ProxyTestClassUnweavableSuper ptcuc = (ProxyTestClassUnweavableSuper) getProxyInstance(woven, tl);
1:     assertCalled(tl, false, false, false);
1:     
0:     assertEquals("Hi!", ptcuc.doStuff());
1:     
1:     assertCalled(tl, true, true, false);
1:     
1:     assertEquals(ProxyTestClassUnweavableGrandParent.class.getMethod("doStuff"), 
1:         tl.getLastMethod());
1:     
1: 
1:     //Because default access works on the package, and we are defined on a different classloader
0:     //we can only check that the method exists, not that it is callable *sigh*
1:     
0:     assertNotNull(ProxyTestClassUnweavableSuper.class.getDeclaredMethod("doStuff2"));
1:   }
1:   
1:   /**
1:    * Test a class whose super couldn't be woven
1:    */
1:   @Test
1:   public void testUnweavableSuperWithFinalMethod() throws Exception
1:   {
1:     try{
1:       getProxyClass(ProxyTestClassUnweavableChildWithFinalMethodParent.class);
1:     } catch (RuntimeException re) {
1:       assertTrue(re.getCause() instanceof FinalModifierException);
1:       assertEquals(ProxyTestClassUnweavableSuperWithFinalMethod.class.getName(),
1:           ((FinalModifierException)re.getCause()).getClassName());
1:       assertEquals("doStuff2", ((FinalModifierException)re.getCause())
1:           .getFinalMethods());
1:     }
1:   }
1:   
1:   /**
1:    * Test a class whose super couldn't be woven
1:    */
1:   @Test
1:   public void testUnweavableSuperWithDefaultMethodInWrongPackage() throws Exception
1:   {
1:     try{
1:       getProxyClass(ProxyTestClassUnweavableChildWithDefaultMethodWrongPackageParent.class);
1:     } catch (RuntimeException re) {
1:       assertTrue(re.getCause() instanceof UnableToProxyException);
1:       assertEquals(ProxyTestClassUnweavableSuperWithDefaultMethodWrongPackageParent
1:           .class.getName(), ((UnableToProxyException)re.getCause()).getClassName());
1:     }
1:   }
1:   
1:   @Override
1:   protected Object getProxyInstance(Class<?> proxyClass) {
1:     try {
1:       return proxyClass.newInstance();
1:     } catch (Exception e) {
1:       return null;
1:     }
1:   }
1: 
1:   @Override
1:   protected Class<?> getProxyClass(Class<?> clazz) {
1:     try {
1:       return weavingLoader.loadClass(clazz.getName());
1:     } catch (ClassNotFoundException e) {
1:       return null;
1:     }
1:   }
1: 
1:   @Override
1:   protected Object setDelegate(Object proxy, Callable<Object> dispatcher) {
1:     return ((WovenProxy) proxy).
1:     org_apache_aries_proxy_weaving_WovenProxy_createNewProxyInstance(
1:         dispatcher, null);
1:   }
1: 
1:   @Override
1:   protected Object getProxyInstance(Class<?> proxyClass,
1:       InvocationListener listener) {
1:     WovenProxy proxy = (WovenProxy) getProxyInstance(proxyClass);
1:     proxy = proxy.org_apache_aries_proxy_weaving_WovenProxy_createNewProxyInstance(
1:         new SingleInstanceDispatcher(proxy), listener);
1:     return proxy;
1:   }
1:   
1:   protected Object getP3() {
0:     return getProxyInstance(getProxyClass(TEST_CLASS));
1:   }
1: }
1: 
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:bef949f
/////////////////////////////////////////////////////////////////////////
0:     ProxyTestClassUnweavableChildWithDefaultMethodWrongPackageParent.class, ProxyTestClassUnweavableSibling.class};
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testUnweavableSuperWithNoNoargsAllTheWay() throws Exception
1:   {
0:     Class<?> woven = getProxyClass(ProxyTestClassUnweavableSibling.class);
0:     
0:     assertNotNull(woven);
0:     assertNotNull(woven.getConstructor(int.class).newInstance(42));
0:     
0:     TestListener tl = new TestListener();
0:     
0:     WovenProxy proxy = (WovenProxy) woven.getConstructor(int.class).newInstance(42);
0:     proxy = proxy.org_apache_aries_proxy_weaving_WovenProxy_createNewProxyInstance(
0:             new SingleInstanceDispatcher(proxy), tl);
0:     
0:     ProxyTestClassUnweavableSuper ptcuc = (ProxyTestClassUnweavableSuper) proxy;
0:     assertCalled(tl, false, false, false);
0:     
0:     assertEquals("Hi!", ptcuc.doStuff());
0:     
0:     assertCalled(tl, true, true, false);
0:     
0:     assertEquals(ProxyTestClassUnweavableGrandParent.class.getMethod("doStuff"), 
0:         tl.getLastMethod());
0:     
0: 
0:     //Because default access works on the package, and we are defined on a different classloader
0:     //we can only check that the method exists, not that it is callable *sigh*
0:     
0:     assertNotNull(ProxyTestClassUnweavableSuper.class.getDeclaredMethod("doStuff2"));
1:   }  
0:   
============================================================================