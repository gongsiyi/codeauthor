1:47d4583: /*
1:47d4583:  * Licensed to the Apache Software Foundation (ASF) under one
1:47d4583:  * or more contributor license agreements.  See the NOTICE file
1:47d4583:  * distributed with this work for additional information
1:47d4583:  * regarding copyright ownership.  The ASF licenses this file
1:47d4583:  * to you under the Apache License, Version 2.0 (the
1:47d4583:  * "License"); you may not use this file except in compliance
1:47d4583:  * with the License.  You may obtain a copy of the License at
1:47d4583:  *
1:47d4583:  *   http://www.apache.org/licenses/LICENSE-2.0
1:47d4583:  *
1:47d4583:  * Unless required by applicable law or agreed to in writing,
1:47d4583:  * software distributed under the License is distributed on an
1:47d4583:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:47d4583:  * KIND, either express or implied.  See the License for the
1:47d4583:  * specific language governing permissions and limitations
1:47d4583:  * under the License.
1:47d4583:  */
1:47d4583: 
1:47d4583: package org.apache.aries.application.impl;
1:47d4583: 
1:0e0fd84: import java.io.File;
1:92ce70e: import java.io.FileNotFoundException;
1:92ce70e: import java.io.FileOutputStream;
1:92ce70e: import java.io.IOException;
1:0e0fd84: import java.io.OutputStream;
1:0e0fd84: import java.util.ArrayList;
1:9c133a0: import java.util.Collection;
1:0e0fd84: import java.util.Collections;
1:ad46961: import java.util.HashMap;
1:9c133a0: import java.util.HashSet;
1:47d4583: import java.util.List;
1:5297b83: import java.util.Map;
1:0e0fd84: import java.util.Set;
1:92ce70e: import java.util.jar.Attributes;
1:92ce70e: import java.util.jar.Manifest;
1:47d4583: 
1:47d4583: import org.apache.aries.application.ApplicationMetadata;
1:5297b83: import org.apache.aries.application.Content;
1:47d4583: import org.apache.aries.application.DeploymentContent;
1:47d4583: import org.apache.aries.application.DeploymentMetadata;
1:89f804e: import org.apache.aries.application.InvalidAttributeException;
1:0e0fd84: import org.apache.aries.application.management.AriesApplication;
1:0e0fd84: import org.apache.aries.application.management.BundleInfo;
1:ad46961: import org.apache.aries.application.management.ResolverException;
1:92ce70e: import org.apache.aries.application.utils.AppConstants;
1:9c133a0: import org.apache.aries.application.utils.FilterUtils;
1:910fec0: import org.apache.aries.util.VersionRange;
1:910fec0: import org.apache.aries.util.manifest.ManifestProcessor;
1:9c133a0: import org.osgi.framework.Filter;
1:9c133a0: import org.osgi.framework.FrameworkUtil;
1:9c133a0: import org.osgi.framework.InvalidSyntaxException;
1:47d4583: import org.osgi.framework.Version;
1:0e0fd84: 
1:47d4583: public class DeploymentMetadataImpl implements DeploymentMetadata {
1:ad46961:   private ApplicationMetadata _applicationMetadata;
1:ad46961:   private List<DeploymentContent> _deploymentContent = new ArrayList<DeploymentContent>();
1:ad46961:   private List<DeploymentContent> _provisionSharedContent = new ArrayList<DeploymentContent>();
1:9c133a0:   private List<DeploymentContent> _deployedUseBundleContent = new ArrayList<DeploymentContent>();
1:9c133a0:   
1:9c133a0:   private Set<Content> _deploymentImportPackage = new HashSet<Content>();
1:9c133a0:   private Map<String, String> _deploymentCustomEntries = new HashMap<String, String>();  
1:9c133a0:   private Map<String, String> _deploymentEntries = new HashMap<String, String>();
1:9c133a0:   private Collection<Filter> _deployedImportService = new ArrayList<Filter>();
1:0e0fd84:   
1:ad46961:   public DeploymentMetadataImpl (AriesApplication app, Set<BundleInfo> bundlesRequired) throws ResolverException
1:ad46961:   {
1:0e0fd84:     _applicationMetadata = app.getApplicationMetadata();
1:ffe1828:     _deploymentContent = new ArrayList<DeploymentContent>();
1:ad46961:     _provisionSharedContent = new ArrayList<DeploymentContent>();
1:9c133a0:     _deployedUseBundleContent = new ArrayList<DeploymentContent>();
1:5297b83:     
1:ad46961:     Map<String, VersionRange> appContent = new HashMap<String, VersionRange>();
1:47d4583:     
1:ad46961:     for (Content c : app.getApplicationMetadata().getApplicationContents()) {
1:ad46961:       appContent.put(c.getContentName(), c.getVersion());
1:5297b83:     }
1:ffe1828:     
1:9c133a0:     Map<String, VersionRange> useBundles = new HashMap<String, VersionRange>();
1:9c133a0:     for (Content c : app.getApplicationMetadata().getUseBundles()) {
1:9c133a0:       useBundles.put(c.getContentName(), c.getVersion());
1:9c133a0:     }
1:9c133a0:     
1:ad46961:     for (BundleInfo info : bundlesRequired) {
1:47d4583:       
1:9c133a0:       VersionRange appContentRange = appContent.get(info.getSymbolicName());
1:9c133a0:       VersionRange useBundleRange = useBundles.get(info.getSymbolicName());
1:ad46961:       DeploymentContent dp = new DeploymentContentImpl(info.getSymbolicName(), info.getVersion());
1:47d4583:       
1:9c133a0:       if ((appContentRange == null) && (useBundleRange == null)){
1:ad46961:         _provisionSharedContent.add(dp);
1:9c133a0:       } else if (appContentRange.matches(info.getVersion())) {
1:ad46961:         _deploymentContent.add(dp);
1:9c133a0:       }  else if (useBundleRange.matches(info.getVersion())) {
1:9c133a0:         _deployedUseBundleContent.add(dp);
1:9c133a0:       }
1:9c133a0:       else {
1:9c133a0:         throw new ResolverException("Bundle " + info.getSymbolicName() + " at version " + info.getVersion() + " is not in the range " + appContentRange + " or " + useBundleRange);
1:0e0fd84:       }
1:0e0fd84:     }
1:47d4583:   }
1:47d4583:   
1:ffe1828:   /**
1:ba73ed7:    * Construct a DeploymentMetadata from Manifest
1:ffe1828:    * @param src
1:ffe1828:    * @throws IOException
1:ffe1828:    */
1:9c133a0:   public DeploymentMetadataImpl(Manifest mf) throws InvalidAttributeException{ 
1:ffe1828:     _applicationMetadata = new ApplicationMetadataImpl (mf);
1:ffe1828: 
1:ffe1828:     Attributes attributes = mf.getMainAttributes();
19:8914925:       
1:9c133a0:     parseDeploymentContent(attributes.getValue(AppConstants.DEPLOYMENT_CONTENT), _deploymentContent);
1:9c133a0:     parseDeploymentContent(attributes.getValue(AppConstants.DEPLOYMENT_PROVISION_BUNDLE), _provisionSharedContent);
1:9c133a0:     parseDeploymentContent(attributes.getValue(AppConstants.DEPLOYMENT_USE_BUNDLE), _deployedUseBundleContent);
1:9c133a0:     parseContent(attributes.getValue(AppConstants.DEPLOYMENT_IMPORT_PACKAGES), _deploymentImportPackage);
1:9c133a0:     
1:9c133a0:     _deployedImportService = getFilters(attributes.getValue(AppConstants.DEPLOYMENTSERVICE_IMPORT));
1:9c133a0:     _deploymentCustomEntries = getCustomEntries(attributes);
1:9c133a0:     _deploymentEntries = getEntries(attributes);
1:9c133a0:   }
1:9c133a0:   
1:9c133a0:   public DeploymentMetadataImpl(Map<String, String> map) throws InvalidAttributeException{ 
1:9c133a0: 
1:9c133a0:     Attributes attributes = new Attributes();
1:9c133a0:     if (map != null) {
1:9c133a0:     for (Map.Entry<String, String> entry : map.entrySet()) {
1:9c133a0:       attributes.putValue(entry.getKey(), entry.getValue());
1:9c133a0:     }
1:9c133a0:     }
1:9c133a0:     parseDeploymentContent(map.get(AppConstants.DEPLOYMENT_CONTENT), _deploymentContent);
1:9c133a0:     parseDeploymentContent(map.get(AppConstants.DEPLOYMENT_PROVISION_BUNDLE), _provisionSharedContent);
1:9c133a0:     parseDeploymentContent(map.get(AppConstants.DEPLOYMENT_USE_BUNDLE), _deployedUseBundleContent);
1:9c133a0:     parseContent(attributes.getValue(AppConstants.DEPLOYMENT_IMPORT_PACKAGES), _deploymentImportPackage);
1:9c133a0:     _deployedImportService = getFilters(attributes.getValue(AppConstants.DEPLOYMENTSERVICE_IMPORT));
1:9c133a0:     _deploymentCustomEntries = getCustomEntries(attributes);
1:9c133a0:     _deploymentEntries = getEntries(attributes);
1:9c133a0:     
1:ffe1828:   }
1:8914925: 
1:9c133a0:   private Collection<Attributes.Name> getDeploymentStandardHeaders() {
1:9c133a0:     Collection<Attributes.Name> standardKeys = new HashSet<Attributes.Name> ();
1:9c133a0:     standardKeys.add(new Attributes.Name(AppConstants.APPLICATION_MANIFEST_VERSION));
1:9c133a0:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENT_CONTENT));
1:9c133a0:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENT_PROVISION_BUNDLE));
1:9c133a0:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENT_USE_BUNDLE));
1:9c133a0:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENT_IMPORT_PACKAGES));
1:9c133a0:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENTSERVICE_IMPORT));
1:9c133a0:     standardKeys.add(new Attributes.Name(AppConstants.APPLICATION_SYMBOLIC_NAME));
1:9c133a0:     standardKeys.add(new Attributes.Name(AppConstants.APPLICATION_VERSION));
1:9c133a0:     return standardKeys;
1:9c133a0:   }
1:9c133a0: 
1:9c133a0:   private Collection<String> getCustomHeaders(Attributes attrs) {
1:9c133a0:     
1:9c133a0:     Collection<String> customKeys = new HashSet<String>();
1:9c133a0:     Collection<Attributes.Name> standardKeys = getDeploymentStandardHeaders();
1:9c133a0:     if ((attrs != null) && (!!!attrs.isEmpty())) {
1:9c133a0:      Set<Object> keys = attrs.keySet();
1:9c133a0:      
1:9c133a0:      if ((keys != null) && (!!!keys.isEmpty())) {
1:9c133a0:        for (Object eachKey : keys) {
1:9c133a0:          String key = eachKey.toString();
1:9c133a0:          customKeys.add(key);
1:9c133a0:        }
1:9c133a0:        
1:9c133a0:          customKeys.removeAll(standardKeys);
1:9c133a0:        
1:9c133a0:      }
1:9c133a0:     }
1:9c133a0:     return customKeys;
1:9c133a0:   }
1:9c133a0:   
1:9c133a0:   private String getContentsAsString (Collection<Content> contents) {
1:9c133a0:     StringBuilder builder = new StringBuilder();
1:9c133a0:     boolean beginning = true;
1:9c133a0:     for (Content c : contents) {
1:9c133a0:       if (!!!beginning) {
1:9c133a0:         builder.append(",");
1:9c133a0:       }
1:9c133a0:       builder.append(c);
1:9c133a0:       beginning = false;
1:9c133a0:       
1:9c133a0:     }
1:9c133a0:     return builder.toString();
1:9c133a0:   }
1:9c133a0:   
1:47d4583:   public List<DeploymentContent> getApplicationDeploymentContents() {
1:0e0fd84:     return Collections.unmodifiableList(_deploymentContent);
1:ffe1828:   }
1:47d4583:   
1:ad46961:   public List<DeploymentContent> getApplicationProvisionBundles() {
1:ad46961:     return Collections.unmodifiableList(_provisionSharedContent);
1:ffe1828:   }
1:47d4583: 
1:47d4583:   public ApplicationMetadata getApplicationMetadata() {
1:0e0fd84:     return _applicationMetadata;
1:47d4583:   }
1:0e0fd84: 
1:47d4583:   public String getApplicationSymbolicName() {
1:0e0fd84:     return _applicationMetadata.getApplicationSymbolicName();
1:47d4583:   }
1:0e0fd84: 
1:47d4583:   public Version getApplicationVersion() {
1:0e0fd84:     return _applicationMetadata.getApplicationVersion();
1:0e0fd84:   }
1:0e0fd84: 
1:0e0fd84: 
1:92ce70e:   public void store(File f) throws FileNotFoundException, IOException{
1:92ce70e:     FileOutputStream fos = new FileOutputStream (f);
1:92ce70e:     store(fos);
1:92ce70e:     fos.close();
1:0e0fd84:   }
1:0e0fd84: 
1:92ce70e:   public void store(OutputStream out) throws IOException {
1:92ce70e:     // We weren't built from a Manifest, so construct one. 
1:92ce70e:     Manifest mf = new Manifest();
1:92ce70e:     Attributes attributes = mf.getMainAttributes();
1:92ce70e:     attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), AppConstants.MANIFEST_VERSION);
1:92ce70e:     attributes.putValue(AppConstants.APPLICATION_VERSION, getApplicationVersion().toString());
1:92ce70e:     attributes.putValue(AppConstants.APPLICATION_SYMBOLIC_NAME, getApplicationSymbolicName());
1:9c133a0:     if ((_deploymentContent != null) && (!_deploymentContent.isEmpty())) {
1:ba73ed7:       attributes.putValue(AppConstants.DEPLOYMENT_CONTENT, getDeploymentContentsAsString(_deploymentContent));
1:47d4583:     }
1:9c133a0:     if ((_provisionSharedContent != null) && (!_provisionSharedContent.isEmpty())) {
1:9c133a0:       attributes.putValue(AppConstants.DEPLOYMENT_PROVISION_BUNDLE, getDeploymentContentsAsString(_provisionSharedContent));
1:9c133a0:     }
1:9c133a0:     if ((_deployedUseBundleContent != null) && (!_deployedUseBundleContent.isEmpty())) {
1:9c133a0:       attributes.putValue(AppConstants.DEPLOYMENT_USE_BUNDLE, getDeploymentContentsAsString(_deployedUseBundleContent));
1:9c133a0:     }
1:9c133a0:     if ((_deploymentImportPackage != null) && (!_deploymentImportPackage.isEmpty())) {
1:9c133a0:       attributes.putValue(AppConstants.DEPLOYMENT_IMPORT_PACKAGES, getContentsAsString(_deploymentImportPackage));
1:9c133a0:     }
1:9c133a0:     if ((_deployedImportService != null) && (!!!_deployedImportService.isEmpty())) {
1:9c133a0:       attributes.putValue(AppConstants.DEPLOYMENTSERVICE_IMPORT, convertFiltersToString(_deployedImportService, ",") );
1:9c133a0:     }
1:9c133a0:     // let's write out the custom headers
1:9c133a0:     if ((_deploymentCustomEntries != null) && (_deploymentCustomEntries.isEmpty())) {
1:9c133a0:       for (Map.Entry<String, String> customEntry : _deploymentCustomEntries.entrySet()) {
1:9c133a0:         attributes.putValue(customEntry.getKey(), customEntry.getValue());
1:9c133a0:       }
1:47d4583:     }
1:92ce70e:     mf.write(out);
1:92ce70e:   }
1:ffe1828:   
1:ffe1828:   
1:92ce70e:   
1:ad46961:   private String getDeploymentContentsAsString (List<DeploymentContent> content) { 
1:92ce70e:     StringBuilder builder = new StringBuilder();
1:ad46961:     for (DeploymentContent dc : content) {
1:92ce70e:       builder.append(dc.getContentName());
1:92ce70e:       builder.append(';' + AppConstants.DEPLOYMENT_BUNDLE_VERSION + "=");
1:92ce70e:       builder.append(dc.getExactVersion());
1:92ce70e:       builder.append(",");
1:92ce70e:     }
1:92ce70e:     if (builder.length() > 0) { 
1:92ce70e:       builder.deleteCharAt(builder.length() - 1);
1:92ce70e:     }
1:92ce70e:     return builder.toString();
1:ba73ed7:   }
1:0e0fd84: 
1:9c133a0:   private void parseDeploymentContent(String content, List<DeploymentContent> contents)
1:ad46961:   {
1:ad46961:     List<String> pcList = ManifestProcessor.split(content, ",");
1:ad46961:     for (String s : pcList) {
1:ad46961:       contents.add(new DeploymentContentImpl(s));
1:ba73ed7:     }
15:8914925:   }
1:59e7b8b: 
1:9c133a0:   private void parseContent(String content, Collection<Content> contents)
1:9c133a0:   {
1:9c133a0:     List<String> pcList = ManifestProcessor.split(content, ",");
1:9c133a0:     for (String s : pcList) {
1:9c133a0:       contents.add(new ContentImpl(s));
1:9c133a0:     }
1:9c133a0:   }
1:9c133a0:   
1:9c133a0: 
1:59e7b8b:   public List<DeploymentContent> getDeployedUseBundle()
1:59e7b8b:   {
1:9c133a0:     return Collections.unmodifiableList(_deployedUseBundleContent);
1:59e7b8b:   }
1:59e7b8b: 
1:59e7b8b:   public Set<Content> getImportPackage()
1:59e7b8b:   {
1:9c133a0:     return Collections.unmodifiableSet(_deploymentImportPackage);
1:59e7b8b:   }
1:9c133a0: 
1:6d76129:   public Collection<Filter> getDeployedServiceImport() 
1:9c133a0:   {
1:9c133a0:     return Collections.unmodifiableCollection(_deployedImportService);
1:9c133a0:   }
1:9c133a0: 
1:9c133a0:   public Map<String, String> getHeaders()
1:9c133a0:   {
1:9c133a0:     return Collections.unmodifiableMap(_deploymentEntries);
1:9c133a0:   }
1:9c133a0:   
1:9c133a0:   private Map<String, String> getEntries(Attributes attrs) {
1:9c133a0:     Map<String, String> entries = new HashMap<String, String>();
1:9c133a0:     if ((attrs != null) && (!attrs.isEmpty())) {
1:9c133a0:       Set<Object> keys = attrs.keySet();
1:9c133a0:       for (Object key : keys) {
1:9c133a0:         entries.put(key.toString(),  attrs.getValue((Attributes.Name)key));
1:9c133a0:       }
1:9c133a0:     }
1:9c133a0:     return entries;
1:9c133a0:   }
1:9c133a0:  
1:9c133a0: 
1:9c133a0:   private Map<String, String> getCustomEntries(Attributes attrs) {
1:9c133a0:     Map<String, String> customEntry = new HashMap<String, String> ();
1:9c133a0:     Collection<String> customHeaders = getCustomHeaders(attrs);
1:9c133a0:     if ((customHeaders != null) && (customHeaders.isEmpty())) {
1:9c133a0:       for (String customHeader : customHeaders)
1:9c133a0:         customEntry.put(customHeader, attrs.getValue(customHeader));
1:9c133a0:       
1:9c133a0:     }
1:9c133a0:     return customEntry;
1:9c133a0:     
1:9c133a0:   }
1:9c133a0:   
1:9c133a0:    private Collection<Filter> getFilters(String filterString) throws InvalidAttributeException{
1:9c133a0:      Collection<Filter> filters = new ArrayList<Filter>();
1:9c133a0:      List<String> fs = ManifestProcessor.split(filterString, ",");
1:9c133a0:      if ((fs != null) && (!!!fs.isEmpty())) {
1:9c133a0:        for (String filter : fs) {
1:9c133a0:          try {
1:9c133a0:          filters.add(FrameworkUtil.createFilter(FilterUtils.removeMandatoryFilterToken(filter)));
1:9c133a0:          } catch (InvalidSyntaxException ise) {
1:9c133a0:            InvalidAttributeException iae = new InvalidAttributeException(ise);
1:9c133a0:            throw iae;
1:9c133a0:          }
1:9c133a0:        }
1:9c133a0:      }
1:9c133a0:      return filters;
1:9c133a0:    }
1:9c133a0:   
1:9c133a0:    private  String convertFiltersToString(Collection<Filter> contents, String separator) {
1:9c133a0:      StringBuilder newContent = new StringBuilder();
1:9c133a0:      if ((contents != null) && (!!!contents.isEmpty())) {
1:9c133a0:        boolean beginning = true;
1:9c133a0:        for (Filter content: contents) {
1:9c133a0:          if (beginning)
1:9c133a0:            newContent.append(separator);
1:9c133a0:          newContent.append(content.toString());
1:9c133a0:          beginning = false;
1:9c133a0:        }
1:9c133a0:      }
1:9c133a0:      return newContent.toString();
1:9c133a0:    }
1:9c133a0:    
1:9c133a0:    
1:8914925: }
============================================================================
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:910fec0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.VersionRange;
1: import org.apache.aries.util.manifest.ManifestProcessor;
commit:89f804e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.InvalidAttributeException;
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:6d76129
/////////////////////////////////////////////////////////////////////////
1:   public Collection<Filter> getDeployedServiceImport() 
commit:9c133a0
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.management.InvalidAttributeException;
1: import org.apache.aries.application.utils.FilterUtils;
1: import org.osgi.framework.Filter;
1: import org.osgi.framework.FrameworkUtil;
1: import org.osgi.framework.InvalidSyntaxException;
1:   private List<DeploymentContent> _deployedUseBundleContent = new ArrayList<DeploymentContent>();
1:   
1:   private Set<Content> _deploymentImportPackage = new HashSet<Content>();
1:   private Map<String, String> _deploymentCustomEntries = new HashMap<String, String>();  
1:   private Map<String, String> _deploymentEntries = new HashMap<String, String>();
1:   private Collection<Filter> _deployedImportService = new ArrayList<Filter>();
1:     _deployedUseBundleContent = new ArrayList<DeploymentContent>();
/////////////////////////////////////////////////////////////////////////
1:     Map<String, VersionRange> useBundles = new HashMap<String, VersionRange>();
1:     for (Content c : app.getApplicationMetadata().getUseBundles()) {
1:       useBundles.put(c.getContentName(), c.getVersion());
1:     }
1:     
1:       VersionRange appContentRange = appContent.get(info.getSymbolicName());
1:       VersionRange useBundleRange = useBundles.get(info.getSymbolicName());
1:       if ((appContentRange == null) && (useBundleRange == null)){
1:       } else if (appContentRange.matches(info.getVersion())) {
1:       }  else if (useBundleRange.matches(info.getVersion())) {
1:         _deployedUseBundleContent.add(dp);
1:       }
1:       else {
1:         throw new ResolverException("Bundle " + info.getSymbolicName() + " at version " + info.getVersion() + " is not in the range " + appContentRange + " or " + useBundleRange);
/////////////////////////////////////////////////////////////////////////
1:   public DeploymentMetadataImpl(Manifest mf) throws InvalidAttributeException{ 
1:     parseDeploymentContent(attributes.getValue(AppConstants.DEPLOYMENT_CONTENT), _deploymentContent);
1:     parseDeploymentContent(attributes.getValue(AppConstants.DEPLOYMENT_PROVISION_BUNDLE), _provisionSharedContent);
1:     parseDeploymentContent(attributes.getValue(AppConstants.DEPLOYMENT_USE_BUNDLE), _deployedUseBundleContent);
1:     parseContent(attributes.getValue(AppConstants.DEPLOYMENT_IMPORT_PACKAGES), _deploymentImportPackage);
1:     
1:     _deployedImportService = getFilters(attributes.getValue(AppConstants.DEPLOYMENTSERVICE_IMPORT));
1:     _deploymentCustomEntries = getCustomEntries(attributes);
1:     _deploymentEntries = getEntries(attributes);
1:   }
1:   
1:   public DeploymentMetadataImpl(Map<String, String> map) throws InvalidAttributeException{ 
1: 
1:     Attributes attributes = new Attributes();
1:     if (map != null) {
1:     for (Map.Entry<String, String> entry : map.entrySet()) {
1:       attributes.putValue(entry.getKey(), entry.getValue());
1:     }
1:     }
1:     parseDeploymentContent(map.get(AppConstants.DEPLOYMENT_CONTENT), _deploymentContent);
1:     parseDeploymentContent(map.get(AppConstants.DEPLOYMENT_PROVISION_BUNDLE), _provisionSharedContent);
1:     parseDeploymentContent(map.get(AppConstants.DEPLOYMENT_USE_BUNDLE), _deployedUseBundleContent);
1:     parseContent(attributes.getValue(AppConstants.DEPLOYMENT_IMPORT_PACKAGES), _deploymentImportPackage);
1:     _deployedImportService = getFilters(attributes.getValue(AppConstants.DEPLOYMENTSERVICE_IMPORT));
1:     _deploymentCustomEntries = getCustomEntries(attributes);
1:     _deploymentEntries = getEntries(attributes);
1:     
1:   private Collection<Attributes.Name> getDeploymentStandardHeaders() {
1:     Collection<Attributes.Name> standardKeys = new HashSet<Attributes.Name> ();
1:     standardKeys.add(new Attributes.Name(AppConstants.APPLICATION_MANIFEST_VERSION));
1:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENT_CONTENT));
1:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENT_PROVISION_BUNDLE));
1:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENT_USE_BUNDLE));
1:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENT_IMPORT_PACKAGES));
1:     standardKeys.add(new Attributes.Name(AppConstants.DEPLOYMENTSERVICE_IMPORT));
1:     standardKeys.add(new Attributes.Name(AppConstants.APPLICATION_SYMBOLIC_NAME));
1:     standardKeys.add(new Attributes.Name(AppConstants.APPLICATION_VERSION));
1:     return standardKeys;
1:   }
1: 
1:   private Collection<String> getCustomHeaders(Attributes attrs) {
1:     
1:     Collection<String> customKeys = new HashSet<String>();
1:     Collection<Attributes.Name> standardKeys = getDeploymentStandardHeaders();
1:     if ((attrs != null) && (!!!attrs.isEmpty())) {
1:      Set<Object> keys = attrs.keySet();
1:      
1:      if ((keys != null) && (!!!keys.isEmpty())) {
1:        for (Object eachKey : keys) {
1:          String key = eachKey.toString();
1:          customKeys.add(key);
1:        }
1:        
1:          customKeys.removeAll(standardKeys);
1:        
1:      }
1:     }
1:     return customKeys;
1:   }
1:   
1:   private String getContentsAsString (Collection<Content> contents) {
1:     StringBuilder builder = new StringBuilder();
1:     boolean beginning = true;
1:     for (Content c : contents) {
1:       if (!!!beginning) {
1:         builder.append(",");
1:       }
1:       builder.append(c);
1:       beginning = false;
1:       
1:     }
1:     return builder.toString();
1:   }
1:   
/////////////////////////////////////////////////////////////////////////
1:     if ((_deploymentContent != null) && (!_deploymentContent.isEmpty())) {
1:     if ((_provisionSharedContent != null) && (!_provisionSharedContent.isEmpty())) {
1:       attributes.putValue(AppConstants.DEPLOYMENT_PROVISION_BUNDLE, getDeploymentContentsAsString(_provisionSharedContent));
1:     }
1:     if ((_deployedUseBundleContent != null) && (!_deployedUseBundleContent.isEmpty())) {
1:       attributes.putValue(AppConstants.DEPLOYMENT_USE_BUNDLE, getDeploymentContentsAsString(_deployedUseBundleContent));
1:     }
1:     if ((_deploymentImportPackage != null) && (!_deploymentImportPackage.isEmpty())) {
1:       attributes.putValue(AppConstants.DEPLOYMENT_IMPORT_PACKAGES, getContentsAsString(_deploymentImportPackage));
1:     }
1:     if ((_deployedImportService != null) && (!!!_deployedImportService.isEmpty())) {
1:       attributes.putValue(AppConstants.DEPLOYMENTSERVICE_IMPORT, convertFiltersToString(_deployedImportService, ",") );
1:     }
1:     // let's write out the custom headers
1:     if ((_deploymentCustomEntries != null) && (_deploymentCustomEntries.isEmpty())) {
1:       for (Map.Entry<String, String> customEntry : _deploymentCustomEntries.entrySet()) {
1:         attributes.putValue(customEntry.getKey(), customEntry.getValue());
1:       }
/////////////////////////////////////////////////////////////////////////
1:   private void parseDeploymentContent(String content, List<DeploymentContent> contents)
/////////////////////////////////////////////////////////////////////////
1:   private void parseContent(String content, Collection<Content> contents)
1:   {
1:     List<String> pcList = ManifestProcessor.split(content, ",");
1:     for (String s : pcList) {
1:       contents.add(new ContentImpl(s));
1:     }
1:   }
1:   
1: 
1:     return Collections.unmodifiableList(_deployedUseBundleContent);
1:     return Collections.unmodifiableSet(_deploymentImportPackage);
1: 
0:   public Collection<Filter> getDeployedServiceImport() throws InvalidAttributeException
1:   {
1:     return Collections.unmodifiableCollection(_deployedImportService);
1:   }
1: 
1:   public Map<String, String> getHeaders()
1:   {
1:     return Collections.unmodifiableMap(_deploymentEntries);
1:   }
1:   
1:   private Map<String, String> getEntries(Attributes attrs) {
1:     Map<String, String> entries = new HashMap<String, String>();
1:     if ((attrs != null) && (!attrs.isEmpty())) {
1:       Set<Object> keys = attrs.keySet();
1:       for (Object key : keys) {
1:         entries.put(key.toString(),  attrs.getValue((Attributes.Name)key));
1:       }
1:     }
1:     return entries;
1:   }
1:  
1: 
1:   private Map<String, String> getCustomEntries(Attributes attrs) {
1:     Map<String, String> customEntry = new HashMap<String, String> ();
1:     Collection<String> customHeaders = getCustomHeaders(attrs);
1:     if ((customHeaders != null) && (customHeaders.isEmpty())) {
1:       for (String customHeader : customHeaders)
1:         customEntry.put(customHeader, attrs.getValue(customHeader));
1:       
1:     }
1:     return customEntry;
1:     
1:   }
1:   
1:    private Collection<Filter> getFilters(String filterString) throws InvalidAttributeException{
1:      Collection<Filter> filters = new ArrayList<Filter>();
1:      List<String> fs = ManifestProcessor.split(filterString, ",");
1:      if ((fs != null) && (!!!fs.isEmpty())) {
1:        for (String filter : fs) {
1:          try {
1:          filters.add(FrameworkUtil.createFilter(FilterUtils.removeMandatoryFilterToken(filter)));
1:          } catch (InvalidSyntaxException ise) {
1:            InvalidAttributeException iae = new InvalidAttributeException(ise);
1:            throw iae;
1:          }
1:        }
1:      }
1:      return filters;
1:    }
1:   
1:    private  String convertFiltersToString(Collection<Filter> contents, String separator) {
1:      StringBuilder newContent = new StringBuilder();
1:      if ((contents != null) && (!!!contents.isEmpty())) {
1:        boolean beginning = true;
1:        for (Filter content: contents) {
1:          if (beginning)
1:            newContent.append(separator);
1:          newContent.append(content.toString());
1:          beginning = false;
1:        }
1:      }
1:      return newContent.toString();
1:    }
1:    
1:    
commit:59e7b8b
/////////////////////////////////////////////////////////////////////////
1: 
1:   public List<DeploymentContent> getDeployedUseBundle()
1:   {
0:     return new ArrayList<DeploymentContent>();
1:   }
1: 
1:   public Set<Content> getImportPackage()
1:   {
0:     return null;
1:   }
commit:ffe1828
/////////////////////////////////////////////////////////////////////////
0: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.filesystem.IFile;
0: import org.apache.aries.application.utils.manifest.ManifestProcessor;
/////////////////////////////////////////////////////////////////////////
1:   
1:   /**
0:    * Construct a DeploymentMetadata from an IFile
1:    * @param src
1:    * @throws IOException
1:    */
0:   public DeploymentMetadataImpl (IFile src) throws IOException { 
0:     InputStream is = src.open();
0:     try { 
0:       // Populate application symbolic name and version fields
0:       Manifest mf = ManifestProcessor.parseManifest(is);
1:       _applicationMetadata = new ApplicationMetadataImpl (mf);
1: 
1:       Attributes attributes = mf.getMainAttributes();
0:       String deploymentContent = attributes.getValue(AppConstants.DEPLOYMENT_CONTENT);
0:       List<String> dcList = ManifestProcessor.split(deploymentContent, ",");
1:       _deploymentContent = new ArrayList<DeploymentContent>();
0:       for (String s : dcList) { 
0:         _deploymentContent.add(new DeploymentContentImpl(s));
1:       }
0:     } finally { 
0:       is.close();
1:     }
1:   }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   
1:   
commit:92ce70e
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileNotFoundException;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.util.jar.Attributes;
1: import java.util.jar.Manifest;
1: import org.apache.aries.application.utils.AppConstants;
/////////////////////////////////////////////////////////////////////////
1:   public void store(File f) throws FileNotFoundException, IOException{
1:     FileOutputStream fos = new FileOutputStream (f);
1:     store(fos);
1:     fos.close();
1:   public void store(OutputStream out) throws IOException {
1:     // We weren't built from a Manifest, so construct one. 
1:     Manifest mf = new Manifest();
1:     Attributes attributes = mf.getMainAttributes();
1:     attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), AppConstants.MANIFEST_VERSION);
1:     attributes.putValue(AppConstants.APPLICATION_VERSION, getApplicationVersion().toString());
1:     attributes.putValue(AppConstants.APPLICATION_SYMBOLIC_NAME, getApplicationSymbolicName());
0:     attributes.putValue(AppConstants.DEPLOYMENT_CONTENT, getDeploymentContentsAsString());
1:     mf.write(out);
1:   }
1:   
0:   private String getDeploymentContentsAsString () { 
1:     StringBuilder builder = new StringBuilder();
0:     for (DeploymentContent dc : getApplicationDeploymentContents()) {
1:       builder.append(dc.getContentName());
1:       builder.append(';' + AppConstants.DEPLOYMENT_BUNDLE_VERSION + "=");
1:       builder.append(dc.getExactVersion());
1:       builder.append(",");
1:     }
1:     if (builder.length() > 0) { 
1:       builder.deleteCharAt(builder.length() - 1);
1:     }
1:     return builder.toString();
commit:5297b83
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
1: import org.apache.aries.application.Content;
0: import org.apache.aries.application.VersionRange;
/////////////////////////////////////////////////////////////////////////
1:     
0:     // DeploymentContent needs to list everything in the application content
0:     // plus all the bundles in additonalBundlesRequired
0:     for (Content c: _applicationMetadata.getApplicationContents()) { 
0:       _deploymentContent.add(new DeploymentContentImpl(c.getContentName(), c.getVersion().getMinimumVersion()));
1:     }
commit:0e0fd84
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.OutputStream;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.Set;
1: import org.apache.aries.application.management.AriesApplication;
1: import org.apache.aries.application.management.BundleInfo;
1:   
0:   ApplicationMetadata _applicationMetadata;
0:   List<DeploymentContent> _deploymentContent;
1:   
0:   public DeploymentMetadataImpl (AriesApplication app, Set<BundleInfo> additionalBundlesRequired) {
1:     _applicationMetadata = app.getApplicationMetadata();
0:     _deploymentContent = new ArrayList<DeploymentContent>();
0:     for (BundleInfo bundleInfo : additionalBundlesRequired) { 
0:       DeploymentContentImpl dci = new DeploymentContentImpl(bundleInfo.getSymbolicName(), 
0:           bundleInfo.getVersion()); 
0:       _deploymentContent.add(dci);
1:     }
1:   }
1:     return Collections.unmodifiableList(_deploymentContent);
1:     return _applicationMetadata;
1:     return _applicationMetadata.getApplicationSymbolicName();
1:     return _applicationMetadata.getApplicationVersion();
1:   }
1: 
1: 
0:   public void store(File f) {
0:     // TODO when writing AriesApplication.store()
1:     
1:   }
1: 
1: 
0:   public void store(OutputStream in) {
0:     // TODO when writing AriesApplication.store()
1:     
commit:47d4583
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.aries.application.impl;
1: 
1: import java.util.List;
1: 
1: import org.apache.aries.application.ApplicationMetadata;
1: import org.apache.aries.application.DeploymentContent;
1: import org.apache.aries.application.DeploymentMetadata;
1: import org.osgi.framework.Version;
1: 
1: public class DeploymentMetadataImpl implements DeploymentMetadata {
1: 
1:   public List<DeploymentContent> getApplicationDeploymentContents() {
0:     // TODO Auto-generated method stub
0:     return null;
1:   }
1: 
1:   public ApplicationMetadata getApplicationMetadata() {
0:     // TODO Auto-generated method stub
0:     return null;
1:   }
1: 
1:   public String getApplicationSymbolicName() {
0:     // TODO Auto-generated method stub
0:     return null;
1:   }
1: 
1:   public Version getApplicationVersion() {
0:     // TODO Auto-generated method stub
0:     return null;
1:   }
1: 
1: }
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:ba73ed7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:    * Construct a DeploymentMetadata from Manifest
0:   public DeploymentMetadataImpl(Manifest mf) { 
0:     _applicationMetadata = new ApplicationMetadataImpl (mf);
0:     Attributes attributes = mf.getMainAttributes();
0:     parseContent(attributes.getValue(AppConstants.DEPLOYMENT_CONTENT), _deploymentContent);
0:     parseContent(attributes.getValue(AppConstants.PROVISION_CONTENT), _provisionSharedContent);
/////////////////////////////////////////////////////////////////////////
0:     if (!_deploymentContent.isEmpty()) {
1:       attributes.putValue(AppConstants.DEPLOYMENT_CONTENT, getDeploymentContentsAsString(_deploymentContent));
1:     }
0:     if (!_provisionSharedContent.isEmpty()) {
0:       attributes.putValue(AppConstants.PROVISION_CONTENT, getDeploymentContentsAsString(_provisionSharedContent));
1:     }
commit:8914925
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
1: 
0: package org.apache.aries.application.impl;
1: 
0: import java.io.File;
0: import java.io.FileNotFoundException;
0: import java.io.FileOutputStream;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.List;
0: import java.util.Set;
0: import java.util.jar.Attributes;
0: import java.util.jar.Manifest;
1: 
0: import org.apache.aries.application.ApplicationMetadata;
0: import org.apache.aries.application.Content;
0: import org.apache.aries.application.DeploymentContent;
0: import org.apache.aries.application.DeploymentMetadata;
0: import org.apache.aries.application.filesystem.IFile;
0: import org.apache.aries.application.management.AriesApplication;
0: import org.apache.aries.application.management.BundleInfo;
0: import org.apache.aries.application.utils.AppConstants;
0: import org.apache.aries.application.utils.manifest.ManifestProcessor;
0: import org.osgi.framework.Version;
1: 
0: public class DeploymentMetadataImpl implements DeploymentMetadata {
1:   
0:   ApplicationMetadata _applicationMetadata;
0:   List<DeploymentContent> _deploymentContent;
1:   
0:   public DeploymentMetadataImpl (AriesApplication app, Set<BundleInfo> additionalBundlesRequired) {
0:     _applicationMetadata = app.getApplicationMetadata();
0:     _deploymentContent = new ArrayList<DeploymentContent>();
1:     
0:     // DeploymentContent needs to list everything in the application content
0:     // plus all the bundles in additonalBundlesRequired
0:     for (Content c: _applicationMetadata.getApplicationContents()) { 
0:       _deploymentContent.add(new DeploymentContentImpl(c.getContentName(), c.getVersion().getMinimumVersion()));
1:     }
0:     for (BundleInfo bundleInfo : additionalBundlesRequired) { 
0:       DeploymentContentImpl dci = new DeploymentContentImpl(bundleInfo.getSymbolicName(), 
0:           bundleInfo.getVersion()); 
0:       _deploymentContent.add(dci);
1:     }
1:   }
1:   
0:   /**
0:    * Construct a DeploymentMetadata from an IFile
0:    * @param src
0:    * @throws IOException
0:    */
0:   public DeploymentMetadataImpl (IFile src) throws IOException { 
0:     InputStream is = src.open();
0:     try { 
0:       // Populate application symbolic name and version fields
0:       Manifest mf = ManifestProcessor.parseManifest(is);
0:       _applicationMetadata = new ApplicationMetadataImpl (mf);
1: 
0:       Attributes attributes = mf.getMainAttributes();
0:       String deploymentContent = attributes.getValue(AppConstants.DEPLOYMENT_CONTENT);
0:       List<String> dcList = ManifestProcessor.split(deploymentContent, ",");
0:       _deploymentContent = new ArrayList<DeploymentContent>();
0:       for (String s : dcList) { 
0:         _deploymentContent.add(new DeploymentContentImpl(s));
1:       }
0:     } finally { 
0:       is.close();
1:     }
1:   }
1: 
0:   public List<DeploymentContent> getApplicationDeploymentContents() {
0:     return Collections.unmodifiableList(_deploymentContent);
1:   }
1: 
0:   public ApplicationMetadata getApplicationMetadata() {
0:     return _applicationMetadata;
1:   }
1: 
0:   public String getApplicationSymbolicName() {
0:     return _applicationMetadata.getApplicationSymbolicName();
1:   }
1: 
0:   public Version getApplicationVersion() {
0:     return _applicationMetadata.getApplicationVersion();
1:   }
1: 
1: 
0:   public void store(File f) throws FileNotFoundException, IOException{
0:     FileOutputStream fos = new FileOutputStream (f);
0:     store(fos);
0:     fos.close();
1:   }
1: 
0:   public void store(OutputStream out) throws IOException {
0:     // We weren't built from a Manifest, so construct one. 
0:     Manifest mf = new Manifest();
0:     Attributes attributes = mf.getMainAttributes();
0:     attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), AppConstants.MANIFEST_VERSION);
0:     attributes.putValue(AppConstants.APPLICATION_VERSION, getApplicationVersion().toString());
0:     attributes.putValue(AppConstants.APPLICATION_SYMBOLIC_NAME, getApplicationSymbolicName());
0:     attributes.putValue(AppConstants.DEPLOYMENT_CONTENT, getDeploymentContentsAsString());
0:     mf.write(out);
1:   }
1:   
1:   
1:   
0:   private String getDeploymentContentsAsString () { 
0:     StringBuilder builder = new StringBuilder();
0:     for (DeploymentContent dc : getApplicationDeploymentContents()) {
0:       builder.append(dc.getContentName());
0:       builder.append(';' + AppConstants.DEPLOYMENT_BUNDLE_VERSION + "=");
0:       builder.append(dc.getExactVersion());
0:       builder.append(",");
1:     }
0:     if (builder.length() > 0) { 
0:       builder.deleteCharAt(builder.length() - 1);
1:     }
0:     return builder.toString();
1:   }
1: 
1: }
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:ad46961
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.VersionRange;
0: import org.apache.aries.application.management.ManagementException;
1: import org.apache.aries.application.management.ResolverException;
1:   private ApplicationMetadata _applicationMetadata;
1:   private List<DeploymentContent> _deploymentContent = new ArrayList<DeploymentContent>();
1:   private List<DeploymentContent> _provisionSharedContent = new ArrayList<DeploymentContent>();
1:   public DeploymentMetadataImpl (AriesApplication app, Set<BundleInfo> bundlesRequired) throws ResolverException
1:   {
1:     _provisionSharedContent = new ArrayList<DeploymentContent>();
1:     Map<String, VersionRange> appContent = new HashMap<String, VersionRange>();
0:     
1:     for (Content c : app.getApplicationMetadata().getApplicationContents()) {
1:       appContent.put(c.getContentName(), c.getVersion());
0:     
1:     for (BundleInfo info : bundlesRequired) {
0:       
0:       VersionRange range = appContent.get(info.getSymbolicName());
0:       
1:       DeploymentContent dp = new DeploymentContentImpl(info.getSymbolicName(), info.getVersion());
0:       
0:       if (range == null) {
1:         _provisionSharedContent.add(dp);
0:       } else if (range.matches(info.getVersion())) {
1:         _deploymentContent.add(dp);
0:       } else {
0:         throw new ResolverException("Bundle " + info.getSymbolicName() + " at version " + info.getVersion() + " is not in the range " + range);
0:       }
/////////////////////////////////////////////////////////////////////////
0:       
0:       parseContent(attributes.getValue(AppConstants.DEPLOYMENT_CONTENT), _deploymentContent);
0:       parseContent(attributes.getValue(AppConstants.PROVISION_CONTENT), _provisionSharedContent);
0:       
/////////////////////////////////////////////////////////////////////////
0:   
1:   public List<DeploymentContent> getApplicationProvisionBundles() {
1:     return Collections.unmodifiableList(_provisionSharedContent);
0:   }
/////////////////////////////////////////////////////////////////////////
0:     attributes.putValue(AppConstants.DEPLOYMENT_CONTENT, getDeploymentContentsAsString(_deploymentContent));
0:     attributes.putValue(AppConstants.PROVISION_CONTENT, getDeploymentContentsAsString(_provisionSharedContent));
1:   private String getDeploymentContentsAsString (List<DeploymentContent> content) { 
1:     for (DeploymentContent dc : content) {
/////////////////////////////////////////////////////////////////////////
0:   private void parseContent(String content, List<DeploymentContent> contents)
1:   {
1:     List<String> pcList = ManifestProcessor.split(content, ",");
1:     for (String s : pcList) {
1:       contents.add(new DeploymentContentImpl(s));
0:     }
0:   }
0: }
============================================================================