1:df2a53a: /**
1:df2a53a:  * Licensed to the Apache Software Foundation (ASF) under one
1:df2a53a:  * or more contributor license agreements.  See the NOTICE file
1:df2a53a:  * distributed with this work for additional information
1:df2a53a:  * regarding copyright ownership.  The ASF licenses this file
1:df2a53a:  * to you under the Apache License, Version 2.0 (the
1:df2a53a:  * "License"); you may not use this file except in compliance
1:df2a53a:  * with the License.  You may obtain a copy of the License at
1:df2a53a:  *
1:df2a53a:  *   http://www.apache.org/licenses/LICENSE-2.0
1:df2a53a:  *
1:df2a53a:  * Unless required by applicable law or agreed to in writing,
1:df2a53a:  * software distributed under the License is distributed on an
1:df2a53a:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:df2a53a:  * KIND, either express or implied.  See the License for the
1:df2a53a:  * specific language governing permissions and limitations
1:df2a53a:  * under the License.
1:df2a53a:  */
1:df2a53a: package org.apache.aries.samples.blog.persistence.jdbc;
1:df2a53a: 
1:df2a53a: import java.sql.Connection;
1:df2a53a: import java.sql.PreparedStatement;
1:df2a53a: import java.sql.ResultSet;
1:df2a53a: import java.sql.SQLException;
1:df2a53a: import java.sql.Statement;
1:df2a53a: import java.text.ParseException;
1:df2a53a: import java.util.ArrayList;
1:df2a53a: import java.util.Date;
1:df2a53a: import java.util.List;
1:df2a53a: 
1:df2a53a: import javax.sql.DataSource;
1:df2a53a: 
1:df2a53a: import org.apache.aries.samples.blog.api.persistence.BlogPersistenceService;
1:df2a53a: import org.apache.aries.samples.blog.persistence.jdbc.entity.AuthorImpl;
1:df2a53a: import org.apache.aries.samples.blog.persistence.jdbc.entity.EntryImpl;
1:df2a53a: 
1:df2a53a: /**
1:df2a53a:  * This class is the implementation of the blogPersistenceService
1:df2a53a:  */
1:df2a53a: public class BlogPersistenceServiceImpl implements BlogPersistenceService {
1:df2a53a: 	private DataSource dataSource;
1:df2a53a: 	
1:df2a53a:     private Statements statements;
1:df2a53a: 
1:df2a53a:     public BlogPersistenceServiceImpl() {
1:df2a53a:         this.statements = new Statements();
1:df2a53a:     }
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * set data source
1:df2a53a: 	 */
1:df2a53a: 	public void setDataSource(DataSource dataSource) {
1:df2a53a: 		this.dataSource = dataSource;
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a:     public void init() {
1:df2a53a:         Statement s = null;
1:df2a53a:         Connection connection = null;
1:df2a53a: 
1:df2a53a:         try {
1:df2a53a:             connection = dataSource.getConnection();
1:df2a53a: 
1:df2a53a:             s = connection.createStatement();
1:df2a53a:             String[] createStatments = this.statements
1:df2a53a:                     .getCreateSchemaStatements();
1:df2a53a:             for (int i = 0; i < createStatments.length; i++) {
1:df2a53a:                 s.execute(createStatments[i]);
1:df2a53a:             }
1:df2a53a:         } catch (SQLException e) {
1:df2a53a:             e.printStackTrace();
1:df2a53a:             throw new RuntimeException(e);
1:df2a53a:         } finally {
1:df2a53a:             if (s != null) {
1:df2a53a:                 try {
1:df2a53a:                     s.close();
1:df2a53a:                 } catch (Throwable e) {
1:df2a53a:                 }
1:df2a53a:             }
1:df2a53a:             if (connection != null) {
1:df2a53a:                 try {
1:df2a53a:                     connection.close();
1:df2a53a:                 } catch (Throwable e) {
1:df2a53a:                 }
1:df2a53a:             }
1:df2a53a:         }
1:df2a53a:     }
1:df2a53a: 
1:df2a53a:     public void destroy() {
1:df2a53a:         Statement s = null;
1:df2a53a:         Connection connection = null;
1:df2a53a: 
1:df2a53a:         try {
1:df2a53a:             connection = dataSource.getConnection();
1:df2a53a: 
1:df2a53a:             s = connection.createStatement();
1:df2a53a:             String[] dropStatments = this.statements.getDropSchemaStatements();
1:df2a53a:             for (int i = 0; i < dropStatments.length; i++) {
1:df2a53a:                 s.execute(dropStatments[i]);
1:df2a53a:             }
1:df2a53a:         } catch (SQLException e) {
1:df2a53a:             e.printStackTrace();
1:df2a53a:             throw new RuntimeException(e);
1:df2a53a:         } finally {
1:df2a53a:             if (s != null) {
1:df2a53a:                 try {
1:df2a53a:                     s.close();
1:df2a53a:                 } catch (Throwable e) {
1:df2a53a:                 }
1:df2a53a:             }
1:df2a53a:             if (connection != null) {
1:df2a53a:                 try {
1:df2a53a:                     connection.close();
1:df2a53a:                 } catch (Throwable e) {
1:df2a53a:                 }
1:df2a53a:             }
1:df2a53a:         }
1:df2a53a:     }
1:df2a53a: 	
1:df2a53a: 	/**
1:df2a53a: 	 * Create an author record
1:df2a53a: 	 * 
1:df2a53a: 	 * @param a
1:df2a53a: 	 *            The author object to be created
1:df2a53a: 	 * @throws ParseException
1:df2a53a: 	 * @throws ParseException
1:df2a53a: 	 */
1:df2a53a: 	public void createAuthor(String email, Date dob, String name,
1:df2a53a: 			String displayName, String bio) {
1:df2a53a: 		
1:df2a53a: 		
1:df2a53a: 		try {
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			String sql = "INSERT INTO AUTHOR VALUES (?,?,?,?,?)";
1:df2a53a: 			
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.setString(1, email);
1:df2a53a: 			ppsm.setString(2, bio);
1:df2a53a: 			ppsm.setString(3, displayName);
1:df2a53a: 			if (dob != null)
1:df2a53a: 				ppsm.setDate(4, new java.sql.Date(dob.getTime()));
1:df2a53a: 			else
1:df2a53a: 				ppsm.setDate(4, null);
1:df2a53a: 			ppsm.setString(5, name);
1:df2a53a: 			int insertRows = ppsm.executeUpdate();
1:df2a53a: 			ppsm.close();
1:df2a53a: 			connection.close();
1:df2a53a: 			
1:df2a53a: 			if (insertRows != 1)
1:df2a53a: 				throw new IllegalArgumentException("The Author " + email
1:df2a53a: 						+ " cannot be inserted.");
1:df2a53a: 		} catch (SQLException e) {
1:df2a53a: 			e.printStackTrace();
1:df2a53a: 			throw new IllegalArgumentException(e.getMessage());
1:df2a53a: 		}
1:df2a53a: 
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Create a blog entry record
1:df2a53a: 	 * 
1:df2a53a: 	 * @param a 
1:df2a53a: 	 * 			The author
1:df2a53a: 	 * @param title 
1:df2a53a: 	 * 			The title of the post
1:df2a53a: 	 * @param blogText 
1:df2a53a: 	 * 			The text of the post
1:df2a53a: 	 * @param tags
1:df2a53a: 	 * 
1:df2a53a: 	 */
1:df2a53a: 	public void createBlogPost(String authorEmail, String title, String blogText,
1:df2a53a: 			List<String> tags) {
1:df2a53a: 		
1:df2a53a: 		AuthorImpl a = getAuthor(authorEmail);
1:df2a53a: 		
1:df2a53a: 		if(title == null) title = "";
1:df2a53a: 		Date publishDate = new Date(System.currentTimeMillis());
1:df2a53a: 		if(tags == null) tags = new ArrayList<String>();
1:df2a53a: 		
1:df2a53a: 
1:df2a53a: 		try {
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			// let's find the max id from the blogentry table
1:df2a53a: 			String sql = "SELECT max(id) FROM BLOGENTRY";
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ResultSet rs = ppsm.executeQuery();
1:df2a53a: 			// we only expect to have one row returned
1:df2a53a: 			rs.next();
1:df2a53a: 
1:df2a53a: 			long max_id = rs.getLong(1);
1:df2a53a: 			ppsm.close();
1:df2a53a: 			
1:df2a53a: 			long post_id = max_id + 1;
1:df2a53a: 			sql = "INSERT INTO BLOGENTRY VALUES (?,?,?,?,?,?)";
1:df2a53a: 			
1:df2a53a: 		    ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.setLong(1, post_id);
1:df2a53a: 			ppsm.setString(2, blogText);
1:df2a53a: 			if (publishDate != null)
1:df2a53a: 				ppsm
1:df2a53a: 						.setDate(3, new java.sql.Date(publishDate
1:df2a53a: 								.getTime()));
1:df2a53a: 			else
1:df2a53a: 				ppsm.setDate(3, null);
1:df2a53a: 			ppsm.setString(4, title);
1:df2a53a: 			
1:df2a53a: 		    ppsm.setDate(5, null);
1:df2a53a: 			ppsm.setString(6, a.getEmail());
1:df2a53a: 			int rows = ppsm.executeUpdate();
1:df2a53a: 			if (rows != 1)
1:df2a53a: 				throw new IllegalArgumentException(
1:df2a53a: 						"The blog entry record cannot be inserted: "
1:df2a53a: 								+ blogText);
1:df2a53a: 			ppsm.close();
1:df2a53a: 			
1:df2a53a: 			// insert a row in the relationship table
1:df2a53a: 
1:df2a53a: 			sql = "INSERT INTO Author_BlogEntry VALUES (?,?)";
1:df2a53a: 			ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.setString(1, a.getEmail());
1:df2a53a: 			ppsm.setLong(2, post_id);
1:df2a53a: 
1:df2a53a: 			rows = ppsm.executeUpdate();
1:df2a53a: 			ppsm.close();
1:df2a53a: 			connection.close();
1:df2a53a: 			
1:df2a53a: 			if (rows != 1)
1:df2a53a: 				throw new IllegalArgumentException(
1:df2a53a: 						"The Author_BlogEntry record cannot be inserted: "
1:df2a53a: 								+ a.getEmail() + " , " + post_id);
1:df2a53a: 
1:df2a53a: 		} catch (SQLException sqle) {
1:df2a53a: 			sqle.printStackTrace();
1:df2a53a: 		}
1:df2a53a: 
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Find the blog entry record with the specified title
1:df2a53a: 	 * 
1:df2a53a: 	 * @param The title to be searched
1:df2a53a: 	 * @return The blogEntry record
1:df2a53a: 	 */
1:df2a53a: 	public EntryImpl findBlogEntryByTitle(String title) {
1:df2a53a: 
1:df2a53a: 		EntryImpl be = null;
1:df2a53a: 
1:df2a53a: 		String sql = "SELECT * FROM BlogEntry e WHERE e.title = '" + title
1:df2a53a: 				+ "'";
1:df2a53a: 
1:df2a53a: 		List<EntryImpl> blogEntries = findBlogs(sql);
1:df2a53a: 		
1:df2a53a: 		// just return the first blog entry for the time being
1:df2a53a: 		if ((blogEntries != null) && (blogEntries.size() > 0))
1:df2a53a: 			be = blogEntries.get(0);
1:df2a53a: 		return be;
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return all author records in the Author table
1:df2a53a: 	 * 
1:df2a53a: 	 * @return the list of Author records
1:df2a53a: 	 */
1:df2a53a: 	public List<AuthorImpl> getAllAuthors() {
1:df2a53a: 		String sql = "SELECT * FROM Author";
1:df2a53a: 
1:df2a53a: 		List<AuthorImpl> list = findAuthors(sql);
1:df2a53a: 
1:df2a53a: 		return list;
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return all blog entry records from BlogEntry table with the most recent
1:df2a53a: 	 * published blog entries first
1:df2a53a: 	 * 
1:df2a53a: 	 * @return a list of blogEntry object
1:df2a53a: 	 */
1:df2a53a: 	public List<EntryImpl> getAllBlogEntries() {
1:df2a53a: 		String sql = "SELECT * FROM BlogEntry b ORDER BY b.publishDate DESC";
1:df2a53a: 
1:df2a53a: 		List<EntryImpl> list = findBlogs(sql);
1:df2a53a: 
1:df2a53a: 		return list;
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return the number of the blog entry records
1:df2a53a: 	 * 
1:df2a53a: 	 * @return the number of the blog Entry records
1:df2a53a: 	 */
1:df2a53a: 	public int getNoOfBlogEntries() {
1:df2a53a: 
1:df2a53a: 		int count = 0;
1:df2a53a: 
1:df2a53a: 		String sql = "SELECT count(*) FROM BLOGENTRY";
1:df2a53a: 		try {
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ResultSet rs = ppsm.executeQuery();
1:df2a53a: 			// we only expect to have one row returned
1:df2a53a: 			rs.next();
1:df2a53a: 			count = rs.getInt(1);
1:df2a53a: 			ppsm.close();
1:df2a53a: 			connection.close();
1:df2a53a: 
1:df2a53a: 		} catch (SQLException sqle) {
1:df2a53a: 			sqle.printStackTrace();
1:df2a53a: 		}
1:df2a53a: 		return count;
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return the portion of blog Entries
1:df2a53a: 	 * 
1:df2a53a: 	 * @param firstPostIndex
1:df2a53a: 	 *            The index of the first blog entry to be returned
1:df2a53a: 	 * @param noOfPosts
1:df2a53a: 	 *            The number of blog entry to be returned
1:df2a53a: 	 * @return The list of the blog entry record
1:df2a53a: 	 */
1:df2a53a: 	public List<EntryImpl> getBlogEntries(int firstPostIndex, int noOfPosts) {
1:df2a53a: 		String sql = "SELECT * FROM BlogEntry b ORDER BY b.publishDate DESC";
1:df2a53a: 		List<EntryImpl> emptyList = new ArrayList<EntryImpl>();
1:df2a53a: 		List<EntryImpl> blogs = findBlogs(sql);
1:df2a53a: 		// we only return a portion of the list
1:df2a53a: 		if (blogs == null)
1:df2a53a: 			return emptyList;
1:df2a53a: 		// We need to make sure we won't throw IndexOutOfBoundException if the
1:df2a53a: 		// supplied
1:df2a53a: 		// index is out of the list range
1:df2a53a: 		int maximumIndex = blogs.size();
1:df2a53a: 		// if the first index is minus or greater than the last item index of
1:df2a53a: 		// the list, return an empty list
1:df2a53a: 		if ((firstPostIndex < 0) || (noOfPosts <= 0)
1:df2a53a: 				|| (firstPostIndex > maximumIndex))
1:df2a53a: 			return emptyList;
1:df2a53a: 		// return the required number of the blog entries or the available blog
1:df2a53a: 		// entries
1:df2a53a: 		int lastIndex = noOfPosts + firstPostIndex;
1:df2a53a: 		// we need to make sure we return the blog entries at most up to the
1:df2a53a: 		// final record
1:df2a53a: 
1:df2a53a: 		return (blogs.subList(firstPostIndex,
1:df2a53a: 				(lastIndex > maximumIndex) ? maximumIndex : lastIndex));
1:df2a53a: 
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return the author with the specified email address
1:df2a53a: 	 * 
1:df2a53a: 	 * @param emailAddress
1:df2a53a: 	 *            The email address
1:df2a53a: 	 * @return The author record
1:df2a53a: 	 */
1:df2a53a: 	public AuthorImpl getAuthor(String emailAddress) {
1:df2a53a: 		String sql = "SELECT * FROM AUTHOR a where a.email='" + emailAddress
1:df2a53a: 				+ "'";
1:df2a53a: 		List<AuthorImpl> authors = findAuthors(sql);
1:df2a53a: 
1:df2a53a: 		if (authors.size() == 0)
1:df2a53a: 			return null;
1:df2a53a: 		else if (authors.size() > 1)
1:df2a53a: 			throw new IllegalArgumentException(
1:df2a53a: 					"Email address should be unique per author");
1:df2a53a: 
1:df2a53a: 		return authors.get(0); // just return the first author
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return the blog entries modified between the date range of [start, end]
1:df2a53a: 	 * 
1:df2a53a: 	 * @param start
1:df2a53a: 	 *            The start date
1:df2a53a: 	 * @param end
1:df2a53a: 	 *            The end date
1:df2a53a: 	 * @return The list of blog entries
1:df2a53a: 	 */
1:df2a53a: 	public List<EntryImpl> getBlogEntriesModifiedBetween(Date start, Date end) {
1:df2a53a: 
1:df2a53a: 		// String sql = "SELECT * FROM BlogEntry b WHERE (b.updatedDate >= " +
1:df2a53a: 		// startTS +" AND b.updatedDate <= " + endTS + ") OR (b.publishDate >= "
1:df2a53a: 		// +startTS + " AND b.publishDate <= " + endTS +
1:df2a53a: 		// ") ORDER BY b.publishDate ASC";
1:df2a53a: 		String sql = "SELECT * FROM BlogEntry b WHERE (Date(b.updatedDate) BETWEEN '"
1:df2a53a: 				+ start
1:df2a53a: 				+ "' AND '"
1:df2a53a: 				+ end
1:df2a53a: 				+ "') OR (Date(b.publishDate) BETWEEN '"
1:df2a53a: 				+ start
1:df2a53a: 				+ "' AND  '"
1:df2a53a: 				+ end + "') ORDER BY b.publishDate ASC";
1:df2a53a: 
1:df2a53a: 		return findBlogs(sql);
1:df2a53a: 
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return a list of blog entries belonging to the author with the specified
1:df2a53a: 	 * email address
1:df2a53a: 	 * 
1:df2a53a: 	 * @param emailAddress
1:df2a53a: 	 *            the author's email address
1:df2a53a: 	 * @return The list of blog entries
1:df2a53a: 	 */
1:df2a53a: 	public List<EntryImpl> getBlogsForAuthor(String emailAddress) {
1:df2a53a: 
1:df2a53a: 		String sql = "SELECT * FROM BlogEntry b WHERE b.AUTHOR_EMAIL='"
1:df2a53a: 				+ emailAddress + "'";
1:df2a53a: 		return findBlogs(sql);
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Update the author record
1:df2a53a: 	 * 
1:df2a53a: 	 * @param email
1:df2a53a: 	 * 			The email associated with an author
1:df2a53a: 	 * @param dob
1:df2a53a: 	 * 			The author's date of birth
1:df2a53a: 	 * @param name
1:df2a53a: 	 * 			the author's name
1:df2a53a: 	 * @param displayName
1:df2a53a: 	 * 			The displayName
1:df2a53a: 	 * @param bio
1:df2a53a: 	 * 			The aouthor's bio
1:df2a53a: 	 */
1:df2a53a: 	public void updateAuthor(String email, Date dob, String name,
1:df2a53a: 			String displayName, String bio) {
1:df2a53a: 
1:df2a53a: 		
1:df2a53a: 		String sql = "UPDATE AUTHOR a SET bio = ?, displayName = ?, dob = ?, name =? WHERE email ='"
1:df2a53a: 				+ email + "'";
1:df2a53a: 		int updatedRows = 0;
1:df2a53a: 		try {
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.setString(1, bio);
1:df2a53a: 			ppsm.setString(2, displayName);
1:df2a53a: 			if (dob != null)
1:df2a53a: 				ppsm.setDate(3, new java.sql.Date(dob.getTime()));
1:df2a53a: 			else
1:df2a53a: 				ppsm.setDate(3, null);
1:df2a53a: 			ppsm.setString(4, name);
1:df2a53a: 			updatedRows = ppsm.executeUpdate();
1:df2a53a: 			
1:df2a53a: 			ppsm.close();
1:df2a53a: 			connection.close();
1:df2a53a: 			
1:df2a53a: 			if (updatedRows != 1)
1:df2a53a: 				throw new IllegalArgumentException("The Author " + email
1:df2a53a: 						+ " cannot be updated.");
1:df2a53a: 		} catch (SQLException e) {
1:df2a53a: 			e.printStackTrace();
1:df2a53a: 		}
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Update the blog entry record
1:df2a53a: 	 * 
1:df2a53a: 	 * 
1:df2a53a: 	 */
1:df2a53a: 	public void updateBlogEntry(long id, String email, String title, String blogText, List<String> tags, Date updatedDate) {
1:df2a53a: 		
1:df2a53a: 		if (id == -1)
1:df2a53a: 			throw new IllegalArgumentException(
1:df2a53a: 					"Not a BlogEntry returned by this interface");
1:df2a53a: 		EntryImpl b = getBlogEntryById(id);
1:df2a53a: 		String sql_se = "SELECT * FROM BLOGENTRY bp WHERE bp.id = " + id;
1:df2a53a: 		String email_old = null;
1:df2a53a: 		// let's find out the email address for the blog post to see whether the
1:df2a53a: 		// table Author_BlogEntry needs to be updated
1:df2a53a: 		// if the email is updated, we need to update the table Author_BlogEntry
1:df2a53a: 		// to reflect the change.
1:df2a53a: 		try {
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql_se);
1:df2a53a: 			ResultSet rs = ppsm.executeQuery();
1:df2a53a: 			// there should be just one record
1:df2a53a: 			rs.next();
1:df2a53a: 			email_old = rs.getString("AUTHOR_EMAIL");
1:df2a53a: 			ppsm.close();
1:df2a53a: 			connection.close();
1:df2a53a: 		} catch (SQLException sqle) {
1:df2a53a: 			sqle.printStackTrace();
1:df2a53a: 		}
1:df2a53a: 		String sql = "UPDATE BLOGENTRY bp SET bp.blogText = ?, bp.publishDate = ?, bp.title = ?, bp.updatedDate = ?, bp.AUTHOR_EMAIL = ? where bp.id = "
1:df2a53a: 				+ id;
1:df2a53a: 		int updatedRows = 0;
1:df2a53a: 		
1:df2a53a: 		try {
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.setString(1, blogText);
1:df2a53a: 			if (b.getPublishDate() != null)
1:df2a53a: 				ppsm
1:df2a53a: 						.setDate(2, new java.sql.Date(b.getPublishDate()
1:df2a53a: 								.getTime()));
1:df2a53a: 			else
1:df2a53a: 				ppsm.setDate(2, null);
1:df2a53a: 			ppsm.setString(3, b.getTitle());
1:df2a53a: 			if (b.getUpdatedDate() != null)
1:df2a53a: 				ppsm
1:df2a53a: 						.setDate(4, new java.sql.Date(b.getUpdatedDate()
1:df2a53a: 								.getTime()));
1:df2a53a: 			else
1:df2a53a: 				ppsm.setDate(4, null);
1:df2a53a: 
1:df2a53a: 			ppsm.setString(5, email);
1:df2a53a: 			updatedRows = ppsm.executeUpdate();
1:df2a53a: 			
1:df2a53a: 			ppsm.close();
1:df2a53a: 			
1:df2a53a: 			connection.close();
1:df2a53a: 
1:df2a53a: 			if (updatedRows != 1)
1:df2a53a: 				throw new IllegalArgumentException("The Blog " + b.getId()
1:df2a53a: 						+ " cannot be updated.");
1:df2a53a: 		} catch (SQLException e) {
1:df2a53a: 			e.printStackTrace();
1:df2a53a: 		}
1:df2a53a: 
1:df2a53a: 		// if the email address is changed, we need to need to update the
1:df2a53a: 		// relationship table Author_BlogEntry
1:df2a53a: 		if ((email_old != null) && (!!!email_old.equals(email))) {
1:df2a53a: 			// update the table Author_BlogEntry
1:df2a53a: 			String sql_ab = "UDPATE Author_BlogEntry ab SET ab.AUTHOR_EMAIL = '"
1:df2a53a: 					+ email + "'";
1:df2a53a: 			updatedRows = 0;
1:df2a53a: 			try {
1:df2a53a: 				Connection connection = dataSource.getConnection();
1:df2a53a: 				PreparedStatement ppsm = connection.prepareStatement(sql_ab);
1:df2a53a: 				updatedRows = ppsm.executeUpdate();
1:df2a53a: 				ppsm.close();
1:df2a53a:                 connection.close();
1:df2a53a: 				if (updatedRows != 1)
1:df2a53a: 					throw new IllegalArgumentException(
1:df2a53a: 							"The Author_BlogEntry with the postsID "
1:df2a53a: 									+ b.getId() + " cannot be updated.");
1:df2a53a: 			} catch (SQLException e) {
1:df2a53a: 				e.printStackTrace();
1:df2a53a: 			}
1:df2a53a: 		}
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Delete the author record with the specified email address
1:df2a53a: 	 * 
1:df2a53a: 	 * @param emailAddress
1:df2a53a: 	 *            The author's email address
1:df2a53a: 	 * 
1:df2a53a: 	 */
1:df2a53a: 	public void removeAuthor(String emailAddress) {
1:df2a53a: 
1:df2a53a: 		// we need to remove the author and its blog entries
1:df2a53a: 
1:df2a53a: 		try {
1:df2a53a: 			String sql = "DELETE FROM BLOGENTRY bp WHERE bp.AUTHOR_EMAIL = '"
1:df2a53a: 					+ emailAddress + "'";
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.executeUpdate();
1:df2a53a: 			ppsm.close();
1:df2a53a: 			
1:df2a53a: 			// delete the records from Author_BlogEntry
1:df2a53a: 			sql = "DELETE FROM Author_BlogEntry ab WHERE ab.AUTHOR_EMAIL = '"
1:df2a53a: 					+ emailAddress + "'";
1:df2a53a: 			ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.executeUpdate();
1:df2a53a: 			ppsm.close();
1:df2a53a: 
1:df2a53a: 			// delete the author record
1:df2a53a: 			sql = "DELETE FROM Author a WHERE a.EMAIL = '" + emailAddress + "'";
1:df2a53a: 			ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.executeUpdate();
1:df2a53a: 			ppsm.close();
1:df2a53a: 			connection.close();
1:df2a53a: 
1:df2a53a: 		} catch (SQLException sqle) {
1:df2a53a: 			sqle.printStackTrace();
1:df2a53a: 		}
1:df2a53a: 
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Delete the blog entry record specified by the blogEntry
1:df2a53a: 	 * 
1:df2a53a: 	 * @param blogEntry
1:df2a53a: 	 *            the blog entry record to be deleted
1:df2a53a: 	 */
1:df2a53a: 	public void removeBlogEntry(long id) {
1:df2a53a: 		if (id == -1)
1:df2a53a: 			throw new IllegalArgumentException(
1:df2a53a: 					"Not a BlogEntry returned by this interface");
1:df2a53a: 
1:df2a53a: 		try {
1:df2a53a: 			String sql = "DELETE FROM BLOGENTRY bp WHERE bp.id = "
1:df2a53a: 					+ id;
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.executeUpdate();
1:df2a53a: 			ppsm.close();
1:df2a53a: 			// We also need to delete the records from Author_BlogEntry, as this
1:df2a53a: 			// table is a kind of link between author and blogentry record
1:df2a53a: 			sql = "DELETE FROM Author_BlogEntry ab WHERE ab.POSTS_ID = "
1:df2a53a: 					+ id;
1:df2a53a: 			ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ppsm.executeUpdate();
1:df2a53a: 			ppsm.close();
1:df2a53a: 			connection.close();
1:df2a53a: 
1:df2a53a: 		} catch (SQLException sqle) {
1:df2a53a: 			sqle.printStackTrace();
1:df2a53a: 		}
1:df2a53a: 
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return the blog entry record with the specified id
1:df2a53a: 	 * 
1:df2a53a: 	 * @param postId
1:df2a53a: 	 *            The blogEntry record id
1:df2a53a: 	 */
1:df2a53a: 	public EntryImpl getBlogEntryById(long postId) {
1:df2a53a: 		String sql = "SELECT * FROM BlogEntry b WHERE b.id = " + postId;
1:df2a53a: 		List<EntryImpl> blogs = findBlogs(sql);
1:df2a53a: 		if (blogs.size() == 0)
1:df2a53a: 			return null;
1:df2a53a: 		if (blogs.size() > 1)
1:df2a53a: 			throw new IllegalArgumentException("Blog id is not unique");
1:df2a53a: 		return blogs.get(0);
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return a list of authors with the sql query
1:df2a53a: 	 * 
1:df2a53a: 	 * @param sql
1:df2a53a: 	 *            The SQL query
1:df2a53a: 	 * @return A list of author records
1:df2a53a: 	 */
1:df2a53a: 	private List<AuthorImpl> findAuthors(String sql) {
1:df2a53a: 		List<AuthorImpl> authorList = new ArrayList<AuthorImpl>();
1:df2a53a: 
1:df2a53a: 		try {
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1:df2a53a: 
1:df2a53a: 			ResultSet ars = ppsm.executeQuery();
1:df2a53a: 
1:df2a53a: 			while (ars.next()) {
1:df2a53a: 				AuthorImpl ar = new AuthorImpl();
1:df2a53a: 				ar.setBio(ars.getString("bio"));
1:df2a53a: 				ar.setDisplayName(ars.getString("displayName"));
1:df2a53a: 				ar.setDob(ars.getDate("dob"));
1:df2a53a: 				String email = ars.getString("email");
1:df2a53a: 				ar.setEmail(email);
1:df2a53a: 				ar.setName(ars.getString("name"));
1:df2a53a: 
1:df2a53a: 				// let's find the blog entries for the author
1:df2a53a: 				String sql_be = "SELECT * FROM BLOGENTRY be WHERE be.AUTHOR_EMAIL = '"
1:df2a53a: 						+ email + "'";
1:df2a53a: 				PreparedStatement ppsm2 = connection.prepareStatement(sql_be);
1:df2a53a: 				ResultSet rs = ppsm2.executeQuery();
1:df2a53a: 
1:df2a53a: 				List<EntryImpl> blogs = new ArrayList<EntryImpl>();
1:df2a53a: 				while (rs.next()) {
1:df2a53a: 					EntryImpl blog = new EntryImpl();
1:df2a53a: 					blog.setAuthor(ar);
1:df2a53a: 					blog.setId(rs.getLong("id"));
1:df2a53a: 					blog.setBlogText(rs.getString("blogText"));
1:df2a53a: 					blog.setPublishDate(rs.getDate("publishDate"));
1:df2a53a: 					blog.setTitle(rs.getString("title"));
1:df2a53a: 					blog.setUpdatedDate(rs.getDate("updatedDate"));
1:df2a53a: 					blogs.add(blog);
1:df2a53a: 				}
1:df2a53a: 				ar.setEntries(blogs);
1:df2a53a: 				authorList.add(ar);
1:df2a53a: 				ppsm2.close();
1:df2a53a: 			}
1:df2a53a: 		    ppsm.close();
1:df2a53a: 			connection.close();
1:df2a53a: 		} catch (Exception e) {
1:df2a53a: 			e.printStackTrace();
1:df2a53a: 		}
1:df2a53a: 		return authorList;
1:df2a53a: 	}
1:df2a53a: 
1:df2a53a: 	/**
1:df2a53a: 	 * Return a list of blog entries with the sql query
1:df2a53a: 	 * 
1:df2a53a: 	 * @param sql
1:df2a53a: 	 *            The sql query to be executed
1:df2a53a: 	 * @return a list of blogEntry records
1:df2a53a: 	 */
1:df2a53a: 	private List<EntryImpl> findBlogs(String sql) {
1:df2a53a: 		List<EntryImpl> blogEntryList = new ArrayList<EntryImpl>();
1:df2a53a: 
1:df2a53a: 		try {
1:df2a53a: 			Connection connection = dataSource.getConnection();
1:df2a53a: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1:df2a53a: 			ResultSet blogrs = ppsm.executeQuery();
1:df2a53a: 
1:df2a53a: 			while (blogrs.next()) {
1:df2a53a: 				EntryImpl be = new EntryImpl();
1:df2a53a: 				be.setId(blogrs.getLong("id"));
1:df2a53a: 				be.setBlogText(blogrs.getString("blogText"));
1:df2a53a: 				be.setPublishDate(blogrs.getDate("publishDate"));
1:df2a53a: 				be.setTitle(blogrs.getString("title"));
1:df2a53a: 				be.setUpdatedDate(blogrs.getDate("updatedDate"));
1:df2a53a: 				// find the author email address
1:df2a53a: 				String author_email = blogrs.getString("AUTHOR_EMAIL");
1:df2a53a: 				String author_sql = "SELECT * FROM Author a WHERE a.email ='"
1:df2a53a: 						+ author_email + "'";
1:df2a53a: 				List<AuthorImpl> authors = findAuthors(author_sql);
1:df2a53a: 				// there should be just one entry, as email is the primary key
1:df2a53a: 				// for the Author table
1:df2a53a: 				if (authors.size() != 1)
1:df2a53a: 					throw new IllegalArgumentException(
1:df2a53a: 							"We got more than one author with the same email address. This is wrong");
1:df2a53a: 				else
1:df2a53a: 					be.setAuthor(authors.get(0));
1:df2a53a: 				blogEntryList.add(be);
1:df2a53a: 			}
1:df2a53a: 			ppsm.close();
1:df2a53a: 			connection.close();
1:df2a53a: 		} catch (Exception e) {
1:df2a53a: 			e.printStackTrace();
1:df2a53a: 		}
1:df2a53a: 		return blogEntryList;
1:df2a53a: 	}
1:df2a53a: }
============================================================================
author:Zoe Slattery
-------------------------------------------------------------------------------
commit:df2a53a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.samples.blog.persistence.jdbc;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.text.ParseException;
1: import java.util.ArrayList;
1: import java.util.Date;
1: import java.util.List;
1: 
1: import javax.sql.DataSource;
1: 
1: import org.apache.aries.samples.blog.api.persistence.BlogPersistenceService;
1: import org.apache.aries.samples.blog.persistence.jdbc.entity.AuthorImpl;
1: import org.apache.aries.samples.blog.persistence.jdbc.entity.EntryImpl;
1: 
1: /**
1:  * This class is the implementation of the blogPersistenceService
1:  */
1: public class BlogPersistenceServiceImpl implements BlogPersistenceService {
1: 	private DataSource dataSource;
1: 	
1:     private Statements statements;
1: 
1:     public BlogPersistenceServiceImpl() {
1:         this.statements = new Statements();
1:     }
1: 
1: 	/**
1: 	 * set data source
1: 	 */
1: 	public void setDataSource(DataSource dataSource) {
1: 		this.dataSource = dataSource;
1: 	}
1: 
1:     public void init() {
1:         Statement s = null;
1:         Connection connection = null;
1: 
1:         try {
1:             connection = dataSource.getConnection();
1: 
1:             s = connection.createStatement();
1:             String[] createStatments = this.statements
1:                     .getCreateSchemaStatements();
1:             for (int i = 0; i < createStatments.length; i++) {
1:                 s.execute(createStatments[i]);
1:             }
1:         } catch (SQLException e) {
1:             e.printStackTrace();
1:             throw new RuntimeException(e);
1:         } finally {
1:             if (s != null) {
1:                 try {
1:                     s.close();
1:                 } catch (Throwable e) {
1:                 }
1:             }
1:             if (connection != null) {
1:                 try {
1:                     connection.close();
1:                 } catch (Throwable e) {
1:                 }
1:             }
1:         }
1:     }
1: 
1:     public void destroy() {
1:         Statement s = null;
1:         Connection connection = null;
1: 
1:         try {
1:             connection = dataSource.getConnection();
1: 
1:             s = connection.createStatement();
1:             String[] dropStatments = this.statements.getDropSchemaStatements();
1:             for (int i = 0; i < dropStatments.length; i++) {
1:                 s.execute(dropStatments[i]);
1:             }
1:         } catch (SQLException e) {
1:             e.printStackTrace();
1:             throw new RuntimeException(e);
1:         } finally {
1:             if (s != null) {
1:                 try {
1:                     s.close();
1:                 } catch (Throwable e) {
1:                 }
1:             }
1:             if (connection != null) {
1:                 try {
1:                     connection.close();
1:                 } catch (Throwable e) {
1:                 }
1:             }
1:         }
1:     }
1: 	
1: 	/**
1: 	 * Create an author record
1: 	 * 
1: 	 * @param a
1: 	 *            The author object to be created
1: 	 * @throws ParseException
1: 	 * @throws ParseException
1: 	 */
1: 	public void createAuthor(String email, Date dob, String name,
1: 			String displayName, String bio) {
1: 		
1: 		
1: 		try {
1: 			Connection connection = dataSource.getConnection();
1: 			String sql = "INSERT INTO AUTHOR VALUES (?,?,?,?,?)";
1: 			
1: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1: 			ppsm.setString(1, email);
1: 			ppsm.setString(2, bio);
1: 			ppsm.setString(3, displayName);
1: 			if (dob != null)
1: 				ppsm.setDate(4, new java.sql.Date(dob.getTime()));
1: 			else
1: 				ppsm.setDate(4, null);
1: 			ppsm.setString(5, name);
1: 			int insertRows = ppsm.executeUpdate();
1: 			ppsm.close();
1: 			connection.close();
1: 			
1: 			if (insertRows != 1)
1: 				throw new IllegalArgumentException("The Author " + email
1: 						+ " cannot be inserted.");
1: 		} catch (SQLException e) {
1: 			e.printStackTrace();
1: 			throw new IllegalArgumentException(e.getMessage());
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Create a blog entry record
1: 	 * 
1: 	 * @param a 
1: 	 * 			The author
1: 	 * @param title 
1: 	 * 			The title of the post
1: 	 * @param blogText 
1: 	 * 			The text of the post
1: 	 * @param tags
1: 	 * 
1: 	 */
1: 	public void createBlogPost(String authorEmail, String title, String blogText,
1: 			List<String> tags) {
1: 		
1: 		AuthorImpl a = getAuthor(authorEmail);
1: 		
1: 		if(title == null) title = "";
1: 		Date publishDate = new Date(System.currentTimeMillis());
1: 		if(tags == null) tags = new ArrayList<String>();
1: 		
1: 
1: 		try {
1: 			Connection connection = dataSource.getConnection();
1: 			// let's find the max id from the blogentry table
1: 			String sql = "SELECT max(id) FROM BLOGENTRY";
1: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1: 			ResultSet rs = ppsm.executeQuery();
1: 			// we only expect to have one row returned
1: 			rs.next();
1: 
1: 			long max_id = rs.getLong(1);
1: 			ppsm.close();
1: 			
1: 			long post_id = max_id + 1;
1: 			sql = "INSERT INTO BLOGENTRY VALUES (?,?,?,?,?,?)";
1: 			
1: 		    ppsm = connection.prepareStatement(sql);
1: 			ppsm.setLong(1, post_id);
1: 			ppsm.setString(2, blogText);
1: 			if (publishDate != null)
1: 				ppsm
1: 						.setDate(3, new java.sql.Date(publishDate
1: 								.getTime()));
1: 			else
1: 				ppsm.setDate(3, null);
1: 			ppsm.setString(4, title);
1: 			
1: 		    ppsm.setDate(5, null);
1: 			ppsm.setString(6, a.getEmail());
1: 			int rows = ppsm.executeUpdate();
1: 			if (rows != 1)
1: 				throw new IllegalArgumentException(
1: 						"The blog entry record cannot be inserted: "
1: 								+ blogText);
1: 			ppsm.close();
1: 			
1: 			// insert a row in the relationship table
1: 
1: 			sql = "INSERT INTO Author_BlogEntry VALUES (?,?)";
1: 			ppsm = connection.prepareStatement(sql);
1: 			ppsm.setString(1, a.getEmail());
1: 			ppsm.setLong(2, post_id);
1: 
1: 			rows = ppsm.executeUpdate();
1: 			ppsm.close();
1: 			connection.close();
1: 			
1: 			if (rows != 1)
1: 				throw new IllegalArgumentException(
1: 						"The Author_BlogEntry record cannot be inserted: "
1: 								+ a.getEmail() + " , " + post_id);
1: 
1: 		} catch (SQLException sqle) {
1: 			sqle.printStackTrace();
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Find the blog entry record with the specified title
1: 	 * 
1: 	 * @param The title to be searched
1: 	 * @return The blogEntry record
1: 	 */
1: 	public EntryImpl findBlogEntryByTitle(String title) {
1: 
1: 		EntryImpl be = null;
1: 
1: 		String sql = "SELECT * FROM BlogEntry e WHERE e.title = '" + title
1: 				+ "'";
1: 
1: 		List<EntryImpl> blogEntries = findBlogs(sql);
1: 		
1: 		// just return the first blog entry for the time being
1: 		if ((blogEntries != null) && (blogEntries.size() > 0))
1: 			be = blogEntries.get(0);
1: 		return be;
1: 	}
1: 
1: 	/**
1: 	 * Return all author records in the Author table
1: 	 * 
1: 	 * @return the list of Author records
1: 	 */
1: 	public List<AuthorImpl> getAllAuthors() {
1: 		String sql = "SELECT * FROM Author";
1: 
1: 		List<AuthorImpl> list = findAuthors(sql);
1: 
1: 		return list;
1: 	}
1: 
1: 	/**
1: 	 * Return all blog entry records from BlogEntry table with the most recent
1: 	 * published blog entries first
1: 	 * 
1: 	 * @return a list of blogEntry object
1: 	 */
1: 	public List<EntryImpl> getAllBlogEntries() {
1: 		String sql = "SELECT * FROM BlogEntry b ORDER BY b.publishDate DESC";
1: 
1: 		List<EntryImpl> list = findBlogs(sql);
1: 
1: 		return list;
1: 	}
1: 
1: 	/**
1: 	 * Return the number of the blog entry records
1: 	 * 
1: 	 * @return the number of the blog Entry records
1: 	 */
1: 	public int getNoOfBlogEntries() {
1: 
1: 		int count = 0;
1: 
1: 		String sql = "SELECT count(*) FROM BLOGENTRY";
1: 		try {
1: 			Connection connection = dataSource.getConnection();
1: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1: 			ResultSet rs = ppsm.executeQuery();
1: 			// we only expect to have one row returned
1: 			rs.next();
1: 			count = rs.getInt(1);
1: 			ppsm.close();
1: 			connection.close();
1: 
1: 		} catch (SQLException sqle) {
1: 			sqle.printStackTrace();
1: 		}
1: 		return count;
1: 	}
1: 
1: 	/**
1: 	 * Return the portion of blog Entries
1: 	 * 
1: 	 * @param firstPostIndex
1: 	 *            The index of the first blog entry to be returned
1: 	 * @param noOfPosts
1: 	 *            The number of blog entry to be returned
1: 	 * @return The list of the blog entry record
1: 	 */
1: 	public List<EntryImpl> getBlogEntries(int firstPostIndex, int noOfPosts) {
1: 		String sql = "SELECT * FROM BlogEntry b ORDER BY b.publishDate DESC";
1: 		List<EntryImpl> emptyList = new ArrayList<EntryImpl>();
1: 		List<EntryImpl> blogs = findBlogs(sql);
1: 		// we only return a portion of the list
1: 		if (blogs == null)
1: 			return emptyList;
1: 		// We need to make sure we won't throw IndexOutOfBoundException if the
1: 		// supplied
1: 		// index is out of the list range
1: 		int maximumIndex = blogs.size();
1: 		// if the first index is minus or greater than the last item index of
1: 		// the list, return an empty list
1: 		if ((firstPostIndex < 0) || (noOfPosts <= 0)
1: 				|| (firstPostIndex > maximumIndex))
1: 			return emptyList;
1: 		// return the required number of the blog entries or the available blog
1: 		// entries
1: 		int lastIndex = noOfPosts + firstPostIndex;
1: 		// we need to make sure we return the blog entries at most up to the
1: 		// final record
1: 
1: 		return (blogs.subList(firstPostIndex,
1: 				(lastIndex > maximumIndex) ? maximumIndex : lastIndex));
1: 
1: 	}
1: 
1: 	/**
1: 	 * Return the author with the specified email address
1: 	 * 
1: 	 * @param emailAddress
1: 	 *            The email address
1: 	 * @return The author record
1: 	 */
1: 	public AuthorImpl getAuthor(String emailAddress) {
1: 		String sql = "SELECT * FROM AUTHOR a where a.email='" + emailAddress
1: 				+ "'";
1: 		List<AuthorImpl> authors = findAuthors(sql);
1: 
1: 		if (authors.size() == 0)
1: 			return null;
1: 		else if (authors.size() > 1)
1: 			throw new IllegalArgumentException(
1: 					"Email address should be unique per author");
1: 
1: 		return authors.get(0); // just return the first author
1: 	}
1: 
1: 	/**
1: 	 * Return the blog entries modified between the date range of [start, end]
1: 	 * 
1: 	 * @param start
1: 	 *            The start date
1: 	 * @param end
1: 	 *            The end date
1: 	 * @return The list of blog entries
1: 	 */
1: 	public List<EntryImpl> getBlogEntriesModifiedBetween(Date start, Date end) {
1: 
1: 		// String sql = "SELECT * FROM BlogEntry b WHERE (b.updatedDate >= " +
1: 		// startTS +" AND b.updatedDate <= " + endTS + ") OR (b.publishDate >= "
1: 		// +startTS + " AND b.publishDate <= " + endTS +
1: 		// ") ORDER BY b.publishDate ASC";
1: 		String sql = "SELECT * FROM BlogEntry b WHERE (Date(b.updatedDate) BETWEEN '"
1: 				+ start
1: 				+ "' AND '"
1: 				+ end
1: 				+ "') OR (Date(b.publishDate) BETWEEN '"
1: 				+ start
1: 				+ "' AND  '"
1: 				+ end + "') ORDER BY b.publishDate ASC";
1: 
1: 		return findBlogs(sql);
1: 
1: 	}
1: 
1: 	/**
1: 	 * Return a list of blog entries belonging to the author with the specified
1: 	 * email address
1: 	 * 
1: 	 * @param emailAddress
1: 	 *            the author's email address
1: 	 * @return The list of blog entries
1: 	 */
1: 	public List<EntryImpl> getBlogsForAuthor(String emailAddress) {
1: 
1: 		String sql = "SELECT * FROM BlogEntry b WHERE b.AUTHOR_EMAIL='"
1: 				+ emailAddress + "'";
1: 		return findBlogs(sql);
1: 	}
1: 
1: 	/**
1: 	 * Update the author record
1: 	 * 
1: 	 * @param email
1: 	 * 			The email associated with an author
1: 	 * @param dob
1: 	 * 			The author's date of birth
1: 	 * @param name
1: 	 * 			the author's name
1: 	 * @param displayName
1: 	 * 			The displayName
1: 	 * @param bio
1: 	 * 			The aouthor's bio
1: 	 */
1: 	public void updateAuthor(String email, Date dob, String name,
1: 			String displayName, String bio) {
1: 
1: 		
1: 		String sql = "UPDATE AUTHOR a SET bio = ?, displayName = ?, dob = ?, name =? WHERE email ='"
1: 				+ email + "'";
1: 		int updatedRows = 0;
1: 		try {
1: 			Connection connection = dataSource.getConnection();
1: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1: 			ppsm.setString(1, bio);
1: 			ppsm.setString(2, displayName);
1: 			if (dob != null)
1: 				ppsm.setDate(3, new java.sql.Date(dob.getTime()));
1: 			else
1: 				ppsm.setDate(3, null);
1: 			ppsm.setString(4, name);
1: 			updatedRows = ppsm.executeUpdate();
1: 			
1: 			ppsm.close();
1: 			connection.close();
1: 			
1: 			if (updatedRows != 1)
1: 				throw new IllegalArgumentException("The Author " + email
1: 						+ " cannot be updated.");
1: 		} catch (SQLException e) {
1: 			e.printStackTrace();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Update the blog entry record
1: 	 * 
1: 	 * 
1: 	 */
1: 	public void updateBlogEntry(long id, String email, String title, String blogText, List<String> tags, Date updatedDate) {
1: 		
1: 		if (id == -1)
1: 			throw new IllegalArgumentException(
1: 					"Not a BlogEntry returned by this interface");
1: 		EntryImpl b = getBlogEntryById(id);
1: 		String sql_se = "SELECT * FROM BLOGENTRY bp WHERE bp.id = " + id;
1: 		String email_old = null;
1: 		// let's find out the email address for the blog post to see whether the
1: 		// table Author_BlogEntry needs to be updated
1: 		// if the email is updated, we need to update the table Author_BlogEntry
1: 		// to reflect the change.
1: 		try {
1: 			Connection connection = dataSource.getConnection();
1: 			PreparedStatement ppsm = connection.prepareStatement(sql_se);
1: 			ResultSet rs = ppsm.executeQuery();
1: 			// there should be just one record
1: 			rs.next();
1: 			email_old = rs.getString("AUTHOR_EMAIL");
1: 			ppsm.close();
1: 			connection.close();
1: 		} catch (SQLException sqle) {
1: 			sqle.printStackTrace();
1: 		}
1: 		String sql = "UPDATE BLOGENTRY bp SET bp.blogText = ?, bp.publishDate = ?, bp.title = ?, bp.updatedDate = ?, bp.AUTHOR_EMAIL = ? where bp.id = "
1: 				+ id;
1: 		int updatedRows = 0;
1: 		
1: 		try {
1: 			Connection connection = dataSource.getConnection();
1: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1: 			ppsm.setString(1, blogText);
1: 			if (b.getPublishDate() != null)
1: 				ppsm
1: 						.setDate(2, new java.sql.Date(b.getPublishDate()
1: 								.getTime()));
1: 			else
1: 				ppsm.setDate(2, null);
1: 			ppsm.setString(3, b.getTitle());
1: 			if (b.getUpdatedDate() != null)
1: 				ppsm
1: 						.setDate(4, new java.sql.Date(b.getUpdatedDate()
1: 								.getTime()));
1: 			else
1: 				ppsm.setDate(4, null);
1: 
1: 			ppsm.setString(5, email);
1: 			updatedRows = ppsm.executeUpdate();
1: 			
1: 			ppsm.close();
1: 			
1: 			connection.close();
1: 
1: 			if (updatedRows != 1)
1: 				throw new IllegalArgumentException("The Blog " + b.getId()
1: 						+ " cannot be updated.");
1: 		} catch (SQLException e) {
1: 			e.printStackTrace();
1: 		}
1: 
1: 		// if the email address is changed, we need to need to update the
1: 		// relationship table Author_BlogEntry
1: 		if ((email_old != null) && (!!!email_old.equals(email))) {
1: 			// update the table Author_BlogEntry
1: 			String sql_ab = "UDPATE Author_BlogEntry ab SET ab.AUTHOR_EMAIL = '"
1: 					+ email + "'";
1: 			updatedRows = 0;
1: 			try {
1: 				Connection connection = dataSource.getConnection();
1: 				PreparedStatement ppsm = connection.prepareStatement(sql_ab);
1: 				updatedRows = ppsm.executeUpdate();
1: 				ppsm.close();
1:                 connection.close();
1: 				if (updatedRows != 1)
1: 					throw new IllegalArgumentException(
1: 							"The Author_BlogEntry with the postsID "
1: 									+ b.getId() + " cannot be updated.");
1: 			} catch (SQLException e) {
1: 				e.printStackTrace();
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Delete the author record with the specified email address
1: 	 * 
1: 	 * @param emailAddress
1: 	 *            The author's email address
1: 	 * 
1: 	 */
1: 	public void removeAuthor(String emailAddress) {
1: 
1: 		// we need to remove the author and its blog entries
1: 
1: 		try {
1: 			String sql = "DELETE FROM BLOGENTRY bp WHERE bp.AUTHOR_EMAIL = '"
1: 					+ emailAddress + "'";
1: 			Connection connection = dataSource.getConnection();
1: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1: 			ppsm.executeUpdate();
1: 			ppsm.close();
1: 			
1: 			// delete the records from Author_BlogEntry
1: 			sql = "DELETE FROM Author_BlogEntry ab WHERE ab.AUTHOR_EMAIL = '"
1: 					+ emailAddress + "'";
1: 			ppsm = connection.prepareStatement(sql);
1: 			ppsm.executeUpdate();
1: 			ppsm.close();
1: 
1: 			// delete the author record
1: 			sql = "DELETE FROM Author a WHERE a.EMAIL = '" + emailAddress + "'";
1: 			ppsm = connection.prepareStatement(sql);
1: 			ppsm.executeUpdate();
1: 			ppsm.close();
1: 			connection.close();
1: 
1: 		} catch (SQLException sqle) {
1: 			sqle.printStackTrace();
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Delete the blog entry record specified by the blogEntry
1: 	 * 
1: 	 * @param blogEntry
1: 	 *            the blog entry record to be deleted
1: 	 */
1: 	public void removeBlogEntry(long id) {
1: 		if (id == -1)
1: 			throw new IllegalArgumentException(
1: 					"Not a BlogEntry returned by this interface");
1: 
1: 		try {
1: 			String sql = "DELETE FROM BLOGENTRY bp WHERE bp.id = "
1: 					+ id;
1: 			Connection connection = dataSource.getConnection();
1: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1: 			ppsm.executeUpdate();
1: 			ppsm.close();
1: 			// We also need to delete the records from Author_BlogEntry, as this
1: 			// table is a kind of link between author and blogentry record
1: 			sql = "DELETE FROM Author_BlogEntry ab WHERE ab.POSTS_ID = "
1: 					+ id;
1: 			ppsm = connection.prepareStatement(sql);
1: 			ppsm.executeUpdate();
1: 			ppsm.close();
1: 			connection.close();
1: 
1: 		} catch (SQLException sqle) {
1: 			sqle.printStackTrace();
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Return the blog entry record with the specified id
1: 	 * 
1: 	 * @param postId
1: 	 *            The blogEntry record id
1: 	 */
1: 	public EntryImpl getBlogEntryById(long postId) {
1: 		String sql = "SELECT * FROM BlogEntry b WHERE b.id = " + postId;
1: 		List<EntryImpl> blogs = findBlogs(sql);
1: 		if (blogs.size() == 0)
1: 			return null;
1: 		if (blogs.size() > 1)
1: 			throw new IllegalArgumentException("Blog id is not unique");
1: 		return blogs.get(0);
1: 	}
1: 
1: 	/**
1: 	 * Return a list of authors with the sql query
1: 	 * 
1: 	 * @param sql
1: 	 *            The SQL query
1: 	 * @return A list of author records
1: 	 */
1: 	private List<AuthorImpl> findAuthors(String sql) {
1: 		List<AuthorImpl> authorList = new ArrayList<AuthorImpl>();
1: 
1: 		try {
1: 			Connection connection = dataSource.getConnection();
1: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1: 
1: 			ResultSet ars = ppsm.executeQuery();
1: 
1: 			while (ars.next()) {
1: 				AuthorImpl ar = new AuthorImpl();
1: 				ar.setBio(ars.getString("bio"));
1: 				ar.setDisplayName(ars.getString("displayName"));
1: 				ar.setDob(ars.getDate("dob"));
1: 				String email = ars.getString("email");
1: 				ar.setEmail(email);
1: 				ar.setName(ars.getString("name"));
1: 
1: 				// let's find the blog entries for the author
1: 				String sql_be = "SELECT * FROM BLOGENTRY be WHERE be.AUTHOR_EMAIL = '"
1: 						+ email + "'";
1: 				PreparedStatement ppsm2 = connection.prepareStatement(sql_be);
1: 				ResultSet rs = ppsm2.executeQuery();
1: 
1: 				List<EntryImpl> blogs = new ArrayList<EntryImpl>();
1: 				while (rs.next()) {
1: 					EntryImpl blog = new EntryImpl();
1: 					blog.setAuthor(ar);
1: 					blog.setId(rs.getLong("id"));
1: 					blog.setBlogText(rs.getString("blogText"));
1: 					blog.setPublishDate(rs.getDate("publishDate"));
1: 					blog.setTitle(rs.getString("title"));
1: 					blog.setUpdatedDate(rs.getDate("updatedDate"));
1: 					blogs.add(blog);
1: 				}
1: 				ar.setEntries(blogs);
1: 				authorList.add(ar);
1: 				ppsm2.close();
1: 			}
1: 		    ppsm.close();
1: 			connection.close();
1: 		} catch (Exception e) {
1: 			e.printStackTrace();
1: 		}
1: 		return authorList;
1: 	}
1: 
1: 	/**
1: 	 * Return a list of blog entries with the sql query
1: 	 * 
1: 	 * @param sql
1: 	 *            The sql query to be executed
1: 	 * @return a list of blogEntry records
1: 	 */
1: 	private List<EntryImpl> findBlogs(String sql) {
1: 		List<EntryImpl> blogEntryList = new ArrayList<EntryImpl>();
1: 
1: 		try {
1: 			Connection connection = dataSource.getConnection();
1: 			PreparedStatement ppsm = connection.prepareStatement(sql);
1: 			ResultSet blogrs = ppsm.executeQuery();
1: 
1: 			while (blogrs.next()) {
1: 				EntryImpl be = new EntryImpl();
1: 				be.setId(blogrs.getLong("id"));
1: 				be.setBlogText(blogrs.getString("blogText"));
1: 				be.setPublishDate(blogrs.getDate("publishDate"));
1: 				be.setTitle(blogrs.getString("title"));
1: 				be.setUpdatedDate(blogrs.getDate("updatedDate"));
1: 				// find the author email address
1: 				String author_email = blogrs.getString("AUTHOR_EMAIL");
1: 				String author_sql = "SELECT * FROM Author a WHERE a.email ='"
1: 						+ author_email + "'";
1: 				List<AuthorImpl> authors = findAuthors(author_sql);
1: 				// there should be just one entry, as email is the primary key
1: 				// for the Author table
1: 				if (authors.size() != 1)
1: 					throw new IllegalArgumentException(
1: 							"We got more than one author with the same email address. This is wrong");
1: 				else
1: 					be.setAuthor(authors.get(0));
1: 				blogEntryList.add(be);
1: 			}
1: 			ppsm.close();
1: 			connection.close();
1: 		} catch (Exception e) {
1: 			e.printStackTrace();
1: 		}
1: 		return blogEntryList;
1: 	}
1: }
commit:afa98ec
commit:1bf77fb
commit:3bf8e16
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: package org.apache.aries.samples.blog.persistence;
0: 
0: import java.util.ArrayList;
0: import java.util.Date;
0: import java.util.List;
0: 
0: import javax.persistence.EntityManager;
0: import javax.persistence.PersistenceContext;
0: import javax.persistence.Query;
0: 
0: import org.apache.aries.samples.blog.persistence.api.BlogPersistenceService;
0: import org.apache.aries.samples.blog.persistence.api.Entry;
0: import org.apache.aries.samples.blog.persistence.entity.AuthorImpl;
0: import org.apache.aries.samples.blog.persistence.entity.EntryImpl;
0: 
0: /**
0:  * This class is the implementation of the blogPersistenceService
0:  */
0: public class BlogPersistenceServiceImpl implements BlogPersistenceService {
0: 
0: 	private EntityManager em;
0: 	
0: 	public BlogPersistenceServiceImpl() {
0: 	}
0: 
0: 	// Annotation scanning injects us with an EntityManager, the associated
0: 	// persistenceUnit details can be found in the persistence.xml associated
0: 	// with this bundle.
0: 	@PersistenceContext(unitName = "blogExample")
0: 	public void setEntityManager(EntityManager e) {
0: 		em = e;
0: 	}
0: 
0: 	public void createAuthor(String email, Date dob, String name,
0: 			String displayName, String bio) {
0: 		AuthorImpl a = new AuthorImpl();
0: 		a.setEmail(email);
0: 		a.setName(name);
0: 		a.setDisplayName(displayName);
0: 		a.setBio(bio);
0: 		a.setDob(dob);
0: 		em.persist(a);
0: 		
0: 	}
0: 
0: 	public void createBlogPost(String authorEmail, String title,
0: 			String blogText, List<String> tags) {
0: 
0: 		AuthorImpl a = em.find(AuthorImpl.class, authorEmail);
0: 		EntryImpl b = new EntryImpl();
0: 
0: 		Date publishDate = new Date(System.currentTimeMillis());
0: 
0: 		b.setBlogText(blogText);
0: 		b.setAuthor(a);
0: 		b.setTitle((title == null) ? "" : title);
0: 		b.setPublishDate(publishDate);
0: 		b.setTags((tags == null) ? new ArrayList<String>() : tags);
0: 
0: 		a.updateEntries(b);
0: 		em.persist(b);
0: 		em.merge(b.getAuthor());
0: 	}
0: 
0: 	public Entry findBlogEntryByTitle(String title) {
0: 		Query q = em
0: 				.createQuery("SELECT e FROM BLOGENTRY e WHERE e.title = ?1");
0: 		q.setParameter(1, title);
0: 		Entry b = (Entry) q.getSingleResult();
0: 		return b;
0: 	}
0: 
0: 	public List<AuthorImpl> getAllAuthors() {
0: 		@SuppressWarnings("unchecked")
0: 		List<AuthorImpl> list = em.createQuery("SELECT a FROM AUTHOR a")
0: 				.getResultList();
0: 
0: 		return list;
0: 	}
0: 
0: 	public List<EntryImpl> getAllBlogEntries() {
0: 		@SuppressWarnings("unchecked")
0: 		List<EntryImpl> list = em.createQuery(
0: 				"SELECT b FROM BLOGENTRY b ORDER BY b.publishDate DESC")
0: 				.getResultList();
0: 		return list;
0: 		
0: 	}
0: 
0: 	public int getNoOfBlogEntries() {
0: 		Number n = (Number) em.createQuery(
0: 				"SELECT COUNT(b) FROM BLOGENTRY b").getSingleResult();
0: 		return n.intValue();
0: 	}
0: 
0: 	public List<EntryImpl> getBlogEntries(int firstPostIndex, int noOfPosts) {
0: 		Query q = em
0: 				.createQuery("SELECT b FROM BLOGENTRY b ORDER BY b.publishDate DESC");
0: 		q.setFirstResult(firstPostIndex);
0: 		q.setMaxResults(noOfPosts);
0: 
0: 		@SuppressWarnings("unchecked")
0: 		List<EntryImpl> list = q.getResultList();
0: 
0: 		return list;
0: 	}
0: 
0: 	public AuthorImpl getAuthor(String emailAddress) {
0: 		AuthorImpl a = em.find(AuthorImpl.class, emailAddress);
0: 		return a;
0: 	}
0: 
0: 	public List<EntryImpl> getBlogEntriesModifiedBetween(Date start, Date end) {
0: 		Query q = em
0: 				.createQuery("SELECT b FROM BLOGENTRY b WHERE (b.updatedDate >= :start AND b.updatedDate <= :end) OR (b.publishDate >= :start AND b.publishDate <= :end) ORDER BY b.publishDate ASC");
0: 		q.setParameter("start", start);
0: 		q.setParameter("end", end);
0: 
0: 		@SuppressWarnings("unchecked")
0: 		List<EntryImpl> list = q.getResultList();
0: 
0: 		return list;
0: 	}
0: 	
0: 	public List<EntryImpl> getBlogsForAuthor(String emailAddress) {
0: 
0: 		List<EntryImpl> list = em.find(AuthorImpl.class, emailAddress)
0: 				.getEntries();
0: 		
0: 		return list;
0: 
0: 	}
0: 
0: 	public void updateAuthor(String email, Date dob, String name,
0: 			String displayName, String bio) {
0: 		AuthorImpl a = em.find(AuthorImpl.class, email);
0: 		a.setEmail(email);
0: 		a.setName(name);
0: 		a.setDisplayName(displayName);
0: 		a.setBio(bio);
0: 		a.setDob(dob);
0: 		em.merge(a);
0: 	}
0: 	
0: 	public void updateBlogEntry(long id, String email, String title,
0: 			String blogText, List<String> tags, Date updatedDate) {
0: 		EntryImpl b = em.find(EntryImpl.class, id);
0: 		b.setTitle(title);
0: 		b.setBlogText(blogText);
0: 		b.setTags(tags);
0: 		b.setUpdatedDate(updatedDate);
0: 
0: 		em.merge(b);
0: 	}
0: 
0: 	public void removeAuthor(String emailAddress) {
0: 		em.remove(em.find(AuthorImpl.class, emailAddress));
0: 	}
0: 
0: 	public void removeBlogEntry(long id) {
0: 		EntryImpl b = em.find(EntryImpl.class, id);
0: 		b = em.merge(b);
0: 		b.getAuthor().getEntries().remove(b);
0: 
0: 		em.remove(em.merge(b));
0: 		em.merge(b.getAuthor());
0: 
0: 	}
0: 
0: 	public EntryImpl getBlogEntryById(long postId) {
0: 		EntryImpl b =  em.find(EntryImpl.class, postId);
0: 		return b;
0: 	}
0: 
0: 	public void setPublishDate (long postId, Date date) {
0: 		//Added for testing
0: 		EntryImpl b = em.find(EntryImpl.class, postId);
0: 		b.setPublishDate(date);	
0: 		em.merge(b);
0: 	}
0: 	
0: 	public void setUpdatedDate (long postId, Date date) {
0: 		//Added for testing
0: 		EntryImpl b = em.find(EntryImpl.class, postId);
0: 		b.setUpdatedDate(date);	
0: 		em.merge(b);
0: 	}
0: }
commit:fe9608b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.samples.blog.persistence.entity.EntryImpl;
/////////////////////////////////////////////////////////////////////////
0: 	public void createBlogPost(String authorEmail, String title, String blogText,
0: 		AuthorImpl a = getAuthor(authorEmail);
/////////////////////////////////////////////////////////////////////////
0: 	public EntryImpl findBlogEntryByTitle(String title) {
0: 		EntryImpl be = null;
0: 		List<EntryImpl> blogEntries = findBlogs(sql);
/////////////////////////////////////////////////////////////////////////
0: 	public List<AuthorImpl> getAllAuthors() {
0: 		List<AuthorImpl> list = findAuthors(sql);
/////////////////////////////////////////////////////////////////////////
0: 	public List<EntryImpl> getAllBlogEntries() {
0: 		List<EntryImpl> list = findBlogs(sql);
/////////////////////////////////////////////////////////////////////////
0: 	public List<EntryImpl> getBlogEntries(int firstPostIndex, int noOfPosts) {
0: 		List<EntryImpl> emptyList = new ArrayList<EntryImpl>();
0: 		List<EntryImpl> blogs = findBlogs(sql);
/////////////////////////////////////////////////////////////////////////
0: 	public AuthorImpl getAuthor(String emailAddress) {
0: 		List<AuthorImpl> authors = findAuthors(sql);
/////////////////////////////////////////////////////////////////////////
0: 	public List<EntryImpl> getBlogEntriesModifiedBetween(Date start, Date end) {
/////////////////////////////////////////////////////////////////////////
0: 	public List<EntryImpl> getBlogsForAuthor(String emailAddress) {
/////////////////////////////////////////////////////////////////////////
0: 	 * 
0: 	public void updateBlogEntry(long id, String email, String title, String blogText, List<String> tags, Date updatedDate) {
0: 		if (id == -1)
0: 		EntryImpl b = getBlogEntryById(id);
0: 		String sql_se = "SELECT * FROM BLOGENTRY bp WHERE bp.id = " + id;
/////////////////////////////////////////////////////////////////////////
0: 				+ id;
0: 		
0: 			ppsm.setString(1, blogText);
/////////////////////////////////////////////////////////////////////////
0: 	public void removeBlogEntry(long id) {
0: 		if (id == -1)
0: 					+ id;
/////////////////////////////////////////////////////////////////////////
0: 					+ id;
/////////////////////////////////////////////////////////////////////////
0: 	public EntryImpl getBlogEntryById(long postId) {
0: 		List<EntryImpl> blogs = findBlogs(sql);
/////////////////////////////////////////////////////////////////////////
0: 	private List<AuthorImpl> findAuthors(String sql) {
0: 		List<AuthorImpl> authorList = new ArrayList<AuthorImpl>();
/////////////////////////////////////////////////////////////////////////
0: 				AuthorImpl ar = new AuthorImpl();
/////////////////////////////////////////////////////////////////////////
0: 				List<EntryImpl> blogs = new ArrayList<EntryImpl>();
0: 					EntryImpl blog = new EntryImpl();
/////////////////////////////////////////////////////////////////////////
0: 				ar.setEntries(blogs);
/////////////////////////////////////////////////////////////////////////
0: 	private List<EntryImpl> findBlogs(String sql) {
0: 		List<EntryImpl> blogEntryList = new ArrayList<EntryImpl>();
/////////////////////////////////////////////////////////////////////////
0: 				EntryImpl be = new EntryImpl();
/////////////////////////////////////////////////////////////////////////
0: 				List<AuthorImpl> authors = findAuthors(author_sql);
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:c887046
/////////////////////////////////////////////////////////////////////////
0: package org.apache.aries.samples.blog.persistence.jdbc;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.samples.blog.persistence.jdbc.entity.AuthorImpl;
0: import org.apache.aries.samples.blog.persistence.jdbc.entity.EntryImpl;
commit:380a6c0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.samples.blog.api.persistence.BlogPersistenceService;
commit:e0beeec
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.samples.blog.api.persistence.api.BlogPersistenceService;
commit:f189a6a
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.samples.blog.persistence;
0: 
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.text.ParseException;
0: import java.util.ArrayList;
0: import java.util.Date;
0: import java.util.List;
0: 
0: import javax.sql.DataSource;
0: 
0: import org.apache.aries.samples.blog.persistence.api.BlogPersistenceService;
0: import org.apache.aries.samples.blog.persistence.entity.AuthorImpl;
0: import org.apache.aries.samples.blog.persistence.entity.EntryImpl;
0: 
0: /**
0:  * This class is the implementation of the blogPersistenceService
0:  */
0: public class BlogPersistenceServiceImpl implements BlogPersistenceService {
0: 	private DataSource dataSource;
0: 	
0: 
0: 	/**
0: 	 * set data source
0: 	 */
0: 	public void setDataSource(DataSource dataSource) {
0: 		this.dataSource = dataSource;
0: 	}
0: 
0: 	/**
0: 	 * Create an author record
0: 	 * 
0: 	 * @param a
0: 	 *            The author object to be created
0: 	 * @throws ParseException
0: 	 * @throws ParseException
0: 	 */
0: 	public void createAuthor(String email, Date dob, String name,
0: 			String displayName, String bio) {
0: 		
0: 		
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			String sql = "INSERT INTO AUTHOR VALUES (?,?,?,?,?)";
0: 			
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.setString(1, email);
0: 			ppsm.setString(2, bio);
0: 			ppsm.setString(3, displayName);
0: 			if (dob != null)
0: 				ppsm.setDate(4, new java.sql.Date(dob.getTime()));
0: 			else
0: 				ppsm.setDate(4, null);
0: 			ppsm.setString(5, name);
0: 			int insertRows = ppsm.executeUpdate();
0: 			ppsm.close();
0: 			connection.close();
0: 			
0: 			if (insertRows != 1)
0: 				throw new IllegalArgumentException("The Author " + email
0: 						+ " cannot be inserted.");
0: 		} catch (SQLException e) {
0: 			e.printStackTrace();
0: 			throw new IllegalArgumentException(e.getMessage());
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Create a blog entry record
0: 	 * 
0: 	 * @param a 
0: 	 * 			The author
0: 	 * @param title 
0: 	 * 			The title of the post
0: 	 * @param blogText 
0: 	 * 			The text of the post
0: 	 * @param tags
0: 	 * 
0: 	 */
0: 	public void createBlogPost(String authorEmail, String title, String blogText,
0: 			List<String> tags) {
0: 		
0: 		AuthorImpl a = getAuthor(authorEmail);
0: 		
0: 		if(title == null) title = "";
0: 		Date publishDate = new Date(System.currentTimeMillis());
0: 		if(tags == null) tags = new ArrayList<String>();
0: 		
0: 
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			// let's find the max id from the blogentry table
0: 			String sql = "SELECT max(id) FROM BLOGENTRY";
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ResultSet rs = ppsm.executeQuery();
0: 			// we only expect to have one row returned
0: 			rs.next();
0: 
0: 			long max_id = rs.getLong(1);
0: 			ppsm.close();
0: 			
0: 			long post_id = max_id + 1;
0: 			sql = "INSERT INTO BLOGENTRY VALUES (?,?,?,?,?,?)";
0: 			
0: 		    ppsm = connection.prepareStatement(sql);
0: 			ppsm.setLong(1, post_id);
0: 			ppsm.setString(2, blogText);
0: 			if (publishDate != null)
0: 				ppsm
0: 						.setDate(3, new java.sql.Date(publishDate
0: 								.getTime()));
0: 			else
0: 				ppsm.setDate(3, null);
0: 			ppsm.setString(4, title);
0: 			
0: 		    ppsm.setDate(5, null);
0: 			ppsm.setString(6, a.getEmail());
0: 			int rows = ppsm.executeUpdate();
0: 			if (rows != 1)
0: 				throw new IllegalArgumentException(
0: 						"The blog entry record cannot be inserted: "
0: 								+ blogText);
0: 			ppsm.close();
0: 			
0: 			// insert a row in the relationship table
0: 
0: 			sql = "INSERT INTO Author_BlogEntry VALUES (?,?)";
0: 			ppsm = connection.prepareStatement(sql);
0: 			ppsm.setString(1, a.getEmail());
0: 			ppsm.setLong(2, post_id);
0: 
0: 			rows = ppsm.executeUpdate();
0: 			ppsm.close();
0: 			connection.close();
0: 			
0: 			if (rows != 1)
0: 				throw new IllegalArgumentException(
0: 						"The Author_BlogEntry record cannot be inserted: "
0: 								+ a.getEmail() + " , " + post_id);
0: 
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Find the blog entry record with the specified title
0: 	 * 
0: 	 * @param The title to be searched
0: 	 * @return The blogEntry record
0: 	 */
0: 	public EntryImpl findBlogEntryByTitle(String title) {
0: 
0: 		EntryImpl be = null;
0: 
0: 		String sql = "SELECT * FROM BlogEntry e WHERE e.title = '" + title
0: 				+ "'";
0: 
0: 		List<EntryImpl> blogEntries = findBlogs(sql);
0: 		
0: 		// just return the first blog entry for the time being
0: 		if ((blogEntries != null) && (blogEntries.size() > 0))
0: 			be = blogEntries.get(0);
0: 		return be;
0: 	}
0: 
0: 	/**
0: 	 * Return all author records in the Author table
0: 	 * 
0: 	 * @return the list of Author records
0: 	 */
0: 	public List<AuthorImpl> getAllAuthors() {
0: 		String sql = "SELECT * FROM Author";
0: 
0: 		List<AuthorImpl> list = findAuthors(sql);
0: 
0: 		return list;
0: 	}
0: 
0: 	/**
0: 	 * Return all blog entry records from BlogEntry table with the most recent
0: 	 * published blog entries first
0: 	 * 
0: 	 * @return a list of blogEntry object
0: 	 */
0: 	public List<EntryImpl> getAllBlogEntries() {
0: 		String sql = "SELECT * FROM BlogEntry b ORDER BY b.publishDate DESC";
0: 
0: 		List<EntryImpl> list = findBlogs(sql);
0: 
0: 		return list;
0: 	}
0: 
0: 	/**
0: 	 * Return the number of the blog entry records
0: 	 * 
0: 	 * @return the number of the blog Entry records
0: 	 */
0: 	public int getNoOfBlogEntries() {
0: 
0: 		int count = 0;
0: 
0: 		String sql = "SELECT count(*) FROM BLOGENTRY";
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ResultSet rs = ppsm.executeQuery();
0: 			// we only expect to have one row returned
0: 			rs.next();
0: 			count = rs.getInt(1);
0: 			ppsm.close();
0: 			connection.close();
0: 
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 		return count;
0: 	}
0: 
0: 	/**
0: 	 * Return the portion of blog Entries
0: 	 * 
0: 	 * @param firstPostIndex
0: 	 *            The index of the first blog entry to be returned
0: 	 * @param noOfPosts
0: 	 *            The number of blog entry to be returned
0: 	 * @return The list of the blog entry record
0: 	 */
0: 	public List<EntryImpl> getBlogEntries(int firstPostIndex, int noOfPosts) {
0: 		String sql = "SELECT * FROM BlogEntry b ORDER BY b.publishDate DESC";
0: 		List<EntryImpl> emptyList = new ArrayList<EntryImpl>();
0: 		List<EntryImpl> blogs = findBlogs(sql);
0: 		// we only return a portion of the list
0: 		if (blogs == null)
0: 			return emptyList;
0: 		// We need to make sure we won't throw IndexOutOfBoundException if the
0: 		// supplied
0: 		// index is out of the list range
0: 		int maximumIndex = blogs.size();
0: 		// if the first index is minus or greater than the last item index of
0: 		// the list, return an empty list
0: 		if ((firstPostIndex < 0) || (noOfPosts <= 0)
0: 				|| (firstPostIndex > maximumIndex))
0: 			return emptyList;
0: 		// return the required number of the blog entries or the available blog
0: 		// entries
0: 		int lastIndex = noOfPosts + firstPostIndex;
0: 		// we need to make sure we return the blog entries at most up to the
0: 		// final record
0: 
0: 		return (blogs.subList(firstPostIndex,
0: 				(lastIndex > maximumIndex) ? maximumIndex : lastIndex));
0: 
0: 	}
0: 
0: 	/**
0: 	 * Return the author with the specified email address
0: 	 * 
0: 	 * @param emailAddress
0: 	 *            The email address
0: 	 * @return The author record
0: 	 */
0: 	public AuthorImpl getAuthor(String emailAddress) {
0: 		String sql = "SELECT * FROM AUTHOR a where a.email='" + emailAddress
0: 				+ "'";
0: 		List<AuthorImpl> authors = findAuthors(sql);
0: 
0: 		if (authors.size() == 0)
0: 			return null;
0: 		else if (authors.size() > 1)
0: 			throw new IllegalArgumentException(
0: 					"Email address should be unique per author");
0: 
0: 		return authors.get(0); // just return the first author
0: 	}
0: 
0: 	/**
0: 	 * Return the blog entries modified between the date range of [start, end]
0: 	 * 
0: 	 * @param start
0: 	 *            The start date
0: 	 * @param end
0: 	 *            The end date
0: 	 * @return The list of blog entries
0: 	 */
0: 	public List<EntryImpl> getBlogEntriesModifiedBetween(Date start, Date end) {
0: 
0: 		// String sql = "SELECT * FROM BlogEntry b WHERE (b.updatedDate >= " +
0: 		// startTS +" AND b.updatedDate <= " + endTS + ") OR (b.publishDate >= "
0: 		// +startTS + " AND b.publishDate <= " + endTS +
0: 		// ") ORDER BY b.publishDate ASC";
0: 		String sql = "SELECT * FROM BlogEntry b WHERE (Date(b.updatedDate) BETWEEN '"
0: 				+ start
0: 				+ "' AND '"
0: 				+ end
0: 				+ "') OR (Date(b.publishDate) BETWEEN '"
0: 				+ start
0: 				+ "' AND  '"
0: 				+ end + "') ORDER BY b.publishDate ASC";
0: 
0: 		return findBlogs(sql);
0: 
0: 	}
0: 
0: 	/**
0: 	 * Return a list of blog entries belonging to the author with the specified
0: 	 * email address
0: 	 * 
0: 	 * @param emailAddress
0: 	 *            the author's email address
0: 	 * @return The list of blog entries
0: 	 */
0: 	public List<EntryImpl> getBlogsForAuthor(String emailAddress) {
0: 
0: 		String sql = "SELECT * FROM BlogEntry b WHERE b.AUTHOR_EMAIL='"
0: 				+ emailAddress + "'";
0: 		return findBlogs(sql);
0: 	}
0: 
0: 	/**
0: 	 * Update the author record
0: 	 * 
0: 	 * @param email
0: 	 * 			The email associated with an author
0: 	 * @param dob
0: 	 * 			The author's date of birth
0: 	 * @param name
0: 	 * 			the author's name
0: 	 * @param displayName
0: 	 * 			The displayName
0: 	 * @param bio
0: 	 * 			The aouthor's bio
0: 	 */
0: 	public void updateAuthor(String email, Date dob, String name,
0: 			String displayName, String bio) {
0: 
0: 		
0: 		String sql = "UPDATE AUTHOR a SET bio = ?, displayName = ?, dob = ?, name =? WHERE email ='"
0: 				+ email + "'";
0: 		int updatedRows = 0;
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.setString(1, bio);
0: 			ppsm.setString(2, displayName);
0: 			if (dob != null)
0: 				ppsm.setDate(3, new java.sql.Date(dob.getTime()));
0: 			else
0: 				ppsm.setDate(3, null);
0: 			ppsm.setString(4, name);
0: 			updatedRows = ppsm.executeUpdate();
0: 			
0: 			ppsm.close();
0: 			connection.close();
0: 			
0: 			if (updatedRows != 1)
0: 				throw new IllegalArgumentException("The Author " + email
0: 						+ " cannot be updated.");
0: 		} catch (SQLException e) {
0: 			e.printStackTrace();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Update the blog entry record
0: 	 * 
0: 	 * 
0: 	 */
0: 	public void updateBlogEntry(long id, String email, String title, String blogText, List<String> tags, Date updatedDate) {
0: 		
0: 		if (id == -1)
0: 			throw new IllegalArgumentException(
0: 					"Not a BlogEntry returned by this interface");
0: 		EntryImpl b = getBlogEntryById(id);
0: 		String sql_se = "SELECT * FROM BLOGENTRY bp WHERE bp.id = " + id;
0: 		String email_old = null;
0: 		// let's find out the email address for the blog post to see whether the
0: 		// table Author_BlogEntry needs to be updated
0: 		// if the email is updated, we need to update the table Author_BlogEntry
0: 		// to reflect the change.
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql_se);
0: 			ResultSet rs = ppsm.executeQuery();
0: 			// there should be just one record
0: 			rs.next();
0: 			email_old = rs.getString("AUTHOR_EMAIL");
0: 			ppsm.close();
0: 			connection.close();
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 		String sql = "UPDATE BLOGENTRY bp SET bp.blogText = ?, bp.publishDate = ?, bp.title = ?, bp.updatedDate = ?, bp.AUTHOR_EMAIL = ? where bp.id = "
0: 				+ id;
0: 		int updatedRows = 0;
0: 		
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.setString(1, blogText);
0: 			if (b.getPublishDate() != null)
0: 				ppsm
0: 						.setDate(2, new java.sql.Date(b.getPublishDate()
0: 								.getTime()));
0: 			else
0: 				ppsm.setDate(2, null);
0: 			ppsm.setString(3, b.getTitle());
0: 			if (b.getUpdatedDate() != null)
0: 				ppsm
0: 						.setDate(4, new java.sql.Date(b.getUpdatedDate()
0: 								.getTime()));
0: 			else
0: 				ppsm.setDate(4, null);
0: 
0: 			ppsm.setString(5, email);
0: 			updatedRows = ppsm.executeUpdate();
0: 			
0: 			ppsm.close();
0: 			
0: 			connection.close();
0: 
0: 			if (updatedRows != 1)
0: 				throw new IllegalArgumentException("The Blog " + b.getId()
0: 						+ " cannot be updated.");
0: 		} catch (SQLException e) {
0: 			e.printStackTrace();
0: 		}
0: 
0: 		// if the email address is changed, we need to need to update the
0: 		// relationship table Author_BlogEntry
0: 		if ((email_old != null) && (!!!email_old.equals(email))) {
0: 			// update the table Author_BlogEntry
0: 			String sql_ab = "UDPATE Author_BlogEntry ab SET ab.AUTHOR_EMAIL = '"
0: 					+ email + "'";
0: 			updatedRows = 0;
0: 			try {
0: 				Connection connection = dataSource.getConnection();
0: 				PreparedStatement ppsm = connection.prepareStatement(sql_ab);
0: 				updatedRows = ppsm.executeUpdate();
0: 				ppsm.close();
0:                 connection.close();
0: 				if (updatedRows != 1)
0: 					throw new IllegalArgumentException(
0: 							"The Author_BlogEntry with the postsID "
0: 									+ b.getId() + " cannot be updated.");
0: 			} catch (SQLException e) {
0: 				e.printStackTrace();
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Delete the author record with the specified email address
0: 	 * 
0: 	 * @param emailAddress
0: 	 *            The author's email address
0: 	 * 
0: 	 */
0: 	public void removeAuthor(String emailAddress) {
0: 
0: 		// we need to remove the author and its blog entries
0: 
0: 		try {
0: 			String sql = "DELETE FROM BLOGENTRY bp WHERE bp.AUTHOR_EMAIL = '"
0: 					+ emailAddress + "'";
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 			
0: 			// delete the records from Author_BlogEntry
0: 			sql = "DELETE FROM Author_BlogEntry ab WHERE ab.AUTHOR_EMAIL = '"
0: 					+ emailAddress + "'";
0: 			ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 
0: 			// delete the author record
0: 			sql = "DELETE FROM Author a WHERE a.EMAIL = '" + emailAddress + "'";
0: 			ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 			connection.close();
0: 
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Delete the blog entry record specified by the blogEntry
0: 	 * 
0: 	 * @param blogEntry
0: 	 *            the blog entry record to be deleted
0: 	 */
0: 	public void removeBlogEntry(long id) {
0: 		if (id == -1)
0: 			throw new IllegalArgumentException(
0: 					"Not a BlogEntry returned by this interface");
0: 
0: 		try {
0: 			String sql = "DELETE FROM BLOGENTRY bp WHERE bp.id = "
0: 					+ id;
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 			// We also need to delete the records from Author_BlogEntry, as this
0: 			// table is a kind of link between author and blogentry record
0: 			sql = "DELETE FROM Author_BlogEntry ab WHERE ab.POSTS_ID = "
0: 					+ id;
0: 			ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 			connection.close();
0: 
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Return the blog entry record with the specified id
0: 	 * 
0: 	 * @param postId
0: 	 *            The blogEntry record id
0: 	 */
0: 	public EntryImpl getBlogEntryById(long postId) {
0: 		String sql = "SELECT * FROM BlogEntry b WHERE b.id = " + postId;
0: 		List<EntryImpl> blogs = findBlogs(sql);
0: 		if (blogs.size() == 0)
0: 			return null;
0: 		if (blogs.size() > 1)
0: 			throw new IllegalArgumentException("Blog id is not unique");
0: 		return blogs.get(0);
0: 	}
0: 
0: 	/**
0: 	 * Return a list of authors with the sql query
0: 	 * 
0: 	 * @param sql
0: 	 *            The SQL query
0: 	 * @return A list of author records
0: 	 */
0: 	private List<AuthorImpl> findAuthors(String sql) {
0: 		List<AuthorImpl> authorList = new ArrayList<AuthorImpl>();
0: 
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 
0: 			ResultSet ars = ppsm.executeQuery();
0: 
0: 			while (ars.next()) {
0: 				AuthorImpl ar = new AuthorImpl();
0: 				ar.setBio(ars.getString("bio"));
0: 				ar.setDisplayName(ars.getString("displayName"));
0: 				ar.setDob(ars.getDate("dob"));
0: 				String email = ars.getString("email");
0: 				ar.setEmail(email);
0: 				ar.setName(ars.getString("name"));
0: 
0: 				// let's find the blog entries for the author
0: 				String sql_be = "SELECT * FROM BLOGENTRY be WHERE be.AUTHOR_EMAIL = '"
0: 						+ email + "'";
0: 				PreparedStatement ppsm2 = connection.prepareStatement(sql_be);
0: 				ResultSet rs = ppsm2.executeQuery();
0: 
0: 				List<EntryImpl> blogs = new ArrayList<EntryImpl>();
0: 				while (rs.next()) {
0: 					EntryImpl blog = new EntryImpl();
0: 					blog.setAuthor(ar);
0: 					blog.setId(rs.getLong("id"));
0: 					blog.setBlogText(rs.getString("blogText"));
0: 					blog.setPublishDate(rs.getDate("publishDate"));
0: 					blog.setTitle(rs.getString("title"));
0: 					blog.setUpdatedDate(rs.getDate("updatedDate"));
0: 					blogs.add(blog);
0: 				}
0: 				ar.setEntries(blogs);
0: 				authorList.add(ar);
0: 				ppsm2.close();
0: 			}
0: 		    ppsm.close();
0: 			connection.close();
0: 		} catch (Exception e) {
0: 			e.printStackTrace();
0: 		}
0: 		return authorList;
0: 	}
0: 
0: 	/**
0: 	 * Return a list of blog entries with the sql query
0: 	 * 
0: 	 * @param sql
0: 	 *            The sql query to be executed
0: 	 * @return a list of blogEntry records
0: 	 */
0: 	private List<EntryImpl> findBlogs(String sql) {
0: 		List<EntryImpl> blogEntryList = new ArrayList<EntryImpl>();
0: 
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ResultSet blogrs = ppsm.executeQuery();
0: 
0: 			while (blogrs.next()) {
0: 				EntryImpl be = new EntryImpl();
0: 				be.setId(blogrs.getLong("id"));
0: 				be.setBlogText(blogrs.getString("blogText"));
0: 				be.setPublishDate(blogrs.getDate("publishDate"));
0: 				be.setTitle(blogrs.getString("title"));
0: 				be.setUpdatedDate(blogrs.getDate("updatedDate"));
0: 				// find the author email address
0: 				String author_email = blogrs.getString("AUTHOR_EMAIL");
0: 				String author_sql = "SELECT * FROM Author a WHERE a.email ='"
0: 						+ author_email + "'";
0: 				List<AuthorImpl> authors = findAuthors(author_sql);
0: 				// there should be just one entry, as email is the primary key
0: 				// for the Author table
0: 				if (authors.size() != 1)
0: 					throw new IllegalArgumentException(
0: 							"We got more than one author with the same email address. This is wrong");
0: 				else
0: 					be.setAuthor(authors.get(0));
0: 				blogEntryList.add(be);
0: 			}
0: 			ppsm.close();
0: 			connection.close();
0: 		} catch (Exception e) {
0: 			e.printStackTrace();
0: 		}
0: 		return blogEntryList;
0: 	}
0: }
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:430e8f5
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.samples.blog.persistence;
0: 
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.text.ParseException;
0: import java.util.ArrayList;
0: import java.util.Date;
0: import java.util.List;
0: 
0: import javax.sql.DataSource;
0: 
0: import org.apache.aries.samples.blog.persistence.api.Author;
0: import org.apache.aries.samples.blog.persistence.api.BlogEntry;
0: import org.apache.aries.samples.blog.persistence.api.BlogPersistenceService;
0: import org.apache.aries.samples.blog.persistence.entity.AuthorImpl;
0: import org.apache.aries.samples.blog.persistence.entity.BlogEntryImpl;
0: 
0: /**
0:  * This class is the implementation of the blogPersistenceService
0:  */
0: public class BlogPersistenceServiceImpl implements BlogPersistenceService {
0: 	private DataSource dataSource;
0: 	
0: 
0: 	/**
0: 	 * set data source
0: 	 */
0: 	public void setDataSource(DataSource dataSource) {
0: 		this.dataSource = dataSource;
0: 	}
0: 
0: 	/**
0: 	 * Create an author record
0: 	 * 
0: 	 * @param a
0: 	 *            The author object to be created
0: 	 * @throws ParseException
0: 	 * @throws ParseException
0: 	 */
0: 	public void createAuthor(String email, Date dob, String name,
0: 			String displayName, String bio) {
0: 		
0: 		
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			String sql = "INSERT INTO AUTHOR VALUES (?,?,?,?,?)";
0: 			
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.setString(1, email);
0: 			ppsm.setString(2, bio);
0: 			ppsm.setString(3, displayName);
0: 			if (dob != null)
0: 				ppsm.setDate(4, new java.sql.Date(dob.getTime()));
0: 			else
0: 				ppsm.setDate(4, null);
0: 			ppsm.setString(5, name);
0: 			int insertRows = ppsm.executeUpdate();
0: 			ppsm.close();
0: 			connection.close();
0: 			
0: 			if (insertRows != 1)
0: 				throw new IllegalArgumentException("The Author " + email
0: 						+ " cannot be inserted.");
0: 		} catch (SQLException e) {
0: 			e.printStackTrace();
0: 			throw new IllegalArgumentException(e.getMessage());
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Create a blog entry record
0: 	 * 
0: 	 * @param a 
0: 	 * 			The author
0: 	 * @param title 
0: 	 * 			The title of the post
0: 	 * @param blogText 
0: 	 * 			The text of the post
0: 	 * @param tags
0: 	 * 
0: 	 */
0: 	public void createBlogPost(Author a, String title, String blogText,
0: 			List<String> tags) {
0: 		
0: 		
0: 		if(title == null) title = "";
0: 		Date publishDate = new Date(System.currentTimeMillis());
0: 		if(tags == null) tags = new ArrayList<String>();
0: 		
0: 
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			// let's find the max id from the blogentry table
0: 			String sql = "SELECT max(id) FROM BLOGENTRY";
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ResultSet rs = ppsm.executeQuery();
0: 			// we only expect to have one row returned
0: 			rs.next();
0: 
0: 			long max_id = rs.getLong(1);
0: 			ppsm.close();
0: 			
0: 			long post_id = max_id + 1;
0: 			sql = "INSERT INTO BLOGENTRY VALUES (?,?,?,?,?,?)";
0: 			
0: 		    ppsm = connection.prepareStatement(sql);
0: 			ppsm.setLong(1, post_id);
0: 			ppsm.setString(2, blogText);
0: 			if (publishDate != null)
0: 				ppsm
0: 						.setDate(3, new java.sql.Date(publishDate
0: 								.getTime()));
0: 			else
0: 				ppsm.setDate(3, null);
0: 			ppsm.setString(4, title);
0: 			
0: 		    ppsm.setDate(5, null);
0: 			ppsm.setString(6, a.getEmail());
0: 			int rows = ppsm.executeUpdate();
0: 			if (rows != 1)
0: 				throw new IllegalArgumentException(
0: 						"The blog entry record cannot be inserted: "
0: 								+ blogText);
0: 			ppsm.close();
0: 			
0: 			// insert a row in the relationship table
0: 
0: 			sql = "INSERT INTO Author_BlogEntry VALUES (?,?)";
0: 			ppsm = connection.prepareStatement(sql);
0: 			ppsm.setString(1, a.getEmail());
0: 			ppsm.setLong(2, post_id);
0: 
0: 			rows = ppsm.executeUpdate();
0: 			ppsm.close();
0: 			connection.close();
0: 			
0: 			if (rows != 1)
0: 				throw new IllegalArgumentException(
0: 						"The Author_BlogEntry record cannot be inserted: "
0: 								+ a.getEmail() + " , " + post_id);
0: 
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Find the blog entry record with the specified title
0: 	 * 
0: 	 * @param The title to be searched
0: 	 * @return The blogEntry record
0: 	 */
0: 	public BlogEntry findBlogEntryByTitle(String title) {
0: 
0: 		BlogEntry be = null;
0: 
0: 		String sql = "SELECT * FROM BlogEntry e WHERE e.title = '" + title
0: 				+ "'";
0: 
0: 		List<BlogEntry> blogEntries = findBlogs(sql);
0: 		
0: 		// just return the first blog entry for the time being
0: 		if ((blogEntries != null) && (blogEntries.size() > 0))
0: 			be = blogEntries.get(0);
0: 		return be;
0: 	}
0: 
0: 	/**
0: 	 * Return all author records in the Author table
0: 	 * 
0: 	 * @return the list of Author records
0: 	 */
0: 	public List<Author> getAllAuthors() {
0: 		String sql = "SELECT * FROM Author";
0: 
0: 		List<Author> list = findAuthors(sql);
0: 
0: 		return list;
0: 	}
0: 
0: 	/**
0: 	 * Return all blog entry records from BlogEntry table with the most recent
0: 	 * published blog entries first
0: 	 * 
0: 	 * @return a list of blogEntry object
0: 	 */
0: 	public List<BlogEntry> getAllBlogEntries() {
0: 		String sql = "SELECT * FROM BlogEntry b ORDER BY b.publishDate DESC";
0: 
0: 		List<BlogEntry> list = findBlogs(sql);
0: 
0: 		return list;
0: 	}
0: 
0: 	/**
0: 	 * Return the number of the blog entry records
0: 	 * 
0: 	 * @return the number of the blog Entry records
0: 	 */
0: 	public int getNoOfBlogEntries() {
0: 
0: 		int count = 0;
0: 
0: 		String sql = "SELECT count(*) FROM BLOGENTRY";
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ResultSet rs = ppsm.executeQuery();
0: 			// we only expect to have one row returned
0: 			rs.next();
0: 			count = rs.getInt(1);
0: 			ppsm.close();
0: 			connection.close();
0: 
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 		return count;
0: 	}
0: 
0: 	/**
0: 	 * Return the portion of blog Entries
0: 	 * 
0: 	 * @param firstPostIndex
0: 	 *            The index of the first blog entry to be returned
0: 	 * @param noOfPosts
0: 	 *            The number of blog entry to be returned
0: 	 * @return The list of the blog entry record
0: 	 */
0: 	public List<BlogEntry> getBlogEntries(int firstPostIndex, int noOfPosts) {
0: 		String sql = "SELECT * FROM BlogEntry b ORDER BY b.publishDate DESC";
0: 		List<BlogEntry> emptyList = new ArrayList<BlogEntry>();
0: 		List<BlogEntry> blogs = findBlogs(sql);
0: 		// we only return a portion of the list
0: 		if (blogs == null)
0: 			return emptyList;
0: 		// We need to make sure we won't throw IndexOutOfBoundException if the
0: 		// supplied
0: 		// index is out of the list range
0: 		int maximumIndex = blogs.size();
0: 		// if the first index is minus or greater than the last item index of
0: 		// the list, return an empty list
0: 		if ((firstPostIndex < 0) || (noOfPosts <= 0)
0: 				|| (firstPostIndex > maximumIndex))
0: 			return emptyList;
0: 		// return the required number of the blog entries or the available blog
0: 		// entries
0: 		int lastIndex = noOfPosts + firstPostIndex;
0: 		// we need to make sure we return the blog entries at most up to the
0: 		// final record
0: 
0: 		return (blogs.subList(firstPostIndex,
0: 				(lastIndex > maximumIndex) ? maximumIndex : lastIndex));
0: 
0: 	}
0: 
0: 	/**
0: 	 * Return the author with the specified email address
0: 	 * 
0: 	 * @param emailAddress
0: 	 *            The email address
0: 	 * @return The author record
0: 	 */
0: 	public Author getAuthor(String emailAddress) {
0: 		String sql = "SELECT * FROM AUTHOR a where a.email='" + emailAddress
0: 				+ "'";
0: 		List<Author> authors = findAuthors(sql);
0: 
0: 		if (authors.size() == 0)
0: 			return null;
0: 		else if (authors.size() > 1)
0: 			throw new IllegalArgumentException(
0: 					"Email address should be unique per author");
0: 
0: 		return authors.get(0); // just return the first author
0: 	}
0: 
0: 	/**
0: 	 * Return the blog entries modified between the date range of [start, end]
0: 	 * 
0: 	 * @param start
0: 	 *            The start date
0: 	 * @param end
0: 	 *            The end date
0: 	 * @return The list of blog entries
0: 	 */
0: 	public List<BlogEntry> getBlogEntriesModifiedBetween(Date start, Date end) {
0: 
0: 		// String sql = "SELECT * FROM BlogEntry b WHERE (b.updatedDate >= " +
0: 		// startTS +" AND b.updatedDate <= " + endTS + ") OR (b.publishDate >= "
0: 		// +startTS + " AND b.publishDate <= " + endTS +
0: 		// ") ORDER BY b.publishDate ASC";
0: 		String sql = "SELECT * FROM BlogEntry b WHERE (Date(b.updatedDate) BETWEEN '"
0: 				+ start
0: 				+ "' AND '"
0: 				+ end
0: 				+ "') OR (Date(b.publishDate) BETWEEN '"
0: 				+ start
0: 				+ "' AND  '"
0: 				+ end + "') ORDER BY b.publishDate ASC";
0: 
0: 		return findBlogs(sql);
0: 
0: 	}
0: 
0: 	/**
0: 	 * Return a list of blog entries belonging to the author with the specified
0: 	 * email address
0: 	 * 
0: 	 * @param emailAddress
0: 	 *            the author's email address
0: 	 * @return The list of blog entries
0: 	 */
0: 	public List<BlogEntry> getBlogsForAuthor(String emailAddress) {
0: 
0: 		String sql = "SELECT * FROM BlogEntry b WHERE b.AUTHOR_EMAIL='"
0: 				+ emailAddress + "'";
0: 		return findBlogs(sql);
0: 	}
0: 
0: 	/**
0: 	 * Update the author record
0: 	 * 
0: 	 * @param email
0: 	 * 			The email associated with an author
0: 	 * @param dob
0: 	 * 			The author's date of birth
0: 	 * @param name
0: 	 * 			the author's name
0: 	 * @param displayName
0: 	 * 			The displayName
0: 	 * @param bio
0: 	 * 			The aouthor's bio
0: 	 */
0: 	public void updateAuthor(String email, Date dob, String name,
0: 			String displayName, String bio) {
0: 
0: 		
0: 		String sql = "UPDATE AUTHOR a SET bio = ?, displayName = ?, dob = ?, name =? WHERE email ='"
0: 				+ email + "'";
0: 		int updatedRows = 0;
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.setString(1, bio);
0: 			ppsm.setString(2, displayName);
0: 			if (dob != null)
0: 				ppsm.setDate(3, new java.sql.Date(dob.getTime()));
0: 			else
0: 				ppsm.setDate(3, null);
0: 			ppsm.setString(4, name);
0: 			updatedRows = ppsm.executeUpdate();
0: 			
0: 			ppsm.close();
0: 			connection.close();
0: 			
0: 			if (updatedRows != 1)
0: 				throw new IllegalArgumentException("The Author " + email
0: 						+ " cannot be updated.");
0: 		} catch (SQLException e) {
0: 			e.printStackTrace();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Update the blog entry record
0: 	 * 
0: 	 * @param b
0: 	 *            The blog entry record to replace the existing record
0: 	 */
0: 	public void updateBlogPost(BlogEntry b) {
0: 		
0: 		if (b.getId() == -1)
0: 			throw new IllegalArgumentException(
0: 					"Not a BlogEntry returned by this interface");
0: 		String sql_se = "SELECT * FROM BLOGENTRY bp WHERE bp.id = " + b.getId();
0: 		String email_old = null;
0: 		// let's find out the email address for the blog post to see whether the
0: 		// table Author_BlogEntry needs to be updated
0: 		// if the email is updated, we need to update the table Author_BlogEntry
0: 		// to reflect the change.
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql_se);
0: 			ResultSet rs = ppsm.executeQuery();
0: 			// there should be just one record
0: 			rs.next();
0: 			email_old = rs.getString("AUTHOR_EMAIL");
0: 			ppsm.close();
0: 			connection.close();
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 		String sql = "UPDATE BLOGENTRY bp SET bp.blogText = ?, bp.publishDate = ?, bp.title = ?, bp.updatedDate = ?, bp.AUTHOR_EMAIL = ? where bp.id = "
0: 				+ b.getId();
0: 		int updatedRows = 0;
0: 		String email = b.getAuthor().getEmail();
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.setString(1, b.getBlogText());
0: 			if (b.getPublishDate() != null)
0: 				ppsm
0: 						.setDate(2, new java.sql.Date(b.getPublishDate()
0: 								.getTime()));
0: 			else
0: 				ppsm.setDate(2, null);
0: 			ppsm.setString(3, b.getTitle());
0: 			if (b.getUpdatedDate() != null)
0: 				ppsm
0: 						.setDate(4, new java.sql.Date(b.getUpdatedDate()
0: 								.getTime()));
0: 			else
0: 				ppsm.setDate(4, null);
0: 
0: 			ppsm.setString(5, email);
0: 			updatedRows = ppsm.executeUpdate();
0: 			
0: 			ppsm.close();
0: 			
0: 			connection.close();
0: 
0: 			if (updatedRows != 1)
0: 				throw new IllegalArgumentException("The Blog " + b.getId()
0: 						+ " cannot be updated.");
0: 		} catch (SQLException e) {
0: 			e.printStackTrace();
0: 		}
0: 
0: 		// if the email address is changed, we need to need to update the
0: 		// relationship table Author_BlogEntry
0: 		if ((email_old != null) && (!!!email_old.equals(email))) {
0: 			// update the table Author_BlogEntry
0: 			String sql_ab = "UDPATE Author_BlogEntry ab SET ab.AUTHOR_EMAIL = '"
0: 					+ email + "'";
0: 			updatedRows = 0;
0: 			try {
0: 				Connection connection = dataSource.getConnection();
0: 				PreparedStatement ppsm = connection.prepareStatement(sql_ab);
0: 				updatedRows = ppsm.executeUpdate();
0: 				ppsm.close();
0:                 connection.close();
0: 				if (updatedRows != 1)
0: 					throw new IllegalArgumentException(
0: 							"The Author_BlogEntry with the postsID "
0: 									+ b.getId() + " cannot be updated.");
0: 			} catch (SQLException e) {
0: 				e.printStackTrace();
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Delete the author record with the specified email address
0: 	 * 
0: 	 * @param emailAddress
0: 	 *            The author's email address
0: 	 * 
0: 	 */
0: 	public void removeAuthor(String emailAddress) {
0: 
0: 		// we need to remove the author and its blog entries
0: 
0: 		try {
0: 			String sql = "DELETE FROM BLOGENTRY bp WHERE bp.AUTHOR_EMAIL = '"
0: 					+ emailAddress + "'";
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 			
0: 			// delete the records from Author_BlogEntry
0: 			sql = "DELETE FROM Author_BlogEntry ab WHERE ab.AUTHOR_EMAIL = '"
0: 					+ emailAddress + "'";
0: 			ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 
0: 			// delete the author record
0: 			sql = "DELETE FROM Author a WHERE a.EMAIL = '" + emailAddress + "'";
0: 			ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 			connection.close();
0: 
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Delete the blog entry record specified by the blogEntry
0: 	 * 
0: 	 * @param blogEntry
0: 	 *            the blog entry record to be deleted
0: 	 */
0: 	public void removeBlogEntry(BlogEntry blogEntry) {
0: 		if (blogEntry.getId() == -1)
0: 			throw new IllegalArgumentException(
0: 					"Not a BlogEntry returned by this interface");
0: 
0: 		try {
0: 			String sql = "DELETE FROM BLOGENTRY bp WHERE bp.id = "
0: 					+ blogEntry.getId();
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 			// We also need to delete the records from Author_BlogEntry, as this
0: 			// table is a kind of link between author and blogentry record
0: 			sql = "DELETE FROM Author_BlogEntry ab WHERE ab.POSTS_ID = "
0: 					+ blogEntry.getId();
0: 			ppsm = connection.prepareStatement(sql);
0: 			ppsm.executeUpdate();
0: 			ppsm.close();
0: 			connection.close();
0: 
0: 		} catch (SQLException sqle) {
0: 			sqle.printStackTrace();
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Return the blog entry record with the specified id
0: 	 * 
0: 	 * @param postId
0: 	 *            The blogEntry record id
0: 	 */
0: 	public BlogEntry getBlogEntryById(long postId) {
0: 		String sql = "SELECT * FROM BlogEntry b WHERE b.id = " + postId;
0: 		List<BlogEntry> blogs = findBlogs(sql);
0: 		if (blogs.size() == 0)
0: 			return null;
0: 		if (blogs.size() > 1)
0: 			throw new IllegalArgumentException("Blog id is not unique");
0: 		return blogs.get(0);
0: 	}
0: 
0: 	/**
0: 	 * Return a list of authors with the sql query
0: 	 * 
0: 	 * @param sql
0: 	 *            The SQL query
0: 	 * @return A list of author records
0: 	 */
0: 	private List<Author> findAuthors(String sql) {
0: 		List<Author> authorList = new ArrayList<Author>();
0: 
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 
0: 			ResultSet ars = ppsm.executeQuery();
0: 
0: 			while (ars.next()) {
0: 				Author ar = new AuthorImpl();
0: 				ar.setBio(ars.getString("bio"));
0: 				ar.setDisplayName(ars.getString("displayName"));
0: 				ar.setDob(ars.getDate("dob"));
0: 				String email = ars.getString("email");
0: 				ar.setEmail(email);
0: 				ar.setName(ars.getString("name"));
0: 
0: 				// let's find the blog entries for the author
0: 				String sql_be = "SELECT * FROM BLOGENTRY be WHERE be.AUTHOR_EMAIL = '"
0: 						+ email + "'";
0: 				PreparedStatement ppsm2 = connection.prepareStatement(sql_be);
0: 				ResultSet rs = ppsm2.executeQuery();
0: 
0: 				List<BlogEntry> blogs = new ArrayList<BlogEntry>();
0: 				while (rs.next()) {
0: 					BlogEntry blog = new BlogEntryImpl();
0: 					blog.setAuthor(ar);
0: 					blog.setId(rs.getLong("id"));
0: 					blog.setBlogText(rs.getString("blogText"));
0: 					blog.setPublishDate(rs.getDate("publishDate"));
0: 					blog.setTitle(rs.getString("title"));
0: 					blog.setUpdatedDate(rs.getDate("updatedDate"));
0: 					blogs.add(blog);
0: 				}
0: 				ar.setPosts(blogs);
0: 				authorList.add(ar);
0: 				ppsm2.close();
0: 			}
0: 		    ppsm.close();
0: 			connection.close();
0: 		} catch (Exception e) {
0: 			e.printStackTrace();
0: 		}
0: 		return authorList;
0: 	}
0: 
0: 	/**
0: 	 * Return a list of blog entries with the sql query
0: 	 * 
0: 	 * @param sql
0: 	 *            The sql query to be executed
0: 	 * @return a list of blogEntry records
0: 	 */
0: 	private List<BlogEntry> findBlogs(String sql) {
0: 		List<BlogEntry> blogEntryList = new ArrayList<BlogEntry>();
0: 
0: 		try {
0: 			Connection connection = dataSource.getConnection();
0: 			PreparedStatement ppsm = connection.prepareStatement(sql);
0: 			ResultSet blogrs = ppsm.executeQuery();
0: 
0: 			while (blogrs.next()) {
0: 				BlogEntry be = new BlogEntryImpl();
0: 				be.setId(blogrs.getLong("id"));
0: 				be.setBlogText(blogrs.getString("blogText"));
0: 				be.setPublishDate(blogrs.getDate("publishDate"));
0: 				be.setTitle(blogrs.getString("title"));
0: 				be.setUpdatedDate(blogrs.getDate("updatedDate"));
0: 				// find the author email address
0: 				String author_email = blogrs.getString("AUTHOR_EMAIL");
0: 				String author_sql = "SELECT * FROM Author a WHERE a.email ='"
0: 						+ author_email + "'";
0: 				List<Author> authors = findAuthors(author_sql);
0: 				// there should be just one entry, as email is the primary key
0: 				// for the Author table
0: 				if (authors.size() != 1)
0: 					throw new IllegalArgumentException(
0: 							"We got more than one author with the same email address. This is wrong");
0: 				else
0: 					be.setAuthor(authors.get(0));
0: 				blogEntryList.add(be);
0: 			}
0: 			ppsm.close();
0: 			connection.close();
0: 		} catch (Exception e) {
0: 			e.printStackTrace();
0: 		}
0: 		return blogEntryList;
0: 	}
0: }
============================================================================