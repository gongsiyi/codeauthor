1:14ceeb1: /*
1:14ceeb1:  * Copyright (c) OSGi Alliance 2015. All Rights Reserved.
1:14ceeb1:  *
1:14ceeb1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:14ceeb1:  * you may not use this file except in compliance with the License.
1:14ceeb1:  * You may obtain a copy of the License at
1:14ceeb1:  *
1:14ceeb1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:14ceeb1:  *
1:14ceeb1:  * Unless required by applicable law or agreed to in writing, software
1:14ceeb1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:14ceeb1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:14ceeb1:  * See the License for the specific language governing permissions and
1:14ceeb1:  * limitations under the License.
1:14ceeb1:  */
1:0d3d319: package org.osgi.util.promise;
2:0d3d319: 
1:8b05938: import java.lang.reflect.InvocationTargetException;
1:8b05938: 
1:8b05938: import org.osgi.util.function.Callback;
1:0d3d319: import org.osgi.util.function.Function;
1:0d3d319: import org.osgi.util.function.Predicate;
1:0d3d319: 
1:0d3d319: /**
1:0d3d319:  * A Promise of a value.
1:0d3d319:  * <p/>
1:0d3d319:  * A Promise represents a future value. It handles the interactions to for asynchronous processing. A Deferred object
1:0d3d319:  * can be used to create a Promise and later resolve the Promise. A Promise is used by the caller of an asynchronous
1:0d3d319:  * function to get the result or handle the error. The caller can either get a callback when the Promise is resolved
1:0d3d319:  * with a value or an error, or the Promise can be used in chaining. In chaining, callbacks are provided that receive
1:0d3d319:  * the resolved Promise, and a new Promise is generated that resolves based upon the result of a callback.
1:0d3d319:  * <p/>
1:0d3d319:  * Both callbacks and chaining can be repeated any number of times, even after the Promise has been resolved.
1:0d3d319:  * <p/>
1:0d3d319:  * Example callback usage:
1:0d3d319:  * <pre>
1:0d3d319:  * final Promise<String> foo= foo();
1:0d3d319:  * foo.onResolve(new Runnable() {
1:0d3d319:  * public void run() {
1:0d3d319:  * System.out.println(foo.getValue());
1:0d3d319:  * }
1:0d3d319:  * });
1:0d3d319:  * </pre>
1:0d3d319:  * <p/>
1:0d3d319:  * Example chaining usage;
1:0d3d319:  * <pre>
1:0d3d319:  * Success<String,String> doubler = new Success<String,String>() {
1:0d3d319:  * public Promise<String> call(Promise<String> p) throws Exception {
1:0d3d319:  * return Promises.resolved(p.getValue()+p.getValue());
1:0d3d319:  * }
1:0d3d319:  * };
1:0d3d319:  * final Promise<String> foo = foo().then(doubler).then(doubler);
1:0d3d319:  * foo.onResolve(new Runnable() {
1:0d3d319:  * public void run() {
1:0d3d319:  * System.out.println(foo.getValue());
1:0d3d319:  * }
1:0d3d319:  * });
1:0d3d319:  * </pre>
1:0d3d319:  *
1:0d3d319:  * @param <T> The value type associated with this Promise.
1:0d3d319:  */
1:14ceeb1: @org.osgi.annotation.versioning.ProviderType
1:0d3d319: public interface Promise<T> {
1:0d3d319:     /**
1:0d3d319:      * Returns whether this Promise has been resolved.
1:0d3d319:      * <p/>
1:0d3d319:      * This Promise may be successfully resolved or resolved with a failure.
1:0d3d319:      *
1:0d3d319:      * @return true if this Promise was resolved either successfully or with a failure; false if this Promise is
1:0d3d319:      * unresolved.
1:0d3d319:      */
1:0d3d319:     boolean isDone();
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Returns the value of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is not resolved, this method must block and wait for this Promise to be resolved before
1:0d3d319:      * completing.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise was successfully resolved, this method returns with the value of this Promise. If this Promise
1:0d3d319:      * was resolved with a failure, this method must throw an InvocationTargetException with the failure exception as
1:0d3d319:      * the cause.
1:0d3d319:      *
1:0d3d319:      * @return The value of this resolved Promise.
1:0d3d319:      * @throws InvocationTargetException If this Promise was resolved with a failure. The cause of the
1:0d3d319:      *                                   InvocationTargetException is the failure exception.
1:0d3d319:      * @throws InterruptedException      If the current thread was interrupted while waiting.
1:0d3d319:      */
1:0d3d319:     T getValue() throws InvocationTargetException, InterruptedException;
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Returns the failure of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is not resolved, this method must block and wait for this Promise to be resolved before
1:0d3d319:      * completing.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise was resolved with a failure, this method returns with the failure of this Promise. If this
1:0d3d319:      * Promise was successfully resolved, this method must return null.
1:0d3d319:      *
1:0d3d319:      * @return The failure of this resolved Promise or null if this Promise was successfully resolved.
1:0d3d319:      * @throws InterruptedException If the current thread was interrupted while waiting.
1:0d3d319:      */
1:0d3d319:     Throwable getFailure() throws InterruptedException;
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Register a callback to be called when this Promise is resolved.
1:0d3d319:      * <p/>
1:0d3d319:      * The specified callback is called when this Promise is resolved either successfully or with a failure.
1:0d3d319:      * <p/>
1:0d3d319:      * This method may be called at any time including before and after this Promise has been resolved.
1:0d3d319:      * <p/>
1:0d3d319:      * Resolving this Promise happens-before any registered callback is called. That is, in a registered callback,
1:0d3d319:      * isDone() must return true and getValue() and getFailure() must not block.
1:0d3d319:      * <p/>
1:0d3d319:      * A callback may be called on a different thread than the thread which registered the callback. So the callback
1:0d3d319:      * must be thread safe but can rely upon that the registration of the callback happens-before the registered
1:0d3d319:      * callback is called.
1:0d3d319:      *
1:0d3d319:      * @param callback A callback to be called when this Promise is resolved. Must not be null.
1:0d3d319:      * @return This Promise.
1:0d3d319:      */
1:0d3d319:     Promise<T> onResolve(Runnable callback);
1:0d3d319: 
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Chain a new Promise to this Promise with Success and Failure callbacks.
1:0d3d319:      * <p/>
1:0d3d319:      * The specified Success callback is called when this Promise is successfully resolved and the specified Failure
1:0d3d319:      * callback is called when this Promise is resolved with a failure.
1:0d3d319:      * <p/>
1:0d3d319:      * This method returns a new Promise which is chained to this Promise. The returned Promise must be resolved when
1:0d3d319:      * this Promise is resolved after the specified Success or Failure callback is executed. The result of the executed
1:0d3d319:      * callback must be used to resolve the returned Promise. Multiple calls to this method can be used to create a
1:0d3d319:      * chain of promises which are resolved in sequence.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is successfully resolved, the Success callback is executed and the result Promise, if any, or
1:0d3d319:      * thrown exception is used to resolve the returned Promise from this method. If this Promise is resolved with a
1:0d3d319:      * failure, the Failure callback is executed and the returned Promise from this method is failed.
1:0d3d319:      * <p/>
1:0d3d319:      * This method may be called at any time including before and after this Promise has been resolved.
1:0d3d319:      * <p/>
1:0d3d319:      * Resolving this Promise happens-before any registered callback is called. That is, in a registered callback,
1:0d3d319:      * isDone() must return true and getValue() and getFailure() must not block.
1:0d3d319:      * <p/>
1:0d3d319:      * A callback may be called on a different thread than the thread which registered the callback. So the callback
1:0d3d319:      * must be thread safe but can rely upon that the registration of the callback happens-before the registered
1:0d3d319:      * callback is called.
1:0d3d319:      *
1:0d3d319:      * @param <R>     The value type associated with the returned Promise.
1:0d3d319:      * @param success A Success callback to be called when this Promise is successfully resolved. May be null if no
1:0d3d319:      *                Success callback is required. In thi
1:0d3d319:      * @param failure A Failure callback to be called when this Promise is resolved with a failure. May be null if no
1:0d3d319:      *                Failure callback is required.
1:0d3d319:      * @return A new Promise which is chained to this Promise. The returned Promise must be resolved when this Promise
1:0d3d319:      * is resolved after the specified Success or Failure callback, if any, is executed
1:0d3d319:      */
1:0d3d319:     <R> Promise<R> then(Success<? super T, ? extends R> success, Failure failure);
1:0d3d319: 
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Chain a new Promise to this Promise with a Success callback.
1:0d3d319:      * <p/>
1:0d3d319:      * This method performs the same function as calling then(Success, Failure) with the specified Success callback and
1:0d3d319:      * null for the Failure callback
1:0d3d319:      *
1:0d3d319:      * @param success A Success callback to be called when this Promise is successfully resolved. May be null if no
1:0d3d319:      *                Success callback is required. In this case, the returned Promise must be resolved with the value
1:0d3d319:      *                null when this Promise is successfully resolved.
1:0d3d319:      * @param <R>     The value type associated with the returned Promise.
1:0d3d319:      * @return A new Promise which is chained to this Promise. The returned Promise must be resolved when this Promise
1:0d3d319:      * is resolved after the specified Success, if any, is executed.
1:0d3d319:      * @see #then(Success, Failure)
1:0d3d319:      */
1:0d3d319:     <R> Promise<R> then(Success<? super T, ? extends R> success);
1:8b05938:     
1:8b05938: 	/**
1:8b05938: 	 * Chain a new Promise to this Promise with a callback.
1:8b05938: 	 * <p>
1:8b05938: 	 * The specified {@link Callback} is called when this Promise is resolved
1:8b05938: 	 * either successfully or with a failure.
1:8b05938: 	 * <p>
1:8b05938: 	 * This method returns a new Promise which is chained to this Promise. The
1:8b05938: 	 * returned Promise must be resolved when this Promise is resolved after the
1:8b05938: 	 * specified callback is executed. If the callback throws an exception, the
1:8b05938: 	 * returned Promise is failed with that exception. Otherwise the returned
1:8b05938: 	 * Promise is resolved with this Promise.
1:8b05938: 	 * <p>
1:8b05938: 	 * This method may be called at any time including before and after this
1:8b05938: 	 * Promise has been resolved.
1:8b05938: 	 * <p>
1:8b05938: 	 * Resolving this Promise <i>happens-before</i> any registered callback is
1:8b05938: 	 * called. That is, in a registered callback, {@link #isDone()} must return
1:8b05938: 	 * {@code true} and {@link #getValue()} and {@link #getFailure()} must not
1:8b05938: 	 * block.
1:8b05938: 	 * <p>
1:8b05938: 	 * A callback may be called on a different thread than the thread which
1:8b05938: 	 * registered the callback. So the callback must be thread safe but can rely
1:8b05938: 	 * upon that the registration of the callback <i>happens-before</i> the
1:8b05938: 	 * registered callback is called.
1:8b05938: 	 * 
1:8b05938: 	 * @param callback A callback to be called when this Promise is resolved.
1:8b05938: 	 *            Must not be {@code null}.
1:8b05938: 	 * @return A new Promise which is chained to this Promise. The returned
1:8b05938: 	 *         Promise must be resolved when this Promise is resolved after the
1:8b05938: 	 *         specified callback is executed.
1:8b05938: 	 * @since 1.1
1:8b05938: 	 */
1:8b05938: 	Promise<T> then(Callback callback);
1:0d3d319: 
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Filter the value of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is successfully resolved, the returned Promise will either be resolved with the value of this
1:0d3d319:      * Promise if the specified Predicate accepts that value or failed with a NoSuchElementException if the specified
1:0d3d319:      * Predicate does not accept that value. If the specified Predicate throws an exception, the returned Promise will
1:0d3d319:      * be failed with the exception.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is resolved with a failure, the returned Promise will be failed with that failure.
1:0d3d319:      * <p/>
1:0d3d319:      * This method may be called at any time including before and after this Promise has been resolved.
1:0d3d319:      *
1:0d3d319:      * @param predicate The Predicate to evaluate the value of this Promise. Must not be null.
1:0d3d319:      * @return A Promise that filters the value of this Promise.
1:0d3d319:      */
1:0d3d319:     Promise<T> filter(Predicate<? super T> predicate);
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Map the value of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is successfully resolved, the returned Promise will be resolved with the value of specified
1:0d3d319:      * Function as applied to the value of this Promise. If the specified Function throws an exception, the returned
1:0d3d319:      * Promise will be failed with the exception.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is resolved with a failure, the returned Promise will be failed with that failure.
1:0d3d319:      * <p/>
1:0d3d319:      * This method may be called at any time including before and after this Promise has been resolved.
1:0d3d319:      *
1:0d3d319:      * @param mapper The Function that will map the value of this Promise to the value that will be used to resolve the
1:0d3d319:      *               returned Promise. Must not be null.
1:0d3d319:      * @param <R>    The value type associated with the returned Promise.
1:0d3d319:      * @return A Promise that returns the value of this Promise as mapped by the specified Function.
1:0d3d319:      */
1:0d3d319:     <R> Promise<R> map(Function<? super T, ? extends R> mapper);
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * FlatMap the value of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is successfully resolved, the returned Promise will be resolved with the Promise from the
1:0d3d319:      * specified Function as applied to the value of this Promise. If the specified Function throws an exception, the
1:0d3d319:      * returned Promise will be failed with the exception.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is resolved with a failure, the returned Promise will be failed with that failure.
1:0d3d319:      * <p/>
1:0d3d319:      * This method may be called at any time including before and after this Promise has been resolved.
1:0d3d319:      *
1:0d3d319:      * @param mapper The Function that will flatMap the value of this Promise to a Promise that will be used to resolve
1:0d3d319:      *               the returned Promise. Must not be null.
1:0d3d319:      * @param <R>    The value type associated with the returned Promise.
1:0d3d319:      * @return A Promise that returns the value of this Promise as mapped by the specified Function.
1:0d3d319:      */
1:0d3d319:     <R> Promise<R> flatMap(Function<? super T, Promise<? extends R>> mapper);
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Recover from a failure of this Promise with a recovery value.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is successfully resolved, the returned Promise will be resolved with the value of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is resolved with a failure, the specified Function is applied to this Promise to produce a
1:0d3d319:      * recovery value.
1:0d3d319:      * <p/>
1:0d3d319:      * If the recovery value is not null, the returned Promise will be resolved with the recovery value.
1:0d3d319:      * <p/>
1:0d3d319:      * If the recovery value is null, the returned Promise will be failed with the failure of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If the specified Function throws an exception, the returned Promise will be failed with that exception.
1:0d3d319:      * <p/>
1:0d3d319:      * To recover from a failure of this Promise with a recovery value of null, the recoverWith(Function) method must be
1:0d3d319:      * used. The specified Function for recoverWith(Function) can return Promises.resolved(null) to supply the desired
1:0d3d319:      * null value.
1:0d3d319:      * <p/>
1:0d3d319:      * This method may be called at any time including before and after this Promise has been resolved.
1:0d3d319:      *
1:0d3d319:      * @param recovery If this Promise resolves with a failure, the specified Function is called to produce a recovery
1:0d3d319:      *                 value to be used to resolve the returned Promise. Must not be null.
1:0d3d319:      * @return A Promise that resolves with the value of this Promise or recovers from the failure of this Promise.
1:0d3d319:      */
1:0d3d319:     Promise<T> recover(Function<Promise<?>, ? extends T> recovery);
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Recover from a failure of this Promise with a recovery Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is successfully resolved, the returned Promise will be resolved with the value of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is resolved with a failure, the specified Function is applied to this Promise to produce a
1:0d3d319:      * recovery Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If the recovery Promise is not null, the returned Promise will be resolved with the recovery Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If the recovery Promise is null, the returned Promise will be failed with the failure of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If the specified Function throws an exception, the returned Promise will be failed with that exception.
1:0d3d319:      * <p/>
1:0d3d319:      * This method may be called at any time including before and after this Promise has been resolved.
1:0d3d319:      *
1:0d3d319:      * @param recovery If this Promise resolves with a failure, the specified Function is called to produce a recovery
1:0d3d319:      *                 Promise to be used to resolve the returned Promise. Must not be null.
1:0d3d319:      * @return A Promise that resolves with the value of this Promise or recovers from the failure of this Promise.
1:0d3d319:      */
1:0d3d319:     Promise<T> recoverWith(Function<Promise<?>, Promise<? extends T>> recovery);
1:0d3d319: 
1:0d3d319:     /**
1:0d3d319:      * Fall back to the value of the specified Promise if this Promise fails.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is successfully resolved, the returned Promise will be resolved with the value of this Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * If this Promise is resolved with a failure, the successful result of the specified Promise is used to resolve the
1:0d3d319:      * returned Promise. If the specified Promise is resolved with a failure, the returned Promise will be failed with
1:0d3d319:      * the failure of this Promise rather than the failure of the specified Promise.
1:0d3d319:      * <p/>
1:0d3d319:      * This method may be called at any time including before and after this Promise has been resolved.
1:0d3d319:      *
1:0d3d319:      * @param fallback The Promise whose value will be used to resolve the returned Promise if this Promise resolves
1:0d3d319:      *                 with a failure. Must not be null.
1:0d3d319:      * @return A Promise that returns the value of this Promise or falls back to the value of the specified Promise.
1:0d3d319:      */
1:0d3d319:     Promise<T> fallbackTo(Promise<? extends T> fallback);
1:8b05938:     
1:8b05938: 	/**
1:8b05938: 	 * Time out the resolution of this Promise.
1:8b05938: 	 * <p>
1:8b05938: 	 * If this Promise is successfully resolved before the timeout, the returned
1:8b05938: 	 * Promise is resolved with the value of this Promise. If this Promise is
1:8b05938: 	 * resolved with a failure before the timeout, the returned Promise is
1:8b05938: 	 * resolved with the failure of this Promise. If the timeout is reached
1:8b05938: 	 * before this Promise is resolved, the returned Promise is failed with a
1:8b05938: 	 * {@link TimeoutException}.
1:8b05938: 	 * 
1:8b05938: 	 * @param milliseconds The time to wait in milliseconds. Zero and negative
1:8b05938: 	 *            time is treated as an immediate timeout.
1:8b05938: 	 * @return A Promise that is resolved when either this Promise is resolved
1:8b05938: 	 *         or the specified timeout is reached.
1:8b05938: 	 * @since 1.1
1:8b05938: 	 */
1:8b05938: 	Promise<T> timeout(long milliseconds);
1:8b05938: 
1:8b05938: 	/**
1:8b05938: 	 * Delay after the resolution of this Promise.
1:8b05938: 	 * <p>
1:8b05938: 	 * Once this Promise is resolved, resolve the returned Promise with this
1:8b05938: 	 * Promise after the specified delay.
1:8b05938: 	 * 
1:8b05938: 	 * @param milliseconds The time to delay in milliseconds. Zero and negative
1:8b05938: 	 *            time is treated as no delay.
1:8b05938: 	 * @return A Promise that is resolved with this Promise after this Promise
1:8b05938: 	 *         is resolved and the specified delay has elapsed.
1:8b05938: 	 * @since 1.1
1:8b05938: 	 */
1:8b05938: 	Promise<T> delay(long milliseconds);
1:0d3d319: 
1:0d3d319: }
============================================================================
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:8b05938
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
1: 
1: import org.osgi.util.function.Callback;
/////////////////////////////////////////////////////////////////////////
1:     
1: 	/**
1: 	 * Chain a new Promise to this Promise with a callback.
1: 	 * <p>
1: 	 * The specified {@link Callback} is called when this Promise is resolved
1: 	 * either successfully or with a failure.
1: 	 * <p>
1: 	 * This method returns a new Promise which is chained to this Promise. The
1: 	 * returned Promise must be resolved when this Promise is resolved after the
1: 	 * specified callback is executed. If the callback throws an exception, the
1: 	 * returned Promise is failed with that exception. Otherwise the returned
1: 	 * Promise is resolved with this Promise.
1: 	 * <p>
1: 	 * This method may be called at any time including before and after this
1: 	 * Promise has been resolved.
1: 	 * <p>
1: 	 * Resolving this Promise <i>happens-before</i> any registered callback is
1: 	 * called. That is, in a registered callback, {@link #isDone()} must return
1: 	 * {@code true} and {@link #getValue()} and {@link #getFailure()} must not
1: 	 * block.
1: 	 * <p>
1: 	 * A callback may be called on a different thread than the thread which
1: 	 * registered the callback. So the callback must be thread safe but can rely
1: 	 * upon that the registration of the callback <i>happens-before</i> the
1: 	 * registered callback is called.
1: 	 * 
1: 	 * @param callback A callback to be called when this Promise is resolved.
1: 	 *            Must not be {@code null}.
1: 	 * @return A new Promise which is chained to this Promise. The returned
1: 	 *         Promise must be resolved when this Promise is resolved after the
1: 	 *         specified callback is executed.
1: 	 * @since 1.1
1: 	 */
1: 	Promise<T> then(Callback callback);
/////////////////////////////////////////////////////////////////////////
1:     
1: 	/**
1: 	 * Time out the resolution of this Promise.
1: 	 * <p>
1: 	 * If this Promise is successfully resolved before the timeout, the returned
1: 	 * Promise is resolved with the value of this Promise. If this Promise is
1: 	 * resolved with a failure before the timeout, the returned Promise is
1: 	 * resolved with the failure of this Promise. If the timeout is reached
1: 	 * before this Promise is resolved, the returned Promise is failed with a
1: 	 * {@link TimeoutException}.
1: 	 * 
1: 	 * @param milliseconds The time to wait in milliseconds. Zero and negative
1: 	 *            time is treated as an immediate timeout.
1: 	 * @return A Promise that is resolved when either this Promise is resolved
1: 	 *         or the specified timeout is reached.
1: 	 * @since 1.1
1: 	 */
1: 	Promise<T> timeout(long milliseconds);
1: 
1: 	/**
1: 	 * Delay after the resolution of this Promise.
1: 	 * <p>
1: 	 * Once this Promise is resolved, resolve the returned Promise with this
1: 	 * Promise after the specified delay.
1: 	 * 
1: 	 * @param milliseconds The time to delay in milliseconds. Zero and negative
1: 	 *            time is treated as no delay.
1: 	 * @return A Promise that is resolved with this Promise after this Promise
1: 	 *         is resolved and the specified delay has elapsed.
1: 	 * @since 1.1
1: 	 */
1: 	Promise<T> delay(long milliseconds);
commit:14ceeb1
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Copyright (c) OSGi Alliance 2015. All Rights Reserved.
1:  *
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
1: @org.osgi.annotation.versioning.ProviderType
commit:0d3d319
/////////////////////////////////////////////////////////////////////////
1: package org.osgi.util.promise;
1: 
1: import org.osgi.util.function.Function;
1: import org.osgi.util.function.Predicate;
1: 
0: import java.lang.reflect.InvocationTargetException;
1: 
1: /**
1:  * A Promise of a value.
1:  * <p/>
1:  * A Promise represents a future value. It handles the interactions to for asynchronous processing. A Deferred object
1:  * can be used to create a Promise and later resolve the Promise. A Promise is used by the caller of an asynchronous
1:  * function to get the result or handle the error. The caller can either get a callback when the Promise is resolved
1:  * with a value or an error, or the Promise can be used in chaining. In chaining, callbacks are provided that receive
1:  * the resolved Promise, and a new Promise is generated that resolves based upon the result of a callback.
1:  * <p/>
1:  * Both callbacks and chaining can be repeated any number of times, even after the Promise has been resolved.
1:  * <p/>
1:  * Example callback usage:
1:  * <pre>
1:  * final Promise<String> foo= foo();
1:  * foo.onResolve(new Runnable() {
1:  * public void run() {
1:  * System.out.println(foo.getValue());
1:  * }
1:  * });
1:  * </pre>
1:  * <p/>
1:  * Example chaining usage;
1:  * <pre>
1:  * Success<String,String> doubler = new Success<String,String>() {
1:  * public Promise<String> call(Promise<String> p) throws Exception {
1:  * return Promises.resolved(p.getValue()+p.getValue());
1:  * }
1:  * };
1:  * final Promise<String> foo = foo().then(doubler).then(doubler);
1:  * foo.onResolve(new Runnable() {
1:  * public void run() {
1:  * System.out.println(foo.getValue());
1:  * }
1:  * });
1:  * </pre>
1:  *
1:  * @param <T> The value type associated with this Promise.
1:  */
0: //@org.osgi.annotation.versioning.ProviderType
1: public interface Promise<T> {
1:     /**
1:      * Returns whether this Promise has been resolved.
1:      * <p/>
1:      * This Promise may be successfully resolved or resolved with a failure.
1:      *
1:      * @return true if this Promise was resolved either successfully or with a failure; false if this Promise is
1:      * unresolved.
1:      */
1:     boolean isDone();
1: 
1:     /**
1:      * Returns the value of this Promise.
1:      * <p/>
1:      * If this Promise is not resolved, this method must block and wait for this Promise to be resolved before
1:      * completing.
1:      * <p/>
1:      * If this Promise was successfully resolved, this method returns with the value of this Promise. If this Promise
1:      * was resolved with a failure, this method must throw an InvocationTargetException with the failure exception as
1:      * the cause.
1:      *
1:      * @return The value of this resolved Promise.
1:      * @throws InvocationTargetException If this Promise was resolved with a failure. The cause of the
1:      *                                   InvocationTargetException is the failure exception.
1:      * @throws InterruptedException      If the current thread was interrupted while waiting.
1:      */
1:     T getValue() throws InvocationTargetException, InterruptedException;
1: 
1:     /**
1:      * Returns the failure of this Promise.
1:      * <p/>
1:      * If this Promise is not resolved, this method must block and wait for this Promise to be resolved before
1:      * completing.
1:      * <p/>
1:      * If this Promise was resolved with a failure, this method returns with the failure of this Promise. If this
1:      * Promise was successfully resolved, this method must return null.
1:      *
1:      * @return The failure of this resolved Promise or null if this Promise was successfully resolved.
1:      * @throws InterruptedException If the current thread was interrupted while waiting.
1:      */
1:     Throwable getFailure() throws InterruptedException;
1: 
1:     /**
1:      * Register a callback to be called when this Promise is resolved.
1:      * <p/>
1:      * The specified callback is called when this Promise is resolved either successfully or with a failure.
1:      * <p/>
1:      * This method may be called at any time including before and after this Promise has been resolved.
1:      * <p/>
1:      * Resolving this Promise happens-before any registered callback is called. That is, in a registered callback,
1:      * isDone() must return true and getValue() and getFailure() must not block.
1:      * <p/>
1:      * A callback may be called on a different thread than the thread which registered the callback. So the callback
1:      * must be thread safe but can rely upon that the registration of the callback happens-before the registered
1:      * callback is called.
1:      *
1:      * @param callback A callback to be called when this Promise is resolved. Must not be null.
1:      * @return This Promise.
1:      */
1:     Promise<T> onResolve(Runnable callback);
1: 
1: 
1:     /**
1:      * Chain a new Promise to this Promise with Success and Failure callbacks.
1:      * <p/>
1:      * The specified Success callback is called when this Promise is successfully resolved and the specified Failure
1:      * callback is called when this Promise is resolved with a failure.
1:      * <p/>
1:      * This method returns a new Promise which is chained to this Promise. The returned Promise must be resolved when
1:      * this Promise is resolved after the specified Success or Failure callback is executed. The result of the executed
1:      * callback must be used to resolve the returned Promise. Multiple calls to this method can be used to create a
1:      * chain of promises which are resolved in sequence.
1:      * <p/>
1:      * If this Promise is successfully resolved, the Success callback is executed and the result Promise, if any, or
1:      * thrown exception is used to resolve the returned Promise from this method. If this Promise is resolved with a
1:      * failure, the Failure callback is executed and the returned Promise from this method is failed.
1:      * <p/>
1:      * This method may be called at any time including before and after this Promise has been resolved.
1:      * <p/>
1:      * Resolving this Promise happens-before any registered callback is called. That is, in a registered callback,
1:      * isDone() must return true and getValue() and getFailure() must not block.
1:      * <p/>
1:      * A callback may be called on a different thread than the thread which registered the callback. So the callback
1:      * must be thread safe but can rely upon that the registration of the callback happens-before the registered
1:      * callback is called.
1:      *
1:      * @param <R>     The value type associated with the returned Promise.
1:      * @param success A Success callback to be called when this Promise is successfully resolved. May be null if no
1:      *                Success callback is required. In thi
1:      * @param failure A Failure callback to be called when this Promise is resolved with a failure. May be null if no
1:      *                Failure callback is required.
1:      * @return A new Promise which is chained to this Promise. The returned Promise must be resolved when this Promise
1:      * is resolved after the specified Success or Failure callback, if any, is executed
1:      */
1:     <R> Promise<R> then(Success<? super T, ? extends R> success, Failure failure);
1: 
1: 
1:     /**
1:      * Chain a new Promise to this Promise with a Success callback.
1:      * <p/>
1:      * This method performs the same function as calling then(Success, Failure) with the specified Success callback and
1:      * null for the Failure callback
1:      *
1:      * @param success A Success callback to be called when this Promise is successfully resolved. May be null if no
1:      *                Success callback is required. In this case, the returned Promise must be resolved with the value
1:      *                null when this Promise is successfully resolved.
1:      * @param <R>     The value type associated with the returned Promise.
1:      * @return A new Promise which is chained to this Promise. The returned Promise must be resolved when this Promise
1:      * is resolved after the specified Success, if any, is executed.
1:      * @see #then(Success, Failure)
1:      */
1:     <R> Promise<R> then(Success<? super T, ? extends R> success);
1: 
1: 
1:     /**
1:      * Filter the value of this Promise.
1:      * <p/>
1:      * If this Promise is successfully resolved, the returned Promise will either be resolved with the value of this
1:      * Promise if the specified Predicate accepts that value or failed with a NoSuchElementException if the specified
1:      * Predicate does not accept that value. If the specified Predicate throws an exception, the returned Promise will
1:      * be failed with the exception.
1:      * <p/>
1:      * If this Promise is resolved with a failure, the returned Promise will be failed with that failure.
1:      * <p/>
1:      * This method may be called at any time including before and after this Promise has been resolved.
1:      *
1:      * @param predicate The Predicate to evaluate the value of this Promise. Must not be null.
1:      * @return A Promise that filters the value of this Promise.
1:      */
1:     Promise<T> filter(Predicate<? super T> predicate);
1: 
1:     /**
1:      * Map the value of this Promise.
1:      * <p/>
1:      * If this Promise is successfully resolved, the returned Promise will be resolved with the value of specified
1:      * Function as applied to the value of this Promise. If the specified Function throws an exception, the returned
1:      * Promise will be failed with the exception.
1:      * <p/>
1:      * If this Promise is resolved with a failure, the returned Promise will be failed with that failure.
1:      * <p/>
1:      * This method may be called at any time including before and after this Promise has been resolved.
1:      *
1:      * @param mapper The Function that will map the value of this Promise to the value that will be used to resolve the
1:      *               returned Promise. Must not be null.
1:      * @param <R>    The value type associated with the returned Promise.
1:      * @return A Promise that returns the value of this Promise as mapped by the specified Function.
1:      */
1:     <R> Promise<R> map(Function<? super T, ? extends R> mapper);
1: 
1:     /**
1:      * FlatMap the value of this Promise.
1:      * <p/>
1:      * If this Promise is successfully resolved, the returned Promise will be resolved with the Promise from the
1:      * specified Function as applied to the value of this Promise. If the specified Function throws an exception, the
1:      * returned Promise will be failed with the exception.
1:      * <p/>
1:      * If this Promise is resolved with a failure, the returned Promise will be failed with that failure.
1:      * <p/>
1:      * This method may be called at any time including before and after this Promise has been resolved.
1:      *
1:      * @param mapper The Function that will flatMap the value of this Promise to a Promise that will be used to resolve
1:      *               the returned Promise. Must not be null.
1:      * @param <R>    The value type associated with the returned Promise.
1:      * @return A Promise that returns the value of this Promise as mapped by the specified Function.
1:      */
1:     <R> Promise<R> flatMap(Function<? super T, Promise<? extends R>> mapper);
1: 
1:     /**
1:      * Recover from a failure of this Promise with a recovery value.
1:      * <p/>
1:      * If this Promise is successfully resolved, the returned Promise will be resolved with the value of this Promise.
1:      * <p/>
1:      * If this Promise is resolved with a failure, the specified Function is applied to this Promise to produce a
1:      * recovery value.
1:      * <p/>
1:      * If the recovery value is not null, the returned Promise will be resolved with the recovery value.
1:      * <p/>
1:      * If the recovery value is null, the returned Promise will be failed with the failure of this Promise.
1:      * <p/>
1:      * If the specified Function throws an exception, the returned Promise will be failed with that exception.
1:      * <p/>
1:      * To recover from a failure of this Promise with a recovery value of null, the recoverWith(Function) method must be
1:      * used. The specified Function for recoverWith(Function) can return Promises.resolved(null) to supply the desired
1:      * null value.
1:      * <p/>
1:      * This method may be called at any time including before and after this Promise has been resolved.
1:      *
1:      * @param recovery If this Promise resolves with a failure, the specified Function is called to produce a recovery
1:      *                 value to be used to resolve the returned Promise. Must not be null.
1:      * @return A Promise that resolves with the value of this Promise or recovers from the failure of this Promise.
1:      */
1:     Promise<T> recover(Function<Promise<?>, ? extends T> recovery);
1: 
1:     /**
1:      * Recover from a failure of this Promise with a recovery Promise.
1:      * <p/>
1:      * If this Promise is successfully resolved, the returned Promise will be resolved with the value of this Promise.
1:      * <p/>
1:      * If this Promise is resolved with a failure, the specified Function is applied to this Promise to produce a
1:      * recovery Promise.
1:      * <p/>
1:      * If the recovery Promise is not null, the returned Promise will be resolved with the recovery Promise.
1:      * <p/>
1:      * If the recovery Promise is null, the returned Promise will be failed with the failure of this Promise.
1:      * <p/>
1:      * If the specified Function throws an exception, the returned Promise will be failed with that exception.
1:      * <p/>
1:      * This method may be called at any time including before and after this Promise has been resolved.
1:      *
1:      * @param recovery If this Promise resolves with a failure, the specified Function is called to produce a recovery
1:      *                 Promise to be used to resolve the returned Promise. Must not be null.
1:      * @return A Promise that resolves with the value of this Promise or recovers from the failure of this Promise.
1:      */
1:     Promise<T> recoverWith(Function<Promise<?>, Promise<? extends T>> recovery);
1: 
1:     /**
1:      * Fall back to the value of the specified Promise if this Promise fails.
1:      * <p/>
1:      * If this Promise is successfully resolved, the returned Promise will be resolved with the value of this Promise.
1:      * <p/>
1:      * If this Promise is resolved with a failure, the successful result of the specified Promise is used to resolve the
1:      * returned Promise. If the specified Promise is resolved with a failure, the returned Promise will be failed with
1:      * the failure of this Promise rather than the failure of the specified Promise.
1:      * <p/>
1:      * This method may be called at any time including before and after this Promise has been resolved.
1:      *
1:      * @param fallback The Promise whose value will be used to resolve the returned Promise if this Promise resolves
1:      *                 with a failure. Must not be null.
1:      * @return A Promise that returns the value of this Promise or falls back to the value of the specified Promise.
1:      */
1:     Promise<T> fallbackTo(Promise<? extends T> fallback);
1: 
1: }
============================================================================