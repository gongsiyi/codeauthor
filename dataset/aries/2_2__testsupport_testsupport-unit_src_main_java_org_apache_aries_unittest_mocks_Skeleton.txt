1:264011e: /*
1:264011e:  * Licensed to the Apache Software Foundation (ASF) under one
1:264011e:  * or more contributor license agreements.  See the NOTICE file
1:264011e:  * distributed with this work for additional information
1:264011e:  * regarding copyright ownership.  The ASF licenses this file
1:264011e:  * to you under the Apache License, Version 2.0 (the
1:264011e:  * "License"); you may not use this file except in compliance
1:264011e:  * with the License.  You may obtain a copy of the License at
1:264011e:  *
1:264011e:  *   http://www.apache.org/licenses/LICENSE-2.0
1:264011e:  *
1:264011e:  * Unless required by applicable law or agreed to in writing,
1:264011e:  * software distributed under the License is distributed on an
1:264011e:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:264011e:  * KIND, either express or implied.  See the License for the
1:264011e:  * specific language governing permissions and limitations
1:264011e:  * under the License.
1:264011e:  */
1:264011e: package org.apache.aries.unittest.mocks;
1:264011e: 
1:264011e: import java.lang.ref.SoftReference;
1:264011e: import java.lang.reflect.Field;
1:264011e: import java.lang.reflect.InvocationHandler;
1:264011e: import java.lang.reflect.InvocationTargetException;
1:264011e: import java.lang.reflect.Method;
1:264011e: import java.lang.reflect.Proxy;
1:264011e: import java.util.ArrayList;
1:264011e: import java.util.HashMap;
1:264011e: import java.util.Iterator;
1:264011e: import java.util.LinkedList;
1:264011e: import java.util.List;
1:264011e: import java.util.Map;
1:264011e: import java.util.concurrent.ConcurrentHashMap;
1:264011e: import java.util.concurrent.ConcurrentMap;
1:264011e: 
1:264011e: import junit.framework.Assert;
1:264011e: import junit.framework.AssertionFailedError;
1:264011e: 
1:264011e: import org.apache.aries.unittest.mocks.annotations.InjectSkeleton;
1:264011e: import org.apache.aries.unittest.mocks.annotations.Singleton;
1:264011e: 
1:264011e: /**
1:264011e:  * <p>The Skeleton class is an implementation of the 
1:264011e:  *   <code>java.lang.reflect.InvocationHandler</code> that can be used for
1:264011e:  *   dynamic mock objects.
1:264011e:  * </p>
1:264011e:  * 
1:264011e:  * <ol>
1:264011e:  *   <li>The static newMock methods can be used to create completely new mock 
1:264011e:  *     objects backed by an entirely new skeleton.
1:264011e:  *   </li>
1:264011e:  *   <li>The static getSkeleton method can be used to obtain the skeleton 
1:264011e:  *     backing a given mock.
1:264011e:  *   </li>
1:264011e:  *   <li>The createMock methods can be used to create a new mock object based on
1:264011e:  *     the skeleton that is invoked.
1:264011e:  *   </li>
1:264011e:  *   <li>The registerMethodCallHandler method can be used to register a handler
1:264011e:  *     that will be invoked when a method is called.
1:264011e:  *   </li>
1:264011e:  *   <li>The registerReturnTypeHandler method can be used to register a handler
1:264011e:  *     that will be invoked when a method with a specific return type is 
1:264011e:  *     invoked. It should be noted that registered ReturnTypeHandlers will be
1:264011e:  *     invoked only if a method call handler has not been registered for the
1:264011e:  *     method that was invoked.
1:264011e:  *   </li>
1:264011e:  *   <li>The setReturnValue method can be used to set a value that will be
1:264011e:  *     returned when a method is invoked.
1:264011e:  *   </li>
1:264011e:  *   <li>The checkCalls methods can be used to determine if the methods in the
1:264011e:  *     list should have been called. They return a boolean to indicate if the
1:264011e:  *     expected calls occurred.
1:264011e:  *   </li>
1:264011e:  *   <li>The assertCalls method performs the same operation as the checkCalls, 
1:264011e:  *     but throws an junit.framework.AssertionFailedError if the calls don't
1:264011e:  *     match. This intended for use within the junit test framework
1:264011e:  *   </li> 
1:264011e:  *   <li>If no method call or return type handlers have been registered for a
1:264011e:  *     call then if the return type is an interface then a mock that implements
1:264011e:  *     that interface will be returned, otherwise null will be returned.
1:264011e:  *   </li>
1:264011e:  * </ol>
1:264011e:  */
1:264011e: public final class Skeleton implements InvocationHandler
1:264011e: {
1:264011e:   /** A list of calls made on this skeleton */
1:264011e:   private List<MethodCall> _methodCalls;
1:264011e:   /** The invocation handler to call after MethodCall and ReturnType handlers */
1:264011e:   private DefaultInvocationHandler default_Handler;
1:264011e:   /** The method call handlers */
1:264011e:   private Map<MethodCall, MethodCallHandler> _callHandlers;
1:264011e:   /** The type handlers */
1:264011e:   private Map<Class<?>, ReturnTypeHandler> _typeHandlers;
1:264011e:   /** The parameter map */
1:264011e:   private Map<String, Object> _mockParameters;
1:264011e:   /** A Map of mock objects to Maps of properties */
1:264011e:   private Map<Object, Map<String, Object>> _objectProperties;
1:264011e:   /** A Map of exception notification listeners */
1:264011e:   private Map<Class<?>, List<ExceptionListener>> _notificationListeners;
1:264011e:   /** The template class used to create this Skeleton, may be null */
1:264011e:   private Object _template;
1:264011e:   /** Cached template objects */
1:264011e:   private static ConcurrentMap<Object, SoftReference<Object>> _singletonMocks = new ConcurrentHashMap<Object, SoftReference<Object>>();
1:264011e: 
1:264011e:   // Constructors
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* Skeleton constructor                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * constructs the skeleton with the default method call handlers and the
1:264011e:    * default return type handlers.
1:264011e:    */
1:264011e:   private Skeleton()
1:264011e:   {
1:264011e:     reset();
1:264011e:   }
1:264011e:   
1:264011e:   // Static methods create methods
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* newMock method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns a completely new mock object backed by a new skeleton
1:264011e:    * object. It is equivalent to 
1:264011e:    * <code>new Skeleton().createMock(interfaceClazzes)</code>
1:264011e:    * 
1:264011e:    * @param interfaceClazzes the classes the mock should implement
1:264011e:    * @return the new mock object.
1:264011e:    */
1:264011e:   public final static Object newMock(Class<?> ... interfaceClazzes)
1:264011e:   {
1:264011e:     return new Skeleton().createMock(interfaceClazzes);
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* newMock method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns a completely new mock object backed by a new skeleton
1:264011e:    * object. It is equivalent to 
1:264011e:    * <code>new Skeleton().createMock(interfaceClazzes)</code>
1:264011e:    * 
1:264011e:    * @param <T>            The object type.
1:264011e:    * @param interfaceClazz the classes the mock should implement
1:264011e:    * @return the new mock object.
1:264011e:    */
1:264011e:   public final static <T> T newMock(Class<T> interfaceClazz)
1:264011e:   {
1:264011e:     return interfaceClazz.cast(new Skeleton().createMock(interfaceClazz));
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * It is often the case that only a subset of methods on an interface are needed, but
1:264011e:    * those methods that are needed are quite complex. In this case a static mock forces
1:264011e:    * you into implementing lots of methods you do not need, and produces problems when
1:264011e:    * new methods are added to the interface being implemented. This method can essentially
1:264011e:    * be used to complete the interface implementation. The object passed in is an instance
1:264011e:    * of a class that implements a subset of the methods on the supplied interface. It does
1:264011e:    * not need to implement the interface itself. The returned object will implement the full
1:264011e:    * interface and delegate to the methods on the templateObject where necessary.
1:264011e:    * 
1:264011e:    * @param <T>            The object type.
1:264011e:    * @param template       The template object for the mock
1:264011e:    * @param interfaceClazz The interface to implement
1:264011e:    * @return An implementation of the interface that delegates (where appropraite) onto the template.  
1:264011e:    */
1:264011e:   public final static <T> T newMock(final Object template, Class<T> interfaceClazz)
1:264011e:   {
1:264011e:     Class<?> templateClass = template.getClass();
1:264011e:     
1:264011e:     if (templateClass.getAnnotation(Singleton.class) != null) {
1:264011e:       SoftReference<Object> mock = _singletonMocks.get(template);
1:264011e:       if (mock != null) {
1:264011e:         Object theMock = mock.get();
1:264011e:         if (theMock == null) {
1:264011e:           _singletonMocks.remove(template);
1:264011e:         } else if (interfaceClazz.isInstance(theMock)) {
1:264011e:           return interfaceClazz.cast(theMock);
1:264011e:         } 
1:264011e:       }
1:264011e:     }
1:264011e:     
1:264011e:     Skeleton s = new Skeleton();
1:264011e:     s._template = template;
1:264011e:     
1:264011e:     for (Method m : interfaceClazz.getMethods()) {
1:264011e:       try {
1:264011e:         final Method m2 = templateClass.getMethod(m.getName(), m.getParameterTypes());
1:264011e:         
1:264011e:         MethodCall mc = new MethodCall(interfaceClazz, m.getName(), (Object[])m.getParameterTypes());
1:264011e:         s.registerMethodCallHandler(mc, new MethodCallHandler()
1:264011e:         {
1:264011e:           public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
1:264011e:           {
1:264011e:             
1:264011e:             try {
1:264011e:               m2.setAccessible(true);
1:264011e:               return m2.invoke(template, methodCall.getArguments());
1:264011e:             } catch (InvocationTargetException ite) {
1:264011e:               if(ite.getTargetException() instanceof Exception)
1:264011e:                 throw (Exception)ite.getTargetException();
1:264011e:               else throw new Exception(ite.getTargetException());
1:264011e:             }
1:264011e:           }
1:264011e:         });
1:264011e:       } catch (NoSuchMethodException e) {
1:264011e:         // do nothing here, it is a method not on the interface so ignore it.
1:264011e:       }
1:264011e:     }
1:264011e:     
1:264011e:     Field[] fs = template.getClass().getFields();
1:264011e:     
1:264011e:     for (Field f : fs) {
1:264011e:       InjectSkeleton sk = f.getAnnotation(InjectSkeleton.class);
1:264011e:       
1:264011e:       if (sk != null) {
1:264011e:         f.setAccessible(true);
1:264011e:         try {
1:264011e:           f.set(template, s);
1:264011e:         } catch (IllegalArgumentException e) {
1:264011e:           e.printStackTrace();
1:264011e:         } catch (IllegalAccessException e) {
1:264011e:           e.printStackTrace();
1:264011e:         }
1:264011e:       }
1:264011e:     }
1:264011e:       
1:264011e:     Object o = s.createMock(interfaceClazz);
1:264011e:     _singletonMocks.put(template, new SoftReference<Object>(o) {
1:264011e:       @Override
1:264011e:       public boolean enqueue()
1:264011e:       {
1:264011e:         _singletonMocks.remove(template);
1:264011e:         
1:264011e:         System.out.println("Done cleanup");
1:264011e:         
1:264011e:         return super.enqueue();
1:264011e:       }
1:264011e:     });
1:264011e:     return interfaceClazz.cast(o);
1:264011e:   }
1:264011e:   
1:264011e:   // static mock query methods
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getSkeleton method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns the Skeleton backing the supplied mock object. If the
1:264011e:    * supplied object is not a mock an IllegalArgumentException will be thrown.
1:264011e:    * 
1:264011e:    * @param mock the mock object
1:264011e:    * @return the skeleton backing the mock object
1:264011e:    * @throws IllegalArgumentException thrown if the object is not a mock.
1:264011e:    */
1:264011e:   public final static Skeleton getSkeleton(Object mock) 
1:264011e:     throws IllegalArgumentException
1:264011e:   {
1:264011e:     InvocationHandler ih = Proxy.getInvocationHandler(mock);
1:264011e:     if (ih instanceof Skeleton)
1:264011e:     {
1:264011e:       return (Skeleton)ih;
1:264011e:     }
1:53ad9ea:     throw new IllegalArgumentException("The supplied proxy (" + mock + ") was not an Aries dynamic mock ");
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* isSkeleton method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns true if and only the provided object is backed by a
1:264011e:    * Skeleton. Another way to think about this is if it returns true then a 
1:264011e:    * call to getSkeleton will not result in an IllegalArgumentException, and is
1:264011e:    * guaranteed to return a Skeleton.
1:264011e:    * 
1:264011e:    * @param mock the mock to test.
1:264011e:    * @return     true if it is backed by a skeleton.
1:264011e:    */
1:264011e:   public final static boolean isSkeleton(Object mock)
1:264011e:   {
1:264011e:     if (Proxy.isProxyClass(mock.getClass())) {
1:264011e:       InvocationHandler ih = Proxy.getInvocationHandler(mock);
1:264011e:       
1:264011e:       return (ih instanceof Skeleton);
1:264011e:     }
1:264011e:     
1:264011e:     return false;
1:264011e:   }
1:264011e: 
1:264011e:   // InvocationHandler defined methods.
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* invoke method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /** 
1:264011e:    * This method is invoked by the mock objects. It constructs a MethodCall
1:264011e:    * object representing the call and adds it to the list of calls that were
1:264011e:    * made. (It should be noted that if the method is toString, hashCode or
1:264011e:    * equals then they are not added to the list.) It then calls a registered
1:264011e:    * MethodCallHandler, if a MethodCallHandler is not registered then a 
1:264011e:    * ReturnTypeHandler is invoked. If a ReturnTypeHandler is not invoked then
1:264011e:    * the registered default InvocationHandler is called. By default the Skeleton
1:264011e:    * is constructed with a DefaultInvocationHandler. If the invoked method has
1:264011e:    * an interface as a return type then the DefaultInvocationHandler will return
1:264011e:    * a new mock implementing that interface. If the return type is a class null
1:264011e:    * will be returned.
1:264011e:    * 
1:264011e:    * @param targetObject The mock object that was invoked.
1:264011e:    * @param calledMethod The method that was called.
1:264011e:    * @param arguments    The arguments that were passed.
1:264011e:    * @return             The return of the method invoked.
1:264011e:    * @throws Throwable   Any exception thrown.
1:264011e:    */
1:264011e:   public Object invoke(Object targetObject, Method calledMethod, Object[] arguments)
1:264011e:       throws Throwable
1:264011e:   {
1:264011e:     String methodName = calledMethod.getName();
1:264011e:     MethodCall call = new MethodCall(targetObject, methodName, arguments);
1:264011e: 
1:264011e:     if (!DefaultMethodCallHandlers.isDefaultMethodCall(call))
1:264011e:     {
1:264011e:       _methodCalls.add(call);
1:264011e:     }
1:264011e: 
1:264011e:     Object result;
1:264011e:     
1:264011e:     try
1:264011e:     {
1:264011e:       if (_callHandlers.containsKey(call))
1:264011e:       {
1:264011e:         MethodCallHandler handler =  _callHandlers.get(call);
1:264011e:         result = handler.handle(call, this);
1:264011e:       }
1:264011e:       else if (isReadWriteProperty(targetObject.getClass(), calledMethod))
1:264011e:       {
1:264011e:         String propertyName = methodName.substring(3);
1:264011e:         if (methodName.startsWith("get") || methodName.startsWith("is"))
1:264011e:         {
1:264011e:           if (methodName.startsWith("is")) propertyName = methodName.substring(2);
1:264011e:           
1:264011e:           Map<String, Object> properties = _objectProperties.get(targetObject);
1:264011e:           if (properties == null)
1:264011e:           {
1:264011e:             properties = new HashMap<String, Object>();
1:264011e:             _objectProperties.put(targetObject, properties);
1:264011e:           }
1:264011e:           
1:264011e:           if (properties.containsKey(propertyName))
1:264011e:           {
1:264011e:             result = properties.get(propertyName);
1:264011e:           }
1:264011e:           else if (_typeHandlers.containsKey(calledMethod.getReturnType()))
1:264011e:           {
1:264011e:             result = createReturnTypeProxy(calledMethod.getReturnType());
1:264011e:           }
1:264011e:           else
1:264011e:           {
1:264011e:             result = default_Handler.invoke(targetObject, calledMethod, arguments);
1:264011e:           }          
1:264011e:         }
1:264011e:         // Must be a setter.
1:264011e:         else
1:264011e:         {
1:264011e:           Map<String, Object> properties = _objectProperties.get(targetObject);
1:264011e:           if (properties == null)
1:264011e:           {
1:264011e:             properties = new HashMap<String, Object>();
1:264011e:             _objectProperties.put(targetObject, properties);
1:264011e:           }
1:264011e:           
1:264011e:           properties.put(propertyName, arguments[0]);
1:264011e:           result = null;
1:264011e:         }
1:264011e:       }
1:264011e:       else if (_typeHandlers.containsKey(calledMethod.getReturnType()))
1:264011e:       {
1:264011e:         result = createReturnTypeProxy(calledMethod.getReturnType());
1:264011e:       }
1:264011e:       else
1:264011e:       {
1:264011e:         result = default_Handler.invoke(targetObject, calledMethod, arguments);
1:264011e:       }
1:264011e:     }
1:264011e:     catch (Throwable t)
1:264011e:     {
1:264011e:       Class<?> throwableType = t.getClass();
1:264011e:       List<ExceptionListener> listeners = _notificationListeners.get(throwableType);
1:264011e:       if (listeners != null)
1:264011e:       {
1:264011e:         for (ExceptionListener listener : listeners)
1:264011e:         {
1:264011e:           listener.exceptionNotification(t);
1:264011e:         }
1:264011e:       }
1:264011e:       
1:264011e:       throw t;
1:264011e:     }
1:264011e:     
1:264011e:     return result;
1:264011e:   }
1:264011e: 
1:264011e:   // MethodCall registration methods
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* registerMethodCallHandler method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method registers a MethodCallHandler for the specified MethodCall.
1:264011e:    * 
1:264011e:    * @param call    The method that was called.
1:264011e:    * @param handler The MethodCallHandler.
1:264011e:    */
1:264011e:   public void registerMethodCallHandler(MethodCall call, MethodCallHandler handler)
1:264011e:   {
1:264011e:     deRegisterMethodCallHandler(call);
1:264011e:     _callHandlers.put(call, handler);
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* deRegisterMethodCallHandler method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method removes a registered MethodCallHandler for the specified 
1:264011e:    * MethodCall.
1:264011e:    * 
1:264011e:    * @param call the specified MethodCall
1:264011e:    */
1:264011e:   public void deRegisterMethodCallHandler(MethodCall call)
1:264011e:   {
1:264011e:     _callHandlers.remove(call);
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* reset method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method resets the skeleton to the state it was in prior just after it
1:264011e:    * was constructed. 
1:264011e:    */
1:264011e:   public void reset()
1:264011e:   {
1:264011e:     _methodCalls = new LinkedList<MethodCall>();
1:264011e:     _callHandlers = new HashMap<MethodCall, MethodCallHandler>();
1:264011e:     _typeHandlers = new HashMap<Class<?>, ReturnTypeHandler>();
1:264011e:     DefaultReturnTypeHandlers.registerDefaultHandlers(this);
1:264011e:     DefaultMethodCallHandlers.registerDefaultHandlers(this);
1:264011e:     default_Handler = new DefaultInvocationHandler(this);
1:264011e:     _mockParameters = new HashMap<String, Object>();
1:264011e:     _objectProperties = new HashMap<Object, Map<String, Object>>();
1:264011e:     _notificationListeners = new HashMap<Class<?>, List<ExceptionListener>>();
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* clearMethodCalls method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method clears the method calls list for the skeleton
1:264011e:    */
1:264011e:   public void clearMethodCalls()
1:264011e:   {
1:264011e:     _methodCalls = new LinkedList<MethodCall>();
1:264011e:   }
1:264011e:   
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* setReturnValue method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This is a convenience method for registering a method call handler where
1:264011e:    * a specific value should be returned when a method is called, rather than 
1:264011e:    * some logic needs to be applied. The value should be an object or the object
1:264011e:    * version of the primitive for the methods return type, so if the method
1:264011e:    * returns short the value must be an instance of java.lang.Short, not 
1:264011e:    * java.lang.Integer.   
1:264011e:    * 
1:264011e:    * @param call  the method being called.
1:264011e:    * @param value the value to be returned when that method is called.
1:264011e:    */
1:264011e:   public void setReturnValue(MethodCall call, final Object value)
1:264011e:   {
1:264011e:     Class<?> clazz;
1:264011e:     try {
1:264011e:       clazz = Class.forName(call.getClassName());
1:264011e:     } catch (ClassNotFoundException e) {
1:264011e:       throw new IllegalStateException("This should be impossible as we have already seen this class loaded");
1:264011e:     }
1:264011e:     
1:264011e:     
1:264011e:       Method[] methods = clazz.getMethods();
1:264011e:       
1:264011e:       methods: for (Method m : methods) {
1:264011e:         if(!!!m.getName().equals(call.getMethodName()))
1:264011e:           continue methods;
1:264011e:         
1:264011e:         Object[] args = call.getArguments();
1:264011e:         Class<?>[] parms = m.getParameterTypes();
1:264011e:         
1:264011e:         if (args.length == parms.length) {
1:264011e:           for (int i = 0; i < args.length; i++) {
1:264011e:             if (args[i] instanceof Class && args[i].equals(parms[i])) {
1:264011e:             } else if (parms[i].isInstance(args[i])) {
1:264011e:             } else {
1:264011e:               continue methods;
1:264011e:             }
1:264011e:           }
1:264011e:           
1:264011e:           Class<?> returnType = m.getReturnType();
1:264011e:           if (returnType.isPrimitive()) {
1:264011e:             if (returnType == boolean.class) returnType = Boolean.class;
1:264011e:             else if (returnType == byte.class) returnType = Byte.class;
1:264011e:             else if (returnType == short.class) returnType = Short.class;
1:264011e:             else if (returnType == char.class) returnType = Character.class;
1:264011e:             else if (returnType == int.class) returnType = Integer.class;
1:264011e:             else if (returnType == long.class) returnType = Long.class;
1:264011e:             else if (returnType == float.class) returnType = Float.class;
1:264011e:             else if (returnType == double.class) returnType = Double.class;
1:264011e:           }
1:264011e:           
1:264011e:           if (value != null && !!!returnType.isInstance(value)) {
1:264011e:             throw new IllegalArgumentException("The object cannot be returned by the requested method: " + call);
1:264011e:           } else break methods; 
1:264011e:         }
1:264011e:       }
1:264011e:     
1:264011e:     
1:264011e:     
1:264011e:     registerMethodCallHandler(call, new MethodCallHandler()
1:264011e:     {
1:264011e:       public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
1:264011e:       {
1:264011e:         return value;
1:264011e:       }
1:264011e:     });
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* setThrow method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This is a convenience method for registering a method call handler where
1:264011e:    * a specific exception should be thrown when the method is called, rather
1:264011e:    * than some logic needs to be applied.
1:264011e:    * 
1:264011e:    * @param call         the method being called
1:264011e:    * @param thingToThrow the exception to throw.
1:264011e:    */
1:264011e:   public void setThrows(MethodCall call, final Exception thingToThrow)
1:264011e:   {
1:264011e:     registerMethodCallHandler(call, new MethodCallHandler()
1:264011e:     {
1:264011e:       public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
1:264011e:       {
1:264011e:         thingToThrow.fillInStackTrace();
1:264011e:         throw thingToThrow;
1:264011e:       }
1:264011e:     });
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* setThrow method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This is a convenience method for registering a method call handler where
1:264011e:    * a specific exception should be thrown when the method is called, rather
1:264011e:    * than some logic needs to be applied.
1:264011e:    * 
1:264011e:    * @param call         the method being called
1:264011e:    * @param thingToThrow the exception to throw.
1:264011e:    */
1:264011e:   public void setThrows(MethodCall call, final Error thingToThrow)
1:264011e:   {
1:264011e:     registerMethodCallHandler(call, new MethodCallHandler()
1:264011e:     {
1:264011e:       public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
1:264011e:       {
1:264011e:         thingToThrow.fillInStackTrace();
1:264011e:         throw thingToThrow;
1:264011e:       }
1:264011e:     });
1:264011e:   }
1:264011e: 
1:264011e:   // ReturnType registration methods
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* registerReturnTypeHandler method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method registers a ReturnTypeHandler for the specified class.
1:264011e:    * 
1:264011e:    * @param clazz   The class to be handled.
1:264011e:    * @param handler The ReturnTypeHandler
1:264011e:    */
1:264011e:   public void registerReturnTypeHandler(Class<?> clazz, ReturnTypeHandler handler)
1:264011e:   {
1:264011e:     deRegisterReturnTypeHandler(clazz);
1:264011e:     _typeHandlers.put(clazz, handler);
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* deRegisterReturnTypeHandler method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method removes a registration for a ReturnTypeHandler for the 
1:264011e:    * specified class.
1:264011e:    * 
1:264011e:    * @param clazz The class to deregister the handler for.
1:264011e:    */
1:264011e:   public void deRegisterReturnTypeHandler(Class<?> clazz)
1:264011e:   {
1:264011e:     _typeHandlers.remove(clazz);
1:264011e:   }
1:264011e:   
1:264011e:   // Exception notification methods
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* registerExceptionListener method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method registers an ExceptionListener when the specified Exception is
1:264011e:    * thrown.
1:264011e:    * 
1:264011e:    * @param throwableType The type of the Throwable
1:264011e:    * @param listener      The listener.
1:264011e:    */
1:264011e:   public void registerExceptionListener(Class<?> throwableType, ExceptionListener listener)
1:264011e:   {
1:264011e:     List<ExceptionListener> l = _notificationListeners.get(throwableType);
1:264011e:     if (l == null)
1:264011e:     {
1:264011e:       l = new ArrayList<ExceptionListener>();
1:264011e:       _notificationListeners.put(throwableType, l);
1:264011e:     }
1:264011e:     l.add(listener);
1:264011e:   }
1:264011e:   
1:264011e:   // parameter related methods
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* setParameter method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method allows a parameter to be set. It is intended to be used by
1:264011e:    * MethodCallHandlers and ReturnTypeHandlers.
1:264011e:    * 
1:264011e:    * @param key   The key
1:264011e:    * @param value The value
1:264011e:    */
1:264011e:   public void setParameter(String key, Object value)
1:264011e:   {
1:264011e:     _mockParameters.put(key, value);
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getParameter method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method allows a parameter to be retrieved.
1:264011e:    * 
1:264011e:    * @param key the key the parameter was set using
1:264011e:    * @return the parameter
1:264011e:    */
1:264011e:   public Object getParameter(String key)
1:264011e:   {
1:264011e:     return _mockParameters.get(key);
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getTemplateObject method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * @return the template object, if one was used when initializing this skeleton.
1:264011e:    */
1:264011e:   public Object getTemplateObject()
1:264011e:   {
1:264011e:     return _template;
1:264011e:   }
1:264011e:   
1:264011e:   // default InvocationHandler related methods
1:264011e:   
1:264011e:   /**
1:264011e:    * @param defaultHandler The defaultHandler to set.
1:264011e:    */
1:264011e:   public void setDefaultHandler(DefaultInvocationHandler defaultHandler)
1:264011e:   {
1:264011e:     this.default_Handler = defaultHandler;
1:264011e:   }
1:264011e:   
1:264011e:   // MethodCall list check methods
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* checkCalls method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method checks that the calls in the list occurred. If the addCalls
1:264011e:    * boolean is true then their must be an exact match. If the allCalls boolean
1:264011e:    * is false then the calls in the list must occur in that order, but other 
1:264011e:    * calls can be in between. 
1:264011e:    * 
1:264011e:    * @param calls    The expected calls list
1:264011e:    * @param allCalls true if an exact match comparison should be performed
1:264011e:    * @return         true if they the expected calls match.
1:264011e:    */
1:264011e:   public boolean checkCalls(List<MethodCall> calls, boolean allCalls)
1:264011e:   {
1:264011e:     boolean found = false;
1:264011e:     if (allCalls)
1:264011e:     {
1:264011e:       return calls.equals(_methodCalls);
1:264011e:     }
1:264011e:     else
1:264011e:     {
1:264011e:       Iterator<MethodCall> actual = _methodCalls.iterator();
1:264011e:       for (MethodCall expectedCall : calls)
1:264011e:       {
1:264011e:         found = false;
1:264011e:         actual: while (actual.hasNext())
1:264011e:         {
1:264011e:           MethodCall actualCall = actual.next();
1:264011e:           if (actualCall.equals(expectedCall))
1:264011e:           {
1:264011e:             found = true;
1:264011e:             break actual;
1:264011e:           }
1:264011e:         }
1:264011e:       }
1:264011e:     }
1:264011e:     
1:264011e:     return found;
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* checkCall method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * Checks that the specified method has been called on this skeleton
1:264011e:    * 
1:264011e:    * @param call the call that should have been called.
1:264011e:    * @return     true if the MethodCall occurs in the list.
1:264011e:    */
1:264011e:   public boolean checkCall(MethodCall call)
1:264011e:   {
1:264011e:     return this._methodCalls.contains(call);
1:264011e:   }
1:264011e:   
1:264011e:   // MethodCall list assert methods
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* assertCalls method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method checks that the MethodCalls objects in the given list were
1:264011e:    * made and throws an AssertionFailedError if they were not. If allCalls is
1:264011e:    * true the given list and the calls list must be identical. If allCalls is
1:264011e:    * false other calls could have been made on the skeleton in between ones
1:264011e:    * specified in the list.
1:264011e:    * 
1:264011e:    * @param calls the list of calls
1:264011e:    * @param allCalls whether an exact match between the lists is required
1:264011e:    * @throws AssertionFailedError if a failure has occurred.
1:264011e:    */
1:264011e:   public void assertCalled(List<MethodCall> calls, boolean allCalls) throws AssertionFailedError
1:264011e:   {
1:264011e:     if (allCalls)
1:264011e:     {
1:264011e:       if ((calls == null) && (_methodCalls == null)) return;
1:264011e: 
1:264011e:       if (calls == null)
1:264011e:       {
1:264011e:         throw new AssertionFailedError("expected null, but was " + _methodCalls);
1:264011e:       }
1:264011e: 
1:264011e:       if (_methodCalls == null)
1:264011e:       {
1:264011e:         throw new AssertionFailedError("expected:" + calls + " but was null");
1:264011e:       }
1:264011e: 
1:264011e:       if (calls.equals(_methodCalls)) return;
1:264011e: 
1:264011e:       // OK compare lists and decide on differences - initially all the lists are different
1:264011e:       int startOfDifferences = 0;
1:264011e:       // Remove the common start of sequence
1:264011e:       boolean lastItemSame = true;
1:264011e: 
1:264011e:       for (int i = 0; i < calls.size() && i < _methodCalls.size() && lastItemSame; i++)
1:264011e:       {
1:264011e:         if ((calls.get(i) == null) && (_methodCalls.get(i) == null))
1:264011e:         {
1:264011e:           lastItemSame = true;
1:264011e:         } 
1:264011e:         else if ((calls.get(i) == null) || (_methodCalls.get(i) == null))
1:264011e:         {
1:264011e:           lastItemSame = false;
1:264011e:         } 
1:264011e:         else
1:264011e:         {
1:264011e:           lastItemSame = calls.get(i).equals(_methodCalls.get(i));
1:264011e:         }
1:264011e: 
1:264011e:         if (lastItemSame) startOfDifferences++;
1:264011e: 
1:264011e:       }//for
1:264011e:       // Now remove the common bit at the end
1:264011e:       int endOfDifferencesInExpected = calls.size();
1:264011e:       int endOfDifferencesInReceived = _methodCalls.size();
1:264011e:       lastItemSame = true;
1:264011e: 
1:264011e:       while ((endOfDifferencesInExpected > startOfDifferences)
1:264011e:         && (endOfDifferencesInReceived > startOfDifferences)
1:264011e:         && lastItemSame)
1:264011e:       {
1:264011e:         int ap = endOfDifferencesInExpected - 1;
1:264011e:         int bp = endOfDifferencesInReceived - 1;
1:264011e: 
1:264011e:         if ((calls.get(ap) == null) && (_methodCalls.get(bp) == null))
1:264011e:         {
1:264011e:           lastItemSame = true;
1:264011e:         } 
1:264011e:         else if ((calls.get(ap) == null) || (_methodCalls.get(bp) == null))
1:264011e:         {
1:264011e:           lastItemSame = false;
1:264011e:         } 
1:264011e:         else
1:264011e:         {
1:264011e:           lastItemSame = calls.get(ap).equals(_methodCalls.get(bp));
1:264011e:         }
1:264011e: 
1:264011e:         if (lastItemSame)
1:264011e:         {
1:264011e:           endOfDifferencesInExpected--;
1:264011e:           endOfDifferencesInReceived--;
1:264011e:         }
1:264011e: 
1:264011e:       }//while
1:264011e: 
1:264011e:       String failureText;
1:264011e:       // OK, now build the failureText
1:264011e:       if (endOfDifferencesInExpected == startOfDifferences)
1:264011e:       {
1:264011e:         failureText =
1:264011e:             "Expected calls and actual calls differed because "
1:264011e:             + _methodCalls.subList(startOfDifferences, endOfDifferencesInReceived)
1:264011e:             + " inserted after element "
1:264011e:             + startOfDifferences;
1:264011e: 
1:264011e:       } 
1:264011e:       else if (endOfDifferencesInReceived == startOfDifferences)
1:264011e:       {
1:264011e:         failureText =
1:264011e:             "Expected calls and actual calls differed  because "
1:264011e:             + calls.subList(startOfDifferences, endOfDifferencesInExpected)
1:264011e:             + " missing after element "
1:264011e:             + startOfDifferences;
1:264011e: 
1:264011e:       } 
1:264011e:       else
1:264011e:       {
1:264011e:         if ((endOfDifferencesInExpected == startOfDifferences + 1)
1:264011e:           && (endOfDifferencesInReceived == startOfDifferences + 1))
1:264011e:         {
1:264011e: 
1:264011e:           failureText =
1:264011e:               "Expected calls and actual calls differed  because element "
1:264011e:               + startOfDifferences
1:264011e:               + " is different (calls:"
1:264011e:               + calls.get(startOfDifferences)
1:264011e:               + " but was:"+_methodCalls.get(startOfDifferences)+") ";
1:264011e: 
1:264011e:         } 
1:264011e:         else if (endOfDifferencesInExpected == startOfDifferences + 1)
1:264011e:         {
1:264011e: 
1:264011e:             failureText =
1:264011e:                 "Expected calls and actual calls differed  because element "
1:264011e:                 + startOfDifferences
1:264011e:                 + " ("
1:264011e:                 + calls.get(startOfDifferences)
1:264011e:                 + ") has been replaced by "
1:264011e:                 + _methodCalls.subList(startOfDifferences, endOfDifferencesInReceived);
1:264011e:         } 
1:264011e:         else
1:264011e:         {
1:264011e:           failureText =
1:264011e:                 "Expected calls and actual calls differed  because elements between "
1:264011e:                 + startOfDifferences
1:264011e:                 + " and "
1:264011e:                 + (endOfDifferencesInExpected - 1)
1:264011e:                 + " are different (expected:"
1:264011e:                 + calls.subList(startOfDifferences, endOfDifferencesInExpected)
1:264011e:                 + " but was:"
1:264011e:                 + _methodCalls.subList(startOfDifferences, endOfDifferencesInReceived)
1:264011e:                 + ")";
1:264011e:         }//if
1:264011e:       }//if
1:264011e: 
1:264011e:       throw new AssertionFailedError(failureText + " expected:" + calls + " but was:" + _methodCalls);
1:264011e:     }
1:264011e:     else
1:264011e:     {
1:264011e:       Iterator<MethodCall> expected = calls.iterator();
1:264011e:       Iterator<MethodCall> actual = _methodCalls.iterator();
1:264011e:       while (expected.hasNext())
1:264011e:       {
1:264011e:         boolean found = false;
1:264011e:         MethodCall expectedCall = expected.next();
1:264011e:         MethodCall actualCall = null;
1:264011e:         
1:264011e:         actual: while (actual.hasNext())
1:264011e:         {
1:264011e:           actualCall = actual.next();
1:264011e:           if (actualCall.equals(expectedCall))
1:264011e:           {
1:264011e:             found = true;
1:264011e:             break actual;
1:264011e:           }
1:264011e:         }
1:264011e:         
1:264011e:         if (!found)
1:264011e:         {
1:264011e:           throw new AssertionFailedError( "The method call " + 
1:264011e:                                           expectedCall + 
1:264011e:                                           " was expected but has not occurred (actual calls = "+_methodCalls+")");
1:264011e:         }
1:264011e:       }
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* assertCall method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This does the same as checkCall, but throws an 
1:264011e:    * junit.framework.AssertionFailedError if the call did not occur.
1:264011e:    * 
1:264011e:    * @param call the call that was expected
1:264011e:    */
1:264011e:   public void assertCalled(MethodCall call)
1:264011e:   {
1:264011e:     if (!checkCall(call))
1:264011e:     {
1:264011e:       throw new AssertionFailedError("The method call " + 
1:264011e:                                       call + 
1:264011e:                                       " was expected but has not occurred. Actual calls: " + getMethodCallsAsString());
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* assertCalledExactNumberOfTimes method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method asserts that the method specified in the call parameter has 
1:264011e:    * been called the number of times specified by numberOfCalls. If 
1:264011e:    * numberOfCalls is zero this method is equivalent to assertNotCalled.
1:264011e:    * 
1:264011e:    * @param call          The call that was made.
1:264011e:    * @param numberOfCalls The number of times the call should have been made.
1:264011e:    */
1:264011e:   public void assertCalledExactNumberOfTimes(MethodCall call, int numberOfCalls)
1:264011e:   {
1:264011e:     int callCount = 0;
1:264011e:     
1:264011e:     for (MethodCall callMade : _methodCalls)
1:264011e:     {
1:264011e:       if (callMade.equals(call))
1:264011e:       {
1:264011e:         callCount++;
1:264011e:       }
1:264011e:     }
1:264011e:     
1:264011e:     if (numberOfCalls != callCount)
1:264011e:     {
1:264011e:       throw new AssertionFailedError("The method call " + call + 
1:264011e:           " should have been called " + numberOfCalls + 
1:264011e:           " time(s), but was called " + callCount + " time(s)");
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* assertNotCalled method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method throws an junit.framework.AssertionFailedError if the specified
1:264011e:    * call was invoked on the skeleton. 
1:264011e:    * 
1:264011e:    * @param call the call to check.
1:264011e:    */
1:264011e:   public void assertNotCalled(MethodCall call)
1:264011e:   {
1:264011e:     Assert.assertFalse( "The method call " + 
1:264011e:                         call + 
1:53ad9ea:                         " occurred in the skeleton " + 
1:264011e:                         this.toString(), checkCall(call));
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* assertMockNotCalled method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method throws an junit.framework.AssertionFailedError if the skeleton
1:264011e:    * has had any methods invoked on it. 
1:264011e:    */
1:264011e:   public void assertSkeletonNotCalled()
1:264011e:   {
1:264011e:     Assert.assertEquals("The skeleton " + this.toString() + 
1:264011e:         " has had the following method invoked on it " + getMethodCallsAsString(), 
1:264011e:         0, _methodCalls.size());
1:264011e:   }
1:264011e: 
1:264011e:   // Instance mock creation methods
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* createMock method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * Creates a new Mock using this skeleton backing it.
1:264011e:    * 
1:264011e:    * @param interfaceClasses an array of interface the mock should implement.
1:264011e:    * @return the mock
1:264011e:    */
1:264011e:   public Object createMock(Class<?> ... interfaceClasses)
1:264011e:   {
1:264011e:     ClassLoader cl;
1:264011e:     
1:264011e:     if (interfaceClasses.length > 0) cl = interfaceClasses[0].getClassLoader();
1:264011e:     else cl = Thread.currentThread().getContextClassLoader();
1:264011e:     
1:264011e:     return Proxy.newProxyInstance(cl, interfaceClasses, this);
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* createMock method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * Creates a new Mock using this skeleton backing it.
1:264011e:    * 
1:264011e:    * @param <T> The object type
1:264011e:    * @param interfaceClass an array of interface the mock should implement.
1:264011e:    * @return the mock
1:264011e:    */
1:264011e:   public <T> T createMock(Class<T> interfaceClass)
1:264011e:   {
1:264011e:     return interfaceClass.cast(Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class[] {interfaceClass}, this));
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* invokeReturnTypeHandlers method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method invokes the return type proxy for the specified class. If a
1:264011e:    * ReturnTypeHandler for that type has not been registered then if the class
1:264011e:    * represents an interface a new mock will be returned, backed by this 
1:264011e:    * skeleton, otherwise null will be returned.
1:264011e:    * 
1:264011e:    * @param type       the type to be invoked.
1:264011e:    * @return           the returned object.
1:264011e:    * @throws Exception if an error occurs when invoking the return type handler.
1:264011e:    */
1:264011e:   public Object invokeReturnTypeHandlers(Class<?> type) throws Exception
1:264011e:   {
1:264011e:     if (_typeHandlers.containsKey(type))
1:264011e:     {
1:264011e:       ReturnTypeHandler rth =  _typeHandlers.get(type);
1:264011e:       return rth.handle(type, this);
1:264011e:     }
1:264011e:     else if (type.isInterface())
1:264011e:     {
1:264011e:       return createMock(type);
1:264011e:     }
1:264011e:     else
1:264011e:     {
1:264011e:       return null;
1:264011e:     }
1:264011e:   }
1:264011e: 
1:264011e:   // Miscellaneous methods that have been deprecated and will be removed.
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* createReturnTypeProxy method
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * create a proxy for given return type. 
1:264011e:    *
1:264011e:    * @deprecated use invokeReturnTypeHandlers instead
1:264011e:    *  
1:264011e:    * @param type               The return type for which a handler is required
1:264011e:    * @return ReturnTypeHandler The return type handler
1:264011e:    * @throws Exception         Thrown if an exception occurs.
1:264011e:    */
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   @Deprecated
1:264011e:   private final Object createReturnTypeProxy(Class<?> type) throws Exception
1:264011e:   {
1:264011e:     return invokeReturnTypeHandlers(type);
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* isReadWriteProperty method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns true if the method passed a getter for a read write
1:264011e:    * java bean property. This is worked out by checking that a setter and getter
1:264011e:    * exist for the property and that the setter and getter take and return 
1:264011e:    * exactly the same time.
1:264011e:    * 
1:264011e:    * @param objClass The object the read write method has been invoked on.
1:264011e:    * @param method   The method to be checked.
1:264011e:    * @return         true if it is a getter or setter for a read write property.
1:264011e:    */
1:264011e:   private boolean isReadWriteProperty(Class<?> objClass, Method method)
1:264011e:   {
1:264011e:     String methodName = method.getName();
1:264011e:     String propertyName = methodName.substring(3);
1:264011e:     Class<?>[] parameters = method.getParameterTypes();
1:264011e:     Class<?> clazz;
1:264011e:     boolean result = false;
1:264011e:     
1:264011e:     if (methodName.startsWith("get") && parameters.length == 0)
1:264011e:     {
1:264011e:       clazz = method.getReturnType();
1:264011e:       try
1:264011e:       {
1:264011e:         objClass.getMethod("set" + propertyName, clazz);
1:264011e:         result = true;
1:264011e:       }
1:264011e:       catch (NoSuchMethodException e)
1:264011e:       {
1:264011e:         if (isPrimitive(clazz))
1:264011e:         {
1:264011e:           clazz = getOtherForm(clazz);
1:264011e:           try
1:264011e:           {
1:264011e:             objClass.getMethod("set" + propertyName, clazz);
1:264011e:             result = true;
1:264011e:           }
1:264011e:           catch (NoSuchMethodException e1)
1:264011e:           {
1:264011e:             
1:264011e:           }
1:264011e:         }
1:264011e:       }
1:264011e:     }
1:264011e:     else if (methodName.startsWith("is") && parameters.length == 0)
1:264011e:     {
1:264011e:       clazz = method.getReturnType();
1:264011e:       if (clazz.equals(Boolean.class) || clazz.equals(boolean.class))
1:264011e:       {
1:264011e:         propertyName = methodName.substring(2);
1:264011e:         try
1:264011e:         {
1:264011e:           objClass.getMethod("set" + propertyName, clazz);
1:264011e:           result = true;
1:264011e:         }
1:264011e:         catch (NoSuchMethodException e)
1:264011e:         {
1:264011e:           
1:264011e:           if (isPrimitive(clazz))
1:264011e:           {
1:264011e:             clazz = getOtherForm(clazz);
1:264011e:             try
1:264011e:             {
1:264011e:               objClass.getMethod("set" + propertyName, clazz);
1:264011e:               result = true;
1:264011e:             }
1:264011e:             catch (NoSuchMethodException e1)
1:264011e:             {
1:264011e:               
1:264011e:             }
1:264011e:           }
1:264011e:         }
1:264011e:       }
1:264011e:     }
1:264011e:     else if (methodName.startsWith("set") && parameters.length == 1)
1:264011e:     {
1:264011e:       clazz = parameters[0];
1:264011e:       
1:264011e:       try
1:264011e:       {
1:264011e:         Method getter = objClass.getMethod("get" + propertyName, new Class[0]);
1:264011e:         result = checkClasses(getter.getReturnType(), clazz);
1:264011e:       }
1:264011e:       catch (NoSuchMethodException e)
1:264011e:       {
1:264011e:         if (isPrimitive(clazz))
1:264011e:         {
1:264011e:           clazz = getOtherForm(clazz);
1:264011e:           try
1:264011e:           {
1:264011e:             Method getter = objClass.getMethod("get" + propertyName, new Class[0]);
1:264011e:             result = checkClasses(getter.getReturnType(), clazz);
1:264011e:           }
1:264011e:           catch (NoSuchMethodException e1)
1:264011e:           {
1:264011e:             if (clazz.equals(Boolean.class) || clazz.equals(boolean.class))
1:264011e:             {
1:264011e:               try
1:264011e:               {
1:264011e:                 Method getter = objClass.getMethod("is" + propertyName, new Class[0]);
1:264011e:                 result = checkClasses(getter.getReturnType(), clazz);
1:264011e:               }
1:264011e:               catch (NoSuchMethodException e2)
1:264011e:               {
1:264011e:                 clazz = getOtherForm(clazz);
1:264011e:                 try
1:264011e:                 {
1:264011e:                   Method getter = objClass.getMethod("is" + propertyName, new Class[0]);
1:264011e:                   result = checkClasses(getter.getReturnType(), clazz);
1:264011e:                 }
1:264011e:                 catch (NoSuchMethodException e3)
1:264011e:                 {
1:264011e:                 }
1:264011e:               }
1:264011e:             }
1:264011e:           }
1:264011e:         }
1:264011e:       }
1:264011e:     }
1:264011e:     
1:264011e:     return result;
1:264011e:   }
1:264011e:   
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* isPrimitive method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns true if the class object represents a primitive or the
1:264011e:    * object version of a primitive.
1:264011e:    * 
1:264011e:    * @param clazz The class to be checked.
1:264011e:    * @return      true if it is a primitive or a wrapper.
1:264011e:    */
1:264011e:   private boolean isPrimitive(Class<?> clazz)
1:264011e:   {
1:264011e:     boolean result = false;
1:264011e:     
1:264011e:     if (clazz.isPrimitive())
1:264011e:     {
1:264011e:       result = true;
1:264011e:     }
1:264011e:     else
1:264011e:     {
1:264011e:       result =  clazz.equals(Boolean.class) || clazz.equals(Byte.class) || 
1:264011e:                 clazz.equals(Short.class) || clazz.equals(Character.class) ||
1:264011e:                 clazz.equals(Integer.class) || clazz.equals(Long.class) ||
1:264011e:                 clazz.equals(Float.class) || clazz.equals(Double.class);
1:264011e:     }
1:264011e:     
1:264011e:     return result;
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getOtherForm method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method takes a class representing either a primitive or an object 
1:264011e:    * wrapper. If the class is a primitive type the object wrapper class is 
1:264011e:    * returned. If the class is an object wrapper class the primitive type is
1:264011e:    * returned.
1:264011e:    * 
1:264011e:    * @param clazz
1:264011e:    * @return the class representing the primitive object wrapper.
1:264011e:    */
1:264011e:   private Class<?> getOtherForm(Class<?> clazz)
1:264011e:   {
1:264011e:     Class<?> result = null;
1:264011e:     
1:264011e:     if (clazz.equals(boolean.class)) result = Boolean.class;
1:264011e:     else if (clazz.equals(byte.class)) result = Byte.class;
1:264011e:     else if (clazz.equals(short.class)) result = Short.class;
1:264011e:     else if (clazz.equals(char.class)) result = Character.class;
1:264011e:     else if (clazz.equals(int.class)) result = Integer.class;
1:264011e:     else if (clazz.equals(long.class)) result = Long.class;
1:264011e:     else if (clazz.equals(float.class)) result = Float.class;
1:264011e:     else if (clazz.equals(double.class)) result = Double.class;
1:264011e:     else if (clazz.equals(Boolean.class)) result = boolean.class;
1:264011e:     else if (clazz.equals(Byte.class)) result = byte.class;
1:264011e:     else if (clazz.equals(Short.class)) result = short.class;
1:264011e:     else if (clazz.equals(Character.class)) result = char.class;
1:264011e:     else if (clazz.equals(Integer.class)) result = int.class;
1:264011e:     else if (clazz.equals(Long.class)) result = long.class;
1:264011e:     else if (clazz.equals(Float.class)) result = float.class;
1:264011e:     else if (clazz.equals(Double.class)) result = double.class;
1:264011e:     
1:264011e:     return result;
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* checkClasses method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns true if the two classes are the same or if one is 
1:264011e:    * primitive that the other is a primitive wrapper.
1:264011e:    * 
1:264011e:    * @param type1
1:264011e:    * @param type2
1:264011e:    * @return true if the classes are compatible.
1:264011e:    */
1:264011e:   private boolean checkClasses(Class<?> type1, Class<?> type2)
1:264011e:   {
1:264011e:     boolean result = false;
1:264011e:     
1:264011e:     if ((type1.isPrimitive() && type2.isPrimitive()) ||
1:264011e:         (!type1.isPrimitive() && !type2.isPrimitive()))
1:264011e:     {
1:264011e:       result = type1.equals(type2);
1:264011e:     }
1:264011e:     else
1:264011e:     {
1:264011e:       result =  (type1.equals(boolean.class)  && type2.equals(Boolean.class))   ||
1:264011e:                 (type1.equals(byte.class)     && type2.equals(Byte.class))      ||
1:264011e:                 (type1.equals(short.class)    && type2.equals(Short.class))     ||
1:264011e:                 (type1.equals(char.class)     && type2.equals(Character.class)) ||
1:264011e:                 (type1.equals(int.class)      && type2.equals(Integer.class))   ||
1:264011e:                 (type1.equals(long.class)     && type2.equals(Long.class))      ||
1:264011e:                 (type1.equals(float.class)    && type2.equals(Float.class))     ||
1:264011e:                 (type1.equals(double.class)   && type2.equals(Double.class))    ||
1:264011e:                 (type2.equals(boolean.class)  && type1.equals(Boolean.class))   ||
1:264011e:                 (type2.equals(byte.class)     && type1.equals(Byte.class))      ||
1:264011e:                 (type2.equals(short.class)    && type1.equals(Short.class))     ||
1:264011e:                 (type2.equals(char.class)     && type1.equals(Character.class)) ||
1:264011e:                 (type2.equals(int.class)      && type1.equals(Integer.class))   ||
1:264011e:                 (type2.equals(long.class)     && type1.equals(Long.class))      ||
1:264011e:                 (type2.equals(float.class)    && type1.equals(Float.class))     ||
1:264011e:                 (type2.equals(double.class)   && type1.equals(Double.class));
1:264011e:     }
1:264011e:     
1:264011e:     return result;
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getMethodCallsAsString method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method builds a String that contains the method calls that have been
1:264011e:    * made on this skeleton. It puts each call on a separate line.
1:264011e:    * 
1:264011e:    * @return the string representation of the method call.
1:264011e:    */
1:264011e:   private String getMethodCallsAsString()
1:264011e:   {
1:264011e:     StringBuilder builder = new StringBuilder();
1:264011e:     
1:264011e:     for (MethodCall call : _methodCalls)
1:264011e:     {
1:264011e:       builder.append(call);
1:264011e:       builder.append("\r\n");
1:264011e:     }
1:264011e:     
1:264011e:     return builder.toString();
1:264011e:   }
1:264011e:   
1:264011e: }
============================================================================
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:53ad9ea
/////////////////////////////////////////////////////////////////////////
1:     throw new IllegalArgumentException("The supplied proxy (" + mock + ") was not an Aries dynamic mock ");
/////////////////////////////////////////////////////////////////////////
1:                         " occurred in the skeleton " + 
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:264011e
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.unittest.mocks;
1: 
1: import java.lang.ref.SoftReference;
1: import java.lang.reflect.Field;
1: import java.lang.reflect.InvocationHandler;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Proxy;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
1: 
1: import junit.framework.Assert;
1: import junit.framework.AssertionFailedError;
1: 
1: import org.apache.aries.unittest.mocks.annotations.InjectSkeleton;
1: import org.apache.aries.unittest.mocks.annotations.Singleton;
1: 
1: /**
1:  * <p>The Skeleton class is an implementation of the 
1:  *   <code>java.lang.reflect.InvocationHandler</code> that can be used for
1:  *   dynamic mock objects.
1:  * </p>
1:  * 
1:  * <ol>
1:  *   <li>The static newMock methods can be used to create completely new mock 
1:  *     objects backed by an entirely new skeleton.
1:  *   </li>
1:  *   <li>The static getSkeleton method can be used to obtain the skeleton 
1:  *     backing a given mock.
1:  *   </li>
1:  *   <li>The createMock methods can be used to create a new mock object based on
1:  *     the skeleton that is invoked.
1:  *   </li>
1:  *   <li>The registerMethodCallHandler method can be used to register a handler
1:  *     that will be invoked when a method is called.
1:  *   </li>
1:  *   <li>The registerReturnTypeHandler method can be used to register a handler
1:  *     that will be invoked when a method with a specific return type is 
1:  *     invoked. It should be noted that registered ReturnTypeHandlers will be
1:  *     invoked only if a method call handler has not been registered for the
1:  *     method that was invoked.
1:  *   </li>
1:  *   <li>The setReturnValue method can be used to set a value that will be
1:  *     returned when a method is invoked.
1:  *   </li>
1:  *   <li>The checkCalls methods can be used to determine if the methods in the
1:  *     list should have been called. They return a boolean to indicate if the
1:  *     expected calls occurred.
1:  *   </li>
1:  *   <li>The assertCalls method performs the same operation as the checkCalls, 
1:  *     but throws an junit.framework.AssertionFailedError if the calls don't
1:  *     match. This intended for use within the junit test framework
1:  *   </li> 
1:  *   <li>If no method call or return type handlers have been registered for a
1:  *     call then if the return type is an interface then a mock that implements
1:  *     that interface will be returned, otherwise null will be returned.
1:  *   </li>
1:  * </ol>
1:  */
1: public final class Skeleton implements InvocationHandler
1: {
1:   /** A list of calls made on this skeleton */
1:   private List<MethodCall> _methodCalls;
1:   /** The invocation handler to call after MethodCall and ReturnType handlers */
1:   private DefaultInvocationHandler default_Handler;
1:   /** The method call handlers */
1:   private Map<MethodCall, MethodCallHandler> _callHandlers;
1:   /** The type handlers */
1:   private Map<Class<?>, ReturnTypeHandler> _typeHandlers;
1:   /** The parameter map */
1:   private Map<String, Object> _mockParameters;
1:   /** A Map of mock objects to Maps of properties */
1:   private Map<Object, Map<String, Object>> _objectProperties;
1:   /** A Map of exception notification listeners */
1:   private Map<Class<?>, List<ExceptionListener>> _notificationListeners;
1:   /** The template class used to create this Skeleton, may be null */
1:   private Object _template;
1:   /** Cached template objects */
1:   private static ConcurrentMap<Object, SoftReference<Object>> _singletonMocks = new ConcurrentHashMap<Object, SoftReference<Object>>();
1: 
1:   // Constructors
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* Skeleton constructor                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * constructs the skeleton with the default method call handlers and the
1:    * default return type handlers.
1:    */
1:   private Skeleton()
1:   {
1:     reset();
1:   }
1:   
1:   // Static methods create methods
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* newMock method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns a completely new mock object backed by a new skeleton
1:    * object. It is equivalent to 
1:    * <code>new Skeleton().createMock(interfaceClazzes)</code>
1:    * 
1:    * @param interfaceClazzes the classes the mock should implement
1:    * @return the new mock object.
1:    */
1:   public final static Object newMock(Class<?> ... interfaceClazzes)
1:   {
1:     return new Skeleton().createMock(interfaceClazzes);
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* newMock method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns a completely new mock object backed by a new skeleton
1:    * object. It is equivalent to 
1:    * <code>new Skeleton().createMock(interfaceClazzes)</code>
1:    * 
1:    * @param <T>            The object type.
1:    * @param interfaceClazz the classes the mock should implement
1:    * @return the new mock object.
1:    */
1:   public final static <T> T newMock(Class<T> interfaceClazz)
1:   {
1:     return interfaceClazz.cast(new Skeleton().createMock(interfaceClazz));
1:   }
1:   
1:   /**
1:    * It is often the case that only a subset of methods on an interface are needed, but
1:    * those methods that are needed are quite complex. In this case a static mock forces
1:    * you into implementing lots of methods you do not need, and produces problems when
1:    * new methods are added to the interface being implemented. This method can essentially
1:    * be used to complete the interface implementation. The object passed in is an instance
1:    * of a class that implements a subset of the methods on the supplied interface. It does
1:    * not need to implement the interface itself. The returned object will implement the full
1:    * interface and delegate to the methods on the templateObject where necessary.
1:    * 
1:    * @param <T>            The object type.
1:    * @param template       The template object for the mock
1:    * @param interfaceClazz The interface to implement
1:    * @return An implementation of the interface that delegates (where appropraite) onto the template.  
1:    */
1:   public final static <T> T newMock(final Object template, Class<T> interfaceClazz)
1:   {
1:     Class<?> templateClass = template.getClass();
1:     
1:     if (templateClass.getAnnotation(Singleton.class) != null) {
1:       SoftReference<Object> mock = _singletonMocks.get(template);
1:       if (mock != null) {
1:         Object theMock = mock.get();
1:         if (theMock == null) {
1:           _singletonMocks.remove(template);
1:         } else if (interfaceClazz.isInstance(theMock)) {
1:           return interfaceClazz.cast(theMock);
1:         } 
1:       }
1:     }
1:     
1:     Skeleton s = new Skeleton();
1:     s._template = template;
1:     
1:     for (Method m : interfaceClazz.getMethods()) {
1:       try {
1:         final Method m2 = templateClass.getMethod(m.getName(), m.getParameterTypes());
1:         
1:         MethodCall mc = new MethodCall(interfaceClazz, m.getName(), (Object[])m.getParameterTypes());
1:         s.registerMethodCallHandler(mc, new MethodCallHandler()
1:         {
1:           public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
1:           {
1:             
1:             try {
1:               m2.setAccessible(true);
1:               return m2.invoke(template, methodCall.getArguments());
1:             } catch (InvocationTargetException ite) {
1:               if(ite.getTargetException() instanceof Exception)
1:                 throw (Exception)ite.getTargetException();
1:               else throw new Exception(ite.getTargetException());
1:             }
1:           }
1:         });
1:       } catch (NoSuchMethodException e) {
1:         // do nothing here, it is a method not on the interface so ignore it.
1:       }
1:     }
1:     
1:     Field[] fs = template.getClass().getFields();
1:     
1:     for (Field f : fs) {
1:       InjectSkeleton sk = f.getAnnotation(InjectSkeleton.class);
1:       
1:       if (sk != null) {
1:         f.setAccessible(true);
1:         try {
1:           f.set(template, s);
1:         } catch (IllegalArgumentException e) {
1:           e.printStackTrace();
1:         } catch (IllegalAccessException e) {
1:           e.printStackTrace();
1:         }
1:       }
1:     }
1:       
1:     Object o = s.createMock(interfaceClazz);
1:     _singletonMocks.put(template, new SoftReference<Object>(o) {
1:       @Override
1:       public boolean enqueue()
1:       {
1:         _singletonMocks.remove(template);
1:         
1:         System.out.println("Done cleanup");
1:         
1:         return super.enqueue();
1:       }
1:     });
1:     return interfaceClazz.cast(o);
1:   }
1:   
1:   // static mock query methods
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* getSkeleton method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns the Skeleton backing the supplied mock object. If the
1:    * supplied object is not a mock an IllegalArgumentException will be thrown.
1:    * 
1:    * @param mock the mock object
1:    * @return the skeleton backing the mock object
1:    * @throws IllegalArgumentException thrown if the object is not a mock.
1:    */
1:   public final static Skeleton getSkeleton(Object mock) 
1:     throws IllegalArgumentException
1:   {
1:     InvocationHandler ih = Proxy.getInvocationHandler(mock);
1:     if (ih instanceof Skeleton)
1:     {
1:       return (Skeleton)ih;
1:     }
0:     throw new IllegalArgumentException("The supplied proxy (" + mock + ") was not a (Jetstream mediations) dynamic mock ");
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* isSkeleton method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns true if and only the provided object is backed by a
1:    * Skeleton. Another way to think about this is if it returns true then a 
1:    * call to getSkeleton will not result in an IllegalArgumentException, and is
1:    * guaranteed to return a Skeleton.
1:    * 
1:    * @param mock the mock to test.
1:    * @return     true if it is backed by a skeleton.
1:    */
1:   public final static boolean isSkeleton(Object mock)
1:   {
1:     if (Proxy.isProxyClass(mock.getClass())) {
1:       InvocationHandler ih = Proxy.getInvocationHandler(mock);
1:       
1:       return (ih instanceof Skeleton);
1:     }
1:     
1:     return false;
1:   }
1: 
1:   // InvocationHandler defined methods.
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* invoke method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /** 
1:    * This method is invoked by the mock objects. It constructs a MethodCall
1:    * object representing the call and adds it to the list of calls that were
1:    * made. (It should be noted that if the method is toString, hashCode or
1:    * equals then they are not added to the list.) It then calls a registered
1:    * MethodCallHandler, if a MethodCallHandler is not registered then a 
1:    * ReturnTypeHandler is invoked. If a ReturnTypeHandler is not invoked then
1:    * the registered default InvocationHandler is called. By default the Skeleton
1:    * is constructed with a DefaultInvocationHandler. If the invoked method has
1:    * an interface as a return type then the DefaultInvocationHandler will return
1:    * a new mock implementing that interface. If the return type is a class null
1:    * will be returned.
1:    * 
1:    * @param targetObject The mock object that was invoked.
1:    * @param calledMethod The method that was called.
1:    * @param arguments    The arguments that were passed.
1:    * @return             The return of the method invoked.
1:    * @throws Throwable   Any exception thrown.
1:    */
1:   public Object invoke(Object targetObject, Method calledMethod, Object[] arguments)
1:       throws Throwable
1:   {
1:     String methodName = calledMethod.getName();
1:     MethodCall call = new MethodCall(targetObject, methodName, arguments);
1: 
1:     if (!DefaultMethodCallHandlers.isDefaultMethodCall(call))
1:     {
1:       _methodCalls.add(call);
1:     }
1: 
1:     Object result;
1:     
1:     try
1:     {
1:       if (_callHandlers.containsKey(call))
1:       {
1:         MethodCallHandler handler =  _callHandlers.get(call);
1:         result = handler.handle(call, this);
1:       }
1:       else if (isReadWriteProperty(targetObject.getClass(), calledMethod))
1:       {
1:         String propertyName = methodName.substring(3);
1:         if (methodName.startsWith("get") || methodName.startsWith("is"))
1:         {
1:           if (methodName.startsWith("is")) propertyName = methodName.substring(2);
1:           
1:           Map<String, Object> properties = _objectProperties.get(targetObject);
1:           if (properties == null)
1:           {
1:             properties = new HashMap<String, Object>();
1:             _objectProperties.put(targetObject, properties);
1:           }
1:           
1:           if (properties.containsKey(propertyName))
1:           {
1:             result = properties.get(propertyName);
1:           }
1:           else if (_typeHandlers.containsKey(calledMethod.getReturnType()))
1:           {
1:             result = createReturnTypeProxy(calledMethod.getReturnType());
1:           }
1:           else
1:           {
1:             result = default_Handler.invoke(targetObject, calledMethod, arguments);
1:           }          
1:         }
1:         // Must be a setter.
1:         else
1:         {
1:           Map<String, Object> properties = _objectProperties.get(targetObject);
1:           if (properties == null)
1:           {
1:             properties = new HashMap<String, Object>();
1:             _objectProperties.put(targetObject, properties);
1:           }
1:           
1:           properties.put(propertyName, arguments[0]);
1:           result = null;
1:         }
1:       }
1:       else if (_typeHandlers.containsKey(calledMethod.getReturnType()))
1:       {
1:         result = createReturnTypeProxy(calledMethod.getReturnType());
1:       }
1:       else
1:       {
1:         result = default_Handler.invoke(targetObject, calledMethod, arguments);
1:       }
1:     }
1:     catch (Throwable t)
1:     {
1:       Class<?> throwableType = t.getClass();
1:       List<ExceptionListener> listeners = _notificationListeners.get(throwableType);
1:       if (listeners != null)
1:       {
1:         for (ExceptionListener listener : listeners)
1:         {
1:           listener.exceptionNotification(t);
1:         }
1:       }
1:       
1:       throw t;
1:     }
1:     
1:     return result;
1:   }
1: 
1:   // MethodCall registration methods
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* registerMethodCallHandler method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method registers a MethodCallHandler for the specified MethodCall.
1:    * 
1:    * @param call    The method that was called.
1:    * @param handler The MethodCallHandler.
1:    */
1:   public void registerMethodCallHandler(MethodCall call, MethodCallHandler handler)
1:   {
1:     deRegisterMethodCallHandler(call);
1:     _callHandlers.put(call, handler);
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* deRegisterMethodCallHandler method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method removes a registered MethodCallHandler for the specified 
1:    * MethodCall.
1:    * 
1:    * @param call the specified MethodCall
1:    */
1:   public void deRegisterMethodCallHandler(MethodCall call)
1:   {
1:     _callHandlers.remove(call);
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* reset method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method resets the skeleton to the state it was in prior just after it
1:    * was constructed. 
1:    */
1:   public void reset()
1:   {
1:     _methodCalls = new LinkedList<MethodCall>();
1:     _callHandlers = new HashMap<MethodCall, MethodCallHandler>();
1:     _typeHandlers = new HashMap<Class<?>, ReturnTypeHandler>();
1:     DefaultReturnTypeHandlers.registerDefaultHandlers(this);
1:     DefaultMethodCallHandlers.registerDefaultHandlers(this);
1:     default_Handler = new DefaultInvocationHandler(this);
1:     _mockParameters = new HashMap<String, Object>();
1:     _objectProperties = new HashMap<Object, Map<String, Object>>();
1:     _notificationListeners = new HashMap<Class<?>, List<ExceptionListener>>();
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* clearMethodCalls method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method clears the method calls list for the skeleton
1:    */
1:   public void clearMethodCalls()
1:   {
1:     _methodCalls = new LinkedList<MethodCall>();
1:   }
1:   
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* setReturnValue method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This is a convenience method for registering a method call handler where
1:    * a specific value should be returned when a method is called, rather than 
1:    * some logic needs to be applied. The value should be an object or the object
1:    * version of the primitive for the methods return type, so if the method
1:    * returns short the value must be an instance of java.lang.Short, not 
1:    * java.lang.Integer.   
1:    * 
1:    * @param call  the method being called.
1:    * @param value the value to be returned when that method is called.
1:    */
1:   public void setReturnValue(MethodCall call, final Object value)
1:   {
1:     Class<?> clazz;
1:     try {
1:       clazz = Class.forName(call.getClassName());
1:     } catch (ClassNotFoundException e) {
1:       throw new IllegalStateException("This should be impossible as we have already seen this class loaded");
1:     }
1:     
1:     
1:       Method[] methods = clazz.getMethods();
1:       
1:       methods: for (Method m : methods) {
1:         if(!!!m.getName().equals(call.getMethodName()))
1:           continue methods;
1:         
1:         Object[] args = call.getArguments();
1:         Class<?>[] parms = m.getParameterTypes();
1:         
1:         if (args.length == parms.length) {
1:           for (int i = 0; i < args.length; i++) {
1:             if (args[i] instanceof Class && args[i].equals(parms[i])) {
1:             } else if (parms[i].isInstance(args[i])) {
1:             } else {
1:               continue methods;
1:             }
1:           }
1:           
1:           Class<?> returnType = m.getReturnType();
1:           if (returnType.isPrimitive()) {
1:             if (returnType == boolean.class) returnType = Boolean.class;
1:             else if (returnType == byte.class) returnType = Byte.class;
1:             else if (returnType == short.class) returnType = Short.class;
1:             else if (returnType == char.class) returnType = Character.class;
1:             else if (returnType == int.class) returnType = Integer.class;
1:             else if (returnType == long.class) returnType = Long.class;
1:             else if (returnType == float.class) returnType = Float.class;
1:             else if (returnType == double.class) returnType = Double.class;
1:           }
1:           
1:           if (value != null && !!!returnType.isInstance(value)) {
1:             throw new IllegalArgumentException("The object cannot be returned by the requested method: " + call);
1:           } else break methods; 
1:         }
1:       }
1:     
1:     
1:     
1:     registerMethodCallHandler(call, new MethodCallHandler()
1:     {
1:       public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
1:       {
1:         return value;
1:       }
1:     });
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* setThrow method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This is a convenience method for registering a method call handler where
1:    * a specific exception should be thrown when the method is called, rather
1:    * than some logic needs to be applied.
1:    * 
1:    * @param call         the method being called
1:    * @param thingToThrow the exception to throw.
1:    */
1:   public void setThrows(MethodCall call, final Exception thingToThrow)
1:   {
1:     registerMethodCallHandler(call, new MethodCallHandler()
1:     {
1:       public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
1:       {
1:         thingToThrow.fillInStackTrace();
1:         throw thingToThrow;
1:       }
1:     });
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* setThrow method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This is a convenience method for registering a method call handler where
1:    * a specific exception should be thrown when the method is called, rather
1:    * than some logic needs to be applied.
1:    * 
1:    * @param call         the method being called
1:    * @param thingToThrow the exception to throw.
1:    */
1:   public void setThrows(MethodCall call, final Error thingToThrow)
1:   {
1:     registerMethodCallHandler(call, new MethodCallHandler()
1:     {
1:       public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
1:       {
1:         thingToThrow.fillInStackTrace();
1:         throw thingToThrow;
1:       }
1:     });
1:   }
1: 
1:   // ReturnType registration methods
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* registerReturnTypeHandler method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method registers a ReturnTypeHandler for the specified class.
1:    * 
1:    * @param clazz   The class to be handled.
1:    * @param handler The ReturnTypeHandler
1:    */
1:   public void registerReturnTypeHandler(Class<?> clazz, ReturnTypeHandler handler)
1:   {
1:     deRegisterReturnTypeHandler(clazz);
1:     _typeHandlers.put(clazz, handler);
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* deRegisterReturnTypeHandler method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method removes a registration for a ReturnTypeHandler for the 
1:    * specified class.
1:    * 
1:    * @param clazz The class to deregister the handler for.
1:    */
1:   public void deRegisterReturnTypeHandler(Class<?> clazz)
1:   {
1:     _typeHandlers.remove(clazz);
1:   }
1:   
1:   // Exception notification methods
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* registerExceptionListener method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method registers an ExceptionListener when the specified Exception is
1:    * thrown.
1:    * 
1:    * @param throwableType The type of the Throwable
1:    * @param listener      The listener.
1:    */
1:   public void registerExceptionListener(Class<?> throwableType, ExceptionListener listener)
1:   {
1:     List<ExceptionListener> l = _notificationListeners.get(throwableType);
1:     if (l == null)
1:     {
1:       l = new ArrayList<ExceptionListener>();
1:       _notificationListeners.put(throwableType, l);
1:     }
1:     l.add(listener);
1:   }
1:   
1:   // parameter related methods
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* setParameter method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method allows a parameter to be set. It is intended to be used by
1:    * MethodCallHandlers and ReturnTypeHandlers.
1:    * 
1:    * @param key   The key
1:    * @param value The value
1:    */
1:   public void setParameter(String key, Object value)
1:   {
1:     _mockParameters.put(key, value);
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* getParameter method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method allows a parameter to be retrieved.
1:    * 
1:    * @param key the key the parameter was set using
1:    * @return the parameter
1:    */
1:   public Object getParameter(String key)
1:   {
1:     return _mockParameters.get(key);
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* getTemplateObject method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * @return the template object, if one was used when initializing this skeleton.
1:    */
1:   public Object getTemplateObject()
1:   {
1:     return _template;
1:   }
1:   
1:   // default InvocationHandler related methods
1:   
1:   /**
1:    * @param defaultHandler The defaultHandler to set.
1:    */
1:   public void setDefaultHandler(DefaultInvocationHandler defaultHandler)
1:   {
1:     this.default_Handler = defaultHandler;
1:   }
1:   
1:   // MethodCall list check methods
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* checkCalls method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method checks that the calls in the list occurred. If the addCalls
1:    * boolean is true then their must be an exact match. If the allCalls boolean
1:    * is false then the calls in the list must occur in that order, but other 
1:    * calls can be in between. 
1:    * 
1:    * @param calls    The expected calls list
1:    * @param allCalls true if an exact match comparison should be performed
1:    * @return         true if they the expected calls match.
1:    */
1:   public boolean checkCalls(List<MethodCall> calls, boolean allCalls)
1:   {
1:     boolean found = false;
1:     if (allCalls)
1:     {
1:       return calls.equals(_methodCalls);
1:     }
1:     else
1:     {
1:       Iterator<MethodCall> actual = _methodCalls.iterator();
1:       for (MethodCall expectedCall : calls)
1:       {
1:         found = false;
1:         actual: while (actual.hasNext())
1:         {
1:           MethodCall actualCall = actual.next();
1:           if (actualCall.equals(expectedCall))
1:           {
1:             found = true;
1:             break actual;
1:           }
1:         }
1:       }
1:     }
1:     
1:     return found;
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* checkCall method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * Checks that the specified method has been called on this skeleton
1:    * 
1:    * @param call the call that should have been called.
1:    * @return     true if the MethodCall occurs in the list.
1:    */
1:   public boolean checkCall(MethodCall call)
1:   {
1:     return this._methodCalls.contains(call);
1:   }
1:   
1:   // MethodCall list assert methods
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* assertCalls method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method checks that the MethodCalls objects in the given list were
1:    * made and throws an AssertionFailedError if they were not. If allCalls is
1:    * true the given list and the calls list must be identical. If allCalls is
1:    * false other calls could have been made on the skeleton in between ones
1:    * specified in the list.
1:    * 
1:    * @param calls the list of calls
1:    * @param allCalls whether an exact match between the lists is required
1:    * @throws AssertionFailedError if a failure has occurred.
1:    */
1:   public void assertCalled(List<MethodCall> calls, boolean allCalls) throws AssertionFailedError
1:   {
1:     if (allCalls)
1:     {
1:       if ((calls == null) && (_methodCalls == null)) return;
1: 
1:       if (calls == null)
1:       {
1:         throw new AssertionFailedError("expected null, but was " + _methodCalls);
1:       }
1: 
1:       if (_methodCalls == null)
1:       {
1:         throw new AssertionFailedError("expected:" + calls + " but was null");
1:       }
1: 
1:       if (calls.equals(_methodCalls)) return;
1: 
1:       // OK compare lists and decide on differences - initially all the lists are different
1:       int startOfDifferences = 0;
1:       // Remove the common start of sequence
1:       boolean lastItemSame = true;
1: 
1:       for (int i = 0; i < calls.size() && i < _methodCalls.size() && lastItemSame; i++)
1:       {
1:         if ((calls.get(i) == null) && (_methodCalls.get(i) == null))
1:         {
1:           lastItemSame = true;
1:         } 
1:         else if ((calls.get(i) == null) || (_methodCalls.get(i) == null))
1:         {
1:           lastItemSame = false;
1:         } 
1:         else
1:         {
1:           lastItemSame = calls.get(i).equals(_methodCalls.get(i));
1:         }
1: 
1:         if (lastItemSame) startOfDifferences++;
1: 
1:       }//for
1:       // Now remove the common bit at the end
1:       int endOfDifferencesInExpected = calls.size();
1:       int endOfDifferencesInReceived = _methodCalls.size();
1:       lastItemSame = true;
1: 
1:       while ((endOfDifferencesInExpected > startOfDifferences)
1:         && (endOfDifferencesInReceived > startOfDifferences)
1:         && lastItemSame)
1:       {
1:         int ap = endOfDifferencesInExpected - 1;
1:         int bp = endOfDifferencesInReceived - 1;
1: 
1:         if ((calls.get(ap) == null) && (_methodCalls.get(bp) == null))
1:         {
1:           lastItemSame = true;
1:         } 
1:         else if ((calls.get(ap) == null) || (_methodCalls.get(bp) == null))
1:         {
1:           lastItemSame = false;
1:         } 
1:         else
1:         {
1:           lastItemSame = calls.get(ap).equals(_methodCalls.get(bp));
1:         }
1: 
1:         if (lastItemSame)
1:         {
1:           endOfDifferencesInExpected--;
1:           endOfDifferencesInReceived--;
1:         }
1: 
1:       }//while
1: 
1:       String failureText;
1:       // OK, now build the failureText
1:       if (endOfDifferencesInExpected == startOfDifferences)
1:       {
1:         failureText =
1:             "Expected calls and actual calls differed because "
1:             + _methodCalls.subList(startOfDifferences, endOfDifferencesInReceived)
1:             + " inserted after element "
1:             + startOfDifferences;
1: 
1:       } 
1:       else if (endOfDifferencesInReceived == startOfDifferences)
1:       {
1:         failureText =
1:             "Expected calls and actual calls differed  because "
1:             + calls.subList(startOfDifferences, endOfDifferencesInExpected)
1:             + " missing after element "
1:             + startOfDifferences;
1: 
1:       } 
1:       else
1:       {
1:         if ((endOfDifferencesInExpected == startOfDifferences + 1)
1:           && (endOfDifferencesInReceived == startOfDifferences + 1))
1:         {
1: 
1:           failureText =
1:               "Expected calls and actual calls differed  because element "
1:               + startOfDifferences
1:               + " is different (calls:"
1:               + calls.get(startOfDifferences)
1:               + " but was:"+_methodCalls.get(startOfDifferences)+") ";
1: 
1:         } 
1:         else if (endOfDifferencesInExpected == startOfDifferences + 1)
1:         {
1: 
1:             failureText =
1:                 "Expected calls and actual calls differed  because element "
1:                 + startOfDifferences
1:                 + " ("
1:                 + calls.get(startOfDifferences)
1:                 + ") has been replaced by "
1:                 + _methodCalls.subList(startOfDifferences, endOfDifferencesInReceived);
1:         } 
1:         else
1:         {
1:           failureText =
1:                 "Expected calls and actual calls differed  because elements between "
1:                 + startOfDifferences
1:                 + " and "
1:                 + (endOfDifferencesInExpected - 1)
1:                 + " are different (expected:"
1:                 + calls.subList(startOfDifferences, endOfDifferencesInExpected)
1:                 + " but was:"
1:                 + _methodCalls.subList(startOfDifferences, endOfDifferencesInReceived)
1:                 + ")";
1:         }//if
1:       }//if
1: 
1:       throw new AssertionFailedError(failureText + " expected:" + calls + " but was:" + _methodCalls);
1:     }
1:     else
1:     {
1:       Iterator<MethodCall> expected = calls.iterator();
1:       Iterator<MethodCall> actual = _methodCalls.iterator();
1:       while (expected.hasNext())
1:       {
1:         boolean found = false;
1:         MethodCall expectedCall = expected.next();
1:         MethodCall actualCall = null;
1:         
1:         actual: while (actual.hasNext())
1:         {
1:           actualCall = actual.next();
1:           if (actualCall.equals(expectedCall))
1:           {
1:             found = true;
1:             break actual;
1:           }
1:         }
1:         
1:         if (!found)
1:         {
1:           throw new AssertionFailedError( "The method call " + 
1:                                           expectedCall + 
1:                                           " was expected but has not occurred (actual calls = "+_methodCalls+")");
1:         }
1:       }
1:     }
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* assertCall method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This does the same as checkCall, but throws an 
1:    * junit.framework.AssertionFailedError if the call did not occur.
1:    * 
1:    * @param call the call that was expected
1:    */
1:   public void assertCalled(MethodCall call)
1:   {
1:     if (!checkCall(call))
1:     {
1:       throw new AssertionFailedError("The method call " + 
1:                                       call + 
1:                                       " was expected but has not occurred. Actual calls: " + getMethodCallsAsString());
1:     }
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* assertCalledExactNumberOfTimes method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method asserts that the method specified in the call parameter has 
1:    * been called the number of times specified by numberOfCalls. If 
1:    * numberOfCalls is zero this method is equivalent to assertNotCalled.
1:    * 
1:    * @param call          The call that was made.
1:    * @param numberOfCalls The number of times the call should have been made.
1:    */
1:   public void assertCalledExactNumberOfTimes(MethodCall call, int numberOfCalls)
1:   {
1:     int callCount = 0;
1:     
1:     for (MethodCall callMade : _methodCalls)
1:     {
1:       if (callMade.equals(call))
1:       {
1:         callCount++;
1:       }
1:     }
1:     
1:     if (numberOfCalls != callCount)
1:     {
1:       throw new AssertionFailedError("The method call " + call + 
1:           " should have been called " + numberOfCalls + 
1:           " time(s), but was called " + callCount + " time(s)");
1:     }
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* assertNotCalled method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method throws an junit.framework.AssertionFailedError if the specified
1:    * call was invoked on the skeleton. 
1:    * 
1:    * @param call the call to check.
1:    */
1:   public void assertNotCalled(MethodCall call)
1:   {
1:     Assert.assertFalse( "The method call " + 
1:                         call + 
0:                         "occurred in the skeleton " + 
1:                         this.toString(), checkCall(call));
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* assertMockNotCalled method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method throws an junit.framework.AssertionFailedError if the skeleton
1:    * has had any methods invoked on it. 
1:    */
1:   public void assertSkeletonNotCalled()
1:   {
1:     Assert.assertEquals("The skeleton " + this.toString() + 
1:         " has had the following method invoked on it " + getMethodCallsAsString(), 
1:         0, _methodCalls.size());
1:   }
1: 
1:   // Instance mock creation methods
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* createMock method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * Creates a new Mock using this skeleton backing it.
1:    * 
1:    * @param interfaceClasses an array of interface the mock should implement.
1:    * @return the mock
1:    */
1:   public Object createMock(Class<?> ... interfaceClasses)
1:   {
1:     ClassLoader cl;
1:     
1:     if (interfaceClasses.length > 0) cl = interfaceClasses[0].getClassLoader();
1:     else cl = Thread.currentThread().getContextClassLoader();
1:     
1:     return Proxy.newProxyInstance(cl, interfaceClasses, this);
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* createMock method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * Creates a new Mock using this skeleton backing it.
1:    * 
1:    * @param <T> The object type
1:    * @param interfaceClass an array of interface the mock should implement.
1:    * @return the mock
1:    */
1:   public <T> T createMock(Class<T> interfaceClass)
1:   {
1:     return interfaceClass.cast(Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class[] {interfaceClass}, this));
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* invokeReturnTypeHandlers method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method invokes the return type proxy for the specified class. If a
1:    * ReturnTypeHandler for that type has not been registered then if the class
1:    * represents an interface a new mock will be returned, backed by this 
1:    * skeleton, otherwise null will be returned.
1:    * 
1:    * @param type       the type to be invoked.
1:    * @return           the returned object.
1:    * @throws Exception if an error occurs when invoking the return type handler.
1:    */
1:   public Object invokeReturnTypeHandlers(Class<?> type) throws Exception
1:   {
1:     if (_typeHandlers.containsKey(type))
1:     {
1:       ReturnTypeHandler rth =  _typeHandlers.get(type);
1:       return rth.handle(type, this);
1:     }
1:     else if (type.isInterface())
1:     {
1:       return createMock(type);
1:     }
1:     else
1:     {
1:       return null;
1:     }
1:   }
1: 
1:   // Miscellaneous methods that have been deprecated and will be removed.
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* createReturnTypeProxy method
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * create a proxy for given return type. 
1:    *
1:    * @deprecated use invokeReturnTypeHandlers instead
1:    *  
1:    * @param type               The return type for which a handler is required
1:    * @return ReturnTypeHandler The return type handler
1:    * @throws Exception         Thrown if an exception occurs.
1:    */
1:   /* ------------------------------------------------------------------------ */
1:   @Deprecated
1:   private final Object createReturnTypeProxy(Class<?> type) throws Exception
1:   {
1:     return invokeReturnTypeHandlers(type);
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* isReadWriteProperty method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns true if the method passed a getter for a read write
1:    * java bean property. This is worked out by checking that a setter and getter
1:    * exist for the property and that the setter and getter take and return 
1:    * exactly the same time.
1:    * 
1:    * @param objClass The object the read write method has been invoked on.
1:    * @param method   The method to be checked.
1:    * @return         true if it is a getter or setter for a read write property.
1:    */
1:   private boolean isReadWriteProperty(Class<?> objClass, Method method)
1:   {
1:     String methodName = method.getName();
1:     String propertyName = methodName.substring(3);
1:     Class<?>[] parameters = method.getParameterTypes();
1:     Class<?> clazz;
1:     boolean result = false;
1:     
1:     if (methodName.startsWith("get") && parameters.length == 0)
1:     {
1:       clazz = method.getReturnType();
1:       try
1:       {
1:         objClass.getMethod("set" + propertyName, clazz);
1:         result = true;
1:       }
1:       catch (NoSuchMethodException e)
1:       {
1:         if (isPrimitive(clazz))
1:         {
1:           clazz = getOtherForm(clazz);
1:           try
1:           {
1:             objClass.getMethod("set" + propertyName, clazz);
1:             result = true;
1:           }
1:           catch (NoSuchMethodException e1)
1:           {
1:             
1:           }
1:         }
1:       }
1:     }
1:     else if (methodName.startsWith("is") && parameters.length == 0)
1:     {
1:       clazz = method.getReturnType();
1:       if (clazz.equals(Boolean.class) || clazz.equals(boolean.class))
1:       {
1:         propertyName = methodName.substring(2);
1:         try
1:         {
1:           objClass.getMethod("set" + propertyName, clazz);
1:           result = true;
1:         }
1:         catch (NoSuchMethodException e)
1:         {
1:           
1:           if (isPrimitive(clazz))
1:           {
1:             clazz = getOtherForm(clazz);
1:             try
1:             {
1:               objClass.getMethod("set" + propertyName, clazz);
1:               result = true;
1:             }
1:             catch (NoSuchMethodException e1)
1:             {
1:               
1:             }
1:           }
1:         }
1:       }
1:     }
1:     else if (methodName.startsWith("set") && parameters.length == 1)
1:     {
1:       clazz = parameters[0];
1:       
1:       try
1:       {
1:         Method getter = objClass.getMethod("get" + propertyName, new Class[0]);
1:         result = checkClasses(getter.getReturnType(), clazz);
1:       }
1:       catch (NoSuchMethodException e)
1:       {
1:         if (isPrimitive(clazz))
1:         {
1:           clazz = getOtherForm(clazz);
1:           try
1:           {
1:             Method getter = objClass.getMethod("get" + propertyName, new Class[0]);
1:             result = checkClasses(getter.getReturnType(), clazz);
1:           }
1:           catch (NoSuchMethodException e1)
1:           {
1:             if (clazz.equals(Boolean.class) || clazz.equals(boolean.class))
1:             {
1:               try
1:               {
1:                 Method getter = objClass.getMethod("is" + propertyName, new Class[0]);
1:                 result = checkClasses(getter.getReturnType(), clazz);
1:               }
1:               catch (NoSuchMethodException e2)
1:               {
1:                 clazz = getOtherForm(clazz);
1:                 try
1:                 {
1:                   Method getter = objClass.getMethod("is" + propertyName, new Class[0]);
1:                   result = checkClasses(getter.getReturnType(), clazz);
1:                 }
1:                 catch (NoSuchMethodException e3)
1:                 {
1:                 }
1:               }
1:             }
1:           }
1:         }
1:       }
1:     }
1:     
1:     return result;
1:   }
1:   
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* isPrimitive method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns true if the class object represents a primitive or the
1:    * object version of a primitive.
1:    * 
1:    * @param clazz The class to be checked.
1:    * @return      true if it is a primitive or a wrapper.
1:    */
1:   private boolean isPrimitive(Class<?> clazz)
1:   {
1:     boolean result = false;
1:     
1:     if (clazz.isPrimitive())
1:     {
1:       result = true;
1:     }
1:     else
1:     {
1:       result =  clazz.equals(Boolean.class) || clazz.equals(Byte.class) || 
1:                 clazz.equals(Short.class) || clazz.equals(Character.class) ||
1:                 clazz.equals(Integer.class) || clazz.equals(Long.class) ||
1:                 clazz.equals(Float.class) || clazz.equals(Double.class);
1:     }
1:     
1:     return result;
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* getOtherForm method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method takes a class representing either a primitive or an object 
1:    * wrapper. If the class is a primitive type the object wrapper class is 
1:    * returned. If the class is an object wrapper class the primitive type is
1:    * returned.
1:    * 
1:    * @param clazz
1:    * @return the class representing the primitive object wrapper.
1:    */
1:   private Class<?> getOtherForm(Class<?> clazz)
1:   {
1:     Class<?> result = null;
1:     
1:     if (clazz.equals(boolean.class)) result = Boolean.class;
1:     else if (clazz.equals(byte.class)) result = Byte.class;
1:     else if (clazz.equals(short.class)) result = Short.class;
1:     else if (clazz.equals(char.class)) result = Character.class;
1:     else if (clazz.equals(int.class)) result = Integer.class;
1:     else if (clazz.equals(long.class)) result = Long.class;
1:     else if (clazz.equals(float.class)) result = Float.class;
1:     else if (clazz.equals(double.class)) result = Double.class;
1:     else if (clazz.equals(Boolean.class)) result = boolean.class;
1:     else if (clazz.equals(Byte.class)) result = byte.class;
1:     else if (clazz.equals(Short.class)) result = short.class;
1:     else if (clazz.equals(Character.class)) result = char.class;
1:     else if (clazz.equals(Integer.class)) result = int.class;
1:     else if (clazz.equals(Long.class)) result = long.class;
1:     else if (clazz.equals(Float.class)) result = float.class;
1:     else if (clazz.equals(Double.class)) result = double.class;
1:     
1:     return result;
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* checkClasses method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns true if the two classes are the same or if one is 
1:    * primitive that the other is a primitive wrapper.
1:    * 
1:    * @param type1
1:    * @param type2
1:    * @return true if the classes are compatible.
1:    */
1:   private boolean checkClasses(Class<?> type1, Class<?> type2)
1:   {
1:     boolean result = false;
1:     
1:     if ((type1.isPrimitive() && type2.isPrimitive()) ||
1:         (!type1.isPrimitive() && !type2.isPrimitive()))
1:     {
1:       result = type1.equals(type2);
1:     }
1:     else
1:     {
1:       result =  (type1.equals(boolean.class)  && type2.equals(Boolean.class))   ||
1:                 (type1.equals(byte.class)     && type2.equals(Byte.class))      ||
1:                 (type1.equals(short.class)    && type2.equals(Short.class))     ||
1:                 (type1.equals(char.class)     && type2.equals(Character.class)) ||
1:                 (type1.equals(int.class)      && type2.equals(Integer.class))   ||
1:                 (type1.equals(long.class)     && type2.equals(Long.class))      ||
1:                 (type1.equals(float.class)    && type2.equals(Float.class))     ||
1:                 (type1.equals(double.class)   && type2.equals(Double.class))    ||
1:                 (type2.equals(boolean.class)  && type1.equals(Boolean.class))   ||
1:                 (type2.equals(byte.class)     && type1.equals(Byte.class))      ||
1:                 (type2.equals(short.class)    && type1.equals(Short.class))     ||
1:                 (type2.equals(char.class)     && type1.equals(Character.class)) ||
1:                 (type2.equals(int.class)      && type1.equals(Integer.class))   ||
1:                 (type2.equals(long.class)     && type1.equals(Long.class))      ||
1:                 (type2.equals(float.class)    && type1.equals(Float.class))     ||
1:                 (type2.equals(double.class)   && type1.equals(Double.class));
1:     }
1:     
1:     return result;
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* getMethodCallsAsString method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method builds a String that contains the method calls that have been
1:    * made on this skeleton. It puts each call on a separate line.
1:    * 
1:    * @return the string representation of the method call.
1:    */
1:   private String getMethodCallsAsString()
1:   {
1:     StringBuilder builder = new StringBuilder();
1:     
1:     for (MethodCall call : _methodCalls)
1:     {
1:       builder.append(call);
1:       builder.append("\r\n");
1:     }
1:     
1:     return builder.toString();
1:   }
1:   
1: }
commit:4e2fb0c
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.unittest.mocks;
0: 
0: import java.lang.ref.SoftReference;
0: import java.lang.reflect.Field;
0: import java.lang.reflect.InvocationHandler;
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Method;
0: import java.lang.reflect.Proxy;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.ConcurrentMap;
0: 
0: import junit.framework.Assert;
0: import junit.framework.AssertionFailedError;
0: 
0: import org.apache.aries.unittest.mocks.annotations.InjectSkeleton;
0: import org.apache.aries.unittest.mocks.annotations.Singleton;
0: 
0: /**
0:  * <p>The Skeleton class is an implementation of the 
0:  *   <code>java.lang.reflect.InvocationHandler</code> that can be used for
0:  *   dynamic mock objects.
0:  * </p>
0:  * 
0:  * <ol>
0:  *   <li>The static newMock methods can be used to create completely new mock 
0:  *     objects backed by an entirely new skeleton.
0:  *   </li>
0:  *   <li>The static getSkeleton method can be used to obtain the skeleton 
0:  *     backing a given mock.
0:  *   </li>
0:  *   <li>The createMock methods can be used to create a new mock object based on
0:  *     the skeleton that is invoked.
0:  *   </li>
0:  *   <li>The registerMethodCallHandler method can be used to register a handler
0:  *     that will be invoked when a method is called.
0:  *   </li>
0:  *   <li>The registerReturnTypeHandler method can be used to register a handler
0:  *     that will be invoked when a method with a specific return type is 
0:  *     invoked. It should be noted that registered ReturnTypeHandlers will be
0:  *     invoked only if a method call handler has not been registered for the
0:  *     method that was invoked.
0:  *   </li>
0:  *   <li>The setReturnValue method can be used to set a value that will be
0:  *     returned when a method is invoked.
0:  *   </li>
0:  *   <li>The checkCalls methods can be used to determine if the methods in the
0:  *     list should have been called. They return a boolean to indicate if the
0:  *     expected calls occurred.
0:  *   </li>
0:  *   <li>The assertCalls method performs the same operation as the checkCalls, 
0:  *     but throws an junit.framework.AssertionFailedError if the calls don't
0:  *     match. This intended for use within the junit test framework
0:  *   </li> 
0:  *   <li>If no method call or return type handlers have been registered for a
0:  *     call then if the return type is an interface then a mock that implements
0:  *     that interface will be returned, otherwise null will be returned.
0:  *   </li>
0:  * </ol>
0:  */
0: public final class Skeleton implements InvocationHandler
0: {
0:   /** A list of calls made on this skeleton */
0:   private List<MethodCall> _methodCalls;
0:   /** The invocation handler to call after MethodCall and ReturnType handlers */
0:   private DefaultInvocationHandler default_Handler;
0:   /** The method call handlers */
0:   private Map<MethodCall, MethodCallHandler> _callHandlers;
0:   /** The type handlers */
0:   private Map<Class<?>, ReturnTypeHandler> _typeHandlers;
0:   /** The parameter map */
0:   private Map<String, Object> _mockParameters;
0:   /** A Map of mock objects to Maps of properties */
0:   private Map<Object, Map<String, Object>> _objectProperties;
0:   /** A Map of exception notification listeners */
0:   private Map<Class<?>, List<ExceptionListener>> _notificationListeners;
0:   /** The template class used to create this Skeleton, may be null */
0:   private Object _template;
0:   /** Cached template objects */
0:   private static ConcurrentMap<Object, SoftReference<Object>> _singletonMocks = new ConcurrentHashMap<Object, SoftReference<Object>>();
0: 
0:   // Constructors
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* Skeleton constructor                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * constructs the skeleton with the default method call handlers and the
0:    * default return type handlers.
0:    */
0:   private Skeleton()
0:   {
0:     reset();
0:   }
0:   
0:   // Static methods create methods
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* newMock method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns a completely new mock object backed by a new skeleton
0:    * object. It is equivalent to 
0:    * <code>new Skeleton().createMock(interfaceClazzes)</code>
0:    * 
0:    * @param interfaceClazzes the classes the mock should implement
0:    * @return the new mock object.
0:    */
0:   public final static Object newMock(Class<?> ... interfaceClazzes)
0:   {
0:     return new Skeleton().createMock(interfaceClazzes);
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* newMock method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns a completely new mock object backed by a new skeleton
0:    * object. It is equivalent to 
0:    * <code>new Skeleton().createMock(interfaceClazzes)</code>
0:    * 
0:    * @param <T>            The object type.
0:    * @param interfaceClazz the classes the mock should implement
0:    * @return the new mock object.
0:    */
0:   public final static <T> T newMock(Class<T> interfaceClazz)
0:   {
0:     return interfaceClazz.cast(new Skeleton().createMock(interfaceClazz));
0:   }
0:   
0:   /**
0:    * It is often the case that only a subset of methods on an interface are needed, but
0:    * those methods that are needed are quite complex. In this case a static mock forces
0:    * you into implementing lots of methods you do not need, and produces problems when
0:    * new methods are added to the interface being implemented. This method can essentially
0:    * be used to complete the interface implementation. The object passed in is an instance
0:    * of a class that implements a subset of the methods on the supplied interface. It does
0:    * not need to implement the interface itself. The returned object will implement the full
0:    * interface and delegate to the methods on the templateObject where necessary.
0:    * 
0:    * @param <T>            The object type.
0:    * @param template       The template object for the mock
0:    * @param interfaceClazz The interface to implement
0:    * @return An implementation of the interface that delegates (where appropraite) onto the template.  
0:    */
0:   public final static <T> T newMock(final Object template, Class<T> interfaceClazz)
0:   {
0:     Class<?> templateClass = template.getClass();
0:     
0:     if (templateClass.getAnnotation(Singleton.class) != null) {
0:       SoftReference<Object> mock = _singletonMocks.get(template);
0:       if (mock != null) {
0:         Object theMock = mock.get();
0:         if (theMock == null) {
0:           _singletonMocks.remove(template);
0:         } else if (interfaceClazz.isInstance(theMock)) {
0:           return interfaceClazz.cast(theMock);
0:         } 
0:       }
0:     }
0:     
0:     Skeleton s = new Skeleton();
0:     s._template = template;
0:     
0:     for (Method m : interfaceClazz.getMethods()) {
0:       try {
0:         final Method m2 = templateClass.getMethod(m.getName(), m.getParameterTypes());
0:         
0:         MethodCall mc = new MethodCall(interfaceClazz, m.getName(), (Object[])m.getParameterTypes());
0:         s.registerMethodCallHandler(mc, new MethodCallHandler()
0:         {
0:           public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
0:           {
0:             
0:             try {
0:               m2.setAccessible(true);
0:               return m2.invoke(template, methodCall.getArguments());
0:             } catch (InvocationTargetException ite) {
0:               if(ite.getTargetException() instanceof Exception)
0:                 throw (Exception)ite.getTargetException();
0:               else throw new Exception(ite.getTargetException());
0:             }
0:           }
0:         });
0:       } catch (NoSuchMethodException e) {
0:         // do nothing here, it is a method not on the interface so ignore it.
0:       }
0:     }
0:     
0:     Field[] fs = template.getClass().getFields();
0:     
0:     for (Field f : fs) {
0:       InjectSkeleton sk = f.getAnnotation(InjectSkeleton.class);
0:       
0:       if (sk != null) {
0:         f.setAccessible(true);
0:         try {
0:           f.set(template, s);
0:         } catch (IllegalArgumentException e) {
0:           e.printStackTrace();
0:         } catch (IllegalAccessException e) {
0:           e.printStackTrace();
0:         }
0:       }
0:     }
0:       
0:     Object o = s.createMock(interfaceClazz);
0:     _singletonMocks.put(template, new SoftReference<Object>(o) {
0:       @Override
0:       public boolean enqueue()
0:       {
0:         _singletonMocks.remove(template);
0:         
0:         System.out.println("Done cleanup");
0:         
0:         return super.enqueue();
0:       }
0:     });
0:     return interfaceClazz.cast(o);
0:   }
0:   
0:   // static mock query methods
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* getSkeleton method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns the Skeleton backing the supplied mock object. If the
0:    * supplied object is not a mock an IllegalArgumentException will be thrown.
0:    * 
0:    * @param mock the mock object
0:    * @return the skeleton backing the mock object
0:    * @throws IllegalArgumentException thrown if the object is not a mock.
0:    */
0:   public final static Skeleton getSkeleton(Object mock) 
0:     throws IllegalArgumentException
0:   {
0:     InvocationHandler ih = Proxy.getInvocationHandler(mock);
0:     if (ih instanceof Skeleton)
0:     {
0:       return (Skeleton)ih;
0:     }
0:     throw new IllegalArgumentException("The supplied proxy (" + mock + ") was not a (Jetstream mediations) dynamic mock ");
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* isSkeleton method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns true if and only the provided object is backed by a
0:    * Skeleton. Another way to think about this is if it returns true then a 
0:    * call to getSkeleton will not result in an IllegalArgumentException, and is
0:    * guaranteed to return a Skeleton.
0:    * 
0:    * @param mock the mock to test.
0:    * @return     true if it is backed by a skeleton.
0:    */
0:   public final static boolean isSkeleton(Object mock)
0:   {
0:     if (Proxy.isProxyClass(mock.getClass())) {
0:       InvocationHandler ih = Proxy.getInvocationHandler(mock);
0:       
0:       return (ih instanceof Skeleton);
0:     }
0:     
0:     return false;
0:   }
0: 
0:   // InvocationHandler defined methods.
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* invoke method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /** 
0:    * This method is invoked by the mock objects. It constructs a MethodCall
0:    * object representing the call and adds it to the list of calls that were
0:    * made. (It should be noted that if the method is toString, hashCode or
0:    * equals then they are not added to the list.) It then calls a registered
0:    * MethodCallHandler, if a MethodCallHandler is not registered then a 
0:    * ReturnTypeHandler is invoked. If a ReturnTypeHandler is not invoked then
0:    * the registered default InvocationHandler is called. By default the Skeleton
0:    * is constructed with a DefaultInvocationHandler. If the invoked method has
0:    * an interface as a return type then the DefaultInvocationHandler will return
0:    * a new mock implementing that interface. If the return type is a class null
0:    * will be returned.
0:    * 
0:    * @param targetObject The mock object that was invoked.
0:    * @param calledMethod The method that was called.
0:    * @param arguments    The arguments that were passed.
0:    * @return             The return of the method invoked.
0:    * @throws Throwable   Any exception thrown.
0:    */
0:   public Object invoke(Object targetObject, Method calledMethod, Object[] arguments)
0:       throws Throwable
0:   {
0:     String methodName = calledMethod.getName();
0:     MethodCall call = new MethodCall(targetObject, methodName, arguments);
0: 
0:     if (!DefaultMethodCallHandlers.isDefaultMethodCall(call))
0:     {
0:       _methodCalls.add(call);
0:     }
0: 
0:     Object result;
0:     
0:     try
0:     {
0:       if (_callHandlers.containsKey(call))
0:       {
0:         MethodCallHandler handler =  _callHandlers.get(call);
0:         result = handler.handle(call, this);
0:       }
0:       else if (isReadWriteProperty(targetObject.getClass(), calledMethod))
0:       {
0:         String propertyName = methodName.substring(3);
0:         if (methodName.startsWith("get") || methodName.startsWith("is"))
0:         {
0:           if (methodName.startsWith("is")) propertyName = methodName.substring(2);
0:           
0:           Map<String, Object> properties = _objectProperties.get(targetObject);
0:           if (properties == null)
0:           {
0:             properties = new HashMap<String, Object>();
0:             _objectProperties.put(targetObject, properties);
0:           }
0:           
0:           if (properties.containsKey(propertyName))
0:           {
0:             result = properties.get(propertyName);
0:           }
0:           else if (_typeHandlers.containsKey(calledMethod.getReturnType()))
0:           {
0:             result = createReturnTypeProxy(calledMethod.getReturnType());
0:           }
0:           else
0:           {
0:             result = default_Handler.invoke(targetObject, calledMethod, arguments);
0:           }          
0:         }
0:         // Must be a setter.
0:         else
0:         {
0:           Map<String, Object> properties = _objectProperties.get(targetObject);
0:           if (properties == null)
0:           {
0:             properties = new HashMap<String, Object>();
0:             _objectProperties.put(targetObject, properties);
0:           }
0:           
0:           properties.put(propertyName, arguments[0]);
0:           result = null;
0:         }
0:       }
0:       else if (_typeHandlers.containsKey(calledMethod.getReturnType()))
0:       {
0:         result = createReturnTypeProxy(calledMethod.getReturnType());
0:       }
0:       else
0:       {
0:         result = default_Handler.invoke(targetObject, calledMethod, arguments);
0:       }
0:     }
0:     catch (Throwable t)
0:     {
0:       Class<?> throwableType = t.getClass();
0:       List<ExceptionListener> listeners = _notificationListeners.get(throwableType);
0:       if (listeners != null)
0:       {
0:         for (ExceptionListener listener : listeners)
0:         {
0:           listener.exceptionNotification(t);
0:         }
0:       }
0:       
0:       throw t;
0:     }
0:     
0:     return result;
0:   }
0: 
0:   // MethodCall registration methods
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* registerMethodCallHandler method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method registers a MethodCallHandler for the specified MethodCall.
0:    * 
0:    * @param call    The method that was called.
0:    * @param handler The MethodCallHandler.
0:    */
0:   public void registerMethodCallHandler(MethodCall call, MethodCallHandler handler)
0:   {
0:     deRegisterMethodCallHandler(call);
0:     _callHandlers.put(call, handler);
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* deRegisterMethodCallHandler method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method removes a registered MethodCallHandler for the specified 
0:    * MethodCall.
0:    * 
0:    * @param call the specified MethodCall
0:    */
0:   public void deRegisterMethodCallHandler(MethodCall call)
0:   {
0:     _callHandlers.remove(call);
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* reset method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method resets the skeleton to the state it was in prior just after it
0:    * was constructed. 
0:    */
0:   public void reset()
0:   {
0:     _methodCalls = new LinkedList<MethodCall>();
0:     _callHandlers = new HashMap<MethodCall, MethodCallHandler>();
0:     _typeHandlers = new HashMap<Class<?>, ReturnTypeHandler>();
0:     DefaultReturnTypeHandlers.registerDefaultHandlers(this);
0:     DefaultMethodCallHandlers.registerDefaultHandlers(this);
0:     default_Handler = new DefaultInvocationHandler(this);
0:     _mockParameters = new HashMap<String, Object>();
0:     _objectProperties = new HashMap<Object, Map<String, Object>>();
0:     _notificationListeners = new HashMap<Class<?>, List<ExceptionListener>>();
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* clearMethodCalls method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method clears the method calls list for the skeleton
0:    */
0:   public void clearMethodCalls()
0:   {
0:     _methodCalls = new LinkedList<MethodCall>();
0:   }
0:   
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* setReturnValue method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This is a convenience method for registering a method call handler where
0:    * a specific value should be returned when a method is called, rather than 
0:    * some logic needs to be applied. The value should be an object or the object
0:    * version of the primitive for the methods return type, so if the method
0:    * returns short the value must be an instance of java.lang.Short, not 
0:    * java.lang.Integer.   
0:    * 
0:    * @param call  the method being called.
0:    * @param value the value to be returned when that method is called.
0:    */
0:   public void setReturnValue(MethodCall call, final Object value)
0:   {
0:     Class<?> clazz;
0:     try {
0:       clazz = Class.forName(call.getClassName());
0:     } catch (ClassNotFoundException e) {
0:       throw new IllegalStateException("This should be impossible as we have already seen this class loaded");
0:     }
0:     
0:     
0:       Method[] methods = clazz.getMethods();
0:       
0:       methods: for (Method m : methods) {
0:         if(!!!m.getName().equals(call.getMethodName()))
0:           continue methods;
0:         
0:         Object[] args = call.getArguments();
0:         Class<?>[] parms = m.getParameterTypes();
0:         
0:         if (args.length == parms.length) {
0:           for (int i = 0; i < args.length; i++) {
0:             if (args[i] instanceof Class && args[i].equals(parms[i])) {
0:             } else if (parms[i].isInstance(args[i])) {
0:             } else {
0:               continue methods;
0:             }
0:           }
0:           
0:           Class<?> returnType = m.getReturnType();
0:           if (returnType.isPrimitive()) {
0:             if (returnType == boolean.class) returnType = Boolean.class;
0:             else if (returnType == byte.class) returnType = Byte.class;
0:             else if (returnType == short.class) returnType = Short.class;
0:             else if (returnType == char.class) returnType = Character.class;
0:             else if (returnType == int.class) returnType = Integer.class;
0:             else if (returnType == long.class) returnType = Long.class;
0:             else if (returnType == float.class) returnType = Float.class;
0:             else if (returnType == double.class) returnType = Double.class;
0:           }
0:           
0:           if (value != null && !!!returnType.isInstance(value)) {
0:             throw new IllegalArgumentException("The object cannot be returned by the requested method: " + call);
0:           } else break methods; 
0:         }
0:       }
0:     
0:     
0:     
0:     registerMethodCallHandler(call, new MethodCallHandler()
0:     {
0:       public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
0:       {
0:         return value;
0:       }
0:     });
0:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* setThrow method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This is a convenience method for registering a method call handler where
0:    * a specific exception should be thrown when the method is called, rather
0:    * than some logic needs to be applied.
0:    * 
0:    * @param call         the method being called
0:    * @param thingToThrow the exception to throw.
0:    */
0:   public void setThrows(MethodCall call, final Exception thingToThrow)
0:   {
0:     registerMethodCallHandler(call, new MethodCallHandler()
0:     {
0:       public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
0:       {
0:         thingToThrow.fillInStackTrace();
0:         throw thingToThrow;
0:       }
0:     });
0:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* setThrow method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This is a convenience method for registering a method call handler where
0:    * a specific exception should be thrown when the method is called, rather
0:    * than some logic needs to be applied.
0:    * 
0:    * @param call         the method being called
0:    * @param thingToThrow the exception to throw.
0:    */
0:   public void setThrows(MethodCall call, final Error thingToThrow)
0:   {
0:     registerMethodCallHandler(call, new MethodCallHandler()
0:     {
0:       public Object handle(MethodCall methodCall, Skeleton parent) throws Exception
0:       {
0:         thingToThrow.fillInStackTrace();
0:         throw thingToThrow;
0:       }
0:     });
0:   }
0: 
0:   // ReturnType registration methods
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* registerReturnTypeHandler method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method registers a ReturnTypeHandler for the specified class.
0:    * 
0:    * @param clazz   The class to be handled.
0:    * @param handler The ReturnTypeHandler
0:    */
0:   public void registerReturnTypeHandler(Class<?> clazz, ReturnTypeHandler handler)
0:   {
0:     deRegisterReturnTypeHandler(clazz);
0:     _typeHandlers.put(clazz, handler);
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* deRegisterReturnTypeHandler method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method removes a registration for a ReturnTypeHandler for the 
0:    * specified class.
0:    * 
0:    * @param clazz The class to deregister the handler for.
0:    */
0:   public void deRegisterReturnTypeHandler(Class<?> clazz)
0:   {
0:     _typeHandlers.remove(clazz);
0:   }
0:   
0:   // Exception notification methods
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* registerExceptionListener method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method registers an ExceptionListener when the specified Exception is
0:    * thrown.
0:    * 
0:    * @param throwableType The type of the Throwable
0:    * @param listener      The listener.
0:    */
0:   public void registerExceptionListener(Class<?> throwableType, ExceptionListener listener)
0:   {
0:     List<ExceptionListener> l = _notificationListeners.get(throwableType);
0:     if (l == null)
0:     {
0:       l = new ArrayList<ExceptionListener>();
0:       _notificationListeners.put(throwableType, l);
0:     }
0:     l.add(listener);
0:   }
0:   
0:   // parameter related methods
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* setParameter method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method allows a parameter to be set. It is intended to be used by
0:    * MethodCallHandlers and ReturnTypeHandlers.
0:    * 
0:    * @param key   The key
0:    * @param value The value
0:    */
0:   public void setParameter(String key, Object value)
0:   {
0:     _mockParameters.put(key, value);
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* getParameter method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method allows a parameter to be retrieved.
0:    * 
0:    * @param key the key the parameter was set using
0:    * @return the parameter
0:    */
0:   public Object getParameter(String key)
0:   {
0:     return _mockParameters.get(key);
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* getTemplateObject method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * @return the template object, if one was used when initializing this skeleton.
0:    */
0:   public Object getTemplateObject()
0:   {
0:     return _template;
0:   }
0:   
0:   // default InvocationHandler related methods
0:   
0:   /**
0:    * @param defaultHandler The defaultHandler to set.
0:    */
0:   public void setDefaultHandler(DefaultInvocationHandler defaultHandler)
0:   {
0:     this.default_Handler = defaultHandler;
0:   }
0:   
0:   // MethodCall list check methods
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* checkCalls method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method checks that the calls in the list occurred. If the addCalls
0:    * boolean is true then their must be an exact match. If the allCalls boolean
0:    * is false then the calls in the list must occur in that order, but other 
0:    * calls can be in between. 
0:    * 
0:    * @param calls    The expected calls list
0:    * @param allCalls true if an exact match comparison should be performed
0:    * @return         true if they the expected calls match.
0:    */
0:   public boolean checkCalls(List<MethodCall> calls, boolean allCalls)
0:   {
0:     boolean found = false;
0:     if (allCalls)
0:     {
0:       return calls.equals(_methodCalls);
0:     }
0:     else
0:     {
0:       Iterator<MethodCall> actual = _methodCalls.iterator();
0:       for (MethodCall expectedCall : calls)
0:       {
0:         found = false;
0:         actual: while (actual.hasNext())
0:         {
0:           MethodCall actualCall = actual.next();
0:           if (actualCall.equals(expectedCall))
0:           {
0:             found = true;
0:             break actual;
0:           }
0:         }
0:       }
0:     }
0:     
0:     return found;
0:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* checkCall method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * Checks that the specified method has been called on this skeleton
0:    * 
0:    * @param call the call that should have been called.
0:    * @return     true if the MethodCall occurs in the list.
0:    */
0:   public boolean checkCall(MethodCall call)
0:   {
0:     return this._methodCalls.contains(call);
0:   }
0:   
0:   // MethodCall list assert methods
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* assertCalls method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method checks that the MethodCalls objects in the given list were
0:    * made and throws an AssertionFailedError if they were not. If allCalls is
0:    * true the given list and the calls list must be identical. If allCalls is
0:    * false other calls could have been made on the skeleton in between ones
0:    * specified in the list.
0:    * 
0:    * @param calls the list of calls
0:    * @param allCalls whether an exact match between the lists is required
0:    * @throws AssertionFailedError if a failure has occurred.
0:    */
0:   public void assertCalled(List<MethodCall> calls, boolean allCalls) throws AssertionFailedError
0:   {
0:     if (allCalls)
0:     {
0:       if ((calls == null) && (_methodCalls == null)) return;
0: 
0:       if (calls == null)
0:       {
0:         throw new AssertionFailedError("expected null, but was " + _methodCalls);
0:       }
0: 
0:       if (_methodCalls == null)
0:       {
0:         throw new AssertionFailedError("expected:" + calls + " but was null");
0:       }
0: 
0:       if (calls.equals(_methodCalls)) return;
0: 
0:       // OK compare lists and decide on differences - initially all the lists are different
0:       int startOfDifferences = 0;
0:       // Remove the common start of sequence
0:       boolean lastItemSame = true;
0: 
0:       for (int i = 0; i < calls.size() && i < _methodCalls.size() && lastItemSame; i++)
0:       {
0:         if ((calls.get(i) == null) && (_methodCalls.get(i) == null))
0:         {
0:           lastItemSame = true;
0:         } 
0:         else if ((calls.get(i) == null) || (_methodCalls.get(i) == null))
0:         {
0:           lastItemSame = false;
0:         } 
0:         else
0:         {
0:           lastItemSame = calls.get(i).equals(_methodCalls.get(i));
0:         }
0: 
0:         if (lastItemSame) startOfDifferences++;
0: 
0:       }//for
0:       // Now remove the common bit at the end
0:       int endOfDifferencesInExpected = calls.size();
0:       int endOfDifferencesInReceived = _methodCalls.size();
0:       lastItemSame = true;
0: 
0:       while ((endOfDifferencesInExpected > startOfDifferences)
0:         && (endOfDifferencesInReceived > startOfDifferences)
0:         && lastItemSame)
0:       {
0:         int ap = endOfDifferencesInExpected - 1;
0:         int bp = endOfDifferencesInReceived - 1;
0: 
0:         if ((calls.get(ap) == null) && (_methodCalls.get(bp) == null))
0:         {
0:           lastItemSame = true;
0:         } 
0:         else if ((calls.get(ap) == null) || (_methodCalls.get(bp) == null))
0:         {
0:           lastItemSame = false;
0:         } 
0:         else
0:         {
0:           lastItemSame = calls.get(ap).equals(_methodCalls.get(bp));
0:         }
0: 
0:         if (lastItemSame)
0:         {
0:           endOfDifferencesInExpected--;
0:           endOfDifferencesInReceived--;
0:         }
0: 
0:       }//while
0: 
0:       String failureText;
0:       // OK, now build the failureText
0:       if (endOfDifferencesInExpected == startOfDifferences)
0:       {
0:         failureText =
0:             "Expected calls and actual calls differed because "
0:             + _methodCalls.subList(startOfDifferences, endOfDifferencesInReceived)
0:             + " inserted after element "
0:             + startOfDifferences;
0: 
0:       } 
0:       else if (endOfDifferencesInReceived == startOfDifferences)
0:       {
0:         failureText =
0:             "Expected calls and actual calls differed  because "
0:             + calls.subList(startOfDifferences, endOfDifferencesInExpected)
0:             + " missing after element "
0:             + startOfDifferences;
0: 
0:       } 
0:       else
0:       {
0:         if ((endOfDifferencesInExpected == startOfDifferences + 1)
0:           && (endOfDifferencesInReceived == startOfDifferences + 1))
0:         {
0: 
0:           failureText =
0:               "Expected calls and actual calls differed  because element "
0:               + startOfDifferences
0:               + " is different (calls:"
0:               + calls.get(startOfDifferences)
0:               + " but was:"+_methodCalls.get(startOfDifferences)+") ";
0: 
0:         } 
0:         else if (endOfDifferencesInExpected == startOfDifferences + 1)
0:         {
0: 
0:             failureText =
0:                 "Expected calls and actual calls differed  because element "
0:                 + startOfDifferences
0:                 + " ("
0:                 + calls.get(startOfDifferences)
0:                 + ") has been replaced by "
0:                 + _methodCalls.subList(startOfDifferences, endOfDifferencesInReceived);
0:         } 
0:         else
0:         {
0:           failureText =
0:                 "Expected calls and actual calls differed  because elements between "
0:                 + startOfDifferences
0:                 + " and "
0:                 + (endOfDifferencesInExpected - 1)
0:                 + " are different (expected:"
0:                 + calls.subList(startOfDifferences, endOfDifferencesInExpected)
0:                 + " but was:"
0:                 + _methodCalls.subList(startOfDifferences, endOfDifferencesInReceived)
0:                 + ")";
0:         }//if
0:       }//if
0: 
0:       throw new AssertionFailedError(failureText + " expected:" + calls + " but was:" + _methodCalls);
0:     }
0:     else
0:     {
0:       Iterator<MethodCall> expected = calls.iterator();
0:       Iterator<MethodCall> actual = _methodCalls.iterator();
0:       while (expected.hasNext())
0:       {
0:         boolean found = false;
0:         MethodCall expectedCall = expected.next();
0:         MethodCall actualCall = null;
0:         
0:         actual: while (actual.hasNext())
0:         {
0:           actualCall = actual.next();
0:           if (actualCall.equals(expectedCall))
0:           {
0:             found = true;
0:             break actual;
0:           }
0:         }
0:         
0:         if (!found)
0:         {
0:           throw new AssertionFailedError( "The method call " + 
0:                                           expectedCall + 
0:                                           " was expected but has not occurred (actual calls = "+_methodCalls+")");
0:         }
0:       }
0:     }
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* assertCall method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This does the same as checkCall, but throws an 
0:    * junit.framework.AssertionFailedError if the call did not occur.
0:    * 
0:    * @param call the call that was expected
0:    */
0:   public void assertCalled(MethodCall call)
0:   {
0:     if (!checkCall(call))
0:     {
0:       throw new AssertionFailedError("The method call " + 
0:                                       call + 
0:                                       " was expected but has not occurred. Actual calls: " + getMethodCallsAsString());
0:     }
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* assertCalledExactNumberOfTimes method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method asserts that the method specified in the call parameter has 
0:    * been called the number of times specified by numberOfCalls. If 
0:    * numberOfCalls is zero this method is equivalent to assertNotCalled.
0:    * 
0:    * @param call          The call that was made.
0:    * @param numberOfCalls The number of times the call should have been made.
0:    */
0:   public void assertCalledExactNumberOfTimes(MethodCall call, int numberOfCalls)
0:   {
0:     int callCount = 0;
0:     
0:     for (MethodCall callMade : _methodCalls)
0:     {
0:       if (callMade.equals(call))
0:       {
0:         callCount++;
0:       }
0:     }
0:     
0:     if (numberOfCalls != callCount)
0:     {
0:       throw new AssertionFailedError("The method call " + call + 
0:           " should have been called " + numberOfCalls + 
0:           " time(s), but was called " + callCount + " time(s)");
0:     }
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* assertNotCalled method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method throws an junit.framework.AssertionFailedError if the specified
0:    * call was invoked on the skeleton. 
0:    * 
0:    * @param call the call to check.
0:    */
0:   public void assertNotCalled(MethodCall call)
0:   {
0:     Assert.assertFalse( "The method call " + 
0:                         call + 
0:                         "occurred in the skeleton " + 
0:                         this.toString(), checkCall(call));
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* assertMockNotCalled method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method throws an junit.framework.AssertionFailedError if the skeleton
0:    * has had any methods invoked on it. 
0:    */
0:   public void assertSkeletonNotCalled()
0:   {
0:     Assert.assertEquals("The skeleton " + this.toString() + 
0:         " has had the following method invoked on it " + getMethodCallsAsString(), 
0:         0, _methodCalls.size());
0:   }
0: 
0:   // Instance mock creation methods
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* createMock method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * Creates a new Mock using this skeleton backing it.
0:    * 
0:    * @param interfaceClasses an array of interface the mock should implement.
0:    * @return the mock
0:    */
0:   public Object createMock(Class<?> ... interfaceClasses)
0:   {
0:     ClassLoader cl;
0:     
0:     if (interfaceClasses.length > 0) cl = interfaceClasses[0].getClassLoader();
0:     else cl = Thread.currentThread().getContextClassLoader();
0:     
0:     return Proxy.newProxyInstance(cl, interfaceClasses, this);
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* createMock method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * Creates a new Mock using this skeleton backing it.
0:    * 
0:    * @param <T> The object type
0:    * @param interfaceClass an array of interface the mock should implement.
0:    * @return the mock
0:    */
0:   public <T> T createMock(Class<T> interfaceClass)
0:   {
0:     return interfaceClass.cast(Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class[] {interfaceClass}, this));
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* invokeReturnTypeHandlers method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method invokes the return type proxy for the specified class. If a
0:    * ReturnTypeHandler for that type has not been registered then if the class
0:    * represents an interface a new mock will be returned, backed by this 
0:    * skeleton, otherwise null will be returned.
0:    * 
0:    * @param type       the type to be invoked.
0:    * @return           the returned object.
0:    * @throws Exception if an error occurs when invoking the return type handler.
0:    */
0:   public Object invokeReturnTypeHandlers(Class<?> type) throws Exception
0:   {
0:     if (_typeHandlers.containsKey(type))
0:     {
0:       ReturnTypeHandler rth =  _typeHandlers.get(type);
0:       return rth.handle(type, this);
0:     }
0:     else if (type.isInterface())
0:     {
0:       return createMock(type);
0:     }
0:     else
0:     {
0:       return null;
0:     }
0:   }
0: 
0:   // Miscellaneous methods that have been deprecated and will be removed.
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* createReturnTypeProxy method
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * create a proxy for given return type. 
0:    *
0:    * @deprecated use invokeReturnTypeHandlers instead
0:    *  
0:    * @param type               The return type for which a handler is required
0:    * @return ReturnTypeHandler The return type handler
0:    * @throws Exception         Thrown if an exception occurs.
0:    */
0:   /* ------------------------------------------------------------------------ */
0:   @Deprecated
0:   private final Object createReturnTypeProxy(Class<?> type) throws Exception
0:   {
0:     return invokeReturnTypeHandlers(type);
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* isReadWriteProperty method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns true if the method passed a getter for a read write
0:    * java bean property. This is worked out by checking that a setter and getter
0:    * exist for the property and that the setter and getter take and return 
0:    * exactly the same time.
0:    * 
0:    * @param objClass The object the read write method has been invoked on.
0:    * @param method   The method to be checked.
0:    * @return         true if it is a getter or setter for a read write property.
0:    */
0:   private boolean isReadWriteProperty(Class<?> objClass, Method method)
0:   {
0:     String methodName = method.getName();
0:     String propertyName = methodName.substring(3);
0:     Class<?>[] parameters = method.getParameterTypes();
0:     Class<?> clazz;
0:     boolean result = false;
0:     
0:     if (methodName.startsWith("get") && parameters.length == 0)
0:     {
0:       clazz = method.getReturnType();
0:       try
0:       {
0:         objClass.getMethod("set" + propertyName, clazz);
0:         result = true;
0:       }
0:       catch (NoSuchMethodException e)
0:       {
0:         if (isPrimitive(clazz))
0:         {
0:           clazz = getOtherForm(clazz);
0:           try
0:           {
0:             objClass.getMethod("set" + propertyName, clazz);
0:             result = true;
0:           }
0:           catch (NoSuchMethodException e1)
0:           {
0:             
0:           }
0:         }
0:       }
0:     }
0:     else if (methodName.startsWith("is") && parameters.length == 0)
0:     {
0:       clazz = method.getReturnType();
0:       if (clazz.equals(Boolean.class) || clazz.equals(boolean.class))
0:       {
0:         propertyName = methodName.substring(2);
0:         try
0:         {
0:           objClass.getMethod("set" + propertyName, clazz);
0:           result = true;
0:         }
0:         catch (NoSuchMethodException e)
0:         {
0:           
0:           if (isPrimitive(clazz))
0:           {
0:             clazz = getOtherForm(clazz);
0:             try
0:             {
0:               objClass.getMethod("set" + propertyName, clazz);
0:               result = true;
0:             }
0:             catch (NoSuchMethodException e1)
0:             {
0:               
0:             }
0:           }
0:         }
0:       }
0:     }
0:     else if (methodName.startsWith("set") && parameters.length == 1)
0:     {
0:       clazz = parameters[0];
0:       
0:       try
0:       {
0:         Method getter = objClass.getMethod("get" + propertyName, new Class[0]);
0:         result = checkClasses(getter.getReturnType(), clazz);
0:       }
0:       catch (NoSuchMethodException e)
0:       {
0:         if (isPrimitive(clazz))
0:         {
0:           clazz = getOtherForm(clazz);
0:           try
0:           {
0:             Method getter = objClass.getMethod("get" + propertyName, new Class[0]);
0:             result = checkClasses(getter.getReturnType(), clazz);
0:           }
0:           catch (NoSuchMethodException e1)
0:           {
0:             if (clazz.equals(Boolean.class) || clazz.equals(boolean.class))
0:             {
0:               try
0:               {
0:                 Method getter = objClass.getMethod("is" + propertyName, new Class[0]);
0:                 result = checkClasses(getter.getReturnType(), clazz);
0:               }
0:               catch (NoSuchMethodException e2)
0:               {
0:                 clazz = getOtherForm(clazz);
0:                 try
0:                 {
0:                   Method getter = objClass.getMethod("is" + propertyName, new Class[0]);
0:                   result = checkClasses(getter.getReturnType(), clazz);
0:                 }
0:                 catch (NoSuchMethodException e3)
0:                 {
0:                 }
0:               }
0:             }
0:           }
0:         }
0:       }
0:     }
0:     
0:     return result;
0:   }
0:   
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* isPrimitive method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns true if the class object represents a primitive or the
0:    * object version of a primitive.
0:    * 
0:    * @param clazz The class to be checked.
0:    * @return      true if it is a primitive or a wrapper.
0:    */
0:   private boolean isPrimitive(Class<?> clazz)
0:   {
0:     boolean result = false;
0:     
0:     if (clazz.isPrimitive())
0:     {
0:       result = true;
0:     }
0:     else
0:     {
0:       result =  clazz.equals(Boolean.class) || clazz.equals(Byte.class) || 
0:                 clazz.equals(Short.class) || clazz.equals(Character.class) ||
0:                 clazz.equals(Integer.class) || clazz.equals(Long.class) ||
0:                 clazz.equals(Float.class) || clazz.equals(Double.class);
0:     }
0:     
0:     return result;
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* getOtherForm method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method takes a class representing either a primitive or an object 
0:    * wrapper. If the class is a primitive type the object wrapper class is 
0:    * returned. If the class is an object wrapper class the primitive type is
0:    * returned.
0:    * 
0:    * @param clazz
0:    * @return the class representing the primitive object wrapper.
0:    */
0:   private Class<?> getOtherForm(Class<?> clazz)
0:   {
0:     Class<?> result = null;
0:     
0:     if (clazz.equals(boolean.class)) result = Boolean.class;
0:     else if (clazz.equals(byte.class)) result = Byte.class;
0:     else if (clazz.equals(short.class)) result = Short.class;
0:     else if (clazz.equals(char.class)) result = Character.class;
0:     else if (clazz.equals(int.class)) result = Integer.class;
0:     else if (clazz.equals(long.class)) result = Long.class;
0:     else if (clazz.equals(float.class)) result = Float.class;
0:     else if (clazz.equals(double.class)) result = Double.class;
0:     else if (clazz.equals(Boolean.class)) result = boolean.class;
0:     else if (clazz.equals(Byte.class)) result = byte.class;
0:     else if (clazz.equals(Short.class)) result = short.class;
0:     else if (clazz.equals(Character.class)) result = char.class;
0:     else if (clazz.equals(Integer.class)) result = int.class;
0:     else if (clazz.equals(Long.class)) result = long.class;
0:     else if (clazz.equals(Float.class)) result = float.class;
0:     else if (clazz.equals(Double.class)) result = double.class;
0:     
0:     return result;
0:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* checkClasses method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns true if the two classes are the same or if one is 
0:    * primitive that the other is a primitive wrapper.
0:    * 
0:    * @param type1
0:    * @param type2
0:    * @return true if the classes are compatible.
0:    */
0:   private boolean checkClasses(Class<?> type1, Class<?> type2)
0:   {
0:     boolean result = false;
0:     
0:     if ((type1.isPrimitive() && type2.isPrimitive()) ||
0:         (!type1.isPrimitive() && !type2.isPrimitive()))
0:     {
0:       result = type1.equals(type2);
0:     }
0:     else
0:     {
0:       result =  (type1.equals(boolean.class)  && type2.equals(Boolean.class))   ||
0:                 (type1.equals(byte.class)     && type2.equals(Byte.class))      ||
0:                 (type1.equals(short.class)    && type2.equals(Short.class))     ||
0:                 (type1.equals(char.class)     && type2.equals(Character.class)) ||
0:                 (type1.equals(int.class)      && type2.equals(Integer.class))   ||
0:                 (type1.equals(long.class)     && type2.equals(Long.class))      ||
0:                 (type1.equals(float.class)    && type2.equals(Float.class))     ||
0:                 (type1.equals(double.class)   && type2.equals(Double.class))    ||
0:                 (type2.equals(boolean.class)  && type1.equals(Boolean.class))   ||
0:                 (type2.equals(byte.class)     && type1.equals(Byte.class))      ||
0:                 (type2.equals(short.class)    && type1.equals(Short.class))     ||
0:                 (type2.equals(char.class)     && type1.equals(Character.class)) ||
0:                 (type2.equals(int.class)      && type1.equals(Integer.class))   ||
0:                 (type2.equals(long.class)     && type1.equals(Long.class))      ||
0:                 (type2.equals(float.class)    && type1.equals(Float.class))     ||
0:                 (type2.equals(double.class)   && type1.equals(Double.class));
0:     }
0:     
0:     return result;
0:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* getMethodCallsAsString method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method builds a String that contains the method calls that have been
0:    * made on this skeleton. It puts each call on a separate line.
0:    * 
0:    * @return the string representation of the method call.
0:    */
0:   private String getMethodCallsAsString()
0:   {
0:     StringBuilder builder = new StringBuilder();
0:     
0:     for (MethodCall call : _methodCalls)
0:     {
0:       builder.append(call);
0:       builder.append("\r\n");
0:     }
0:     
0:     return builder.toString();
0:   }
0:   
0: }
============================================================================