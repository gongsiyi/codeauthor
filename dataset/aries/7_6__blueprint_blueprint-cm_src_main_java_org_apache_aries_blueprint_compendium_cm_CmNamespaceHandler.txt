2:f13c6ac: /**
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
2:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
2:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.compendium.cm;
1:f13c6ac: 
1:f13c6ac: import java.net.URL;
1:f13c6ac: import java.util.ArrayList;
1:3b2c33b: import java.util.Arrays;
1:f13c6ac: import java.util.Collections;
1:3b2c33b: import java.util.HashSet;
1:f13c6ac: import java.util.List;
1:fc74a12: import java.util.Properties;
1:3b2c33b: import java.util.Set;
1:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:6414875: import org.apache.aries.blueprint.NamespaceHandler;
1:6414875: import org.apache.aries.blueprint.ParserContext;
1:fc74a12: import org.apache.aries.blueprint.ext.PlaceholdersUtils;
1:6414875: import org.apache.aries.blueprint.mutable.MutableBeanMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableCollectionMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableComponentMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableIdRefMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableMapMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableRefMetadata;
1:370ce47: import org.apache.aries.blueprint.mutable.MutableReferenceMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableValueMetadata;
1:e2445d0: import org.apache.aries.blueprint.utils.ServiceListener;
1:b685f35: import org.osgi.framework.Bundle;
1:b685f35: import org.osgi.framework.FrameworkUtil;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanProperty;
1:f13c6ac: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.IdRefMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.MapMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Metadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RefMetadata;
1:370ce47: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RegistrationListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ValueMetadata;
1:f13c6ac: import org.osgi.service.cm.ConfigurationAdmin;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:fc74a12: import org.w3c.dom.CharacterData;
1:fc74a12: import org.w3c.dom.Comment;
1:fc74a12: import org.w3c.dom.Element;
1:fc74a12: import org.w3c.dom.EntityReference;
1:fc74a12: import org.w3c.dom.Node;
1:fc74a12: import org.w3c.dom.NodeList;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * Namespace handler for the Config Admin service.
1:f13c6ac:  * This handler will parse the various elements defined and populate / modify the registry
1:f13c6ac:  * accordingly.
1:f13c6ac:  *
1:f13c6ac:  * @see CmManagedProperties
1:f13c6ac:  * @see CmManagedServiceFactory
1:f13c6ac:  * @see CmProperties
1:f13c6ac:  * @see CmPropertyPlaceholder
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:b571b31: public class CmNamespaceHandler implements NamespaceHandler {
1:f13c6ac: 
1:f13c6ac:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
1:2447745:     public static final String BLUEPRINT_CM_NAMESPACE_1_0 = "http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0";
1:2447745:     public static final String BLUEPRINT_CM_NAMESPACE_1_1 = "http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0";
1:7fc0de1:     public static final String BLUEPRINT_CM_NAMESPACE_1_2 = "http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.2.0";
1:dd30693:     public static final String BLUEPRINT_CM_NAMESPACE_1_3 = "http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.3.0";
1:e2445d0:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_0 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0";
1:e2445d0:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_1 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.1.0";
1:e2445d0:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_2 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.2.0";
1:b8e1010:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_3 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.3.0";
1:b8e1010:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_4 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.4.0";
1:a15082b:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_5 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.5.0";
1:b8e1010: 
1:f13c6ac:     public static final String PROPERTY_PLACEHOLDER_ELEMENT = "property-placeholder";
1:f13c6ac:     public static final String MANAGED_PROPERTIES_ELEMENT = "managed-properties";
1:f13c6ac:     public static final String MANAGED_SERVICE_FACTORY_ELEMENT = "managed-service-factory";
1:f13c6ac:     public static final String CM_PROPERTIES_ELEMENT = "cm-properties";
1:f13c6ac:     public static final String DEFAULT_PROPERTIES_ELEMENT = "default-properties";
1:f13c6ac:     public static final String PROPERTY_ELEMENT = "property";
1:f13c6ac:     public static final String INTERFACES_ELEMENT = "interfaces";
1:f13c6ac:     public static final String VALUE_ELEMENT = "value";
1:f13c6ac:     public static final String MANAGED_COMPONENT_ELEMENT = "managed-component";
1:e2445d0:     public static final String LOCATION_ELEMENT = "location";
1:e2445d0:     public static final String SERVICE_PROPERTIES_ELEMENT = "service-properties";
1:e2445d0:     public static final String REGISTRATION_LISTENER_ELEMENT = "registration-listener";
1:f13c6ac: 
1:f13c6ac:     public static final String ID_ATTRIBUTE = "id";
1:e2445d0:     public static final String SYSTEM_PROPERTIES_NEVER = "never";
1:f13c6ac:     public static final String PERSISTENT_ID_ATTRIBUTE = "persistent-id";
1:f13c6ac:     public static final String PLACEHOLDER_PREFIX_ATTRIBUTE = "placeholder-prefix";
1:f13c6ac:     public static final String PLACEHOLDER_SUFFIX_ATTRIBUTE = "placeholder-suffix";
1:f13c6ac:     public static final String DEFAULTS_REF_ATTRIBUTE = "defaults-ref";
1:f13c6ac:     public static final String UPDATE_STRATEGY_ATTRIBUTE = "update-strategy";
1:f13c6ac:     public static final String UPDATE_METHOD_ATTRIBUTE = "update-method";
1:f13c6ac:     public static final String FACTORY_PID_ATTRIBUTE = "factory-pid";
1:f13c6ac:     public static final String AUTO_EXPORT_ATTRIBUTE = "auto-export";
1:f13c6ac:     public static final String RANKING_ATTRIBUTE = "ranking";
1:f13c6ac:     public static final String INTERFACE_ATTRIBUTE = "interface";
1:f13c6ac:     public static final String UPDATE_ATTRIBUTE = "update";
1:e2445d0:     public static final String SYSTEM_PROPERTIES_ATTRIBUTE = "system-properties";
1:e2445d0:     public static final String IGNORE_MISSING_LOCATIONS_ATTRIBUTE = "ignore-missing-locations";
1:f13c6ac: 
1:f13c6ac:     public static final String AUTO_EXPORT_DISABLED = "disabled";
1:f13c6ac:     public static final String AUTO_EXPORT_INTERFACES = "interfaces";
1:f13c6ac:     public static final String AUTO_EXPORT_CLASS_HIERARCHY = "class-hierarchy";
1:f13c6ac:     public static final String AUTO_EXPORT_ALL = "all-classes";
1:f13c6ac:     public static final String AUTO_EXPORT_DEFAULT = AUTO_EXPORT_DISABLED;
1:f13c6ac:     public static final String RANKING_DEFAULT = "0";
1:f13c6ac: 
1:6414875:     private static final String MANAGED_OBJECT_MANAGER_NAME = "org.apache.aries.managedObjectManager";
1:f13c6ac:     
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(CmNamespaceHandler.class);
1:f13c6ac: 
1:f13c6ac:     // This property is static but it should be ok since there will be only a single instance
1:f13c6ac:     // of this class for the bundle
1:f13c6ac:     private static ConfigurationAdmin configAdmin;
1:f13c6ac: 
1:f13c6ac:     private int idCounter;
1:f13c6ac: 
1:f13c6ac:     public int getIdCounter() {
1:f13c6ac:         return idCounter;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void setIdCounter(int idCounter) {
1:f13c6ac:         this.idCounter = idCounter;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public static ConfigurationAdmin getConfigAdmin() {
1:f13c6ac:         return configAdmin;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void setConfigAdmin(ConfigurationAdmin configAdmin) {
1:b685f35:         CmNamespaceHandler.configAdmin = configAdmin;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public URL getSchemaLocation(String namespace) {
1:dd30693:         if (BLUEPRINT_CM_NAMESPACE_1_3.equals(namespace)) {
1:dd30693:             return getClass().getResource("blueprint-cm-1.3.0.xsd");
1:dd30693:         } else if (BLUEPRINT_CM_NAMESPACE_1_2.equals(namespace)) {
1:7fc0de1:             return getClass().getResource("blueprint-cm-1.2.0.xsd");
1:7fc0de1:         } else if (BLUEPRINT_CM_NAMESPACE_1_1.equals(namespace)) {
1:2447745:             return getClass().getResource("blueprint-cm-1.1.0.xsd");
1:2447745:         } else if (BLUEPRINT_CM_NAMESPACE_1_0.equals(namespace)) {
1:2447745:             return getClass().getResource("blueprint-cm-1.0.0.xsd");
1:b685f35:         } else if (namespace.startsWith("http://aries.apache.org/blueprint/xmlns/blueprint-ext")) {
1:b685f35:             try {
1:2806780:                 Class<?> extNsHandlerClazz;
1:b685f35:                 Bundle extBundle = FrameworkUtil.getBundle(PlaceholdersUtils.class);
1:2806780:                 if (extBundle == null) {
1:2806780:                     // we may not be in OSGi environment
1:2806780:                     extNsHandlerClazz = getClass().getClassLoader().loadClass("org.apache.aries.blueprint.ext.impl.ExtNamespaceHandler");
1:2447745:                 } else {
1:2806780:                     extNsHandlerClazz = extBundle.loadClass("org.apache.aries.blueprint.ext.impl.ExtNamespaceHandler");
1:f13c6ac:                 }
1:b685f35:                 return ((NamespaceHandler) extNsHandlerClazz.newInstance()).getSchemaLocation(namespace);
1:b685f35:             } catch (Throwable t) {
1:b685f35:                 LOGGER.warn("Could not locate ext namespace schema", t);
1:b685f35:                 return null;
1:b685f35:             }
1:2806780:         } else {
1:2447745:             return null;
1:2447745:         }
1:2806780:     }
1:f13c6ac: 
1:3b2c33b:     public Set<Class> getManagedClasses() {
1:3b2c33b:         return new HashSet<Class>(Arrays.asList(
1:3b2c33b:                 CmPropertyPlaceholder.class,
1:3b2c33b:                 CmManagedServiceFactory.class,
1:3b2c33b:                 CmManagedProperties.class,
1:3b2c33b:                 CmProperties.class
1:3b2c33b:         ));
1:3b2c33b:     }
1:3b2c33b: 
1:f13c6ac:     public Metadata parse(Element element, ParserContext context) {
1:f13c6ac:         LOGGER.debug("Parsing element {{}}{}", element.getNamespaceURI(), element.getLocalName());
1:f13c6ac:         ComponentDefinitionRegistry registry = context.getComponentDefinitionRegistry();
1:f13c6ac:         registerManagedObjectManager(context, registry);
1:f13c6ac:         if (nodeNameEquals(element, PROPERTY_PLACEHOLDER_ELEMENT)) {
1:f13c6ac:             return parsePropertyPlaceholder(context, element);
1:f13c6ac:         } else if (nodeNameEquals(element, MANAGED_SERVICE_FACTORY_ELEMENT)) {
1:f13c6ac:             return parseManagedServiceFactory(context, element);
1:7fc0de1:         } else if (nodeNameEquals(element, CM_PROPERTIES_ELEMENT)) {
1:7fc0de1:             return parseCmProperties(context, element);
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Unsupported element: " + element.getNodeName());
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context) {
1:f13c6ac:         LOGGER.debug("Decorating node {{}}{}", node.getNamespaceURI(), node.getLocalName());
1:f13c6ac:         ComponentDefinitionRegistry registry = context.getComponentDefinitionRegistry();
1:f13c6ac:         registerManagedObjectManager(context, registry);
1:f13c6ac:         if (node instanceof Element) {
1:f13c6ac:             if (nodeNameEquals(node, MANAGED_PROPERTIES_ELEMENT)) {
1:f13c6ac:                 return decorateManagedProperties(context, (Element) node, component);
1:f13c6ac:             } else if (nodeNameEquals(node, CM_PROPERTIES_ELEMENT)) {
1:f13c6ac:                 return decorateCmProperties(context, (Element) node, component);
1:f13c6ac:             } else {
1:f13c6ac:                 throw new ComponentDefinitionException("Unsupported element: " + node.getNodeName());
1:f13c6ac:             }
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Illegal use of blueprint cm namespace");
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:7fc0de1:     private ComponentMetadata parseCmProperties(ParserContext context, Element element) {
1:7fc0de1:         String id = getId(context, element);
1:7fc0de1: 
1:7fc0de1:         MutableBeanMetadata factoryMetadata = context.createMetadata(MutableBeanMetadata.class);
1:7fc0de1:         generateIdIfNeeded(context, factoryMetadata);
1:7fc0de1:         factoryMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:7fc0de1:         factoryMetadata.setRuntimeClass(CmProperties.class);
1:7fc0de1:         factoryMetadata.setInitMethod("init");
1:7fc0de1:         factoryMetadata.setDestroyMethod("destroy");
1:7fc0de1:         factoryMetadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
1:7fc0de1:         factoryMetadata.addProperty("configAdmin", createConfigurationAdminRef(context));
1:7fc0de1:         factoryMetadata.addProperty("managedObjectManager", createRef(context, MANAGED_OBJECT_MANAGER_NAME));
1:7fc0de1:         String persistentId = element.getAttribute(PERSISTENT_ID_ATTRIBUTE);
1:7fc0de1:         factoryMetadata.addProperty("persistentId", createValue(context, persistentId));
1:7fc0de1:         context.getComponentDefinitionRegistry().registerComponentDefinition(factoryMetadata);
1:7fc0de1: 
1:7fc0de1:         MutableBeanMetadata propertiesMetadata = context.createMetadata(MutableBeanMetadata.class);
1:7fc0de1:         propertiesMetadata.setId(id);
1:7fc0de1:         propertiesMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:7fc0de1:         propertiesMetadata.setRuntimeClass(Properties.class);
1:7fc0de1:         propertiesMetadata.setFactoryComponent(createRef(context, factoryMetadata.getId()));
1:7fc0de1:         propertiesMetadata.setFactoryComponent(factoryMetadata);
1:7fc0de1:         propertiesMetadata.setFactoryMethod("getProperties");
1:7fc0de1:         // Work around ARIES-877
1:7fc0de1:         propertiesMetadata.setDependsOn(Arrays.asList(factoryMetadata.getId()));
1:7fc0de1: 
1:7fc0de1:         return propertiesMetadata;
1:7fc0de1:     }
1:7fc0de1: 
1:f13c6ac:     private ComponentMetadata parsePropertyPlaceholder(ParserContext context, Element element) {
1:f13c6ac:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:f13c6ac:         metadata.setProcessor(true);
1:f13c6ac:         metadata.setId(getId(context, element));
1:f13c6ac:         metadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:f13c6ac:         metadata.setRuntimeClass(CmPropertyPlaceholder.class);
1:f492016:         metadata.setInitMethod("init");
1:f492016:         metadata.setDestroyMethod("destroy");
1:f13c6ac:         metadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
1:370ce47:         metadata.addProperty("configAdmin", createConfigurationAdminRef(context));
1:f13c6ac:         metadata.addProperty("persistentId", createValue(context, element.getAttribute(PERSISTENT_ID_ATTRIBUTE)));
1:f13c6ac:         String prefix = element.hasAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:f13c6ac:                                     ? element.getAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:f13c6ac:                                     : "${";
1:f13c6ac:         metadata.addProperty("placeholderPrefix", createValue(context, prefix));
1:f13c6ac:         String suffix = element.hasAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:f13c6ac:                                     ? element.getAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:f13c6ac:                                     : "}";
1:f13c6ac:         metadata.addProperty("placeholderSuffix", createValue(context, suffix));
1:f13c6ac:         String defaultsRef = element.hasAttribute(DEFAULTS_REF_ATTRIBUTE) ? element.getAttribute(DEFAULTS_REF_ATTRIBUTE) : null;
1:f13c6ac:         if (defaultsRef != null) {
1:f13c6ac:             metadata.addProperty("defaultProperties", createRef(context, defaultsRef));
1:f13c6ac:         }
1:e104a3b:         String ignoreMissingLocations = extractIgnoreMissingLocations(element);
1:f13c6ac:         if (ignoreMissingLocations != null) {
1:f13c6ac:             metadata.addProperty("ignoreMissingLocations", createValue(context, ignoreMissingLocations));
1:f13c6ac:         }
1:e104a3b:         String systemProperties = extractSystemPropertiesAttribute(element);
1:f13c6ac:         if (systemProperties == null) {
1:e2445d0:             systemProperties = SYSTEM_PROPERTIES_NEVER;
1:f13c6ac:         }
1:f13c6ac:         metadata.addProperty("systemProperties", createValue(context, systemProperties));
1:f492016:         String updateStrategy = element.getAttribute(UPDATE_STRATEGY_ATTRIBUTE);
1:f492016:         if (updateStrategy != null) {
1:f492016:             metadata.addProperty("updateStrategy", createValue(context, updateStrategy));
1:f492016:         }
1:f492016:         metadata.addProperty("managedObjectManager", createRef(context, MANAGED_OBJECT_MANAGER_NAME));
1:f13c6ac:         // Parse elements
1:f13c6ac:         List<String> locations = new ArrayList<String>();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:fc74a12:                 if (isCmNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, DEFAULT_PROPERTIES_ELEMENT)) {
1:f13c6ac:                         if (defaultsRef != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + DEFAULTS_REF_ATTRIBUTE + " attribute or " + DEFAULT_PROPERTIES_ELEMENT + " element is allowed");
1:f13c6ac:                         }
1:f13c6ac:                         Metadata props = parseDefaultProperties(context, metadata, e);
1:f13c6ac:                         metadata.addProperty("defaultProperties", props);
1:f13c6ac:                     }
1:fc74a12:                 } else if (isExtNamespace(e.getNamespaceURI())) {
1:e2445d0:                     if (nodeNameEquals(e, LOCATION_ELEMENT)) {
1:f13c6ac:                         locations.add(getTextValue(e));
1:f13c6ac:                     }
1:f13c6ac:                 } 
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (!locations.isEmpty()) {
1:f13c6ac:             metadata.addProperty("locations", createList(context, locations));
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         PlaceholdersUtils.validatePlaceholder(metadata, context.getComponentDefinitionRegistry());
1:f13c6ac:         
1:f13c6ac:         return metadata;
1:f13c6ac:     }
1:f13c6ac: 
1:e104a3b:     private String extractSystemPropertiesAttribute(Element element) {
1:e104a3b:       String systemProperties = null;
1:f13c6ac:       
1:e2445d0:       if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_0, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:e2445d0:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_0, SYSTEM_PROPERTIES_ATTRIBUTE);
1:e2445d0:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_1, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:e2445d0:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_1, SYSTEM_PROPERTIES_ATTRIBUTE);
1:e2445d0:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_2, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:e2445d0:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_2, SYSTEM_PROPERTIES_ATTRIBUTE);
1:b8e1010:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_3, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:b8e1010:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_3, SYSTEM_PROPERTIES_ATTRIBUTE);
1:b8e1010:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_4, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:b8e1010:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_4, SYSTEM_PROPERTIES_ATTRIBUTE);
1:a15082b:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_5, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:a15082b:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_5, SYSTEM_PROPERTIES_ATTRIBUTE);
1:29cac76:       }
1:e104a3b:       return systemProperties;
1:29cac76:     }
1:f13c6ac: 
1:e104a3b:     private String extractIgnoreMissingLocations(Element element) {
1:e104a3b:       String ignoreMissingLocations = null;
1:e2445d0:       if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_0, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:e2445d0:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_0, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
1:e2445d0:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_1, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
2:e2445d0:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_1, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
1:e2445d0:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_2, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:b84c539:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_2, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
1:b8e1010:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_3, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:b8e1010:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_3, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
1:b8e1010:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_4, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:b8e1010:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_4, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
1:a15082b:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_5, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:a15082b:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_5, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
1:370ce47:       }
1:e104a3b:       return ignoreMissingLocations;
2:370ce47:     }
1:f13c6ac: 
1:f13c6ac:     private Metadata parseDefaultProperties(ParserContext context, MutableBeanMetadata enclosingComponent, Element element) {
1:f13c6ac:         MutableMapMetadata props = context.createMetadata(MutableMapMetadata.class);
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:fc74a12:                 if (isCmNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, PROPERTY_ELEMENT)) {
1:f13c6ac:                         BeanProperty prop = context.parseElement(BeanProperty.class, enclosingComponent, e);
1:f13c6ac:                         props.addEntry(createValue(context, prop.getName(), String.class.getName()), prop.getValue());
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return props;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private ComponentMetadata parseManagedServiceFactory(ParserContext context, Element element) {
1:f13c6ac:         String id = getId(context, element);
1:f13c6ac: 
1:f13c6ac:         MutableBeanMetadata factoryMetadata = context.createMetadata(MutableBeanMetadata.class);
1:f13c6ac:         generateIdIfNeeded(context, factoryMetadata);
1:f13c6ac:         factoryMetadata.addProperty("id", createValue(context, factoryMetadata.getId()));
1:f13c6ac:         factoryMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:f13c6ac:         factoryMetadata.setRuntimeClass(CmManagedServiceFactory.class);
1:f13c6ac:         factoryMetadata.setInitMethod("init");
1:f13c6ac:         factoryMetadata.setDestroyMethod("destroy");
1:e9215e0:         factoryMetadata.addArgument(createRef(context, "blueprintContainer"), null, 0);
1:f13c6ac:         factoryMetadata.addProperty("factoryPid", createValue(context, element.getAttribute(FACTORY_PID_ATTRIBUTE)));
1:f13c6ac:         String autoExport = element.hasAttribute(AUTO_EXPORT_ATTRIBUTE) ? element.getAttribute(AUTO_EXPORT_ATTRIBUTE) : AUTO_EXPORT_DEFAULT;
1:f13c6ac:         if (AUTO_EXPORT_DISABLED.equals(autoExport)) {
1:f13c6ac:             autoExport = Integer.toString(ServiceMetadata.AUTO_EXPORT_DISABLED);
1:f13c6ac:         } else if (AUTO_EXPORT_INTERFACES.equals(autoExport)) {
1:f13c6ac:             autoExport = Integer.toString(ServiceMetadata.AUTO_EXPORT_INTERFACES);
1:f13c6ac:         } else if (AUTO_EXPORT_CLASS_HIERARCHY.equals(autoExport)) {
1:f13c6ac:             autoExport = Integer.toString(ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY);
1:f13c6ac:         } else if (AUTO_EXPORT_ALL.equals(autoExport)) {
1:f13c6ac:             autoExport = Integer.toString(ServiceMetadata.AUTO_EXPORT_ALL_CLASSES);
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Illegal value (" + autoExport + ") for " + AUTO_EXPORT_ATTRIBUTE + " attribute");
1:f13c6ac:         }
1:f13c6ac:         factoryMetadata.addProperty("autoExport", createValue(context, autoExport));
1:f13c6ac:         String ranking = element.hasAttribute(RANKING_ATTRIBUTE) ? element.getAttribute(RANKING_ATTRIBUTE) : RANKING_DEFAULT;
1:f13c6ac:         factoryMetadata.addProperty("ranking", createValue(context, ranking));
1:f13c6ac: 
1:f13c6ac:         List<String> interfaces = null;
1:f13c6ac:         if (element.hasAttribute(INTERFACE_ATTRIBUTE)) {
1:f13c6ac:             interfaces = Collections.singletonList(element.getAttribute(INTERFACE_ATTRIBUTE));
1:f13c6ac:             factoryMetadata.addProperty("interfaces", createList(context, interfaces));
1:f13c6ac:         }
1:f13c6ac:        
1:f13c6ac:         // Parse elements
1:f13c6ac:         List<RegistrationListener> listeners = new ArrayList<RegistrationListener>();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, INTERFACES_ELEMENT)) {
1:f13c6ac:                         if (interfaces != null) {
1:e2445d0:                             throw new ComponentDefinitionException("Only one of " + INTERFACE_ATTRIBUTE + " attribute or " + INTERFACES_ELEMENT + " element must be used");
1:f13c6ac:                         }
1:f13c6ac:                         interfaces = parseInterfaceNames(e);
1:f13c6ac:                         factoryMetadata.addProperty("interfaces", createList(context, interfaces));                    
1:e2445d0:                     } else if (nodeNameEquals(e, SERVICE_PROPERTIES_ELEMENT)) { 
1:e2445d0:                         MapMetadata map = context.parseElement(MapMetadata.class,
1:e2445d0:                             factoryMetadata, e);
1:f13c6ac:                         factoryMetadata.addProperty("serviceProperties", map);
1:fc74a12:                         NodeList enl = e.getChildNodes();
1:fc74a12:                         for (int j = 0; j < enl.getLength(); j++) {
1:fc74a12:                             Node enode = enl.item(j);
1:fc74a12:                             if (enode instanceof Element) {
1:fc74a12:                                 if (isCmNamespace(enode.getNamespaceURI()) && nodeNameEquals(enode, CM_PROPERTIES_ELEMENT)) {
1:fc74a12:                                     decorateCmProperties(context, (Element) enode, factoryMetadata);
1:fc74a12:                                 }
1:fc74a12:                             }
1:fc74a12:                         }
1:e2445d0:                     } else if (nodeNameEquals(e, REGISTRATION_LISTENER_ELEMENT)) {
1:e2445d0:                         listeners.add(context.parseElement(RegistrationListener.class,
1:e2445d0:                             factoryMetadata, e));
1:f13c6ac:                     }
1:fc74a12:                 } else if (isCmNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, MANAGED_COMPONENT_ELEMENT)) {
1:f13c6ac:                         MutableBeanMetadata managedComponent = context.parseElement(MutableBeanMetadata.class, null, e);
1:f13c6ac:                         generateIdIfNeeded(context, managedComponent);
1:f13c6ac:                         managedComponent.setScope(BeanMetadata.SCOPE_PROTOTYPE);
1:f13c6ac:                         // destroy-method on managed-component has different signature than on regular beans
1:f13c6ac:                         // so we'll handle it differently
1:f13c6ac:                         String destroyMethod = managedComponent.getDestroyMethod();
1:f13c6ac:                         if (destroyMethod != null) {
1:f13c6ac:                             factoryMetadata.addProperty("componentDestroyMethod", createValue(context, destroyMethod));
1:f13c6ac:                             managedComponent.setDestroyMethod(null);
1:f13c6ac:                         }
1:f13c6ac:                         context.getComponentDefinitionRegistry().registerComponentDefinition(managedComponent);
1:f13c6ac:                         factoryMetadata.addProperty("managedComponentName", createIdRef(context, managedComponent.getId()));
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         MutableCollectionMetadata listenerCollection = context.createMetadata(MutableCollectionMetadata.class);
1:f13c6ac:         listenerCollection.setCollectionClass(List.class);
1:f13c6ac:         for (RegistrationListener listener : listeners) {
2:f13c6ac:             MutableBeanMetadata bean = context.createMetadata(MutableBeanMetadata.class);
1:f13c6ac:             bean.setRuntimeClass(ServiceListener.class);
1:f13c6ac:             bean.addProperty("listener", listener.getListenerComponent());
1:f13c6ac:             bean.addProperty("registerMethod", createValue(context, listener.getRegistrationMethod()));
1:f13c6ac:             bean.addProperty("unregisterMethod", createValue(context, listener.getUnregistrationMethod()));
1:f13c6ac:             listenerCollection.addValue(bean);
1:f13c6ac:         }
1:f13c6ac:         factoryMetadata.addProperty("listeners", listenerCollection);
1:f13c6ac:         
1:f13c6ac:         context.getComponentDefinitionRegistry().registerComponentDefinition(factoryMetadata);
1:f13c6ac:         
1:f13c6ac:         MutableBeanMetadata mapMetadata = context.createMetadata(MutableBeanMetadata.class);
1:f13c6ac:         mapMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:f13c6ac:         mapMetadata.setId(id);
1:f13c6ac:         mapMetadata.setFactoryComponent(createRef(context, factoryMetadata.getId()));
1:f13c6ac:         mapMetadata.setFactoryMethod("getServiceMap");
1:f13c6ac:         return mapMetadata;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private ComponentMetadata decorateCmProperties(ParserContext context, Element element, ComponentMetadata component) {
1:f13c6ac:         generateIdIfNeeded(context, ((MutableComponentMetadata) component));
1:f13c6ac:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:f13c6ac:         metadata.setProcessor(true);
1:f13c6ac:         metadata.setId(getId(context, element));
1:f13c6ac:         metadata.setRuntimeClass(CmProperties.class);
1:f13c6ac:         String persistentId = element.getAttribute(PERSISTENT_ID_ATTRIBUTE);
1:f13c6ac:         // if persistentId is "" the cm-properties element in nested in managed-service-factory
1:f13c6ac:         // and the configuration object will come from the factory. So we only really need to register
1:f13c6ac:         // ManagedService if the persistentId is not an empty string.
1:f13c6ac:         if (persistentId.length() > 0) {
1:f13c6ac:             metadata.setInitMethod("init");
1:f13c6ac:             metadata.setDestroyMethod("destroy");
1:f13c6ac:         }
1:f13c6ac:         metadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
1:370ce47:         metadata.addProperty("configAdmin", createConfigurationAdminRef(context));
1:f13c6ac:         metadata.addProperty("managedObjectManager", createRef(context, MANAGED_OBJECT_MANAGER_NAME));
1:f13c6ac:         metadata.addProperty("persistentId", createValue(context, persistentId));
1:f13c6ac:         if (element.hasAttribute(UPDATE_ATTRIBUTE)) {
1:f13c6ac:             metadata.addProperty("update", createValue(context, element.getAttribute(UPDATE_ATTRIBUTE)));
1:f13c6ac:         }
1:f13c6ac:         metadata.addProperty("serviceId", createIdRef(context, component.getId()));
1:f13c6ac:         context.getComponentDefinitionRegistry().registerComponentDefinition(metadata);
1:f13c6ac:         return component;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private ComponentMetadata decorateManagedProperties(ParserContext context, Element element, ComponentMetadata component) {
1:f13c6ac:         if (!(component instanceof MutableBeanMetadata)) {
1:f13c6ac:             throw new ComponentDefinitionException("Element " + MANAGED_PROPERTIES_ELEMENT + " must be used inside a <bp:bean> element");
1:f13c6ac:         }
1:f13c6ac:         generateIdIfNeeded(context, ((MutableBeanMetadata) component));
1:f13c6ac:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:f13c6ac:         metadata.setProcessor(true);
1:f13c6ac:         metadata.setId(getId(context, element));
1:f13c6ac:         metadata.setRuntimeClass(CmManagedProperties.class);
1:f13c6ac:         String persistentId = element.getAttribute(PERSISTENT_ID_ATTRIBUTE);
1:f13c6ac:         // if persistentId is "" the managed properties element in nested in managed-service-factory
1:f13c6ac:         // and the configuration object will come from the factory. So we only really need to register
1:f13c6ac:         // ManagedService if the persistentId is not an empty string.
1:f13c6ac:         if (persistentId.length() > 0) {
1:f13c6ac:             metadata.setInitMethod("init");
1:f13c6ac:             metadata.setDestroyMethod("destroy");
1:f13c6ac:         }
1:f13c6ac:         metadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
1:370ce47:         metadata.addProperty("configAdmin", createConfigurationAdminRef(context));
1:f13c6ac:         metadata.addProperty("managedObjectManager", createRef(context, MANAGED_OBJECT_MANAGER_NAME));
1:f13c6ac:         metadata.addProperty("persistentId", createValue(context, persistentId));
1:f13c6ac:         String updateStrategy = element.getAttribute(UPDATE_STRATEGY_ATTRIBUTE);
1:f13c6ac:         if (updateStrategy != null) {
1:f13c6ac:             metadata.addProperty("updateStrategy", createValue(context, updateStrategy));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(UPDATE_METHOD_ATTRIBUTE)) {
1:f13c6ac:             metadata.addProperty("updateMethod", createValue(context, element.getAttribute(UPDATE_METHOD_ATTRIBUTE)));
1:f13c6ac:         } else if ("component-managed".equals(updateStrategy)) {
1:f13c6ac:             throw new ComponentDefinitionException(UPDATE_METHOD_ATTRIBUTE + " attribute must be set when " + UPDATE_STRATEGY_ATTRIBUTE + " is set to 'component-managed'");
1:f13c6ac:         }
1:f13c6ac:         metadata.addProperty("beanName", createIdRef(context, component.getId()));
1:f13c6ac:         context.getComponentDefinitionRegistry().registerComponentDefinition(metadata);
1:f13c6ac:         return component;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void registerManagedObjectManager(ParserContext context, ComponentDefinitionRegistry registry) {
1:f13c6ac:         if (registry.getComponentDefinition(MANAGED_OBJECT_MANAGER_NAME) == null) {
1:f13c6ac:             MutableBeanMetadata beanMetadata = context.createMetadata(MutableBeanMetadata.class);
1:f13c6ac:             beanMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:f13c6ac:             beanMetadata.setId(MANAGED_OBJECT_MANAGER_NAME);
1:f13c6ac:             beanMetadata.setRuntimeClass(ManagedObjectManager.class);            
1:f13c6ac:             registry.registerComponentDefinition(beanMetadata);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:370ce47:     private MutableReferenceMetadata createConfigurationAdminRef(ParserContext context) {
1:fc74a12:         return createServiceRef(context, ConfigurationAdmin.class, null);
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private static ValueMetadata createValue(ParserContext context, String value) {
1:f13c6ac:         return createValue(context, value, null);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static ValueMetadata createValue(ParserContext context, String value, String type) {
1:f13c6ac:         MutableValueMetadata m = context.createMetadata(MutableValueMetadata.class);
1:f13c6ac:         m.setStringValue(value);
1:f13c6ac:         m.setType(type);
1:f13c6ac:         return m;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static RefMetadata createRef(ParserContext context, String value) {
1:f13c6ac:         MutableRefMetadata m = context.createMetadata(MutableRefMetadata.class);
1:f13c6ac:         m.setComponentId(value);
1:f13c6ac:         return m;
1:f13c6ac:     }
1:f13c6ac:     
1:49d1fb2:     private MutableReferenceMetadata createServiceRef(ParserContext context, Class<?> cls, String filter) {
1:370ce47:         MutableReferenceMetadata m = context.createMetadata(MutableReferenceMetadata.class);
1:370ce47:         m.setRuntimeInterface(cls);
1:370ce47:         m.setInterface(cls.getName());
1:370ce47:         m.setActivation(ReferenceMetadata.ACTIVATION_EAGER);
1:370ce47:         m.setAvailability(ReferenceMetadata.AVAILABILITY_MANDATORY);
1:f13c6ac:         
1:370ce47:         if (filter != null) {
1:370ce47:             m.setFilter(filter);
1:f13c6ac:         }
1:f13c6ac:         
1:370ce47:         return m;
1:f13c6ac:     }
2:29cac76: 
1:f13c6ac:     private static IdRefMetadata createIdRef(ParserContext context, String value) {
1:f13c6ac:         MutableIdRefMetadata m = context.createMetadata(MutableIdRefMetadata.class);
1:f13c6ac:         m.setComponentId(value);
1:f13c6ac:         return m;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static CollectionMetadata createList(ParserContext context, List<String> list) {
1:f13c6ac:         MutableCollectionMetadata m = context.createMetadata(MutableCollectionMetadata.class);
1:f13c6ac:         m.setCollectionClass(List.class);
1:f13c6ac:         m.setValueType(String.class.getName());
1:f13c6ac:         for (String v : list) {
1:f13c6ac:             m.addValue(createValue(context, v, String.class.getName()));
1:f13c6ac:         }
1:f13c6ac:         return m;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static String getTextValue(Element element) {
1:f13c6ac:         StringBuffer value = new StringBuffer();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node item = nl.item(i);
1:f13c6ac:             if ((item instanceof CharacterData && !(item instanceof Comment)) || item instanceof EntityReference) {
1:f13c6ac:                 value.append(item.getNodeValue());
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return value.toString();
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static boolean nodeNameEquals(Node node, String name) {
1:f13c6ac:         return (name.equals(node.getNodeName()) || name.equals(node.getLocalName()));
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public static boolean isBlueprintNamespace(String ns) {
1:f13c6ac:         return BLUEPRINT_NAMESPACE.equals(ns);
1:f13c6ac:     }
1:f13c6ac: 
1:fc74a12:     public static boolean isCmNamespace(String uri) {
1:fc74a12:         return BLUEPRINT_CM_NAMESPACE_1_0.equals(uri)
1:7fc0de1:                 || BLUEPRINT_CM_NAMESPACE_1_1.equals(uri)
1:dd30693:                 || BLUEPRINT_CM_NAMESPACE_1_2.equals(uri)
1:dd30693:                 || BLUEPRINT_CM_NAMESPACE_1_3.equals(uri);
1:fc74a12:     }
1:fc74a12: 
1:fc74a12:     public static boolean isExtNamespace(String uri) {
1:fc74a12:         return BLUEPRINT_EXT_NAMESPACE_V1_0.equals(uri)
1:fc74a12:                 || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(uri)
1:b8e1010:                 || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(uri)
1:b8e1010:                 || BLUEPRINT_EXT_NAMESPACE_V1_3.equals(uri)
1:b8e1010:                 || BLUEPRINT_EXT_NAMESPACE_V1_4.equals(uri);
1:fc74a12:     }
1:fc74a12: 
1:f13c6ac:     public String getId(ParserContext context, Element element) {
1:f13c6ac:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:f13c6ac:             return element.getAttribute(ID_ATTRIBUTE);
1:f13c6ac:         } else {
1:f13c6ac:             return generateId(context);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void generateIdIfNeeded(ParserContext context, MutableComponentMetadata metadata) {
1:f13c6ac:         if (metadata.getId() == null) {
1:f13c6ac:             metadata.setId(generateId(context));
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private String generateId(ParserContext context) {
1:f13c6ac:         String id;
1:f13c6ac:         do {
1:f13c6ac:             id = ".cm-" + ++idCounter;
1:f13c6ac:         } while (context.getComponentDefinitionRegistry().containsComponentDefinition(id));
1:f13c6ac:         return id;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public List<String> parseInterfaceNames(Element element) {
1:f13c6ac:         List<String> interfaceNames = new ArrayList<String>();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (nodeNameEquals(e, VALUE_ELEMENT)) {
1:f13c6ac:                     String v = getTextValue(e).trim();
1:f13c6ac:                     if (interfaceNames.contains(v)) {
1:f13c6ac:                         throw new ComponentDefinitionException("The element " + INTERFACES_ELEMENT + " should not contain the same interface twice");
1:f13c6ac:                     }
1:f13c6ac:                     interfaceNames.add(getTextValue(e));
1:f13c6ac:                 } else {
1:f13c6ac:                     throw new ComponentDefinitionException("Unsupported element " + e.getNodeName() + " inside an " + INTERFACES_ELEMENT + " element");
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return interfaceNames;
1:f13c6ac:     }
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:b571b31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class CmNamespaceHandler implements NamespaceHandler {
/////////////////////////////////////////////////////////////////////////
commit:b685f35
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.FrameworkUtil;
/////////////////////////////////////////////////////////////////////////
1:         CmNamespaceHandler.configAdmin = configAdmin;
/////////////////////////////////////////////////////////////////////////
1:         } else if (namespace.startsWith("http://aries.apache.org/blueprint/xmlns/blueprint-ext")) {
1:             try {
1:                 Bundle extBundle = FrameworkUtil.getBundle(PlaceholdersUtils.class);
0:                 Class<?> extNsHandlerClazz = extBundle.loadClass("org.apache.aries.blueprint.ext.impl.ExtNamespaceHandler");
1:                 return ((NamespaceHandler) extNsHandlerClazz.newInstance()).getSchemaLocation(namespace);
1:             } catch (Throwable t) {
1:                 LOGGER.warn("Could not locate ext namespace schema", t);
1:                 return null;
1:             }
commit:a15082b
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_5 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.5.0";
/////////////////////////////////////////////////////////////////////////
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_5, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_5, SYSTEM_PROPERTIES_ATTRIBUTE);
/////////////////////////////////////////////////////////////////////////
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_5, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_5, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
commit:b8e1010
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_3 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.3.0";
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_4 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.4.0";
1: 
/////////////////////////////////////////////////////////////////////////
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_3, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_3, SYSTEM_PROPERTIES_ATTRIBUTE);
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_4, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_4, SYSTEM_PROPERTIES_ATTRIBUTE);
/////////////////////////////////////////////////////////////////////////
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_3, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_3, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_4, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_4, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
/////////////////////////////////////////////////////////////////////////
1:                 || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(uri)
1:                 || BLUEPRINT_EXT_NAMESPACE_V1_3.equals(uri)
1:                 || BLUEPRINT_EXT_NAMESPACE_V1_4.equals(uri);
commit:b84c539
/////////////////////////////////////////////////////////////////////////
1:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_2, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
commit:e9215e0
/////////////////////////////////////////////////////////////////////////
1:         factoryMetadata.addArgument(createRef(context, "blueprintContainer"), null, 0);
commit:7fc0de1
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_CM_NAMESPACE_1_2 = "http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.2.0";
/////////////////////////////////////////////////////////////////////////
0:         if (BLUEPRINT_CM_NAMESPACE_1_2.equals(namespace)) {
1:             return getClass().getResource("blueprint-cm-1.2.0.xsd");
1:         } else if (BLUEPRINT_CM_NAMESPACE_1_1.equals(namespace)) {
/////////////////////////////////////////////////////////////////////////
1:         } else if (nodeNameEquals(element, CM_PROPERTIES_ELEMENT)) {
1:             return parseCmProperties(context, element);
/////////////////////////////////////////////////////////////////////////
1:     private ComponentMetadata parseCmProperties(ParserContext context, Element element) {
1:         String id = getId(context, element);
1: 
1:         MutableBeanMetadata factoryMetadata = context.createMetadata(MutableBeanMetadata.class);
1:         generateIdIfNeeded(context, factoryMetadata);
1:         factoryMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:         factoryMetadata.setRuntimeClass(CmProperties.class);
1:         factoryMetadata.setInitMethod("init");
1:         factoryMetadata.setDestroyMethod("destroy");
1:         factoryMetadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
1:         factoryMetadata.addProperty("configAdmin", createConfigurationAdminRef(context));
1:         factoryMetadata.addProperty("managedObjectManager", createRef(context, MANAGED_OBJECT_MANAGER_NAME));
1:         String persistentId = element.getAttribute(PERSISTENT_ID_ATTRIBUTE);
1:         factoryMetadata.addProperty("persistentId", createValue(context, persistentId));
1:         context.getComponentDefinitionRegistry().registerComponentDefinition(factoryMetadata);
1: 
1:         MutableBeanMetadata propertiesMetadata = context.createMetadata(MutableBeanMetadata.class);
1:         propertiesMetadata.setId(id);
1:         propertiesMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:         propertiesMetadata.setRuntimeClass(Properties.class);
1:         propertiesMetadata.setFactoryComponent(createRef(context, factoryMetadata.getId()));
1:         propertiesMetadata.setFactoryComponent(factoryMetadata);
1:         propertiesMetadata.setFactoryMethod("getProperties");
1:         // Work around ARIES-877
1:         propertiesMetadata.setDependsOn(Arrays.asList(factoryMetadata.getId()));
1: 
1:         return propertiesMetadata;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 || BLUEPRINT_CM_NAMESPACE_1_1.equals(uri)
0:                 || BLUEPRINT_CM_NAMESPACE_1_2.equals(uri);
commit:fc74a12
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.aries.blueprint.ext.PlaceholdersUtils;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.w3c.dom.CharacterData;
1: import org.w3c.dom.Comment;
1: import org.w3c.dom.Element;
1: import org.w3c.dom.EntityReference;
1: import org.w3c.dom.Node;
1: import org.w3c.dom.NodeList;
/////////////////////////////////////////////////////////////////////////
1:                 if (isCmNamespace(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
1:                 } else if (isExtNamespace(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
1:                 if (isCmNamespace(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
1:                         NodeList enl = e.getChildNodes();
1:                         for (int j = 0; j < enl.getLength(); j++) {
1:                             Node enode = enl.item(j);
1:                             if (enode instanceof Element) {
1:                                 if (isCmNamespace(enode.getNamespaceURI()) && nodeNameEquals(enode, CM_PROPERTIES_ELEMENT)) {
1:                                     decorateCmProperties(context, (Element) enode, factoryMetadata);
1:                                 }
1:                             }
1:                         }
1:                 } else if (isCmNamespace(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
1:         return createServiceRef(context, ConfigurationAdmin.class, null);
/////////////////////////////////////////////////////////////////////////
1:     public static boolean isCmNamespace(String uri) {
1:         return BLUEPRINT_CM_NAMESPACE_1_0.equals(uri)
0:                 || BLUEPRINT_CM_NAMESPACE_1_1.equals(uri);
1:     }
1: 
1:     public static boolean isExtNamespace(String uri) {
1:         return BLUEPRINT_EXT_NAMESPACE_V1_0.equals(uri)
1:                 || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(uri)
0:                 || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(uri);
1:     }
1: 
commit:be8e9c5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.ext.PlaceholdersUtils;
/////////////////////////////////////////////////////////////////////////
commit:2447745
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_CM_NAMESPACE_1_0 = "http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0";
1:     public static final String BLUEPRINT_CM_NAMESPACE_1_1 = "http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0";
/////////////////////////////////////////////////////////////////////////
0:         if (BLUEPRINT_CM_NAMESPACE_1_1.equals(namespace)) {
1:             return getClass().getResource("blueprint-cm-1.1.0.xsd");
1:         } else if (BLUEPRINT_CM_NAMESPACE_1_0.equals(namespace)) {
1:             return getClass().getResource("blueprint-cm-1.0.0.xsd");
1:         } else {
1:             return null;
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 if (BLUEPRINT_CM_NAMESPACE_1_0.equals(e.getNamespaceURI())
0:                         || BLUEPRINT_CM_NAMESPACE_1_1.equals(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
0:                 if (BLUEPRINT_CM_NAMESPACE_1_0.equals(e.getNamespaceURI())
0:                         || BLUEPRINT_CM_NAMESPACE_1_1.equals(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
0:                 } else if (BLUEPRINT_CM_NAMESPACE_1_0.equals(e.getNamespaceURI())
0:                         || BLUEPRINT_CM_NAMESPACE_1_1.equals(e.getNamespaceURI())) {
commit:f492016
/////////////////////////////////////////////////////////////////////////
1:         metadata.setInitMethod("init");
1:         metadata.setDestroyMethod("destroy");
/////////////////////////////////////////////////////////////////////////
1:         String updateStrategy = element.getAttribute(UPDATE_STRATEGY_ATTRIBUTE);
1:         if (updateStrategy != null) {
1:             metadata.addProperty("updateStrategy", createValue(context, updateStrategy));
1:         }
1:         metadata.addProperty("managedObjectManager", createRef(context, MANAGED_OBJECT_MANAGER_NAME));
commit:3b2c33b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:     public Set<Class> getManagedClasses() {
1:         return new HashSet<Class>(Arrays.asList(
1:                 CmPropertyPlaceholder.class,
1:                 CmManagedServiceFactory.class,
1:                 CmManagedProperties.class,
1:                 CmProperties.class
1:         ));
1:     }
1: 
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.compendium.cm;
1: 
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.List;
1: 
0: import org.w3c.dom.CharacterData;
0: import org.w3c.dom.Comment;
0: import org.w3c.dom.Element;
0: import org.w3c.dom.EntityReference;
0: import org.w3c.dom.Node;
0: import org.w3c.dom.NodeList;
1: 
0: import org.apache.geronimo.blueprint.ComponentDefinitionRegistry;
0: import org.apache.geronimo.blueprint.NamespaceHandler;
0: import org.apache.geronimo.blueprint.ParserContext;
0: import org.apache.geronimo.blueprint.container.Parser;
0: import org.apache.geronimo.blueprint.container.ParserContextImpl;
0: import org.apache.geronimo.blueprint.container.ServiceListener;
0: import org.apache.geronimo.blueprint.ext.ExtNamespaceHandler;
0: import org.apache.geronimo.blueprint.ext.PlaceholdersUtils;
0: import org.apache.geronimo.blueprint.mutable.MutableBeanMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableCollectionMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableComponentMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableIdRefMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableMapMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableRefMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableValueMetadata;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.BeanProperty;
1: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.IdRefMetadata;
1: import org.osgi.service.blueprint.reflect.MapMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.osgi.service.blueprint.reflect.RefMetadata;
1: import org.osgi.service.blueprint.reflect.RegistrationListener;
1: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1: import org.osgi.service.blueprint.reflect.ValueMetadata;
1: import org.osgi.service.cm.ConfigurationAdmin;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Namespace handler for the Config Admin service.
1:  * This handler will parse the various elements defined and populate / modify the registry
1:  * accordingly.
1:  *
1:  * @see CmManagedProperties
1:  * @see CmManagedServiceFactory
1:  * @see CmProperties
1:  * @see CmPropertyPlaceholder
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 766508 $, $Date: 2009-04-19 22:09:27 +0200 (Sun, 19 Apr 2009) $
1:  */
0: public class CmNamespaceHandler implements NamespaceHandler {
1: 
1:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
0:     public static final String BLUEPRINT_CM_NAMESPACE = "http://geronimo.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0";
1: 
1:     public static final String PROPERTY_PLACEHOLDER_ELEMENT = "property-placeholder";
1:     public static final String MANAGED_PROPERTIES_ELEMENT = "managed-properties";
1:     public static final String MANAGED_SERVICE_FACTORY_ELEMENT = "managed-service-factory";
1:     public static final String CM_PROPERTIES_ELEMENT = "cm-properties";
1:     public static final String DEFAULT_PROPERTIES_ELEMENT = "default-properties";
1:     public static final String PROPERTY_ELEMENT = "property";
1:     public static final String INTERFACES_ELEMENT = "interfaces";
1:     public static final String VALUE_ELEMENT = "value";
1:     public static final String MANAGED_COMPONENT_ELEMENT = "managed-component";
1: 
1:     public static final String ID_ATTRIBUTE = "id";
1:     public static final String PERSISTENT_ID_ATTRIBUTE = "persistent-id";
1:     public static final String PLACEHOLDER_PREFIX_ATTRIBUTE = "placeholder-prefix";
1:     public static final String PLACEHOLDER_SUFFIX_ATTRIBUTE = "placeholder-suffix";
1:     public static final String DEFAULTS_REF_ATTRIBUTE = "defaults-ref";
1:     public static final String UPDATE_STRATEGY_ATTRIBUTE = "update-strategy";
1:     public static final String UPDATE_METHOD_ATTRIBUTE = "update-method";
1:     public static final String FACTORY_PID_ATTRIBUTE = "factory-pid";
1:     public static final String AUTO_EXPORT_ATTRIBUTE = "auto-export";
1:     public static final String RANKING_ATTRIBUTE = "ranking";
1:     public static final String INTERFACE_ATTRIBUTE = "interface";
1:     public static final String UPDATE_ATTRIBUTE = "update";
1: 
1:     public static final String AUTO_EXPORT_DISABLED = "disabled";
1:     public static final String AUTO_EXPORT_INTERFACES = "interfaces";
1:     public static final String AUTO_EXPORT_CLASS_HIERARCHY = "class-hierarchy";
1:     public static final String AUTO_EXPORT_ALL = "all-classes";
1:     public static final String AUTO_EXPORT_DEFAULT = AUTO_EXPORT_DISABLED;
1:     public static final String RANKING_DEFAULT = "0";
1: 
0:     private static final String MANAGED_OBJECT_MANAGER_NAME = "org.apache.geronimo.managedObjectManager";
1:     
1:     private static final Logger LOGGER = LoggerFactory.getLogger(CmNamespaceHandler.class);
1: 
1:     // This property is static but it should be ok since there will be only a single instance
1:     // of this class for the bundle
1:     private static ConfigurationAdmin configAdmin;
1: 
1:     private int idCounter;
1: 
1:     public int getIdCounter() {
1:         return idCounter;
1:     }
1: 
1:     public void setIdCounter(int idCounter) {
1:         this.idCounter = idCounter;
1:     }
1: 
1:     public static ConfigurationAdmin getConfigAdmin() {
1:         return configAdmin;
1:     }
1: 
1:     public void setConfigAdmin(ConfigurationAdmin configAdmin) {
0:         this.configAdmin = configAdmin;
1:     }
1: 
1:     public URL getSchemaLocation(String namespace) {
0:         return getClass().getResource("blueprint-cm.xsd");
1:     }
1: 
1:     public Metadata parse(Element element, ParserContext context) {
1:         LOGGER.debug("Parsing element {{}}{}", element.getNamespaceURI(), element.getLocalName());
1:         ComponentDefinitionRegistry registry = context.getComponentDefinitionRegistry();
1:         registerManagedObjectManager(context, registry);
1:         if (nodeNameEquals(element, PROPERTY_PLACEHOLDER_ELEMENT)) {
1:             return parsePropertyPlaceholder(context, element);
1:         } else if (nodeNameEquals(element, MANAGED_SERVICE_FACTORY_ELEMENT)) {
1:             return parseManagedServiceFactory(context, element);
1:         } else {
1:             throw new ComponentDefinitionException("Unsupported element: " + element.getNodeName());
1:         }
1:     }
1: 
1:     public ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context) {
1:         LOGGER.debug("Decorating node {{}}{}", node.getNamespaceURI(), node.getLocalName());
1:         ComponentDefinitionRegistry registry = context.getComponentDefinitionRegistry();
1:         registerManagedObjectManager(context, registry);
1:         if (node instanceof Element) {
1:             if (nodeNameEquals(node, MANAGED_PROPERTIES_ELEMENT)) {
1:                 return decorateManagedProperties(context, (Element) node, component);
1:             } else if (nodeNameEquals(node, CM_PROPERTIES_ELEMENT)) {
1:                 return decorateCmProperties(context, (Element) node, component);
1:             } else {
1:                 throw new ComponentDefinitionException("Unsupported element: " + node.getNodeName());
1:             }
1:         } else {
1:             throw new ComponentDefinitionException("Illegal use of blueprint cm namespace");
1:         }
1:     }
1: 
1:     private ComponentMetadata parsePropertyPlaceholder(ParserContext context, Element element) {
1:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:         metadata.setProcessor(true);
1:         metadata.setId(getId(context, element));
1:         metadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:         metadata.setRuntimeClass(CmPropertyPlaceholder.class);
1:         metadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
0:         metadata.addProperty("configAdmin", createConfigAdminProxy(context));
1:         metadata.addProperty("persistentId", createValue(context, element.getAttribute(PERSISTENT_ID_ATTRIBUTE)));
1:         String prefix = element.hasAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:                                     ? element.getAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:                                     : "${";
1:         metadata.addProperty("placeholderPrefix", createValue(context, prefix));
1:         String suffix = element.hasAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:                                     ? element.getAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:                                     : "}";
1:         metadata.addProperty("placeholderSuffix", createValue(context, suffix));
1:         String defaultsRef = element.hasAttribute(DEFAULTS_REF_ATTRIBUTE) ? element.getAttribute(DEFAULTS_REF_ATTRIBUTE) : null;
1:         if (defaultsRef != null) {
1:             metadata.addProperty("defaultProperties", createRef(context, defaultsRef));
1:         }
0:         String ignoreMissingLocations = element.hasAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE, ExtNamespaceHandler.IGNORE_MISSING_LOCATIONS_ATTRIBUTE)
0:                 ? element.getAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE, ExtNamespaceHandler.IGNORE_MISSING_LOCATIONS_ATTRIBUTE) : null;
1:         if (ignoreMissingLocations != null) {
1:             metadata.addProperty("ignoreMissingLocations", createValue(context, ignoreMissingLocations));
1:         }
0:         String systemProperties = element.hasAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE, ExtNamespaceHandler.SYSTEM_PROPERTIES_ATTRIBUTE)
0:                 ? element.getAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE, ExtNamespaceHandler.SYSTEM_PROPERTIES_ATTRIBUTE) : null;
1:         if (systemProperties == null) {
0:             systemProperties = ExtNamespaceHandler.SYSTEM_PROPERTIES_NEVER;
1:         }
1:         metadata.addProperty("systemProperties", createValue(context, systemProperties));
1:         // Parse elements
1:         List<String> locations = new ArrayList<String>();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
0:                 if (BLUEPRINT_CM_NAMESPACE.equals(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, DEFAULT_PROPERTIES_ELEMENT)) {
1:                         if (defaultsRef != null) {
1:                             throw new ComponentDefinitionException("Only one of " + DEFAULTS_REF_ATTRIBUTE + " attribute or " + DEFAULT_PROPERTIES_ELEMENT + " element is allowed");
1:                         }
1:                         Metadata props = parseDefaultProperties(context, metadata, e);
1:                         metadata.addProperty("defaultProperties", props);
1:                     }
0:                 } else if (ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE.equals(e.getNamespaceURI())) {
0:                     if (nodeNameEquals(e, ExtNamespaceHandler.LOCATION_ELEMENT)) {
1:                         locations.add(getTextValue(e));
1:                     }
1:                 }
1:             }
1:         }
1:         if (!locations.isEmpty()) {
1:             metadata.addProperty("locations", createList(context, locations));
1:         }
1: 
1:         PlaceholdersUtils.validatePlaceholder(metadata, context.getComponentDefinitionRegistry());
1:         
1:         return metadata;
1:     }
1: 
1:     private Metadata parseDefaultProperties(ParserContext context, MutableBeanMetadata enclosingComponent, Element element) {
1:         MutableMapMetadata props = context.createMetadata(MutableMapMetadata.class);
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
0:                 if (BLUEPRINT_CM_NAMESPACE.equals(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, PROPERTY_ELEMENT)) {
1:                         BeanProperty prop = context.parseElement(BeanProperty.class, enclosingComponent, e);
1:                         props.addEntry(createValue(context, prop.getName(), String.class.getName()), prop.getValue());
1:                     }
1:                 }
1:             }
1:         }
1:         return props;
1:     }
1: 
1:     private ComponentMetadata parseManagedServiceFactory(ParserContext context, Element element) {
1:         String id = getId(context, element);
1: 
1:         MutableBeanMetadata factoryMetadata = context.createMetadata(MutableBeanMetadata.class);
1:         generateIdIfNeeded(context, factoryMetadata);
1:         factoryMetadata.addProperty("id", createValue(context, factoryMetadata.getId()));
1:         factoryMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:         factoryMetadata.setRuntimeClass(CmManagedServiceFactory.class);
1:         factoryMetadata.setInitMethod("init");
1:         factoryMetadata.setDestroyMethod("destroy");
0:         factoryMetadata.addProperty("configAdmin", createConfigAdminProxy(context));
0:         factoryMetadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
1:         factoryMetadata.addProperty("factoryPid", createValue(context, element.getAttribute(FACTORY_PID_ATTRIBUTE)));
1:         String autoExport = element.hasAttribute(AUTO_EXPORT_ATTRIBUTE) ? element.getAttribute(AUTO_EXPORT_ATTRIBUTE) : AUTO_EXPORT_DEFAULT;
1:         if (AUTO_EXPORT_DISABLED.equals(autoExport)) {
1:             autoExport = Integer.toString(ServiceMetadata.AUTO_EXPORT_DISABLED);
1:         } else if (AUTO_EXPORT_INTERFACES.equals(autoExport)) {
1:             autoExport = Integer.toString(ServiceMetadata.AUTO_EXPORT_INTERFACES);
1:         } else if (AUTO_EXPORT_CLASS_HIERARCHY.equals(autoExport)) {
1:             autoExport = Integer.toString(ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY);
1:         } else if (AUTO_EXPORT_ALL.equals(autoExport)) {
1:             autoExport = Integer.toString(ServiceMetadata.AUTO_EXPORT_ALL_CLASSES);
1:         } else {
1:             throw new ComponentDefinitionException("Illegal value (" + autoExport + ") for " + AUTO_EXPORT_ATTRIBUTE + " attribute");
1:         }
1:         factoryMetadata.addProperty("autoExport", createValue(context, autoExport));
1:         String ranking = element.hasAttribute(RANKING_ATTRIBUTE) ? element.getAttribute(RANKING_ATTRIBUTE) : RANKING_DEFAULT;
1:         factoryMetadata.addProperty("ranking", createValue(context, ranking));
1: 
1:         List<String> interfaces = null;
1:         if (element.hasAttribute(INTERFACE_ATTRIBUTE)) {
1:             interfaces = Collections.singletonList(element.getAttribute(INTERFACE_ATTRIBUTE));
1:             factoryMetadata.addProperty("interfaces", createList(context, interfaces));
1:         }
1: 
0:         Parser parser = getParser(context);
1:         
1:         // Parse elements
1:         List<RegistrationListener> listeners = new ArrayList<RegistrationListener>();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, INTERFACES_ELEMENT)) {
1:                         if (interfaces != null) {
0:                             throw new ComponentDefinitionException("Only one of " + Parser.INTERFACE_ATTRIBUTE + " attribute or " + INTERFACES_ELEMENT + " element must be used");
1:                         }
1:                         interfaces = parseInterfaceNames(e);
1:                         factoryMetadata.addProperty("interfaces", createList(context, interfaces));                    
0:                     } else if (nodeNameEquals(e, Parser.SERVICE_PROPERTIES_ELEMENT)) { 
0:                         MapMetadata map = parser.parseServiceProperties(e, factoryMetadata);
1:                         factoryMetadata.addProperty("serviceProperties", map);
0:                     } else if (nodeNameEquals(e, Parser.REGISTRATION_LISTENER_ELEMENT)) {
0:                         listeners.add(parser.parseRegistrationListener(e, factoryMetadata));
1:                     }
0:                 } else if (BLUEPRINT_CM_NAMESPACE.equals(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, MANAGED_COMPONENT_ELEMENT)) {
1:                         MutableBeanMetadata managedComponent = context.parseElement(MutableBeanMetadata.class, null, e);
1:                         generateIdIfNeeded(context, managedComponent);
1:                         managedComponent.setScope(BeanMetadata.SCOPE_PROTOTYPE);
1:                         // destroy-method on managed-component has different signature than on regular beans
1:                         // so we'll handle it differently
1:                         String destroyMethod = managedComponent.getDestroyMethod();
1:                         if (destroyMethod != null) {
1:                             factoryMetadata.addProperty("componentDestroyMethod", createValue(context, destroyMethod));
1:                             managedComponent.setDestroyMethod(null);
1:                         }
1:                         context.getComponentDefinitionRegistry().registerComponentDefinition(managedComponent);
1:                         factoryMetadata.addProperty("managedComponentName", createIdRef(context, managedComponent.getId()));
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         MutableCollectionMetadata listenerCollection = context.createMetadata(MutableCollectionMetadata.class);
1:         listenerCollection.setCollectionClass(List.class);
1:         for (RegistrationListener listener : listeners) {
1:             MutableBeanMetadata bean = context.createMetadata(MutableBeanMetadata.class);
1:             bean.setRuntimeClass(ServiceListener.class);
1:             bean.addProperty("listener", listener.getListenerComponent());
1:             bean.addProperty("registerMethod", createValue(context, listener.getRegistrationMethod()));
1:             bean.addProperty("unregisterMethod", createValue(context, listener.getUnregistrationMethod()));
1:             listenerCollection.addValue(bean);
1:         }
1:         factoryMetadata.addProperty("listeners", listenerCollection);
1:         
1:         context.getComponentDefinitionRegistry().registerComponentDefinition(factoryMetadata);
1:         
1:         MutableBeanMetadata mapMetadata = context.createMetadata(MutableBeanMetadata.class);
1:         mapMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:         mapMetadata.setId(id);
1:         mapMetadata.setFactoryComponent(createRef(context, factoryMetadata.getId()));
1:         mapMetadata.setFactoryMethod("getServiceMap");
1:         return mapMetadata;
1:     }
1: 
1:     private ComponentMetadata decorateCmProperties(ParserContext context, Element element, ComponentMetadata component) {
1:         generateIdIfNeeded(context, ((MutableComponentMetadata) component));
1:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:         metadata.setProcessor(true);
1:         metadata.setId(getId(context, element));
1:         metadata.setRuntimeClass(CmProperties.class);
1:         String persistentId = element.getAttribute(PERSISTENT_ID_ATTRIBUTE);
1:         // if persistentId is "" the cm-properties element in nested in managed-service-factory
1:         // and the configuration object will come from the factory. So we only really need to register
1:         // ManagedService if the persistentId is not an empty string.
1:         if (persistentId.length() > 0) {
1:             metadata.setInitMethod("init");
1:             metadata.setDestroyMethod("destroy");
1:         }
1:         metadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
0:         metadata.addProperty("configAdmin", createConfigAdminProxy(context));
1:         metadata.addProperty("managedObjectManager", createRef(context, MANAGED_OBJECT_MANAGER_NAME));
1:         metadata.addProperty("persistentId", createValue(context, persistentId));
1:         if (element.hasAttribute(UPDATE_ATTRIBUTE)) {
1:             metadata.addProperty("update", createValue(context, element.getAttribute(UPDATE_ATTRIBUTE)));
1:         }
1:         metadata.addProperty("serviceId", createIdRef(context, component.getId()));
1:         context.getComponentDefinitionRegistry().registerComponentDefinition(metadata);
1:         return component;
1:     }
1: 
1:     private ComponentMetadata decorateManagedProperties(ParserContext context, Element element, ComponentMetadata component) {
1:         if (!(component instanceof MutableBeanMetadata)) {
1:             throw new ComponentDefinitionException("Element " + MANAGED_PROPERTIES_ELEMENT + " must be used inside a <bp:bean> element");
1:         }
1:         generateIdIfNeeded(context, ((MutableBeanMetadata) component));
1:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:         metadata.setProcessor(true);
1:         metadata.setId(getId(context, element));
1:         metadata.setRuntimeClass(CmManagedProperties.class);
1:         String persistentId = element.getAttribute(PERSISTENT_ID_ATTRIBUTE);
1:         // if persistentId is "" the managed properties element in nested in managed-service-factory
1:         // and the configuration object will come from the factory. So we only really need to register
1:         // ManagedService if the persistentId is not an empty string.
1:         if (persistentId.length() > 0) {
1:             metadata.setInitMethod("init");
1:             metadata.setDestroyMethod("destroy");
1:         }
1:         metadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
0:         metadata.addProperty("configAdmin", createConfigAdminProxy(context));
1:         metadata.addProperty("managedObjectManager", createRef(context, MANAGED_OBJECT_MANAGER_NAME));
1:         metadata.addProperty("persistentId", createValue(context, persistentId));
1:         String updateStrategy = element.getAttribute(UPDATE_STRATEGY_ATTRIBUTE);
1:         if (updateStrategy != null) {
1:             metadata.addProperty("updateStrategy", createValue(context, updateStrategy));
1:         }
1:         if (element.hasAttribute(UPDATE_METHOD_ATTRIBUTE)) {
1:             metadata.addProperty("updateMethod", createValue(context, element.getAttribute(UPDATE_METHOD_ATTRIBUTE)));
1:         } else if ("component-managed".equals(updateStrategy)) {
1:             throw new ComponentDefinitionException(UPDATE_METHOD_ATTRIBUTE + " attribute must be set when " + UPDATE_STRATEGY_ATTRIBUTE + " is set to 'component-managed'");
1:         }
1:         metadata.addProperty("beanName", createIdRef(context, component.getId()));
1:         context.getComponentDefinitionRegistry().registerComponentDefinition(metadata);
1:         return component;
1:     }
1: 
1:     /**
0:      * Create a reference to the ConfigurationAdmin service if not already done
0:      * and add it to the registry.
1:      *
0:      * @param context the parser context
0:      * @return a metadata pointing to the config admin
1:      */
0:     private Metadata createConfigAdminProxy(ParserContext context) {
1:         MutableBeanMetadata bean = context.createMetadata(MutableBeanMetadata.class);
0:         bean.setRuntimeClass(CmNamespaceHandler.class);
0:         bean.setFactoryMethod("getConfigAdmin");
0:         bean.setActivation(MutableBeanMetadata.ACTIVATION_LAZY);
0:         bean.setScope(MutableBeanMetadata.SCOPE_PROTOTYPE);
0:         return bean;
1:     }
1: 
1:     private void registerManagedObjectManager(ParserContext context, ComponentDefinitionRegistry registry) {
1:         if (registry.getComponentDefinition(MANAGED_OBJECT_MANAGER_NAME) == null) {
1:             MutableBeanMetadata beanMetadata = context.createMetadata(MutableBeanMetadata.class);
1:             beanMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:             beanMetadata.setId(MANAGED_OBJECT_MANAGER_NAME);
1:             beanMetadata.setRuntimeClass(ManagedObjectManager.class);            
1:             registry.registerComponentDefinition(beanMetadata);
1:         }
1:     }
1:     
1:     private static ValueMetadata createValue(ParserContext context, String value) {
1:         return createValue(context, value, null);
1:     }
1: 
1:     private static ValueMetadata createValue(ParserContext context, String value, String type) {
1:         MutableValueMetadata m = context.createMetadata(MutableValueMetadata.class);
1:         m.setStringValue(value);
1:         m.setType(type);
1:         return m;
1:     }
1: 
1:     private static RefMetadata createRef(ParserContext context, String value) {
1:         MutableRefMetadata m = context.createMetadata(MutableRefMetadata.class);
1:         m.setComponentId(value);
1:         return m;
1:     }
1: 
1:     private static IdRefMetadata createIdRef(ParserContext context, String value) {
1:         MutableIdRefMetadata m = context.createMetadata(MutableIdRefMetadata.class);
1:         m.setComponentId(value);
1:         return m;
1:     }
1: 
1:     private static CollectionMetadata createList(ParserContext context, List<String> list) {
1:         MutableCollectionMetadata m = context.createMetadata(MutableCollectionMetadata.class);
1:         m.setCollectionClass(List.class);
1:         m.setValueType(String.class.getName());
1:         for (String v : list) {
1:             m.addValue(createValue(context, v, String.class.getName()));
1:         }
1:         return m;
1:     }
1: 
1:     private static String getTextValue(Element element) {
1:         StringBuffer value = new StringBuffer();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node item = nl.item(i);
1:             if ((item instanceof CharacterData && !(item instanceof Comment)) || item instanceof EntityReference) {
1:                 value.append(item.getNodeValue());
1:             }
1:         }
1:         return value.toString();
1:     }
1: 
1:     private static boolean nodeNameEquals(Node node, String name) {
1:         return (name.equals(node.getNodeName()) || name.equals(node.getLocalName()));
1:     }
1: 
1:     public static boolean isBlueprintNamespace(String ns) {
1:         return BLUEPRINT_NAMESPACE.equals(ns);
1:     }
1: 
1:     public String getId(ParserContext context, Element element) {
1:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:             return element.getAttribute(ID_ATTRIBUTE);
1:         } else {
1:             return generateId(context);
1:         }
1:     }
1: 
1:     public void generateIdIfNeeded(ParserContext context, MutableComponentMetadata metadata) {
1:         if (metadata.getId() == null) {
1:             metadata.setId(generateId(context));
1:         }
1:     }
1: 
1:     private String generateId(ParserContext context) {
1:         String id;
1:         do {
1:             id = ".cm-" + ++idCounter;
1:         } while (context.getComponentDefinitionRegistry().containsComponentDefinition(id));
1:         return id;
1:     }
1:     
0:     private Parser getParser(ParserContext ctx) {
0:         if (ctx instanceof ParserContextImpl) {
0:             return ((ParserContextImpl) ctx).getParser();
1:         }
0:         throw new RuntimeException("Unable to get parser");
1:     }
1: 
1:     public List<String> parseInterfaceNames(Element element) {
1:         List<String> interfaceNames = new ArrayList<String>();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (nodeNameEquals(e, VALUE_ELEMENT)) {
1:                     String v = getTextValue(e).trim();
1:                     if (interfaceNames.contains(v)) {
1:                         throw new ComponentDefinitionException("The element " + INTERFACES_ELEMENT + " should not contain the same interface twice");
1:                     }
1:                     interfaceNames.add(getTextValue(e));
1:                 } else {
1:                     throw new ComponentDefinitionException("Unsupported element " + e.getNodeName() + " inside an " + INTERFACES_ELEMENT + " element");
1:                 }
1:             }
1:         }
1:         return interfaceNames;
1:     }
1: 
1: }
author:Jean-Baptiste Onofr
-------------------------------------------------------------------------------
commit:2806780
/////////////////////////////////////////////////////////////////////////
1:                 Class<?> extNsHandlerClazz;
1:                 if (extBundle == null) {
1:                     // we may not be in OSGi environment
1:                     extNsHandlerClazz = getClass().getClassLoader().loadClass("org.apache.aries.blueprint.ext.impl.ExtNamespaceHandler");
1:                 } else {
1:                     extNsHandlerClazz = extBundle.loadClass("org.apache.aries.blueprint.ext.impl.ExtNamespaceHandler");
1:                 }
commit:29cac76
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.NamespaceHandler2;
/////////////////////////////////////////////////////////////////////////
0: public class CmNamespaceHandler implements NamespaceHandler2 {
/////////////////////////////////////////////////////////////////////////
0:     public boolean usePsvi() {
0:         return false;
1:     }
1: 
0:     public boolean mayResolve(String namespace) {
0:         return namespace != null
0:                 && (namespace.startsWith("http://aries.apache.org/blueprint/xmlns/blueprint-cm")
0:                 || namespace.startsWith("http://aries.apache.org/blueprint/xmlns/blueprint-ext"));
1:     }
1: 
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:dd30693
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_CM_NAMESPACE_1_3 = "http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.3.0";
/////////////////////////////////////////////////////////////////////////
1:         if (BLUEPRINT_CM_NAMESPACE_1_3.equals(namespace)) {
1:             return getClass().getResource("blueprint-cm-1.3.0.xsd");
1:         } else if (BLUEPRINT_CM_NAMESPACE_1_2.equals(namespace)) {
/////////////////////////////////////////////////////////////////////////
1:                 || BLUEPRINT_CM_NAMESPACE_1_2.equals(uri)
1:                 || BLUEPRINT_CM_NAMESPACE_1_3.equals(uri);
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:49d1fb2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return createServiceRef(context, ConfigurationAdmin.class, "(objectClass=" + ConfigurationAdmin.class.getName() + ")");
/////////////////////////////////////////////////////////////////////////
1:     private MutableReferenceMetadata createServiceRef(ParserContext context, Class<?> cls, String filter) {
/////////////////////////////////////////////////////////////////////////
commit:370ce47
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.mutable.MutableReferenceMetadata;
0: import org.apache.aries.blueprint.reflect.PassThroughMetadataImpl;
0: import org.osgi.framework.BundleContext;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
1:         metadata.addProperty("configAdmin", createConfigurationAdminRef(context));
/////////////////////////////////////////////////////////////////////////
0:         factoryMetadata.addProperty("configAdmin", createConfigurationAdminRef(context));
/////////////////////////////////////////////////////////////////////////
1:         metadata.addProperty("configAdmin", createConfigurationAdminRef(context));
/////////////////////////////////////////////////////////////////////////
1:         metadata.addProperty("configAdmin", createConfigurationAdminRef(context));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private MutableReferenceMetadata createConfigurationAdminRef(ParserContext context) {
0:         return createServiceRef(getBlueprintBundleContext(context), context, ConfigurationAdmin.class, "(objectClass=" + ConfigurationAdmin.class.getName() + ")");
1:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     private MutableReferenceMetadata createServiceRef(BundleContext ctx, ParserContext context, Class<?> cls, String filter) {
1:         MutableReferenceMetadata m = context.createMetadata(MutableReferenceMetadata.class);
1:         m.setRuntimeInterface(cls);
1:         m.setInterface(cls.getName());
0:         m.setBundleContext(ctx);
1:         m.setActivation(ReferenceMetadata.ACTIVATION_EAGER);
1:         m.setAvailability(ReferenceMetadata.AVAILABILITY_MANDATORY);
0:         
1:         if (filter != null) {
1:             m.setFilter(filter);
1:         }
0:         
1:         return m;
1:     }
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Returns the bundle context within the parser context
0:      * 
0:      * @param parserContext the parser context
0:      * @return the bundle context within the parser context (if it exists)
0:      */
0:     private BundleContext getBlueprintBundleContext(ParserContext parserContext)
0:     {
0:         BundleContext blueprintContext = null;
0:         
0:         if (parserContext != null) {
0:             ComponentMetadata metaData = parserContext.getComponentDefinitionRegistry().getComponentDefinition("blueprintBundleContext");
0:             
0:             if (metaData != null) {
0:                 blueprintContext = (BundleContext)((PassThroughMetadataImpl)metaData).getObject();   
0:             }   
0:         }
0:         
0:         return blueprintContext;
0:     }
commit:e2445d0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.utils.PlaceholdersUtils;
1: import org.apache.aries.blueprint.utils.ServiceListener;
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_0 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0";
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_1 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.1.0";
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_2 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.2.0";
0:     
/////////////////////////////////////////////////////////////////////////
1:     public static final String LOCATION_ELEMENT = "location";
1:     public static final String SERVICE_PROPERTIES_ELEMENT = "service-properties";
1:     public static final String REGISTRATION_LISTENER_ELEMENT = "registration-listener";
1:     public static final String SYSTEM_PROPERTIES_NEVER = "never";
/////////////////////////////////////////////////////////////////////////
1:     public static final String SYSTEM_PROPERTIES_ATTRIBUTE = "system-properties";
1:     public static final String IGNORE_MISSING_LOCATIONS_ATTRIBUTE = "ignore-missing-locations";
/////////////////////////////////////////////////////////////////////////
1:             systemProperties = SYSTEM_PROPERTIES_NEVER;
/////////////////////////////////////////////////////////////////////////
0:                 } else if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())
0:                     || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())
0:                     || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, LOCATION_ELEMENT)) {
0:                 } 
/////////////////////////////////////////////////////////////////////////
1:       if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_0, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_0, SYSTEM_PROPERTIES_ATTRIBUTE);
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_1, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_1, SYSTEM_PROPERTIES_ATTRIBUTE);
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_2, SYSTEM_PROPERTIES_ATTRIBUTE)) {
1:         systemProperties =  element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_2, SYSTEM_PROPERTIES_ATTRIBUTE);
1:       if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_0, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_0, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_1, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_1, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
1:       } else if (element.hasAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_2, IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
1:         ignoreMissingLocations = element.getAttributeNS(BLUEPRINT_EXT_NAMESPACE_V1_1, IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
/////////////////////////////////////////////////////////////////////////
0:        
/////////////////////////////////////////////////////////////////////////
1:                             throw new ComponentDefinitionException("Only one of " + INTERFACE_ATTRIBUTE + " attribute or " + INTERFACES_ELEMENT + " element must be used");
1:                     } else if (nodeNameEquals(e, SERVICE_PROPERTIES_ELEMENT)) { 
1:                         MapMetadata map = context.parseElement(MapMetadata.class,
1:                             factoryMetadata, e);
1:                     } else if (nodeNameEquals(e, REGISTRATION_LISTENER_ELEMENT)) {
1:                         listeners.add(context.parseElement(RegistrationListener.class,
1:                             factoryMetadata, e));
/////////////////////////////////////////////////////////////////////////
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.parser.Parser;
0: import org.apache.aries.blueprint.parser.ParserContextImpl;
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:e104a3b
/////////////////////////////////////////////////////////////////////////
1:         String ignoreMissingLocations = extractIgnoreMissingLocations(element);
1:         String systemProperties = extractSystemPropertiesAttribute(element);
/////////////////////////////////////////////////////////////////////////
0:                 } else if (ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())) {
0:                     if (nodeNameEquals(e, ExtNamespaceHandler.LOCATION_ELEMENT)) {
0:                         locations.add(getTextValue(e));
0:                     }
0:                 } else if (ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
1:     private String extractSystemPropertiesAttribute(Element element) {
1:       String systemProperties = null;
0:       
0:       if (element.hasAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_0, ExtNamespaceHandler.SYSTEM_PROPERTIES_ATTRIBUTE)) {
0:         systemProperties =  element.getAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_0, ExtNamespaceHandler.SYSTEM_PROPERTIES_ATTRIBUTE);
0:       } else if (element.hasAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_1, ExtNamespaceHandler.SYSTEM_PROPERTIES_ATTRIBUTE)) {
0:         systemProperties =  element.getAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_1, ExtNamespaceHandler.SYSTEM_PROPERTIES_ATTRIBUTE);
0:       }
1:       return systemProperties;
0:     }
0: 
1:     private String extractIgnoreMissingLocations(Element element) {
1:       String ignoreMissingLocations = null;
0:       if (element.hasAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_0, ExtNamespaceHandler.IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
0:         ignoreMissingLocations = element.getAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_0, ExtNamespaceHandler.IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
0:       } else if (element.hasAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_1, ExtNamespaceHandler.IGNORE_MISSING_LOCATIONS_ATTRIBUTE)) {
0:         ignoreMissingLocations = element.getAttributeNS(ExtNamespaceHandler.BLUEPRINT_EXT_NAMESPACE_V1_1, ExtNamespaceHandler.IGNORE_MISSING_LOCATIONS_ATTRIBUTE);
0:       }
1:       return ignoreMissingLocations;
0:     }
0: 
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.compendium.cm;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1: import org.apache.aries.blueprint.NamespaceHandler;
1: import org.apache.aries.blueprint.ParserContext;
0: import org.apache.aries.blueprint.container.Parser;
0: import org.apache.aries.blueprint.container.ParserContextImpl;
0: import org.apache.aries.blueprint.container.ServiceListener;
0: import org.apache.aries.blueprint.ext.ExtNamespaceHandler;
0: import org.apache.aries.blueprint.ext.PlaceholdersUtils;
1: import org.apache.aries.blueprint.mutable.MutableBeanMetadata;
1: import org.apache.aries.blueprint.mutable.MutableCollectionMetadata;
1: import org.apache.aries.blueprint.mutable.MutableComponentMetadata;
1: import org.apache.aries.blueprint.mutable.MutableIdRefMetadata;
1: import org.apache.aries.blueprint.mutable.MutableMapMetadata;
1: import org.apache.aries.blueprint.mutable.MutableRefMetadata;
1: import org.apache.aries.blueprint.mutable.MutableValueMetadata;
/////////////////////////////////////////////////////////////////////////
0:     public static final String BLUEPRINT_CM_NAMESPACE = "http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0";
/////////////////////////////////////////////////////////////////////////
1:     private static final String MANAGED_OBJECT_MANAGER_NAME = "org.apache.aries.managedObjectManager";
============================================================================