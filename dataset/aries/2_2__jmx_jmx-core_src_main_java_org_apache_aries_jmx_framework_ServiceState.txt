1:fdf3952: /**
1:fdf3952:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:fdf3952:  *  contributor license agreements.  See the NOTICE file distributed with
1:fdf3952:  *  this work for additional information regarding copyright ownership.
1:fdf3952:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:fdf3952:  *  (the "License"); you may not use this file except in compliance with
1:fdf3952:  *  the License.  You may obtain a copy of the License at
2:fdf3952:  *
1:fdf3952:  *     http://www.apache.org/licenses/LICENSE-2.0
1:fdf3952:  *
1:fdf3952:  *  Unless required by applicable law or agreed to in writing, software
1:fdf3952:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:fdf3952:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fdf3952:  *  See the License for the specific language governing permissions and
1:fdf3952:  *  limitations under the License.
1:fdf3952:  */
1:fdf3952: package org.apache.aries.jmx.framework;
10:fdf3952: 
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleIds;
1:fdf3952: import static org.apache.aries.jmx.util.FrameworkUtils.resolveService;
1:fdf3952: import static org.osgi.jmx.JmxConstants.PROPERTIES_TYPE;
1:fdf3952: 
1:fdf3952: import java.io.IOException;
1:eb663f7: import java.util.ArrayList;
1:c8116cd: import java.util.Arrays;
1:c8116cd: import java.util.Collection;
1:eb663f7: import java.util.Collections;
1:eb663f7: import java.util.List;
1:fdf3952: import java.util.concurrent.ExecutorService;
1:fdf3952: import java.util.concurrent.Executors;
1:fdf3952: import java.util.concurrent.RejectedExecutionException;
1:fdf3952: import java.util.concurrent.atomic.AtomicInteger;
1:fdf3952: import java.util.concurrent.locks.Lock;
1:fdf3952: import java.util.concurrent.locks.ReentrantLock;
1:fdf3952: 
1:eb663f7: import javax.management.AttributeChangeNotification;
1:fdf3952: import javax.management.MBeanNotificationInfo;
1:fdf3952: import javax.management.MBeanRegistration;
1:fdf3952: import javax.management.MBeanServer;
1:fdf3952: import javax.management.Notification;
1:fdf3952: import javax.management.NotificationBroadcasterSupport;
1:fdf3952: import javax.management.ObjectName;
1:15d33bc: import javax.management.openmbean.CompositeData;
1:fdf3952: import javax.management.openmbean.TabularData;
1:fdf3952: import javax.management.openmbean.TabularDataSupport;
1:fdf3952: 
1:fdf3952: import org.apache.aries.jmx.JMXThreadFactory;
1:fdf3952: import org.apache.aries.jmx.Logger;
1:fdf3952: import org.apache.aries.jmx.codec.PropertyData;
1:fdf3952: import org.apache.aries.jmx.codec.ServiceData;
1:fdf3952: import org.apache.aries.jmx.codec.ServiceEventData;
1:fdf3952: import org.osgi.framework.AllServiceListener;
1:fdf3952: import org.osgi.framework.Bundle;
1:fdf3952: import org.osgi.framework.BundleContext;
1:fdf3952: import org.osgi.framework.Constants;
1:fdf3952: import org.osgi.framework.InvalidSyntaxException;
1:fdf3952: import org.osgi.framework.ServiceEvent;
1:fdf3952: import org.osgi.framework.ServiceReference;
1:fdf3952: import org.osgi.jmx.framework.ServiceStateMBean;
1:fdf3952: import org.osgi.service.log.LogService;
1:fdf3952: 
1:fdf3952: /**
1:fdf3952:  * Implementation of <code>ServiceStateMBean</code> which emits JMX <code>Notification</code> for framework
1:eb663f7:  * <code>ServiceEvent</code> events and changes to the <code>ServiceIds</code> attribute.
1:15d33bc:  *
1:fdf3952:  * @version $Rev$ $Date$
1:fdf3952:  */
1:fdf3952: public class ServiceState extends NotificationBroadcasterSupport implements ServiceStateMBean, MBeanRegistration {
1:fdf3952: 
1:fdf3952:     protected Logger logger;
1:fdf3952:     private BundleContext bundleContext;
1:a0df2a3:     private StateConfig stateConfig;
1:fdf3952: 
1:fdf3952:     protected ExecutorService eventDispatcher;
1:fdf3952:     protected AllServiceListener serviceListener;
1:fdf3952:     private AtomicInteger notificationSequenceNumber = new AtomicInteger(1);
1:eb663f7:     private AtomicInteger attributeChangeNotificationSequenceNumber = new AtomicInteger(1);
1:fdf3952:     private AtomicInteger registrations = new AtomicInteger(0);
1:fdf3952:     private Lock lock = new ReentrantLock();
1:ade4709: 
1:fdf3952:     // notification type description
1:fdf3952:     public static String SERVICE_EVENT = "org.osgi.service.event";
1:fdf3952: 
1:a0df2a3:     public ServiceState(BundleContext bundleContext, StateConfig stateConfig, Logger logger) {
1:fdf3952:         if (bundleContext == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundleContext cannot be null");
9:fdf3952:         }
1:fdf3952:         this.bundleContext = bundleContext;
1:a0df2a3:         this.stateConfig = stateConfig;
1:fdf3952:         this.logger = logger;
1:15d33bc:     }
1:15d33bc: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.ServiceStateMBean#getBundleIdentifier(long)
1:fdf3952:      */
1:fdf3952:     public long getBundleIdentifier(long serviceId) throws IOException {
1:fdf3952:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:fdf3952:         return reference.getBundle().getBundleId();
1:fdf3952:     }
1:15d33bc: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.ServiceStateMBean#getObjectClass(long)
1:fdf3952:      */
1:fdf3952:     public String[] getObjectClass(long serviceId) throws IOException {
1:fdf3952:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:fdf3952:         return (String[]) reference.getProperty(Constants.OBJECTCLASS);
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.ServiceStateMBean#getProperties(long)
1:fdf3952:      */
1:fdf3952:     public TabularData getProperties(long serviceId) throws IOException {
1:fdf3952:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:fdf3952:         TabularData propertiesTable = new TabularDataSupport(PROPERTIES_TYPE);
1:fdf3952:         for (String propertyKey : reference.getPropertyKeys()) {
1:fdf3952:             propertiesTable.put(PropertyData.newInstance(propertyKey, reference.getProperty(propertyKey))
1:fdf3952:                     .toCompositeData());
1:fdf3952:         }
1:fdf3952:         return propertiesTable;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:305da5d:      * @see org.osgi.jmx.framework.ServiceStateMBean#getProperty(long, java.lang.String)
1:305da5d:      */
1:305da5d:     public CompositeData getProperty(long serviceId, String key) throws IOException {
1:305da5d:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:305da5d:             return PropertyData.newInstance(key, reference.getProperty(key)).toCompositeData();
1:305da5d:     }
1:305da5d: 
1:305da5d:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.ServiceStateMBean#getUsingBundles(long)
1:fdf3952:      */
1:fdf3952:     public long[] getUsingBundles(long serviceId) throws IOException {
1:fdf3952:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:fdf3952:         Bundle[] usingBundles = reference.getUsingBundles();
1:fdf3952:         return getBundleIds(usingBundles);
1:15d33bc:     }
1:15d33bc: 
1:fdf3952:     /**
1:cbbcd95:      * @see org.osgi.jmx.framework.ServiceStateMBean#getService(long)
1:cbbcd95:      */
1:cbbcd95:     public CompositeData getService(long serviceId) throws IOException {
1:305da5d:         return new ServiceData(resolveService(bundleContext, serviceId)).toCompositeData();
1:cbbcd95:     }
1:cbbcd95: 
1:cbbcd95:     /**
1:fdf3952:      * @see org.osgi.jmx.framework.ServiceStateMBean#listServices()
1:fdf3952:      */
1:fdf3952:     public TabularData listServices() throws IOException {
1:9516abb:         return listServices(null, null);
1:9516abb:     }
1:9516abb: 
1:9516abb:     /**
1:9516abb:      * @see org.osgi.jmx.framework.ServiceStateMBean#listServices(java.lang.String, java.lang.String)
1:9516abb:      */
1:9516abb:     public TabularData listServices(String clazz, String filter) throws IOException {
1:c8116cd:         return listServices(clazz, filter, ServiceStateMBean.SERVICE_TYPE.keySet());
1:c8116cd:     }
1:c8116cd: 
1:c8116cd:     /**
1:c8116cd:      * @see org.osgi.jmx.framework.ServiceStateMBean#listServices(java.lang.String, java.lang.String, java.lang.String...)
1:c8116cd:      */
1:c8116cd:     public TabularData listServices(String clazz, String filter, String ... serviceTypeItems) throws IOException {
1:c8116cd:         return listServices(clazz, filter, Arrays.asList(serviceTypeItems));
1:c8116cd:     }
1:c8116cd: 
1:c8116cd:     private TabularData listServices(String clazz, String filter, Collection<String> serviceTypeItems) throws IOException {
1:fdf3952:         TabularData servicesTable = new TabularDataSupport(SERVICES_TYPE);
1:fdf3952:         ServiceReference[] allServiceReferences = null;
1:cbbcd95:         try {
1:9516abb:             allServiceReferences = bundleContext.getAllServiceReferences(clazz, filter);
1:cbbcd95:         } catch (InvalidSyntaxException e) {
1:fdf3952:             throw new IllegalStateException("Failed to retrieve all service references", e);
1:fdf3952:         }
1:fdf3952:         if (allServiceReferences != null) {
1:fdf3952:             for (ServiceReference reference : allServiceReferences) {
1:c8116cd:                 servicesTable.put(new ServiceData(reference).toCompositeData(serviceTypeItems));
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         return servicesTable;
1:fdf3952:     }
1:eb663f7: 
1:fdf3952:     /**
1:fdf3952:      * @see javax.management.NotificationBroadcasterSupport#getNotificationInfo()
1:fdf3952:      */
1:fdf3952:     public MBeanNotificationInfo[] getNotificationInfo() {
1:eb663f7:         MBeanNotificationInfo eventInfo = new MBeanNotificationInfo(
1:eb663f7:                 new String[] { SERVICE_EVENT },
1:eb663f7:                 Notification.class.getName(),
1:eb663f7:                 "A ServiceEvent issued from the Framework describing a service lifecycle change");
1:eb663f7: 
1:eb663f7:         MBeanNotificationInfo attributeChangeInfo = new MBeanNotificationInfo(
1:eb663f7:                 new String[] { AttributeChangeNotification.ATTRIBUTE_CHANGE },
1:eb663f7:                 AttributeChangeNotification.class.getName(),
1:eb663f7:                 "An attribute of this MBean has changed");
1:eb663f7: 
1:eb663f7:         return new MBeanNotificationInfo[] { eventInfo, attributeChangeInfo };
1:fdf3952:     }
1:15d33bc: 
1:fdf3952:     /**
1:15d33bc:      * @see org.osgi.jmx.framework.ServiceStateMBean#getServiceIds()
1:15d33bc:      */
1:15d33bc:     public long[] getServiceIds() throws IOException {
1:15d33bc:         try {
1:15d33bc:             ServiceReference<?>[] refs = bundleContext.getAllServiceReferences(null, null);
1:15d33bc:             long[] ids = new long[refs.length];
1:15d33bc:             for (int i=0; i < refs.length; i++) {
1:15d33bc:                 ServiceReference<?> ref = refs[i];
1:15d33bc:                 long id = (Long) ref.getProperty(Constants.SERVICE_ID);
1:15d33bc:                 ids[i] = id;
1:15d33bc:             }
1:15d33bc: 
1:eb663f7:             // The IDs are sorted here. It's not required by the spec but it's nice
1:eb663f7:             // to have an ordered list returned.
1:eb663f7:             Arrays.sort(ids);
1:eb663f7: 
1:15d33bc:             return ids;
1:15d33bc:         } catch (InvalidSyntaxException e) {
1:15d33bc:             IOException ioe = new IOException();
1:15d33bc:             ioe.initCause(e);
1:15d33bc:             throw ioe;
1:15d33bc:         }
1:15d33bc:     }
1:15d33bc: 
1:15d33bc:     /**
1:fdf3952:      * @see javax.management.MBeanRegistration#postDeregister()
1:fdf3952:      */
1:fdf3952:     public void postDeregister() {
1:fdf3952:         if (registrations.decrementAndGet() < 1) {
1:fdf3952:             shutDownDispatcher();
1:fdf3952:         }
1:fdf3952:     }
1:15d33bc: 
1:fdf3952:     /**
1:fdf3952:      * @see javax.management.MBeanRegistration#postRegister(java.lang.Boolean)
1:fdf3952:      */
1:fdf3952:     public void postRegister(Boolean registrationDone) {
1:fdf3952:         if (registrationDone && registrations.incrementAndGet() == 1) {
1:fdf3952:             eventDispatcher = Executors.newSingleThreadExecutor(new JMXThreadFactory("JMX OSGi Service State Event Dispatcher"));
1:fdf3952:             bundleContext.addServiceListener(serviceListener);
1:fdf3952:         }
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     public void preDeregister() throws Exception {
1:fdf3952:         // No action
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * @see javax.management.MBeanRegistration#preRegister(javax.management.MBeanServer, javax.management.ObjectName)
1:fdf3952:      */
1:fdf3952:     public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
1:fdf3952:         lock.lock();
2:fdf3952:         try {
1:fdf3952:             if (serviceListener == null) {
1:fdf3952:                 serviceListener = new AllServiceListener() {
1:fdf3952:                     public void serviceChanged(ServiceEvent serviceevent) {
1:1570712:                         if (stateConfig != null && !stateConfig.isServiceChangeNotificationEnabled()) {
1:1570712:                             return;
1:1570712:                         }
1:fdf3952:                         try {
1:eb663f7:                             // Create a notification for the event
1:eb663f7:                             final Notification notification = new Notification(EVENT, OBJECTNAME,
1:eb663f7:                                     notificationSequenceNumber.getAndIncrement());
1:fdf3952:                             notification.setUserData(new ServiceEventData(serviceevent).toCompositeData());
1:eb663f7: 
1:eb663f7:                             // also send notifications to the serviceIDs attribute listeners, if a service was added or removed
1:ade4709:                             final AttributeChangeNotification attributeChangeNotification =
1:ade4709:                                     getAttributeChangeNotification(serviceevent);
1:eb663f7: 
1:fdf3952:                             eventDispatcher.submit(new Runnable() {
1:fdf3952:                                 public void run() {
1:fdf3952:                                     sendNotification(notification);
1:eb663f7:                                     if (attributeChangeNotification != null)
1:eb663f7:                                         sendNotification(attributeChangeNotification);
1:fdf3952:                                 }
1:fdf3952:                             });
1:fdf3952:                         } catch (RejectedExecutionException re) {
1:fdf3952:                             logger.log(LogService.LOG_WARNING, "Task rejected for JMX Notification dispatch of event ["
1:fdf3952:                                     + serviceevent + "] - Dispatcher may have been shutdown");
1:fdf3952:                         } catch (Exception e) {
1:fdf3952:                             logger.log(LogService.LOG_WARNING,
1:fdf3952:                                     "Exception occured on JMX Notification dispatch for event [" + serviceevent + "]",
1:fdf3952:                                     e);
1:fdf3952:                         }
1:fdf3952:                     }
1:fdf3952:                 };
1:fdf3952:             }
1:fdf3952:         } finally {
1:fdf3952:             lock.unlock();
1:fdf3952:         }
1:fdf3952:         return name;
1:fdf3952:     }
1:eb663f7: 
1:ade4709:     protected AttributeChangeNotification getAttributeChangeNotification(ServiceEvent serviceevent) throws IOException {
1:a0df2a3:         if (stateConfig != null && !stateConfig.isAttributeChangeNotificationEnabled()) {
1:a0df2a3:             return null;
1:a0df2a3:         }
1:a0df2a3: 
1:ade4709:         int eventType = serviceevent.getType();
1:ade4709:         switch (eventType) {
1:ade4709:         case ServiceEvent.REGISTERED:
1:ade4709:         case ServiceEvent.UNREGISTERING:
1:ade4709:             long serviceID = (Long) serviceevent.getServiceReference().getProperty(Constants.SERVICE_ID);
1:ade4709:             long[] ids = getServiceIds();
1:ade4709: 
1:ade4709:             List<Long> without = new ArrayList<Long>(ids.length);
1:ade4709:             for (long id : ids) {
1:ade4709:                 if (id != serviceID)
1:ade4709:                     without.add(id);
1:ade4709:             }
1:ade4709:             List<Long> with = new ArrayList<Long>(without);
1:ade4709:             with.add(serviceID);
1:ade4709: 
1:ade4709:             // Sorting is not mandatory, but its nice for the user, note that getServiceIds() also returns a sorted array
1:ade4709:             Collections.sort(with);
1:ade4709: 
1:d98b820:             List<Long> oldList = eventType == ServiceEvent.REGISTERED ? without : with;
1:d98b820:             List<Long> newList = eventType == ServiceEvent.REGISTERED ? with : without;
1:d98b820: 
1:d98b820:             long[] oldIDs = new long[oldList.size()];
1:d98b820:             for (int i = 0; i < oldIDs.length; i++) {
1:d98b820:                 oldIDs[i] = oldList.get(i);
1:d98b820:             }
1:d98b820: 
1:d98b820:             long[] newIDs = new long[newList.size()];
1:d98b820:             for (int i = 0; i < newIDs.length; i++) {
1:d98b820:                 newIDs[i] = newList.get(i);
1:d98b820:             }
1:ade4709: 
1:ade4709:             return new AttributeChangeNotification(OBJECTNAME, attributeChangeNotificationSequenceNumber.getAndIncrement(),
1:d98b820:                     System.currentTimeMillis(), "ServiceIds changed", "ServiceIds", "Array of long", oldIDs, newIDs);
1:ade4709:         default:
1:ade4709:             return null;
1:ade4709:         }
1:ade4709:     }
1:ade4709: 
1:fdf3952:     /*
1:fdf3952:      * Shuts down the notification dispatcher
1:fdf3952:      * [ARIES-259] MBeans not getting unregistered reliably
1:fdf3952:      */
1:fdf3952:     protected void shutDownDispatcher() {
1:fdf3952:         if (serviceListener != null) {
1:fdf3952:             try {
1:fdf3952:                bundleContext.removeServiceListener(serviceListener);
1:eb663f7:             }
1:fdf3952:             catch (Exception e) {
1:fdf3952:                // ignore
1:eb663f7:             }
1:cbbcd95:         }
1:15d33bc:         if (eventDispatcher != null) {
1:fdf3952:             eventDispatcher.shutdown();
1:cbbcd95:         }
1:15d33bc:     }
1:eb663f7: 
1:fdf3952:     /*
1:fdf3952:      * Returns the ExecutorService used to dispatch Notifications
1:fdf3952:      */
1:fdf3952:     protected ExecutorService getEventDispatcher() {
1:fdf3952:         return eventDispatcher;
1:15d33bc:     }
1:fdf3952: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:1570712
/////////////////////////////////////////////////////////////////////////
1:                         if (stateConfig != null && !stateConfig.isServiceChangeNotificationEnabled()) {
1:                             return;
1:                         }
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:a0df2a3
/////////////////////////////////////////////////////////////////////////
1:     private StateConfig stateConfig;
/////////////////////////////////////////////////////////////////////////
1:     public ServiceState(BundleContext bundleContext, StateConfig stateConfig, Logger logger) {
1:         this.stateConfig = stateConfig;
/////////////////////////////////////////////////////////////////////////
1:         if (stateConfig != null && !stateConfig.isAttributeChangeNotificationEnabled()) {
1:             return null;
1:         }
1: 
commit:0273964
commit:d98b820
/////////////////////////////////////////////////////////////////////////
1:             List<Long> oldList = eventType == ServiceEvent.REGISTERED ? without : with;
1:             List<Long> newList = eventType == ServiceEvent.REGISTERED ? with : without;
1: 
1:             long[] oldIDs = new long[oldList.size()];
1:             for (int i = 0; i < oldIDs.length; i++) {
1:                 oldIDs[i] = oldList.get(i);
1:             }
1: 
1:             long[] newIDs = new long[newList.size()];
1:             for (int i = 0; i < newIDs.length; i++) {
1:                 newIDs[i] = newList.get(i);
1:             }
1:                     System.currentTimeMillis(), "ServiceIds changed", "ServiceIds", "Array of long", oldIDs, newIDs);
commit:ade4709
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                             final AttributeChangeNotification attributeChangeNotification =
1:                                     getAttributeChangeNotification(serviceevent);
/////////////////////////////////////////////////////////////////////////
1:     protected AttributeChangeNotification getAttributeChangeNotification(ServiceEvent serviceevent) throws IOException {
1:         int eventType = serviceevent.getType();
1:         switch (eventType) {
1:         case ServiceEvent.REGISTERED:
1:         case ServiceEvent.UNREGISTERING:
1:             long serviceID = (Long) serviceevent.getServiceReference().getProperty(Constants.SERVICE_ID);
1:             long[] ids = getServiceIds();
1: 
1:             List<Long> without = new ArrayList<Long>(ids.length);
1:             for (long id : ids) {
1:                 if (id != serviceID)
1:                     without.add(id);
1:             }
1:             List<Long> with = new ArrayList<Long>(without);
1:             with.add(serviceID);
1: 
1:             // Sorting is not mandatory, but its nice for the user, note that getServiceIds() also returns a sorted array
1:             Collections.sort(with);
1: 
0:             Long[] oldIDs = (eventType == ServiceEvent.REGISTERED ? without : with).toArray(new Long[] {});
0:             Long[] newIDs = (eventType == ServiceEvent.REGISTERED ? with : without).toArray(new Long[] {});
1: 
1:             return new AttributeChangeNotification(OBJECTNAME, attributeChangeNotificationSequenceNumber.getAndIncrement(),
0:                     System.currentTimeMillis(), "ServiceIds changed", "ServiceIds", "[Ljava.lang.Long;", oldIDs, newIDs);
1:         default:
1:             return null;
1:         }
1:     }
1: 
commit:eb663f7
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: import javax.management.AttributeChangeNotification;
/////////////////////////////////////////////////////////////////////////
1:  * <code>ServiceEvent</code> events and changes to the <code>ServiceIds</code> attribute.
/////////////////////////////////////////////////////////////////////////
1:     private AtomicInteger attributeChangeNotificationSequenceNumber = new AtomicInteger(1);
/////////////////////////////////////////////////////////////////////////
1:         MBeanNotificationInfo eventInfo = new MBeanNotificationInfo(
1:                 new String[] { SERVICE_EVENT },
1:                 Notification.class.getName(),
1:                 "A ServiceEvent issued from the Framework describing a service lifecycle change");
1: 
1:         MBeanNotificationInfo attributeChangeInfo = new MBeanNotificationInfo(
1:                 new String[] { AttributeChangeNotification.ATTRIBUTE_CHANGE },
1:                 AttributeChangeNotification.class.getName(),
1:                 "An attribute of this MBean has changed");
1: 
1:         return new MBeanNotificationInfo[] { eventInfo, attributeChangeInfo };
/////////////////////////////////////////////////////////////////////////
1:             // The IDs are sorted here. It's not required by the spec but it's nice
1:             // to have an ordered list returned.
1:             Arrays.sort(ids);
1: 
/////////////////////////////////////////////////////////////////////////
1:                             // Create a notification for the event
1:                             final Notification notification = new Notification(EVENT, OBJECTNAME,
1:                                     notificationSequenceNumber.getAndIncrement());
1: 
1:                             // also send notifications to the serviceIDs attribute listeners, if a service was added or removed
0:                             final AttributeChangeNotification attributeChangeNotification;
0:                             int eventType = serviceevent.getType();
0:                             switch (eventType) {
0:                             case ServiceEvent.REGISTERED:
0:                             case ServiceEvent.UNREGISTERING:
0:                                 long serviceID = (Long) serviceevent.getServiceReference().getProperty(Constants.SERVICE_ID);
0:                                 long[] ids = getServiceIds();
1: 
0:                                 List<Long> without = new ArrayList<Long>(ids.length);
0:                                 for (long id : ids) {
0:                                     if (id != serviceID)
0:                                         without.add(id);
1:                                 }
0:                                 List<Long> with = new ArrayList<Long>(without);
0:                                 with.add(serviceID);
0:                                 Collections.sort(with);
1: 
0:                                 Long[] oldIDs = (eventType == ServiceEvent.REGISTERED ? without : with).toArray(new Long[] {});
0:                                 Long[] newIDs = (eventType == ServiceEvent.REGISTERED ? with : without).toArray(new Long[] {});
1: 
0:                                 attributeChangeNotification = new AttributeChangeNotification(OBJECTNAME, attributeChangeNotificationSequenceNumber.getAndIncrement(),
0:                                         System.currentTimeMillis(), "ServiceIds changed", "ServiceIds", "[Ljava.lang.Long;", oldIDs, newIDs);
0:                                 break;
0:                             default:
0:                                 attributeChangeNotification = null;
1:                             }
1: 
1:                                     if (attributeChangeNotification != null)
1:                                         sendNotification(attributeChangeNotification);
commit:c8116cd
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1:         return listServices(clazz, filter, ServiceStateMBean.SERVICE_TYPE.keySet());
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#listServices(java.lang.String, java.lang.String, java.lang.String...)
1:      */
1:     public TabularData listServices(String clazz, String filter, String ... serviceTypeItems) throws IOException {
1:         return listServices(clazz, filter, Arrays.asList(serviceTypeItems));
1:     }
1: 
1:     private TabularData listServices(String clazz, String filter, Collection<String> serviceTypeItems) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:                 servicesTable.put(new ServiceData(reference).toCompositeData(serviceTypeItems));
/////////////////////////////////////////////////////////////////////////
commit:9516abb
/////////////////////////////////////////////////////////////////////////
1:         return listServices(null, null);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#listServices(java.lang.String, java.lang.String)
1:      */
1:     public TabularData listServices(String clazz, String filter) throws IOException {
1:             allServiceReferences = bundleContext.getAllServiceReferences(clazz, filter);
/////////////////////////////////////////////////////////////////////////
commit:305da5d
/////////////////////////////////////////////////////////////////////////
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#getProperty(long, java.lang.String)
1:      */
1:     public CompositeData getProperty(long serviceId, String key) throws IOException {
1:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:             return PropertyData.newInstance(key, reference.getProperty(key)).toCompositeData();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         return new ServiceData(resolveService(bundleContext, serviceId)).toCompositeData();
/////////////////////////////////////////////////////////////////////////
commit:cbbcd95
/////////////////////////////////////////////////////////////////////////
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#getService(long)
1:      */
1:     public CompositeData getService(long serviceId) throws IOException {
1:         try {
0:             ServiceReference[] srefs = bundleContext.getAllServiceReferences(null, "(" + Constants.SERVICE_ID + "=" + serviceId + ")");
0:             if (srefs.length >= 0) {
0:                 return new ServiceData(srefs[0]).toCompositeData();
0:             } else {
0:                 return null;
1:             }
1:         } catch (InvalidSyntaxException e) {
0:             return null;
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
commit:15d33bc
/////////////////////////////////////////////////////////////////////////
1: import javax.management.openmbean.CompositeData;
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#getServiceIds()
1:      */
1:     public long[] getServiceIds() throws IOException {
1:         try {
1:             ServiceReference<?>[] refs = bundleContext.getAllServiceReferences(null, null);
1:             long[] ids = new long[refs.length];
1:             for (int i=0; i < refs.length; i++) {
1:                 ServiceReference<?> ref = refs[i];
1:                 long id = (Long) ref.getProperty(Constants.SERVICE_ID);
1:                 ids[i] = id;
1:             }
1: 
1:             return ids;
1:         } catch (InvalidSyntaxException e) {
1:             IOException ioe = new IOException();
1:             ioe.initCause(e);
1:             throw ioe;
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         if (eventDispatcher != null) {
/////////////////////////////////////////////////////////////////////////
0:     ////// TODO these
1: 
0:     public CompositeData getService(long serviceId) throws IOException {
0:         // TODO Auto-generated method stub
0:         return null;
1:     }
1: 
0:     public CompositeData getProperty(long serviceId, String key) throws IOException {
0:         // TODO Auto-generated method stub
0:         return null;
1:     }
1: 
0:     public TabularData listServices(String clazz, String filter) throws IOException {
0:         // TODO Auto-generated method stub
0:         return null;
1:     }
1: 
0:     public TabularData listServices(String clazz, String filter, String[] serviceTypeItems) throws IOException {
0:         // TODO Auto-generated method stub
0:         return null;
1:     }
1: 
commit:fdf3952
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
1: package org.apache.aries.jmx.framework;
1: 
1: import static org.apache.aries.jmx.util.FrameworkUtils.getBundleIds;
1: import static org.apache.aries.jmx.util.FrameworkUtils.resolveService;
1: import static org.osgi.jmx.JmxConstants.PROPERTIES_TYPE;
1: 
1: import java.io.IOException;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.RejectedExecutionException;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.locks.Lock;
1: import java.util.concurrent.locks.ReentrantLock;
1: 
1: import javax.management.MBeanNotificationInfo;
1: import javax.management.MBeanRegistration;
1: import javax.management.MBeanServer;
1: import javax.management.Notification;
1: import javax.management.NotificationBroadcasterSupport;
1: import javax.management.ObjectName;
1: import javax.management.openmbean.TabularData;
1: import javax.management.openmbean.TabularDataSupport;
1: 
1: import org.apache.aries.jmx.JMXThreadFactory;
1: import org.apache.aries.jmx.Logger;
1: import org.apache.aries.jmx.codec.PropertyData;
1: import org.apache.aries.jmx.codec.ServiceData;
1: import org.apache.aries.jmx.codec.ServiceEventData;
1: import org.osgi.framework.AllServiceListener;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceEvent;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.jmx.framework.ServiceStateMBean;
1: import org.osgi.service.log.LogService;
1: 
1: /**
1:  * Implementation of <code>ServiceStateMBean</code> which emits JMX <code>Notification</code> for framework
0:  * <code>ServiceEvent</code> events
1:  * 
1:  * @version $Rev$ $Date$
1:  */
1: public class ServiceState extends NotificationBroadcasterSupport implements ServiceStateMBean, MBeanRegistration {
1: 
1:     protected Logger logger;
1:     private BundleContext bundleContext;
1: 
1:     protected ExecutorService eventDispatcher;
1:     protected AllServiceListener serviceListener;
1:     private AtomicInteger notificationSequenceNumber = new AtomicInteger(1);
1:     private AtomicInteger registrations = new AtomicInteger(0);
1:     private Lock lock = new ReentrantLock();
1:     // notification type description
1:     public static String SERVICE_EVENT = "org.osgi.service.event";
1: 
0:     public ServiceState(BundleContext bundleContext, Logger logger) {
1:         if (bundleContext == null) {
1:             throw new IllegalArgumentException("Argument bundleContext cannot be null");
1:         }
1:         this.bundleContext = bundleContext;
1:         this.logger = logger;
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#getBundleIdentifier(long)
1:      */
1:     public long getBundleIdentifier(long serviceId) throws IOException {
1:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:         return reference.getBundle().getBundleId();
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#getObjectClass(long)
1:      */
1:     public String[] getObjectClass(long serviceId) throws IOException {
1:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:         return (String[]) reference.getProperty(Constants.OBJECTCLASS);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#getProperties(long)
1:      */
1:     public TabularData getProperties(long serviceId) throws IOException {
1:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:         TabularData propertiesTable = new TabularDataSupport(PROPERTIES_TYPE);
1:         for (String propertyKey : reference.getPropertyKeys()) {
1:             propertiesTable.put(PropertyData.newInstance(propertyKey, reference.getProperty(propertyKey))
1:                     .toCompositeData());
1:         }
1:         return propertiesTable;
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#getUsingBundles(long)
1:      */
1:     public long[] getUsingBundles(long serviceId) throws IOException {
1:         ServiceReference reference = resolveService(bundleContext, serviceId);
1:         Bundle[] usingBundles = reference.getUsingBundles();
1:         return getBundleIds(usingBundles);
1:     }
1: 
1:     /**
1:      * @see org.osgi.jmx.framework.ServiceStateMBean#listServices()
1:      */
1:     public TabularData listServices() throws IOException {
1:         TabularData servicesTable = new TabularDataSupport(SERVICES_TYPE);
1:         ServiceReference[] allServiceReferences = null;
1:         try {
0:             allServiceReferences = bundleContext.getAllServiceReferences(null, null);
0:         } catch (InvalidSyntaxException e) {
1:             throw new IllegalStateException("Failed to retrieve all service references", e);
1:         }
1:         if (allServiceReferences != null) {
1:             for (ServiceReference reference : allServiceReferences) {
0:                 servicesTable.put(new ServiceData(reference).toCompositeData());
1:             }
1:         }
1:         return servicesTable;
1:     }
1: 
1:     /**
1:      * @see javax.management.NotificationBroadcasterSupport#getNotificationInfo()
1:      */
1:     public MBeanNotificationInfo[] getNotificationInfo() {
0:         String[] types = new String[] { SERVICE_EVENT };
0:         String name = Notification.class.getName();
0:         String description = "A ServiceEvent issued from the Framework describing a service lifecycle change";
0:         MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description);
0:         return new MBeanNotificationInfo[] { info };
1:     }
1: 
1:     /**
1:      * @see javax.management.MBeanRegistration#postDeregister()
1:      */
1:     public void postDeregister() {
1:         if (registrations.decrementAndGet() < 1) {
1:             shutDownDispatcher();
1:         }
1:     }
1: 
1:     /**
1:      * @see javax.management.MBeanRegistration#postRegister(java.lang.Boolean)
1:      */
1:     public void postRegister(Boolean registrationDone) {
1:         if (registrationDone && registrations.incrementAndGet() == 1) {
1:             eventDispatcher = Executors.newSingleThreadExecutor(new JMXThreadFactory("JMX OSGi Service State Event Dispatcher"));
1:             bundleContext.addServiceListener(serviceListener);
1:         }
1:     }
1: 
1:     public void preDeregister() throws Exception {
1:         // No action
1:     }
1: 
1:     /**
1:      * @see javax.management.MBeanRegistration#preRegister(javax.management.MBeanServer, javax.management.ObjectName)
1:      */
1:     public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
1:         lock.lock();
1:         try {
1:             if (serviceListener == null) {
1:                 serviceListener = new AllServiceListener() {
1:                     public void serviceChanged(ServiceEvent serviceevent) {
0:                         final Notification notification = new Notification(EVENT, OBJECTNAME,
0:                                 notificationSequenceNumber.getAndIncrement());
1:                         try {
1:                             notification.setUserData(new ServiceEventData(serviceevent).toCompositeData());
1:                             eventDispatcher.submit(new Runnable() {
1:                                 public void run() {
1:                                     sendNotification(notification);
1:                                 }
1:                             });
1:                         } catch (RejectedExecutionException re) {
1:                             logger.log(LogService.LOG_WARNING, "Task rejected for JMX Notification dispatch of event ["
1:                                     + serviceevent + "] - Dispatcher may have been shutdown");
1:                         } catch (Exception e) {
1:                             logger.log(LogService.LOG_WARNING,
1:                                     "Exception occured on JMX Notification dispatch for event [" + serviceevent + "]",
1:                                     e);
1:                         }
1:                     }
1:                 };
1:             }
1:         } finally {
1:             lock.unlock();
1:         }
1:         return name;
1:     }
1: 
1:     /*
1:      * Shuts down the notification dispatcher
1:      * [ARIES-259] MBeans not getting unregistered reliably
1:      */
1:     protected void shutDownDispatcher() {
1:         if (serviceListener != null) {
1:             try {
1:                bundleContext.removeServiceListener(serviceListener);
1:             }
1:             catch (Exception e) {
1:                // ignore
1:             }
1:         }
0:         if (eventDispatcher != null) {  
1:             eventDispatcher.shutdown();
1:         }
1:     }
1: 
1:     /*
1:      * Returns the ExecutorService used to dispatch Notifications
1:      */
1:     protected ExecutorService getEventDispatcher() {
1:         return eventDispatcher;
1:     }
1: 
1: }
============================================================================