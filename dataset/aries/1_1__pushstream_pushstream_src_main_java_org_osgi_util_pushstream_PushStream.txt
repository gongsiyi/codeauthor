1:7fa86e8: /*
1:7fa86e8:  * Copyright (c) OSGi Alliance (2015). All Rights Reserved.
1:7fa86e8:  * 
1:7fa86e8:  * Licensed under the Apache License, Version 2.0 (the "License");
1:7fa86e8:  * you may not use this file except in compliance with the License.
1:7fa86e8:  * You may obtain a copy of the License at
1:7fa86e8:  *
1:7fa86e8:  *      http://www.apache.org/licenses/LICENSE-2.0
1:7fa86e8:  *
1:7fa86e8:  * Unless required by applicable law or agreed to in writing, software
1:7fa86e8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7fa86e8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7fa86e8:  * See the License for the specific language governing permissions and
1:7fa86e8:  * limitations under the License.
1:7fa86e8:  */
1:7fa86e8: 
1:7fa86e8: package org.osgi.util.pushstream;
1:7fa86e8: 
1:7fa86e8: import java.time.Duration;
1:7fa86e8: import java.util.Collection;
1:7fa86e8: import java.util.Comparator;
1:7fa86e8: import java.util.Optional;
1:7fa86e8: import java.util.concurrent.BlockingQueue;
1:7fa86e8: import java.util.concurrent.Executor;
1:7fa86e8: import java.util.function.BiFunction;
1:7fa86e8: import java.util.function.BinaryOperator;
1:7fa86e8: import java.util.function.Consumer;
1:7fa86e8: import java.util.function.Function;
1:7fa86e8: import java.util.function.IntFunction;
1:7fa86e8: import java.util.function.IntSupplier;
1:7fa86e8: import java.util.function.Predicate;
1:7fa86e8: import java.util.function.Supplier;
1:7fa86e8: import java.util.stream.Collector;
1:7fa86e8: 
1:7fa86e8: import org.osgi.annotation.versioning.ProviderType;
1:7fa86e8: import org.osgi.util.promise.Promise;
1:7fa86e8: 
1:7fa86e8: /**
1:7fa86e8:  * A Push Stream fulfills the same role as the Java 8 stream but it reverses the
1:7fa86e8:  * control direction. The Java 8 stream is pull based and this is push based. A
1:7fa86e8:  * Push Stream makes it possible to build a pipeline of transformations using a
1:7fa86e8:  * builder kind of model. Just like streams, it provides a number of terminating
1:7fa86e8:  * methods that will actually open the channel and perform the processing until
1:7fa86e8:  * the channel is closed (The source sends a Close event). The results of the
1:7fa86e8:  * processing will be send to a Promise, just like any error events. A stream
1:7fa86e8:  * can be used multiple times. The Push Stream represents a pipeline. Upstream
1:7fa86e8:  * is in the direction of the source, downstream is in the direction of the
1:7fa86e8:  * terminating method. Events are sent downstream asynchronously with no
1:7fa86e8:  * guarantee for ordering or concurrency. Methods are available to provide
1:7fa86e8:  * serialization of the events and splitting in background threads.
1:7fa86e8:  * 
1:7fa86e8:  * @param <T> The Payload type
1:7fa86e8:  */
1:7fa86e8: @ProviderType
1:7fa86e8: public interface PushStream<T> extends AutoCloseable {
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Must be run after the channel is closed. This handler will run after the
1:7fa86e8: 	 * downstream methods have processed the close event and before the upstream
1:7fa86e8: 	 * methods have closed.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param closeHandler Will be called on close
1:7fa86e8: 	 * @return This stream
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> onClose(Runnable closeHandler);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Must be run after the channel is closed. This handler will run after the
1:7fa86e8: 	 * downstream methods have processed the close event and before the upstream
1:7fa86e8: 	 * methods have closed.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param closeHandler Will be called on close
1:7fa86e8: 	 * @return This stream
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> onError(Consumer< ? super Throwable> closeHandler);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Only pass events downstream when the predicate tests true.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param predicate The predicate that is tested (not null)
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> filter(Predicate< ? super T> predicate);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Map a payload value.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param mapper The map function
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	<R> PushStream<R> map(Function< ? super T, ? extends R> mapper);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Flat map the payload value (turn one event into 0..n events of
1:7fa86e8: 	 * potentially another type).
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param mapper The flat map function
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	<R> PushStream<R> flatMap(
1:7fa86e8: 			Function< ? super T, ? extends PushStream< ? extends R>> mapper);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Remove any duplicates. Notice that this can be expensive in a large
1:7fa86e8: 	 * stream since it must track previous payloads.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> distinct();
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Sorted the elements, assuming that T extends Comparable. This is of
1:7fa86e8: 	 * course expensive for large or infinite streams since it requires
1:7fa86e8: 	 * buffering the stream until close.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> sorted();
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Sorted the elements with the given comparator. This is of course
1:7fa86e8: 	 * expensive for large or infinite streams since it requires buffering the
1:7fa86e8: 	 * stream until close.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param comparator
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> sorted(Comparator< ? super T> comparator);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Automatically close the channel after the maxSize number of elements is
1:7fa86e8: 	 * received.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param maxSize Maximum number of elements has been received
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> limit(long maxSize);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Skip a number of events in the channel.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param n number of elements to skip
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> skip(long n);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Execute the downstream events in up to n background threads. If more
1:7fa86e8: 	 * requests are outstanding apply delay * nr of delayed threads back
1:7fa86e8: 	 * pressure. A downstream channel that is closed or throws an exception will
1:7fa86e8: 	 * cause all execution to cease and the stream to close
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param n number of simultaneous background threads to use
1:7fa86e8: 	 * @param delay Nr of ms/thread that is queued back pressure
1:7fa86e8: 	 * @param e an executor to use for the background threads.
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 * @throws IllegalArgumentException if the number of threads is < 1 or the
1:7fa86e8: 	 *             delay is < 0
1:7fa86e8: 	 * @throws NullPointerException if the Executor is null
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> fork(int n, int delay, Executor e)
1:7fa86e8: 			throws IllegalArgumentException, NullPointerException;
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Buffer the events in a queue using default values for the queue size and
1:7fa86e8: 	 * other behaviours. Buffered work will be processed asynchronously in the
1:7fa86e8: 	 * rest of the chain. Buffering also blocks the transmission of back
1:7fa86e8: 	 * pressure to previous elements in the chain, although back pressure is
1:7fa86e8: 	 * honoured by the buffer.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * Buffers are useful for "bursty" event sources which produce a number of
1:7fa86e8: 	 * events close together, then none for some time. These bursts can
1:7fa86e8: 	 * sometimes overwhelm downstream event consumers. Buffering will not,
1:7fa86e8: 	 * however, protect downstream components from a source which produces
1:7fa86e8: 	 * events faster than they can be consumed. For fast sources
1:7fa86e8: 	 * {@link #filter(Predicate)} and {@link #coalesce(int, Function)}
1:7fa86e8: 	 * {@link #fork(int, int, Executor)} are better choices.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> buffer();
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Build a buffer to enqueue events in a queue using custom values for the
1:7fa86e8: 	 * queue size and other behaviours. Buffered work will be processed
1:7fa86e8: 	 * asynchronously in the rest of the chain. Buffering also blocks the
1:7fa86e8: 	 * transmission of back pressure to previous elements in the chain, although
1:7fa86e8: 	 * back pressure is honoured by the buffer.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * Buffers are useful for "bursty" event sources which produce a number of
1:7fa86e8: 	 * events close together, then none for some time. These bursts can
1:7fa86e8: 	 * sometimes overwhelm downstream event consumers. Buffering will not,
1:7fa86e8: 	 * however, protect downstream components from a source which produces
1:7fa86e8: 	 * events faster than they can be consumed. For fast sources
1:7fa86e8: 	 * {@link #filter(Predicate)} and {@link #coalesce(int, Function)}
1:7fa86e8: 	 * {@link #fork(int, int, Executor)} are better choices.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * Buffers are also useful as "circuit breakers" in the pipeline. If a
1:7fa86e8: 	 * {@link QueuePolicyOption#FAIL} is used then a full buffer will trigger
1:7fa86e8: 	 * the stream to close, preventing an event storm from reaching the client.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param parallelism
1:7fa86e8: 	 * @param executor
1:7fa86e8: 	 * @param queue
1:7fa86e8: 	 * @param queuePolicy
1:7fa86e8: 	 * @param pushbackPolicy
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	<U extends BlockingQueue<PushEvent< ? extends T>>> PushStreamBuilder<T,U> buildBuffer();
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Merge in the events from another source. The resulting channel is not
1:7fa86e8: 	 * closed until this channel and the channel from the source are closed.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param source The source to merge in.
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> merge(PushEventSource< ? extends T> source);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Merge in the events from another PushStream. The resulting channel is not
1:7fa86e8: 	 * closed until this channel and the channel from the source are closed.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param source The source to merge in.
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> merge(PushStream< ? extends T> source);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Split the events to different streams based on a predicate. If the
1:7fa86e8: 	 * predicate is true, the event is dispatched to that channel on the same
1:7fa86e8: 	 * position. All predicates are tested for every event.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This method differs from other methods of AsyncStream in three
1:7fa86e8: 	 * significant ways:
1:7fa86e8: 	 * <ul>
1:7fa86e8: 	 * <li>The return value contains multiple streams.</li>
1:7fa86e8: 	 * <li>This stream will only close when all of these child streams have
1:7fa86e8: 	 * closed.</li>
1:7fa86e8: 	 * <li>Event delivery is made to all open children that accept the event.
1:7fa86e8: 	 * </li>
1:7fa86e8: 	 * </ul>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param predicates the predicates to test
1:7fa86e8: 	 * @return streams that map to the predicates
1:7fa86e8: 	 */
1:7fa86e8: 	@SuppressWarnings("unchecked")
1:7fa86e8: 	PushStream<T>[] split(Predicate< ? super T>... predicates);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Ensure that any events are delivered sequentially. That is, no
1:7fa86e8: 	 * overlapping calls downstream. This can be used to turn a forked stream
1:7fa86e8: 	 * (where for example a heavy conversion is done in multiple threads) back
1:7fa86e8: 	 * into a sequential stream so a reduce is simple to do.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	PushStream<T> sequential();
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Coalesces a number of events into a new type of event. The input events
1:7fa86e8: 	 * are forwarded to a accumulator function. This function returns an
1:7fa86e8: 	 * Optional. If the optional is present, it's value is send downstream,
1:7fa86e8: 	 * otherwise it is ignored.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param f
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	<R> PushStream<R> coalesce(Function< ? super T,Optional<R>> f);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Coalesces a number of events into a new type of event. A fixed number of
1:7fa86e8: 	 * input events are forwarded to a accumulator function. This function
1:7fa86e8: 	 * returns new event data to be forwarded on.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param count
1:7fa86e8: 	 * @param f
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	public <R> PushStream<R> coalesce(int count, Function<Collection<T>,R> f);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Coalesces a number of events into a new type of event. A variable number
1:7fa86e8: 	 * of input events are forwarded to a accumulator function. The number of
1:7fa86e8: 	 * events to be forwarded is determined by calling the count function. The
1:7fa86e8: 	 * accumulator function then returns new event data to be forwarded on.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param count
1:7fa86e8: 	 * @param f
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	public <R> PushStream<R> coalesce(IntSupplier count,
1:7fa86e8: 			Function<Collection<T>,R> f);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Buffers a number of events over a fixed time interval and then forwards
1:7fa86e8: 	 * the events to an accumulator function. This function returns new event
1:7fa86e8: 	 * data to be forwarded on. Note that:
1:7fa86e8: 	 * <ul>
1:7fa86e8: 	 * <li>The collection forwarded to the accumulator function will be empty if
1:7fa86e8: 	 * no events arrived during the time interval.</li>
1:7fa86e8: 	 * <li>The accumulator function will be run and the forwarded event
1:7fa86e8: 	 * delivered as a different task, (and therefore potentially on a different
1:7fa86e8: 	 * thread) from the one that delivered the event to this {@link PushStream}.
1:7fa86e8: 	 * </li>
1:7fa86e8: 	 * <li>Due to the buffering and asynchronous delivery required, this method
1:7fa86e8: 	 * prevents the propagation of back-pressure to earlier stages</li>
1:7fa86e8: 	 * </ul>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param d
1:7fa86e8: 	 * @param f
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	<R> PushStream<R> window(Duration d, Function<Collection<T>,R> f);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Buffers a number of events over a fixed time interval and then forwards
1:7fa86e8: 	 * the events to an accumulator function. This function returns new event
1:7fa86e8: 	 * data to be forwarded on. Note that:
1:7fa86e8: 	 * <ul>
1:7fa86e8: 	 * <li>The collection forwarded to the accumulator function will be empty if
1:7fa86e8: 	 * no events arrived during the time interval.</li>
1:7fa86e8: 	 * <li>The accumulator function will be run and the forwarded event
1:7fa86e8: 	 * delivered by a task given to the supplied executor.</li>
1:7fa86e8: 	 * <li>Due to the buffering and asynchronous delivery required, this method
1:7fa86e8: 	 * prevents the propagation of back-pressure to earlier stages</li>
1:7fa86e8: 	 * </ul>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param d
1:7fa86e8: 	 * @param executor
1:7fa86e8: 	 * @param f
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	<R> PushStream<R> window(Duration d, Executor executor,
1:7fa86e8: 			Function<Collection<T>,R> f);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Buffers a number of events over a variable time interval and then
1:7fa86e8: 	 * forwards the events to an accumulator function. The length of time over
1:7fa86e8: 	 * which events are buffered is determined by the time function. A maximum
1:7fa86e8: 	 * number of events can also be requested, if this number of events is
1:7fa86e8: 	 * reached then the accumulator will be called early. The accumulator
1:7fa86e8: 	 * function returns new event data to be forwarded on. It is also given the
1:7fa86e8: 	 * length of time for which the buffer accumulated data. This may be less
1:7fa86e8: 	 * than the requested interval if the buffer reached the maximum number of
1:7fa86e8: 	 * requested events early. Note that:
1:7fa86e8: 	 * <ul>
1:7fa86e8: 	 * <li>The collection forwarded to the accumulator function will be empty if
1:7fa86e8: 	 * no events arrived during the time interval.</li>
1:7fa86e8: 	 * <li>The accumulator function will be run and the forwarded event
1:7fa86e8: 	 * delivered as a different task, (and therefore potentially on a different
1:7fa86e8: 	 * thread) from the one that delivered the event to this {@link PushStream}.
1:7fa86e8: 	 * </li>
1:7fa86e8: 	 * <li>Due to the buffering and asynchronous delivery required, this method
1:7fa86e8: 	 * prevents the propagation of back-pressure to earlier stages</li>
1:7fa86e8: 	 * <li>If the window finishes by hitting the maximum number of events then
1:7fa86e8: 	 * the remaining time in the window will be applied as back-pressure to the
1:7fa86e8: 	 * previous stage, attempting to slow the producer to the expected windowing
1:7fa86e8: 	 * threshold.</li>
1:7fa86e8: 	 * </ul>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param timeSupplier
1:7fa86e8: 	 * @param maxEvents
1:7fa86e8: 	 * @param f
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	<R> PushStream<R> window(Supplier<Duration> timeSupplier,
1:7fa86e8: 			IntSupplier maxEvents, BiFunction<Long,Collection<T>,R> f);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Buffers a number of events over a variable time interval and then
1:7fa86e8: 	 * forwards the events to an accumulator function. The length of time over
1:7fa86e8: 	 * which events are buffered is determined by the time function. A maximum
1:7fa86e8: 	 * number of events can also be requested, if this number of events is
1:7fa86e8: 	 * reached then the accumulator will be called early. The accumulator
1:7fa86e8: 	 * function returns new event data to be forwarded on. It is also given the
1:7fa86e8: 	 * length of time for which the buffer accumulated data. This may be less
1:7fa86e8: 	 * than the requested interval if the buffer reached the maximum number of
1:7fa86e8: 	 * requested events early. Note that:
1:7fa86e8: 	 * <ul>
1:7fa86e8: 	 * <li>The collection forwarded to the accumulator function will be empty if
1:7fa86e8: 	 * no events arrived during the time interval.</li>
1:7fa86e8: 	 * <li>The accumulator function will be run and the forwarded event
1:7fa86e8: 	 * delivered as a different task, (and therefore potentially on a different
1:7fa86e8: 	 * thread) from the one that delivered the event to this {@link PushStream}.
1:7fa86e8: 	 * </li>
1:7fa86e8: 	 * <li>If the window finishes by hitting the maximum number of events then
1:7fa86e8: 	 * the remaining time in the window will be applied as back-pressure to the
1:7fa86e8: 	 * previous stage, attempting to slow the producer to the expected windowing
1:7fa86e8: 	 * threshold.</li>
1:7fa86e8: 	 * </ul>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param timeSupplier
1:7fa86e8: 	 * @param maxEvents
1:7fa86e8: 	 * @param executor
1:7fa86e8: 	 * @param f
1:7fa86e8: 	 * @return Builder style (can be a new or the same object)
1:7fa86e8: 	 */
1:7fa86e8: 	<R> PushStream<R> window(Supplier<Duration> timeSupplier,
1:7fa86e8: 			IntSupplier maxEvents, Executor executor,
1:7fa86e8: 			BiFunction<Long,Collection<T>,R> f);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Execute the action for each event received until the channel is closed.
1:7fa86e8: 	 * This is a terminating method, the returned promise is resolved when the
1:7fa86e8: 	 * channel closes.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param action The action to perform
1:7fa86e8: 	 * @return A promise that is resolved when the channel closes.
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Void> forEach(Consumer< ? super T> action);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Collect the payloads in an Object array after the channel is closed. This
1:7fa86e8: 	 * is a terminating method, the returned promise is resolved when the
1:7fa86e8: 	 * channel is closed.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return A promise that is resolved with all the payloads received over
1:7fa86e8: 	 *         the channel
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Object[]> toArray();
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Collect the payloads in an Object array after the channel is closed. This
1:7fa86e8: 	 * is a terminating method, the returned promise is resolved when the
1:7fa86e8: 	 * channel is closed. The type of the array is handled by the caller using a
1:7fa86e8: 	 * generator function that gets the length of the desired array.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param generator
1:7fa86e8: 	 * @return A promise that is resolved with all the payloads received over
1:7fa86e8: 	 *         the channel
1:7fa86e8: 	 */
1:7fa86e8: 	<A extends T> Promise<A[]> toArray(IntFunction<A[]> generator);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Standard reduce, see Stream. The returned promise will be resolved when
1:7fa86e8: 	 * the channel closes.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param identity The identity/begin value
1:7fa86e8: 	 * @param accumulator The accumulator
1:7fa86e8: 	 * @return A
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<T> reduce(T identity, BinaryOperator<T> accumulator);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Standard reduce without identity, so the return is an Optional. The
1:7fa86e8: 	 * returned promise will be resolved when the channel closes.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param accumulator The accumulator
1:7fa86e8: 	 * @return an Optional
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Optional<T>> reduce(BinaryOperator<T> accumulator);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Standard reduce with identity, accumulator and combiner. The returned
1:7fa86e8: 	 * promise will be resolved when the channel closes.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param identity
1:7fa86e8: 	 * @param accumulator
1:7fa86e8: 	 * @param combiner combines to U's into one U (e.g. how combine two lists)
1:7fa86e8: 	 * @return The promise
1:7fa86e8: 	 */
1:7fa86e8: 	<U> Promise<U> reduce(U identity, BiFunction<U, ? super T,U> accumulator,
1:7fa86e8: 			BinaryOperator<U> combiner);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * See Stream. Will resolve onces the channel closes.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param collector
1:7fa86e8: 	 * @return A Promise representing the collected results
1:7fa86e8: 	 */
1:7fa86e8: 	<R, A> Promise<R> collect(Collector< ? super T,A,R> collector);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * See Stream. Will resolve onces the channel closes.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param comparator
1:7fa86e8: 	 * @return A Promise representing the minimum value, or null if no values
1:7fa86e8: 	 *         are seen before the end of the stream
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Optional<T>> min(Comparator< ? super T> comparator);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * See Stream. Will resolve onces the channel closes.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param comparator
1:7fa86e8: 	 * @return A Promise representing the maximum value, or null if no values
1:7fa86e8: 	 *         are seen before the end of the stream
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Optional<T>> max(Comparator< ? super T> comparator);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * See Stream. Will resolve onces the channel closes.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return A Promise representing the number of values in the stream
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Long> count();
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Close the channel and resolve the promise with true when the predicate
1:7fa86e8: 	 * matches a payload. If the channel is closed before the predicate matches,
1:7fa86e8: 	 * the promise is resolved with false.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>short circuiting terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param predicate
1:7fa86e8: 	 * @return A Promise that will resolve when an event matches the predicate,
1:7fa86e8: 	 *         or the end of the stream is reached
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Boolean> anyMatch(Predicate< ? super T> predicate);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Closes the channel and resolve the promise with false when the predicate
1:7fa86e8: 	 * does not matches a pay load.If the channel is closed before, the promise
1:7fa86e8: 	 * is resolved with true.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>short circuiting terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param predicate
1:7fa86e8: 	 * @return A Promise that will resolve when an event fails to match the
1:7fa86e8: 	 *         predicate, or the end of the stream is reached
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Boolean> allMatch(Predicate< ? super T> predicate);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Closes the channel and resolve the promise with false when the predicate
1:7fa86e8: 	 * matches any pay load. If the channel is closed before, the promise is
1:7fa86e8: 	 * resolved with true.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>short circuiting terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param predicate
1:7fa86e8: 	 * @return A Promise that will resolve when an event matches the predicate,
1:7fa86e8: 	 *         or the end of the stream is reached
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Boolean> noneMatch(Predicate< ? super T> predicate);
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Close the channel and resolve the promise with the first element. If the
1:7fa86e8: 	 * channel is closed before, the Optional will have no value.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return a promise
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Optional<T>> findFirst();
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Close the channel and resolve the promise with the first element. If the
1:7fa86e8: 	 * channel is closed before, the Optional will have no value.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @return a promise
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Optional<T>> findAny();
1:7fa86e8: 
1:7fa86e8: 	/**
1:7fa86e8: 	 * Pass on each event to another consumer until the stream is closed.
1:7fa86e8: 	 * <p>
1:7fa86e8: 	 * This is a <strong>terminal operation</strong>
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param action
1:7fa86e8: 	 * @return a promise
1:7fa86e8: 	 */
1:7fa86e8: 	Promise<Long> forEachEvent(PushEventConsumer< ? super T> action);
1:7fa86e8: 
1:7fa86e8: }
============================================================================
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:7fa86e8
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Copyright (c) OSGi Alliance (2015). All Rights Reserved.
1:  * 
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.osgi.util.pushstream;
1: 
1: import java.time.Duration;
1: import java.util.Collection;
1: import java.util.Comparator;
1: import java.util.Optional;
1: import java.util.concurrent.BlockingQueue;
1: import java.util.concurrent.Executor;
1: import java.util.function.BiFunction;
1: import java.util.function.BinaryOperator;
1: import java.util.function.Consumer;
1: import java.util.function.Function;
1: import java.util.function.IntFunction;
1: import java.util.function.IntSupplier;
1: import java.util.function.Predicate;
1: import java.util.function.Supplier;
1: import java.util.stream.Collector;
1: 
1: import org.osgi.annotation.versioning.ProviderType;
1: import org.osgi.util.promise.Promise;
1: 
1: /**
1:  * A Push Stream fulfills the same role as the Java 8 stream but it reverses the
1:  * control direction. The Java 8 stream is pull based and this is push based. A
1:  * Push Stream makes it possible to build a pipeline of transformations using a
1:  * builder kind of model. Just like streams, it provides a number of terminating
1:  * methods that will actually open the channel and perform the processing until
1:  * the channel is closed (The source sends a Close event). The results of the
1:  * processing will be send to a Promise, just like any error events. A stream
1:  * can be used multiple times. The Push Stream represents a pipeline. Upstream
1:  * is in the direction of the source, downstream is in the direction of the
1:  * terminating method. Events are sent downstream asynchronously with no
1:  * guarantee for ordering or concurrency. Methods are available to provide
1:  * serialization of the events and splitting in background threads.
1:  * 
1:  * @param <T> The Payload type
1:  */
1: @ProviderType
1: public interface PushStream<T> extends AutoCloseable {
1: 
1: 	/**
1: 	 * Must be run after the channel is closed. This handler will run after the
1: 	 * downstream methods have processed the close event and before the upstream
1: 	 * methods have closed.
1: 	 * 
1: 	 * @param closeHandler Will be called on close
1: 	 * @return This stream
1: 	 */
1: 	PushStream<T> onClose(Runnable closeHandler);
1: 
1: 	/**
1: 	 * Must be run after the channel is closed. This handler will run after the
1: 	 * downstream methods have processed the close event and before the upstream
1: 	 * methods have closed.
1: 	 * 
1: 	 * @param closeHandler Will be called on close
1: 	 * @return This stream
1: 	 */
1: 	PushStream<T> onError(Consumer< ? super Throwable> closeHandler);
1: 
1: 	/**
1: 	 * Only pass events downstream when the predicate tests true.
1: 	 * 
1: 	 * @param predicate The predicate that is tested (not null)
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> filter(Predicate< ? super T> predicate);
1: 
1: 	/**
1: 	 * Map a payload value.
1: 	 * 
1: 	 * @param mapper The map function
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	<R> PushStream<R> map(Function< ? super T, ? extends R> mapper);
1: 
1: 	/**
1: 	 * Flat map the payload value (turn one event into 0..n events of
1: 	 * potentially another type).
1: 	 * 
1: 	 * @param mapper The flat map function
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	<R> PushStream<R> flatMap(
1: 			Function< ? super T, ? extends PushStream< ? extends R>> mapper);
1: 
1: 	/**
1: 	 * Remove any duplicates. Notice that this can be expensive in a large
1: 	 * stream since it must track previous payloads.
1: 	 * 
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> distinct();
1: 
1: 	/**
1: 	 * Sorted the elements, assuming that T extends Comparable. This is of
1: 	 * course expensive for large or infinite streams since it requires
1: 	 * buffering the stream until close.
1: 	 * 
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> sorted();
1: 
1: 	/**
1: 	 * Sorted the elements with the given comparator. This is of course
1: 	 * expensive for large or infinite streams since it requires buffering the
1: 	 * stream until close.
1: 	 * 
1: 	 * @param comparator
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> sorted(Comparator< ? super T> comparator);
1: 
1: 	/**
1: 	 * Automatically close the channel after the maxSize number of elements is
1: 	 * received.
1: 	 * 
1: 	 * @param maxSize Maximum number of elements has been received
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> limit(long maxSize);
1: 
1: 	/**
1: 	 * Skip a number of events in the channel.
1: 	 * 
1: 	 * @param n number of elements to skip
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> skip(long n);
1: 
1: 	/**
1: 	 * Execute the downstream events in up to n background threads. If more
1: 	 * requests are outstanding apply delay * nr of delayed threads back
1: 	 * pressure. A downstream channel that is closed or throws an exception will
1: 	 * cause all execution to cease and the stream to close
1: 	 * 
1: 	 * @param n number of simultaneous background threads to use
1: 	 * @param delay Nr of ms/thread that is queued back pressure
1: 	 * @param e an executor to use for the background threads.
1: 	 * @return Builder style (can be a new or the same object)
1: 	 * @throws IllegalArgumentException if the number of threads is < 1 or the
1: 	 *             delay is < 0
1: 	 * @throws NullPointerException if the Executor is null
1: 	 */
1: 	PushStream<T> fork(int n, int delay, Executor e)
1: 			throws IllegalArgumentException, NullPointerException;
1: 
1: 	/**
1: 	 * Buffer the events in a queue using default values for the queue size and
1: 	 * other behaviours. Buffered work will be processed asynchronously in the
1: 	 * rest of the chain. Buffering also blocks the transmission of back
1: 	 * pressure to previous elements in the chain, although back pressure is
1: 	 * honoured by the buffer.
1: 	 * <p>
1: 	 * Buffers are useful for "bursty" event sources which produce a number of
1: 	 * events close together, then none for some time. These bursts can
1: 	 * sometimes overwhelm downstream event consumers. Buffering will not,
1: 	 * however, protect downstream components from a source which produces
1: 	 * events faster than they can be consumed. For fast sources
1: 	 * {@link #filter(Predicate)} and {@link #coalesce(int, Function)}
1: 	 * {@link #fork(int, int, Executor)} are better choices.
1: 	 * 
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> buffer();
1: 
1: 	/**
1: 	 * Build a buffer to enqueue events in a queue using custom values for the
1: 	 * queue size and other behaviours. Buffered work will be processed
1: 	 * asynchronously in the rest of the chain. Buffering also blocks the
1: 	 * transmission of back pressure to previous elements in the chain, although
1: 	 * back pressure is honoured by the buffer.
1: 	 * <p>
1: 	 * Buffers are useful for "bursty" event sources which produce a number of
1: 	 * events close together, then none for some time. These bursts can
1: 	 * sometimes overwhelm downstream event consumers. Buffering will not,
1: 	 * however, protect downstream components from a source which produces
1: 	 * events faster than they can be consumed. For fast sources
1: 	 * {@link #filter(Predicate)} and {@link #coalesce(int, Function)}
1: 	 * {@link #fork(int, int, Executor)} are better choices.
1: 	 * <p>
1: 	 * Buffers are also useful as "circuit breakers" in the pipeline. If a
1: 	 * {@link QueuePolicyOption#FAIL} is used then a full buffer will trigger
1: 	 * the stream to close, preventing an event storm from reaching the client.
1: 	 * 
1: 	 * @param parallelism
1: 	 * @param executor
1: 	 * @param queue
1: 	 * @param queuePolicy
1: 	 * @param pushbackPolicy
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	<U extends BlockingQueue<PushEvent< ? extends T>>> PushStreamBuilder<T,U> buildBuffer();
1: 
1: 	/**
1: 	 * Merge in the events from another source. The resulting channel is not
1: 	 * closed until this channel and the channel from the source are closed.
1: 	 * 
1: 	 * @param source The source to merge in.
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> merge(PushEventSource< ? extends T> source);
1: 
1: 	/**
1: 	 * Merge in the events from another PushStream. The resulting channel is not
1: 	 * closed until this channel and the channel from the source are closed.
1: 	 * 
1: 	 * @param source The source to merge in.
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> merge(PushStream< ? extends T> source);
1: 
1: 	/**
1: 	 * Split the events to different streams based on a predicate. If the
1: 	 * predicate is true, the event is dispatched to that channel on the same
1: 	 * position. All predicates are tested for every event.
1: 	 * <p>
1: 	 * This method differs from other methods of AsyncStream in three
1: 	 * significant ways:
1: 	 * <ul>
1: 	 * <li>The return value contains multiple streams.</li>
1: 	 * <li>This stream will only close when all of these child streams have
1: 	 * closed.</li>
1: 	 * <li>Event delivery is made to all open children that accept the event.
1: 	 * </li>
1: 	 * </ul>
1: 	 * 
1: 	 * @param predicates the predicates to test
1: 	 * @return streams that map to the predicates
1: 	 */
1: 	@SuppressWarnings("unchecked")
1: 	PushStream<T>[] split(Predicate< ? super T>... predicates);
1: 
1: 	/**
1: 	 * Ensure that any events are delivered sequentially. That is, no
1: 	 * overlapping calls downstream. This can be used to turn a forked stream
1: 	 * (where for example a heavy conversion is done in multiple threads) back
1: 	 * into a sequential stream so a reduce is simple to do.
1: 	 * 
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	PushStream<T> sequential();
1: 
1: 	/**
1: 	 * Coalesces a number of events into a new type of event. The input events
1: 	 * are forwarded to a accumulator function. This function returns an
1: 	 * Optional. If the optional is present, it's value is send downstream,
1: 	 * otherwise it is ignored.
1: 	 * 
1: 	 * @param f
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	<R> PushStream<R> coalesce(Function< ? super T,Optional<R>> f);
1: 
1: 	/**
1: 	 * Coalesces a number of events into a new type of event. A fixed number of
1: 	 * input events are forwarded to a accumulator function. This function
1: 	 * returns new event data to be forwarded on.
1: 	 * 
1: 	 * @param count
1: 	 * @param f
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	public <R> PushStream<R> coalesce(int count, Function<Collection<T>,R> f);
1: 
1: 	/**
1: 	 * Coalesces a number of events into a new type of event. A variable number
1: 	 * of input events are forwarded to a accumulator function. The number of
1: 	 * events to be forwarded is determined by calling the count function. The
1: 	 * accumulator function then returns new event data to be forwarded on.
1: 	 * 
1: 	 * @param count
1: 	 * @param f
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	public <R> PushStream<R> coalesce(IntSupplier count,
1: 			Function<Collection<T>,R> f);
1: 
1: 	/**
1: 	 * Buffers a number of events over a fixed time interval and then forwards
1: 	 * the events to an accumulator function. This function returns new event
1: 	 * data to be forwarded on. Note that:
1: 	 * <ul>
1: 	 * <li>The collection forwarded to the accumulator function will be empty if
1: 	 * no events arrived during the time interval.</li>
1: 	 * <li>The accumulator function will be run and the forwarded event
1: 	 * delivered as a different task, (and therefore potentially on a different
1: 	 * thread) from the one that delivered the event to this {@link PushStream}.
1: 	 * </li>
1: 	 * <li>Due to the buffering and asynchronous delivery required, this method
1: 	 * prevents the propagation of back-pressure to earlier stages</li>
1: 	 * </ul>
1: 	 * 
1: 	 * @param d
1: 	 * @param f
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	<R> PushStream<R> window(Duration d, Function<Collection<T>,R> f);
1: 
1: 	/**
1: 	 * Buffers a number of events over a fixed time interval and then forwards
1: 	 * the events to an accumulator function. This function returns new event
1: 	 * data to be forwarded on. Note that:
1: 	 * <ul>
1: 	 * <li>The collection forwarded to the accumulator function will be empty if
1: 	 * no events arrived during the time interval.</li>
1: 	 * <li>The accumulator function will be run and the forwarded event
1: 	 * delivered by a task given to the supplied executor.</li>
1: 	 * <li>Due to the buffering and asynchronous delivery required, this method
1: 	 * prevents the propagation of back-pressure to earlier stages</li>
1: 	 * </ul>
1: 	 * 
1: 	 * @param d
1: 	 * @param executor
1: 	 * @param f
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	<R> PushStream<R> window(Duration d, Executor executor,
1: 			Function<Collection<T>,R> f);
1: 
1: 	/**
1: 	 * Buffers a number of events over a variable time interval and then
1: 	 * forwards the events to an accumulator function. The length of time over
1: 	 * which events are buffered is determined by the time function. A maximum
1: 	 * number of events can also be requested, if this number of events is
1: 	 * reached then the accumulator will be called early. The accumulator
1: 	 * function returns new event data to be forwarded on. It is also given the
1: 	 * length of time for which the buffer accumulated data. This may be less
1: 	 * than the requested interval if the buffer reached the maximum number of
1: 	 * requested events early. Note that:
1: 	 * <ul>
1: 	 * <li>The collection forwarded to the accumulator function will be empty if
1: 	 * no events arrived during the time interval.</li>
1: 	 * <li>The accumulator function will be run and the forwarded event
1: 	 * delivered as a different task, (and therefore potentially on a different
1: 	 * thread) from the one that delivered the event to this {@link PushStream}.
1: 	 * </li>
1: 	 * <li>Due to the buffering and asynchronous delivery required, this method
1: 	 * prevents the propagation of back-pressure to earlier stages</li>
1: 	 * <li>If the window finishes by hitting the maximum number of events then
1: 	 * the remaining time in the window will be applied as back-pressure to the
1: 	 * previous stage, attempting to slow the producer to the expected windowing
1: 	 * threshold.</li>
1: 	 * </ul>
1: 	 * 
1: 	 * @param timeSupplier
1: 	 * @param maxEvents
1: 	 * @param f
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	<R> PushStream<R> window(Supplier<Duration> timeSupplier,
1: 			IntSupplier maxEvents, BiFunction<Long,Collection<T>,R> f);
1: 
1: 	/**
1: 	 * Buffers a number of events over a variable time interval and then
1: 	 * forwards the events to an accumulator function. The length of time over
1: 	 * which events are buffered is determined by the time function. A maximum
1: 	 * number of events can also be requested, if this number of events is
1: 	 * reached then the accumulator will be called early. The accumulator
1: 	 * function returns new event data to be forwarded on. It is also given the
1: 	 * length of time for which the buffer accumulated data. This may be less
1: 	 * than the requested interval if the buffer reached the maximum number of
1: 	 * requested events early. Note that:
1: 	 * <ul>
1: 	 * <li>The collection forwarded to the accumulator function will be empty if
1: 	 * no events arrived during the time interval.</li>
1: 	 * <li>The accumulator function will be run and the forwarded event
1: 	 * delivered as a different task, (and therefore potentially on a different
1: 	 * thread) from the one that delivered the event to this {@link PushStream}.
1: 	 * </li>
1: 	 * <li>If the window finishes by hitting the maximum number of events then
1: 	 * the remaining time in the window will be applied as back-pressure to the
1: 	 * previous stage, attempting to slow the producer to the expected windowing
1: 	 * threshold.</li>
1: 	 * </ul>
1: 	 * 
1: 	 * @param timeSupplier
1: 	 * @param maxEvents
1: 	 * @param executor
1: 	 * @param f
1: 	 * @return Builder style (can be a new or the same object)
1: 	 */
1: 	<R> PushStream<R> window(Supplier<Duration> timeSupplier,
1: 			IntSupplier maxEvents, Executor executor,
1: 			BiFunction<Long,Collection<T>,R> f);
1: 
1: 	/**
1: 	 * Execute the action for each event received until the channel is closed.
1: 	 * This is a terminating method, the returned promise is resolved when the
1: 	 * channel closes.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @param action The action to perform
1: 	 * @return A promise that is resolved when the channel closes.
1: 	 */
1: 	Promise<Void> forEach(Consumer< ? super T> action);
1: 
1: 	/**
1: 	 * Collect the payloads in an Object array after the channel is closed. This
1: 	 * is a terminating method, the returned promise is resolved when the
1: 	 * channel is closed.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @return A promise that is resolved with all the payloads received over
1: 	 *         the channel
1: 	 */
1: 	Promise<Object[]> toArray();
1: 
1: 	/**
1: 	 * Collect the payloads in an Object array after the channel is closed. This
1: 	 * is a terminating method, the returned promise is resolved when the
1: 	 * channel is closed. The type of the array is handled by the caller using a
1: 	 * generator function that gets the length of the desired array.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @param generator
1: 	 * @return A promise that is resolved with all the payloads received over
1: 	 *         the channel
1: 	 */
1: 	<A extends T> Promise<A[]> toArray(IntFunction<A[]> generator);
1: 
1: 	/**
1: 	 * Standard reduce, see Stream. The returned promise will be resolved when
1: 	 * the channel closes.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @param identity The identity/begin value
1: 	 * @param accumulator The accumulator
1: 	 * @return A
1: 	 */
1: 	Promise<T> reduce(T identity, BinaryOperator<T> accumulator);
1: 
1: 	/**
1: 	 * Standard reduce without identity, so the return is an Optional. The
1: 	 * returned promise will be resolved when the channel closes.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @param accumulator The accumulator
1: 	 * @return an Optional
1: 	 */
1: 	Promise<Optional<T>> reduce(BinaryOperator<T> accumulator);
1: 
1: 	/**
1: 	 * Standard reduce with identity, accumulator and combiner. The returned
1: 	 * promise will be resolved when the channel closes.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @param identity
1: 	 * @param accumulator
1: 	 * @param combiner combines to U's into one U (e.g. how combine two lists)
1: 	 * @return The promise
1: 	 */
1: 	<U> Promise<U> reduce(U identity, BiFunction<U, ? super T,U> accumulator,
1: 			BinaryOperator<U> combiner);
1: 
1: 	/**
1: 	 * See Stream. Will resolve onces the channel closes.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @param collector
1: 	 * @return A Promise representing the collected results
1: 	 */
1: 	<R, A> Promise<R> collect(Collector< ? super T,A,R> collector);
1: 
1: 	/**
1: 	 * See Stream. Will resolve onces the channel closes.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @param comparator
1: 	 * @return A Promise representing the minimum value, or null if no values
1: 	 *         are seen before the end of the stream
1: 	 */
1: 	Promise<Optional<T>> min(Comparator< ? super T> comparator);
1: 
1: 	/**
1: 	 * See Stream. Will resolve onces the channel closes.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @param comparator
1: 	 * @return A Promise representing the maximum value, or null if no values
1: 	 *         are seen before the end of the stream
1: 	 */
1: 	Promise<Optional<T>> max(Comparator< ? super T> comparator);
1: 
1: 	/**
1: 	 * See Stream. Will resolve onces the channel closes.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @return A Promise representing the number of values in the stream
1: 	 */
1: 	Promise<Long> count();
1: 
1: 	/**
1: 	 * Close the channel and resolve the promise with true when the predicate
1: 	 * matches a payload. If the channel is closed before the predicate matches,
1: 	 * the promise is resolved with false.
1: 	 * <p>
1: 	 * This is a <strong>short circuiting terminal operation</strong>
1: 	 * 
1: 	 * @param predicate
1: 	 * @return A Promise that will resolve when an event matches the predicate,
1: 	 *         or the end of the stream is reached
1: 	 */
1: 	Promise<Boolean> anyMatch(Predicate< ? super T> predicate);
1: 
1: 	/**
1: 	 * Closes the channel and resolve the promise with false when the predicate
1: 	 * does not matches a pay load.If the channel is closed before, the promise
1: 	 * is resolved with true.
1: 	 * <p>
1: 	 * This is a <strong>short circuiting terminal operation</strong>
1: 	 * 
1: 	 * @param predicate
1: 	 * @return A Promise that will resolve when an event fails to match the
1: 	 *         predicate, or the end of the stream is reached
1: 	 */
1: 	Promise<Boolean> allMatch(Predicate< ? super T> predicate);
1: 
1: 	/**
1: 	 * Closes the channel and resolve the promise with false when the predicate
1: 	 * matches any pay load. If the channel is closed before, the promise is
1: 	 * resolved with true.
1: 	 * <p>
1: 	 * This is a <strong>short circuiting terminal operation</strong>
1: 	 * 
1: 	 * @param predicate
1: 	 * @return A Promise that will resolve when an event matches the predicate,
1: 	 *         or the end of the stream is reached
1: 	 */
1: 	Promise<Boolean> noneMatch(Predicate< ? super T> predicate);
1: 
1: 	/**
1: 	 * Close the channel and resolve the promise with the first element. If the
1: 	 * channel is closed before, the Optional will have no value.
1: 	 * 
1: 	 * @return a promise
1: 	 */
1: 	Promise<Optional<T>> findFirst();
1: 
1: 	/**
1: 	 * Close the channel and resolve the promise with the first element. If the
1: 	 * channel is closed before, the Optional will have no value.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @return a promise
1: 	 */
1: 	Promise<Optional<T>> findAny();
1: 
1: 	/**
1: 	 * Pass on each event to another consumer until the stream is closed.
1: 	 * <p>
1: 	 * This is a <strong>terminal operation</strong>
1: 	 * 
1: 	 * @param action
1: 	 * @return a promise
1: 	 */
1: 	Promise<Long> forEachEvent(PushEventConsumer< ? super T> action);
1: 
1: }
============================================================================