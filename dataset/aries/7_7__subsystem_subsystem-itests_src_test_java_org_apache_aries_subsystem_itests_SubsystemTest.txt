1:4717af0: /*
1:4717af0:  * Licensed under the Apache License, Version 2.0 (the "License");
1:4717af0:  * you may not use this file except in compliance with the License.
1:4717af0:  * You may obtain a copy of the License at
1:4717af0:  *
1:4717af0:  *      http://www.apache.org/licenses/LICENSE-2.0
1:4717af0:  *
1:4717af0:  * Unless required by applicable law or agreed to in writing, software
1:4717af0:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4717af0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4717af0:  * See the License for the specific language governing permissions and
1:4717af0:  * limitations under the License.
1:4717af0:  */
1:e8a0b01: package org.apache.aries.subsystem.itests;
10:e8a0b01: 
1:e8a0b01: import static org.junit.Assert.assertEquals;
1:e8a0b01: import static org.junit.Assert.assertFalse;
1:e8a0b01: import static org.junit.Assert.assertNotNull;
1:875a6d6: import static org.junit.Assert.assertNull;
1:e8a0b01: import static org.junit.Assert.assertTrue;
1:1c9c28b: import static org.junit.Assert.fail;
1:57b6627: import static org.ops4j.pax.exam.CoreOptions.composite;
1:57b6627: import static org.ops4j.pax.exam.CoreOptions.junitBundles;
1:57b6627: import static org.ops4j.pax.exam.CoreOptions.mavenBundle;
1:57b6627: import static org.ops4j.pax.exam.CoreOptions.streamBundle;
1:e8a0b01: import static org.ops4j.pax.exam.CoreOptions.systemProperty;
1:57b6627: import static org.ops4j.pax.exam.CoreOptions.vmOption;
1:57b6627: import static org.ops4j.pax.exam.CoreOptions.when;
1:d299aa1: 
1:e8a0b01: import java.io.File;
1:deca8ed: import java.io.FileInputStream;
1:deca8ed: import java.io.FileNotFoundException;
1:deca8ed: import java.io.FileOutputStream;
1:deca8ed: import java.io.IOException;
1:e8a0b01: import java.io.InputStream;
1:1c9c28b: import java.lang.reflect.Field;
1:a990e32: import java.lang.reflect.Method;
1:e8a0b01: import java.net.URL;
1:e8a0b01: import java.util.ArrayList;
1:e8a0b01: import java.util.Collection;
1:a6b79e8: import java.util.Collections;
1:e8a0b01: import java.util.EnumSet;
1:4717af0: import java.util.HashMap;
1:e8a0b01: import java.util.List;
1:4717af0: import java.util.Map;
1:7e004f1: import java.util.Map.Entry;
1:a990e32: import java.util.Set;
1:4b2d185: import java.util.concurrent.atomic.AtomicBoolean;
1:0c3bb10: 
1:57b6627: import org.apache.aries.itest.AbstractIntegrationTest;
1:57b6627: import org.apache.aries.itest.RichBundleContext;
1:5bd3bf6: import org.apache.aries.subsystem.AriesSubsystem;
1:a990e32: import org.apache.aries.subsystem.core.archive.AriesProvisionDependenciesDirective;
1:875a6d6: import org.apache.aries.subsystem.core.archive.ProvisionPolicyDirective;
1:875a6d6: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
1:7c69962: import org.apache.aries.subsystem.core.archive.TypeAttribute;
1:a990e32: import org.apache.aries.subsystem.core.internal.BasicSubsystem;
1:67ef08f: import org.apache.aries.subsystem.core.internal.BundleResource;
1:95f6444: import org.apache.aries.subsystem.core.internal.SubsystemIdentifier;
1:875a6d6: import org.apache.aries.subsystem.itests.util.TestRepository;
1:e6bf465: import org.apache.aries.subsystem.itests.util.Utils;
1:deca8ed: import org.apache.aries.unittest.fixture.ArchiveFixture;
1:7e004f1: import org.apache.aries.unittest.fixture.ArchiveFixture.JarFixture;
1:7e004f1: import org.apache.aries.unittest.fixture.ArchiveFixture.ManifestFixture;
1:7e004f1: import org.apache.aries.unittest.fixture.ArchiveFixture.ZipFixture;
1:47cea41: import org.apache.aries.util.filesystem.FileSystem;
1:8481849: import org.eclipse.equinox.region.Region;
1:8481849: import org.eclipse.equinox.region.RegionDigraph;
1:57b6627: import org.junit.After;
1:57b6627: import org.junit.Before;
1:57b6627: import org.junit.runner.RunWith;
1:7c69962: import org.ops4j.io.StreamUtils;
1:57b6627: import org.ops4j.pax.exam.Configuration;
1:7112947: import org.ops4j.pax.exam.CoreOptions;
1:e8a0b01: import org.ops4j.pax.exam.Option;
1:57b6627: import org.ops4j.pax.exam.junit.PaxExam;
1:57b6627: import org.ops4j.pax.exam.spi.reactors.ExamReactorStrategy;
1:57b6627: import org.ops4j.pax.exam.spi.reactors.PerClass;
1:7c69962: import org.ops4j.pax.tinybundles.core.TinyBundles;
1:e8a0b01: import org.osgi.framework.Bundle;
1:5725f09: import org.osgi.framework.BundleContext;
1:deca8ed: import org.osgi.framework.BundleException;
1:1c9c28b: import org.osgi.framework.Constants;
1:4b2d185: import org.osgi.framework.FrameworkEvent;
1:4b2d185: import org.osgi.framework.FrameworkListener;
1:1c9c28b: import org.osgi.framework.InvalidSyntaxException;
1:1c9c28b: import org.osgi.framework.ServiceEvent;
1:e8a0b01: import org.osgi.framework.ServiceRegistration;
1:e8a0b01: import org.osgi.framework.Version;
1:a1c6951: import org.osgi.framework.namespace.IdentityNamespace;
1:590cf45: import org.osgi.framework.startlevel.BundleStartLevel;
1:590cf45: import org.osgi.framework.startlevel.FrameworkStartLevel;
1:391a1aa: import org.osgi.framework.wiring.BundleRevision;
1:4b2d185: import org.osgi.framework.wiring.FrameworkWiring;
1:7c69962: import org.osgi.resource.Capability;
1:71fe81a: import org.osgi.resource.Resource;
1:e6bf465: import org.osgi.service.repository.Repository;
1:e8a0b01: import org.osgi.service.subsystem.Subsystem;
1:e8a0b01: import org.osgi.service.subsystem.Subsystem.State;
1:e8a0b01: import org.osgi.service.subsystem.SubsystemConstants;
1:e8a0b01: 
1:57b6627: @RunWith(PaxExam.class)
1:57b6627: @ExamReactorStrategy(PerClass.class)
1:57b6627: public abstract class SubsystemTest extends AbstractIntegrationTest {
1:7c69962: 	private static final String SUBSYSTEM_CORE_NAME = "org.apache.aries.subsystem.core";
1:7c69962:     protected static boolean createdApplications = false;
1:57b6627: 	boolean installModeler = true;
1:79b20bc:     boolean installConfigAdmin = false;
1:e8a0b01: 
1:57b6627: 	public SubsystemTest() {
1:d299aa1: 	}
1:69fd7d4: 
1:57b6627: 	public SubsystemTest(boolean installModeller) {
1:57b6627: 		this.installModeler = installModeller;
1:391a1aa: 	}
1:f334800: 
1:57b6627: 	public Option baseOptions() {
1:57b6627:         String localRepo = getLocalRepo();
1:57b6627:         return composite(
1:57b6627:                 junitBundles(),
1:1c9c28b:                 // this is how you set the default log level when using pax
1:1c9c28b:                 // logging (logProfile)
1:1c9c28b:                 systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("INFO"),
1:57b6627:                 when(localRepo != null).useOptions(vmOption("-Dorg.ops4j.pax.url.mvn.localRepository=" + localRepo))
1:57b6627:          );
1:7e004f1:     }
1:391a1aa: 
1:57b6627: 	@Configuration
1:57b6627: 	public Option[] configuration() throws Exception {
1:7c69962: 	    new File("target").mkdirs();
1:7c69962: 	    init();
1:b6ac132: 		return new Option[] {
1:57b6627: 				baseOptions(),
1:1c9c28b: 				systemProperty("org.osgi.framework.bsnversion").value("multiple"),
1:1c027e7: 				systemProperty("org.osgi.framework.storage.clean").value("onFirstInit"),
1:e8a0b01: 				// Bundles
1:a6a8290: 				mavenBundle("org.apache.aries",             "org.apache.aries.util").versionAsInProject(),
1:a6a8290: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils").versionAsInProject(),
1:57b6627: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.api").versionAsInProject(),
1:7c69962: 				when(installModeler).useOptions(modelerBundles()),
1:79b20bc:                 when(installConfigAdmin).useOptions(
1:79b20bc:                         mavenBundle("org.apache.felix",     "org.apache.felix.configadmin").versionAsInProject()),
1:a6a8290: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.api").versionAsInProject(),
1:7c69962: 				mavenBundle("org.apache.aries.subsystem",   SUBSYSTEM_CORE_NAME).versionAsInProject(),
1:7c69962: 				streamBundle(createCoreFragment()).noStart(),
1:a6a8290: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.itest.interfaces").versionAsInProject(),
1:a6a8290: 				mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit").versionAsInProject(),
1:d6eb080: 				//mavenBundle("org.apache.felix",             "org.apache.felix.resolver").versionAsInProject(),
1:b75f264: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.coordinator").version("1.1.0.v20120522-1841"),
1:57b6627: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.event").versionAsInProject(),
1:b75f264: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.region").version("1.1.0.v20120522-1841"),
1:e1a1f0d: 				mavenBundle("org.osgi",                     "org.osgi.enterprise").versionAsInProject(),
1:5bd3bf6: 				mavenBundle("org.easymock",					"easymock").versionAsInProject(),
1:e1a1f0d:                 mavenBundle("org.ops4j.pax.logging",        "pax-logging-api").versionAsInProject(),
1:e1a1f0d:                 mavenBundle("org.ops4j.pax.logging",        "pax-logging-service").versionAsInProject(),
1:a85c505:                 mavenBundle("org.ops4j.pax.tinybundles",    "tinybundles").versionAsInProject(),
1:a85c505:                 mavenBundle("biz.aQute.bnd",                "bndlib").versionAsInProject(),
1:6ebbd4c:                 mavenBundle("org.apache.aries.subsystem",	"org.apache.aries.subsystem.obr").versionAsInProject(),
1:6ebbd4c:                 mavenBundle("org.apache.felix",				"org.apache.felix.bundlerepository").versionAsInProject(),	
1:8481849: //				org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=7777"),
1:b6ac132: 		};
1:b6ac132: 	}
1:b6ac132: 
1:7c69962:     protected void init() throws Exception {
1:a990e32: 
1:deca8ed:     }
1:7e004f1:     
1:a990e32:     protected long lastSubsystemId() throws Exception {
1:a990e32:     	Method method = SubsystemIdentifier.class.getDeclaredMethod("getLastId");
1:a990e32:     	method.setAccessible(true);
1:a990e32:     	return (Long)method.invoke(null);
1:a990e32:     }
1:deca8ed: 
1:7c69962:     private Option modelerBundles() {
1:7c69962:         return CoreOptions.composite(
1:7c69962:         		mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller").versionAsInProject(),
1:7c69962:         		mavenBundle("org.apache.aries.blueprint",   "org.apache.aries.blueprint").versionAsInProject(),
1:7c69962:         		mavenBundle("org.apache.aries.proxy",       "org.apache.aries.proxy").versionAsInProject());
1:fc759fb:     }
1:deca8ed: 
1:7c69962:     /**
1:7c69962:      * The itests need private packages from the core subsystems bundle.
1:7c69962:      * So this fragment exports them.
1:79b20bc:      * @return stream containing the fragment
1:7c69962:      */
1:7c69962:     private InputStream createCoreFragment() {
1:7c69962: 	return TinyBundles.bundle()
1:7c69962: 	    .set("Bundle-SymbolicName", SUBSYSTEM_CORE_NAME + ".fragment")
1:7c69962: 	    .set("Export-Package", "org.apache.aries.subsystem.core.internal,org.apache.aries.subsystem.core.archive")
1:7c69962: 	    .set("Fragment-Host", SUBSYSTEM_CORE_NAME)
1:7c69962: 	    .build();
1:fc759fb:     }
1:d299aa1: 
1:0c3bb10: 	protected final SubsystemEventHandler subsystemEvents = new SubsystemEventHandler();
1:d299aa1: 
1:7c69962: 	@SuppressWarnings("rawtypes")
1:7c69962:     protected Collection<ServiceRegistration> serviceRegistrations = new ArrayList<ServiceRegistration>();
1:1c027e7: 
1:afe81b7: 	protected final List<Region> deletableRegions = Collections.synchronizedList(new ArrayList<Region>());
1:afe81b7: 	protected final List<Subsystem> stoppableSubsystems = Collections.synchronizedList(new ArrayList<Subsystem>());
1:afe81b7: 	protected final List<Bundle> uninstallableBundles = Collections.synchronizedList(new ArrayList<Bundle>());
1:afe81b7:     protected final List<Subsystem> uninstallableSubsystems = Collections.synchronizedList(new ArrayList<Subsystem>());
1:d299aa1: 	
1:57b6627: 	@Before
1:875a6d6: 	public void setUp() throws Exception {
1:afe81b7: 		serviceRegistrations.clear();
1:1c027e7: 		deletableRegions.clear();
1:1c027e7: 		stoppableSubsystems.clear();
1:1c027e7: 		uninstallableBundles.clear();
1:1c027e7:         uninstallableSubsystems.clear();
1:57b6627: 		if (!createdApplications) {
1:57b6627: 			createApplications();
1:57b6627: 			createdApplications = true;
1:d299aa1: 		}
1:d299aa1: 		bundleContext.getBundle(0).getBundleContext().addServiceListener(subsystemEvents, '(' + Constants.OBJECTCLASS + '=' + Subsystem.class.getName() + ')');
1:d299aa1: 	}
1:1c027e7: 	
1:7c69962: 	@SuppressWarnings("rawtypes")
1:7c69962:     @After
1:79b20bc: 	public void tearDown() throws Exception
1:69d4847: 	{
1:1c027e7: 		for (Subsystem subsystem : stoppableSubsystems) {
1:1c027e7: 			stopSubsystemSilently(subsystem);
1:1c027e7: 		}
1:1c027e7: 		for (Subsystem subsystem : uninstallableSubsystems) {
1:1c027e7: 			uninstallSubsystemSilently(subsystem);
1:1c027e7: 		}
1:1c027e7: 		RegionDigraph digraph = context().getService(RegionDigraph.class);
1:1c027e7: 		for (Region region : deletableRegions) {
1:1c027e7: 			digraph.removeRegion(region);
1:1c027e7: 		}
1:1c027e7: 		for (Bundle bundle : uninstallableBundles) {
1:1c027e7: 			uninstallSilently(bundle);
1:1c027e7: 		}
1:1c9c28b: 		bundleContext.removeServiceListener(subsystemEvents);
1:11d09f4: 		for (ServiceRegistration registration : serviceRegistrations)
1:1c9c28b: 			Utils.unregisterQuietly(registration);
1:d299aa1: 	}
1:d299aa1: 
1:1c027e7: 	protected void createApplications() throws Exception {
1:1c027e7: 	}
1:1c027e7: 
1:57b6627: 	protected RichBundleContext context(Subsystem subsystem) {
1:57b6627: 		return new RichBundleContext(subsystem.getBundleContext());
1:d299aa1: 	}
1:d299aa1: 
1:27f76f6: 	protected void assertEmptySubsystem(Subsystem subsystem) {
1:27f76f6:     	assertSymbolicName("org.apache.aries.subsystem.itests.subsystem.empty", subsystem);
1:27f76f6:     	assertVersion("0", subsystem);
1:27f76f6:     	assertType(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, subsystem);
1:27f76f6:     }
1:27f76f6: 
1:fc759fb: 	protected void assertBundleState(int state, String symbolicName, Subsystem subsystem) {
1:57b6627:     	Bundle bundle = context(subsystem).getBundleByName(symbolicName);
1:9f94bb4:     	assertNotNull("Bundle not found: " + symbolicName, bundle);
1:df175a6:     	assertBundleState(bundle, state);
1:fc759fb:     }
1:fc759fb: 
1:df175a6: 	protected void assertBundleState(Bundle bundle, int state) {
1:df175a6: 		assertTrue("Wrong state: " + bundle + " [expected " + state + " but was " + bundle.getState() + "]", (bundle.getState() & state) != 0);
1:df175a6: 	}
1:df175a6: 
1:4b2d185: 	protected Subsystem assertChild(Subsystem parent, String symbolicName) {
1:4b2d185: 		return assertChild(parent, symbolicName, null, null);
1:4b2d185: 	}
1:4b2d185: 
1:4b2d185: 	protected Subsystem assertChild(Subsystem parent, String symbolicName, Version version) {
1:4b2d185: 		return assertChild(parent, symbolicName, version, null);
1:4b2d185: 	}
1:4b2d185: 
1:4b2d185: 	protected Subsystem assertChild(Subsystem parent, String symbolicName, Version version, String type) {
1:4b2d185: 		Subsystem result = getChild(parent, symbolicName, version, type);
1:4b2d185: 		assertNotNull("Child does not exist: " + symbolicName, result);
1:4b2d185: 		return result;
1:4b2d185: 	}
1:4b2d185: 
1:e8a0b01: 	protected void assertChild(Subsystem parent, Subsystem child) {
1:e8a0b01: 		Collection<Subsystem> children = new ArrayList<Subsystem>(1);
1:e8a0b01: 		children.add(child);
1:e8a0b01: 		assertChildren(parent, children);
1:d299aa1: 	}
1:d299aa1: 
1:4717af0: 	protected void assertChildren(int size, Subsystem subsystem) {
1:4717af0: 		assertEquals("Wrong number of children", size, subsystem.getChildren().size());
1:d299aa1: 	}
1:d299aa1: 
1:e8a0b01: 	protected void assertChildren(Subsystem parent, Collection<Subsystem> children) {
1:e8a0b01: 		assertTrue("Parent did not contain all children", parent.getChildren().containsAll(children));
1:d299aa1: 	}
1:1c9c28b: 
1:47cea41: 	protected void assertClassLoadable(String clazz, Bundle bundle) {
1:47cea41: 		try {
1:47cea41: 			bundle.loadClass(clazz);
1:47cea41: 		}
1:47cea41: 		catch (Exception e) {
1:47cea41: 			e.printStackTrace();
1:47cea41: 			fail("Class " + clazz + " from bundle " + bundle + " should be loadable");
1:47cea41: 		}
1:47cea41: 	}
1:47cea41: 
1:875a6d6: 	protected void assertConstituent(Subsystem subsystem, String symbolicName) {
1:875a6d6: 		assertConstituent(subsystem, symbolicName, Version.emptyVersion);
1:875a6d6: 	}
1:875a6d6: 
1:875a6d6: 	protected void assertConstituent(Subsystem subsystem, String symbolicName, Version version) {
1:875a6d6: 		assertConstituent(subsystem, symbolicName, version, IdentityNamespace.TYPE_BUNDLE);
1:875a6d6: 	}
1:875a6d6: 
1:3b4e485: 	protected void assertConstituent(Subsystem subsystem, String symbolicName, String type) {
1:875a6d6: 		assertConstituent(subsystem, symbolicName, Version.emptyVersion, type);
1:875a6d6: 	}
1:875a6d6: 
1:b75f264: 	protected Resource assertConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
1:875a6d6: 		Resource constituent = getConstituent(subsystem, symbolicName, version, type);
1:875a6d6: 		assertNotNull("Constituent not found: " + symbolicName + ';' + version + ';' + type, constituent);
1:b75f264: 		return constituent;
1:1c9c28b: 	}
1:0c3bb10: 
1:e8a0b01: 	protected void assertConstituents(int size, Subsystem subsystem) {
1:e8a0b01: 		assertEquals("Wrong number of constituents", size, subsystem.getConstituents().size());
1:1c9c28b: 	}
1:4717af0: 
1:d299aa1:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state) throws InterruptedException {
1:d299aa1:  		assertEvent(subsystem, state, 0);
1:d299aa1:  	}
1:d299aa1: 
1:d299aa1:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, long timeout) throws InterruptedException {
1:d299aa1:  		assertEvent(subsystem, state, subsystemEvents.poll(subsystem.getSubsystemId(), timeout));
1:d299aa1:  	}
1:d299aa1:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemEventHandler.ServiceEventInfo event) {
1:d299aa1:  		if (State.INSTALLING.equals(state))
1:d299aa1: 			assertEvent(subsystem, state, event, ServiceEvent.REGISTERED);
1:d299aa1:  		else
1:d299aa1:  			assertEvent(subsystem, state, event, ServiceEvent.MODIFIED);
1:d299aa1:  	}
1:d299aa1: 
1:d299aa1: 	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemEventHandler.ServiceEventInfo event, int type) {
1:a990e32: 		assertEvent(subsystem.getSubsystemId(), subsystem.getSymbolicName(), 
1:a990e32: 				subsystem.getVersion(), subsystem.getType(), state, event, type);
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	protected void assertEvent(
1:a990e32: 			long id, 
1:a990e32: 			String symbolicName, 
1:a990e32: 			Version version, 
1:a990e32: 			String type, 
1:a990e32: 			Subsystem.State state,
1:a990e32: 			SubsystemEventHandler.ServiceEventInfo event,
1:a990e32: 			int eventType) {
1:d299aa1: 		// TODO Could accept a ServiceRegistration as an argument and verify it against the one in the event.
1:777b216: 		assertNotNull("No event", event);
1:a990e32: 		assertEquals("Wrong ID", id, event.getId());
1:a990e32: 		assertEquals("Wrong symbolic name", symbolicName, event.getSymbolicName());
1:a990e32: 		assertEquals("Wrong version", version, event.getVersion());
1:a990e32: 		assertEquals("Wrong type", type, event.getType());
1:d299aa1: 		assertEquals("Wrong state", state, event.getState());
1:a990e32: 		assertEquals("Wrong event type", eventType, event.getEventType());
1:d299aa1: 	}
1:4717af0: 
1:b75f264: 	protected String assertHeaderExists(Subsystem subsystem, String name) {
1:b75f264: 		String header = subsystem.getSubsystemHeaders(null).get(name);
1:b75f264: 		assertNotNull("Missing header: " + name, header);
1:b75f264: 		return header;
1:1c9c28b: 	}
1:4717af0: 
1:e8a0b01: 	protected void assertId(Subsystem subsystem) {
1:e8a0b01: 		assertId(subsystem.getSubsystemId());
1:1c9c28b: 	}
1:4717af0: 
1:e8a0b01: 	protected void assertId(Long id) {
1:e8a0b01: 		assertTrue("Subsystem ID was not a positive integer: " + id, id > 0);
1:1c9c28b: 	}
1:4717af0: 
1:71ee087: 	protected void assertLastId(long id) throws Exception {
1:1c9c28b: 		Subsystem root = getRootSubsystem();
1:95f6444: 		Field lastId = SubsystemIdentifier.class.getDeclaredField("lastId");
1:1c9c28b: 		lastId.setAccessible(true);
1:95f6444: 		assertEquals("Wrong lastId", id, lastId.getLong(root));
1:1c9c28b: 	}
1:1c9c28b: 
1:71ee087: 	protected void resetLastId() throws Exception {
1:71ee087: 		Field lastId = SubsystemIdentifier.class.getDeclaredField("lastId");
1:71ee087: 		lastId.setAccessible(true);
1:71ee087: 		lastId.setInt(SubsystemIdentifier.class, 0);
1:71ee087: 	}
1:71ee087: 
1:e8a0b01: 	protected void assertLocation(String expected, String actual) {
1:e8a0b01: 		assertTrue("Wrong location: " + actual, actual.indexOf(expected) != -1);
1:1c9c28b: 	}
1:e8a0b01: 
1:e8a0b01: 	protected void assertLocation(String expected, Subsystem subsystem) {
1:e8a0b01: 		assertLocation(expected, subsystem.getLocation());
1:4717af0: 	}
1:e8a0b01: 
1:e8a0b01: 	protected void assertNotChild(Subsystem parent, Subsystem child) {
1:e8a0b01: 		assertFalse("Parent contained child", parent.getChildren().contains(child));
1:4717af0: 	}
1:e8a0b01: 
1:875a6d6: 	protected void assertNotConstituent(Subsystem subsystem, String symbolicName) {
1:875a6d6: 		assertNotConstituent(subsystem, symbolicName, Version.emptyVersion, IdentityNamespace.TYPE_BUNDLE);
1:875a6d6: 	}
1:875a6d6: 
1:875a6d6: 	protected void assertNotConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
1:875a6d6: 		Resource constituent = getConstituent(subsystem, symbolicName, version, type);
1:875a6d6: 		assertNull("Constituent found: " + symbolicName + ';' + version + ';' + type, constituent);
1:875a6d6: 	}
1:875a6d6: 
1:e8a0b01: 	protected void assertParent(Subsystem expected, Subsystem subsystem) {
1:1c9c28b: 		for (Subsystem parent : subsystem.getParents()) {
1:1c9c28b: 			if (parent.equals(expected))
1:1c9c28b: 				return;
1:1c9c28b: 
1:1c9c28b: 		}
1:1c9c28b: 		fail("Parent did not exist: " + expected.getSymbolicName());
1:4717af0: 	}
1:e8a0b01: 
1:875a6d6: 	protected void assertProvisionPolicy(Subsystem subsystem, boolean acceptsDependencies) {
1:875a6d6: 		String headerStr = subsystem.getSubsystemHeaders(null).get(SubsystemConstants.SUBSYSTEM_TYPE);
1:875a6d6: 		assertNotNull("Missing subsystem type header", headerStr);
1:875a6d6: 		SubsystemTypeHeader header = new SubsystemTypeHeader(headerStr);
1:875a6d6: 		ProvisionPolicyDirective directive = header.getProvisionPolicyDirective();
1:875a6d6: 		if (acceptsDependencies)
1:875a6d6: 			assertTrue("Subsystem does not accept dependencies", directive.isAcceptDependencies());
1:875a6d6: 		else
1:875a6d6: 			assertTrue("Subsystem accepts dependencies", directive.isRejectDependencies());
1:875a6d6: 	}
1:875a6d6: 
1:4b2d185: 	protected void assertRefresh(Collection<Bundle> bundles) throws InterruptedException {
1:4b2d185: 		FrameworkWiring wiring = getSystemBundleAsFrameworkWiring();
1:4b2d185: 		final AtomicBoolean refreshed = new AtomicBoolean(false);
1:11d09f4: 		wiring.refreshBundles(bundles, new FrameworkListener[]{ new FrameworkListener() {
1:4b2d185: 			@Override
1:4b2d185: 			public void frameworkEvent(FrameworkEvent event) {
1:4b2d185: 				if (FrameworkEvent.PACKAGES_REFRESHED == event.getType()) {
1:4b2d185: 					synchronized (refreshed) {
1:4b2d185: 						refreshed.set(true);
1:4b2d185: 						refreshed.notify();
1:4b2d185: 					}
1:4b2d185: 				}
1:4b2d185: 			}
1:11d09f4: 		}});
1:4b2d185: 		synchronized (refreshed) {
1:4b2d185: 			refreshed.wait(5000);
1:4b2d185: 		}
1:4b2d185: 		assertTrue("Bundles not refreshed", refreshed.get());
1:4b2d185: 	}
1:4b2d185: 
1:4b2d185: 	protected void assertRefreshAndResolve(Collection<Bundle> bundles) throws InterruptedException {
1:4b2d185: 		assertRefresh(bundles);
1:4b2d185: 		assertResolve(bundles);
1:4b2d185: 	}
1:4b2d185: 
1:5725f09: 	protected void assertRegionContextBundle(Subsystem s) {
1:f1ff8f8: 		Bundle b = getRegionContextBundle(s);
1:5725f09: 		assertEquals("Not active", Bundle.ACTIVE, b.getState());
1:5725f09: 		assertEquals("Wrong location", s.getLocation() + '/' + s.getSubsystemId(), b.getLocation());
1:5725f09: 		assertEquals("Wrong symbolic name", "org.osgi.service.subsystem.region.context." + s.getSubsystemId(), b.getSymbolicName());
1:5725f09: 		assertEquals("Wrong version", Version.parseVersion("1.0.0"), b.getVersion());
1:a1c6951: 		assertConstituent(s, "org.osgi.service.subsystem.region.context." + s.getSubsystemId(), Version.parseVersion("1.0.0"), IdentityNamespace.TYPE_BUNDLE);
1:5725f09: 	}
1:5725f09: 
1:4b2d185: 	protected void assertResolve(Collection<Bundle> bundles) {
1:4b2d185: 		FrameworkWiring wiring = getSystemBundleAsFrameworkWiring();
1:4b2d185: 		assertTrue("Bundles not resolved", wiring.resolveBundles(bundles));
1:4b2d185: 	}
1:4b2d185: 
1:bda6868: 	protected void assertServiceEventsInstall(Subsystem subsystem) throws InterruptedException {
1:bda6868: 		assertEvent(subsystem, Subsystem.State.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:bda6868: 		assertEvent(subsystem, Subsystem.State.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:bda6868: 	}
1:bda6868: 
1:bda6868: 	protected void assertServiceEventsResolve(Subsystem subsystem) throws InterruptedException {
1:bda6868: 		assertEvent(subsystem, Subsystem.State.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:391a1aa: 		assertServiceEventResolved(subsystem, ServiceEvent.MODIFIED);
1:bda6868: 	}
1:bda6868: 
1:bda6868: 	protected void assertServiceEventsStart(Subsystem subsystem) throws InterruptedException {
1:bda6868: 		assertEvent(subsystem, Subsystem.State.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:bda6868: 		assertEvent(subsystem, Subsystem.State.ACTIVE, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:bda6868: 	}
1:bda6868: 
1:bda6868: 	protected void assertServiceEventsStop(Subsystem subsystem) throws InterruptedException {
1:bda6868: 		assertEvent(subsystem, Subsystem.State.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:391a1aa: 		assertServiceEventResolved(subsystem, ServiceEvent.MODIFIED);
1:bda6868: 		// Don't forget about the unregistering event, which will have the same state as before.
1:391a1aa: 		assertServiceEventResolved(subsystem, ServiceEvent.UNREGISTERING);
1:391a1aa: 	}
1:391a1aa: 
1:391a1aa: 	protected void assertServiceEventResolved(Subsystem subsystem, int type) throws InterruptedException {
1:391a1aa: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000), type);
1:bda6868: 	}
1:bda6868: 
1:590cf45: 	protected void assertStartLevel(Bundle bundle, int expected) {
1:57b6627: 		assertNotNull("Bundle is null", bundle);
1:590cf45: 		assertEquals("Wrong start level", expected, bundle.adapt(BundleStartLevel.class).getStartLevel());
1:590cf45: 	}
1:590cf45: 
1:e8a0b01: 	protected void assertState(State expected, State actual) {
1:e8a0b01: 		assertState(EnumSet.of(expected), actual);
1:4717af0: 	}
1:e8a0b01: 
1:e8a0b01: 	protected void assertState(EnumSet<State> expected, State actual) {
1:7837a59: 		assertTrue("Wrong state: expected=" + expected + ", actual=" + actual, expected.contains(actual));
1:4717af0: 	}
1:e8a0b01: 
1:e8a0b01: 	protected void assertState(State expected, Subsystem subsystem) {
1:e8a0b01: 		assertState(expected, subsystem.getState());
1:4717af0: 	}
1:e8a0b01: 
1:e8a0b01: 	protected void assertState(EnumSet<State> expected, Subsystem subsystem) {
1:e8a0b01: 		assertState(expected, subsystem.getState());
1:4717af0: 	}
1:e8a0b01: 
1:e8a0b01: 	protected Subsystem assertSubsystemLifeCycle(File file) throws Exception {
1:57b6627: 		Subsystem rootSubsystem = context().getService(Subsystem.class);
1:e8a0b01:         assertNotNull("Root subsystem was null", rootSubsystem);
1:e8a0b01:         Subsystem subsystem = rootSubsystem.install(file.toURI().toURL().toExternalForm());
1:e8a0b01:         assertNotNull("The subsystem was null", subsystem);
1:e8a0b01:         assertState(EnumSet.of(State.INSTALLING, State.INSTALLED), subsystem.getState());
1:d299aa1: 		assertEvent(subsystem, Subsystem.State.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:d299aa1: 		assertEvent(subsystem, Subsystem.State.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:e8a0b01: 		assertChild(rootSubsystem, subsystem);
1:e8a0b01:         subsystem.start();
1:e8a0b01:         assertState(EnumSet.of(State.RESOLVING, State.RESOLVED, State.STARTING, State.ACTIVE), subsystem.getState());
1:d299aa1: 		assertEvent(subsystem, Subsystem.State.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:bda6868: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:d299aa1: 		assertEvent(subsystem, Subsystem.State.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:d299aa1: 		assertEvent(subsystem, Subsystem.State.ACTIVE, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:e8a0b01: 		subsystem.stop();
1:e8a0b01: 		assertState(EnumSet.of(State.STOPPING, State.RESOLVED), subsystem.getState());
1:d299aa1: 		assertEvent(subsystem, Subsystem.State.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:bda6868: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:e8a0b01: 		subsystem.uninstall();
1:e8a0b01: 		assertState(EnumSet.of(State.UNINSTALLING, State.UNINSTALLED), subsystem.getState());
1:d299aa1: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1:d299aa1: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
2:e8a0b01: 		assertNotChild(rootSubsystem, subsystem);
2:e8a0b01: 		return subsystem;
1:4717af0: 	}
1:e8a0b01: 
1:e8a0b01: 	protected void assertSubsystemNotNull(Subsystem subsystem) {
1:e8a0b01: 		assertNotNull("Subsystem was null", subsystem);
1:4717af0: 	}
1:e8a0b01: 
1:e8a0b01: 	protected void assertSymbolicName(String expected, Subsystem subsystem) {
1:4fd3b7f: 		assertSymbolicName(expected, subsystem.getSymbolicName());
1:4fd3b7f: 	}
1:4fd3b7f: 
1:4fd3b7f: 	protected void assertSymbolicName(String expected, String actual) {
1:4fd3b7f: 		assertEquals("Wrong symbolic name", expected, actual);
1:4717af0: 	}
1:e8a0b01: 
1:f1ff8f8: 	protected void assertType(String expected, Subsystem subsystem) {
1:f1ff8f8: 		assertEquals("Wrong type", expected, subsystem.getType());
1:f1ff8f8: 	}
1:f1ff8f8: 
1:e8a0b01: 	protected void assertVersion(String expected, Subsystem subsystem) {
1:e8a0b01: 		assertVersion(Version.parseVersion(expected), subsystem);
24:e8a0b01: 	}
1:e8a0b01: 
1:e8a0b01: 	protected void assertVersion(Version expected, Subsystem subsystem) {
1:0c3bb10: 		assertVersion(expected, subsystem.getVersion());
1:0c3bb10: 	}
1:0c3bb10: 
1:0c3bb10: 	protected void assertVersion(Version expected, Version actual) {
1:0c3bb10: 		assertEquals("Wrong version", expected, actual);
1:7e004f1: 	}
1:7e004f1: 
1:57b6627: 	protected Header version(String version) {
1:57b6627: 		return new Header(Constants.BUNDLE_VERSION, version);
1:7e004f1: 	}
1:7e004f1: 
1:57b6627: 	protected Header name(String name) {
1:57b6627: 		return new Header(Constants.BUNDLE_SYMBOLICNAME, name);
1:7e004f1: 	}
1:7e004f1: 
1:57b6627: 	protected Header exportPackage(String exportPackage) {
1:57b6627: 		return new Header(Constants.EXPORT_PACKAGE, exportPackage);
1:e8a0b01: 	}
1:e8a0b01: 
1:57b6627: 	protected Header importPackage(String importPackage) {
1:57b6627: 		return new Header(Constants.IMPORT_PACKAGE, importPackage);
1:e8a0b01: 	}
1:e8a0b01: 
1:57b6627: 	protected Header requireBundle(String bundleName) {
1:57b6627: 		return new Header(Constants.REQUIRE_BUNDLE, bundleName);
1:e8a0b01: 	}
1:e8a0b01: 
1:57b6627: 	protected Header requireCapability(String capability) {
1:57b6627: 		return new Header(Constants.REQUIRE_CAPABILITY, capability);
1:e8a0b01: 	}
1:e8a0b01: 
1:57b6627: 	protected Header provideCapability(String capability) {
1:57b6627: 		return new Header(Constants.PROVIDE_CAPABILITY, capability);
1:e8a0b01: 	}
1:57b6627: 	protected static void createBundle(Header...  headers) throws IOException {
1:a6b79e8: 		createBundle(Collections.<String> emptyList(), headers);
1:e8a0b01: 	}
1:e8a0b01: 
1:a6b79e8: 	protected static void createBundle(List<String> emptyFiles, Header...  headers) throws IOException {
1:57b6627: 		HashMap<String, String> headerMap = new HashMap<String, String>();
1:57b6627: 		for (Header header : headers) {
1:57b6627: 			headerMap.put(header.key, header.value);
1:e8a0b01: 		}
1:a6b79e8: 		createBundle(emptyFiles, headerMap);
1:e8a0b01: 	}
1:3b4e485: 	
1:3b4e485: 	protected static void createBundle(List<String> emptyFiles, Map<String, String> headers) throws IOException {
1:3b4e485: 		createBundle(headers.get(Constants.BUNDLE_SYMBOLICNAME), emptyFiles, headers);
1:3b4e485: 	}
1:e8a0b01: 
1:3b4e485: 	protected static void createBundle(String fileName, List<String> emptyFiles, Map<String, String> headers) throws IOException
1:69d4847: 	{
1:7e004f1: 		JarFixture bundle = ArchiveFixture.newJar();
1:7e004f1: 		ManifestFixture manifest = bundle.manifest();
1:7e004f1: 		for (Entry<String, String> header : headers.entrySet()) {
1:7e004f1: 			manifest.attribute(header.getKey(), header.getValue());
1:7e004f1: 		}
1:a6b79e8: 		for (String path : emptyFiles) {
1:a6b79e8: 			bundle.file(path).end();
1:7e004f1: 		}
1:3b4e485: 		write(fileName, bundle);
1:7e004f1: 	}
1:7e004f1: 
1:57b6627: 	protected static void createBlueprintBundle(String symbolicName, String blueprintXml)
1:57b6627: 			throws IOException {
1:57b6627: 		write(symbolicName,
1:57b6627: 				ArchiveFixture.newJar().manifest().symbolicName(symbolicName)
1:57b6627: 						.end().file("OSGI-INF/blueprint/blueprint.xml", blueprintXml));
1:e8a0b01: 	}
1:7e004f1: 
1:d6eb080: 	protected Resource createBundleRepositoryContent(String file) throws Exception {
1:875a6d6: 		return createBundleRepositoryContent(new File(file));
1:875a6d6: 	}
1:875a6d6: 
1:d6eb080: 	protected Resource createBundleRepositoryContent(File file) throws Exception {
1:47cea41: 		return new BundleResource(FileSystem.getFSRoot(file));
1:875a6d6: 	}
1:875a6d6: 
1:7e004f1: 	protected static void createManifest(String name, Map<String, String> headers) throws IOException {
1:7e004f1: 		ManifestFixture manifest = ArchiveFixture.newJar().manifest();
1:7e004f1: 		for (Entry<String, String> header : headers.entrySet()) {
1:7e004f1: 			manifest.attribute(header.getKey(), header.getValue());
1:7e004f1: 		}
1:7e004f1: 		write(name, manifest);
1:7e004f1: 	}
1:7e004f1: 
1:7e004f1: 	protected static void createSubsystem(String name, String...contents) throws IOException {
1:4fd3b7f: 		File manifest = new File(name + ".mf");
1:4fd3b7f: 		ZipFixture fixture = ArchiveFixture.newZip();
1:4fd3b7f: 		if (manifest.exists())
1:4fd3b7f: 			// The following input stream is closed by ArchiveFixture.copy.
1:4fd3b7f: 			fixture.binary("OSGI-INF/SUBSYSTEM.MF", new FileInputStream(name + ".mf"));
1:7e004f1: 		if (contents != null) {
1:7e004f1: 			for (String content : contents) {
1:f615d56: 				// The following input stream is closed by ArchiveFixture.copy.
1:7e004f1: 				fixture.binary(content, new FileInputStream(content));
1:7e004f1: 			}
1:7e004f1: 		}
1:7e004f1: 		write(name, fixture);
1:df175a6: 	}
1:7e004f1: 
1:391a1aa: 	protected Subsystem findSubsystemService(long id) throws InvalidSyntaxException {
1:391a1aa: 		String filter = "(" + SubsystemConstants.SUBSYSTEM_ID_PROPERTY + "=" + id + ")";
1:57b6627: 		return context().getService(Subsystem.class, filter, 5000);
1:391a1aa: 	}
1:391a1aa: 
1:4b2d185: 	protected Subsystem getChild(Subsystem parent, String symbolicName) {
1:4b2d185: 		return getChild(parent, symbolicName, null, null);
1:4b2d185: 	}
1:4b2d185: 
1:4b2d185: 	protected Subsystem getChild(Subsystem parent, String symbolicName, Version version) {
1:4b2d185: 		return getChild(parent, symbolicName, version, null);
1:4b2d185: 	}
1:4b2d185: 
1:4b2d185: 	protected Subsystem getChild(Subsystem parent, String symbolicName, Version version, String type) {
1:4b2d185: 		for (Subsystem child : parent.getChildren()) {
1:4b2d185: 			if (symbolicName.equals(child.getSymbolicName())) {
1:4b2d185: 				if (version == null)
1:4b2d185: 					version = Version.emptyVersion;
1:4b2d185: 				if (version.equals(child.getVersion())) {
1:4b2d185: 					if (type == null)
1:4b2d185: 						type = SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION;
1:4b2d185: 					if (type.equals(child.getType())) {
1:4b2d185: 						return child;
1:df175a6: 					}
1:df175a6: 				}
1:7e004f1: 			}
1:e8a0b01: 		}
1:4b2d185: 		return null;
1:4b2d185: 	}
1:4b2d185: 
1:7c69962: 	public static Object getIdentityAttribute(Resource resource, String name) {
1:7c69962: 	    List<Capability> capabilities = resource.getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE);
1:7c69962:         Capability capability = capabilities.get(0);
1:7c69962:         return capability.getAttributes().get(name);
1:4b2d185:     }
1:df175a6: 
1:7c69962: 	public static String getSymbolicNameAttribute(Resource resource) {
1:7c69962:         return (String)getIdentityAttribute(resource, IdentityNamespace.IDENTITY_NAMESPACE);
1:4b2d185:     }
1:4717af0: 
1:7c69962:    public static Version getVersionAttribute(Resource resource) {
1:7c69962:         Version result = (Version)getIdentityAttribute(resource, IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE);
1:7c69962:         if (result == null)
1:7c69962:             result = Version.emptyVersion;
1:7c69962:         return result;
1:4b2d185:     }
1:e8a0b01: 
1:7c69962:    public static String getTypeAttribute(Resource resource) {
1:7c69962:        String result = (String)getIdentityAttribute(resource, IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE);
1:7c69962:        if (result == null)
1:7c69962:            result = TypeAttribute.DEFAULT_VALUE;
1:7c69962:        return result;
1:4b2d185:    }
1:e8a0b01: 
1:875a6d6:    protected Resource getConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
1:875a6d6: 		for (Resource resource : subsystem.getConstituents()) {
1:7c69962: 			if (symbolicName.equals(getSymbolicNameAttribute(resource))) {
1:875a6d6: 				if (version == null)
1:875a6d6: 					version = Version.emptyVersion;
1:7c69962: 				if (version.equals(getVersionAttribute(resource))) {
1:875a6d6: 					if (type == null)
1:875a6d6: 						type = IdentityNamespace.TYPE_BUNDLE;
1:7c69962: 					if (type.equals(getTypeAttribute(resource))) {
1:875a6d6: 						return resource;
1:875a6d6: 					}
1:875a6d6: 				}
1:875a6d6: 			}
1:875a6d6: 		}
1:df175a6: 		return null;
1:875a6d6: 	}
1:875a6d6: 
1:4b2d185: 	protected AriesSubsystem getConstituentAsAriesSubsystem(Subsystem subsystem, String symbolicName, Version version, String type) {
1:4b2d185: 		Resource resource = getConstituent(subsystem, symbolicName, version, type);
1:4b2d185: 		return (AriesSubsystem)resource;
1:4b2d185: 	}
1:4b2d185: 
1:391a1aa: 	protected Bundle getConstituentAsBundle(Subsystem subsystem, String symbolicName, Version version, String type) {
1:391a1aa: 		return getConstituentAsBundleRevision(subsystem, symbolicName, version, type).getBundle();
1:391a1aa: 	}
1:391a1aa: 
1:391a1aa: 	protected BundleRevision getConstituentAsBundleRevision(Subsystem subsystem, String symbolicName, Version version, String type) {
1:391a1aa: 		Resource resource = getConstituent(subsystem, symbolicName, version, type);
1:391a1aa: 		return (BundleRevision)resource;
1:391a1aa: 	}
1:391a1aa: 
1:4b2d185: 	protected Subsystem getConstituentAsSubsystem(Subsystem subsystem, String symbolicName, Version version, String type) {
1:4b2d185: 		Resource resource = getConstituent(subsystem, symbolicName, version, type);
1:4b2d185: 		return (Subsystem)resource;
1:4b2d185: 	}
1:4b2d185: 
1:4b2d185: 	protected Region getRegion(Subsystem subsystem) {
1:57b6627: 		RegionDigraph digraph = context().getService(RegionDigraph.class);
1:f8a980d: 		String name = getRegionName(subsystem);
1:4b2d185: 		Region region = digraph.getRegion(name);
1:4b2d185: 		assertNotNull("Region not found: " + name, region);
1:4b2d185: 		return region;
1:4b2d185: 	}
1:4b2d185: 
1:f1ff8f8: 	protected Bundle getRegionContextBundle(Subsystem subsystem) {
1:f1ff8f8: 		BundleContext bc = subsystem.getBundleContext();
1:f1ff8f8: 		assertNotNull("No region context bundle", bc);
1:f1ff8f8: 		return bc.getBundle();
1:f1ff8f8: 	}
1:f1ff8f8: 
1:f8a980d: 	protected String getRegionName(Subsystem subsystem) {
1:f8a980d: 		if (subsystem.getSubsystemId() == 0)
1:f8a980d: 			return "org.eclipse.equinox.region.kernel";
1:f8a980d: 		return subsystem.getSymbolicName() + ';' + subsystem.getVersion() + ';' + subsystem.getType() + ';' + subsystem.getSubsystemId();
1:f8a980d: 	}
1:f8a980d: 
1:5bd3bf6: 	protected AriesSubsystem getRootAriesSubsystem() {
1:57b6627: 		return context().getService(AriesSubsystem.class);
1:5bd3bf6: 	}
1:5bd3bf6: 
1:1c9c28b: 	protected Subsystem getRootSubsystem() {
1:57b6627: 		return context().getService(Subsystem.class, "(subsystem.id=0)");
1:1c9c28b: 	}
1:1c9c28b: 
1:74ef56e: 	protected Subsystem getRootSubsystemInState(Subsystem.State state, long timeout) throws InterruptedException {
1:74ef56e: 		Subsystem root = getRootSubsystem();
1:74ef56e: 		long now = System.currentTimeMillis();
1:74ef56e: 		long then = now + timeout;
1:74ef56e: 		while (!root.getState().equals(state) && System.currentTimeMillis() < then)
1:74ef56e: 			Thread.sleep(100);
1:74ef56e: 		if (!root.getState().equals(state))
1:74ef56e: 			fail("Root subsystem never achieved state: " + state);
1:74ef56e: 		return root;
1:74ef56e: 	}
1:74ef56e: 
1:590cf45: 	protected Bundle getSystemBundle() {
1:590cf45: 		return bundleContext.getBundle(Constants.SYSTEM_BUNDLE_LOCATION);
1:590cf45: 	}
1:590cf45: 
1:590cf45: 	protected FrameworkStartLevel getSystemBundleAsFrameworkStartLevel() {
1:590cf45: 		return getSystemBundle().adapt(FrameworkStartLevel.class);
1:590cf45: 	}
1:590cf45: 
1:4b2d185: 	protected FrameworkWiring getSystemBundleAsFrameworkWiring() {
1:4b2d185: 		return getSystemBundle().adapt(FrameworkWiring.class);
1:4b2d185: 	}
1:4b2d185: 
1:e8a0b01: 	protected Bundle getSubsystemCoreBundle() {
1:7c69962: 		return context().getBundleByName(SUBSYSTEM_CORE_NAME);
1:0c3bb10: 	}
1:e8a0b01: 
1:deca8ed: 	protected Bundle installBundleFromFile(String fileName) throws FileNotFoundException, BundleException {
1:57b6627: 		return installBundleFromFile(new File(fileName), getRootSubsystem());
1:deca8ed: 	}
1:deca8ed: 
1:57b6627: 	protected Bundle installBundleFromFile(String fileName, Subsystem subsystem) throws FileNotFoundException, BundleException {
1:57b6627: 		return installBundleFromFile(new File(fileName), subsystem);
1:deca8ed: 	}
1:deca8ed: 
1:57b6627: 	private Bundle installBundleFromFile(File file, Subsystem subsystem) throws FileNotFoundException, BundleException {
1:deca8ed: 		Bundle bundle = installBundleFromFile(file, subsystem.getBundleContext());
1:deca8ed: 		assertBundleState(Bundle.INSTALLED|Bundle.RESOLVED, bundle.getSymbolicName(), subsystem);
1:df175a6: 		return bundle;
1:deca8ed: 	}
1:deca8ed: 
1:57b6627: 	private Bundle installBundleFromFile(File file, BundleContext bundleContext) throws FileNotFoundException, BundleException {
1:f615d56: 		// The following input stream is closed by the bundle context.
1:deca8ed: 		return bundleContext.installBundle(file.toURI().toString(), new FileInputStream(file));
1:deca8ed: 	}
1:deca8ed: 
1:e8a0b01: 	protected Subsystem installSubsystemFromFile(Subsystem parent, String fileName) throws Exception {
1:e8a0b01: 		return installSubsystemFromFile(parent, new File(fileName));
1:0c3bb10: 	}
1:e8a0b01: 
1:a990e32: 	protected Subsystem installSubsystemFromFile(String fileName, Boolean ... configChecks) throws Exception {
1:a990e32: 		return installSubsystemFromFile(new File(fileName), configChecks);
1:0c3bb10: 	}
1:e8a0b01: 
1:e8a0b01: 	protected Subsystem installSubsystemFromFile(Subsystem parent, File file) throws Exception {
1:e8a0b01: 		return installSubsystem(parent, file.toURI().toURL().toExternalForm());
1:4717af0: 	}
1:e8a0b01: 
1:a990e32: 	private Subsystem installSubsystemFromFile(File file, Boolean ... configChecks) throws Exception {
1:a990e32: 		return installSubsystem(getRootSubsystem(), file.toURI().toURL().toExternalForm(), configChecks);
1:4717af0: 	}
1:e8a0b01: 	
1:69fd7d4: 	protected Subsystem installSubsystemFromFile(Subsystem parent, File file, String location) throws Exception {
1:69fd7d4: 		return installSubsystem(parent, location, new URL(file.toURI().toURL().toExternalForm()).openStream());
1:69fd7d4: 	}
1:e8a0b01: 
1:e8a0b01: 	protected Subsystem installSubsystem(String location) throws Exception {
1:1c9c28b: 		return installSubsystem(getRootSubsystem(), location);
1:4717af0: 	}
1:e8a0b01: 
1:e8a0b01: 	protected Subsystem installSubsystem(String location, InputStream content) throws Exception {
1:1c9c28b: 		return installSubsystem(getRootSubsystem(), location, content);
1:4717af0: 	}
1:e8a0b01: 
1:a990e32: 	protected Subsystem installSubsystem(Subsystem parent, String location, Boolean ... configChecks) throws Exception {
1:f615d56: 		// The following input stream is closed by Subsystem.install.
1:a990e32: 		return installSubsystem(parent, location, new URL(location).openStream(), configChecks);
1:4717af0: 	}
1:e8a0b01: 
1:a990e32: 	protected Subsystem installSubsystem(Subsystem parent, String location, InputStream content, Boolean ... configChecks) throws Exception {
1:a990e32: 	    boolean ariesProvisionDepsAtInstall = true; //set default value
1:a990e32: 	    if (configChecks!=null && configChecks.length > 0) {
1:a990e32: 	        ariesProvisionDepsAtInstall = configChecks[0].booleanValue();
1:a990e32: 	    }
1:a990e32: 	    subsystemEvents.clear();
1:a990e32: 	    Subsystem subsystem = parent.install(location, content);
1:a990e32: 	    assertSubsystemNotNull(subsystem);
1:a990e32: 	    assertEvent(subsystem, State.INSTALLING, 5000);
1:a990e32: 	    if (ariesProvisionDepsAtInstall) {
1:a990e32: 	        assertEvent(subsystem, State.INSTALLED, 5000);
1:a990e32: 	    }
1:a990e32: 	    assertChild(parent, subsystem);
1:a990e32: 	    assertLocation(location, subsystem);
1:a990e32: 	    assertParent(parent, subsystem);
1:a990e32: 	    State finalState=State.INSTALLED;
1:a990e32: 	    if (!ariesProvisionDepsAtInstall) {
1:a990e32: 	        finalState=State.INSTALLING;
1:a990e32: 	    }
1:a990e32: 	    assertState(finalState, subsystem);
1:a990e32: 	    assertLocation(location, subsystem);
1:a990e32: 	    assertId(subsystem);
1:a990e32: 	    // TODO This does not take into account nested directories.
1:a990e32: 	    //		assertDirectory(subsystem);
1:a990e32: 	    return subsystem;
1:e8a0b01: 	}
1:e8a0b01: 
1:875a6d6: 	protected void registerRepositoryService(Repository repository) {
1:875a6d6: 		serviceRegistrations.add(bundleContext.registerService(
1:875a6d6: 				Repository.class, repository, null));
1:875a6d6: 	}
1:875a6d6: 
1:875a6d6: 	protected void registerRepositoryService(Resource...resources) {
1:875a6d6: 		TestRepository.Builder builder = new TestRepository.Builder();
1:875a6d6: 		for (Resource resource : resources) {
1:875a6d6: 			builder.resource(resource);
1:875a6d6: 		}
1:875a6d6: 		registerRepositoryService(builder.build());
1:875a6d6: 	}
1:875a6d6: 
1:875a6d6: 	protected void registerRepositoryService(String...files) throws Exception {
1:875a6d6: 		Resource[] resources = new Resource[files.length];
1:875a6d6: 		int i = 0;
1:875a6d6: 		for (String file : files) {
1:875a6d6: 			resources[i++] = (Resource)createBundleRepositoryContent(file);
1:875a6d6: 		}
1:875a6d6: 		registerRepositoryService(resources);
1:875a6d6: 	}
1:2aab796: 	
1:2aab796: 	protected void removeConnectionWithParent(Subsystem subsystem) throws BundleException {
1:2aab796: 		Region tail = getRegion(subsystem);
1:2aab796: 		RegionDigraph digraph = tail.getRegionDigraph();
1:2aab796: 		RegionDigraph copy = digraph.copy();
1:2aab796: 		Region tailCopy = copy.getRegion(tail.getName());
1:2aab796: 		Set<Long> ids = tail.getBundleIds();
1:2aab796: 		copy.removeRegion(tailCopy);
1:2aab796: 		tailCopy= copy.createRegion(tailCopy.getName());
1:2aab796: 		for (long id : ids) {
1:2aab796: 			tailCopy.addBundle(id);
1:2aab796: 		}
1:2aab796: 		digraph.replace(copy);
1:2aab796: 	}
1:875a6d6: 
1:391a1aa: 	protected void restartSubsystemsImplBundle() throws BundleException {
1:391a1aa: 		Bundle b = getSubsystemCoreBundle();
1:391a1aa: 		b.stop();
1:391a1aa: 		b.start();
1:391a1aa: 	}
1:391a1aa: 
1:deca8ed: 	protected void startBundle(Bundle bundle) throws BundleException {
1:deca8ed: 		startBundle(bundle, getRootSubsystem());
1:deca8ed: 	}
1:deca8ed: 
1:deca8ed: 	protected void startBundle(Bundle bundle, Subsystem subsystem) throws BundleException {
1:deca8ed: 		bundle.start();
1:deca8ed: 		assertBundleState(Bundle.ACTIVE, bundle.getSymbolicName(), subsystem);
1:deca8ed: 	}
1:deca8ed: 
1:a990e32: 	protected void startSubsystem(Subsystem subsystem, Boolean ... configChecks) throws Exception {
1:a990e32: 		startSubsystemFromInstalled(subsystem, configChecks);
1:e8a0b01: 	}
1:e8a0b01: 
1:a990e32: 	protected void startSubsystemFromInstalled(Subsystem subsystem, Boolean ... configChecks) throws InterruptedException {
1:a990e32: 	    boolean ariesProvisionDependenciesAtInstall = true; //set default value
1:a990e32: 	    if (configChecks.length>0) {
1:a990e32: 	        ariesProvisionDependenciesAtInstall = configChecks[0].booleanValue();
1:a990e32: 	    }
1:a990e32: 	    if (ariesProvisionDependenciesAtInstall) {
1:a990e32: 		    assertState(State.INSTALLED, subsystem);
1:a990e32: 	    }
1:a990e32: 	    else {
1:a990e32: 	        assertState(State.INSTALLING, subsystem);
1:a990e32: 	    }
1:a990e32: 	        
3:e8a0b01: 		subsystemEvents.clear();
1:e8a0b01: 		subsystem.start();
1:a990e32: 		if (!ariesProvisionDependenciesAtInstall) {
1:a990e32: 		    assertEvent(subsystem, State.INSTALLED, 5000);
1:a990e32: 		}
1:f1ff8f8: 		assertEvent(subsystem, State.RESOLVING, 5000);
1:f1ff8f8: 		assertEvent(subsystem, State.RESOLVED, 5000);
1:f1ff8f8: 		assertEvent(subsystem, State.STARTING, 5000);
1:f1ff8f8: 		assertEvent(subsystem, State.ACTIVE, 5000);
1:e8a0b01: 		assertState(State.ACTIVE, subsystem);
1:e8a0b01: 	}
1:e8a0b01: 
1:391a1aa: 	protected void startSubsystemFromResolved(Subsystem subsystem) throws InterruptedException {
1:391a1aa: 		assertState(State.RESOLVED, subsystem);
1:391a1aa: 		subsystemEvents.clear();
1:391a1aa: 		subsystem.start();
1:391a1aa: 		assertEvent(subsystem, State.STARTING, 5000);
1:391a1aa: 		assertEvent(subsystem, State.ACTIVE, 5000);
1:391a1aa: 		assertState(State.ACTIVE, subsystem);
1:391a1aa: 	}
1:391a1aa: 
1:875a6d6: 	protected void stopAndUninstallSubsystemSilently(Subsystem subsystem) {
1:875a6d6: 		stopSubsystemSilently(subsystem);
1:875a6d6: 		uninstallSubsystemSilently(subsystem);
1:875a6d6: 	}
1:875a6d6: 
1:e8a0b01: 	protected void stopSubsystem(Subsystem subsystem) throws Exception {
1:e8a0b01: 		assertState(State.ACTIVE, subsystem);
1:e8a0b01: 		subsystemEvents.clear();
1:e8a0b01: 		subsystem.stop();
1:f1ff8f8: 		assertEvent(subsystem, State.STOPPING, 5000);
1:f1ff8f8: 		assertEvent(subsystem, State.RESOLVED, 5000);
1:e8a0b01: 		assertState(State.RESOLVED, subsystem);
1:a677a53: 	}
1:a677a53: 
1:574fba9: 	protected void stopSubsystemSilently(Subsystem subsystem) {
1:574fba9: 		try {
1:574fba9: 			stopSubsystem(subsystem);
1:574fba9: 		}
1:574fba9: 		catch (Throwable t) {
1:574fba9: 			t.printStackTrace();
1:574fba9: 		}
1:e8a0b01: 	}
1:e8a0b01: 
1:67ef08f: 	protected void uninstallSilently(Bundle bundle) {
1:67ef08f: 		if (bundle == null)
1:67ef08f: 			return;
1:67ef08f: 		try {
1:67ef08f: 			bundle.uninstall();
1:1c027e7: 		}
1:1c027e7: 		catch (Exception e) {
1:1c027e7: 			e.printStackTrace();
1:67ef08f: 		}
1:67ef08f: 	}
1:67ef08f: 
1:e8a0b01: 	protected void uninstallSubsystem(Subsystem subsystem) throws Exception {
1:a990e32: 		uninstallSubsystem(subsystem, false);
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	protected void uninstallSubsystem(Subsystem subsystem, boolean quietly) throws Exception {
1:a990e32: 		BasicSubsystem basicSubsystem = (BasicSubsystem)subsystem;
1:a990e32: 		AriesProvisionDependenciesDirective directive = basicSubsystem.getAriesProvisionDependenciesDirective();
1:574fba9: 		Bundle b = null;
1:8481849: 		Region region = null;
1:57b6627: 		RegionDigraph digraph = context().getService(RegionDigraph.class);
1:a990e32: 		if (!quietly) {
1:a990e32: 			if (directive.isResolve()) {
1:a990e32: 				assertState(EnumSet.of(State.INSTALLING, State.INSTALLED, State.RESOLVED), subsystem);
1:a990e32: 			}
1:a990e32: 			else {
1:a990e32: 				assertState(EnumSet.of(State.INSTALLED, State.RESOLVED), subsystem);
1:a990e32: 			}
1:a990e32: 			subsystemEvents.clear();
1:a990e32: 			if (subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1:a990e32: 					|| subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)) {
1:a990e32: 				b = getRegionContextBundle(subsystem);
1:a990e32: 				region = digraph.getRegion(b);
1:a990e32: 			}
1:8481849: 		}
1:225bcae: 		State state = subsystem.getState();
1:e8a0b01: 		subsystem.uninstall();
1:a990e32: 		if (quietly) {
1:a990e32: 			return;
1:a990e32: 		}
1:a990e32: 		Collection<Subsystem> parents = subsystem.getParents();
1:a990e32: 		if (!EnumSet.of(State.INSTALL_FAILED, State.INSTALLED, State.INSTALLING).contains(state)) {
1:225bcae: 			assertEvent(subsystem, State.INSTALLED, 5000);
1:a990e32: 		}
1:f1ff8f8: 		assertEvent(subsystem, State.UNINSTALLING, 5000);
1:f1ff8f8: 		assertEvent(subsystem, State.UNINSTALLED, 5000);
1:e8a0b01: 		assertState(State.UNINSTALLED, subsystem);
1:a990e32: 		for (Subsystem parent : parents) {
1:1c9c28b: 			assertNotChild(parent, subsystem);
1:a990e32: 		}
1:8481849: 		if (subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1:8481849: 				|| subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)) {
1:574fba9: 			assertEquals("Region context bundle not uninstalled", Bundle.UNINSTALLED, b.getState());
1:8481849: 			assertNull("Region not removed", digraph.getRegion(region.getName()));
1:8481849: 		}
1:a677a53: 	}
1:a677a53: 
1:574fba9: 	protected void uninstallSubsystemSilently(Subsystem subsystem) {
1:875a6d6: 		if (subsystem == null)
1:875a6d6: 			return;
1:574fba9: 		try {
1:a990e32: 			uninstallSubsystem(subsystem, true);
1:574fba9: 		}
1:574fba9: 		catch (Throwable t) {
1:574fba9: 			t.printStackTrace();
1:574fba9: 		}
1:e8a0b01: 	}
1:e8a0b01: 
1:7c69962: 	protected void writeToFile(InputStream is, String name) {
1:1c9c28b:         try {
1:7c69962:             FileOutputStream dest = new FileOutputStream(name);
1:7c69962:             StreamUtils.copyStream(is, dest, true);
1:7c69962:         } catch (IOException e) {
1:7c69962:             e.printStackTrace();
1:e8a0b01:         }
1:e8a0b01:     }
1:e8a0b01: 
1:79b20bc:     protected static void write(String file, ArchiveFixture.AbstractFixture fixture) throws IOException
1:69d4847: 	{
1:deca8ed: 		write(new File(file), fixture);
1:deca8ed: 	}
1:deca8ed: 
1:57b6627: 	private static void write(File file, ArchiveFixture.AbstractFixture fixture) throws IOException {
1:deca8ed: 		FileOutputStream fos = new FileOutputStream(file);
1:deca8ed:     	try {
1:deca8ed:     		fixture.writeOut(fos);
1:deca8ed:     	}
1:deca8ed:     	finally {
1:f334800:     		fos.close();
1:deca8ed:     	}
1:deca8ed: 	}
1:e8a0b01: 
1:79b20bc: 	static void createApplication(String name, String ... contents) throws Exception
1:69d4847: 	{
1:7c69962: 		ClassLoader cl = SubsystemTest.class.getClassLoader();
1:7c69962:         ZipFixture feature = ArchiveFixture
1:69d4847: 				.newZip()
1:69d4847: 				.binary("OSGI-INF/SUBSYSTEM.MF",
1:f615d56: 						// The following input stream is closed by ArchiveFixture.copy.
1:7c69962: 						cl.getResourceAsStream(name + "/OSGI-INF/SUBSYSTEM.MF"));
1:7c69962: 		for (String content : contents) {
1:7c69962: 			try {
1:7c69962: 				feature.binary(content,
2:f615d56: 						// The following input stream is closed by ArchiveFixture.copy.
1:7c69962: 						cl.getResourceAsStream(name + '/' + content));
1:e8a0b01: 			}
1:69d4847: 			catch (Exception e) {
1:f615d56: 				// The following input stream is closed by ArchiveFixture.copy.
1:7c69962: 				feature.binary(content, new FileInputStream(new File(content)));
1:e8a0b01: 			}
1:e8a0b01: 		}
1:69d4847: 		feature.end();
1:69d4847: 		FileOutputStream fos = new FileOutputStream(name + ".esa");
7:69d4847: 		try {
1:69d4847: 			feature.writeOut(fos);
1:69d4847: 		} finally {
1:69d4847: 			Utils.closeQuietly(fos);
1:e8a0b01: 		}
1:e8a0b01: 	}
1:8481849: 
1:d6eb080: 	protected static String normalizeBundleLocation(Bundle bundle) {
1:d6eb080: 		return normalizeBundleLocation(bundle.getLocation());
1:e8a0b01: 	}
1:e8a0b01: 	
1:8481849: 	protected static String normalizeBundleLocation(String location) {
1:8481849: 		if (location.startsWith("initial@"))
1:8481849: 			return location.substring(8);
1:8481849: 		return location;
1:f334800: 	}
1:f334800: 
1:7c69962: 	protected InputStream getResource(String path) {
1:7c69962: 	    InputStream is = this.getClass().getClassLoader().getResourceAsStream(path);
1:7c69962: 	    if (is == null) {
1:7c69962: 	        throw new IllegalArgumentException("No resource found at path " + path);
1:8481849: 	    }
1:7c69962: 	    return is;
1:e8a0b01: 	}
1:e8a0b01: 
1:e8a0b01: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:6ebbd4c
/////////////////////////////////////////////////////////////////////////
1:                 mavenBundle("org.apache.aries.subsystem",	"org.apache.aries.subsystem.obr").versionAsInProject(),
1:                 mavenBundle("org.apache.felix",				"org.apache.felix.bundlerepository").versionAsInProject(),	
commit:afe81b7
/////////////////////////////////////////////////////////////////////////
1: 	protected final List<Region> deletableRegions = Collections.synchronizedList(new ArrayList<Region>());
1: 	protected final List<Subsystem> stoppableSubsystems = Collections.synchronizedList(new ArrayList<Subsystem>());
1: 	protected final List<Bundle> uninstallableBundles = Collections.synchronizedList(new ArrayList<Bundle>());
1:     protected final List<Subsystem> uninstallableSubsystems = Collections.synchronizedList(new ArrayList<Subsystem>());
1: 		serviceRegistrations.clear();
/////////////////////////////////////////////////////////////////////////
commit:1c027e7
/////////////////////////////////////////////////////////////////////////
1: 				systemProperty("org.osgi.framework.storage.clean").value("onFirstInit"),
/////////////////////////////////////////////////////////////////////////
0: 	protected final List<Region> deletableRegions = new ArrayList<Region>();
0: 	protected final List<Subsystem> stoppableSubsystems = new ArrayList<Subsystem>();
0: 	protected final List<Bundle> uninstallableBundles = new ArrayList<Bundle>();
0:     protected final List<Subsystem> uninstallableSubsystems = new ArrayList<Subsystem>();
1: 	
1: 		deletableRegions.clear();
1: 		stoppableSubsystems.clear();
1: 		uninstallableBundles.clear();
1:         uninstallableSubsystems.clear();
1: 	
1: 		for (Subsystem subsystem : stoppableSubsystems) {
1: 			stopSubsystemSilently(subsystem);
1: 		}
1: 		for (Subsystem subsystem : uninstallableSubsystems) {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 		RegionDigraph digraph = context().getService(RegionDigraph.class);
1: 		for (Region region : deletableRegions) {
1: 			digraph.removeRegion(region);
1: 		}
1: 		for (Bundle bundle : uninstallableBundles) {
1: 			uninstallSilently(bundle);
1: 		}
1: 	protected void createApplications() throws Exception {
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		catch (Exception e) {
1: 			e.printStackTrace();
1: 		}
commit:a990e32
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
1: import org.apache.aries.subsystem.core.archive.AriesProvisionDependenciesDirective;
1: import org.apache.aries.subsystem.core.internal.BasicSubsystem;
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected long lastSubsystemId() throws Exception {
1:     	Method method = SubsystemIdentifier.class.getDeclaredMethod("getLastId");
1:     	method.setAccessible(true);
1:     	return (Long)method.invoke(null);
1:     }
/////////////////////////////////////////////////////////////////////////
1: 		assertEvent(subsystem.getSubsystemId(), subsystem.getSymbolicName(), 
1: 				subsystem.getVersion(), subsystem.getType(), state, event, type);
1: 	}
1: 	
1: 	protected void assertEvent(
1: 			long id, 
1: 			String symbolicName, 
1: 			Version version, 
1: 			String type, 
1: 			Subsystem.State state,
1: 			SubsystemEventHandler.ServiceEventInfo event,
1: 			int eventType) {
1: 		assertEquals("Wrong ID", id, event.getId());
1: 		assertEquals("Wrong symbolic name", symbolicName, event.getSymbolicName());
1: 		assertEquals("Wrong version", version, event.getVersion());
1: 		assertEquals("Wrong type", type, event.getType());
1: 		assertEquals("Wrong event type", eventType, event.getEventType());
/////////////////////////////////////////////////////////////////////////
1: 	protected Subsystem installSubsystemFromFile(String fileName, Boolean ... configChecks) throws Exception {
1: 		return installSubsystemFromFile(new File(fileName), configChecks);
1: 	private Subsystem installSubsystemFromFile(File file, Boolean ... configChecks) throws Exception {
1: 		return installSubsystem(getRootSubsystem(), file.toURI().toURL().toExternalForm(), configChecks);
/////////////////////////////////////////////////////////////////////////
1: 	protected Subsystem installSubsystem(Subsystem parent, String location, Boolean ... configChecks) throws Exception {
1: 		return installSubsystem(parent, location, new URL(location).openStream(), configChecks);
1: 	protected Subsystem installSubsystem(Subsystem parent, String location, InputStream content, Boolean ... configChecks) throws Exception {
1: 	    boolean ariesProvisionDepsAtInstall = true; //set default value
1: 	    if (configChecks!=null && configChecks.length > 0) {
1: 	        ariesProvisionDepsAtInstall = configChecks[0].booleanValue();
1: 	    }
1: 	    subsystemEvents.clear();
1: 	    Subsystem subsystem = parent.install(location, content);
1: 	    assertSubsystemNotNull(subsystem);
1: 	    assertEvent(subsystem, State.INSTALLING, 5000);
1: 	    if (ariesProvisionDepsAtInstall) {
1: 	        assertEvent(subsystem, State.INSTALLED, 5000);
1: 	    }
1: 	    assertChild(parent, subsystem);
1: 	    assertLocation(location, subsystem);
1: 	    assertParent(parent, subsystem);
1: 	    State finalState=State.INSTALLED;
1: 	    if (!ariesProvisionDepsAtInstall) {
1: 	        finalState=State.INSTALLING;
1: 	    }
1: 	    assertState(finalState, subsystem);
1: 	    assertLocation(location, subsystem);
1: 	    assertId(subsystem);
1: 	    // TODO This does not take into account nested directories.
1: 	    //		assertDirectory(subsystem);
1: 	    return subsystem;
/////////////////////////////////////////////////////////////////////////
1: 	protected void startSubsystem(Subsystem subsystem, Boolean ... configChecks) throws Exception {
1: 		startSubsystemFromInstalled(subsystem, configChecks);
1: 	protected void startSubsystemFromInstalled(Subsystem subsystem, Boolean ... configChecks) throws InterruptedException {
1: 	    boolean ariesProvisionDependenciesAtInstall = true; //set default value
1: 	    if (configChecks.length>0) {
1: 	        ariesProvisionDependenciesAtInstall = configChecks[0].booleanValue();
1: 	    }
1: 	    if (ariesProvisionDependenciesAtInstall) {
1: 		    assertState(State.INSTALLED, subsystem);
1: 	    }
1: 	    else {
1: 	        assertState(State.INSTALLING, subsystem);
1: 	    }
1: 	        
1: 		if (!ariesProvisionDependenciesAtInstall) {
1: 		    assertEvent(subsystem, State.INSTALLED, 5000);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		uninstallSubsystem(subsystem, false);
1: 	}
1: 	
1: 	protected void uninstallSubsystem(Subsystem subsystem, boolean quietly) throws Exception {
1: 		BasicSubsystem basicSubsystem = (BasicSubsystem)subsystem;
1: 		AriesProvisionDependenciesDirective directive = basicSubsystem.getAriesProvisionDependenciesDirective();
1: 		if (!quietly) {
1: 			if (directive.isResolve()) {
1: 				assertState(EnumSet.of(State.INSTALLING, State.INSTALLED, State.RESOLVED), subsystem);
1: 			}
1: 			else {
1: 				assertState(EnumSet.of(State.INSTALLED, State.RESOLVED), subsystem);
1: 			}
1: 			subsystemEvents.clear();
1: 			if (subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1: 					|| subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)) {
1: 				b = getRegionContextBundle(subsystem);
1: 				region = digraph.getRegion(b);
1: 			}
1: 		if (quietly) {
1: 			return;
1: 		}
1: 		Collection<Subsystem> parents = subsystem.getParents();
1: 		if (!EnumSet.of(State.INSTALL_FAILED, State.INSTALLED, State.INSTALLING).contains(state)) {
1: 		}
1: 		for (Subsystem parent : parents) {
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			uninstallSubsystem(subsystem, true);
commit:2aab796
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	protected void removeConnectionWithParent(Subsystem subsystem) throws BundleException {
1: 		Region tail = getRegion(subsystem);
1: 		RegionDigraph digraph = tail.getRegionDigraph();
1: 		RegionDigraph copy = digraph.copy();
1: 		Region tailCopy = copy.getRegion(tail.getName());
1: 		Set<Long> ids = tail.getBundleIds();
1: 		copy.removeRegion(tailCopy);
1: 		tailCopy= copy.createRegion(tailCopy.getName());
1: 		for (long id : ids) {
1: 			tailCopy.addBundle(id);
1: 		}
1: 		digraph.replace(copy);
1: 	}
commit:3b4e485
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertConstituent(Subsystem subsystem, String symbolicName, String type) {
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	protected static void createBundle(List<String> emptyFiles, Map<String, String> headers) throws IOException {
1: 		createBundle(headers.get(Constants.BUNDLE_SYMBOLICNAME), emptyFiles, headers);
1: 	}
1: 	protected static void createBundle(String fileName, List<String> emptyFiles, Map<String, String> headers) throws IOException
/////////////////////////////////////////////////////////////////////////
1: 		write(fileName, bundle);
commit:8ab013a
/////////////////////////////////////////////////////////////////////////
commit:69fd7d4
/////////////////////////////////////////////////////////////////////////
0: import java.net.MalformedURLException;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	protected Subsystem installSubsystemFromFile(Subsystem parent, File file, String location) throws Exception {
1: 		return installSubsystem(parent, location, new URL(file.toURI().toURL().toExternalForm()).openStream());
1: 	}
commit:a85c505
/////////////////////////////////////////////////////////////////////////
1:                 mavenBundle("org.ops4j.pax.tinybundles",    "tinybundles").versionAsInProject(),
1:                 mavenBundle("biz.aQute.bnd",                "bndlib").versionAsInProject(),
commit:9f94bb4
/////////////////////////////////////////////////////////////////////////
1:     	assertNotNull("Bundle not found: " + symbolicName, bundle);
commit:b6ac132
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	protected static Option[] defineOptions() {
1: 		return new Option[] {
/////////////////////////////////////////////////////////////////////////
0: 				equinox().version("3.8.0.V20120529-1548")
1: 		};
1: 	}
1: 	
0: 	@org.ops4j.pax.exam.junit.Configuration
0: 	public static Option[] configuration() {
0: 		Option[] options = defineOptions();
commit:f8a980d
/////////////////////////////////////////////////////////////////////////
1: 		String name = getRegionName(subsystem);
/////////////////////////////////////////////////////////////////////////
1: 	protected String getRegionName(Subsystem subsystem) {
1: 		if (subsystem.getSubsystemId() == 0)
1: 			return "org.eclipse.equinox.region.kernel";
1: 		return subsystem.getSymbolicName() + ';' + subsystem.getVersion() + ';' + subsystem.getType() + ';' + subsystem.getSubsystemId();
1: 	}
1: 	
commit:f334800
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	protected static final byte[] EMPTY_CLASS = new byte[] {
0: 			(byte)0xca, (byte)0xfe, (byte)0xba, (byte)0xbe, 
0: 			(byte)0x00, (byte)0x00, (byte)0x00, (byte)0x32, 
0: 			(byte)0x00, (byte)0x12, (byte)0x07, (byte)0x00, 
0: 			(byte)0x02, (byte)0x01, (byte)0x00, (byte)0x05, 
0: 			(byte)0x45, (byte)0x6d, (byte)0x70, (byte)0x74, 
0: 			(byte)0x79, (byte)0x07, (byte)0x00, (byte)0x04, 
0: 			(byte)0x01, (byte)0x00, (byte)0x10, (byte)0x6a, 
0: 			(byte)0x61, (byte)0x76, (byte)0x61, (byte)0x2f, 
0: 			(byte)0x6c, (byte)0x61, (byte)0x6e, (byte)0x67, 
0: 			(byte)0x2f, (byte)0x4f, (byte)0x62, (byte)0x6a, 
0: 			(byte)0x65, (byte)0x63, (byte)0x74, (byte)0x07, 
0: 			(byte)0x00, (byte)0x06, (byte)0x01, (byte)0x00, 
0: 			(byte)0x14, (byte)0x6a, (byte)0x61, (byte)0x76, 
0: 			(byte)0x61, (byte)0x2f, (byte)0x69, (byte)0x6f, 
0: 			(byte)0x2f, (byte)0x53, (byte)0x65, (byte)0x72, 
0: 			(byte)0x69, (byte)0x61, (byte)0x6c, (byte)0x69, 
0: 			(byte)0x7a, (byte)0x61, (byte)0x62, (byte)0x6c, 
0: 			(byte)0x65, (byte)0x01, (byte)0x00, (byte)0x06, 
0: 			(byte)0x3c, (byte)0x69, (byte)0x6e, (byte)0x69, 
0: 			(byte)0x74, (byte)0x3e, (byte)0x01, (byte)0x00, 
0: 			(byte)0x03, (byte)0x28, (byte)0x29, (byte)0x56, 
0: 			(byte)0x01, (byte)0x00, (byte)0x04, (byte)0x43, 
0: 			(byte)0x6f, (byte)0x64, (byte)0x65, (byte)0x0a, 
0: 			(byte)0x00, (byte)0x03, (byte)0x00, (byte)0x0b, 
0: 			(byte)0x0c, (byte)0x00, (byte)0x07, (byte)0x00, 
0: 			(byte)0x08, (byte)0x01, (byte)0x00, (byte)0x0f, 
0: 			(byte)0x4c, (byte)0x69, (byte)0x6e, (byte)0x65, 
0: 			(byte)0x4e, (byte)0x75, (byte)0x6d, (byte)0x62, 
0: 			(byte)0x65, (byte)0x72, (byte)0x54, (byte)0x61, 
0: 			(byte)0x62, (byte)0x6c, (byte)0x65, (byte)0x01, 
0: 			(byte)0x00, (byte)0x12, (byte)0x4c, (byte)0x6f, 
0: 			(byte)0x63, (byte)0x61, (byte)0x6c, (byte)0x56, 
0: 			(byte)0x61, (byte)0x72, (byte)0x69, (byte)0x61, 
0: 			(byte)0x62, (byte)0x6c, (byte)0x65, (byte)0x54, 
0: 			(byte)0x61, (byte)0x62, (byte)0x6c, (byte)0x65, 
0: 			(byte)0x01, (byte)0x00, (byte)0x04, (byte)0x74, 
0: 			(byte)0x68, (byte)0x69, (byte)0x73, (byte)0x01, 
0: 			(byte)0x00, (byte)0x07, (byte)0x4c, (byte)0x45, 
0: 			(byte)0x6d, (byte)0x70, (byte)0x74, (byte)0x79, 
0: 			(byte)0x3b, (byte)0x01, (byte)0x00, (byte)0x0a, 
0: 			(byte)0x53, (byte)0x6f, (byte)0x75, (byte)0x72, 
0: 			(byte)0x63, (byte)0x65, (byte)0x46, (byte)0x69, 
0: 			(byte)0x6c, (byte)0x65, (byte)0x01, (byte)0x00, 
0: 			(byte)0x0a, (byte)0x45, (byte)0x6d, (byte)0x70, 
0: 			(byte)0x74, (byte)0x79, (byte)0x2e, (byte)0x6a, 
0: 			(byte)0x61, (byte)0x76, (byte)0x61, (byte)0x00, 
0: 			(byte)0x21, (byte)0x00, (byte)0x01, (byte)0x00, 
0: 			(byte)0x03, (byte)0x00, (byte)0x01, (byte)0x00, 
0: 			(byte)0x05, (byte)0x00, (byte)0x00, (byte)0x00, 
0: 			(byte)0x01, (byte)0x00, (byte)0x01, (byte)0x00, 
0: 			(byte)0x07, (byte)0x00, (byte)0x08, (byte)0x00, 
0: 			(byte)0x01, (byte)0x00, (byte)0x09, (byte)0x00, 
0: 			(byte)0x00, (byte)0x00, (byte)0x2f, (byte)0x00, 
0: 			(byte)0x01, (byte)0x00, (byte)0x01, (byte)0x00, 
0: 			(byte)0x00, (byte)0x00, (byte)0x05, (byte)0x2a, 
0: 			(byte)0xb7, (byte)0x00, (byte)0x0a, (byte)0xb1, 
0: 			(byte)0x00, (byte)0x00, (byte)0x00, (byte)0x02, 
0: 			(byte)0x00, (byte)0x0c, (byte)0x00, (byte)0x00, 
0: 			(byte)0x00, (byte)0x06, (byte)0x00, (byte)0x01, 
0: 			(byte)0x00, (byte)0x00, (byte)0x00, (byte)0x04, 
0: 			(byte)0x00, (byte)0x0d, (byte)0x00, (byte)0x00, 
0: 			(byte)0x00, (byte)0x0c, (byte)0x00, (byte)0x01, 
0: 			(byte)0x00, (byte)0x00, (byte)0x00, (byte)0x05, 
0: 			(byte)0x00, (byte)0x0e, (byte)0x00, (byte)0x0f, 
0: 			(byte)0x00, (byte)0x00, (byte)0x00, (byte)0x01, 
0: 			(byte)0x00, (byte)0x10, (byte)0x00, (byte)0x00, 
0: 			(byte)0x00, (byte)0x02, (byte)0x00, (byte)0x11
0: 		};
1: 	
0: 	protected static void createEmptyClass() throws IOException {
0: 		FileOutputStream fos = new FileOutputStream("Empty.class");
0: 		fos.write(EMPTY_CLASS);
1: 		fos.close();
1: 	}
commit:71ee087
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertLastId(long id) throws Exception {
1: 	protected void resetLastId() throws Exception {
1: 		Field lastId = SubsystemIdentifier.class.getDeclaredField("lastId");
1: 		lastId.setAccessible(true);
1: 		lastId.setInt(SubsystemIdentifier.class, 0);
1: 	}
1: 	
commit:c49d412
/////////////////////////////////////////////////////////////////////////
0: 		return getOsgiService(Subsystem.class, "(&(objectClass=org.osgi.service.subsystem.Subsystem)(subsystem.id=0))", DEFAULT_TIMEOUT);
commit:74ef56e
/////////////////////////////////////////////////////////////////////////
1: 	protected Subsystem getRootSubsystemInState(Subsystem.State state, long timeout) throws InterruptedException {
1: 		Subsystem root = getRootSubsystem();
1: 		long now = System.currentTimeMillis();
1: 		long then = now + timeout;
1: 		while (!root.getState().equals(state) && System.currentTimeMillis() < then)
1: 			Thread.sleep(100);
1: 		if (!root.getState().equals(state))
1: 			fail("Root subsystem never achieved state: " + state);
1: 		return root;
1: 	}
1: 	
commit:7112947
/////////////////////////////////////////////////////////////////////////
1: import org.ops4j.pax.exam.CoreOptions;
/////////////////////////////////////////////////////////////////////////
0: 				// The itests need private packages from the core subsystems bundle.
0: 				CoreOptions.provision(SubsystemTest.class.getClassLoader().getResourceAsStream("core.fragment/core.fragment.jar")),
commit:4b2d185
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.FrameworkEvent;
1: import org.osgi.framework.FrameworkListener;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.FrameworkWiring;
/////////////////////////////////////////////////////////////////////////
1: 	protected Subsystem assertChild(Subsystem parent, String symbolicName) {
1: 		return assertChild(parent, symbolicName, null, null);
1: 	}
1: 	
1: 	protected Subsystem assertChild(Subsystem parent, String symbolicName, Version version) {
1: 		return assertChild(parent, symbolicName, version, null);
1: 	}
1: 	
1: 	protected Subsystem assertChild(Subsystem parent, String symbolicName, Version version, String type) {
1: 		Subsystem result = getChild(parent, symbolicName, version, type);
1: 		assertNotNull("Child does not exist: " + symbolicName, result);
1: 		return result;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertRefresh(Collection<Bundle> bundles) throws InterruptedException {
1: 		FrameworkWiring wiring = getSystemBundleAsFrameworkWiring();
1: 		final AtomicBoolean refreshed = new AtomicBoolean(false);
0: 		wiring.refreshBundles(bundles, new FrameworkListener() {
1: 			@Override
1: 			public void frameworkEvent(FrameworkEvent event) {
1: 				if (FrameworkEvent.PACKAGES_REFRESHED == event.getType()) {
1: 					synchronized (refreshed) {
1: 						refreshed.set(true);
1: 						refreshed.notify();
1: 					}
1: 				}
1: 			}
0: 		});
1: 		synchronized (refreshed) {
1: 			refreshed.wait(5000);
1: 		}
1: 		assertTrue("Bundles not refreshed", refreshed.get());
1: 	}
1: 	
1: 	protected void assertRefreshAndResolve(Collection<Bundle> bundles) throws InterruptedException {
1: 		assertRefresh(bundles);
1: 		assertResolve(bundles);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertResolve(Collection<Bundle> bundles) {
1: 		FrameworkWiring wiring = getSystemBundleAsFrameworkWiring();
1: 		assertTrue("Bundles not resolved", wiring.resolveBundles(bundles));
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected Subsystem getChild(Subsystem parent, String symbolicName) {
1: 		return getChild(parent, symbolicName, null, null);
1: 	}
1: 	
1: 	protected Subsystem getChild(Subsystem parent, String symbolicName, Version version) {
1: 		return getChild(parent, symbolicName, version, null);
1: 	}
1: 	
1: 	protected Subsystem getChild(Subsystem parent, String symbolicName, Version version, String type) {
1: 		for (Subsystem child : parent.getChildren()) {
1: 			if (symbolicName.equals(child.getSymbolicName())) {
1: 				if (version == null)
1: 					version = Version.emptyVersion;
1: 				if (version.equals(child.getVersion())) {
1: 					if (type == null)
1: 						type = SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION;
1: 					if (type.equals(child.getType())) {
1: 						return child;
1: 					}
1: 				}
1: 			}
1: 		}
1: 		return null;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected AriesSubsystem getConstituentAsAriesSubsystem(Subsystem subsystem, String symbolicName, Version version, String type) {
1: 		Resource resource = getConstituent(subsystem, symbolicName, version, type);
1: 		return (AriesSubsystem)resource;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected Subsystem getConstituentAsSubsystem(Subsystem subsystem, String symbolicName, Version version, String type) {
1: 		Resource resource = getConstituent(subsystem, symbolicName, version, type);
1: 		return (Subsystem)resource;
1: 	}
1: 	
1: 	protected Region getRegion(Subsystem subsystem) {
0: 		RegionDigraph digraph = getOsgiService(RegionDigraph.class);
0: 		String name = subsystem.getSymbolicName() + ';' + subsystem.getVersion() + ';' + subsystem.getType() + ';' + subsystem.getSubsystemId();
1: 		Region region = digraph.getRegion(name);
1: 		assertNotNull("Region not found: " + name, region);
1: 		return region;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected FrameworkWiring getSystemBundleAsFrameworkWiring() {
1: 		return getSystemBundle().adapt(FrameworkWiring.class);
1: 	}
1: 	
commit:4fd3b7f
/////////////////////////////////////////////////////////////////////////
1: 		assertSymbolicName(expected, subsystem.getSymbolicName());
1: 	}
1: 	
1: 	protected void assertSymbolicName(String expected, String actual) {
1: 		assertEquals("Wrong symbolic name", expected, actual);
/////////////////////////////////////////////////////////////////////////
1: 		File manifest = new File(name + ".mf");
1: 		ZipFixture fixture = ArchiveFixture.newZip();
1: 		if (manifest.exists())
1: 			// The following input stream is closed by ArchiveFixture.copy.
1: 			fixture.binary("OSGI-INF/SUBSYSTEM.MF", new FileInputStream(name + ".mf"));
commit:590cf45
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.startlevel.BundleStartLevel;
1: import org.osgi.framework.startlevel.FrameworkStartLevel;
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertStartLevel(Bundle bundle, int expected) {
1: 		assertEquals("Wrong start level", expected, bundle.adapt(BundleStartLevel.class).getStartLevel());
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected Bundle getSystemBundle() {
1: 		return bundleContext.getBundle(Constants.SYSTEM_BUNDLE_LOCATION);
1: 	}
1: 	
1: 	protected FrameworkStartLevel getSystemBundleAsFrameworkStartLevel() {
1: 		return getSystemBundle().adapt(FrameworkStartLevel.class);
1: 	}
1: 	
commit:5bd3bf6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.AriesSubsystem;
/////////////////////////////////////////////////////////////////////////
1: 				mavenBundle("org.easymock",					"easymock").versionAsInProject(),
/////////////////////////////////////////////////////////////////////////
1: 	protected AriesSubsystem getRootAriesSubsystem() {
0: 		return getOsgiService(AriesSubsystem.class);
1: 	}
1: 	
commit:47cea41
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.filesystem.FileSystem;
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertClassLoadable(String clazz, Bundle bundle) {
1: 		try {
1: 			bundle.loadClass(clazz);
1: 		}
1: 		catch (Exception e) {
1: 			e.printStackTrace();
1: 			fail("Class " + clazz + " from bundle " + bundle + " should be loadable");
1: 		}
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		return new BundleResource(FileSystem.getFSRoot(file));
commit:8481849
/////////////////////////////////////////////////////////////////////////
1: import org.eclipse.equinox.region.Region;
1: import org.eclipse.equinox.region.RegionDigraph;
/////////////////////////////////////////////////////////////////////////
1: //				org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=7777"),
/////////////////////////////////////////////////////////////////////////
1: 		Region region = null;
0: 		RegionDigraph digraph = getOsgiService(RegionDigraph.class);
1: 				|| subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)) {
0: 			region = digraph.getRegion(b);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		if (subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
0: 				|| subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)) {
1: 			assertNull("Region not removed", digraph.getRegion(region.getName()));
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	protected static String normalizeBundleLocation(String location) {
1: 		if (location.startsWith("initial@"))
1: 			return location.substring(8);
1: 		return location;
1: 	}
commit:b75f264
/////////////////////////////////////////////////////////////////////////
0: 				mavenBundle("org.apache.aries",             "org.apache.aries.util").version("1.0.0"),
0: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller").version("1.0.0"),
0: 				mavenBundle("org.apache.aries.blueprint",   "org.apache.aries.blueprint").version("1.0.0"),
0: 				mavenBundle("org.apache.aries.proxy",       "org.apache.aries.proxy").version("1.0.1-SNAPSHOT"),
0: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.api"),
0: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.core"),
0: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.itest.interfaces"),
0: 				mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit"),
0: 				mavenBundle("org.apache.felix",             "org.apache.felix.resolver"),
1: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.coordinator").version("1.1.0.v20120522-1841"),
0: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.event").version("1.2.200.v20120522-2049"),
1: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.region").version("1.1.0.v20120522-1841"),
0: 				mavenBundle("org.osgi",                     "org.osgi.enterprise").version("5.0.0"),
/////////////////////////////////////////////////////////////////////////
1: 	protected Resource assertConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
1: 		return constituent;
/////////////////////////////////////////////////////////////////////////
1: 	protected String assertHeaderExists(Subsystem subsystem, String name) {
1: 		String header = subsystem.getSubsystemHeaders(null).get(name);
1: 		assertNotNull("Missing header: " + name, header);
1: 		return header;
/////////////////////////////////////////////////////////////////////////
0: 		return new BundleResource(file.toURI().toURL());
commit:27f76f6
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertEmptySubsystem(Subsystem subsystem) {
1:     	assertSymbolicName("org.apache.aries.subsystem.itests.subsystem.empty", subsystem);
1:     	assertVersion("0", subsystem);
1:     	assertType(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, subsystem);
1:     }
1: 	
commit:f615d56
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		// The following input stream is closed by ArchiveFixture.copy.
1: 				// The following input stream is closed by ArchiveFixture.copy.
/////////////////////////////////////////////////////////////////////////
1: 		// The following input stream is closed by the bundle context.
/////////////////////////////////////////////////////////////////////////
1: 		// The following input stream is closed by Subsystem.install.
/////////////////////////////////////////////////////////////////////////
1: 						// The following input stream is closed by ArchiveFixture.copy.
1: 						// The following input stream is closed by ArchiveFixture.copy.
1: 				// The following input stream is closed by ArchiveFixture.copy.
commit:5ddaa55
/////////////////////////////////////////////////////////////////////////
0: 				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.region").version("1.1.0.v20120522-1841"),
0: 				mavenBundle("org.apache.aries", "org.apache.aries.util").version("1.0.0"),
0: 				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.coordinator").version("1.1.0.v20120522-1841"),
0: 				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.event").version("1.2.200.v20120522-2049"),
0: 				equinox().version("3.8.0.V20120529-1548"));
commit:ec9e430
/////////////////////////////////////////////////////////////////////////
0: 				mavenBundle("org.osgi", "org.osgi.enterprise").version("5.0.0"),
commit:391a1aa
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.BundleRevision;
/////////////////////////////////////////////////////////////////////////
1: 		assertServiceEventResolved(subsystem, ServiceEvent.MODIFIED);
/////////////////////////////////////////////////////////////////////////
1: 		assertServiceEventResolved(subsystem, ServiceEvent.MODIFIED);
1: 		assertServiceEventResolved(subsystem, ServiceEvent.UNREGISTERING);
1: 	}
1: 	
1: 	protected void assertServiceEventResolved(Subsystem subsystem, int type) throws InterruptedException {
1: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000), type);
/////////////////////////////////////////////////////////////////////////
1: 	protected Subsystem findSubsystemService(long id) throws InvalidSyntaxException {
1: 		String filter = "(" + SubsystemConstants.SUBSYSTEM_ID_PROPERTY + "=" + id + ")";
0: 		return getOsgiService(Subsystem.class, filter, 5000);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected Bundle getConstituentAsBundle(Subsystem subsystem, String symbolicName, Version version, String type) {
1: 		return getConstituentAsBundleRevision(subsystem, symbolicName, version, type).getBundle();
1: 	}
1: 	
1: 	protected BundleRevision getConstituentAsBundleRevision(Subsystem subsystem, String symbolicName, Version version, String type) {
1: 		Resource resource = getConstituent(subsystem, symbolicName, version, type);
1: 		return (BundleRevision)resource;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected void restartSubsystemsImplBundle() throws BundleException {
1: 		Bundle b = getSubsystemCoreBundle();
1: 		b.stop();
1: 		b.start();
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 		startSubsystemFromInstalled(subsystem);
1: 	}
1: 	
0: 	protected void startSubsystemFromInstalled(Subsystem subsystem) throws InterruptedException {
/////////////////////////////////////////////////////////////////////////
1: 	protected void startSubsystemFromResolved(Subsystem subsystem) throws InterruptedException {
1: 		assertState(State.RESOLVED, subsystem);
1: 		subsystemEvents.clear();
1: 		subsystem.start();
1: 		assertEvent(subsystem, State.STARTING, 5000);
1: 		assertEvent(subsystem, State.ACTIVE, 5000);
1: 		assertState(State.ACTIVE, subsystem);
1: 	}
1: 	
commit:0a1ae8c
/////////////////////////////////////////////////////////////////////////
0: 				mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.itest.interfaces"),
commit:3fb51dc
/////////////////////////////////////////////////////////////////////////
0: 				mavenBundle("org.apache.aries", "org.apache.aries.util").version("1.0.0-SNAPSHOT"),
/////////////////////////////////////////////////////////////////////////
0: //				org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"),
commit:777b216
/////////////////////////////////////////////////////////////////////////
1: 		assertNotNull("No event", event);
commit:225bcae
/////////////////////////////////////////////////////////////////////////
1: 		State state = subsystem.getState();
0: 		if (!EnumSet.of(State.INSTALL_FAILED, State.INSTALLED, State.INSTALLING).contains(state))
1: 			assertEvent(subsystem, State.INSTALLED, 5000);
commit:67ef08f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.internal.BundleResource;
0: import org.apache.aries.subsystem.core.internal.ResourceHelper;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	protected void uninstallSilently(Bundle bundle) {
1: 		if (bundle == null)
1: 			return;
1: 		try {
1: 			bundle.uninstall();
1: 		}
0: 		catch (Exception e) {}
1: 	}
1: 	
commit:5c1fea2
/////////////////////////////////////////////////////////////////////////
0: 				mavenBundle("org.apache.felix", "org.apache.felix.resolver"),
/////////////////////////////////////////////////////////////////////////
commit:3e4b2d5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.felix.resolver.ResolverImpl;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.resolver.Resolver;
/////////////////////////////////////////////////////////////////////////
0: 		serviceRegistrations.add(bundleContext.registerService(Resolver.class, new ResolverImpl(null), null));
commit:276997f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.itests.obr.felix.RepositoryAdminRepository;
commit:52b079f
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, State.INSTALLED, 5000);
commit:428e9f1
/////////////////////////////////////////////////////////////////////////
0: //		assertNotDirectory(subsystem);
commit:df175a6
/////////////////////////////////////////////////////////////////////////
0:     	Bundle bundle = getBundle(subsystem, symbolicName);
1:     	assertBundleState(bundle, state);
1: 	protected void assertBundleState(Bundle bundle, int state) {
0: 		assertNotNull("Bundle not found: " + bundle, bundle);
1: 		assertTrue("Wrong state: " + bundle + " [expected " + state + " but was " + bundle.getState() + "]", (bundle.getState() & state) != 0);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 	protected Bundle getBundle(Subsystem subsystem, String symbolicName) {
0: 		for (Bundle bundle : subsystem.getBundleContext().getBundles()) {
0: 			if (symbolicName.equals(bundle.getSymbolicName())) { 
1: 				return bundle;
1: 			}
1: 		}
1: 		return null;
1: 	}
1: 	
commit:875a6d6
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertNull;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.ProvisionPolicyDirective;
1: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
0: import org.apache.aries.subsystem.core.resource.BundleResource;
1: import org.apache.aries.subsystem.itests.util.TestRepository;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.repository.RepositoryContent;
/////////////////////////////////////////////////////////////////////////
1: 	public void setUp() throws Exception {
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertConstituent(Subsystem subsystem, String symbolicName) {
1: 		assertConstituent(subsystem, symbolicName, Version.emptyVersion);
1: 	}
1: 	
1: 	protected void assertConstituent(Subsystem subsystem, String symbolicName, Version version) {
1: 		assertConstituent(subsystem, symbolicName, version, IdentityNamespace.TYPE_BUNDLE);
1: 	}
1: 	
0: 	protected void assertContituent(Subsystem subsystem, String symbolicName, String type) {
1: 		assertConstituent(subsystem, symbolicName, Version.emptyVersion, type);
1: 	}
1: 	
1: 		Resource constituent = getConstituent(subsystem, symbolicName, version, type);
1: 		assertNotNull("Constituent not found: " + symbolicName + ';' + version + ';' + type, constituent);
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertNotConstituent(Subsystem subsystem, String symbolicName) {
1: 		assertNotConstituent(subsystem, symbolicName, Version.emptyVersion, IdentityNamespace.TYPE_BUNDLE);
1: 	}
1: 	
1: 	protected void assertNotConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
1: 		Resource constituent = getConstituent(subsystem, symbolicName, version, type);
1: 		assertNull("Constituent found: " + symbolicName + ';' + version + ';' + type, constituent);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertProvisionPolicy(Subsystem subsystem, boolean acceptsDependencies) {
1: 		String headerStr = subsystem.getSubsystemHeaders(null).get(SubsystemConstants.SUBSYSTEM_TYPE);
1: 		assertNotNull("Missing subsystem type header", headerStr);
1: 		SubsystemTypeHeader header = new SubsystemTypeHeader(headerStr);
1: 		ProvisionPolicyDirective directive = header.getProvisionPolicyDirective();
1: 		if (acceptsDependencies)
1: 			assertTrue("Subsystem does not accept dependencies", directive.isAcceptDependencies());
1: 		else
1: 			assertTrue("Subsystem accepts dependencies", directive.isRejectDependencies());
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 	protected RepositoryContent createBundleRepositoryContent(String file) throws Exception {
1: 		return createBundleRepositoryContent(new File(file));
1: 	}
1: 	
0: 	protected RepositoryContent createBundleRepositoryContent(File file) throws Exception {
0: 		return BundleResource.newInstance(file.toURI().toURL());
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected Resource getConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
1: 		for (Resource resource : subsystem.getConstituents()) {
0: 			if (symbolicName.equals(ResourceHelper.getSymbolicNameAttribute(resource))) {
1: 				if (version == null)
1: 					version = Version.emptyVersion;
0: 				if (version.equals(ResourceHelper.getVersionAttribute(resource))) {
1: 					if (type == null)
1: 						type = IdentityNamespace.TYPE_BUNDLE;
0: 					if (type.equals(ResourceHelper.getTypeAttribute(resource))) {
1: 						return resource;
1: 					}
1: 				}
1: 			}
1: 		}
0: 		return null;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 		Subsystem subsystem = parent.install(location, content);
/////////////////////////////////////////////////////////////////////////
0: 		// TODO This does not take into account nested directories.
0: //		assertDirectory(subsystem);
1: 	protected void registerRepositoryService(Repository repository) {
1: 		serviceRegistrations.add(bundleContext.registerService(
1: 				Repository.class, repository, null));
1: 	}
1: 	
1: 	protected void registerRepositoryService(Resource...resources) {
1: 		TestRepository.Builder builder = new TestRepository.Builder();
1: 		for (Resource resource : resources) {
1: 			builder.resource(resource);
1: 		}
1: 		registerRepositoryService(builder.build());
1: 	}
1: 	
1: 	protected void registerRepositoryService(String...files) throws Exception {
1: 		Resource[] resources = new Resource[files.length];
1: 		int i = 0;
1: 		for (String file : files) {
1: 			resources[i++] = (Resource)createBundleRepositoryContent(file);
1: 		}
1: 		registerRepositoryService(resources);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected void stopAndUninstallSubsystemSilently(Subsystem subsystem) {
1: 		stopSubsystemSilently(subsystem);
1: 		uninstallSubsystemSilently(subsystem);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		if (subsystem == null)
1: 			return;
commit:95f6444
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.internal.SubsystemIdentifier;
/////////////////////////////////////////////////////////////////////////
1: 		Field lastId = SubsystemIdentifier.class.getDeclaredField("lastId");
1: 		assertEquals("Wrong lastId", id, lastId.getLong(root));
commit:574fba9
/////////////////////////////////////////////////////////////////////////
1: 	protected void stopSubsystemSilently(Subsystem subsystem) {
1: 		try {
1: 			stopSubsystem(subsystem);
1: 		}
1: 		catch (Throwable t) {
1: 			t.printStackTrace();
1: 		}
1: 		Bundle b = null;
0: 		if (subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
0: 				|| subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE))
0: 			b = getRegionContextBundle(subsystem);
/////////////////////////////////////////////////////////////////////////
0: 		if (b != null)
1: 			assertEquals("Region context bundle not uninstalled", Bundle.UNINSTALLED, b.getState());
1: 	protected void uninstallSubsystemSilently(Subsystem subsystem) {
1: 		try {
0: 			uninstallSubsystem(subsystem);
1: 		}
1: 		catch (Throwable t) {
1: 			t.printStackTrace();
1: 		}
commit:7e004f1
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.unittest.fixture.ArchiveFixture.JarFixture;
1: import org.apache.aries.unittest.fixture.ArchiveFixture.ManifestFixture;
1: import org.apache.aries.unittest.fixture.ArchiveFixture.ZipFixture;
/////////////////////////////////////////////////////////////////////////
0: 	protected void assertHeaderExists(Subsystem subsystem, String name) {
0: 		assertNotNull("Missing header: " + name, subsystem.getSubsystemHeaders(null).get(name));
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 	protected static void createBundle(String symbolicName) throws IOException {
0: 		createBundle(symbolicName, null);
1: 	}
1: 	
0: 	protected static void createBundle(String symbolicName, Map<String, String> headers) throws IOException {
0: 		createBundle(symbolicName, null, headers);
1: 	}
1: 	
0: 	protected static void createBundle(String symbolicName, String version, Map<String, String> headers) throws IOException {
0: 		if (headers == null)
0: 			headers = new HashMap<String, String>();
0: 		headers.put(Constants.BUNDLE_SYMBOLICNAME, symbolicName);
0: 		if (version != null)
0: 			headers.put(Constants.BUNDLE_VERSION, version);
0: 		createBundle(headers);
1: 	}
1: 	
0: 	protected static void createBundle(Map<String, String> headers) throws IOException {
0: 		String symbolicName = headers.get(Constants.BUNDLE_SYMBOLICNAME);
1: 		JarFixture bundle = ArchiveFixture.newJar();
1: 		ManifestFixture manifest = bundle.manifest();
1: 		for (Entry<String, String> header : headers.entrySet()) {
1: 			manifest.attribute(header.getKey(), header.getValue());
1: 		}
0: 		write(symbolicName, bundle);
1: 	}
1: 	
1: 	protected static void createManifest(String name, Map<String, String> headers) throws IOException {
1: 		ManifestFixture manifest = ArchiveFixture.newJar().manifest();
1: 		for (Entry<String, String> header : headers.entrySet()) {
1: 			manifest.attribute(header.getKey(), header.getValue());
1: 		}
1: 		write(name, manifest);
1: 	}
1: 	
0: 	protected static void createSubsystem(String name) throws IOException {
0: 		createSubsystem(name, new String[0]);
1: 	}
1: 	
1: 	protected static void createSubsystem(String name, String...contents) throws IOException {
0: 		ZipFixture fixture = ArchiveFixture.newZip().binary("OSGI-INF/SUBSYSTEM.MF", new FileInputStream(name + ".mf"));
1: 		if (contents != null) {
1: 			for (String content : contents) {
1: 				fixture.binary(content, new FileInputStream(content));
1: 			}
1: 		}
1: 		write(name, fixture);
1: 	}
1: 	
commit:7837a59
/////////////////////////////////////////////////////////////////////////
1: 		assertTrue("Wrong state: expected=" + expected + ", actual=" + actual, expected.contains(actual));
commit:deca8ed
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileInputStream;
1: import java.io.FileNotFoundException;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.unittest.fixture.ArchiveFixture;
1: import org.osgi.framework.BundleException;
/////////////////////////////////////////////////////////////////////////
0: 			if (symbolicName.equals(bundle.getSymbolicName())) { 
0: 				assertTrue("Wrong state: " + symbolicName + " [expected " + state + " but was " + bundle.getState() + "]", (bundle.getState() & state) != 0);
0:     	assertTrue("Bundle '" + symbolicName + "' not found in region of '" + subsystem + "'", found);
/////////////////////////////////////////////////////////////////////////
1: 	protected Bundle installBundleFromFile(String fileName) throws FileNotFoundException, BundleException {
0: 		return installBundleFromFile(new File(fileName));
1: 	}
1: 	
0: 	protected Bundle installBundleFromFile(File file) throws FileNotFoundException, BundleException {
0: 		return installBundleFromFile(file, getRootSubsystem());
1: 	}
1: 	
0: 	protected Bundle installBundleFromFile(String file, Subsystem subsystem) throws FileNotFoundException, BundleException {
0: 		return installBundleFromFile(new File(file), subsystem);
1: 	}
1: 	
0: 	protected Bundle installBundleFromFile(File file, Subsystem subsystem) throws FileNotFoundException, BundleException {
1: 		Bundle bundle = installBundleFromFile(file, subsystem.getBundleContext());
1: 		assertBundleState(Bundle.INSTALLED|Bundle.RESOLVED, bundle.getSymbolicName(), subsystem);
0: 		return bundle;
1: 	}
1: 	
0: 	protected Bundle installBundleFromFile(File file, BundleContext bundleContext) throws FileNotFoundException, BundleException {
1: 		return bundleContext.installBundle(file.toURI().toString(), new FileInputStream(file));
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected void startBundle(Bundle bundle) throws BundleException {
1: 		startBundle(bundle, getRootSubsystem());
1: 	}
1: 	
1: 	protected void startBundle(Bundle bundle, Subsystem subsystem) throws BundleException {
1: 		bundle.start();
1: 		assertBundleState(Bundle.ACTIVE, bundle.getSymbolicName(), subsystem);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	protected static void write(String file, ArchiveFixture.AbstractFixture fixture) throws IOException {
1: 		write(new File(file), fixture);
1: 	}
1: 	
0: 	protected static void write(File file, ArchiveFixture.AbstractFixture fixture) throws IOException {
1: 		FileOutputStream fos = new FileOutputStream(file);
1:     	try {
1:     		fixture.writeOut(fos);
1:     	}
1:     	finally {
0:     		fos.close();
1:     	}
1: 	}
commit:71fe81a
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.resource.Resource;
commit:fc759fb
/////////////////////////////////////////////////////////////////////////
0: 	protected Collection<ServiceRegistration<?>> serviceRegistrations = new ArrayList<ServiceRegistration<?>>();
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertBundleState(int state, String symbolicName, Subsystem subsystem) {
0:     	boolean found = false;
0:     	for (Bundle bundle : subsystem.getBundleContext().getBundles()) {
0: 			if (symbolicName.equals(bundle.getSymbolicName())) {
0: 				assertTrue("Wrong state: " + symbolicName, (bundle.getState() & state) != 0);
0: 				found = true;
0: 				break;
1: 			}
1: 		}
0:     	assertTrue("Bundle '" + symbolicName + "' not found in region context bundle of '" + subsystem + "'", found);
1:     }
1: 	
commit:a1c6951
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.namespace.IdentityNamespace;
/////////////////////////////////////////////////////////////////////////
1: 		assertConstituent(s, "org.osgi.service.subsystem.region.context." + s.getSubsystemId(), Version.parseVersion("1.0.0"), IdentityNamespace.TYPE_BUNDLE);
commit:a677a53
/////////////////////////////////////////////////////////////////////////
0: 	protected void uninstallScopedSubsystem(Subsystem subsystem) throws Exception {
0: 		Bundle b = getRegionContextBundle(subsystem);
0: 		uninstallSubsystem(subsystem);
0: 		assertEquals("Region context bundle not uninstalled", Bundle.UNINSTALLED, b.getState());
1: 	}
1: 	
1: 	
0: 	protected void uninstallUnscopedSubsystem(Subsystem subsystem) throws Exception {
0: 		uninstallSubsystem(subsystem);
1: 	}
commit:bda6868
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertServiceEventsInstall(Subsystem subsystem) throws InterruptedException {
1: 		assertEvent(subsystem, Subsystem.State.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 	}
1: 	
1: 	protected void assertServiceEventsResolve(Subsystem subsystem) throws InterruptedException {
1: 		assertEvent(subsystem, Subsystem.State.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 	}
1: 	
1: 	protected void assertServiceEventsStart(Subsystem subsystem) throws InterruptedException {
1: 		assertEvent(subsystem, Subsystem.State.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.ACTIVE, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 	}
1: 	
1: 	protected void assertServiceEventsStop(Subsystem subsystem) throws InterruptedException {
1: 		assertEvent(subsystem, Subsystem.State.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		// Don't forget about the unregistering event, which will have the same state as before.
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000), ServiceEvent.UNREGISTERING);
1: 	}
1: 	
commit:f1ff8f8
/////////////////////////////////////////////////////////////////////////
1: 		Bundle b = getRegionContextBundle(s);
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertType(String expected, Subsystem subsystem) {
1: 		assertEquals("Wrong type", expected, subsystem.getType());
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	protected Bundle getRegionContextBundle(Subsystem subsystem) {
1: 		BundleContext bc = subsystem.getBundleContext();
1: 		assertNotNull("No region context bundle", bc);
1: 		return bc.getBundle();
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, State.INSTALLING, 5000);
0: 		assertEvent(subsystem, State.INSTALLED, 5000);
0: 		assertState(State.INSTALLED, subsystem);
/////////////////////////////////////////////////////////////////////////
1: 		assertEvent(subsystem, State.RESOLVING, 5000);
1: 		assertEvent(subsystem, State.RESOLVED, 5000);
1: 		assertEvent(subsystem, State.STARTING, 5000);
1: 		assertEvent(subsystem, State.ACTIVE, 5000);
/////////////////////////////////////////////////////////////////////////
1: 		assertEvent(subsystem, State.STOPPING, 5000);
1: 		assertEvent(subsystem, State.RESOLVED, 5000);
/////////////////////////////////////////////////////////////////////////
0: 		Bundle b = getRegionContextBundle(subsystem);
1: 		assertEvent(subsystem, State.UNINSTALLING, 5000);
1: 		assertEvent(subsystem, State.UNINSTALLED, 5000);
0: 		assertEquals("Region context bundle not uninstalled", Bundle.UNINSTALLED, b.getState());
commit:5725f09
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.BundleContext;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.resource.ResourceConstants;
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertRegionContextBundle(Subsystem s) {
0: 		BundleContext bc = s.getBundleContext();
0: 		assertNotNull("No region context bundle", bc);
0: 		Bundle b = bc.getBundle();
1: 		assertEquals("Not active", Bundle.ACTIVE, b.getState());
1: 		assertEquals("Wrong location", s.getLocation() + '/' + s.getSubsystemId(), b.getLocation());
1: 		assertEquals("Wrong symbolic name", "org.osgi.service.subsystem.region.context." + s.getSubsystemId(), b.getSymbolicName());
1: 		assertEquals("Wrong version", Version.parseVersion("1.0.0"), b.getVersion());
0: 		assertConstituent(s, "org.osgi.service.subsystem.region.context." + s.getSubsystemId(), Version.parseVersion("1.0.0"), ResourceConstants.IDENTITY_TYPE_BUNDLE);
1: 	}
1: 	
commit:d299aa1
/////////////////////////////////////////////////////////////////////////
0: 		private static class ServiceEventInfo {
0: 			private final ServiceEvent event;
0: 			private final long id;
0: 			private final State state;
0: 			private final String symbolicName;
0: 			private final String type;
0: 			private final Version version;
1: 			
0: 			public ServiceEventInfo(ServiceEvent event) {
0: 				id = (Long)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_ID_PROPERTY);
0: 				state = (State)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_STATE_PROPERTY);
0: 				symbolicName = (String)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME_PROPERTY);
0: 				type = (String)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_TYPE_PROPERTY);
0: 				version = (Version)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_VERSION_PROPERTY);
0: 				this.event = event;
1: 			}
1: 			
0: 			public int getEventType() {
0: 				return event.getType();
1: 			}
1: 			
0: 			public long getId() {
0: 				return id;
1: 			}
1: 			
0: 			public State getState() {
0: 				return state;
1: 			}
1: 			
0: 			public String getSymbolicName() {
0: 				return symbolicName;
1: 			}
1: 			
0: 			public String getType() {
0: 				return type;
1: 			}
1: 			
0: 			public Version getVersion() {
0: 				return version;
1: 			}
1: 		}
1: 		
0: 		private final Map<Long, List<ServiceEventInfo>> subsystemIdToEvents = new HashMap<Long, List<ServiceEventInfo>>();
/////////////////////////////////////////////////////////////////////////
0: 		public ServiceEventInfo poll(long subsystemId) throws InterruptedException {
0: 		public ServiceEventInfo poll(long subsystemId, long timeout) throws InterruptedException {
0: 			List<ServiceEventInfo> events;
0: 					events = new ArrayList<ServiceEventInfo>();
/////////////////////////////////////////////////////////////////////////
0: 				List<ServiceEventInfo> events = subsystemIdToEvents.get(subsystemId);
0: 					events = new ArrayList<ServiceEventInfo>();
0: 					events.add(new ServiceEventInfo(event));
/////////////////////////////////////////////////////////////////////////
1: 			bundleContext.getBundle(0).getBundleContext().addServiceListener(subsystemEvents, '(' + Constants.OBJECTCLASS + '=' + Subsystem.class.getName() + ')');
/////////////////////////////////////////////////////////////////////////
1:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state) throws InterruptedException {
1:  		assertEvent(subsystem, state, 0);
1:  	}
1:  	
1:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, long timeout) throws InterruptedException {
1:  		assertEvent(subsystem, state, subsystemEvents.poll(subsystem.getSubsystemId(), timeout));
1:  	}
1:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemEventHandler.ServiceEventInfo event) {
1:  		if (State.INSTALLING.equals(state))
1: 			assertEvent(subsystem, state, event, ServiceEvent.REGISTERED);
1:  		else
1:  			assertEvent(subsystem, state, event, ServiceEvent.MODIFIED);
1:  	}
1: 	
1: 	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemEventHandler.ServiceEventInfo event, int type) {
1: 		// TODO Could accept a ServiceRegistration as an argument and verify it against the one in the event.
0: 		assertEquals("Wrong ID", subsystem.getSubsystemId(), event.getId());
0: 		assertEquals("Wrong symbolic name", subsystem.getSymbolicName(), event.getSymbolicName());
0: 		assertEquals("Wrong version", subsystem.getVersion(), event.getVersion());
0: 		assertEquals("Wrong type", subsystem.getType(), event.getType());
1: 		assertEquals("Wrong state", state, event.getState());
0: 		assertEquals("Wrong event type", type, event.getEventType());
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 		assertEvent(subsystem, Subsystem.State.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.ACTIVE, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
1: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.ACTIVE, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
commit:1c9c28b
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.fail;
1: import java.lang.reflect.Field;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceEvent;
0: import org.osgi.framework.ServiceListener;
0: 	protected static class SubsystemEventHandler implements ServiceListener {
0: 		private final Map<Long, List<ServiceEvent>> subsystemIdToEvents = new HashMap<Long, List<ServiceEvent>>();
/////////////////////////////////////////////////////////////////////////
0: 		public ServiceEvent poll(long subsystemId) throws InterruptedException {
0: 		public ServiceEvent poll(long subsystemId, long timeout) throws InterruptedException {
0: 			List<ServiceEvent> events;
0: 					events = new ArrayList<ServiceEvent>();
/////////////////////////////////////////////////////////////////////////
0: 		public void serviceChanged(ServiceEvent event) {
0: 			Long subsystemId = (Long)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_ID_PROPERTY);
0: 			synchronized (subsystemIdToEvents) {
0: 				List<ServiceEvent> events = subsystemIdToEvents.get(subsystemId);
0: 				if (events == null) {
0: 					events = new ArrayList<ServiceEvent>();
0: 					subsystemIdToEvents.put(subsystemId, events);
1: 				}
0: 				synchronized (events) {
0: 					events.add(event);
0: 					events.notify();
1: 				}
1: 			}
1: 		}
1: 		
/////////////////////////////////////////////////////////////////////////
1: 				// this is how you set the default log level when using pax
1: 				// logging (logProfile)
1: 				systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("INFO"),
1: 				systemProperty("org.osgi.framework.bsnversion").value("multiple"),
0: //				mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
0: 				mavenBundle("org.eclipse.osgi", "org.eclipse.osgi.services").version("3.8.0-SNAPSHOT"),
0: 				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.region").version("3.8.0-SNAPSHOT"),
0: 				mavenBundle("org.apache.aries", "org.apache.aries.util").version("0.5-SNAPSHOT"),
0: 				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.coordinator").version("3.8.0-SNAPSHOT"),
0: 				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.event").version("3.8.0-SNAPSHOT"),
/////////////////////////////////////////////////////////////////////////
0: 	private Collection<ServiceRegistration<?>> serviceRegistrations = new ArrayList<ServiceRegistration<?>>();
0: 		serviceRegistrations.add(bundleContext.registerService(Repository.class, new RepositoryAdminRepository(getOsgiService(RepositoryAdmin.class)), null));
1: 		try {
0: 			bundleContext.addServiceListener(subsystemEvents, '(' + Constants.OBJECTCLASS + '=' + Subsystem.class + ')');
1: 		}
0: 		catch (InvalidSyntaxException e) {
0: 			fail("Invalid filter: " + e.getMessage());
1: 		}
0: 		assertSubsystemNotNull(getRootSubsystem());
1: 		bundleContext.removeServiceListener(subsystemEvents);
0: 		for (ServiceRegistration<?> registration : serviceRegistrations)
1: 			Utils.unregisterQuietly(registration);
0: 		serviceRegistrations.clear();
/////////////////////////////////////////////////////////////////////////
0: // 	protected void assertEvent(Subsystem subsystem, Subsystem.State state) throws InterruptedException {
0: // 		assertEvent(subsystem, state, 0);
0: // 	}
0: // 	
0: // 	protected void assertEvent(Subsystem subsystem, Subsystem.State state, long timeout) throws InterruptedException {
0: // 		assertEvent(subsystem, state, subsystemEvents.poll(subsystem.getSubsystemId(), timeout));
0: // 	}
0: //	
0: //	protected void assertEvent(Subsystem subsystem, Subsystem.State state, ServiceEvent event) {
0: //		// TODO Could accept a ServiceRegistration as an argument and verify it against the one in the event.
0: //		assertEquals("Wrong ID", subsystem.getSubsystemId(), event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_ID_PROPERTY));
0: //		assertEquals("Wrong symbolic name", subsystem.getSymbolicName(), event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME_PROPERTY));
0: //		assertEquals("Wrong version", String.valueOf(subsystem.getVersion()), event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_VERSION_PROPERTY));
0: //		assertEquals("Wrong type", subsystem.getType(), event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_TYPE_PROPERTY));
0: //		assertEquals("Wrong state", String.valueOf(state), event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_STATE_PROPERTY));
0: //	}
/////////////////////////////////////////////////////////////////////////
0: 	protected void assertLastId(long id) throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
1: 		Subsystem root = getRootSubsystem();
0: 		Field lastId = root.getClass().getDeclaredField("lastId");
1: 		lastId.setAccessible(true);
0: 		assertEquals("Incorrect value for lastId", id, lastId.getLong(root));
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		for (Subsystem parent : subsystem.getParents()) {
1: 			if (parent.equals(expected))
1: 				return;
1: 			
1: 		}
1: 		fail("Parent did not exist: " + expected.getSymbolicName());
/////////////////////////////////////////////////////////////////////////
0: //		assertEvent(subsystem, Subsystem.State.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.ACTIVE, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
1: 	protected Subsystem getRootSubsystem() {
0: 		return getOsgiService(Subsystem.class);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 		return installSubsystem(getRootSubsystem(), file.toURI().toURL().toExternalForm());
1: 		return installSubsystem(getRootSubsystem(), location);
1: 		return installSubsystem(getRootSubsystem(), location, content);
/////////////////////////////////////////////////////////////////////////
0: 		Subsystem subsystem = getRootSubsystem().install(location, content);
0: //		assertEvent(subsystem, Subsystem.State.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: //		assertEvent(subsystem, Subsystem.State.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.ACTIVE, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: //		assertEvent(subsystem, Subsystem.State.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		Collection<Subsystem> parents = subsystem.getParents();
0: //		assertEvent(subsystem, Subsystem.State.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: //		assertEvent(subsystem, Subsystem.State.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		for (Subsystem parent : parents)
1: 			assertNotChild(parent, subsystem);
commit:0c3bb10
/////////////////////////////////////////////////////////////////////////
0: import junit.framework.Assert;
1: 
0: import org.apache.aries.subsystem.core.ResourceHelper;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.resource.Resource;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.subsystem.SubsystemConstants.EVENT_TYPE;
0: 	protected static class SubsystemEventHandler implements EventHandler {
/////////////////////////////////////////////////////////////////////////
1: 	protected final SubsystemEventHandler subsystemEvents = new SubsystemEventHandler();
0: 	protected final SubsystemEventHandler subsystemInternalEvents = new SubsystemEventHandler();
/////////////////////////////////////////////////////////////////////////
0: 	protected void assertConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
0: 		for (Resource resource : subsystem.getConstituents()) {
0: 			if (symbolicName.equals(ResourceHelper.getSymbolicNameAttribute(resource))) {
0: 				if (version != null)
0: 					assertVersion(version, ResourceHelper.getVersionAttribute(resource));
0: 				if (type != null)
0: 					assertEquals("Wrong type", type, ResourceHelper.getTypeAttribute(resource));
0: 				return;
1: 			}
1: 		}
0: 		Assert.fail("Constituent not found: " + symbolicName);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		assertVersion(expected, subsystem.getVersion());
1: 	}
1: 	
1: 	protected void assertVersion(Version expected, Version actual) {
1: 		assertEquals("Wrong version", expected, actual);
commit:046b8ec
/////////////////////////////////////////////////////////////////////////
0: 				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.resolver").version("1.0.0-SNAPSHOT"),
commit:ead9c04
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.subsystem.SubsystemConstants.EVENT_TYPE;;
/////////////////////////////////////////////////////////////////////////
0: 			Long subsystemId = (Long)event.getProperty(SubsystemConstants.EVENT_SUBSYSTEM_ID);
/////////////////////////////////////////////////////////////////////////
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemConstants.EVENT_TYPE type) throws InterruptedException {
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemConstants.EVENT_TYPE type, long timeout) throws InterruptedException {
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemConstants.EVENT_TYPE type, Event event) {
0: 	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemConstants.EVENT_TYPE type, Event event, Throwable throwable) {
0: 		assertEquals("Wrong ID", subsystem.getSubsystemId(), event.getProperty(SubsystemConstants.EVENT_SUBSYSTEM_ID));
0: 		assertEquals("Wrong location", subsystem.getLocation(), event.getProperty(SubsystemConstants.EVENT_SUBSYSTEM_LOCATION));
0: 		if (!EVENT_TYPE.INSTALLING.equals(type)) {
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.INSTALLING, SubsystemConstants.EVENT_TYPE.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.INSTALLED, SubsystemConstants.EVENT_TYPE.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVING, SubsystemConstants.EVENT_TYPE.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EVENT_TYPE.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.STARTING, SubsystemConstants.EVENT_TYPE.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.ACTIVE, SubsystemConstants.EVENT_TYPE.STARTED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.STOPPING, SubsystemConstants.EVENT_TYPE.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EVENT_TYPE.STOPPED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, SubsystemConstants.EVENT_TYPE.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, SubsystemConstants.EVENT_TYPE.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.INSTALLING, SubsystemConstants.EVENT_TYPE.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.INSTALLED, SubsystemConstants.EVENT_TYPE.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.RESOLVING, SubsystemConstants.EVENT_TYPE.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EVENT_TYPE.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.STARTING, SubsystemConstants.EVENT_TYPE.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.ACTIVE, SubsystemConstants.EVENT_TYPE.STARTED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.STOPPING, SubsystemConstants.EVENT_TYPE.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EVENT_TYPE.STOPPED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, SubsystemConstants.EVENT_TYPE.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, SubsystemConstants.EVENT_TYPE.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
commit:4717af0
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.subsystem.SubsystemConstants.EventType;
0: 		private final Map<Long, List<Event>> subsystemIdToEvents = new HashMap<Long, List<Event>>();
0: 		public void clear() {
0: 			synchronized (subsystemIdToEvents) {
0: 				subsystemIdToEvents.clear();
0: 		public void handleEvent(Event event) {
0: 			Long subsystemId = (Long)event.getProperty(SubsystemConstants.SUBSYSTEM_ID);
0: 			synchronized (subsystemIdToEvents) {
0: 				List <Event> events = subsystemIdToEvents.get(subsystemId);
0: 				if (events == null) {
0: 					events = new ArrayList<Event>();
0: 					subsystemIdToEvents.put(subsystemId, events);
1: 				}
0: 				synchronized (events) {
0: 					events.add(event);
0: 					events.notify();
1: 				}
0: 		public Event poll(long subsystemId) throws InterruptedException {
0: 			return poll(subsystemId, 0);
1: 		}
1: 		
0: 		public Event poll(long subsystemId, long timeout) throws InterruptedException {
0: 			List<Event> events;
0: 			synchronized (subsystemIdToEvents) {
0: 				events = subsystemIdToEvents.get(subsystemId);
0: 				if (events == null) {
0: 					events = new ArrayList<Event>();
0: 					subsystemIdToEvents.put(subsystemId, events);
1: 				}
1: 			}
0: 			synchronized (events) {
0: 				if (events.isEmpty()) {
0: 					events.wait(timeout);
0: 					if (events.isEmpty()) {
0: 						return null;
1: 					}
1: 				}
0: 				return events.remove(0);
1: 			}
1: 		}
1: 		
0: 		public int size() {
0: 			synchronized (subsystemIdToEvents) {
0: 				return subsystemIdToEvents.size();
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertChildren(int size, Subsystem subsystem) {
1: 		assertEquals("Wrong number of children", size, subsystem.getChildren().size());
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  	
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemConstants.EventType type) throws InterruptedException {
0:  		assertEvent(subsystem, state, type, 0);
1:  	}
1:  	
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemConstants.EventType type, long timeout) throws InterruptedException {
0:  		assertEvent(subsystem, state, type, subsystemEvents.poll(subsystem.getSubsystemId(), timeout));
1:  	}
1:  	
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemConstants.EventType type, Event event) {
0: 		assertEvent(subsystem, state, type, event, null);
1: 	}
0: 		if (!EventType.INSTALLING.equals(type)) {
0: 			assertEquals("Wrong symbolic name", subsystem.getSymbolicName(), event.getProperty(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME));
0: 			assertEquals("Wrong version", String.valueOf(subsystem.getVersion()), event.getProperty(SubsystemConstants.SUBSYSTEM_VERSION));
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.INSTALLING, SubsystemConstants.EventType.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.INSTALLED, SubsystemConstants.EventType.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVING, SubsystemConstants.EventType.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EventType.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.STARTING, SubsystemConstants.EventType.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.ACTIVE, SubsystemConstants.EventType.STARTED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.STOPPING, SubsystemConstants.EventType.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EventType.STOPPED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, SubsystemConstants.EventType.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, SubsystemConstants.EventType.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.INSTALLING, SubsystemConstants.EventType.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.INSTALLED, SubsystemConstants.EventType.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.RESOLVING, SubsystemConstants.EventType.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EventType.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.STARTING, SubsystemConstants.EventType.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.ACTIVE, SubsystemConstants.EventType.STARTED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
/////////////////////////////////////////////////////////////////////////
0: 		assertEvent(subsystem, Subsystem.State.STOPPING, SubsystemConstants.EventType.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EventType.STOPPED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		Subsystem parent = subsystem.getParent();
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, SubsystemConstants.EventType.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, SubsystemConstants.EventType.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertConstituents(0, subsystem);
0: 		assertNotChild(parent, subsystem);
commit:226c63f
/////////////////////////////////////////////////////////////////////////
0: 				equinox().version("3.8.0-SNAPSHOT"));
commit:e6bf465
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.obr.felix.RepositoryAdminRepository;
0: import org.apache.aries.subsystem.itests.util.RepositoryGenerator;
1: import org.apache.aries.subsystem.itests.util.Utils;
0: import org.apache.felix.bundlerepository.RepositoryAdmin;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.repository.Repository;
/////////////////////////////////////////////////////////////////////////
0: 	private ServiceRegistration<Repository> repositoryReg;
0: 		new RepositoryGenerator(bundleContext).generateOBR();
0: 		repositoryReg = bundleContext.registerService(Repository.class, new RepositoryAdminRepository(getOsgiService(RepositoryAdmin.class)), null);
/////////////////////////////////////////////////////////////////////////
0: 		Utils.unregisterQuietly(repositoryReg);
commit:e8a0b01
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.subsystem.itests;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
0: import static org.ops4j.pax.exam.CoreOptions.equinox;
0: import static org.ops4j.pax.exam.CoreOptions.options;
1: import static org.ops4j.pax.exam.CoreOptions.systemProperty;
1: 
1: import java.io.File;
1: import java.io.InputStream;
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.Collection;
0: import java.util.Dictionary;
1: import java.util.EnumSet;
0: import java.util.Hashtable;
1: import java.util.List;
1: 
1: import org.ops4j.pax.exam.Option;
0: import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.ServiceRegistration;
1: import org.osgi.framework.Version;
0: import org.osgi.service.event.Event;
0: import org.osgi.service.event.EventConstants;
0: import org.osgi.service.event.EventHandler;
1: import org.osgi.service.subsystem.Subsystem;
1: import org.osgi.service.subsystem.Subsystem.State;
1: import org.osgi.service.subsystem.SubsystemConstants;
1: 
0: public abstract class SubsystemTest extends IntegrationTest {
0: 	protected static class SubsystemTestEventHandler implements EventHandler {
0: 		private final List<Event> events = new ArrayList<Event>();
1: 		
0: 		public synchronized void clear() {
0: 			events.clear();
1: 		}
1: 		
0: 		public synchronized Event get() {
0: 			if (events.isEmpty()) {
0: 				return null;
1: 			}
0: 			return events.remove(0);
1: 		}
1: 		
0: 		public synchronized void handleEvent(Event event) {
0: 			events.add(event);
0: 			notifyAll();
1: 		}
1: 		
0: 		public synchronized Event poll() throws InterruptedException {
0: 			return poll(0);
1: 		}
1: 		
0: 		public synchronized Event poll(long timeout) throws InterruptedException {
0: 			if (events.isEmpty()) {
0: 				wait(timeout);
1: 			}
0: 			return get();
1: 		}
1: 		
0: 		public synchronized int size() {
0: 			return events.size();
1: 		}
1: 	}
1: 	
0: 	@org.ops4j.pax.exam.junit.Configuration
0: 	public static Option[] configuration() {
0: 		Option[] options = options(
0: 				// Log
0: 				mavenBundle("org.ops4j.pax.logging", "pax-logging-api"),
0: 				mavenBundle("org.ops4j.pax.logging", "pax-logging-service"),
0: 				// Felix Config Admin
0: 				mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
0: 				// Felix mvn url handler
0: 				mavenBundle("org.ops4j.pax.url", "pax-url-mvn"),
0: 				// this is how you set the default log level when using pax
0: 				// logging (logProfile)
0: 				systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("DEBUG"),
0: 				systemProperty("org.osgi.framework.bsnversion").value("multiple"),
1: 				// Bundles
0: 				mavenBundle("org.eclipse.osgi", "services").version("3.3.0-v20110523"),
0: 				mavenBundle("org.eclipse.equinox", "region").version("1.0.0.v20110518"),
0: 				mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit"),
0: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.api"),
0: 				mavenBundle("org.apache.aries", "org.apache.aries.util"),
0: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils"),
0: 				mavenBundle("org.apache.felix", "org.apache.felix.bundlerepository"),
0: 				mavenBundle("org.eclipse.equinox", "coordinator"),
0: 				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.event"),
0: 				mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.api"),
0: 				mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.core"),
0: 				mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.executor"),
0: //				org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"),
0: 				PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
0: 				equinox().version("3.8.0.v20110621"));
0: 		options = updateOptions(options);
0: 		return options;
1: 	}
1: 	
0: 	protected final SubsystemTestEventHandler subsystemEvents = new SubsystemTestEventHandler();
0: 	protected final SubsystemTestEventHandler subsystemInternalEvents = new SubsystemTestEventHandler();
1: 	
0: 	protected Subsystem rootSubsystem;
1: 	
0: 	private ServiceRegistration<EventHandler> subsystemEventsReg;
0: 	private ServiceRegistration<EventHandler> subsystemInternalEventsReg;
1: 	
0: 	public void setUp() {
0: 		super.setUp();
0: 		Dictionary<String, Object> d = new Hashtable<String, Object>();
0: 		d.put(EventConstants.EVENT_TOPIC, new String[]{"org/osgi/service/Subsystem/*"});
0: 		subsystemEventsReg = bundleContext.registerService(EventHandler.class, subsystemEvents, d);
0: 		d.put(EventConstants.EVENT_TOPIC, new String[]{"org/osgi/service/SubsystemInternals/*"});
0: 		subsystemInternalEventsReg = bundleContext.registerService(EventHandler.class, subsystemInternalEvents, d);
0: 		rootSubsystem = getOsgiService(Subsystem.class);
0: 		assertSubsystemNotNull(rootSubsystem);
1: 	}
1: 	
0: 	public void tearDown() {
0: 		Utils.unregisterQuietly(subsystemInternalEventsReg);
0: 		Utils.unregisterQuietly(subsystemEventsReg);
0: 		super.tearDown();
1: 	}
1: 	
1: 	protected void assertChild(Subsystem parent, Subsystem child) {
1: 		Collection<Subsystem> children = new ArrayList<Subsystem>(1);
1: 		children.add(child);
1: 		assertChildren(parent, children);
1: 	}
1: 	
1: 	protected void assertChildren(Subsystem parent, Collection<Subsystem> children) {
1: 		assertTrue("Parent did not contain all children", parent.getChildren().containsAll(children));
1: 	}
1: 	
1: 	protected void assertConstituents(int size, Subsystem subsystem) {
1: 		assertEquals("Wrong number of constituents", size, subsystem.getConstituents().size());
1: 	}
1: 	
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemConstants.EventType type, Event event) {
0: 		assertEvent(subsystem, state, type, event, null);
1: 	}
1:  	
0:  	protected void assertDirectory(Subsystem subsystem) {
0:  		Bundle bundle = getSubsystemCoreBundle();
0:  		File file = bundle.getDataFile("subsystem" + subsystem.getSubsystemId());
0:  		assertNotNull("Subsystem data file was null", file);
0:  		assertTrue("Subsystem data file does not exist", file.exists());
1:  	}
1:  	
0:  	protected void assertNotDirectory(Subsystem subsystem) {
0:  		Bundle bundle = getSubsystemCoreBundle();
0:  		File file = bundle.getDataFile("subsystem" + subsystem.getSubsystemId());
0:  		assertNotNull("Subsystem data file was null", file);
0:  		assertFalse("Subsystem data file exists", file.exists());
1:  	}
1: 	
0: 	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemConstants.EventType type, Event event, Throwable throwable) {
0: 		assertNotNull("The event was null", event);
0: 		assertTrue("Wrong topic: " + event.getTopic(), event.getTopic().endsWith(type.name()));
0: 		assertEquals("Wrong ID", subsystem.getSubsystemId(), event.getProperty(SubsystemConstants.SUBSYSTEM_ID));
0: 		assertEquals("Wrong location", subsystem.getLocation(), event.getProperty(SubsystemConstants.SUBSYSTEM_LOCATION));
0: 		assertEquals("Wrong symbolic name", subsystem.getSymbolicName(), event.getProperty(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME));
0: 		assertEquals("Wrong version", String.valueOf(subsystem.getVersion()), event.getProperty(SubsystemConstants.SUBSYSTEM_VERSION));
0: 		assertEquals("Wrong state", String.valueOf(state), event.getProperty("subsystem.state"));
0: 		assertNotNull("Missing timestamp", event.getProperty(EventConstants.TIMESTAMP));
0: 		if (throwable == null) {
0: 			assertNull("Exception not expected", event.getProperty(EventConstants.EXCEPTION));
0: 			assertNull("Exception class not expected", event.getProperty(EventConstants.EXCEPTION_CLASS));
0: 			assertNull("Exception message not expected", event.getProperty(EventConstants.EXCEPTION_MESSAGE));
1: 		}
0: 		else {
0: 			assertTrue("Wrong exception", event.getProperty(EventConstants.EXCEPTION) instanceof Throwable);
0: 			assertEquals("Wrong exception class", throwable.getClass().getName(), event.getProperty(EventConstants.EXCEPTION_CLASS));
0: 			assertTrue("Wrong message", ((String)event.getProperty(EventConstants.EXCEPTION_MESSAGE)).indexOf(throwable.getMessage()) != -1);
1: 		}
1: 	}
1: 	
1: 	protected void assertId(Subsystem subsystem) {
1: 		assertId(subsystem.getSubsystemId());
1: 	}
1: 	
1: 	protected void assertId(Long id) {
1: 		assertTrue("Subsystem ID was not a positive integer: " + id, id > 0);
1: 	}
1: 	
1: 	protected void assertLocation(String expected, String actual) {
1: 		assertTrue("Wrong location: " + actual, actual.indexOf(expected) != -1);
1: 	}
1: 	
1: 	protected void assertLocation(String expected, Subsystem subsystem) {
1: 		assertLocation(expected, subsystem.getLocation());
1: 	}
1: 	
1: 	protected void assertNotChild(Subsystem parent, Subsystem child) {
1: 		assertFalse("Parent contained child", parent.getChildren().contains(child));
1: 	}
1: 	
1: 	protected void assertParent(Subsystem expected, Subsystem subsystem) {
0: 		assertEquals("Wrong parent", expected, subsystem.getParent());
1: 	}
1: 	
1: 	protected void assertState(State expected, State actual) {
1: 		assertState(EnumSet.of(expected), actual);
1: 	}
1: 	
1: 	protected void assertState(EnumSet<State> expected, State actual) {
0: 		assertTrue("Wrong state: " + actual, expected.contains(actual));
1: 	}
1: 	
1: 	protected void assertState(State expected, Subsystem subsystem) {
1: 		assertState(expected, subsystem.getState());
1: 	}
1: 	
1: 	protected void assertState(EnumSet<State> expected, Subsystem subsystem) {
1: 		assertState(expected, subsystem.getState());
1: 	}
1: 	
1: 	protected Subsystem assertSubsystemLifeCycle(File file) throws Exception {
0: 		Subsystem rootSubsystem = getOsgiService(Subsystem.class);
1:         assertNotNull("Root subsystem was null", rootSubsystem);
1:         Subsystem subsystem = rootSubsystem.install(file.toURI().toURL().toExternalForm());
1:         assertNotNull("The subsystem was null", subsystem);
1:         assertState(EnumSet.of(State.INSTALLING, State.INSTALLED), subsystem.getState());
0: 		assertEvent(subsystem, Subsystem.State.INSTALLING, SubsystemConstants.EventType.INSTALLING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.INSTALLED, SubsystemConstants.EventType.INSTALLED, subsystemEvents.poll(5000));
1: 		assertChild(rootSubsystem, subsystem);
1:         subsystem.start();
1:         assertState(EnumSet.of(State.RESOLVING, State.RESOLVED, State.STARTING, State.ACTIVE), subsystem.getState());
0: 		assertEvent(subsystem, Subsystem.State.RESOLVING, SubsystemConstants.EventType.RESOLVING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EventType.RESOLVED, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.STARTING, SubsystemConstants.EventType.STARTING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.ACTIVE, SubsystemConstants.EventType.STARTED, subsystemEvents.poll(5000));
1: 		subsystem.stop();
1: 		assertState(EnumSet.of(State.STOPPING, State.RESOLVED), subsystem.getState());
0: 		assertEvent(subsystem, Subsystem.State.STOPPING, SubsystemConstants.EventType.STOPPING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EventType.STOPPED, subsystemEvents.poll(5000));
0: 		// TODO Add update.
1: 		subsystem.uninstall();
1: 		assertState(EnumSet.of(State.UNINSTALLING, State.UNINSTALLED), subsystem.getState());
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, SubsystemConstants.EventType.UNINSTALLING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, SubsystemConstants.EventType.UNINSTALLED, subsystemEvents.poll(5000));
1: 		assertNotChild(rootSubsystem, subsystem);
1: 		return subsystem;
1: 	}
1: 	
1: 	protected void assertSubsystemNotNull(Subsystem subsystem) {
1: 		assertNotNull("Subsystem was null", subsystem);
1: 	}
1: 	
1: 	protected void assertSymbolicName(String expected, Subsystem subsystem) {
0: 		assertEquals("Wrong symbolic name: " + subsystem.getSymbolicName(), expected, subsystem.getSymbolicName());
1: 	}
1: 	
1: 	protected void assertVersion(String expected, Subsystem subsystem) {
1: 		assertVersion(Version.parseVersion(expected), subsystem);
1: 	}
1: 	
1: 	protected void assertVersion(Version expected, Subsystem subsystem) {
0: 		assertEquals("Wrong version: " + subsystem.getVersion(), expected, subsystem.getVersion());
1: 	}
1: 	
1: 	protected Bundle getSubsystemCoreBundle() {
0: 		return findBundleBySymbolicName("org.apache.aries.subsystem.core");
1: 	}
1: 	
1: 	protected Subsystem installSubsystemFromFile(Subsystem parent, String fileName) throws Exception {
1: 		return installSubsystemFromFile(parent, new File(fileName));
1: 	}
1: 	
0: 	protected Subsystem installSubsystemFromFile(String fileName) throws Exception {
0: 		return installSubsystemFromFile(new File(fileName));
1: 	}
1: 	
1: 	protected Subsystem installSubsystemFromFile(Subsystem parent, File file) throws Exception {
1: 		return installSubsystem(parent, file.toURI().toURL().toExternalForm());
1: 	}
1: 	
0: 	protected Subsystem installSubsystemFromFile(File file) throws Exception {
0: 		return installSubsystem(rootSubsystem, file.toURI().toURL().toExternalForm());
1: 	}
1: 	
1: 	protected Subsystem installSubsystem(String location) throws Exception {
0: 		return installSubsystem(rootSubsystem, location);
1: 	}
1: 	
1: 	protected Subsystem installSubsystem(String location, InputStream content) throws Exception {
0: 		return installSubsystem(rootSubsystem, location, content);
1: 	}
1: 	
0: 	protected Subsystem installSubsystem(Subsystem parent, String location) throws Exception {
0: 		return installSubsystem(parent, location, new URL(location).openStream());
1: 	}
1: 	
0: 	protected Subsystem installSubsystem(Subsystem parent, String location, InputStream content) throws Exception {
1: 		subsystemEvents.clear();
0: 		Subsystem subsystem = rootSubsystem.install(location, content);
0: 		assertSubsystemNotNull(subsystem);
0: 		assertChild(parent, subsystem);
0: 		assertLocation(location, subsystem);
0: 		assertParent(parent, subsystem);
0: 		assertState(EnumSet.of(State.INSTALLED, State.INSTALLING), subsystem);
0: 		assertLocation(location, subsystem);
0: 		assertId(subsystem);
0: 		assertDirectory(subsystem);
0: 		assertEvent(subsystem, Subsystem.State.INSTALLING, SubsystemConstants.EventType.INSTALLING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.INSTALLED, SubsystemConstants.EventType.INSTALLED, subsystemEvents.poll(5000));
0: 		assertState(State.INSTALLED, subsystem);
1: 		return subsystem;
1: 	}
1: 	
0: 	protected void startSubsystem(Subsystem subsystem) throws Exception {
0: 		assertState(State.INSTALLED, subsystem);
1: 		subsystemEvents.clear();
1: 		subsystem.start();
0: 		assertState(EnumSet.of(State.RESOLVING, State.RESOLVED, State.STARTING, State.ACTIVE), subsystem);
0: 		assertEvent(subsystem, Subsystem.State.RESOLVING, SubsystemConstants.EventType.RESOLVING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EventType.RESOLVED, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.STARTING, SubsystemConstants.EventType.STARTING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.ACTIVE, SubsystemConstants.EventType.STARTED, subsystemEvents.poll(5000));
1: 		assertState(State.ACTIVE, subsystem);
1: 	}
1: 	
1: 	protected void stopSubsystem(Subsystem subsystem) throws Exception {
1: 		assertState(State.ACTIVE, subsystem);
1: 		subsystemEvents.clear();
1: 		subsystem.stop();
0: 		assertState(EnumSet.of(State.STOPPING, State.RESOLVED), subsystem);
0: 		assertEvent(subsystem, Subsystem.State.STOPPING, SubsystemConstants.EventType.STOPPING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, SubsystemConstants.EventType.STOPPED, subsystemEvents.poll(5000));
1: 		assertState(State.RESOLVED, subsystem);
1: 	}
1: 	
1: 	protected void uninstallSubsystem(Subsystem subsystem) throws Exception {
0: 		assertState(EnumSet.of(State.INSTALLED, State.RESOLVED), subsystem);
1: 		subsystemEvents.clear();
1: 		subsystem.uninstall();
0: 		assertState(EnumSet.of(State.UNINSTALLED, State.UNINSTALLING), subsystem);
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, SubsystemConstants.EventType.UNINSTALLING, subsystemEvents.poll(5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, SubsystemConstants.EventType.UNINSTALLED, subsystemEvents.poll(5000));
1: 		assertState(State.UNINSTALLED, subsystem);
1: 		assertNotChild(rootSubsystem, subsystem);
0: 		assertNotDirectory(subsystem);
1: 	}
1: }
author:Tom Watson
-------------------------------------------------------------------------------
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				//mavenBundle("org.apache.felix",             "org.apache.felix.resolver").versionAsInProject(),
/////////////////////////////////////////////////////////////////////////
1: 	protected Resource createBundleRepositoryContent(String file) throws Exception {
1: 	protected Resource createBundleRepositoryContent(File file) throws Exception {
/////////////////////////////////////////////////////////////////////////
1: 	protected static String normalizeBundleLocation(Bundle bundle) {
1: 		return normalizeBundleLocation(bundle.getLocation());
0: 	}
0: 	
commit:a6b79e8
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1: 		createBundle(Collections.<String> emptyList(), headers);
0: 	}
0: 
1: 	protected static void createBundle(List<String> emptyFiles, Header...  headers) throws IOException {
1: 		createBundle(emptyFiles, headerMap);
0: 	private static void createBundle(List<String> emptyFiles, Map<String, String> headers) throws IOException 
/////////////////////////////////////////////////////////////////////////
1: 		for (String path : emptyFiles) {
1: 			bundle.file(path).end();
0: 		}
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:79b20bc
/////////////////////////////////////////////////////////////////////////
1:     boolean installConfigAdmin = false;
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:                 when(installConfigAdmin).useOptions(
1:                         mavenBundle("org.apache.felix",     "org.apache.felix.configadmin").versionAsInProject()),
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:      * @return stream containing the fragment
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1: 	public void tearDown() throws Exception
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 		assertEquals("Wrong start level", expected, bundle.adapt(BundleStartLevel.class).getStartLevel());
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 	private static void createBundle(List<String> emptyFiles, Map<String, String> headers) throws IOException
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 		return getSystemBundle().adapt(FrameworkStartLevel.class);
0: 
0: 		return getSystemBundle().adapt(FrameworkWiring.class);
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     protected static void write(String file, ArchiveFixture.AbstractFixture fixture) throws IOException
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1: 	static void createApplication(String name, String ... contents) throws Exception
/////////////////////////////////////////////////////////////////////////
0: 
0: 
author:Christian Schneider
-------------------------------------------------------------------------------
commit:7c69962
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.TypeAttribute;
/////////////////////////////////////////////////////////////////////////
1: import org.ops4j.io.StreamUtils;
0: import org.ops4j.pax.exam.CoreOptions;
1: import org.ops4j.pax.tinybundles.core.TinyBundles;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.resource.Capability;
/////////////////////////////////////////////////////////////////////////
1: 	private static final String SUBSYSTEM_CORE_NAME = "org.apache.aries.subsystem.core";
1:     protected static boolean createdApplications = false;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	    new File("target").mkdirs();
1: 	    init();
/////////////////////////////////////////////////////////////////////////
1: 				when(installModeler).useOptions(modelerBundles()),
1: 				mavenBundle("org.apache.aries.subsystem",   SUBSYSTEM_CORE_NAME).versionAsInProject(),
1: 				streamBundle(createCoreFragment()).noStart(),
/////////////////////////////////////////////////////////////////////////
0: 
1:     protected void init() throws Exception {
0:        
0:     }
0: 
1:     private Option modelerBundles() {
1:         return CoreOptions.composite(
1:         		mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller").versionAsInProject(),
1:         		mavenBundle("org.apache.aries.blueprint",   "org.apache.aries.blueprint").versionAsInProject(),
1:         		mavenBundle("org.apache.aries.proxy",       "org.apache.aries.proxy").versionAsInProject());
0:     }
0: 
1:     /**
1:      * The itests need private packages from the core subsystems bundle.
1:      * So this fragment exports them.
0:      * @return stream containing the fragment 
1:      */
1:     private InputStream createCoreFragment() {
1: 	return TinyBundles.bundle()
1: 	    .set("Bundle-SymbolicName", SUBSYSTEM_CORE_NAME + ".fragment")
1: 	    .set("Export-Package", "org.apache.aries.subsystem.core.internal,org.apache.aries.subsystem.core.archive")
1: 	    .set("Fragment-Host", SUBSYSTEM_CORE_NAME)
1: 	    .build();
0:     }
1: 	@SuppressWarnings("rawtypes")
1:     protected Collection<ServiceRegistration> serviceRegistrations = new ArrayList<ServiceRegistration>();
/////////////////////////////////////////////////////////////////////////
0: 		bundleContext.getBundle(0).getBundleContext().addServiceListener(subsystemEvents, '(' + Constants.OBJECTCLASS + '=' + Subsystem.class.getName() + ')');
0: 	protected void createApplications() throws Exception {
0: 	}
1: 	@SuppressWarnings("rawtypes")
1:     @After
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public static Object getIdentityAttribute(Resource resource, String name) {
1: 	    List<Capability> capabilities = resource.getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE);
1:         Capability capability = capabilities.get(0);
1:         return capability.getAttributes().get(name);
0:     }
0: 	
1: 	public static String getSymbolicNameAttribute(Resource resource) {
1:         return (String)getIdentityAttribute(resource, IdentityNamespace.IDENTITY_NAMESPACE);
0:     }
0: 	
1:    public static Version getVersionAttribute(Resource resource) {
1:         Version result = (Version)getIdentityAttribute(resource, IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE);
1:         if (result == null)
1:             result = Version.emptyVersion;
1:         return result;
0:     }
0:    
1:    public static String getTypeAttribute(Resource resource) {
1:        String result = (String)getIdentityAttribute(resource, IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE);
1:        if (result == null)
1:            result = TypeAttribute.DEFAULT_VALUE;
1:        return result;
0:    }
0: 	
0:    protected Resource getConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
1: 			if (symbolicName.equals(getSymbolicNameAttribute(resource))) {
1: 				if (version.equals(getVersionAttribute(resource))) {
1: 					if (type.equals(getTypeAttribute(resource))) {
/////////////////////////////////////////////////////////////////////////
1: 		return context().getBundleByName(SUBSYSTEM_CORE_NAME);
/////////////////////////////////////////////////////////////////////////
1: 	protected void writeToFile(InputStream is, String name) {
1:         try {
1:             FileOutputStream dest = new FileOutputStream(name);
1:             StreamUtils.copyStream(is, dest, true);
1:         } catch (IOException e) {
1:             e.printStackTrace();
0:         }
0:     }
0: 
0:     protected static void write(String file, ArchiveFixture.AbstractFixture fixture) throws IOException 
/////////////////////////////////////////////////////////////////////////
0: 	static void createApplication(String name, String ... contents) throws Exception 
1: 		ClassLoader cl = SubsystemTest.class.getClassLoader();
1:         ZipFixture feature = ArchiveFixture
1: 						cl.getResourceAsStream(name + "/OSGI-INF/SUBSYSTEM.MF"));
1: 		for (String content : contents) {
1: 				feature.binary(content,
1: 						cl.getResourceAsStream(name + '/' + content));
1: 				feature.binary(content, new FileInputStream(new File(content)));
/////////////////////////////////////////////////////////////////////////
1: 	protected InputStream getResource(String path) {
1: 	    InputStream is = this.getClass().getClassLoader().getResourceAsStream(path);
1: 	    if (is == null) {
1: 	        throw new IllegalArgumentException("No resource found at path " + path);
0: 	    }
1: 	    return is;
0: 
commit:57b6627
/////////////////////////////////////////////////////////////////////////
1: import static org.ops4j.pax.exam.CoreOptions.composite;
1: import static org.ops4j.pax.exam.CoreOptions.junitBundles;
1: import static org.ops4j.pax.exam.CoreOptions.mavenBundle;
1: import static org.ops4j.pax.exam.CoreOptions.streamBundle;
1: import static org.ops4j.pax.exam.CoreOptions.vmOption;
1: import static org.ops4j.pax.exam.CoreOptions.when;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.itest.AbstractIntegrationTest;
1: import org.apache.aries.itest.RichBundleContext;
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.runner.RunWith;
1: import org.ops4j.pax.exam.Configuration;
1: import org.ops4j.pax.exam.junit.PaxExam;
1: import org.ops4j.pax.exam.spi.reactors.ExamReactorStrategy;
1: import org.ops4j.pax.exam.spi.reactors.PerClass;
/////////////////////////////////////////////////////////////////////////
1: @RunWith(PaxExam.class)
1: @ExamReactorStrategy(PerClass.class)
1: public abstract class SubsystemTest extends AbstractIntegrationTest {
0: 	protected static boolean createdApplications = false;
1: 	boolean installModeler = true;
0: 	
1: 	public SubsystemTest() {
0: 	}
0: 	
1: 	public SubsystemTest(boolean installModeller) {
1: 		this.installModeler = installModeller;
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
1: 	public Option baseOptions() {
1:         String localRepo = getLocalRepo();
1:         return composite(
1:                 junitBundles(),
0:                 // this is how you set the default log level when using pax
0:                 // logging (logProfile)
0:                 systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("INFO"),
1:                 when(localRepo != null).useOptions(vmOption("-Dorg.ops4j.pax.url.mvn.localRepository=" + localRepo))
1:          );
0:     }
0: 	
1: 	@Configuration
1: 	public Option[] configuration() throws Exception {
0: 		// The itests need private packages from the core subsystems bundle.
0: 		InputStream fragment = SubsystemTest.class.getClassLoader().getResourceAsStream("core.fragment/core.fragment.jar");
1: 				baseOptions(),
1: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.api").versionAsInProject(),
0: 				when(installModeler).useOptions(
0: 						mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller").versionAsInProject(),
0: 						mavenBundle("org.apache.aries.blueprint",   "org.apache.aries.blueprint").versionAsInProject(),
0: 						mavenBundle("org.apache.aries.proxy",       "org.apache.aries.proxy").versionAsInProject()),
0: 				streamBundle(fragment).noStart(),
0: 				mavenBundle("org.apache.felix",             "org.apache.felix.resolver").versionAsInProject(),
1: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.event").versionAsInProject(),
1: 	@Before
1: 		if (!createdApplications) {
1: 			createApplications();
1: 			createdApplications = true;
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 	protected abstract void createApplications() throws Exception;
0: 
0: 	@After
0: 	}
0: 	
1: 	protected RichBundleContext context(Subsystem subsystem) {
1: 		return new RichBundleContext(subsystem.getBundleContext());
/////////////////////////////////////////////////////////////////////////
1:     	Bundle bundle = context(subsystem).getBundleByName(symbolicName);
/////////////////////////////////////////////////////////////////////////
1: 		assertNotNull("Bundle is null", bundle);
/////////////////////////////////////////////////////////////////////////
1: 		Subsystem rootSubsystem = context().getService(Subsystem.class);
/////////////////////////////////////////////////////////////////////////
1: 	protected Header version(String version) {
1: 		return new Header(Constants.BUNDLE_VERSION, version);
1: 	protected Header name(String name) {
1: 		return new Header(Constants.BUNDLE_SYMBOLICNAME, name);
1: 	protected Header exportPackage(String exportPackage) {
1: 		return new Header(Constants.EXPORT_PACKAGE, exportPackage);
1: 	protected Header importPackage(String importPackage) {
1: 		return new Header(Constants.IMPORT_PACKAGE, importPackage);
0: 	}
0: 
1: 	protected Header requireBundle(String bundleName) {
1: 		return new Header(Constants.REQUIRE_BUNDLE, bundleName);
0: 	}
0: 	
1: 	protected Header requireCapability(String capability) {
1: 		return new Header(Constants.REQUIRE_CAPABILITY, capability);
0: 	}
0: 
1: 	protected Header provideCapability(String capability) {
1: 		return new Header(Constants.PROVIDE_CAPABILITY, capability);
0: 	}
0: 	
1: 	protected static void createBundle(Header...  headers) throws IOException {
1: 		HashMap<String, String> headerMap = new HashMap<String, String>();
1: 		for (Header header : headers) {
1: 			headerMap.put(header.key, header.value);
0: 		}
0: 		createBundle(headerMap);
0: 	}
0: 	
0: 	private static void createBundle(Map<String, String> headers) throws IOException 
/////////////////////////////////////////////////////////////////////////
1: 	protected static void createBlueprintBundle(String symbolicName, String blueprintXml)
1: 			throws IOException {
1: 		write(symbolicName,
1: 				ArchiveFixture.newJar().manifest().symbolicName(symbolicName)
1: 						.end().file("OSGI-INF/blueprint/blueprint.xml", blueprintXml));
0: 	}
0: 	
0: 	private RepositoryContent createBundleRepositoryContent(String file) throws Exception {
0: 	private RepositoryContent createBundleRepositoryContent(File file) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		return context().getService(Subsystem.class, filter, 5000);
/////////////////////////////////////////////////////////////////////////
1: 		RegionDigraph digraph = context().getService(RegionDigraph.class);
/////////////////////////////////////////////////////////////////////////
1: 		return context().getService(AriesSubsystem.class);
1: 		return context().getService(Subsystem.class, "(subsystem.id=0)");
/////////////////////////////////////////////////////////////////////////
0: 		return context().getBundleByName("org.apache.aries.subsystem.core");
1: 		return installBundleFromFile(new File(fileName), getRootSubsystem());
1: 	protected Bundle installBundleFromFile(String fileName, Subsystem subsystem) throws FileNotFoundException, BundleException {
1: 		return installBundleFromFile(new File(fileName), subsystem);
1: 	private Bundle installBundleFromFile(File file, Subsystem subsystem) throws FileNotFoundException, BundleException {
1: 	private Bundle installBundleFromFile(File file, BundleContext bundleContext) throws FileNotFoundException, BundleException {
/////////////////////////////////////////////////////////////////////////
0: 	private Subsystem installSubsystemFromFile(File file) throws Exception {
/////////////////////////////////////////////////////////////////////////
1: 		RegionDigraph digraph = context().getService(RegionDigraph.class);
/////////////////////////////////////////////////////////////////////////
1: 	private static void write(File file, ArchiveFixture.AbstractFixture fixture) throws IOException {
/////////////////////////////////////////////////////////////////////////
0: 	static void createApplication(String name, String ... content) throws Exception 
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:e1a1f0d
/////////////////////////////////////////////////////////////////////////
1: 				mavenBundle("org.osgi",                     "org.osgi.enterprise").versionAsInProject(),
1:                 mavenBundle("org.ops4j.pax.logging",        "pax-logging-api").versionAsInProject(),
1:                 mavenBundle("org.ops4j.pax.logging",        "pax-logging-service").versionAsInProject(),
author:Jean-Baptiste Onofre
-------------------------------------------------------------------------------
commit:11d09f4
/////////////////////////////////////////////////////////////////////////
0: 	protected Collection<ServiceRegistration> serviceRegistrations = new ArrayList<ServiceRegistration>();
/////////////////////////////////////////////////////////////////////////
1: 		for (ServiceRegistration registration : serviceRegistrations)
/////////////////////////////////////////////////////////////////////////
1: 		wiring.refreshBundles(bundles, new FrameworkListener[]{ new FrameworkListener() {
/////////////////////////////////////////////////////////////////////////
1: 		}});
/////////////////////////////////////////////////////////////////////////
0: 		assertEquals("Wrong start level", expected, ((BundleStartLevel) bundle.adapt(BundleStartLevel.class)).getStartLevel());
/////////////////////////////////////////////////////////////////////////
0: 		return (FrameworkStartLevel) getSystemBundle().adapt(FrameworkStartLevel.class);
0: 		return (FrameworkWiring) getSystemBundle().adapt(FrameworkWiring.class);
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:a6a8290
/////////////////////////////////////////////////////////////////////////
1: 				mavenBundle("org.apache.aries",             "org.apache.aries.util").versionAsInProject(),
0: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.api").versionAsInProject(),
0: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller").versionAsInProject(),
1: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils").versionAsInProject(),
0: 				mavenBundle("org.apache.aries.blueprint",   "org.apache.aries.blueprint").versionAsInProject(),
0: 				mavenBundle("org.apache.aries.proxy",       "org.apache.aries.proxy").versionAsInProject(),
1: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.api").versionAsInProject(),
0: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.core").versionAsInProject(),
1: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.itest.interfaces").versionAsInProject(),
1: 				mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit").versionAsInProject(),
commit:82cb8b0
/////////////////////////////////////////////////////////////////////////
0: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller"),
0: 				mavenBundle("org.apache.aries.blueprint",   "org.apache.aries.blueprint"),
0: 				mavenBundle("org.apache.aries.proxy",       "org.apache.aries.proxy"),
commit:69d4847
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.aries.subsystem.itests;
0: 
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertFalse;
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.fail;
0: import static org.ops4j.pax.exam.CoreOptions.equinox;
0: import static org.ops4j.pax.exam.CoreOptions.options;
0: import static org.ops4j.pax.exam.CoreOptions.systemProperty;
0: 
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.FileNotFoundException;
0: import java.io.FileOutputStream;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.lang.reflect.Field;
0: import java.net.URL;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.EnumSet;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Map.Entry;
0: 
0: import org.apache.aries.subsystem.core.archive.ProvisionPolicyDirective;
0: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
0: import org.apache.aries.subsystem.core.internal.BundleResource;
0: import org.apache.aries.subsystem.core.internal.ResourceHelper;
0: import org.apache.aries.subsystem.core.internal.SubsystemIdentifier;
0: import org.apache.aries.subsystem.itests.util.TestRepository;
0: import org.apache.aries.subsystem.itests.util.Utils;
0: import org.apache.aries.unittest.fixture.ArchiveFixture;
0: import org.apache.aries.unittest.fixture.ArchiveFixture.JarFixture;
0: import org.apache.aries.unittest.fixture.ArchiveFixture.ManifestFixture;
0: import org.apache.aries.unittest.fixture.ArchiveFixture.ZipFixture;
0: import org.ops4j.pax.exam.Option;
0: import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
0: import org.osgi.framework.Bundle;
0: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.BundleException;
0: import org.osgi.framework.Constants;
0: import org.osgi.framework.InvalidSyntaxException;
0: import org.osgi.framework.ServiceEvent;
0: import org.osgi.framework.ServiceListener;
0: import org.osgi.framework.ServiceRegistration;
0: import org.osgi.framework.Version;
0: import org.osgi.framework.namespace.IdentityNamespace;
0: import org.osgi.framework.wiring.BundleRevision;
0: import org.osgi.resource.Resource;
0: import org.osgi.service.repository.Repository;
0: import org.osgi.service.repository.RepositoryContent;
0: import org.osgi.service.subsystem.Subsystem;
0: import org.osgi.service.subsystem.Subsystem.State;
0: import org.osgi.service.subsystem.SubsystemConstants;
0: 
0: public abstract class SubsystemTest extends IntegrationTest {
0: 	protected static class SubsystemEventHandler implements ServiceListener {
0: 		private static class ServiceEventInfo {
0: 			private final ServiceEvent event;
0: 			private final long id;
0: 			private final State state;
0: 			private final String symbolicName;
0: 			private final String type;
0: 			private final Version version;
0: 			
0: 			public ServiceEventInfo(ServiceEvent event) {
0: 				id = (Long)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_ID_PROPERTY);
0: 				state = (State)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_STATE_PROPERTY);
0: 				symbolicName = (String)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME_PROPERTY);
0: 				type = (String)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_TYPE_PROPERTY);
0: 				version = (Version)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_VERSION_PROPERTY);
0: 				this.event = event;
0: 			}
0: 			
0: 			public int getEventType() {
0: 				return event.getType();
0: 			}
0: 			
0: 			public long getId() {
0: 				return id;
0: 			}
0: 			
0: 			public State getState() {
0: 				return state;
0: 			}
0: 			
0: 			public String getSymbolicName() {
0: 				return symbolicName;
0: 			}
0: 			
0: 			public String getType() {
0: 				return type;
0: 			}
0: 			
0: 			public Version getVersion() {
0: 				return version;
0: 			}
0: 		}
0: 		
0: 		private final Map<Long, List<ServiceEventInfo>> subsystemIdToEvents = new HashMap<Long, List<ServiceEventInfo>>();
0: 		
0: 		public void clear() {
0: 			synchronized (subsystemIdToEvents) {
0: 				subsystemIdToEvents.clear();
0: 			}
0: 		}
0: 		
0: 		public ServiceEventInfo poll(long subsystemId) throws InterruptedException {
0: 			return poll(subsystemId, 0);
0: 		}
0: 		
0: 		public ServiceEventInfo poll(long subsystemId, long timeout) throws InterruptedException {
0: 			List<ServiceEventInfo> events;
0: 			synchronized (subsystemIdToEvents) {
0: 				events = subsystemIdToEvents.get(subsystemId);
0: 				if (events == null) {
0: 					events = new ArrayList<ServiceEventInfo>();
0: 					subsystemIdToEvents.put(subsystemId, events);
0: 				}
0: 			}
0: 			synchronized (events) {
0: 				if (events.isEmpty()) {
0: 					events.wait(timeout);
0: 					if (events.isEmpty()) {
0: 						return null;
0: 					}
0: 				}
0: 				return events.remove(0);
0: 			}
0: 		}
0: 		
0: 		public void serviceChanged(ServiceEvent event) {
0: 			Long subsystemId = (Long)event.getServiceReference().getProperty(SubsystemConstants.SUBSYSTEM_ID_PROPERTY);
0: 			synchronized (subsystemIdToEvents) {
0: 				List<ServiceEventInfo> events = subsystemIdToEvents.get(subsystemId);
0: 				if (events == null) {
0: 					events = new ArrayList<ServiceEventInfo>();
0: 					subsystemIdToEvents.put(subsystemId, events);
0: 				}
0: 				synchronized (events) {
0: 					events.add(new ServiceEventInfo(event));
0: 					events.notify();
0: 				}
0: 			}
0: 		}
0: 		
0: 		public int size() {
0: 			synchronized (subsystemIdToEvents) {
0: 				return subsystemIdToEvents.size();
0: 			}
0: 		}
0: 	}
0: 	
0: 	@org.ops4j.pax.exam.junit.Configuration
0: 	public static Option[] configuration() {
0: 		Option[] options = options(
0: 				// this is how you set the default log level when using pax
0: 				// logging (logProfile)
0: 				systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("INFO"),
0: 				systemProperty("org.osgi.framework.bsnversion").value("multiple"),
0: 				// Log
0: 				mavenBundle("org.ops4j.pax.logging", "pax-logging-api"),
0: 				mavenBundle("org.ops4j.pax.logging", "pax-logging-service"),
0: 				// Felix mvn url handler
0: 				mavenBundle("org.ops4j.pax.url", "pax-url-mvn"),
0: 				// Bundles
0: 				mavenBundle("org.apache.aries",             "org.apache.aries.util"),
0: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.api"),
0: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller").version("1.0.0"),
0: 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils"),
0: 				mavenBundle("org.apache.aries.blueprint",   "org.apache.aries.blueprint").version("1.0.0"),
0: 				mavenBundle("org.apache.aries.proxy",       "org.apache.aries.proxy").version("1.0.1-SNAPSHOT"),
0: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.api"),
0: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.core"),
0: 				mavenBundle("org.apache.aries.subsystem",   "org.apache.aries.subsystem.itest.interfaces"),
0: 				mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit"),
0: 				mavenBundle("org.apache.felix",             "org.apache.felix.resolver"),
0: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.coordinator").version("1.1.0.v20120522-1841"),
0: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.event").version("1.2.200.v20120522-2049"),
0: 				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.region").version("1.1.0.v20120522-1841"),
0: 				mavenBundle("org.osgi",                     "org.osgi.enterprise").version("5.0.0"),
0:         //org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=7777"),
0: 				PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
0: 				equinox().version("3.8.0.V20120529-1548"));
0: 		options = updateOptions(options);
0: 		return options;
0: 	}
0: 	
0: 	protected final SubsystemEventHandler subsystemEvents = new SubsystemEventHandler();
0: 	
0: 	protected Collection<ServiceRegistration<?>> serviceRegistrations = new ArrayList<ServiceRegistration<?>>();
0: 	
0: 	public void setUp() throws Exception {
0: 		super.setUp();
1: 		try {
0: 			bundleContext.getBundle(0).getBundleContext().addServiceListener(subsystemEvents, '(' + Constants.OBJECTCLASS + '=' + Subsystem.class.getName() + ')');
0: 		}
0: 		catch (InvalidSyntaxException e) {
0: 			fail("Invalid filter: " + e.getMessage());
0: 		}
0: 		assertSubsystemNotNull(getRootSubsystem());
0: 	}
0: 	
0: 	public void tearDown() throws Exception 
1: 	{
0: 		bundleContext.removeServiceListener(subsystemEvents);
0: 		for (ServiceRegistration<?> registration : serviceRegistrations)
0: 			Utils.unregisterQuietly(registration);
0: 		serviceRegistrations.clear();
0: 		super.tearDown();
0: 	}
0: 	
0: 	protected void assertEmptySubsystem(Subsystem subsystem) {
0:     	assertSymbolicName("org.apache.aries.subsystem.itests.subsystem.empty", subsystem);
0:     	assertVersion("0", subsystem);
0:     	assertType(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, subsystem);
0:     }
0: 	
0: 	protected void assertBundleState(int state, String symbolicName, Subsystem subsystem) {
0:     	Bundle bundle = getBundle(subsystem, symbolicName);
0:     	assertBundleState(bundle, state);
0:     }
0: 	
0: 	protected void assertBundleState(Bundle bundle, int state) {
0: 		assertNotNull("Bundle not found: " + bundle, bundle);
0: 		assertTrue("Wrong state: " + bundle + " [expected " + state + " but was " + bundle.getState() + "]", (bundle.getState() & state) != 0);
0: 	}
0: 	
0: 	protected void assertChild(Subsystem parent, Subsystem child) {
0: 		Collection<Subsystem> children = new ArrayList<Subsystem>(1);
0: 		children.add(child);
0: 		assertChildren(parent, children);
0: 	}
0: 	
0: 	protected void assertChildren(int size, Subsystem subsystem) {
0: 		assertEquals("Wrong number of children", size, subsystem.getChildren().size());
0: 	}
0: 	
0: 	protected void assertChildren(Subsystem parent, Collection<Subsystem> children) {
0: 		assertTrue("Parent did not contain all children", parent.getChildren().containsAll(children));
0: 	}
0: 	
0: 	protected void assertConstituent(Subsystem subsystem, String symbolicName) {
0: 		assertConstituent(subsystem, symbolicName, Version.emptyVersion);
0: 	}
0: 	
0: 	protected void assertConstituent(Subsystem subsystem, String symbolicName, Version version) {
0: 		assertConstituent(subsystem, symbolicName, version, IdentityNamespace.TYPE_BUNDLE);
0: 	}
0: 	
0: 	protected void assertContituent(Subsystem subsystem, String symbolicName, String type) {
0: 		assertConstituent(subsystem, symbolicName, Version.emptyVersion, type);
0: 	}
0: 	
0: 	protected Resource assertConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
0: 		Resource constituent = getConstituent(subsystem, symbolicName, version, type);
0: 		assertNotNull("Constituent not found: " + symbolicName + ';' + version + ';' + type, constituent);
0: 		return constituent;
0: 	}
0: 	
0: 	protected void assertConstituents(int size, Subsystem subsystem) {
0: 		assertEquals("Wrong number of constituents", size, subsystem.getConstituents().size());
0: 	}
0: 	
0:  	protected void assertDirectory(Subsystem subsystem) {
0:  		Bundle bundle = getSubsystemCoreBundle();
0:  		File file = bundle.getDataFile("subsystem" + subsystem.getSubsystemId());
0:  		assertNotNull("Subsystem data file was null", file);
0:  		assertTrue("Subsystem data file does not exist", file.exists());
0:  	}
0:  	
0:  	protected void assertNotDirectory(Subsystem subsystem) {
0:  		Bundle bundle = getSubsystemCoreBundle();
0:  		File file = bundle.getDataFile("subsystem" + subsystem.getSubsystemId());
0:  		assertNotNull("Subsystem data file was null", file);
0:  		assertFalse("Subsystem data file exists", file.exists());
0:  	}
0:  	
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state) throws InterruptedException {
0:  		assertEvent(subsystem, state, 0);
0:  	}
0:  	
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, long timeout) throws InterruptedException {
0:  		assertEvent(subsystem, state, subsystemEvents.poll(subsystem.getSubsystemId(), timeout));
0:  	}
0:  	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemEventHandler.ServiceEventInfo event) {
0:  		if (State.INSTALLING.equals(state))
0: 			assertEvent(subsystem, state, event, ServiceEvent.REGISTERED);
0:  		else
0:  			assertEvent(subsystem, state, event, ServiceEvent.MODIFIED);
0:  	}
0: 	
0: 	protected void assertEvent(Subsystem subsystem, Subsystem.State state, SubsystemEventHandler.ServiceEventInfo event, int type) {
0: 		// TODO Could accept a ServiceRegistration as an argument and verify it against the one in the event.
0: 		assertNotNull("No event", event);
0: 		assertEquals("Wrong ID", subsystem.getSubsystemId(), event.getId());
0: 		assertEquals("Wrong symbolic name", subsystem.getSymbolicName(), event.getSymbolicName());
0: 		assertEquals("Wrong version", subsystem.getVersion(), event.getVersion());
0: 		assertEquals("Wrong type", subsystem.getType(), event.getType());
0: 		assertEquals("Wrong state", state, event.getState());
0: 		assertEquals("Wrong event type", type, event.getEventType());
0: 	}
0: 	
0: 	protected String assertHeaderExists(Subsystem subsystem, String name) {
0: 		String header = subsystem.getSubsystemHeaders(null).get(name);
0: 		assertNotNull("Missing header: " + name, header);
0: 		return header;
0: 	}
0: 	
0: 	protected void assertId(Subsystem subsystem) {
0: 		assertId(subsystem.getSubsystemId());
0: 	}
0: 	
0: 	protected void assertId(Long id) {
0: 		assertTrue("Subsystem ID was not a positive integer: " + id, id > 0);
0: 	}
0: 	
0: 	protected void assertLastId(long id) throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
0: 		Subsystem root = getRootSubsystem();
0: 		Field lastId = SubsystemIdentifier.class.getDeclaredField("lastId");
0: 		lastId.setAccessible(true);
0: 		assertEquals("Wrong lastId", id, lastId.getLong(root));
0: 	}
0: 	
0: 	protected void assertLocation(String expected, String actual) {
0: 		assertTrue("Wrong location: " + actual, actual.indexOf(expected) != -1);
0: 	}
0: 	
0: 	protected void assertLocation(String expected, Subsystem subsystem) {
0: 		assertLocation(expected, subsystem.getLocation());
0: 	}
0: 	
0: 	protected void assertNotChild(Subsystem parent, Subsystem child) {
0: 		assertFalse("Parent contained child", parent.getChildren().contains(child));
0: 	}
0: 	
0: 	protected void assertNotConstituent(Subsystem subsystem, String symbolicName) {
0: 		assertNotConstituent(subsystem, symbolicName, Version.emptyVersion, IdentityNamespace.TYPE_BUNDLE);
0: 	}
0: 	
0: 	protected void assertNotConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
0: 		Resource constituent = getConstituent(subsystem, symbolicName, version, type);
0: 		assertNull("Constituent found: " + symbolicName + ';' + version + ';' + type, constituent);
0: 	}
0: 	
0: 	protected void assertParent(Subsystem expected, Subsystem subsystem) {
0: 		for (Subsystem parent : subsystem.getParents()) {
0: 			if (parent.equals(expected))
0: 				return;
0: 			
0: 		}
0: 		fail("Parent did not exist: " + expected.getSymbolicName());
0: 	}
0: 	
0: 	protected void assertProvisionPolicy(Subsystem subsystem, boolean acceptsDependencies) {
0: 		String headerStr = subsystem.getSubsystemHeaders(null).get(SubsystemConstants.SUBSYSTEM_TYPE);
0: 		assertNotNull("Missing subsystem type header", headerStr);
0: 		SubsystemTypeHeader header = new SubsystemTypeHeader(headerStr);
0: 		ProvisionPolicyDirective directive = header.getProvisionPolicyDirective();
0: 		if (acceptsDependencies)
0: 			assertTrue("Subsystem does not accept dependencies", directive.isAcceptDependencies());
0: 		else
0: 			assertTrue("Subsystem accepts dependencies", directive.isRejectDependencies());
0: 	}
0: 	
0: 	protected void assertRegionContextBundle(Subsystem s) {
0: 		Bundle b = getRegionContextBundle(s);
0: 		assertEquals("Not active", Bundle.ACTIVE, b.getState());
0: 		assertEquals("Wrong location", s.getLocation() + '/' + s.getSubsystemId(), b.getLocation());
0: 		assertEquals("Wrong symbolic name", "org.osgi.service.subsystem.region.context." + s.getSubsystemId(), b.getSymbolicName());
0: 		assertEquals("Wrong version", Version.parseVersion("1.0.0"), b.getVersion());
0: 		assertConstituent(s, "org.osgi.service.subsystem.region.context." + s.getSubsystemId(), Version.parseVersion("1.0.0"), IdentityNamespace.TYPE_BUNDLE);
0: 	}
0: 	
0: 	protected void assertServiceEventsInstall(Subsystem subsystem) throws InterruptedException {
0: 		assertEvent(subsystem, Subsystem.State.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 	}
0: 	
0: 	protected void assertServiceEventsResolve(Subsystem subsystem) throws InterruptedException {
0: 		assertEvent(subsystem, Subsystem.State.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertServiceEventResolved(subsystem, ServiceEvent.MODIFIED);
0: 	}
0: 	
0: 	protected void assertServiceEventsStart(Subsystem subsystem) throws InterruptedException {
0: 		assertEvent(subsystem, Subsystem.State.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.ACTIVE, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 	}
0: 	
0: 	protected void assertServiceEventsStop(Subsystem subsystem) throws InterruptedException {
0: 		assertEvent(subsystem, Subsystem.State.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertServiceEventResolved(subsystem, ServiceEvent.MODIFIED);
0: 		// Don't forget about the unregistering event, which will have the same state as before.
0: 		assertServiceEventResolved(subsystem, ServiceEvent.UNREGISTERING);
0: 	}
0: 	
0: 	protected void assertServiceEventResolved(Subsystem subsystem, int type) throws InterruptedException {
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000), type);
0: 	}
0: 	
0: 	protected void assertState(State expected, State actual) {
0: 		assertState(EnumSet.of(expected), actual);
0: 	}
0: 	
0: 	protected void assertState(EnumSet<State> expected, State actual) {
0: 		assertTrue("Wrong state: expected=" + expected + ", actual=" + actual, expected.contains(actual));
0: 	}
0: 	
0: 	protected void assertState(State expected, Subsystem subsystem) {
0: 		assertState(expected, subsystem.getState());
0: 	}
0: 	
0: 	protected void assertState(EnumSet<State> expected, Subsystem subsystem) {
0: 		assertState(expected, subsystem.getState());
0: 	}
0: 	
0: 	protected Subsystem assertSubsystemLifeCycle(File file) throws Exception {
0: 		Subsystem rootSubsystem = getOsgiService(Subsystem.class);
0:         assertNotNull("Root subsystem was null", rootSubsystem);
0:         Subsystem subsystem = rootSubsystem.install(file.toURI().toURL().toExternalForm());
0:         assertNotNull("The subsystem was null", subsystem);
0:         assertState(EnumSet.of(State.INSTALLING, State.INSTALLED), subsystem.getState());
0: 		assertEvent(subsystem, Subsystem.State.INSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.INSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertChild(rootSubsystem, subsystem);
0:         subsystem.start();
0:         assertState(EnumSet.of(State.RESOLVING, State.RESOLVED, State.STARTING, State.ACTIVE), subsystem.getState());
0: 		assertEvent(subsystem, Subsystem.State.RESOLVING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.STARTING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.ACTIVE, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		subsystem.stop();
0: 		assertState(EnumSet.of(State.STOPPING, State.RESOLVED), subsystem.getState());
0: 		assertEvent(subsystem, Subsystem.State.STOPPING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.RESOLVED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		subsystem.uninstall();
0: 		assertState(EnumSet.of(State.UNINSTALLING, State.UNINSTALLED), subsystem.getState());
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLING, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertEvent(subsystem, Subsystem.State.UNINSTALLED, subsystemEvents.poll(subsystem.getSubsystemId(), 5000));
0: 		assertNotChild(rootSubsystem, subsystem);
0: 		return subsystem;
0: 	}
0: 	
0: 	protected void assertSubsystemNotNull(Subsystem subsystem) {
0: 		assertNotNull("Subsystem was null", subsystem);
0: 	}
0: 	
0: 	protected void assertSymbolicName(String expected, Subsystem subsystem) {
0: 		assertEquals("Wrong symbolic name: " + subsystem.getSymbolicName(), expected, subsystem.getSymbolicName());
0: 	}
0: 	
0: 	protected void assertType(String expected, Subsystem subsystem) {
0: 		assertEquals("Wrong type", expected, subsystem.getType());
0: 	}
0: 	
0: 	protected void assertVersion(String expected, Subsystem subsystem) {
0: 		assertVersion(Version.parseVersion(expected), subsystem);
0: 	}
0: 	
0: 	protected void assertVersion(Version expected, Subsystem subsystem) {
0: 		assertVersion(expected, subsystem.getVersion());
0: 	}
0: 	
0: 	protected void assertVersion(Version expected, Version actual) {
0: 		assertEquals("Wrong version", expected, actual);
0: 	}
0: 	
0: 	protected static void createBundle(String symbolicName) throws IOException {
0: 		createBundle(symbolicName, null);
0: 	}
0: 	
0: 	protected static void createBundle(String symbolicName, Map<String, String> headers) throws IOException {
0: 		createBundle(symbolicName, null, headers);
0: 	}
0: 	
0: 	protected static void createBundle(String symbolicName, String version, Map<String, String> headers) throws IOException {
0: 		if (headers == null)
0: 			headers = new HashMap<String, String>();
0: 		headers.put(Constants.BUNDLE_SYMBOLICNAME, symbolicName);
0: 		if (version != null)
0: 			headers.put(Constants.BUNDLE_VERSION, version);
0: 		createBundle(headers);
0: 	}
0: 	
0: 	protected static void createBundle(Map<String, String> headers) throws IOException 
1: 	{
0: 		String symbolicName = headers.get(Constants.BUNDLE_SYMBOLICNAME);
0: 		JarFixture bundle = ArchiveFixture.newJar();
0: 		ManifestFixture manifest = bundle.manifest();
0: 		for (Entry<String, String> header : headers.entrySet()) {
0: 			manifest.attribute(header.getKey(), header.getValue());
0: 		}
0: 		write(symbolicName, bundle);
0: 	}
0: 	
0: 	protected RepositoryContent createBundleRepositoryContent(String file) throws Exception {
0: 		return createBundleRepositoryContent(new File(file));
0: 	}
0: 	
0: 	protected RepositoryContent createBundleRepositoryContent(File file) throws Exception {
0: 		return new BundleResource(file.toURI().toURL());
0: 	}
0: 	
0: 	protected static void createManifest(String name, Map<String, String> headers) throws IOException {
0: 		ManifestFixture manifest = ArchiveFixture.newJar().manifest();
0: 		for (Entry<String, String> header : headers.entrySet()) {
0: 			manifest.attribute(header.getKey(), header.getValue());
0: 		}
0: 		write(name, manifest);
0: 	}
0: 	
0: 	protected static void createSubsystem(String name) throws IOException {
0: 		createSubsystem(name, new String[0]);
0: 	}
0: 	
0: 	protected static void createSubsystem(String name, String...contents) throws IOException {
0: 		// The following input stream is closed by ArchiveFixture.copy.
0: 		ZipFixture fixture = ArchiveFixture.newZip().binary("OSGI-INF/SUBSYSTEM.MF", new FileInputStream(name + ".mf"));
0: 		if (contents != null) {
0: 			for (String content : contents) {
0: 				// The following input stream is closed by ArchiveFixture.copy.
0: 				fixture.binary(content, new FileInputStream(content));
0: 			}
0: 		}
0: 		write(name, fixture);
0: 	}
0: 	
0: 	protected Subsystem findSubsystemService(long id) throws InvalidSyntaxException {
0: 		String filter = "(" + SubsystemConstants.SUBSYSTEM_ID_PROPERTY + "=" + id + ")";
0: 		return getOsgiService(Subsystem.class, filter, 5000);
0: 	}
0: 	
0: 	protected Bundle getBundle(Subsystem subsystem, String symbolicName) {
0: 		for (Bundle bundle : subsystem.getBundleContext().getBundles()) {
0: 			if (symbolicName.equals(bundle.getSymbolicName())) { 
0: 				return bundle;
0: 			}
0: 		}
0: 		return null;
0: 	}
0: 	
0: 	protected Resource getConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
0: 		for (Resource resource : subsystem.getConstituents()) {
0: 			if (symbolicName.equals(ResourceHelper.getSymbolicNameAttribute(resource))) {
0: 				if (version == null)
0: 					version = Version.emptyVersion;
0: 				if (version.equals(ResourceHelper.getVersionAttribute(resource))) {
0: 					if (type == null)
0: 						type = IdentityNamespace.TYPE_BUNDLE;
0: 					if (type.equals(ResourceHelper.getTypeAttribute(resource))) {
0: 						return resource;
0: 					}
0: 				}
0: 			}
0: 		}
0: 		return null;
0: 	}
0: 	
0: 	protected Bundle getConstituentAsBundle(Subsystem subsystem, String symbolicName, Version version, String type) {
0: 		return getConstituentAsBundleRevision(subsystem, symbolicName, version, type).getBundle();
0: 	}
0: 	
0: 	protected BundleRevision getConstituentAsBundleRevision(Subsystem subsystem, String symbolicName, Version version, String type) {
0: 		Resource resource = getConstituent(subsystem, symbolicName, version, type);
0: 		return (BundleRevision)resource;
0: 	}
0: 	
0: 	protected Bundle getRegionContextBundle(Subsystem subsystem) {
0: 		BundleContext bc = subsystem.getBundleContext();
0: 		assertNotNull("No region context bundle", bc);
0: 		return bc.getBundle();
0: 	}
0: 	
0: 	protected Subsystem getRootSubsystem() {
0: 		return getOsgiService(Subsystem.class);
0: 	}
0: 	
0: 	protected Bundle getSubsystemCoreBundle() {
0: 		return findBundleBySymbolicName("org.apache.aries.subsystem.core");
0: 	}
0: 	
0: 	protected Bundle installBundleFromFile(String fileName) throws FileNotFoundException, BundleException {
0: 		return installBundleFromFile(new File(fileName));
0: 	}
0: 	
0: 	protected Bundle installBundleFromFile(File file) throws FileNotFoundException, BundleException {
0: 		return installBundleFromFile(file, getRootSubsystem());
0: 	}
0: 	
0: 	protected Bundle installBundleFromFile(String file, Subsystem subsystem) throws FileNotFoundException, BundleException {
0: 		return installBundleFromFile(new File(file), subsystem);
0: 	}
0: 	
0: 	protected Bundle installBundleFromFile(File file, Subsystem subsystem) throws FileNotFoundException, BundleException {
0: 		Bundle bundle = installBundleFromFile(file, subsystem.getBundleContext());
0: 		assertBundleState(Bundle.INSTALLED|Bundle.RESOLVED, bundle.getSymbolicName(), subsystem);
0: 		return bundle;
0: 	}
0: 	
0: 	protected Bundle installBundleFromFile(File file, BundleContext bundleContext) throws FileNotFoundException, BundleException {
0: 		// The following input stream is closed by the bundle context.
0: 		return bundleContext.installBundle(file.toURI().toString(), new FileInputStream(file));
0: 	}
0: 	
0: 	protected Subsystem installSubsystemFromFile(Subsystem parent, String fileName) throws Exception {
0: 		return installSubsystemFromFile(parent, new File(fileName));
0: 	}
0: 	
0: 	protected Subsystem installSubsystemFromFile(String fileName) throws Exception {
0: 		return installSubsystemFromFile(new File(fileName));
0: 	}
0: 	
0: 	protected Subsystem installSubsystemFromFile(Subsystem parent, File file) throws Exception {
0: 		return installSubsystem(parent, file.toURI().toURL().toExternalForm());
0: 	}
0: 	
0: 	protected Subsystem installSubsystemFromFile(File file) throws Exception {
0: 		return installSubsystem(getRootSubsystem(), file.toURI().toURL().toExternalForm());
0: 	}
0: 	
0: 	protected Subsystem installSubsystem(String location) throws Exception {
0: 		return installSubsystem(getRootSubsystem(), location);
0: 	}
0: 	
0: 	protected Subsystem installSubsystem(String location, InputStream content) throws Exception {
0: 		return installSubsystem(getRootSubsystem(), location, content);
0: 	}
0: 	
0: 	protected Subsystem installSubsystem(Subsystem parent, String location) throws Exception {
0: 		// The following input stream is closed by Subsystem.install.
0: 		return installSubsystem(parent, location, new URL(location).openStream());
0: 	}
0: 	
0: 	protected Subsystem installSubsystem(Subsystem parent, String location, InputStream content) throws Exception {
0: 		subsystemEvents.clear();
0: 		Subsystem subsystem = parent.install(location, content);
0: 		assertSubsystemNotNull(subsystem);
0: 		assertEvent(subsystem, State.INSTALLING, 5000);
0: 		assertEvent(subsystem, State.INSTALLED, 5000);
0: 		assertChild(parent, subsystem);
0: 		assertLocation(location, subsystem);
0: 		assertParent(parent, subsystem);
0: 		assertState(State.INSTALLED, subsystem);
0: 		assertLocation(location, subsystem);
0: 		assertId(subsystem);
0: 		// TODO This does not take into account nested directories.
0: //		assertDirectory(subsystem);
0: 		return subsystem;
0: 	}
0: 	
0: 	protected void registerRepositoryService(Repository repository) {
0: 		serviceRegistrations.add(bundleContext.registerService(
0: 				Repository.class, repository, null));
0: 	}
0: 	
0: 	protected void registerRepositoryService(Resource...resources) {
0: 		TestRepository.Builder builder = new TestRepository.Builder();
0: 		for (Resource resource : resources) {
0: 			builder.resource(resource);
0: 		}
0: 		registerRepositoryService(builder.build());
0: 	}
0: 	
0: 	protected void registerRepositoryService(String...files) throws Exception {
0: 		Resource[] resources = new Resource[files.length];
0: 		int i = 0;
0: 		for (String file : files) {
0: 			resources[i++] = (Resource)createBundleRepositoryContent(file);
0: 		}
0: 		registerRepositoryService(resources);
0: 	}
0: 	
0: 	protected void restartSubsystemsImplBundle() throws BundleException {
0: 		Bundle b = getSubsystemCoreBundle();
0: 		b.stop();
0: 		b.start();
0: 	}
0: 	
0: 	protected void startBundle(Bundle bundle) throws BundleException {
0: 		startBundle(bundle, getRootSubsystem());
0: 	}
0: 	
0: 	protected void startBundle(Bundle bundle, Subsystem subsystem) throws BundleException {
0: 		bundle.start();
0: 		assertBundleState(Bundle.ACTIVE, bundle.getSymbolicName(), subsystem);
0: 	}
0: 	
0: 	protected void startSubsystem(Subsystem subsystem) throws Exception {
0: 		startSubsystemFromInstalled(subsystem);
0: 	}
0: 	
0: 	protected void startSubsystemFromInstalled(Subsystem subsystem) throws InterruptedException {
0: 		assertState(State.INSTALLED, subsystem);
0: 		subsystemEvents.clear();
0: 		subsystem.start();
0: 		assertEvent(subsystem, State.RESOLVING, 5000);
0: 		assertEvent(subsystem, State.RESOLVED, 5000);
0: 		assertEvent(subsystem, State.STARTING, 5000);
0: 		assertEvent(subsystem, State.ACTIVE, 5000);
0: 		assertState(State.ACTIVE, subsystem);
0: 	}
0: 	
0: 	protected void startSubsystemFromResolved(Subsystem subsystem) throws InterruptedException {
0: 		assertState(State.RESOLVED, subsystem);
0: 		subsystemEvents.clear();
0: 		subsystem.start();
0: 		assertEvent(subsystem, State.STARTING, 5000);
0: 		assertEvent(subsystem, State.ACTIVE, 5000);
0: 		assertState(State.ACTIVE, subsystem);
0: 	}
0: 	
0: 	protected void stopAndUninstallSubsystemSilently(Subsystem subsystem) {
0: 		stopSubsystemSilently(subsystem);
0: 		uninstallSubsystemSilently(subsystem);
0: 	}
0: 	
0: 	protected void stopSubsystem(Subsystem subsystem) throws Exception {
0: 		assertState(State.ACTIVE, subsystem);
0: 		subsystemEvents.clear();
0: 		subsystem.stop();
0: 		assertEvent(subsystem, State.STOPPING, 5000);
0: 		assertEvent(subsystem, State.RESOLVED, 5000);
0: 		assertState(State.RESOLVED, subsystem);
0: 	}
0: 	
0: 	protected void stopSubsystemSilently(Subsystem subsystem) {
1: 		try {
0: 			stopSubsystem(subsystem);
0: 		}
0: 		catch (Throwable t) {
0: 			t.printStackTrace();
0: 		}
0: 	}
0: 	
0: 	protected void uninstallSilently(Bundle bundle) {
0: 		if (bundle == null)
0: 			return;
1: 		try {
0: 			bundle.uninstall();
0: 		}
0: 		catch (Exception e) {}
0: 	}
0: 	
0: 	protected void uninstallSubsystem(Subsystem subsystem) throws Exception {
0: 		assertState(EnumSet.of(State.INSTALLED, State.RESOLVED), subsystem);
0: 		subsystemEvents.clear();
0: 		Collection<Subsystem> parents = subsystem.getParents();
0: 		Bundle b = null;
0: 		if (subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
0: 				|| subsystem.getType().equals(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE))
0: 			b = getRegionContextBundle(subsystem);
0: 		State state = subsystem.getState();
0: 		subsystem.uninstall();
0: 		if (!EnumSet.of(State.INSTALL_FAILED, State.INSTALLED, State.INSTALLING).contains(state))
0: 			assertEvent(subsystem, State.INSTALLED, 5000);
0: 		assertEvent(subsystem, State.UNINSTALLING, 5000);
0: 		assertEvent(subsystem, State.UNINSTALLED, 5000);
0: 		assertState(State.UNINSTALLED, subsystem);
0: 		for (Subsystem parent : parents)
0: 			assertNotChild(parent, subsystem);
0: //		assertNotDirectory(subsystem);
0: 		if (b != null)
0: 			assertEquals("Region context bundle not uninstalled", Bundle.UNINSTALLED, b.getState());
0: 	}
0: 	
0: 	protected void uninstallSubsystemSilently(Subsystem subsystem) {
0: 		if (subsystem == null)
0: 			return;
1: 		try {
0: 			uninstallSubsystem(subsystem);
0: 		}
0: 		catch (Throwable t) {
0: 			t.printStackTrace();
0: 		}
0: 	}
0: 	
0: 	protected static void write(String file, ArchiveFixture.AbstractFixture fixture) throws IOException 
1: 	{
0: 		write(new File(file), fixture);
0: 	}
0: 	
0: 	protected static void write(File file, ArchiveFixture.AbstractFixture fixture) throws IOException {
0: 		FileOutputStream fos = new FileOutputStream(file);
1:     	try {
0:     		fixture.writeOut(fos);
0:     	}
0:     	finally {
0:     		fos.close();
0:     	}
0: 	}
0: 	
0: 	static void createApplication(String name, String[] content) throws Exception 
1: 	{
0: 		ZipFixture feature = ArchiveFixture
1: 				.newZip()
1: 				.binary("OSGI-INF/SUBSYSTEM.MF",
0: 						// The following input stream is closed by ArchiveFixture.copy.
0: 						SubsystemTest.class.getClassLoader().getResourceAsStream(
0: 								name + "/OSGI-INF/SUBSYSTEM.MF"));
0: 		for (String s : content) {
1: 			try {
0: 				feature.binary(s,
0: 						// The following input stream is closed by ArchiveFixture.copy.
0: 						SubsystemTest.class.getClassLoader().getResourceAsStream(
0: 								name + '/' + s));
0: 			}
1: 			catch (Exception e) {
0: 				// The following input stream is closed by ArchiveFixture.copy.
0: 				feature.binary(s, new FileInputStream(new File(s)));
0: 			}
0: 		}
1: 		feature.end();
1: 		FileOutputStream fos = new FileOutputStream(name + ".esa");
1: 		try {
1: 			feature.writeOut(fos);
1: 		} finally {
1: 			Utils.closeQuietly(fos);
0: 		}
0: 	}
0: }
commit:294aae2
/////////////////////////////////////////////////////////////////////////
0: 				mavenBundle("org.apache.aries", "org.apache.aries.util").version("1.0.1-SNAPSHOT"),
commit:412c1f8
/////////////////////////////////////////////////////////////////////////
0: 	public void tearDown() throws Exception 
0: 	{
commit:3e9adfe
/////////////////////////////////////////////////////////////////////////
0: //				org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=7777"),
/////////////////////////////////////////////////////////////////////////
0: 	protected static void createBundle(Map<String, String> headers) throws IOException 
0: 	{
/////////////////////////////////////////////////////////////////////////
0: 	protected static void write(String file, ArchiveFixture.AbstractFixture fixture) throws IOException 
0: 	{
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	static void createApplication(String name, String[] content) throws Exception 
0: 	{
0: 		ZipFixture feature = ArchiveFixture
0: 				.newZip()
0: 				.binary("OSGI-INF/SUBSYSTEM.MF",
0: 						SubsystemTest.class.getClassLoader().getResourceAsStream(
0: 								name + "/OSGI-INF/SUBSYSTEM.MF"));
0: 		for (String s : content) {
0: 			try {
0: 				feature.binary(s,
0: 						SubsystemTest.class.getClassLoader().getResourceAsStream(
0: 								name + '/' + s));
0: 			}
0: 			catch (Exception e) {
0: 				feature.binary(s, new FileInputStream(new File(s)));
0: 			}
0: 		}
0: 		feature.end();
0: 		FileOutputStream fos = new FileOutputStream(name + ".esa");
0: 		try {
0: 			feature.writeOut(fos);
0: 		} finally {
0: 			Utils.closeQuietly(fos);
0: 		}
0: 	}
============================================================================