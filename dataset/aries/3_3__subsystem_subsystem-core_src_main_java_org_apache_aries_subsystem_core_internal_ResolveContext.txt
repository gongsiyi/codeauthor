1:d6eb080: /*
1:d6eb080:  * Licensed under the Apache License, Version 2.0 (the "License");
1:d6eb080:  * you may not use this file except in compliance with the License.
1:d6eb080:  * You may obtain a copy of the License at
1:d6eb080:  *
1:d6eb080:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d6eb080:  *
1:d6eb080:  * Unless required by applicable law or agreed to in writing, software
1:d6eb080:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d6eb080:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d6eb080:  * See the License for the specific language governing permissions and
1:d6eb080:  * limitations under the License.
1:d6eb080:  */
1:d6eb080: package org.apache.aries.subsystem.core.internal;
1:9652a71: 
1:d6eb080: import java.io.IOException;
1:d6eb080: import java.net.URISyntaxException;
1:b66ad7c: import java.security.AccessController;
1:d6eb080: import java.util.ArrayList;
1:d6eb080: import java.util.Collection;
1:d6eb080: import java.util.Collections;
1:d6eb080: import java.util.HashMap;
1:d6eb080: import java.util.List;
1:d6eb080: import java.util.Map;
11:d6eb080: 
1:a990e32: import org.apache.aries.subsystem.core.archive.ProvisionPolicyDirective;
1:97f1954: import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
1:a990e32: import org.apache.aries.subsystem.core.archive.SubsystemManifest;
1:a990e32: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
1:d6eb080: import org.apache.aries.subsystem.core.internal.BundleResourceInstaller.BundleConstituent;
1:d6eb080: import org.apache.aries.subsystem.core.internal.DependencyCalculator.MissingCapability;
1:b66ad7c: import org.apache.aries.subsystem.core.internal.StartAction.Restriction;
1:d6eb080: import org.apache.aries.subsystem.core.repository.Repository;
1:d6eb080: import org.eclipse.equinox.region.Region;
1:d6eb080: import org.osgi.framework.BundleException;
1:d6eb080: import org.osgi.framework.InvalidSyntaxException;
1:d6eb080: import org.osgi.framework.namespace.ExecutionEnvironmentNamespace;
1:445abc4: import org.osgi.framework.namespace.HostNamespace;
1:d6eb080: import org.osgi.framework.namespace.IdentityNamespace;
1:d6eb080: import org.osgi.framework.namespace.NativeNamespace;
1:445abc4: import org.osgi.framework.namespace.PackageNamespace;
1:d6eb080: import org.osgi.framework.wiring.BundleRevision;
1:a990e32: import org.osgi.framework.wiring.BundleWiring;
1:d6eb080: import org.osgi.resource.Capability;
1:d6eb080: import org.osgi.resource.Namespace;
1:d6eb080: import org.osgi.resource.Requirement;
1:d6eb080: import org.osgi.resource.Resource;
1:445abc4: import org.osgi.resource.Wire;
1:d6eb080: import org.osgi.resource.Wiring;
1:d6eb080: import org.osgi.service.resolver.HostedCapability;
1:b66ad7c: import org.osgi.service.subsystem.Subsystem.State;
1:d6eb080: 
1:d6eb080: public class ResolveContext extends org.osgi.service.resolver.ResolveContext {
1:d6eb080: 	private final Repository contentRepository;
1:d6eb080: 	private final Repository localRepository;
1:d6eb080: 	private final Repository preferredProviderRepository;
1:d6eb080: 	private final Repository repositoryServiceRepository;
1:d6eb080: 	private final SubsystemResource resource;
1:d6eb080: 	private final Repository systemRepository;
1:d6eb080: 	private final Map<Resource, Wiring> wirings = computeWirings();
1:9652a71: 
1:d6eb080: 	public ResolveContext(SubsystemResource resource) {
1:d6eb080: 		this.resource = resource;
1:d6eb080: 		contentRepository = new ContentRepository(resource.getInstallableContent(), resource.getSharedContent());
1:d6eb080: 		localRepository = resource.getLocalRepository();
1:d6eb080: 		preferredProviderRepository = new PreferredProviderRepository(resource);
1:d6eb080: 		repositoryServiceRepository = new RepositoryServiceRepository();
1:d6eb080: 		systemRepository = Activator.getInstance().getSystemRepository();
13:d6eb080: 	}
1:b66ad7c: 	
1:b66ad7c: 	private void installDependenciesOfRequirerIfNecessary(Requirement requirement) {
1:b66ad7c: 		if (requirement == null) {
1:445abc4: 			return;
1:b66ad7c: 		}
1:b66ad7c: 		Resource requirer = requirement.getResource();
1:b66ad7c: 		if (resource.equals(requirer)) {
1:445abc4: 			return;
1:b66ad7c: 		}
1:b66ad7c: 		Collection<BasicSubsystem> subsystems;
1:b66ad7c: 		if (requirer instanceof BasicSubsystem) {
1:b66ad7c: 			BasicSubsystem subsystem = (BasicSubsystem)requirer;
1:b66ad7c: 			subsystems = Collections.singletonList(subsystem);
1:b66ad7c: 		}
1:b66ad7c: 		else if (requirer instanceof BundleRevision) {
1:b66ad7c: 			BundleRevision revision = (BundleRevision)requirer;
1:b66ad7c: 			BundleConstituent constituent = new BundleConstituent(null, revision);
1:b66ad7c: 			subsystems = Activator.getInstance().getSubsystems().getSubsystemsByConstituent(constituent);
1:b66ad7c: 		}
1:b66ad7c: 		else {
3:b66ad7c: 			return;
1:b66ad7c: 		}
1:b66ad7c: 		for (BasicSubsystem subsystem : subsystems) {
1:b66ad7c: 			if (Utils.isProvisionDependenciesInstall(subsystem) 
1:b66ad7c: 					|| !State.INSTALLING.equals(subsystem.getState())) {
1:b66ad7c: 				continue;
1:b66ad7c: 			}
1:b66ad7c: 			AccessController.doPrivileged(new StartAction(subsystem, subsystem, subsystem, Restriction.INSTALL_ONLY));
1:445abc4: 		}
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private boolean isResolved(Resource resource) {
1:445abc4: 		return wirings.containsKey(resource);
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private boolean isProcessableAsFragment(Requirement requirement) {
1:445abc4: 		Resource resource = requirement.getResource();
2:445abc4: 		String namespace = requirement.getNamespace();
1:445abc4: 		return Utils.isFragment(resource)
1:445abc4: 				&& !(ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE.equals(namespace)
1:445abc4: 						|| HostNamespace.HOST_NAMESPACE.equals(namespace));
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void processAsFragment(Requirement requirement, List<Capability> capabilities) {
1:445abc4: 		String namespace = requirement.getNamespace();
1:445abc4: 		Resource fragment = requirement.getResource();
1:445abc4: 		Wiring fragmentWiring = wirings.get(fragment);
1:445abc4: 		List<Wire> fragmentWires = fragmentWiring.getRequiredResourceWires(HostNamespace.HOST_NAMESPACE);
1:445abc4: 		for (Wire fragmentWire : fragmentWires) {
1:445abc4: 			Resource host = fragmentWire.getProvider();
1:445abc4: 			Wiring hostWiring = wirings.get(host);
1:445abc4: 			List<Wire> hostWires = hostWiring.getRequiredResourceWires(namespace);
1:445abc4: 			processWires(hostWires, requirement, capabilities);
1:445abc4: 		}
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void processWires(Collection<Wire> wires, Requirement requirement, List<Capability> capabilities) {
1:445abc4: 		for (Wire wire : wires) {
1:445abc4: 			processWire(wire, requirement, capabilities);
1:445abc4: 		}
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void processWire(Wire wire, Requirement requirement, List<Capability> capabilities) {
1:445abc4: 		Capability capability = wire.getCapability();
1:445abc4: 		processCapability(capability, requirement, capabilities);
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void processCapability(Capability capability, Requirement requirement, List<Capability> capabilities) {
1:445abc4: 		if (ResourceHelper.matches(requirement, capability)) {
1:445abc4: 			capabilities.add(capability);
1:445abc4: 		}
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void processResourceCapabilities(Collection<Capability> resourceCapabilities, Requirement requirement, List<Capability> capabilities) {
1:445abc4: 		for (Capability resourceCapability : resourceCapabilities) {
1:445abc4: 			processCapability(resourceCapability, requirement, capabilities);
1:445abc4: 		}
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void processAsBundle(Requirement requirement, List<Capability> capabilities) {
1:445abc4: 		String namespace = requirement.getNamespace();
1:445abc4: 		Resource bundle = requirement.getResource();
1:445abc4: 		Wiring wiring = wirings.get(bundle);
1:445abc4: 		List<Wire> wires = wiring.getRequiredResourceWires(namespace);
1:445abc4: 		processWires(wires, requirement, capabilities);
1:445abc4: 	}
1:445abc4: 	
1:72b684b: 	private void processAsSubstitutableExport(boolean isFragment, Requirement requirement, List<Capability> capabilities) {
1:445abc4: 		String namespace = requirement.getNamespace();
1:445abc4: 		if (!PackageNamespace.PACKAGE_NAMESPACE.equals(namespace)) {
1:445abc4: 			return;
1:445abc4: 		}
1:445abc4: 		Resource resource = requirement.getResource();
1:445abc4: 		Wiring wiring = wirings.get(resource);
1:72b684b: 		if (isFragment) {
1:72b684b: 			List<Wire> fragmentWires = wiring.getRequiredResourceWires(HostNamespace.HOST_NAMESPACE);
1:72b684b: 			for (Wire fragmentWire : fragmentWires) {
1:72b684b: 				Resource host = fragmentWire.getProvider();
1:72b684b: 				processResourceCapabilities(
1:72b684b: 						wirings.get(host).getResourceCapabilities(namespace),
1:72b684b: 						requirement,
1:72b684b: 						capabilities);
1:72b684b: 			}
1:72b684b: 		}
1:72b684b: 		else {
1:72b684b: 			List<Capability> resourceCapabilities = wiring.getResourceCapabilities(namespace);
1:72b684b: 			processResourceCapabilities(resourceCapabilities, requirement, capabilities);
1:72b684b: 		}
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void processAlreadyResolvedResource(Resource resource, Requirement requirement, List<Capability> capabilities) {
1:72b684b: 		boolean isFragment = isProcessableAsFragment(requirement);
1:72b684b: 		if (isFragment) {
1:445abc4: 			processAsFragment(requirement, capabilities);
1:445abc4: 		}
1:445abc4: 		else {
1:445abc4: 			processAsBundle(requirement, capabilities);
1:445abc4: 		}
1:445abc4: 		if (capabilities.isEmpty() && Utils.isMandatory(requirement)) {
1:72b684b: 			processAsSubstitutableExport(isFragment, requirement, capabilities);
1:72b684b: 			if (capabilities.isEmpty()) {
1:72b684b: 				// ARIES-1538. Do not fail subsystem resolution if an already
1:72b684b: 				// resolved resource has a missing dependency.
1:72b684b: 				capabilities.add(new MissingCapability(requirement));
1:72b684b: 			}
1:445abc4: 		}
1:445abc4: 	}
1:445abc4: 	
1:445abc4: 	private void processNewlyResolvedResource(Resource resource, Requirement requirement, List<Capability> capabilities) {
1:445abc4: 		try {
1:d6eb080: 			// Only check the system repository for osgi.ee and osgi.native
1:9652a71: 			if (ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE.equals(requirement.getNamespace())
1:d6eb080: 					|| NativeNamespace.NATIVE_NAMESPACE.equals(requirement.getNamespace())) {
2:445abc4: 				addDependenciesFromSystemRepository(requirement, capabilities);
1:d6eb080: 			} else {
1:445abc4: 				addDependenciesFromContentRepository(requirement, capabilities);
1:445abc4: 				addDependenciesFromPreferredProviderRepository(requirement, capabilities);
1:445abc4: 				addDependenciesFromSystemRepository(requirement, capabilities);
1:445abc4: 				addDependenciesFromLocalRepository(requirement, capabilities);
1:445abc4: 				if (capabilities.isEmpty()) {
1:445abc4: 					addDependenciesFromRepositoryServiceRepositories(requirement, capabilities);
1:445abc4: 				}
1:445abc4: 			}
1:445abc4: 			if (capabilities.isEmpty()) {
1:d6eb080: 				// Is the requirement optional?
1:d6eb080: 				String resolution = requirement.getDirectives().get(Namespace.REQUIREMENT_RESOLUTION_DIRECTIVE);
1:d6eb080: 				if (Namespace.RESOLUTION_OPTIONAL.equals(resolution)) {
1:d6eb080: 					// Yes, it's optional. Add a missing capability to ensure
1:d6eb080: 					// it gets added to the sharing policy per the specification.
1:445abc4: 					capabilities.add(new MissingCapability(requirement));
1:445abc4: 				}
1:bcfcde2: 				// Is the requirement resource already resolved? See ARIES-1538.
1:bcfcde2: 				else if (isResolved(requirement.getResource())) {
1:bcfcde2: 					// Yes, the resource has already been resolved. Do not fail
1:bcfcde2: 					// the subsystem resolution due to a missing dependency.
1:bcfcde2: 					capabilities.add(new MissingCapability(requirement));
1:bcfcde2: 				}
1:b66ad7c: 			}
1:b66ad7c: 		}
1:d6eb080: 		catch (Throwable t) {
1:445abc4: 			Utils.handleTrowable(t);
1:445abc4: 		}
1:d6eb080: 	}
1:445abc4: 
1:445abc4: 	@Override
1:445abc4: 	public List<Capability> findProviders(Requirement requirement) {
1:445abc4: 		ArrayList<Capability> capabilities = new ArrayList<Capability>();
1:445abc4: 		Resource resource = requirement.getResource();
1:445abc4: 		if (isResolved(resource)
1:445abc4: 				&& Utils.isEffectiveResolve(requirement)) {
1:445abc4: 			processAlreadyResolvedResource(resource, requirement, capabilities);
1:445abc4: 		}
1:445abc4: 		else {
1:445abc4: 			installDependenciesOfRequirerIfNecessary(requirement);
1:445abc4: 			processNewlyResolvedResource(resource, requirement, capabilities);
1:445abc4: 		}
1:445abc4: 		capabilities.trimToSize();
1:445abc4: 		return capabilities;
1:d6eb080: 	}
1:445abc4: 
3:d6eb080: 	@Override
1:d6eb080: 	public int insertHostedCapability(List<Capability> capabilities, HostedCapability hostedCapability) {
1:9652a71: 	    // Must specify the location where the capability is to be added. From the ResoveContext javadoc:
1:9652a71: 	    // "This method must insert the specified HostedCapability in a place that makes the list maintain
1:9652a71: 	    // the preference order."
1:9652a71: 	    // The Felix implementation provides a list that requires the index to be specified in the add() call,
1:9652a71: 	    // otherwise it will throw an exception.
1:9652a71:         int sz = capabilities.size();
1:9652a71: 		capabilities.add(sz, hostedCapability);
1:9652a71:         return sz;
1:d6eb080: 	}
1:9652a71: 
1:d6eb080: 	@Override
1:d6eb080: 	public boolean isEffective(Requirement requirement) {
1:d6eb080: 		return true;
1:d6eb080: 	}
1:9652a71: 
1:d6eb080: 	@Override
1:d6eb080: 	public Collection<Resource> getMandatoryResources() {
1:d6eb080: 		return resource.getMandatoryResources();
1:d6eb080: 	}
1:9652a71: 
1:9652a71: 	@Override
1:d6eb080: 	public Collection<Resource> getOptionalResources() {
1:d6eb080: 		return resource.getOptionalResources();
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	@Override
1:d6eb080: 	public Map<Resource, Wiring> getWirings() {
1:445abc4: 		return Collections.emptyMap();
1:d6eb080: 	}
1:9652a71: 
1:d6eb080: 	private boolean addDependencies(Repository repository, Requirement requirement, List<Capability> capabilities, boolean validate) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:d6eb080: 		if (repository == null)
1:d6eb080: 			return false;
1:d6eb080: 		Map<Requirement, Collection<Capability>> m = repository.findProviders(Collections.singleton(requirement));
1:d6eb080: 		if (m.containsKey(requirement)) {
1:d6eb080: 			Collection<Capability> cc = m.get(requirement);
1:d6eb080: 			addValidCapabilities(cc, capabilities, requirement, validate);
1:d6eb080: 		}
1:d6eb080: 		return !capabilities.isEmpty();
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private boolean addDependenciesFromContentRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:d6eb080: 		return addDependencies(contentRepository, requirement, capabilities, false);
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private boolean addDependenciesFromLocalRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:d6eb080: 		return addDependencies(localRepository, requirement, capabilities, true);
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private boolean addDependenciesFromPreferredProviderRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:d6eb080: 		return addDependencies(preferredProviderRepository, requirement, capabilities, true);
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private boolean addDependenciesFromRepositoryServiceRepositories(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:d6eb080: 		return addDependencies(repositoryServiceRepository, requirement, capabilities, true);
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private boolean addDependenciesFromSystemRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:b66ad7c: 		boolean result = addDependencies(systemRepository, requirement, capabilities, true);
1:b66ad7c: 		return result;
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private void addValidCapabilities(Collection<Capability> from, Collection<Capability> to, Requirement requirement, boolean validate) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:d6eb080: 		for (Capability c : from) {
1:d6eb080: 			if (!validate || isValid(c, requirement)) {
1:d6eb080: 				// either validation is not requested or the capability is valid.
1:d6eb080: 				to.add(c);
1:d6eb080: 			}
1:d6eb080: 		}
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private void addWiring(Resource resource, Map<Resource, Wiring> wirings) {
1:d6eb080: 		if (resource instanceof BundleConstituent) {
1:d6eb080: 			BundleConstituent bc = (BundleConstituent)resource;
1:a990e32: 			BundleWiring wiring = bc.getWiring();
1:a990e32: 			if (wiring != null) {
1:a990e32: 				wirings.put(bc.getBundle().adapt(BundleRevision.class), wiring);
1:a990e32: 			}
1:d6eb080: 		}
1:d6eb080: 		else if (resource instanceof BundleRevision) {
1:d6eb080: 			BundleRevision br = (BundleRevision)resource;
1:a990e32: 			BundleWiring wiring = br.getWiring();
1:a990e32: 			if (wiring != null) {
1:a990e32: 				wirings.put(br, wiring);
1:a990e32: 			}
1:a990e32: 			
1:d6eb080: 		}
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private Map<Resource, Wiring> computeWirings() {
1:d6eb080: 		Map<Resource, Wiring> wirings = new HashMap<Resource, Wiring>();
1:d6eb080: 		for (BasicSubsystem subsystem : Activator.getInstance().getSubsystems().getSubsystems()) { // NEED
1:d6eb080: 			for (Resource constituent : subsystem.getConstituents()) {
1:d6eb080: 				addWiring(constituent, wirings);
1:d6eb080: 			}
1:d6eb080: 		}
1:d6eb080: 		return Collections.unmodifiableMap(wirings);
1:d6eb080: 	}
1:a990e32: 	
1:d6eb080: 	private boolean isContent(Resource resource) {
1:3f524ae: 		return this.resource.isContent(resource);
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private boolean isInstallable(Resource resource) {
1:d6eb080: 		return !isShared(resource);
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private boolean isShared(Resource resource) {
1:d6eb080: 		return Utils.isSharedResource(resource);
1:d6eb080: 	}
1:d6eb080: 
1:d6eb080: 	private boolean isValid(Capability capability, Requirement requirement) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:d6eb080: 		if (IdentityNamespace.IDENTITY_NAMESPACE.equals(capability.getNamespace()))
1:d6eb080: 			return true;
1:97f1954: 		Resource provider = capability.getResource();
1:97f1954: 		Resource requirer = requirement.getResource();
1:97f1954: 		SubsystemManifest manifest = resource.getSubsystemManifest();
1:97f1954: 		SubsystemContentHeader header = manifest.getSubsystemContentHeader();
1:97f1954: 		if (header.contains(provider) && header.contains(requirer)) {
1:97f1954: 			// Shortcut. If both the provider and requirer are content then they
1:97f1954: 			// are in the same region and the capability will be visible.
1:97f1954: 			return true;
1:97f1954: 		}
1:97f1954: 		Region from = findRegionForCapabilityValidation(provider);
1:97f1954: 		Region to = findRegionForCapabilityValidation(requirer);
1:d6eb080: 		return new SharingPolicyValidator(from, to).isValid(capability);
1:d6eb080: 	}
1:a990e32: 	
1:a990e32: 	private boolean isAcceptDependencies() {
1:a990e32: 		SubsystemManifest manifest = resource.getSubsystemManifest();
1:a990e32: 		SubsystemTypeHeader header = manifest.getSubsystemTypeHeader();
1:a990e32: 		ProvisionPolicyDirective directive = header.getProvisionPolicyDirective();
1:a990e32: 		return directive.isAcceptDependencies();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private Region findRegionForCapabilityValidation(Resource resource) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1:a990e32: 		if (isInstallable(resource)) {
1:a990e32: 			// This is an installable resource so we need to figure out where it
1:a990e32: 			// will be installed.
1:a990e32: 			if (isContent(resource) // If the resource is content of this subsystem, it will be installed here.
1:a990e32: 					// Or if this subsystem accepts dependencies, the resource will be installed here.
1:a990e32: 					|| isAcceptDependencies()) {
1:a990e32: 				if (this.resource.isComposite()) {
1:a990e32: 					// Composites define their own sharing policy with which
1:a990e32: 					// their regions are already configured by the time we get
1:a990e32: 					// here. We ensure capabilities are visible to this region.
1:a990e32: 					return this.resource.getRegion();
1:a990e32: 				}
1:a990e32: 				// For applications and features, we must ensure capabilities
1:a990e32: 				// are visible to their scoped parent. Features import
1:a990e32: 				// everything. Applications have their sharing policies
1:a990e32: 				// computed, so if capabilities are visible to the parent, we
1:a990e32: 				// know we can make them visible to the application. 
1:a990e32: 				BasicSubsystem parent = this.resource.getParents().iterator().next();
1:a990e32: 				// If the parent accepts dependencies, the resource will 
1:a990e32: 				// be installed there and all capabilities will be visible.
1:a990e32: 				if (parent.getSubsystemManifest().getSubsystemTypeHeader().getProvisionPolicyDirective().isAcceptDependencies()) {
1:a990e32: 					return parent.getRegion();
1:a990e32: 				}
1:a990e32: 				// Otherwise, the "parent" is defined as the first scoped 
1:a990e32: 				// ancestor whose sharing policy has already been set. This 
1:a990e32: 				// covers the case of multiple subsystems from the same archive 
1:a990e32: 				// being installed whose regions will form a tree of depth N.
1:a990e32: 				parent = Utils.findFirstScopedAncestorWithSharingPolicy(this.resource);
1:a990e32: 				return parent.getRegion();
1:a990e32: 			}
1:a990e32: 			return Utils.findFirstSubsystemAcceptingDependenciesStartingFrom(this.resource.getParents().iterator().next()).getRegion();
1:a990e32: 		}
1:a990e32: 		else {
1:a990e32: 			// This is an already installed resource from the system repository.
1:a990e32: 			if (Utils.isBundle(resource)) {
1:9ea9cc5: 				if (isContent(resource) 
1:9ea9cc5: 						&& this.resource.getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective().isResolve()) {
1:a990e32: 					// If we get here with a subsystem that is 
1:a990e32: 					// apache-aries-provision-dependencies:=resolve, it means
1:a990e32: 					// that a restart has occurred with the subsystem in the
1:9ea9cc5: 					// INSTALLING state. Its content has already been installed.
1:a990e32: 					// However, because the sharing policy has not yet been set,
1:a990e32: 					// we must treat it similarly to the installable content case
1:a990e32: 					// above.
1:a990e32: 					return Utils.findFirstScopedAncestorWithSharingPolicy(this.resource).getRegion();
1:a990e32: 				}
1:a990e32: 			    BundleRevision revision = resource instanceof BundleRevision ? (BundleRevision)resource : ((BundleRevisionResource)resource).getRevision();
1:a990e32: 				// If it's a bundle, use region digraph to get the region in order
1:a990e32: 				// to account for bundles in isolated regions outside of the
1:a990e32: 				// subsystems API.
1:a990e32: 				return Activator.getInstance().getRegionDigraph().getRegion(revision.getBundle());
1:a990e32: 			}
1:a990e32: 			else {
2:a990e32: 				if (this.resource.getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective().isResolve()) {
1:a990e32: 					return Utils.findFirstScopedAncestorWithSharingPolicy(this.resource).getRegion();
1:a990e32: 				}
1:a990e32: 				// If it's anything else, get the region from one of the
1:a990e32: 				// subsystems referencing it.
1:a990e32: 				return Activator.getInstance().getSubsystems().getSubsystemsReferencing(resource).iterator().next().getRegion();
1:a990e32: 			}
1:a990e32: 		}
1:a990e32: 	}
1:9df8274: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:72b684b
/////////////////////////////////////////////////////////////////////////
1: 	private void processAsSubstitutableExport(boolean isFragment, Requirement requirement, List<Capability> capabilities) {
1: 		if (isFragment) {
1: 			List<Wire> fragmentWires = wiring.getRequiredResourceWires(HostNamespace.HOST_NAMESPACE);
1: 			for (Wire fragmentWire : fragmentWires) {
1: 				Resource host = fragmentWire.getProvider();
1: 				processResourceCapabilities(
1: 						wirings.get(host).getResourceCapabilities(namespace),
1: 						requirement,
1: 						capabilities);
1: 			}
1: 		}
1: 		else {
1: 			List<Capability> resourceCapabilities = wiring.getResourceCapabilities(namespace);
1: 			processResourceCapabilities(resourceCapabilities, requirement, capabilities);
1: 		}
1: 		boolean isFragment = isProcessableAsFragment(requirement);
1: 		if (isFragment) {
1: 			processAsSubstitutableExport(isFragment, requirement, capabilities);
1: 			if (capabilities.isEmpty()) {
1: 				// ARIES-1538. Do not fail subsystem resolution if an already
1: 				// resolved resource has a missing dependency.
1: 				capabilities.add(new MissingCapability(requirement));
1: 			}
commit:bcfcde2
/////////////////////////////////////////////////////////////////////////
1: 				// Is the requirement resource already resolved? See ARIES-1538.
1: 				else if (isResolved(requirement.getResource())) {
1: 					// Yes, the resource has already been resolved. Do not fail
1: 					// the subsystem resolution due to a missing dependency.
1: 					capabilities.add(new MissingCapability(requirement));
1: 				}
commit:97f1954
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
/////////////////////////////////////////////////////////////////////////
1: 		Resource provider = capability.getResource();
1: 		Resource requirer = requirement.getResource();
1: 		SubsystemManifest manifest = resource.getSubsystemManifest();
1: 		SubsystemContentHeader header = manifest.getSubsystemContentHeader();
1: 		if (header.contains(provider) && header.contains(requirer)) {
1: 			// Shortcut. If both the provider and requirer are content then they
1: 			// are in the same region and the capability will be visible.
1: 			return true;
1: 		}
1: 		Region from = findRegionForCapabilityValidation(provider);
1: 		Region to = findRegionForCapabilityValidation(requirer);
commit:9a1587f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:445abc4
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.namespace.HostNamespace;
1: import org.osgi.framework.namespace.PackageNamespace;
0: import org.osgi.namespace.service.ServiceNamespace;
1: import org.osgi.resource.Wire;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	private boolean isResolved(Resource resource) {
1: 		return wirings.containsKey(resource);
1: 	}
1: 	
1: 	private boolean isProcessableAsFragment(Requirement requirement) {
1: 		Resource resource = requirement.getResource();
1: 		String namespace = requirement.getNamespace();
1: 		return Utils.isFragment(resource)
1: 				&& !(ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE.equals(namespace)
1: 						|| HostNamespace.HOST_NAMESPACE.equals(namespace));
1: 	}
1: 	
1: 	private void processAsFragment(Requirement requirement, List<Capability> capabilities) {
1: 		String namespace = requirement.getNamespace();
1: 		Resource fragment = requirement.getResource();
1: 		Wiring fragmentWiring = wirings.get(fragment);
1: 		List<Wire> fragmentWires = fragmentWiring.getRequiredResourceWires(HostNamespace.HOST_NAMESPACE);
1: 		for (Wire fragmentWire : fragmentWires) {
1: 			Resource host = fragmentWire.getProvider();
1: 			Wiring hostWiring = wirings.get(host);
1: 			List<Wire> hostWires = hostWiring.getRequiredResourceWires(namespace);
1: 			processWires(hostWires, requirement, capabilities);
1: 		}
1: 	}
1: 	
1: 	private void processWires(Collection<Wire> wires, Requirement requirement, List<Capability> capabilities) {
0: 		if (wires.isEmpty()) {
0: 			handleNoWires(requirement, capabilities);
1: 			return;
1: 		}
1: 		for (Wire wire : wires) {
1: 			processWire(wire, requirement, capabilities);
1: 		}
1: 	}
1: 	
1: 	private void processWire(Wire wire, Requirement requirement, List<Capability> capabilities) {
1: 		Capability capability = wire.getCapability();
1: 		processCapability(capability, requirement, capabilities);
1: 	}
1: 	
1: 	private void processCapability(Capability capability, Requirement requirement, List<Capability> capabilities) {
1: 		if (ResourceHelper.matches(requirement, capability)) {
1: 			capabilities.add(capability);
1: 		}
1: 	}
1: 	
1: 	private void processResourceCapabilities(Collection<Capability> resourceCapabilities, Requirement requirement, List<Capability> capabilities) {
1: 		for (Capability resourceCapability : resourceCapabilities) {
1: 			processCapability(resourceCapability, requirement, capabilities);
1: 		}
1: 	}
1: 	
1: 	private void processAsBundle(Requirement requirement, List<Capability> capabilities) {
1: 		String namespace = requirement.getNamespace();
1: 		Resource bundle = requirement.getResource();
1: 		Wiring wiring = wirings.get(bundle);
1: 		List<Wire> wires = wiring.getRequiredResourceWires(namespace);
1: 		processWires(wires, requirement, capabilities);
1: 	}
1: 	
0: 	private void handleNoWires(Requirement requirement, List<Capability> capabilities) {
1: 		String namespace = requirement.getNamespace();
0: 		if (!ServiceNamespace.SERVICE_NAMESPACE.equals(namespace)) {
1: 			return;
1: 		}
1: 		try {
1: 			addDependenciesFromSystemRepository(requirement, capabilities);
1: 		}
0: 		catch (Exception e) {
0: 			Utils.handleTrowable(e);
1: 		}
1: 	}
1: 	
0: 	private void processAsSubstitutableExport(Requirement requirement, List<Capability> capabilities) {
1: 		String namespace = requirement.getNamespace();
1: 		if (!PackageNamespace.PACKAGE_NAMESPACE.equals(namespace)) {
1: 			return;
1: 		}
1: 		Resource resource = requirement.getResource();
1: 		Wiring wiring = wirings.get(resource);
0: 		List<Capability> resourceCapabilities = wiring.getResourceCapabilities(namespace);
0: 		processResourceCapabilities(resourceCapabilities, requirement, capabilities);
1: 	}
1: 	
1: 	private void processAlreadyResolvedResource(Resource resource, Requirement requirement, List<Capability> capabilities) {
0: 		if (isProcessableAsFragment(requirement)) {
1: 			processAsFragment(requirement, capabilities);
1: 		}
1: 		else {
1: 			processAsBundle(requirement, capabilities);
1: 		}
1: 		if (capabilities.isEmpty() && Utils.isMandatory(requirement)) {
0: 			processAsSubstitutableExport(requirement, capabilities);
1: 		}
1: 	}
1: 	
1: 	private void processNewlyResolvedResource(Resource resource, Requirement requirement, List<Capability> capabilities) {
1: 				addDependenciesFromSystemRepository(requirement, capabilities);
1: 				addDependenciesFromContentRepository(requirement, capabilities);
1: 				addDependenciesFromPreferredProviderRepository(requirement, capabilities);
1: 				addDependenciesFromSystemRepository(requirement, capabilities);
1: 				addDependenciesFromLocalRepository(requirement, capabilities);
1: 				if (capabilities.isEmpty()) {
1: 					addDependenciesFromRepositoryServiceRepositories(requirement, capabilities);
1: 			if (capabilities.isEmpty()) {
1: 					capabilities.add(new MissingCapability(requirement));
1: 			Utils.handleTrowable(t);
1: 	}
1: 
1: 	@Override
1: 	public List<Capability> findProviders(Requirement requirement) {
1: 		ArrayList<Capability> capabilities = new ArrayList<Capability>();
1: 		Resource resource = requirement.getResource();
1: 		if (isResolved(resource)
1: 				&& Utils.isEffectiveResolve(requirement)) {
1: 			processAlreadyResolvedResource(resource, requirement, capabilities);
1: 		}
1: 		else {
1: 			installDependenciesOfRequirerIfNecessary(requirement);
1: 			processNewlyResolvedResource(resource, requirement, capabilities);
1: 		}
1: 		capabilities.trimToSize();
1: 		return capabilities;
/////////////////////////////////////////////////////////////////////////
1: 		return Collections.emptyMap();
commit:b66ad7c
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.internal.StartAction.Restriction;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.subsystem.Subsystem.State;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	private void installDependenciesOfRequirerIfNecessary(Requirement requirement) {
1: 		if (requirement == null) {
1: 			return;
1: 		}
1: 		Resource requirer = requirement.getResource();
1: 		if (resource.equals(requirer)) {
1: 			return;
1: 		}
1: 		Collection<BasicSubsystem> subsystems;
1: 		if (requirer instanceof BasicSubsystem) {
1: 			BasicSubsystem subsystem = (BasicSubsystem)requirer;
1: 			subsystems = Collections.singletonList(subsystem);
1: 		}
1: 		else if (requirer instanceof BundleRevision) {
1: 			BundleRevision revision = (BundleRevision)requirer;
1: 			BundleConstituent constituent = new BundleConstituent(null, revision);
1: 			subsystems = Activator.getInstance().getSubsystems().getSubsystemsByConstituent(constituent);
1: 		}
1: 		else {
1: 			return;
1: 		}
1: 		for (BasicSubsystem subsystem : subsystems) {
1: 			if (Utils.isProvisionDependenciesInstall(subsystem) 
1: 					|| !State.INSTALLING.equals(subsystem.getState())) {
1: 				continue;
1: 			}
1: 			AccessController.doPrivileged(new StartAction(subsystem, subsystem, subsystem, Restriction.INSTALL_ONLY));
1: 		}
1: 	}
0: 		installDependenciesOfRequirerIfNecessary(requirement);
/////////////////////////////////////////////////////////////////////////
1: 		boolean result = addDependencies(systemRepository, requirement, capabilities, true);
1: 		return result;
commit:9ea9cc5
/////////////////////////////////////////////////////////////////////////
1: 				if (isContent(resource) 
1: 						&& this.resource.getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective().isResolve()) {
1: 					// INSTALLING state. Its content has already been installed.
commit:a990e32
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.ProvisionPolicyDirective;
1: import org.apache.aries.subsystem.core.archive.SubsystemManifest;
1: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.BundleWiring;
/////////////////////////////////////////////////////////////////////////
1: 			BundleWiring wiring = bc.getWiring();
1: 			if (wiring != null) {
1: 				wirings.put(bc.getBundle().adapt(BundleRevision.class), wiring);
1: 			}
1: 			BundleWiring wiring = br.getWiring();
1: 			if (wiring != null) {
1: 				wirings.put(br, wiring);
1: 			}
1: 			
/////////////////////////////////////////////////////////////////////////
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	private boolean isAcceptDependencies() {
1: 		SubsystemManifest manifest = resource.getSubsystemManifest();
1: 		SubsystemTypeHeader header = manifest.getSubsystemTypeHeader();
1: 		ProvisionPolicyDirective directive = header.getProvisionPolicyDirective();
1: 		return directive.isAcceptDependencies();
1: 	}
1: 	
1: 	private Region findRegionForCapabilityValidation(Resource resource) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		if (isInstallable(resource)) {
1: 			// This is an installable resource so we need to figure out where it
1: 			// will be installed.
1: 			if (isContent(resource) // If the resource is content of this subsystem, it will be installed here.
1: 					// Or if this subsystem accepts dependencies, the resource will be installed here.
1: 					|| isAcceptDependencies()) {
1: 				if (this.resource.isComposite()) {
1: 					// Composites define their own sharing policy with which
1: 					// their regions are already configured by the time we get
1: 					// here. We ensure capabilities are visible to this region.
1: 					return this.resource.getRegion();
1: 				}
1: 				// For applications and features, we must ensure capabilities
1: 				// are visible to their scoped parent. Features import
1: 				// everything. Applications have their sharing policies
1: 				// computed, so if capabilities are visible to the parent, we
1: 				// know we can make them visible to the application. 
1: 				BasicSubsystem parent = this.resource.getParents().iterator().next();
1: 				// If the parent accepts dependencies, the resource will 
1: 				// be installed there and all capabilities will be visible.
1: 				if (parent.getSubsystemManifest().getSubsystemTypeHeader().getProvisionPolicyDirective().isAcceptDependencies()) {
1: 					return parent.getRegion();
1: 				}
1: 				// Otherwise, the "parent" is defined as the first scoped 
1: 				// ancestor whose sharing policy has already been set. This 
1: 				// covers the case of multiple subsystems from the same archive 
1: 				// being installed whose regions will form a tree of depth N.
1: 				parent = Utils.findFirstScopedAncestorWithSharingPolicy(this.resource);
1: 				return parent.getRegion();
1: 			}
1: 			return Utils.findFirstSubsystemAcceptingDependenciesStartingFrom(this.resource.getParents().iterator().next()).getRegion();
1: 		}
1: 		else {
1: 			// This is an already installed resource from the system repository.
1: 			if (Utils.isBundle(resource)) {
1: 				if (this.resource.getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective().isResolve()) {
1: 					// If we get here with a subsystem that is 
1: 					// apache-aries-provision-dependencies:=resolve, it means
1: 					// that a restart has occurred with the subsystem in the
0: 					// INSTALLING state. It's content has already been installed.
1: 					// However, because the sharing policy has not yet been set,
1: 					// we must treat it similarly to the installable content case
1: 					// above.
1: 					return Utils.findFirstScopedAncestorWithSharingPolicy(this.resource).getRegion();
1: 				}
1: 			    BundleRevision revision = resource instanceof BundleRevision ? (BundleRevision)resource : ((BundleRevisionResource)resource).getRevision();
1: 				// If it's a bundle, use region digraph to get the region in order
1: 				// to account for bundles in isolated regions outside of the
1: 				// subsystems API.
1: 				return Activator.getInstance().getRegionDigraph().getRegion(revision.getBundle());
1: 			}
1: 			else {
1: 				if (this.resource.getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective().isResolve()) {
1: 					return Utils.findFirstScopedAncestorWithSharingPolicy(this.resource).getRegion();
1: 				}
1: 				// If it's anything else, get the region from one of the
1: 				// subsystems referencing it.
1: 				return Activator.getInstance().getSubsystems().getSubsystemsReferencing(resource).iterator().next().getRegion();
1: 			}
1: 		}
1: 	}
commit:3f524ae
/////////////////////////////////////////////////////////////////////////
1: 		return this.resource.isContent(resource);
commit:9df8274
/////////////////////////////////////////////////////////////////////////
0: 			if (Utils.isBundle(resource)) {
0: 			    BundleRevision revision = resource instanceof BundleRevision ? (BundleRevision)resource : ((BundleRevisionResource)resource).getRevision();
0: 				return Activator.getInstance().getRegionDigraph().getRegion(revision.getBundle());
1: 			}
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:9652a71
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 			if (ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE.equals(requirement.getNamespace())
/////////////////////////////////////////////////////////////////////////
1: 	    // Must specify the location where the capability is to be added. From the ResoveContext javadoc:
1: 	    // "This method must insert the specified HostedCapability in a place that makes the list maintain
1: 	    // the preference order."
1: 	    // The Felix implementation provides a list that requires the index to be specified in the add() call,
1: 	    // otherwise it will throw an exception.
1:         int sz = capabilities.size();
1: 		capabilities.add(sz, hostedCapability);
1:         return sz;
1: 
1: 
1: 	@Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 				// everything. Applications have their sharing policies
author:Tom Watson
-------------------------------------------------------------------------------
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.aries.subsystem.core.internal;
1: 
1: import java.io.IOException;
1: import java.net.URISyntaxException;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: 
1: import org.apache.aries.subsystem.core.internal.BundleResourceInstaller.BundleConstituent;
1: import org.apache.aries.subsystem.core.internal.DependencyCalculator.MissingCapability;
1: import org.apache.aries.subsystem.core.repository.Repository;
1: import org.eclipse.equinox.region.Region;
1: import org.osgi.framework.BundleException;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.namespace.ExecutionEnvironmentNamespace;
1: import org.osgi.framework.namespace.IdentityNamespace;
1: import org.osgi.framework.namespace.NativeNamespace;
1: import org.osgi.framework.wiring.BundleRevision;
1: import org.osgi.resource.Capability;
1: import org.osgi.resource.Namespace;
1: import org.osgi.resource.Requirement;
1: import org.osgi.resource.Resource;
1: import org.osgi.resource.Wiring;
1: import org.osgi.service.resolver.HostedCapability;
0: import org.osgi.service.subsystem.SubsystemException;
1: 
1: public class ResolveContext extends org.osgi.service.resolver.ResolveContext {
1: 	private final Repository contentRepository;
1: 	private final Repository localRepository;
1: 	private final Repository preferredProviderRepository;
1: 	private final Repository repositoryServiceRepository;
1: 	private final SubsystemResource resource;
1: 	private final Repository systemRepository;
1: 	private final Map<Resource, Wiring> wirings = computeWirings();
1: 	
1: 	public ResolveContext(SubsystemResource resource) {
1: 		this.resource = resource;
1: 		contentRepository = new ContentRepository(resource.getInstallableContent(), resource.getSharedContent());
1: 		localRepository = resource.getLocalRepository();
1: 		preferredProviderRepository = new PreferredProviderRepository(resource);
1: 		repositoryServiceRepository = new RepositoryServiceRepository();
1: 		systemRepository = Activator.getInstance().getSystemRepository();
1: 	}
1: 	
1: 	@Override
0: 	public List<Capability> findProviders(Requirement requirement) {
0: 		ArrayList<Capability> result = new ArrayList<Capability>();
0: 		try {
1: 			// Only check the system repository for osgi.ee and osgi.native
0: 			if (ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE.equals(requirement.getNamespace()) 
1: 					|| NativeNamespace.NATIVE_NAMESPACE.equals(requirement.getNamespace())) {
0: 				addDependenciesFromSystemRepository(requirement, result);
1: 			} else {
0: 				addDependenciesFromContentRepository(requirement, result);
0: 				addDependenciesFromPreferredProviderRepository(requirement, result);
0: 				addDependenciesFromSystemRepository(requirement, result);
0: 				addDependenciesFromLocalRepository(requirement, result);
0: 				if (result.isEmpty()) {
0: 					addDependenciesFromRepositoryServiceRepositories(requirement, result);
1: 				}
1: 			}
0: 			if (result.isEmpty()) {
1: 				// Is the requirement optional?
1: 				String resolution = requirement.getDirectives().get(Namespace.REQUIREMENT_RESOLUTION_DIRECTIVE);
1: 				if (Namespace.RESOLUTION_OPTIONAL.equals(resolution)) {
1: 					// Yes, it's optional. Add a missing capability to ensure
1: 					// it gets added to the sharing policy per the specification.
0: 					result.add(new MissingCapability(requirement));
1: 				}
1: 			}
1: 		}
1: 		catch (Throwable t) {
0: 			if (t instanceof SubsystemException)
0: 				throw (SubsystemException)t;
0: 			if (t instanceof SecurityException)
0: 				throw (SecurityException)t;
0: 			throw new SubsystemException(t);
1: 		}
0: 		result.trimToSize();
0: 		return result;
1: 	}
1: 
1: 	@Override
1: 	public int insertHostedCapability(List<Capability> capabilities, HostedCapability hostedCapability) {
0: 		capabilities.add(hostedCapability);
0: 		return capabilities.size() - 1;
1: 	}
1: 
1: 	@Override
1: 	public boolean isEffective(Requirement requirement) {
1: 		return true;
1: 	}
1: 	
1: 	@Override
1: 	public Collection<Resource> getMandatoryResources() {
1: 		return resource.getMandatoryResources();
1: 	}
1: 	
1: 	@Override 
1: 	public Collection<Resource> getOptionalResources() {
1: 		return resource.getOptionalResources();
1: 	}
1: 
1: 	@Override
1: 	public Map<Resource, Wiring> getWirings() {
0: 		return wirings;
1: 	}
1: 	
1: 	private boolean addDependencies(Repository repository, Requirement requirement, List<Capability> capabilities, boolean validate) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		if (repository == null)
1: 			return false;
1: 		Map<Requirement, Collection<Capability>> m = repository.findProviders(Collections.singleton(requirement));
1: 		if (m.containsKey(requirement)) {
1: 			Collection<Capability> cc = m.get(requirement);
1: 			addValidCapabilities(cc, capabilities, requirement, validate);
1: 		}
1: 		return !capabilities.isEmpty();
1: 	}
1: 
1: 	private boolean addDependenciesFromContentRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		return addDependencies(contentRepository, requirement, capabilities, false);
1: 	}
1: 
1: 	private boolean addDependenciesFromLocalRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		return addDependencies(localRepository, requirement, capabilities, true);
1: 	}
1: 
1: 	private boolean addDependenciesFromPreferredProviderRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		return addDependencies(preferredProviderRepository, requirement, capabilities, true);
1: 	}
1: 
1: 	private boolean addDependenciesFromRepositoryServiceRepositories(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		return addDependencies(repositoryServiceRepository, requirement, capabilities, true);
1: 	}
1: 
1: 	private boolean addDependenciesFromSystemRepository(Requirement requirement, List<Capability> capabilities) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 		return addDependencies(systemRepository, requirement, capabilities, true);
1: 	}
1: 
1: 	private void addValidCapabilities(Collection<Capability> from, Collection<Capability> to, Requirement requirement, boolean validate) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		for (Capability c : from) {
1: 			if (!validate || isValid(c, requirement)) {
1: 				// either validation is not requested or the capability is valid.
1: 				to.add(c);
1: 			}
1: 		}
1: 	}
1: 
1: 	private void addWiring(Resource resource, Map<Resource, Wiring> wirings) {
1: 		if (resource instanceof BundleConstituent) {
1: 			BundleConstituent bc = (BundleConstituent)resource;
0: 			wirings.put(bc.getBundle().adapt(BundleRevision.class), bc.getWiring());
1: 		}
1: 		else if (resource instanceof BundleRevision) {
1: 			BundleRevision br = (BundleRevision)resource;
0: 			wirings.put(br, br.getWiring());
1: 		}
1: 	}
1: 	
1: 	private Map<Resource, Wiring> computeWirings() {
1: 		Map<Resource, Wiring> wirings = new HashMap<Resource, Wiring>();
1: 		for (BasicSubsystem subsystem : Activator.getInstance().getSubsystems().getSubsystems()) { // NEED
1: 			for (Resource constituent : subsystem.getConstituents()) {
1: 				addWiring(constituent, wirings);
1: 			}
1: 		}
1: 		return Collections.unmodifiableMap(wirings);
1: 	}
1: 
0: 	private Region findRegionForCapabilityValidation(Resource resource) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
0: 		if (isInstallable(resource)) {
0: 			// This is an installable resource so we need to figure out where it
0: 			// will be installed.
0: 			if (isContent(resource) // If the resource is content of this subsystem, it will be installed here.
0: 					// Or if this subsystem accepts dependencies, the resource will be installed here.
0: 					|| this.resource.getSubsystemManifest().getSubsystemTypeHeader().getProvisionPolicyDirective().isAcceptDependencies()) {
0: 				if (this.resource.isComposite()) {
0: 					// Composites define their own sharing policy with which
0: 					// their regions are already configured by the time we get
0: 					// here. We ensure capabilities are visible to this region.
0: 					return this.resource.getRegion();
1: 				}
0: 				// For applications and features, we must ensure capabilities
0: 				// are visible to their scoped parent. Features import
0: 				// everything. Applications have their sharing policies 
0: 				// computed, so if capabilities are visible to the parent, we
0: 				// know we can make them visible to the application.
0: 				return this.resource.getParents().iterator().next().getRegion();
1: 			}
0: 			// Same reasoning as above applies here.
0: 			if (this.resource.isComposite() && this.resource.getSubsystemManifest().getSubsystemTypeHeader().getProvisionPolicyDirective().isAcceptDependencies()) {
0: 				 return this.resource.getRegion();
1: 			}
0: 			return Utils.findFirstSubsystemAcceptingDependenciesStartingFrom(this.resource.getParents().iterator().next()).getRegion();
1: 		}
0: 		else {
0: 			// This is an already installed resource from the system repository.
0: 			if (Utils.isBundle(resource))
0: 				// If it's a bundle, use region digraph to get the region in order
0: 				// to account for bundles in isolated regions outside of the
0: 				// subsystems API.
0: 				return Activator.getInstance().getRegionDigraph().getRegion(((BundleRevision)resource).getBundle());
0: 			else
0: 				// If it's anything else, get the region from one of the
0: 				// subsystems referencing it.
0: 				return Activator.getInstance().getSubsystems().getSubsystemsReferencing(resource).iterator().next().getRegion();
1: 		}
1: 	}
1: 
1: 	private boolean isContent(Resource resource) {
0: 		return this.resource.getSubsystemManifest().getSubsystemContentHeader().contains(resource);
1: 	}
1: 
1: 	private boolean isInstallable(Resource resource) {
1: 		return !isShared(resource);
1: 	}
1: 
1: 	private boolean isShared(Resource resource) {
1: 		return Utils.isSharedResource(resource);
1: 	}
1: 
1: 	private boolean isValid(Capability capability, Requirement requirement) throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
1: 		if (IdentityNamespace.IDENTITY_NAMESPACE.equals(capability.getNamespace()))
1: 			return true;
0: 		Region from = findRegionForCapabilityValidation(capability.getResource());
0: 		Region to = findRegionForCapabilityValidation(requirement.getResource());
1: 		return new SharingPolicyValidator(from, to).isValid(capability);
1: 	}
1: }
============================================================================