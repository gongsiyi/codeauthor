1:96d4e06: /*
1:96d4e06:  * Licensed to the Apache Software Foundation (ASF) under one
1:96d4e06:  * or more contributor license agreements.  See the NOTICE file
1:96d4e06:  * distributed with this work for additional information
1:96d4e06:  * regarding copyright ownership.  The ASF licenses this file
1:96d4e06:  * to you under the Apache License, Version 2.0 (the
1:96d4e06:  * "License"); you may not use this file except in compliance
1:96d4e06:  * with the License.  You may obtain a copy of the License at
1:96d4e06:  *
1:96d4e06:  *   http://www.apache.org/licenses/LICENSE-2.0
1:96d4e06:  *
1:96d4e06:  * Unless required by applicable law or agreed to in writing,
1:96d4e06:  * software distributed under the License is distributed on an
1:96d4e06:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:96d4e06:  * KIND, either express or implied.  See the License for the
1:96d4e06:  * specific language governing permissions and limitations
1:96d4e06:  * under the License.
3:96d4e06:  */
1:475ef33: package org.apache.aries.proxy.impl.common;
5:96d4e06: 
1:8fc6c7b: import static org.apache.aries.proxy.impl.ProxyUtils.JAVA_CLASS_VERSION;
1:96d4e06: 
1:96d4e06: import java.io.IOException;
1:14c07d5: import java.io.InputStream;
1:f43b433: import java.io.Serializable;
1:96d4e06: import java.util.ArrayList;
1:f43b433: import java.util.Arrays;
1:96d4e06: import java.util.HashMap;
1:96d4e06: import java.util.HashSet;
1:96d4e06: import java.util.List;
1:96d4e06: import java.util.Map;
1:96d4e06: import java.util.Set;
1:96d4e06: import java.util.UUID;
1:96d4e06: import java.util.Map.Entry;
1:96d4e06: import java.util.concurrent.Callable;
1:96d4e06: 
1:96d4e06: import org.apache.aries.proxy.InvocationListener;
1:88359ce: import org.apache.aries.proxy.UnableToProxyException;
1:ef57cb3: import org.apache.aries.proxy.impl.NLS;
1:0737543: import org.apache.aries.proxy.impl.SystemModuleClassLoader;
1:96d4e06: import org.apache.aries.proxy.impl.gen.Constants;
1:96d4e06: import org.apache.aries.proxy.weaving.WovenProxy;
1:96d4e06: import org.objectweb.asm.ClassReader;
1:96d4e06: import org.objectweb.asm.ClassVisitor;
1:96d4e06: import org.objectweb.asm.FieldVisitor;
1:96d4e06: import org.objectweb.asm.Label;
1:96d4e06: import org.objectweb.asm.MethodVisitor;
1:96d4e06: import org.objectweb.asm.Opcodes;
1:96d4e06: import org.objectweb.asm.Type;
1:da504e5: import org.objectweb.asm.commons.AdviceAdapter;
1:96d4e06: import org.objectweb.asm.commons.GeneratorAdapter;
1:96d4e06: import org.objectweb.asm.commons.Method;
1:96d4e06: import org.slf4j.Logger;
1:96d4e06: import org.slf4j.LoggerFactory;
1:96d4e06: 
1:96d4e06: 
2:96d4e06: /**
1:96d4e06:  * This abstract superclass is responsible for providing proxy extensions to 
1:96d4e06:  * classes being written. Classes processed by this adapter will implement 
1:96d4e06:  * {@link WovenProxy}, and have a static initialiser that populates 
1:96d4e06:  * {@link java.lang.reflect.Method} fields for use with the 
1:475ef33:  * {@link InvocationListener}. Known subclasses are WovenProxyAdapter, 
1:475ef33:  * used to weave classes being loaded by the framework, and InterfaceCombiningClassAdapter
1:96d4e06:  * which is used to dynamically create objects that implement multiple interfaces
1:96d4e06:  */
1:e6518d7: public abstract class AbstractWovenProxyAdapter extends ClassVisitor implements Opcodes {
1:96d4e06:   private static final Logger LOGGER = LoggerFactory
1:96d4e06:       .getLogger(AbstractWovenProxyAdapter.class);
1:96d4e06: 
1:96d4e06:   /** Access modifier for a public generated method */
1:96d4e06:   private static final int PUBLIC_GENERATED_METHOD_ACCESS = ACC_PUBLIC | ACC_FINAL
1:96d4e06:       | ACC_SYNTHETIC;
1:96d4e06:   /** The internal name for Throwable */
1:96d4e06:   static final String THROWABLE_INAME = Type.getInternalName(Throwable.class);
1:48be854:   /** 
1:48be854:    * A static UUID for adding to our method names. 
1:48be854:    * This must not change over time, otherwise uninstalling
1:48be854:    * and reinstalling the proxy component with a separate
1:48be854:    * API bundle will cause BIG trouble (NoSuchFieldError)
1:48be854:    * with subclasses that get woven by the "new" hook
1:48be854:    */
1:48be854:   private static final String UU_ID = "04df3c80_2877_4f6c_99e2_5a25e11d5535";
1:96d4e06:   /** A constant for No Args methods */
1:96d4e06:   static final Type[] NO_ARGS = new Type[0];
1:96d4e06: 
1:96d4e06:   /** The annotation types we should add to generated methods and fields */
1:96d4e06:   private static final String[] annotationTypeDescriptors = new String[] { "Ljavax/persistence/Transient;" };
1:96d4e06: 
1:96d4e06:   /** the name of the field used to store the {@link InvocationListener} */
1:475ef33:   protected static final String LISTENER_FIELD = "org_apache_aries_proxy_InvocationListener_"
1:96d4e06:       + UU_ID;
1:96d4e06:   /** the name of the field used to store the dispatcher */
1:475ef33:   public static final String DISPATCHER_FIELD = "woven_proxy_dispatcher_" + UU_ID;
1:96d4e06: 
1:96d4e06:   /* Useful ASM types */
1:96d4e06:   /** The ASM type for the {@link InvocationListener} */
1:96d4e06:   static final Type LISTENER_TYPE = Type.getType(InvocationListener.class);
1:96d4e06:   /** The ASM type for the dispatcher */
1:475ef33:   public static final Type DISPATCHER_TYPE = Type.getType(Callable.class);
1:96d4e06:   private static final Type CLASS_TYPE = Type.getType(Class.class);
1:96d4e06:   private static final Type CLASS_ARRAY_TYPE = Type.getType(Class[].class);
1:96d4e06:   private static final Type STRING_TYPE = Type.getType(String.class);
1:475ef33:   public static final Type OBJECT_TYPE = Type.getType(Object.class);
1:96d4e06:   static final Type METHOD_TYPE = Type.getType(java.lang.reflect.Method.class);
1:96d4e06:   /** The {@link Type} of the {@link WovenProxy} interface */
1:96d4e06:   static final Type WOVEN_PROXY_IFACE_TYPE = Type.getType(WovenProxy.class);
1:96d4e06:   private static final Type NPE_TYPE = Type.getType(NullPointerException.class);
1:96d4e06:   
1:96d4e06:   private static final Type[] DISPATCHER_LISTENER_METHOD_ARGS = new Type[] {
1:96d4e06:     DISPATCHER_TYPE, LISTENER_TYPE };
1:96d4e06: 
1:96d4e06:   private static final Method ARGS_CONSTRUCTOR = new Method("<init>", Type.VOID_TYPE,
1:96d4e06:       DISPATCHER_LISTENER_METHOD_ARGS);
1:96d4e06:   private static final Method NO_ARGS_CONSTRUCTOR = new Method("<init>", Type.VOID_TYPE,
1:96d4e06:       NO_ARGS);
1:96d4e06:   private static final Method NPE_CONSTRUCTOR = new Method("<init>", Type.VOID_TYPE,
1:96d4e06:       new Type[] {STRING_TYPE});
1:96d4e06: 
1:96d4e06:   // other new methods we will need
1:96d4e06:   static final Method getInovcationTargetMethod = new Method(
1:96d4e06:       "getInvocationTarget" + UU_ID, OBJECT_TYPE, NO_ARGS);
1:96d4e06:   static final Method listenerPreInvokeMethod = new Method("getListener"
1:96d4e06:       + UU_ID, OBJECT_TYPE, new Type[] { OBJECT_TYPE,
1:96d4e06:       Type.getType(java.lang.reflect.Method.class),
1:96d4e06:       Type.getType(Object[].class) });
1:96d4e06: 
1:96d4e06:   /* Instance fields */
1:96d4e06: 
1:96d4e06:   /** The type of this class */
1:96d4e06:   protected final Type typeBeingWoven;
1:96d4e06:   /** The type of this class's super */
1:96d4e06:   private Type superType;
1:96d4e06:   /** The {@link ClassLoader} loading this class */
1:96d4e06:   private final ClassLoader loader;
1:96d4e06:   /**
1:96d4e06:    * A flag to indicate that we need to weave WovenProxy methods into this class
1:96d4e06:    */
1:96d4e06:   private boolean implementWovenProxy = false;
1:96d4e06:   /** 
1:96d4e06:    * A list of un-woven superclasses between this object and {@link Object}, 
1:96d4e06:    * only populated for classes which will directly implement {@link WovenProxy}.
1:96d4e06:    * This list is then used to override any methods that would otherwise be missed
1:96d4e06:    * by the weaving process. 
1:96d4e06:    */
1:475ef33:   protected final List<Class<?>> nonObjectSupers = new ArrayList<Class<?>>();
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    * Methods we have transformed and need to create static fields for.
1:96d4e06:    * Stored as field name to {@link TypeMethod} so we know which Class to reflect
1:96d4e06:    * them off
1:96d4e06:    */
1:475ef33:   protected final Map<String, TypeMethod> transformedMethods = new HashMap<String, TypeMethod>();
1:96d4e06:   
1:96d4e06:   /**
1:96d4e06:    *  A set of {@link Method} objects identifying the methods that are in this 
1:96d4e06:    *  class. This is used to prevent us duplicating methods copied from 
1:475ef33:    *  {@link AbstractWovenProxyAdapter#nonObjectSupers} that are already overridden in 
1:96d4e06:    *  this class.
1:96d4e06:    */
1:475ef33:   private final Set<Method> knownMethods = new HashSet<Method>();
1:96d4e06:   /** 
1:96d4e06:    * If our super does not have a no-args constructor then we need to be clever
1:96d4e06:    * when writing our own constructor.
1:96d4e06:    */
1:96d4e06:   private boolean superHasNoArgsConstructor = false;
1:dd7db57:   /**
1:dd7db57:    * If we have a no-args constructor then we can delegate there rather than 
1:dd7db57:    * to a super no-args
1:dd7db57:    */
1:dd7db57:   private boolean hasNoArgsConstructor = false;
1:da504e5:   /**
1:f43b433:    * If we have a no-args constructor then we can delegate there rather than 
1:f43b433:    * to a super no-args
1:f43b433:    */
1:f43b433:   protected boolean isSerializable = false;
1:f43b433:   /**
1:da504e5:    * The default static initialization method where we will write the proxy init
1:da504e5:    * code. If there is an existing <clinit> then we will change this and write a
1:da504e5:    * static_init_UUID instead (see the overriden 
1:da504e5:    * {@link #visitMethod(int, String, String, String, String[])}
1:da504e5:    * for where this swap happens). See also {@link #writeStaticInitMethod()} for
1:da504e5:    * where the method is actually written.
1:da504e5:    */
1:da504e5:   private Method staticInitMethod = new Method("<clinit>", Type.VOID_TYPE, NO_ARGS);
1:da504e5:   /**
1:da504e5:    * The default access flags for the staticInitMethod. If we find an existing
1:da504e5:    * <clinit> then we will write a static_init_UUID method and add the ACC_PRIVATE_FLAG.
1:da504e5:    * See the overriden {@link #visitMethod(int, String, String, String, String[])}
1:da504e5:    * for where this flag is added. See also {@link #writeStaticInitMethod()} for
1:da504e5:    * where the method is actually written.
1:da504e5:    */
1:da504e5:   private int staticInitMethodFlags = ACC_SYNTHETIC | ACC_PRIVATE | ACC_STATIC;
1:8f852b6: 
1:8f852b6:   protected Type currentMethodDeclaringType;
1:8f852b6: 
1:8f852b6:   protected boolean currentMethodDeclaringTypeIsInterface;
1:475ef33:   
1:96d4e06:  
1:475ef33:   public static final boolean IS_AT_LEAST_JAVA_6 = JAVA_CLASS_VERSION >= Opcodes.V1_6;
1:475ef33:   
1:96d4e06:   /**
1:96d4e06:    * Create a new adapter for the supplied class
1:96d4e06:    * 
1:96d4e06:    * @param writer
1:96d4e06:    *          The ClassWriter to delegate to
1:96d4e06:    * @param className
1:96d4e06:    *          The name of this class
1:96d4e06:    * @param loader
1:96d4e06:    *          The ClassLoader loading this class
1:9a9631e:    */
1:9a9631e:   public AbstractWovenProxyAdapter(ClassVisitor writer, String className,
1:9a9631e:       ClassLoader loader) {
1:9a9631e:     super(Opcodes.ASM5, writer);
1:9a9631e:     typeBeingWoven = Type.getType("L" + className.replace('.', '/') + ";");
1:9a9631e:     //By default we expect to see methods from a concrete class
1:9a9631e:     currentMethodDeclaringType = typeBeingWoven;
1:8f852b6:     currentMethodDeclaringTypeIsInterface = false;
1:96d4e06:     this.loader = loader;
9:96d4e06:   }
1:96d4e06: 
1:96d4e06:   public final void visit(int version, int access, String name, String signature,
1:96d4e06:       String superName, String[] interfaces) {
1:96d4e06:     LOGGER.debug(Constants.LOG_ENTRY, "visit", new Object[] { version, access,
1:96d4e06:         name, signature, superName, interfaces });
1:96d4e06: 
1:bef949f:     // always update to the most recent version of the JVM
1:8fc6c7b:     version = JAVA_CLASS_VERSION;
1:96d4e06: 
1:96d4e06:     superType = Type.getType("L" + superName + ";");
1:96d4e06: 
1:dd7db57:     try {
1:96d4e06:       // we only want to implement WovenProxy once in the hierarchy.
1:96d4e06:       // It's best to do this as high up as possible so we check the
1:96d4e06:       // super. By loading it we may end up weaving it, but that's a good thing!
1:96d4e06:       Class<?> superClass = Class.forName(superName.replace('/', '.'), false,
1:96d4e06:           loader);
1:96d4e06: 
1:f43b433:       isSerializable = Serializable.class.isAssignableFrom(superClass) || 
1:0857a0e:                        Arrays.asList(interfaces).contains(Type.getInternalName(Serializable.class)) ||
1:0857a0e:                        checkInterfacesForSerializability(interfaces);
1:f43b433:       
1:96d4e06:       if (!!!WovenProxy.class.isAssignableFrom(superClass)) {
1:96d4e06: 
1:96d4e06:         // We have found a type we need to add WovenProxy information to
1:96d4e06: 
1:96d4e06:         implementWovenProxy = true;
1:96d4e06:         
1:96d4e06:         if(superClass != Object.class) {
1:96d4e06:           //If our superclass isn't Object, it means we didn't weave all the way
1:96d4e06:           //to the top of the hierarchy. This means we need to override all the
1:96d4e06:           //methods defined on our parent so that they can be intercepted!
1:96d4e06:           nonObjectSupers.add(superClass);
1:96d4e06:           Class<?> nextSuper = superClass.getSuperclass();
1:96d4e06:           while(nextSuper != Object.class) {
1:96d4e06:             nonObjectSupers.add(nextSuper);
1:96d4e06:             nextSuper = nextSuper.getSuperclass();
1:dd7db57:           }
1:14c07d5:           //Don't use reflection - it can be dangerous
1:14c07d5:           superHasNoArgsConstructor = superHasNoArgsConstructor(superName, name);
1:14c07d5: 
1:dd7db57:         } else {
1:dd7db57:           superHasNoArgsConstructor = true;
1:96d4e06:         }
1:96d4e06: 
1:96d4e06:         // re-work the interfaces list to include WovenProxy
1:96d4e06:         String[] interfacesPlusWovenProxy = new String[interfaces.length + 1];
1:96d4e06:         System.arraycopy(interfaces, 0, interfacesPlusWovenProxy, 0, interfaces.length);
1:96d4e06:         interfacesPlusWovenProxy[interfaces.length] = WOVEN_PROXY_IFACE_TYPE.getInternalName();
1:96d4e06: 
1:96d4e06:         // Write the class header including WovenProxy.
1:96d4e06:         cv.visit(version, access, name, signature, superName, interfacesPlusWovenProxy);
1:96d4e06: 
1:96d4e06:       } else {
1:96d4e06:         // Already has a woven proxy parent, but we still need to write the
1:96d4e06:         // header!
1:96d4e06:         cv.visit(version, access, name, signature, superName, interfaces);
1:96d4e06:       }
1:96d4e06:     } catch (ClassNotFoundException e) {
1:ff6b522:       // If this happens we're about to hit bigger trouble on verify, so we
1:ff6b522:       // should stop weaving and fail. Make sure we don't cause the hook to
1:ff6b522:       // throw an error though.
1:ff6b522:       UnableToProxyException u = new UnableToProxyException(name, e);
1:ff6b522:       throw new RuntimeException(NLS.MESSAGES.getMessage("cannot.load.superclass", superName.replace('/', '.'), typeBeingWoven.getClassName()), u);
1:96d4e06:     }
1:96d4e06:   }
1:96d4e06: 
1:14c07d5:   /**
1:14c07d5:    * This method allows us to determine whether a superclass has a
1:14c07d5:    * non-private no-args constructor without causing it to initialize.
1:14c07d5:    * This avoids a potential ClassCircularityError on Mac VMs if the
1:14c07d5:    * initialization references the subclass being woven. Odd, but seen
1:14c07d5:    * in the wild!
1:14c07d5:    */
1:14c07d5:   private final boolean superHasNoArgsConstructor(String superName, String name) {
1:14c07d5:     
1:14c07d5:     ConstructorFinder cf = new ConstructorFinder();
1:14c07d5:     
1:14c07d5:     try {
1:14c07d5:       InputStream is = loader.getResourceAsStream(superName +".class");
1:14c07d5:     
1:14c07d5:       if(is == null)
1:14c07d5:         throw new IOException();
1:14c07d5:       
1:14c07d5:       new ClassReader(is).accept(cf, ClassReader.SKIP_FRAMES + ClassReader.SKIP_DEBUG + ClassReader.SKIP_CODE);
1:14c07d5:     } catch (IOException ioe) {
1:14c07d5:       UnableToProxyException u = new UnableToProxyException(name, ioe);
1:14c07d5:       throw new RuntimeException(NLS.MESSAGES.getMessage("cannot.load.superclass", superName.replace('/', '.'), typeBeingWoven.getClassName()), u);
1:14c07d5:     }
1:14c07d5:     return cf.hasNoArgsConstructor();
1:14c07d5:   }
1:14c07d5:   
1:0857a0e:   private boolean checkInterfacesForSerializability(String[] interfaces) throws ClassNotFoundException {
1:0857a0e:     for(String iface : interfaces)
1:0857a0e:     {
1:0857a0e:       if(Serializable.class.isAssignableFrom(Class.forName(
1:0857a0e:                  iface.replace('/', '.'), false, loader)))
1:0857a0e:         return true;
1:0857a0e:     }
1:0857a0e:     return false;
1:0857a0e:   }
1:0857a0e: 
1:96d4e06:   /**
1:96d4e06:    * This method is called on each method implemented on this object (but not
1:96d4e06:    * for superclass methods) Each of these methods is visited in turn and the
1:96d4e06:    * code here generates the byte code for the calls to the InovcationListener
1:96d4e06:    * around the existing method
1:96d4e06:    */
1:96d4e06:   public final MethodVisitor visitMethod(int access, String name, String desc,
1:96d4e06:       String signature, String[] exceptions) {
1:96d4e06:     LOGGER.debug(Constants.LOG_ENTRY, "visitMethod", new Object[] { access,
1:96d4e06:         name, desc, signature, exceptions });
1:96d4e06: 
1:96d4e06:     
1:96d4e06:     Method currentMethod = new Method(name, desc);
1:96d4e06:     
1:475ef33:     getKnownMethods().add(currentMethod);
1:96d4e06:     
1:96d4e06:     MethodVisitor methodVisitorToReturn = null;
1:96d4e06: 
1:96d4e06:     // Only weave "real" instance methods. Not constructors, initializers or
1:96d4e06:     // compiler generated ones.
1:8f852b6:     if ((access & (ACC_STATIC | ACC_PRIVATE | ACC_SYNTHETIC 
1:dd7db57:         | ACC_NATIVE | ACC_BRIDGE)) == 0 && !!!name.equals("<init>") && 
1:dd7db57:         !!!name.equals("<clinit>")) {
1:96d4e06: 
1:96d4e06:       // found a method we should weave
1:96d4e06: 
1:96d4e06:       //Create a field name and store it for later
1:96d4e06:       String methodStaticFieldName = "methodField" + getSanitizedUUIDString();
1:96d4e06:       transformedMethods.put(methodStaticFieldName, new TypeMethod(
1:8f852b6:            currentMethodDeclaringType, currentMethod));
1:96d4e06: 
1:96d4e06:       // Surround the MethodVisitor with our weaver so we can manipulate the code
1:96d4e06:       methodVisitorToReturn = getWeavingMethodVisitor(access, name, desc,
1:8f852b6:           signature, exceptions, currentMethod, methodStaticFieldName,
1:8f852b6:           currentMethodDeclaringType, currentMethodDeclaringTypeIsInterface);
1:da504e5:     } else if (name.equals("<clinit>")){
1:da504e5:       //there is an existing clinit method, change the fields we use
1:9a9631e:       //to write our init code to static_init_UUID instead
1:9a9631e:       staticInitMethod = new Method("static_init_" + UU_ID, Type.VOID_TYPE, NO_ARGS);
1:9a9631e:       staticInitMethodFlags = staticInitMethodFlags | ACC_FINAL;
1:9a9631e:       methodVisitorToReturn = new AdviceAdapter(Opcodes.ASM5, cv.visitMethod(access, name, desc, signature,
1:9a9631e:           exceptions), access, name, desc){
1:9a9631e:         @Override
1:9a9631e:         protected void onMethodEnter()
1:da504e5:         {
1:da504e5:           //add into the <clinit> a call to our synthetic static_init_UUID
1:da504e5:           invokeStatic(typeBeingWoven, staticInitMethod);
1:da504e5:           super.onMethodEnter();
1:da504e5:         }
1:da504e5:       };
1:96d4e06:     } else {
1:dd7db57:       if(currentMethod.getArgumentTypes().length == 0 && name.equals("<init>"))
1:dd7db57:         hasNoArgsConstructor = true;
1:96d4e06:       //This isn't a method we want to weave, so just get the default visitor
1:96d4e06:       methodVisitorToReturn = cv.visitMethod(access, name, desc, signature,
1:96d4e06:           exceptions);
1:96d4e06:     }
1:96d4e06: 
1:96d4e06:     LOGGER.debug(Constants.LOG_EXIT, "visitMethod", methodVisitorToReturn);
1:96d4e06:     return methodVisitorToReturn;
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Our class may claim to implement WovenProxy, but doesn't have any
1:96d4e06:    * implementations! We should fix this.
1:96d4e06:    */
1:475ef33:   public void visitEnd() {
1:96d4e06:     LOGGER.debug(Constants.LOG_ENTRY, "visitEnd");
1:96d4e06: 
1:8f852b6:     for(Class<?> c : nonObjectSupers) {
1:8f852b6:       setCurrentMethodDeclaringType(Type.getType(c), false);
1:8f852b6:       try {
1:8f852b6:         readClass(c, new MethodCopyingClassAdapter(this, loader, c, typeBeingWoven, 
1:8f852b6:             getKnownMethods(), transformedMethods));
1:8f852b6:       } catch (IOException e) {
1:8f852b6:         // This should never happen! <= famous last words (not)
1:8f852b6:         throw new RuntimeException(NLS.MESSAGES.getMessage("unexpected.error.processing.class", c.getName(), typeBeingWoven.getClassName()), e);
1:8f852b6:       }
1:8f852b6:     }
1:96d4e06:     // If we need to implement woven proxy in this class then write the methods
1:96d4e06:     if (implementWovenProxy) {
1:96d4e06:       writeFinalWovenProxyMethods();
1:88359ce:     }
1:88359ce:     
1:96d4e06:     // this method is called when we reach the end of the class
1:96d4e06:     // so it is time to make sure the static initialiser method is written
1:96d4e06:     writeStaticInitMethod();
1:96d4e06: 
1:96d4e06:     // Make sure we add the instance specific WovenProxy method to our class,
1:96d4e06:     // and give ourselves a constructor to use
1:96d4e06:     writeCreateNewProxyInstanceAndConstructor();
1:96d4e06: 
1:96d4e06:     // now delegate to the cv
1:96d4e06:     cv.visitEnd();
1:96d4e06: 
1:96d4e06:     LOGGER.debug(Constants.LOG_EXIT, "visitEnd");
1:88359ce:   }
1:475ef33:   
1:475ef33:   public Set<Method> getKnownMethods() {
1:475ef33:     return knownMethods;
1:475ef33:   }
1:475ef33: 
1:96d4e06:   /**
1:96d4e06:    * Get the {@link MethodVisitor} that will weave a given method
1:96d4e06:    * @param access
1:96d4e06:    * @param name
1:96d4e06:    * @param desc
1:96d4e06:    * @param signature
1:96d4e06:    * @param exceptions
1:96d4e06:    * @param currentMethod
1:96d4e06:    * @param methodStaticFieldName
2:96d4e06:    * @return
1:96d4e06:    */
1:96d4e06:   protected abstract MethodVisitor getWeavingMethodVisitor(int access, String name,
1:96d4e06:   String desc, String signature, String[] exceptions, Method currentMethod,
1:8f852b6:   String methodStaticFieldName, Type currentMethodDeclaringType,
1:8f852b6:   boolean currentMethodDeclaringTypeIsInterface);
1:96d4e06:   
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Write the methods we need for wovenProxies on the highest supertype
1:96d4e06:    */
1:96d4e06:   private final void writeFinalWovenProxyMethods() {
1:96d4e06:     // add private fields for the Callable<Object> dispatcher
1:96d4e06:     // and InvocationListener. These aren't static because we can have
1:96d4e06:     // multiple instances of the same proxy class. These should not be
1:96d4e06:     // serialized, or used in JPA or any other thing we can think of,
1:96d4e06:     // so we annotate them as necessary
1:96d4e06: 
1:96d4e06:     generateField(DISPATCHER_FIELD, Type.getDescriptor(Callable.class));
1:96d4e06:     generateField(LISTENER_FIELD, Type.getDescriptor(InvocationListener.class));
1:96d4e06: 
1:96d4e06:     // a general methodAdapter field that we will use to with GeneratorAdapters
1:96d4e06:     // to create the methods required to implement WovenProxy
1:96d4e06:     GeneratorAdapter methodAdapter;
1:96d4e06: 
1:96d4e06:     // add a method for unwrapping the dispatcher
1:96d4e06:     methodAdapter = getMethodGenerator(PUBLIC_GENERATED_METHOD_ACCESS, new Method(
1:96d4e06:         "org_apache_aries_proxy_weaving_WovenProxy_unwrap", DISPATCHER_TYPE,
1:96d4e06:         NO_ARGS));
1:96d4e06: 
1:96d4e06:     // /////////////////////////////////////////////////////
1:96d4e06:     // Implement the method
1:96d4e06: 
1:96d4e06:     // load this to get the field
1:96d4e06:     methodAdapter.loadThis();
1:96d4e06:     // get the dispatcher field and return
1:96d4e06:     methodAdapter.getField(typeBeingWoven, DISPATCHER_FIELD, DISPATCHER_TYPE);
1:96d4e06:     methodAdapter.returnValue();
1:96d4e06:     methodAdapter.endMethod();
1:96d4e06: 
1:96d4e06:     // /////////////////////////////////////////////////////
1:96d4e06: 
1:96d4e06:     // add a method for checking if the dispatcher is set
1:96d4e06:     methodAdapter = getMethodGenerator(PUBLIC_GENERATED_METHOD_ACCESS, new Method(
1:96d4e06:         "org_apache_aries_proxy_weaving_WovenProxy_isProxyInstance",
1:96d4e06:         Type.BOOLEAN_TYPE, NO_ARGS));
1:96d4e06: 
1:96d4e06:     // /////////////////////////////////////////////////////
1:96d4e06:     // Implement the method
1:96d4e06: 
1:96d4e06:     // load this to get the field
1:96d4e06:     methodAdapter.loadThis();
1:96d4e06:     // make a label for return true
1:96d4e06:     Label returnTrueLabel = methodAdapter.newLabel();
1:96d4e06:     // get the dispatcher field for the stack
1:96d4e06:     methodAdapter.getField(typeBeingWoven, DISPATCHER_FIELD, DISPATCHER_TYPE);
1:96d4e06:     // check if the dispatcher was non-null and goto return true if it was
1:96d4e06:     methodAdapter.ifNonNull(returnTrueLabel);
1:96d4e06:     methodAdapter.loadThis();
1:96d4e06:     // get the listener field for the stack
1:96d4e06:     methodAdapter.getField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);
1:96d4e06:     // check if the listener field was non-null and goto return true if it was
1:96d4e06:     methodAdapter.ifNonNull(returnTrueLabel);
1:96d4e06:     // return false if we haven't jumped anywhere
1:96d4e06:     methodAdapter.push(false);
1:96d4e06:     methodAdapter.returnValue();
1:96d4e06:     // mark the returnTrueLable
1:96d4e06:     methodAdapter.mark(returnTrueLabel);
1:96d4e06:     methodAdapter.push(true);
1:96d4e06:     methodAdapter.returnValue();
1:96d4e06:     // end the method
1:96d4e06:     methodAdapter.endMethod();
1:96d4e06: 
1:96d4e06:     // ///////////////////////////////////////////////////////
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * We write createNewProxyInstance separately because it isn't final, and is
1:96d4e06:    * overridden on each class, we also write a constructor for this method to
1:96d4e06:    * use if we don't have one.
1:96d4e06:    */
1:96d4e06:   private final void writeCreateNewProxyInstanceAndConstructor() {
1:96d4e06:     GeneratorAdapter methodAdapter = getMethodGenerator(ACC_PUBLIC, new Method(
1:96d4e06:         "org_apache_aries_proxy_weaving_WovenProxy_createNewProxyInstance",
1:96d4e06:         WOVEN_PROXY_IFACE_TYPE, DISPATCHER_LISTENER_METHOD_ARGS));
1:96d4e06: 
1:96d4e06:     // /////////////////////////////////////////////////////
1:96d4e06:     // Implement the method
1:96d4e06: 
1:96d4e06:     // Create and instantiate a new instance, then return it
1:96d4e06:     methodAdapter.newInstance(typeBeingWoven);
1:96d4e06:     methodAdapter.dup();
1:96d4e06:     methodAdapter.loadArgs();
1:96d4e06:     methodAdapter.invokeConstructor(typeBeingWoven, new Method("<init>",
1:96d4e06:         Type.VOID_TYPE, DISPATCHER_LISTENER_METHOD_ARGS));
1:96d4e06:     methodAdapter.returnValue();
1:96d4e06:     methodAdapter.endMethod();
1:96d4e06:     //////////////////////////////////////////////////////////
1:96d4e06: 
1:96d4e06:     
1:96d4e06:     // Write a protected no-args constructor for this class
1:bef949f:     methodAdapter = getMethodGenerator(ACC_PROTECTED | ACC_SYNTHETIC, ARGS_CONSTRUCTOR);
1:96d4e06: 
1:96d4e06:     // /////////////////////////////////////////////////////
1:96d4e06:     // Implement the constructor
1:96d4e06: 
1:96d4e06:     // For the top level supertype we need to invoke a no-args super, on object 
1:96d4e06:     //if we have to
1:96d4e06:     
1:96d4e06:     if(implementWovenProxy) {
1:96d4e06:       methodAdapter.loadThis();
1:96d4e06: 
1:96d4e06:       if (superHasNoArgsConstructor)
1:96d4e06:         methodAdapter.invokeConstructor(superType, NO_ARGS_CONSTRUCTOR);
1:dd7db57:       else {
1:dd7db57:         if(hasNoArgsConstructor)
1:dd7db57:           methodAdapter.invokeConstructor(typeBeingWoven, NO_ARGS_CONSTRUCTOR);
1:dd7db57:         else
1:ef57cb3:           throw new RuntimeException(new UnableToProxyException(typeBeingWoven.getClassName(), 
1:ef57cb3:               NLS.MESSAGES.getMessage("type.lacking.no.arg.constructor", typeBeingWoven.getClassName(), superType.getClassName())));
1:dd7db57:       }
1:96d4e06:       methodAdapter.loadThis();
1:96d4e06:       methodAdapter.loadArg(0);
1:96d4e06:       methodAdapter.putField(typeBeingWoven, DISPATCHER_FIELD, DISPATCHER_TYPE);
1:96d4e06:       
1:96d4e06:       methodAdapter.loadThis();
1:96d4e06:       methodAdapter.loadArg(1);
1:96d4e06:       methodAdapter.putField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);
1:96d4e06:     } else {
1:96d4e06:       //We just invoke the super with args
1:96d4e06:       methodAdapter.loadThis();
1:96d4e06:       methodAdapter.loadArgs();
1:96d4e06:       methodAdapter.invokeConstructor(superType, ARGS_CONSTRUCTOR);
1:96d4e06:     }
1:96d4e06:     
1:96d4e06:     //Throw an NPE if the dispatcher is null, return otherwise
1:96d4e06:     methodAdapter.loadArg(0);
1:96d4e06:     Label returnValue = methodAdapter.newLabel();
1:96d4e06:     methodAdapter.ifNonNull(returnValue);
1:96d4e06:     methodAdapter.newInstance(NPE_TYPE);
1:96d4e06:     methodAdapter.dup();
1:96d4e06:     methodAdapter.push("The dispatcher must never be null!");
1:96d4e06:     methodAdapter.invokeConstructor(NPE_TYPE, NPE_CONSTRUCTOR);
1:96d4e06:     methodAdapter.throwException();
1:96d4e06:     
1:96d4e06:     methodAdapter.mark(returnValue);
1:96d4e06:     methodAdapter.returnValue();
1:96d4e06:     methodAdapter.endMethod();
1:96d4e06:     //////////////////////////////////////////////////////////
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Create fields and an initialiser for {@link java.lang.reflect.Method}
1:96d4e06:    * objects in our class
1:96d4e06:    */
1:96d4e06:   private final void writeStaticInitMethod() {
1:96d4e06:     // we create a static field for each method we encounter with a *unique*
1:96d4e06:     // random name
1:96d4e06:     // since each method needs to be stored individually
1:96d4e06: 
1:96d4e06:     for (String methodStaticFieldName : transformedMethods.keySet()) {
1:96d4e06:       // add a private static field for the method
1:96d4e06:       cv.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL | ACC_SYNTHETIC,
1:96d4e06:           methodStaticFieldName, METHOD_TYPE.getDescriptor(), null, null)
1:96d4e06:           .visitEnd();
1:96d4e06:     }
1:da504e5:     GeneratorAdapter staticAdapter = new GeneratorAdapter(staticInitMethodFlags,
1:da504e5:         staticInitMethod, null, null, cv);
1:96d4e06: 
1:96d4e06:     for (Entry<String, TypeMethod> entry : transformedMethods.entrySet()) {
1:96d4e06:       // Add some more code to the static initializer
1:96d4e06: 
1:96d4e06:       TypeMethod m = entry.getValue();
1:96d4e06:       Type[] targetMethodParameters = m.method.getArgumentTypes();
1:96d4e06: 
1:96d4e06:       String methodStaticFieldName = entry.getKey();
1:96d4e06: 
1:96d4e06:       Label beginPopulate = staticAdapter.newLabel();
1:96d4e06:       Label endPopulate = staticAdapter.newLabel();
1:96d4e06:       Label catchHandler = staticAdapter.newLabel();
1:96d4e06:       staticAdapter.visitTryCatchBlock(beginPopulate, endPopulate,
1:96d4e06:           catchHandler, THROWABLE_INAME);
1:96d4e06: 
1:96d4e06:       staticAdapter.mark(beginPopulate);
1:96d4e06:       staticAdapter.push(m.declaringClass);
1:96d4e06: 
1:96d4e06:       // push the method name string arg onto the stack
1:96d4e06:       staticAdapter.push(m.method.getName());
1:96d4e06: 
1:96d4e06:       // create an array of the method parm class[] arg
1:96d4e06:       staticAdapter.push(targetMethodParameters.length);
1:96d4e06:       staticAdapter.newArray(CLASS_TYPE);
1:96d4e06:       int index = 0;
1:96d4e06:       for (Type t : targetMethodParameters) {
1:96d4e06:         staticAdapter.dup();
1:96d4e06:         staticAdapter.push(index);
1:96d4e06:         staticAdapter.push(t);
1:96d4e06:         staticAdapter.arrayStore(CLASS_TYPE);
1:96d4e06:         index++;
1:96d4e06:       }
1:96d4e06: 
1:96d4e06:       // invoke the getMethod
1:96d4e06:       staticAdapter.invokeVirtual(CLASS_TYPE,
1:96d4e06:           new Method("getDeclaredMethod", METHOD_TYPE, new Type[] {
1:96d4e06:               STRING_TYPE, CLASS_ARRAY_TYPE}));
1:96d4e06: 
1:96d4e06:       // store the reflected method in the static field
1:96d4e06:       staticAdapter.putStatic(typeBeingWoven, methodStaticFieldName,
1:96d4e06:           METHOD_TYPE);
1:96d4e06: 
1:96d4e06:       Label afterCatch = staticAdapter.newLabel();
1:96d4e06:       staticAdapter.mark(endPopulate);
1:96d4e06:       staticAdapter.goTo(afterCatch);
1:96d4e06: 
1:96d4e06:       staticAdapter.mark(catchHandler);
1:96d4e06:       // We don't care about the exception, so pop it off
1:96d4e06:       staticAdapter.pop();
1:96d4e06:       // store the reflected method in the static field
1:96d4e06:       staticAdapter.visitInsn(ACONST_NULL);
1:96d4e06:       staticAdapter.putStatic(typeBeingWoven, methodStaticFieldName,
1:96d4e06:           METHOD_TYPE);
1:96d4e06:       staticAdapter.mark(afterCatch);
1:96d4e06: 
1:96d4e06:     }
1:96d4e06:     staticAdapter.returnValue();
1:96d4e06:     staticAdapter.endMethod();
1:96d4e06:   }
1:96d4e06: 
1:96d4e06:   /**
1:96d4e06:    * Get a new UUID suitable for use in method and field names
1:96d4e06:    * 
1:96d4e06:    * @return
1:96d4e06:    */
1:475ef33:   public static final String getSanitizedUUIDString() {
1:96d4e06:     return UUID.randomUUID().toString().replace('-', '_');
1:475ef33:   }
1:475ef33: 
1:96d4e06:   /**
1:475ef33:    * This method will read the bytes for the supplied {@link Class} using the
1:475ef33:    * supplied ASM {@link ClassVisitor}, the reader will skip DEBUG, FRAMES and CODE.
1:475ef33:    * @param c
1:475ef33:    * @param adapter
1:475ef33:    * @throws IOException
1:475ef33:    */
1:475ef33:   public static void readClass(Class<?> c, ClassVisitor adapter) throws IOException {
1:0737543:     String className = c.getName().replace(".", "/") + ".class";
1:0737543: 
1:475ef33:     //Load the class bytes and copy methods across
1:0737543:     ClassLoader loader = c.getClassLoader();
1:0737543:     if (loader == null) {
1:0737543:       //system class, use SystemModuleClassLoader as fallback
1:0737543:       loader = new SystemModuleClassLoader();
1:0737543:     }
1:0737543:     ClassReader cReader = new ClassReader(loader.getResourceAsStream(className));
1:83a2c7c: 
1:475ef33:     cReader.accept(adapter, ClassReader.SKIP_CODE | 
1:475ef33:         ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
1:475ef33:   }
1:475ef33: 
1:475ef33:   /**
1:96d4e06:    * Generate an instance field that should be "invisible" to normal code
1:96d4e06:    * 
1:96d4e06:    * @param fieldName
1:96d4e06:    * @param fieldDescriptor
1:96d4e06:    */
1:96d4e06:   private final void generateField(String fieldName, String fieldDescriptor) {
1:96d4e06:     FieldVisitor fv = cv.visitField(ACC_PROTECTED | ACC_TRANSIENT | ACC_SYNTHETIC
1:96d4e06:         | ACC_FINAL, fieldName, fieldDescriptor, null, null);
1:96d4e06:     for (String s : annotationTypeDescriptors)
1:96d4e06:       fv.visitAnnotation(s, true).visitEnd();
1:96d4e06:     fv.visitEnd();
1:475ef33:   }
1:475ef33: 
1:96d4e06:   /**
1:96d4e06:    * Get a generator for a method, this be annotated with the "invisibility"
1:96d4e06:    * annotations (and ensured synthetic)
1:96d4e06:    * 
1:e182908:    * @param methodSignature
1:96d4e06:    * @return
1:96d4e06:    */
1:96d4e06:   private final GeneratorAdapter getMethodGenerator(int access, Method method) {
1:96d4e06:     access = access | ACC_SYNTHETIC;
1:96d4e06:     GeneratorAdapter ga = new GeneratorAdapter(access, method, null, null, cv);
1:96d4e06:     for (String s : annotationTypeDescriptors)
1:96d4e06:       ga.visitAnnotation(s, true).visitEnd();
1:96d4e06:     ga.visitCode();
1:96d4e06:     return ga;
1:96d4e06:   }
1:8f852b6: 
1:8f852b6:   public final void setCurrentMethodDeclaringType(Type type, boolean isInterface) {
1:8f852b6:     currentMethodDeclaringType = type;
1:8f852b6:     currentMethodDeclaringTypeIsInterface = isInterface;
1:8f852b6:   }
1:96d4e06: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:0737543
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.impl.SystemModuleClassLoader;
/////////////////////////////////////////////////////////////////////////
1:     String className = c.getName().replace(".", "/") + ".class";
1: 
1:     ClassLoader loader = c.getClassLoader();
1:     if (loader == null) {
1:       //system class, use SystemModuleClassLoader as fallback
1:       loader = new SystemModuleClassLoader();
1:     }
1:     ClassReader cReader = new ClassReader(loader.getResourceAsStream(className));
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:9a9631e
/////////////////////////////////////////////////////////////////////////
1:    */
1:   public AbstractWovenProxyAdapter(ClassVisitor writer, String className,
1:       ClassLoader loader) {
1:     super(Opcodes.ASM5, writer);
1:     typeBeingWoven = Type.getType("L" + className.replace('.', '/') + ";");
1:     //By default we expect to see methods from a concrete class
1:     currentMethodDeclaringType = typeBeingWoven;
/////////////////////////////////////////////////////////////////////////
1:       //to write our init code to static_init_UUID instead
1:       staticInitMethod = new Method("static_init_" + UU_ID, Type.VOID_TYPE, NO_ARGS);
1:       staticInitMethodFlags = staticInitMethodFlags | ACC_FINAL;
1:       methodVisitorToReturn = new AdviceAdapter(Opcodes.ASM5, cv.visitMethod(access, name, desc, signature,
1:           exceptions), access, name, desc){
1:         @Override
1:         protected void onMethodEnter()
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:48be854
/////////////////////////////////////////////////////////////////////////
1:   /** 
1:    * A static UUID for adding to our method names. 
1:    * This must not change over time, otherwise uninstalling
1:    * and reinstalling the proxy component with a separate
1:    * API bundle will cause BIG trouble (NoSuchFieldError)
1:    * with subclasses that get woven by the "new" hook
1:    */
1:   private static final String UU_ID = "04df3c80_2877_4f6c_99e2_5a25e11d5535";
commit:8f852b6
/////////////////////////////////////////////////////////////////////////
1: 
1:   protected Type currentMethodDeclaringType;
1: 
1:   protected boolean currentMethodDeclaringTypeIsInterface;
/////////////////////////////////////////////////////////////////////////
0:     //By default we expect to see methods from a concrete class
0:     currentMethodDeclaringType = typeBeingWoven;
1:     currentMethodDeclaringTypeIsInterface = false;
/////////////////////////////////////////////////////////////////////////
1:     if ((access & (ACC_STATIC | ACC_PRIVATE | ACC_SYNTHETIC 
/////////////////////////////////////////////////////////////////////////
1:            currentMethodDeclaringType, currentMethod));
1:           signature, exceptions, currentMethod, methodStaticFieldName,
1:           currentMethodDeclaringType, currentMethodDeclaringTypeIsInterface);
/////////////////////////////////////////////////////////////////////////
1:     for(Class<?> c : nonObjectSupers) {
1:       setCurrentMethodDeclaringType(Type.getType(c), false);
1:       try {
1:         readClass(c, new MethodCopyingClassAdapter(this, loader, c, typeBeingWoven, 
1:             getKnownMethods(), transformedMethods));
1:       } catch (IOException e) {
1:         // This should never happen! <= famous last words (not)
1:         throw new RuntimeException(NLS.MESSAGES.getMessage("unexpected.error.processing.class", c.getName(), typeBeingWoven.getClassName()), e);
1:       }
1:     }
/////////////////////////////////////////////////////////////////////////
1:   String methodStaticFieldName, Type currentMethodDeclaringType,
1:   boolean currentMethodDeclaringTypeIsInterface);
/////////////////////////////////////////////////////////////////////////
1: 
1:   public final void setCurrentMethodDeclaringType(Type type, boolean isInterface) {
1:     currentMethodDeclaringType = type;
1:     currentMethodDeclaringTypeIsInterface = isInterface;
1:   }
commit:14c07d5
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
1:           //Don't use reflection - it can be dangerous
1:           superHasNoArgsConstructor = superHasNoArgsConstructor(superName, name);
1: 
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * This method allows us to determine whether a superclass has a
1:    * non-private no-args constructor without causing it to initialize.
1:    * This avoids a potential ClassCircularityError on Mac VMs if the
1:    * initialization references the subclass being woven. Odd, but seen
1:    * in the wild!
1:    */
1:   private final boolean superHasNoArgsConstructor(String superName, String name) {
1:     
1:     ConstructorFinder cf = new ConstructorFinder();
1:     
1:     try {
1:       InputStream is = loader.getResourceAsStream(superName +".class");
1:     
1:       if(is == null)
1:         throw new IOException();
1:       
1:       new ClassReader(is).accept(cf, ClassReader.SKIP_FRAMES + ClassReader.SKIP_DEBUG + ClassReader.SKIP_CODE);
1:     } catch (IOException ioe) {
1:       UnableToProxyException u = new UnableToProxyException(name, ioe);
1:       throw new RuntimeException(NLS.MESSAGES.getMessage("cannot.load.superclass", superName.replace('/', '.'), typeBeingWoven.getClassName()), u);
1:     }
1:     return cf.hasNoArgsConstructor();
1:   }
1:   
commit:0857a0e
/////////////////////////////////////////////////////////////////////////
1:                        Arrays.asList(interfaces).contains(Type.getInternalName(Serializable.class)) ||
1:                        checkInterfacesForSerializability(interfaces);
/////////////////////////////////////////////////////////////////////////
1:   private boolean checkInterfacesForSerializability(String[] interfaces) throws ClassNotFoundException {
1:     for(String iface : interfaces)
1:     {
1:       if(Serializable.class.isAssignableFrom(Class.forName(
1:                  iface.replace('/', '.'), false, loader)))
1:         return true;
1:     }
1:     return false;
1:   }
1: 
commit:f43b433
/////////////////////////////////////////////////////////////////////////
1: import java.io.Serializable;
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:    * If we have a no-args constructor then we can delegate there rather than 
1:    * to a super no-args
1:    */
1:   protected boolean isSerializable = false;
1:   /**
/////////////////////////////////////////////////////////////////////////
1:       isSerializable = Serializable.class.isAssignableFrom(superClass) || 
0:                        Arrays.asList(interfaces).contains(Type.getInternalName(Serializable.class));
1:       
commit:83a2c7c
/////////////////////////////////////////////////////////////////////////
0:     String className = c.getName();
0:     className = className.substring(className.lastIndexOf('.') + 1) + ".class";
1:         
commit:ff6b522
/////////////////////////////////////////////////////////////////////////
1:       // If this happens we're about to hit bigger trouble on verify, so we
1:       // should stop weaving and fail. Make sure we don't cause the hook to
1:       // throw an error though.
1:       UnableToProxyException u = new UnableToProxyException(name, e);
1:       throw new RuntimeException(NLS.MESSAGES.getMessage("cannot.load.superclass", superName.replace('/', '.'), typeBeingWoven.getClassName()), u);
commit:dad18d4
/////////////////////////////////////////////////////////////////////////
commit:da504e5
/////////////////////////////////////////////////////////////////////////
1: import org.objectweb.asm.commons.AdviceAdapter;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * The default static initialization method where we will write the proxy init
1:    * code. If there is an existing <clinit> then we will change this and write a
1:    * static_init_UUID instead (see the overriden 
1:    * {@link #visitMethod(int, String, String, String, String[])}
1:    * for where this swap happens). See also {@link #writeStaticInitMethod()} for
1:    * where the method is actually written.
1:    */
1:   private Method staticInitMethod = new Method("<clinit>", Type.VOID_TYPE, NO_ARGS);
1:   /**
1:    * The default access flags for the staticInitMethod. If we find an existing
1:    * <clinit> then we will write a static_init_UUID method and add the ACC_PRIVATE_FLAG.
1:    * See the overriden {@link #visitMethod(int, String, String, String, String[])}
1:    * for where this flag is added. See also {@link #writeStaticInitMethod()} for
1:    * where the method is actually written.
1:    */
1:   private int staticInitMethodFlags = ACC_SYNTHETIC | ACC_PRIVATE | ACC_STATIC;
/////////////////////////////////////////////////////////////////////////
0:     super(writer);
/////////////////////////////////////////////////////////////////////////
1:     } else if (name.equals("<clinit>")){
1:       //there is an existing clinit method, change the fields we use
0:       //to write our init code to static_init_UUID instead
0:       staticInitMethod = new Method("static_init_" + UU_ID, Type.VOID_TYPE, NO_ARGS);
0:       staticInitMethodFlags = staticInitMethodFlags | ACC_FINAL;
0:       methodVisitorToReturn = new AdviceAdapter(cv.visitMethod(access, name, desc, signature,
0:           exceptions), access, name, desc){
0:         @Override
0:         protected void onMethodEnter()
1:         {
1:           //add into the <clinit> a call to our synthetic static_init_UUID
1:           invokeStatic(typeBeingWoven, staticInitMethod);
1:           super.onMethodEnter();
1:         }
1:       };
/////////////////////////////////////////////////////////////////////////
1:     GeneratorAdapter staticAdapter = new GeneratorAdapter(staticInitMethodFlags,
1:         staticInitMethod, null, null, cv);
commit:475ef33
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.proxy.impl.common;
0: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1:  * {@link InvocationListener}. Known subclasses are WovenProxyAdapter, 
1:  * used to weave classes being loaded by the framework, and InterfaceCombiningClassAdapter
0: public abstract class AbstractWovenProxyAdapter extends ClassAdapter implements Opcodes {
/////////////////////////////////////////////////////////////////////////
1:   protected static final String LISTENER_FIELD = "org_apache_aries_proxy_InvocationListener_"
1:   public static final String DISPATCHER_FIELD = "woven_proxy_dispatcher_" + UU_ID;
1:   public static final Type DISPATCHER_TYPE = Type.getType(Callable.class);
1:   public static final Type OBJECT_TYPE = Type.getType(Object.class);
/////////////////////////////////////////////////////////////////////////
1:   protected final List<Class<?>> nonObjectSupers = new ArrayList<Class<?>>();
1:   protected final Map<String, TypeMethod> transformedMethods = new HashMap<String, TypeMethod>();
1:    *  {@link AbstractWovenProxyAdapter#nonObjectSupers} that are already overridden in 
1:   private final Set<Method> knownMethods = new HashSet<Method>();
/////////////////////////////////////////////////////////////////////////
1:   
0:   public static final int JAVA_CLASS_VERSION = new BigDecimal(System.getProperty("java.class.version")).intValue();
1:   public static final boolean IS_AT_LEAST_JAVA_6 = JAVA_CLASS_VERSION >= Opcodes.V1_6;
1:   
/////////////////////////////////////////////////////////////////////////
0:     version = AbstractWovenProxyAdapter.JAVA_CLASS_VERSION;
/////////////////////////////////////////////////////////////////////////
1:     getKnownMethods().add(currentMethod);
/////////////////////////////////////////////////////////////////////////
1:   public void visitEnd() {
/////////////////////////////////////////////////////////////////////////
1:   
1:   public Set<Method> getKnownMethods() {
1:     return knownMethods;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   public static final String getSanitizedUUIDString() {
1:    * This method will read the bytes for the supplied {@link Class} using the
1:    * supplied ASM {@link ClassVisitor}, the reader will skip DEBUG, FRAMES and CODE.
1:    * @param c
1:    * @param adapter
1:    * @throws IOException
1:    */
1:   public static void readClass(Class<?> c, ClassVisitor adapter) throws IOException {
0:     String className;
0:     Class<?> enclosing = c.getEnclosingClass();
0:     List<Class<?>> enclosingChain = new ArrayList<Class<?>>();
0:     while(enclosing != null) {
0:       enclosingChain.add(enclosing);
0:       enclosing = enclosing.getEnclosingClass();
1:     }
0:     StringBuilder sb = new StringBuilder();
0:     for(Class<?> clazz : enclosingChain) {
0:       sb.append(clazz.getSimpleName()).append('$');
1:     }
0:     className = sb.append(c.getSimpleName()).append(".class").toString();
1:     
1:     //Load the class bytes and copy methods across
0:     ClassReader cReader = new ClassReader(c.getResourceAsStream(className));
1: 
1:     cReader.accept(adapter, ClassReader.SKIP_CODE | 
1:         ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
1:   }
1: 
1:   /**
commit:e182908
/////////////////////////////////////////////////////////////////////////
0:     super(new StaticInitMerger("static_init_" + UU_ID, writer));
/////////////////////////////////////////////////////////////////////////
0:     GeneratorAdapter staticAdapter = new GeneratorAdapter(ACC_STATIC,
/////////////////////////////////////////////////////////////////////////
1:    * @param methodSignature
/////////////////////////////////////////////////////////////////////////
commit:88359ce
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.UnableToProxyException;
/////////////////////////////////////////////////////////////////////////
0:         String className;
0:         Class<?> enclosing = c.getEnclosingClass();
0:         List<Class<?>> enclosingChain = new ArrayList<Class<?>>();
0:         while(enclosing != null) {
0:           enclosingChain.add(enclosing);
0:           enclosing = enclosing.getEnclosingClass();
1:         }
0:         StringBuilder sb = new StringBuilder();
0:         for(Class<?> clazz : enclosingChain) {
0:           sb.append(clazz.getSimpleName()).append('$');
1:         }
0:         className = sb.append(c.getSimpleName()).append(".class").toString();
1:         
0:         ClassReader cReader = new ClassReader(c.getResourceAsStream(className));
/////////////////////////////////////////////////////////////////////////
0:           throw new RuntimeException(new UnableToProxyException(typeBeingWoven.getClassName(), "The class " + 
0:               typeBeingWoven.getClassName() + " and its supertype " + superType.getClassName() +
0:               " do not have no-args constructors and cannot be woven."));
commit:dd7db57
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Modifier;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * If we have a no-args constructor then we can delegate there rather than 
1:    * to a super no-args
1:    */
1:   private boolean hasNoArgsConstructor = false;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:           try {
0:             superHasNoArgsConstructor = (superClass.getDeclaredConstructor().
0:                      getModifiers() & Modifier.PRIVATE) == 0;
0:           } catch (NoSuchMethodException nsme) {
0:             // This is a no-op here, but means we need to add a no-Args that
0:             // delegates to Object#<init>() yuck :(
1:           }
1:         } else {
1:           superHasNoArgsConstructor = true;
/////////////////////////////////////////////////////////////////////////
0:     if ((access & (ACC_STATIC | ACC_PRIVATE | ACC_SYNTHETIC | ACC_ABSTRACT
1:         | ACC_NATIVE | ACC_BRIDGE)) == 0 && !!!name.equals("<init>") && 
1:         !!!name.equals("<clinit>")) {
/////////////////////////////////////////////////////////////////////////
1:       if(currentMethod.getArgumentTypes().length == 0 && name.equals("<init>"))
1:         hasNoArgsConstructor = true;
/////////////////////////////////////////////////////////////////////////
1:       else {
1:         if(hasNoArgsConstructor)
1:           methodAdapter.invokeConstructor(typeBeingWoven, NO_ARGS_CONSTRUCTOR);
1:         else
0:           methodAdapter.invokeConstructor(OBJECT_TYPE, NO_ARGS_CONSTRUCTOR);
1:       }
commit:96d4e06
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.aries.proxy.impl.weaving;
1: 
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: import java.util.Set;
1: import java.util.UUID;
1: import java.util.concurrent.Callable;
1: 
1: import org.apache.aries.proxy.InvocationListener;
1: import org.apache.aries.proxy.impl.gen.Constants;
1: import org.apache.aries.proxy.weaving.WovenProxy;
0: import org.objectweb.asm.ClassAdapter;
1: import org.objectweb.asm.ClassReader;
1: import org.objectweb.asm.ClassVisitor;
1: import org.objectweb.asm.FieldVisitor;
1: import org.objectweb.asm.Label;
1: import org.objectweb.asm.MethodVisitor;
1: import org.objectweb.asm.Opcodes;
1: import org.objectweb.asm.Type;
1: import org.objectweb.asm.commons.GeneratorAdapter;
1: import org.objectweb.asm.commons.Method;
0: import org.objectweb.asm.commons.StaticInitMerger;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: 
1: /**
1:  * This abstract superclass is responsible for providing proxy extensions to 
1:  * classes being written. Classes processed by this adapter will implement 
1:  * {@link WovenProxy}, and have a static initialiser that populates 
1:  * {@link java.lang.reflect.Method} fields for use with the 
0:  * {@link InvocationListener}. Known subclasses are {@link WovenProxyAdapter}, 
0:  * used to weave classes being loaded by the framework, and {@link InterfaceCombiningClassAdapter}
1:  * which is used to dynamically create objects that implement multiple interfaces
1:  */
0: abstract class AbstractWovenProxyAdapter extends ClassAdapter implements Opcodes {
1:   private static final Logger LOGGER = LoggerFactory
1:       .getLogger(AbstractWovenProxyAdapter.class);
1: 
1:   /** Access modifier for a public generated method */
1:   private static final int PUBLIC_GENERATED_METHOD_ACCESS = ACC_PUBLIC | ACC_FINAL
1:       | ACC_SYNTHETIC;
1:   /** The internal name for Throwable */
1:   static final String THROWABLE_INAME = Type.getInternalName(Throwable.class);
0:   /** A UUID for adding to our method names */
0:   private static final String UU_ID = getSanitizedUUIDString();
1:   /** A constant for No Args methods */
1:   static final Type[] NO_ARGS = new Type[0];
1: 
1:   /** The annotation types we should add to generated methods and fields */
1:   private static final String[] annotationTypeDescriptors = new String[] { "Ljavax/persistence/Transient;" };
1: 
1:   /** the name of the field used to store the {@link InvocationListener} */
0:   static final String LISTENER_FIELD = "org_apache_aries_proxy_InvocationListener_"
1:       + UU_ID;
1:   /** the name of the field used to store the dispatcher */
0:   static final String DISPATCHER_FIELD = "woven_proxy_dispatcher_" + UU_ID;
1: 
1:   /* Useful ASM types */
1:   /** The ASM type for the {@link InvocationListener} */
1:   static final Type LISTENER_TYPE = Type.getType(InvocationListener.class);
1:   /** The ASM type for the dispatcher */
0:   static final Type DISPATCHER_TYPE = Type.getType(Callable.class);
1:   private static final Type CLASS_TYPE = Type.getType(Class.class);
1:   private static final Type CLASS_ARRAY_TYPE = Type.getType(Class[].class);
1:   private static final Type STRING_TYPE = Type.getType(String.class);
0:   static final Type OBJECT_TYPE = Type.getType(Object.class);
1:   static final Type METHOD_TYPE = Type.getType(java.lang.reflect.Method.class);
1:   /** The {@link Type} of the {@link WovenProxy} interface */
1:   static final Type WOVEN_PROXY_IFACE_TYPE = Type.getType(WovenProxy.class);
1:   private static final Type NPE_TYPE = Type.getType(NullPointerException.class);
1:   
1:   private static final Type[] DISPATCHER_LISTENER_METHOD_ARGS = new Type[] {
1:     DISPATCHER_TYPE, LISTENER_TYPE };
1: 
1:   private static final Method ARGS_CONSTRUCTOR = new Method("<init>", Type.VOID_TYPE,
1:       DISPATCHER_LISTENER_METHOD_ARGS);
1:   private static final Method NO_ARGS_CONSTRUCTOR = new Method("<init>", Type.VOID_TYPE,
1:       NO_ARGS);
1:   private static final Method NPE_CONSTRUCTOR = new Method("<init>", Type.VOID_TYPE,
1:       new Type[] {STRING_TYPE});
1: 
1:   // other new methods we will need
1:   static final Method getInovcationTargetMethod = new Method(
1:       "getInvocationTarget" + UU_ID, OBJECT_TYPE, NO_ARGS);
1:   static final Method listenerPreInvokeMethod = new Method("getListener"
1:       + UU_ID, OBJECT_TYPE, new Type[] { OBJECT_TYPE,
1:       Type.getType(java.lang.reflect.Method.class),
1:       Type.getType(Object[].class) });
1: 
1:   /* Instance fields */
1: 
1:   /** The type of this class */
1:   protected final Type typeBeingWoven;
1:   /** The type of this class's super */
1:   private Type superType;
1:   /** The {@link ClassLoader} loading this class */
1:   private final ClassLoader loader;
1:   /**
1:    * A flag to indicate that we need to weave WovenProxy methods into this class
1:    */
1:   private boolean implementWovenProxy = false;
1:   /** 
1:    * A list of un-woven superclasses between this object and {@link Object}, 
1:    * only populated for classes which will directly implement {@link WovenProxy}.
1:    * This list is then used to override any methods that would otherwise be missed
1:    * by the weaving process. 
1:    */
0:   private final List<Class<?>> nonObjectSupers = new ArrayList<Class<?>>();
1:   
1:   /**
1:    * Methods we have transformed and need to create static fields for.
1:    * Stored as field name to {@link TypeMethod} so we know which Class to reflect
1:    * them off
1:    */
0:   private final Map<String, TypeMethod> transformedMethods = new HashMap<String, TypeMethod>();
1:   
1:   /**
1:    *  A set of {@link Method} objects identifying the methods that are in this 
1:    *  class. This is used to prevent us duplicating methods copied from 
0:    *  {@link WovenProxyAdapter#nonObjectSupers} that are already overridden in 
1:    *  this class.
1:    */
0:   final Set<Method> knownMethods = new HashSet<Method>();
1:   /** 
1:    * If our super does not have a no-args constructor then we need to be clever
1:    * when writing our own constructor.
1:    */
1:   private boolean superHasNoArgsConstructor = false;
1: 
1:   /**
1:    * Create a new adapter for the supplied class
1:    * 
1:    * @param writer
1:    *          The ClassWriter to delegate to
1:    * @param className
1:    *          The name of this class
1:    * @param loader
1:    *          The ClassLoader loading this class
1:    */
0:   public AbstractWovenProxyAdapter(ClassVisitor writer, String className,
0:       ClassLoader loader) {
0:     // We wrap the writer in a StaticInitMerger so we don't have to worry about
0:     // our generated static init clashing with an existing one!
0:     super(new StaticInitMerger("static_init_" + UU_ID, writer));
0:     typeBeingWoven = Type.getType("L" + className.replace('.', '/') + ";");
1:     this.loader = loader;
1:   }
1: 
1:   public final void visit(int version, int access, String name, String signature,
1:       String superName, String[] interfaces) {
1:     LOGGER.debug(Constants.LOG_ENTRY, "visit", new Object[] { version, access,
1:         name, signature, superName, interfaces });
1: 
0:     // We update to at least Java 1.5 because we add annotations and synthetic
0:     // modifiers. Java 1.4 would not like this at all!
0:     if (version < V1_5)
0:       version = V1_5;
1: 
1:     superType = Type.getType("L" + superName + ";");
1: 
0:     try {
1:       // we only want to implement WovenProxy once in the hierarchy.
1:       // It's best to do this as high up as possible so we check the
1:       // super. By loading it we may end up weaving it, but that's a good thing!
1:       Class<?> superClass = Class.forName(superName.replace('/', '.'), false,
1:           loader);
1: 
1:       if (!!!WovenProxy.class.isAssignableFrom(superClass)) {
1: 
1:         // We have found a type we need to add WovenProxy information to
1: 
1:         implementWovenProxy = true;
1:         
0:         try {
0:           superClass.getDeclaredConstructor();
0:           superHasNoArgsConstructor = true;
0:         } catch (NoSuchMethodException nsme) {
0:           // This is a no-op here, but means we need to add a no-Args that
0:           // delegates to Object#<init>() yuck :(
1:         }
1:         
1:         if(superClass != Object.class) {
1:           //If our superclass isn't Object, it means we didn't weave all the way
1:           //to the top of the hierarchy. This means we need to override all the
1:           //methods defined on our parent so that they can be intercepted!
1:           nonObjectSupers.add(superClass);
1:           Class<?> nextSuper = superClass.getSuperclass();
1:           while(nextSuper != Object.class) {
1:             nonObjectSupers.add(nextSuper);
1:             nextSuper = nextSuper.getSuperclass();
1:           }
1:         }
1: 
1:         // re-work the interfaces list to include WovenProxy
1:         String[] interfacesPlusWovenProxy = new String[interfaces.length + 1];
1:         System.arraycopy(interfaces, 0, interfacesPlusWovenProxy, 0, interfaces.length);
1:         interfacesPlusWovenProxy[interfaces.length] = WOVEN_PROXY_IFACE_TYPE.getInternalName();
1: 
1:         // Write the class header including WovenProxy.
1:         cv.visit(version, access, name, signature, superName, interfacesPlusWovenProxy);
1: 
1:       } else {
1:         // Already has a woven proxy parent, but we still need to write the
1:         // header!
1:         cv.visit(version, access, name, signature, superName, interfaces);
1:       }
1:     } catch (ClassNotFoundException e) {
0:       // If this happens we're about to hit bigger trouble on verify, so we can
0:       // just throw it
0:       throw new RuntimeException("Unable to load the super type "
0:           + superName.replace('/', '.') + " for class "
0:           + typeBeingWoven.getClassName(), e);
1:     }
1:   }
1: 
1:   /**
1:    * This method is called on each method implemented on this object (but not
1:    * for superclass methods) Each of these methods is visited in turn and the
1:    * code here generates the byte code for the calls to the InovcationListener
1:    * around the existing method
1:    */
1:   public final MethodVisitor visitMethod(int access, String name, String desc,
1:       String signature, String[] exceptions) {
1:     LOGGER.debug(Constants.LOG_ENTRY, "visitMethod", new Object[] { access,
1:         name, desc, signature, exceptions });
1: 
1:     
1:     Method currentMethod = new Method(name, desc);
1:     
0:     knownMethods.add(currentMethod);
1:     
1:     MethodVisitor methodVisitorToReturn = null;
1: 
1:     // Only weave "real" instance methods. Not constructors, initializers or
1:     // compiler generated ones.
0:     if (!!!name.equals("<init>") && !!!name.equals("<clinit>")
0:         && (access & (ACC_STATIC | ACC_PRIVATE | ACC_SYNTHETIC | ACC_ABSTRACT
0:             | ACC_NATIVE | ACC_BRIDGE)) == 0) {
1: 
1:       // found a method we should weave
1: 
1:       //Create a field name and store it for later
1:       String methodStaticFieldName = "methodField" + getSanitizedUUIDString();
1:       transformedMethods.put(methodStaticFieldName, new TypeMethod(
0:            getDeclaringTypeForCurrentMethod(), currentMethod));
1: 
1:       // Surround the MethodVisitor with our weaver so we can manipulate the code
1:       methodVisitorToReturn = getWeavingMethodVisitor(access, name, desc,
0:           signature, exceptions, currentMethod, methodStaticFieldName);
1:     } else {
1:       //This isn't a method we want to weave, so just get the default visitor
1:       methodVisitorToReturn = cv.visitMethod(access, name, desc, signature,
1:           exceptions);
1:     }
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "visitMethod", methodVisitorToReturn);
1:     return methodVisitorToReturn;
1:   }
1: 
1:   /**
1:    * Our class may claim to implement WovenProxy, but doesn't have any
1:    * implementations! We should fix this.
1:    */
0:   public final void visitEnd() {
1:     LOGGER.debug(Constants.LOG_ENTRY, "visitEnd");
1: 
0:     //first we need to override all the methods that were on non-object parents
0:     for(Class<?> c : nonObjectSupers) {
0:       try {
0:         //Load the class bytes and copy methods across
0:         ClassReader cReader = new ClassReader(c.getResourceAsStream(
0:             c.getSimpleName() + ".class"));
0:         //We don't need the method bodies, so skip them for speed
0:         cReader.accept(new MethodCopyingClassAdapter(cv, c, typeBeingWoven,
0:             knownMethods, transformedMethods), ClassReader.SKIP_CODE | 
0:             ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
0:       } catch (IOException e) {
0:         //This should never happen!
0:         throw new RuntimeException("Error processing " + c.getName() + " when weaving "
0:             + typeBeingWoven.getClassName(), e);
1:       }
1:     }
1:     // If we need to implement woven proxy in this class then write the methods
1:     if (implementWovenProxy) {
1:       writeFinalWovenProxyMethods();
1:     }
1:     
1:     // this method is called when we reach the end of the class
1:     // so it is time to make sure the static initialiser method is written
1:     writeStaticInitMethod();
1: 
1:     // Make sure we add the instance specific WovenProxy method to our class,
1:     // and give ourselves a constructor to use
1:     writeCreateNewProxyInstanceAndConstructor();
1: 
1:     // now delegate to the cv
1:     cv.visitEnd();
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "visitEnd");
1:   }
1:   /**
1:    * Get the {@link MethodVisitor} that will weave a given method
1:    * @param access
1:    * @param name
1:    * @param desc
1:    * @param signature
1:    * @param exceptions
1:    * @param currentMethod
1:    * @param methodStaticFieldName
1:    * @return
1:    */
1:   protected abstract MethodVisitor getWeavingMethodVisitor(int access, String name,
1:   String desc, String signature, String[] exceptions, Method currentMethod,
0:   String methodStaticFieldName);
1:   
1:   /**
0:    * Get the Type which declares the method being currently processed. For class
0:    * weaving this will be the {@link #typeBeingWoven}, for dynamic interface
0:    * implementation this will be the interface type.
1:    * @return
1:    */
0:   protected abstract Type getDeclaringTypeForCurrentMethod();
1: 
1:   /**
1:    * Write the methods we need for wovenProxies on the highest supertype
1:    */
1:   private final void writeFinalWovenProxyMethods() {
1:     // add private fields for the Callable<Object> dispatcher
1:     // and InvocationListener. These aren't static because we can have
1:     // multiple instances of the same proxy class. These should not be
1:     // serialized, or used in JPA or any other thing we can think of,
1:     // so we annotate them as necessary
1: 
1:     generateField(DISPATCHER_FIELD, Type.getDescriptor(Callable.class));
1:     generateField(LISTENER_FIELD, Type.getDescriptor(InvocationListener.class));
1: 
1:     // a general methodAdapter field that we will use to with GeneratorAdapters
1:     // to create the methods required to implement WovenProxy
1:     GeneratorAdapter methodAdapter;
1: 
1:     // add a method for unwrapping the dispatcher
1:     methodAdapter = getMethodGenerator(PUBLIC_GENERATED_METHOD_ACCESS, new Method(
1:         "org_apache_aries_proxy_weaving_WovenProxy_unwrap", DISPATCHER_TYPE,
1:         NO_ARGS));
1: 
1:     // /////////////////////////////////////////////////////
1:     // Implement the method
1: 
1:     // load this to get the field
1:     methodAdapter.loadThis();
1:     // get the dispatcher field and return
1:     methodAdapter.getField(typeBeingWoven, DISPATCHER_FIELD, DISPATCHER_TYPE);
1:     methodAdapter.returnValue();
1:     methodAdapter.endMethod();
1: 
1:     // /////////////////////////////////////////////////////
1: 
1:     // add a method for checking if the dispatcher is set
1:     methodAdapter = getMethodGenerator(PUBLIC_GENERATED_METHOD_ACCESS, new Method(
1:         "org_apache_aries_proxy_weaving_WovenProxy_isProxyInstance",
1:         Type.BOOLEAN_TYPE, NO_ARGS));
1: 
1:     // /////////////////////////////////////////////////////
1:     // Implement the method
1: 
1:     // load this to get the field
1:     methodAdapter.loadThis();
1:     // make a label for return true
1:     Label returnTrueLabel = methodAdapter.newLabel();
1:     // get the dispatcher field for the stack
1:     methodAdapter.getField(typeBeingWoven, DISPATCHER_FIELD, DISPATCHER_TYPE);
1:     // check if the dispatcher was non-null and goto return true if it was
1:     methodAdapter.ifNonNull(returnTrueLabel);
1:     methodAdapter.loadThis();
1:     // get the listener field for the stack
1:     methodAdapter.getField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);
1:     // check if the listener field was non-null and goto return true if it was
1:     methodAdapter.ifNonNull(returnTrueLabel);
1:     // return false if we haven't jumped anywhere
1:     methodAdapter.push(false);
1:     methodAdapter.returnValue();
1:     // mark the returnTrueLable
1:     methodAdapter.mark(returnTrueLabel);
1:     methodAdapter.push(true);
1:     methodAdapter.returnValue();
1:     // end the method
1:     methodAdapter.endMethod();
1: 
1:     // ///////////////////////////////////////////////////////
1:   }
1: 
1:   /**
1:    * We write createNewProxyInstance separately because it isn't final, and is
1:    * overridden on each class, we also write a constructor for this method to
1:    * use if we don't have one.
1:    */
1:   private final void writeCreateNewProxyInstanceAndConstructor() {
1:     GeneratorAdapter methodAdapter = getMethodGenerator(ACC_PUBLIC, new Method(
1:         "org_apache_aries_proxy_weaving_WovenProxy_createNewProxyInstance",
1:         WOVEN_PROXY_IFACE_TYPE, DISPATCHER_LISTENER_METHOD_ARGS));
1: 
1:     // /////////////////////////////////////////////////////
1:     // Implement the method
1: 
1:     // Create and instantiate a new instance, then return it
1:     methodAdapter.newInstance(typeBeingWoven);
1:     methodAdapter.dup();
1:     methodAdapter.loadArgs();
1:     methodAdapter.invokeConstructor(typeBeingWoven, new Method("<init>",
1:         Type.VOID_TYPE, DISPATCHER_LISTENER_METHOD_ARGS));
1:     methodAdapter.returnValue();
1:     methodAdapter.endMethod();
1:     //////////////////////////////////////////////////////////
1: 
1:     
1:     // Write a protected no-args constructor for this class
0:     methodAdapter = getMethodGenerator(ACC_PROTECTED, ARGS_CONSTRUCTOR);
1: 
1:     // /////////////////////////////////////////////////////
1:     // Implement the constructor
1: 
1:     // For the top level supertype we need to invoke a no-args super, on object 
1:     //if we have to
1:     
1:     if(implementWovenProxy) {
1:       methodAdapter.loadThis();
1: 
1:       if (superHasNoArgsConstructor)
1:         methodAdapter.invokeConstructor(superType, NO_ARGS_CONSTRUCTOR);
0:       else
0:         methodAdapter.invokeConstructor(OBJECT_TYPE, NO_ARGS_CONSTRUCTOR);
1:       
1:       methodAdapter.loadThis();
1:       methodAdapter.loadArg(0);
1:       methodAdapter.putField(typeBeingWoven, DISPATCHER_FIELD, DISPATCHER_TYPE);
1:       
1:       methodAdapter.loadThis();
1:       methodAdapter.loadArg(1);
1:       methodAdapter.putField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);
1:     } else {
1:       //We just invoke the super with args
1:       methodAdapter.loadThis();
1:       methodAdapter.loadArgs();
1:       methodAdapter.invokeConstructor(superType, ARGS_CONSTRUCTOR);
1:     }
1:     
1:     //Throw an NPE if the dispatcher is null, return otherwise
1:     methodAdapter.loadArg(0);
1:     Label returnValue = methodAdapter.newLabel();
1:     methodAdapter.ifNonNull(returnValue);
1:     methodAdapter.newInstance(NPE_TYPE);
1:     methodAdapter.dup();
1:     methodAdapter.push("The dispatcher must never be null!");
1:     methodAdapter.invokeConstructor(NPE_TYPE, NPE_CONSTRUCTOR);
1:     methodAdapter.throwException();
1:     
1:     methodAdapter.mark(returnValue);
1:     methodAdapter.returnValue();
1:     methodAdapter.endMethod();
1:     //////////////////////////////////////////////////////////
1:   }
1: 
1:   /**
1:    * Create fields and an initialiser for {@link java.lang.reflect.Method}
1:    * objects in our class
1:    */
1:   private final void writeStaticInitMethod() {
1:     // we create a static field for each method we encounter with a *unique*
1:     // random name
1:     // since each method needs to be stored individually
1: 
1:     for (String methodStaticFieldName : transformedMethods.keySet()) {
1:       // add a private static field for the method
1:       cv.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL | ACC_SYNTHETIC,
1:           methodStaticFieldName, METHOD_TYPE.getDescriptor(), null, null)
1:           .visitEnd();
1:     }
0:     GeneratorAdapter staticAdapter = new GeneratorAdapter(ACC_STATIC,
0:         new Method("<clinit>", Type.VOID_TYPE, NO_ARGS), null, null, cv);
1: 
1:     for (Entry<String, TypeMethod> entry : transformedMethods.entrySet()) {
1:       // Add some more code to the static initializer
1: 
1:       TypeMethod m = entry.getValue();
1:       Type[] targetMethodParameters = m.method.getArgumentTypes();
1: 
1:       String methodStaticFieldName = entry.getKey();
1: 
1:       Label beginPopulate = staticAdapter.newLabel();
1:       Label endPopulate = staticAdapter.newLabel();
1:       Label catchHandler = staticAdapter.newLabel();
1:       staticAdapter.visitTryCatchBlock(beginPopulate, endPopulate,
1:           catchHandler, THROWABLE_INAME);
1: 
1:       staticAdapter.mark(beginPopulate);
1:       staticAdapter.push(m.declaringClass);
1: 
1:       // push the method name string arg onto the stack
1:       staticAdapter.push(m.method.getName());
1: 
1:       // create an array of the method parm class[] arg
1:       staticAdapter.push(targetMethodParameters.length);
1:       staticAdapter.newArray(CLASS_TYPE);
1:       int index = 0;
1:       for (Type t : targetMethodParameters) {
1:         staticAdapter.dup();
1:         staticAdapter.push(index);
1:         staticAdapter.push(t);
1:         staticAdapter.arrayStore(CLASS_TYPE);
1:         index++;
1:       }
1: 
1:       // invoke the getMethod
1:       staticAdapter.invokeVirtual(CLASS_TYPE,
1:           new Method("getDeclaredMethod", METHOD_TYPE, new Type[] {
1:               STRING_TYPE, CLASS_ARRAY_TYPE}));
1: 
1:       // store the reflected method in the static field
1:       staticAdapter.putStatic(typeBeingWoven, methodStaticFieldName,
1:           METHOD_TYPE);
1: 
1:       Label afterCatch = staticAdapter.newLabel();
1:       staticAdapter.mark(endPopulate);
1:       staticAdapter.goTo(afterCatch);
1: 
1:       staticAdapter.mark(catchHandler);
1:       // We don't care about the exception, so pop it off
1:       staticAdapter.pop();
1:       // store the reflected method in the static field
1:       staticAdapter.visitInsn(ACONST_NULL);
1:       staticAdapter.putStatic(typeBeingWoven, methodStaticFieldName,
1:           METHOD_TYPE);
1:       staticAdapter.mark(afterCatch);
1: 
1:     }
1:     staticAdapter.returnValue();
1:     staticAdapter.endMethod();
1:   }
1: 
1:   /**
1:    * Get a new UUID suitable for use in method and field names
1:    * 
1:    * @return
1:    */
0:   static final String getSanitizedUUIDString() {
1:     return UUID.randomUUID().toString().replace('-', '_');
1:   }
1: 
1:   /**
1:    * Generate an instance field that should be "invisible" to normal code
1:    * 
1:    * @param fieldName
1:    * @param fieldDescriptor
1:    */
1:   private final void generateField(String fieldName, String fieldDescriptor) {
1:     FieldVisitor fv = cv.visitField(ACC_PROTECTED | ACC_TRANSIENT | ACC_SYNTHETIC
1:         | ACC_FINAL, fieldName, fieldDescriptor, null, null);
1:     for (String s : annotationTypeDescriptors)
1:       fv.visitAnnotation(s, true).visitEnd();
1:     fv.visitEnd();
1:   }
1: 
1:   /**
1:    * Get a generator for a method, this be annotated with the "invisibility"
1:    * annotations (and ensured synthetic)
1:    * 
0:    * @param methodSignature
1:    * @return
1:    */
1:   private final GeneratorAdapter getMethodGenerator(int access, Method method) {
1:     access = access | ACC_SYNTHETIC;
1:     GeneratorAdapter ga = new GeneratorAdapter(access, method, null, null, cv);
1:     for (String s : annotationTypeDescriptors)
1:       ga.visitAnnotation(s, true).visitEnd();
1:     ga.visitCode();
1:     return ga;
1:   }
1: }
author:Emily Jiang
-------------------------------------------------------------------------------
commit:8fc6c7b
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.aries.proxy.impl.ProxyUtils.JAVA_CLASS_VERSION;
0: 
/////////////////////////////////////////////////////////////////////////
0:  
/////////////////////////////////////////////////////////////////////////
1:     version = JAVA_CLASS_VERSION;
commit:322f373
/////////////////////////////////////////////////////////////////////////
0:     super(Opcodes.ASM4, writer);
/////////////////////////////////////////////////////////////////////////
0:       methodVisitorToReturn = new AdviceAdapter(Opcodes.ASM4, cv.visitMethod(access, name, desc, signature,
commit:e6518d7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public abstract class AbstractWovenProxyAdapter extends ClassVisitor implements Opcodes {
/////////////////////////////////////////////////////////////////////////
0:     super(Constants.ASM4, writer);
/////////////////////////////////////////////////////////////////////////
0:       methodVisitorToReturn = new AdviceAdapter(Constants.ASM4, cv.visitMethod(access, name, desc, signature,
author:David Jencks
-------------------------------------------------------------------------------
commit:c8d426c
/////////////////////////////////////////////////////////////////////////
0:   private static final int PUBLIC_GENERATED_METHOD_ACCESS = ACC_PUBLIC | ACC_FINAL
0:       | ACC_SYNTHETIC;
commit:2960c84
/////////////////////////////////////////////////////////////////////////
0:     super(new MyStaticInitMerger("static_init_" + UU_ID, writer));
/////////////////////////////////////////////////////////////////////////
0:     GeneratorAdapter staticAdapter = new GeneratorAdapter(ACC_STATIC | ACC_SYNTHETIC,
/////////////////////////////////////////////////////////////////////////
0:    * @param method
/////////////////////////////////////////////////////////////////////////
0: 
0:   /**
0:    * This is a copy of the asm StaticInitMerger class modified
0:    * to mark the generated static init method synthetic
0:    */
0:   /***
0:    * ASM: a very small and fast Java bytecode manipulation framework
0:    * Copyright (c) 2000-2007 INRIA, France Telecom
0:    * All rights reserved.
0:    *
0:    * Redistribution and use in source and binary forms, with or without
0:    * modification, are permitted provided that the following conditions
0:    * are met:
0:    * 1. Redistributions of source code must retain the above copyright
0:    *    notice, this list of conditions and the following disclaimer.
0:    * 2. Redistributions in binary form must reproduce the above copyright
0:    *    notice, this list of conditions and the following disclaimer in the
0:    *    documentation and/or other materials provided with the distribution.
0:    * 3. Neither the name of the copyright holders nor the names of its
0:    *    contributors may be used to endorse or promote products derived from
0:    *    this software without specific prior written permission.
0:    *
0:    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
0:    * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
0:    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
0:    * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
0:    * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
0:    * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
0:    * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
0:    * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
0:    * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
0:    * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
0:    * THE POSSIBILITY OF SUCH DAMAGE.
0:    */
0:   public static class MyStaticInitMerger extends ClassAdapter {
0: 
0:     private String name;
0: 
0:     private MethodVisitor clinit;
0: 
0:     private final String prefix;
0: 
0:     private int counter;
0: 
0:     public MyStaticInitMerger(final String prefix, final ClassVisitor cv) {
0:       super(cv);
0:       this.prefix = prefix;
0:     }
0: 
0:     public void visit(
0:         final int version,
0:         final int access,
0:         final String name,
0:         final String signature,
0:         final String superName,
0:         final String[] interfaces) {
0:       cv.visit(version, access, name, signature, superName, interfaces);
0:       this.name = name;
0:     }
0: 
0:     public MethodVisitor visitMethod(
0:         final int access,
0:         final String name,
0:         final String desc,
0:         final String signature,
0:         final String[] exceptions) {
0:       MethodVisitor mv;
0:       if ("<clinit>".equals(name)) {
0:         int a = Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC + Opcodes.ACC_SYNTHETIC;
0:         String n = prefix + counter++;
0:         mv = cv.visitMethod(a, n, desc, signature, exceptions);
0: 
0:         if (clinit == null) {
0:           clinit = cv.visitMethod(a, name, desc, null, null);
0:         }
0:         clinit.visitMethodInsn(Opcodes.INVOKESTATIC, this.name, n, desc);
0:       } else {
0:         mv = cv.visitMethod(access, name, desc, signature, exceptions);
0:       }
0:       return mv;
0:     }
0: 
0:     public void visitEnd() {
0:       if (clinit != null) {
0:         clinit.visitInsn(Opcodes.RETURN);
0:         clinit.visitMaxs(0, 0);
0:       }
0:       cv.visitEnd();
0:     }
0:   }
0: 
commit:d0913c7
/////////////////////////////////////////////////////////////////////////
0:   private static final int PUBLIC_GENERATED_METHOD_ACCESS = ACC_PUBLIC | ACC_SYNTHETIC;
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:ef57cb3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.impl.NLS;
/////////////////////////////////////////////////////////////////////////
0:       throw new RuntimeException(NLS.MESSAGES.getMessage("cannot.load.superclass", superName.replace('/', '.'), typeBeingWoven.getClassName()), e);
/////////////////////////////////////////////////////////////////////////
0:         // This should never happen! <= famous last words (not)
0:         throw new RuntimeException(NLS.MESSAGES.getMessage("unexpected.error.processing.class", c.getName(), typeBeingWoven.getClassName()), e);
/////////////////////////////////////////////////////////////////////////
1:           throw new RuntimeException(new UnableToProxyException(typeBeingWoven.getClassName(), 
1:               NLS.MESSAGES.getMessage("type.lacking.no.arg.constructor", typeBeingWoven.getClassName(), superType.getClassName())));
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:bef949f
/////////////////////////////////////////////////////////////////////////
1:     // always update to the most recent version of the JVM
0:     version = WovenProxyGenerator.JAVA_CLASS_VERSION;
/////////////////////////////////////////////////////////////////////////
1:     methodAdapter = getMethodGenerator(ACC_PROTECTED | ACC_SYNTHETIC, ARGS_CONSTRUCTOR);
============================================================================