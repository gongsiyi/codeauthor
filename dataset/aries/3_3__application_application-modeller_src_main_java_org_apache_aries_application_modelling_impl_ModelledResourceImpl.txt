1:4fec049: /*
1:4fec049:  * Licensed to the Apache Software Foundation (ASF) under one
1:4fec049:  * or more contributor license agreements.  See the NOTICE file
1:4fec049:  * distributed with this work for additional information
1:4fec049:  * regarding copyright ownership.  The ASF licenses this file
1:4fec049:  * to you under the Apache License, Version 2.0 (the
1:4fec049:  * "License"); you may not use this file except in compliance
1:4fec049:  * with the License.  You may obtain a copy of the License at
1:4fec049:  *
1:4fec049:  *   http://www.apache.org/licenses/LICENSE-2.0
1:4fec049:  *
1:4fec049:  * Unless required by applicable law or agreed to in writing,
1:4fec049:  * software distributed under the License is distributed on an
1:4fec049:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:4fec049:  * KIND, either express or implied.  See the License for the
1:4fec049:  * specific language governing permissions and limitations
1:4fec049:  * under the License.
1:4fec049:  */
1:4fec049: package org.apache.aries.application.modelling.impl;
18:4fec049: 
1:4fec049: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1:4fec049: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1:4fec049: import static org.osgi.framework.Constants.BUNDLE_VERSION_ATTRIBUTE;
1:4fec049: import static org.osgi.framework.Constants.DYNAMICIMPORT_PACKAGE;
1:4fec049: import static org.osgi.framework.Constants.EXPORT_PACKAGE;
1:4fec049: import static org.osgi.framework.Constants.EXPORT_SERVICE;
1:4fec049: import static org.osgi.framework.Constants.IMPORT_PACKAGE;
1:4fec049: import static org.osgi.framework.Constants.IMPORT_SERVICE;
1:4fec049: import static org.osgi.framework.Constants.REQUIRE_BUNDLE;
1:4fec049: import static org.osgi.framework.Constants.RESOLUTION_DIRECTIVE;
1:4fec049: import static org.osgi.framework.Constants.RESOLUTION_OPTIONAL;
1:4fec049: import static org.osgi.framework.Constants.VERSION_ATTRIBUTE;
1:4fec049: 
1:4fec049: import java.util.ArrayList;
1:4fec049: import java.util.Collection;
1:4fec049: import java.util.Collections;
1:4fec049: import java.util.HashMap;
1:4fec049: import java.util.List;
1:4fec049: import java.util.Map;
1:4fec049: import java.util.jar.Attributes;
1:4fec049: 
1:89f804e: import org.apache.aries.application.InvalidAttributeException;
1:4fec049: import org.apache.aries.application.management.BundleInfo;
1:4fec049: import org.apache.aries.application.modelling.ExportedBundle;
1:4fec049: import org.apache.aries.application.modelling.ExportedPackage;
1:4fec049: import org.apache.aries.application.modelling.ExportedService;
1:4fec049: import org.apache.aries.application.modelling.ImportedBundle;
1:4fec049: import org.apache.aries.application.modelling.ImportedPackage;
1:4fec049: import org.apache.aries.application.modelling.ImportedService;
1:4fec049: import org.apache.aries.application.modelling.ModelledResource;
1:58f55bd: import org.apache.aries.application.modelling.ModellingConstants;
1:4fec049: import org.apache.aries.application.modelling.ResourceType;
1:910fec0: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
1:910fec0: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
1:4fec049: import org.slf4j.Logger;
1:4fec049: import org.slf4j.LoggerFactory;
1:4fec049: 
1:4fec049: 
1:4fec049: /**
1:4fec049:  * A model of a bundle or composite. Used for example to supply information to 
1:4fec049:  * RepositoryGenerator.generateRepository()
1:4fec049:  *
1:4fec049:  */
1:4fec049: public class ModelledResourceImpl implements ModelledResource
1:4fec049: {
1:4fec049:   private final Logger logger = LoggerFactory.getLogger(ModelledResourceImpl.class);
1:4fec049:   private final String _fileURI;
1:4fec049:   private final Collection<ImportedService> _importedServices;
1:4fec049:   private final Collection<ExportedService> _exportedServices;
1:4fec049:   private final Collection<ExportedPackage> _exportedPackages;
1:4fec049:   private final Collection<ImportedPackage> _importedPackages;
1:4fec049:   private final Collection<ImportedBundle> _requiredBundles;
1:297d1fb:   private final ExportedBundle _exportedBundle; 
1:297d1fb:   private final ResourceType _resourceType;     
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Construct a new {@link ModelledResourceImpl} for the following manifest and services
1:4fec049:    * @param fileURI The location of the bundle, may be null, which indicates a by value bundle
1:4fec049:    * @param bundleInfo The bundle info object
1:4fec049:    * @param importedServices The blueprint references defined by the bundle. May be null
1:4fec049:    * @param exportedServices The blueprint services exported by the bundle. May be null
1:4fec049:    * @throws InvalidAttributeException
1:4fec049:    */
1:4fec049:   public ModelledResourceImpl (String fileURI, BundleInfo bundleInfo, 
1:4fec049:       Collection<ImportedService> importedServices, 
1:4fec049:       Collection<ExportedService> exportedServices) throws InvalidAttributeException
1:4fec049:   {
1:4fec049:     this(fileURI, bundleInfo.getRawAttributes(), importedServices, exportedServices);
1:4fec049:   }
1:4fec049:   /**
1:4fec049:    * Construct a new {@link ModelledResourceImpl} for the following manifest and services
1:4fec049:    * @param fileURI The location of the bundle, may be null, which indicates a by value bundle
1:4fec049:    * @param bundleAttributes The bundle manifest, must not be null
1:4fec049:    * @param importedServices The blueprint references defined by the bundle. May be null
1:4fec049:    * @param exportedServices The blueprint services exported by the bundle. May be null
1:4fec049:    * @throws InvalidAttributeException
1:4fec049:    */
1:4fec049:   @SuppressWarnings("deprecation")
1:297d1fb:   public ModelledResourceImpl (String fileURI, Attributes bundleAttributes, ExportedBundle exportedBundle, ResourceType resourceType,
1:297d1fb:       Collection<ImportedService> importedServices, 
1:297d1fb:       Collection<ExportedService> exportedServices) throws InvalidAttributeException
1:297d1fb:   { 
1:297d1fb:     this (fileURI, bundleAttributes, resourceType, exportedBundle, importedServices, exportedServices);
1:297d1fb:     logger.debug(LOG_ENTRY, "ModelledResourceImpl", new Object[]{fileURI, bundleAttributes, importedServices, exportedServices});
1:297d1fb:     logger.debug(LOG_EXIT, "ModelledResourceImpl");
1:297d1fb:   }
1:297d1fb: 
1:297d1fb:   /**
1:297d1fb:    * Construct a new {@link ModelledResourceImpl} for the following manifest and services
1:297d1fb:    * @param fileURI The location of the bundle, may be null, which indicates a by value bundle
1:297d1fb:    * @param bundleAttributes The bundle manifest, must not be null
1:297d1fb:    * @param importedServices The blueprint references defined by the bundle. May be null
1:297d1fb:    * @param exportedServices The blueprint services exported by the bundle. May be null
1:297d1fb:    * @throws InvalidAttributeException
1:297d1fb:    */
1:297d1fb:   @SuppressWarnings("deprecation")
1:4fec049:   public ModelledResourceImpl (String fileURI, Attributes bundleAttributes, 
1:4fec049:       Collection<ImportedService> importedServices, 
1:4fec049:       Collection<ExportedService> exportedServices) throws InvalidAttributeException
1:4fec049:   { 
1:297d1fb:     this (fileURI, bundleAttributes, ResourceType.BUNDLE, null, importedServices, exportedServices );
1:4fec049:     logger.debug(LOG_ENTRY, "ModelledResourceImpl", new Object[]{fileURI, bundleAttributes, importedServices, exportedServices});
1:297d1fb:     logger.debug(LOG_EXIT, "ModelledResourceImpl");
1:297d1fb:   }
1:297d1fb:   
1:297d1fb:   public ModelledResourceImpl (String fileURI, Attributes bundleAttributes, 
1:297d1fb:       ResourceType resourceType, ExportedBundle exportedBundle,
1:297d1fb:       Collection<ImportedService> importedServices, 
1:297d1fb:       Collection<ExportedService> exportedServices 
1:297d1fb:       ) throws InvalidAttributeException 
1:297d1fb:   {
1:297d1fb:     logger.debug(LOG_ENTRY, "ModelledResourceImpl", new Object[]{fileURI, bundleAttributes, importedServices, exportedServices, 
1:297d1fb:         resourceType});
1:297d1fb: 
1:297d1fb:     if (exportedBundle == null) { 
1:297d1fb:       _exportedBundle = new ExportedBundleImpl (bundleAttributes);
1:297d1fb:     } else { 
1:297d1fb:       _exportedBundle = exportedBundle;
1:297d1fb:     }
1:297d1fb:     _resourceType = resourceType;
1:4fec049:     _fileURI = fileURI;
1:4fec049:     if(importedServices != null)
1:4fec049:       _importedServices = new ArrayList<ImportedService> (importedServices);
1:4fec049:     else
1:4fec049:       _importedServices = new ArrayList<ImportedService>();
1:297d1fb:     
1:4fec049:     if(exportedServices != null)
1:4fec049:       _exportedServices = new ArrayList<ExportedService> (exportedServices);
1:4fec049:     else
1:4fec049:       _exportedServices = new ArrayList<ExportedService>();
1:297d1fb:     
1:4fec049:     _exportedPackages = new ArrayList<ExportedPackage>();
1:4fec049:     String packageExports = bundleAttributes.getValue(EXPORT_PACKAGE);
1:4fec049:     if (packageExports != null) {
1:de5b346:       List<NameValuePair> exportedPackages = ManifestHeaderProcessor
1:4fec049:         .parseExportString(packageExports);
1:de5b346:       for (NameValuePair exportedPackage : exportedPackages) {
1:4fec049:         _exportedPackages.add(new ExportedPackageImpl(this, exportedPackage.getName(), 
1:de5b346:             new HashMap<String, Object>(exportedPackage.getAttributes())));
1:4fec049:     
1:4fec049:       }
1:4fec049:     }
1:4fec049:   
1:4fec049:     _importedPackages = new ArrayList<ImportedPackage>();
1:4fec049:     String packageImports = bundleAttributes.getValue(IMPORT_PACKAGE);
1:4fec049:     if (packageImports != null) {
1:de5b346:       Map<String, Map<String, String>> importedPackages = ManifestHeaderProcessor
1:4fec049:           .parseImportString(packageImports);
1:de5b346:       for (Map.Entry<String, Map<String, String>> importedPackage : importedPackages.entrySet()) {
1:4fec049:         Map<String, String> atts = importedPackage.getValue();
1:4fec049:         _importedPackages.add(new ImportedPackageImpl(importedPackage.getKey(), atts));
1:4fec049:       }
1:4fec049:     }
1:4fec049:     
1:4fec049:     // Use of Import-Service and Export-Service is deprecated in OSGi. We like Blueprint. 
1:4fec049:     // Blueprint is good. 
1:4fec049:     
1:4fec049:     String serviceExports = null; 
1:4fec049:     if (_resourceType == ResourceType.BUNDLE) { 
1:4fec049:       serviceExports = bundleAttributes.getValue(EXPORT_SERVICE);
1:4fec049:     } 
1:4fec049:     if (serviceExports != null) {
1:de5b346:       List<NameValuePair> expServices = ManifestHeaderProcessor
1:4fec049:           .parseExportString(serviceExports);
1:de5b346:       for (NameValuePair exportedService : expServices) {
1:de5b346:         _exportedServices.add(new ExportedServiceImpl(exportedService.getName(), exportedService.getAttributes()));
1:4fec049:       }
1:4fec049:     }
1:4fec049:   
1:4fec049:     String serviceImports =null;
1:4fec049:     if (_resourceType == ResourceType.BUNDLE) { 
1:4fec049:       serviceImports = bundleAttributes.getValue(IMPORT_SERVICE);
1:4fec049:     } 
1:4fec049:     if (serviceImports != null) {
1:de5b346:       Map<String, Map<String, String>> svcImports = ManifestHeaderProcessor
1:4fec049:           .parseImportString(serviceImports);
1:de5b346:       for (Map.Entry<String, Map<String, String>> importedService : svcImports.entrySet()) {
1:4fec049:         _importedServices.add(new ImportedServiceImpl(importedService.getKey(), importedService.getValue()));
1:4fec049:       }
1:4fec049:     }
1:4fec049:     
1:4fec049:     _requiredBundles = new ArrayList<ImportedBundle>();
1:4fec049:     // Require-Bundle and DynamicImport-Package relevant to Bundles but not Composites
1:4fec049:     if (_resourceType == ResourceType.BUNDLE) { 
1:4fec049:       String requireBundleHeader = bundleAttributes.getValue(REQUIRE_BUNDLE);
1:4fec049:       if (requireBundleHeader != null) {
1:de5b346:         Map<String, Map<String, String>> requiredBundles = ManifestHeaderProcessor
1:4fec049:             .parseImportString(requireBundleHeader);
1:de5b346:         for (Map.Entry<String, Map<String, String>> bundle : requiredBundles.entrySet()) {
1:4fec049:           String type = bundle.getKey();
1:4fec049:           Map<String, String> attribs = bundle.getValue();
1:4fec049:           // We may parse a manifest with a header like Require-Bundle: bundle.a;bundle-version=3.0.0
1:4fec049:           // The filter that we generate is intended for OBR in which case we need (version>=3.0.0) and not (bundle-version>=3.0.0)
1:4fec049:           String bundleVersion = attribs.remove(BUNDLE_VERSION_ATTRIBUTE);
1:4fec049:           if (bundleVersion != null && attribs.get(VERSION_ATTRIBUTE) == null) { 
1:4fec049:             attribs.put (VERSION_ATTRIBUTE, bundleVersion);
1:4fec049:           }
1:4fec049:           String filter = ManifestHeaderProcessor.generateFilter(ModellingConstants.OBR_SYMBOLIC_NAME, type, attribs);
1:4fec049:           Map<String, String> atts = new HashMap<String, String>(bundle.getValue());
1:4fec049:           atts.put(ModellingConstants.OBR_SYMBOLIC_NAME,  bundle.getKey());
1:4fec049:           _requiredBundles.add(new ImportedBundleImpl(filter, atts));
1:4fec049:         }
1:4fec049:       }
1:4fec049:     
1:4fec049:       String dynamicImports = bundleAttributes.getValue(DYNAMICIMPORT_PACKAGE);
1:4fec049:       if (dynamicImports != null) {
1:de5b346:         Map<String, Map<String, String>> dynamicImportPackages = ManifestHeaderProcessor
1:4fec049:             .parseImportString(dynamicImports);
1:de5b346:         for (Map.Entry<String, Map<String, String>> dynImportPkg : dynamicImportPackages.entrySet()) {
1:4fec049:           if (dynImportPkg.getKey().indexOf("*") == -1) {
1:4fec049:             dynImportPkg.getValue().put(RESOLUTION_DIRECTIVE + ":", RESOLUTION_OPTIONAL);
1:4fec049:             _importedPackages.add(new ImportedPackageImpl(dynImportPkg.getKey(), dynImportPkg.getValue()));
1:4fec049:           }
1:4fec049:         }
1:4fec049:       }
1:4fec049:     }
1:4fec049:     logger.debug(LOG_EXIT, "ModelledResourceImpl");
1:4fec049:   }
1:4fec049: 
1:4fec049: 
1:09a7647:   public String getLocation() {
1:4fec049:     logger.debug(LOG_ENTRY, "getLocation");
1:4fec049:     logger.debug(LOG_EXIT, "getLocation", _fileURI);
1:4fec049:     return _fileURI;
1:4fec049:   }
1:4fec049: 
1:09a7647:   public ExportedBundle getExportedBundle() {
1:4fec049:     logger.debug(LOG_ENTRY, "getExportedBundle");
1:4fec049:     logger.debug(LOG_EXIT, "getExportedBundle",  _exportedBundle);
1:4fec049:     return _exportedBundle;
1:4fec049:   }
1:4fec049: 
1:09a7647:   public Collection<ExportedPackage> getExportedPackages() {
1:4fec049:     logger.debug(LOG_ENTRY, "getExportedPackages");
1:4fec049:     logger.debug(LOG_EXIT, "getExportedPackages",  _exportedPackages);
1:4fec049:     return Collections.unmodifiableCollection(_exportedPackages);
1:4fec049:   }
1:4fec049:   
1:09a7647:   public Collection<ImportedPackage> getImportedPackages() {
1:4fec049:     logger.debug(LOG_ENTRY, "getImportedPackages");
1:4fec049:     logger.debug(LOG_EXIT, "getImportedPackages",  _importedPackages);
1:4fec049:     return Collections.unmodifiableCollection(_importedPackages);
1:4fec049:   }
1:4fec049: 
1:09a7647:   public Collection<ExportedService> getExportedServices() {
1:4fec049:     logger.debug(LOG_ENTRY, "getExportedServices");
1:4fec049:     logger.debug(LOG_EXIT, "getExportedServices",  _exportedServices);
1:4fec049:     return Collections.unmodifiableCollection(_exportedServices);
1:4fec049:   }
1:4fec049: 
1:09a7647:   public Collection<ImportedService> getImportedServices() {
1:4fec049:     logger.debug(LOG_ENTRY, "getImportedServices");
1:4fec049:     logger.debug(LOG_EXIT, "getImportedServices",  _exportedServices);
1:4fec049:     return Collections.unmodifiableCollection(_importedServices);
1:4fec049:   }
1:4fec049: 
1:09a7647:   public String getSymbolicName() {
1:4fec049:     logger.debug(LOG_ENTRY, "getSymbolicName");
1:4fec049:     String result = _exportedBundle.getSymbolicName();
1:4fec049:     logger.debug(LOG_EXIT, "getSymbolicName",  result);
1:4fec049:     return result;
1:4fec049:   }
1:4fec049:   
1:09a7647:   public String getVersion() {
1:4fec049:     logger.debug(LOG_ENTRY, "getVersion");
1:4fec049:     String result = _exportedBundle.getVersion();
1:4fec049:     logger.debug(LOG_EXIT, "getVersion",  result);
1:4fec049:     return result;
1:4fec049:   }
1:4fec049: 
1:09a7647:   public String toDeploymentString() {
1:4fec049:     logger.debug(LOG_ENTRY, "toDeploymentString");
1:4fec049:     String result = _exportedBundle.toDeploymentString();
1:4fec049:     logger.debug(LOG_EXIT, "toDeploymentString",  result);
1:4fec049:     return result;
1:4fec049:   }
1:4fec049: 
1:09a7647:   public ResourceType getType() {
1:4fec049:     logger.debug(LOG_ENTRY, "getType");
1:4fec049:     logger.debug(LOG_EXIT, "getType",  ResourceType.BUNDLE);
1:4fec049:     return _resourceType;
1:4fec049:   }
1:4fec049:   
1:4fec049:   public String toString() {
1:4fec049:     return toDeploymentString();
1:4fec049:   }
1:4fec049: 
1:4fec049: 
1:3d7f5b3:   public Collection<ImportedBundle> getRequiredBundles() {
1:4fec049:     logger.debug(LOG_ENTRY, "getRequiredBundles");
1:4fec049:     logger.debug(LOG_EXIT, "getRequiredBundles",  _requiredBundles);
1:4fec049:     return Collections.unmodifiableCollection(_requiredBundles);
1:4fec049:   }
1:4fec049: 
1:4fec049: 
1:3d7f5b3:   public ImportedBundle getFragmentHost() {
1:4fec049:     logger.debug(LOG_ENTRY, "getFragmentHost");
1:4fec049:     ImportedBundle result = _exportedBundle.getFragmentHost();
1:4fec049:     logger.debug(LOG_EXIT, "getFragmentHost",  result);
1:4fec049:     return result;
1:4fec049:   }
1:4fec049: 
1:4fec049: 
1:3d7f5b3:   public boolean isFragment() {
1:4fec049:     logger.debug(LOG_ENTRY, "isFragment");
1:4fec049:     boolean result = _exportedBundle.isFragment();
1:4fec049:     logger.debug(LOG_EXIT, "isFragment",  result);
1:4fec049:     return result;
1:4fec049:   }
1:4fec049: }
============================================================================
author:J. Daniel Kulp
-------------------------------------------------------------------------------
commit:3d7f5b3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   public Collection<ImportedBundle> getRequiredBundles() {
1:   public ImportedBundle getFragmentHost() {
/////////////////////////////////////////////////////////////////////////
1:   public boolean isFragment() {
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
1:   public String getLocation() {
/////////////////////////////////////////////////////////////////////////
1:   public ExportedBundle getExportedBundle() {
/////////////////////////////////////////////////////////////////////////
1:   public Collection<ExportedPackage> getExportedPackages() {
/////////////////////////////////////////////////////////////////////////
1:   public Collection<ImportedPackage> getImportedPackages() {
1:   public Collection<ExportedService> getExportedServices() {
1:   public Collection<ImportedService> getImportedServices() {
/////////////////////////////////////////////////////////////////////////
1:   public String getSymbolicName() {
/////////////////////////////////////////////////////////////////////////
1:   public String getVersion() {
/////////////////////////////////////////////////////////////////////////
1:   public String toDeploymentString() {
/////////////////////////////////////////////////////////////////////////
1:   public ResourceType getType() {
commit:de5b346
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       List<NameValuePair> exportedPackages = ManifestHeaderProcessor
1:       for (NameValuePair exportedPackage : exportedPackages) {
1:             new HashMap<String, Object>(exportedPackage.getAttributes())));
/////////////////////////////////////////////////////////////////////////
1:       Map<String, Map<String, String>> importedPackages = ManifestHeaderProcessor
1:       for (Map.Entry<String, Map<String, String>> importedPackage : importedPackages.entrySet()) {
/////////////////////////////////////////////////////////////////////////
1:       List<NameValuePair> expServices = ManifestHeaderProcessor
1:       for (NameValuePair exportedService : expServices) {
1:         _exportedServices.add(new ExportedServiceImpl(exportedService.getName(), exportedService.getAttributes()));
/////////////////////////////////////////////////////////////////////////
1:       Map<String, Map<String, String>> svcImports = ManifestHeaderProcessor
1:       for (Map.Entry<String, Map<String, String>> importedService : svcImports.entrySet()) {
/////////////////////////////////////////////////////////////////////////
1:         Map<String, Map<String, String>> requiredBundles = ManifestHeaderProcessor
1:         for (Map.Entry<String, Map<String, String>> bundle : requiredBundles.entrySet()) {
/////////////////////////////////////////////////////////////////////////
1:         Map<String, Map<String, String>> dynamicImportPackages = ManifestHeaderProcessor
1:         for (Map.Entry<String, Map<String, String>> dynImportPkg : dynamicImportPackages.entrySet()) {
/////////////////////////////////////////////////////////////////////////
0:   @Override
0: public String getLocation() {
0:   @Override
0: public ExportedBundle getExportedBundle() {
0:   @Override
0: public Collection<ExportedPackage> getExportedPackages() {
/////////////////////////////////////////////////////////////////////////
0:   @Override
0: public Collection<ImportedPackage> getImportedPackages() {
0:   @Override
0: public Collection<ExportedService> getExportedServices() {
/////////////////////////////////////////////////////////////////////////
0:   @Override
0: public Collection<ImportedService> getImportedServices() {
0:   @Override
0: public String getSymbolicName() {
/////////////////////////////////////////////////////////////////////////
0:   @Override
0: public String getVersion() {
/////////////////////////////////////////////////////////////////////////
0:   @Override
0: public String toDeploymentString() {
/////////////////////////////////////////////////////////////////////////
0:   @Override
0: public ResourceType getType() {
/////////////////////////////////////////////////////////////////////////
0:   @Override
0: public Collection<ImportedBundle> getRequiredBundles() {
0:   @Override
0: public ImportedBundle getFragmentHost() {
/////////////////////////////////////////////////////////////////////////
0:   @Override
0: public boolean isFragment() {
commit:910fec0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValueMap;
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
commit:89f804e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.InvalidAttributeException;
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:297d1fb
/////////////////////////////////////////////////////////////////////////
1:   private final ExportedBundle _exportedBundle; 
1:   private final ResourceType _resourceType;     
/////////////////////////////////////////////////////////////////////////
1:   public ModelledResourceImpl (String fileURI, Attributes bundleAttributes, ExportedBundle exportedBundle, ResourceType resourceType,
1:       Collection<ImportedService> importedServices, 
1:       Collection<ExportedService> exportedServices) throws InvalidAttributeException
1:   { 
1:     this (fileURI, bundleAttributes, resourceType, exportedBundle, importedServices, exportedServices);
1:     logger.debug(LOG_ENTRY, "ModelledResourceImpl", new Object[]{fileURI, bundleAttributes, importedServices, exportedServices});
1:     logger.debug(LOG_EXIT, "ModelledResourceImpl");
1:   }
1: 
1:   /**
1:    * Construct a new {@link ModelledResourceImpl} for the following manifest and services
1:    * @param fileURI The location of the bundle, may be null, which indicates a by value bundle
1:    * @param bundleAttributes The bundle manifest, must not be null
1:    * @param importedServices The blueprint references defined by the bundle. May be null
1:    * @param exportedServices The blueprint services exported by the bundle. May be null
1:    * @throws InvalidAttributeException
1:    */
1:   @SuppressWarnings("deprecation")
1:     this (fileURI, bundleAttributes, ResourceType.BUNDLE, null, importedServices, exportedServices );
1:     logger.debug(LOG_EXIT, "ModelledResourceImpl");
1:   }
1:   
1:   public ModelledResourceImpl (String fileURI, Attributes bundleAttributes, 
1:       ResourceType resourceType, ExportedBundle exportedBundle,
1:       Collection<ImportedService> importedServices, 
1:       Collection<ExportedService> exportedServices 
1:       ) throws InvalidAttributeException 
1:   {
1:     logger.debug(LOG_ENTRY, "ModelledResourceImpl", new Object[]{fileURI, bundleAttributes, importedServices, exportedServices, 
1:         resourceType});
1: 
1:     if (exportedBundle == null) { 
1:       _exportedBundle = new ExportedBundleImpl (bundleAttributes);
1:     } else { 
1:       _exportedBundle = exportedBundle;
1:     }
1:     _resourceType = resourceType;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
commit:58f55bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.modelling.ModellingConstants;
commit:4fec049
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.application.modelling.impl;
1: 
1: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1: import static org.osgi.framework.Constants.BUNDLE_VERSION_ATTRIBUTE;
1: import static org.osgi.framework.Constants.DYNAMICIMPORT_PACKAGE;
1: import static org.osgi.framework.Constants.EXPORT_PACKAGE;
1: import static org.osgi.framework.Constants.EXPORT_SERVICE;
1: import static org.osgi.framework.Constants.IMPORT_PACKAGE;
1: import static org.osgi.framework.Constants.IMPORT_SERVICE;
1: import static org.osgi.framework.Constants.REQUIRE_BUNDLE;
1: import static org.osgi.framework.Constants.RESOLUTION_DIRECTIVE;
1: import static org.osgi.framework.Constants.RESOLUTION_OPTIONAL;
1: import static org.osgi.framework.Constants.VERSION_ATTRIBUTE;
1: 
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.jar.Attributes;
1: 
1: import org.apache.aries.application.management.BundleInfo;
0: import org.apache.aries.application.management.InvalidAttributeException;
1: import org.apache.aries.application.modelling.ExportedBundle;
1: import org.apache.aries.application.modelling.ExportedPackage;
1: import org.apache.aries.application.modelling.ExportedService;
1: import org.apache.aries.application.modelling.ImportedBundle;
1: import org.apache.aries.application.modelling.ImportedPackage;
1: import org.apache.aries.application.modelling.ImportedService;
1: import org.apache.aries.application.modelling.ModelledResource;
1: import org.apache.aries.application.modelling.ResourceType;
0: import org.apache.aries.application.modelling.utils.ModellingConstants;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor.NameValueMap;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor.NameValuePair;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: 
1: /**
1:  * A model of a bundle or composite. Used for example to supply information to 
1:  * RepositoryGenerator.generateRepository()
1:  *
1:  */
1: public class ModelledResourceImpl implements ModelledResource
1: {
1:   private final Logger logger = LoggerFactory.getLogger(ModelledResourceImpl.class);
1:   private final String _fileURI;
1:   private final Collection<ImportedService> _importedServices;
1:   private final Collection<ExportedService> _exportedServices;
1:   private final Collection<ExportedPackage> _exportedPackages;
1:   private final Collection<ImportedPackage> _importedPackages;
1:   private final Collection<ImportedBundle> _requiredBundles;
0:   private final ExportedBundle _exportedBundle;
0:   private final ResourceType _resourceType;
1:   
1:   /**
1:    * Construct a new {@link ModelledResourceImpl} for the following manifest and services
1:    * @param fileURI The location of the bundle, may be null, which indicates a by value bundle
1:    * @param bundleInfo The bundle info object
1:    * @param importedServices The blueprint references defined by the bundle. May be null
1:    * @param exportedServices The blueprint services exported by the bundle. May be null
1:    * @throws InvalidAttributeException
1:    */
1:   public ModelledResourceImpl (String fileURI, BundleInfo bundleInfo, 
1:       Collection<ImportedService> importedServices, 
1:       Collection<ExportedService> exportedServices) throws InvalidAttributeException
1:   {
1:     this(fileURI, bundleInfo.getRawAttributes(), importedServices, exportedServices);
1:   }
1:   /**
1:    * Construct a new {@link ModelledResourceImpl} for the following manifest and services
1:    * @param fileURI The location of the bundle, may be null, which indicates a by value bundle
1:    * @param bundleAttributes The bundle manifest, must not be null
1:    * @param importedServices The blueprint references defined by the bundle. May be null
1:    * @param exportedServices The blueprint services exported by the bundle. May be null
1:    * @throws InvalidAttributeException
1:    */
1:   @SuppressWarnings("deprecation")
1:   public ModelledResourceImpl (String fileURI, Attributes bundleAttributes, 
1:       Collection<ImportedService> importedServices, 
1:       Collection<ExportedService> exportedServices) throws InvalidAttributeException
1:   { 
1:     logger.debug(LOG_ENTRY, "ModelledResourceImpl", new Object[]{fileURI, bundleAttributes, importedServices, exportedServices});
1:     _fileURI = fileURI;
1:     if(importedServices != null)
1:       _importedServices = new ArrayList<ImportedService> (importedServices);
1:     else
1:       _importedServices = new ArrayList<ImportedService>();
1:     
1:     if(exportedServices != null)
1:       _exportedServices = new ArrayList<ExportedService> (exportedServices);
1:     else
1:       _exportedServices = new ArrayList<ExportedService>();
1:     
1:     
0:       _resourceType = ResourceType.BUNDLE;
0:       _exportedBundle = new ExportedBundleImpl (bundleAttributes);
1:   
1: 
1:     
1:     _exportedPackages = new ArrayList<ExportedPackage>();
1:     String packageExports = bundleAttributes.getValue(EXPORT_PACKAGE);
1:     if (packageExports != null) {
0:       List<NameValuePair<String, NameValueMap<String, String>>> exportedPackages = ManifestHeaderProcessor
1:         .parseExportString(packageExports);
0:       for (NameValuePair<String, NameValueMap<String, String>> exportedPackage : exportedPackages) {
1:         _exportedPackages.add(new ExportedPackageImpl(this, exportedPackage.getName(), 
0:             new HashMap<String, Object>(exportedPackage.getValue())));
1:     
1:       }
1:     }
1: 
1:     _importedPackages = new ArrayList<ImportedPackage>();
1:     String packageImports = bundleAttributes.getValue(IMPORT_PACKAGE);
1:     if (packageImports != null) {
0:       Map<String, NameValueMap<String, String>> importedPackages = ManifestHeaderProcessor
1:           .parseImportString(packageImports);
0:       for (Map.Entry<String, NameValueMap<String, String>> importedPackage : importedPackages.entrySet()) {
1:         Map<String, String> atts = importedPackage.getValue();
1:         _importedPackages.add(new ImportedPackageImpl(importedPackage.getKey(), atts));
1:       }
1:     }
1:     
1:     // Use of Import-Service and Export-Service is deprecated in OSGi. We like Blueprint. 
1:     // Blueprint is good. 
1:     
1:     String serviceExports = null; 
1:     if (_resourceType == ResourceType.BUNDLE) { 
1:       serviceExports = bundleAttributes.getValue(EXPORT_SERVICE);
1:     } 
1:     if (serviceExports != null) {
0:       List<NameValuePair<String, NameValueMap<String, String>>> expServices = ManifestHeaderProcessor
1:           .parseExportString(serviceExports);
0:       for (NameValuePair<String, NameValueMap<String, String>> exportedService : expServices) {
0:         _exportedServices.add(new ExportedServiceImpl(exportedService.getName(), exportedService.getValue()));
1:       }
1:     }
1: 
1:     String serviceImports =null;
1:     if (_resourceType == ResourceType.BUNDLE) { 
1:       serviceImports = bundleAttributes.getValue(IMPORT_SERVICE);
1:     } 
1:     if (serviceImports != null) {
0:       Map<String, NameValueMap<String, String>> svcImports = ManifestHeaderProcessor
1:           .parseImportString(serviceImports);
0:       for (Map.Entry<String, NameValueMap<String, String>> importedService : svcImports.entrySet()) {
1:         _importedServices.add(new ImportedServiceImpl(importedService.getKey(), importedService.getValue()));
1:       }
1:     }
1:     
1:     _requiredBundles = new ArrayList<ImportedBundle>();
1:     // Require-Bundle and DynamicImport-Package relevant to Bundles but not Composites
1:     if (_resourceType == ResourceType.BUNDLE) { 
1:       String requireBundleHeader = bundleAttributes.getValue(REQUIRE_BUNDLE);
1:       if (requireBundleHeader != null) {
0:         Map<String, NameValueMap<String, String>> requiredBundles = ManifestHeaderProcessor
1:             .parseImportString(requireBundleHeader);
0:         for (Map.Entry<String, NameValueMap<String, String>> bundle : requiredBundles.entrySet()) {
1:           String type = bundle.getKey();
1:           Map<String, String> attribs = bundle.getValue();
1:           // We may parse a manifest with a header like Require-Bundle: bundle.a;bundle-version=3.0.0
1:           // The filter that we generate is intended for OBR in which case we need (version>=3.0.0) and not (bundle-version>=3.0.0)
1:           String bundleVersion = attribs.remove(BUNDLE_VERSION_ATTRIBUTE);
1:           if (bundleVersion != null && attribs.get(VERSION_ATTRIBUTE) == null) { 
1:             attribs.put (VERSION_ATTRIBUTE, bundleVersion);
1:           }
1:           String filter = ManifestHeaderProcessor.generateFilter(ModellingConstants.OBR_SYMBOLIC_NAME, type, attribs);
1:           Map<String, String> atts = new HashMap<String, String>(bundle.getValue());
1:           atts.put(ModellingConstants.OBR_SYMBOLIC_NAME,  bundle.getKey());
1:           _requiredBundles.add(new ImportedBundleImpl(filter, atts));
1:         }
1:       }
1:     
1:       String dynamicImports = bundleAttributes.getValue(DYNAMICIMPORT_PACKAGE);
1:       if (dynamicImports != null) {
0:         Map<String, NameValueMap<String, String>> dynamicImportPackages = ManifestHeaderProcessor
1:             .parseImportString(dynamicImports);
0:         for (Map.Entry<String, NameValueMap<String, String>> dynImportPkg : dynamicImportPackages.entrySet()) {
1:           if (dynImportPkg.getKey().indexOf("*") == -1) {
1:             dynImportPkg.getValue().put(RESOLUTION_DIRECTIVE + ":", RESOLUTION_OPTIONAL);
1:             _importedPackages.add(new ImportedPackageImpl(dynImportPkg.getKey(), dynImportPkg.getValue()));
1:           }
1:         }
1:       }
1:     }
1: 
1:     logger.debug(LOG_EXIT, "ModelledResourceImpl");
1:   }
1: 
1: 
0:   public String getLocation() {
1:     logger.debug(LOG_ENTRY, "getLocation");
1:     logger.debug(LOG_EXIT, "getLocation", _fileURI);
1:     return _fileURI;
1:   }
1: 
1: 
0:   public ExportedBundle getExportedBundle() {
1:     logger.debug(LOG_ENTRY, "getExportedBundle");
1:     logger.debug(LOG_EXIT, "getExportedBundle",  _exportedBundle);
1:     return _exportedBundle;
1:   }
1: 
1: 
0:   public Collection<ExportedPackage> getExportedPackages() {
1:     logger.debug(LOG_ENTRY, "getExportedPackages");
1:     logger.debug(LOG_EXIT, "getExportedPackages",  _exportedPackages);
1:     return Collections.unmodifiableCollection(_exportedPackages);
1:   }
1:   
1: 
1: 
0:   public Collection<ImportedPackage> getImportedPackages() {
1:     logger.debug(LOG_ENTRY, "getImportedPackages");
1:     logger.debug(LOG_EXIT, "getImportedPackages",  _importedPackages);
1:     return Collections.unmodifiableCollection(_importedPackages);
1:   }
1: 
0:   public Collection<ExportedService> getExportedServices() {
1:     logger.debug(LOG_ENTRY, "getExportedServices");
1:     logger.debug(LOG_EXIT, "getExportedServices",  _exportedServices);
1:     return Collections.unmodifiableCollection(_exportedServices);
1:   }
1: 
1: 
1: 
0:   public Collection<ImportedService> getImportedServices() {
1:     logger.debug(LOG_ENTRY, "getImportedServices");
1:     logger.debug(LOG_EXIT, "getImportedServices",  _exportedServices);
1:     return Collections.unmodifiableCollection(_importedServices);
1:   }
1: 
1: 
0:   public String getSymbolicName() {
1:     logger.debug(LOG_ENTRY, "getSymbolicName");
1:     String result = _exportedBundle.getSymbolicName();
1:     logger.debug(LOG_EXIT, "getSymbolicName",  result);
1:     return result;
1:   }
1:   
1: 
0:   public String getVersion() {
1:     logger.debug(LOG_ENTRY, "getVersion");
1:     String result = _exportedBundle.getVersion();
1:     logger.debug(LOG_EXIT, "getVersion",  result);
1:     return result;
1:   }
1: 
1: 
0:   public String toDeploymentString() {
1:     logger.debug(LOG_ENTRY, "toDeploymentString");
1:     String result = _exportedBundle.toDeploymentString();
1:     logger.debug(LOG_EXIT, "toDeploymentString",  result);
1:     return result;
1:   }
1: 
1: 
0:   public ResourceType getType() {
1:     logger.debug(LOG_ENTRY, "getType");
1:     logger.debug(LOG_EXIT, "getType",  ResourceType.BUNDLE);
1:     return _resourceType;
1:   }
1:   
0:   @Override
1:   public String toString() {
1:     return toDeploymentString();
1:   }
1: 
1: 
0:   public Collection<ImportedBundle> getRequiredBundles() {
1:     logger.debug(LOG_ENTRY, "getRequiredBundles");
1:     logger.debug(LOG_EXIT, "getRequiredBundles",  _requiredBundles);
1:     return Collections.unmodifiableCollection(_requiredBundles);
1:   }
1: 
1: 
0:   public ImportedBundle getFragmentHost() {
1:     logger.debug(LOG_ENTRY, "getFragmentHost");
1:     ImportedBundle result = _exportedBundle.getFragmentHost();
1:     logger.debug(LOG_EXIT, "getFragmentHost",  result);
1:     return result;
1:   }
1: 
1: 
0:   public boolean isFragment() {
1:     logger.debug(LOG_ENTRY, "isFragment");
1:     boolean result = _exportedBundle.isFragment();
1:     logger.debug(LOG_EXIT, "isFragment",  result);
1:     return result;
1:   }
1: }
============================================================================