1:3bece4b: package org.apache.aries.plugin.eba;
6:3bece4b: 
1:3bece4b: /*
1:3bece4b:  * Licensed to the Apache Software Foundation (ASF) under one
1:3bece4b:  * or more contributor license agreements.  See the NOTICE file
1:3bece4b:  * distributed with this work for additional information
1:3bece4b:  * regarding copyright ownership.  The ASF licenses this file
1:3bece4b:  * to you under the Apache License, Version 2.0 (the
1:3bece4b:  * "License"); you may not use this file except in compliance
1:3bece4b:  * with the License.  You may obtain a copy of the License at
2:3bece4b:  *
1:3bece4b:  *  http://www.apache.org/licenses/LICENSE-2.0
1:3bece4b:  *
1:3bece4b:  * Unless required by applicable law or agreed to in writing,
1:3bece4b:  * software distributed under the License is distributed on an
1:3bece4b:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:3bece4b:  * KIND, either express or implied.  See the License for the
1:3bece4b:  * specific language governing permissions and limitations
1:3bece4b:  * under the License.
2:3bece4b:  */
1:3bece4b: 
1:e1f2a07: import org.apache.maven.archiver.PomPropertiesUtil;
1:e1f2a07: import org.apache.maven.artifact.Artifact;
1:e1f2a07: import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
1:3bece4b: import org.apache.maven.plugin.AbstractMojo;
1:3bece4b: import org.apache.maven.plugin.MojoExecutionException;
1:3bece4b: import org.apache.maven.project.MavenProject;
1:a5742c5: import org.codehaus.plexus.archiver.ArchiverException;
1:e1f2a07: import org.codehaus.plexus.archiver.zip.ZipArchiver;
1:3bece4b: import org.codehaus.plexus.util.DirectoryScanner;
1:e1f2a07: import org.codehaus.plexus.util.FileUtils;
1:58e1079: import org.apache.maven.shared.osgi.DefaultMaven2OsgiConverter;
1:58e1079: import org.apache.maven.shared.osgi.Maven2OsgiConverter;
1:58e1079: import aQute.lib.osgi.Analyzer;
1:3bece4b: import java.io.File;
1:3bece4b: import java.io.IOException;
1:3bece4b: import java.util.Iterator;
1:521fd4c: import java.util.LinkedHashMap;
1:6d61cef: import java.util.LinkedHashSet;
1:521fd4c: import java.util.Map;
1:3bece4b: import java.util.Set;
1:3bece4b: 
2:3bece4b: /**
1:3bece4b:  * Builds Aries Enterprise Bundle Archive (eba) files.
1:3bece4b:  *
1:3bece4b:  * @version $Id: $
1:3bece4b:  * @goal eba
1:3bece4b:  * @phase package
1:3bece4b:  * @requiresDependencyResolution test
1:3bece4b:  */
1:3bece4b: public class EbaMojo
1:3bece4b:     extends AbstractMojo
6:3bece4b: {
1:58e1079: 
1:58e1079:     
1:58e1079: 	public static final String APPLICATION_MF_URI = "META-INF/APPLICATION.MF";
1:3bece4b: 
1:3bece4b:     private static final String[] DEFAULT_INCLUDES = {"**/**"};
1:58e1079: 
1:3bece4b:     /**
1:58e1079:      * Application manifest headers
1:58e1079:      */
1:521fd4c:     private static final String MANIFEST_VERSION = "Manifest-Version";
1:521fd4c:     private static final String APPLICATION_MANIFESTVERSION = "Application-ManifestVersion";
1:521fd4c:     private static final String APPLICATION_SYMBOLICNAME = "Application-SymbolicName";
1:521fd4c:     private static final String APPLICATION_VERSION = "Application-Version";
1:521fd4c:     private static final String APPLICATION_NAME = "Application-Name";
1:521fd4c:     private static final String APPLICATION_DESCRIPTION = "Application-Description";
1:521fd4c:     private static final String APPLICATION_CONTENT = "Application-Content";
1:521fd4c:     private static final String APPLICATION_EXPORTSERVICE = "Application-ExportService";
1:521fd4c:     private static final String APPLICATION_IMPORTSERVICE = "Application-ImportService";
1:a68eb1d:     private static final String APPLICATION_USEBUNDLE = "Use-Bundle";
1:9e91704:     
1:58e1079:     /**
1:58e1079:      * Coverter for maven pom values to OSGi manifest values (pulled in from the maven-bundle-plugin)
1:58e1079:      */
1:58e1079:     private Maven2OsgiConverter maven2OsgiConverter = new DefaultMaven2OsgiConverter();
1:58e1079:     
1:58e1079:     /**
1:3bece4b:      * Single directory for extra files to include in the eba.
1:3bece4b:      *
1:3bece4b:      * @parameter expression="${basedir}/src/main/eba"
1:3bece4b:      * @required
1:3bece4b:      */
1:3bece4b:     private File ebaSourceDirectory;
1:3bece4b: 
1:3bece4b:     /**
1:58e1079:      * The location of the APPLICATION.MF file to be used within the eba file.
1:3bece4b:      *
1:58e1079:      * @parameter expression="${basedir}/src/main/eba/META-INF/APPLICATION.MF"
1:3bece4b:      */
1:3bece4b:     private File applicationManifestFile;
1:3bece4b: 
1:3bece4b:     /**
1:3bece4b:      * Specify if the generated jar file of this project should be
1:3bece4b:      * included in the eba file ; default is true.
1:3bece4b:      *
2:3bece4b:      * @parameter
1:3bece4b:      */
1:3bece4b:     private Boolean includeJar = Boolean.TRUE;
1:3bece4b: 
1:3bece4b:     /**
1:3bece4b:      * The location of the manifest file to be used within the eba file.
1:3bece4b:      *
1:3bece4b:      * @parameter expression="${basedir}/src/main/eba/META-INF/MANIFEST.MF"
1:3bece4b:      */
1:3bece4b:     private File manifestFile;
1:3bece4b: 
1:3bece4b:     /**
1:3bece4b:      * Directory that resources are copied to during the build.
1:3bece4b:      *
1:3bece4b:      * @parameter expression="${project.build.directory}/${project.build.finalName}"
1:3bece4b:      * @required
1:3bece4b:      */
1:3bece4b:     private String workDirectory;
1:3bece4b: 
1:3bece4b:     /**
1:9c0f809:      * Directory that remote-resources puts legal files.
1:9c0f809:      *
1:9c0f809:      * @parameter expression="${project.build.directory}/maven-shared-archive-resources"
1:9c0f809:      * @required
1:9c0f809:      */
1:9c0f809:     private String sharedResources;
1:9c0f809: 
1:9c0f809:     /**
1:3bece4b:      * The directory for the generated eba.
1:3bece4b:      *
1:3bece4b:      * @parameter expression="${project.build.directory}"
1:3bece4b:      * @required
1:3bece4b:      */
1:3bece4b:     private String outputDirectory;
1:3bece4b: 
1:3bece4b:     /**
1:3bece4b:      * The name of the eba file to generate.
1:3bece4b:      *
1:3bece4b:      * @parameter alias="ebaName" expression="${project.build.finalName}"
1:3bece4b:      * @required
1:3bece4b:      */
1:3bece4b:     private String finalName;
1:3bece4b: 
1:3bece4b:     /**
1:3bece4b:      * The maven project.
1:3bece4b:      *
1:3bece4b:      * @parameter expression="${project}"
1:3bece4b:      * @required
1:3bece4b:      * @readonly
1:3bece4b:      */
1:3bece4b:     private MavenProject project;
1:3bece4b: 
1:3bece4b:     /**
1:3bece4b:      * The Jar archiver.
1:3bece4b:      *
1:3f25446:      * @component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
1:e1f2a07:      * @required
1:3bece4b:      */
1:e1f2a07:     private ZipArchiver zipArchiver;
1:e1f2a07: 
1:e1f2a07:     /**
1:58e1079:      * Whether to generate a manifest based on maven configuration.
1:58e1079:      *
1:58e1079:      * @parameter expression="${generateManifest}" default-value="false"
1:58e1079:      */
1:58e1079:     private boolean generateManifest;
1:58e1079: 
1:58e1079:     /**
1:521fd4c:      * Configuration for the plugin.
1:58e1079:      *
1:521fd4c:      * @parameter
1:58e1079:      */
1:521fd4c:     private Map instructions = new LinkedHashMap();;    
1:521fd4c:     
1:58e1079:     /**
1:e1f2a07:      * Adding pom.xml and pom.properties to the archive.
1:58e1079:      *
1:e1f2a07:      * @parameter expression="${addMavenDescriptor}" default-value="true"
1:58e1079:      */
1:e1f2a07:     private boolean addMavenDescriptor;
1:58e1079: 
1:58e1079:     /**
1:e1f2a07:      * Include or not empty directories
1:e1f2a07:      *
1:dcad9e9:      * @parameter expression="${includeEmptyDirs}" default-value="true"
1:e1f2a07:      */
1:e1f2a07:     private boolean includeEmptyDirs;
1:58e1079: 
1:e1f2a07:     /**
1:e1f2a07:      * Whether creating the archive should be forced.
1:e1f2a07:      *
1:dcad9e9:      * @parameter expression="${forceCreation}" default-value="false"
1:e1f2a07:      */
1:e1f2a07:     private boolean forceCreation;
1:e1f2a07: 
1:dcad9e9:     /**
1:dcad9e9:      * Whether to follow transitive dependencies or use explicit dependencies.
1:dcad9e9:      *
1:dcad9e9:      * @parameter expression="${useTransitiveDependencies}" default-value="false"
1:dcad9e9:      */
1:dcad9e9:     private boolean useTransitiveDependencies;
1:dcad9e9: 
1:9e91704:     /**
1:9e91704:      * Define which bundles to include in the archive.
1:9e91704:      *   none - no bundles are included 
1:9e91704:      *   applicationContent - direct dependencies go into the content
1:9e91704:      *   all - direct and transitive dependencies go into the content 
1:9e91704:      *
1:9e91704:      * @parameter expression="${archiveContent}" default-value="applicationContent"
1:9e91704:      */
1:9e91704:     private String archiveContent;
1:9e91704: 
1:3bece4b: 
1:3bece4b:     private File buildDir;
1:3bece4b: 
1:3bece4b: 
1:3bece4b:     public void execute()
1:3bece4b:         throws MojoExecutionException
1:3bece4b:     {
1:3bece4b:         getLog().debug( " ======= EbaMojo settings =======" );
1:3bece4b:         getLog().debug( "ebaSourceDirectory[" + ebaSourceDirectory + "]" );
1:3bece4b:         getLog().debug( "manifestFile[" + manifestFile + "]" );
1:3bece4b:         getLog().debug( "applicationManifestFile[" + applicationManifestFile + "]" );
1:3bece4b:         getLog().debug( "workDirectory[" + workDirectory + "]" );
1:3bece4b:         getLog().debug( "outputDirectory[" + outputDirectory + "]" );
1:3bece4b:         getLog().debug( "finalName[" + finalName + "]" );
1:58e1079:         getLog().debug( "generateManifest[" + generateManifest + "]" );
1:3bece4b: 
1:9e91704:         if (archiveContent == null) {
1:9e91704:         	archiveContent = new String("applicationContent");
1:9e91704:         }
1:9e91704:         
1:9e91704:         getLog().debug( "archiveContent[" + archiveContent + "]" );        
1:9e91704:         getLog().info( "archiveContent[" + archiveContent + "]" );        
1:9e91704:         
1:e1f2a07:         zipArchiver.setIncludeEmptyDirs( includeEmptyDirs );
1:e1f2a07:         zipArchiver.setCompress( true );
1:e1f2a07:         zipArchiver.setForced( forceCreation );
1:3bece4b:         // Check if jar file is there and if requested, copy it
1:3bece4b:         try
1:3bece4b:         {
1:3bece4b:             if (includeJar.booleanValue()) {
1:3bece4b:                 File generatedJarFile = new File( outputDirectory, finalName + ".jar" );
1:3bece4b:                 if (generatedJarFile.exists()) {
1:3bece4b:                     getLog().info( "Including generated jar file["+generatedJarFile.getName()+"]");
1:e1f2a07:                     zipArchiver.addFile(generatedJarFile, finalName + ".jar");
5:3bece4b:                 }
1:3bece4b:             }
1:3bece4b:         }
1:a5742c5:         catch ( ArchiverException e )
1:3bece4b:         {
1:a5742c5:             throw new MojoExecutionException( "Error adding generated Jar file", e );
1:a5742c5: 
1:3bece4b:         }
1:3bece4b: 
1:3bece4b:         // Copy dependencies
1:3bece4b:         try
1:3bece4b:         {
1:9e91704:             Set<Artifact> artifacts = null;
1:b95d944:             if (useTransitiveDependencies || "all".equals(archiveContent)) {
1:9e91704:                 // if use transitive is set (i.e. true) then we need to make sure archiveContent does not contradict (i.e. is set
1:9e91704:                 // to the same compatible value or is the default).
1:9e91704:             	if ("none".equals(archiveContent)) {
1:9e91704:                     throw new MojoExecutionException("<useTransitiveDependencies/> and <archiveContent/> incompatibly configured.  <useTransitiveDependencies/> is deprecated in favor of <archiveContent/>." );            		
1:9e91704:             	}
1:9e91704:             	else {
1:9e91704:                     artifacts = project.getArtifacts();            		
1:9e91704:             	}
1:dcad9e9:             } else {
1:9e91704:             	// check that archiveContent is compatible
1:9e91704:             	if ("applicationContent".equals(archiveContent)) {
1:9e91704:                     artifacts = project.getDependencyArtifacts();            		
1:9e91704:             	}
1:9e91704:             	else {
1:9e91704:                 	// the only remaining options should be applicationContent="none"
1:9e91704:                     getLog().info("archiveContent=none: application arvhive will not contain any bundles.");            		
1:9e91704:             	}
1:dcad9e9:             }
1:9e91704:             if (artifacts != null) {
1:9e91704:                 for (Artifact artifact : artifacts) {
1:3bece4b: 
1:9e91704:                     ScopeArtifactFilter filter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME);
1:9e91704:                     if (!artifact.isOptional() && filter.include(artifact)) {
1:9e91704:                         getLog().info("Copying artifact[" + artifact.getGroupId() + ", " + artifact.getId() + ", " +
1:9e91704:                                 artifact.getScope() + "]");
1:9e91704:                         zipArchiver.addFile(artifact.getFile(), artifact.getArtifactId() + "-" + artifact.getVersion() + "." + (artifact.getType() == null ? "jar" : artifact.getType()));
1:9e91704:                     }
1:9e91704:                 }            	
1:3bece4b:             }
1:3bece4b:         }
1:a5742c5:         catch ( ArchiverException e )
1:3bece4b:         {
1:3bece4b:             throw new MojoExecutionException( "Error copying EBA dependencies", e );
1:3bece4b:         }
1:3bece4b: 
1:3bece4b:         // Copy source files
1:3bece4b:         try
1:3bece4b:         {
1:3bece4b:             File ebaSourceDir = ebaSourceDirectory;
1:3bece4b:             if ( ebaSourceDir.exists() )
1:3bece4b:             {
1:3bece4b:                 getLog().info( "Copy eba resources to " + getBuildDir().getAbsolutePath() );
1:3bece4b: 
1:3bece4b:                 DirectoryScanner scanner = new DirectoryScanner();
1:3bece4b:                 scanner.setBasedir( ebaSourceDir.getAbsolutePath() );
1:3bece4b:                 scanner.setIncludes( DEFAULT_INCLUDES );
1:3bece4b:                 scanner.addDefaultExcludes();
1:3bece4b:                 scanner.scan();
1:3bece4b: 
1:3bece4b:                 String[] dirs = scanner.getIncludedDirectories();
1:3bece4b: 
1:3bece4b:                 for ( int j = 0; j < dirs.length; j++ )
1:3bece4b:                 {
1:3bece4b:                     new File( getBuildDir(), dirs[j] ).mkdirs();
1:3bece4b:                 }
1:3bece4b: 
1:3bece4b:                 String[] files = scanner.getIncludedFiles();
1:3bece4b: 
1:3bece4b:                 for ( int j = 0; j < files.length; j++ )
1:3bece4b:                 {
1:3bece4b:                     File targetFile = new File( getBuildDir(), files[j] );
1:3bece4b: 
1:3bece4b:                     targetFile.getParentFile().mkdirs();
1:3bece4b: 
1:3bece4b:                     File file = new File( ebaSourceDir, files[j] );
1:3bece4b:                     FileUtils.copyFileToDirectory( file, targetFile.getParentFile() );
1:3bece4b:                 }
1:3bece4b:             }
1:3bece4b:         }
1:3bece4b:         catch ( Exception e )
1:3bece4b:         {
1:3bece4b:             throw new MojoExecutionException( "Error copying EBA resources", e );
1:3bece4b:         }
1:3bece4b: 
2:3bece4b:         // Include custom manifest if necessary
1:3bece4b:         try
1:3bece4b:         {
1:58e1079:             if (!generateManifest) {
1:58e1079:             	includeCustomApplicationManifestFile();
1:58e1079:             }
1:3bece4b:         }
3:3bece4b:         catch ( IOException e )
1:3bece4b:         {
1:58e1079:             throw new MojoExecutionException( "Error copying APPLICATION.MF file", e );
1:3bece4b:         }
1:3bece4b: 
1:58e1079: 		// Generate application manifest if requested
1:58e1079: 		if (generateManifest) {
1:58e1079: 			String fileName = new String(getBuildDir() + "/"
1:58e1079: 					+ APPLICATION_MF_URI);
1:58e1079: 			File appMfFile = new File(fileName);
1:58e1079: 
1:58e1079: 			try {
1:58e1079: 				// Delete any old manifest
1:58e1079: 				if (appMfFile.exists()) {
1:58e1079: 					FileUtils.fileDelete(fileName);
1:58e1079: 				}
1:58e1079: 
1:58e1079: 				appMfFile.getParentFile().mkdirs();
1:58e1079: 				if (appMfFile.createNewFile()) {
1:58e1079: 					writeApplicationManifest(fileName);
1:58e1079: 				}
1:58e1079: 			} catch (java.io.IOException e) {
1:58e1079: 				throw new MojoExecutionException(
1:58e1079: 						"Error generating APPLICATION.MF file: " + fileName, e);
1:58e1079: 			}
1:58e1079: 		}
1:58e1079:         
1:3bece4b:         // Check if connector deployment descriptor is there
1:3bece4b:         File ddFile = new File( getBuildDir(), APPLICATION_MF_URI);
1:3bece4b:         if ( !ddFile.exists() )
1:3bece4b:         {
1:3bece4b:             getLog().warn(
1:58e1079:                 "Application manifest: " + ddFile.getAbsolutePath() + " does not exist." );
1:3bece4b:         }
1:3bece4b: 
1:3bece4b:         try
1:3bece4b:         {
1:e1f2a07:             if (addMavenDescriptor) {
1:e1f2a07:                 if (project.getArtifact().isSnapshot()) {
1:e1f2a07:                     project.setVersion(project.getArtifact().getVersion());
1:e1f2a07:                 }
1:3bece4b: 
1:e1f2a07:                 String groupId = project.getGroupId();
1:e1f2a07: 
1:e1f2a07:                 String artifactId = project.getArtifactId();
1:e1f2a07: 
1:e1f2a07:                 zipArchiver.addFile(project.getFile(), "META-INF/maven/" + groupId + "/" + artifactId + "/pom.xml");
1:e1f2a07:                 PomPropertiesUtil pomPropertiesUtil = new PomPropertiesUtil();
1:e1f2a07:                 File dir = new File(project.getBuild().getDirectory(), "maven-zip-plugin");
1:e1f2a07:                 File pomPropertiesFile = new File(dir, "pom.properties");
1:e1f2a07:                 pomPropertiesUtil.createPomProperties(project, zipArchiver, pomPropertiesFile, forceCreation);
1:e1f2a07:             }
1:e1f2a07:             File ebaFile = new File( outputDirectory, finalName + ".eba" );
1:e1f2a07:             zipArchiver.setDestFile(ebaFile);
1:3bece4b: 
1:a5742c5:             File buildDir = getBuildDir();
1:a5742c5:             if (buildDir.isDirectory()) {
1:e1f2a07:                 zipArchiver.addDirectory(buildDir);
1:a5742c5:             }
1:9c0f809:             //include legal files if any
1:9c0f809:             File sharedResourcesDir = new File(sharedResources);
1:9c0f809:             if (sharedResourcesDir.isDirectory()) {
1:e1f2a07:                 zipArchiver.addDirectory(sharedResourcesDir);
1:9c0f809:             }
1:e1f2a07:             zipArchiver.createArchive();
1:3bece4b: 
1:3bece4b:             project.getArtifact().setFile( ebaFile );
1:3bece4b:         }
1:3bece4b:         catch ( Exception e )
1:3bece4b:         {
1:3bece4b:             throw new MojoExecutionException( "Error assembling eba", e );
1:3bece4b:         }
1:3bece4b:     }
1:3bece4b: 
1:58e1079: 	private void writeApplicationManifest(String fileName)
1:58e1079: 			throws MojoExecutionException {
1:58e1079: 		try {
1:58e1079: 			// TODO: add support for dependency version ranges. Need to pick
1:58e1079: 			// them up from the pom and convert them to OSGi version ranges.
1:521fd4c: 			FileUtils.fileAppend(fileName, MANIFEST_VERSION + ": " + "1" + "\n");
1:521fd4c: 			FileUtils.fileAppend(fileName, APPLICATION_MANIFESTVERSION + ": " + "1" + "\n");
1:521fd4c: 			FileUtils.fileAppend(fileName, APPLICATION_SYMBOLICNAME + ": "
1:58e1079: 					+ getApplicationSymbolicName(project.getArtifact()) + "\n");
1:521fd4c: 			FileUtils.fileAppend(fileName, APPLICATION_VERSION + ": "
1:e2c47f0: 					+ getApplicationVersion() + "\n");
1:521fd4c: 			FileUtils.fileAppend(fileName, APPLICATION_NAME + ": " + project.getName() + "\n");
1:521fd4c: 			FileUtils.fileAppend(fileName, APPLICATION_DESCRIPTION + ": "
1:58e1079: 					+ project.getDescription() + "\n");
1:58e1079: 
1:58e1079: 			// Write the APPLICATION-CONTENT
1:58e1079: 			// TODO: check that the dependencies are bundles (currently, the converter
1:58e1079: 			// will throw an exception)
1:58e1079: 			Set<Artifact> artifacts;
1:58e1079: 			if (useTransitiveDependencies) {
1:58e1079: 				artifacts = project.getArtifacts();
1:58e1079: 			} else {
1:58e1079: 				artifacts = project.getDependencyArtifacts();
1:58e1079: 			}
1:6d61cef: 			artifacts = selectArtifacts(artifacts);
1:58e1079: 			Iterator<Artifact> iter = artifacts.iterator();
1:58e1079: 
1:521fd4c: 			FileUtils.fileAppend(fileName, APPLICATION_CONTENT + ": ");
1:58e1079: 			if (iter.hasNext()) {
1:58e1079: 				Artifact artifact = iter.next();
1:58e1079: 				FileUtils.fileAppend(fileName, maven2OsgiConverter
1:58e1079: 						.getBundleSymbolicName(artifact)
1:58e1079: 						+ ";version=\""
1:6d61cef: 						+ Analyzer.cleanupVersion(artifact.getVersion())
1:58e1079: //						+ maven2OsgiConverter.getVersion(artifact.getVersion())
1:58e1079: 						+ "\"");
1:58e1079: 			}
1:58e1079: 			while (iter.hasNext()) {
1:58e1079: 				Artifact artifact = iter.next();
1:58e1079: 				FileUtils.fileAppend(fileName, ",\n "
1:58e1079: 						+ maven2OsgiConverter.getBundleSymbolicName(artifact)
1:58e1079: 						+ ";version=\""
1:6d61cef: 						+ Analyzer.cleanupVersion(artifact.getVersion())
1:58e1079: //						+ maven2OsgiConverter.getVersion(artifact.getVersion())
1:58e1079: 						+ "\"");
1:58e1079: 			}
1:58e1079: 
1:58e1079: 			FileUtils.fileAppend(fileName, "\n");
1:58e1079: 
1:58e1079: 			// Add any service imports or exports
1:521fd4c: 			if (instructions.containsKey(APPLICATION_EXPORTSERVICE)) {
1:521fd4c: 				FileUtils.fileAppend(fileName, APPLICATION_EXPORTSERVICE + ": "
1:521fd4c: 						+ instructions.get(APPLICATION_EXPORTSERVICE) + "\n");
1:58e1079: 			}
1:521fd4c: 			if (instructions.containsKey(APPLICATION_IMPORTSERVICE)) {
1:521fd4c: 				FileUtils.fileAppend(fileName, APPLICATION_IMPORTSERVICE + ": "
1:521fd4c: 						+ instructions.get(APPLICATION_IMPORTSERVICE) + "\n");
1:58e1079: 			}
1:a68eb1d: 			if (instructions.containsKey(APPLICATION_USEBUNDLE)) {
1:a68eb1d: 				FileUtils.fileAppend(fileName, APPLICATION_USEBUNDLE + ": "
1:a68eb1d: 						+ instructions.get(APPLICATION_USEBUNDLE) + "\n");
1:a68eb1d: 			}
1:a68eb1d:                         // Add any use bundle entry
1:58e1079: 
1:58e1079: 		} catch (Exception e) {
1:58e1079: 			throw new MojoExecutionException(
1:58e1079: 					"Error writing dependencies into APPLICATION.MF", e);
1:58e1079: 		}
1:58e1079: 
1:58e1079: 	}
1:58e1079:     
1:58e1079:     // The maven2OsgiConverter assumes the artifact is a jar so we need our own
1:58e1079: 	// This uses the same fallback scheme as the converter
1:58e1079:     private String getApplicationSymbolicName(Artifact artifact) {
1:4511e38: 		if (instructions.containsKey(APPLICATION_SYMBOLICNAME)) {
1:4511e38: 			return instructions.get(APPLICATION_SYMBOLICNAME).toString();
1:4511e38: 		}
1:58e1079:     	return artifact.getGroupId() + "." + artifact.getArtifactId();
1:58e1079:     }
1:58e1079:     
1:e2c47f0:     private String getApplicationVersion() {
1:e2c47f0:         if (instructions.containsKey(APPLICATION_VERSION)) {
1:e2c47f0:             return instructions.get(APPLICATION_VERSION).toString();
1:e2c47f0:         }
1:e2c47f0:         return aQute.lib.osgi.Analyzer.cleanupVersion(project.getVersion());
1:e2c47f0:     }
1:e2c47f0:     
1:3bece4b:     protected File getBuildDir()
1:3bece4b:     {
1:3bece4b:         if ( buildDir == null )
1:3bece4b:         {
1:3bece4b:             buildDir = new File( workDirectory );
1:3bece4b:         }
1:3bece4b:         return buildDir;
1:3bece4b:     }
1:3bece4b: 
1:3bece4b:     private void includeCustomApplicationManifestFile()
2:3bece4b:         throws IOException
1:3bece4b:     {
1:3bece4b:         if (applicationManifestFile == null) {
1:9e91704:             throw new NullPointerException("Application manifest file location not set.  Use <generateManifest>true</generateManifest> if you want it to be generated.");
1:3bece4b:         }
1:3bece4b:         File appMfFile = applicationManifestFile;
1:3bece4b:         if (appMfFile.exists()) {
1:58e1079:             getLog().info( "Using APPLICATION.MF "+ applicationManifestFile);
2:3bece4b:             File metaInfDir = new File(getBuildDir(), "META-INF");
1:3bece4b:             FileUtils.copyFileToDirectory( appMfFile, metaInfDir);
1:3bece4b:         }
1:3bece4b:     }
1:6d61cef:     
1:6d61cef:     /**
1:6d61cef:      * Return artifacts in 'compile' or 'runtime' scope only.   
1:6d61cef:      */
1:6d61cef:     private Set<Artifact> selectArtifacts(Set<Artifact> artifacts) 
1:6d61cef:     {
1:6d61cef:         Set<Artifact> selected = new LinkedHashSet<Artifact>();
1:6d61cef:         for (Artifact artifact : artifacts) {
1:6d61cef:             String scope = artifact.getScope();
1:6d61cef:             if (scope == null 
1:6d61cef:                 || Artifact.SCOPE_COMPILE.equals(scope)
1:6d61cef:                 || Artifact.SCOPE_RUNTIME.equals(scope)) {
1:6d61cef:                 selected.add(artifact);
1:6d61cef:             }
1:6d61cef:         }
1:6d61cef:         return selected;
1:6d61cef:     }
1:3bece4b: }
============================================================================
author:Graham Charters
-------------------------------------------------------------------------------
commit:b95d944
/////////////////////////////////////////////////////////////////////////
1:             if (useTransitiveDependencies || "all".equals(archiveContent)) {
commit:9e91704
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Define which bundles to include in the archive.
1:      *   none - no bundles are included 
1:      *   applicationContent - direct dependencies go into the content
1:      *   all - direct and transitive dependencies go into the content 
1:      *
1:      * @parameter expression="${archiveContent}" default-value="applicationContent"
1:      */
1:     private String archiveContent;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (archiveContent == null) {
1:         	archiveContent = new String("applicationContent");
1:         }
1:         
1:         getLog().debug( "archiveContent[" + archiveContent + "]" );        
1:         getLog().info( "archiveContent[" + archiveContent + "]" );        
1:         
/////////////////////////////////////////////////////////////////////////
1:             Set<Artifact> artifacts = null;
1:                 // if use transitive is set (i.e. true) then we need to make sure archiveContent does not contradict (i.e. is set
1:                 // to the same compatible value or is the default).
1:             	if ("none".equals(archiveContent)) {
1:                     throw new MojoExecutionException("<useTransitiveDependencies/> and <archiveContent/> incompatibly configured.  <useTransitiveDependencies/> is deprecated in favor of <archiveContent/>." );            		
1:             	}
1:             	else {
1:                     artifacts = project.getArtifacts();            		
1:             	}
1:             	// check that archiveContent is compatible
1:             	if ("applicationContent".equals(archiveContent)) {
1:                     artifacts = project.getDependencyArtifacts();            		
1:             	}
1:             	else {
1:                 	// the only remaining options should be applicationContent="none"
1:                     getLog().info("archiveContent=none: application arvhive will not contain any bundles.");            		
1:             	}
1:             if (artifacts != null) {
1:                 for (Artifact artifact : artifacts) {
1:                     ScopeArtifactFilter filter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME);
1:                     if (!artifact.isOptional() && filter.include(artifact)) {
1:                         getLog().info("Copying artifact[" + artifact.getGroupId() + ", " + artifact.getId() + ", " +
1:                                 artifact.getScope() + "]");
1:                         zipArchiver.addFile(artifact.getFile(), artifact.getArtifactId() + "-" + artifact.getVersion() + "." + (artifact.getType() == null ? "jar" : artifact.getType()));
1:                     }
1:                 }            	
/////////////////////////////////////////////////////////////////////////
1:             throw new NullPointerException("Application manifest file location not set.  Use <generateManifest>true</generateManifest> if you want it to be generated.");
commit:a68eb1d
/////////////////////////////////////////////////////////////////////////
1:     private static final String APPLICATION_USEBUNDLE = "Use-Bundle";
/////////////////////////////////////////////////////////////////////////
1: 			if (instructions.containsKey(APPLICATION_USEBUNDLE)) {
1: 				FileUtils.fileAppend(fileName, APPLICATION_USEBUNDLE + ": "
1: 						+ instructions.get(APPLICATION_USEBUNDLE) + "\n");
1: 			}
1:                         // Add any use bundle entry
commit:3b91bb3
commit:4511e38
/////////////////////////////////////////////////////////////////////////
1: 		if (instructions.containsKey(APPLICATION_SYMBOLICNAME)) {
1: 			return instructions.get(APPLICATION_SYMBOLICNAME).toString();
1: 		}
commit:521fd4c
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedHashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     private static final String MANIFEST_VERSION = "Manifest-Version";
1:     private static final String APPLICATION_MANIFESTVERSION = "Application-ManifestVersion";
1:     private static final String APPLICATION_SYMBOLICNAME = "Application-SymbolicName";
1:     private static final String APPLICATION_VERSION = "Application-Version";
1:     private static final String APPLICATION_NAME = "Application-Name";
1:     private static final String APPLICATION_DESCRIPTION = "Application-Description";
1:     private static final String APPLICATION_CONTENT = "Application-Content";
1:     private static final String APPLICATION_EXPORTSERVICE = "Application-ExportService";
1:     private static final String APPLICATION_IMPORTSERVICE = "Application-ImportService";
/////////////////////////////////////////////////////////////////////////
1:      * Configuration for the plugin.
1:      * @parameter
1:     private Map instructions = new LinkedHashMap();;    
1:     
/////////////////////////////////////////////////////////////////////////
1: 			FileUtils.fileAppend(fileName, MANIFEST_VERSION + ": " + "1" + "\n");
1: 			FileUtils.fileAppend(fileName, APPLICATION_MANIFESTVERSION + ": " + "1" + "\n");
1: 			FileUtils.fileAppend(fileName, APPLICATION_SYMBOLICNAME + ": "
1: 			FileUtils.fileAppend(fileName, APPLICATION_VERSION + ": "
1: 			FileUtils.fileAppend(fileName, APPLICATION_NAME + ": " + project.getName() + "\n");
1: 			FileUtils.fileAppend(fileName, APPLICATION_DESCRIPTION + ": "
/////////////////////////////////////////////////////////////////////////
1: 			FileUtils.fileAppend(fileName, APPLICATION_CONTENT + ": ");
/////////////////////////////////////////////////////////////////////////
1: 			if (instructions.containsKey(APPLICATION_EXPORTSERVICE)) {
1: 				FileUtils.fileAppend(fileName, APPLICATION_EXPORTSERVICE + ": "
1: 						+ instructions.get(APPLICATION_EXPORTSERVICE) + "\n");
1: 			if (instructions.containsKey(APPLICATION_IMPORTSERVICE)) {
1: 				FileUtils.fileAppend(fileName, APPLICATION_IMPORTSERVICE + ": "
1: 						+ instructions.get(APPLICATION_IMPORTSERVICE) + "\n");
commit:3ef076f
commit:58e1079
/////////////////////////////////////////////////////////////////////////
1: import org.apache.maven.shared.osgi.DefaultMaven2OsgiConverter;
1: import org.apache.maven.shared.osgi.Maven2OsgiConverter;
1: import aQute.lib.osgi.Analyzer;
/////////////////////////////////////////////////////////////////////////
1: 
1:     
1: 	public static final String APPLICATION_MF_URI = "META-INF/APPLICATION.MF";
1:      * Application manifest headers
1:      */
0:     private static final String MANIFEST_VERSION = "Manifest-Version: ";
0:     private static final String APPLICATION_MANIFESTVERSION = "Application-ManifestVersion: ";
0:     private static final String APPLICATION_SYMBOLICNAME = "Application-SymbolicName: ";
0:     private static final String APPLICATION_VERSION = "Application-Version: ";
0:     private static final String APPLICATION_NAME = "Application-Name: ";
0:     private static final String APPLICATION_DESCRIPTION = "Application-Description: ";
0:     private static final String APPLICATION_CONTENT = "Application-Content: ";
0:     private static final String APPLICATION_EXPORTSERVICE = "Application-ExportService: ";
0:     private static final String APPLICATION_IMPORTSERVICE = "Application-ImportService: ";
1: 
1:     /**
1:      * Coverter for maven pom values to OSGi manifest values (pulled in from the maven-bundle-plugin)
1:      */
1:     private Maven2OsgiConverter maven2OsgiConverter = new DefaultMaven2OsgiConverter();
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * The location of the APPLICATION.MF file to be used within the eba file.
1:      * @parameter expression="${basedir}/src/main/eba/META-INF/APPLICATION.MF"
/////////////////////////////////////////////////////////////////////////
1:      * Whether to generate a manifest based on maven configuration.
1:      *
1:      * @parameter expression="${generateManifest}" default-value="false"
1:      */
1:     private boolean generateManifest;
1: 
1:     /**
0:      * Any service exports to add to a generated manifest.
1:      *
0:      * @parameter expression="${serviceExports}"
1:      */
0:     private String serviceExports;
1: 
1:     /**
0:      * Any service imports to add to a generated manifest.
1:      *
0:      * @parameter expression="${serviceImports}"
1:      */
0:     private String serviceImports;
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         getLog().debug( "generateManifest[" + generateManifest + "]" );
/////////////////////////////////////////////////////////////////////////
1:             if (!generateManifest) {
1:             	includeCustomApplicationManifestFile();
1:             }
1:             throw new MojoExecutionException( "Error copying APPLICATION.MF file", e );
1: 		// Generate application manifest if requested
1: 		if (generateManifest) {
1: 			String fileName = new String(getBuildDir() + "/"
1: 					+ APPLICATION_MF_URI);
1: 			File appMfFile = new File(fileName);
1: 
1: 			try {
1: 				// Delete any old manifest
1: 				if (appMfFile.exists()) {
1: 					FileUtils.fileDelete(fileName);
1: 				}
1: 
1: 				appMfFile.getParentFile().mkdirs();
1: 				if (appMfFile.createNewFile()) {
1: 					writeApplicationManifest(fileName);
1: 				}
1: 			} catch (java.io.IOException e) {
1: 				throw new MojoExecutionException(
1: 						"Error generating APPLICATION.MF file: " + fileName, e);
1: 			}
1: 		}
1:         
1:                 "Application manifest: " + ddFile.getAbsolutePath() + " does not exist." );
/////////////////////////////////////////////////////////////////////////
1: 	private void writeApplicationManifest(String fileName)
1: 			throws MojoExecutionException {
1: 		try {
1: 			// TODO: add support for dependency version ranges. Need to pick
1: 			// them up from the pom and convert them to OSGi version ranges.
0: 			FileUtils.fileAppend(fileName, MANIFEST_VERSION + "1" + "\n");
0: 			FileUtils.fileAppend(fileName, APPLICATION_MANIFESTVERSION + "1" + "\n");
0: 			FileUtils.fileAppend(fileName, APPLICATION_SYMBOLICNAME
1: 					+ getApplicationSymbolicName(project.getArtifact()) + "\n");
0: 			FileUtils.fileAppend(fileName, APPLICATION_VERSION
0: 					+ aQute.lib.osgi.Analyzer.cleanupVersion(project.getVersion()) + "\n");
0: //					+ maven2OsgiConverter.getVersion(project.getVersion()) + "\n");
0: 			FileUtils.fileAppend(fileName, APPLICATION_NAME + project.getName() + "\n");
0: 			FileUtils.fileAppend(fileName, APPLICATION_DESCRIPTION
1: 					+ project.getDescription() + "\n");
1: 
1: 			// Write the APPLICATION-CONTENT
1: 			// TODO: check that the dependencies are bundles (currently, the converter
1: 			// will throw an exception)
1: 			Set<Artifact> artifacts;
1: 			if (useTransitiveDependencies) {
1: 				artifacts = project.getArtifacts();
1: 			} else {
1: 				artifacts = project.getDependencyArtifacts();
1: 			}
1: 			Iterator<Artifact> iter = artifacts.iterator();
1: 
0: 			FileUtils.fileAppend(fileName, APPLICATION_CONTENT);
1: 			if (iter.hasNext()) {
1: 				Artifact artifact = iter.next();
1: 				FileUtils.fileAppend(fileName, maven2OsgiConverter
1: 						.getBundleSymbolicName(artifact)
1: 						+ ";version=\""
0: 						+ aQute.lib.osgi.Analyzer.cleanupVersion(artifact.getVersion())
1: //						+ maven2OsgiConverter.getVersion(artifact.getVersion())
1: 						+ "\"");
1: 			}
1: 			while (iter.hasNext()) {
1: 				Artifact artifact = iter.next();
1: 				FileUtils.fileAppend(fileName, ",\n "
1: 						+ maven2OsgiConverter.getBundleSymbolicName(artifact)
1: 						+ ";version=\""
0: 						+ aQute.lib.osgi.Analyzer.cleanupVersion(artifact.getVersion())
1: //						+ maven2OsgiConverter.getVersion(artifact.getVersion())
1: 						+ "\"");
1: 			}
1: 
1: 			FileUtils.fileAppend(fileName, "\n");
1: 
1: 			// Add any service imports or exports
0: 			if (serviceExports != null) {
0: 				FileUtils.fileAppend(fileName, APPLICATION_EXPORTSERVICE
0: 						+ serviceExports + "\n");
1: 			}
0: 			if (serviceImports != null) {
0: 				FileUtils.fileAppend(fileName, APPLICATION_IMPORTSERVICE
0: 						+ serviceImports + "\n");
1: 			}
1: 
1: 		} catch (Exception e) {
1: 			throw new MojoExecutionException(
1: 					"Error writing dependencies into APPLICATION.MF", e);
1: 		}
1: 
1: 	}
1:     
1:     // The maven2OsgiConverter assumes the artifact is a jar so we need our own
1: 	// This uses the same fallback scheme as the converter
1:     private String getApplicationSymbolicName(Artifact artifact) {
1:     	return artifact.getGroupId() + "." + artifact.getArtifactId();
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:             getLog().info( "Using APPLICATION.MF "+ applicationManifestFile);
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:e2c47f0
/////////////////////////////////////////////////////////////////////////
1: 					+ getApplicationVersion() + "\n");
/////////////////////////////////////////////////////////////////////////
1:     private String getApplicationVersion() {
1:         if (instructions.containsKey(APPLICATION_VERSION)) {
1:             return instructions.get(APPLICATION_VERSION).toString();
1:         }
1:         return aQute.lib.osgi.Analyzer.cleanupVersion(project.getVersion());
1:     }
1:     
commit:3f25446
/////////////////////////////////////////////////////////////////////////
1:      * @component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
commit:6d61cef
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedHashSet;
/////////////////////////////////////////////////////////////////////////
1: 			artifacts = selectArtifacts(artifacts);
/////////////////////////////////////////////////////////////////////////
1: 						+ Analyzer.cleanupVersion(artifact.getVersion())
/////////////////////////////////////////////////////////////////////////
1: 						+ Analyzer.cleanupVersion(artifact.getVersion())
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return artifacts in 'compile' or 'runtime' scope only.   
1:      */
1:     private Set<Artifact> selectArtifacts(Set<Artifact> artifacts) 
1:     {
1:         Set<Artifact> selected = new LinkedHashSet<Artifact>();
1:         for (Artifact artifact : artifacts) {
1:             String scope = artifact.getScope();
1:             if (scope == null 
1:                 || Artifact.SCOPE_COMPILE.equals(scope)
1:                 || Artifact.SCOPE_RUNTIME.equals(scope)) {
1:                 selected.add(artifact);
1:             }
1:         }
1:         return selected;
1:     }
author:David Jencks
-------------------------------------------------------------------------------
commit:1705c08
commit:dcad9e9
/////////////////////////////////////////////////////////////////////////
1:      * @parameter expression="${includeEmptyDirs}" default-value="true"
1:      * @parameter expression="${forceCreation}" default-value="false"
1:     /**
1:      * Whether to follow transitive dependencies or use explicit dependencies.
1:      *
1:      * @parameter expression="${useTransitiveDependencies}" default-value="false"
1:      */
1:     private boolean useTransitiveDependencies;
1: 
/////////////////////////////////////////////////////////////////////////
0:             Set<Artifact> artifacts;
0:             if (useTransitiveDependencies) {
0:                 artifacts = project.getArtifacts();
1:             } else {
0:                 artifacts = project.getDependencyArtifacts();
1:             }
0:             for (Artifact artifact : artifacts) {
0:                 ScopeArtifactFilter filter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME);
0:                 if (!artifact.isOptional() && filter.include(artifact)) {
0:                             artifact.getScope() + "]");
0:                     zipArchiver.addFile(artifact.getFile(), artifact.getArtifactId() + "-" + artifact.getVersion() + "." + (artifact.getType() == null ? "jar" : artifact.getType()));
commit:e1f2a07
/////////////////////////////////////////////////////////////////////////
1: import org.apache.maven.archiver.PomPropertiesUtil;
1: import org.apache.maven.artifact.Artifact;
1: import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
1: import org.codehaus.plexus.archiver.zip.ZipArchiver;
1: import org.codehaus.plexus.util.FileUtils;
/////////////////////////////////////////////////////////////////////////
0:      * @parameter expression="${component.org.codehaus.plexus.archiver.Archiver#zip}"
1:      * @required
1:     private ZipArchiver zipArchiver;
1:      * Adding pom.xml and pom.properties to the archive.
1:      * @parameter expression="${addMavenDescriptor}" default-value="true"
1:     private boolean addMavenDescriptor;
1: 
1:     /**
1:      * Include or not empty directories
1:      *
0:      * @parameter expression="${zip.includeEmptyDirs}" default-value="true"
1:      */
1:     private boolean includeEmptyDirs;
1: 
1:     /**
1:      * Whether creating the archive should be forced.
1:      *
0:      * @parameter expression="${zip.forceCreation}" default-value="false"
1:      */
1:     private boolean forceCreation;
/////////////////////////////////////////////////////////////////////////
1:         zipArchiver.setIncludeEmptyDirs( includeEmptyDirs );
1:         zipArchiver.setCompress( true );
1:         zipArchiver.setForced( forceCreation );
/////////////////////////////////////////////////////////////////////////
1:                     zipArchiver.addFile(generatedJarFile, finalName + ".jar");
/////////////////////////////////////////////////////////////////////////
0:                     zipArchiver.addFile(artifact.getFile(), artifact.getArtifactId() + "-" + artifact.getVersion() + "." + (artifact.getType() == null? "jar": artifact.getType()));
/////////////////////////////////////////////////////////////////////////
1:             if (addMavenDescriptor) {
1:                 if (project.getArtifact().isSnapshot()) {
1:                     project.setVersion(project.getArtifact().getVersion());
1:                 }
1:                 String groupId = project.getGroupId();
1: 
1:                 String artifactId = project.getArtifactId();
1: 
1:                 zipArchiver.addFile(project.getFile(), "META-INF/maven/" + groupId + "/" + artifactId + "/pom.xml");
1:                 PomPropertiesUtil pomPropertiesUtil = new PomPropertiesUtil();
1:                 File dir = new File(project.getBuild().getDirectory(), "maven-zip-plugin");
1:                 File pomPropertiesFile = new File(dir, "pom.properties");
1:                 pomPropertiesUtil.createPomProperties(project, zipArchiver, pomPropertiesFile, forceCreation);
1:             }
1:             File ebaFile = new File( outputDirectory, finalName + ".eba" );
1:             zipArchiver.setDestFile(ebaFile);
1:                 zipArchiver.addDirectory(buildDir);
1:                 zipArchiver.addDirectory(sharedResourcesDir);
1:             zipArchiver.createArchive();
/////////////////////////////////////////////////////////////////////////
commit:a5742c5
/////////////////////////////////////////////////////////////////////////
1: import org.codehaus.plexus.archiver.ArchiverException;
/////////////////////////////////////////////////////////////////////////
0:                     jarArchiver.addFile(generatedJarFile, finalName + ".jar");
1:         catch ( ArchiverException e )
1:             throw new MojoExecutionException( "Error adding generated Jar file", e );
1: 
/////////////////////////////////////////////////////////////////////////
0:                     jarArchiver.addFile(artifact.getFile(), artifact.getArtifactId() + "-" + artifact.getVersion() + "." + (artifact.getType() == null? "jar": artifact.getType()));
1:         catch ( ArchiverException e )
/////////////////////////////////////////////////////////////////////////
1:             File buildDir = getBuildDir();
1:             if (buildDir.isDirectory()) {
0:                 jarArchiver.addDirectory(buildDir);
1:             }
commit:9c0f809
/////////////////////////////////////////////////////////////////////////
1:      * Directory that remote-resources puts legal files.
1:      *
1:      * @parameter expression="${project.build.directory}/maven-shared-archive-resources"
1:      * @required
1:      */
1:     private String sharedResources;
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:             jarArchiver.addDirectory( getBuildDir() );
1:             //include legal files if any
1:             File sharedResourcesDir = new File(sharedResources);
1:             if (sharedResourcesDir.isDirectory()) {
0:                 jarArchiver.addDirectory(sharedResourcesDir);
1:             }
commit:3bece4b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.plugin.eba;
1: 
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *  http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: import org.apache.maven.plugin.AbstractMojo;
1: import org.apache.maven.plugin.MojoExecutionException;
0: import org.apache.maven.archiver.MavenArchiver;
0: import org.apache.maven.archiver.MavenArchiveConfiguration;
1: import org.apache.maven.project.MavenProject;
0: import org.apache.maven.artifact.Artifact;
0: import org.codehaus.plexus.archiver.jar.JarArchiver;
0: import org.codehaus.plexus.util.FileUtils;
1: import org.codehaus.plexus.util.DirectoryScanner;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.util.Iterator;
1: import java.util.Set;
0: import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
1: 
1: /**
1:  * Builds Aries Enterprise Bundle Archive (eba) files.
1:  *
1:  * @version $Id: $
1:  * @goal eba
1:  * @phase package
1:  * @requiresDependencyResolution test
1:  */
1: public class EbaMojo
1:     extends AbstractMojo
1: {
0:     public static final String APPLICATION_MF_URI = "META-INF/application.mf";
1: 
1:     private static final String[] DEFAULT_INCLUDES = {"**/**"};
1: 
1:     /**
1:      * Single directory for extra files to include in the eba.
1:      *
1:      * @parameter expression="${basedir}/src/main/eba"
1:      * @required
1:      */
1:     private File ebaSourceDirectory;
1: 
1:     /**
0:      * The location of the application.mf file to be used within the eba file.
1:      *
0:      * @parameter expression="${basedir}/src/main/eba/META-INF/application.mf"
1:      */
1:     private File applicationManifestFile;
1: 
1:     /**
1:      * Specify if the generated jar file of this project should be
1:      * included in the eba file ; default is true.
1:      *
1:      * @parameter
1:      */
1:     private Boolean includeJar = Boolean.TRUE;
1: 
1:     /**
1:      * The location of the manifest file to be used within the eba file.
1:      *
1:      * @parameter expression="${basedir}/src/main/eba/META-INF/MANIFEST.MF"
1:      */
1:     private File manifestFile;
1: 
1:     /**
1:      * Directory that resources are copied to during the build.
1:      *
1:      * @parameter expression="${project.build.directory}/${project.build.finalName}"
1:      * @required
1:      */
1:     private String workDirectory;
1: 
1:     /**
1:      * The directory for the generated eba.
1:      *
1:      * @parameter expression="${project.build.directory}"
1:      * @required
1:      */
1:     private String outputDirectory;
1: 
1:     /**
1:      * The name of the eba file to generate.
1:      *
1:      * @parameter alias="ebaName" expression="${project.build.finalName}"
1:      * @required
1:      */
1:     private String finalName;
1: 
1:     /**
1:      * The maven project.
1:      *
1:      * @parameter expression="${project}"
1:      * @required
1:      * @readonly
1:      */
1:     private MavenProject project;
1: 
1:     /**
1:      * The Jar archiver.
1:      *
0:      * @component role="org.codehaus.plexus.archiver.Archiver" roleHint="jar"
1:      */
0:     private JarArchiver jarArchiver;
1: 
1:     /**
0:      * The archive configuration to use.
0:      * See <a href="http://maven.apache.org/shared/maven-archiver/index.html">Maven Archiver Reference</a>.
1:      *
1:      * @parameter
1:      */
0:     private MavenArchiveConfiguration archive = new MavenArchiveConfiguration();
1: 
1: 
1:     private File buildDir;
1: 
1: 
1:     public void execute()
1:         throws MojoExecutionException
1:     {
1:         getLog().debug( " ======= EbaMojo settings =======" );
1:         getLog().debug( "ebaSourceDirectory[" + ebaSourceDirectory + "]" );
1:         getLog().debug( "manifestFile[" + manifestFile + "]" );
1:         getLog().debug( "applicationManifestFile[" + applicationManifestFile + "]" );
1:         getLog().debug( "workDirectory[" + workDirectory + "]" );
1:         getLog().debug( "outputDirectory[" + outputDirectory + "]" );
1:         getLog().debug( "finalName[" + finalName + "]" );
1: 
1:         // Check if jar file is there and if requested, copy it
1:         try
1:         {
1:             if (includeJar.booleanValue()) {
1:                 File generatedJarFile = new File( outputDirectory, finalName + ".jar" );
1:                 if (generatedJarFile.exists()) {
1:                     getLog().info( "Including generated jar file["+generatedJarFile.getName()+"]");
0:                     FileUtils.copyFileToDirectory( generatedJarFile, getBuildDir());
1:                 }
1:             }
1:         }
1:         catch ( IOException e )
1:         {
0:             throw new MojoExecutionException( "Error copying generated Jar file", e );
1:         }
1: 
1:         // Copy dependencies
1:         try
1:         {
0:             Set artifacts = project.getArtifacts();
0:             for ( Iterator iter = artifacts.iterator(); iter.hasNext(); )
1:             {
0:                 Artifact artifact = (Artifact) iter.next();
1: 
0:                 ScopeArtifactFilter filter = new ScopeArtifactFilter( Artifact.SCOPE_RUNTIME );
0:                 if ( !artifact.isOptional() && filter.include( artifact ) )
1:                 {
0:                     getLog().info("Copying artifact[" + artifact.getGroupId() + ", " + artifact.getId() + ", " +
0:                         artifact.getScope() + "]");
0:                     FileUtils.copyFileToDirectory( artifact.getFile(), getBuildDir() );
1:                 }
1:             }
1:         }
1:         catch ( IOException e )
1:         {
1:             throw new MojoExecutionException( "Error copying EBA dependencies", e );
1:         }
1: 
1:         // Copy source files
1:         try
1:         {
1:             File ebaSourceDir = ebaSourceDirectory;
1:             if ( ebaSourceDir.exists() )
1:             {
1:                 getLog().info( "Copy eba resources to " + getBuildDir().getAbsolutePath() );
1: 
1:                 DirectoryScanner scanner = new DirectoryScanner();
1:                 scanner.setBasedir( ebaSourceDir.getAbsolutePath() );
1:                 scanner.setIncludes( DEFAULT_INCLUDES );
1:                 scanner.addDefaultExcludes();
1:                 scanner.scan();
1: 
1:                 String[] dirs = scanner.getIncludedDirectories();
1: 
1:                 for ( int j = 0; j < dirs.length; j++ )
1:                 {
1:                     new File( getBuildDir(), dirs[j] ).mkdirs();
1:                 }
1: 
1:                 String[] files = scanner.getIncludedFiles();
1: 
1:                 for ( int j = 0; j < files.length; j++ )
1:                 {
1:                     File targetFile = new File( getBuildDir(), files[j] );
1: 
1:                     targetFile.getParentFile().mkdirs();
1: 
1:                     File file = new File( ebaSourceDir, files[j] );
1:                     FileUtils.copyFileToDirectory( file, targetFile.getParentFile() );
1:                 }
1:             }
1:         }
1:         catch ( Exception e )
1:         {
1:             throw new MojoExecutionException( "Error copying EBA resources", e );
1:         }
1: 
1:         // Include custom manifest if necessary
1:         try
1:         {
0:             includeCustomApplicationManifestFile();
1:         }
1:         catch ( IOException e )
1:         {
0:             throw new MojoExecutionException( "Error copying application.mf file", e );
1:         }
1: 
1:         // Check if connector deployment descriptor is there
1:         File ddFile = new File( getBuildDir(), APPLICATION_MF_URI);
1:         if ( !ddFile.exists() )
1:         {
1:             getLog().warn(
0:                 "eba deployment descriptor: " + ddFile.getAbsolutePath() + " does not exist." );
1:         }
1: 
1:         try
1:         {
0:             File ebaFile = new File( outputDirectory, finalName + ".eba" );
0:             MavenArchiver archiver = new MavenArchiver();
0:             archiver.setArchiver( jarArchiver );
0:             archiver.setOutputFile( ebaFile );
1: 
1:             // Include custom manifest if necessary
0:             includeCustomManifestFile();
1: 
0:             archiver.getArchiver().addDirectory( getBuildDir() );
0:             archiver.createArchive( project, archive );
1: 
1:             project.getArtifact().setFile( ebaFile );
1:         }
1:         catch ( Exception e )
1:         {
1:             throw new MojoExecutionException( "Error assembling eba", e );
1:         }
1:     }
1: 
1:     protected File getBuildDir()
1:     {
1:         if ( buildDir == null )
1:         {
1:             buildDir = new File( workDirectory );
1:         }
1:         return buildDir;
1:     }
1: 
0:     private void includeCustomManifestFile()
1:         throws IOException
1:     {
0:         File customManifestFile = manifestFile;
0:         if ( !customManifestFile.exists() )
1:         {
0:             getLog().info( "Could not find manifest file: " + manifestFile +" - Generating one");
1:         }
0:         else
1:         {
0:             getLog().info( "Including custom manifest file[" + customManifestFile + "]" );
0:             archive.setManifestFile( customManifestFile );
1:             File metaInfDir = new File(getBuildDir(), "META-INF");
0:             FileUtils.copyFileToDirectory( customManifestFile, metaInfDir );
1:         }
1:     }
1: 
1:     private void includeCustomApplicationManifestFile()
1:         throws IOException
1:     {
1:         if (applicationManifestFile == null) {
0:             throw new NullPointerException("application manifest file location not set");
1:         }
1:         File appMfFile = applicationManifestFile;
1:         if (appMfFile.exists()) {
0:             getLog().info( "Using application.mf "+ applicationManifestFile);
1:             File metaInfDir = new File(getBuildDir(), "META-INF");
1:             FileUtils.copyFileToDirectory( appMfFile, metaInfDir);
1:         }
1:     }
1: }
============================================================================