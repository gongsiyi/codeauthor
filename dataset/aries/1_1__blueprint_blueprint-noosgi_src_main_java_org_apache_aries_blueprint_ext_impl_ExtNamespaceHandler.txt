1:28d2e82: /**
1:28d2e82:  * Licensed to the Apache Software Foundation (ASF) under one
1:28d2e82:  * or more contributor license agreements.  See the NOTICE file
1:28d2e82:  * distributed with this work for additional information
1:28d2e82:  * regarding copyright ownership.  The ASF licenses this file
1:28d2e82:  * to you under the Apache License, Version 2.0 (the
1:28d2e82:  * "License"); you may not use this file except in compliance
1:28d2e82:  * with the License.  You may obtain a copy of the License at
1:28d2e82:  *
1:28d2e82:  *   http://www.apache.org/licenses/LICENSE-2.0
1:28d2e82:  *
1:28d2e82:  * Unless required by applicable law or agreed to in writing,
1:28d2e82:  * software distributed under the License is distributed on an
1:28d2e82:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:28d2e82:  * KIND, either express or implied.  See the License for the
1:28d2e82:  * specific language governing permissions and limitations
1:28d2e82:  * under the License.
1:28d2e82:  */
1:28d2e82: package org.apache.aries.blueprint.ext.impl;
1:28d2e82: 
1:bd82987: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:bd82987: import org.apache.aries.blueprint.ExtendedBeanMetadata;
1:28d2e82: import org.apache.aries.blueprint.ExtendedReferenceListMetadata;
1:28d2e82: import org.apache.aries.blueprint.ParserContext;
1:bd82987: import org.apache.aries.blueprint.ext.AbstractPropertyPlaceholder;
1:28d2e82: import org.apache.aries.blueprint.ext.PlaceholdersUtils;
1:28d2e82: import org.apache.aries.blueprint.ext.PropertyPlaceholder;
1:28d2e82: import org.apache.aries.blueprint.ext.evaluator.PropertyEvaluator;
1:28d2e82: import org.apache.aries.blueprint.mutable.*;
1:28d2e82: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:28d2e82: import org.osgi.service.blueprint.reflect.*;
1:28d2e82: import org.slf4j.Logger;
1:28d2e82: import org.slf4j.LoggerFactory;
1:28d2e82: import org.w3c.dom.*;
1:28d2e82: import org.w3c.dom.CharacterData;
1:28d2e82: 
1:28d2e82: import java.net.URL;
1:28d2e82: import java.util.*;
1:28d2e82: 
1:28d2e82: /**
1:28d2e82:  * A namespace handler for Aries blueprint extensions
1:28d2e82:  *
1:28d2e82:  * @version $Rev$, $Date$
1:28d2e82:  */
1:28d2e82: public class ExtNamespaceHandler implements org.apache.aries.blueprint.NamespaceHandler {
1:28d2e82: 
1:28d2e82:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
1:28d2e82:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_0 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0";
1:28d2e82:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_1 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.1.0";
1:28d2e82:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_2 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.2.0";
1:28d2e82:     
1:28d2e82:     public static final String PROPERTY_PLACEHOLDER_ELEMENT = "property-placeholder";
1:28d2e82:     public static final String DEFAULT_PROPERTIES_ELEMENT = "default-properties";
1:28d2e82:     public static final String PROPERTY_ELEMENT = "property";
1:28d2e82:     public static final String VALUE_ELEMENT = "value";
1:28d2e82:     public static final String LOCATION_ELEMENT = "location";
1:28d2e82: 
1:28d2e82:     public static final String ID_ATTRIBUTE = "id";
1:28d2e82:     public static final String PLACEHOLDER_PREFIX_ATTRIBUTE = "placeholder-prefix";
1:28d2e82:     public static final String PLACEHOLDER_SUFFIX_ATTRIBUTE = "placeholder-suffix";
1:28d2e82:     public static final String DEFAULTS_REF_ATTRIBUTE = "defaults-ref";
1:28d2e82:     public static final String IGNORE_MISSING_LOCATIONS_ATTRIBUTE = "ignore-missing-locations";
1:28d2e82:     public static final String EVALUATOR_ATTRIBUTE = "evaluator";
1:28d2e82: 
1:28d2e82:     public static final String SYSTEM_PROPERTIES_ATTRIBUTE = "system-properties";
1:28d2e82:     public static final String SYSTEM_PROPERTIES_NEVER = "never";
1:28d2e82:     public static final String SYSTEM_PROPERTIES_FALLBACK = "fallback";
1:28d2e82:     public static final String SYSTEM_PROPERTIES_OVERRIDE = "override";
1:28d2e82: 
1:28d2e82:     public static final String PROXY_METHOD_ATTRIBUTE = "proxy-method";
1:28d2e82:     public static final String PROXY_METHOD_DEFAULT = "default";
1:28d2e82:     public static final String PROXY_METHOD_CLASSES = "classes";
1:28d2e82:     public static final String PROXY_METHOD_GREEDY = "greedy";
1:28d2e82: 
1:28d2e82:     public static final String ROLE_ATTRIBUTE = "role";
1:28d2e82:     public static final String ROLE_PROCESSOR = "processor";
1:28d2e82:     
1:28d2e82:     public static final String FIELD_INJECTION_ATTRIBUTE = "field-injection";
1:28d2e82:     
1:28d2e82:     public static final String DEFAULT_REFERENCE_BEAN = "default";
1:28d2e82: 
1:28d2e82:     private static final Logger LOGGER = LoggerFactory.getLogger(ExtNamespaceHandler.class);
1:28d2e82: 
1:28d2e82:     private int idCounter;
1:28d2e82:     
1:28d2e82:     public URL getSchemaLocation(String namespace) {
1:28d2e82:         if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(namespace)) {
1:28d2e82:           return getClass().getResource("blueprint-ext.xsd");
1:28d2e82:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_1.equals(namespace)) {
1:28d2e82:           return getClass().getResource("blueprint-ext-1.1.xsd");
1:28d2e82:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_2.equals(namespace)) {
1:28d2e82:           return getClass().getResource("blueprint-ext-1.2.xsd");
1:28d2e82:         } else {
1:28d2e82:           return null;
1:28d2e82:         }
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     public Set<Class> getManagedClasses() {
1:28d2e82:         return new HashSet<Class>(Arrays.asList(
1:28d2e82:                 PropertyPlaceholder.class
1:28d2e82:         ));
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     public Metadata parse(Element element, ParserContext context) {
1:28d2e82:         LOGGER.debug("Parsing element {{}}{}", element.getNamespaceURI(), element.getLocalName());
1:28d2e82:         if (nodeNameEquals(element, PROPERTY_PLACEHOLDER_ELEMENT)) {
1:28d2e82:             return parsePropertyPlaceholder(context, element);
1:28d2e82:         } else {
1:28d2e82:             throw new ComponentDefinitionException("Unsupported element: " + element.getNodeName());
1:28d2e82:         }
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     public ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context) {
1:28d2e82:         if (node instanceof Attr && nodeNameEquals(node, PROXY_METHOD_ATTRIBUTE)) {
1:28d2e82:             return decorateProxyMethod(node, component, context);
1:28d2e82:         } else if (node instanceof Attr && nodeNameEquals(node, ROLE_ATTRIBUTE)) {
1:28d2e82:             return decorateRole(node, component, context);
1:28d2e82:         } else if (node instanceof Attr && nodeNameEquals(node, FIELD_INJECTION_ATTRIBUTE)) {
1:28d2e82:             return decorateFieldInjection(node, component, context);
1:28d2e82:         } else if (node instanceof Attr && nodeNameEquals(node, DEFAULT_REFERENCE_BEAN)) {
1:28d2e82:             return decorateDefaultBean(node, component, context);
1:28d2e82:         } else {
1:28d2e82:             throw new ComponentDefinitionException("Unsupported node: " + node.getNodeName());
1:28d2e82:         }
1:28d2e82:     }
1:28d2e82:     
1:28d2e82:     private ComponentMetadata decorateDefaultBean(Node node,
1:28d2e82:         ComponentMetadata component, ParserContext context) 
1:28d2e82:     {
1:28d2e82:         if (!(component instanceof ReferenceMetadata)) {
1:28d2e82:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> element");
1:28d2e82:         }
1:28d2e82:       
1:28d2e82:         if (!(component instanceof MutableReferenceMetadata)) {
1:28d2e82:             throw new ComponentDefinitionException("Expected an instanceof MutableReferenceMetadata");
1:28d2e82:         }
1:28d2e82:         
1:28d2e82:         String value = ((Attr) node).getValue();
1:28d2e82:         ((MutableReferenceMetadata) component).setDefaultBean(value);
1:28d2e82:         return component;
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private ComponentMetadata decorateFieldInjection(Node node, ComponentMetadata component, ParserContext context) {
1:28d2e82:         if (!(component instanceof BeanMetadata)) {
1:28d2e82:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <bean> element");
1:28d2e82:         }
1:28d2e82:         
1:28d2e82:         if (!(component instanceof MutableBeanMetadata)) {
1:28d2e82:             throw new ComponentDefinitionException("Expected an instanceof MutableBeanMetadata");
1:28d2e82:         }
1:28d2e82:         
1:28d2e82:         String value = ((Attr) node).getValue();
1:28d2e82:         ((MutableBeanMetadata) component).setFieldInjection("true".equals(value) || "1".equals(value));
1:28d2e82:         return component;
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private ComponentMetadata decorateRole(Node node, ComponentMetadata component, ParserContext context) {
1:28d2e82:         if (!(component instanceof BeanMetadata)) {
1:28d2e82:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <bean> element");
1:28d2e82:         }
1:28d2e82:         if (!(component instanceof MutableBeanMetadata)) {
1:28d2e82:             throw new ComponentDefinitionException("Expected an instance of MutableBeanMetadata");
1:28d2e82:         }
1:28d2e82:         boolean processor = false;
1:28d2e82:         String value = ((Attr) node).getValue();
1:28d2e82:         String[] flags = value.trim().split(" ");
1:28d2e82:         for (String flag : flags) {
1:28d2e82:             if (ROLE_PROCESSOR.equals(flag)) {
1:28d2e82:                 processor = true;
1:28d2e82:             } else {
1:28d2e82:                 throw new ComponentDefinitionException("Unknown proxy method: " + flag);
1:28d2e82:             }
1:28d2e82:         }
1:28d2e82:         ((MutableBeanMetadata) component).setProcessor(processor);
1:28d2e82:         return component;
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private ComponentMetadata decorateProxyMethod(Node node, ComponentMetadata component, ParserContext context) {
1:28d2e82:         if (!(component instanceof ServiceReferenceMetadata)) {
1:28d2e82:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> or <reference-list> element");
1:28d2e82:         }
1:28d2e82:         if (!(component instanceof MutableServiceReferenceMetadata)) {
1:28d2e82:             throw new ComponentDefinitionException("Expected an instance of MutableServiceReferenceMetadata");
1:28d2e82:         }
1:28d2e82:         int method = 0;
1:28d2e82:         String value = ((Attr) node).getValue();
1:28d2e82:         String[] flags = value.trim().split(" ");
1:28d2e82:         for (String flag : flags) {
1:28d2e82:             if (PROXY_METHOD_DEFAULT.equals(flag)) {
1:28d2e82:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_DEFAULT;
1:28d2e82:             } else if (PROXY_METHOD_CLASSES.equals(flag)) {
1:28d2e82:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_CLASSES;
1:28d2e82:             } else if (PROXY_METHOD_GREEDY.equals(flag)) {
1:28d2e82:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY;
1:28d2e82:             } else {
1:28d2e82:                 throw new ComponentDefinitionException("Unknown proxy method: " + flag);
1:28d2e82:             }
1:28d2e82:         }
1:28d2e82:         if ((method & ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY) != 0 && !(component instanceof ReferenceListMetadata)) {
1:28d2e82:             throw new ComponentDefinitionException("Greedy proxying is only available for <reference-list> element");
1:28d2e82:         }
1:28d2e82:         ((MutableServiceReferenceMetadata) component).setProxyMethod(method);
1:28d2e82:         return component;
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private Metadata parsePropertyPlaceholder(ParserContext context, Element element) {
1:28d2e82:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:28d2e82:         metadata.setProcessor(true);
1:28d2e82:         metadata.setId(getId(context, element));
1:28d2e82:         metadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:28d2e82:         metadata.setRuntimeClass(PropertyPlaceholder.class);
1:28d2e82:         metadata.setInitMethod("init");
1:28d2e82:         String prefix = element.hasAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:28d2e82:                                     ? element.getAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:28d2e82:                                     : "${";
1:28d2e82:         metadata.addProperty("placeholderPrefix", createValue(context, prefix));
1:28d2e82:         String suffix = element.hasAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:28d2e82:                                     ? element.getAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:28d2e82:                                     : "}";
1:28d2e82:         metadata.addProperty("placeholderSuffix", createValue(context, suffix));
1:28d2e82:         metadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
1:28d2e82:         String defaultsRef = element.hasAttribute(DEFAULTS_REF_ATTRIBUTE) ? element.getAttribute(DEFAULTS_REF_ATTRIBUTE) : null;
1:28d2e82:         if (defaultsRef != null) {
1:28d2e82:             metadata.addProperty("defaultProperties", createRef(context, defaultsRef));
1:28d2e82:         }
1:28d2e82:         String ignoreMissingLocations = element.hasAttribute(IGNORE_MISSING_LOCATIONS_ATTRIBUTE) ? element.getAttribute(IGNORE_MISSING_LOCATIONS_ATTRIBUTE) : null;
1:28d2e82:         if (ignoreMissingLocations != null) {
1:28d2e82:             metadata.addProperty("ignoreMissingLocations", createValue(context, ignoreMissingLocations));
1:28d2e82:         }
1:28d2e82:         String systemProperties = element.hasAttribute(SYSTEM_PROPERTIES_ATTRIBUTE) ? element.getAttribute(SYSTEM_PROPERTIES_ATTRIBUTE) : null;
1:28d2e82:         if (systemProperties != null) {
1:28d2e82:             metadata.addProperty("systemProperties", createValue(context, systemProperties));
1:28d2e82:         }
1:28d2e82:         String evaluator = element.hasAttribute(EVALUATOR_ATTRIBUTE) ? element.getAttribute(EVALUATOR_ATTRIBUTE) : null;
1:28d2e82:         if (evaluator != null) {
1:28d2e82:             throw new IllegalStateException("Evaluators are not supported outside OSGi");
1:28d2e82:         }
1:28d2e82:         // Parse elements
1:28d2e82:         List<String> locations = new ArrayList<String>();
1:28d2e82:         NodeList nl = element.getChildNodes();
1:28d2e82:         for (int i = 0; i < nl.getLength(); i++) {
1:28d2e82:             Node node = nl.item(i);
1:28d2e82:             if (node instanceof Element) {
1:28d2e82:                 Element e = (Element) node;
1:28d2e82:                 if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())
1:28d2e82:                         || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())
1:28d2e82:                         || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e.getNamespaceURI())) {
1:28d2e82:                     if (nodeNameEquals(e, DEFAULT_PROPERTIES_ELEMENT)) {
1:28d2e82:                         if (defaultsRef != null) {
1:28d2e82:                             throw new ComponentDefinitionException("Only one of " + DEFAULTS_REF_ATTRIBUTE + " attribute or " + DEFAULT_PROPERTIES_ELEMENT + " element is allowed");
1:28d2e82:                         }
1:28d2e82:                         Metadata props = parseDefaultProperties(context, metadata, e);
1:28d2e82:                         metadata.addProperty("defaultProperties", props);
1:28d2e82:                     } else if (nodeNameEquals(e, LOCATION_ELEMENT)) {
1:28d2e82:                         locations.add(getTextValue(e));
1:28d2e82:                     }
1:28d2e82:                 }
1:28d2e82:             }
1:28d2e82:         }
1:28d2e82:         if (!locations.isEmpty()) {
1:28d2e82:             metadata.addProperty("locations", createList(context, locations));
1:28d2e82:         }
1:28d2e82: 
1:bd82987:         boolean result = validatePlaceholder(metadata, context.getComponentDefinitionRegistry());
1:28d2e82: 
1:bd82987:         return result ? metadata : null;
1:28d2e82:     }
1:28d2e82: 
1:bd82987:     private boolean validatePlaceholder(MutableBeanMetadata metadata, ComponentDefinitionRegistry registry) {
1:bd82987:         for (String id : registry.getComponentDefinitionNames()) {
1:bd82987:             ComponentMetadata component = registry.getComponentDefinition(id);
1:bd82987:             if (component instanceof ExtendedBeanMetadata) {
1:bd82987:                 ExtendedBeanMetadata bean = (ExtendedBeanMetadata) component;
1:bd82987:                 if (bean.getRuntimeClass() != null && AbstractPropertyPlaceholder.class.isAssignableFrom(bean.getRuntimeClass())) {
1:bd82987:                     if (arePropertiesEquals(bean, metadata, "placeholderPrefix")
1:bd82987:                             && arePropertiesEquals(bean, metadata, "placeholderSuffix")) {
1:bd82987:                         if (!arePropertiesEquals(bean, metadata, "systemProperties")
1:bd82987:                                 || !arePropertiesEquals(bean, metadata, "ignoreMissingLocations")) {
1:bd82987:                             throw new ComponentDefinitionException("Multiple incompatible placeholders found");
1:bd82987:                         }
1:bd82987:                         // Merge both placeholders
1:bd82987:                         mergeList(bean, metadata, "locations");
1:bd82987:                         mergeMap(bean, metadata, "defaultProperties");
1:bd82987:                         return false;
1:bd82987:                     }
1:bd82987:                 }
1:bd82987:             }
1:bd82987:         }
1:bd82987:         return true;
1:bd82987:     }
1:bd82987: 
1:bd82987:     private void mergeList(ExtendedBeanMetadata bean1, MutableBeanMetadata bean2, String name) {
1:bd82987:         Metadata m1 = getProperty(bean1, name);
1:bd82987:         Metadata m2 = getProperty(bean2, name);
1:bd82987:         if (m1 == null && m2 != null) {
1:bd82987:             ((MutableBeanMetadata) bean1).addProperty(name, m2);
1:bd82987:         } else if (m1 != null && m2 != null) {
1:bd82987:             if (!(m1 instanceof MutableCollectionMetadata) || !(m2 instanceof MutableCollectionMetadata)) {
1:bd82987:                 throw new ComponentDefinitionException("Unable to merge " + name + " list properties");
1:bd82987:             }
1:bd82987:             MutableCollectionMetadata c1 = (MutableCollectionMetadata) m1;
1:bd82987:             MutableCollectionMetadata c2 = (MutableCollectionMetadata) m2;
1:bd82987:             for (Metadata v : c2.getValues()) {
1:bd82987:                 c1.addValue(v);
1:bd82987:             }
1:bd82987:         }
1:bd82987:     }
1:bd82987: 
1:bd82987:     private void mergeMap(ExtendedBeanMetadata bean1, MutableBeanMetadata bean2, String name) {
1:bd82987:         Metadata m1 = getProperty(bean1, name);
1:bd82987:         Metadata m2 = getProperty(bean2, name);
1:bd82987:         if (m1 == null && m2 != null) {
1:bd82987:             ((MutableBeanMetadata) bean1).addProperty(name, m2);
1:bd82987:         } else if (m1 != null && m2 != null) {
1:bd82987:             if (!(m1 instanceof MutableMapMetadata) || !(m2 instanceof MutableMapMetadata)) {
1:bd82987:                 throw new ComponentDefinitionException("Unable to merge " + name + " list properties");
1:bd82987:             }
1:bd82987:             MutableMapMetadata c1 = (MutableMapMetadata) m1;
1:bd82987:             MutableMapMetadata c2 = (MutableMapMetadata) m2;
1:bd82987:             for (MapEntry e : c2.getEntries()) {
1:bd82987:                 c1.addEntry(e);
1:bd82987:             }
1:bd82987:         }
1:bd82987:     }
1:bd82987: 
1:bd82987:     private boolean arePropertiesEquals(BeanMetadata bean1, BeanMetadata bean2, String name) {
1:bd82987:         String v1 = getPlaceholderProperty(bean1, name);
1:bd82987:         String v2 = getPlaceholderProperty(bean2, name);
1:bd82987:         return v1 == null ? v2 == null : v1.equals(v2);
1:bd82987:     }
1:bd82987: 
1:bd82987:     private String getPlaceholderProperty(BeanMetadata bean, String name) {
1:bd82987:         Metadata metadata = getProperty(bean, name);
1:bd82987:         if (metadata instanceof ValueMetadata) {
1:bd82987:             return ((ValueMetadata) metadata).getStringValue();
1:bd82987:         }
1:bd82987:         return null;
1:bd82987:     }
1:bd82987: 
1:bd82987:     private Metadata getProperty(BeanMetadata bean, String name) {
1:bd82987:         for (BeanProperty property : bean.getProperties()) {
1:bd82987:             if (name.equals(property.getName())) {
1:bd82987:                 return property.getValue();
1:bd82987:             }
1:bd82987:         }
1:bd82987:         return null;
1:bd82987:     }
1:bd82987: 
1:bd82987: 
1:28d2e82:     private Metadata parseDefaultProperties(ParserContext context, MutableBeanMetadata enclosingComponent, Element element) {
1:28d2e82:         MutableMapMetadata props = context.createMetadata(MutableMapMetadata.class);
1:28d2e82:         NodeList nl = element.getChildNodes();
1:28d2e82:         for (int i = 0; i < nl.getLength(); i++) {
1:28d2e82:             Node node = nl.item(i);
1:28d2e82:             if (node instanceof Element) {
1:28d2e82:                 Element e = (Element) node;
1:28d2e82:                 if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())
1:28d2e82:                         || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())
1:28d2e82:                         || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e.getNamespaceURI())) {
1:28d2e82:                     if (nodeNameEquals(e, PROPERTY_ELEMENT)) {
1:28d2e82:                         BeanProperty prop = context.parseElement(BeanProperty.class, enclosingComponent, e);
1:28d2e82:                         props.addEntry(createValue(context, prop.getName(), String.class.getName()), prop.getValue());
1:28d2e82:                     }
1:28d2e82:                 }
1:28d2e82:             }
1:28d2e82:         }
1:28d2e82:         return props;
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     public String getId(ParserContext context, Element element) {
1:28d2e82:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:28d2e82:             return element.getAttribute(ID_ATTRIBUTE);
1:28d2e82:         } else {
1:28d2e82:             return generateId(context);
1:28d2e82:         }
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     public void generateIdIfNeeded(ParserContext context, MutableComponentMetadata metadata) {
1:28d2e82:         if (metadata.getId() == null) {
1:28d2e82:             metadata.setId(generateId(context));
1:28d2e82:         }
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private String generateId(ParserContext context) {
1:28d2e82:         String id;
1:28d2e82:         do {
1:28d2e82:             id = ".ext-" + ++idCounter;
1:28d2e82:         } while (context.getComponentDefinitionRegistry().containsComponentDefinition(id));
1:28d2e82:         return id;
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private static ValueMetadata createValue(ParserContext context, String value) {
1:28d2e82:         return createValue(context, value, null);
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private static ValueMetadata createValue(ParserContext context, String value, String type) {
1:28d2e82:         MutableValueMetadata m = context.createMetadata(MutableValueMetadata.class);
1:28d2e82:         m.setStringValue(value);
1:28d2e82:         m.setType(type);
1:28d2e82:         return m;
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private static RefMetadata createRef(ParserContext context, String value) {
1:28d2e82:         MutableRefMetadata m = context.createMetadata(MutableRefMetadata.class);
1:28d2e82:         m.setComponentId(value);
1:28d2e82:         return m;
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private static IdRefMetadata createIdRef(ParserContext context, String value) {
1:28d2e82:         MutableIdRefMetadata m = context.createMetadata(MutableIdRefMetadata.class);
1:28d2e82:         m.setComponentId(value);
1:28d2e82:         return m;
1:28d2e82:     }
1:28d2e82:     
1:28d2e82:     private static CollectionMetadata createList(ParserContext context, List<String> list) {
1:28d2e82:         MutableCollectionMetadata m = context.createMetadata(MutableCollectionMetadata.class);
1:28d2e82:         m.setCollectionClass(List.class);
1:28d2e82:         m.setValueType(String.class.getName());
1:28d2e82:         for (String v : list) {
1:28d2e82:             m.addValue(createValue(context, v, String.class.getName()));
1:28d2e82:         }
1:28d2e82:         return m;
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private static String getTextValue(Element element) {
1:28d2e82:         StringBuffer value = new StringBuffer();
1:28d2e82:         NodeList nl = element.getChildNodes();
1:28d2e82:         for (int i = 0; i < nl.getLength(); i++) {
1:28d2e82:             Node item = nl.item(i);
1:28d2e82:             if ((item instanceof CharacterData && !(item instanceof Comment)) || item instanceof EntityReference) {
1:28d2e82:                 value.append(item.getNodeValue());
1:28d2e82:             }
1:28d2e82:         }
1:28d2e82:         return value.toString();
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     private static boolean nodeNameEquals(Node node, String name) {
1:28d2e82:         return (name.equals(node.getNodeName()) || name.equals(node.getLocalName()));
1:28d2e82:     }
1:28d2e82: 
1:28d2e82:     public static boolean isBlueprintNamespace(String ns) {
1:28d2e82:         return BLUEPRINT_NAMESPACE.equals(ns);
1:28d2e82:     }
1:28d2e82: 
1:28d2e82: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:bd82987
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1: import org.apache.aries.blueprint.ExtendedBeanMetadata;
1: import org.apache.aries.blueprint.ext.AbstractPropertyPlaceholder;
/////////////////////////////////////////////////////////////////////////
1:         boolean result = validatePlaceholder(metadata, context.getComponentDefinitionRegistry());
1:         return result ? metadata : null;
1:     private boolean validatePlaceholder(MutableBeanMetadata metadata, ComponentDefinitionRegistry registry) {
1:         for (String id : registry.getComponentDefinitionNames()) {
1:             ComponentMetadata component = registry.getComponentDefinition(id);
1:             if (component instanceof ExtendedBeanMetadata) {
1:                 ExtendedBeanMetadata bean = (ExtendedBeanMetadata) component;
1:                 if (bean.getRuntimeClass() != null && AbstractPropertyPlaceholder.class.isAssignableFrom(bean.getRuntimeClass())) {
1:                     if (arePropertiesEquals(bean, metadata, "placeholderPrefix")
1:                             && arePropertiesEquals(bean, metadata, "placeholderSuffix")) {
1:                         if (!arePropertiesEquals(bean, metadata, "systemProperties")
1:                                 || !arePropertiesEquals(bean, metadata, "ignoreMissingLocations")) {
1:                             throw new ComponentDefinitionException("Multiple incompatible placeholders found");
1:                         }
1:                         // Merge both placeholders
1:                         mergeList(bean, metadata, "locations");
1:                         mergeMap(bean, metadata, "defaultProperties");
1:                         return false;
1:                     }
1:                 }
1:             }
1:         }
1:         return true;
1:     }
1: 
1:     private void mergeList(ExtendedBeanMetadata bean1, MutableBeanMetadata bean2, String name) {
1:         Metadata m1 = getProperty(bean1, name);
1:         Metadata m2 = getProperty(bean2, name);
1:         if (m1 == null && m2 != null) {
1:             ((MutableBeanMetadata) bean1).addProperty(name, m2);
1:         } else if (m1 != null && m2 != null) {
1:             if (!(m1 instanceof MutableCollectionMetadata) || !(m2 instanceof MutableCollectionMetadata)) {
1:                 throw new ComponentDefinitionException("Unable to merge " + name + " list properties");
1:             }
1:             MutableCollectionMetadata c1 = (MutableCollectionMetadata) m1;
1:             MutableCollectionMetadata c2 = (MutableCollectionMetadata) m2;
1:             for (Metadata v : c2.getValues()) {
1:                 c1.addValue(v);
1:             }
1:         }
1:     }
1: 
1:     private void mergeMap(ExtendedBeanMetadata bean1, MutableBeanMetadata bean2, String name) {
1:         Metadata m1 = getProperty(bean1, name);
1:         Metadata m2 = getProperty(bean2, name);
1:         if (m1 == null && m2 != null) {
1:             ((MutableBeanMetadata) bean1).addProperty(name, m2);
1:         } else if (m1 != null && m2 != null) {
1:             if (!(m1 instanceof MutableMapMetadata) || !(m2 instanceof MutableMapMetadata)) {
1:                 throw new ComponentDefinitionException("Unable to merge " + name + " list properties");
1:             }
1:             MutableMapMetadata c1 = (MutableMapMetadata) m1;
1:             MutableMapMetadata c2 = (MutableMapMetadata) m2;
1:             for (MapEntry e : c2.getEntries()) {
1:                 c1.addEntry(e);
1:             }
1:         }
1:     }
1: 
1:     private boolean arePropertiesEquals(BeanMetadata bean1, BeanMetadata bean2, String name) {
1:         String v1 = getPlaceholderProperty(bean1, name);
1:         String v2 = getPlaceholderProperty(bean2, name);
1:         return v1 == null ? v2 == null : v1.equals(v2);
1:     }
1: 
1:     private String getPlaceholderProperty(BeanMetadata bean, String name) {
1:         Metadata metadata = getProperty(bean, name);
1:         if (metadata instanceof ValueMetadata) {
1:             return ((ValueMetadata) metadata).getStringValue();
1:         }
1:         return null;
1:     }
1: 
1:     private Metadata getProperty(BeanMetadata bean, String name) {
1:         for (BeanProperty property : bean.getProperties()) {
1:             if (name.equals(property.getName())) {
1:                 return property.getValue();
1:             }
1:         }
1:         return null;
1:     }
1: 
1: 
commit:28d2e82
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.blueprint.ext.impl;
1: 
1: import org.apache.aries.blueprint.ExtendedReferenceListMetadata;
1: import org.apache.aries.blueprint.ParserContext;
1: import org.apache.aries.blueprint.ext.PlaceholdersUtils;
1: import org.apache.aries.blueprint.ext.PropertyPlaceholder;
1: import org.apache.aries.blueprint.ext.evaluator.PropertyEvaluator;
1: import org.apache.aries.blueprint.mutable.*;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.reflect.*;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: import org.w3c.dom.*;
1: import org.w3c.dom.CharacterData;
1: 
1: import java.net.URL;
1: import java.util.*;
1: 
1: /**
1:  * A namespace handler for Aries blueprint extensions
1:  *
1:  * @version $Rev$, $Date$
1:  */
1: public class ExtNamespaceHandler implements org.apache.aries.blueprint.NamespaceHandler {
1: 
1:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_0 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0";
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_1 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.1.0";
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_2 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.2.0";
1:     
1:     public static final String PROPERTY_PLACEHOLDER_ELEMENT = "property-placeholder";
1:     public static final String DEFAULT_PROPERTIES_ELEMENT = "default-properties";
1:     public static final String PROPERTY_ELEMENT = "property";
1:     public static final String VALUE_ELEMENT = "value";
1:     public static final String LOCATION_ELEMENT = "location";
1: 
1:     public static final String ID_ATTRIBUTE = "id";
1:     public static final String PLACEHOLDER_PREFIX_ATTRIBUTE = "placeholder-prefix";
1:     public static final String PLACEHOLDER_SUFFIX_ATTRIBUTE = "placeholder-suffix";
1:     public static final String DEFAULTS_REF_ATTRIBUTE = "defaults-ref";
1:     public static final String IGNORE_MISSING_LOCATIONS_ATTRIBUTE = "ignore-missing-locations";
1:     public static final String EVALUATOR_ATTRIBUTE = "evaluator";
1: 
1:     public static final String SYSTEM_PROPERTIES_ATTRIBUTE = "system-properties";
1:     public static final String SYSTEM_PROPERTIES_NEVER = "never";
1:     public static final String SYSTEM_PROPERTIES_FALLBACK = "fallback";
1:     public static final String SYSTEM_PROPERTIES_OVERRIDE = "override";
1: 
1:     public static final String PROXY_METHOD_ATTRIBUTE = "proxy-method";
1:     public static final String PROXY_METHOD_DEFAULT = "default";
1:     public static final String PROXY_METHOD_CLASSES = "classes";
1:     public static final String PROXY_METHOD_GREEDY = "greedy";
1: 
1:     public static final String ROLE_ATTRIBUTE = "role";
1:     public static final String ROLE_PROCESSOR = "processor";
1:     
1:     public static final String FIELD_INJECTION_ATTRIBUTE = "field-injection";
1:     
1:     public static final String DEFAULT_REFERENCE_BEAN = "default";
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(ExtNamespaceHandler.class);
1: 
1:     private int idCounter;
1:     
1:     public URL getSchemaLocation(String namespace) {
1:         if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(namespace)) {
1:           return getClass().getResource("blueprint-ext.xsd");
1:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_1.equals(namespace)) {
1:           return getClass().getResource("blueprint-ext-1.1.xsd");
1:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_2.equals(namespace)) {
1:           return getClass().getResource("blueprint-ext-1.2.xsd");
1:         } else {
1:           return null;
1:         }
1:     }
1: 
1:     public Set<Class> getManagedClasses() {
1:         return new HashSet<Class>(Arrays.asList(
1:                 PropertyPlaceholder.class
1:         ));
1:     }
1: 
1:     public Metadata parse(Element element, ParserContext context) {
1:         LOGGER.debug("Parsing element {{}}{}", element.getNamespaceURI(), element.getLocalName());
1:         if (nodeNameEquals(element, PROPERTY_PLACEHOLDER_ELEMENT)) {
1:             return parsePropertyPlaceholder(context, element);
1:         } else {
1:             throw new ComponentDefinitionException("Unsupported element: " + element.getNodeName());
1:         }
1:     }
1: 
1:     public ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context) {
1:         if (node instanceof Attr && nodeNameEquals(node, PROXY_METHOD_ATTRIBUTE)) {
1:             return decorateProxyMethod(node, component, context);
1:         } else if (node instanceof Attr && nodeNameEquals(node, ROLE_ATTRIBUTE)) {
1:             return decorateRole(node, component, context);
1:         } else if (node instanceof Attr && nodeNameEquals(node, FIELD_INJECTION_ATTRIBUTE)) {
1:             return decorateFieldInjection(node, component, context);
1:         } else if (node instanceof Attr && nodeNameEquals(node, DEFAULT_REFERENCE_BEAN)) {
1:             return decorateDefaultBean(node, component, context);
1:         } else {
1:             throw new ComponentDefinitionException("Unsupported node: " + node.getNodeName());
1:         }
1:     }
1:     
1:     private ComponentMetadata decorateDefaultBean(Node node,
1:         ComponentMetadata component, ParserContext context) 
1:     {
1:         if (!(component instanceof ReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> element");
1:         }
1:       
1:         if (!(component instanceof MutableReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instanceof MutableReferenceMetadata");
1:         }
1:         
1:         String value = ((Attr) node).getValue();
1:         ((MutableReferenceMetadata) component).setDefaultBean(value);
1:         return component;
1:     }
1: 
1:     private ComponentMetadata decorateFieldInjection(Node node, ComponentMetadata component, ParserContext context) {
1:         if (!(component instanceof BeanMetadata)) {
1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <bean> element");
1:         }
1:         
1:         if (!(component instanceof MutableBeanMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instanceof MutableBeanMetadata");
1:         }
1:         
1:         String value = ((Attr) node).getValue();
1:         ((MutableBeanMetadata) component).setFieldInjection("true".equals(value) || "1".equals(value));
1:         return component;
1:     }
1: 
1:     private ComponentMetadata decorateRole(Node node, ComponentMetadata component, ParserContext context) {
1:         if (!(component instanceof BeanMetadata)) {
1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <bean> element");
1:         }
1:         if (!(component instanceof MutableBeanMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instance of MutableBeanMetadata");
1:         }
1:         boolean processor = false;
1:         String value = ((Attr) node).getValue();
1:         String[] flags = value.trim().split(" ");
1:         for (String flag : flags) {
1:             if (ROLE_PROCESSOR.equals(flag)) {
1:                 processor = true;
1:             } else {
1:                 throw new ComponentDefinitionException("Unknown proxy method: " + flag);
1:             }
1:         }
1:         ((MutableBeanMetadata) component).setProcessor(processor);
1:         return component;
1:     }
1: 
1:     private ComponentMetadata decorateProxyMethod(Node node, ComponentMetadata component, ParserContext context) {
1:         if (!(component instanceof ServiceReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> or <reference-list> element");
1:         }
1:         if (!(component instanceof MutableServiceReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instance of MutableServiceReferenceMetadata");
1:         }
1:         int method = 0;
1:         String value = ((Attr) node).getValue();
1:         String[] flags = value.trim().split(" ");
1:         for (String flag : flags) {
1:             if (PROXY_METHOD_DEFAULT.equals(flag)) {
1:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_DEFAULT;
1:             } else if (PROXY_METHOD_CLASSES.equals(flag)) {
1:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_CLASSES;
1:             } else if (PROXY_METHOD_GREEDY.equals(flag)) {
1:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY;
1:             } else {
1:                 throw new ComponentDefinitionException("Unknown proxy method: " + flag);
1:             }
1:         }
1:         if ((method & ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY) != 0 && !(component instanceof ReferenceListMetadata)) {
1:             throw new ComponentDefinitionException("Greedy proxying is only available for <reference-list> element");
1:         }
1:         ((MutableServiceReferenceMetadata) component).setProxyMethod(method);
1:         return component;
1:     }
1: 
1:     private Metadata parsePropertyPlaceholder(ParserContext context, Element element) {
1:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:         metadata.setProcessor(true);
1:         metadata.setId(getId(context, element));
1:         metadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:         metadata.setRuntimeClass(PropertyPlaceholder.class);
1:         metadata.setInitMethod("init");
1:         String prefix = element.hasAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:                                     ? element.getAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:                                     : "${";
1:         metadata.addProperty("placeholderPrefix", createValue(context, prefix));
1:         String suffix = element.hasAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:                                     ? element.getAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:                                     : "}";
1:         metadata.addProperty("placeholderSuffix", createValue(context, suffix));
1:         metadata.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));
1:         String defaultsRef = element.hasAttribute(DEFAULTS_REF_ATTRIBUTE) ? element.getAttribute(DEFAULTS_REF_ATTRIBUTE) : null;
1:         if (defaultsRef != null) {
1:             metadata.addProperty("defaultProperties", createRef(context, defaultsRef));
1:         }
1:         String ignoreMissingLocations = element.hasAttribute(IGNORE_MISSING_LOCATIONS_ATTRIBUTE) ? element.getAttribute(IGNORE_MISSING_LOCATIONS_ATTRIBUTE) : null;
1:         if (ignoreMissingLocations != null) {
1:             metadata.addProperty("ignoreMissingLocations", createValue(context, ignoreMissingLocations));
1:         }
1:         String systemProperties = element.hasAttribute(SYSTEM_PROPERTIES_ATTRIBUTE) ? element.getAttribute(SYSTEM_PROPERTIES_ATTRIBUTE) : null;
1:         if (systemProperties != null) {
1:             metadata.addProperty("systemProperties", createValue(context, systemProperties));
1:         }
1:         String evaluator = element.hasAttribute(EVALUATOR_ATTRIBUTE) ? element.getAttribute(EVALUATOR_ATTRIBUTE) : null;
1:         if (evaluator != null) {
1:             throw new IllegalStateException("Evaluators are not supported outside OSGi");
1:         }
1:         // Parse elements
1:         List<String> locations = new ArrayList<String>();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())
1:                         || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())
1:                         || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, DEFAULT_PROPERTIES_ELEMENT)) {
1:                         if (defaultsRef != null) {
1:                             throw new ComponentDefinitionException("Only one of " + DEFAULTS_REF_ATTRIBUTE + " attribute or " + DEFAULT_PROPERTIES_ELEMENT + " element is allowed");
1:                         }
1:                         Metadata props = parseDefaultProperties(context, metadata, e);
1:                         metadata.addProperty("defaultProperties", props);
1:                     } else if (nodeNameEquals(e, LOCATION_ELEMENT)) {
1:                         locations.add(getTextValue(e));
1:                     }
1:                 }
1:             }
1:         }
1:         if (!locations.isEmpty()) {
1:             metadata.addProperty("locations", createList(context, locations));
1:         }
1: 
0:         PlaceholdersUtils.validatePlaceholder(metadata, context.getComponentDefinitionRegistry());
1: 
0:         return metadata;
1:     }
1: 
1:     private Metadata parseDefaultProperties(ParserContext context, MutableBeanMetadata enclosingComponent, Element element) {
1:         MutableMapMetadata props = context.createMetadata(MutableMapMetadata.class);
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())
1:                         || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())
1:                         || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, PROPERTY_ELEMENT)) {
1:                         BeanProperty prop = context.parseElement(BeanProperty.class, enclosingComponent, e);
1:                         props.addEntry(createValue(context, prop.getName(), String.class.getName()), prop.getValue());
1:                     }
1:                 }
1:             }
1:         }
1:         return props;
1:     }
1: 
1:     public String getId(ParserContext context, Element element) {
1:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:             return element.getAttribute(ID_ATTRIBUTE);
1:         } else {
1:             return generateId(context);
1:         }
1:     }
1: 
1:     public void generateIdIfNeeded(ParserContext context, MutableComponentMetadata metadata) {
1:         if (metadata.getId() == null) {
1:             metadata.setId(generateId(context));
1:         }
1:     }
1: 
1:     private String generateId(ParserContext context) {
1:         String id;
1:         do {
1:             id = ".ext-" + ++idCounter;
1:         } while (context.getComponentDefinitionRegistry().containsComponentDefinition(id));
1:         return id;
1:     }
1: 
1:     private static ValueMetadata createValue(ParserContext context, String value) {
1:         return createValue(context, value, null);
1:     }
1: 
1:     private static ValueMetadata createValue(ParserContext context, String value, String type) {
1:         MutableValueMetadata m = context.createMetadata(MutableValueMetadata.class);
1:         m.setStringValue(value);
1:         m.setType(type);
1:         return m;
1:     }
1: 
1:     private static RefMetadata createRef(ParserContext context, String value) {
1:         MutableRefMetadata m = context.createMetadata(MutableRefMetadata.class);
1:         m.setComponentId(value);
1:         return m;
1:     }
1: 
1:     private static IdRefMetadata createIdRef(ParserContext context, String value) {
1:         MutableIdRefMetadata m = context.createMetadata(MutableIdRefMetadata.class);
1:         m.setComponentId(value);
1:         return m;
1:     }
1:     
1:     private static CollectionMetadata createList(ParserContext context, List<String> list) {
1:         MutableCollectionMetadata m = context.createMetadata(MutableCollectionMetadata.class);
1:         m.setCollectionClass(List.class);
1:         m.setValueType(String.class.getName());
1:         for (String v : list) {
1:             m.addValue(createValue(context, v, String.class.getName()));
1:         }
1:         return m;
1:     }
1: 
1:     private static String getTextValue(Element element) {
1:         StringBuffer value = new StringBuffer();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node item = nl.item(i);
1:             if ((item instanceof CharacterData && !(item instanceof Comment)) || item instanceof EntityReference) {
1:                 value.append(item.getNodeValue());
1:             }
1:         }
1:         return value.toString();
1:     }
1: 
1:     private static boolean nodeNameEquals(Node node, String name) {
1:         return (name.equals(node.getNodeName()) || name.equals(node.getLocalName()));
1:     }
1: 
1:     public static boolean isBlueprintNamespace(String ns) {
1:         return BLUEPRINT_NAMESPACE.equals(ns);
1:     }
1: 
1: }
============================================================================