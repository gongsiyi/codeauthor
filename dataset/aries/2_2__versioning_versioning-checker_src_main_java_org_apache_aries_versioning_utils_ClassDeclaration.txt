1:6aa0635: /*
1:6aa0635:  * Licensed to the Apache Software Foundation (ASF) under one
1:6aa0635:  * or more contributor license agreements.  See the NOTICE file
1:6aa0635:  * distributed with this work for additional information
1:6aa0635:  * regarding copyright ownership.  The ASF licenses this file
1:6aa0635:  * to you under the Apache License, Version 2.0 (the
1:6aa0635:  * "License"); you may not use this file except in compliance
1:6aa0635:  * with the License.  You may obtain a copy of the License at
1:6aa0635:  *
1:6aa0635:  *   http://www.apache.org/licenses/LICENSE-2.0
1:6aa0635:  *
1:6aa0635:  * Unless required by applicable law or agreed to in writing,
1:6aa0635:  * software distributed under the License is distributed on an
1:6aa0635:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6aa0635:  * KIND, either express or implied.  See the License for the
1:6aa0635:  * specific language governing permissions and limitations
1:6aa0635:  * under the License.
1:6aa0635:  */
1:6aa0635: package org.apache.aries.versioning.utils;
3:6aa0635: 
1:6aa0635: import java.io.IOException;
1:6aa0635: import java.lang.reflect.Modifier;
1:6aa0635: import java.net.URLClassLoader;
1:6aa0635: import java.util.ArrayList;
1:6aa0635: import java.util.Collection;
1:6aa0635: import java.util.HashMap;
1:6aa0635: import java.util.HashSet;
1:490f397: import java.util.List;
1:6aa0635: import java.util.Map;
1:6aa0635: import java.util.Set;
1:6aa0635: 
1:6aa0635: import org.objectweb.asm.ClassReader;
1:6aa0635: import org.objectweb.asm.Type;
1:6aa0635: 
1:9822203: public class ClassDeclaration extends GenericDeclaration {
1:6aa0635: 
1:6aa0635:     // Binary Compatibility - deletion of package-level access field/method/constructors of classes and interfaces in the package
1:6aa0635:     // will not break binary compatibility when an entire package is updated.
1:6aa0635: 
1:6aa0635:     // Assumptions:
1:6aa0635:     // 1.  This tool assumes that the deletion of package-level fields/methods/constructors is not break binary compatibility
1:6aa0635:     // based on the assumption of the entire package is updated.
1:6aa0635:     //
1:6aa0635: 
1:6aa0635: 
1:6aa0635:     private final String superName;
1:6aa0635:     private final String[] interfaces;
1:6aa0635:     private final Map<String, FieldDeclaration> fields;
1:6aa0635:     private final Map<String, Set<MethodDeclaration>> methods;
1:6aa0635: 
1:6aa0635:     private final Map<String, Set<MethodDeclaration>> methodsInUpperChain = new HashMap<String, Set<MethodDeclaration>>();
1:f9b43fb:     private final Map<String, FieldDeclaration> fieldsInUpperChain = new HashMap<String, FieldDeclaration>();
1:9822203:     private final Collection<String> supers = new ArrayList<String>();
1:6aa0635: 
1:6aa0635: 
1:6aa0635:     private final URLClassLoader jarsLoader;
1:f9b43fb: 
1:9822203:     private final SerialVersionClassVisitor serialVisitor;
1:6aa0635: 
1:9822203:     public Map<String, FieldDeclaration> getFields() {
1:6aa0635:         return fields;
27:6aa0635:     }
1:6aa0635: 
1:f9b43fb:     public Map<String, FieldDeclaration> getAllFields() {
1:f9b43fb:         Map<String, FieldDeclaration> allFields = new HashMap<String, FieldDeclaration>(getFields());
1:f9b43fb:         Map<String, FieldDeclaration> fieldsFromSupers = getFieldsInUpperChain();
1:f9b43fb:         putIfAbsent(allFields, fieldsFromSupers);
1:f9b43fb: 
1:f9b43fb: 
1:f9b43fb:         return allFields;
1:f9b43fb:     }
1:6aa0635: 
1:f9b43fb:     private void putIfAbsent(Map<String, FieldDeclaration> allFields,
1:9822203:                              Map<String, FieldDeclaration> fieldsFromSupers) {
1:f9b43fb:         for (Map.Entry<String, FieldDeclaration> superFieldEntry : fieldsFromSupers.entrySet()) {
1:f9b43fb:             String fieldName = superFieldEntry.getKey();
1:f9b43fb:             FieldDeclaration fd = superFieldEntry.getValue();
1:f9b43fb:             if (allFields.get(fieldName) == null) {
1:f9b43fb:                 allFields.put(fieldName, fd);
1:f9b43fb:             }
1:f9b43fb: 
1:f9b43fb:         }
1:f9b43fb:     }
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * Get the methods in the current class plus the methods in the upper chain
1:9822203:      *
1:490f397:      * @return map of method name to set of method declarations
1:6aa0635:      */
1:6aa0635:     public Map<String, Set<MethodDeclaration>> getAllMethods() {
1:6aa0635: 
1:6aa0635:         Map<String, Set<MethodDeclaration>> methods = new HashMap<String, Set<MethodDeclaration>>(getMethods());
1:f9b43fb:         Map<String, Set<MethodDeclaration>> methodsFromSupers = getMethodsInUpperChain();
1:f9b43fb:         for (Map.Entry<String, Set<MethodDeclaration>> superMethodsEntry : methodsFromSupers.entrySet()) {
1:f9b43fb:             Set<MethodDeclaration> overloadingMethods = methods.get(superMethodsEntry.getKey());
1:f9b43fb:             if (overloadingMethods != null) {
1:f9b43fb:                 overloadingMethods.addAll(superMethodsEntry.getValue());
1:f9b43fb:             } else {
1:f9b43fb:                 methods.put(superMethodsEntry.getKey(), superMethodsEntry.getValue());
1:f9b43fb:             }
1:f9b43fb: 
1:f9b43fb:         }
1:f9b43fb: 
1:f9b43fb: 
1:6aa0635:         return methods;
1:6aa0635:     }
1:6aa0635: 
1:9822203:     public Map<String, Set<MethodDeclaration>> getMethods() {
1:6aa0635:         return methods;
1:6aa0635:     }
1:6aa0635: 
1:6aa0635: 
1:417a860: //    public ClassDeclaration(int access, String name, String signature, String superName,
1:417a860: //                            String[] interfaces, URLClassLoader loader) {
1:417a860: //        super(access, name, signature);
1:417a860: //        this.superName = superName;
1:417a860: //        this.interfaces = interfaces;
1:417a860: //        this.fields = new HashMap<String, FieldDeclaration>();
1:417a860: //        this.methods = new HashMap<String, Set<MethodDeclaration>>();
1:417a860: //        this.jarsLoader = loader;
1:417a860: //        this.serialVisitor = null;
1:417a860: //    }
1:6aa0635: 
1:f9b43fb:     public ClassDeclaration(int access, String name, String signature, String superName,
1:9822203:                             String[] interfaces, URLClassLoader loader, SerialVersionClassVisitor cv) {
1:f9b43fb:         super(access, name, signature);
1:f9b43fb:         this.superName = superName;
1:f9b43fb:         this.interfaces = interfaces;
1:f9b43fb:         this.fields = new HashMap<String, FieldDeclaration>();
1:f9b43fb:         this.methods = new HashMap<String, Set<MethodDeclaration>>();
1:f9b43fb:         this.jarsLoader = loader;
1:f9b43fb:         this.serialVisitor = cv;
1:f9b43fb:     }
1:6aa0635: 
1:6aa0635:     private void getFieldsRecursively(String superClass) {
1:6aa0635: 
1:9822203:         if ((superClass != null)) {
1:6aa0635:             // load the super class of the cd
1:6aa0635:             try {
1:417a860:                 SerialVersionClassVisitor cv = new SerialVersionClassVisitor(null);
1:f9b43fb:                 SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader, cv);
1:6aa0635:                 ClassReader cr = new ClassReader(jarsLoader.getResourceAsStream(superClass + SemanticVersioningUtils.classExt));
1:6aa0635:                 cr.accept(svc, 0);
1:6aa0635:                 ClassDeclaration cd = svc.getClassDeclaration();
1:6aa0635:                 if (cd != null) {
1:6aa0635:                     addFieldInUpperChain(cd.getFields());
1:6aa0635:                     getFieldsRecursively(cd.getSuperName());
1:6aa0635:                     for (String iface : cd.getInterfaces()) {
1:6aa0635:                         getFieldsRecursively(iface);
1:6aa0635:                     }
1:6aa0635:                 }
1:6aa0635:             } catch (IOException ioe) {
1:6aa0635:                 // not a problem
1:6aa0635:             }
1:6aa0635:         }
1:6aa0635:     }
1:f9b43fb: 
1:9822203:     private void getMethodsRecursively(String superClass) {
1:9822203:         if ((superClass != null)) {
1:6aa0635:             // load the super class of the cd
1:417a860:             SerialVersionClassVisitor cv = new SerialVersionClassVisitor(null);
1:f9b43fb: 
1:f9b43fb:             SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader, cv);
1:6aa0635:             // use URLClassLoader to load the class
1:6aa0635:             try {
2:9822203:                 ClassReader cr = new ClassReader(jarsLoader.getResourceAsStream(superClass + SemanticVersioningUtils.classExt));
1:6aa0635:                 cr.accept(svc, 0);
1:6aa0635:                 ClassDeclaration cd = svc.getClassDeclaration();
1:6aa0635:                 if (cd != null) {
1:6aa0635:                     addMethodsInUpperChain(cd.getMethods());
1:6aa0635:                     getMethodsRecursively(cd.getSuperName());
1:6aa0635:                     for (String iface : cd.getInterfaces()) {
1:6aa0635:                         getMethodsRecursively(iface);
1:6aa0635:                     }
1:6aa0635:                 }
1:6aa0635:             } catch (IOException ioe) {
1:6aa0635:                 // not a deal
1:6aa0635:             }
1:6aa0635:         }
1:6aa0635:     }
1:6aa0635: 
1:6aa0635: 
1:f9b43fb:     public Map<String, FieldDeclaration> getFieldsInUpperChain() {
1:6aa0635:         if (fieldsInUpperChain.isEmpty()) {
1:6aa0635:             getFieldsRecursively(getSuperName());
1:6aa0635:             for (String ifs : getInterfaces()) {
1:6aa0635:                 getFieldsRecursively(ifs);
1:6aa0635:             }
1:6aa0635:         }
1:6aa0635:         return fieldsInUpperChain;
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     private void addFieldInUpperChain(Map<String, FieldDeclaration> fields) {
1:f9b43fb:         putIfAbsent(fieldsInUpperChain, fields);
1:f9b43fb: 
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     public Map<String, Set<MethodDeclaration>> getMethodsInUpperChain() {
1:6aa0635:         if (methodsInUpperChain.isEmpty()) {
1:6aa0635:             getMethodsRecursively(getSuperName());
1:6aa0635:             for (String ifs : getInterfaces()) {
1:6aa0635:                 getMethodsRecursively(ifs);
1:6aa0635:             }
1:6aa0635:         }
1:6aa0635:         return methodsInUpperChain;
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     private void addMethodsInUpperChain(Map<String, Set<MethodDeclaration>> methods) {
1:6aa0635:         for (Map.Entry<String, Set<MethodDeclaration>> method : methods.entrySet()) {
1:6aa0635:             String methodName = method.getKey();
1:6aa0635:             Set<MethodDeclaration> mds = new HashSet<MethodDeclaration>();
1:6aa0635:             if (methodsInUpperChain.get(methodName) != null) {
1:6aa0635:                 mds.addAll(methodsInUpperChain.get(methodName));
1:6aa0635:             }
1:6aa0635:             mds.addAll(method.getValue());
1:f9b43fb: 
1:6aa0635:             methodsInUpperChain.put(methodName, mds);
1:6aa0635:         }
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     public Collection<String> getUpperChainRecursively(String className) {
1:6aa0635:         Collection<String> clazz = new HashSet<String>();
1:6aa0635: 
1:9822203:         if (className != null) {
1:6aa0635:             // load the super class of the cd
1:417a860:             SerialVersionClassVisitor cv = new SerialVersionClassVisitor(null);
1:6aa0635: 
1:f9b43fb:             SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader, cv);
1:6aa0635:             try {
1:6aa0635:                 ClassReader cr = new ClassReader(jarsLoader.getResourceAsStream(className + SemanticVersioningUtils.classExt));
1:6aa0635:                 cr.accept(svc, 0);
1:6aa0635:                 clazz.add(className);
1:6aa0635:                 if (svc.getClassDeclaration() != null) {
1:6aa0635:                     String superName = svc.getClassDeclaration().getSuperName();
1:6aa0635:                     clazz.addAll(getUpperChainRecursively(superName));
1:6aa0635:                     if (svc.getClassDeclaration().getInterfaces() != null) {
1:6aa0635:                         for (String iface : svc.getClassDeclaration().getInterfaces()) {
1:6aa0635:                             clazz.addAll(getUpperChainRecursively(iface));
1:6aa0635:                         }
1:6aa0635:                     }
1:6aa0635:                 }
1:6aa0635:             } catch (IOException ioe) {
1:6aa0635:                 // not to worry about this. terminate.
1:6aa0635:             }
1:6aa0635:         }
1:6aa0635:         return clazz;
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     public Collection<String> getAllSupers() {
1:6aa0635:         if (supers.isEmpty()) {
1:6aa0635:             supers.addAll(getUpperChainRecursively(getSuperName()));
1:6aa0635:             for (String iface : getInterfaces()) {
1:6aa0635:                 supers.addAll(getUpperChainRecursively(iface));
1:6aa0635:             }
1:6aa0635:         }
1:6aa0635:         return supers;
1:6aa0635:     }
1:6aa0635: 
1:9822203:     public String getSuperName() {
1:6aa0635:         return superName;
1:6aa0635:     }
1:6aa0635: 
1:9822203:     public String[] getInterfaces() {
1:6aa0635:         return interfaces;
1:6aa0635:     }
1:6aa0635: 
1:6aa0635:     public void addFields(FieldDeclaration fd) {
1:6aa0635:         fields.put(fd.getName(), fd);
1:6aa0635:     }
1:6aa0635: 
1:6aa0635: 
1:9822203:     public void addMethods(MethodDeclaration md) {
1:6aa0635:         String key = md.getName();
1:6aa0635:         Set<MethodDeclaration> overloaddingMethods = methods.get(key);
1:6aa0635:         if (overloaddingMethods != null) {
1:6aa0635:             overloaddingMethods.add(md);
1:6aa0635:             methods.put(key, overloaddingMethods);
1:f9b43fb:         } else {
1:6aa0635:             Set<MethodDeclaration> mds = new HashSet<MethodDeclaration>();
1:6aa0635:             mds.add(md);
1:6aa0635:             methods.put(key, mds);
1:6aa0635:         }
1:6aa0635:     }
1:6aa0635: 
1:6aa0635: 
1:6aa0635:     public BinaryCompatibilityStatus getBinaryCompatibleStatus(ClassDeclaration old) {
1:6aa0635:         // check class signature, fields, methods
1:6aa0635: 
1:490f397:         BinaryCompatibilityStatus reasons = new BinaryCompatibilityStatus();
1:6aa0635:         if (old == null) {
1:490f397:             return reasons;
1:f9b43fb:         }
1:490f397:         getClassSignatureBinaryCompatibleStatus(old, reasons);
1:490f397:         getAllMethodsBinaryCompatibleStatus(old, reasons);
1:490f397:         getAllFieldsBinaryCompatibleStatus(old, reasons);
1:490f397:         getAllSuperPresentStatus(old, reasons);
1:490f397:         getSerializableBackCompatable(old, reasons);
1:490f397:         return reasons;
1:6aa0635:     }
1:f9b43fb: 
1:6aa0635: 
1:6aa0635:     public boolean isAbstract() {
1:6aa0635:         return Modifier.isAbstract(getAccess());
1:6aa0635:     }
1:6aa0635: 
1:490f397:     private void getClassSignatureBinaryCompatibleStatus(ClassDeclaration originalClass, List<String> reasons) {
1:6aa0635:         // if a class was not abstract but changed to abstract
1:6aa0635:         // not final changed to final
1:6aa0635:         // public changed to non-public
1:9822203:         String prefix = " The class " + getName();
1:6aa0635:         if (!!!originalClass.isAbstract() && isAbstract()) {
1:490f397:             reasons.add(prefix + " was not abstract but is changed to be abstract.");
1:f9b43fb:         }
1:9822203:         if (!!!originalClass.isFinal() && isFinal()) {
1:490f397:             reasons.add(prefix + " was not final but is changed to be final.");
1:f9b43fb:         }
1:9822203:         if (originalClass.isPublic() && !!!isPublic()) {
1:490f397:             reasons.add(prefix + " was public but is changed to be non-public.");
1:f9b43fb:         }
1:f9b43fb:     }
1:6aa0635: 
1:490f397:     private void getAllFieldsBinaryCompatibleStatus(ClassDeclaration originalClass, List<String> reasons) {
1:6aa0635:         // for each field to see whether the same field has changed
1:6aa0635:         // not final -> final
1:6aa0635:         // static <-> nonstatic
1:f9b43fb:         Map<String, FieldDeclaration> oldFields = originalClass.getAllFields();
1:f9b43fb:         Map<String, FieldDeclaration> newFields = getAllFields();
1:490f397:         areFieldsBinaryCompatible(oldFields, newFields, reasons);
1:f9b43fb:     }
1:f9b43fb: 
1:490f397:     private void areFieldsBinaryCompatible(Map<String, FieldDeclaration> oldFields, Map<String, FieldDeclaration> currentFields, List<String> reasons) {
1:f9b43fb: 
1:f9b43fb:         for (Map.Entry<String, FieldDeclaration> entry : oldFields.entrySet()) {
1:6aa0635:             FieldDeclaration bef_fd = entry.getValue();
1:f9b43fb:             FieldDeclaration cur_fd = currentFields.get(entry.getKey());
1:f9b43fb: 
1:490f397:             isFieldBinaryCompatible(reasons, bef_fd, cur_fd);
1:f9b43fb:         }
1:f9b43fb:     }
1:f9b43fb: 
1:490f397:     private boolean isFieldBinaryCompatible(List<String> reasons,
1:9822203:                                             FieldDeclaration bef_fd, FieldDeclaration cur_fd) {
1:f9b43fb:         String fieldName = bef_fd.getName();
1:f9b43fb:         //only interested in the public or protected fields
1:6aa0635: 
1:f9b43fb:         boolean compatible = true;
1:6aa0635: 
1:f9b43fb:         if (bef_fd.isPublic() || bef_fd.isProtected()) {
1:490f397:             String prefix = "The " + (bef_fd.isPublic() ? "public" : "protected") + " field " + fieldName;
1:f9b43fb: 
1:6aa0635: 
1:f9b43fb:             if (cur_fd == null) {
1:490f397:                 reasons.add(prefix + " has been deleted.");
1:f9b43fb:                 compatible = false;
1:f9b43fb:             } else {
1:f9b43fb: 
1:f9b43fb:                 if ((!!!bef_fd.isFinal()) && (cur_fd.isFinal())) {
1:6aa0635:                     // make sure it has not been changed to final
1:490f397:                     reasons.add(prefix + " was not final but has been changed to be final.");
1:f9b43fb:                     compatible = false;
1:f9b43fb: 
1:f9b43fb:                 }
1:9822203:                 if (bef_fd.isStatic() != cur_fd.isStatic()) {
1:6aa0635:                     // make sure it the static signature has not been changed
1:490f397:                     reasons.add(prefix + " was static but is changed to be non static or vice versa.");
1:f9b43fb:                     compatible = false;
1:6aa0635:                 }
1:6aa0635:                 // check to see the field type is the same
1:9822203:                 if (!isFieldTypeSame(bef_fd, cur_fd)) {
1:490f397:                     reasons.add(prefix + " has changed its type.");
1:f9b43fb:                     compatible = false;
1:6aa0635: 
1:6aa0635:                 }
1:9822203:                 if (SemanticVersioningUtils.isLessAccessible(bef_fd, cur_fd)) {
1:f9b43fb:                     // check whether the new field is less accessible than the old one
1:490f397:                     reasons.add(prefix + " becomes less accessible.");
4:6aa0635:                     compatible = false;
1:f9b43fb:                 }
1:f9b43fb: 
1:f9b43fb:             }
1:6aa0635:         }
1:f9b43fb:         return compatible;
1:f9b43fb:     }
1:f9b43fb: 
1:f9b43fb:     /**
1:f9b43fb:      * Return whether the serializable class is binary compatible. The serial verison uid change breaks binary compatibility.
1:490f397:      *
1:9822203:      *
1:490f397:      * @param old Old class declaration
1:490f397:      * @param reasons list of binary compatibility problems
1:f9b43fb:      */
1:490f397:     private void getSerializableBackCompatable(ClassDeclaration old, List<String> reasons) {
1:490f397:         // It does not matter one of them is not serializable.
1:9822203:         if ((getAllSupers().contains(SemanticVersioningUtils.SERIALIZABLE_CLASS_IDENTIFIER)) && (old.getAllSupers().contains(SemanticVersioningUtils.SERIALIZABLE_CLASS_IDENTIFIER))) {
1:f9b43fb:             // check to see whether the serializable id is the same
1:f9b43fb:             //ignore if it is enum
1:f9b43fb:             if ((!getAllSupers().contains(SemanticVersioningUtils.ENUM_CLASS) && (!old.getAllSupers().contains(SemanticVersioningUtils.ENUM_CLASS)))) {
1:b534b91:                 long oldValue = getSerialVersionUID(old);
1:b534b91:                 long curValue = getSerialVersionUID(this);
1:b534b91:                 if ((oldValue != curValue)) {
1:490f397:                     reasons.add("The serializable class is no longer back compatible as the value of SerialVersionUID has changed from " + oldValue + " to " + curValue + ".");
1:f9b43fb:                 }
1:6aa0635:             }
1:6aa0635:         }
1:f9b43fb: 
1:6aa0635:     }
1:f9b43fb: 
1:84181ac:     private long getSerialVersionUID(ClassDeclaration cd) {
1:84181ac:       FieldDeclaration serialID = cd.getAllFields().get(SemanticVersioningUtils.SERIAL_VERSION_UTD);
1:84181ac:       if (serialID != null) {
1:84181ac:         if (serialID.isFinal() && serialID.isStatic() && Type.LONG_TYPE.equals(Type.getType(serialID.getDesc()))) {
1:84181ac:           if (serialID.getValue() != null) {
1:84181ac:             return (Long)serialID.getValue();
1:84181ac: 
1:84181ac:           } else {
1:84181ac:             return 0;
1:84181ac:           }
1:84181ac:         }
1:f9b43fb:       }
1:f9b43fb:         // get the generated value
1:84181ac:         return cd.getSerialVisitor().getComputeSerialVersionUID();
1:f9b43fb:     }
1:6aa0635: 
1:9822203:     private boolean isFieldTypeSame(FieldDeclaration bef_fd, FieldDeclaration cur_fd) {
1:f9b43fb:         boolean descSame = bef_fd.getDesc().equals(cur_fd.getDesc());
1:f9b43fb:         if (descSame) {
1:cb248d1:             return true;
1:f9b43fb:         }
1:f9b43fb:         return false;
1:f9b43fb: 
1:f9b43fb:     }
1:f9b43fb: 
1:490f397:     private void getAllMethodsBinaryCompatibleStatus(ClassDeclaration originalClass, List<String> reasons) {
1:6aa0635:         //  for all methods
1:6aa0635:         // no methods should have deleted
1:6aa0635:         // method return type has not changed
1:6aa0635:         // method changed from not abstract -> abstract
1:f9b43fb:         Map<String, Set<MethodDeclaration>> oldMethods = originalClass.getAllMethods();
1:f9b43fb:         Map<String, Set<MethodDeclaration>> newMethods = getAllMethods();
1:490f397:         areMethodsBinaryCompatible(oldMethods, newMethods, reasons);
1:f9b43fb:     }
1:f9b43fb: 
1:490f397:     private void areMethodsBinaryCompatible(
1:490f397:             Map<String, Set<MethodDeclaration>> oldMethods, Map<String, Set<MethodDeclaration>> newMethods, List<String> reasons) {
1:6aa0635: 
1:f9b43fb:         boolean compatible = true;
1:6aa0635:         Map<String, Collection<MethodDeclaration>> extraMethods = new HashMap<String, Collection<MethodDeclaration>>();
1:6aa0635: 
1:6aa0635:         for (Map.Entry<String, Set<MethodDeclaration>> me : newMethods.entrySet()) {
1:6aa0635:             Collection<MethodDeclaration> mds = new ArrayList<MethodDeclaration>(me.getValue());
1:6aa0635:             extraMethods.put(me.getKey(), mds);
1:f9b43fb:         }
1:6aa0635: 
1:6aa0635:         for (Map.Entry<String, Set<MethodDeclaration>> methods : oldMethods.entrySet()) {
1:6aa0635:             // all overloading methods, check against the current class
1:6aa0635:             String methodName = methods.getKey();
1:6aa0635:             Collection<MethodDeclaration> oldMDSigs = methods.getValue();
1:6aa0635:             // If the method cannot be found in the current class, it means that it has been deleted.
1:6aa0635:             Collection<MethodDeclaration> newMDSigs = newMethods.get(methodName);
1:6aa0635:             // for each overloading methods
1:9822203:             outer:
1:9822203:             for (MethodDeclaration md : oldMDSigs) {
1:6aa0635:                 String mdName = md.getName();
1:f9b43fb: 
1:490f397:                 String prefix = "The " + SemanticVersioningUtils.getReadableMethodSignature(mdName, md.getDesc());
1:6aa0635:                 if (md.isProtected() || md.isPublic()) {
1:f9b43fb:                     boolean found = false;
1:6aa0635:                     if (newMDSigs != null) {
1:6aa0635:                         // try to find it in the current class
2:6aa0635:                         for (MethodDeclaration new_md : newMDSigs) {
2:6aa0635:                             // find the method with the same return type, parameter list
1:6aa0635:                             if ((md.equals(new_md))) {
1:f9b43fb:                                 found = true;
1:6aa0635:                                 // If the old method is final but the new one is not or vice versa
1:6aa0635:                                 // If the old method is static but the new one is non static
1:6aa0635:                                 // If the old method is not abstract but the new is
1:6aa0635: 
1:9822203:                                 if (!!!Modifier.isFinal(md.getAccess()) && !!!Modifier.isStatic(md.getAccess()) && Modifier.isFinal(new_md.getAccess())) {
1:6aa0635:                                     compatible = false;
1:490f397:                                     reasons.add(prefix + " was not final but has been changed to be final.");
1:f9b43fb:                                 }
1:9822203:                                 if (Modifier.isStatic(md.getAccess()) != Modifier.isStatic(new_md.getAccess())) {
1:6aa0635:                                     compatible = false;
1:490f397:                                     reasons.add(prefix + " has changed from static to non-static or vice versa.");
1:f9b43fb:                                 }
1:490f397:                                 if ((Modifier.isAbstract(new_md.getAccess())) && (!Modifier.isAbstract(md.getAccess()))) {
1:6aa0635:                                     compatible = false;
1:490f397:                                     reasons.add(prefix + " has changed from non abstract to abstract.");
1:f9b43fb:                                 }
1:f9b43fb:                                 if (SemanticVersioningUtils.isLessAccessible(md, new_md)) {
1:6aa0635:                                     compatible = false;
1:490f397:                                     reasons.add(prefix + " is less accessible.");
1:6aa0635:                                 }
1:f9b43fb: 
1:f9b43fb:                                 if (compatible) {
1:6aa0635:                                     // remove from the extra map
2:6aa0635:                                     Collection<MethodDeclaration> mds = extraMethods.get(methodName);
2:6aa0635:                                     mds.remove(new_md);
2:6aa0635:                                     extraMethods.put(methodName, mds);
1:6aa0635:                                     continue outer;
1:6aa0635:                                 }
1:6aa0635:                             }
1:6aa0635:                         }
1:6aa0635:                     }
1:6aa0635: 
1:6aa0635:                     //
1:6aa0635:                     // if we are here, it means that we have not found the method with the same description and signature
1:6aa0635:                     // which means that the method has been deleted. Let's make sure it is not moved to its upper chain.
1:9822203:                     if (!found) {
1:f9b43fb:                         if (!isMethodInSuperClass(md)) {
1:6aa0635: 
1:f9b43fb:                             compatible = false;
1:490f397:                             reasons.add(prefix + " has been deleted or its return type or parameter list has changed.");
1:f9b43fb:                         } else {
1:f9b43fb:                             if (newMDSigs != null) {
1:f9b43fb:                                 for (MethodDeclaration new_md : newMDSigs) {
1:f9b43fb:                                     // find the method with the same return type, parameter list
2:9822203:                                     if ((md.equals(new_md))) {
1:f9b43fb:                                         Collection<MethodDeclaration> mds = extraMethods.get(methodName);
1:f9b43fb:                                         mds.remove(new_md);
1:f9b43fb:                                         extraMethods.put(methodName, mds);
1:f9b43fb:                                     }
1:6aa0635:                                 }
1:6aa0635:                             }
1:6aa0635:                         }
1:6aa0635:                     }
1:6aa0635:                 }
1:6aa0635:             }
1:6aa0635:         }
1:6aa0635: 
1:6aa0635:         // Check the newly added method has not caused binary incompatibility
1:9822203:         for (Map.Entry<String, Collection<MethodDeclaration>> extraMethodSet : extraMethods.entrySet()) {
1:6aa0635:             for (MethodDeclaration md : extraMethodSet.getValue()) {
1:490f397:                 String head = "The " + SemanticVersioningUtils.getReadableMethodSignature(md.getName(), md.getDesc());
1:490f397:                 isNewMethodSpecialCase(md, head, reasons);
1:f9b43fb:             }
1:f9b43fb:         }
1:6aa0635:     }
1:6aa0635: 
1:f9b43fb:     /**
1:f9b43fb:      * Return the newly added fields
1:9822203:      *
1:490f397:      * @param old old class declaration
1:490f397:      * @return FieldDeclarations for fields added to new class
1:f9b43fb:      */
1:f9b43fb:     public Collection<FieldDeclaration> getExtraFields(ClassDeclaration old) {
1:f9b43fb:         Map<String, FieldDeclaration> oldFields = old.getAllFields();
1:f9b43fb:         Map<String, FieldDeclaration> newFields = getAllFields();
1:f9b43fb:         Map<String, FieldDeclaration> extraFields = new HashMap<String, FieldDeclaration>(newFields);
1:f9b43fb:         for (String key : oldFields.keySet()) {
1:f9b43fb:             extraFields.remove(key);
1:f9b43fb:         }
1:f9b43fb:         return extraFields.values();
1:f9b43fb:     }
1:6aa0635: 
1:f9b43fb:     /**
1:f9b43fb:      * Return the extra non-private methods
1:9822203:      *
1:490f397:      * @param old old class declaration
1:490f397:      * @return method declarations for methods added to new class
1:f9b43fb:      */
1:9822203:     public Collection<MethodDeclaration> getExtraMethods(ClassDeclaration old) {
1:f9b43fb:         // Need to find whether there are new methods added.
1:f9b43fb:         Collection<MethodDeclaration> extraMethods = new HashSet<MethodDeclaration>();
1:f9b43fb:         Map<String, Set<MethodDeclaration>> currMethodsMap = getAllMethods();
1:f9b43fb:         Map<String, Set<MethodDeclaration>> oldMethodsMap = old.getAllMethods();
1:6aa0635: 
1:f9b43fb:         for (Map.Entry<String, Set<MethodDeclaration>> currMethod : currMethodsMap.entrySet()) {
1:f9b43fb:             String methodName = currMethod.getKey();
1:f9b43fb:             Collection<MethodDeclaration> newMethods = currMethod.getValue();
1:6aa0635: 
1:f9b43fb:             // for each  method, we look for whether it exists in the old class
1:f9b43fb:             Collection<MethodDeclaration> oldMethods = oldMethodsMap.get(methodName);
1:f9b43fb:             for (MethodDeclaration new_md : newMethods) {
1:9822203:                 if (!new_md.isPrivate()) {
1:6aa0635:                     if (oldMethods == null) {
1:f9b43fb:                         extraMethods.add(new_md);
1:f9b43fb:                     } else {
1:f9b43fb:                         if (!oldMethods.contains(new_md)) {
1:f9b43fb:                             extraMethods.add(new_md);
1:6aa0635:                         }
1:6aa0635:                     }
1:6aa0635:                 }
1:6aa0635:             }
1:6aa0635:         }
1:f9b43fb:         return extraMethods;
1:6aa0635:     }
1:6aa0635: 
1:9822203:     public boolean isMethodInSuperClass(MethodDeclaration md) {
1:6aa0635:         // scan the super class and interfaces
1:6aa0635:         String methodName = md.getName();
1:6aa0635:         Collection<MethodDeclaration> overloaddingMethods = getMethodsInUpperChain().get(methodName);
1:6aa0635:         if (overloaddingMethods != null) {
1:6aa0635:             for (MethodDeclaration value : overloaddingMethods) {
1:6aa0635:                 // method signature and name same and also the method should not be less accessible
1:9822203:                 if (md.equals(value) && (!!!SemanticVersioningUtils.isLessAccessible(md, value)) && (value.isStatic() == md.isStatic())) {
2:f9b43fb:                     return true;
1:6aa0635:                 }
1:6aa0635:             }
1:6aa0635:         }
2:6aa0635:         return false;
1:6aa0635:     }
1:6aa0635: 
1:6aa0635: 
1:6aa0635:     /**
1:6aa0635:      * The newly added method is less accessible than the old one in the super or is a static (respectively instance) method.
1:490f397:      *
1:9822203:      *
1:490f397:      * @param md method declaration
1:490f397:      * @param prefix beginning of incompatibility message
1:490f397:      * @param reasons list of binary incompatibility reasons
1:490f397:      * @return whether new method is less accessible or changed static-ness compared to old class
1:6aa0635:      */
1:490f397:     private boolean isNewMethodSpecialCase(MethodDeclaration md, String prefix, List<String> reasons) {
1:6aa0635:         // scan the super class and interfaces
1:6aa0635:         String methodName = md.getName();
1:f9b43fb:         boolean special = false;
1:6aa0635:         Collection<MethodDeclaration> overloaddingMethods = getMethodsInUpperChain().get(methodName);
1:6aa0635:         if (overloaddingMethods != null) {
1:6aa0635:             for (MethodDeclaration value : overloaddingMethods) {
1:6aa0635:                 // method signature and name same and also the method should not be less accessible
1:f9b43fb:                 if (!SemanticVersioningUtils.CONSTRUTOR.equals(md.getName())) {
1:f9b43fb:                     if (md.equals(value)) {
1:f9b43fb:                         if (SemanticVersioningUtils.isLessAccessible(value, md)) {
1:9822203:                             special = true;
1:490f397:                             reasons.add(prefix + " is less accessible than the same method in its parent.");
1:f9b43fb:                         }
1:f9b43fb:                         if (value.isStatic()) {
1:f9b43fb:                             if (!md.isStatic()) {
1:9822203:                                 special = true;
1:490f397:                                 reasons.add(prefix + " is non-static but the same method in its parent is static.");
1:f9b43fb:                             }
1:f9b43fb:                         } else {
1:f9b43fb:                             if (md.isStatic()) {
1:9822203:                                 special = true;
1:490f397:                                 reasons.add(prefix + " is static but the same method is its parent is not static.");
1:f9b43fb:                             }
1:f9b43fb:                         }
1:f9b43fb:                     }
1:6aa0635:                 }
1:6aa0635:             }
1:6aa0635:         }
1:f9b43fb:         return special;
1:6aa0635:     }
1:6aa0635: 
1:490f397:     private void getAllSuperPresentStatus(ClassDeclaration old, List<String> reasons) {
1:6aa0635:         Collection<String> oldSupers = old.getAllSupers();
1:6aa0635:         boolean containsAll = getAllSupers().containsAll(oldSupers);
1:6aa0635:         if (!!!containsAll) {
1:6aa0635:             oldSupers.removeAll(getAllSupers());
1:490f397:             reasons.add("The superclasses or superinterfaces have stopped being super: " + oldSupers.toString() + ".");
1:6aa0635:         }
1:6aa0635:     }
1:6aa0635: 
1:9822203:     public SerialVersionClassVisitor getSerialVisitor() {
1:f9b43fb:         return serialVisitor;
1:f9b43fb:     }
1:f9b43fb: 
1:6aa0635: }
============================================================================
author:Emily Jiang
-------------------------------------------------------------------------------
commit:84181ac
/////////////////////////////////////////////////////////////////////////
1:     private long getSerialVersionUID(ClassDeclaration cd) {
1:       FieldDeclaration serialID = cd.getAllFields().get(SemanticVersioningUtils.SERIAL_VERSION_UTD);
1:       if (serialID != null) {
1:         if (serialID.isFinal() && serialID.isStatic() && Type.LONG_TYPE.equals(Type.getType(serialID.getDesc()))) {
1:           if (serialID.getValue() != null) {
1:             return (Long)serialID.getValue();
1: 
1:           } else {
1:             return 0;
1:           }
1:       }
1:         return cd.getSerialVisitor().getComputeSerialVersionUID();
commit:cb248d1
/////////////////////////////////////////////////////////////////////////
1:             return true;
commit:b534b91
/////////////////////////////////////////////////////////////////////////
1:                 long oldValue = getSerialVersionUID(old);
1:                 long curValue = getSerialVersionUID(this);
1:                 if ((oldValue != curValue)) {
commit:c511085
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if ((oldValue.longValue() != curValue.longValue())) {
commit:f9b43fb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.objectweb.asm.ClassVisitor;
0: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.htmlOneLineBreak;
0: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.htmlTwoLineBreaks;
/////////////////////////////////////////////////////////////////////////
1:   private final Map<String, FieldDeclaration> fieldsInUpperChain = new HashMap<String, FieldDeclaration>();
0:   private final SerialVersionClassVisitor serialVisitor ;
1:   
1:   public Map<String, FieldDeclaration> getAllFields() {
1:     Map<String, FieldDeclaration> allFields = new HashMap<String, FieldDeclaration>(getFields());
1:     Map<String, FieldDeclaration> fieldsFromSupers = getFieldsInUpperChain();
1:     putIfAbsent(allFields, fieldsFromSupers);
1:    
1:     
1:     return allFields;
1:   }
1:   private void putIfAbsent(Map<String, FieldDeclaration> allFields,
0:       Map<String, FieldDeclaration> fieldsFromSupers)
0:   {
1:     for (Map.Entry<String, FieldDeclaration> superFieldEntry : fieldsFromSupers.entrySet()) {
1:       String fieldName = superFieldEntry.getKey();
1:       FieldDeclaration fd = superFieldEntry.getValue();
1:       if (allFields.get(fieldName) == null) {
1:         allFields.put(fieldName, fd);
1:       }
1:      
1:     }
1:   }
/////////////////////////////////////////////////////////////////////////
1:     Map<String, Set<MethodDeclaration>> methodsFromSupers = getMethodsInUpperChain();
1:     for (Map.Entry<String, Set<MethodDeclaration>> superMethodsEntry : methodsFromSupers.entrySet()) {
1:       Set<MethodDeclaration> overloadingMethods = methods.get(superMethodsEntry.getKey());
1:       if (overloadingMethods != null) {
1:       overloadingMethods.addAll(superMethodsEntry.getValue());
1:       } else {
1:         methods.put(superMethodsEntry.getKey(), superMethodsEntry.getValue());
1:       }
1:       
1:     }
1:    
1:     
/////////////////////////////////////////////////////////////////////////
0:     this.serialVisitor = null;
1:   public ClassDeclaration(int access, String name, String signature, String superName,
0:       String[] interfaces, URLClassLoader loader, SerialVersionClassVisitor cv)
0:   {
1:     super(access, name, signature);
1:     this.superName = superName;
1:     this.interfaces = interfaces;
1:     this.fields = new HashMap<String, FieldDeclaration>();
1:     this.methods = new HashMap<String, Set<MethodDeclaration>>();
1:     this.jarsLoader = loader;
1:     this.serialVisitor = cv;
1:   }
0:         ClassVisitor cw = new EmptyClassVisitor();
0:         SerialVersionClassVisitor cv = new SerialVersionClassVisitor(cw);
1:         SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader, cv);
/////////////////////////////////////////////////////////////////////////
0:       ClassVisitor cw = new EmptyClassVisitor();
0:       SerialVersionClassVisitor cv = new SerialVersionClassVisitor(cw);
1:       
1:       SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader, cv);
/////////////////////////////////////////////////////////////////////////
1:   public Map<String, FieldDeclaration> getFieldsInUpperChain() {
/////////////////////////////////////////////////////////////////////////
1:     putIfAbsent(fieldsInUpperChain, fields);
1:    
/////////////////////////////////////////////////////////////////////////
1:       
/////////////////////////////////////////////////////////////////////////
0:       ClassVisitor cw = new EmptyClassVisitor();
0:       SerialVersionClassVisitor cv = new SerialVersionClassVisitor(cw);
1:       
1:       SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader, cv);
/////////////////////////////////////////////////////////////////////////
0:     StringBuilder reason = new StringBuilder();
0:     boolean isCompatible = true;
1: 
0:     Set<BinaryCompatibilityStatus>  bcsSet = new HashSet<BinaryCompatibilityStatus>();
0:     bcsSet.add(getClassSignatureBinaryCompatibleStatus(old));
0:     bcsSet.add(getAllMethodsBinaryCompatibleStatus(old));
0:     bcsSet.add(getAllFieldsBinaryCompatibleStatus(old));
0:     bcsSet.add(getAllSuperPresentStatus(old));
0:     bcsSet.add(getSerializableBackCompatable(old));
0:     for (BinaryCompatibilityStatus bcs: bcsSet) {
0:       if (!bcs.isCompatible()){
0:         isCompatible = false;
0:         reason.append(bcs.getReason());
0:     if (!isCompatible) {
0:       return new BinaryCompatibilityStatus(isCompatible, reason.toString());
0:     } else{
0:       return binaryCompatible;
1:     }
/////////////////////////////////////////////////////////////////////////
0:     String prefix = " The class "  + getName();
0:     StringBuilder reason = new StringBuilder();
1:     boolean compatible = true;
0:       reason.append(prefix + " was not abstract but is changed to be abstract.") ;
1:       compatible = false;
1:     } 
0:     if (!!!originalClass.isFinal() && isFinal()){
0:       reason.append(prefix + " was not final but is changed to be final.");
1:       compatible = false;
1:     } 
0:     if (originalClass.isPublic() && !!! isPublic()) {
0:       reason.append(prefix + " was public but is changed to be non-public.");
1:       compatible = false;
1:     } 
0:   public BinaryCompatibilityStatus getAllFieldsBinaryCompatibleStatus(ClassDeclaration originalClass) {
1:     Map<String, FieldDeclaration> oldFields = originalClass.getAllFields();
1:     Map<String, FieldDeclaration> newFields = getAllFields();
0:     return areFieldsBinaryCompatible(oldFields, newFields);
1:   }
0:   private BinaryCompatibilityStatus areFieldsBinaryCompatible(Map<String, FieldDeclaration> oldFields, Map<String, FieldDeclaration> currentFields) {
1:     
0:     boolean overallCompatible = true;
0:     StringBuilder reason = new StringBuilder();
1:     
1:     for (Map.Entry<String, FieldDeclaration> entry : oldFields.entrySet()) {
1:       FieldDeclaration cur_fd = currentFields.get(entry.getKey());
1:       
0:       boolean compatible = isFieldBinaryCompatible( reason, bef_fd, cur_fd) ;
0:       if (!compatible) {
0:         overallCompatible = compatible;
1:       } 
1:       
1:     }
0:     if (!overallCompatible) {
0:       return new BinaryCompatibilityStatus(overallCompatible, reason.toString());
1:     } else {
0:       return binaryCompatible;
1:     }
1:   }
0:   private boolean isFieldBinaryCompatible( StringBuilder reason,
0:       FieldDeclaration bef_fd, FieldDeclaration cur_fd)
0:   {
1:     String fieldName = bef_fd.getName();
1:     //only interested in the public or protected fields
1:     boolean compatible = true;
1:     
1:     if (bef_fd.isPublic() || bef_fd.isProtected()) {
0:       String prefix = htmlOneLineBreak + "The " + (bef_fd.isPublic()? "public" : "protcted") + " field "  +fieldName;
1: 
1:       if (cur_fd == null) {
0:         reason.append(prefix + " has been deleted.");
0:         compatible =  false;
1:       } else {
1: 
1:         if ((!!!bef_fd.isFinal()) && (cur_fd.isFinal())) {
0:           reason.append(prefix + " was not final but has been changed to be final.");
0:         }  if (bef_fd.isStatic() != cur_fd.isStatic()) {
0:           reason.append(prefix+ " was static but is changed to be non static or vice versa.");
0:         if (!isFieldTypeSame(bef_fd, cur_fd) ) {
0:           reason.append(prefix + " has changed its type.");
0:         }  if (SemanticVersioningUtils.isLessAccessible(bef_fd, cur_fd)) {
1:           // check whether the new field is less accessible than the old one
0:           reason.append(prefix + " becomes less accessible.");
1: 
1:       }
1:     }
1:     return compatible;
1:   }
1: 
1:   /**
1:    * Return whether the serializable class is binary compatible. The serial verison uid change breaks binary compatibility.
0:    * @param old
0:    * @return
1:    */
0:   private BinaryCompatibilityStatus getSerializableBackCompatable(ClassDeclaration old ) {
0:     // It does not matter one of them is not seralizable.
0:     boolean serializableBackCompatible = true;
0:     String reason = null;
0:     if ((getAllSupers().contains(SemanticVersioningUtils.SERIALIZABLE_CLASS_IDENTIFIER)) && (old.getAllSupers().contains(SemanticVersioningUtils.SERIALIZABLE_CLASS_IDENTIFIER))){
1:       // check to see whether the serializable id is the same
1:       //ignore if it is enum
1:       if ((!getAllSupers().contains(SemanticVersioningUtils.ENUM_CLASS) && (!old.getAllSupers().contains(SemanticVersioningUtils.ENUM_CLASS)))) {
0:         long oldValue = getSerialVersionUID(old) ;
0:         long curValue = getSerialVersionUID(this);
0:         if ((oldValue != curValue)) {
0:           serializableBackCompatible = false;
0:           reason = htmlOneLineBreak + "The serializable class is no longer back compatible as the value of SerialVersionUID has changed from " + oldValue + " to " + curValue + ".";
1:     
0:     if (!serializableBackCompatible) {
0:       return new BinaryCompatibilityStatus(serializableBackCompatible, reason);
1:   
0:   private long getSerialVersionUID(ClassDeclaration cd) {
0:     FieldDeclaration serialID = cd.getAllFields().get(SemanticVersioningUtils.SERIAL_VERSION_UTD);
0:     if (serialID != null) {
0:       if (serialID.isFinal() && serialID.isStatic() && Type.LONG_TYPE.equals(Type.getType(serialID.getDesc()))) {
0:         if (serialID.getValue() != null){
0:           return ((Long)(serialID.getValue())).longValue();
1:         } else {
0:           return 0;
1:         }
1:       }
1:     }
1:     // get the generated value
0:     return cd.getSerialVisitor().getComputeSerialVersionUID();
1:   }
0:   private boolean isFieldTypeSame (FieldDeclaration bef_fd, FieldDeclaration cur_fd) {
1:     boolean descSame = bef_fd.getDesc().equals(cur_fd.getDesc());
1:     if (descSame) {
0:       // check whether the signatures are the same
0:       if ((bef_fd.getSignature() == null) && (cur_fd.getSignature() == null)) {
1:       
1:         return true;
1:       }
0:       if ((bef_fd.getSignature() != null) && (bef_fd.getSignature().equals(cur_fd.getSignature()))) {
1:          return true;
1:       }
1:     }
1:     return false;
1:     
1:   }
1:     Map<String, Set<MethodDeclaration>> oldMethods = originalClass.getAllMethods();
1:     Map<String, Set<MethodDeclaration>> newMethods = getAllMethods();
/////////////////////////////////////////////////////////////////////////
0:     StringBuilder reason = new StringBuilder();
0:     boolean compatible = true;
/////////////////////////////////////////////////////////////////////////
1: 
0:         String prefix = htmlOneLineBreak  +"The "  + SemanticVersioningUtils.getReadableMethodSignature(mdName, md.getDesc());
1:           boolean found = false;
1:                 found = true;
0:                   reason.append(prefix + " was not final but has been changed to be final.");
1:                 } 
0:                 if (Modifier.isStatic(md.getAccess()) != Modifier.isStatic(new_md.getAccess())){
0:                   reason.append(prefix + " has changed from static to non-static or vice versa.");
1:                 } 
0:                 if ((Modifier.isAbstract(new_md.getAccess()) == true) && (Modifier.isAbstract(md.getAccess()) == false)) {
0:                   reason.append( prefix + " has changed from non abstract to abstract. ");
1:                 if (SemanticVersioningUtils.isLessAccessible(md, new_md)) {
0:                   reason.append(prefix + " is less accessible.");
1: 
1:                 if (compatible) {
/////////////////////////////////////////////////////////////////////////
0:           if ( !found){
1:             if (!isMethodInSuperClass(md)) {
1:               compatible = false;
0:               reason.append(prefix + " has been deleted or its return type or parameter list has changed.");
1:             } else {
1:               if (newMDSigs != null) {
1:                 for (MethodDeclaration new_md : newMDSigs) {
1:                   // find the method with the same return type, parameter list 
0:                   if ((md.equals(new_md)))  {
1:                     Collection<MethodDeclaration> mds = extraMethods.get(methodName);
1:                     mds.remove(new_md);
1:                     extraMethods.put(methodName, mds);
1:                   }
/////////////////////////////////////////////////////////////////////////
0:         String head = htmlOneLineBreak  +"The "  + SemanticVersioningUtils.getReadableMethodSignature(md.getName(), md.getDesc());
0:         if (isNewMethodSpecialCase(md, head, reason)){
1:           compatible = false;
0:     if (compatible){
0:       return  binaryCompatible;
1:     }
0:     else {
0:       return new BinaryCompatibilityStatus(compatible, reason.toString());
1:     }
1:   /**
1:    * Return the newly added fields
0:    * @param old
0:    * @return
1:    */
1:   public Collection<FieldDeclaration> getExtraFields(ClassDeclaration old) {
1:     Map<String, FieldDeclaration> oldFields = old.getAllFields();
1:     Map<String, FieldDeclaration> newFields = getAllFields();
1:     Map<String, FieldDeclaration> extraFields = new HashMap<String, FieldDeclaration>(newFields);
1:     for (String key : oldFields.keySet()) {
1:       extraFields.remove(key);
1:     }
1:     return extraFields.values();
1:   }
1:   /**
1:    * Return the extra non-private methods
0:    * @param old
0:    * @return
1:    */
0:   public Collection<MethodDeclaration> getExtraMethods(ClassDeclaration old ) {
1:     // Need to find whether there are new methods added.
1:     Collection<MethodDeclaration> extraMethods = new HashSet<MethodDeclaration>();
1:     Map<String, Set<MethodDeclaration>> currMethodsMap = getAllMethods();
1:     Map<String, Set<MethodDeclaration>> oldMethodsMap = old.getAllMethods();
1:     for (Map.Entry<String, Set<MethodDeclaration>> currMethod : currMethodsMap.entrySet()) {
1:       String methodName = currMethod.getKey();
1:       Collection<MethodDeclaration> newMethods = currMethod.getValue();
1:       // for each  method, we look for whether it exists in the old class
1:       Collection<MethodDeclaration> oldMethods = oldMethodsMap.get(methodName);
1:       for (MethodDeclaration new_md : newMethods) {
0:         if (!new_md.isPrivate()){
1:             extraMethods.add(new_md);
1:             if (!oldMethods.contains(new_md)) {
1:               extraMethods.add(new_md);
1:     return extraMethods;
/////////////////////////////////////////////////////////////////////////
1:   
0:   public boolean isNewMethodSpecialCase(MethodDeclaration md, String prefix, StringBuilder reason){
1:     boolean special = false;
1:         if (!SemanticVersioningUtils.CONSTRUTOR.equals(md.getName())) {
1:           if (md.equals(value)) {
1:             if (SemanticVersioningUtils.isLessAccessible(value, md)) {
0:               special =true;
0:               reason.append(prefix + " is less accessible than the same method in its parent.");
1:             }
1:             if (value.isStatic()) {
1:               if (!md.isStatic()) {
0:                 special =true;
0:                 reason.append(prefix + " is non-static but the same method in its parent is static.");
1:               }
1:             } else {
1:               if (md.isStatic()) {
0:                 special =true;
0:                 reason.append(prefix + " is static but the same method is its parent is not static.");
1:               }
1:             }
1:           }
1:     return special;
0:   public BinaryCompatibilityStatus getAllSuperPresentStatus(ClassDeclaration old) {
0:       return new BinaryCompatibilityStatus(false, htmlTwoLineBreaks  +"The superclasses or superinterfaces have stopped being super: " + oldSupers.toString() + ".");
0:   public SerialVersionClassVisitor getSerialVisitor()
0:   {
1:     return serialVisitor;
1:   }
1:   
commit:6aa0635
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.versioning.utils;
1: 
1: import java.io.IOException;
1: import java.lang.reflect.Modifier;
1: import java.net.URLClassLoader;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.Map;
1: import java.util.Set;
1: 
1: import org.objectweb.asm.ClassReader;
1: import org.objectweb.asm.Type;
1: 
1: 
0: public class ClassDeclaration extends GenericDeclaration
0: {
1: 
1:   // Binary Compatibility - deletion of package-level access field/method/constructors of classes and interfaces in the package
1:   // will not break binary compatibility when an entire package is updated.
1: 
1:   // Assumptions:
1:   // 1.  This tool assumes that the deletion of package-level fields/methods/constructors is not break binary compatibility 
1:   // based on the assumption of the entire package is updated.
1:   // 
1: 
1: 
1: 
1:   private final String superName;
1:   private final String[] interfaces;
1:   private final Map<String, FieldDeclaration> fields;
1:   private final Map<String, Set<MethodDeclaration>> methods;
1: 
1:   private final Map<String, Set<MethodDeclaration>> methodsInUpperChain = new HashMap<String, Set<MethodDeclaration>>();
0:   private final Map<String, Collection<FieldDeclaration>> fieldsInUpperChain = new HashMap<String, Collection<FieldDeclaration>>();
0:   private final Collection<String> supers = new ArrayList<String> ();
1: 
1: 
1:   private final URLClassLoader jarsLoader;
1: 
0:   private final BinaryCompatibilityStatus binaryCompatible = new BinaryCompatibilityStatus(true, null);
0:   public Map<String, FieldDeclaration> getFields()
0:   {
1:     return fields;
1:   }
1:   /**
1:    * Get the methods in the current class plus the methods in the upper chain
0:    * @return
1:    */
1:   public Map<String, Set<MethodDeclaration>> getAllMethods() {
1: 
1:     Map<String, Set<MethodDeclaration>> methods = new HashMap<String, Set<MethodDeclaration>>(getMethods());
0:     methods.putAll(getMethodsInUpperChain());
1:     return methods;
1:   }
1: 
0:   public Map<String, Set<MethodDeclaration>> getMethods()
0:   {
1:     return methods;
1:   }
1: 
1: 
0:   public ClassDeclaration(int access, String name, String signature, String superName,
0:       String[] interfaces, URLClassLoader loader)
0:   {
0:     super(access, name, signature);
0:     this.superName = superName;
0:     this.interfaces = interfaces;
0:     this.fields = new HashMap<String, FieldDeclaration>();
0:     this.methods = new HashMap<String, Set<MethodDeclaration>>();
0:     this.jarsLoader = loader;
1:   }
1: 
1:   private void getFieldsRecursively(String superClass) {
1: 
0:     if ((superClass != null) ) {
1:       // load the super class of the cd
1:       try {
0:         SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader);
1:         ClassReader cr = new ClassReader(jarsLoader.getResourceAsStream(superClass + SemanticVersioningUtils.classExt));
0:         if (cr != null) {
1:           cr.accept(svc, 0);
1:           ClassDeclaration cd = svc.getClassDeclaration();
1:           if (cd != null) {
1:             addFieldInUpperChain(cd.getFields());
1:             getFieldsRecursively(cd.getSuperName());
1:             for (String iface : cd.getInterfaces()) {
1:               getFieldsRecursively(iface);
1:             }
1:           }
1:         }
1:       } catch (IOException ioe) {
1:         // not a problem
1:       }
1:     }
1:   }
1: 
0:   private void getMethodsRecursively(String superClass)
0:   {
0:     if ((superClass != null) ) {
1:       // load the super class of the cd
0:       SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader);
1:       // use URLClassLoader to load the class
1:       try {
0:         ClassReader cr = new ClassReader(jarsLoader.getResourceAsStream(superClass  + SemanticVersioningUtils.classExt));
0:         if (cr !=  null) {
1:           cr.accept(svc, 0);
1:           ClassDeclaration cd = svc.getClassDeclaration();
1:           if (cd != null) {
1:             addMethodsInUpperChain(cd.getMethods());
1:             getMethodsRecursively(cd.getSuperName());
1:             for (String iface : cd.getInterfaces()) {
1:               getMethodsRecursively(iface);
1:             }
1:           }
1:         }
1:       } catch (IOException ioe) {
1:         // not a deal
1:       }
1:     }
1:   }
1: 
1: 
0:   public Map<String, Collection<FieldDeclaration>> getFieldsInUpperChain() {
1:     if (fieldsInUpperChain.isEmpty()) {
1:       getFieldsRecursively(getSuperName());
1:       for (String ifs : getInterfaces()) {
1:         getFieldsRecursively(ifs);
1:       }
1:     }
1:     return fieldsInUpperChain;
1:   }
1: 
1:   private void addFieldInUpperChain(Map<String, FieldDeclaration> fields) {
0:     for (Map.Entry<String, FieldDeclaration> field : fields.entrySet()) {
0:       String fieldName = field.getKey();
0:       Set<FieldDeclaration> fds = new HashSet<FieldDeclaration>();
0:       if (fieldsInUpperChain.get(fieldName) != null) {
0:         fds.addAll(fieldsInUpperChain.get(fieldName));
1:       } 
1: 
0:       fds.add(fields.get(fieldName));
0:       fieldsInUpperChain.put(fieldName, fds);
1:     }
1:   }
1:   public Map<String, Set<MethodDeclaration>> getMethodsInUpperChain() {
1:     if (methodsInUpperChain.isEmpty()) {
1:       getMethodsRecursively(getSuperName());
1:       for (String ifs : getInterfaces()) {
1:         getMethodsRecursively(ifs);
1:       }
1:     }
1:     return methodsInUpperChain;
1:   }
1: 
1:   private void addMethodsInUpperChain(Map<String, Set<MethodDeclaration>> methods) {
1:     for (Map.Entry<String, Set<MethodDeclaration>> method : methods.entrySet()) {
1:       String methodName = method.getKey();
1:       Set<MethodDeclaration> mds = new HashSet<MethodDeclaration>();
1:       if (methodsInUpperChain.get(methodName) != null) {
1:         mds.addAll(methodsInUpperChain.get(methodName));
1:       }
1:       mds.addAll(method.getValue());
1:       methodsInUpperChain.put(methodName, mds);
1:     }
1:   }
1:   public Collection<String> getUpperChainRecursively(String className) {
1:     Collection<String> clazz = new HashSet<String>();
1: 
0:     if (className!= null)  {
1:       // load the super class of the cd
0:       SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader);
1:       try {
1:         ClassReader cr = new ClassReader(jarsLoader.getResourceAsStream(className + SemanticVersioningUtils.classExt));
1:         cr.accept(svc, 0);
1:         clazz.add(className);
1:         if (svc.getClassDeclaration() != null) {
1:           String superName = svc.getClassDeclaration().getSuperName();
0:           className = superName;
1:           clazz.addAll(getUpperChainRecursively(superName));
1:           if (svc.getClassDeclaration().getInterfaces() != null) {
1:             for (String iface : svc.getClassDeclaration().getInterfaces()) {
1:               clazz.addAll(getUpperChainRecursively(iface));
1:             }
1:           }
1:         }
1:       } catch (IOException ioe) {
1:         // not to worry about this. terminate.
1:       }
1:     }
1:     return clazz;
1:   }
1: 
1:   public Collection<String> getAllSupers() {
1:     if (supers.isEmpty()) {
1:       supers.addAll(getUpperChainRecursively(getSuperName()));
1:       for (String iface : getInterfaces()) {
1:         supers.addAll(getUpperChainRecursively(iface));
1:       }
1:     }
1:     return supers;
1:   }
0:   public String getSuperName()
0:   {
1:     return superName;
1:   }
0:   public String[] getInterfaces()
0:   {
1:     return interfaces;
1:   }
1: 
1:   public void addFields(FieldDeclaration fd) {
1:     fields.put(fd.getName(), fd);
1:   }
1: 
1: 
0:   public void addMethods(MethodDeclaration md)
0:   {
1:     String key = md.getName();
1:     Set<MethodDeclaration> overloaddingMethods = methods.get(key);
1:     if (overloaddingMethods != null) {
1:       overloaddingMethods.add(md);
1:       methods.put(key, overloaddingMethods);
0:     } else {
1:       Set<MethodDeclaration> mds = new HashSet<MethodDeclaration>();
1:       mds.add(md);
1:       methods.put(key, mds);
1:     }
1:   }
1: 
1: 
1:   public BinaryCompatibilityStatus getBinaryCompatibleStatus(ClassDeclaration old) {
1:     // check class signature, fields, methods
1:     if (old == null) {
0:       return binaryCompatible;
1:     }
0:     BinaryCompatibilityStatus bcs = getClassSignatureBinaryCompatibleStatus(old);
0:     if (!!!bcs.isCompatible()) {
0:       return bcs;
0:     } else {
0:       bcs = getAllMethodsBinaryCompatibleStatus(old);
0:       if (!!!bcs.isCompatible()) {
0:         return bcs;
0:       } else {
0:         bcs = getFieldsBinaryCompatibleStatus(old);
0:         if (!!!bcs.isCompatible()) {
0:           return bcs;
0:         } else {
0:           bcs = areAllSuperPresent(old);
0:           if (!!!bcs.isCompatible()) {
0:             return bcs;
1:           }
1:         }
1:       }
1:     }
0:     return binaryCompatible;
1: 
1:   }
1: 
1: 
1:   public boolean isAbstract() {
1:     return Modifier.isAbstract(getAccess());
1:   }
1: 
0:   private BinaryCompatibilityStatus getClassSignatureBinaryCompatibleStatus(ClassDeclaration originalClass) {
1:     // if a class was not abstract but changed to abstract
1:     // not final changed to final
1:     // public changed to non-public
0:     StringBuilder reason = new StringBuilder("The class "  + getName() );
0:     boolean compatible = false;
1:     if (!!!originalClass.isAbstract() && isAbstract()) {
0:       reason.append(" was not abstract but is changed to be abstract.") ;
0:     } else if (!!!originalClass.isFinal() && isFinal()){
0:       reason.append( " was not final but is changed to be final.");
0:     } else if (originalClass.isPublic() && !!! isPublic()) {
0:       reason.append(" was public but is changed to be non-public.");
0:     } else {
0:       compatible = true;
1:     }
0:     return new BinaryCompatibilityStatus(compatible, compatible? null: reason.toString());
1:   }
1: 
0:   public BinaryCompatibilityStatus getFieldsBinaryCompatibleStatus(ClassDeclaration originalClass) {
1:     // for each field to see whether the same field has changed
1:     // not final -> final
1:     // static <-> nonstatic
1: 
0:     for (Map.Entry<String, FieldDeclaration> entry : originalClass.getFields().entrySet()) {
1: 
1:       FieldDeclaration bef_fd = entry.getValue();
0:       FieldDeclaration cur_fd = getFields().get(entry.getKey());
1: 
0:       String fieldName = bef_fd.getName();
0:       //only interested in the public or protected fields
0:       boolean compatible = true;
0:       if (bef_fd.isPublic() || bef_fd.isProtected()) {
0:         StringBuilder reason = new StringBuilder("The public or protected field "  +fieldName);
1: 
0:         if (cur_fd == null) {
0:           reason.append(" has been deleted.");
0:           compatible =  false;
0:         } else if ((!!!bef_fd.isFinal()) && (cur_fd.isFinal())) {
1:           // make sure it has not been changed to final
0:           reason.append(" was not final but has been changed to be final.");
1:           compatible = false;
1: 
0:         } else if (bef_fd.isStatic() != cur_fd.isStatic()) {
1:           // make sure it the static signature has not been changed
0:           reason.append( " was static but is changed to be non static or vice versa.");
1:           compatible = false;
1:         }
1:         // check to see the field type is the same 
0:         else if (!!!Type.getType(bef_fd.getDesc()).equals(Type.getType(cur_fd.getDesc()))) {
0:           reason.append(" has different type.");
1:           compatible = false;
1: 
0:         } else if (SemanticVersioningUtils.isLessAccessible(bef_fd, cur_fd)) {
0:           // check whether the new field is less accessible than the old one         
0:           reason.append(" is less accessible.");
1:           compatible = false;
1:         }
0:         if (!!!compatible) {
0:           return new BinaryCompatibilityStatus(compatible, reason.toString());
1:         }
1:       }
1:     }
0:     // need to check the newly added fields do not cause binary compatibility issue:
0:     // e.g. the new fields has less access than the old one
0:     // the new field is static(instance) while the old one is instance(static) respectively.
0:     Collection<String> curFields = getFields().keySet();
0:     Collection<String> oldFields = originalClass.getFields().keySet();
0:     curFields.removeAll(oldFields);
0:     Map<String, Collection<FieldDeclaration>> superFields = new HashMap<String, Collection<FieldDeclaration>>();
0:     if (!!!(curFields.isEmpty())) {
0:       superFields = getFieldsInUpperChain();
1:     }
0:     // for each new field we need to find out whether it may cause binary incompatibility
0:     for ( String newFieldName : curFields) {
0:       // check whether the new field has the same field name in the super with the same type
0:       boolean existInSuper = false;
0:       if (superFields.containsKey(newFieldName)) {
0:         FieldDeclaration newfd = getFields().get(newFieldName);
0:         Collection<FieldDeclaration> superfd = superFields.get(newFieldName);
0:         FieldDeclaration oldfd = null;
0:         if ((superfd != null) ) {
0:           for (FieldDeclaration fd : superfd) {
0:             if (newfd.equals(fd)) {
0:               oldfd = fd;
0:               existInSuper = true;
0:               break;
1:             }
1:           }
1:         }
0:         if ((existInSuper) && ((SemanticVersioningUtils.isLessAccessible(oldfd, newfd)) || (oldfd.isStatic() != newfd.isStatic()))){
1: 
0:           return new BinaryCompatibilityStatus(false, "The new field " + newfd.getName() + " conflicts with the same field in its super class. For more details, check the Binary Compatibility section(Chapter 13) of the Java Specification.");
1:         }
1:       }
1:     }
0:     return binaryCompatible;
1:   }
1: 
0:   private BinaryCompatibilityStatus getAllMethodsBinaryCompatibleStatus(ClassDeclaration originalClass) {
1:     //  for all methods
1:     // no methods should have deleted
1:     // method return type has not changed
1:     // method changed from not abstract -> abstract
0:     Map<String, Set<MethodDeclaration>> oldMethods = originalClass.getMethods();
0:     Map<String, Set<MethodDeclaration>> newMethods = getMethods();
0:     return  areMethodsBinaryCompatible(oldMethods, newMethods) ;
1:   }
1: 
0:   public BinaryCompatibilityStatus areMethodsBinaryCompatible(
0:       Map<String, Set<MethodDeclaration>> oldMethods, Map<String, Set<MethodDeclaration>> newMethods)
0:   {
1: 
1:     Map<String, Collection<MethodDeclaration>> extraMethods = new HashMap<String, Collection<MethodDeclaration>>();
1: 
1:     for (Map.Entry<String, Set<MethodDeclaration>> me : newMethods.entrySet()) {
1:       Collection<MethodDeclaration> mds = new ArrayList<MethodDeclaration>(me.getValue());
1:       extraMethods.put(me.getKey(), mds);
1:     }
1: 
1:     for (Map.Entry<String, Set<MethodDeclaration>> methods : oldMethods.entrySet()) {
1:       // all overloading methods, check against the current class
1:       String methodName = methods.getKey();
1:       Collection<MethodDeclaration> oldMDSigs = methods.getValue();
1:       // If the method cannot be found in the current class, it means that it has been deleted.
1:       Collection<MethodDeclaration> newMDSigs = newMethods.get(methodName);
1:       // for each overloading methods
0:       outer: for (MethodDeclaration md : oldMDSigs) {
1:         String mdName = md.getName();
0:         StringBuilder reason = new StringBuilder("The "  + SemanticVersioningUtils.getReadableMethodSignature(mdName, md.getDesc()) );
1:         if (md.isProtected() || md.isPublic()) {
0:           if (newMDSigs !=  null) {
1:             // try to find it in the current class
1:             for (MethodDeclaration new_md : newMDSigs) {
1:               // find the method with the same return type, parameter list 
1:               if ((md.equals(new_md))) {
1:                 // If the old method is final but the new one is not or vice versa
1:                 // If the old method is static but the new one is non static
1:                 // If the old method is not abstract but the new is
1: 
1: 
0:                 boolean compatible = true;
0:                 if ( !!!Modifier.isFinal(md.getAccess()) && !!!Modifier.isStatic(md.getAccess()) && Modifier.isFinal(new_md.getAccess())) {
1:                   compatible = false;
0:                   reason.append(" was not final but has been changed to be final.");
0:                 } else if (Modifier.isStatic(md.getAccess()) != Modifier.isStatic(new_md.getAccess())){
1:                   compatible = false;
0:                   reason.append(" has changed from static to non-static or vice versa.");
0:                 } else if ((Modifier.isAbstract(new_md.getAccess()) == true) && (Modifier.isAbstract(md.getAccess()) == false)) {
1:                   compatible = false;
0:                   reason.append( " has changed from non abstract to abstract. ");
1:                 }
0:                 else if (SemanticVersioningUtils.isLessAccessible(md, new_md)) {
1:                   compatible = false;
0:                   reason.append(" is less accessible.");
1:                 }
0:                 if (!!!compatible) {
0:                   return new BinaryCompatibilityStatus(compatible, reason.toString());
1:                 }
0:                 else {
1:                   // remove from the extra map
1:                   Collection<MethodDeclaration> mds = extraMethods.get(methodName);
1:                   mds.remove(new_md);
1:                   extraMethods.put(methodName, mds);
1:                   continue outer;
1:                 }
1:               }
1:             }
1:           }
1: 
1:           // 
1:           // if we are here, it means that we have not found the method with the same description and signature
1:           // which means that the method has been deleted. Let's make sure it is not moved to its upper chain.
0:           if (!!!isMethodInSuperClass(md)) {
1: 
0:             reason.append(" has been deleted or its return type or parameter list has changed.");
0:             return new BinaryCompatibilityStatus(false, reason.toString());
1: 
1: 
0:           } else {
1:             if (newMDSigs != null) {
1:               for (MethodDeclaration new_md : newMDSigs) {
1:                 // find the method with the same return type, parameter list 
0:                 if ((md.equals(new_md)))  {
1:                   Collection<MethodDeclaration> mds = extraMethods.get(methodName);
1:                   mds.remove(new_md);
1:                   extraMethods.put(methodName, mds);
1:                 }
1:               }
1:             }
1:           }
1:         }
1:       }
1:     }
1: 
1:     // Check the newly added method has not caused binary incompatibility
0:     for (Map.Entry<String, Collection<MethodDeclaration>> extraMethodSet : extraMethods.entrySet()){
1:       for (MethodDeclaration md : extraMethodSet.getValue()) {
0:         if (isNewMethodSpecialCase(md)){
0:           String reason = "The newly added " + SemanticVersioningUtils.getReadableMethodSignature(md.getName(), md.getDesc()) + " conflicts with the same method in its super class. For more details, check the Binary Compatibility section(Chapter 13) of the Java Specification.";
0:           return new BinaryCompatibilityStatus(false, reason);
1:         }
1:       }
1:     }
1: 
1: 
0:     return  binaryCompatible;
1:   }
0:   public MethodDeclaration getExtraMethods(ClassDeclaration old ) {
0:     // Need to find whether there are new abstract methods added.
1: 
0:     if (Modifier.isAbstract(getAccess())) {
0:       Map<String, Set<MethodDeclaration>> currMethodsMap = getAllMethods();
1: 
0:       Map<String, Set<MethodDeclaration>> oldMethodsMap = old.getAllMethods();
0:       // only interested in an abstract class
1: 
0:       for (Map.Entry<String, Set<MethodDeclaration>> currMethod : currMethodsMap.entrySet()) {
0:         String methodName = currMethod.getKey();
0:         Collection<MethodDeclaration> newMethods = currMethod.getValue();
1: 
0:         // for each abstract method, we look for whether it exists in the old class
0:         Collection<MethodDeclaration> oldMethods = oldMethodsMap.get(methodName);
0:         for (MethodDeclaration new_md : newMethods) {
1:           if (oldMethods == null) {
0:             return new_md;
0:           } else {
0:             if (oldMethods.contains(new_md)) {
0:               continue;
0:             } else {
0:               return new_md;
1:             }
1:           }
1:         }
1:       }
0:       // if we reach here, it means we have scanned all methods in the new classes. All of them are in the original class. No new method is added!
0:       return null;
1:     }
0:     // not to worry as it is not abstract class:o
0:     return null;
1:   }
1: 
0:   public boolean isMethodInSuperClass(MethodDeclaration md){
1:     // scan the super class and interfaces
1:     String methodName = md.getName();
1:     Collection<MethodDeclaration> overloaddingMethods = getMethodsInUpperChain().get(methodName);
1:     if (overloaddingMethods != null) {
1:       for (MethodDeclaration value : overloaddingMethods) {
1:         // method signature and name same and also the method should not be less accessible
0:         if (md.equals(value) && (!!!SemanticVersioningUtils.isLessAccessible(md, value)) && (value.isStatic()==md.isStatic())) {
0:           return true;
1:         }
1:       }
1:     }
1:     return false;
1:   }
1: 
1:   /**
1:    * The newly added method is less accessible than the old one in the super or is a static (respectively instance) method.
0:    * @param md
0:    * @return
1:    */
0:   public boolean isNewMethodSpecialCase(MethodDeclaration md){
1:     // scan the super class and interfaces
1:     String methodName = md.getName();
1:     Collection<MethodDeclaration> overloaddingMethods = getMethodsInUpperChain().get(methodName);
1:     if (overloaddingMethods != null) {
1:       for (MethodDeclaration value : overloaddingMethods) {
1:         // method signature and name same and also the method should not be less accessible
0:         if (md.equals(value) && (SemanticVersioningUtils.isLessAccessible(md, value) || value.isStatic()!=md.isStatic())) {
0:           return true;
1:         }
1:       }
1:     }
1:     return false;
1:   }
0:   public BinaryCompatibilityStatus areAllSuperPresent(ClassDeclaration old) {
1:     Collection<String> oldSupers = old.getAllSupers();
1:     boolean containsAll = getAllSupers().containsAll(oldSupers);
1:     if (!!!containsAll) {
1:       oldSupers.removeAll(getAllSupers());
0:       return new BinaryCompatibilityStatus(false, "The superclasses or superinterfaces have stopped being super: " + oldSupers.toString());
1:     }
0:     return binaryCompatible;
1:   }
1: }
author:David Jencks
-------------------------------------------------------------------------------
commit:417a860
/////////////////////////////////////////////////////////////////////////
1: //    public ClassDeclaration(int access, String name, String signature, String superName,
1: //                            String[] interfaces, URLClassLoader loader) {
1: //        super(access, name, signature);
1: //        this.superName = superName;
1: //        this.interfaces = interfaces;
1: //        this.fields = new HashMap<String, FieldDeclaration>();
1: //        this.methods = new HashMap<String, Set<MethodDeclaration>>();
1: //        this.jarsLoader = loader;
1: //        this.serialVisitor = null;
1: //    }
/////////////////////////////////////////////////////////////////////////
1:                 SerialVersionClassVisitor cv = new SerialVersionClassVisitor(null);
/////////////////////////////////////////////////////////////////////////
1:             SerialVersionClassVisitor cv = new SerialVersionClassVisitor(null);
/////////////////////////////////////////////////////////////////////////
1:             SerialVersionClassVisitor cv = new SerialVersionClassVisitor(null);
/////////////////////////////////////////////////////////////////////////
0:                 Long oldValue = getSerialVersionUID(old);
0:                 Long curValue = getSerialVersionUID(this);
/////////////////////////////////////////////////////////////////////////
0:     private Long getSerialVersionUID(ClassDeclaration cd) {
0:         return cd.getSerialVisitor() == null? null: cd.getSerialVisitor().getComputeSerialVersionUID();
commit:490f397
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @return map of method name to set of method declarations
/////////////////////////////////////////////////////////////////////////
0:                 cr.accept(svc, 0);
0:                 ClassDeclaration cd = svc.getClassDeclaration();
0:                 if (cd != null) {
0:                     addFieldInUpperChain(cd.getFields());
0:                     getFieldsRecursively(cd.getSuperName());
0:                     for (String iface : cd.getInterfaces()) {
0:                         getFieldsRecursively(iface);
/////////////////////////////////////////////////////////////////////////
0:                 cr.accept(svc, 0);
0:                 ClassDeclaration cd = svc.getClassDeclaration();
0:                 if (cd != null) {
0:                     addMethodsInUpperChain(cd.getMethods());
0:                     getMethodsRecursively(cd.getSuperName());
0:                     for (String iface : cd.getInterfaces()) {
0:                         getMethodsRecursively(iface);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
1:         BinaryCompatibilityStatus reasons = new BinaryCompatibilityStatus();
1:             return reasons;
1:         getClassSignatureBinaryCompatibleStatus(old, reasons);
1:         getAllMethodsBinaryCompatibleStatus(old, reasons);
1:         getAllFieldsBinaryCompatibleStatus(old, reasons);
1:         getAllSuperPresentStatus(old, reasons);
1:         getSerializableBackCompatable(old, reasons);
1:         return reasons;
/////////////////////////////////////////////////////////////////////////
1:     private void getClassSignatureBinaryCompatibleStatus(ClassDeclaration originalClass, List<String> reasons) {
1:             reasons.add(prefix + " was not abstract but is changed to be abstract.");
1:             reasons.add(prefix + " was not final but is changed to be final.");
1:             reasons.add(prefix + " was public but is changed to be non-public.");
1:     private void getAllFieldsBinaryCompatibleStatus(ClassDeclaration originalClass, List<String> reasons) {
1:         areFieldsBinaryCompatible(oldFields, newFields, reasons);
1:     private void areFieldsBinaryCompatible(Map<String, FieldDeclaration> oldFields, Map<String, FieldDeclaration> currentFields, List<String> reasons) {
1:             isFieldBinaryCompatible(reasons, bef_fd, cur_fd);
1:     private boolean isFieldBinaryCompatible(List<String> reasons,
/////////////////////////////////////////////////////////////////////////
1:             String prefix = "The " + (bef_fd.isPublic() ? "public" : "protected") + " field " + fieldName;
1:                 reasons.add(prefix + " has been deleted.");
1:                     reasons.add(prefix + " was not final but has been changed to be final.");
1:                     reasons.add(prefix + " was static but is changed to be non static or vice versa.");
1:                     reasons.add(prefix + " has changed its type.");
1:                     reasons.add(prefix + " becomes less accessible.");
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param old Old class declaration
1:      * @param reasons list of binary compatibility problems
1:     private void getSerializableBackCompatable(ClassDeclaration old, List<String> reasons) {
1:         // It does not matter one of them is not serializable.
/////////////////////////////////////////////////////////////////////////
1:                     reasons.add("The serializable class is no longer back compatible as the value of SerialVersionUID has changed from " + oldValue + " to " + curValue + ".");
/////////////////////////////////////////////////////////////////////////
0:                     return (Long) (serialID.getValue());
/////////////////////////////////////////////////////////////////////////
1:     private void getAllMethodsBinaryCompatibleStatus(ClassDeclaration originalClass, List<String> reasons) {
1:         areMethodsBinaryCompatible(oldMethods, newMethods, reasons);
1:     private void areMethodsBinaryCompatible(
1:             Map<String, Set<MethodDeclaration>> oldMethods, Map<String, Set<MethodDeclaration>> newMethods, List<String> reasons) {
/////////////////////////////////////////////////////////////////////////
1:                 String prefix = "The " + SemanticVersioningUtils.getReadableMethodSignature(mdName, md.getDesc());
/////////////////////////////////////////////////////////////////////////
1:                                     reasons.add(prefix + " was not final but has been changed to be final.");
1:                                     reasons.add(prefix + " has changed from static to non-static or vice versa.");
1:                                 if ((Modifier.isAbstract(new_md.getAccess())) && (!Modifier.isAbstract(md.getAccess()))) {
1:                                     reasons.add(prefix + " has changed from non abstract to abstract.");
1:                                     reasons.add(prefix + " is less accessible.");
/////////////////////////////////////////////////////////////////////////
1:                             reasons.add(prefix + " has been deleted or its return type or parameter list has changed.");
/////////////////////////////////////////////////////////////////////////
1:                 String head = "The " + SemanticVersioningUtils.getReadableMethodSignature(md.getName(), md.getDesc());
1:                 isNewMethodSpecialCase(md, head, reasons);
1:      * @param old old class declaration
1:      * @return FieldDeclarations for fields added to new class
/////////////////////////////////////////////////////////////////////////
1:      * @param old old class declaration
1:      * @return method declarations for methods added to new class
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param md method declaration
1:      * @param prefix beginning of incompatibility message
1:      * @param reasons list of binary incompatibility reasons
1:      * @return whether new method is less accessible or changed static-ness compared to old class
1:     private boolean isNewMethodSpecialCase(MethodDeclaration md, String prefix, List<String> reasons) {
/////////////////////////////////////////////////////////////////////////
1:                             reasons.add(prefix + " is less accessible than the same method in its parent.");
1:                                 reasons.add(prefix + " is non-static but the same method in its parent is static.");
1:                                 reasons.add(prefix + " is static but the same method is its parent is not static.");
/////////////////////////////////////////////////////////////////////////
1:     private void getAllSuperPresentStatus(ClassDeclaration old, List<String> reasons) {
1:             reasons.add("The superclasses or superinterfaces have stopped being super: " + oldSupers.toString() + ".");
commit:9822203
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1: public class ClassDeclaration extends GenericDeclaration {
0:     // Binary Compatibility - deletion of package-level access field/method/constructors of classes and interfaces in the package
0:     // will not break binary compatibility when an entire package is updated.
0: 
0:     // Assumptions:
0:     // 1.  This tool assumes that the deletion of package-level fields/methods/constructors is not break binary compatibility
0:     // based on the assumption of the entire package is updated.
0:     //
0:     private final String superName;
0:     private final String[] interfaces;
0:     private final Map<String, FieldDeclaration> fields;
0:     private final Map<String, Set<MethodDeclaration>> methods;
0:     private final Map<String, Set<MethodDeclaration>> methodsInUpperChain = new HashMap<String, Set<MethodDeclaration>>();
0:     private final Map<String, FieldDeclaration> fieldsInUpperChain = new HashMap<String, FieldDeclaration>();
1:     private final Collection<String> supers = new ArrayList<String>();
0:     private final URLClassLoader jarsLoader;
0:     private final BinaryCompatibilityStatus binaryCompatible = new BinaryCompatibilityStatus(true, null);
1:     private final SerialVersionClassVisitor serialVisitor;
0: 
1:     public Map<String, FieldDeclaration> getFields() {
0:         return fields;
0:     public Map<String, FieldDeclaration> getAllFields() {
0:         Map<String, FieldDeclaration> allFields = new HashMap<String, FieldDeclaration>(getFields());
0:         Map<String, FieldDeclaration> fieldsFromSupers = getFieldsInUpperChain();
0:         putIfAbsent(allFields, fieldsFromSupers);
0: 
0: 
0:         return allFields;
0:     private void putIfAbsent(Map<String, FieldDeclaration> allFields,
1:                              Map<String, FieldDeclaration> fieldsFromSupers) {
0:         for (Map.Entry<String, FieldDeclaration> superFieldEntry : fieldsFromSupers.entrySet()) {
0:             String fieldName = superFieldEntry.getKey();
0:             FieldDeclaration fd = superFieldEntry.getValue();
0:             if (allFields.get(fieldName) == null) {
0:                 allFields.put(fieldName, fd);
0:         }
0:     }
0: 
0:     /**
0:      * Get the methods in the current class plus the methods in the upper chain
1:      *
0:      * @return
0:      */
0:     public Map<String, Set<MethodDeclaration>> getAllMethods() {
0: 
0:         Map<String, Set<MethodDeclaration>> methods = new HashMap<String, Set<MethodDeclaration>>(getMethods());
0:         Map<String, Set<MethodDeclaration>> methodsFromSupers = getMethodsInUpperChain();
0:         for (Map.Entry<String, Set<MethodDeclaration>> superMethodsEntry : methodsFromSupers.entrySet()) {
0:             Set<MethodDeclaration> overloadingMethods = methods.get(superMethodsEntry.getKey());
0:             if (overloadingMethods != null) {
0:                 overloadingMethods.addAll(superMethodsEntry.getValue());
0:             } else {
0:                 methods.put(superMethodsEntry.getKey(), superMethodsEntry.getValue());
0: 
0: 
0: 
0:         return methods;
1:     public Map<String, Set<MethodDeclaration>> getMethods() {
0:         return methods;
0: 
0:     public ClassDeclaration(int access, String name, String signature, String superName,
0:                             String[] interfaces, URLClassLoader loader) {
0:         super(access, name, signature);
0:         this.superName = superName;
0:         this.interfaces = interfaces;
0:         this.fields = new HashMap<String, FieldDeclaration>();
0:         this.methods = new HashMap<String, Set<MethodDeclaration>>();
0:         this.jarsLoader = loader;
0:         this.serialVisitor = null;
0:     public ClassDeclaration(int access, String name, String signature, String superName,
1:                             String[] interfaces, URLClassLoader loader, SerialVersionClassVisitor cv) {
0:         super(access, name, signature);
0:         this.superName = superName;
0:         this.interfaces = interfaces;
0:         this.fields = new HashMap<String, FieldDeclaration>();
0:         this.methods = new HashMap<String, Set<MethodDeclaration>>();
0:         this.jarsLoader = loader;
0:         this.serialVisitor = cv;
0:     private void getFieldsRecursively(String superClass) {
0: 
1:         if ((superClass != null)) {
0:             // load the super class of the cd
0:             try {
0:                 ClassVisitor cw = new EmptyClassVisitor();
0:                 SerialVersionClassVisitor cv = new SerialVersionClassVisitor(cw);
0:                 SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader, cv);
1:                 ClassReader cr = new ClassReader(jarsLoader.getResourceAsStream(superClass + SemanticVersioningUtils.classExt));
0:                 if (cr != null) {
0:                     cr.accept(svc, 0);
0:                     ClassDeclaration cd = svc.getClassDeclaration();
0:                     if (cd != null) {
0:                         addFieldInUpperChain(cd.getFields());
0:                         getFieldsRecursively(cd.getSuperName());
0:                         for (String iface : cd.getInterfaces()) {
0:                             getFieldsRecursively(iface);
0:                         }
0:                     }
0:                 }
0:             } catch (IOException ioe) {
0:                 // not a problem
1:     private void getMethodsRecursively(String superClass) {
1:         if ((superClass != null)) {
0:             // load the super class of the cd
0:             ClassVisitor cw = new EmptyClassVisitor();
0:             SerialVersionClassVisitor cv = new SerialVersionClassVisitor(cw);
0:             SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader, cv);
0:             // use URLClassLoader to load the class
0:             try {
1:                 ClassReader cr = new ClassReader(jarsLoader.getResourceAsStream(superClass + SemanticVersioningUtils.classExt));
0:                 if (cr != null) {
0:                     cr.accept(svc, 0);
0:                     ClassDeclaration cd = svc.getClassDeclaration();
0:                     if (cd != null) {
0:                         addMethodsInUpperChain(cd.getMethods());
0:                         getMethodsRecursively(cd.getSuperName());
0:                         for (String iface : cd.getInterfaces()) {
0:                             getMethodsRecursively(iface);
0:                         }
0:                     }
0:                 }
0:             } catch (IOException ioe) {
0:                 // not a deal
0:             }
0:     }
0: 
0:     public Map<String, FieldDeclaration> getFieldsInUpperChain() {
0:         if (fieldsInUpperChain.isEmpty()) {
0:             getFieldsRecursively(getSuperName());
0:             for (String ifs : getInterfaces()) {
0:                 getFieldsRecursively(ifs);
0:             }
0:         return fieldsInUpperChain;
0:     private void addFieldInUpperChain(Map<String, FieldDeclaration> fields) {
0:         putIfAbsent(fieldsInUpperChain, fields);
0: 
0:     }
0: 
0:     public Map<String, Set<MethodDeclaration>> getMethodsInUpperChain() {
0:         if (methodsInUpperChain.isEmpty()) {
0:             getMethodsRecursively(getSuperName());
0:             for (String ifs : getInterfaces()) {
0:                 getMethodsRecursively(ifs);
0:             }
0:         return methodsInUpperChain;
0: 
0:     private void addMethodsInUpperChain(Map<String, Set<MethodDeclaration>> methods) {
0:         for (Map.Entry<String, Set<MethodDeclaration>> method : methods.entrySet()) {
0:             String methodName = method.getKey();
0:             Set<MethodDeclaration> mds = new HashSet<MethodDeclaration>();
0:             if (methodsInUpperChain.get(methodName) != null) {
0:                 mds.addAll(methodsInUpperChain.get(methodName));
0:             }
0:             mds.addAll(method.getValue());
0: 
0:             methodsInUpperChain.put(methodName, mds);
0:         }
0: 
0:     public Collection<String> getUpperChainRecursively(String className) {
0:         Collection<String> clazz = new HashSet<String>();
0: 
1:         if (className != null) {
0:             // load the super class of the cd
0:             ClassVisitor cw = new EmptyClassVisitor();
0:             SerialVersionClassVisitor cv = new SerialVersionClassVisitor(cw);
0: 
0:             SemanticVersioningClassVisitor svc = new SemanticVersioningClassVisitor(jarsLoader, cv);
0:             try {
0:                 ClassReader cr = new ClassReader(jarsLoader.getResourceAsStream(className + SemanticVersioningUtils.classExt));
0:                 cr.accept(svc, 0);
0:                 clazz.add(className);
0:                 if (svc.getClassDeclaration() != null) {
0:                     String superName = svc.getClassDeclaration().getSuperName();
0:                     className = superName;
0:                     clazz.addAll(getUpperChainRecursively(superName));
0:                     if (svc.getClassDeclaration().getInterfaces() != null) {
0:                         for (String iface : svc.getClassDeclaration().getInterfaces()) {
0:                             clazz.addAll(getUpperChainRecursively(iface));
0:                         }
0:                     }
0:                 }
0:             } catch (IOException ioe) {
0:                 // not to worry about this. terminate.
0:             }
0:         }
0:         return clazz;
0:     }
0: 
0:     public Collection<String> getAllSupers() {
0:         if (supers.isEmpty()) {
0:             supers.addAll(getUpperChainRecursively(getSuperName()));
0:             for (String iface : getInterfaces()) {
0:                 supers.addAll(getUpperChainRecursively(iface));
0:             }
0:         }
0:         return supers;
0:     }
0: 
1:     public String getSuperName() {
0:         return superName;
0:     }
0: 
1:     public String[] getInterfaces() {
0:         return interfaces;
0:     }
0: 
0:     public void addFields(FieldDeclaration fd) {
0:         fields.put(fd.getName(), fd);
0:     }
0: 
0: 
1:     public void addMethods(MethodDeclaration md) {
0:         String key = md.getName();
0:         Set<MethodDeclaration> overloaddingMethods = methods.get(key);
0:         if (overloaddingMethods != null) {
0:             overloaddingMethods.add(md);
0:             methods.put(key, overloaddingMethods);
0:             Set<MethodDeclaration> mds = new HashSet<MethodDeclaration>();
0:             mds.add(md);
0:             methods.put(key, mds);
0:     public BinaryCompatibilityStatus getBinaryCompatibleStatus(ClassDeclaration old) {
0:         // check class signature, fields, methods
0:         if (old == null) {
0:             return binaryCompatible;
0:         }
0:         StringBuilder reason = new StringBuilder();
0:         boolean isCompatible = true;
0:         Set<BinaryCompatibilityStatus> bcsSet = new HashSet<BinaryCompatibilityStatus>();
0:         bcsSet.add(getClassSignatureBinaryCompatibleStatus(old));
0:         bcsSet.add(getAllMethodsBinaryCompatibleStatus(old));
0:         bcsSet.add(getAllFieldsBinaryCompatibleStatus(old));
0:         bcsSet.add(getAllSuperPresentStatus(old));
0:         bcsSet.add(getSerializableBackCompatable(old));
0:         for (BinaryCompatibilityStatus bcs : bcsSet) {
0:             if (!bcs.isCompatible()) {
0:                 isCompatible = false;
0:                 reason.append(bcs.getReason());
0:         }
0:         if (!isCompatible) {
0:             return new BinaryCompatibilityStatus(isCompatible, reason.toString());
0:         } else {
0:             return binaryCompatible;
0:         }
0:     }
0: 
0:     public boolean isAbstract() {
0:         return Modifier.isAbstract(getAccess());
0:     }
0: 
0:     private BinaryCompatibilityStatus getClassSignatureBinaryCompatibleStatus(ClassDeclaration originalClass) {
0:         // if a class was not abstract but changed to abstract
0:         // not final changed to final
0:         // public changed to non-public
1:         String prefix = " The class " + getName();
0:         StringBuilder reason = new StringBuilder();
0:         boolean compatible = true;
0:         if (!!!originalClass.isAbstract() && isAbstract()) {
0:             reason.append(prefix + " was not abstract but is changed to be abstract.");
0:             compatible = false;
0:         }
1:         if (!!!originalClass.isFinal() && isFinal()) {
0:             reason.append(prefix + " was not final but is changed to be final.");
0:             compatible = false;
0:         }
1:         if (originalClass.isPublic() && !!!isPublic()) {
0:             reason.append(prefix + " was public but is changed to be non-public.");
0:             compatible = false;
0:         }
0:         return new BinaryCompatibilityStatus(compatible, compatible ? null : reason.toString());
0:     }
0: 
0:     public BinaryCompatibilityStatus getAllFieldsBinaryCompatibleStatus(ClassDeclaration originalClass) {
0:         // for each field to see whether the same field has changed
0:         // not final -> final
0:         // static <-> nonstatic
0:         Map<String, FieldDeclaration> oldFields = originalClass.getAllFields();
0:         Map<String, FieldDeclaration> newFields = getAllFields();
0:         return areFieldsBinaryCompatible(oldFields, newFields);
0:     }
0: 
0:     private BinaryCompatibilityStatus areFieldsBinaryCompatible(Map<String, FieldDeclaration> oldFields, Map<String, FieldDeclaration> currentFields) {
0: 
0:         boolean overallCompatible = true;
0:         StringBuilder reason = new StringBuilder();
0: 
0:         for (Map.Entry<String, FieldDeclaration> entry : oldFields.entrySet()) {
0:             FieldDeclaration bef_fd = entry.getValue();
0:             FieldDeclaration cur_fd = currentFields.get(entry.getKey());
0: 
0:             boolean compatible = isFieldBinaryCompatible(reason, bef_fd, cur_fd);
0:             if (!compatible) {
0:                 overallCompatible = compatible;
0:             }
0: 
0:         }
0:         if (!overallCompatible) {
0:             return new BinaryCompatibilityStatus(overallCompatible, reason.toString());
0:         } else {
0:             return binaryCompatible;
0:         }
0:     }
0: 
0:     private boolean isFieldBinaryCompatible(StringBuilder reason,
1:                                             FieldDeclaration bef_fd, FieldDeclaration cur_fd) {
0:         String fieldName = bef_fd.getName();
0:         //only interested in the public or protected fields
0: 
0:         boolean compatible = true;
0: 
0:         if (bef_fd.isPublic() || bef_fd.isProtected()) {
0:             String prefix = htmlOneLineBreak + "The " + (bef_fd.isPublic() ? "public" : "protcted") + " field " + fieldName;
0: 
0: 
0:             if (cur_fd == null) {
0:                 reason.append(prefix + " has been deleted.");
0:                 compatible = false;
0: 
0:                 if ((!!!bef_fd.isFinal()) && (cur_fd.isFinal())) {
0:                     // make sure it has not been changed to final
0:                     reason.append(prefix + " was not final but has been changed to be final.");
0:                     compatible = false;
0: 
1:                 if (bef_fd.isStatic() != cur_fd.isStatic()) {
0:                     // make sure it the static signature has not been changed
0:                     reason.append(prefix + " was static but is changed to be non static or vice versa.");
0:                     compatible = false;
0:                 }
0:                 // check to see the field type is the same
1:                 if (!isFieldTypeSame(bef_fd, cur_fd)) {
0:                     reason.append(prefix + " has changed its type.");
0:                     compatible = false;
0: 
0:                 }
1:                 if (SemanticVersioningUtils.isLessAccessible(bef_fd, cur_fd)) {
0:                     // check whether the new field is less accessible than the old one
0:                     reason.append(prefix + " becomes less accessible.");
0:                     compatible = false;
0:                 }
0: 
0:         return compatible;
0:     /**
0:      * Return whether the serializable class is binary compatible. The serial verison uid change breaks binary compatibility.
1:      *
0:      * @param old
0:      * @return
0:      */
0:     private BinaryCompatibilityStatus getSerializableBackCompatable(ClassDeclaration old) {
0:         // It does not matter one of them is not seralizable.
0:         boolean serializableBackCompatible = true;
0:         String reason = null;
1:         if ((getAllSupers().contains(SemanticVersioningUtils.SERIALIZABLE_CLASS_IDENTIFIER)) && (old.getAllSupers().contains(SemanticVersioningUtils.SERIALIZABLE_CLASS_IDENTIFIER))) {
0:             // check to see whether the serializable id is the same
0:             //ignore if it is enum
0:             if ((!getAllSupers().contains(SemanticVersioningUtils.ENUM_CLASS) && (!old.getAllSupers().contains(SemanticVersioningUtils.ENUM_CLASS)))) {
0:                 long oldValue = getSerialVersionUID(old);
0:                 long curValue = getSerialVersionUID(this);
0:                 if ((oldValue != curValue)) {
0:                     serializableBackCompatible = false;
0:                     reason = htmlOneLineBreak + "The serializable class is no longer back compatible as the value of SerialVersionUID has changed from " + oldValue + " to " + curValue + ".";
0:                 }
0:         if (!serializableBackCompatible) {
0:             return new BinaryCompatibilityStatus(serializableBackCompatible, reason);
0:         return binaryCompatible;
0:     private long getSerialVersionUID(ClassDeclaration cd) {
0:         FieldDeclaration serialID = cd.getAllFields().get(SemanticVersioningUtils.SERIAL_VERSION_UTD);
0:         if (serialID != null) {
0:             if (serialID.isFinal() && serialID.isStatic() && Type.LONG_TYPE.equals(Type.getType(serialID.getDesc()))) {
0:                 if (serialID.getValue() != null) {
0:                     return ((Long) (serialID.getValue())).longValue();
0:                 } else {
0:                     return 0;
0:                 }
0:         // get the generated value
0:         return cd.getSerialVisitor().getComputeSerialVersionUID();
0: 
1:     private boolean isFieldTypeSame(FieldDeclaration bef_fd, FieldDeclaration cur_fd) {
0:         boolean descSame = bef_fd.getDesc().equals(cur_fd.getDesc());
0:         if (descSame) {
0:             // check whether the signatures are the same
0:             if ((bef_fd.getSignature() == null) && (cur_fd.getSignature() == null)) {
0: 
0:                 return true;
0:             }
0:             if ((bef_fd.getSignature() != null) && (bef_fd.getSignature().equals(cur_fd.getSignature()))) {
0:                 return true;
0:             }
0:         }
0:         return false;
0: 
0: 
0:     private BinaryCompatibilityStatus getAllMethodsBinaryCompatibleStatus(ClassDeclaration originalClass) {
0:         //  for all methods
0:         // no methods should have deleted
0:         // method return type has not changed
0:         // method changed from not abstract -> abstract
0:         Map<String, Set<MethodDeclaration>> oldMethods = originalClass.getAllMethods();
0:         Map<String, Set<MethodDeclaration>> newMethods = getAllMethods();
0:         return areMethodsBinaryCompatible(oldMethods, newMethods);
0:     }
0: 
0:     public BinaryCompatibilityStatus areMethodsBinaryCompatible(
0:             Map<String, Set<MethodDeclaration>> oldMethods, Map<String, Set<MethodDeclaration>> newMethods) {
0: 
0:         StringBuilder reason = new StringBuilder();
0:         boolean compatible = true;
0:         Map<String, Collection<MethodDeclaration>> extraMethods = new HashMap<String, Collection<MethodDeclaration>>();
0: 
0:         for (Map.Entry<String, Set<MethodDeclaration>> me : newMethods.entrySet()) {
0:             Collection<MethodDeclaration> mds = new ArrayList<MethodDeclaration>(me.getValue());
0:             extraMethods.put(me.getKey(), mds);
0:         }
0: 
0:         for (Map.Entry<String, Set<MethodDeclaration>> methods : oldMethods.entrySet()) {
0:             // all overloading methods, check against the current class
0:             String methodName = methods.getKey();
0:             Collection<MethodDeclaration> oldMDSigs = methods.getValue();
0:             // If the method cannot be found in the current class, it means that it has been deleted.
0:             Collection<MethodDeclaration> newMDSigs = newMethods.get(methodName);
0:             // for each overloading methods
1:             outer:
1:             for (MethodDeclaration md : oldMDSigs) {
0:                 String mdName = md.getName();
0: 
0:                 String prefix = htmlOneLineBreak + "The " + SemanticVersioningUtils.getReadableMethodSignature(mdName, md.getDesc());
0:                 if (md.isProtected() || md.isPublic()) {
0:                     boolean found = false;
0:                     if (newMDSigs != null) {
0:                         // try to find it in the current class
0:                         for (MethodDeclaration new_md : newMDSigs) {
0:                             // find the method with the same return type, parameter list
1:                             if ((md.equals(new_md))) {
0:                                 found = true;
0:                                 // If the old method is final but the new one is not or vice versa
0:                                 // If the old method is static but the new one is non static
0:                                 // If the old method is not abstract but the new is
0: 
1:                                 if (!!!Modifier.isFinal(md.getAccess()) && !!!Modifier.isStatic(md.getAccess()) && Modifier.isFinal(new_md.getAccess())) {
0:                                     compatible = false;
0:                                     reason.append(prefix + " was not final but has been changed to be final.");
0:                                 }
1:                                 if (Modifier.isStatic(md.getAccess()) != Modifier.isStatic(new_md.getAccess())) {
0:                                     compatible = false;
0:                                     reason.append(prefix + " has changed from static to non-static or vice versa.");
0:                                 }
0:                                 if ((Modifier.isAbstract(new_md.getAccess()) == true) && (Modifier.isAbstract(md.getAccess()) == false)) {
0:                                     compatible = false;
0:                                     reason.append(prefix + " has changed from non abstract to abstract. ");
0:                                 }
0:                                 if (SemanticVersioningUtils.isLessAccessible(md, new_md)) {
0:                                     compatible = false;
0:                                     reason.append(prefix + " is less accessible.");
0:                                 }
0: 
0:                                 if (compatible) {
0:                                     // remove from the extra map
0:                                     Collection<MethodDeclaration> mds = extraMethods.get(methodName);
0:                                     mds.remove(new_md);
0:                                     extraMethods.put(methodName, mds);
0:                                     continue outer;
0:                                 }
0:                             }
0:                         }
0:                     }
0: 
0:                     //
0:                     // if we are here, it means that we have not found the method with the same description and signature
0:                     // which means that the method has been deleted. Let's make sure it is not moved to its upper chain.
1:                     if (!found) {
0:                         if (!isMethodInSuperClass(md)) {
0: 
0:                             compatible = false;
0:                             reason.append(prefix + " has been deleted or its return type or parameter list has changed.");
0:                         } else {
0:                             if (newMDSigs != null) {
0:                                 for (MethodDeclaration new_md : newMDSigs) {
0:                                     // find the method with the same return type, parameter list
1:                                     if ((md.equals(new_md))) {
0:                                         Collection<MethodDeclaration> mds = extraMethods.get(methodName);
0:                                         mds.remove(new_md);
0:                                         extraMethods.put(methodName, mds);
0:                                     }
0:                                 }
0:                             }
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0: 
0:         // Check the newly added method has not caused binary incompatibility
1:         for (Map.Entry<String, Collection<MethodDeclaration>> extraMethodSet : extraMethods.entrySet()) {
0:             for (MethodDeclaration md : extraMethodSet.getValue()) {
0:                 String head = htmlOneLineBreak + "The " + SemanticVersioningUtils.getReadableMethodSignature(md.getName(), md.getDesc());
0:                 if (isNewMethodSpecialCase(md, head, reason)) {
0:                     compatible = false;
0:                 }
0:             }
0:         }
0:         if (compatible) {
0:             return binaryCompatible;
0:         } else {
0:             return new BinaryCompatibilityStatus(compatible, reason.toString());
0:         }
0:     }
0: 
0:     /**
0:      * Return the newly added fields
1:      *
0:      * @param old
0:      * @return
0:      */
0:     public Collection<FieldDeclaration> getExtraFields(ClassDeclaration old) {
0:         Map<String, FieldDeclaration> oldFields = old.getAllFields();
0:         Map<String, FieldDeclaration> newFields = getAllFields();
0:         Map<String, FieldDeclaration> extraFields = new HashMap<String, FieldDeclaration>(newFields);
0:         for (String key : oldFields.keySet()) {
0:             extraFields.remove(key);
0:         }
0:         return extraFields.values();
0:     }
0: 
0:     /**
0:      * Return the extra non-private methods
1:      *
0:      * @param old
0:      * @return
0:      */
1:     public Collection<MethodDeclaration> getExtraMethods(ClassDeclaration old) {
0:         // Need to find whether there are new methods added.
0:         Collection<MethodDeclaration> extraMethods = new HashSet<MethodDeclaration>();
0:         Map<String, Set<MethodDeclaration>> currMethodsMap = getAllMethods();
0:         Map<String, Set<MethodDeclaration>> oldMethodsMap = old.getAllMethods();
0: 
0:         for (Map.Entry<String, Set<MethodDeclaration>> currMethod : currMethodsMap.entrySet()) {
0:             String methodName = currMethod.getKey();
0:             Collection<MethodDeclaration> newMethods = currMethod.getValue();
0: 
0:             // for each  method, we look for whether it exists in the old class
0:             Collection<MethodDeclaration> oldMethods = oldMethodsMap.get(methodName);
0:             for (MethodDeclaration new_md : newMethods) {
1:                 if (!new_md.isPrivate()) {
0:                     if (oldMethods == null) {
0:                         extraMethods.add(new_md);
0:                     } else {
0:                         if (!oldMethods.contains(new_md)) {
0:                             extraMethods.add(new_md);
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0:         return extraMethods;
0:     }
0: 
1:     public boolean isMethodInSuperClass(MethodDeclaration md) {
0:         // scan the super class and interfaces
0:         String methodName = md.getName();
0:         Collection<MethodDeclaration> overloaddingMethods = getMethodsInUpperChain().get(methodName);
0:         if (overloaddingMethods != null) {
0:             for (MethodDeclaration value : overloaddingMethods) {
0:                 // method signature and name same and also the method should not be less accessible
1:                 if (md.equals(value) && (!!!SemanticVersioningUtils.isLessAccessible(md, value)) && (value.isStatic() == md.isStatic())) {
0:                     return true;
0:                 }
0:             }
0:         }
0:         return false;
0:     }
0: 
0: 
0:     /**
0:      * The newly added method is less accessible than the old one in the super or is a static (respectively instance) method.
1:      *
0:      * @param md
0:      * @return
0:      */
0:     public boolean isNewMethodSpecialCase(MethodDeclaration md, String prefix, StringBuilder reason) {
0:         // scan the super class and interfaces
0:         String methodName = md.getName();
0:         boolean special = false;
0:         Collection<MethodDeclaration> overloaddingMethods = getMethodsInUpperChain().get(methodName);
0:         if (overloaddingMethods != null) {
0:             for (MethodDeclaration value : overloaddingMethods) {
0:                 // method signature and name same and also the method should not be less accessible
0:                 if (!SemanticVersioningUtils.CONSTRUTOR.equals(md.getName())) {
0:                     if (md.equals(value)) {
0:                         if (SemanticVersioningUtils.isLessAccessible(value, md)) {
1:                             special = true;
0:                             reason.append(prefix + " is less accessible than the same method in its parent.");
0:                         }
0:                         if (value.isStatic()) {
0:                             if (!md.isStatic()) {
1:                                 special = true;
0:                                 reason.append(prefix + " is non-static but the same method in its parent is static.");
0:                             }
0:                         } else {
0:                             if (md.isStatic()) {
1:                                 special = true;
0:                                 reason.append(prefix + " is static but the same method is its parent is not static.");
0:                             }
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0:         return special;
0:     }
0: 
0:     public BinaryCompatibilityStatus getAllSuperPresentStatus(ClassDeclaration old) {
0:         Collection<String> oldSupers = old.getAllSupers();
0:         boolean containsAll = getAllSupers().containsAll(oldSupers);
0:         if (!!!containsAll) {
0:             oldSupers.removeAll(getAllSupers());
0:             return new BinaryCompatibilityStatus(false, htmlTwoLineBreaks + "The superclasses or superinterfaces have stopped being super: " + oldSupers.toString() + ".");
0:         }
0:         return binaryCompatible;
0:     }
0: 
1:     public SerialVersionClassVisitor getSerialVisitor() {
0:         return serialVisitor;
0:     }
0: 
============================================================================