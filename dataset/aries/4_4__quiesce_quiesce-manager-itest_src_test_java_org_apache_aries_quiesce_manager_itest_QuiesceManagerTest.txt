1:74884c6: /*  Licensed to the Apache Software Foundation (ASF) under one or more
1:74884c6:  *  contributor license agreements.  See the NOTICE file distributed with
1:74884c6:  *  this work for additional information regarding copyright ownership.
1:74884c6:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:74884c6:  *  (the "License"); you may not use this file except in compliance with
1:74884c6:  *  the License.  You may obtain a copy of the License at
1:74884c6:  *
1:74884c6:  *     http://www.apache.org/licenses/LICENSE-2.0
1:74884c6:  *
1:74884c6:  *  Unless required by applicable law or agreed to in writing, software
1:74884c6:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:74884c6:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:74884c6:  *  See the License for the specific language governing permissions and
1:74884c6:  *  limitations under the License.
1:74884c6:  */
1:74884c6: package org.apache.aries.quiesce.manager.itest;
4:2f3073f: 
1:74884c6: import java.util.ArrayList;
1:2f3073f: import java.util.Arrays;
1:74884c6: import java.util.List;
1:2f3073f: import java.util.concurrent.Future;
1:2f3073f: import java.util.concurrent.TimeUnit;
1:2f3073f: import java.util.concurrent.TimeoutException;
1:2f3073f: 
1:86224ba: import org.apache.aries.itest.AbstractIntegrationTest;
1:74884c6: import org.apache.aries.quiesce.manager.QuiesceManager;
1:74884c6: import org.apache.aries.quiesce.participant.QuiesceParticipant;
1:2f3073f: import org.junit.After;
1:74884c6: import org.junit.Before;
1:74884c6: import org.junit.Test;
1:74884c6: import org.junit.runner.RunWith;
1:2d9cc78: import org.ops4j.pax.exam.Configuration;
1:74884c6: import org.ops4j.pax.exam.Option;
1:2d9cc78: import org.ops4j.pax.exam.junit.PaxExam;
1:2d9cc78: import org.ops4j.pax.exam.spi.reactors.ExamReactorStrategy;
1:2d9cc78: import org.ops4j.pax.exam.spi.reactors.PerClass;
1:2d9cc78: import org.ops4j.pax.exam.spi.reactors.PerMethod;
1:74884c6: import org.osgi.framework.Bundle;
1:2f3073f: 
1:2d9cc78: import static org.junit.Assert.assertEquals;
1:2d9cc78: import static org.junit.Assert.assertTrue;
1:2d9cc78: import static org.junit.Assert.fail;
1:2d9cc78: import static org.ops4j.pax.exam.CoreOptions.composite;
1:2d9cc78: import static org.ops4j.pax.exam.CoreOptions.junitBundles;
1:2d9cc78: import static org.ops4j.pax.exam.CoreOptions.mavenBundle;
1:2d9cc78: import static org.ops4j.pax.exam.CoreOptions.systemProperty;
1:2d9cc78: import static org.ops4j.pax.exam.CoreOptions.vmOption;
1:2d9cc78: import static org.ops4j.pax.exam.CoreOptions.when;
1:2d9cc78: 
1:2d9cc78: @RunWith(PaxExam.class)
1:2d9cc78: @ExamReactorStrategy(PerMethod.class)
1:86224ba: public class QuiesceManagerTest extends AbstractIntegrationTest {
1:2f3073f:     private QuiesceManager manager;
1:2f3073f:     private Bundle b1;
1:2f3073f:     private Bundle b2;
1:2f3073f:     private Bundle b3;
1:2f3073f:     private long timeoutTime;
1:2f3073f:     private List<Bundle> bundleList;
1:2f3073f:     private MockQuiesceParticipant participant1;
1:2f3073f:     private MockQuiesceParticipant participant2;
1:2f3073f:     private MockQuiesceParticipant participant3;
1:2f3073f: 
1:2f3073f: 
1:2f3073f:     @Before
1:2f3073f:     public void setup() {
1:86224ba:         manager = context().getService(QuiesceManager.class);
1:2f3073f:         b1 = bundleContext.getBundle(5);
1:2f3073f:         b2 = bundleContext.getBundle(6);
1:2f3073f:         b3 = bundleContext.getBundle(10);
1:2f3073f:         participant1 = new MockQuiesceParticipant(MockQuiesceParticipant.RETURNIMMEDIATELY);
1:2f3073f:         participant2 = new MockQuiesceParticipant(MockQuiesceParticipant.NEVERRETURN);
1:2f3073f:         participant3 = new MockQuiesceParticipant(MockQuiesceParticipant.WAIT);
1:2f3073f: 
13:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @After
1:2f3073f:     public void after() {
1:2f3073f:         participant1.reset();
1:2f3073f:         participant2.reset();
1:2f3073f:         participant3.reset();
1:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @Test
1:2f3073f:     public void testNullSafe() throws Exception {
1:2f3073f:         //Check we're null safe
1:2f3073f:         manager.quiesce(null);  
1:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @Test
1:2f3073f:     public void testNoParticipants() throws Exception {
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b1);
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:2f3073f: 
1:2f3073f:         //Try quiescing one bundle with no participants
1:2f3073f:         manager.quiesceWithFuture(2000, bundleList).get(5000, TimeUnit.MILLISECONDS);
1:2f3073f: 
1:2f3073f:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @Test
1:2f3073f:     public void testImmediateReturn() throws Exception {
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b1);
1:2f3073f:         //Register a mock participant which will report back quiesced immediately
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
1:2f3073f:         //Try quiescing the bundle with immediate return
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:2f3073f:         
1:2f3073f:         manager.quiesceWithFuture(1000,bundleList).get(5000, TimeUnit.MILLISECONDS);
1:2f3073f:         
1:98b0a0b:         assertEquals("Participant should have finished once", 1, participant1.getFinishedCount());
1:2f3073f:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @Test
1:2f3073f:     public void testNoReturn() throws Exception {
1:2f3073f:         //Register a mock participant which won't respond
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:2f3073f:         //recreate the list as it may have been emptied?
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b1);
1:2f3073f: 
1:2f3073f:         //Try quiescing the bundle with no return
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:2f3073f:         manager.quiesce(1000,bundleList);
1:2f3073f:         timeoutTime = System.currentTimeMillis()+5000;
1:2f3073f:         while (System.currentTimeMillis() < timeoutTime && b1.getState() == Bundle.ACTIVE){
1:2f3073f:             Thread.sleep(500);
1:2f3073f:         }
1:2f3073f:         
1:98b0a0b:         assertEquals("Participant should have started once", 1, participant2.getStartedCount());
1:98b0a0b:         assertEquals("Participant should not have finished", 0, participant2.getFinishedCount());
1:2f3073f:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @Test
1:2f3073f:     public void testWaitAShortTime() throws Exception {
1:2f3073f:         //Try quiescing where participant takes 5s to do the work. We should get InterruptedException
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:2f3073f:         //recreate the list as it may have been emptied?
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b1);
1:2f3073f: 
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:2f3073f:         
1:2f3073f:         // we should be finishing in about 5000 millis not 10000
1:2f3073f:         manager.quiesceWithFuture(10000,bundleList).get(7000, TimeUnit.MILLISECONDS);
1:2f3073f: 
1:98b0a0b:         assertEquals("Participant should have started once", 1, participant3.getStartedCount());
1:98b0a0b:         assertEquals("Participant should finished once", 1, participant3.getFinishedCount());
1:2f3073f:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @Test
1:2f3073f:     public void testThreeParticipants() throws Exception {
1:2f3073f:         //Register three participants. One returns immediately, one waits 5s then returns, one never returns
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:2f3073f:         //recreate the list as it may have been emptied
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b1);
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:2f3073f:         
1:2f3073f:         manager.quiesceWithFuture(10000,bundleList).get(15000, TimeUnit.MILLISECONDS);
1:2f3073f:         
1:98b0a0b:         assertEquals("Participant 1 should have started once", 1, participant1.getStartedCount());
1:98b0a0b:         assertEquals("Participant 1 should finished once", 1, participant1.getFinishedCount());
1:98b0a0b:         assertEquals("Participant 2 should have started once", 1, participant2.getStartedCount());
1:98b0a0b:         assertEquals("Participant 2 should not have finished", 0, participant2.getFinishedCount());
1:98b0a0b:         assertEquals("Participant 3 should have started once", 1, participant3.getStartedCount());
1:98b0a0b:         assertEquals("Participant 3 should finished once", 1, participant3.getFinishedCount());
1:2f3073f:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @Test
1:2f3073f:     public void testFuture() throws Exception {
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b1);
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:2f3073f: 
1:2f3073f:         Future<?> future = manager.quiesceWithFuture(2000, Arrays.asList(b1));
1:2f3073f: 
1:2f3073f:         // causes us to wait
1:2f3073f:         future.get();
1:2f3073f: 
1:2f3073f:         assertEquals("Participant 2 has started", 1, participant2.getStartedCount());
1:2f3073f:         assertEquals("Participant 2 has finished", 0, participant2.getFinishedCount());
1:2f3073f:         assertEquals("Participant 3 has started", 1, participant3.getStartedCount());
1:2f3073f:         assertEquals("Participant 3 has finished", 1, participant3.getFinishedCount());
1:2f3073f:     }
1:2f3073f:     
1:2f3073f:     @Test
1:2f3073f:     public void testFutureWithWait() throws Exception {
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b1);
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:2f3073f: 
1:2f3073f:         Future<?> future = manager.quiesceWithFuture(2000, Arrays.asList(b1));
1:2f3073f: 
2:2f3073f:         try {
1:2f3073f:             // causes us to wait, but too short
1:2f3073f:             future.get(500, TimeUnit.MILLISECONDS);
1:2f3073f:             fail("Too short wait, should have thrown TimeoutException");
1:2f3073f:         } catch (TimeoutException te) {
1:2f3073f:             // expected
1:2f3073f:         }
1:2f3073f: 
1:2f3073f:         assertEquals("Participant 2 has started", 1, participant2.getStartedCount());
1:2f3073f:         assertEquals("Participant 2 has finished", 0, participant2.getFinishedCount());
1:2f3073f:         assertEquals("Participant 3 has started", 1, participant3.getStartedCount());
1:2f3073f:         assertEquals("Participant 3 has finished", 0, participant3.getFinishedCount());
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should still be active, because we did not wait long enough", Bundle.ACTIVE, b1.getState());
1:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @Test
1:2f3073f:     public void testTwoBundles() throws Exception {
1:2f3073f:         //Register three participants. One returns immediately, one waits 5s then returns, one never returns
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:2f3073f:         //recreate the list as it may have been emptied
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b1);
1:2f3073f:         bundleList.add(b2);
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:98b0a0b:         assertEquals("Bundle "+b2.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b2.getState());
1:2f3073f: 
1:2f3073f:         manager.quiesceWithFuture(10000,bundleList).get(15000, TimeUnit.MILLISECONDS);
1:2f3073f: 
1:98b0a0b:         assertEquals("Participant 1 should have started once", 1, participant1.getStartedCount());
1:98b0a0b:         assertEquals("Participant 1 should finished once", 1, participant1.getFinishedCount());
1:98b0a0b:         assertEquals("Participant 2 should have started once", 1, participant2.getStartedCount());
1:98b0a0b:         assertEquals("Participant 2 should not have finished", 0, participant2.getFinishedCount());
1:98b0a0b:         assertEquals("Participant 3 should have started once", 1, participant3.getStartedCount());
1:98b0a0b:         assertEquals("Participant 3 should finished once", 1, participant3.getFinishedCount());
1:2f3073f:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:2f3073f:         assertTrue("Bundle "+b2.getSymbolicName()+" should not be in active state", b2.getState() != Bundle.ACTIVE);
1:2f3073f:     }
1:2f3073f: 
1:2f3073f:     @Test
1:2f3073f:     public void testOverlappedQuiesces() throws Exception {
1:2f3073f: 
1:2f3073f:         //Register three participants. One returns immediately, one waits 5s then returns, one never returns
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:2f3073f:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:2f3073f:         //recreate the list as it may have been emptied
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b1);
1:2f3073f:         bundleList.add(b2);
1:98b0a0b:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:98b0a0b:         assertEquals("Bundle "+b2.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b2.getState());
1:98b0a0b:         assertEquals("Bundle "+b3.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b3.getState());
1:2f3073f:         manager.quiesce(2000,bundleList);
1:2f3073f:         bundleList = new ArrayList<Bundle>();
1:2f3073f:         bundleList.add(b2);
1:2f3073f:         bundleList.add(b3);
1:2f3073f:         manager.quiesce(2000,bundleList);
1:2f3073f:         timeoutTime = System.currentTimeMillis()+10000;
1:2f3073f:         while (System.currentTimeMillis() < timeoutTime && (b1.getState() == Bundle.ACTIVE || b2.getState() == Bundle.ACTIVE || b3.getState() == Bundle.ACTIVE)) {
1:2f3073f:             Thread.sleep(500);
1:2f3073f:         }
1:98b0a0b:         assertEquals("Participant 1 should have started twice as it has been asked to quiesce twice", 2, participant1.getStartedCount());
1:98b0a0b:         assertEquals("Participant 1 should finished twice as it should have returned from two quiesce requests immediately", 2, participant1.getFinishedCount());
1:98b0a0b:         assertEquals("Participant 2 should have started twice as it has been asked to quiesce twice", 2, participant2.getStartedCount());
1:98b0a0b:         assertEquals("Participant 2 should not have finished as it should never return from it's two quiesce requests", 0, participant2.getFinishedCount());
1:98b0a0b:         assertEquals("Participant 3 should have started twice as it has been asked to quiesce twice", 2, participant3.getStartedCount());
1:98b0a0b:         assertEquals("Participant 3 should finished twice as it should have waited a short time before returning from it's two quiesce requests", 2, participant3.getFinishedCount());
1:2f3073f:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:2f3073f:         assertTrue("Bundle "+b2.getSymbolicName()+" should not be in active state", b2.getState() != Bundle.ACTIVE);
1:2f3073f:         assertTrue("Bundle "+b3.getSymbolicName()+" should not be in active state", b3.getState() != Bundle.ACTIVE);
1:2f3073f:     }
1:2f3073f: 
1:2d9cc78:     public Option baseOptions() {
1:2d9cc78:         String localRepo = getLocalRepo();
1:2d9cc78:         return composite(
1:2d9cc78:                 junitBundles(),
1:2d9cc78:                 // this is how you set the default log level when using pax
1:2d9cc78:                 // logging (logProfile)
1:2d9cc78:                 systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("INFO"),
1:2d9cc78:                 when(localRepo != null).useOptions(vmOption("-Dorg.ops4j.pax.url.mvn.localRepository=" + localRepo))
1:2d9cc78:         );
1:2d9cc78:     }
1:2f3073f: 
1:2d9cc78:     @Configuration
1:2d9cc78:     public Option[] configuration() {
1:2d9cc78:         return new Option[]{
1:2d9cc78:                 baseOptions(),
1:2f3073f:                 // Bundles
1:2d9cc78:                 mavenBundle("org.osgi", "org.osgi.compendium").versionAsInProject(),
1:2d9cc78:                 mavenBundle("org.apache.aries", "org.apache.aries.util").versionAsInProject(),
1:2d9cc78:                 mavenBundle("commons-lang", "commons-lang").versionAsInProject(),
1:2d9cc78:                 mavenBundle("commons-collections", "commons-collections").versionAsInProject(),
1:2d9cc78:                 mavenBundle("commons-pool", "commons-pool").versionAsInProject(),
1:2d9cc78:                 mavenBundle("org.apache.servicemix.bundles", "org.apache.servicemix.bundles.serp").versionAsInProject(),
1:2d9cc78:                 mavenBundle("org.apache.aries.quiesce", "org.apache.aries.quiesce.api").versionAsInProject(),
1:2d9cc78:                 mavenBundle("org.apache.aries.quiesce", "org.apache.aries.quiesce.manager").versionAsInProject(),
1:2d9cc78:                 mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit").versionAsInProject(),
1:2d9cc78: 
1:79902ae:                 //new VMOption( "-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000" ),
1:79902ae:                 //new TimeoutOption( 0 ),
1:2f3073f: 
1:2d9cc78:         };
1:2f3073f:     }
1:2f3073f: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:2d9cc78
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.ops4j.pax.exam.Configuration;
1: import org.ops4j.pax.exam.junit.PaxExam;
1: import org.ops4j.pax.exam.spi.reactors.ExamReactorStrategy;
1: import org.ops4j.pax.exam.spi.reactors.PerClass;
1: import org.ops4j.pax.exam.spi.reactors.PerMethod;
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: import static org.ops4j.pax.exam.CoreOptions.composite;
1: import static org.ops4j.pax.exam.CoreOptions.junitBundles;
1: import static org.ops4j.pax.exam.CoreOptions.mavenBundle;
1: import static org.ops4j.pax.exam.CoreOptions.systemProperty;
1: import static org.ops4j.pax.exam.CoreOptions.vmOption;
1: import static org.ops4j.pax.exam.CoreOptions.when;
1: 
1: @RunWith(PaxExam.class)
1: @ExamReactorStrategy(PerMethod.class)
/////////////////////////////////////////////////////////////////////////
1:     public Option baseOptions() {
1:         String localRepo = getLocalRepo();
1:         return composite(
1:                 junitBundles(),
1:                 // this is how you set the default log level when using pax
1:                 // logging (logProfile)
1:                 systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("INFO"),
1:                 when(localRepo != null).useOptions(vmOption("-Dorg.ops4j.pax.url.mvn.localRepository=" + localRepo))
1:         );
1:     }
1:     @Configuration
1:     public Option[] configuration() {
1:         return new Option[]{
1:                 baseOptions(),
1:                 mavenBundle("org.osgi", "org.osgi.compendium").versionAsInProject(),
1:                 mavenBundle("org.apache.aries", "org.apache.aries.util").versionAsInProject(),
1:                 mavenBundle("commons-lang", "commons-lang").versionAsInProject(),
1:                 mavenBundle("commons-collections", "commons-collections").versionAsInProject(),
1:                 mavenBundle("commons-pool", "commons-pool").versionAsInProject(),
1:                 mavenBundle("org.apache.servicemix.bundles", "org.apache.servicemix.bundles.serp").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.quiesce", "org.apache.aries.quiesce.api").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.quiesce", "org.apache.aries.quiesce.manager").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit").versionAsInProject(),
1: 
1:         };
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:86224ba
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.itest.ExtraOptions.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.itest.AbstractIntegrationTest;
1: public class QuiesceManagerTest extends AbstractIntegrationTest {
/////////////////////////////////////////////////////////////////////////
1:         manager = context().getService(QuiesceManager.class);
/////////////////////////////////////////////////////////////////////////
0:         return testOptions(
0:                 paxLogging("DEBUG"),
/////////////////////////////////////////////////////////////////////////
commit:98b0a0b
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:         assertEquals("Participant should have finished once", 1, participant1.getFinishedCount());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:         assertEquals("Participant should have started once", 1, participant2.getStartedCount());
1:         assertEquals("Participant should not have finished", 0, participant2.getFinishedCount());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:         assertEquals("Participant should have started once", 1, participant3.getStartedCount());
1:         assertEquals("Participant should finished once", 1, participant3.getFinishedCount());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:         assertEquals("Participant 1 should have started once", 1, participant1.getStartedCount());
1:         assertEquals("Participant 1 should finished once", 1, participant1.getFinishedCount());
1:         assertEquals("Participant 2 should have started once", 1, participant2.getStartedCount());
1:         assertEquals("Participant 2 should not have finished", 0, participant2.getFinishedCount());
1:         assertEquals("Participant 3 should have started once", 1, participant3.getStartedCount());
1:         assertEquals("Participant 3 should finished once", 1, participant3.getFinishedCount());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should still be active, because we did not wait long enough", Bundle.ACTIVE, b1.getState());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:         assertEquals("Bundle "+b2.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b2.getState());
1:         assertEquals("Participant 1 should have started once", 1, participant1.getStartedCount());
1:         assertEquals("Participant 1 should finished once", 1, participant1.getFinishedCount());
1:         assertEquals("Participant 2 should have started once", 1, participant2.getStartedCount());
1:         assertEquals("Participant 2 should not have finished", 0, participant2.getFinishedCount());
1:         assertEquals("Participant 3 should have started once", 1, participant3.getStartedCount());
1:         assertEquals("Participant 3 should finished once", 1, participant3.getFinishedCount());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Bundle "+b1.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b1.getState());
1:         assertEquals("Bundle "+b2.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b2.getState());
1:         assertEquals("Bundle "+b3.getSymbolicName()+" should be in active state", Bundle.ACTIVE, b3.getState());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Participant 1 should have started twice as it has been asked to quiesce twice", 2, participant1.getStartedCount());
1:         assertEquals("Participant 1 should finished twice as it should have returned from two quiesce requests immediately", 2, participant1.getFinishedCount());
1:         assertEquals("Participant 2 should have started twice as it has been asked to quiesce twice", 2, participant2.getStartedCount());
1:         assertEquals("Participant 2 should not have finished as it should never return from it's two quiesce requests", 0, participant2.getFinishedCount());
1:         assertEquals("Participant 3 should have started twice as it has been asked to quiesce twice", 2, participant3.getStartedCount());
1:         assertEquals("Participant 3 should finished twice as it should have waited a short time before returning from it's two quiesce requests", 2, participant3.getFinishedCount());
commit:2f3073f
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.concurrent.Future;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.TimeoutException;
1: import org.junit.After;
/////////////////////////////////////////////////////////////////////////
0:     public static final long DEFAULT_TIMEOUT = 30000;
1:     private QuiesceManager manager;
1:     private Bundle b1;
1:     private Bundle b2;
1:     private Bundle b3;
1:     private long timeoutTime;
1:     private List<Bundle> bundleList;
1:     private MockQuiesceParticipant participant1;
1:     private MockQuiesceParticipant participant2;
1:     private MockQuiesceParticipant participant3;
0:     @Inject
0:     protected BundleContext bundleContext;
1:     @Before
1:     public void setup() {
0:         manager = getOsgiService(QuiesceManager.class);
1:         b1 = bundleContext.getBundle(5);
1:         b2 = bundleContext.getBundle(6);
1:         b3 = bundleContext.getBundle(10);
1:         participant1 = new MockQuiesceParticipant(MockQuiesceParticipant.RETURNIMMEDIATELY);
1:         participant2 = new MockQuiesceParticipant(MockQuiesceParticipant.NEVERRETURN);
1:         participant3 = new MockQuiesceParticipant(MockQuiesceParticipant.WAIT);
1: 
1:     }
1: 
1:     @After
1:     public void after() {
1:         participant1.reset();
1:         participant2.reset();
1:         participant3.reset();
1:     }
1: 
1:     @Test
1:     public void testNullSafe() throws Exception {
1:         //Check we're null safe
1:         manager.quiesce(null);  
1:     }
1: 
1:     @Test
1:     public void testNoParticipants() throws Exception {
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b1);
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
1: 
1:         //Try quiescing one bundle with no participants
1:         manager.quiesceWithFuture(2000, bundleList).get(5000, TimeUnit.MILLISECONDS);
1: 
1:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:     }
1: 
1:     @Test
1:     public void testImmediateReturn() throws Exception {
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b1);
1:         //Register a mock participant which will report back quiesced immediately
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
1:         //Try quiescing the bundle with immediate return
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
1:         
1:         manager.quiesceWithFuture(1000,bundleList).get(5000, TimeUnit.MILLISECONDS);
1:         
0:         assertTrue("Participant should have finished once", participant1.getFinishedCount() == 1);
1:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:     }
1: 
1:     @Test
1:     public void testNoReturn() throws Exception {
1:         //Register a mock participant which won't respond
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:         //recreate the list as it may have been emptied?
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b1);
1: 
1:         //Try quiescing the bundle with no return
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
1:         manager.quiesce(1000,bundleList);
1:         timeoutTime = System.currentTimeMillis()+5000;
1:         while (System.currentTimeMillis() < timeoutTime && b1.getState() == Bundle.ACTIVE){
1:             Thread.sleep(500);
1:         }
1:         
0:         assertTrue("Participant should have started once", participant2.getStartedCount() == 1);
0:         assertTrue("Participant should not have finished", participant2.getFinishedCount() == 0);
1:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:     }
1: 
1:     @Test
1:     public void testWaitAShortTime() throws Exception {
1:         //Try quiescing where participant takes 5s to do the work. We should get InterruptedException
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:         //recreate the list as it may have been emptied?
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b1);
1: 
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
1:         
1:         // we should be finishing in about 5000 millis not 10000
1:         manager.quiesceWithFuture(10000,bundleList).get(7000, TimeUnit.MILLISECONDS);
1: 
0:         assertTrue("Participant should have started once", participant3.getStartedCount() == 1);
0:         assertTrue("Participant should finished once", participant3.getFinishedCount() == 1);
1:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:     }
1: 
1:     @Test
1:     public void testThreeParticipants() throws Exception {
1:         //Register three participants. One returns immediately, one waits 5s then returns, one never returns
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:         //recreate the list as it may have been emptied
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b1);
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
1:         
1:         manager.quiesceWithFuture(10000,bundleList).get(15000, TimeUnit.MILLISECONDS);
1:         
0:         assertTrue("Participant 1 should have started once", participant1.getStartedCount() == 1);
0:         assertTrue("Participant 1 should finished once", participant1.getFinishedCount() == 1);
0:         assertTrue("Participant 2 should have started once", participant2.getStartedCount() == 1);
0:         assertTrue("Participant 2 should not have finished", participant2.getFinishedCount() == 0);
0:         assertTrue("Participant 3 should have started once", participant3.getStartedCount() == 1);
0:         assertTrue("Participant 3 should finished once", participant3.getFinishedCount() == 1);
1:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:     }
1: 
1:     @Test
1:     public void testFuture() throws Exception {
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b1);
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
1: 
1:         Future<?> future = manager.quiesceWithFuture(2000, Arrays.asList(b1));
1: 
1:         // causes us to wait
1:         future.get();
1: 
1:         assertEquals("Participant 2 has started", 1, participant2.getStartedCount());
1:         assertEquals("Participant 2 has finished", 0, participant2.getFinishedCount());
1:         assertEquals("Participant 3 has started", 1, participant3.getStartedCount());
1:         assertEquals("Participant 3 has finished", 1, participant3.getFinishedCount());
1:     }
1:     @Test
1:     public void testFutureWithWait() throws Exception {
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b1);
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
1:         Future<?> future = manager.quiesceWithFuture(2000, Arrays.asList(b1));
1:         try {
1:             // causes us to wait, but too short
1:             future.get(500, TimeUnit.MILLISECONDS);
1:             fail("Too short wait, should have thrown TimeoutException");
1:         } catch (TimeoutException te) {
1:             // expected
1:         assertEquals("Participant 2 has started", 1, participant2.getStartedCount());
1:         assertEquals("Participant 2 has finished", 0, participant2.getFinishedCount());
1:         assertEquals("Participant 3 has started", 1, participant3.getStartedCount());
1:         assertEquals("Participant 3 has finished", 0, participant3.getFinishedCount());
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should still be active, because we did not wait long enough", b1.getState() == Bundle.ACTIVE);
1:     }
1: 
1:     @Test
1:     public void testTwoBundles() throws Exception {
1:         //Register three participants. One returns immediately, one waits 5s then returns, one never returns
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:         //recreate the list as it may have been emptied
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b1);
1:         bundleList.add(b2);
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
0:         assertTrue("Bundle "+b2.getSymbolicName()+" should be in active state", b2.getState() == Bundle.ACTIVE);
1: 
1:         manager.quiesceWithFuture(10000,bundleList).get(15000, TimeUnit.MILLISECONDS);
1: 
0:         assertTrue("Participant 1 should have started once", participant1.getStartedCount() == 1);
0:         assertTrue("Participant 1 should finished once", participant1.getFinishedCount() == 1);
0:         assertTrue("Participant 2 should have started once", participant2.getStartedCount() == 1);
0:         assertTrue("Participant 2 should not have finished", participant2.getFinishedCount() == 0);
0:         assertTrue("Participant 3 should have started once", participant3.getStartedCount() == 1);
0:         assertTrue("Participant 3 should finished once", participant3.getFinishedCount() == 1);
1:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:         assertTrue("Bundle "+b2.getSymbolicName()+" should not be in active state", b2.getState() != Bundle.ACTIVE);
1:     }
1: 
1:     @Test
1:     public void testOverlappedQuiesces() throws Exception {
1: 
1:         //Register three participants. One returns immediately, one waits 5s then returns, one never returns
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
1:         bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
1:         //recreate the list as it may have been emptied
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b1);
1:         bundleList.add(b2);
0:         assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
0:         assertTrue("Bundle "+b2.getSymbolicName()+" should be in active state", b2.getState() == Bundle.ACTIVE);
0:         assertTrue("Bundle "+b3.getSymbolicName()+" should be in active state", b3.getState() == Bundle.ACTIVE);
1:         manager.quiesce(2000,bundleList);
1:         bundleList = new ArrayList<Bundle>();
1:         bundleList.add(b2);
1:         bundleList.add(b3);
1:         manager.quiesce(2000,bundleList);
1:         timeoutTime = System.currentTimeMillis()+10000;
1:         while (System.currentTimeMillis() < timeoutTime && (b1.getState() == Bundle.ACTIVE || b2.getState() == Bundle.ACTIVE || b3.getState() == Bundle.ACTIVE)) {
1:             Thread.sleep(500);
1:         }
0:         assertTrue("Participant 1 should have started twice as it has been asked to quiesce twice", participant1.getStartedCount() == 2);
0:         assertTrue("Participant 1 should finished twice as it should have returned from two quiesce requests immediately", participant1.getFinishedCount() == 2);
0:         assertTrue("Participant 2 should have started twice as it has been asked to quiesce twice", participant2.getStartedCount() == 2);
0:         assertTrue("Participant 2 should not have finished as it should never return from it's two quiesce requests", participant2.getFinishedCount() == 0);
0:         assertTrue("Participant 3 should have started twice as it has been asked to quiesce twice", participant3.getStartedCount() == 2);
0:         assertTrue("Participant 3 should finished twice as it should have waited a short time before returning from it's two quiesce requests", participant3.getFinishedCount() == 2);
1:         assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
1:         assertTrue("Bundle "+b2.getSymbolicName()+" should not be in active state", b2.getState() != Bundle.ACTIVE);
1:         assertTrue("Bundle "+b3.getSymbolicName()+" should not be in active state", b3.getState() != Bundle.ACTIVE);
1:     }
1: 
0:     @org.ops4j.pax.exam.junit.Configuration
0:     public static Option[] configuration() {
0:         Option[] options = options(
0:                 bootDelegation(),
1: 
0:                 // Log
0:                 mavenBundle("org.ops4j.pax.logging", "pax-logging-api"),
0:                 mavenBundle("org.ops4j.pax.logging", "pax-logging-service"),
0:                 // Felix Config Admin
0:                 mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
0:                 // Felix mvn url handler
0:                 mavenBundle("org.ops4j.pax.url", "pax-url-mvn"),
1: 
0:                 // this is how you set the default log level when using pax
0:                 // logging (logProfile)
0:                 systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("DEBUG"),
1: 
1:                 // Bundles
0:                 mavenBundle("org.osgi", "org.osgi.compendium"),
0:                 mavenBundle("org.apache.aries", "org.apache.aries.util"),
0:                 mavenBundle("commons-lang", "commons-lang"),
0:                 mavenBundle("commons-collections", "commons-collections"),
0:                 mavenBundle("commons-pool", "commons-pool"),
0:                 mavenBundle("org.apache.servicemix.bundles", "org.apache.servicemix.bundles.serp"),
0:                 mavenBundle("org.apache.aries.quiesce", "org.apache.aries.quiesce.api"),
0:                 mavenBundle("org.apache.aries.quiesce", "org.apache.aries.quiesce.manager"),
1: 
0:                 equinox().version("3.5.0"));
0:         options = updateOptions(options);
0:         return options;
1:     }
1: 
1: 
0:     protected Bundle getBundle(String symbolicName) {
0:         return getBundle(symbolicName, null);
1:     }
1: 
0:     protected Bundle getBundle(String bundleSymbolicName, String version) {
0:         Bundle result = null;
0:         for (Bundle b : bundleContext.getBundles()) {
0:             if (b.getSymbolicName().equals(bundleSymbolicName)) {
0:                 if (version == null
0:                         || b.getVersion().equals(Version.parseVersion(version))) {
0:                     result = b;
0:                     break;
1:                 }
1:             }
1:         }
0:         return result;
1:     }
1: 
0:     public static BootDelegationOption bootDelegation() {
0:         return new BootDelegationOption("org.apache.aries.unittest.fixture");
1:     }
1: 
0:     public static MavenArtifactProvisionOption mavenBundle(String groupId,
0:             String artifactId) {
0:         return CoreOptions.mavenBundle().groupId(groupId).artifactId(artifactId)
0:     protected static Option[] updateOptions(Option[] options) {
0:         // We need to add pax-exam-junit here when running with the ibm
0:         // jdk to avoid the following exception during the test run:
0:         // ClassNotFoundException: org.ops4j.pax.exam.junit.Configuration
0:         if ("IBM Corporation".equals(System.getProperty("java.vendor"))) {
0:             Option[] ibmOptions = options(wrappedBundle(mavenBundle(
0:                     "org.ops4j.pax.exam", "pax-exam-junit")));
0:             options = combine(ibmOptions, options);
1: 
0:         return options;
1: 
0:     protected <T> T getOsgiService(Class<T> type, long timeout) {
0:         return getOsgiService(type, null, timeout);
1:     }
1: 
0:     protected <T> T getOsgiService(Class<T> type) {
0:         return getOsgiService(type, null, DEFAULT_TIMEOUT);
1:     }
1: 
0:     protected <T> T getOsgiService(Class<T> type, String filter, long timeout) {
0:         return getOsgiService(null, type, filter, timeout);
1:     }
1: 
0:     protected <T> T getOsgiService(BundleContext bc, Class<T> type,
0:             String filter, long timeout) {
0:         ServiceTracker tracker = null;
1:         try {
0:             String flt;
0:             if (filter != null) {
0:                 if (filter.startsWith("(")) {
0:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")"
0:                     + filter + ")";
0:                 } else {
0:                     flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")("
0:                     + filter + "))";
1:                 }
0:             } else {
0:                 flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";
1:             }
0:             Filter osgiFilter = FrameworkUtil.createFilter(flt);
0:             tracker = new ServiceTracker(bc == null ? bundleContext : bc, osgiFilter,
0:                     null);
0:             tracker.open();
0:             // Note that the tracker is not closed to keep the reference
0:             // This is buggy, has the service reference may change i think
0:             Object svc = type.cast(tracker.waitForService(timeout));
0:             if (svc == null) {
0:                 throw new RuntimeException("Gave up waiting for service " + flt);
1:             }
0:             return type.cast(svc);
0:         } catch (InvalidSyntaxException e) {
0:             throw new IllegalArgumentException("Invalid filter", e);
0:         } catch (InterruptedException e) {
0:             throw new RuntimeException(e);
1:         }
1:     }
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:79902ae
/////////////////////////////////////////////////////////////////////////
0: //import org.ops4j.pax.exam.container.def.options.VMOption;
0: //import org.ops4j.pax.exam.options.TimeoutOption
/////////////////////////////////////////////////////////////////////////
0:     public static final long DEFAULT_TIMEOUT = 60000;
/////////////////////////////////////////////////////////////////////////
0:                 
1:                 //new VMOption( "-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000" ),
1:                 //new TimeoutOption( 0 ),
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:74884c6
/////////////////////////////////////////////////////////////////////////
1: /*  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
1: package org.apache.aries.quiesce.manager.itest;
0: 
0: import static org.junit.Assert.assertTrue;
0: import static org.ops4j.pax.exam.CoreOptions.equinox;
0: import static org.ops4j.pax.exam.CoreOptions.options;
0: import static org.ops4j.pax.exam.CoreOptions.systemProperty;
0: import static org.ops4j.pax.exam.CoreOptions.wrappedBundle;
0: import static org.ops4j.pax.exam.OptionUtils.combine;
0: 
1: import java.util.ArrayList;
1: import java.util.List;
0: 
1: import org.apache.aries.quiesce.manager.QuiesceManager;
1: import org.apache.aries.quiesce.participant.QuiesceParticipant;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
0: import org.ops4j.pax.exam.CoreOptions;
0: import org.ops4j.pax.exam.Inject;
1: import org.ops4j.pax.exam.Option;
0: import org.ops4j.pax.exam.junit.JUnit4TestRunner;
0: import org.ops4j.pax.exam.options.BootDelegationOption;
0: import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
1: import org.osgi.framework.Bundle;
0: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.Constants;
0: import org.osgi.framework.Filter;
0: import org.osgi.framework.FrameworkUtil;
0: import org.osgi.framework.InvalidSyntaxException;
0: import org.osgi.framework.ServiceRegistration;
0: import org.osgi.framework.Version;
0: import org.osgi.util.tracker.ServiceTracker;
0: 
0: @RunWith(JUnit4TestRunner.class)
0: public class QuiesceManagerTest {
0:   public static final long DEFAULT_TIMEOUT = 30000;
0:   private QuiesceManager manager;
0:   private Bundle b1;
0:   private Bundle b2;
0:   private Bundle b3;
0:   private long timeoutTime;
0:   private List<Bundle> bundleList;
0:   private MockQuiesceParticipant participant1;
0:   private MockQuiesceParticipant participant2;
0:   private MockQuiesceParticipant participant3;
0: 
0: 
0:   @Inject
0:   protected BundleContext bundleContext;
0:   
0:   @Before
0:   public void setup() {
0: 	  manager = getOsgiService(QuiesceManager.class);
0: 	  b1 = bundleContext.getBundle(5);
0: 	  b2 = bundleContext.getBundle(6);
0: 	  b3 = bundleContext.getBundle(10);
0: 	  participant1 = new MockQuiesceParticipant(MockQuiesceParticipant.RETURNIMMEDIATELY);
0: 	  participant2 = new MockQuiesceParticipant(MockQuiesceParticipant.NEVERRETURN);
0: 	  participant3 = new MockQuiesceParticipant(MockQuiesceParticipant.WAIT);
0: 
0:   }
0:   
0:   @Test
0:   public void testNullSafe() throws Exception {
0: 	  //Check we're null safe
0: 	  manager.quiesce(null);  
0:   }
0:   
0:   @Test
0:   public void testNoParticipants() throws Exception {
0: 	  bundleList = new ArrayList<Bundle>();
0: 	  bundleList.add(b1);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
0: 	  //Try quiescing one bundle with no participants
0: 	  manager.quiesce(bundleList);
0: 	  //quiesce is non-blocking so what do we do? 
0: 	  //verify bundle is no longer active
0: 	  timeoutTime = System.currentTimeMillis()+5000;
0: 	  while (System.currentTimeMillis() < timeoutTime && b1.getState() == Bundle.ACTIVE){
0: 		  Thread.sleep(500);
0: 	  }
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
0: 	  b1.start();
0:   }
0:   
0:   @Test
0:   public void testImmediateReturn() throws Exception {
0: 	  bundleList = new ArrayList<Bundle>();
0: 	  bundleList.add(b1);
0: 	  //Register a mock participant which will report back quiesced immediately
0: 	  ServiceRegistration sr = bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
0: 	  //Try quiescing the bundle with immediate return
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
0: 	  manager.quiesce(1000,bundleList);
0: 	  timeoutTime = System.currentTimeMillis()+5000;
0: 	  while (System.currentTimeMillis() < timeoutTime && b1.getState() == Bundle.ACTIVE){
0: 		  Thread.sleep(500);
0: 	  }
0: 	  assertTrue("Participant should have finished once", participant1.getFinishedCount() == 1);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
0: 	  b1.start();
0: 	  sr.unregister();
0: 	  participant1.reset();
0:   }
0:     
0:   @Test
0:   public void testNoReturn() throws Exception {
0: 	  //Register a mock participant which won't respond
0: 	  ServiceRegistration sr = bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
0: 	  //recreate the list as it may have been emptied?
0: 	  bundleList = new ArrayList<Bundle>();
0: 	  bundleList.add(b1);
0: 	  
0: 	  //Try quiescing the bundle with no return
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
0: 	  manager.quiesce(1000,bundleList);
0: 	  timeoutTime = System.currentTimeMillis()+5000;
0: 	  while (System.currentTimeMillis() < timeoutTime && b1.getState() == Bundle.ACTIVE){
0: 		  Thread.sleep(500);
0: 	  }
0: 	  assertTrue("Participant should have started once", participant2.getStartedCount() == 1);
0: 	  assertTrue("Participant should not have finished", participant2.getFinishedCount() == 0);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
0: 	  b1.start();
0: 	  sr.unregister();
0: 	  participant2.reset();
0:   }
0: 	  
0: 	@Test
0: 	public void testWaitAShortTime() throws Exception {
0: 	  //Try quiescing where participant takes 5s to do the work. We should get InterruptedException
0: 	  ServiceRegistration sr = bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
0: 	  //recreate the list as it may have been emptied?
0: 	  bundleList = new ArrayList<Bundle>();
0: 	  bundleList.add(b1);
0: 	  
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
0: 	  manager.quiesce(10000,bundleList);
0: 	  //timeout is > how long participant takes, and < the quiesce timeout
0: 	  timeoutTime = System.currentTimeMillis()+7000;
0: 	  while (System.currentTimeMillis() < timeoutTime && b1.getState() == Bundle.ACTIVE){
0: 		  Thread.sleep(500);
0: 	  }
0: 	  assertTrue("Participant should have started once", participant3.getStartedCount() == 1);
0: 	  assertTrue("Participant should finished once", participant3.getFinishedCount() == 1);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
0: 	  b1.start();
0: 	  participant3.reset();
0: 	}
0: 
0: 	@Test
0: 	public void testThreeParticipants() throws Exception {
0: 	  //Register three participants. One returns immediately, one waits 5s then returns, one never returns
0: 	  bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
0: 	  bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
0: 	  bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
0: 	  //recreate the list as it may have been emptied
0: 	  bundleList = new ArrayList<Bundle>();
0: 	  bundleList.add(b1);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
0: 	  manager.quiesce(10000,bundleList);
0: 	  timeoutTime = System.currentTimeMillis()+15000;
0: 	  while (System.currentTimeMillis() < timeoutTime && b1.getState() == Bundle.ACTIVE){
0: 		  Thread.sleep(500);
0: 	  }
0: 	  assertTrue("Participant 1 should have started once", participant1.getStartedCount() == 1);
0: 	  assertTrue("Participant 1 should finished once", participant1.getFinishedCount() == 1);
0: 	  assertTrue("Participant 2 should have started once", participant2.getStartedCount() == 1);
0: 	  assertTrue("Participant 2 should not have finished", participant2.getFinishedCount() == 0);
0: 	  assertTrue("Participant 3 should have started once", participant3.getStartedCount() == 1);
0: 	  assertTrue("Participant 3 should finished once", participant3.getFinishedCount() == 1);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
0: 	  
0: 	  b1.start();
0: 	  participant1.reset();
0: 	  participant2.reset();
0: 	  participant3.reset();
0: 	}
0: 	
0: 	@Test
0: 	public void testTwoBundles() throws Exception {
0: 		//Register three participants. One returns immediately, one waits 5s then returns, one never returns
0: 		  bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
0: 		  bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
0: 		  bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
0: 	  //recreate the list as it may have been emptied
0: 	  bundleList = new ArrayList<Bundle>();
0: 	  bundleList.add(b1);
0: 	  bundleList.add(b2);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
0: 	  assertTrue("Bundle "+b2.getSymbolicName()+" should be in active state", b2.getState() == Bundle.ACTIVE);
0: 	  manager.quiesce(10000,bundleList);
0: 	  timeoutTime = System.currentTimeMillis()+15000;
0: 	  while (System.currentTimeMillis() < timeoutTime && b1.getState() == Bundle.ACTIVE){
0: 		  Thread.sleep(500);
0: 	  }
0: 	  assertTrue("Participant 1 should have started once", participant1.getStartedCount() == 1);
0: 	  assertTrue("Participant 1 should finished once", participant1.getFinishedCount() == 1);
0: 	  assertTrue("Participant 2 should have started once", participant2.getStartedCount() == 1);
0: 	  assertTrue("Participant 2 should not have finished", participant2.getFinishedCount() == 0);
0: 	  assertTrue("Participant 3 should have started once", participant3.getStartedCount() == 1);
0: 	  assertTrue("Participant 3 should finished once", participant3.getFinishedCount() == 1);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
0: 	  assertTrue("Bundle "+b2.getSymbolicName()+" should not be in active state", b2.getState() != Bundle.ACTIVE);
0: 	  b1.start();
0: 	  b2.start();	
0: 	  participant1.reset();
0: 	  participant2.reset();
0: 	  participant3.reset();
0: 	}
0: 	
0: 	@Test
0: 	public void testOverlappedQuiesces() throws Exception {
0: 	  
0:       //Register three participants. One returns immediately, one waits 5s then returns, one never returns
0: 	  bundleContext.registerService(QuiesceParticipant.class.getName(), participant1, null);
0: 	  bundleContext.registerService(QuiesceParticipant.class.getName(), participant2, null);
0: 	  bundleContext.registerService(QuiesceParticipant.class.getName(), participant3, null);
0: 	  //recreate the list as it may have been emptied
0: 	  bundleList = new ArrayList<Bundle>();
0: 	  bundleList.add(b1);
0: 	  bundleList.add(b2);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should be in active state", b1.getState() == Bundle.ACTIVE);
0: 	  assertTrue("Bundle "+b2.getSymbolicName()+" should be in active state", b2.getState() == Bundle.ACTIVE);
0: 	  assertTrue("Bundle "+b3.getSymbolicName()+" should be in active state", b3.getState() == Bundle.ACTIVE);
0: 	  manager.quiesce(10000,bundleList);
0: 	  bundleList = new ArrayList<Bundle>();
0: 	  bundleList.add(b2);
0: 	  bundleList.add(b3);
0: 	  manager.quiesce(bundleList);
0: 	  timeoutTime = System.currentTimeMillis()+15000;
0: 	  while (System.currentTimeMillis() < timeoutTime && b1.getState() == Bundle.ACTIVE){
0: 		  Thread.sleep(500);
0: 	  }
0: 	  assertTrue("Participant 1 should have started twice", participant1.getStartedCount() == 2);
0: 	  assertTrue("Participant 1 should finished twice", participant1.getFinishedCount() == 2);
0: 	  assertTrue("Participant 2 should have started twice", participant2.getStartedCount() == 2);
0: 	  assertTrue("Participant 2 should not have finished", participant2.getFinishedCount() == 0);
0: 	  assertTrue("Participant 3 should have started twice", participant3.getStartedCount() == 2);
0: 	  assertTrue("Participant 3 should finished twice", participant3.getFinishedCount() == 2);
0: 	  assertTrue("Bundle "+b1.getSymbolicName()+" should not be in active state", b1.getState() != Bundle.ACTIVE);
0: 	  assertTrue("Bundle "+b2.getSymbolicName()+" should not be in active state", b2.getState() != Bundle.ACTIVE);
0: 	  assertTrue("Bundle "+b3.getSymbolicName()+" should not be in active state", b3.getState() != Bundle.ACTIVE);
0: 	  participant1.reset();
0: 	  participant2.reset();
0: 	  participant3.reset();
0: 	  
0: 	}
0:  
0:   @org.ops4j.pax.exam.junit.Configuration
0:   public static Option[] configuration() {
0:     Option[] options = options(
0:         bootDelegation(),
0:         
0:         // Log
0:         mavenBundle("org.ops4j.pax.logging", "pax-logging-api"),
0:         mavenBundle("org.ops4j.pax.logging", "pax-logging-service"),
0:         // Felix Config Admin
0:         mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
0:         // Felix mvn url handler
0:         mavenBundle("org.ops4j.pax.url", "pax-url-mvn"),
0: 
0:         // this is how you set the default log level when using pax
0:         // logging (logProfile)
0:         systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("DEBUG"),
0: 
0:         // Bundles
0:         mavenBundle("org.osgi", "org.osgi.compendium"),
0:         mavenBundle("org.apache.aries", "org.apache.aries.util"),
0:         mavenBundle("commons-lang", "commons-lang"),
0:         mavenBundle("commons-collections", "commons-collections"),
0:         mavenBundle("commons-pool", "commons-pool"),
0:         mavenBundle("org.apache.servicemix.bundles", "org.apache.servicemix.bundles.serp"),
0:         mavenBundle("org.apache.aries.quiesce", "org.apache.aries.quiesce.api"),
0:         mavenBundle("org.apache.aries.quiesce", "org.apache.aries.quiesce.manager"),
0:         
0:         equinox().version("3.5.0"));
0:     options = updateOptions(options);
0:     return options;
0:   }
0:   
0:   
0:   protected Bundle getBundle(String symbolicName) {
0:     return getBundle(symbolicName, null);
0:   }
0: 
0:   protected Bundle getBundle(String bundleSymbolicName, String version) {
0:     Bundle result = null;
0:     for (Bundle b : bundleContext.getBundles()) {
0:       if (b.getSymbolicName().equals(bundleSymbolicName)) {
0:         if (version == null
0:             || b.getVersion().equals(Version.parseVersion(version))) {
0:           result = b;
0:           break;
0:         }
0:       }
0:     }
0:     return result;
0:   }
0: 
0:   public static BootDelegationOption bootDelegation() {
0:     return new BootDelegationOption("org.apache.aries.unittest.fixture");
0:   }
0:   
0:   public static MavenArtifactProvisionOption mavenBundle(String groupId,
0:       String artifactId) {
0:     return CoreOptions.mavenBundle().groupId(groupId).artifactId(artifactId)
0:         .versionAsInProject();
0:   }
0: 
0:   protected static Option[] updateOptions(Option[] options) {
0:     // We need to add pax-exam-junit here when running with the ibm
0:     // jdk to avoid the following exception during the test run:
0:     // ClassNotFoundException: org.ops4j.pax.exam.junit.Configuration
0:     if ("IBM Corporation".equals(System.getProperty("java.vendor"))) {
0:       Option[] ibmOptions = options(wrappedBundle(mavenBundle(
0:           "org.ops4j.pax.exam", "pax-exam-junit")));
0:       options = combine(ibmOptions, options);
0:     }
0: 
0:     return options;
0:   }
0: 
0:   protected <T> T getOsgiService(Class<T> type, long timeout) {
0:     return getOsgiService(type, null, timeout);
0:   }
0: 
0:   protected <T> T getOsgiService(Class<T> type) {
0:     return getOsgiService(type, null, DEFAULT_TIMEOUT);
0:   }
0:   
0:   protected <T> T getOsgiService(Class<T> type, String filter, long timeout) {
0:     return getOsgiService(null, type, filter, timeout);
0:   }
0: 
0:   protected <T> T getOsgiService(BundleContext bc, Class<T> type,
0:       String filter, long timeout) {
0:     ServiceTracker tracker = null;
0:     try {
0:       String flt;
0:       if (filter != null) {
0:         if (filter.startsWith("(")) {
0:           flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")"
0:               + filter + ")";
0:         } else {
0:           flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")("
0:               + filter + "))";
0:         }
0:       } else {
0:         flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";
0:       }
0:       Filter osgiFilter = FrameworkUtil.createFilter(flt);
0:       tracker = new ServiceTracker(bc == null ? bundleContext : bc, osgiFilter,
0:           null);
0:       tracker.open();
0:       // Note that the tracker is not closed to keep the reference
0:       // This is buggy, has the service reference may change i think
0:       Object svc = type.cast(tracker.waitForService(timeout));
0:       if (svc == null) {
0:         throw new RuntimeException("Gave up waiting for service " + flt);
0:       }
0:       return type.cast(svc);
0:     } catch (InvalidSyntaxException e) {
0:       throw new IllegalArgumentException("Invalid filter", e);
0:     } catch (InterruptedException e) {
0:       throw new RuntimeException(e);
0:     }
0:   }
0: }
============================================================================