1:4cbf0d3: /*
1:4cbf0d3:  * Licensed to the Apache Software Foundation (ASF) under one
1:4cbf0d3:  * or more contributor license agreements.  See the NOTICE file
1:4cbf0d3:  * distributed with this work for additional information
1:4cbf0d3:  * regarding copyright ownership.  The ASF licenses this file
1:4cbf0d3:  * to you under the Apache License, Version 2.0 (the
1:4cbf0d3:  * "License"); you may not use this file except in compliance
1:4cbf0d3:  * with the License.  You may obtain a copy of the License at
1:4cbf0d3:  *
1:4cbf0d3:  *   http://www.apache.org/licenses/LICENSE-2.0
1:4cbf0d3:  *
1:4cbf0d3:  * Unless required by applicable law or agreed to in writing,
1:4cbf0d3:  * software distributed under the License is distributed on an
1:4cbf0d3:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:4cbf0d3:  * KIND, either express or implied.  See the License for the
1:4cbf0d3:  * specific language governing permissions and limitations
1:4cbf0d3:  * under the License.
1:4cbf0d3:  */
1:4cbf0d3: package org.apache.aries.blueprint.container;
1:4cbf0d3: 
1:4cbf0d3: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
1:4cbf0d3: 
1:4cbf0d3: import java.lang.reflect.Constructor;
1:4cbf0d3: import java.lang.reflect.InvocationTargetException;
1:4cbf0d3: import java.lang.reflect.Method;
1:4cbf0d3: import java.lang.reflect.Modifier;
1:4cbf0d3: import java.lang.reflect.Type;
1:4cbf0d3: import java.util.ArrayList;
1:4cbf0d3: import java.util.Arrays;
1:4cbf0d3: import java.util.Collection;
1:4cbf0d3: import java.util.HashMap;
1:4cbf0d3: import java.util.Iterator;
1:4cbf0d3: import java.util.LinkedHashMap;
1:4cbf0d3: import java.util.List;
1:4cbf0d3: import java.util.Map;
1:4cbf0d3: import java.util.concurrent.Callable;
1:4cbf0d3: import java.util.concurrent.Semaphore;
1:4cbf0d3: import java.util.concurrent.atomic.AtomicReference;
1:4cbf0d3: 
1:4cbf0d3: import org.apache.aries.blueprint.BeanProcessor;
1:4cbf0d3: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:4cbf0d3: import org.apache.aries.blueprint.Interceptor;
1:4cbf0d3: import org.apache.aries.blueprint.di.AbstractRecipe;
1:4cbf0d3: import org.apache.aries.blueprint.di.Recipe;
1:4cbf0d3: import org.apache.aries.blueprint.proxy.Collaborator;
1:4cbf0d3: import org.apache.aries.blueprint.proxy.ProxyUtils;
1:4cbf0d3: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:4cbf0d3: import org.apache.aries.blueprint.utils.ReflectionUtils;
1:4cbf0d3: import org.apache.aries.blueprint.utils.ReflectionUtils.PropertyDescriptor;
1:4cbf0d3: import org.apache.aries.proxy.UnableToProxyException;
1:4cbf0d3: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:4cbf0d3: import org.osgi.service.blueprint.container.ReifiedType;
1:4cbf0d3: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:4cbf0d3: import org.slf4j.Logger;
1:4cbf0d3: import org.slf4j.LoggerFactory;
1:4cbf0d3: 
1:4cbf0d3: /**
1:4cbf0d3:  * A <code>Recipe</code> to create POJOs.
1:4cbf0d3:  *
1:4cbf0d3:  * @version $Rev$, $Date$
1:4cbf0d3:  */
1:4cbf0d3: public class BeanRecipe extends AbstractRecipe {
1:4cbf0d3: 
1:4cbf0d3:     static class UnwrapperedBeanHolder {
1:4cbf0d3:         final Object unwrapperedBean;
1:4cbf0d3:         final BeanRecipe recipe;
1:4cbf0d3: 
1:4cbf0d3:         public UnwrapperedBeanHolder(Object unwrapperedBean, BeanRecipe recipe) {
1:4cbf0d3:             this.unwrapperedBean = unwrapperedBean;
1:4cbf0d3:             this.recipe = recipe;
1:4cbf0d3:         }
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public class VoidableCallable implements Callable<Object>, Voidable {
1:4cbf0d3: 
1:4cbf0d3:         private final AtomicReference<Object> ref = new AtomicReference<Object>();
1:4cbf0d3: 
1:4cbf0d3:         private final Semaphore sem = new Semaphore(1);
1:4cbf0d3: 
1:4cbf0d3:         private final ThreadLocal<Object> deadlockDetector = new ThreadLocal<Object>();
1:4cbf0d3: 
1:4cbf0d3:         public void voidReference() {
1:4cbf0d3:             ref.set(null);
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         public Object call() throws ComponentDefinitionException {
1:4cbf0d3:             Object o = ref.get();
1:4cbf0d3: 
1:4cbf0d3:             if (o == null) {
1:4cbf0d3:                 if(deadlockDetector.get() != null) {
1:4cbf0d3:                     deadlockDetector.remove();
1:4cbf0d3:                     throw new ComponentDefinitionException("Construction cycle detected for bean " + name);
1:4cbf0d3:                 }
1:4cbf0d3: 
1:4cbf0d3:                 sem.acquireUninterruptibly();
1:4cbf0d3:                 try {
1:4cbf0d3:                     o = ref.get();
1:4cbf0d3:                     if (o == null) {
1:4cbf0d3:                         deadlockDetector.set(this);
1:4cbf0d3:                         try {
1:4cbf0d3:                             o = internalCreate2();
1:4cbf0d3:                             ref.set(o);
1:4cbf0d3:                         } finally {
1:4cbf0d3:                             deadlockDetector.remove();
1:4cbf0d3:                         }
1:4cbf0d3:                     }
1:4cbf0d3:                 } finally {
1:4cbf0d3:                     sem.release();
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3: 
1:4cbf0d3:             return o;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private static final Logger LOGGER = LoggerFactory.getLogger(BeanRecipe.class);
1:4cbf0d3: 
1:4cbf0d3:     private final ExtendedBlueprintContainer blueprintContainer;
1:4cbf0d3:     private final LinkedHashMap<String,Object> properties = new LinkedHashMap<String,Object>();
1:4cbf0d3:     private final Object type;
1:4cbf0d3: 
1:4cbf0d3:     private String initMethod;
1:4cbf0d3:     private String destroyMethod;
1:4cbf0d3:     private List<Recipe> explicitDependencies;
1:4cbf0d3: 
1:4cbf0d3:     private Recipe factory;
1:4cbf0d3:     private String factoryMethod;
1:4cbf0d3:     private List<Object> arguments;
1:4cbf0d3:     private List<String> argTypes;
1:4cbf0d3:     private boolean reorderArguments;
1:4cbf0d3:     private final boolean allowsFieldInjection;
1:4cbf0d3:     private BeanMetadata interceptorLookupKey;
1:4cbf0d3: 
1:4cbf0d3: 
1:4cbf0d3:     public BeanRecipe(String name, ExtendedBlueprintContainer blueprintContainer, Object type, boolean allowsFieldInjection) {
1:4cbf0d3:         super(name);
1:4cbf0d3:         this.blueprintContainer = blueprintContainer;
1:4cbf0d3:         this.type = type;
1:4cbf0d3:         this.allowsFieldInjection = allowsFieldInjection;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public Object getProperty(String name) {
1:4cbf0d3:         return properties.get(name);
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public Map<String, Object> getProperties() {
1:4cbf0d3:         return new LinkedHashMap<String, Object>(properties);
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setProperty(String name, Object value) {
1:4cbf0d3:         properties.put(name, value);
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setFactoryMethod(String method) {
1:4cbf0d3:         this.factoryMethod = method;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setFactoryComponent(Recipe factory) {
1:4cbf0d3:         this.factory = factory;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setArgTypes(List<String> argTypes) {
1:4cbf0d3:         this.argTypes = argTypes;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setArguments(List<Object> arguments) {
1:4cbf0d3:         this.arguments = arguments;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setReorderArguments(boolean reorder) {
1:4cbf0d3:         this.reorderArguments = reorder;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setInitMethod(String initMethod) {
1:4cbf0d3:         this.initMethod = initMethod;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public String getInitMethod() {
1:4cbf0d3:         return initMethod;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setDestroyMethod(String destroyMethod) {
1:4cbf0d3:         this.destroyMethod = destroyMethod;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public String getDestroyMethod() {
1:4cbf0d3:         return destroyMethod;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public List<Recipe> getExplicitDependencies() {
1:4cbf0d3:         return explicitDependencies;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setExplicitDependencies(List<Recipe> explicitDependencies) {
1:4cbf0d3:         this.explicitDependencies = explicitDependencies;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setInterceptorLookupKey(BeanMetadata metadata) {
1:4cbf0d3:         interceptorLookupKey = metadata;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     @Override
1:4cbf0d3:     public List<Recipe> getConstructorDependencies() {
1:4cbf0d3:         List<Recipe> recipes = new ArrayList<Recipe>();
1:4cbf0d3:         if (explicitDependencies != null) {
1:4cbf0d3:             recipes.addAll(explicitDependencies);
1:4cbf0d3:         }
1:4cbf0d3:         if (arguments != null) {
1:4cbf0d3:             for (Object argument : arguments) {
1:4cbf0d3:                 if (argument instanceof Recipe) {
1:4cbf0d3:                     recipes.add((Recipe)argument);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         return recipes;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public List<Recipe> getDependencies() {
1:4cbf0d3:         List<Recipe> recipes = new ArrayList<Recipe>();
1:4cbf0d3:         for (Object o : properties.values()) {
1:4cbf0d3:             if (o instanceof Recipe) {
1:4cbf0d3:                 Recipe recipe = (Recipe) o;
1:4cbf0d3:                 recipes.add(recipe);
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         recipes.addAll(getConstructorDependencies());
1:4cbf0d3:         return recipes;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private void instantiateExplicitDependencies() {
1:4cbf0d3:         if (explicitDependencies != null) {
1:4cbf0d3:             for (Recipe recipe : explicitDependencies) {
1:4cbf0d3:                 recipe.create();
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     @Override
1:4cbf0d3:     protected Class loadClass(String className) {
1:4cbf0d3:         ClassLoader loader = type instanceof Class ? ((Class) type).getClassLoader() : null;
1:4cbf0d3:         ReifiedType t = loadType(className, loader);
1:4cbf0d3:         return t != null ? t.getRawClass() : null;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     @Override
1:4cbf0d3:     protected ReifiedType loadType(String className) {
1:4cbf0d3:         return loadType(className, type instanceof Class ? ((Class) type).getClassLoader() : null);
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private Object getInstance() throws ComponentDefinitionException {
1:4cbf0d3:         Object instance;
1:4cbf0d3: 
1:4cbf0d3:         // Instanciate arguments
1:4cbf0d3:         List<Object> args = new ArrayList<Object>();
1:4cbf0d3:         List<ReifiedType> argTypes = new ArrayList<ReifiedType>();
1:4cbf0d3:         if (arguments != null) {
1:4cbf0d3:             for (int i = 0; i < arguments.size(); i++) {
1:4cbf0d3:                 Object arg = arguments.get(i);
1:4cbf0d3:                 if (arg instanceof Recipe) {
1:4cbf0d3:                     args.add(((Recipe) arg).create());
1:4cbf0d3:                 } else {
1:4cbf0d3:                     args.add(arg);
1:4cbf0d3:                 }
1:4cbf0d3:                 if (this.argTypes != null) {
1:4cbf0d3:                     argTypes.add(this.argTypes.get(i) != null ? loadType(this.argTypes.get(i)) : null);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         if (factory != null) {
1:4cbf0d3:             // look for instance method on factory object
1:4cbf0d3:             Object factoryObj = factory.create();
1:4cbf0d3: 
1:4cbf0d3:             // If the factory is a service reference, we need to get hold of the actual proxy for the service
1:4cbf0d3:             /* BLUEPRINT-NOOSGI
1:4cbf0d3:             if (factoryObj instanceof ReferenceRecipe.ServiceProxyWrapper) {
1:4cbf0d3:                 try {
1:4cbf0d3:                     factoryObj = ((ReferenceRecipe.ServiceProxyWrapper) factoryObj).convert(new ReifiedType(Object.class));
1:4cbf0d3:                 } catch (Exception e) {
1:4cbf0d3:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
1:4cbf0d3:                 }
1:4cbf0d3:             } else*/ if (factoryObj instanceof UnwrapperedBeanHolder) {
1:4cbf0d3:                 factoryObj = wrap((UnwrapperedBeanHolder) factoryObj, Object.class);
1:4cbf0d3:             }
1:4cbf0d3: 
1:4cbf0d3:             // Map of matching methods
1:4cbf0d3:             Map<Method, List<Object>> matches = findMatchingMethods(factoryObj.getClass(), factoryMethod, true, args, argTypes);
1:4cbf0d3:             if (matches.size() == 1) {
1:4cbf0d3:                 try {
1:4cbf0d3:                     Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
1:4cbf0d3:                     instance = invoke(match.getKey(), factoryObj, match.getValue().toArray());
1:4cbf0d3:                 } catch (Throwable e) {
1:4cbf0d3:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
1:4cbf0d3:                 }
1:4cbf0d3:             } else if (matches.size() == 0) {
1:4cbf0d3:                 throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + factoryObj.getClass().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:4cbf0d3:             } else {
1:4cbf0d3:                 throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + factoryObj.getClass().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:4cbf0d3:             }
1:4cbf0d3:         } else if (factoryMethod != null) {
1:4cbf0d3:             // Map of matching methods
1:4cbf0d3:             Map<Method, List<Object>> matches = findMatchingMethods(getType(), factoryMethod, false, args, argTypes);
1:4cbf0d3:             if (matches.size() == 1) {
1:4cbf0d3:                 try {
1:4cbf0d3:                     Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
1:4cbf0d3:                     instance = invoke(match.getKey(), null, match.getValue().toArray());
1:4cbf0d3:                 } catch (Throwable e) {
1:4cbf0d3:                     throw new ComponentDefinitionException("Error when instanciating bean " + getName() + " of class " + getType(), getRealCause(e));
1:4cbf0d3:                 }
1:4cbf0d3:             } else if (matches.size() == 0) {
1:4cbf0d3:                 throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:4cbf0d3:             } else {
1:4cbf0d3:                 throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:4cbf0d3:             }
1:4cbf0d3:         } else {
1:4cbf0d3:             if (getType() == null) {
1:4cbf0d3:                 throw new ComponentDefinitionException("No factoryMethod nor class is defined for this bean");
1:4cbf0d3:             }
1:4cbf0d3:             // Map of matching constructors
1:4cbf0d3:             Map<Constructor, List<Object>> matches = findMatchingConstructors(getType(), args, argTypes);
1:4cbf0d3:             if (matches.size() == 1) {
1:4cbf0d3:                 try {
1:4cbf0d3:                     Map.Entry<Constructor, List<Object>> match = matches.entrySet().iterator().next();
1:4cbf0d3:                     instance = newInstance(match.getKey(), match.getValue().toArray());
1:4cbf0d3:                 } catch (Throwable e) {
1:4cbf0d3:                     throw new ComponentDefinitionException("Error when instanciating bean " + getName() + " of class " + getType(), getRealCause(e));
1:4cbf0d3:                 }
1:4cbf0d3:             } else if (matches.size() == 0) {
1:4cbf0d3:                 throw new ComponentDefinitionException("Unable to find a matching constructor on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:4cbf0d3:             } else {
1:4cbf0d3:                 throw new ComponentDefinitionException("Multiple matching constructors found on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         return instance;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private Map<Method, List<Object>> findMatchingMethods(Class type, String name, boolean instance, List<Object> args, List<ReifiedType> types) {
1:4cbf0d3:         Map<Method, List<Object>> matches = new HashMap<Method, List<Object>>();
1:4cbf0d3:         // Get constructors
1:4cbf0d3:         List<Method> methods = new ArrayList<Method>(Arrays.asList(type.getMethods()));
1:4cbf0d3:         // Discard any signature with wrong cardinality
1:4cbf0d3:         for (Iterator<Method> it = methods.iterator(); it.hasNext();) {
1:4cbf0d3:             Method mth = it.next();
1:4cbf0d3:             if (!mth.getName().equals(name)) {
1:4cbf0d3:                 it.remove();
1:4cbf0d3:             } else if (mth.getParameterTypes().length != args.size()) {
1:4cbf0d3:                 it.remove();
1:4cbf0d3:             } else if (instance ^ !Modifier.isStatic(mth.getModifiers())) {
1:4cbf0d3:                 it.remove();
1:4cbf0d3:             } else if (mth.isBridge()) {
1:4cbf0d3:                 it.remove();
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         // on some JVMs (J9) hidden static methods are returned by Class.getMethods so we need to weed them out
1:4cbf0d3:         // to reduce ambiguity
1:4cbf0d3:         if (!instance) {
1:4cbf0d3:             methods = applyStaticHidingRules(methods);
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         // Find a direct match with assignment
1:4cbf0d3:         if (matches.size() != 1) {
1:4cbf0d3:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:4cbf0d3:             for (Method mth : methods) {
1:4cbf0d3:                 boolean found = true;
1:4cbf0d3:                 List<Object> match = new ArrayList<Object>();
1:4cbf0d3:                 for (int i = 0; i < args.size(); i++) {
1:4cbf0d3:                     ReifiedType argType = new GenericType(mth.getGenericParameterTypes()[i]);
1:4cbf0d3:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                     //If the arg is an Unwrappered bean then we need to do the assignment check against the
1:4cbf0d3:                     //unwrappered bean itself.
1:4cbf0d3:                     Object arg = args.get(i);
1:4cbf0d3:                     Object argToTest = arg;
1:4cbf0d3:                     if(arg instanceof UnwrapperedBeanHolder)
1:4cbf0d3:                         argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
1:4cbf0d3:                     if (!AggregateConverter.isAssignable(argToTest, argType)) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                     try {
1:4cbf0d3:                         match.add(convert(arg, mth.getGenericParameterTypes()[i]));
1:4cbf0d3:                     } catch (Throwable t) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                 }
1:4cbf0d3:                 if (found) {
1:4cbf0d3:                     nmatches.put(mth, match);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:             if (nmatches.size() > 0) {
1:4cbf0d3:                 matches = nmatches;
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         // Find a direct match with conversion
1:4cbf0d3:         if (matches.size() != 1) {
1:4cbf0d3:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:4cbf0d3:             for (Method mth : methods) {
1:4cbf0d3:                 boolean found = true;
1:4cbf0d3:                 List<Object> match = new ArrayList<Object>();
1:4cbf0d3:                 for (int i = 0; i < args.size(); i++) {
1:4cbf0d3:                     ReifiedType argType = new GenericType(mth.getGenericParameterTypes()[i]);
1:4cbf0d3:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                     try {
1:4cbf0d3:                         Object val = convert(args.get(i), argType);
1:4cbf0d3:                         match.add(val);
1:4cbf0d3:                     } catch (Throwable t) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                 }
1:4cbf0d3:                 if (found) {
1:4cbf0d3:                     nmatches.put(mth, match);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:             if (nmatches.size() > 0) {
1:4cbf0d3:                 matches = nmatches;
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         // Start reordering with assignment
1:4cbf0d3:         if (matches.size() != 1 && reorderArguments && args.size() > 1) {
1:4cbf0d3:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:4cbf0d3:             for (Method mth : methods) {
1:4cbf0d3:                 ArgumentMatcher matcher = new ArgumentMatcher(mth.getGenericParameterTypes(), false);
1:4cbf0d3:                 List<Object> match = matcher.match(args, types);
1:4cbf0d3:                 if (match != null) {
1:4cbf0d3:                     nmatches.put(mth, match);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:             if (nmatches.size() > 0) {
1:4cbf0d3:                 matches = nmatches;
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         // Start reordering with conversion
1:4cbf0d3:         if (matches.size() != 1 && reorderArguments && args.size() > 1) {
1:4cbf0d3:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:4cbf0d3:             for (Method mth : methods) {
1:4cbf0d3:                 ArgumentMatcher matcher = new ArgumentMatcher(mth.getGenericParameterTypes(), true);
1:4cbf0d3:                 List<Object> match = matcher.match(args, types);
1:4cbf0d3:                 if (match != null) {
1:4cbf0d3:                     nmatches.put(mth, match);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:             if (nmatches.size() > 0) {
1:4cbf0d3:                 matches = nmatches;
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         return matches;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private static List<Method> applyStaticHidingRules(Collection<Method> methods) {
1:4cbf0d3:         List<Method> result = new ArrayList<Method>(methods.size());
1:4cbf0d3:         for (Method m : methods) {
1:4cbf0d3:             boolean toBeAdded = true;
1:4cbf0d3: 
1:4cbf0d3:             Iterator<Method> it = result.iterator();
1:4cbf0d3:             inner: while (it.hasNext()) {
1:4cbf0d3:                 Method other = it.next();
1:4cbf0d3:                 if (hasIdenticalParameters(m, other)) {
1:4cbf0d3:                     Class<?> mClass = m.getDeclaringClass();
1:4cbf0d3:                     Class<?> otherClass = other.getDeclaringClass();
1:4cbf0d3: 
1:4cbf0d3:                     if (mClass.isAssignableFrom(otherClass)) {
1:4cbf0d3:                         toBeAdded = false;
1:4cbf0d3:                         break inner;
1:4cbf0d3:                     } else if (otherClass.isAssignableFrom(mClass)) {
1:4cbf0d3:                         it.remove();
1:4cbf0d3:                     }
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3: 
1:4cbf0d3:             if (toBeAdded) result.add(m);
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         return result;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private static boolean hasIdenticalParameters(Method one, Method two) {
1:4cbf0d3:         Class<?>[] oneTypes = one.getParameterTypes();
1:4cbf0d3:         Class<?>[] twoTypes = two.getParameterTypes();
1:4cbf0d3: 
1:4cbf0d3:         if (oneTypes.length != twoTypes.length) return false;
1:4cbf0d3: 
1:4cbf0d3:         for (int i=0; i<oneTypes.length; i++) {
1:4cbf0d3:             if (!oneTypes[i].equals(twoTypes[i])) return false;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         return true;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private Map<Constructor, List<Object>> findMatchingConstructors(Class type, List<Object> args, List<ReifiedType> types) {
1:4cbf0d3:         Map<Constructor, List<Object>> matches = new HashMap<Constructor, List<Object>>();
1:4cbf0d3:         // Get constructors
1:4cbf0d3:         List<Constructor> constructors = new ArrayList<Constructor>(Arrays.asList(type.getConstructors()));
1:4cbf0d3:         // Discard any signature with wrong cardinality
1:4cbf0d3:         for (Iterator<Constructor> it = constructors.iterator(); it.hasNext();) {
1:4cbf0d3:             if (it.next().getParameterTypes().length != args.size()) {
1:4cbf0d3:                 it.remove();
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         // Find a direct match with assignment
1:4cbf0d3:         if (matches.size() != 1) {
1:4cbf0d3:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:4cbf0d3:             for (Constructor cns : constructors) {
1:4cbf0d3:                 boolean found = true;
1:4cbf0d3:                 List<Object> match = new ArrayList<Object>();
1:4cbf0d3:                 for (int i = 0; i < args.size(); i++) {
1:4cbf0d3:                     ReifiedType argType = new GenericType(cns.getGenericParameterTypes()[i]);
1:4cbf0d3:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                     //If the arg is an Unwrappered bean then we need to do the assignment check against the
1:4cbf0d3:                     //unwrappered bean itself.
1:4cbf0d3:                     Object arg = args.get(i);
1:4cbf0d3:                     Object argToTest = arg;
1:4cbf0d3:                     if(arg instanceof UnwrapperedBeanHolder)
1:4cbf0d3:                         argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
1:4cbf0d3:                     if (!AggregateConverter.isAssignable(argToTest, argType)) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                     try {
1:4cbf0d3:                         match.add(convert(arg, cns.getGenericParameterTypes()[i]));
1:4cbf0d3:                     } catch (Throwable t) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                 }
1:4cbf0d3:                 if (found) {
1:4cbf0d3:                     nmatches.put(cns, match);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:             if (nmatches.size() > 0) {
1:4cbf0d3:                 matches = nmatches;
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         // Find a direct match with conversion
1:4cbf0d3:         if (matches.size() != 1) {
1:4cbf0d3:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:4cbf0d3:             for (Constructor cns : constructors) {
1:4cbf0d3:                 boolean found = true;
1:4cbf0d3:                 List<Object> match = new ArrayList<Object>();
1:4cbf0d3:                 for (int i = 0; i < args.size(); i++) {
1:4cbf0d3:                     ReifiedType argType = new GenericType(cns.getGenericParameterTypes()[i]);
1:4cbf0d3:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                     try {
1:4cbf0d3:                         Object val = convert(args.get(i), argType);
1:4cbf0d3:                         match.add(val);
1:4cbf0d3:                     } catch (Throwable t) {
1:4cbf0d3:                         found = false;
1:4cbf0d3:                         break;
1:4cbf0d3:                     }
1:4cbf0d3:                 }
1:4cbf0d3:                 if (found) {
1:4cbf0d3:                     nmatches.put(cns, match);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:             if (nmatches.size() > 0) {
1:4cbf0d3:                 matches = nmatches;
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         // Start reordering with assignment
1:4cbf0d3:         if (matches.size() != 1 && reorderArguments && arguments.size() > 1) {
1:4cbf0d3:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:4cbf0d3:             for (Constructor cns : constructors) {
1:4cbf0d3:                 ArgumentMatcher matcher = new ArgumentMatcher(cns.getGenericParameterTypes(), false);
1:4cbf0d3:                 List<Object> match = matcher.match(args, types);
1:4cbf0d3:                 if (match != null) {
1:4cbf0d3:                     nmatches.put(cns, match);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:             if (nmatches.size() > 0) {
1:4cbf0d3:                 matches = nmatches;
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         // Start reordering with conversion
1:4cbf0d3:         if (matches.size() != 1 && reorderArguments && arguments.size() > 1) {
1:4cbf0d3:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:4cbf0d3:             for (Constructor cns : constructors) {
1:4cbf0d3:                 ArgumentMatcher matcher = new ArgumentMatcher(cns.getGenericParameterTypes(), true);
1:4cbf0d3:                 List<Object> match = matcher.match(args, types);
1:4cbf0d3:                 if (match != null) {
1:4cbf0d3:                     nmatches.put(cns, match);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:             if (nmatches.size() > 0) {
1:4cbf0d3:                 matches = nmatches;
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         return matches;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     /**
1:4cbf0d3:      * Returns init method (if any). Throws exception if the init-method was set explicitly on the bean
1:4cbf0d3:      * and the method is not found on the instance.
1:4cbf0d3:      */
1:4cbf0d3:     protected Method getInitMethod(Object instance) throws ComponentDefinitionException {
1:4cbf0d3:         Method method = null;
1:4cbf0d3:         if (initMethod != null && initMethod.length() > 0) {
1:4cbf0d3:             method = ReflectionUtils.getLifecycleMethod(instance.getClass(), initMethod);
1:4cbf0d3:             if (method == null) {
1:4cbf0d3:                 throw new ComponentDefinitionException("Component '" + getName() + "' does not have init-method: " + initMethod);
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         return method;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     /**
1:4cbf0d3:      * Returns destroy method (if any). Throws exception if the destroy-method was set explicitly on the bean
1:4cbf0d3:      * and the method is not found on the instance.
1:4cbf0d3:      */
1:4cbf0d3:     public Method getDestroyMethod(Object instance) throws ComponentDefinitionException {
1:4cbf0d3:         Method method = null;
1:4cbf0d3:         if (instance != null && destroyMethod != null && destroyMethod.length() > 0) {
1:4cbf0d3:             method = ReflectionUtils.getLifecycleMethod(instance.getClass(), destroyMethod);
1:4cbf0d3:             if (method == null) {
1:4cbf0d3:                 throw new ComponentDefinitionException("Component '" + getName() + "' does not have destroy-method: " + destroyMethod);
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         return method;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     /**
1:4cbf0d3:      * Small helper class, to construct a chain of BeanCreators.
1:4cbf0d3:      * <br> 
1:4cbf0d3:      * Each bean creator in the chain will return a bean that has been 
1:4cbf0d3:      * processed by every BeanProcessor in the chain before it.
1:4cbf0d3:      */
1:4cbf0d3:     private static class BeanCreatorChain implements BeanProcessor.BeanCreator {
1:4cbf0d3:         public enum ChainType{Before,After};
1:4cbf0d3:         private final BeanProcessor.BeanCreator parentBeanCreator;
1:4cbf0d3:         private final BeanProcessor parentBeanProcessor;
1:4cbf0d3:         private final BeanMetadata beanData;
1:4cbf0d3:         private final String beanName;
1:4cbf0d3:         private final ChainType when;
1:4cbf0d3:         public BeanCreatorChain(BeanProcessor.BeanCreator parentBeanCreator,
1:4cbf0d3:                                 BeanProcessor parentBeanProcessor,
1:4cbf0d3:                                 BeanMetadata beanData,
1:4cbf0d3:                                 String beanName,
1:4cbf0d3:                                 ChainType when){
1:4cbf0d3:             this.parentBeanCreator = parentBeanCreator;
1:4cbf0d3:             this.parentBeanProcessor = parentBeanProcessor;
1:4cbf0d3:             this.beanData = beanData;
1:4cbf0d3:             this.beanName = beanName;
1:4cbf0d3:             this.when = when;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         public Object getBean() {
1:4cbf0d3:             Object previousBean = parentBeanCreator.getBean();
1:4cbf0d3:             Object processed = null;
1:4cbf0d3:             switch(when){
1:4cbf0d3:                 case Before :
1:4cbf0d3:                     processed = parentBeanProcessor.beforeInit(previousBean, beanName, parentBeanCreator, beanData);
1:4cbf0d3:                     break;
1:4cbf0d3:                 case After:
1:4cbf0d3:                     processed = parentBeanProcessor.afterInit(previousBean, beanName, parentBeanCreator, beanData);
1:4cbf0d3:                     break;
1:4cbf0d3:             }
1:4cbf0d3:             return processed;
1:4cbf0d3:         }
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private Object runBeanProcPreInit(Object obj){
1:4cbf0d3:         String beanName = getName();
1:4cbf0d3:         BeanMetadata beanData = (BeanMetadata) blueprintContainer
1:4cbf0d3:                 .getComponentDefinitionRegistry().getComponentDefinition(beanName);
1:4cbf0d3:         List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
1:4cbf0d3: 
1:4cbf0d3:         //The start link of the chain, that provides the 
1:4cbf0d3:         //original, unprocessed bean to the head of the chain.
1:4cbf0d3:         BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {
1:4cbf0d3:             public Object getBean() {
1:4cbf0d3:                 Object obj = getInstance();
1:4cbf0d3:                 //getinit, getdestroy, addpartial object don't need calling again.
1:4cbf0d3:                 //however, property injection does.
1:4cbf0d3:                 setProperties(obj);
1:4cbf0d3:                 return obj;
1:4cbf0d3:             }
1:4cbf0d3:         };
1:4cbf0d3: 
1:4cbf0d3:         BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
1:4cbf0d3:         for(BeanProcessor processor : processors){
1:4cbf0d3:             obj = processor.beforeInit(obj, getName(), currentCreator, beanData);
1:4cbf0d3:             currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.Before);
1:4cbf0d3:         }
1:4cbf0d3:         return obj;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private void runBeanProcInit(Method initMethod, Object obj){
1:4cbf0d3:         // call init method
1:4cbf0d3:         if (initMethod != null) {
1:4cbf0d3:             try {
1:4cbf0d3:                 invoke(initMethod, obj, (Object[]) null);
1:4cbf0d3:             } catch (Throwable t) {
1:4cbf0d3:                 throw new ComponentDefinitionException("Unable to intialize bean " + getName(), getRealCause(t));
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private Object runBeanProcPostInit(Object obj){
1:4cbf0d3:         String beanName = getName();
1:4cbf0d3:         BeanMetadata beanData = (BeanMetadata) blueprintContainer
1:4cbf0d3:                 .getComponentDefinitionRegistry().getComponentDefinition(beanName);
1:4cbf0d3:         List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
1:4cbf0d3: 
1:4cbf0d3:         //The start link of the chain, that provides the 
1:4cbf0d3:         //original, unprocessed bean to the head of the chain.
1:4cbf0d3:         BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {
1:4cbf0d3:             public Object getBean() {
1:4cbf0d3:                 Object obj = getInstance();
1:4cbf0d3:                 //getinit, getdestroy, addpartial object don't need calling again.
1:4cbf0d3:                 //however, property injection does.
1:4cbf0d3:                 setProperties(obj);
1:4cbf0d3:                 //as this is the post init chain, new beans need to go thru 
1:4cbf0d3:                 //the pre-init chain, and then have init called, before 
1:4cbf0d3:                 //being passed along the post-init chain.
1:4cbf0d3:                 obj = runBeanProcPreInit(obj);
1:4cbf0d3:                 runBeanProcInit(getInitMethod(obj), obj);
1:4cbf0d3:                 return obj;
1:4cbf0d3:             }
1:4cbf0d3:         };
1:4cbf0d3: 
1:4cbf0d3:         BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
1:4cbf0d3:         for(BeanProcessor processor : processors){
1:4cbf0d3:             obj = processor.afterInit(obj, getName(), currentCreator, beanData);
1:4cbf0d3:             currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.After);
1:4cbf0d3:         }
1:4cbf0d3:         return obj;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private Object addInterceptors(final Object original, Collection<Class<?>> requiredInterfaces)
1:4cbf0d3:             throws ComponentDefinitionException {
1:4cbf0d3: 
1:4cbf0d3:         Object intercepted = null;
1:4cbf0d3:         if(requiredInterfaces.isEmpty())
1:4cbf0d3:             requiredInterfaces.add(original.getClass());
1:4cbf0d3: 
1:4cbf0d3:         ComponentDefinitionRegistry reg = blueprintContainer
1:4cbf0d3:                 .getComponentDefinitionRegistry();
1:4cbf0d3:         List<Interceptor> interceptors = reg.getInterceptors(interceptorLookupKey);
1:4cbf0d3:         if (interceptors != null && interceptors.size() > 0) {
1:4cbf0d3:             /* BLUEPRINT-NOOSGI
1:4cbf0d3:             try {
1:4cbf0d3:                 Bundle b = FrameworkUtil.getBundle(original.getClass());
1:4cbf0d3:                 if (b == null) {
1:4cbf0d3:                     // we have a class from the framework parent, so use our bundle for proxying.
1:4cbf0d3:                     b = blueprintContainer.getBundleContext().getBundle();
1:4cbf0d3:                 }
1:4cbf0d3:                 intercepted = blueprintContainer.getProxyManager().createInterceptingProxy(b,
1:4cbf0d3:                         requiredInterfaces, original, new Collaborator(interceptorLookupKey, interceptors));
1:4cbf0d3:             } catch (org.apache.aries.proxy.UnableToProxyException e) {
1:4cbf0d3:                 Bundle b = blueprintContainer.getBundleContext().getBundle();
1:4cbf0d3:                 throw new ComponentDefinitionException("Unable to create proxy for bean " + name + " in bundle " + b.getSymbolicName() + " version " + b.getVersion(), e);
1:4cbf0d3:             }
1:4cbf0d3:             */
1:4cbf0d3:             throw new ComponentDefinitionException("Unable to create proxy for bean " + name + ".  Not supported in blueprint-noosgi");
1:4cbf0d3:         } else {
1:4cbf0d3:             intercepted = original;
1:4cbf0d3:         }
1:4cbf0d3:         return intercepted;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     @Override
1:4cbf0d3:     protected Object internalCreate() throws ComponentDefinitionException {
1:4cbf0d3:         /* BLUEPRINT-NOOSGI
1:4cbf0d3:         if (factory instanceof ReferenceRecipe) {
1:4cbf0d3:             ReferenceRecipe rr = (ReferenceRecipe) factory;
1:4cbf0d3:             if (rr.getProxyChildBeanClasses() != null) {
1:4cbf0d3:                 return createProxyBean(rr);
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         */
1:4cbf0d3:         return new UnwrapperedBeanHolder(internalCreate2(), this);
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     /* BLUEPRINT-NOOSGI
1:4cbf0d3:     private Object createProxyBean(ReferenceRecipe rr) {
1:4cbf0d3:         try {
1:4cbf0d3:             VoidableCallable vc = new VoidableCallable();
1:4cbf0d3:             rr.addVoidableChild(vc);
1:4cbf0d3:             return blueprintContainer.getProxyManager().createDelegatingProxy(
1:4cbf0d3:                     blueprintContainer.getBundleContext().getBundle(), rr.getProxyChildBeanClasses(),
1:4cbf0d3:                     vc, vc.call());
1:4cbf0d3:         } catch (UnableToProxyException e) {
1:4cbf0d3:             throw new ComponentDefinitionException(e);
1:4cbf0d3:         }
1:4cbf0d3:     }
1:4cbf0d3:     */
1:4cbf0d3: 
1:4cbf0d3:     private Object internalCreate2() throws ComponentDefinitionException {
1:4cbf0d3: 
1:4cbf0d3:         instantiateExplicitDependencies();
1:4cbf0d3: 
1:4cbf0d3:         Object obj = getInstance();
1:4cbf0d3: 
1:4cbf0d3:         // check for init lifecycle method (if any)
1:4cbf0d3:         Method initMethod = getInitMethod(obj);
1:4cbf0d3: 
1:4cbf0d3:         // check for destroy lifecycle method (if any)
1:4cbf0d3:         getDestroyMethod(obj);
1:4cbf0d3: 
1:4cbf0d3:         // Add partially created object to the container
1:4cbf0d3: //        if (initMethod == null) {
1:4cbf0d3:         addPartialObject(obj);
1:4cbf0d3: //        }
1:4cbf0d3: 
1:4cbf0d3:         // inject properties
1:4cbf0d3:         setProperties(obj);
1:4cbf0d3: 
1:4cbf0d3:         obj = runBeanProcPreInit(obj);
1:4cbf0d3: 
1:4cbf0d3:         runBeanProcInit(initMethod, obj);
1:4cbf0d3: 
1:4cbf0d3:         obj = runBeanProcPostInit(obj);
1:4cbf0d3: 
1:4cbf0d3:         //Replaced by calling wrap on the UnwrapperedBeanHolder
1:4cbf0d3: //        obj = addInterceptors(obj);
1:4cbf0d3: 
1:4cbf0d3:         return obj;
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     static Object wrap(UnwrapperedBeanHolder holder, Collection<Class<?>> requiredViews) {
1:4cbf0d3:         return holder.recipe.addInterceptors(holder.unwrapperedBean, requiredViews);
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     static Object wrap(UnwrapperedBeanHolder holder, Class<?> requiredView) {
1:4cbf0d3:         if(requiredView == Object.class) {
1:4cbf0d3:             //We don't know what we need so we have to do everything
1:4cbf0d3:             return holder.recipe.addInterceptors(holder.unwrapperedBean, new ArrayList<Class<?>>(1));
1:4cbf0d3:         } else {
1:4cbf0d3:             return holder.recipe.addInterceptors(holder.unwrapperedBean, ProxyUtils.asList(requiredView));
1:4cbf0d3:         }
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3: 
1:4cbf0d3:     @Override
1:4cbf0d3:     public void destroy(Object obj) {
1:4cbf0d3:         if (!(obj instanceof UnwrapperedBeanHolder)) {
1:4cbf0d3:             LOGGER.warn("Object to be destroyed is not an instance of UnwrapperedBeanHolder, type: " + obj);
1:4cbf0d3:             return;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         obj = ((UnwrapperedBeanHolder)obj).unwrapperedBean;
1:4cbf0d3: 
1:4cbf0d3:         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
1:4cbf0d3:             processor.beforeDestroy(obj, getName());
1:4cbf0d3:         }
1:4cbf0d3:         try {
1:4cbf0d3:             Method method = getDestroyMethod(obj);
1:4cbf0d3:             if (method != null) {
1:4cbf0d3:                 invoke(method, obj, (Object[]) null);
1:4cbf0d3:             }
1:4cbf0d3:         } catch (ComponentDefinitionException e) {
1:4cbf0d3:             // This exception occurs if the destroy method does not exist, so we just output the exception message.
1:4cbf0d3:             LOGGER.error(e.getMessage());
1:4cbf0d3:         } catch (InvocationTargetException ite) {
1:4cbf0d3:             /* BLUEPRINT-OSGI
1:4cbf0d3:             Throwable t = ite.getTargetException();
1:4cbf0d3:             BundleContext ctx = blueprintContainer.getBundleContext();
1:4cbf0d3:             Bundle b = ctx.getBundle();
1:4cbf0d3:             String bundleIdentifier = b.getSymbolicName() + '/' + b.getVersion();
1:4cbf0d3:             LOGGER.error("The blueprint bean " + getName() + " in bundle " + bundleIdentifier + " incorrectly threw an exception from its destroy method.", t);
1:4cbf0d3:             */
1:4cbf0d3:             Throwable t = ite.getTargetException();
1:4cbf0d3:             LOGGER.error("The blueprint bean " + getName() + " in incorrectly threw an exception from its destroy method.", t);
1:4cbf0d3:         } catch (Exception e) {
1:4cbf0d3:             /* BLUEPRINT-OSGI
1:4cbf0d3:             BundleContext ctx = blueprintContainer.getBundleContext();
1:4cbf0d3:             Bundle b = ctx.getBundle();
1:4cbf0d3:             String bundleIdentifier = b.getSymbolicName() + '/' + b.getVersion();
1:4cbf0d3:             LOGGER.error("An exception occurred while calling the destroy method of the blueprint bean " + getName() + " in bundle " + bundleIdentifier + ".", getRealCause(e));
1:4cbf0d3:             */
1:4cbf0d3:             LOGGER.error("An exception occurred while calling the destroy method of the blueprint bean " + getName() + ".", getRealCause(e));
1:4cbf0d3:         }
1:4cbf0d3:         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
1:4cbf0d3:             processor.afterDestroy(obj, getName());
1:4cbf0d3:         }
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public void setProperties(Object instance) throws ComponentDefinitionException {
1:4cbf0d3:         // clone the properties so they can be used again
1:4cbf0d3:         Map<String,Object> propertyValues = new LinkedHashMap<String,Object>(properties);
1:4cbf0d3:         setProperties(propertyValues, instance, instance.getClass());
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     public Class getType() {
1:4cbf0d3:         if (type instanceof Class) {
1:4cbf0d3:             return (Class) type;
1:4cbf0d3:         } else if (type instanceof String) {
1:4cbf0d3:             return loadClass((String) type);
1:4cbf0d3:         } else {
1:4cbf0d3:             return null;
1:4cbf0d3:         }
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private void setProperties(Map<String, Object> propertyValues, Object instance, Class clazz) {
1:4cbf0d3:         // set remaining properties
1:4cbf0d3:         for (Map.Entry<String, Object> entry : propertyValues.entrySet()) {
1:4cbf0d3:             String propertyName = entry.getKey();
1:4cbf0d3:             Object propertyValue = entry.getValue();
1:4cbf0d3: 
1:4cbf0d3:             setProperty(instance, clazz, propertyName, propertyValue);
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private void setProperty(Object instance, Class clazz, String propertyName, Object propertyValue) {
1:4cbf0d3:         String[] names = propertyName.split("\\.");
1:4cbf0d3:         for (int i = 0; i < names.length - 1; i++) {
1:4cbf0d3:             PropertyDescriptor pd = getPropertyDescriptor(clazz, names[i]);
1:4cbf0d3:             if (pd.allowsGet()) {
1:4cbf0d3:                 try {
1:4cbf0d3:                     instance = pd.get(instance, blueprintContainer);
1:4cbf0d3:                 } catch (Exception e) {
1:4cbf0d3:                     throw new ComponentDefinitionException("Error getting property: " + names[i] + " on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName(), getRealCause(e));
1:4cbf0d3:                 }
1:4cbf0d3:                 if (instance == null) {
1:4cbf0d3:                     throw new ComponentDefinitionException("Error setting compound property " + propertyName + " on bean " + getName() + ". Property " + names[i] + " is null");
1:4cbf0d3:                 }
1:4cbf0d3:                 clazz = instance.getClass();
1:4cbf0d3:             } else {
1:4cbf0d3:                 throw new ComponentDefinitionException("No getter for " + names[i] + " property on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName());
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         // Instantiate value
1:4cbf0d3:         if (propertyValue instanceof Recipe) {
1:4cbf0d3:             propertyValue = ((Recipe) propertyValue).create();
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         final PropertyDescriptor pd = getPropertyDescriptor(clazz, names[names.length - 1]);
1:4cbf0d3:         if (pd.allowsSet()) {
1:4cbf0d3:             try {
1:4cbf0d3:                 pd.set(instance, propertyValue, blueprintContainer);
1:4cbf0d3:             } catch (Exception e) {
1:4cbf0d3:                 throw new ComponentDefinitionException("Error setting property: " + pd, getRealCause(e));
1:4cbf0d3:             }
1:4cbf0d3:         } else {
1:4cbf0d3:             throw new ComponentDefinitionException("No setter for " + names[names.length - 1] + " property");
1:4cbf0d3:         }
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private ReflectionUtils.PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String name) {
1:4cbf0d3:         for (ReflectionUtils.PropertyDescriptor pd : ReflectionUtils.getPropertyDescriptors(clazz, allowsFieldInjection)) {
1:4cbf0d3:             if (pd.getName().equals(name)) {
1:4cbf0d3:                 return pd;
1:4cbf0d3:             }
1:4cbf0d3:         }
1:4cbf0d3:         throw new ComponentDefinitionException("Unable to find property descriptor " + name + " on class " + clazz.getName());
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private Object invoke(Method method, Object instance, Object... args) throws Exception {
1:4cbf0d3:         return ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), method, instance, args);
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private Object newInstance(Constructor constructor, Object... args) throws Exception {
1:4cbf0d3:         return ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), constructor, args);
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private static Object UNMATCHED = new Object();
1:4cbf0d3: 
1:4cbf0d3:     private class ArgumentMatcher {
1:4cbf0d3: 
1:4cbf0d3:         private final List<TypeEntry> entries;
1:4cbf0d3:         private final boolean convert;
1:4cbf0d3: 
1:4cbf0d3:         public ArgumentMatcher(Type[] types, boolean convert) {
1:4cbf0d3:             entries = new ArrayList<TypeEntry>();
1:4cbf0d3:             for (Type type : types) {
1:4cbf0d3:                 entries.add(new TypeEntry(new GenericType(type)));
1:4cbf0d3:             }
1:4cbf0d3:             this.convert = convert;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         public List<Object> match(List<Object> arguments, List<ReifiedType> forcedTypes) {
1:4cbf0d3:             if (find(arguments, forcedTypes)) {
1:4cbf0d3:                 return getArguments();
1:4cbf0d3:             }
1:4cbf0d3:             return null;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         private List<Object> getArguments() {
1:4cbf0d3:             List<Object> list = new ArrayList<Object>();
1:4cbf0d3:             for (TypeEntry entry : entries) {
1:4cbf0d3:                 if (entry.argument == UNMATCHED) {
1:4cbf0d3:                     throw new RuntimeException("There are unmatched types");
1:4cbf0d3:                 } else {
1:4cbf0d3:                     list.add(entry.argument);
1:4cbf0d3:                 }
1:4cbf0d3:             }
1:4cbf0d3:             return list;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         private boolean find(List<Object> arguments, List<ReifiedType> forcedTypes) {
1:4cbf0d3:             if (entries.size() == arguments.size()) {
1:4cbf0d3:                 boolean matched = true;
1:4cbf0d3:                 for (int i = 0; i < arguments.size() && matched; i++) {
1:4cbf0d3:                     matched = find(arguments.get(i), forcedTypes.get(i));
1:4cbf0d3:                 }
1:4cbf0d3:                 return matched;
1:4cbf0d3:             }
1:4cbf0d3:             return false;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:         private boolean find(Object arg, ReifiedType forcedType) {
1:4cbf0d3:             for (TypeEntry entry : entries) {
1:4cbf0d3:                 Object val = arg;
1:4cbf0d3:                 if (entry.argument != UNMATCHED) {
1:4cbf0d3:                     continue;
1:4cbf0d3:                 }
1:4cbf0d3:                 if (forcedType != null) {
1:4cbf0d3:                     if (!forcedType.equals(entry.type)) {
1:4cbf0d3:                         continue;
1:4cbf0d3:                     }
1:4cbf0d3:                 } else if (arg != null) {
1:4cbf0d3:                     if (convert) {
1:4cbf0d3: 
1:4cbf0d3:                         if(canConvert(arg, entry.type)) {
1:4cbf0d3:                             try {
1:4cbf0d3:                                 val = convert(arg, entry.type);
1:4cbf0d3:                             } catch (Exception e) {
1:4cbf0d3:                                 throw new ComponentDefinitionException(e);
1:4cbf0d3:                             }
1:4cbf0d3:                         } else {
1:4cbf0d3:                             continue;
1:4cbf0d3:                         }
1:4cbf0d3:                     } else {
1:4cbf0d3:                         UnwrapperedBeanHolder holder = null;
1:4cbf0d3:                         if(arg instanceof UnwrapperedBeanHolder) {
1:4cbf0d3:                             holder = (UnwrapperedBeanHolder)arg;
1:4cbf0d3:                             arg = holder.unwrapperedBean;
1:4cbf0d3:                         }
1:4cbf0d3:                         if (!AggregateConverter.isAssignable(arg, entry.type)) {
1:4cbf0d3:                             continue;
1:4cbf0d3:                         } else if (holder != null) {
1:4cbf0d3:                             val = wrap(holder, entry.type.getRawClass());
1:4cbf0d3:                         }
1:4cbf0d3:                     }
1:4cbf0d3:                 }
1:4cbf0d3:                 entry.argument = val;
1:4cbf0d3:                 return true;
1:4cbf0d3:             }
1:4cbf0d3:             return false;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3:     private static class TypeEntry {
1:4cbf0d3: 
1:4cbf0d3:         private final ReifiedType type;
1:4cbf0d3:         private Object argument;
1:4cbf0d3: 
1:4cbf0d3:         public TypeEntry(ReifiedType type) {
1:4cbf0d3:             this.type = type;
1:4cbf0d3:             this.argument = UNMATCHED;
1:4cbf0d3:         }
1:4cbf0d3: 
1:4cbf0d3:     }
1:4cbf0d3: 
1:4cbf0d3: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:4cbf0d3
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.blueprint.container;
1: 
1: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
1: 
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
1: import java.lang.reflect.Type;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.Semaphore;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
1: import org.apache.aries.blueprint.BeanProcessor;
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1: import org.apache.aries.blueprint.Interceptor;
1: import org.apache.aries.blueprint.di.AbstractRecipe;
1: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.proxy.Collaborator;
1: import org.apache.aries.blueprint.proxy.ProxyUtils;
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.utils.ReflectionUtils;
1: import org.apache.aries.blueprint.utils.ReflectionUtils.PropertyDescriptor;
1: import org.apache.aries.proxy.UnableToProxyException;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.container.ReifiedType;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A <code>Recipe</code> to create POJOs.
1:  *
1:  * @version $Rev$, $Date$
1:  */
1: public class BeanRecipe extends AbstractRecipe {
1: 
1:     static class UnwrapperedBeanHolder {
1:         final Object unwrapperedBean;
1:         final BeanRecipe recipe;
1: 
1:         public UnwrapperedBeanHolder(Object unwrapperedBean, BeanRecipe recipe) {
1:             this.unwrapperedBean = unwrapperedBean;
1:             this.recipe = recipe;
1:         }
1:     }
1: 
1:     public class VoidableCallable implements Callable<Object>, Voidable {
1: 
1:         private final AtomicReference<Object> ref = new AtomicReference<Object>();
1: 
1:         private final Semaphore sem = new Semaphore(1);
1: 
1:         private final ThreadLocal<Object> deadlockDetector = new ThreadLocal<Object>();
1: 
1:         public void voidReference() {
1:             ref.set(null);
1:         }
1: 
1:         public Object call() throws ComponentDefinitionException {
1:             Object o = ref.get();
1: 
1:             if (o == null) {
1:                 if(deadlockDetector.get() != null) {
1:                     deadlockDetector.remove();
1:                     throw new ComponentDefinitionException("Construction cycle detected for bean " + name);
1:                 }
1: 
1:                 sem.acquireUninterruptibly();
1:                 try {
1:                     o = ref.get();
1:                     if (o == null) {
1:                         deadlockDetector.set(this);
1:                         try {
1:                             o = internalCreate2();
1:                             ref.set(o);
1:                         } finally {
1:                             deadlockDetector.remove();
1:                         }
1:                     }
1:                 } finally {
1:                     sem.release();
1:                 }
1:             }
1: 
1:             return o;
1:         }
1: 
1:     }
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(BeanRecipe.class);
1: 
1:     private final ExtendedBlueprintContainer blueprintContainer;
1:     private final LinkedHashMap<String,Object> properties = new LinkedHashMap<String,Object>();
1:     private final Object type;
1: 
1:     private String initMethod;
1:     private String destroyMethod;
1:     private List<Recipe> explicitDependencies;
1: 
1:     private Recipe factory;
1:     private String factoryMethod;
1:     private List<Object> arguments;
1:     private List<String> argTypes;
1:     private boolean reorderArguments;
1:     private final boolean allowsFieldInjection;
1:     private BeanMetadata interceptorLookupKey;
1: 
1: 
1:     public BeanRecipe(String name, ExtendedBlueprintContainer blueprintContainer, Object type, boolean allowsFieldInjection) {
1:         super(name);
1:         this.blueprintContainer = blueprintContainer;
1:         this.type = type;
1:         this.allowsFieldInjection = allowsFieldInjection;
1:     }
1: 
1:     public Object getProperty(String name) {
1:         return properties.get(name);
1:     }
1: 
1:     public Map<String, Object> getProperties() {
1:         return new LinkedHashMap<String, Object>(properties);
1:     }
1: 
1:     public void setProperty(String name, Object value) {
1:         properties.put(name, value);
1:     }
1: 
1:     public void setFactoryMethod(String method) {
1:         this.factoryMethod = method;
1:     }
1: 
1:     public void setFactoryComponent(Recipe factory) {
1:         this.factory = factory;
1:     }
1: 
1:     public void setArgTypes(List<String> argTypes) {
1:         this.argTypes = argTypes;
1:     }
1: 
1:     public void setArguments(List<Object> arguments) {
1:         this.arguments = arguments;
1:     }
1: 
1:     public void setReorderArguments(boolean reorder) {
1:         this.reorderArguments = reorder;
1:     }
1: 
1:     public void setInitMethod(String initMethod) {
1:         this.initMethod = initMethod;
1:     }
1: 
1:     public String getInitMethod() {
1:         return initMethod;
1:     }
1: 
1:     public void setDestroyMethod(String destroyMethod) {
1:         this.destroyMethod = destroyMethod;
1:     }
1: 
1:     public String getDestroyMethod() {
1:         return destroyMethod;
1:     }
1: 
1:     public List<Recipe> getExplicitDependencies() {
1:         return explicitDependencies;
1:     }
1: 
1:     public void setExplicitDependencies(List<Recipe> explicitDependencies) {
1:         this.explicitDependencies = explicitDependencies;
1:     }
1: 
1:     public void setInterceptorLookupKey(BeanMetadata metadata) {
1:         interceptorLookupKey = metadata;
1:     }
1: 
1:     @Override
1:     public List<Recipe> getConstructorDependencies() {
1:         List<Recipe> recipes = new ArrayList<Recipe>();
1:         if (explicitDependencies != null) {
1:             recipes.addAll(explicitDependencies);
1:         }
1:         if (arguments != null) {
1:             for (Object argument : arguments) {
1:                 if (argument instanceof Recipe) {
1:                     recipes.add((Recipe)argument);
1:                 }
1:             }
1:         }
1:         return recipes;
1:     }
1: 
1:     public List<Recipe> getDependencies() {
1:         List<Recipe> recipes = new ArrayList<Recipe>();
1:         for (Object o : properties.values()) {
1:             if (o instanceof Recipe) {
1:                 Recipe recipe = (Recipe) o;
1:                 recipes.add(recipe);
1:             }
1:         }
1:         recipes.addAll(getConstructorDependencies());
1:         return recipes;
1:     }
1: 
1:     private void instantiateExplicitDependencies() {
1:         if (explicitDependencies != null) {
1:             for (Recipe recipe : explicitDependencies) {
1:                 recipe.create();
1:             }
1:         }
1:     }
1: 
1:     @Override
1:     protected Class loadClass(String className) {
1:         ClassLoader loader = type instanceof Class ? ((Class) type).getClassLoader() : null;
1:         ReifiedType t = loadType(className, loader);
1:         return t != null ? t.getRawClass() : null;
1:     }
1: 
1:     @Override
1:     protected ReifiedType loadType(String className) {
1:         return loadType(className, type instanceof Class ? ((Class) type).getClassLoader() : null);
1:     }
1: 
1:     private Object getInstance() throws ComponentDefinitionException {
1:         Object instance;
1: 
1:         // Instanciate arguments
1:         List<Object> args = new ArrayList<Object>();
1:         List<ReifiedType> argTypes = new ArrayList<ReifiedType>();
1:         if (arguments != null) {
1:             for (int i = 0; i < arguments.size(); i++) {
1:                 Object arg = arguments.get(i);
1:                 if (arg instanceof Recipe) {
1:                     args.add(((Recipe) arg).create());
1:                 } else {
1:                     args.add(arg);
1:                 }
1:                 if (this.argTypes != null) {
1:                     argTypes.add(this.argTypes.get(i) != null ? loadType(this.argTypes.get(i)) : null);
1:                 }
1:             }
1:         }
1: 
1:         if (factory != null) {
1:             // look for instance method on factory object
1:             Object factoryObj = factory.create();
1: 
1:             // If the factory is a service reference, we need to get hold of the actual proxy for the service
1:             /* BLUEPRINT-NOOSGI
1:             if (factoryObj instanceof ReferenceRecipe.ServiceProxyWrapper) {
1:                 try {
1:                     factoryObj = ((ReferenceRecipe.ServiceProxyWrapper) factoryObj).convert(new ReifiedType(Object.class));
1:                 } catch (Exception e) {
1:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
1:                 }
1:             } else*/ if (factoryObj instanceof UnwrapperedBeanHolder) {
1:                 factoryObj = wrap((UnwrapperedBeanHolder) factoryObj, Object.class);
1:             }
1: 
1:             // Map of matching methods
1:             Map<Method, List<Object>> matches = findMatchingMethods(factoryObj.getClass(), factoryMethod, true, args, argTypes);
1:             if (matches.size() == 1) {
1:                 try {
1:                     Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
1:                     instance = invoke(match.getKey(), factoryObj, match.getValue().toArray());
1:                 } catch (Throwable e) {
1:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
1:                 }
1:             } else if (matches.size() == 0) {
1:                 throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + factoryObj.getClass().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:             } else {
1:                 throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + factoryObj.getClass().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:             }
1:         } else if (factoryMethod != null) {
1:             // Map of matching methods
1:             Map<Method, List<Object>> matches = findMatchingMethods(getType(), factoryMethod, false, args, argTypes);
1:             if (matches.size() == 1) {
1:                 try {
1:                     Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
1:                     instance = invoke(match.getKey(), null, match.getValue().toArray());
1:                 } catch (Throwable e) {
1:                     throw new ComponentDefinitionException("Error when instanciating bean " + getName() + " of class " + getType(), getRealCause(e));
1:                 }
1:             } else if (matches.size() == 0) {
1:                 throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:             } else {
1:                 throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:             }
1:         } else {
1:             if (getType() == null) {
1:                 throw new ComponentDefinitionException("No factoryMethod nor class is defined for this bean");
1:             }
1:             // Map of matching constructors
1:             Map<Constructor, List<Object>> matches = findMatchingConstructors(getType(), args, argTypes);
1:             if (matches.size() == 1) {
1:                 try {
1:                     Map.Entry<Constructor, List<Object>> match = matches.entrySet().iterator().next();
1:                     instance = newInstance(match.getKey(), match.getValue().toArray());
1:                 } catch (Throwable e) {
1:                     throw new ComponentDefinitionException("Error when instanciating bean " + getName() + " of class " + getType(), getRealCause(e));
1:                 }
1:             } else if (matches.size() == 0) {
1:                 throw new ComponentDefinitionException("Unable to find a matching constructor on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:             } else {
1:                 throw new ComponentDefinitionException("Multiple matching constructors found on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:             }
1:         }
1: 
1:         return instance;
1:     }
1: 
1:     private Map<Method, List<Object>> findMatchingMethods(Class type, String name, boolean instance, List<Object> args, List<ReifiedType> types) {
1:         Map<Method, List<Object>> matches = new HashMap<Method, List<Object>>();
1:         // Get constructors
1:         List<Method> methods = new ArrayList<Method>(Arrays.asList(type.getMethods()));
1:         // Discard any signature with wrong cardinality
1:         for (Iterator<Method> it = methods.iterator(); it.hasNext();) {
1:             Method mth = it.next();
1:             if (!mth.getName().equals(name)) {
1:                 it.remove();
1:             } else if (mth.getParameterTypes().length != args.size()) {
1:                 it.remove();
1:             } else if (instance ^ !Modifier.isStatic(mth.getModifiers())) {
1:                 it.remove();
1:             } else if (mth.isBridge()) {
1:                 it.remove();
1:             }
1:         }
1: 
1:         // on some JVMs (J9) hidden static methods are returned by Class.getMethods so we need to weed them out
1:         // to reduce ambiguity
1:         if (!instance) {
1:             methods = applyStaticHidingRules(methods);
1:         }
1: 
1:         // Find a direct match with assignment
1:         if (matches.size() != 1) {
1:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:             for (Method mth : methods) {
1:                 boolean found = true;
1:                 List<Object> match = new ArrayList<Object>();
1:                 for (int i = 0; i < args.size(); i++) {
1:                     ReifiedType argType = new GenericType(mth.getGenericParameterTypes()[i]);
1:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:                         found = false;
1:                         break;
1:                     }
1:                     //If the arg is an Unwrappered bean then we need to do the assignment check against the
1:                     //unwrappered bean itself.
1:                     Object arg = args.get(i);
1:                     Object argToTest = arg;
1:                     if(arg instanceof UnwrapperedBeanHolder)
1:                         argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
1:                     if (!AggregateConverter.isAssignable(argToTest, argType)) {
1:                         found = false;
1:                         break;
1:                     }
1:                     try {
1:                         match.add(convert(arg, mth.getGenericParameterTypes()[i]));
1:                     } catch (Throwable t) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     nmatches.put(mth, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Find a direct match with conversion
1:         if (matches.size() != 1) {
1:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:             for (Method mth : methods) {
1:                 boolean found = true;
1:                 List<Object> match = new ArrayList<Object>();
1:                 for (int i = 0; i < args.size(); i++) {
1:                     ReifiedType argType = new GenericType(mth.getGenericParameterTypes()[i]);
1:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:                         found = false;
1:                         break;
1:                     }
1:                     try {
1:                         Object val = convert(args.get(i), argType);
1:                         match.add(val);
1:                     } catch (Throwable t) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     nmatches.put(mth, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Start reordering with assignment
1:         if (matches.size() != 1 && reorderArguments && args.size() > 1) {
1:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:             for (Method mth : methods) {
1:                 ArgumentMatcher matcher = new ArgumentMatcher(mth.getGenericParameterTypes(), false);
1:                 List<Object> match = matcher.match(args, types);
1:                 if (match != null) {
1:                     nmatches.put(mth, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Start reordering with conversion
1:         if (matches.size() != 1 && reorderArguments && args.size() > 1) {
1:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:             for (Method mth : methods) {
1:                 ArgumentMatcher matcher = new ArgumentMatcher(mth.getGenericParameterTypes(), true);
1:                 List<Object> match = matcher.match(args, types);
1:                 if (match != null) {
1:                     nmatches.put(mth, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1: 
1:         return matches;
1:     }
1: 
1:     private static List<Method> applyStaticHidingRules(Collection<Method> methods) {
1:         List<Method> result = new ArrayList<Method>(methods.size());
1:         for (Method m : methods) {
1:             boolean toBeAdded = true;
1: 
1:             Iterator<Method> it = result.iterator();
1:             inner: while (it.hasNext()) {
1:                 Method other = it.next();
1:                 if (hasIdenticalParameters(m, other)) {
1:                     Class<?> mClass = m.getDeclaringClass();
1:                     Class<?> otherClass = other.getDeclaringClass();
1: 
1:                     if (mClass.isAssignableFrom(otherClass)) {
1:                         toBeAdded = false;
1:                         break inner;
1:                     } else if (otherClass.isAssignableFrom(mClass)) {
1:                         it.remove();
1:                     }
1:                 }
1:             }
1: 
1:             if (toBeAdded) result.add(m);
1:         }
1: 
1:         return result;
1:     }
1: 
1:     private static boolean hasIdenticalParameters(Method one, Method two) {
1:         Class<?>[] oneTypes = one.getParameterTypes();
1:         Class<?>[] twoTypes = two.getParameterTypes();
1: 
1:         if (oneTypes.length != twoTypes.length) return false;
1: 
1:         for (int i=0; i<oneTypes.length; i++) {
1:             if (!oneTypes[i].equals(twoTypes[i])) return false;
1:         }
1: 
1:         return true;
1:     }
1: 
1:     private Map<Constructor, List<Object>> findMatchingConstructors(Class type, List<Object> args, List<ReifiedType> types) {
1:         Map<Constructor, List<Object>> matches = new HashMap<Constructor, List<Object>>();
1:         // Get constructors
1:         List<Constructor> constructors = new ArrayList<Constructor>(Arrays.asList(type.getConstructors()));
1:         // Discard any signature with wrong cardinality
1:         for (Iterator<Constructor> it = constructors.iterator(); it.hasNext();) {
1:             if (it.next().getParameterTypes().length != args.size()) {
1:                 it.remove();
1:             }
1:         }
1:         // Find a direct match with assignment
1:         if (matches.size() != 1) {
1:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:             for (Constructor cns : constructors) {
1:                 boolean found = true;
1:                 List<Object> match = new ArrayList<Object>();
1:                 for (int i = 0; i < args.size(); i++) {
1:                     ReifiedType argType = new GenericType(cns.getGenericParameterTypes()[i]);
1:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:                         found = false;
1:                         break;
1:                     }
1:                     //If the arg is an Unwrappered bean then we need to do the assignment check against the
1:                     //unwrappered bean itself.
1:                     Object arg = args.get(i);
1:                     Object argToTest = arg;
1:                     if(arg instanceof UnwrapperedBeanHolder)
1:                         argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
1:                     if (!AggregateConverter.isAssignable(argToTest, argType)) {
1:                         found = false;
1:                         break;
1:                     }
1:                     try {
1:                         match.add(convert(arg, cns.getGenericParameterTypes()[i]));
1:                     } catch (Throwable t) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     nmatches.put(cns, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Find a direct match with conversion
1:         if (matches.size() != 1) {
1:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:             for (Constructor cns : constructors) {
1:                 boolean found = true;
1:                 List<Object> match = new ArrayList<Object>();
1:                 for (int i = 0; i < args.size(); i++) {
1:                     ReifiedType argType = new GenericType(cns.getGenericParameterTypes()[i]);
1:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:                         found = false;
1:                         break;
1:                     }
1:                     try {
1:                         Object val = convert(args.get(i), argType);
1:                         match.add(val);
1:                     } catch (Throwable t) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     nmatches.put(cns, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Start reordering with assignment
1:         if (matches.size() != 1 && reorderArguments && arguments.size() > 1) {
1:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:             for (Constructor cns : constructors) {
1:                 ArgumentMatcher matcher = new ArgumentMatcher(cns.getGenericParameterTypes(), false);
1:                 List<Object> match = matcher.match(args, types);
1:                 if (match != null) {
1:                     nmatches.put(cns, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Start reordering with conversion
1:         if (matches.size() != 1 && reorderArguments && arguments.size() > 1) {
1:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:             for (Constructor cns : constructors) {
1:                 ArgumentMatcher matcher = new ArgumentMatcher(cns.getGenericParameterTypes(), true);
1:                 List<Object> match = matcher.match(args, types);
1:                 if (match != null) {
1:                     nmatches.put(cns, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         return matches;
1:     }
1: 
1:     /**
1:      * Returns init method (if any). Throws exception if the init-method was set explicitly on the bean
1:      * and the method is not found on the instance.
1:      */
1:     protected Method getInitMethod(Object instance) throws ComponentDefinitionException {
1:         Method method = null;
1:         if (initMethod != null && initMethod.length() > 0) {
1:             method = ReflectionUtils.getLifecycleMethod(instance.getClass(), initMethod);
1:             if (method == null) {
1:                 throw new ComponentDefinitionException("Component '" + getName() + "' does not have init-method: " + initMethod);
1:             }
1:         }
1:         return method;
1:     }
1: 
1:     /**
1:      * Returns destroy method (if any). Throws exception if the destroy-method was set explicitly on the bean
1:      * and the method is not found on the instance.
1:      */
1:     public Method getDestroyMethod(Object instance) throws ComponentDefinitionException {
1:         Method method = null;
1:         if (instance != null && destroyMethod != null && destroyMethod.length() > 0) {
1:             method = ReflectionUtils.getLifecycleMethod(instance.getClass(), destroyMethod);
1:             if (method == null) {
1:                 throw new ComponentDefinitionException("Component '" + getName() + "' does not have destroy-method: " + destroyMethod);
1:             }
1:         }
1:         return method;
1:     }
1: 
1:     /**
1:      * Small helper class, to construct a chain of BeanCreators.
1:      * <br> 
1:      * Each bean creator in the chain will return a bean that has been 
1:      * processed by every BeanProcessor in the chain before it.
1:      */
1:     private static class BeanCreatorChain implements BeanProcessor.BeanCreator {
1:         public enum ChainType{Before,After};
1:         private final BeanProcessor.BeanCreator parentBeanCreator;
1:         private final BeanProcessor parentBeanProcessor;
1:         private final BeanMetadata beanData;
1:         private final String beanName;
1:         private final ChainType when;
1:         public BeanCreatorChain(BeanProcessor.BeanCreator parentBeanCreator,
1:                                 BeanProcessor parentBeanProcessor,
1:                                 BeanMetadata beanData,
1:                                 String beanName,
1:                                 ChainType when){
1:             this.parentBeanCreator = parentBeanCreator;
1:             this.parentBeanProcessor = parentBeanProcessor;
1:             this.beanData = beanData;
1:             this.beanName = beanName;
1:             this.when = when;
1:         }
1: 
1:         public Object getBean() {
1:             Object previousBean = parentBeanCreator.getBean();
1:             Object processed = null;
1:             switch(when){
1:                 case Before :
1:                     processed = parentBeanProcessor.beforeInit(previousBean, beanName, parentBeanCreator, beanData);
1:                     break;
1:                 case After:
1:                     processed = parentBeanProcessor.afterInit(previousBean, beanName, parentBeanCreator, beanData);
1:                     break;
1:             }
1:             return processed;
1:         }
1:     }
1: 
1:     private Object runBeanProcPreInit(Object obj){
1:         String beanName = getName();
1:         BeanMetadata beanData = (BeanMetadata) blueprintContainer
1:                 .getComponentDefinitionRegistry().getComponentDefinition(beanName);
1:         List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
1: 
1:         //The start link of the chain, that provides the 
1:         //original, unprocessed bean to the head of the chain.
1:         BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {
1:             public Object getBean() {
1:                 Object obj = getInstance();
1:                 //getinit, getdestroy, addpartial object don't need calling again.
1:                 //however, property injection does.
1:                 setProperties(obj);
1:                 return obj;
1:             }
1:         };
1: 
1:         BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
1:         for(BeanProcessor processor : processors){
1:             obj = processor.beforeInit(obj, getName(), currentCreator, beanData);
1:             currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.Before);
1:         }
1:         return obj;
1:     }
1: 
1:     private void runBeanProcInit(Method initMethod, Object obj){
1:         // call init method
1:         if (initMethod != null) {
1:             try {
1:                 invoke(initMethod, obj, (Object[]) null);
1:             } catch (Throwable t) {
1:                 throw new ComponentDefinitionException("Unable to intialize bean " + getName(), getRealCause(t));
1:             }
1:         }
1:     }
1: 
1:     private Object runBeanProcPostInit(Object obj){
1:         String beanName = getName();
1:         BeanMetadata beanData = (BeanMetadata) blueprintContainer
1:                 .getComponentDefinitionRegistry().getComponentDefinition(beanName);
1:         List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
1: 
1:         //The start link of the chain, that provides the 
1:         //original, unprocessed bean to the head of the chain.
1:         BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {
1:             public Object getBean() {
1:                 Object obj = getInstance();
1:                 //getinit, getdestroy, addpartial object don't need calling again.
1:                 //however, property injection does.
1:                 setProperties(obj);
1:                 //as this is the post init chain, new beans need to go thru 
1:                 //the pre-init chain, and then have init called, before 
1:                 //being passed along the post-init chain.
1:                 obj = runBeanProcPreInit(obj);
1:                 runBeanProcInit(getInitMethod(obj), obj);
1:                 return obj;
1:             }
1:         };
1: 
1:         BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
1:         for(BeanProcessor processor : processors){
1:             obj = processor.afterInit(obj, getName(), currentCreator, beanData);
1:             currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.After);
1:         }
1:         return obj;
1:     }
1: 
1:     private Object addInterceptors(final Object original, Collection<Class<?>> requiredInterfaces)
1:             throws ComponentDefinitionException {
1: 
1:         Object intercepted = null;
1:         if(requiredInterfaces.isEmpty())
1:             requiredInterfaces.add(original.getClass());
1: 
1:         ComponentDefinitionRegistry reg = blueprintContainer
1:                 .getComponentDefinitionRegistry();
1:         List<Interceptor> interceptors = reg.getInterceptors(interceptorLookupKey);
1:         if (interceptors != null && interceptors.size() > 0) {
1:             /* BLUEPRINT-NOOSGI
1:             try {
1:                 Bundle b = FrameworkUtil.getBundle(original.getClass());
1:                 if (b == null) {
1:                     // we have a class from the framework parent, so use our bundle for proxying.
1:                     b = blueprintContainer.getBundleContext().getBundle();
1:                 }
1:                 intercepted = blueprintContainer.getProxyManager().createInterceptingProxy(b,
1:                         requiredInterfaces, original, new Collaborator(interceptorLookupKey, interceptors));
1:             } catch (org.apache.aries.proxy.UnableToProxyException e) {
1:                 Bundle b = blueprintContainer.getBundleContext().getBundle();
1:                 throw new ComponentDefinitionException("Unable to create proxy for bean " + name + " in bundle " + b.getSymbolicName() + " version " + b.getVersion(), e);
1:             }
1:             */
1:             throw new ComponentDefinitionException("Unable to create proxy for bean " + name + ".  Not supported in blueprint-noosgi");
1:         } else {
1:             intercepted = original;
1:         }
1:         return intercepted;
1:     }
1: 
1:     @Override
1:     protected Object internalCreate() throws ComponentDefinitionException {
1:         /* BLUEPRINT-NOOSGI
1:         if (factory instanceof ReferenceRecipe) {
1:             ReferenceRecipe rr = (ReferenceRecipe) factory;
1:             if (rr.getProxyChildBeanClasses() != null) {
1:                 return createProxyBean(rr);
1:             }
1:         }
1:         */
1:         return new UnwrapperedBeanHolder(internalCreate2(), this);
1:     }
1: 
1:     /* BLUEPRINT-NOOSGI
1:     private Object createProxyBean(ReferenceRecipe rr) {
1:         try {
1:             VoidableCallable vc = new VoidableCallable();
1:             rr.addVoidableChild(vc);
1:             return blueprintContainer.getProxyManager().createDelegatingProxy(
1:                     blueprintContainer.getBundleContext().getBundle(), rr.getProxyChildBeanClasses(),
1:                     vc, vc.call());
1:         } catch (UnableToProxyException e) {
1:             throw new ComponentDefinitionException(e);
1:         }
1:     }
1:     */
1: 
1:     private Object internalCreate2() throws ComponentDefinitionException {
1: 
1:         instantiateExplicitDependencies();
1: 
1:         Object obj = getInstance();
1: 
1:         // check for init lifecycle method (if any)
1:         Method initMethod = getInitMethod(obj);
1: 
1:         // check for destroy lifecycle method (if any)
1:         getDestroyMethod(obj);
1: 
1:         // Add partially created object to the container
1: //        if (initMethod == null) {
1:         addPartialObject(obj);
1: //        }
1: 
1:         // inject properties
1:         setProperties(obj);
1: 
1:         obj = runBeanProcPreInit(obj);
1: 
1:         runBeanProcInit(initMethod, obj);
1: 
1:         obj = runBeanProcPostInit(obj);
1: 
1:         //Replaced by calling wrap on the UnwrapperedBeanHolder
1: //        obj = addInterceptors(obj);
1: 
1:         return obj;
1:     }
1: 
1:     static Object wrap(UnwrapperedBeanHolder holder, Collection<Class<?>> requiredViews) {
1:         return holder.recipe.addInterceptors(holder.unwrapperedBean, requiredViews);
1:     }
1: 
1:     static Object wrap(UnwrapperedBeanHolder holder, Class<?> requiredView) {
1:         if(requiredView == Object.class) {
1:             //We don't know what we need so we have to do everything
1:             return holder.recipe.addInterceptors(holder.unwrapperedBean, new ArrayList<Class<?>>(1));
1:         } else {
1:             return holder.recipe.addInterceptors(holder.unwrapperedBean, ProxyUtils.asList(requiredView));
1:         }
1:     }
1: 
1: 
1:     @Override
1:     public void destroy(Object obj) {
1:         if (!(obj instanceof UnwrapperedBeanHolder)) {
1:             LOGGER.warn("Object to be destroyed is not an instance of UnwrapperedBeanHolder, type: " + obj);
1:             return;
1:         }
1: 
1:         obj = ((UnwrapperedBeanHolder)obj).unwrapperedBean;
1: 
1:         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
1:             processor.beforeDestroy(obj, getName());
1:         }
1:         try {
1:             Method method = getDestroyMethod(obj);
1:             if (method != null) {
1:                 invoke(method, obj, (Object[]) null);
1:             }
1:         } catch (ComponentDefinitionException e) {
1:             // This exception occurs if the destroy method does not exist, so we just output the exception message.
1:             LOGGER.error(e.getMessage());
1:         } catch (InvocationTargetException ite) {
1:             /* BLUEPRINT-OSGI
1:             Throwable t = ite.getTargetException();
1:             BundleContext ctx = blueprintContainer.getBundleContext();
1:             Bundle b = ctx.getBundle();
1:             String bundleIdentifier = b.getSymbolicName() + '/' + b.getVersion();
1:             LOGGER.error("The blueprint bean " + getName() + " in bundle " + bundleIdentifier + " incorrectly threw an exception from its destroy method.", t);
1:             */
1:             Throwable t = ite.getTargetException();
1:             LOGGER.error("The blueprint bean " + getName() + " in incorrectly threw an exception from its destroy method.", t);
1:         } catch (Exception e) {
1:             /* BLUEPRINT-OSGI
1:             BundleContext ctx = blueprintContainer.getBundleContext();
1:             Bundle b = ctx.getBundle();
1:             String bundleIdentifier = b.getSymbolicName() + '/' + b.getVersion();
1:             LOGGER.error("An exception occurred while calling the destroy method of the blueprint bean " + getName() + " in bundle " + bundleIdentifier + ".", getRealCause(e));
1:             */
1:             LOGGER.error("An exception occurred while calling the destroy method of the blueprint bean " + getName() + ".", getRealCause(e));
1:         }
1:         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
1:             processor.afterDestroy(obj, getName());
1:         }
1:     }
1: 
1:     public void setProperties(Object instance) throws ComponentDefinitionException {
1:         // clone the properties so they can be used again
1:         Map<String,Object> propertyValues = new LinkedHashMap<String,Object>(properties);
1:         setProperties(propertyValues, instance, instance.getClass());
1:     }
1: 
1:     public Class getType() {
1:         if (type instanceof Class) {
1:             return (Class) type;
1:         } else if (type instanceof String) {
1:             return loadClass((String) type);
1:         } else {
1:             return null;
1:         }
1:     }
1: 
1:     private void setProperties(Map<String, Object> propertyValues, Object instance, Class clazz) {
1:         // set remaining properties
1:         for (Map.Entry<String, Object> entry : propertyValues.entrySet()) {
1:             String propertyName = entry.getKey();
1:             Object propertyValue = entry.getValue();
1: 
1:             setProperty(instance, clazz, propertyName, propertyValue);
1:         }
1: 
1:     }
1: 
1:     private void setProperty(Object instance, Class clazz, String propertyName, Object propertyValue) {
1:         String[] names = propertyName.split("\\.");
1:         for (int i = 0; i < names.length - 1; i++) {
1:             PropertyDescriptor pd = getPropertyDescriptor(clazz, names[i]);
1:             if (pd.allowsGet()) {
1:                 try {
1:                     instance = pd.get(instance, blueprintContainer);
1:                 } catch (Exception e) {
1:                     throw new ComponentDefinitionException("Error getting property: " + names[i] + " on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName(), getRealCause(e));
1:                 }
1:                 if (instance == null) {
1:                     throw new ComponentDefinitionException("Error setting compound property " + propertyName + " on bean " + getName() + ". Property " + names[i] + " is null");
1:                 }
1:                 clazz = instance.getClass();
1:             } else {
1:                 throw new ComponentDefinitionException("No getter for " + names[i] + " property on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName());
1:             }
1:         }
1: 
1:         // Instantiate value
1:         if (propertyValue instanceof Recipe) {
1:             propertyValue = ((Recipe) propertyValue).create();
1:         }
1: 
1:         final PropertyDescriptor pd = getPropertyDescriptor(clazz, names[names.length - 1]);
1:         if (pd.allowsSet()) {
1:             try {
1:                 pd.set(instance, propertyValue, blueprintContainer);
1:             } catch (Exception e) {
1:                 throw new ComponentDefinitionException("Error setting property: " + pd, getRealCause(e));
1:             }
1:         } else {
1:             throw new ComponentDefinitionException("No setter for " + names[names.length - 1] + " property");
1:         }
1:     }
1: 
1:     private ReflectionUtils.PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String name) {
1:         for (ReflectionUtils.PropertyDescriptor pd : ReflectionUtils.getPropertyDescriptors(clazz, allowsFieldInjection)) {
1:             if (pd.getName().equals(name)) {
1:                 return pd;
1:             }
1:         }
1:         throw new ComponentDefinitionException("Unable to find property descriptor " + name + " on class " + clazz.getName());
1:     }
1: 
1:     private Object invoke(Method method, Object instance, Object... args) throws Exception {
1:         return ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), method, instance, args);
1:     }
1: 
1:     private Object newInstance(Constructor constructor, Object... args) throws Exception {
1:         return ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), constructor, args);
1:     }
1: 
1:     private static Object UNMATCHED = new Object();
1: 
1:     private class ArgumentMatcher {
1: 
1:         private final List<TypeEntry> entries;
1:         private final boolean convert;
1: 
1:         public ArgumentMatcher(Type[] types, boolean convert) {
1:             entries = new ArrayList<TypeEntry>();
1:             for (Type type : types) {
1:                 entries.add(new TypeEntry(new GenericType(type)));
1:             }
1:             this.convert = convert;
1:         }
1: 
1:         public List<Object> match(List<Object> arguments, List<ReifiedType> forcedTypes) {
1:             if (find(arguments, forcedTypes)) {
1:                 return getArguments();
1:             }
1:             return null;
1:         }
1: 
1:         private List<Object> getArguments() {
1:             List<Object> list = new ArrayList<Object>();
1:             for (TypeEntry entry : entries) {
1:                 if (entry.argument == UNMATCHED) {
1:                     throw new RuntimeException("There are unmatched types");
1:                 } else {
1:                     list.add(entry.argument);
1:                 }
1:             }
1:             return list;
1:         }
1: 
1:         private boolean find(List<Object> arguments, List<ReifiedType> forcedTypes) {
1:             if (entries.size() == arguments.size()) {
1:                 boolean matched = true;
1:                 for (int i = 0; i < arguments.size() && matched; i++) {
1:                     matched = find(arguments.get(i), forcedTypes.get(i));
1:                 }
1:                 return matched;
1:             }
1:             return false;
1:         }
1: 
1:         private boolean find(Object arg, ReifiedType forcedType) {
1:             for (TypeEntry entry : entries) {
1:                 Object val = arg;
1:                 if (entry.argument != UNMATCHED) {
1:                     continue;
1:                 }
1:                 if (forcedType != null) {
1:                     if (!forcedType.equals(entry.type)) {
1:                         continue;
1:                     }
1:                 } else if (arg != null) {
1:                     if (convert) {
1: 
1:                         if(canConvert(arg, entry.type)) {
1:                             try {
1:                                 val = convert(arg, entry.type);
1:                             } catch (Exception e) {
1:                                 throw new ComponentDefinitionException(e);
1:                             }
1:                         } else {
1:                             continue;
1:                         }
1:                     } else {
1:                         UnwrapperedBeanHolder holder = null;
1:                         if(arg instanceof UnwrapperedBeanHolder) {
1:                             holder = (UnwrapperedBeanHolder)arg;
1:                             arg = holder.unwrapperedBean;
1:                         }
1:                         if (!AggregateConverter.isAssignable(arg, entry.type)) {
1:                             continue;
1:                         } else if (holder != null) {
1:                             val = wrap(holder, entry.type.getRawClass());
1:                         }
1:                     }
1:                 }
1:                 entry.argument = val;
1:                 return true;
1:             }
1:             return false;
1:         }
1: 
1:     }
1: 
1:     private static class TypeEntry {
1: 
1:         private final ReifiedType type;
1:         private Object argument;
1: 
1:         public TypeEntry(ReifiedType type) {
1:             this.type = type;
1:             this.argument = UNMATCHED;
1:         }
1: 
1:     }
1: 
1: }
============================================================================