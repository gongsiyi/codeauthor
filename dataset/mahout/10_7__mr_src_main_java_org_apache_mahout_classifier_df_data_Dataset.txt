1:8c37a84: /**
1:8c37a84:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:8c37a84:  * contributor license agreements.  See the NOTICE file distributed with
1:8c37a84:  * this work for additional information regarding copyright ownership.
1:8c37a84:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:8c37a84:  * (the "License"); you may not use this file except in compliance with
1:8c37a84:  * the License.  You may obtain a copy of the License at
7:8c37a84:  *
1:8c37a84:  *     http://www.apache.org/licenses/LICENSE-2.0
1:8c37a84:  *
1:8c37a84:  * Unless required by applicable law or agreed to in writing, software
1:8c37a84:  * distributed under the License is distributed on an "AS IS" BASIS,
1:8c37a84:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8c37a84:  * See the License for the specific language governing permissions and
1:8c37a84:  * limitations under the License.
1:8c37a84:  */
1:8547de7: 
1:52ce412: package org.apache.mahout.classifier.df.data;
1:6b7f601: 
1:69ba194: import com.google.common.base.Preconditions;
1:d608a88: import com.google.common.io.Closeables;
1:67a531e: import org.apache.commons.lang3.ArrayUtils;
1:8c37a84: import org.apache.hadoop.conf.Configuration;
1:8c37a84: import org.apache.hadoop.fs.FSDataInputStream;
1:8c37a84: import org.apache.hadoop.fs.FileSystem;
1:8c37a84: import org.apache.hadoop.fs.Path;
1:6b7f601: import org.codehaus.jackson.map.ObjectMapper;
1:6b7f601: import org.codehaus.jackson.type.TypeReference;
1:d6aba1a: 
1:d6aba1a: import java.io.IOException;
1:6b7f601: import java.nio.charset.Charset;
1:d6aba1a: import java.util.Arrays;
1:85f9ece: import java.util.HashMap;
1:85f9ece: import java.util.LinkedList;
1:d6aba1a: import java.util.List;
1:6b7f601: import java.util.Locale;
1:6b7f601: import java.util.Map;
1:d6aba1a: 
1:8c37a84: /**
1:cd167f9:  * Contains information about the attributes.
1:8c37a84:  */
1:1ffa3a4: @Deprecated
1:6b7f601: public class Dataset {
1:d6aba1a: 
1:8c37a84:   /**
1:8c37a84:    * Attributes type
1:8c37a84:    */
1:8c37a84:   public enum Attribute {
1:ad11134:     IGNORED,
1:ad11134:     NUMERICAL,
1:ad11134:     CATEGORICAL,
1:ad11134:     LABEL;
1:d6aba1a: 
1:8c37a84:     public boolean isNumerical() {
1:8c37a84:       return this == NUMERICAL;
15:8c37a84:     }
1:6b7f601: 
1:8c37a84:     public boolean isCategorical() {
1:8c37a84:       return this == CATEGORICAL;
1:7f0d774:     }
1:6b7f601: 
1:8c37a84:     public boolean isLabel() {
1:8c37a84:       return this == LABEL;
1:8c37a84:     }
1:d6aba1a: 
1:8c37a84:     public boolean isIgnored() {
1:8c37a84:       return this == IGNORED;
1:8c37a84:     }
1:6b7f601:     
1:6b7f601:     private static Attribute fromString(String from) {
1:6b7f601:       Attribute toReturn = LABEL;
1:58cc1ae:       if (NUMERICAL.toString().equalsIgnoreCase(from)) {
1:6b7f601:         toReturn = NUMERICAL;
1:6b7f601:       } else if (CATEGORICAL.toString().equalsIgnoreCase(from)) {
1:6b7f601:         toReturn = CATEGORICAL;
1:6b7f601:       } else if (IGNORED.toString().equalsIgnoreCase(from)) {
1:6b7f601:         toReturn = IGNORED;
1:6b7f601:       }
1:6b7f601:       return toReturn;
1:6b7f601:     }
1:8c37a84:   }
1:d6aba1a: 
1:8c37a84:   private Attribute[] attributes;
1:d6aba1a: 
1:d6aba1a:   /**
1:d6aba1a:    * list of ignored attributes
1:d6aba1a:    */
1:8c37a84:   private int[] ignored;
1:d6aba1a: 
1:d6aba1a:   /**
1:d6aba1a:    * distinct values (CATEGORIAL attributes only)
1:d6aba1a:    */
1:8c37a84:   private String[][] values;
1:d6aba1a: 
1:d6aba1a:   /**
1:d6aba1a:    * index of the label attribute in the loaded data (without ignored attributed)
1:d6aba1a:    */
1:8c37a84:   private int labelId;
1:d6aba1a: 
1:d6aba1a:   /**
1:d6aba1a:    * number of instances in the dataset
1:d6aba1a:    */
1:8c37a84:   private int nbInstances;
1:6b7f601:   
1:6b7f601:   /** JSON serial/de-serial-izer */
1:58cc1ae:   private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
1:d6aba1a: 
1:6b7f601:   // Some literals for JSON representation
1:58cc1ae:   static final String TYPE = "type";
1:58cc1ae:   static final String VALUES = "values";
1:58cc1ae:   static final String LABEL = "label";
1:6b7f601: 
1:58cc1ae:   protected Dataset() {}
1:d6aba1a: 
1:8c37a84:   /**
1:8c37a84:    * Should only be called by a DataLoader
1:e9cc323:    *
1:d6aba1a:    * @param attrs  attributes description
1:d6aba1a:    * @param values distinct values for all CATEGORICAL attributes
1:8c37a84:    */
1:e9cc323:   Dataset(Attribute[] attrs, List<String>[] values, int nbInstances, boolean regression) {
1:8c37a84:     validateValues(attrs, values);
1:d6aba1a: 
1:8c37a84:     int nbattrs = countAttributes(attrs);
1:d6aba1a: 
1:8c37a84:     // the label values are set apart
1:8c37a84:     attributes = new Attribute[nbattrs];
1:8c37a84:     this.values = new String[nbattrs][];
1:e107bfa:     ignored = new int[attrs.length - nbattrs]; // nbignored = total - nbattrs
1:8547de7: 
1:8c37a84:     labelId = -1;
1:8c37a84:     int ignoredId = 0;
1:8547de7:     int ind = 0;
2:8c37a84:     for (int attr = 0; attr < attrs.length; attr++) {
1:8c37a84:       if (attrs[attr].isIgnored()) {
1:8c37a84:         ignored[ignoredId++] = attr;
2:8c37a84:         continue;
1:d6aba1a:       }
1:d6aba1a: 
1:8c37a84:       if (attrs[attr].isLabel()) {
1:8c37a84:         if (labelId != -1) {
1:acafdc0:           throw new IllegalStateException("Label found more than once");
1:8c37a84:         }
1:e107bfa:         labelId = ind;
1:e9cc323:         if (regression) {
1:e9cc323:           attrs[attr] = Attribute.NUMERICAL;
1:e9cc323:         } else {
1:e9cc323:           attrs[attr] = Attribute.CATEGORICAL;
1:e9cc323:         }
1:8c37a84:       }
1:d6aba1a: 
1:e107bfa:       if (attrs[attr].isCategorical() || (!regression && attrs[attr].isLabel())) {
1:8c37a84:         this.values[ind] = new String[values[attr].size()];
1:8c37a84:         values[attr].toArray(this.values[ind]);
1:8c37a84:       }
1:d6aba1a: 
1:8c37a84:       attributes[ind++] = attrs[attr];
1:8c37a84:     }
1:d6aba1a: 
1:8c37a84:     if (labelId == -1) {
1:acafdc0:       throw new IllegalStateException("Label not found");
1:8c37a84:     }
1:d6aba1a: 
1:8c37a84:     this.nbInstances = nbInstances;
1:8c37a84:   }
1:d6aba1a: 
1:e9cc323:   public int nbValues(int attr) {
1:e9cc323:     return values[attr].length;
1:e9cc323:   }
1:d6aba1a: 
1:2563b6e:   public String[] labels() {
1:e107bfa:     return Arrays.copyOf(values[labelId], nblabels());
1:2563b6e:   }
1:d6aba1a: 
1:8c37a84:   public int nblabels() {
1:e107bfa:     return values[labelId].length;
1:8c37a84:   }
1:d6aba1a: 
1:8c37a84:   public int getLabelId() {
1:8c37a84:     return labelId;
1:e107bfa:   }
1:d6aba1a: 
1:e9cc323:   public double getLabel(Instance instance) {
1:d6aba1a:     return instance.get(getLabelId());
1:8c37a84:   }
1:6b7f601:   
1:6b7f601:   public Attribute getAttribute(int attr) {
1:58cc1ae:     return attributes[attr];
1:8c37a84:   }
1:d6aba1a: 
1:8c37a84:   /**
1:8c37a84:    * Returns the code used to represent the label value in the data
1:d6aba1a:    *
1:d6aba1a:    * @param label label's value to code
1:8c37a84:    * @return label's code
1:8c37a84:    */
1:8c37a84:   public int labelCode(String label) {
1:e107bfa:     return ArrayUtils.indexOf(values[labelId], label);
1:8c37a84:   }
1:d6aba1a: 
1:e9cc323:   /**
1:e9cc323:    * Returns the label value in the data
1:e9cc323:    * This method can be used when the criterion variable is the categorical attribute.
1:d6aba1a:    *
1:d6aba1a:    * @param code label's code
1:e9cc323:    * @return label's value
1:e9cc323:    */
1:e9cc323:   public String getLabelString(double code) {
1:1608f61:     // handle the case (prediction is NaN)
1:1608f61:     if (Double.isNaN(code)) {
1:d6aba1a:       return "unknown";
1:d6aba1a:     }
1:e9cc323:     return values[labelId][(int) code];
1:e107bfa:   }
1:6b7f601:   
1:335a993:   @Override
1:6b7f601:   public String toString() {
1:58cc1ae:     return "attributes=" + Arrays.toString(attributes);
1:6b7f601:   }
1:d6aba1a: 
1:8c37a84:   /**
1:6b7f601:    * Converts a token to its corresponding integer code for a given attribute
1:d6aba1a:    *
1:6b7f601:    * @param attr attribute index
1:8c37a84:    */
1:8c37a84:   public int valueOf(int attr, String token) {
1:69ba194:     Preconditions.checkArgument(!isNumerical(attr), "Only for CATEGORICAL attributes");
1:cd167f9:     Preconditions.checkArgument(values != null, "Values not found (equals null)");
1:8c37a84:     return ArrayUtils.indexOf(values[attr], token);
1:8c37a84:   }
1:d6aba1a: 
1:8c37a84:   public int[] getIgnored() {
1:8c37a84:     return ignored;
1:8c37a84:   }
1:d6aba1a: 
1:8c37a84:   /**
1:e107bfa:    * @return number of attributes that are not IGNORED
1:8c37a84:    */
1:e9cc323:   private static int countAttributes(Attribute[] attrs) {
1:8c37a84:     int nbattrs = 0;
1:e107bfa:     for (Attribute attr : attrs) {
1:e107bfa:       if (!attr.isIgnored()) {
1:8c37a84:         nbattrs++;
1:8c37a84:       }
1:8c37a84:     }
1:8c37a84:     return nbattrs;
1:8c37a84:   }
1:d6aba1a: 
1:8547de7:   private static void validateValues(Attribute[] attrs, List<String>[] values) {
1:d6aba1a:     Preconditions.checkArgument(attrs.length == values.length, "attrs.length != values.length");
1:8c37a84:     for (int attr = 0; attr < attrs.length; attr++) {
1:69ba194:       Preconditions.checkArgument(!attrs[attr].isCategorical() || values[attr] != null,
1:69ba194:           "values not found for attribute " + attr);
1:7f0d774:     }
1:7f0d774:   }
1:d6aba1a: 
1:8c37a84:   /**
1:515bac4:    * @return number of attributes
1:8c37a84:    */
1:8c37a84:   public int nbAttributes() {
1:8c37a84:     return attributes.length;
1:8c37a84:   }
1:d6aba1a: 
1:8c37a84:   /**
1:8c37a84:    * Is this a numerical attribute ?
1:d6aba1a:    *
1:d6aba1a:    * @param attr index of the attribute to check
1:8c37a84:    * @return true if the attribute is numerical
1:8c37a84:    */
1:8c37a84:   public boolean isNumerical(int attr) {
1:8c37a84:     return attributes[attr].isNumerical();
1:8c37a84:   }
1:d6aba1a: 
1:8547de7:   @Override
1:8c37a84:   public boolean equals(Object obj) {
1:ad11134:     if (this == obj) {
1:8c37a84:       return true;
1:8c37a84:     }
1:4194a28:     if (!(obj instanceof Dataset)) {
2:8c37a84:       return false;
1:8c37a84:     }
1:d6aba1a: 
1:8c37a84:     Dataset dataset = (Dataset) obj;
1:d6aba1a: 
1:8c37a84:     if (!Arrays.equals(attributes, dataset.attributes)) {
1:8c37a84:       return false;
1:8c37a84:     }
1:d6aba1a: 
1:8c37a84:     for (int attr = 0; attr < nbAttributes(); attr++) {
1:8c37a84:       if (!Arrays.equals(values[attr], dataset.values[attr])) {
1:8c37a84:         return false;
1:8c37a84:       }
1:8c37a84:     }
1:d6aba1a: 
1:39fe224:     return labelId == dataset.labelId && nbInstances == dataset.nbInstances;
1:8547de7:   }
1:d6aba1a: 
1:8547de7:   @Override
1:8547de7:   public int hashCode() {
1:8547de7:     int hashCode = labelId + 31 * nbInstances;
1:8547de7:     for (Attribute attr : attributes) {
1:8547de7:       hashCode = 31 * hashCode + attr.hashCode();
1:8547de7:     }
1:8547de7:     for (String[] valueRow : values) {
1:e0ec7c1:       if (valueRow == null) {
1:e0ec7c1:         continue;
1:e0ec7c1:       }
1:8547de7:       for (String value : valueRow) {
1:8547de7:         hashCode = 31 * hashCode + value.hashCode();
1:8547de7:       }
1:8547de7:     }
1:8547de7:     return hashCode;
1:8547de7:   }
1:8547de7: 
1:8c37a84:   /**
1:8c37a84:    * Loads the dataset from a file
1:d6aba1a:    *
1:e9cc323:    * @throws java.io.IOException
1:8c37a84:    */
1:8c37a84:   public static Dataset load(Configuration conf, Path path) throws IOException {
1:8c37a84:     FileSystem fs = path.getFileSystem(conf);
1:6b7f601:     long bytesToRead = fs.getFileStatus(path).getLen();
1:58cc1ae:     byte[] buff = new byte[Long.valueOf(bytesToRead).intValue()];
1:8c37a84:     FSDataInputStream input = fs.open(path);
1:d608a88:     try {
1:6b7f601:       input.readFully(buff);
1:d608a88:     } finally {
1:31cb292:       Closeables.close(input, true);
1:d608a88:     }
1:6b7f601:     String json = new String(buff, Charset.defaultCharset());
1:6b7f601:     return fromJSON(json);
1:6b7f601:   }
1:6b7f601:   
1:6b7f601: 
1:6b7f601:   /**
1:6b7f601:    * Serialize this instance to JSON
1:6b7f601:    * @return some JSON
1:6b7f601:    */
1:6b7f601:   public String toJSON() {
1:85f9ece:     List<Map<String, Object>> toWrite = new LinkedList<>();
1:6b7f601:     // attributes does not include ignored columns and it does include the class label
1:6b7f601:     int ignoredCount = 0;
1:6b7f601:     for (int i = 0; i < attributes.length + ignored.length; i++) {
1:44cc7b3:       Map<String, Object> attribute;
1:6b7f601:       int attributesIndex = i - ignoredCount;
1:6b7f601:       if (ignoredCount < ignored.length && i == ignored[ignoredCount]) {
1:6b7f601:         // fill in ignored atttribute
1:6b7f601:         attribute = getMap(Attribute.IGNORED, null, false);
1:6b7f601:         ignoredCount++;
1:6b7f601:       } else if (attributesIndex == labelId) {
1:6b7f601:         // fill in the label
1:6b7f601:         attribute = getMap(attributes[attributesIndex], values[attributesIndex], true);
1:6b7f601:       } else  {
1:6b7f601:         // normal attribute
1:6b7f601:         attribute = getMap(attributes[attributesIndex], values[attributesIndex], false);
1:6b7f601:       }
1:6b7f601:       toWrite.add(attribute);
1:6b7f601:     }
1:6b7f601:     try {
1:58cc1ae:       return OBJECT_MAPPER.writeValueAsString(toWrite);
1:6b7f601:     } catch (Exception ex) {
1:6b7f601:       throw new RuntimeException(ex);
1:6b7f601:     }
1:8c37a84:   }
6:d6aba1a: 
1:6b7f601:   /**
1:6b7f601:    * De-serialize an instance from a string
1:6b7f601:    * @param json From which an instance is created
1:44cc7b3:    * @return A shiny new Dataset
1:6b7f601:    */
1:6b7f601:   public static Dataset fromJSON(String json) {
1:6b7f601:     List<Map<String, Object>> fromJSON;
1:6b7f601:     try {
1:58cc1ae:       fromJSON = OBJECT_MAPPER.readValue(json, new TypeReference<List<Map<String, Object>>>() {});
1:6b7f601:     } catch (Exception ex) {
1:6b7f601:       throw new RuntimeException(ex);
1:6b7f601:     }
1:85f9ece:     List<Attribute> attributes = new LinkedList<>();
1:85f9ece:     List<Integer> ignored = new LinkedList<>();
1:6b7f601:     String[][] nominalValues = new String[fromJSON.size()][];
1:335a993:     Dataset dataset = new Dataset();
1:6b7f601:     for (int i = 0; i < fromJSON.size(); i++) {
1:6b7f601:       Map<String, Object> attribute = fromJSON.get(i);
1:58cc1ae:       if (Attribute.fromString((String) attribute.get(TYPE)) == Attribute.IGNORED) {
1:6b7f601:         ignored.add(i);
1:6b7f601:       } else {
1:6b7f601:         Attribute asAttribute = Attribute.fromString((String) attribute.get(TYPE));
1:6b7f601:         attributes.add(asAttribute);
1:58cc1ae:         if ((Boolean) attribute.get(LABEL)) {
1:6b7f601:           dataset.labelId = i - ignored.size();
1:6b7f601:         }
1:58cc1ae:         if (attribute.get(VALUES) != null) {
1:335a993:           List<String> get = (List<String>) attribute.get(VALUES);
1:335a993:           String[] array = get.toArray(new String[get.size()]);
1:44cc7b3:           nominalValues[i - ignored.size()] = array;
1:6b7f601:         }
1:6b7f601:       }
1:6b7f601:     }
1:335a993:     dataset.attributes = attributes.toArray(new Attribute[attributes.size()]);
1:6b7f601:     dataset.ignored = new int[ignored.size()];
1:6b7f601:     dataset.values = nominalValues;
1:58cc1ae:     for (int i = 0; i < dataset.ignored.length; i++) {
1:6b7f601:       dataset.ignored[i] = ignored.get(i);
1:6b7f601:     }
2:8c37a84:     return dataset;
1:8c37a84:   }
1:6b7f601:   
1:6b7f601:   /**
1:6b7f601:    * Generate a map to describe an attribute
1:6b7f601:    * @param type The type
1:44cc7b3:    * @param values - values
1:44cc7b3:    * @param isLabel - is a label
1:44cc7b3:    * @return map of (AttributeTypes, Values)
1:6b7f601:    */
1:6b7f601:   private Map<String, Object> getMap(Attribute type, String[] values, boolean isLabel) {
1:85f9ece:     Map<String, Object> attribute = new HashMap<>();
1:6b7f601:     attribute.put(TYPE, type.toString().toLowerCase(Locale.getDefault()));
1:6b7f601:     attribute.put(VALUES, values);
1:6b7f601:     attribute.put(LABEL, isLabel);
1:6b7f601:     return attribute;
1:8c37a84:   }
1:8c37a84: }
============================================================================
author:smarthi
-------------------------------------------------------------------------------
commit:1ffa3a4
/////////////////////////////////////////////////////////////////////////
1: @Deprecated
commit:44cc7b3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       Map<String, Object> attribute;
/////////////////////////////////////////////////////////////////////////
1:    * @return A shiny new Dataset
/////////////////////////////////////////////////////////////////////////
1:           nominalValues[i - ignored.size()] = array;
/////////////////////////////////////////////////////////////////////////
1:    * @param values - values
1:    * @param isLabel - is a label
1:    * @return map of (AttributeTypes, Values)
commit:cd167f9
/////////////////////////////////////////////////////////////////////////
1:  * Contains information about the attributes.
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkArgument(values != null, "Values not found (equals null)");
commit:67a531e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.lang3.ArrayUtils;
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:85f9ece
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
1:     List<Map<String, Object>> toWrite = new LinkedList<>();
/////////////////////////////////////////////////////////////////////////
1:     List<Attribute> attributes = new LinkedList<>();
1:     List<Integer> ignored = new LinkedList<>();
/////////////////////////////////////////////////////////////////////////
1:     Map<String, Object> attribute = new HashMap<>();
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:335a993
/////////////////////////////////////////////////////////////////////////
1:   @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     Dataset dataset = new Dataset();
/////////////////////////////////////////////////////////////////////////
1:           List<String> get = (List<String>) attribute.get(VALUES);
1:           String[] array = get.toArray(new String[get.size()]);
1:     dataset.attributes = attributes.toArray(new Attribute[attributes.size()]);
commit:1608f61
/////////////////////////////////////////////////////////////////////////
1:     // handle the case (prediction is NaN)
1:     if (Double.isNaN(code)) {
commit:e0ec7c1
/////////////////////////////////////////////////////////////////////////
0:   	Preconditions.checkArgument(!regression, "Regression Problems not supported");
/////////////////////////////////////////////////////////////////////////
1:     	if (valueRow == null) {
1:         continue;
1:       }
commit:4194a28
/////////////////////////////////////////////////////////////////////////
1:     if (!(obj instanceof Dataset)) {
commit:39fe224
/////////////////////////////////////////////////////////////////////////
0:     if (obj == null || !(obj instanceof Dataset)) {
/////////////////////////////////////////////////////////////////////////
1:     return labelId == dataset.labelId && nbInstances == dataset.nbInstances;
commit:69ba194
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.base.Preconditions;
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkArgument(!isNumerical(attr), "Only for CATEGORICAL attributes");
0:     Preconditions.checkArgument(values != null, "Values not found");
/////////////////////////////////////////////////////////////////////////
0:     Preconditions.checkArgument(attrs.length == values.length,  "attrs.length != values.length");
1:       Preconditions.checkArgument(!attrs[attr].isCategorical() || values[attr] != null,
1:           "values not found for attribute " + attr);
commit:515bac4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:    * @return number of attributes
/////////////////////////////////////////////////////////////////////////
commit:f824f90
commit:210fac3
commit:7f0d774
/////////////////////////////////////////////////////////////////////////
0:     if (attrs.length != values.length) {
0:       throw new IllegalArgumentException("attrs.length != values.length");
1:     }
0:       if (attrs[attr].isCategorical()) {
0:         if (values[attr] == null) {
0:           throw new IllegalArgumentException("values not found for attribute N° "
0:               + attr);
1:         }
1:       }
commit:acafdc0
/////////////////////////////////////////////////////////////////////////
0:       throw new IllegalArgumentException("Only for CATEGORICAL attributes");
0:       throw new IllegalStateException("Values not found");
/////////////////////////////////////////////////////////////////////////
1:           throw new IllegalStateException("Label found more than once");
/////////////////////////////////////////////////////////////////////////
1:       throw new IllegalStateException("Label not found");
commit:8547de7
/////////////////////////////////////////////////////////////////////////
0:   private Dataset() {
/////////////////////////////////////////////////////////////////////////
1: 
1:     int ind = 0;
/////////////////////////////////////////////////////////////////////////
1: 
0:     for (Attribute attr1 : attrs) {
0:       if (attr1.isNumerical() || attr1.isCategorical())
1:   private static void validateValues(Attribute[] attrs, List<String>[] values) {
/////////////////////////////////////////////////////////////////////////
1:   public int hashCode() {
1:     int hashCode = labelId + 31 * nbInstances;
1:     for (Attribute attr : attributes) {
1:       hashCode = 31 * hashCode + attr.hashCode();
1:     }
0:     for (String label : labels) {
0:       hashCode = 31 * hashCode + label.hashCode();
1:     }
1:     for (String[] valueRow : values) {
1:       for (String value : valueRow) {
1:         hashCode = 31 * hashCode + value.hashCode();
1:       }
1:     }
1:     return hashCode;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:     Dataset dataset = read(input);
/////////////////////////////////////////////////////////////////////////
1:   @Override
/////////////////////////////////////////////////////////////////////////
1:   @Override
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:58cc1ae
/////////////////////////////////////////////////////////////////////////
1:       if (NUMERICAL.toString().equalsIgnoreCase(from)) {
/////////////////////////////////////////////////////////////////////////
1:   private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
1:   static final String TYPE = "type";
1:   static final String VALUES = "values";
1:   static final String LABEL = "label";
1:   protected Dataset() {}
/////////////////////////////////////////////////////////////////////////
1:     return attributes[attr];
/////////////////////////////////////////////////////////////////////////
1:     return "attributes=" + Arrays.toString(attributes);
/////////////////////////////////////////////////////////////////////////
1:     byte[] buff = new byte[Long.valueOf(bytesToRead).intValue()];
/////////////////////////////////////////////////////////////////////////
1:       return OBJECT_MAPPER.writeValueAsString(toWrite);
/////////////////////////////////////////////////////////////////////////
1:       fromJSON = OBJECT_MAPPER.readValue(json, new TypeReference<List<Map<String, Object>>>() {});
/////////////////////////////////////////////////////////////////////////
1:       if (Attribute.fromString((String) attribute.get(TYPE)) == Attribute.IGNORED) {
1:         if ((Boolean) attribute.get(LABEL)) {
1:         if (attribute.get(VALUES) != null) {
/////////////////////////////////////////////////////////////////////////
1:     for (int i = 0; i < dataset.ignored.length; i++) {
commit:6b7f601
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Lists;
0: import com.google.common.collect.Maps;
1: import org.codehaus.jackson.map.ObjectMapper;
1: import org.codehaus.jackson.type.TypeReference;
1: import java.nio.charset.Charset;
1: import java.util.Locale;
1: import java.util.Map;
1: public class Dataset {
/////////////////////////////////////////////////////////////////////////
1:     
1:     private static Attribute fromString(String from) {
1:       
1:       Attribute toReturn = LABEL;
0:       if(NUMERICAL.toString().equalsIgnoreCase(from)) {
1:         toReturn = NUMERICAL;
1:       } else if (CATEGORICAL.toString().equalsIgnoreCase(from)) {
1:         toReturn = CATEGORICAL;
1:       } else if (IGNORED.toString().equalsIgnoreCase(from)) {
1:         toReturn = IGNORED;
1:       }
1:       return toReturn;
1:     }
/////////////////////////////////////////////////////////////////////////
1:   
1:   /** JSON serial/de-serial-izer */
0:   private static final ObjectMapper objectMapper = new ObjectMapper();
1:   // Some literals for JSON representation
0:   final static String TYPE = "type";
0:   final static String VALUES = "values";
0:   final static String LABEL = "label";
1: 
0:   protected Dataset() {
/////////////////////////////////////////////////////////////////////////
1:   
1:   public Attribute getAttribute(int attr) {
0: 	  return attributes[attr];
/////////////////////////////////////////////////////////////////////////
1:   
1:   public String toString() {
0: 	  return "attributes="+Arrays.toString(attributes);
1:   }
1:    * Converts a token to its corresponding integer code for a given attribute
1:    * @param attr attribute index
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     long bytesToRead = fs.getFileStatus(path).getLen();
0:     byte[] buff = new byte[new Long(bytesToRead).intValue()];
1:       input.readFully(buff);
1:     String json = new String(buff, Charset.defaultCharset());
1:     return fromJSON(json);
1:   }
1:   
1: 
1:   /**
1:    * Serialize this instance to JSON
1:    * @return some JSON
1:    */
1:   public String toJSON() {
1: 
0:     List<Map<String, Object>> toWrite = Lists.newLinkedList();
1:     // attributes does not include ignored columns and it does include the class label
1:     int ignoredCount = 0;
1:     for (int i = 0; i < attributes.length + ignored.length; i++) {
0:       Map<String, Object> attribute = null;
1:       int attributesIndex = i - ignoredCount;
1:       if (ignoredCount < ignored.length && i == ignored[ignoredCount]) {
1:         // fill in ignored atttribute
1:         attribute = getMap(Attribute.IGNORED, null, false);
1:         ignoredCount++;
1:       } else if (attributesIndex == labelId) {
1:         // fill in the label
1:         attribute = getMap(attributes[attributesIndex], values[attributesIndex], true);
1:       } else  {
1:         // normal attribute
1:         attribute = getMap(attributes[attributesIndex], values[attributesIndex], false);
1:       }
1:       toWrite.add(attribute);
1:     }
1:     try {
0:       return objectMapper.writeValueAsString(toWrite);
1:     } catch (Exception ex) {
1:       throw new RuntimeException(ex);
1:     }
1:   /**
1:    * De-serialize an instance from a string
1:    * @param json From which an instance is created
0:    * @return A shinny new Dataset
1:    */
1:   public static Dataset fromJSON(String json) {
0:     Dataset dataset = new Dataset();
1:     List<Map<String, Object>> fromJSON;
1:     try {
0:        fromJSON = objectMapper.readValue(json, new TypeReference<List<Map<String, Object>>>() {});
1:     } catch (Exception ex) {
1:       throw new RuntimeException(ex);
1:     }
0:     List<Attribute> attributes = Lists.newLinkedList();
0:     List<Integer> ignored = Lists.newLinkedList();
1:     String[][] nominalValues = new String[fromJSON.size()][];
1:     for (int i = 0; i < fromJSON.size(); i++) {
1:       Map<String, Object> attribute = fromJSON.get(i);
0:       if(Attribute.fromString((String) attribute.get(TYPE)) == Attribute.IGNORED) {
1:         ignored.add(i);
1:       } else {
1:         Attribute asAttribute = Attribute.fromString((String) attribute.get(TYPE));
1:         attributes.add(asAttribute);
0:         if((Boolean) attribute.get(LABEL)) {
1:           dataset.labelId = i - ignored.size();
1:         }
0:         if(attribute.get(VALUES) != null) {
0:           List get = (List) attribute.get(VALUES);
0:           String[] array = (String[]) get.toArray(new String[]{});
0:           nominalValues[i] = array;
1:         }
1:       }
1:     }
0:     dataset.attributes = attributes.toArray(new Attribute[]{});
1:     dataset.ignored = new int[ignored.size()];
1:     dataset.values = nominalValues;
0:     for(int i = 0; i < dataset.ignored.length; i++) {
1:       dataset.ignored[i] = ignored.get(i);
1:     }
1:   
1:   /**
1:    * Generate a map to describe an attribute
1:    * @param type The type
0:    * @param values
0:    * @param isLabel
0:    * @return 
1:    */
1:   private Map<String, Object> getMap(Attribute type, String[] values, boolean isLabel) {
0:     Map<String, Object> attribute = Maps.newHashMap();
1:     attribute.put(TYPE, type.toString().toLowerCase(Locale.getDefault()));
1:     attribute.put(VALUES, values);
1:     attribute.put(LABEL, isLabel);
1:     return attribute;
commit:d608a88
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.io.Closeables;
/////////////////////////////////////////////////////////////////////////
1:     try {
0:       return read(input);
1:     } finally {
0:       Closeables.closeQuietly(input);
1:     }
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:31cb292
/////////////////////////////////////////////////////////////////////////
1:       Closeables.close(input, true);
commit:52ce412
/////////////////////////////////////////////////////////////////////////
1: package org.apache.mahout.classifier.df.data;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.classifier.df.DFUtils;
author:Abdel Hakim Deneche
-------------------------------------------------------------------------------
commit:d6aba1a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
0: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.util.Arrays;
1: import java.util.List;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1:   /**
1:    * list of ignored attributes
1:    */
1: 
1:   /**
1:    * distinct values (CATEGORIAL attributes only)
1:    */
1: 
1:   /**
1:    * index of the label attribute in the loaded data (without ignored attributed)
1:    */
1: 
1:   /**
1:    * number of instances in the dataset
1:    */
0:   private Dataset() {
1:   }
1:    * @param attrs  attributes description
1:    * @param values distinct values for all CATEGORICAL attributes
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1:     return instance.get(getLabelId());
1: 
1:    *
1:    * @param label label's value to code
1: 
1:    *
1:    * @param code label's code
0:     if (code == -1) {
1:       return "unknown";
1:     }
1: 
1:    *
0:    * @param attr attribute's index
1: 
1: 
1: 
1: 
1: 
1:     Preconditions.checkArgument(attrs.length == values.length, "attrs.length != values.length");
1: 
1: 
1:    *
1:    * @param attr index of the attribute to check
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:       if (valueRow == null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
commit:e9cc323
/////////////////////////////////////////////////////////////////////////
1:   Dataset(Attribute[] attrs, List<String>[] values, int nbInstances, boolean regression) {
/////////////////////////////////////////////////////////////////////////
1:         if (regression) {
1:           attrs[attr] = Attribute.NUMERICAL;
1:         } else {
1:           attrs[attr] = Attribute.CATEGORICAL;
1:         }
/////////////////////////////////////////////////////////////////////////
1:   public int nbValues(int attr) {
1:     return values[attr].length;
1:   }
0:   
/////////////////////////////////////////////////////////////////////////
1:   public double getLabel(Instance instance) {
0:   	return instance.get(getLabelId());
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Returns the label value in the data
1:    * This method can be used when the criterion variable is the categorical attribute.
1:    * 
0:    * @param code
0:    *          label's code
1:    * @return label's value
1:    */
1:   public String getLabelString(double code) {
1:     return values[labelId][(int) code];
/////////////////////////////////////////////////////////////////////////
1:   private static int countAttributes(Attribute[] attrs) {
/////////////////////////////////////////////////////////////////////////
0:       Preconditions.checkArgument(!attrs[attr].isCategorical() || values[attr] != null,
/////////////////////////////////////////////////////////////////////////
1:    * @throws java.io.IOException
/////////////////////////////////////////////////////////////////////////
0:     // only CATEGORICAL attributes have values
0:       if (attributes[attr].isCategorical()) {
commit:e107bfa
/////////////////////////////////////////////////////////////////////////
0:   /** index of the label attribute in the loaded data (without ignored attributed) */
/////////////////////////////////////////////////////////////////////////
0:   protected Dataset(Attribute[] attrs, List<String>[] values, int nbInstances, boolean regression) {
0:   	Preconditions.checkArgument(regression == false, "Regression Problems not supported");
/////////////////////////////////////////////////////////////////////////
1:     ignored = new int[attrs.length - nbattrs]; // nbignored = total - nbattrs
/////////////////////////////////////////////////////////////////////////
1:         labelId = ind;
1:       if (attrs[attr].isCategorical() || (!regression && attrs[attr].isLabel())) {
/////////////////////////////////////////////////////////////////////////
1:     return Arrays.copyOf(values[labelId], nblabels());
1:     return values[labelId].length;
0:   public int getLabel(Instance instance) {
0:   	return (int) instance.get(getLabelId());
1:   }
0: 
/////////////////////////////////////////////////////////////////////////
1:     return ArrayUtils.indexOf(values[labelId], label);
0:   public String getLabelString(int code) {
0:     // handle the case (prediction == -1)
0:   	if (code == -1) {
0:   		return "unknown";
1:   	}
0:     return values[labelId][code];
/////////////////////////////////////////////////////////////////////////
1:    * @return number of attributes that are not IGNORED
1:     for (Attribute attr : attrs) {
1:       if (!attr.isIgnored()) {
/////////////////////////////////////////////////////////////////////////
0:       Preconditions.checkArgument(!(attrs[attr].isCategorical() || attrs[attr].isLabel()) || values[attr] != null,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     	if (valueRow == null) continue;
/////////////////////////////////////////////////////////////////////////
0:     // only CATEGORICAL/LABEL attributes have values
0:       if (attributes[attr].isCategorical() || attributes[attr].isLabel()) {
/////////////////////////////////////////////////////////////////////////
commit:2563b6e
/////////////////////////////////////////////////////////////////////////
0: 
1:   public String[] labels() {
0:     return Arrays.copyOf(labels, labels.length);
1:   }
0: 
commit:8c37a84
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
0: package org.apache.mahout.df.data;
0: 
0: import java.io.DataInput;
0: import java.io.DataOutput;
0: import java.io.IOException;
0: import java.util.Arrays;
0: import java.util.List;
0: 
0: import org.apache.commons.lang.ArrayUtils;
1: import org.apache.hadoop.conf.Configuration;
1: import org.apache.hadoop.fs.FSDataInputStream;
1: import org.apache.hadoop.fs.FileSystem;
1: import org.apache.hadoop.fs.Path;
0: import org.apache.hadoop.io.Writable;
0: import org.apache.hadoop.io.WritableUtils;
0: import org.apache.mahout.df.DFUtils;
0: 
1: /**
0:  * Contains informations about the attributes.
1:  * 
1:  */
0: public class Dataset implements Writable {
0: 
1:   /**
1:    * Attributes type
1:    */
1:   public enum Attribute {
0:     IGNORED, NUMERICAL, CATEGORICAL, LABEL;
0: 
1:     public boolean isNumerical() {
1:       return this == NUMERICAL;
1:     }
0: 
1:     public boolean isCategorical() {
1:       return this == CATEGORICAL;
1:     }
0: 
1:     public boolean isLabel() {
1:       return this == LABEL;
1:     }
0: 
1:     public boolean isIgnored() {
1:       return this == IGNORED; 
1:     }
1:   }
0: 
1:   private Attribute[] attributes;
0: 
0:   /** all distinct labels */
0:   private String[] labels;
0: 
0:   /** list of ignored attributes */
1:   private int[] ignored;
0:   
0:   /** distinct values (CATEGORIAL attributes only) */
1:   private String[][] values;
0: 
0:   /** index of the label attribute in the original data */
1:   private int labelId;
0:   
0:   /** number of instances in the dataset */
1:   private int nbInstances;
0:   
1:   public int nblabels() {
0:     return labels.length;
1:   }
0: 
1:   public int getLabelId() {
1:     return labelId;
1:   }
0:   
0:   public int nbInstances() {
0:     return nbInstances;
1:   }
0:   
1:   /**
1:    * Returns the code used to represent the label value in the data
1:    * 
0:    * @param label label's value to code
1:    * @return label's code
1:    */
1:   public int labelCode(String label) {
0:     return ArrayUtils.indexOf(labels, label);
1:   }
0: 
0:   public String getLabel(int code) {
0:     return labels[code];
1:   }
0:   
1:   /**
0:    * Converts a token to its corresponding int code for a given attribute
0:    * @param attr attribute's index
0:    * @param token
0:    * @return
1:    */
1:   public int valueOf(int attr, String token) {
0:     if (isNumerical(attr)) {
0:       throw new RuntimeException("Only for CATEGORICAL attributes");
1:     }
0:     if (values == null) {
0:       throw new RuntimeException("Values not found");
1:     }
0: 
1:     return ArrayUtils.indexOf(values[attr], token);
1:   }
0:   
1:   public int[] getIgnored() {
1:     return ignored;
1:   }
0: 
0:   protected Dataset() {
1:   }
0: 
1:   /**
1:    * Should only be called by a DataLoader
1:    * 
0:    * @param attrs attributes description
0:    * @param values distinct values for all CATEGORICAL attributes
0:    * @param nbInstances
1:    */
0:   protected Dataset(Attribute[] attrs, List<String>[] values, int nbInstances) {
1:     validateValues(attrs, values);
0: 
1:     int nbattrs = countAttributes(attrs);
0:     
1:     // the label values are set apart
1:     attributes = new Attribute[nbattrs];
1:     this.values = new String[nbattrs][];
0:     ignored = new int[attrs.length - (nbattrs + 1)]; // nbignored = total - (nbattrs + label)
0:     
0:     int ind = 0;
1:     labelId = -1;
1:     int ignoredId = 0;
1:     for (int attr = 0; attr < attrs.length; attr++) {
1:       if (attrs[attr].isIgnored()) {
1:         ignored[ignoredId++] = attr;
1:         continue;
1:       }
0:       
1:       if (attrs[attr].isLabel()) {
1:         if (labelId != -1) {
0:           throw new RuntimeException("Label found more than once");
1:         }
0:         labelId = attr;
1:         continue;
1:       }
0:       
0:       if (attrs[attr].isCategorical()) {
1:         this.values[ind] = new String[values[attr].size()];
1:         values[attr].toArray(this.values[ind]);
1:       }
0: 
1:       attributes[ind++] = attrs[attr];
1:     }
0:     
1:     if (labelId == -1) {
0:       throw new RuntimeException("Label not found");
1:     }
0: 
0:     labels = new String[values[labelId].size()];
0:     values[labelId].toArray(labels);
0:     
1:     this.nbInstances = nbInstances;
1:   }
0: 
1:   /**
0:    * Counts the number of attributes, except IGNORED and LABEL
1:    * 
0:    * @param attrs
0:    * @return number of attributes that are not IGNORED or LABEL
1:    */
0:   protected static int countAttributes(Attribute[] attrs) {
1:     int nbattrs = 0;
0:   
1:     for (int attr = 0; attr < attrs.length; attr++) {
0:       if (attrs[attr].isNumerical() || attrs[attr].isCategorical())
1:         nbattrs++;
1:     }
0:   
1:     return nbattrs;
1:   }
0: 
0:   protected static void validateValues(Attribute[] attrs, List<String>[] values) {
0:     assert attrs.length == values.length : "attrs.length != values.length";
0: 
1:     for (int attr = 0; attr < attrs.length; attr++) {
0:       if (attrs[attr].isCategorical())
0:         assert values[attr] != null : "values not found for attribute N° "
0:             + attr;
1:     }
1:   }
0: 
1:   /**
0:    * Number of attributes
1:    * 
0:    * @return
1:    */
1:   public int nbAttributes() {
1:     return attributes.length;
1:   }
0: 
1:   /**
1:    * Is this a numerical attribute ?
1:    * 
0:    * @param attr index of the attribute to check
1:    * @return true if the attribute is numerical
1:    */
1:   public boolean isNumerical(int attr) {
1:     return attributes[attr].isNumerical();
1:   }
0: 
0:   @Override
1:   public boolean equals(Object obj) {
0:     if (this == obj)
1:       return true;
0:     if (obj == null || !(obj instanceof Dataset))
1:       return false;
0: 
1:     Dataset dataset = (Dataset) obj;
0:     
1:     if (!Arrays.equals(attributes, dataset.attributes)) {
1:       return false;
1:     }
0:     
0:     if (!Arrays.equals(labels, dataset.labels)) {
1:       return false;
1:     }
0: 
1:     for (int attr = 0; attr < nbAttributes(); attr++) {
1:       if (!Arrays.equals(values[attr], dataset.values[attr])) {
1:         return false;
1:       }
1:     }
0: 
0:     return labelId == dataset.labelId && nbInstances == dataset.nbInstances;
1:   }
0: 
1:   /**
1:    * Loads the dataset from a file
0:    * @param fs
0:    * @param path
0:    * @return
0:    * @throws IOException
1:    */
1:   public static Dataset load(Configuration conf, Path path) throws IOException {
1:     FileSystem fs = path.getFileSystem(conf);
0:     
1:     FSDataInputStream input = fs.open(path);
0: 
0:     Dataset dataset = Dataset.read(input);
0:     input.close();
0: 
1:     return dataset;
1:   }
0:   
0:   public static Dataset read(DataInput in) throws IOException {
0:     Dataset dataset = new Dataset();
0:     
0:     dataset.readFields(in);
1:     return dataset;
1:   }
0:   
0:   public void readFields(DataInput in) throws IOException {
0:     int nbAttributes = in.readInt();
0:     attributes = new Attribute[nbAttributes];
0:     for (int attr = 0; attr < nbAttributes; attr++) {
0:       String name = WritableUtils.readString(in);
0:       attributes[attr] = Attribute.valueOf(name);
1:     }
0:     
0:     labels = WritableUtils.readStringArray(in);
0:     
0:     ignored = DFUtils.readIntArray(in);
0:     
0:     // only CATEGORICAL attributes have values
0:     values = new String[nbAttributes][];
0:     for (int attr = 0; attr < nbAttributes; attr++) {
0:       if (attributes[attr].isCategorical()) {
0:         values[attr] = WritableUtils.readStringArray(in);
1:       }
1:     }
0:     
0:     labelId = in.readInt();
0:     nbInstances = in.readInt();
1:   }
0: 
0:   public void write(DataOutput out) throws IOException {
0:     out.writeInt(attributes.length); // nb attributes
0:     for (Attribute attr:attributes) {
0:       WritableUtils.writeString(out, attr.name());
1:     }
0:     
0:     WritableUtils.writeStringArray(out, labels);
0:     
0:     DFUtils.writeArray(out, ignored);
0:     
0:     // only CATEGORICAL attributes have values
0:     for (String[] vals : values) {
0:       if (vals != null) {
0:         WritableUtils.writeStringArray(out, vals);
1:       }
1:     }
0:     
0:     out.writeInt(labelId);
0:     out.writeInt(nbInstances);
1:   }
0: 
1: }
author:Ted Dunning
-------------------------------------------------------------------------------
commit:bf7cb96
/////////////////////////////////////////////////////////////////////////
0:     // TODO should handle the case (prediction == -1)
author:Robin Anil
-------------------------------------------------------------------------------
commit:297bef5
/////////////////////////////////////////////////////////////////////////
0:   private Dataset() { }
commit:ad11134
/////////////////////////////////////////////////////////////////////////
0:   
1:     IGNORED,
1:     NUMERICAL,
1:     CATEGORICAL,
1:     LABEL;
0:     
0:     
0:     
0:     
0:       return this == IGNORED;
0:   
0:   
0:   
0:   
0:   
0:   
0:   
/////////////////////////////////////////////////////////////////////////
0:    * @param label
0:    *          label's value to code
0:   
0:    * 
0:    * @param attr
0:    *          attribute's index
/////////////////////////////////////////////////////////////////////////
0:     
0:   
0:   private Dataset() {}
0:   
0:    * @param attrs
0:    *          attributes description
0:    * @param values
0:    *          distinct values for all CATEGORICAL attributes
0:     Dataset.validateValues(attrs, values);
0:     
0:     int nbattrs = Dataset.countAttributes(attrs);
0:     
/////////////////////////////////////////////////////////////////////////
0:       
0:     
0:   
/////////////////////////////////////////////////////////////////////////
0:     
0:       if (attr1.isNumerical() || attr1.isCategorical()) {
0:       }
0:     
0:   
0:     
0:           throw new IllegalArgumentException("values not found for attribute N° " + attr);
0:   
/////////////////////////////////////////////////////////////////////////
0:   
0:    * @param attr
0:    *          index of the attribute to check
0:   
1:     if (this == obj) {
0:     }
0:     if ((obj == null) || !(obj instanceof Dataset)) {
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     
0:     return (labelId == dataset.labelId) && (nbInstances == dataset.nbInstances);
0:   
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   
0:    * 
0:     
0:     Dataset dataset = Dataset.read(input);
0:     
/////////////////////////////////////////////////////////////////////////
0:   
0:     for (Attribute attr : attributes) {
/////////////////////////////////////////////////////////////////////////
0:   
============================================================================