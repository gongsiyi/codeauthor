1:27d33a2: /**
1:27d33a2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:27d33a2:  * contributor license agreements.  See the NOTICE file distributed with
1:27d33a2:  * this work for additional information regarding copyright ownership.
1:27d33a2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:27d33a2:  * (the "License"); you may not use this file except in compliance with
1:27d33a2:  * the License.  You may obtain a copy of the License at
2:27d33a2:  *
1:27d33a2:  *     http://www.apache.org/licenses/LICENSE-2.0
1:27d33a2:  *
1:27d33a2:  * Unless required by applicable law or agreed to in writing, software
1:27d33a2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:27d33a2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:27d33a2:  * See the License for the specific language governing permissions and
1:27d33a2:  * limitations under the License.
1:27d33a2:  */
1:27d33a2: 
1:27d33a2: package org.apache.mahout.classifier.sequencelearning.hmm;
1:27d33a2: 
1:27d33a2: import java.util.Random;
1:27d33a2: 
1:27d33a2: import org.apache.mahout.common.RandomUtils;
1:27d33a2: import org.apache.mahout.math.Matrix;
1:27d33a2: import org.apache.mahout.math.Vector;
1:27d33a2: 
1:27d33a2: /**
1:27d33a2:  * The HMMEvaluator class offers several methods to evaluate an HMM Model. The
1:27d33a2:  * following use-cases are covered: 1) Generate a sequence of output states from
1:27d33a2:  * a given model (prediction). 2) Compute the likelihood that a given model
1:27d33a2:  * generated a given sequence of output states (model likelihood). 3) Compute
1:27d33a2:  * the most likely hidden sequence for a given model and a given observed
1:27d33a2:  * sequence (decoding).
1:27d33a2:  */
1:27d33a2: public final class HmmEvaluator {
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * No constructor for utility classes.
1:27d33a2:    */
1:210b265:   private HmmEvaluator() {}
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Predict a sequence of steps output states for the given HMM model
1:27d33a2:    *
1:27d33a2:    * @param model The Hidden Markov model used to generate the output sequence
1:27d33a2:    * @param steps Size of the generated output sequence
1:27d33a2:    * @return integer array containing a sequence of steps output state IDs,
1:27d33a2:    *         generated by the specified model
1:27d33a2:    */
1:27d33a2:   public static int[] predict(HmmModel model, int steps) {
1:210b265:     return predict(model, steps, RandomUtils.getRandom());
1:d53cf4a:   }
1:27d33a2: 
1:27d33a2:   /**
1:210b265:    * Predict a sequence of steps output states for the given HMM model
1:210b265:    *
1:210b265:    * @param model The Hidden Markov model used to generate the output sequence
1:210b265:    * @param steps Size of the generated output sequence
1:210b265:    * @param seed  seed to use for the RNG
1:210b265:    * @return integer array containing a sequence of steps output state IDs,
1:210b265:    *         generated by the specified model
1:210b265:    */
1:210b265:   public static int[] predict(HmmModel model, int steps, long seed) {
1:210b265:     return predict(model, steps, RandomUtils.getRandom(seed));
1:210b265:   }
1:210b265:   /**
1:27d33a2:    * Predict a sequence of steps output states for the given HMM model using the
1:27d33a2:    * given seed for probabilistic experiments
1:27d33a2:    *
1:27d33a2:    * @param model The Hidden Markov model used to generate the output sequence
1:27d33a2:    * @param steps Size of the generated output sequence
1:210b265:    * @param rand  RNG to use
1:27d33a2:    * @return integer array containing a sequence of steps output state IDs,
1:27d33a2:    *         generated by the specified model
1:27d33a2:    */
1:210b265:   private static int[] predict(HmmModel model, int steps, Random rand) {
1:27d33a2:     // fetch the cumulative distributions
1:27d33a2:     Vector cip = HmmUtils.getCumulativeInitialProbabilities(model);
1:27d33a2:     Matrix ctm = HmmUtils.getCumulativeTransitionMatrix(model);
1:27d33a2:     Matrix com = HmmUtils.getCumulativeOutputMatrix(model);
1:27d33a2:     // allocate the result IntArrayList
1:27d33a2:     int[] result = new int[steps];
1:27d33a2:     // choose the initial state
1:27d33a2:     int hiddenState = 0;
1:27d33a2: 
1:27d33a2:     double randnr = rand.nextDouble();
1:d53cf4a:     while (cip.get(hiddenState) < randnr) {
1:27d33a2:       hiddenState++;
1:d53cf4a:     }
1:27d33a2: 
1:27d33a2:     // now draw steps output states according to the cumulative
1:27d33a2:     // distributions
1:27d33a2:     for (int step = 0; step < steps; ++step) {
1:27d33a2:       // choose output state to given hidden state
1:27d33a2:       randnr = rand.nextDouble();
1:27d33a2:       int outputState = 0;
1:d53cf4a:       while (com.get(hiddenState, outputState) < randnr) {
1:27d33a2:         outputState++;
1:d53cf4a:       }
1:27d33a2:       result[step] = outputState;
1:27d33a2:       // choose the next hidden state
1:27d33a2:       randnr = rand.nextDouble();
1:27d33a2:       int nextHiddenState = 0;
1:d53cf4a:       while (ctm.get(hiddenState, nextHiddenState) < randnr) {
1:27d33a2:         nextHiddenState++;
1:d53cf4a:       }
1:27d33a2:       hiddenState = nextHiddenState;
3:27d33a2:     }
1:27d33a2:     return result;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Returns the likelihood that a given output sequence was produced by the
1:27d33a2:    * given model. Internally, this function calls the forward algorithm to
1:27d33a2:    * compute the alpha values and then uses the overloaded function to compute
1:27d33a2:    * the actual model likelihood.
1:27d33a2:    *
1:27d33a2:    * @param model          Model to base the likelihood on.
1:27d33a2:    * @param outputSequence Sequence to compute likelihood for.
1:27d33a2:    * @param scaled         Use log-scaled parameters for computation. This is computationally
1:27d33a2:    *                       more expensive, but offers better numerically stability in case of
1:27d33a2:    *                       long output sequences
1:27d33a2:    * @return Likelihood that the given model produced the given sequence
1:27d33a2:    */
1:210b265:   public static double modelLikelihood(HmmModel model, int[] outputSequence, boolean scaled) {
1:d53cf4a:     return modelLikelihood(HmmAlgorithms.forwardAlgorithm(model, outputSequence, scaled), scaled);
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Computes the likelihood that a given output sequence was computed by a
1:27d33a2:    * given model using the alpha values computed by the forward algorithm.
1:27d33a2:    * // TODO I am a bit confused here - where is the output sequence referenced in the comment above in the code?
1:27d33a2:    * @param alpha  Matrix of alpha values
1:27d33a2:    * @param scaled Set to true if the alpha values are log-scaled.
1:27d33a2:    * @return model likelihood.
1:27d33a2:    */
1:27d33a2:   public static double modelLikelihood(Matrix alpha, boolean scaled) {
1:27d33a2:     double likelihood = 0;
1:27d33a2:     if (scaled) {
1:27d33a2:       for (int i = 0; i < alpha.numCols(); ++i) {
1:27d33a2:         likelihood += Math.exp(alpha.getQuick(alpha.numRows() - 1, i));
1:27d33a2:       }
1:d53cf4a:     } else {
1:27d33a2:       for (int i = 0; i < alpha.numCols(); ++i) {
1:27d33a2:         likelihood += alpha.getQuick(alpha.numRows() - 1, i);
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:     return likelihood;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Computes the likelihood that a given output sequence was computed by a
1:27d33a2:    * given model.
1:27d33a2:    *
1:27d33a2:    * @param model model to compute sequence likelihood for.
1:27d33a2:    * @param outputSequence sequence to base computation on.
1:27d33a2:    * @param beta beta parameters.
1:27d33a2:    * @param scaled     set to true if betas are log-scaled.
1:27d33a2:    * @return likelihood of the outputSequence given the model.
1:27d33a2:    */
1:74f849b:   public static double modelLikelihood(HmmModel model, int[] outputSequence, Matrix beta, boolean scaled) {
1:27d33a2:     double likelihood = 0;
1:27d33a2:     // fetch the emission probabilities
1:27d33a2:     Matrix e = model.getEmissionMatrix();
1:27d33a2:     Vector pi = model.getInitialProbabilities();
1:27d33a2:     int firstOutput = outputSequence[0];
1:27d33a2:     if (scaled) {
1:27d33a2:       for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
1:d53cf4a:         likelihood += pi.getQuick(i) * Math.exp(beta.getQuick(0, i)) * e.getQuick(i, firstOutput);
1:27d33a2:       }
2:27d33a2:     } else {
1:27d33a2:       for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
1:d53cf4a:         likelihood += pi.getQuick(i) * beta.getQuick(0, i) * e.getQuick(i, firstOutput);
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:     return likelihood;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Returns the most likely sequence of hidden states for the given model and
1:27d33a2:    * observation
1:27d33a2:    *
1:27d33a2:    * @param model model to use for decoding.
1:27d33a2:    * @param observations integer Array containing a sequence of observed state IDs
1:27d33a2:    * @param scaled       Use log-scaled computations, this requires higher computational
1:27d33a2:    *                     effort but is numerically more stable for large observation
1:27d33a2:    *                     sequences
1:27d33a2:    * @return integer array containing the most likely sequence of hidden state
1:27d33a2:    * IDs
1:27d33a2:    */
1:27d33a2:   public static int[] decode(HmmModel model, int[] observations, boolean scaled) {
1:27d33a2:     return HmmAlgorithms.viterbiAlgorithm(model, observations, scaled);
1:27d33a2:   }
1:27d33a2: 
1:27d33a2: }
============================================================================
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:210b265
/////////////////////////////////////////////////////////////////////////
1:   private HmmEvaluator() {}
/////////////////////////////////////////////////////////////////////////
1:     return predict(model, steps, RandomUtils.getRandom());
1:    * Predict a sequence of steps output states for the given HMM model
1:    *
1:    * @param model The Hidden Markov model used to generate the output sequence
1:    * @param steps Size of the generated output sequence
1:    * @param seed  seed to use for the RNG
1:    * @return integer array containing a sequence of steps output state IDs,
1:    *         generated by the specified model
1:    */
1:   public static int[] predict(HmmModel model, int steps, long seed) {
1:     return predict(model, steps, RandomUtils.getRandom(seed));
1:   }
1:   /**
1:    * @param rand  RNG to use
1:   private static int[] predict(HmmModel model, int steps, Random rand) {
/////////////////////////////////////////////////////////////////////////
1:   public static double modelLikelihood(HmmModel model, int[] outputSequence, boolean scaled) {
commit:74f849b
/////////////////////////////////////////////////////////////////////////
1:   public static double modelLikelihood(HmmModel model, int[] outputSequence, Matrix beta, boolean scaled) {
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:d53cf4a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     if (seed == 0) {
1:     } else {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     while (cip.get(hiddenState) < randnr) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:       while (com.get(hiddenState, outputState) < randnr) {
1:       }
1:       while (ctm.get(hiddenState, nextHiddenState) < randnr) {
1:       }
/////////////////////////////////////////////////////////////////////////
1:     return modelLikelihood(HmmAlgorithms.forwardAlgorithm(model, outputSequence, scaled), scaled);
/////////////////////////////////////////////////////////////////////////
1:         likelihood += pi.getQuick(i) * Math.exp(beta.getQuick(0, i)) * e.getQuick(i, firstOutput);
1:         likelihood += pi.getQuick(i) * beta.getQuick(0, i) * e.getQuick(i, firstOutput);
author:Isabel Drost
-------------------------------------------------------------------------------
commit:27d33a2
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.classifier.sequencelearning.hmm;
1: 
1: import java.util.Random;
1: 
1: import org.apache.mahout.common.RandomUtils;
1: import org.apache.mahout.math.Matrix;
1: import org.apache.mahout.math.Vector;
1: 
1: /**
1:  * The HMMEvaluator class offers several methods to evaluate an HMM Model. The
1:  * following use-cases are covered: 1) Generate a sequence of output states from
1:  * a given model (prediction). 2) Compute the likelihood that a given model
1:  * generated a given sequence of output states (model likelihood). 3) Compute
1:  * the most likely hidden sequence for a given model and a given observed
1:  * sequence (decoding).
1:  *
0:  * @author mheimel
1:  */
1: public final class HmmEvaluator {
1: 
1:   /**
1:    * No constructor for utility classes.
1:    */
0:   private HmmEvaluator() {
0:     // Nothing to do here.
1:   }
1: 
1:   /**
1:    * Predict a sequence of steps output states for the given HMM model
1:    *
1:    * @param model The Hidden Markov model used to generate the output sequence
1:    * @param steps Size of the generated output sequence
1:    * @return integer array containing a sequence of steps output state IDs,
1:    *         generated by the specified model
1:    */
1:   public static int[] predict(HmmModel model, int steps) {
0:     return predict(model, steps, 0);
1:   }
1: 
1:   /**
1:    * Predict a sequence of steps output states for the given HMM model using the
1:    * given seed for probabilistic experiments
1:    *
1:    * @param model The Hidden Markov model used to generate the output sequence
1:    * @param steps Size of the generated output sequence
0:    * @param seed  Seed to initialize the RNG
1:    * @return integer array containing a sequence of steps output state IDs,
1:    *         generated by the specified model
1:    */
0:   public static int[] predict(HmmModel model, int steps, long seed) {
0:     // create the random number generator
0:     Random rand;
0:     if (seed == 0)
0:       rand = RandomUtils.getRandom();
0:     else
0:       rand = RandomUtils.getRandom(seed);
1:     // fetch the cumulative distributions
1:     Vector cip = HmmUtils.getCumulativeInitialProbabilities(model);
1:     Matrix ctm = HmmUtils.getCumulativeTransitionMatrix(model);
1:     Matrix com = HmmUtils.getCumulativeOutputMatrix(model);
1:     // allocate the result IntArrayList
1:     int[] result = new int[steps];
1:     // choose the initial state
1:     int hiddenState = 0;
1: 
1:     double randnr = rand.nextDouble();
0:     while (cip.get(hiddenState) < randnr)
1:       hiddenState++;
1: 
1:     // now draw steps output states according to the cumulative
1:     // distributions
1:     for (int step = 0; step < steps; ++step) {
1:       // choose output state to given hidden state
1:       randnr = rand.nextDouble();
1:       int outputState = 0;
0:       while (com.get(hiddenState, outputState) < randnr)
1:         outputState++;
1:       result[step] = outputState;
1:       // choose the next hidden state
1:       randnr = rand.nextDouble();
1:       int nextHiddenState = 0;
0:       while (ctm.get(hiddenState, nextHiddenState) < randnr)
1:         nextHiddenState++;
1:       hiddenState = nextHiddenState;
1:     }
1:     return result;
1:   }
1: 
1:   /**
1:    * Returns the likelihood that a given output sequence was produced by the
1:    * given model. Internally, this function calls the forward algorithm to
1:    * compute the alpha values and then uses the overloaded function to compute
1:    * the actual model likelihood.
1:    *
1:    * @param model          Model to base the likelihood on.
1:    * @param outputSequence Sequence to compute likelihood for.
1:    * @param scaled         Use log-scaled parameters for computation. This is computationally
1:    *                       more expensive, but offers better numerically stability in case of
1:    *                       long output sequences
1:    * @return Likelihood that the given model produced the given sequence
1:    */
0:   public static double modelLikelihood(HmmModel model, int[] outputSequence,
0:                                        boolean scaled) {
0:     return modelLikelihood(HmmAlgorithms.forwardAlgorithm(model,
0:         outputSequence, scaled), scaled);
1:   }
1: 
1:   /**
1:    * Computes the likelihood that a given output sequence was computed by a
1:    * given model using the alpha values computed by the forward algorithm.
1:    * // TODO I am a bit confused here - where is the output sequence referenced in the comment above in the code?
1:    * @param alpha  Matrix of alpha values
1:    * @param scaled Set to true if the alpha values are log-scaled.
1:    * @return model likelihood.
1:    */
1:   public static double modelLikelihood(Matrix alpha, boolean scaled) {
1:     double likelihood = 0;
1:     if (scaled) {
1:       for (int i = 0; i < alpha.numCols(); ++i) {
1:         likelihood += Math.exp(alpha.getQuick(alpha.numRows() - 1, i));
1:       }
1:     } else {
1:       for (int i = 0; i < alpha.numCols(); ++i) {
1:         likelihood += alpha.getQuick(alpha.numRows() - 1, i);
1:       }
1:     }
1:     return likelihood;
1:   }
1: 
1:   /**
1:    * Computes the likelihood that a given output sequence was computed by a
1:    * given model.
1:    *
1:    * @param model model to compute sequence likelihood for.
1:    * @param outputSequence sequence to base computation on.
1:    * @param beta beta parameters.
1:    * @param scaled     set to true if betas are log-scaled.
1:    * @return likelihood of the outputSequence given the model.
1:    */
0:   public static double modelLikelihood(HmmModel model, int[] outputSequence,
0:                                        Matrix beta, boolean scaled) {
1:     double likelihood = 0;
1:     // fetch the emission probabilities
1:     Matrix e = model.getEmissionMatrix();
1:     Vector pi = model.getInitialProbabilities();
1:     int firstOutput = outputSequence[0];
1:     if (scaled) {
1:       for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
0:         likelihood += pi.getQuick(i) * Math.exp(beta.getQuick(0, i))
0:             * e.getQuick(i, firstOutput);
1:       }
1:     } else {
1:       for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
0:         likelihood += pi.getQuick(i) * beta.getQuick(0, i)
0:             * e.getQuick(i, firstOutput);
1:       }
1:     }
1:     return likelihood;
1:   }
1: 
1:   /**
1:    * Returns the most likely sequence of hidden states for the given model and
1:    * observation
1:    *
1:    * @param model model to use for decoding.
1:    * @param observations integer Array containing a sequence of observed state IDs
1:    * @param scaled       Use log-scaled computations, this requires higher computational
1:    *                     effort but is numerically more stable for large observation
1:    *                     sequences
1:    * @return integer array containing the most likely sequence of hidden state
1:    * IDs
1:    */
1:   public static int[] decode(HmmModel model, int[] observations, boolean scaled) {
1:     return HmmAlgorithms.viterbiAlgorithm(model, observations, scaled);
1:   }
1: 
1: }
============================================================================