4:35fa73f: /**
1:35fa73f:  * Licensed to the Apache Software Foundation (ASF) under one
1:35fa73f:  * or more contributor license agreements. See the NOTICE file
1:35fa73f:  * distributed with this work for additional information
1:35fa73f:  * regarding copyright ownership. The ASF licenses this file
1:35fa73f:  * to you under the Apache License, Version 2.0 (the
1:35fa73f:  * "License"); you may not use this file except in compliance
1:35fa73f:  * with the License. You may obtain a copy of the License at
8:35fa73f:  *
1:35fa73f:  * http://www.apache.org/licenses/LICENSE-2.0
1:35fa73f:  *
1:35fa73f:  * Unless required by applicable law or agreed to in writing,
1:35fa73f:  * software distributed under the License is distributed on an
1:35fa73f:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:35fa73f:  * KIND, either express or implied. See the License for the
1:35fa73f:  * specific language governing permissions and limitations
1:35fa73f:  * under the License.
2:fcbc54a:  */
7:7926fcb: 
1:35fa73f: package org.apache.mahout.math.map;
1:a90e57e: 
1:a90e57e: import java.util.Arrays;
1:a90e57e: 
1:fcbc54a: /**
1:35fa73f:  * Not of interest for users; only for implementors of hashtables.
1:35fa73f:  * Used to keep hash table capacities prime numbers.
1:fcbc54a:  *
1:35fa73f:  * <p>Choosing prime numbers as hash table capacities is a good idea to keep them working fast,
1:35fa73f:  * particularly under hash table expansions.
1:35fa73f:  *
1:35fa73f:  * <p>However, JDK 1.2, JGL 3.1 and many other toolkits do nothing to keep capacities prime.
1:35fa73f:  * This class provides efficient means to choose prime capacities.
1:35fa73f:  *
1:35fa73f:  * <p>Choosing a prime is <tt>O(log 300)</tt> (binary search in a list of 300 int's).
1:35fa73f:  * Memory requirements: 1 KB static memory.
1:fcbc54a:  *
1:fcbc54a:  */
1:10c535c: public final class PrimeFinder {
1:a90e57e: 
1:7926fcb:   /** The largest prime this class can generate; currently equal to <tt>Integer.MAX_VALUE</tt>. */
1:6d16230:   public static final int LARGEST_PRIME = Integer.MAX_VALUE; //yes, it is prime.
1:7926fcb: 
1:fcbc54a:   /**
1:7926fcb:    * The prime number list consists of 11 chunks. Each chunk contains prime numbers. A chunk starts with a prime P1. The
1:7926fcb:    * next element is a prime P2. P2 is the smallest prime for which holds: P2 >= 2*P1. The next element is P3, for which
1:7926fcb:    * the same holds with respect to P2, and so on.
1:fcbc54a:    *
1:7926fcb:    * Chunks are chosen such that for any desired capacity >= 1000 the list includes a prime number <= desired capacity *
1:7926fcb:    * 1.11 (11%). For any desired capacity >= 200 the list includes a prime number <= desired capacity * 1.16 (16%). For
1:7926fcb:    * any desired capacity >= 16 the list includes a prime number <= desired capacity * 1.21 (21%).
1:fcbc54a:    *
1:7926fcb:    * Therefore, primes can be retrieved which are quite close to any desired capacity, which in turn avoids wasting
1:7926fcb:    * memory. For example, the list includes 1039,1117,1201,1277,1361,1439,1523,1597,1759,1907,2081. So if you need a
1:7926fcb:    * prime >= 1040, you will find a prime <= 1040*1.11=1154.
1:7926fcb:    *
1:7926fcb:    * Chunks are chosen such that they are optimized for a hashtable growthfactor of 2.0; If your hashtable has such a
1:7926fcb:    * growthfactor then, after initially "rounding to a prime" upon hashtable construction, it will later expand to prime
1:7926fcb:    * capacities such that there exist no better primes.
1:7926fcb:    *
1:7926fcb:    * In total these are about 32*10=320 numbers -> 1 KB of static memory needed. If you are stingy, then delete every
1:7926fcb:    * second or fourth chunk.
1:7926fcb:    */
1:7926fcb: 
1:6d16230:   private static final int[] PRIME_CAPACITIES = {
1:229aeff:     //chunk #0
1:6d16230:     LARGEST_PRIME,
1:7926fcb: 
1:229aeff:     //chunk #1
1:229aeff:     5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717, 51437, 102877, 205759,
1:229aeff:     411527, 823117, 1646237, 3292489, 6584983, 13169977, 26339969, 52679969, 105359939,
1:229aeff:     210719881, 421439783, 842879579, 1685759167,
1:7926fcb: 
1:229aeff:     //chunk #2
1:229aeff:     433, 877, 1759, 3527, 7057, 14143, 28289, 56591, 113189, 226379, 452759, 905551, 1811107,
1:229aeff:     3622219, 7244441, 14488931, 28977863, 57955739, 115911563, 231823147, 463646329, 927292699,
1:229aeff:     1854585413,
1:7926fcb: 
1:229aeff:     //chunk #3
1:229aeff:     953, 1907, 3821, 7643, 15287, 30577, 61169, 122347, 244703, 489407, 978821, 1957651, 3915341,
1:229aeff:     7830701, 15661423, 31322867, 62645741, 125291483, 250582987, 501165979, 1002331963,
1:229aeff:     2004663929,
1:7926fcb: 
1:229aeff:     //chunk #4
1:229aeff:     1039, 2081, 4177, 8363, 16729, 33461, 66923, 133853, 267713, 535481, 1070981, 2141977, 4283963,
1:229aeff:     8567929, 17135863, 34271747, 68543509, 137087021, 274174111, 548348231, 1096696463,
1:7926fcb: 
1:229aeff:     //chunk #5
1:229aeff:     31, 67, 137, 277, 557, 1117, 2237, 4481, 8963, 17929, 35863, 71741, 143483, 286973, 573953,
1:229aeff:     1147921, 2295859, 4591721, 9183457, 18366923, 36733847, 73467739, 146935499, 293871013,
1:229aeff:     587742049, 1175484103,
1:7926fcb: 
1:229aeff:     //chunk #6
1:229aeff:     599, 1201, 2411, 4831, 9677, 19373, 38747, 77509, 155027, 310081, 620171, 1240361, 2480729,
1:229aeff:     4961459, 9922933, 19845871, 39691759, 79383533, 158767069, 317534141, 635068283, 1270136683,
1:7926fcb: 
1:229aeff:     //chunk #7
1:229aeff:     311, 631, 1277, 2557, 5119, 10243, 20507, 41017, 82037, 164089, 328213, 656429, 1312867,
1:229aeff:     2625761, 5251529, 10503061, 21006137, 42012281, 84024581, 168049163, 336098327, 672196673,
1:229aeff:     1344393353,
1:7926fcb: 
1:229aeff:     //chunk #8
1:229aeff:     3, 7, 17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949, 21911, 43853, 87719, 175447, 350899,
1:229aeff:     701819, 1403641, 2807303, 5614657, 11229331, 22458671, 44917381, 89834777, 179669557,
1:229aeff:     359339171, 718678369, 1437356741,
1:7926fcb: 
1:229aeff:     //chunk #9
1:229aeff:     43, 89, 179, 359, 719, 1439, 2879, 5779, 11579, 23159, 46327, 92657, 185323, 370661, 741337,
1:229aeff:     1482707, 2965421, 5930887, 11861791, 23723597, 47447201, 94894427, 189788857, 379577741,
1:229aeff:     759155483, 1518310967,
1:7926fcb: 
1:229aeff:     //chunk #10
1:229aeff:     379, 761, 1523, 3049, 6101, 12203, 24407, 48817, 97649, 195311, 390647, 781301, 1562611,
1:229aeff:     3125257, 6250537, 12501169, 25002389, 50004791, 100009607, 200019221, 400038451, 800076929,
1:229aeff:     1600153859
1:7926fcb:   };
1:7926fcb: 
1:7926fcb: 
1:fcbc54a:   static { //initializer
1:fcbc54a:     // The above prime numbers are formatted for human readability.
1:fcbc54a:     // To find numbers fast, we sort them once and for all.
1:7926fcb: 
1:6d16230:     Arrays.sort(PRIME_CAPACITIES);
3:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /** Makes this class non instantiable, but still let's others inherit from it. */
1:7926fcb:   private PrimeFinder() {
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:229aeff:    * Returns a prime number which is {@code <= desiredCapacity} and very close to {@code desiredCapacity}
1:229aeff:    * (within 11% if {@code desiredCapacity <= 1000}).
1:7926fcb:    *
1:7926fcb:    * @param desiredCapacity the capacity desired by the user.
1:7926fcb:    * @return the capacity which should be used for a hashtable.
1:7926fcb:    */
1:7926fcb:   public static int nextPrime(int desiredCapacity) {
1:6d16230:     int i = java.util.Arrays.binarySearch(PRIME_CAPACITIES, desiredCapacity);
1:7926fcb:     if (i < 0) {
1:7926fcb:       // desired capacity not found, choose next prime greater than desired capacity
1:7926fcb:       i = -i - 1; // remember the semantics of binarySearch...
1:7926fcb:     }
1:6d16230:     return PRIME_CAPACITIES[i];
1:7926fcb:   }
1:7926fcb: 
1:7926fcb: }
============================================================================
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:   public static final int LARGEST_PRIME = Integer.MAX_VALUE; //yes, it is prime.
/////////////////////////////////////////////////////////////////////////
1:   private static final int[] PRIME_CAPACITIES = {
1:     LARGEST_PRIME,
/////////////////////////////////////////////////////////////////////////
1:     Arrays.sort(PRIME_CAPACITIES);
/////////////////////////////////////////////////////////////////////////
1:     int i = java.util.Arrays.binarySearch(PRIME_CAPACITIES, desiredCapacity);
1:     return PRIME_CAPACITIES[i];
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:10c535c
/////////////////////////////////////////////////////////////////////////
1: public final class PrimeFinder {
commit:229aeff
/////////////////////////////////////////////////////////////////////////
1:     //chunk #0
0:     largestPrime,
1:     //chunk #1
1:     5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717, 51437, 102877, 205759,
1:     411527, 823117, 1646237, 3292489, 6584983, 13169977, 26339969, 52679969, 105359939,
1:     210719881, 421439783, 842879579, 1685759167,
1:     //chunk #2
1:     433, 877, 1759, 3527, 7057, 14143, 28289, 56591, 113189, 226379, 452759, 905551, 1811107,
1:     3622219, 7244441, 14488931, 28977863, 57955739, 115911563, 231823147, 463646329, 927292699,
1:     1854585413,
1:     //chunk #3
1:     953, 1907, 3821, 7643, 15287, 30577, 61169, 122347, 244703, 489407, 978821, 1957651, 3915341,
1:     7830701, 15661423, 31322867, 62645741, 125291483, 250582987, 501165979, 1002331963,
1:     2004663929,
1:     //chunk #4
1:     1039, 2081, 4177, 8363, 16729, 33461, 66923, 133853, 267713, 535481, 1070981, 2141977, 4283963,
1:     8567929, 17135863, 34271747, 68543509, 137087021, 274174111, 548348231, 1096696463,
1:     //chunk #5
1:     31, 67, 137, 277, 557, 1117, 2237, 4481, 8963, 17929, 35863, 71741, 143483, 286973, 573953,
1:     1147921, 2295859, 4591721, 9183457, 18366923, 36733847, 73467739, 146935499, 293871013,
1:     587742049, 1175484103,
1:     //chunk #6
1:     599, 1201, 2411, 4831, 9677, 19373, 38747, 77509, 155027, 310081, 620171, 1240361, 2480729,
1:     4961459, 9922933, 19845871, 39691759, 79383533, 158767069, 317534141, 635068283, 1270136683,
1:     //chunk #7
1:     311, 631, 1277, 2557, 5119, 10243, 20507, 41017, 82037, 164089, 328213, 656429, 1312867,
1:     2625761, 5251529, 10503061, 21006137, 42012281, 84024581, 168049163, 336098327, 672196673,
1:     1344393353,
1:     //chunk #8
1:     3, 7, 17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949, 21911, 43853, 87719, 175447, 350899,
1:     701819, 1403641, 2807303, 5614657, 11229331, 22458671, 44917381, 89834777, 179669557,
1:     359339171, 718678369, 1437356741,
1:     //chunk #9
1:     43, 89, 179, 359, 719, 1439, 2879, 5779, 11579, 23159, 46327, 92657, 185323, 370661, 741337,
1:     1482707, 2965421, 5930887, 11861791, 23723597, 47447201, 94894427, 189788857, 379577741,
1:     759155483, 1518310967,
1:     //chunk #10
1:     379, 761, 1523, 3049, 6101, 12203, 24407, 48817, 97649, 195311, 390647, 781301, 1562611,
1:     3125257, 6250537, 12501169, 25002389, 50004791, 100009607, 200019221, 400038451, 800076929,
1:     1600153859
/////////////////////////////////////////////////////////////////////////
1:    * Returns a prime number which is {@code <= desiredCapacity} and very close to {@code desiredCapacity}
1:    * (within 11% if {@code desiredCapacity <= 1000}).
/////////////////////////////////////////////////////////////////////////
commit:ea65197
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         log.info("new maxdev @{}@dev={}", i, maxDeviation);
/////////////////////////////////////////////////////////////////////////
0:     log.info("Statistics for [{},{}] are as follows", from, to);
0:     log.info("meanDeviation = {} %", (float) meanDeviation * 100);
0:     log.info("maxDeviation = {} %", (float) maxDeviation * 100);
commit:cfe7f01
/////////////////////////////////////////////////////////////////////////
commit:7369cd5
/////////////////////////////////////////////////////////////////////////
commit:7627de6
/////////////////////////////////////////////////////////////////////////
0:     //int i = new IntArrayList(primeCapacities).binarySearch(desiredCapacity); // for debug only TODO
/////////////////////////////////////////////////////////////////////////
0:   private static void statistics(int from, int to) {
commit:a90e57e
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
1: import java.util.Arrays;
1: 
/////////////////////////////////////////////////////////////////////////
0:   private static final Logger log = LoggerFactory.getLogger(PrimeFinder.class);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     Arrays.sort(primeCapacities);
/////////////////////////////////////////////////////////////////////////
0:             "primes are unsorted or contain duplicates; detected at " + i + '@' + primeCapacities[i]);
/////////////////////////////////////////////////////////////////////////
0:       //log.info(primeCapacity);
0:         log.info("new maxdev @" + i + "@dev=" + maxDeviation);
/////////////////////////////////////////////////////////////////////////
0:     log.info("Statistics for [" + from + ',' + to + "] are as follows");
0:     log.info("meanDeviation = " + (float) meanDeviation * 100 + " %");
0:     log.info("maxDeviation = " + (float) maxDeviation * 100 + " %");
commit:7926fcb
/////////////////////////////////////////////////////////////////////////
1: 
0: /** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
0: public class PrimeFinder {
1: 
1:   /** The largest prime this class can generate; currently equal to <tt>Integer.MAX_VALUE</tt>. */
1:    * The prime number list consists of 11 chunks. Each chunk contains prime numbers. A chunk starts with a prime P1. The
1:    * next element is a prime P2. P2 is the smallest prime for which holds: P2 >= 2*P1. The next element is P3, for which
1:    * the same holds with respect to P2, and so on.
1:    * Chunks are chosen such that for any desired capacity >= 1000 the list includes a prime number <= desired capacity *
1:    * 1.11 (11%). For any desired capacity >= 200 the list includes a prime number <= desired capacity * 1.16 (16%). For
1:    * any desired capacity >= 16 the list includes a prime number <= desired capacity * 1.21 (21%).
1:    * Therefore, primes can be retrieved which are quite close to any desired capacity, which in turn avoids wasting
1:    * memory. For example, the list includes 1039,1117,1201,1277,1361,1439,1523,1597,1759,1907,2081. So if you need a
1:    * prime >= 1040, you will find a prime <= 1040*1.11=1154.
1:    *
1:    * Chunks are chosen such that they are optimized for a hashtable growthfactor of 2.0; If your hashtable has such a
1:    * growthfactor then, after initially "rounding to a prime" upon hashtable construction, it will later expand to prime
1:    * capacities such that there exist no better primes.
1:    *
1:    * In total these are about 32*10=320 numbers -> 1 KB of static memory needed. If you are stingy, then delete every
1:    * second or fourth chunk.
1: 
0:       //chunk #0
0:       largestPrime,
1: 
0:       //chunk #1
0:       5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717, 51437, 102877, 205759,
0:       411527, 823117, 1646237, 3292489, 6584983, 13169977, 26339969, 52679969, 105359939,
0:       210719881, 421439783, 842879579, 1685759167,
1: 
0:       //chunk #2
0:       433, 877, 1759, 3527, 7057, 14143, 28289, 56591, 113189, 226379, 452759, 905551, 1811107,
0:       3622219, 7244441, 14488931, 28977863, 57955739, 115911563, 231823147, 463646329, 927292699,
1: 
0:       //chunk #3
0:       953, 1907, 3821, 7643, 15287, 30577, 61169, 122347, 244703, 489407, 978821, 1957651, 3915341,
0:       7830701, 15661423, 31322867, 62645741, 125291483, 250582987, 501165979, 1002331963,
1: 
0:       //chunk #4
0:       1039, 2081, 4177, 8363, 16729, 33461, 66923, 133853, 267713, 535481, 1070981, 2141977, 4283963,
0:       8567929, 17135863, 34271747, 68543509, 137087021, 274174111, 548348231, 1096696463,
1: 
0:       //chunk #5
0:       31, 67, 137, 277, 557, 1117, 2237, 4481, 8963, 17929, 35863, 71741, 143483, 286973, 573953,
0:       1147921, 2295859, 4591721, 9183457, 18366923, 36733847, 73467739, 146935499, 293871013,
0:       587742049, 1175484103,
1: 
0:       //chunk #6
0:       599, 1201, 2411, 4831, 9677, 19373, 38747, 77509, 155027, 310081, 620171, 1240361, 2480729,
0:       4961459, 9922933, 19845871, 39691759, 79383533, 158767069, 317534141, 635068283, 1270136683,
1: 
0:       //chunk #7
0:       311, 631, 1277, 2557, 5119, 10243, 20507, 41017, 82037, 164089, 328213, 656429, 1312867,
0:       2625761, 5251529, 10503061, 21006137, 42012281, 84024581, 168049163, 336098327, 672196673,
1: 
0:       //chunk #8
0:       3, 7, 17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949, 21911, 43853, 87719, 175447, 350899,
0:       701819, 1403641, 2807303, 5614657, 11229331, 22458671, 44917381, 89834777, 179669557,
0:       359339171, 718678369, 1437356741,
1: 
0:       //chunk #9
0:       43, 89, 179, 359, 719, 1439, 2879, 5779, 11579, 23159, 46327, 92657, 185323, 370661, 741337,
0:       1482707, 2965421, 5930887, 11861791, 23723597, 47447201, 94894427, 189788857, 379577741,
0:       759155483, 1518310967,
1: 
0:       //chunk #10
0:       379, 761, 1523, 3049, 6101, 12203, 24407, 48817, 97649, 195311, 390647, 781301, 1562611,
0:       3125257, 6250537, 12501169, 25002389, 50004791, 100009607, 200019221, 400038451, 800076929,
0:       /*
0:       // some more chunks for the low range [3..1000]
0:       //chunk #11
0:       13,29,59,127,257,521,1049,2099,4201,8419,16843,33703,67409,134837,269683,
0:       539389,1078787,2157587,4315183,8630387,17260781,34521589,69043189,138086407,
0:       276172823,552345671,1104691373,
1: 
0:       //chunk #12
0:       19,41,83,167,337,677,
0:       //1361,2729,5471,10949,21911,43853,87719,175447,350899,
0:       //701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,
0:       //359339171,718678369,1437356741,
1: 
0:       //chunk #13
0:       53,107,223,449,907,1823,3659,7321,14653,29311,58631,117269,
0:       234539,469099,938207,1876417,3752839,7505681,15011389,30022781,
0:       60045577,120091177,240182359,480364727,960729461,1921458943
1:       */
1:   };
1: 
1: 
1:   /** Makes this class non instantiable, but still let's others inherit from it. */
1:   private PrimeFinder() {
1:   }
1: 
0:   /** Tests correctness. Try from=1000, to=10000 from=200,  to=1000 from=16,   to=1000 from=1000, to=Integer.MAX_VALUE */
0:   protected static void main(String[] args) {
0:     int from = Integer.parseInt(args[0]);
0:     int to = Integer.parseInt(args[1]);
1: 
0:     statistics(from, to);
1:   }
1: 
1:   /**
0:    * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code>
0:    * (within 11% if <code>desiredCapacity &gt;= 1000</code>).
1:    *
1:    * @param desiredCapacity the capacity desired by the user.
1:    * @return the capacity which should be used for a hashtable.
1:    */
1:   public static int nextPrime(int desiredCapacity) {
0:     int i = java.util.Arrays.binarySearch(primeCapacities, desiredCapacity);
0:     //int i = new org.apache.mahout.matrix.list.IntArrayList(primeCapacities).binarySearch(desiredCapacity); // for debug only TODO
1:     if (i < 0) {
1:       // desired capacity not found, choose next prime greater than desired capacity
1:       i = -i - 1; // remember the semantics of binarySearch...
1:     }
0:     return primeCapacities[i];
1:   }
1: 
0:   /** Tests correctness. */
0:   protected static void statistics(int from, int to) {
0:     // check that primes contain no accidental errors
0:     for (int i = 0; i < primeCapacities.length - 1; i++) {
0:       if (primeCapacities[i] >= primeCapacities[i + 1]) {
0:         throw new IllegalStateException(
0:             "primes are unsorted or contain duplicates; detected at " + i + "@" + primeCapacities[i]);
1:       }
0:     double accDeviation = 0.0;
0:     double maxDeviation = -1.0;
1: 
0:     for (int i = from; i <= to; i++) {
0:       int primeCapacity = nextPrime(i);
0:       //System.out.println(primeCapacity);
0:       double deviation = (primeCapacity - i) / (double) i;
1: 
0:       if (deviation > maxDeviation) {
0:         maxDeviation = deviation;
0:         System.out.println("new maxdev @" + i + "@dev=" + maxDeviation);
1:       }
1: 
0:       accDeviation += deviation;
1:     }
0:     long width = 1 + (long) to - (long) from;
1: 
0:     double meanDeviation = accDeviation / width;
0:     System.out.println("Statistics for [" + from + "," + to + "] are as follows");
0:     System.out.println("meanDeviation = " + (float) meanDeviation * 100 + " %");
0:     System.out.println("maxDeviation = " + (float) maxDeviation * 100 + " %");
commit:fcbc54a
/////////////////////////////////////////////////////////////////////////
1:   /**
0:    * The largest prime this class can generate; currently equal to <tt>Integer.MAX_VALUE</tt>.
1:    */
0:   public static final int largestPrime = Integer.MAX_VALUE; //yes, it is prime.
1:   /**
0:    * The prime number list consists of 11 chunks.
0:    * Each chunk contains prime numbers.
0:    * A chunk starts with a prime P1. The next element is a prime P2. P2 is the smallest prime for which holds: P2 >= 2*P1.
0:    * The next element is P3, for which the same holds with respect to P2, and so on.
1:    *
0:    * Chunks are chosen such that for any desired capacity >= 1000 
0:    * the list includes a prime number <= desired capacity * 1.11 (11%).
0:    * For any desired capacity >= 200 
0:    * the list includes a prime number <= desired capacity * 1.16 (16%).
0:    * For any desired capacity >= 16
0:    * the list includes a prime number <= desired capacity * 1.21 (21%).
1:    * 
0:    * Therefore, primes can be retrieved which are quite close to any desired capacity,
0:    * which in turn avoids wasting memory.
0:    * For example, the list includes 1039,1117,1201,1277,1361,1439,1523,1597,1759,1907,2081.
0:    * So if you need a prime >= 1040, you will find a prime <= 1040*1.11=1154.
1:    *  
0:    * Chunks are chosen such that they are optimized for a hashtable growthfactor of 2.0;
0:    * If your hashtable has such a growthfactor then,  
0:    * after initially "rounding to a prime" upon hashtable construction, 
0:    * it will later expand to prime capacities such that there exist no better primes.
1:    *
0:    * In total these are about 32*10=320 numbers -> 1 KB of static memory needed.
0:    * If you are stingy, then delete every second or fourth chunk.
1:    */
0:   
0:   private static final int[] primeCapacities = {
0:     //chunk #0
0:     largestPrime,
0:     
0:     //chunk #1
0:     5,11,23,47,97,197,397,797,1597,3203,6421,12853,25717,51437,102877,205759,
0:       411527,823117,1646237,3292489,6584983,13169977,26339969,52679969,105359939,
0:       210719881,421439783,842879579,1685759167,
0:       
0:     //chunk #2
0:     433,877,1759,3527,7057,14143,28289,56591,113189,226379,452759,905551,1811107,
0:       3622219,7244441,14488931,28977863,57955739,115911563,231823147,463646329,927292699,
0:       1854585413,
0:       
0:     //chunk #3
0:     953,1907,3821,7643,15287,30577,61169,122347,244703,489407,978821,1957651,3915341,
0:       7830701,15661423,31322867,62645741,125291483,250582987,501165979,1002331963,
0:       2004663929,
0:       
0:     //chunk #4
0:     1039,2081,4177,8363,16729,33461,66923,133853,267713,535481,1070981,2141977,4283963,
0:       8567929,17135863,34271747,68543509,137087021,274174111,548348231,1096696463,
0:       
0:     //chunk #5
0:     31,67,137,277,557,1117,2237,4481,8963,17929,35863,71741,143483,286973,573953,
0:       1147921,2295859,4591721,9183457,18366923,36733847,73467739,146935499,293871013,
0:       587742049,1175484103,
0:       
0:     //chunk #6
0:     599,1201,2411,4831,9677,19373,38747,77509,155027,310081,620171,1240361,2480729,
0:       4961459,9922933,19845871,39691759,79383533,158767069,317534141,635068283,1270136683,
0:       
0:     //chunk #7
0:     311,631,1277,2557,5119,10243,20507,41017,82037,164089,328213,656429,1312867,
0:       2625761,5251529,10503061,21006137,42012281,84024581,168049163,336098327,672196673,
0:       1344393353,
0:       
0:     //chunk #8
0:     3,7,17,37,79,163,331,673,1361,2729,5471,10949,21911,43853,87719,175447,350899,
0:       701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,
0:       359339171,718678369,1437356741,
0:       
0:     //chunk #9
0:     43,89,179,359,719,1439,2879,5779,11579,23159,46327,92657,185323,370661,741337,
0:       1482707,2965421,5930887,11861791,23723597,47447201,94894427,189788857,379577741,
0:       759155483,1518310967,
0:       
0:     //chunk #10
0:     379,761,1523,3049,6101,12203,24407,48817,97649,195311,390647,781301,1562611,
0:       3125257,6250537,12501169,25002389,50004791,100009607,200019221,400038451,800076929,
0:       1600153859
0:     /*
0:     // some more chunks for the low range [3..1000]
0:     //chunk #11
0:     13,29,59,127,257,521,1049,2099,4201,8419,16843,33703,67409,134837,269683,
0:     539389,1078787,2157587,4315183,8630387,17260781,34521589,69043189,138086407,
0:     276172823,552345671,1104691373,
0:     
0:     //chunk #12
0:     19,41,83,167,337,677,
0:     //1361,2729,5471,10949,21911,43853,87719,175447,350899,
0:     //701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,
0:     //359339171,718678369,1437356741,
0:     
0:     //chunk #13
0:     53,107,223,449,907,1823,3659,7321,14653,29311,58631,117269,
0:     234539,469099,938207,1876417,3752839,7505681,15011389,30022781,
0:     60045577,120091177,240182359,480364727,960729461,1921458943
1:     */
0:     };
0:     
1:   static { //initializer
1:     // The above prime numbers are formatted for human readability.
1:     // To find numbers fast, we sort them once and for all.
0:     
0:     java.util.Arrays.sort(primeCapacities);
0:     //new org.apache.mahout.matrix.list.IntArrayList(primeCapacities).mergeSort(); // for debug only, TODO
0:   }
0:   
/////////////////////////////////////////////////////////////////////////
0:   int from = Integer.parseInt(args[0]);  
0:   int to = Integer.parseInt(args[1]);
0:   
0:   statistics(from,to);
/////////////////////////////////////////////////////////////////////////
0:   int i = java.util.Arrays.binarySearch(primeCapacities, desiredCapacity);
0:   //int i = new org.apache.mahout.matrix.list.IntArrayList(primeCapacities).binarySearch(desiredCapacity); // for debug only TODO
0:   if (i<0) {
0:     // desired capacity not found, choose next prime greater than desired capacity
0:     i = -i -1; // remember the semantics of binarySearch...
0:   }
0:   return primeCapacities[i];
0:   // check that primes contain no accidental errors
0:   for (int i=0; i<primeCapacities.length-1; i++) {
0:     if (primeCapacities[i] >= primeCapacities[i+1]) throw new RuntimeException("primes are unsorted or contain duplicates; detected at "+i+"@"+primeCapacities[i]);
0:   }
0:   
0:   double accDeviation = 0.0;
0:   double maxDeviation = - 1.0;
0:   for (int i=from; i<=to; i++) {
0:     int primeCapacity = nextPrime(i);
0:     //System.out.println(primeCapacity);
0:     double deviation = (primeCapacity - i) / (double)i;
0:     
0:     if (deviation > maxDeviation) {
0:       maxDeviation = deviation;
0:       System.out.println("new maxdev @"+i+"@dev="+maxDeviation);
0:     }
0:     accDeviation += deviation;
0:   }
0:   long width = 1 + (long)to - (long)from;
0:   
0:   double meanDeviation = accDeviation/width;
0:   System.out.println("Statistics for ["+ from + ","+to+"] are as follows");
0:   System.out.println("meanDeviation = "+(float)meanDeviation*100+" %");
0:   System.out.println("maxDeviation = "+(float)maxDeviation*100+" %");
author:Ted Dunning
-------------------------------------------------------------------------------
commit:35fa73f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements. See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership. The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License. You may obtain a copy of the License at
1:  *
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied. See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  */
0: 
1: package org.apache.mahout.math.map;
0: 
0: import java.util.Arrays;
0: 
1: /**
1:  * Not of interest for users; only for implementors of hashtables.
1:  * Used to keep hash table capacities prime numbers.
1:  *
1:  * <p>Choosing prime numbers as hash table capacities is a good idea to keep them working fast,
1:  * particularly under hash table expansions.
1:  *
1:  * <p>However, JDK 1.2, JGL 3.1 and many other toolkits do nothing to keep capacities prime.
1:  * This class provides efficient means to choose prime capacities.
1:  *
1:  * <p>Choosing a prime is <tt>O(log 300)</tt> (binary search in a list of 300 int's).
1:  * Memory requirements: 1 KB static memory.
1:  *
0:  */
0: public class PrimeFinder {
0: 
0:   /** The largest prime this class can generate; currently equal to <tt>Integer.MAX_VALUE</tt>. */
0:   public static final int largestPrime = Integer.MAX_VALUE; //yes, it is prime.
0: 
1:   /**
0:    * The prime number list consists of 11 chunks. Each chunk contains prime numbers. A chunk starts with a prime P1. The
0:    * next element is a prime P2. P2 is the smallest prime for which holds: P2 >= 2*P1. The next element is P3, for which
0:    * the same holds with respect to P2, and so on.
1:    *
0:    * Chunks are chosen such that for any desired capacity >= 1000 the list includes a prime number <= desired capacity *
0:    * 1.11 (11%). For any desired capacity >= 200 the list includes a prime number <= desired capacity * 1.16 (16%). For
0:    * any desired capacity >= 16 the list includes a prime number <= desired capacity * 1.21 (21%).
1:    *
0:    * Therefore, primes can be retrieved which are quite close to any desired capacity, which in turn avoids wasting
0:    * memory. For example, the list includes 1039,1117,1201,1277,1361,1439,1523,1597,1759,1907,2081. So if you need a
0:    * prime >= 1040, you will find a prime <= 1040*1.11=1154.
1:    *
0:    * Chunks are chosen such that they are optimized for a hashtable growthfactor of 2.0; If your hashtable has such a
0:    * growthfactor then, after initially "rounding to a prime" upon hashtable construction, it will later expand to prime
0:    * capacities such that there exist no better primes.
1:    *
0:    * In total these are about 32*10=320 numbers -> 1 KB of static memory needed. If you are stingy, then delete every
0:    * second or fourth chunk.
0:    */
0: 
0:   private static final int[] primeCapacities = {
0:       //chunk #0
0:       largestPrime,
0: 
0:       //chunk #1
0:       5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717, 51437, 102877, 205759,
0:       411527, 823117, 1646237, 3292489, 6584983, 13169977, 26339969, 52679969, 105359939,
0:       210719881, 421439783, 842879579, 1685759167,
0: 
0:       //chunk #2
0:       433, 877, 1759, 3527, 7057, 14143, 28289, 56591, 113189, 226379, 452759, 905551, 1811107,
0:       3622219, 7244441, 14488931, 28977863, 57955739, 115911563, 231823147, 463646329, 927292699,
0:       1854585413,
0: 
0:       //chunk #3
0:       953, 1907, 3821, 7643, 15287, 30577, 61169, 122347, 244703, 489407, 978821, 1957651, 3915341,
0:       7830701, 15661423, 31322867, 62645741, 125291483, 250582987, 501165979, 1002331963,
0:       2004663929,
0: 
0:       //chunk #4
0:       1039, 2081, 4177, 8363, 16729, 33461, 66923, 133853, 267713, 535481, 1070981, 2141977, 4283963,
0:       8567929, 17135863, 34271747, 68543509, 137087021, 274174111, 548348231, 1096696463,
0: 
0:       //chunk #5
0:       31, 67, 137, 277, 557, 1117, 2237, 4481, 8963, 17929, 35863, 71741, 143483, 286973, 573953,
0:       1147921, 2295859, 4591721, 9183457, 18366923, 36733847, 73467739, 146935499, 293871013,
0:       587742049, 1175484103,
0: 
0:       //chunk #6
0:       599, 1201, 2411, 4831, 9677, 19373, 38747, 77509, 155027, 310081, 620171, 1240361, 2480729,
0:       4961459, 9922933, 19845871, 39691759, 79383533, 158767069, 317534141, 635068283, 1270136683,
0: 
0:       //chunk #7
0:       311, 631, 1277, 2557, 5119, 10243, 20507, 41017, 82037, 164089, 328213, 656429, 1312867,
0:       2625761, 5251529, 10503061, 21006137, 42012281, 84024581, 168049163, 336098327, 672196673,
0:       1344393353,
0: 
0:       //chunk #8
0:       3, 7, 17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949, 21911, 43853, 87719, 175447, 350899,
0:       701819, 1403641, 2807303, 5614657, 11229331, 22458671, 44917381, 89834777, 179669557,
0:       359339171, 718678369, 1437356741,
0: 
0:       //chunk #9
0:       43, 89, 179, 359, 719, 1439, 2879, 5779, 11579, 23159, 46327, 92657, 185323, 370661, 741337,
0:       1482707, 2965421, 5930887, 11861791, 23723597, 47447201, 94894427, 189788857, 379577741,
0:       759155483, 1518310967,
0: 
0:       //chunk #10
0:       379, 761, 1523, 3049, 6101, 12203, 24407, 48817, 97649, 195311, 390647, 781301, 1562611,
0:       3125257, 6250537, 12501169, 25002389, 50004791, 100009607, 200019221, 400038451, 800076929,
0:       1600153859
0:   };
0: 
0: 
0:   static { //initializer
0:     // The above prime numbers are formatted for human readability.
0:     // To find numbers fast, we sort them once and for all.
0: 
0:     Arrays.sort(primeCapacities);
0:   }
0: 
0:   /** Makes this class non instantiable, but still let's others inherit from it. */
0:   private PrimeFinder() {
0:   }
0: 
1:   /**
0:    * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code>
0:    * (within 11% if <code>desiredCapacity &gt;= 1000</code>).
1:    *
0:    * @param desiredCapacity the capacity desired by the user.
0:    * @return the capacity which should be used for a hashtable.
0:    */
0:   public static int nextPrime(int desiredCapacity) {
0:     int i = java.util.Arrays.binarySearch(primeCapacities, desiredCapacity);
0:     if (i < 0) {
0:       // desired capacity not found, choose next prime greater than desired capacity
0:       i = -i - 1; // remember the semantics of binarySearch...
0:     }
0:     return primeCapacities[i];
0:   }
0: 
0:   /** Tests correctness. */
0:   private static void statistics(int from, int to) {
0:     // check that primes contain no accidental errors
0:     for (int i = 0; i < primeCapacities.length - 1; i++) {
0:       if (primeCapacities[i] >= primeCapacities[i + 1]) {
0:         throw new IllegalStateException(
0:             "primes are unsorted or contain duplicates; detected at " + i + '@' + primeCapacities[i]);
0:       }
0:     }
0: 
0:     double accDeviation = 0.0;
0:     double maxDeviation = -1.0;
0: 
0:     for (int i = from; i <= to; i++) {
0:       int primeCapacity = nextPrime(i);
0:       //log.info(primeCapacity);
0:       double deviation = (primeCapacity - i) / (double) i;
0: 
0:       if (deviation > maxDeviation) {
0:         maxDeviation = deviation;
0:       }
0: 
0:       accDeviation += deviation;
0:     }
0:     long width = 1 + (long) to - (long) from;
0: 
0:     double meanDeviation = accDeviation / width;
0:   }
0: }
author:Benson Margulies
-------------------------------------------------------------------------------
commit:ebf9a4d
/////////////////////////////////////////////////////////////////////////
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:a435efb
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.math.map;
commit:f49424e
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.matrix.map;
/////////////////////////////////////////////////////////////////////////
0: 		//new org.apache.mahout.matrix.list.IntArrayList(primeCapacities).mergeSort(); // for debug only, TODO
/////////////////////////////////////////////////////////////////////////
0: 	//int i = new org.apache.mahout.matrix.list.IntArrayList(primeCapacities).binarySearch(desiredCapacity); // for debug only TODO
commit:7550a10
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.colt.map;
0: 
0: /**
0:  * Not of interest for users; only for implementors of hashtables.
0:  * Used to keep hash table capacities prime numbers.
0:  *
0:  * <p>Choosing prime numbers as hash table capacities is a good idea to keep them working fast,
0:  * particularly under hash table expansions.
0:  *
0:  * <p>However, JDK 1.2, JGL 3.1 and many other toolkits do nothing to keep capacities prime.
0:  * This class provides efficient means to choose prime capacities.
0:  *
0:  * <p>Choosing a prime is <tt>O(log 300)</tt> (binary search in a list of 300 int's).
0:  * Memory requirements: 1 KB static memory.
0:  *
0:  * @author wolfgang.hoschek@cern.ch
0:  * @version 1.0, 09/24/99
0:  */
0: /** 
0:  * @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported.
0:  */
0: @Deprecated
0: public class PrimeFinder extends Object {
0: 	/**
0: 	 * The largest prime this class can generate; currently equal to <tt>Integer.MAX_VALUE</tt>.
0: 	 */
0: 	public static final int largestPrime = Integer.MAX_VALUE; //yes, it is prime.
0: 
0: 	/**
0: 	 * The prime number list consists of 11 chunks.
0: 	 * Each chunk contains prime numbers.
0: 	 * A chunk starts with a prime P1. The next element is a prime P2. P2 is the smallest prime for which holds: P2 >= 2*P1.
0: 	 * The next element is P3, for which the same holds with respect to P2, and so on.
0: 	 *
0: 	 * Chunks are chosen such that for any desired capacity >= 1000 
0: 	 * the list includes a prime number <= desired capacity * 1.11 (11%).
0: 	 * For any desired capacity >= 200 
0: 	 * the list includes a prime number <= desired capacity * 1.16 (16%).
0: 	 * For any desired capacity >= 16
0: 	 * the list includes a prime number <= desired capacity * 1.21 (21%).
0: 	 * 
0: 	 * Therefore, primes can be retrieved which are quite close to any desired capacity,
0: 	 * which in turn avoids wasting memory.
0: 	 * For example, the list includes 1039,1117,1201,1277,1361,1439,1523,1597,1759,1907,2081.
0: 	 * So if you need a prime >= 1040, you will find a prime <= 1040*1.11=1154.
0: 	 *	
0: 	 * Chunks are chosen such that they are optimized for a hashtable growthfactor of 2.0;
0: 	 * If your hashtable has such a growthfactor then,  
0: 	 * after initially "rounding to a prime" upon hashtable construction, 
0: 	 * it will later expand to prime capacities such that there exist no better primes.
0: 	 *
0: 	 * In total these are about 32*10=320 numbers -> 1 KB of static memory needed.
0: 	 * If you are stingy, then delete every second or fourth chunk.
0: 	 */
0: 	
0: 	private static final int[] primeCapacities = {
0: 		//chunk #0
0: 		largestPrime,
0: 		
0: 		//chunk #1
0: 		5,11,23,47,97,197,397,797,1597,3203,6421,12853,25717,51437,102877,205759,
0: 		  411527,823117,1646237,3292489,6584983,13169977,26339969,52679969,105359939,
0: 		  210719881,421439783,842879579,1685759167,
0: 		  
0: 		//chunk #2
0: 		433,877,1759,3527,7057,14143,28289,56591,113189,226379,452759,905551,1811107,
0: 		  3622219,7244441,14488931,28977863,57955739,115911563,231823147,463646329,927292699,
0: 		  1854585413,
0: 		  
0: 		//chunk #3
0: 		953,1907,3821,7643,15287,30577,61169,122347,244703,489407,978821,1957651,3915341,
0: 		  7830701,15661423,31322867,62645741,125291483,250582987,501165979,1002331963,
0: 		  2004663929,
0: 		  
0: 		//chunk #4
0: 		1039,2081,4177,8363,16729,33461,66923,133853,267713,535481,1070981,2141977,4283963,
0: 		  8567929,17135863,34271747,68543509,137087021,274174111,548348231,1096696463,
0: 		  
0: 		//chunk #5
0: 		31,67,137,277,557,1117,2237,4481,8963,17929,35863,71741,143483,286973,573953,
0: 		  1147921,2295859,4591721,9183457,18366923,36733847,73467739,146935499,293871013,
0: 		  587742049,1175484103,
0: 		  
0: 		//chunk #6
0: 		599,1201,2411,4831,9677,19373,38747,77509,155027,310081,620171,1240361,2480729,
0: 		  4961459,9922933,19845871,39691759,79383533,158767069,317534141,635068283,1270136683,
0: 		  
0: 		//chunk #7
0: 		311,631,1277,2557,5119,10243,20507,41017,82037,164089,328213,656429,1312867,
0: 		  2625761,5251529,10503061,21006137,42012281,84024581,168049163,336098327,672196673,
0: 		  1344393353,
0: 		  
0: 		//chunk #8
0: 		3,7,17,37,79,163,331,673,1361,2729,5471,10949,21911,43853,87719,175447,350899,
0: 		  701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,
0: 		  359339171,718678369,1437356741,
0: 		  
0: 		//chunk #9
0: 		43,89,179,359,719,1439,2879,5779,11579,23159,46327,92657,185323,370661,741337,
0: 		  1482707,2965421,5930887,11861791,23723597,47447201,94894427,189788857,379577741,
0: 		  759155483,1518310967,
0: 		  
0: 		//chunk #10
0: 		379,761,1523,3049,6101,12203,24407,48817,97649,195311,390647,781301,1562611,
0: 		  3125257,6250537,12501169,25002389,50004791,100009607,200019221,400038451,800076929,
0: 		  1600153859
0: 		/*
0: 		// some more chunks for the low range [3..1000]
0: 		//chunk #11
0: 		13,29,59,127,257,521,1049,2099,4201,8419,16843,33703,67409,134837,269683,
0: 		539389,1078787,2157587,4315183,8630387,17260781,34521589,69043189,138086407,
0: 		276172823,552345671,1104691373,
0: 		
0: 		//chunk #12
0: 		19,41,83,167,337,677,
0: 		//1361,2729,5471,10949,21911,43853,87719,175447,350899,
0: 		//701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,
0: 		//359339171,718678369,1437356741,
0: 		
0: 		//chunk #13
0: 		53,107,223,449,907,1823,3659,7321,14653,29311,58631,117269,
0: 		234539,469099,938207,1876417,3752839,7505681,15011389,30022781,
0: 		60045577,120091177,240182359,480364727,960729461,1921458943
0: 		*/
0: 		};
0: 		
0: 
0: 	static { //initializer
0: 		// The above prime numbers are formatted for human readability.
0: 		// To find numbers fast, we sort them once and for all.
0: 		
0: 		java.util.Arrays.sort(primeCapacities);
0: 		//new org.apache.mahout.colt.list.IntArrayList(primeCapacities).mergeSort(); // for debug only, TODO
0: 	}
0: 	
0: /**
0:  * Makes this class non instantiable, but still let's others inherit from it.
0:  */
0: protected PrimeFinder() {}
0: /**
0:  * Tests correctness. Try 
0:  * from=1000, to=10000
0:  * from=200,  to=1000
0:  * from=16,   to=1000
0:  * from=1000, to=Integer.MAX_VALUE
0:  */
0: protected static void main(String args[]) {
0: 	int from = Integer.parseInt(args[0]);	
0: 	int to = Integer.parseInt(args[1]);
0: 	
0: 	statistics(from,to);
0: }
0: /**
0:  * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).
0:  * @param desiredCapacity the capacity desired by the user.
0:  * @return the capacity which should be used for a hashtable.
0:  */
0: public static int nextPrime(int desiredCapacity) {
0: 	int i = java.util.Arrays.binarySearch(primeCapacities, desiredCapacity);
0: 	//int i = new org.apache.mahout.colt.list.IntArrayList(primeCapacities).binarySearch(desiredCapacity); // for debug only TODO
0: 	if (i<0) {
0: 		// desired capacity not found, choose next prime greater than desired capacity
0: 		i = -i -1; // remember the semantics of binarySearch...
0: 	}
0: 	return primeCapacities[i];
0: }
0: /**
0:  * Tests correctness.
0:  */
0: protected static void statistics(int from, int to) {
0: 	// check that primes contain no accidental errors
0: 	for (int i=0; i<primeCapacities.length-1; i++) {
0: 		if (primeCapacities[i] >= primeCapacities[i+1]) throw new RuntimeException("primes are unsorted or contain duplicates; detected at "+i+"@"+primeCapacities[i]);
0: 	}
0: 	
0: 	double accDeviation = 0.0;
0: 	double maxDeviation = - 1.0;
0: 
0: 	for (int i=from; i<=to; i++) {
0: 		int primeCapacity = nextPrime(i);
0: 		//System.out.println(primeCapacity);
0: 		double deviation = (primeCapacity - i) / (double)i;
0: 		
0: 		if (deviation > maxDeviation) {
0: 			maxDeviation = deviation;
0: 			System.out.println("new maxdev @"+i+"@dev="+maxDeviation);
0: 		}
0: 
0: 		accDeviation += deviation;
0: 	}
0: 	long width = 1 + (long)to - (long)from;
0: 	
0: 	double meanDeviation = accDeviation/width;
0: 	System.out.println("Statistics for ["+ from + ","+to+"] are as follows");
0: 	System.out.println("meanDeviation = "+(float)meanDeviation*100+" %");
0: 	System.out.println("maxDeviation = "+(float)maxDeviation*100+" %");
0: }
0: }
============================================================================