1:c8270dc: /**
1:c8270dc:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:c8270dc:  * contributor license agreements.  See the NOTICE file distributed with
1:c8270dc:  * this work for additional information regarding copyright ownership.
1:c8270dc:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:c8270dc:  * (the "License"); you may not use this file except in compliance with
1:c8270dc:  * the License.  You may obtain a copy of the License at
1:c8270dc:  *
1:c8270dc:  *     http://www.apache.org/licenses/LICENSE-2.0
1:c8270dc:  *
1:c8270dc:  * Unless required by applicable law or agreed to in writing, software
1:c8270dc:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c8270dc:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c8270dc:  * See the License for the specific language governing permissions and
1:c8270dc:  * limitations under the License.
1:c8270dc:  */
2:0de31cb: 
1:c8270dc: package org.apache.mahout.clustering;
1:0de31cb: 
1:c8270dc: import java.io.IOException;
1:c8270dc: import java.util.List;
1:c8270dc: import java.util.Map;
1:0de31cb: 
1:c8270dc: import org.apache.hadoop.conf.Configuration;
1:c8270dc: import org.apache.hadoop.fs.FileSystem;
1:c8270dc: import org.apache.hadoop.fs.Path;
1:c8270dc: import org.apache.mahout.clustering.canopy.Canopy;
1:c8270dc: import org.apache.mahout.clustering.canopy.CanopyDriver;
1:c8270dc: import org.apache.mahout.clustering.evaluation.ClusterEvaluator;
1:c8270dc: import org.apache.mahout.clustering.evaluation.RepresentativePointsDriver;
1:c8270dc: import org.apache.mahout.clustering.fuzzykmeans.FuzzyKMeansDriver;
1:c8270dc: import org.apache.mahout.clustering.kmeans.KMeansDriver;
1:c8270dc: import org.apache.mahout.clustering.kmeans.TestKmeansClustering;
1:1ce47b6: import org.apache.mahout.common.HadoopUtil;
1:c8270dc: import org.apache.mahout.common.MahoutTestCase;
1:c8270dc: import org.apache.mahout.common.distance.DistanceMeasure;
1:c8270dc: import org.apache.mahout.common.distance.EuclideanDistanceMeasure;
1:c8270dc: import org.apache.mahout.math.DenseVector;
1:c8270dc: import org.apache.mahout.math.VectorWritable;
1:c8270dc: import org.junit.Before;
1:c8270dc: import org.junit.Test;
1:d41b360: import org.slf4j.Logger;
1:d41b360: import org.slf4j.LoggerFactory;
1:0de31cb: 
1:74f849b: import com.google.common.collect.Lists;
1:74f849b: import com.google.common.collect.Maps;
1:e69bcbd: 
1:c8270dc: public final class TestClusterEvaluator extends MahoutTestCase {
1:0de31cb:   
1:73c5336:   private static final double[][] REFERENCE = { {1, 1}, {2, 1}, {1, 2}, {2, 2}, {3, 3}, {4, 4}, {5, 4}, {4, 5}, {5, 5}};
1:0de31cb:   
1:74f849b:   private List<VectorWritable> referenceData = Lists.newArrayList();
1:0de31cb:   
1:74f849b:   private final List<VectorWritable> sampleData = Lists.newArrayList();
1:0de31cb:   
1:0de31cb:   private Map<Integer,List<VectorWritable>> representativePoints;
1:0de31cb:   
1:c8270dc:   private List<Cluster> clusters;
1:0de31cb:   
1:73c5336:   private static final Logger log = LoggerFactory.getLogger(TestClusterEvaluator.class);
1:0de31cb:   
1:d41b360:   private Configuration conf;
1:0de31cb:   
1:d41b360:   private FileSystem fs;
1:0de31cb:   
1:d41b360:   private Path testdata;
1:0de31cb:   
1:d41b360:   private Path output;
1:0de31cb:   
1:c8270dc:   @Override
1:c8270dc:   @Before
1:c8270dc:   public void setUp() throws Exception {
1:c8270dc:     super.setUp();
1:921e201:     conf = getConfiguration();
1:d41b360:     fs = FileSystem.get(conf);
1:d41b360:     testdata = getTestTempDirPath("testdata");
1:d41b360:     output = getTestTempDirPath("output");
1:d41b360:     // Create small reference data set
1:d41b360:     referenceData = TestKmeansClustering.getPointsWritable(REFERENCE);
1:d41b360:     // generate larger test data set for the clustering tests to chew on
1:d41b360:     generateSamples();
1:d41b360:   }
1:73c5336:   
1:d41b360:   /**
1:d41b360:    * Generate random samples and add them to the sampleData
1:d41b360:    * 
1:d41b360:    * @param num
1:d41b360:    *          int number of samples to generate
1:d41b360:    * @param mx
1:d41b360:    *          double x-value of the sample mean
1:d41b360:    * @param my
1:d41b360:    *          double y-value of the sample mean
1:d41b360:    * @param sd
1:d41b360:    *          double standard deviation of the samples
1:d41b360:    */
1:d41b360:   private void generateSamples(int num, double mx, double my, double sd) {
1:8396a27:     log.info("Generating {} samples m=[{}, {}] sd={}", num, mx, my, sd);
1:d41b360:     for (int i = 0; i < num; i++) {
1:73c5336:       sampleData.add(new VectorWritable(new DenseVector(new double[] {UncommonDistributions.rNorm(mx, sd),
1:0de31cb:           UncommonDistributions.rNorm(my, sd)})));
1:73c5336:     }
1:d41b360:   }
1:0de31cb:   
1:d41b360:   private void generateSamples() {
1:d41b360:     generateSamples(500, 1, 1, 3);
1:d41b360:     generateSamples(300, 1, 0, 0.5);
1:d41b360:     generateSamples(300, 0, 2, 0.1);
1:d41b360:   }
1:0de31cb:   
1:229aeff:   private void printRepPoints(int numIterations) {
1:e69bcbd:     RepresentativePointsDriver.printRepresentativePoints(output, numIterations);
9:c8270dc:   }
1:0de31cb:   
1:c8270dc:   /**
1:73c5336:    * Initialize synthetic data using 4 clusters dC units from origin having 4 representative points dP from each center
1:0de31cb:    * 
1:0de31cb:    * @param dC
1:0de31cb:    *          a double cluster center offset
1:0de31cb:    * @param dP
1:0de31cb:    *          a double representative point offset
1:0de31cb:    * @param measure
1:0de31cb:    *          the DistanceMeasure
1:c8270dc:    */
1:c8270dc:   private void initData(double dC, double dP, DistanceMeasure measure) {
1:74f849b:     clusters = Lists.newArrayList();
1:73c5336:     clusters.add(new Canopy(new DenseVector(new double[] {-dC, -dC}), 1, measure));
1:73c5336:     clusters.add(new Canopy(new DenseVector(new double[] {-dC, dC}), 3, measure));
1:73c5336:     clusters.add(new Canopy(new DenseVector(new double[] {dC, dC}), 5, measure));
1:73c5336:     clusters.add(new Canopy(new DenseVector(new double[] {dC, -dC}), 7, measure));
1:74f849b:     representativePoints = Maps.newHashMap();
1:c8270dc:     for (Cluster cluster : clusters) {
1:74f849b:       List<VectorWritable> points = Lists.newArrayList();
1:c8270dc:       representativePoints.put(cluster.getId(), points);
1:c8270dc:       points.add(new VectorWritable(cluster.getCenter().clone()));
1:73c5336:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {dP, dP}))));
1:73c5336:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {dP, -dP}))));
1:73c5336:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {-dP, -dP}))));
1:73c5336:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {-dP, dP}))));
1:c8270dc:     }
1:c8270dc:   }
1:88bddb0: 
3:c8270dc:   @Test
1:1ce47b6:   public void testRepresentativePoints() throws Exception {
1:73c5336:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:1ce47b6:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:e3ec9d8:     Configuration conf = getConfiguration();
1:1ce47b6:     // run using MR reference point calculation
1:f99a18f:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, 0.0, true);
1:1ce47b6:     int numIterations = 2;
1:9d44881:     Path clustersIn = new Path(output, "clusters-0-final");
2:73c5336:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure,
1:73c5336:         numIterations, false);
2:73c5336:     printRepPoints(numIterations);
1:1ce47b6:     ClusterEvaluator evaluatorMR = new ClusterEvaluator(conf, clustersIn);
1:1ce47b6:     // now run again using sequential reference point calculation
1:a13b4b7:     HadoopUtil.delete(conf, output);
1:f99a18f:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, 0.0, true);
1:73c5336:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure,
3:73c5336:         numIterations, true);
1:73c5336:     printRepPoints(numIterations);
1:1ce47b6:     ClusterEvaluator evaluatorSeq = new ClusterEvaluator(conf, clustersIn);
1:1ce47b6:     // compare results
1:73c5336:     assertEquals("InterCluster Density", evaluatorMR.interClusterDensity(), evaluatorSeq.interClusterDensity(), EPSILON);
1:73c5336:     assertEquals("IntraCluster Density", evaluatorMR.intraClusterDensity(), evaluatorSeq.intraClusterDensity(), EPSILON);
1:1ce47b6:   }
1:0de31cb:   
1:1ce47b6:   @Test
1:d41b360:   public void testCluster0() throws IOException {
1:73c5336:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
2:c8270dc:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:c8270dc:     initData(1, 0.25, measure);
1:73c5336:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
4:73c5336:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
1:73c5336:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:c8270dc:   }
1:0de31cb:   
1:c8270dc:   @Test
1:d41b360:   public void testCluster1() throws IOException {
1:73c5336:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:c8270dc:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:c8270dc:     initData(1, 0.5, measure);
1:73c5336:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:73c5336:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
1:73c5336:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:c8270dc:   }
1:0de31cb:   
1:c8270dc:   @Test
1:d41b360:   public void testCluster2() throws IOException {
1:73c5336:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:c8270dc:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:c8270dc:     initData(1, 0.75, measure);
1:73c5336:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:73c5336:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
1:73c5336:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:c8270dc:   }
1:0de31cb:   
1:22b0c3d:   /**
1:22b0c3d:    * adding an empty cluster should modify the inter cluster density but not change the intra-cluster density as that
1:22b0c3d:    * cluster would have NaN as its intra-cluster density and NaN values are ignored by the evaluator
1:22b0c3d:    * 
1:22b0c3d:    * @throws IOException
1:22b0c3d:    */
1:c8270dc:   @Test
1:d41b360:   public void testEmptyCluster() throws IOException {
1:73c5336:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:c8270dc:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:c8270dc:     initData(1, 0.25, measure);
1:73c5336:     Canopy cluster = new Canopy(new DenseVector(new double[] {10, 10}), 19, measure);
1:c8270dc:     clusters.add(cluster);
1:74f849b:     List<VectorWritable> points = Lists.newArrayList();
1:c8270dc:     representativePoints.put(cluster.getId(), points);
1:73c5336:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:22b0c3d:     assertEquals("inter cluster density", 0.371534146934532, evaluator.interClusterDensity(), EPSILON);
1:73c5336:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:c8270dc:   }
1:0de31cb:   
1:22b0c3d:   /**
1:22b0c3d:    * adding an single-valued cluster should modify the inter cluster density but not change the intra-cluster density as
1:22b0c3d:    * that cluster would have NaN as its intra-cluster density and NaN values are ignored by the evaluator
1:22b0c3d:    * 
1:22b0c3d:    * @throws IOException
1:22b0c3d:    */
1:c8270dc:   @Test
1:d41b360:   public void testSingleValueCluster() throws IOException {
1:73c5336:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:c8270dc:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:c8270dc:     initData(1, 0.25, measure);
1:73c5336:     Canopy cluster = new Canopy(new DenseVector(new double[] {0, 0}), 19, measure);
1:c8270dc:     clusters.add(cluster);
1:74f849b:     List<VectorWritable> points = Lists.newArrayList();
1:73c5336:     points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {1, 1}))));
1:c8270dc:     representativePoints.put(cluster.getId(), points);
1:73c5336:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:22b0c3d:     assertEquals("inter cluster density", 0.3656854249492381, evaluator.interClusterDensity(), EPSILON);
1:73c5336:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:c8270dc:   }
1:0de31cb:   
1:c8270dc:   /**
1:73c5336:    * Representative points extraction will duplicate the cluster center if the cluster has no assigned points. These
1:22b0c3d:    * clusters are included in the inter-cluster density but their NaN intra-density values are ignored by the evaluator.
1:0de31cb:    * 
1:0de31cb:    * @throws IOException
1:c8270dc:    */
1:c8270dc:   @Test
1:d41b360:   public void testAllSameValueCluster() throws IOException {
1:73c5336:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:c8270dc:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:c8270dc:     initData(1, 0.25, measure);
1:73c5336:     Canopy cluster = new Canopy(new DenseVector(new double[] {0, 0}), 19, measure);
1:c8270dc:     clusters.add(cluster);
1:74f849b:     List<VectorWritable> points = Lists.newArrayList();
1:c8270dc:     points.add(new VectorWritable(cluster.getCenter()));
1:c8270dc:     points.add(new VectorWritable(cluster.getCenter()));
1:c8270dc:     points.add(new VectorWritable(cluster.getCenter()));
1:c8270dc:     representativePoints.put(cluster.getId(), points);
1:73c5336:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:22b0c3d:     assertEquals("inter cluster density", 0.3656854249492381, evaluator.interClusterDensity(), EPSILON);
1:73c5336:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:c8270dc:   }
1:0de31cb:   
1:c8270dc:   @Test
1:d41b360:   public void testCanopy() throws Exception {
3:73c5336:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
1:c8270dc:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:921e201:     Configuration conf = getConfiguration();
1:f99a18f:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, 0.0, true);
1:d41b360:     int numIterations = 10;
1:9d44881:     Path clustersIn = new Path(output, "clusters-0-final");
1:73c5336:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure,
1:22b0c3d:         numIterations, true);
1:22b0c3d:     //printRepPoints(numIterations);
3:c8270dc:     ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);
3:c8270dc:     // now print out the Results
3:73c5336:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
3:73c5336:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
1:c8270dc:   }
1:0de31cb:   
1:c8270dc:   @Test
1:c8270dc:   public void testKmeans() throws Exception {
1:73c5336:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
1:c8270dc:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:c8270dc:     // now run the Canopy job to prime kMeans canopies
1:921e201:     Configuration conf = getConfiguration();
1:f99a18f:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, false, 0.0, true);
1:73c5336:     // now run the KMeans job
1:ba81a93:     Path kmeansOutput = new Path(output, "kmeans");
1:8405928:     KMeansDriver.run(testdata, new Path(output, "clusters-0-final"), kmeansOutput, 0.001, 10, true, 0.0, true);
1:d41b360:     int numIterations = 10;
1:73c5336:     Path clustersIn = new Path(kmeansOutput, "clusters-2");
1:73c5336:     RepresentativePointsDriver.run(conf, clustersIn, new Path(kmeansOutput, "clusteredPoints"), kmeansOutput, measure,
1:73c5336:         numIterations, true);
1:e69bcbd:     RepresentativePointsDriver.printRepresentativePoints(kmeansOutput, numIterations);
1:c8270dc:     ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);
1:c8270dc:     // now print out the Results
1:73c5336:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
1:73c5336:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
1:c8270dc:   }
1:0de31cb:   
1:c8270dc:   @Test
1:c8270dc:   public void testFuzzyKmeans() throws Exception {
1:73c5336:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
1:c8270dc:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:c8270dc:     // now run the Canopy job to prime kMeans canopies
1:921e201:     Configuration conf = getConfiguration();
1:f99a18f:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, false, 0.0, true);
1:fd355fe:     Path fuzzyKMeansOutput = new Path(output, "fuzzyk");
2:c8270dc:     // now run the KMeans job
1:8405928:     FuzzyKMeansDriver.run(testdata, new Path(output, "clusters-0-final"), fuzzyKMeansOutput, 0.001, 10, 2,
1:73c5336:         true, true, 0, true);
1:d41b360:     int numIterations = 10;
1:73c5336:     Path clustersIn = new Path(fuzzyKMeansOutput, "clusters-4");
1:73c5336:     RepresentativePointsDriver.run(conf, clustersIn, new Path(fuzzyKMeansOutput, "clusteredPoints"), fuzzyKMeansOutput,
1:73c5336:         measure, numIterations, true);
1:e69bcbd:     RepresentativePointsDriver.printRepresentativePoints(fuzzyKMeansOutput, numIterations);
1:c8270dc:     ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);
1:c8270dc:     // now print out the Results
1:73c5336:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
1:73c5336:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
1:c8270dc:   }
1:0de31cb:   
1:c8270dc: }
============================================================================
author:Andrew Musselman
-------------------------------------------------------------------------------
commit:88bddb0
/////////////////////////////////////////////////////////////////////////
1: 
author:smarthi
-------------------------------------------------------------------------------
commit:8405928
/////////////////////////////////////////////////////////////////////////
1:     KMeansDriver.run(testdata, new Path(output, "clusters-0-final"), kmeansOutput, 0.001, 10, true, 0.0, true);
/////////////////////////////////////////////////////////////////////////
1:     FuzzyKMeansDriver.run(testdata, new Path(output, "clusters-0-final"), fuzzyKMeansOutput, 0.001, 10, 2,
author:sslavic
-------------------------------------------------------------------------------
commit:921e201
/////////////////////////////////////////////////////////////////////////
1:     conf = getConfiguration();
/////////////////////////////////////////////////////////////////////////
1:     Configuration conf = getConfiguration();
/////////////////////////////////////////////////////////////////////////
1:     Configuration conf = getConfiguration();
/////////////////////////////////////////////////////////////////////////
1:     Configuration conf = getConfiguration();
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:b60c909
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:dd56a29
/////////////////////////////////////////////////////////////////////////
0:     Path clustersIn = new Path(output, "clusters-8-final");
commit:de76182
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.clustering.kernel.IKernelProfile;
0: import org.apache.mahout.clustering.kernel.TriangularKernelProfile;
/////////////////////////////////////////////////////////////////////////
commit:74f849b
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.Lists;
1: import com.google.common.collect.Maps;
/////////////////////////////////////////////////////////////////////////
1:   private List<VectorWritable> referenceData = Lists.newArrayList();
1:   private final List<VectorWritable> sampleData = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:     clusters = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:     representativePoints = Maps.newHashMap();
1:       List<VectorWritable> points = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:     List<VectorWritable> points = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:     List<VectorWritable> points = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:     List<VectorWritable> points = Lists.newArrayList();
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:4ca6b86
/////////////////////////////////////////////////////////////////////////
0:     DirichletDriver.run(new Configuration(), testdata, output, description, 15, 5, 1.0, true, true, 0.0, true);
commit:8396a27
/////////////////////////////////////////////////////////////////////////
1:     log.info("Generating {} samples m=[{}, {}] sd={}", num, mx, my, sd);
commit:229aeff
/////////////////////////////////////////////////////////////////////////
1:   private void printRepPoints(int numIterations) {
commit:b0ccf74
/////////////////////////////////////////////////////////////////////////
0:     Path clustersIn = new Path(output, "clusters-7-final");
/////////////////////////////////////////////////////////////////////////
0:     Path clustersIn = new Path(output, "clusters-5-final");
commit:50fd693
commit:35032b8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.clustering.dirichlet.models.DistributionDescription;
/////////////////////////////////////////////////////////////////////////
0:     DistributionDescription description =
0:         new DistributionDescription(GaussianClusterDistribution.class.getName(),
0:                                     DenseVector.class.getName(),
0:                                     null,
0:                                     2);
0:     DirichletDriver.run(testdata, output, description, 15, 5, 1.0, true, true, 0, true);
commit:a13b4b7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.common.Pair;
0: import org.apache.mahout.common.iterator.sequencefile.PathFilters;
0: import org.apache.mahout.common.iterator.sequencefile.PathType;
0: import org.apache.mahout.common.iterator.sequencefile.SequenceFileDirIterable;
/////////////////////////////////////////////////////////////////////////
0:       for (Pair<IntWritable,VectorWritable> record :
0:            new SequenceFileDirIterable<IntWritable,VectorWritable>(
0:                out, PathType.LIST, PathFilters.logsCRCFilter(), null, true, conf)) {
0:         System.out.println("\tC-" + record.getFirst().get()
0:                            + ": " + AbstractCluster.formatVector(record.getSecond().get(), null));
/////////////////////////////////////////////////////////////////////////
1:     HadoopUtil.delete(conf, output);
commit:049e7dc
/////////////////////////////////////////////////////////////////////////
0:   private final List<VectorWritable> sampleData = new ArrayList<VectorWritable>();
author:Isabel Drost
-------------------------------------------------------------------------------
commit:e3ec9d8
/////////////////////////////////////////////////////////////////////////
1:     Configuration conf = getConfiguration();
author:Jeff Eastman
-------------------------------------------------------------------------------
commit:22b0c3d
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * adding an empty cluster should modify the inter cluster density but not change the intra-cluster density as that
1:    * cluster would have NaN as its intra-cluster density and NaN values are ignored by the evaluator
1:    * 
1:    * @throws IOException
1:    */
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("inter cluster density", 0.371534146934532, evaluator.interClusterDensity(), EPSILON);
1:   /**
1:    * adding an single-valued cluster should modify the inter cluster density but not change the intra-cluster density as
1:    * that cluster would have NaN as its intra-cluster density and NaN values are ignored by the evaluator
1:    * 
1:    * @throws IOException
1:    */
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("inter cluster density", 0.3656854249492381, evaluator.interClusterDensity(), EPSILON);
1:    * clusters are included in the inter-cluster density but their NaN intra-density values are ignored by the evaluator.
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("inter cluster density", 0.3656854249492381, evaluator.interClusterDensity(), EPSILON);
/////////////////////////////////////////////////////////////////////////
1:         numIterations, true);
1:     //printRepPoints(numIterations);
/////////////////////////////////////////////////////////////////////////
0:     //printRepPoints(numIterations);
/////////////////////////////////////////////////////////////////////////
0:     //printRepPoints(numIterations);
commit:e69bcbd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Lists;
0: import com.google.common.collect.Maps;
1: 
/////////////////////////////////////////////////////////////////////////
1:     RepresentativePointsDriver.printRepresentativePoints(output, numIterations);
/////////////////////////////////////////////////////////////////////////
1:     RepresentativePointsDriver.printRepresentativePoints(kmeansOutput, numIterations);
/////////////////////////////////////////////////////////////////////////
1:     RepresentativePointsDriver.printRepresentativePoints(fuzzyKMeansOutput, numIterations);
commit:73c5336
/////////////////////////////////////////////////////////////////////////
1:   private static final double[][] REFERENCE = { {1, 1}, {2, 1}, {1, 2}, {2, 2}, {3, 3}, {4, 4}, {5, 4}, {4, 5}, {5, 5}};
/////////////////////////////////////////////////////////////////////////
1:   private static final Logger log = LoggerFactory.getLogger(TestClusterEvaluator.class);
/////////////////////////////////////////////////////////////////////////
0:     log.info("Generating {} samples m=[{}, {}] sd={}", new Object[] {num, mx, my, sd});
1:       sampleData.add(new VectorWritable(new DenseVector(new double[] {UncommonDistributions.rNorm(mx, sd),
/////////////////////////////////////////////////////////////////////////
0:     printRepPoints(output, numIterations);
1:   }
1:   
0:   private void printRepPoints(Path output, int numIterations) throws IOException {
0:       Path out = new Path(output, "representativePoints-" + i);
0:       for (Pair<IntWritable,VectorWritable> record : new SequenceFileDirIterable<IntWritable,VectorWritable>(out,
0:           PathType.LIST, PathFilters.logsCRCFilter(), null, true, conf)) {
/////////////////////////////////////////////////////////////////////////
1:    * Initialize synthetic data using 4 clusters dC units from origin having 4 representative points dP from each center
/////////////////////////////////////////////////////////////////////////
1:     clusters.add(new Canopy(new DenseVector(new double[] {-dC, -dC}), 1, measure));
1:     clusters.add(new Canopy(new DenseVector(new double[] {-dC, dC}), 3, measure));
1:     clusters.add(new Canopy(new DenseVector(new double[] {dC, dC}), 5, measure));
1:     clusters.add(new Canopy(new DenseVector(new double[] {dC, -dC}), 7, measure));
1:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {dP, dP}))));
1:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {dP, -dP}))));
1:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {-dP, -dP}))));
1:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {-dP, dP}))));
1:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure,
1:         numIterations, false);
1:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure,
1:         numIterations, true);
1:     assertEquals("InterCluster Density", evaluatorMR.interClusterDensity(), evaluatorSeq.interClusterDensity(), EPSILON);
1:     assertEquals("IntraCluster Density", evaluatorMR.intraClusterDensity(), evaluatorSeq.intraClusterDensity(), EPSILON);
1:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
1:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
1:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
1:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:     Canopy cluster = new Canopy(new DenseVector(new double[] {10, 10}), 19, measure);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
1:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:     Canopy cluster = new Canopy(new DenseVector(new double[] {0, 0}), 19, measure);
1:     points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] {1, 1}))));
1:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
1:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:    * Representative points extraction will duplicate the cluster center if the cluster has no assigned points. These
0:    * clusters should be ignored like empty clusters above
1:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:     Canopy cluster = new Canopy(new DenseVector(new double[] {0, 0}), 19, measure);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
1:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
1:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
1:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure,
1:         numIterations, true);   
1:     printRepPoints(numIterations);
1:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
1:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
1:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
0:     KMeansDriver.run(testdata, new Path(output, "clusters-0-final"), kmeansOutput, measure, 0.001, 10, true, 0.0, true);
1:     Path clustersIn = new Path(kmeansOutput, "clusters-2");
1:     RepresentativePointsDriver.run(conf, clustersIn, new Path(kmeansOutput, "clusteredPoints"), kmeansOutput, measure,
1:         numIterations, true);
0:     printRepPoints(kmeansOutput, numIterations);
1:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
1:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
1:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
1:     // now run the KMeans job
0:     FuzzyKMeansDriver.run(testdata, new Path(output, "clusters-0-final"), fuzzyKMeansOutput, measure, 0.001, 10, 2,
1:         true, true, 0, true);
1:     Path clustersIn = new Path(fuzzyKMeansOutput, "clusters-4");
1:     RepresentativePointsDriver.run(conf, clustersIn, new Path(fuzzyKMeansOutput, "clusteredPoints"), fuzzyKMeansOutput,
1:         measure, numIterations, true);
0:     printRepPoints(fuzzyKMeansOutput, numIterations);
1:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
1:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
1:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
0:     MeanShiftCanopyDriver.run(conf, testdata, output, measure, kernelProfile, 2.1, 1.0, 0.001, 10, false, true, true);
1:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure,
1:         numIterations, true);
1:     printRepPoints(numIterations);
1:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
1:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
1:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
0:     DistributionDescription description = new DistributionDescription(GaussianClusterDistribution.class.getName(),
0:     DirichletDriver.run(new Configuration(), testdata, output, description, 15, 5, 1.0, true, true, (double) 0, true);
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output,
0:         new EuclideanDistanceMeasure(), numIterations, true);
1:     printRepPoints(numIterations);
1:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
1:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
commit:590ffed
/////////////////////////////////////////////////////////////////////////
0:     DirichletDriver.run(new Configuration(), testdata, output, description, 15, 5, 1.0, true,
0:     true, (double) 0, true);
commit:9d44881
/////////////////////////////////////////////////////////////////////////
1:     Path clustersIn = new Path(output, "clusters-0-final");
/////////////////////////////////////////////////////////////////////////
1:     Path clustersIn = new Path(output, "clusters-0-final");
/////////////////////////////////////////////////////////////////////////
0:     KMeansDriver.run(testdata, new Path(output, "clusters-0-final"), output, measure,
/////////////////////////////////////////////////////////////////////////
0:     FuzzyKMeansDriver.run(testdata, new Path(output, "clusters-0-final"), output,
commit:0de31cb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.common.kernel.IKernelProfile;
0: import org.apache.mahout.common.kernel.TriangularKernelProfile;
/////////////////////////////////////////////////////////////////////////
1:   
0:   private static final double[][] REFERENCE = { {1, 1}, {2, 1}, {1, 2}, {2, 2},
0:       {3, 3}, {4, 4}, {5, 4}, {4, 5}, {5, 5}};
1:   
1:   
1:   
1:   private Map<Integer,List<VectorWritable>> representativePoints;
1:   
1:   
0:   private static final Logger log = LoggerFactory
0:       .getLogger(TestClusterEvaluator.class);
1:   
1:   
1:   
1:   
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
0:     log.info("Generating {} samples m=[{}, {}] sd={}", new Object[] {num, mx,
0:         my, sd});
0:       sampleData.add(new VectorWritable(new DenseVector(new double[] {
0:           UncommonDistributions.rNorm(mx, sd),
1:           UncommonDistributions.rNorm(my, sd)})));
1:   
1:   
0:       Path out = new Path(getTestTempDirPath("output"), "representativePoints-"
0:           + i);
0:       for (Pair<IntWritable,VectorWritable> record : new SequenceFileDirIterable<IntWritable,VectorWritable>(
0:           out, PathType.LIST, PathFilters.logsCRCFilter(), null, true, conf)) {
0:         System.out.println("\tC-" + record.getFirst().get() + ": "
0:             + AbstractCluster.formatVector(record.getSecond().get(), null));
1:   
0:    * Initialize synthetic data using 4 clusters dC units from origin having 4
0:    * representative points dP from each center
1:    * 
1:    * @param dC
1:    *          a double cluster center offset
1:    * @param dP
1:    *          a double representative point offset
1:    * @param measure
1:    *          the DistanceMeasure
0:     clusters.add(new Canopy(new DenseVector(new double[] {-dC, -dC}), 1,
0:         measure));
0:     clusters
0:         .add(new Canopy(new DenseVector(new double[] {-dC, dC}), 3, measure));
0:     clusters
0:         .add(new Canopy(new DenseVector(new double[] {dC, dC}), 5, measure));
0:     clusters
0:         .add(new Canopy(new DenseVector(new double[] {dC, -dC}), 7, measure));
0:     representativePoints = new HashMap<Integer,List<VectorWritable>>();
0:       points.add(new VectorWritable(cluster.getCenter().plus(
0:           new DenseVector(new double[] {dP, dP}))));
0:       points.add(new VectorWritable(cluster.getCenter().plus(
0:           new DenseVector(new double[] {dP, -dP}))));
0:       points.add(new VectorWritable(cluster.getCenter().plus(
0:           new DenseVector(new double[] {-dP, -dP}))));
0:       points.add(new VectorWritable(cluster.getCenter().plus(
0:           new DenseVector(new double[] {-dP, dP}))));
1:   
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata,
0:         "file1"), fs, conf);
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output,
0:         "clusteredPoints"), output, measure, numIterations, false);
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output,
0:         "clusteredPoints"), output, measure, numIterations, true);
0:     assertEquals("InterCluster Density", evaluatorMR.interClusterDensity(),
0:         evaluatorSeq.interClusterDensity(), EPSILON);
0:     assertEquals("IntraCluster Density", evaluatorMR.intraClusterDensity(),
0:         evaluatorSeq.intraClusterDensity(), EPSILON);
1:   
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata,
0:         "file1"), fs, conf);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints,
0:         clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315,
0:         evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381,
0:         evaluator.intraClusterDensity(), EPSILON);
1:   
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata,
0:         "file1"), fs, conf);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints,
0:         clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315,
0:         evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381,
0:         evaluator.intraClusterDensity(), EPSILON);
1:   
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata,
0:         "file1"), fs, conf);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints,
0:         clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315,
0:         evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381,
0:         evaluator.intraClusterDensity(), EPSILON);
1:   
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata,
0:         "file1"), fs, conf);
0:     Canopy cluster = new Canopy(new DenseVector(new double[] {10, 10}), 19,
0:         measure);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints,
0:         clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315,
0:         evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381,
0:         evaluator.intraClusterDensity(), EPSILON);
1:   
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata,
0:         "file1"), fs, conf);
0:     Canopy cluster = new Canopy(new DenseVector(new double[] {0, 0}), 19,
0:         measure);
0:     points.add(new VectorWritable(cluster.getCenter().plus(
0:         new DenseVector(new double[] {1, 1}))));
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints,
0:         clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315,
0:         evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381,
0:         evaluator.intraClusterDensity(), EPSILON);
1:   
0:    * Representative points extraction will duplicate the cluster center if the
0:    * cluster has no assigned points. These clusters should be ignored like empty
0:    * clusters above
1:    * 
1:    * @throws IOException
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata,
0:         "file1"), fs, conf);
0:     Canopy cluster = new Canopy(new DenseVector(new double[] {0, 0}), 19,
0:         measure);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints,
0:         clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315,
0:         evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381,
0:         evaluator.intraClusterDensity(), EPSILON);
1:   
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata,
0:         "file1"), fs, conf);
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output,
0:         "clusteredPoints"), output, measure, numIterations, true);
0:     System.out.println("Intra-cluster density = "
0:         + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = "
0:         + evaluator.interClusterDensity());
1:     
1:   
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata,
0:         "file1"), fs, conf);
0:     KMeansDriver.run(testdata, new Path(output, "clusters-0"), output, measure,
0:         0.001, 10, true, true);
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output,
0:         "clusteredPoints"), output, measure, numIterations, true);
0:     System.out.println("Intra-cluster density = "
0:         + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = "
0:         + evaluator.interClusterDensity());
1:   
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata,
0:         "file1"), fs, conf);
0:     FuzzyKMeansDriver.run(testdata, new Path(output, "clusters-0"), output,
0:         measure, 0.001, 10, 2, true, true, 0, true);
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output,
0:         "clusteredPoints"), output, measure, numIterations, true);
0:     System.out.println("Intra-cluster density = "
0:         + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = "
0:         + evaluator.interClusterDensity());
1:   
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata,
0:         "file1"), fs, conf);
0:     IKernelProfile kernelProfile = new TriangularKernelProfile();
0:     MeanShiftCanopyDriver.run(conf, testdata, output, measure, kernelProfile,
0:         2.1, 1.0, 0.001, 10, false, true, true);
0:     Path clustersIn = new Path(output, "clusters-7");
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output,
0:         "clusteredPoints"), output, measure, numIterations, true);
0:     System.out.println("Intra-cluster density = "
0:         + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = "
0:         + evaluator.interClusterDensity());
1:   
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata,
0:         "file1"), fs, conf);
0:     DistributionDescription description = new DistributionDescription(
0:         GaussianClusterDistribution.class.getName(),
0:         DenseVector.class.getName(), null, 2);
0:     DirichletDriver.run(testdata, output, description, 15, 5, 1.0, true, true,
0:         0, true);
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output,
0:         "clusteredPoints"), output, new EuclideanDistanceMeasure(),
0:         numIterations, true);
0:     System.out.println("Intra-cluster density = "
0:         + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = "
0:         + evaluator.interClusterDensity());
1:   
commit:1ce47b6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.common.HadoopUtil;
/////////////////////////////////////////////////////////////////////////
0:   private void printRepPoints(int numIterations) throws IOException {
0:       System.out.println("Representative Points for iteration " + i);
/////////////////////////////////////////////////////////////////////////
1:   public void testRepresentativePoints() throws Exception {
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
0:     Configuration conf = new Configuration();
1:     // run using MR reference point calculation
0:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, true);
1:     int numIterations = 2;
0:     Path clustersIn = new Path(output, "clusters-0");
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, false);
0:     printRepPoints(numIterations);
1:     ClusterEvaluator evaluatorMR = new ClusterEvaluator(conf, clustersIn);
1:     // now run again using sequential reference point calculation
0:     HadoopUtil.overwriteOutput(output);
0:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, true);
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, true);
0:     printRepPoints(numIterations);
1:     ClusterEvaluator evaluatorSeq = new ClusterEvaluator(conf, clustersIn);
1:     // compare results
0:     assertEquals("InterCluster Density", evaluatorMR.interClusterDensity(), evaluatorSeq.interClusterDensity(), EPSILON);
0:     assertEquals("IntraCluster Density", evaluatorMR.intraClusterDensity(), evaluatorSeq.intraClusterDensity(), EPSILON);
1:   }
0: 
1:   @Test
/////////////////////////////////////////////////////////////////////////
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, true);
0:     printRepPoints(numIterations);
/////////////////////////////////////////////////////////////////////////
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, true);
0:     printRepPoints(numIterations);
/////////////////////////////////////////////////////////////////////////
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, true);
0:     printRepPoints(numIterations);
/////////////////////////////////////////////////////////////////////////
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, true);
0:     printRepPoints(numIterations);
/////////////////////////////////////////////////////////////////////////
0:                                    numIterations,
0:                                    true);
0:     printRepPoints(numIterations);
commit:d41b360
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.clustering.dirichlet.UncommonDistributions;
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0:   private List<VectorWritable> referenceData = new ArrayList<VectorWritable>();
0: 
0:   private List<VectorWritable> sampleData = new ArrayList<VectorWritable>();
0: 
0:   private static final Logger log = LoggerFactory.getLogger(TestClusterEvaluator.class);
0: 
1:   private Configuration conf;
0: 
1:   private FileSystem fs;
0: 
1:   private Path testdata;
0: 
1:   private Path output;
0: 
0:     conf = new Configuration();
1:     fs = FileSystem.get(conf);
1:     testdata = getTestTempDirPath("testdata");
1:     output = getTestTempDirPath("output");
1:     // Create small reference data set
1:     referenceData = TestKmeansClustering.getPointsWritable(REFERENCE);
1:     // generate larger test data set for the clustering tests to chew on
1:     generateSamples();
1:   }
0: 
1:   /**
1:    * Generate random samples and add them to the sampleData
1:    * 
1:    * @param num
1:    *          int number of samples to generate
1:    * @param mx
1:    *          double x-value of the sample mean
1:    * @param my
1:    *          double y-value of the sample mean
1:    * @param sd
1:    *          double standard deviation of the samples
1:    */
1:   private void generateSamples(int num, double mx, double my, double sd) {
0:     log.info("Generating {} samples m=[{}, {}] sd={}", new Object[] { num, mx, my, sd });
1:     for (int i = 0; i < num; i++) {
0:       sampleData.add(new VectorWritable(new DenseVector(new double[] { UncommonDistributions.rNorm(mx, sd),
0:           UncommonDistributions.rNorm(my, sd) })));
1:     }
1:   }
0: 
1:   private void generateSamples() {
1:     generateSamples(500, 1, 1, 3);
1:     generateSamples(300, 1, 0, 0.5);
1:     generateSamples(300, 0, 2, 0.1);
/////////////////////////////////////////////////////////////////////////
1:   public void testCluster0() throws IOException {
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
/////////////////////////////////////////////////////////////////////////
1:   public void testCluster1() throws IOException {
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
/////////////////////////////////////////////////////////////////////////
1:   public void testCluster2() throws IOException {
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
/////////////////////////////////////////////////////////////////////////
1:   public void testEmptyCluster() throws IOException {
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
/////////////////////////////////////////////////////////////////////////
1:   public void testSingleValueCluster() throws IOException {
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
/////////////////////////////////////////////////////////////////////////
0:    * @throws IOException 
1:   public void testAllSameValueCluster() throws IOException {
0:     ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);
/////////////////////////////////////////////////////////////////////////
1:   public void testCanopy() throws Exception {
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
0:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, true);
1:     int numIterations = 10;
/////////////////////////////////////////////////////////////////////////
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
0:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, false, true);
0:     KMeansDriver.run(testdata, new Path(output, "clusters-0"), output, measure, 0.001, 10, true, true);
1:     int numIterations = 10;
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations);
/////////////////////////////////////////////////////////////////////////
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
0:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, false, true);
0:     FuzzyKMeansDriver.run(testdata, new Path(output, "clusters-0"), output, measure, 0.001, 10, 2, true, true, 0, true);
1:     int numIterations = 10;
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations);
/////////////////////////////////////////////////////////////////////////
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
0:     new MeanShiftCanopyDriver().run(conf, testdata, output, measure, 2.1, 1.0, 0.001, 10, false, true, true);
0:     int numIterations = 10;
0:     Path clustersIn = new Path(output, "clusters-10");
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations);
/////////////////////////////////////////////////////////////////////////
0:     ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);
0:     DirichletDriver.run(testdata, output, modelDistribution, 15, 5, 1.0, true, true, 0, true);
0:     int numIterations = 10;
commit:c4a0cb9
/////////////////////////////////////////////////////////////////////////
0:     Configuration conf = new Configuration();
0:     new MeanShiftCanopyDriver().run(conf,
0:                                     getTestTempDirPath("testdata"),
/////////////////////////////////////////////////////////////////////////
0:                                     true, false);
commit:c8270dc
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
1: package org.apache.mahout.clustering;
0: 
1: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
0: 
1: import org.apache.hadoop.conf.Configuration;
0: import org.apache.hadoop.fs.FileStatus;
1: import org.apache.hadoop.fs.FileSystem;
1: import org.apache.hadoop.fs.Path;
0: import org.apache.hadoop.io.IntWritable;
0: import org.apache.hadoop.io.SequenceFile;
0: import org.apache.hadoop.io.Writable;
1: import org.apache.mahout.clustering.canopy.Canopy;
1: import org.apache.mahout.clustering.canopy.CanopyDriver;
0: import org.apache.mahout.clustering.dirichlet.DirichletDriver;
0: import org.apache.mahout.clustering.dirichlet.models.GaussianClusterDistribution;
1: import org.apache.mahout.clustering.evaluation.ClusterEvaluator;
1: import org.apache.mahout.clustering.evaluation.RepresentativePointsDriver;
1: import org.apache.mahout.clustering.fuzzykmeans.FuzzyKMeansDriver;
1: import org.apache.mahout.clustering.kmeans.KMeansDriver;
1: import org.apache.mahout.clustering.kmeans.TestKmeansClustering;
0: import org.apache.mahout.clustering.meanshift.MeanShiftCanopyDriver;
1: import org.apache.mahout.common.MahoutTestCase;
1: import org.apache.mahout.common.distance.DistanceMeasure;
1: import org.apache.mahout.common.distance.EuclideanDistanceMeasure;
1: import org.apache.mahout.math.DenseVector;
1: import org.apache.mahout.math.VectorWritable;
1: import org.junit.Before;
1: import org.junit.Test;
0: 
1: public final class TestClusterEvaluator extends MahoutTestCase {
0: 
0:   private static final double[][] REFERENCE = { { 1, 1 }, { 2, 1 }, { 1, 2 }, { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 4 }, { 4, 5 },
0:       { 5, 5 } };
0: 
0:   private Map<Integer, List<VectorWritable>> representativePoints;
0: 
1:   private List<Cluster> clusters;
0: 
1:   @Override
1:   @Before
1:   public void setUp() throws Exception {
1:     super.setUp();
0:     Configuration conf = new Configuration();
0:     FileSystem fs = FileSystem.get(conf);
0:     // Create test data
0:     List<VectorWritable> sampleData = TestKmeansClustering.getPointsWritable(REFERENCE);
0:     ClusteringTestUtils.writePointsToFile(sampleData, getTestTempFilePath("testdata/file1"), fs, conf);
1:   }
0: 
0:   private void checkRefPoints(int numIterations) throws IOException {
0:     for (int i = 0; i <= numIterations; i++) {
0:       Path out = new Path(getTestTempDirPath("output"), "representativePoints-" + i);
0:       Configuration conf = new Configuration();
0:       FileSystem fs = FileSystem.get(conf);
0:       for (FileStatus file : fs.listStatus(out)) {
0:         if (!file.getPath().getName().startsWith(".")) {
0:           SequenceFile.Reader reader = new SequenceFile.Reader(fs, file.getPath(), conf);
0:           try {
0:             Writable clusterId = new IntWritable(0);
0:             VectorWritable point = new VectorWritable();
0:             while (reader.next(clusterId, point)) {
0:               System.out.println("\tC-" + clusterId + ": " + AbstractCluster.formatVector(point.get(), null));
1:             }
0:           } finally {
0:             reader.close();
1:           }
1:         }
1:       }
1:     }
1:   }
0: 
1:   /**
0:    * Initialize synthetic data using 4 clusters dC units from origin having 4 representative points dP from each center
0:    * @param dC a double cluster center offset
0:    * @param dP a double representative point offset
0:    * @param measure the DistanceMeasure
1:    */
1:   private void initData(double dC, double dP, DistanceMeasure measure) {
0:     clusters = new ArrayList<Cluster>();
0:     clusters.add(new Canopy(new DenseVector(new double[] { -dC, -dC }), 1, measure));
0:     clusters.add(new Canopy(new DenseVector(new double[] { -dC, dC }), 3, measure));
0:     clusters.add(new Canopy(new DenseVector(new double[] { dC, dC }), 5, measure));
0:     clusters.add(new Canopy(new DenseVector(new double[] { dC, -dC }), 7, measure));
0:     representativePoints = new HashMap<Integer, List<VectorWritable>>();
1:     for (Cluster cluster : clusters) {
0:       List<VectorWritable> points = new ArrayList<VectorWritable>();
1:       representativePoints.put(cluster.getId(), points);
1:       points.add(new VectorWritable(cluster.getCenter().clone()));
0:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { dP, dP }))));
0:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { dP, -dP }))));
0:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { -dP, -dP }))));
0:       points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { -dP, dP }))));
1:     }
1:   }
0: 
1:   @Test
0:   public void testCluster0() {
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:     initData(1, 0.25, measure);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:   }
0: 
1:   @Test
0:   public void testCluster1() {
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:     initData(1, 0.5, measure);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:   }
0: 
1:   @Test
0:   public void testCluster2() {
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:     initData(1, 0.75, measure);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:   }
0: 
1:   @Test
0:   public void testEmptyCluster() {
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:     initData(1, 0.25, measure);
0:     Canopy cluster = new Canopy(new DenseVector(new double[] { 10, 10 }), 19, measure);
1:     clusters.add(cluster);
0:     List<VectorWritable> points = new ArrayList<VectorWritable>();
1:     representativePoints.put(cluster.getId(), points);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:   }
0: 
1:   @Test
0:   public void testSingleValueCluster() {
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:     initData(1, 0.25, measure);
0:     Canopy cluster = new Canopy(new DenseVector(new double[] { 0, 0 }), 19, measure);
1:     clusters.add(cluster);
0:     List<VectorWritable> points = new ArrayList<VectorWritable>();
0:     points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { 1, 1 }))));
1:     representativePoints.put(cluster.getId(), points);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:   }
0: 
1:   /**
0:    * Representative points extraction will duplicate the cluster center if the cluster has no 
0:    * assigned points. These clusters should be ignored like empty clusters above
1:    */
1:   @Test
0:   public void testAllSameValueCluster() {
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:     initData(1, 0.25, measure);
0:     Canopy cluster = new Canopy(new DenseVector(new double[] { 0, 0 }), 19, measure);
1:     clusters.add(cluster);
0:     List<VectorWritable> points = new ArrayList<VectorWritable>();
1:     points.add(new VectorWritable(cluster.getCenter()));
1:     points.add(new VectorWritable(cluster.getCenter()));
1:     points.add(new VectorWritable(cluster.getCenter()));
1:     representativePoints.put(cluster.getId(), points);
0:     ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);
0:     assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);
0:     assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);
1:   }
0: 
1:   @Test
0:   public void testCanopy() throws Exception { // now run the Job
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
0:     Configuration conf = new Configuration();
0:     CanopyDriver.run(conf, getTestTempDirPath("testdata"), getTestTempDirPath("output"), measure, 3.1, 2.1, true, false);
0:     int numIterations = 2;
0:     Path output = getTestTempDirPath("output");
0:     Path clustersIn = new Path(output, "clusters-0");
0:     RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);
1:     // now print out the Results
0:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
0: 
0:     checkRefPoints(numIterations);
1:   }
0: 
1:   @Test
1:   public void testKmeans() throws Exception {
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:     // now run the Canopy job to prime kMeans canopies
0:     Configuration conf = new Configuration();
0:     CanopyDriver.run(conf,
0:                      getTestTempDirPath("testdata"),
0:                      getTestTempDirPath("output"),
0:                      measure,
0:                      3.1,
0:                      2.1,
0:                      false,
0:                      false);
1:     // now run the KMeans job
0:     Path output = getTestTempDirPath("output");
0:     KMeansDriver.run(getTestTempDirPath("testdata"), new Path(output, "clusters-0"), output, measure, 0.001, 10, true, false);
0:     int numIterations = 2;
0:     Path clustersIn = new Path(output, "clusters-2");
0:     RepresentativePointsDriver.run(conf,
0:                                    clustersIn,
0:                                    new Path(output, "clusteredPoints"),
0:                                    output,
0:                                    measure,
0:                                    numIterations);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);
1:     // now print out the Results
0:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
0:     checkRefPoints(numIterations);
1:   }
0: 
1:   @Test
1:   public void testFuzzyKmeans() throws Exception {
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
1:     // now run the Canopy job to prime kMeans canopies
0:     Configuration conf = new Configuration();
0:     CanopyDriver.run(conf,
0:                      getTestTempDirPath("testdata"),
0:                      getTestTempDirPath("output"),
0:                      measure,
0:                      3.1,
0:                      2.1,
0:                      false,
0:                      false);
1:     // now run the KMeans job
0:     Path output = getTestTempDirPath("output");
0:     FuzzyKMeansDriver.run(getTestTempDirPath("testdata"),
0:                           new Path(output, "clusters-0"),
0:                           output,
0:                           measure,
0:                           0.001,
0:                           10,
0:                           2,
0:                           true,
0:                           true,
0:                           0,
0:                           false);
0:     int numIterations = 2;
0:     Path clustersIn = new Path(output, "clusters-4");
0:     RepresentativePointsDriver.run(conf,
0:                                    clustersIn,
0:                                    new Path(output, "clusteredPoints"),
0:                                    output,
0:                                    measure,
0:                                    numIterations);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);
1:     // now print out the Results
0:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
0:     checkRefPoints(numIterations);
1:   }
0: 
1:   @Test
0:   public void testMeanShift() throws Exception {
1:     DistanceMeasure measure = new EuclideanDistanceMeasure();
0:     new MeanShiftCanopyDriver().run(getTestTempDirPath("testdata"),
0:                                     getTestTempDirPath("output"),
0:                                     measure,
0:                                     2.1,
0:                                     1.0,
0:                                     0.001,
0:                                     10,
0:                                     false,
0:                                     true,
0:                                     false);
0:     int numIterations = 2;
0:     Path output = getTestTempDirPath("output");
0:     Configuration conf = new Configuration();
0:     Path clustersIn = new Path(output, "clusters-2");
0:     RepresentativePointsDriver.run(conf,
0:                                    clustersIn,
0:                                    new Path(output, "clusteredPoints"),
0:                                    output,
0:                                    measure,
0:                                    numIterations);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);
1:     // now print out the Results
0:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
0:     checkRefPoints(numIterations);
1:   }
0: 
1:   @Test
0:   public void testDirichlet() throws Exception {
0:     ModelDistribution<VectorWritable> modelDistribution = new GaussianClusterDistribution(new VectorWritable(new DenseVector(2)));
0:     DirichletDriver.run(getTestTempDirPath("testdata"),
0:                         getTestTempDirPath("output"),
0:                         modelDistribution,
0:                         15,
0:                         5,
0:                         1.0,
0:                         true,
0:                         true,
0:                         0,
0:                         true);
0:     int numIterations = 2;
0:     Path output = getTestTempDirPath("output");
0:     Configuration conf = new Configuration();
0:     Path clustersIn = new Path(output, "clusters-5");
0:     RepresentativePointsDriver.run(conf,
0:                                    clustersIn,
0:                                    new Path(output, "clusteredPoints"),
0:                                    output,
0:                                    new EuclideanDistanceMeasure(),
0:                                    numIterations);
1:     ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);
1:     // now print out the Results
0:     System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());
0:     System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());
0:     checkRefPoints(numIterations);
1:   }
0: 
1: }
author:pranjan
-------------------------------------------------------------------------------
commit:fd355fe
/////////////////////////////////////////////////////////////////////////
1:     Path fuzzyKMeansOutput = new Path(output, "fuzzyk");
0: 	// now run the KMeans job
0:     FuzzyKMeansDriver.run(testdata, new Path(output, "clusters-0-final"), fuzzyKMeansOutput ,
0:         "clusteredPoints"), fuzzyKMeansOutput, measure, numIterations, true);
commit:2cfaf19
/////////////////////////////////////////////////////////////////////////
0:         0.001, 10, true, 0.0, true);
commit:ba81a93
/////////////////////////////////////////////////////////////////////////
1:     Path kmeansOutput = new Path(output, "kmeans");
0: 	KMeansDriver.run(testdata, new Path(output, "clusters-0-final"), kmeansOutput, measure,
0:         "clusteredPoints"), kmeansOutput, measure, numIterations, true);
commit:f99a18f
/////////////////////////////////////////////////////////////////////////
1:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, 0.0, true);
/////////////////////////////////////////////////////////////////////////
1:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, 0.0, true);
/////////////////////////////////////////////////////////////////////////
1:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, 0.0, true);
/////////////////////////////////////////////////////////////////////////
1:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, false, 0.0, true);
/////////////////////////////////////////////////////////////////////////
1:     CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, false, 0.0, true);
============================================================================