1:8a99d75: /**
1:8a99d75:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:8a99d75:  * contributor license agreements.  See the NOTICE file distributed with
1:8a99d75:  * this work for additional information regarding copyright ownership.
1:8a99d75:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:8a99d75:  * (the "License"); you may not use this file except in compliance with
1:8a99d75:  * the License.  You may obtain a copy of the License at
1:8a99d75:  *
1:8a99d75:  *     http://www.apache.org/licenses/LICENSE-2.0
1:8a99d75:  *
1:8a99d75:  * Unless required by applicable law or agreed to in writing, software
1:8a99d75:  * distributed under the License is distributed on an "AS IS" BASIS,
1:8a99d75:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8a99d75:  * See the License for the specific language governing permissions and
1:8a99d75:  * limitations under the License.
1:8a99d75:  */
1:8a99d75: 
1:a704e17: package org.apache.mahout.classifier.sgd;
1:8a99d75: 
1:1499411: import java.io.DataInput;
1:02f8694: import java.io.DataInputStream;
1:02f8694: import java.io.DataOutputStream;
1:02f8694: import java.io.FileOutputStream;
1:a704e17: import java.io.IOException;
1:02f8694: import java.io.InputStream;
4:58b5f28: 
1:87d4b2e: import com.google.common.io.Closeables;
1:87d4b2e: import org.apache.hadoop.io.Writable;
1:87d4b2e: 
4:a704e17: /**
1:4641c87:  * Provides the ability to store SGD model-related objects as binary files.
4:a704e17:  */
1:8a99d75: public final class ModelSerializer {
1:8a99d75: 
1:a704e17:   // static class ... don't instantiate
1:a704e17:   private ModelSerializer() {
5:58b5f28:   }
1:02f8694: 
1:35032b8:   public static void writeBinary(String path, CrossFoldLearner model) throws IOException {
1:85f9ece:     try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path))) {
1:35032b8:       PolymorphicWritable.write(out, model);
1:02f8694:     }
1:02f8694:   }
1:02f8694: 
1:02f8694:   public static void writeBinary(String path, OnlineLogisticRegression model) throws IOException {
1:85f9ece:     try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path))) {
1:35032b8:       PolymorphicWritable.write(out, model);
1:35032b8:     }
1:02f8694:   }
1:02f8694: 
1:02f8694:   public static void writeBinary(String path, AdaptiveLogisticRegression model) throws IOException {
1:85f9ece:     try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path))){
1:35032b8:       PolymorphicWritable.write(out, model);
1:02f8694:     }
1:02f8694:   }
1:02f8694: 
1:02f8694:   public static <T extends Writable> T readBinary(InputStream in, Class<T> clazz) throws IOException {
1:1499411:     DataInput dataIn = new DataInputStream(in);
3:35032b8:     try {
1:35032b8:       return PolymorphicWritable.read(dataIn, clazz);
3:35032b8:     } finally {
1:87d4b2e:       Closeables.close(in, false);
1:35032b8:     }
1:8a99d75:   }
1:02f8694: 
1:58b5f28: 
1:58b5f28: }
============================================================================
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:85f9ece
/////////////////////////////////////////////////////////////////////////
1:     try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path))) {
1:     try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path))) {
1:     try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path))){
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:dfilimon
-------------------------------------------------------------------------------
commit:87d4b2e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.io.Closeables;
1: import org.apache.hadoop.io.Writable;
1: 
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(out, false);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(out, false);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(out, false);
/////////////////////////////////////////////////////////////////////////
1:       Closeables.close(in, false);
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:31cb292
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(out, true);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(out, true);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(out, true);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(in, true);
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:1499411
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataInput;
/////////////////////////////////////////////////////////////////////////
1:     DataInput dataIn = new DataInputStream(in);
commit:4641c87
/////////////////////////////////////////////////////////////////////////
1:  * Provides the ability to store SGD model-related objects as binary files.
commit:35032b8
/////////////////////////////////////////////////////////////////////////
1:   public static void writeBinary(String path, CrossFoldLearner model) throws IOException {
0:     DataOutputStream out = new DataOutputStream(new FileOutputStream(path));
1:       PolymorphicWritable.write(out, model);
0:     DataOutputStream out = new DataOutputStream(new FileOutputStream(path));
1:     try {
1:       PolymorphicWritable.write(out, model);
1:     } finally {
0:       out.close();
1:     }
0:     DataOutputStream out = new DataOutputStream(new FileOutputStream(path));
1:     try {
1:       PolymorphicWritable.write(out, model);
1:     } finally {
0:       out.close();
1:     }
0:     DataInputStream dataIn = new DataInputStream(in);
1:     try {
1:       return PolymorphicWritable.read(dataIn, clazz);
1:     } finally {
0:       dataIn.close();
commit:ad8b61d
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.InputStreamReader;
0: import java.io.Writer;
0: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
0:     Writer out = new OutputStreamWriter(new FileOutputStream(new File(path)), Charset.forName("UTF-8"));
/////////////////////////////////////////////////////////////////////////
0:     loadJsonFrom(new InputStreamReader(new FileInputStream(new File("/tmp/news-group-1000.model")),
0:                                        Charset.forName("UTF-8")),
0:                  OnlineLogisticRegression.class);
commit:61ae2e7
/////////////////////////////////////////////////////////////////////////
commit:5ce5992
/////////////////////////////////////////////////////////////////////////
0:       Type mapListType = new TypeToken<List<Mapping>>() {}.getType();
/////////////////////////////////////////////////////////////////////////
0:       Type stateType = new TypeToken<State<AdaptiveLogisticRegression.Wrapper>>() {}.getType();
0:       Type epType = new TypeToken<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>() {}.getType();
/////////////////////////////////////////////////////////////////////////
0:       r.add("ep", jsc.serialize(x.getEp(),
0:           new TypeToken<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>() {}.getType()));
0:       r.add("buffer", jsc.serialize(x.getBuffer(),
0:           new TypeToken<List<AdaptiveLogisticRegression.TrainingExample>>() {}.getType()));
0:       Type stateType = new TypeToken<State<AdaptiveLogisticRegression.Wrapper>>() {}.getType();
commit:8a99d75
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
0: import com.google.gson.Gson;
0: import com.google.gson.GsonBuilder;
0: import com.google.gson.InstanceCreator;
0: import com.google.gson.JsonArray;
0: import com.google.gson.JsonDeserializationContext;
0: import com.google.gson.JsonDeserializer;
0: import com.google.gson.JsonElement;
0: import com.google.gson.JsonObject;
0: import com.google.gson.JsonPrimitive;
0: import com.google.gson.JsonSerializationContext;
0: import com.google.gson.JsonSerializer;
/////////////////////////////////////////////////////////////////////////
0: import java.io.OutputStreamWriter;
/////////////////////////////////////////////////////////////////////////
1: public final class ModelSerializer {
1: 
/////////////////////////////////////////////////////////////////////////
0:     OutputStreamWriter out = new FileWriter(path);
0:     try {
0:       out.write(gson().toJson(model));
0:     } finally {
0:       out.close();
1:     }
/////////////////////////////////////////////////////////////////////////
0:     public Mapping deserialize(JsonElement jsonElement,
0:                                Type type,
0:                                JsonDeserializationContext jsonDeserializationContext) {
0:         return jsonDeserializationContext.deserialize(x.get("value"), Class.forName(x.get("class").getAsString()));
0:         throw new IllegalStateException("Can't understand serialized data, found bad type: "
0:             + x.get("class").getAsString());
/////////////////////////////////////////////////////////////////////////
0:     public PriorFunction deserialize(JsonElement jsonElement,
0:                                      Type type,
0:                                      JsonDeserializationContext jsonDeserializationContext) {
0:         return jsonDeserializationContext.deserialize(x.get("value"), Class.forName(x.get("class").getAsString()));
0:         throw new IllegalStateException("Can't understand serialized data, found bad type: "
0:             + x.get("class").getAsString());
0:     public JsonElement serialize(PriorFunction priorFunction,
0:                                  Type type,
0:                                  JsonSerializationContext jsonSerializationContext) {
/////////////////////////////////////////////////////////////////////////
0:     public CrossFoldLearner deserialize(JsonElement jsonElement,
0:                                         Type type,
0:                                         JsonDeserializationContext jsonDeserializationContext) {
/////////////////////////////////////////////////////////////////////////
0:         r.addModel(
0:             jsonDeserializationContext.<OnlineLogisticRegression>deserialize(model, OnlineLogisticRegression.class));
/////////////////////////////////////////////////////////////////////////
0:     public State<AdaptiveLogisticRegression.Wrapper> deserialize(
0:       JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) {
1: 
/////////////////////////////////////////////////////////////////////////
0:       r.setPayload(
0:           jsonDeserializationContext.<AdaptiveLogisticRegression.Wrapper>deserialize(
0:               v.get("payload"),
0:               AdaptiveLogisticRegression.Wrapper.class));
0:     public JsonElement serialize(State<AdaptiveLogisticRegression.Wrapper> state,
0:                                  Type type,
0:                                  JsonSerializationContext jsonSerializationContext) {
/////////////////////////////////////////////////////////////////////////
0:     public AdaptiveLogisticRegression deserialize(JsonElement element, Type type, JsonDeserializationContext jdc) {
0:       AdaptiveLogisticRegression r =
0:           new AdaptiveLogisticRegression(x.get("numCategories").getAsInt(),
0:                                          x.get("numFeatures").getAsInt(),
0:                                          jdc.<PriorFunction>deserialize(x.get("prior"), PriorFunction.class));
/////////////////////////////////////////////////////////////////////////
0:       r.setBuffer(jdc.<List<AdaptiveLogisticRegression.TrainingExample>>deserialize(x.get("buffer"),
0:                   new TypeToken<List<AdaptiveLogisticRegression.TrainingExample>>() {}.getType()));
/////////////////////////////////////////////////////////////////////////
0:   private static class EvolutionaryProcessTypeAdapter implements
0:     InstanceCreator<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>,
0:     private static final Type STATE_TYPE = new TypeToken<State<AdaptiveLogisticRegression.Wrapper>>() {}.getType();
/////////////////////////////////////////////////////////////////////////
0:     public EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper> deserialize(
0:         JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) {
0:       EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper> r =
0:           new EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>();
/////////////////////////////////////////////////////////////////////////
0:     public JsonElement serialize(EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper> x,
0:                                  Type type,
0:                                  JsonSerializationContext jsc) {
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:d608a88
/////////////////////////////////////////////////////////////////////////
0:       Closeables.closeQuietly(out);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.closeQuietly(out);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.closeQuietly(out);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.closeQuietly(in);
commit:96024a7
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.io.Closeables;
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(out, false);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(out, false);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(out, false);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(in, false);
author:Ted Dunning
-------------------------------------------------------------------------------
commit:02f8694
/////////////////////////////////////////////////////////////////////////
0: import org.apache.hadoop.io.Writable;
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataInputStream;
1: import java.io.DataOutputStream;
0: import java.io.FileNotFoundException;
1: import java.io.FileOutputStream;
0: import java.io.FileReader;
1: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
0:   public static <T> T loadJsonFrom(Reader in, Class<T> clazz) {
0:   public static void writeBinary(String path, CrossFoldLearner model) throws IOException {
0:     PolymorphicWritable.write(new DataOutputStream(new FileOutputStream(path)), model);
1:   }
1: 
1:   public static void writeBinary(String path, OnlineLogisticRegression model) throws IOException {
0:     PolymorphicWritable.write(new DataOutputStream(new FileOutputStream(path)), model);
1:   }
1: 
1:   public static void writeBinary(String path, AdaptiveLogisticRegression model) throws IOException {
0:     PolymorphicWritable.write(new DataOutputStream(new FileOutputStream(path)), model);
1:   }
1: 
1:   public static <T extends Writable> T readBinary(InputStream in, Class<T> clazz) throws IOException {
0:     return PolymorphicWritable.read(new DataInputStream(in), clazz);
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:       Type stateType = new TypeToken<State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>() {}.getType();
/////////////////////////////////////////////////////////////////////////
0:       Type epType = new TypeToken<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>() {}.getType();
0:       r.setEp(jdc.<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>deserialize(x.get("ep"), epType));
0:       r.setSeed(jdc.<State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>deserialize(x.get("seed"), stateType));
0:         r.setBest(jdc.<State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>deserialize(x.get("best"), stateType));
/////////////////////////////////////////////////////////////////////////
0:           new TypeToken<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>() {}.getType()));
0:       Type stateType = new TypeToken<State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>() {}.getType();
/////////////////////////////////////////////////////////////////////////
0:   private static class StateTypeAdapter implements JsonSerializer<State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>,
0:     JsonDeserializer<State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>> {
0:     public State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> deserialize(
0:       State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> r = new State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>(params, omni);
/////////////////////////////////////////////////////////////////////////
0:     public JsonElement serialize(State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> state,
/////////////////////////////////////////////////////////////////////////
0:     InstanceCreator<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>,
0:     JsonDeserializer<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>,
0:     JsonSerializer<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>> {
0:     private static final Type STATE_TYPE = new TypeToken<State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>>() {}.getType();
0:     public EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> createInstance(Type type) {
0:       return new EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>();
0:     public EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> deserialize(
0:       EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> r =
0:           new EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner>();
0:         State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> state = jsonDeserializationContext.deserialize(element, STATE_TYPE);
0:     public JsonElement serialize(EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> x,
0:       for (State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> state : x.getPopulation()) {
/////////////////////////////////////////////////////////////////////////
1: 
0:   public static void main(String[] args) throws FileNotFoundException {
0:     OnlineLogisticRegression m = ModelSerializer.loadJsonFrom(new FileReader("/tmp/news-group-1000.model"), OnlineLogisticRegression.class);
1:   }
commit:319fd82
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.classifier.AbstractVectorClassifier;
0: import org.apache.mahout.classifier.OnlineLearner;
/////////////////////////////////////////////////////////////////////////
0:   public static void writeJson(String path, OnlineLearner model) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:   public static AbstractVectorClassifier loadJsonFrom(Reader in, Class<? extends AbstractVectorClassifier> clazz) {
commit:58b5f28
/////////////////////////////////////////////////////////////////////////
0:     gb.registerTypeAdapter(Mapping.class, new PolymorphicTypeAdapter<Mapping>());
0:     gb.registerTypeAdapter(PriorFunction.class, new PolymorphicTypeAdapter<PriorFunction>());
0:     gb.registerTypeAdapter(OnlineAuc.class, new PolymorphicTypeAdapter<OnlineAuc>());
0:     gb.registerTypeAdapter(Gradient.class, new PolymorphicTypeAdapter<Gradient>());
/////////////////////////////////////////////////////////////////////////
0:    * @param clazz The class of the object we expect to read.
0:   private static class PolymorphicTypeAdapter<T> implements JsonDeserializer<T>, JsonSerializer<T> {
0:     public T deserialize(JsonElement jsonElement,
0:         //noinspection RedundantTypeArguments
0:         return jsonDeserializationContext.<T>deserialize(x.get("value"), Class.forName(x.get("class").getAsString()));
/////////////////////////////////////////////////////////////////////////
0:     public JsonElement serialize(T x,
0:       r.add("class", new JsonPrimitive(x.getClass().getName()));
0:       r.add("value", jsonSerializationContext.serialize(x));
/////////////////////////////////////////////////////////////////////////
0:   private static class AdaptiveLogisticRegressionTypeAdapter implements JsonSerializer<AdaptiveLogisticRegression>,
0:     JsonDeserializer<AdaptiveLogisticRegression> {
1: 
0:     @Override
0:     public AdaptiveLogisticRegression deserialize(JsonElement element, Type type, JsonDeserializationContext jdc) {
0:       JsonObject x = element.getAsJsonObject();
0:       AdaptiveLogisticRegression r =
0:           new AdaptiveLogisticRegression(x.get("numCategories").getAsInt(),
0:                                          x.get("numFeatures").getAsInt(),
0:                                          jdc.<PriorFunction>deserialize(x.get("prior"), PriorFunction.class));
0:       Type stateType = new TypeToken<State<AdaptiveLogisticRegression.Wrapper>>() {}.getType();
0:       if (x.get("evaluationInterval")!=null) {
0:         r.setInterval(x.get("evaluationInterval").getAsInt());
0:       } else {
0:         r.setInterval(x.get("minInterval").getAsInt(), x.get("minInterval").getAsInt());
1:       }
0:       r.setRecord(x.get("record").getAsInt());
1: 
0:       Type epType = new TypeToken<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>() {}.getType();
0:       r.setEp(jdc.<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>deserialize(x.get("ep"), epType));
0:       r.setSeed(jdc.<State<AdaptiveLogisticRegression.Wrapper>>deserialize(x.get("seed"), stateType));
0:       if (x.get("best") != null) {
0:         r.setBest(jdc.<State<AdaptiveLogisticRegression.Wrapper>>deserialize(x.get("best"), stateType));
1:       }
1: 
0:       if (x.get("buffer") != null) {
0:         r.setBuffer(jdc.<List<AdaptiveLogisticRegression.TrainingExample>>deserialize(x.get("buffer"),
0:           new TypeToken<List<AdaptiveLogisticRegression.TrainingExample>>() {
0:           }.getType()));
1:       }
0:       return r;
1:     }
1: 
0:     @Override
0:     public JsonElement serialize(AdaptiveLogisticRegression x, Type type, JsonSerializationContext jsc) {
0:       JsonObject r = new JsonObject();
0:       r.add("ep", jsc.serialize(x.getEp(),
0:           new TypeToken<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>() {}.getType()));
0:       r.add("minInterval", jsc.serialize(x.getMinInterval()));
0:       r.add("maxInterval", jsc.serialize(x.getMaxInterval()));
0:       Type stateType = new TypeToken<State<AdaptiveLogisticRegression.Wrapper>>() {}.getType();
0:       r.add("best", jsc.serialize(x.getBest(), stateType));
0:       r.add("numFeatures", jsc.serialize(x.getNumFeatures()));
0:       r.add("numCategories", jsc.serialize(x.getNumCategories()));
0:       PriorFunction prior = x.getPrior();
0:       JsonElement pf = jsc.serialize(prior, PriorFunction.class);
0:       r.add("prior", pf);
0:       r.add("record", jsc.serialize(x.getRecord()));
0:       r.add("seed", jsc.serialize(x.getSeed(), stateType));
0:       return r;
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d0dc388
/////////////////////////////////////////////////////////////////////////
0:       if (x.get("best") != null) {
0:         r.setBest(jdc.<State<AdaptiveLogisticRegression.Wrapper>>deserialize(x.get("best"), stateType));
0:       }
0:       if (x.get("buffer") != null) {
0:         r.setBuffer(jdc.<List<AdaptiveLogisticRegression.TrainingExample>>deserialize(x.get("buffer"),
0:           new TypeToken<List<AdaptiveLogisticRegression.TrainingExample>>() {
0:           }.getType()));
0:       }
/////////////////////////////////////////////////////////////////////////
commit:597db6a
/////////////////////////////////////////////////////////////////////////
0:       if (x.get("evaluationInterval")!=null) {
0:         r.setInterval(x.get("evaluationInterval").getAsInt());
0:       } else {
0:         r.setInterval(x.get("minInterval").getAsInt(), x.get("minInterval").getAsInt());
0:       }
/////////////////////////////////////////////////////////////////////////
0:       r.add("minInterval", jsc.serialize(x.getMinInterval()));
0:       r.add("maxInterval", jsc.serialize(x.getMaxInterval()));
commit:b500070
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.math.stats.OnlineAuc;
/////////////////////////////////////////////////////////////////////////
0:     gb.registerTypeAdapter(OnlineAuc.class, new AucTypeAdapter());
/////////////////////////////////////////////////////////////////////////
0:   private static class AucTypeAdapter implements JsonDeserializer<OnlineAuc>, JsonSerializer<OnlineAuc> {
0:     @Override
0:     public OnlineAuc deserialize(JsonElement jsonElement,
0:                                      Type type,
0:                                      JsonDeserializationContext jsonDeserializationContext) {
0:       JsonObject x = jsonElement.getAsJsonObject();
0:       try {
0:         return jsonDeserializationContext.deserialize(x.get("value"), Class.forName(x.get("class").getAsString()));
0:       } catch (ClassNotFoundException e) {
0:         throw new IllegalStateException("Can't understand serialized data, found bad type: "
0:             + x.get("class").getAsString());
0:       }
0:     }
0: 
0:     @Override
0:     public JsonElement serialize(OnlineAuc auc,
0:                                  Type type,
0:                                  JsonSerializationContext jsonSerializationContext) {
0:       JsonObject r = new JsonObject();
0:       r.add("class", new JsonPrimitive(auc.getClass().getName()));
0:       r.add("value", jsonSerializationContext.serialize(auc));
0:       return r;
0:     }
0:   }
0: 
/////////////////////////////////////////////////////////////////////////
0:       r.setAucEvaluator(jsonDeserializationContext.<OnlineAuc>deserialize(x.get("auc"), OnlineAuc.class));
commit:e6b4e35
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.math.stats.GlobalOnlineAuc;
/////////////////////////////////////////////////////////////////////////
0:       r.setAucEvaluator(jsonDeserializationContext.<GlobalOnlineAuc>deserialize(x.get("auc"), GlobalOnlineAuc.class));
commit:a704e17
/////////////////////////////////////////////////////////////////////////
1: package org.apache.mahout.classifier.sgd;
0: 
0: import com.google.gson.*;
0: import com.google.gson.reflect.TypeToken;
0: import org.apache.mahout.ep.EvolutionaryProcess;
0: import org.apache.mahout.ep.Mapping;
0: import org.apache.mahout.ep.State;
0: import org.apache.mahout.math.DenseMatrix;
0: import org.apache.mahout.math.DenseVector;
0: import org.apache.mahout.math.Matrix;
0: import org.apache.mahout.math.Vector;
0: import org.apache.mahout.math.stats.OnlineAuc;
0: 
0: import java.io.FileWriter;
1: import java.io.IOException;
0: import java.io.Reader;
0: import java.lang.reflect.Type;
0: import java.util.List;
0: 
1: /**
0:  * Provides the ability to store SGD model-related objects as JSON.
1:  */
0: public class ModelSerializer {
0:   // thread-local singleton json (de)serializer
0:   private static final ThreadLocal<Gson> GSON;
0:   static {
0:     final GsonBuilder gb = new GsonBuilder();
0:     gb.registerTypeAdapter(AdaptiveLogisticRegression.class, new AdaptiveLogisticRegressionTypeAdapter());
0:     gb.registerTypeAdapter(Mapping.class, new MappingTypeAdapter());
0:     gb.registerTypeAdapter(PriorFunction.class, new PriorTypeAdapter());
0:     gb.registerTypeAdapter(CrossFoldLearner.class, new CrossFoldLearnerTypeAdapter());
0:     gb.registerTypeAdapter(Vector.class, new VectorTypeAdapter());
0:     gb.registerTypeAdapter(Matrix.class, new MatrixTypeAdapter());
0:     gb.registerTypeAdapter(EvolutionaryProcess.class, new EvolutionaryProcessTypeAdapter());
0:     gb.registerTypeAdapter(State.class, new StateTypeAdapter());
0:     GSON = new ThreadLocal<Gson>() {
0:       @Override
0:       protected Gson initialValue() {
0:         return gb.create();
0:       }
0:     };
0:   }
0: 
1:   // static class ... don't instantiate
1:   private ModelSerializer() {
0:   }
0: 
0:   public static Gson gson() {
0:     return GSON.get();
0:   }
0: 
0:   public static void writeJson(String path, AdaptiveLogisticRegression model) throws IOException {
0:     FileWriter out = new FileWriter(path);
0:     out.write(gson().toJson(model));
0:     out.close();
0:   }
0: 
1:   /**
0:    * Reads a model in JSON format.
0:    *
0:    * @param in Where to read the model from.
0:    * @param clazz
0:    * @return The LogisticModelParameters object that we read.
1:    */
0:   public static AdaptiveLogisticRegression loadJsonFrom(Reader in, Class<AdaptiveLogisticRegression> clazz) {
0:     return gson().fromJson(in, clazz);
0:   }
0: 
0:   private static class MappingTypeAdapter implements JsonDeserializer<Mapping>, JsonSerializer<Mapping> {
0:     @Override
0:     public Mapping deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
0:       JsonObject x = jsonElement.getAsJsonObject();
0:       try {
0:         return jsonDeserializationContext.deserialize(x.get("value"), (Class) Class.forName(x.get("class").getAsString()));
0:       } catch (ClassNotFoundException e) {
0:         throw new IllegalStateException("Can't understand serialized data, found bad type: " + x.get("class").getAsString());
0:       }
0:     }
0: 
0:     @Override
0:     public JsonElement serialize(Mapping mapping, Type type, JsonSerializationContext jsonSerializationContext) {
0:       JsonObject r = new JsonObject();
0:       r.add("class", new JsonPrimitive(mapping.getClass().getName()));
0:       r.add("value", jsonSerializationContext.serialize(mapping));
0:       return r;
0:     }
0:   }
0: 
0:   private static class PriorTypeAdapter implements JsonDeserializer<PriorFunction>, JsonSerializer<PriorFunction> {
0:     @Override
0:     public PriorFunction deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
0:       JsonObject x = jsonElement.getAsJsonObject();
0:       try {
0:         return jsonDeserializationContext.deserialize(x.get("value"), (Class) Class.forName(x.get("class").getAsString()));
0:       } catch (ClassNotFoundException e) {
0:         throw new IllegalStateException("Can't understand serialized data, found bad type: " + x.get("class").getAsString());
0:       }
0:     }
0: 
0:     @Override
0:     public JsonElement serialize(PriorFunction priorFunction, Type type, JsonSerializationContext jsonSerializationContext) {
0:       JsonObject r = new JsonObject();
0:       r.add("class", new JsonPrimitive(priorFunction.getClass().getName()));
0:       r.add("value", jsonSerializationContext.serialize(priorFunction));
0:       return r;
0:     }
0:   }
0: 
0:   private static class CrossFoldLearnerTypeAdapter implements JsonDeserializer<CrossFoldLearner> {
0:     @Override
0:     public CrossFoldLearner deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
0:       CrossFoldLearner r = new CrossFoldLearner();
0:       JsonObject x = jsonElement.getAsJsonObject();
0:       r.setRecord(x.get("record").getAsInt());
0:       r.setAuc(jsonDeserializationContext.<OnlineAuc>deserialize(x.get("auc"), OnlineAuc.class));
0:       r.setLogLikelihood(x.get("logLikelihood").getAsDouble());
0: 
0:       JsonArray models = x.get("models").getAsJsonArray();
0:       for (JsonElement model : models) {
0:         r.addModel(jsonDeserializationContext.<OnlineLogisticRegression>deserialize(model, OnlineLogisticRegression.class));
0:       }
0: 
0:       r.setParameters(asArray(x, "parameters"));
0:       r.setNumFeatures(x.get("numFeatures").getAsInt());
0:       r.setPrior(jsonDeserializationContext.<PriorFunction>deserialize(x.get("prior"), PriorFunction.class));
0:       return r;
0:     }
0:   }
0: 
1:   /**
0:    * Tells GSON how to (de)serialize a Mahout matrix.  We assume on deserialization that the matrix
0:    * is dense.
1:    */
0:   private static class MatrixTypeAdapter
0:     implements JsonDeserializer<Matrix>, JsonSerializer<Matrix>, InstanceCreator<Matrix> {
0:     @Override
0:     public JsonElement serialize(Matrix m, Type type, JsonSerializationContext jsonSerializationContext) {
0:       JsonObject r = new JsonObject();
0:       r.add("rows", new JsonPrimitive(m.numRows()));
0:       r.add("cols", new JsonPrimitive(m.numCols()));
0:       JsonArray v = new JsonArray();
0:       for (int row = 0; row < m.numRows(); row++) {
0:         JsonArray rowData = new JsonArray();
0:         for (int col = 0; col < m.numCols(); col++) {
0:           rowData.add(new JsonPrimitive(m.get(row, col)));
0:         }
0:         v.add(rowData);
0:       }
0:       r.add("data", v);
0:       return r;
0:     }
0: 
0:     @Override
0:     public Matrix deserialize(JsonElement x, Type type, JsonDeserializationContext jsonDeserializationContext) {
0:       JsonObject data = x.getAsJsonObject();
0:       Matrix r = new DenseMatrix(data.get("rows").getAsInt(), data.get("cols").getAsInt());
0:       int i = 0;
0:       for (JsonElement row : data.get("data").getAsJsonArray()) {
0:         int j = 0;
0:         for (JsonElement element : row.getAsJsonArray()) {
0:           r.set(i, j, element.getAsDouble());
0:           j++;
0:         }
0:         i++;
0:       }
0:       return r;
0:     }
0: 
0:     @Override
0:     public Matrix createInstance(Type type) {
0:       return new DenseMatrix();
0:     }
0:   }
0: 
0: 
1:   /**
0:    * Tells GSON how to (de)serialize a Mahout matrix.  We assume on deserialization that the
0:    * matrix is dense.
1:    */
0:   private static class VectorTypeAdapter
0:     implements JsonDeserializer<Vector>, JsonSerializer<Vector>, InstanceCreator<Vector> {
0:     @Override
0:     public JsonElement serialize(Vector m, Type type, JsonSerializationContext jsonSerializationContext) {
0:       JsonObject r = new JsonObject();
0:       JsonArray v = new JsonArray();
0:       for (int i = 0; i < m.size(); i++) {
0:         v.add(new JsonPrimitive(m.get(i)));
0:       }
0:       r.add("data", v);
0:       return r;
0:     }
0: 
0:     @Override
0:     public Vector deserialize(JsonElement x, Type type, JsonDeserializationContext jsonDeserializationContext) {
0:       JsonArray data = x.getAsJsonObject().get("data").getAsJsonArray();
0:       Vector r = new DenseVector(data.size());
0:       int i = 0;
0:       for (JsonElement v : data) {
0:         r.set(i, v.getAsDouble());
0:         i++;
0:       }
0:       return r;
0:     }
0: 
0:     @Override
0:     public Vector createInstance(Type type) {
0:       return new DenseVector();
0:     }
0:   }
0: 
0:   private static class StateTypeAdapter implements JsonSerializer<State<AdaptiveLogisticRegression.Wrapper>>,
0:     JsonDeserializer<State<AdaptiveLogisticRegression.Wrapper>> {
0:     @Override
0:     public State<AdaptiveLogisticRegression.Wrapper> deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
0:       JsonObject v = (JsonObject) jsonElement;
0:       double[] params = asArray(v, "params");
0:       double omni = v.get("omni").getAsDouble();
0:       State<AdaptiveLogisticRegression.Wrapper> r = new State<AdaptiveLogisticRegression.Wrapper>(params, omni);
0: 
0:       double[] step = asArray(v, "step");
0:       r.setId(v.get("id").getAsInt());
0:       r.setStep(step);
0:       r.setValue(v.get("value").getAsDouble());
0: 
0:       Type mapListType = new TypeToken<List<Mapping>>() {
0:       }.getType();
0:       r.setMaps(jsonDeserializationContext.<List<Mapping>>deserialize(v.get("maps"), mapListType));
0: 
0:       r.setPayload(jsonDeserializationContext.<AdaptiveLogisticRegression.Wrapper>deserialize(v.get("payload"), AdaptiveLogisticRegression.Wrapper.class));
0:       return r;
0:     }
0: 
0:     @Override
0:     public JsonElement serialize(State<AdaptiveLogisticRegression.Wrapper> state, Type type, JsonSerializationContext jsonSerializationContext) {
0:       JsonObject r = new JsonObject();
0:       r.add("id", new JsonPrimitive(state.getId()));
0:       JsonArray v = new JsonArray();
0:       for (double x : state.getParams()) {
0:         v.add(new JsonPrimitive(x));
0:       }
0:       r.add("params", v);
0: 
0:       v = new JsonArray();
0:       for (Mapping mapping : state.getMaps()) {
0:         v.add(jsonSerializationContext.serialize(mapping, Mapping.class));
0:       }
0:       r.add("maps", v);
0:       r.add("omni", new JsonPrimitive(state.getOmni()));
0:       r.add("step", jsonSerializationContext.serialize(state.getStep()));
0:       r.add("value", new JsonPrimitive(state.getValue()));
0:       r.add("payload", jsonSerializationContext.serialize(state.getPayload()));
0: 
0:       return r;
0:     }
0:   }
0: 
0:   private static class AdaptiveLogisticRegressionTypeAdapter implements JsonSerializer<AdaptiveLogisticRegression>,
0:     JsonDeserializer<AdaptiveLogisticRegression> {
0: 
0:     @Override
0:     public AdaptiveLogisticRegression deserialize(JsonElement element, Type type, JsonDeserializationContext jdc) throws JsonParseException {
0:       JsonObject x = element.getAsJsonObject();
0:       AdaptiveLogisticRegression r = new AdaptiveLogisticRegression(x.get("numCategories").getAsInt(), x.get("numFeatures").getAsInt(), jdc.<PriorFunction>deserialize(x.get("prior"), PriorFunction.class));
0:       Type stateType = new TypeToken<State<AdaptiveLogisticRegression.Wrapper>>() {
0:       }.getType();
0:       r.setEvaluationInterval(x.get("evaluationInterval").getAsInt());
0:       r.setRecord(x.get("record").getAsInt());
0: 
0:       Type epType = new TypeToken<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>() {
0:       }.getType();
0:       r.setEp(jdc.<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>deserialize(x.get("ep"), epType));
0:       r.setSeed(jdc.<State<AdaptiveLogisticRegression.Wrapper>>deserialize(x.get("seed"), stateType));
0:       r.setBest(jdc.<State<AdaptiveLogisticRegression.Wrapper>>deserialize(x.get("best"), stateType));
0: 
0:       r.setBuffer(jdc.<List<AdaptiveLogisticRegression.TrainingExample>>deserialize(x.get("buffer"), new TypeToken<List<AdaptiveLogisticRegression.TrainingExample>>() {
0:       }.getType()));
0:       return r;
0:     }
0: 
0:     @Override
0:     public JsonElement serialize(AdaptiveLogisticRegression x, Type type, JsonSerializationContext jsc) {
0:       JsonObject r = new JsonObject();
0:       r.add("ep", jsc.serialize(x.getEp(), new TypeToken<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>() {
0:       }.getType()));
0:       r.add("buffer", jsc.serialize(x.getBuffer(), new TypeToken<List<AdaptiveLogisticRegression.TrainingExample>>() {
0:       }.getType()));
0:       r.add("evaluationInterval", jsc.serialize(x.getEvaluationInterval()));
0:       Type stateType = new TypeToken<State<AdaptiveLogisticRegression.Wrapper>>() {
0:       }.getType();
0:       r.add("best", jsc.serialize(x.getBest(), stateType));
0:       r.add("numFeatures", jsc.serialize(x.getNumFeatures()));
0:       r.add("numCategories", jsc.serialize(x.getNumCategories()));
0:       PriorFunction prior = x.getPrior();
0:       JsonElement pf = jsc.serialize(prior, PriorFunction.class);
0:       r.add("prior", pf);
0:       r.add("record", jsc.serialize(x.getRecord()));
0:       r.add("seed", jsc.serialize(x.getSeed(), stateType));
0:       return r;
0:     }
0:   }
0: 
0:   private static class EvolutionaryProcessTypeAdapter implements InstanceCreator<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>,
0:     JsonDeserializer<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>>,
0:     JsonSerializer<EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>> {
0:     private static final Type STATE_TYPE = new TypeToken<State<AdaptiveLogisticRegression.Wrapper>>() {
0:     }.getType();
0: 
0:     @Override
0:     public EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper> createInstance(Type type) {
0:       return new EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>();
0:     }
0: 
0:     @Override
0:     public EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper> deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
0:       JsonObject x = (JsonObject) jsonElement;
0:       int threadCount = x.get("threadCount").getAsInt();
0: 
0:       EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper> r = new EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper>();
0:       r.setThreadCount(threadCount);
0: 
0:       for (JsonElement element : x.get("population").getAsJsonArray()) {
0:         State<AdaptiveLogisticRegression.Wrapper> state = jsonDeserializationContext.deserialize(element, STATE_TYPE);
0:         r.add(state);
0:       }
0:       return r;
0:     }
0: 
0:     @Override
0:     public JsonElement serialize(EvolutionaryProcess<AdaptiveLogisticRegression.Wrapper> x, Type type, JsonSerializationContext jsc) {
0:       JsonObject r = new JsonObject();
0:       r.add("threadCount", new JsonPrimitive(x.getThreadCount()));
0:       JsonArray v = new JsonArray();
0:       for (State<AdaptiveLogisticRegression.Wrapper> state : x.getPopulation()) {
0:         v.add(jsc.serialize(state, STATE_TYPE));
0:       }
0:       r.add("population", v);
0:       return r;
0:     }
0:   }
0: 
0:   public static double[] asArray(JsonObject v, String name) {
0:     JsonArray x = v.get(name).getAsJsonArray();
0:     double[] params = new double[x.size()];
0:     int i = 0;
0:     for (JsonElement element : x) {
0:       params[i++] = element.getAsDouble();
0:     }
0:     return params;
0:   }
0: 
0: }
============================================================================