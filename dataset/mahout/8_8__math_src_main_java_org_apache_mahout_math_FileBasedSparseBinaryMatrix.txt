1:5fc1b50: /*
1:5fc1b50:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:5fc1b50:  * contributor license agreements.  See the NOTICE file distributed with
1:5fc1b50:  * this work for additional information regarding copyright ownership.
1:5fc1b50:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:5fc1b50:  * (the "License"); you may not use this file except in compliance with
1:5fc1b50:  * the License.  You may obtain a copy of the License at
1:5fc1b50:  *
1:5fc1b50:  *     http://www.apache.org/licenses/LICENSE-2.0
1:5fc1b50:  *
1:5fc1b50:  * Unless required by applicable law or agreed to in writing, software
1:5fc1b50:  * distributed under the License is distributed on an "AS IS" BASIS,
1:5fc1b50:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5fc1b50:  * See the License for the specific language governing permissions and
1:5fc1b50:  * limitations under the License.
1:5fc1b50:  */
2:5fc1b50: 
1:5fc1b50: package org.apache.mahout.math;
1:5fc1b50: 
1:5fc1b50: import java.io.DataOutputStream;
1:5fc1b50: import java.io.File;
1:5fc1b50: import java.io.FileInputStream;
1:5fc1b50: import java.io.FileOutputStream;
1:5fc1b50: import java.io.IOException;
1:5fc1b50: import java.nio.ByteBuffer;
1:5fc1b50: import java.nio.IntBuffer;
1:5fc1b50: import java.nio.channels.FileChannel;
1:5fc1b50: import java.util.Collections;
1:5fc1b50: import java.util.Iterator;
1:5fc1b50: import java.util.List;
1:5fc1b50: 
1:0a0fddf: import com.google.common.base.Function;
1:0a0fddf: import com.google.common.base.Preconditions;
1:0a0fddf: import com.google.common.collect.AbstractIterator;
1:dc62944: import com.google.common.collect.Iterables;
1:0a0fddf: import com.google.common.collect.Lists;
1:0a0fddf: 
1:5fc1b50: /**
1:5fc1b50:  * Provides a way to get data from a file and treat it as if it were a matrix, but avoids putting
1:5fc1b50:  * all that data onto the Java heap.  Instead, the file is mapped into non-heap memory as a
1:5fc1b50:  * DoubleBuffer and we access that instead.  The interesting aspect of this is that the values in
1:5fc1b50:  * the matrix are binary and sparse so we don't need to store the actual data, just the location of
1:5fc1b50:  * non-zero values.
1:b5c2879:  * <p>
1:5fc1b50:  * Currently file data is formatted as follows:
1:b5c2879:  * <p>
1:5fc1b50:  * <ul> <li>A magic number to indicate the file format.</li> <li>The size of the matrix (max rows
1:5fc1b50:  * and columns possible)</li> <li>Number of non-zeros in each row.</li> <li>A list of non-zero
1:5fc1b50:  * columns for each row.  The list starts with a count and then has column numbers</li> </ul>
1:b5c2879:  * <p>
1:5fc1b50:  * It would be preferable to use something like protobufs to define the format so that we can use
1:5fc1b50:  * different row formats for different kinds of data.  For instance, Golay coding of column numbers
1:5fc1b50:  * or compressed bit vectors might be good representations for some purposes.
1:5fc1b50:  */
1:8b6a26a: public final class FileBasedSparseBinaryMatrix extends AbstractMatrix {
1:5fc1b50:   private static final int MAGIC_NUMBER_V0 = 0x12d7067d;
1:5fc1b50: 
1:8b6a26a:   private final List<IntBuffer> data = Lists.newArrayList();
1:5fc1b50:   private int[] bufferIndex;
1:5fc1b50:   private int[] rowOffset;
1:5fc1b50:   private int[] rowSize;
1:5fc1b50: 
1:5fc1b50:   /**
1:5fc1b50:    * Constructs an empty matrix of the given size.
1:5fc1b50:    *
1:5fc1b50:    * @param rows    The number of rows in the result.
1:5fc1b50:    * @param columns The number of columns in the result.
1:5fc1b50:    */
1:5fc1b50:   public FileBasedSparseBinaryMatrix(int rows, int columns) {
1:5fc1b50:     super(rows, columns);
6:5fc1b50:   }
1:5fc1b50: 
1:bdb1c48:   public void setData(File f) throws IOException {
1:5fc1b50:     List<ByteBuffer> buffers = Lists.newArrayList();
1:5fc1b50:     FileChannel input = new FileInputStream(f).getChannel();
1:5fc1b50: 
1:5fc1b50:     buffers.add(input.map(FileChannel.MapMode.READ_ONLY, 0, Math.min(Integer.MAX_VALUE, f.length())));
1:5fc1b50:     data.add(buffers.get(0).asIntBuffer());
1:5fc1b50:     Preconditions.checkArgument(buffers.get(0).getInt() == MAGIC_NUMBER_V0, "Wrong type of file");
1:5fc1b50: 
1:5fc1b50:     int rows = buffers.get(0).getInt();
1:5fc1b50:     int cols = buffers.get(0).getInt();
1:5fc1b50:     Preconditions.checkArgument(rows == rowSize());
1:5fc1b50:     Preconditions.checkArgument(cols == columnSize());
1:5fc1b50: 
1:5fc1b50:     rowOffset = new int[rows];
1:5fc1b50:     rowSize = new int[rows];
1:5fc1b50:     bufferIndex = new int[rows];
1:5fc1b50: 
1:5fc1b50:     int offset = 12 + 4 * rows;
1:5fc1b50:     for (int i = 0; i < rows; i++) {
1:5fc1b50:       int size = buffers.get(0).getInt();
1:5fc1b50:       int buffer = 0;
1:5fc1b50:       while (buffer < buffers.size()) {
1:5fc1b50:         if (offset + size * 4 <= buffers.get(buffer).limit()) {
1:5fc1b50:           break;
2:5fc1b50:         } else {
1:5fc1b50:           offset -= buffers.get(buffer).capacity();
1:5fc1b50:         }
1:5fc1b50:       }
1:5fc1b50:       if (buffer == buffers.size()) {
1:5fc1b50:         buffers.add(input.map(FileChannel.MapMode.READ_ONLY, 0, Math.min(Integer.MAX_VALUE, f.length() - offset)));
1:5fc1b50:         data.add(buffers.get(buffer).asIntBuffer());
1:5fc1b50:       }
1:5fc1b50:       rowOffset[i] = offset / 4;
1:5fc1b50:       rowSize[i] = size;
1:5fc1b50:       bufferIndex[i] = buffer;
1:5fc1b50: 
1:5fc1b50: //      final SparseBinaryVector v = new SparseBinaryVector(buffers.get(buffer), columns, offset, size);
1:5fc1b50: //      this.rows.add(v);
1:5fc1b50:       offset += size * 4;
1:5fc1b50:     }
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   public static void writeMatrix(File f, Matrix m) throws IOException {
1:5fc1b50:     Preconditions.checkArgument(f.canWrite(), "Can't write to output file");
1:5fc1b50:     FileOutputStream fos = new FileOutputStream(f);
1:5fc1b50: 
1:5fc1b50:     // write header
1:5fc1b50:     DataOutputStream out = new DataOutputStream(fos);
1:5fc1b50:     out.writeInt(MAGIC_NUMBER_V0);
1:5fc1b50:     out.writeInt(m.rowSize());
1:5fc1b50:     out.writeInt(m.columnSize());
1:5fc1b50: 
1:5fc1b50:     // compute offsets and write row headers
1:5fc1b50:     for (MatrixSlice row : m) {
1:8b6a26a:       int nondefaultElements = row.vector().getNumNondefaultElements();
1:5fc1b50:       out.writeInt(nondefaultElements);
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     // write rows
1:5fc1b50:     for (MatrixSlice row : m) {
1:dc62944:       List<Integer> columns = Lists.newArrayList(Iterables.transform(row.vector().nonZeroes(),
1:58cc1ae:         new Function<Vector.Element, Integer>() {
1:58cc1ae:           @Override
1:58cc1ae:           public Integer apply(Vector.Element element) {
1:58cc1ae:             return element.index();
1:58cc1ae:           }
1:58cc1ae:         }));
1:5fc1b50:       Collections.sort(columns);
1:5fc1b50: 
1:5fc1b50:       for (Integer column : columns) {
1:5fc1b50:         out.writeInt(column);
1:dc62944:       }
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     out.close();
1:5fc1b50:     fos.close();
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   /**
1:5fc1b50:    * Assign the other vector values to the column of the receiver
1:5fc1b50:    *
1:5fc1b50:    * @param column the int row to assign
1:5fc1b50:    * @param other  a Vector
1:5fc1b50:    * @return the modified receiver
1:5fc1b50:    * @throws org.apache.mahout.math.CardinalityException
1:5fc1b50:    *          if the cardinalities differ
1:5fc1b50:    */
1:dc62944:   @Override
1:5fc1b50:   public Matrix assignColumn(int column, Vector other) {
1:5fc1b50:     throw new UnsupportedOperationException("Default operation");
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   /**
1:5fc1b50:    * Assign the other vector values to the row of the receiver
1:5fc1b50:    *
1:5fc1b50:    * @param row   the int row to assign
1:5fc1b50:    * @param other a Vector
1:5fc1b50:    * @return the modified receiver
1:5fc1b50:    * @throws org.apache.mahout.math.CardinalityException
1:5fc1b50:    *          if the cardinalities differ
1:5fc1b50:    */
3:5fc1b50:   @Override
1:5fc1b50:   public Matrix assignRow(int row, Vector other) {
1:5fc1b50:     throw new UnsupportedOperationException("Default operation");
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   /**
1:5fc1b50:    * Return the value at the given indexes, without checking bounds
1:5fc1b50:    *
1:5fc1b50:    * @param rowIndex    an int row index
1:5fc1b50:    * @param columnIndex an int column index
1:5fc1b50:    * @return the double at the index
1:5fc1b50:    */
1:5fc1b50:   @Override
1:5fc1b50:   public double getQuick(int rowIndex, int columnIndex) {
1:5fc1b50:     IntBuffer tmp = data.get(bufferIndex[rowIndex]).asReadOnlyBuffer();
1:5fc1b50:     tmp.position(rowOffset[rowIndex]);
1:5fc1b50:     tmp.limit(rowSize[rowIndex]);
1:5fc1b50:     tmp = tmp.slice();
1:5fc1b50:     return searchForIndex(tmp, columnIndex);
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   private static double searchForIndex(IntBuffer row, int columnIndex) {
1:5fc1b50:     int high = row.limit();
1:5fc1b50:     if (high == 0) {
1:5fc1b50:       return 0;
1:5fc1b50:     }
1:8b6a26a:     int low = 0;
1:5fc1b50:     while (high > low) {
1:5fc1b50:       int mid = (low + high) / 2;
1:5fc1b50:       if (row.get(mid) < columnIndex) {
1:5fc1b50:         low = mid + 1;
1:5fc1b50:       } else {
1:5fc1b50:         high = mid;
1:5fc1b50:       }
1:5fc1b50:     }
1:5fc1b50:     if (low >= row.limit()) {
1:5fc1b50:       return 0;
1:6d16230:     } else if (high == low && row.get(low) == columnIndex) {
1:5fc1b50:       return 1;
1:5fc1b50:     } else {
1:5fc1b50:       return 0;
1:5fc1b50:     }
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   /**
1:5fc1b50:    * Return an empty matrix of the same underlying class as the receiver
1:5fc1b50:    *
1:5fc1b50:    * @return a Matrix
1:5fc1b50:    */
1:5fc1b50:   @Override
1:5fc1b50:   public Matrix like() {
1:5fc1b50:     throw new UnsupportedOperationException("Default operation");
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   /**
1:5fc1b50:    * Returns an empty matrix of the same underlying class as the receiver and of the specified
1:5fc1b50:    * size.
1:5fc1b50:    *
1:5fc1b50:    * @param rows    the int number of rows
1:5fc1b50:    * @param columns the int number of columns
1:5fc1b50:    */
1:5fc1b50:   @Override
1:5fc1b50:   public Matrix like(int rows, int columns) {
1:5fc1b50:     return new DenseMatrix(rows, columns);
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   /**
1:0a0fddf:    * Set the value at the given index, without checking bounds
1:0a0fddf:    *
1:5fc1b50:    * @param row    an int row index into the receiver
1:5fc1b50:    * @param column an int column index into the receiver
1:5fc1b50:    * @param value  a double value to set
1:5fc1b50:    */
1:5fc1b50:   @Override
1:5fc1b50:   public void setQuick(int row, int column, double value) {
1:5fc1b50:     throw new UnsupportedOperationException("Default operation");
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   /**
1:5fc1b50:    * Return a view into part of a matrix.  Changes to the view will change the original matrix.
1:5fc1b50:    *
1:5fc1b50:    * @param offset an int[2] offset into the receiver
1:5fc1b50:    * @param size   the int[2] size of the desired result
1:5fc1b50:    * @return a matrix that shares storage with part of the original matrix.
1:5fc1b50:    * @throws org.apache.mahout.math.CardinalityException
1:5fc1b50:    *          if the length is greater than the cardinality of the receiver
1:5fc1b50:    * @throws org.apache.mahout.math.IndexException
1:5fc1b50:    *          if the offset is negative or the offset+length is outside of the receiver
1:5fc1b50:    */
1:5fc1b50:   @Override
1:5fc1b50:   public Matrix viewPart(int[] offset, int[] size) {
1:5fc1b50:     throw new UnsupportedOperationException("Default operation");
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   /**
1:5fc1b50:    * Returns a view of a row.  Changes to the view will affect the original.
1:5fc1b50:    *
1:5fc1b50:    * @param rowIndex Which row to return.
1:5fc1b50:    * @return A vector that references the desired row.
1:5fc1b50:    */
1:5fc1b50:   @Override
1:5fc1b50:   public Vector viewRow(int rowIndex) {
1:5fc1b50:     IntBuffer tmp = data.get(bufferIndex[rowIndex]).asReadOnlyBuffer();
1:5fc1b50:     tmp.position(rowOffset[rowIndex]);
1:5fc1b50:     tmp.limit(rowOffset[rowIndex] + rowSize[rowIndex]);
1:5fc1b50:     tmp = tmp.slice();
1:bdb1c48:     return new SparseBinaryVector(tmp, columnSize());
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   private static class SparseBinaryVector extends AbstractVector {
1:8b6a26a:     private final IntBuffer buffer;
1:8b6a26a:     private final int maxIndex;
1:5fc1b50: 
1:bdb1c48:     private SparseBinaryVector(IntBuffer buffer, int maxIndex) {
1:5fc1b50:       super(maxIndex);
1:5fc1b50:       this.buffer = buffer;
1:5fc1b50:       this.maxIndex = maxIndex;
1:5fc1b50:     }
1:5fc1b50: 
1:8b6a26a:     SparseBinaryVector(ByteBuffer row, int maxIndex, int offset, int size) {
1:5fc1b50:       super(maxIndex);
1:5fc1b50:       row = row.asReadOnlyBuffer();
1:5fc1b50:       row.position(offset);
1:5fc1b50:       row.limit(offset + size * 4);
1:5fc1b50:       row = row.slice();
1:5fc1b50:       this.buffer = row.slice().asIntBuffer();
1:5fc1b50:       this.maxIndex = maxIndex;
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:5fc1b50:      * Subclasses must override to return an appropriately sparse or dense result
1:5fc1b50:      *
1:5fc1b50:      * @param rows    the row cardinality
1:5fc1b50:      * @param columns the column cardinality
1:5fc1b50:      * @return a Matrix
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     protected Matrix matrixLike(int rows, int columns) {
1:5fc1b50:       throw new UnsupportedOperationException("Default operation");
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:a8d3dbd:      * Used internally by assign() to update multiple indices and values at once.
1:a8d3dbd:      * Only really useful for sparse vectors (especially SequentialAccessSparseVector).
1:a8d3dbd:      * <p/>
1:a8d3dbd:      * If someone ever adds a new type of sparse vectors, this method must merge (index, value) pairs into the vector.
1:a8d3dbd:      *
1:a8d3dbd:      * @param updates a mapping of indices to values to merge in the vector.
1:a8d3dbd:      */
1:a8d3dbd:     @Override
1:a8d3dbd:     public void mergeUpdates(OrderedIntDoubleMapping updates) {
1:a8d3dbd:       throw new UnsupportedOperationException("Cannot mutate SparseBinaryVector");
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     /**
1:5fc1b50:      * @return true iff this implementation should be considered dense -- that it explicitly represents
1:5fc1b50:      *         every value
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     public boolean isDense() {
1:5fc1b50:       return false;
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:5fc1b50:      * @return true iff this implementation should be considered to be iterable in index order in an
1:5fc1b50:      *         efficient way. In particular this implies that {@link #iterator()} and {@link
1:5fc1b50:      *         #iterateNonZero()} return elements in ascending order by index.
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     public boolean isSequentialAccess() {
1:5fc1b50:       return true;
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:5fc1b50:      * Iterates over all elements
1:5fc1b50:      *
1:5fc1b50:      * NOTE: Implementations may choose to reuse the Element returned
1:5fc1b50:      * for performance reasons, so if you need a copy of it, you should call {@link #getElement(int)}
1:5fc1b50:      * for the given index
1:5fc1b50:      *
1:5fc1b50:      * @return An {@link java.util.Iterator} over all elements
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     public Iterator<Element> iterator() {
1:5fc1b50:       return new AbstractIterator<Element>() {
1:5fc1b50:         int i = 0;
1:5fc1b50: 
1:5fc1b50:         @Override
1:5fc1b50:         protected Element computeNext() {
1:5fc1b50:           if (i < maxIndex) {
1:5fc1b50:             return new Element() {
1:5fc1b50:               int index = i++;
1:5fc1b50:               /**
1:5fc1b50:                * @return the value of this vector element.
1:5fc1b50:                */
1:5fc1b50:               @Override
1:5fc1b50:               public double get() {
1:5fc1b50:                 return getQuick(index);
1:5fc1b50:               }
1:5fc1b50: 
1:5fc1b50:               /**
1:5fc1b50:                * @return the index of this vector element.
1:5fc1b50:                */
1:5fc1b50:               @Override
1:5fc1b50:               public int index() {
1:5fc1b50:                 return index;
1:5fc1b50:               }
1:5fc1b50: 
1:5fc1b50:               /**
1:5fc1b50:                * @param value Set the current element to value.
1:5fc1b50:                */
1:5fc1b50:               @Override
1:5fc1b50:               public void set(double value) {
1:5fc1b50:                 throw new UnsupportedOperationException("Default operation");
1:5fc1b50:               }
2:5fc1b50:             };
1:5fc1b50:           } else {
2:5fc1b50:             return endOfData();
1:5fc1b50:           }
1:5fc1b50:         }
1:5fc1b50:       };
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:5fc1b50:       * Iterates over all non-zero elements. <p/> NOTE: Implementations may choose to reuse the Element
1:5fc1b50:       * returned for performance reasons, so if you need a copy of it, you should call {@link
1:5fc1b50:       * #getElement(int)} for the given index
1:5fc1b50:       *
1:5fc1b50:       * @return An {@link java.util.Iterator} over all non-zero elements
1:5fc1b50:       */
1:5fc1b50:     @Override
1:5fc1b50:     public Iterator<Element> iterateNonZero() {
1:5fc1b50:       return new AbstractIterator<Element>() {
1:5fc1b50:         int i = 0;
1:5fc1b50:         @Override
1:5fc1b50:         protected Element computeNext() {
1:5fc1b50:           if (i < buffer.limit()) {
1:6d16230:             return new BinaryReadOnlyElement(buffer.get(i++));
1:6d16230:           } else {
1:6d16230:             return endOfData();
1:6d16230:           }
1:6d16230:         }
1:6d16230:       };
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:   /**
1:5fc1b50:      * Return the value at the given index, without checking bounds
1:5fc1b50:      *
1:5fc1b50:      * @param index an int index
1:5fc1b50:      * @return the double at the index
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     public double getQuick(int index) {
1:5fc1b50:       return searchForIndex(buffer, index);
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:5fc1b50:      * Return an empty vector of the same underlying class as the receiver
1:5fc1b50:      *
1:5fc1b50:      * @return a Vector
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     public Vector like() {
1:5fc1b50:       return new RandomAccessSparseVector(size());
1:5fc1b50:     }
1:5fc1b50: 
1:0b564c7:     @Override
1:0b564c7:     public Vector like(int cardinality) {
1:0b564c7:       return new RandomAccessSparseVector(cardinality);
1:0b564c7:     }
1:0b564c7: 
1:5fc1b50:     /**
1:8b194c8:      * Copy the vector for fast operations.
1:0a0fddf:      *
1:0a0fddf:      * @return a Vector
1:0a0fddf:      */
1:0a0fddf:     @Override
1:0a0fddf:     protected Vector createOptimizedCopy() {
1:0a0fddf:       return new RandomAccessSparseVector(size()).assign(this);
1:0a0fddf:     }
1:0a0fddf: 
1:0a0fddf:     /**
1:5fc1b50:      * Set the value at the given index, without checking bounds
1:5fc1b50:      *
1:0a0fddf:      * @param index an int index into the receiver
1:0a0fddf:      * @param value a double value to set
1:0a0fddf:      */
1:0a0fddf:     @Override
1:5fc1b50:     public void setQuick(int index, double value) {
1:5fc1b50:       throw new UnsupportedOperationException("Read-only view");
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:5fc1b50:      * Set the value at the given index, without checking bounds
1:5fc1b50:      *
1:5fc1b50:      * @param index an int index into the receiver
1:a8d3dbd:      * @param increment a double value to set
1:5fc1b50:      */
1:5fc1b50:     @Override
1:0a0fddf:     public void incrementQuick(int index, double increment) {
1:0a0fddf:       throw new UnsupportedOperationException("Read-only view");
1:0a0fddf:     }
1:0a0fddf: 
1:0a0fddf:     /**
1:5fc1b50:      * Return the number of values in the recipient which are not the default value.  For instance, for
1:5fc1b50:      * a sparse vector, this would be the number of non-zero values.
1:5fc1b50:      *
1:5fc1b50:      * @return an int
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     public int getNumNondefaultElements() {
1:5fc1b50:       return buffer.limit();
1:5fc1b50:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double getLookupCost() {
1:a8d3dbd:       return 1;
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double getIteratorAdvanceCost() {
1:a8d3dbd:       return 1;
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isAddConstantTime() {
1:a8d3dbd:       throw new UnsupportedOperationException("Can't add binary value");
1:a8d3dbd:     }
1:5fc1b50:   }
1:5fc1b50: 
1:5fc1b50:   public static class BinaryReadOnlyElement implements Vector.Element {
1:8b6a26a:     private final int index;
1:5fc1b50: 
1:5fc1b50:     public BinaryReadOnlyElement(int index) {
1:5fc1b50:       this.index = index;
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:5fc1b50:      * @return the value of this vector element.
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     public double get() {
1:5fc1b50:       return 1;
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:5fc1b50:      * @return the index of this vector element.
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     public int index() {
1:5fc1b50:       return index;
1:5fc1b50:     }
1:5fc1b50: 
1:5fc1b50:     /**
1:5fc1b50:      * @param value Set the current element to value.
1:5fc1b50:      */
1:5fc1b50:     @Override
1:5fc1b50:     public void set(double value) {
1:5fc1b50:       throw new UnsupportedOperationException("Can't set binary value");
1:5fc1b50:     }
1:5fc1b50:   }
1:5fc1b50: }
============================================================================
author:Karl Richter
-------------------------------------------------------------------------------
commit:b5c2879
/////////////////////////////////////////////////////////////////////////
1:  * <p>
1:  * <p>
1:  * <p>
author:Dmitriy Lyubimov
-------------------------------------------------------------------------------
commit:0b564c7
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public Vector like(int cardinality) {
1:       return new RandomAccessSparseVector(cardinality);
1:     }
1: 
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:8b194c8
/////////////////////////////////////////////////////////////////////////
1:      * Copy the vector for fast operations.
commit:58cc1ae
/////////////////////////////////////////////////////////////////////////
1:         new Function<Vector.Element, Integer>() {
1:           @Override
1:           public Integer apply(Vector.Element element) {
1:             return element.index();
1:           }
1:         }));
/////////////////////////////////////////////////////////////////////////
0:      * Copy the vector for fast OPERATIONS.
commit:bdb1c48
/////////////////////////////////////////////////////////////////////////
1:   public void setData(File f) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     return new SparseBinaryVector(tmp, columnSize());
1:     private SparseBinaryVector(IntBuffer buffer, int maxIndex) {
/////////////////////////////////////////////////////////////////////////
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:     } else if (high == low && row.get(low) == columnIndex) {
/////////////////////////////////////////////////////////////////////////
1:             return new BinaryReadOnlyElement(buffer.get(i++));
1:           } else {
1:             return endOfData();
1:           }
1:       };
1:     }
author:Jacob Alexander Mannix
-------------------------------------------------------------------------------
commit:dc62944
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.Iterables;
/////////////////////////////////////////////////////////////////////////
1:       List<Integer> columns = Lists.newArrayList(Iterables.transform(row.vector().nonZeroes(),
0:                                                  new Function<Vector.Element, Integer>() {
1:                                                    @Override
0:                                                    public Integer apply(Vector.Element element) {
0:                                                      return element.index();
1:                                                    }
0:                                                  }));
author:dfilimon
-------------------------------------------------------------------------------
commit:a8d3dbd
/////////////////////////////////////////////////////////////////////////
1:      * Used internally by assign() to update multiple indices and values at once.
1:      * Only really useful for sparse vectors (especially SequentialAccessSparseVector).
1:      * <p/>
1:      * If someone ever adds a new type of sparse vectors, this method must merge (index, value) pairs into the vector.
1:      *
1:      * @param updates a mapping of indices to values to merge in the vector.
1:      */
1:     @Override
1:     public void mergeUpdates(OrderedIntDoubleMapping updates) {
1:       throw new UnsupportedOperationException("Cannot mutate SparseBinaryVector");
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * @param increment a double value to set
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public double getLookupCost() {
1:       return 1;
1:     }
1: 
1:     @Override
1:     public double getIteratorAdvanceCost() {
1:       return 1;
1:     }
1: 
1:     @Override
1:     public boolean isAddConstantTime() {
1:       throw new UnsupportedOperationException("Can't add binary value");
1:     }
author:Robin Anil
-------------------------------------------------------------------------------
commit:0a0fddf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.base.Function;
1: import com.google.common.base.Preconditions;
1: import com.google.common.collect.AbstractIterator;
0: import com.google.common.collect.Iterators;
1: import com.google.common.collect.Lists;
1: 
/////////////////////////////////////////////////////////////////////////
0:      * Copy the vector for fast operations.
1:      *
1:      * @return a Vector
1:      */
1:     @Override
1:     protected Vector createOptimizedCopy() {
1:       return new RandomAccessSparseVector(size()).assign(this);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Set the value at the given index, without checking bounds
1:      *
1:      * @param index an int index into the receiver
1:      * @param value a double value to set
1:      */
1:     @Override
1:     public void incrementQuick(int index, double increment) {
1:       throw new UnsupportedOperationException("Read-only view");
1:     }
1: 
1:     /**
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:d688be0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:           public Integer apply(Vector.Element element) {
commit:8b6a26a
/////////////////////////////////////////////////////////////////////////
1: public final class FileBasedSparseBinaryMatrix extends AbstractMatrix {
1:   private final List<IntBuffer> data = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:       int nondefaultElements = row.vector().getNumNondefaultElements();
/////////////////////////////////////////////////////////////////////////
1:     int low = 0;
/////////////////////////////////////////////////////////////////////////
1:     private final IntBuffer buffer;
1:     private final int maxIndex;
/////////////////////////////////////////////////////////////////////////
1:     SparseBinaryVector(ByteBuffer row, int maxIndex, int offset, int size) {
/////////////////////////////////////////////////////////////////////////
1:     private final int index;
author:Ted Dunning
-------------------------------------------------------------------------------
commit:5fc1b50
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.math;
1: 
0: import com.google.common.base.Function;
0: import com.google.common.base.Preconditions;
0: import com.google.common.collect.AbstractIterator;
0: import com.google.common.collect.Iterators;
0: import com.google.common.collect.Lists;
1: 
0: import javax.annotation.Nullable;
1: import java.io.DataOutputStream;
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.nio.ByteBuffer;
1: import java.nio.IntBuffer;
1: import java.nio.channels.FileChannel;
1: import java.util.Collections;
1: import java.util.Iterator;
1: import java.util.List;
1: 
1: /**
1:  * Provides a way to get data from a file and treat it as if it were a matrix, but avoids putting
1:  * all that data onto the Java heap.  Instead, the file is mapped into non-heap memory as a
1:  * DoubleBuffer and we access that instead.  The interesting aspect of this is that the values in
1:  * the matrix are binary and sparse so we don't need to store the actual data, just the location of
1:  * non-zero values.
0:  * <p/>
1:  * Currently file data is formatted as follows:
0:  * <p/>
1:  * <ul> <li>A magic number to indicate the file format.</li> <li>The size of the matrix (max rows
1:  * and columns possible)</li> <li>Number of non-zeros in each row.</li> <li>A list of non-zero
1:  * columns for each row.  The list starts with a count and then has column numbers</li> </ul>
0:  * <p/>
1:  * It would be preferable to use something like protobufs to define the format so that we can use
1:  * different row formats for different kinds of data.  For instance, Golay coding of column numbers
1:  * or compressed bit vectors might be good representations for some purposes.
1:  */
0: public class FileBasedSparseBinaryMatrix extends AbstractMatrix {
1:   private static final int MAGIC_NUMBER_V0 = 0x12d7067d;
1: 
0:   private List<IntBuffer> data = Lists.newArrayList();
1:   private int[] bufferIndex;
1:   private int[] rowOffset;
1:   private int[] rowSize;
1: 
1:   /**
1:    * Constructs an empty matrix of the given size.
1:    *
1:    * @param rows    The number of rows in the result.
1:    * @param columns The number of columns in the result.
1:    */
1:   public FileBasedSparseBinaryMatrix(int rows, int columns) {
1:     super(rows, columns);
1:   }
1: 
0:   public void setData(File f, boolean loadNow) throws IOException {
1:     List<ByteBuffer> buffers = Lists.newArrayList();
1:     FileChannel input = new FileInputStream(f).getChannel();
1: 
1:     buffers.add(input.map(FileChannel.MapMode.READ_ONLY, 0, Math.min(Integer.MAX_VALUE, f.length())));
1:     data.add(buffers.get(0).asIntBuffer());
1:     Preconditions.checkArgument(buffers.get(0).getInt() == MAGIC_NUMBER_V0, "Wrong type of file");
1: 
1:     int rows = buffers.get(0).getInt();
1:     int cols = buffers.get(0).getInt();
1:     Preconditions.checkArgument(rows == rowSize());
1:     Preconditions.checkArgument(cols == columnSize());
1: 
1:     rowOffset = new int[rows];
1:     rowSize = new int[rows];
1:     bufferIndex = new int[rows];
1: 
1:     int offset = 12 + 4 * rows;
1:     for (int i = 0; i < rows; i++) {
1:       int size = buffers.get(0).getInt();
1:       int buffer = 0;
1:       while (buffer < buffers.size()) {
1:         if (offset + size * 4 <= buffers.get(buffer).limit()) {
1:           break;
1:         } else {
1:           offset -= buffers.get(buffer).capacity();
1:         }
1:       }
1:       if (buffer == buffers.size()) {
1:         buffers.add(input.map(FileChannel.MapMode.READ_ONLY, 0, Math.min(Integer.MAX_VALUE, f.length() - offset)));
1:         data.add(buffers.get(buffer).asIntBuffer());
1:       }
1:       rowOffset[i] = offset / 4;
1:       rowSize[i] = size;
1:       bufferIndex[i] = buffer;
1: 
1: //      final SparseBinaryVector v = new SparseBinaryVector(buffers.get(buffer), columns, offset, size);
1: //      this.rows.add(v);
1:       offset += size * 4;
1:     }
1:   }
1: 
1:   public static void writeMatrix(File f, Matrix m) throws IOException {
1:     Preconditions.checkArgument(f.canWrite(), "Can't write to output file");
1:     FileOutputStream fos = new FileOutputStream(f);
1: 
1:     // write header
1:     DataOutputStream out = new DataOutputStream(fos);
1:     out.writeInt(MAGIC_NUMBER_V0);
1:     out.writeInt(m.rowSize());
1:     out.writeInt(m.columnSize());
1: 
1:     // compute offsets and write row headers
1:     for (MatrixSlice row : m) {
0:       final int nondefaultElements = row.vector().getNumNondefaultElements();
1:       out.writeInt(nondefaultElements);
1:     }
1: 
1:     // write rows
1:     for (MatrixSlice row : m) {
0:       List<Integer> columns = Lists.newArrayList(Iterators.transform(row.vector().iterateNonZero(),
0:         new Function<Vector.Element, Integer>() {
1:           @Override
0:           public Integer apply(@Nullable Vector.Element element) {
0:             return element.index();
1:           }
0:         }));
1:       Collections.sort(columns);
1: 
1:       for (Integer column : columns) {
1:         out.writeInt(column);
1:       }
1:     }
1: 
1:     out.close();
1:     fos.close();
1:   }
1: 
1:   /**
1:    * Assign the other vector values to the column of the receiver
1:    *
1:    * @param column the int row to assign
1:    * @param other  a Vector
1:    * @return the modified receiver
1:    * @throws org.apache.mahout.math.CardinalityException
1:    *          if the cardinalities differ
1:    */
1:   @Override
1:   public Matrix assignColumn(int column, Vector other) {
1:     throw new UnsupportedOperationException("Default operation");
1:   }
1: 
1:   /**
1:    * Assign the other vector values to the row of the receiver
1:    *
1:    * @param row   the int row to assign
1:    * @param other a Vector
1:    * @return the modified receiver
1:    * @throws org.apache.mahout.math.CardinalityException
1:    *          if the cardinalities differ
1:    */
1:   @Override
1:   public Matrix assignRow(int row, Vector other) {
1:     throw new UnsupportedOperationException("Default operation");
1:   }
1: 
1:   /**
1:    * Return the value at the given indexes, without checking bounds
1:    *
1:    * @param rowIndex    an int row index
1:    * @param columnIndex an int column index
1:    * @return the double at the index
1:    */
1:   @Override
1:   public double getQuick(int rowIndex, int columnIndex) {
1:     IntBuffer tmp = data.get(bufferIndex[rowIndex]).asReadOnlyBuffer();
1:     tmp.position(rowOffset[rowIndex]);
1:     tmp.limit(rowSize[rowIndex]);
1:     tmp = tmp.slice();
1:     return searchForIndex(tmp, columnIndex);
1:   }
1: 
1:   private static double searchForIndex(IntBuffer row, int columnIndex) {
0:     int low = 0;
1:     int high = row.limit();
1:     if (high == 0) {
1:       return 0;
1:     }
1:     while (high > low) {
1:       int mid = (low + high) / 2;
1:       if (row.get(mid) < columnIndex) {
1:         low = mid + 1;
1:       } else {
1:         high = mid;
1:       }
1:     }
1:     if (low >= row.limit()) {
1:       return 0;
1:     }
0:     else if (high == low && row.get(low) == columnIndex) {
1:       return 1;
1:     } else {
1:       return 0;
1:     }
1:   }
1: 
1:   /**
1:    * Return an empty matrix of the same underlying class as the receiver
1:    *
1:    * @return a Matrix
1:    */
1:   @Override
1:   public Matrix like() {
1:     throw new UnsupportedOperationException("Default operation");
1:   }
1: 
1:   /**
1:    * Returns an empty matrix of the same underlying class as the receiver and of the specified
1:    * size.
1:    *
1:    * @param rows    the int number of rows
1:    * @param columns the int number of columns
1:    */
1:   @Override
1:   public Matrix like(int rows, int columns) {
1:     return new DenseMatrix(rows, columns);
1:   }
1: 
1:   /**
1:    * Set the value at the given index, without checking bounds
1:    *
1:    * @param row    an int row index into the receiver
1:    * @param column an int column index into the receiver
1:    * @param value  a double value to set
1:    */
1:   @Override
1:   public void setQuick(int row, int column, double value) {
1:     throw new UnsupportedOperationException("Default operation");
1:   }
1: 
1:   /**
1:    * Return a view into part of a matrix.  Changes to the view will change the original matrix.
1:    *
1:    * @param offset an int[2] offset into the receiver
1:    * @param size   the int[2] size of the desired result
1:    * @return a matrix that shares storage with part of the original matrix.
1:    * @throws org.apache.mahout.math.CardinalityException
1:    *          if the length is greater than the cardinality of the receiver
1:    * @throws org.apache.mahout.math.IndexException
1:    *          if the offset is negative or the offset+length is outside of the receiver
1:    */
1:   @Override
1:   public Matrix viewPart(int[] offset, int[] size) {
1:     throw new UnsupportedOperationException("Default operation");
1:   }
1: 
1:   /**
1:    * Returns a view of a row.  Changes to the view will affect the original.
1:    *
1:    * @param rowIndex Which row to return.
1:    * @return A vector that references the desired row.
1:    */
1:   @Override
1:   public Vector viewRow(int rowIndex) {
1:     IntBuffer tmp = data.get(bufferIndex[rowIndex]).asReadOnlyBuffer();
1:     tmp.position(rowOffset[rowIndex]);
1:     tmp.limit(rowOffset[rowIndex] + rowSize[rowIndex]);
1:     tmp = tmp.slice();
0:     return new SparseBinaryVector(rowSize[rowIndex], tmp, columnSize());
1:   }
1: 
1:   private static class SparseBinaryVector extends AbstractVector {
0:     private IntBuffer buffer;
0:     private int maxIndex;
1: 
0:     private SparseBinaryVector(int size, IntBuffer buffer, int maxIndex) {
1:       super(maxIndex);
1:       this.buffer = buffer;
1:       this.maxIndex = maxIndex;
1:     }
1: 
0:     public SparseBinaryVector(ByteBuffer row, int maxIndex, int offset, int size) {
1:       super(maxIndex);
1:       row = row.asReadOnlyBuffer();
1:       row.position(offset);
1:       row.limit(offset + size * 4);
1:       row = row.slice();
1:       this.buffer = row.slice().asIntBuffer();
1:       this.maxIndex = maxIndex;
1:     }
1: 
1:     /**
1:      * Subclasses must override to return an appropriately sparse or dense result
1:      *
1:      * @param rows    the row cardinality
1:      * @param columns the column cardinality
1:      * @return a Matrix
1:      */
1:     @Override
1:     protected Matrix matrixLike(int rows, int columns) {
1:       throw new UnsupportedOperationException("Default operation");
1:     }
1: 
1:     /**
1:      * @return true iff this implementation should be considered dense -- that it explicitly represents
1:      *         every value
1:      */
1:     @Override
1:     public boolean isDense() {
1:       return false;
1:     }
1: 
1:     /**
1:      * @return true iff this implementation should be considered to be iterable in index order in an
1:      *         efficient way. In particular this implies that {@link #iterator()} and {@link
1:      *         #iterateNonZero()} return elements in ascending order by index.
1:      */
1:     @Override
1:     public boolean isSequentialAccess() {
1:       return true;
1:     }
1: 
1:     /**
1:      * Iterates over all elements
1:      *
1:      * NOTE: Implementations may choose to reuse the Element returned
1:      * for performance reasons, so if you need a copy of it, you should call {@link #getElement(int)}
1:      * for the given index
1:      *
1:      * @return An {@link java.util.Iterator} over all elements
1:      */
1:     @Override
1:     public Iterator<Element> iterator() {
1:       return new AbstractIterator<Element>() {
1:         int i = 0;
0:         int index = 0;
1: 
1:         @Override
1:         protected Element computeNext() {
1:           if (i < maxIndex) {
1:             return new Element() {
1:               int index = i++;
1:               /**
1:                * @return the value of this vector element.
1:                */
1:               @Override
1:               public double get() {
1:                 return getQuick(index);
1:               }
1: 
1:               /**
1:                * @return the index of this vector element.
1:                */
1:               @Override
1:               public int index() {
1:                 return index;
1:               }
1: 
1:               /**
1:                * @param value Set the current element to value.
1:                */
1:               @Override
1:               public void set(double value) {
1:                 throw new UnsupportedOperationException("Default operation");
1:               }
1:             };
1:           } else {
1:             return endOfData();
1:           }
1:         }
1:       };
1:     }
1: 
1:     /**
1:       * Iterates over all non-zero elements. <p/> NOTE: Implementations may choose to reuse the Element
1:       * returned for performance reasons, so if you need a copy of it, you should call {@link
1:       * #getElement(int)} for the given index
1:       *
1:       * @return An {@link java.util.Iterator} over all non-zero elements
1:       */
1:     @Override
1:     public Iterator<Element> iterateNonZero() {
1:       return new AbstractIterator<Element>() {
1:         int i = 0;
1:         @Override
1:         protected Element computeNext() {
1:           if (i < buffer.limit()) {
0:           return new BinaryReadOnlyElement(buffer.get(i++));
1:         } else {
1:           return endOfData();
1:         }
1:       }
1:     };
1:   }
1: 
1:   /**
1:      * Return the value at the given index, without checking bounds
1:      *
1:      * @param index an int index
1:      * @return the double at the index
1:      */
1:     @Override
1:     public double getQuick(int index) {
1:       return searchForIndex(buffer, index);
1:     }
1: 
1:     /**
1:      * Return an empty vector of the same underlying class as the receiver
1:      *
1:      * @return a Vector
1:      */
1:     @Override
1:     public Vector like() {
1:       return new RandomAccessSparseVector(size());
1:     }
1: 
1:     /**
1:      * Set the value at the given index, without checking bounds
1:      *
1:      * @param index an int index into the receiver
0:      * @param value a double value to set
1:      */
1:     @Override
1:     public void setQuick(int index, double value) {
1:       throw new UnsupportedOperationException("Read-only view");
1:     }
1: 
1:     /**
1:      * Return the number of values in the recipient which are not the default value.  For instance, for
1:      * a sparse vector, this would be the number of non-zero values.
1:      *
1:      * @return an int
1:      */
1:     @Override
1:     public int getNumNondefaultElements() {
1:       return buffer.limit();
1:     }
1:   }
1: 
1:   public static class BinaryReadOnlyElement implements Vector.Element {
0:     private int index;
1: 
1:     public BinaryReadOnlyElement(int index) {
1:       this.index = index;
1:     }
1: 
1:     /**
1:      * @return the value of this vector element.
1:      */
1:     @Override
1:     public double get() {
1:       return 1;
1:     }
1: 
1:     /**
1:      * @return the index of this vector element.
1:      */
1:     @Override
1:     public int index() {
1:       return index;
1:     }
1: 
1:     /**
1:      * @param value Set the current element to value.
1:      */
1:     @Override
1:     public void set(double value) {
1:       throw new UnsupportedOperationException("Can't set binary value");
1:     }
1:   }
1: }
============================================================================