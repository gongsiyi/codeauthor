1:35fa73f: /**
1:35fa73f:  * Licensed to the Apache Software Foundation (ASF) under one
1:35fa73f:  * or more contributor license agreements. See the NOTICE file
1:35fa73f:  * distributed with this work for additional information
1:35fa73f:  * regarding copyright ownership. The ASF licenses this file
1:35fa73f:  * to you under the Apache License, Version 2.0 (the
1:35fa73f:  * "License"); you may not use this file except in compliance
1:35fa73f:  * with the License. You may obtain a copy of the License at
1:35fa73f:  *
1:35fa73f:  * http://www.apache.org/licenses/LICENSE-2.0
1:35fa73f:  *
1:35fa73f:  * Unless required by applicable law or agreed to in writing,
1:35fa73f:  * software distributed under the License is distributed on an
1:35fa73f:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:35fa73f:  * KIND, either express or implied. See the License for the
1:35fa73f:  * specific language governing permissions and limitations
1:35fa73f:  * under the License.
1:35fa73f:  */
3:35fa73f: 
1:35fa73f: package org.apache.mahout.math.set;
1:35fa73f: 
1:ca9b6d0: import java.nio.ByteBuffer;
1:35fa73f: import java.util.ArrayList;
1:35fa73f: import java.util.Arrays;
1:35fa73f: import java.util.Collection;
1:35fa73f: import java.util.Iterator;
1:35fa73f: import java.util.List;
1:35fa73f: import java.util.Set;
1:35fa73f: 
1:ca9b6d0: import org.apache.mahout.math.MurmurHash;
1:35fa73f: import org.apache.mahout.math.function.ObjectProcedure;
1:35fa73f: import org.apache.mahout.math.map.PrimeFinder;
1:35fa73f: 
1:35fa73f: /**
1:35fa73f:   * Open hashing alternative to java.util.HashSet.
1:35fa73f:  **/
1:35fa73f: public class OpenHashSet<T> extends AbstractSet implements Set<T>  {
1:35fa73f:   protected static final byte FREE = 0;
1:35fa73f:   protected static final byte FULL = 1;
1:35fa73f:   protected static final byte REMOVED = 2;
1:35fa73f:   protected static final char NO_KEY_VALUE = 0;
1:35fa73f: 
1:35fa73f:   /** The hash table keys. */
1:35fa73f:   private Object[] table;
1:35fa73f: 
1:35fa73f:   /** The state of each hash table entry (FREE, FULL, REMOVED). */
1:35fa73f:   private byte[] state;
1:35fa73f: 
1:35fa73f:   /** The number of table entries in state==FREE. */
1:35fa73f:   private int freeEntries;
1:35fa73f: 
1:35fa73f: 
1:35fa73f:   /** Constructs an empty map with default capacity and default load factors. */
1:35fa73f:   public OpenHashSet() {
1:6d16230:     this(DEFAULT_CAPACITY);
1:35fa73f:   }
1:ca9b6d0: 
1:35fa73f:   /**
1:35fa73f:    * Constructs an empty map with the specified initial capacity and default load factors.
1:35fa73f:    *
1:35fa73f:    * @param initialCapacity the initial capacity of the map.
1:35fa73f:    * @throws IllegalArgumentException if the initial capacity is less than zero.
1:35fa73f:    */
1:35fa73f:   public OpenHashSet(int initialCapacity) {
1:6d16230:     this(initialCapacity, DEFAULT_MIN_LOAD_FACTOR, DEFAULT_MAX_LOAD_FACTOR);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.
1:35fa73f:    *
1:35fa73f:    * @param initialCapacity the initial capacity.
1:35fa73f:    * @param minLoadFactor   the minimum load factor.
1:35fa73f:    * @param maxLoadFactor   the maximum load factor.
1:35fa73f:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:35fa73f:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:35fa73f:    *                                  maxLoadFactor)</tt>.
1:35fa73f:    */
1:35fa73f:   public OpenHashSet(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:35fa73f:     setUp(initialCapacity, minLoadFactor, maxLoadFactor);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /** Removes all values associations from the receiver. Implicitly calls <tt>trimToSize()</tt>. */
1:ca9b6d0:   @Override
1:35fa73f:   public void clear() {
1:35fa73f:     Arrays.fill(this.state, 0, state.length - 1, FREE);
1:35fa73f:     distinct = 0;
1:35fa73f:     freeEntries = table.length; // delta
1:35fa73f:     trimToSize();
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns a deep copy of the receiver.
1:35fa73f:    *
1:35fa73f:    * @return a deep copy of the receiver.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   @Override
1:35fa73f:   public Object clone() {
1:35fa73f:     OpenHashSet<T> copy = (OpenHashSet<T>) super.clone();
1:35fa73f:     copy.table = copy.table.clone();
1:35fa73f:     copy.state = copy.state.clone();
1:35fa73f:     return copy;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns <tt>true</tt> if the receiver contains the specified key.
1:35fa73f:    *
1:35fa73f:    * @return <tt>true</tt> if the receiver contains the specified key.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public boolean contains(Object key) {
1:35fa73f:     return indexOfKey((T)key) >= 0;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Ensures that the receiver can hold at least the specified number of associations without needing to allocate new
1:35fa73f:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This
1:35fa73f:    * method never need be called; it is for performance tuning only. Calling this method before <tt>add()</tt>ing a
1:35fa73f:    * large number of associations boosts performance, because the receiver will grow only once instead of potentially
1:35fa73f:    * many times and hash collisions get less probable.
1:35fa73f:    *
1:35fa73f:    * @param minCapacity the desired minimum capacity.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   public void ensureCapacity(int minCapacity) {
1:35fa73f:     if (table.length < minCapacity) {
1:35fa73f:       int newCapacity = nextPrime(minCapacity);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Applies a procedure to each key of the receiver, if any. Note: Iterates over the keys in no particular order.
1:35fa73f:    * Subclasses can define a particular order, for example, "sorted by key". All methods which <i>can</i> be expressed
1:35fa73f:    * in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this
1:35fa73f:    * method, even if it is no particular order. This is necessary so that, for example, methods <tt>keys</tt> and
1:35fa73f:    * <tt>values</tt> will yield association pairs, not two uncorrelated lists.
1:35fa73f:    *
1:35fa73f:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
1:35fa73f:    *                  continues.
1:35fa73f:    * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public boolean forEachKey(ObjectProcedure<T> procedure) {
1:35fa73f:     for (int i = table.length; i-- > 0;) {
1:35fa73f:       if (state[i] == FULL) {
1:35fa73f:         if (!procedure.apply((T)table[i])) {
1:35fa73f:           return false;
1:35fa73f:         }
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:     return true;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * @param key the key to be added to the receiver.
1:35fa73f:    * @return the index where the key would need to be inserted, if it is not already contained. Returns -index-1 if the
1:35fa73f:    *         key is already contained at slot index. Therefore, if the returned index < 0, then it is already contained
1:35fa73f:    *         at slot -index-1. If the returned index >= 0, then it is NOT already contained and should be inserted at
1:35fa73f:    *         slot index.
1:35fa73f:    */
1:35fa73f:   protected int indexOfInsertion(T key) {
1:35fa73f:     Object[] tab = table;
1:35fa73f:     byte[] stat = state;
1:35fa73f:     int length = tab.length;
1:35fa73f: 
1:35fa73f:     int hash = key.hashCode() & 0x7FFFFFFF;
1:35fa73f:     int i = hash % length;
1:35fa73f:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
1:35fa73f:     //int decrement = (hash / length) % length;
1:35fa73f:     if (decrement == 0) {
1:35fa73f:       decrement = 1;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     // stop if we find a removed or free slot, or if we find the key itself
1:35fa73f:     // do NOT skip over removed slots (yes, open addressing is like that...)
1:35fa73f:     while (stat[i] == FULL && tab[i] != key) {
1:35fa73f:       i -= decrement;
1:35fa73f:       //hashCollisions++;
1:35fa73f:       if (i < 0) {
1:35fa73f:         i += length;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     if (stat[i] == REMOVED) {
1:35fa73f:       // stop if we find a free slot, or if we find the key itself.
1:35fa73f:       // do skip over removed slots (yes, open addressing is like that...)
1:35fa73f:       // assertion: there is at least one FREE slot.
1:35fa73f:       int j = i;
1:35fa73f:       while (stat[i] != FREE && (stat[i] == REMOVED || tab[i] != key)) {
1:35fa73f:         i -= decrement;
1:35fa73f:         //hashCollisions++;
1:35fa73f:         if (i < 0) {
1:35fa73f:           i += length;
1:35fa73f:         }
1:35fa73f:       }
1:35fa73f:       if (stat[i] == FREE) {
1:35fa73f:         i = j;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f: 
1:35fa73f: 
1:35fa73f:     if (stat[i] == FULL) {
1:35fa73f:       // key already contained at slot i.
1:35fa73f:       // return a negative number identifying the slot.
1:35fa73f:       return -i - 1;
1:35fa73f:     }
1:35fa73f:     // not already contained, should be inserted at slot i.
1:35fa73f:     // return a number >= 0 identifying the slot.
1:35fa73f:     return i;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * @param key the key to be searched in the receiver.
1:35fa73f:    * @return the index where the key is contained in the receiver, returns -1 if the key was not found.
1:35fa73f:    */
1:35fa73f:   protected int indexOfKey(T key) {
1:35fa73f:     Object[] tab = table;
1:35fa73f:     byte[] stat = state;
1:35fa73f:     int length = tab.length;
1:35fa73f: 
1:35fa73f:     int hash = key.hashCode() & 0x7FFFFFFF;
1:35fa73f:     int i = hash % length;
1:35fa73f:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
1:35fa73f:     //int decrement = (hash / length) % length;
1:35fa73f:     if (decrement == 0) {
1:35fa73f:       decrement = 1;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     // stop if we find a free slot, or if we find the key itself.
1:35fa73f:     // do skip over removed slots (yes, open addressing is like that...)
1:35fa73f:     while (stat[i] != FREE && (stat[i] == REMOVED || (!key.equals(tab[i])))) {
1:35fa73f:       i -= decrement;
1:35fa73f:       //hashCollisions++;
1:35fa73f:       if (i < 0) {
1:35fa73f:         i += length;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     if (stat[i] == FREE) {
1:35fa73f:       return -1;
1:35fa73f:     } // not found
1:35fa73f:     return i; //found, return index where key is contained
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Fills all keys contained in the receiver into the specified list. Fills the list, starting at index 0. After this
1:35fa73f:    * call returns the specified list has a new size that equals <tt>this.size()</tt>. 
1:35fa73f:    * This method can be used
1:35fa73f:    * to iterate over the keys of the receiver.
1:35fa73f:    *
1:35fa73f:    * @param list the list to be filled, can have any size.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public void keys(List<T> list) {
1:35fa73f:     list.clear();
1:35fa73f:   
1:35fa73f: 
1:35fa73f:     Object [] tab = table;
1:35fa73f:     byte[] stat = state;
1:35fa73f: 
1:35fa73f:     for (int i = tab.length; i-- > 0;) {
1:35fa73f:       if (stat[i] == FULL) {
1:35fa73f:         list.add((T)tab[i]);
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   @Override
1:35fa73f:   public boolean add(Object key) {
1:35fa73f:     int i = indexOfInsertion((T)key);
1:35fa73f:     if (i < 0) { //already contained
1:35fa73f:       return false;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     if (this.distinct > this.highWaterMark) {
1:35fa73f:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:       return add(key);
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     this.table[i] = key;
1:35fa73f:     if (this.state[i] == FREE) {
1:35fa73f:       this.freeEntries--;
1:35fa73f:     }
1:35fa73f:     this.state[i] = FULL;
1:35fa73f:     this.distinct++;
1:35fa73f: 
1:35fa73f:     if (this.freeEntries < 1) { //delta
1:35fa73f:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:       return add(key);
1:35fa73f:     }
1:35fa73f:     
1:35fa73f:     return true;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called
1:35fa73f:    * automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water
1:35fa73f:    * mark.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   protected void rehash(int newCapacity) {
1:35fa73f:     int oldCapacity = table.length;
1:35fa73f:     //if (oldCapacity == newCapacity) return;
1:35fa73f: 
1:35fa73f:     Object[] oldTable = table;
1:35fa73f:     byte[] oldState = state;
1:35fa73f: 
1:35fa73f:     Object[] newTable = new Object[newCapacity];
1:35fa73f:     byte[] newState = new byte[newCapacity];
1:35fa73f: 
1:35fa73f:     this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
1:35fa73f:     this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);
1:35fa73f: 
1:35fa73f:     this.table = newTable;
1:35fa73f:     this.state = newState;
1:35fa73f:     this.freeEntries = newCapacity - this.distinct; // delta
1:35fa73f: 
1:35fa73f:     for (int i = oldCapacity; i-- > 0;) {
1:35fa73f:       if (oldState[i] == FULL) {
1:35fa73f:         Object element = oldTable[i];
1:35fa73f:         int index = indexOfInsertion((T)element);
1:35fa73f:         newTable[index] = element;
1:35fa73f:         newState[index] = FULL;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Removes the given key with its associated element from the receiver, if present.
1:35fa73f:    *
1:35fa73f:    * @param key the key to be removed from the receiver.
1:35fa73f:    * @return <tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   @Override
1:35fa73f:   public boolean remove(Object key) {
1:35fa73f:     int i = indexOfKey((T)key);
1:35fa73f:     if (i < 0) {
1:35fa73f:       return false;
1:35fa73f:     } // key not contained
1:35fa73f: 
1:35fa73f:     this.state[i] = REMOVED;
1:35fa73f:     this.distinct--;
1:35fa73f: 
1:35fa73f:     if (this.distinct < this.lowWaterMark) {
1:35fa73f:       int newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     return true;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Initializes the receiver.
1:35fa73f:    *
1:35fa73f:    * @param initialCapacity the initial capacity of the receiver.
1:35fa73f:    * @param minLoadFactor   the minLoadFactor of the receiver.
1:35fa73f:    * @param maxLoadFactor   the maxLoadFactor of the receiver.
1:35fa73f:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:35fa73f:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:35fa73f:    *                                  maxLoadFactor)</tt>.
1:35fa73f:    */
1:35fa73f:   @Override
1:0844e69:   protected final void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:35fa73f:     int capacity = initialCapacity;
1:35fa73f:     super.setUp(capacity, minLoadFactor, maxLoadFactor);
1:35fa73f:     capacity = nextPrime(capacity);
1:35fa73f:     if (capacity == 0) {
1:35fa73f:       capacity = 1;
1:35fa73f:     } // open addressing needs at least one FREE slot at any time.
1:35fa73f: 
1:35fa73f:     this.table = new Object[capacity];
1:35fa73f:     this.state = new byte[capacity];
1:35fa73f: 
1:35fa73f:     // memory will be exhausted long before this pathological case happens, anyway.
1:35fa73f:     this.minLoadFactor = minLoadFactor;
1:6d16230:     if (capacity == PrimeFinder.LARGEST_PRIME) {
1:35fa73f:       this.maxLoadFactor = 1.0;
1:35fa73f:     } else {
1:35fa73f:       this.maxLoadFactor = maxLoadFactor;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     this.distinct = 0;
1:35fa73f:     this.freeEntries = capacity; // delta
1:35fa73f: 
1:35fa73f:     // lowWaterMark will be established upon first expansion.
1:35fa73f:     // establishing it now (upon instance construction) would immediately make the table shrink upon first put(...).
1:35fa73f:     // After all the idea of an "initialCapacity" implies violating lowWaterMarks when an object is young.
1:35fa73f:     // See ensureCapacity(...)
1:35fa73f:     this.lowWaterMark = 0;
1:35fa73f:     this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
1:35fa73f:    * application can use this operation to minimize the storage of the receiver.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   public void trimToSize() {
1:35fa73f:     // * 1.2 because open addressing's performance exponentially degrades beyond that point
1:35fa73f:     // so that even rehashing the table can take very long
1:35fa73f:     int newCapacity = nextPrime((int) (1 + 1.2 * size()));
1:35fa73f:     if (table.length > newCapacity) {
1:35fa73f:       rehash(newCapacity);
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Access for unit tests.
1:35fa73f:    * @param capacity
1:35fa73f:    * @param minLoadFactor
1:35fa73f:    * @param maxLoadFactor
1:35fa73f:    */
1:35fa73f:   void getInternalFactors(int[] capacity, 
1:35fa73f:       double[] minLoadFactor, 
1:35fa73f:       double[] maxLoadFactor) {
1:35fa73f:     capacity[0] = table.length;
1:35fa73f:     minLoadFactor[0] = this.minLoadFactor;
1:35fa73f:     maxLoadFactor[0] = this.maxLoadFactor;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @Override
1:35fa73f:   public boolean isEmpty() {
1:35fa73f:     return size() == 0;
1:35fa73f:   }
1:35fa73f:   
1:35fa73f:   /**
1:35fa73f:    * OpenHashSet instances are only equal to other OpenHashSet instances, not to 
1:35fa73f:    * any other collection. Hypothetically, we should check for and permit
1:35fa73f:    * equals on other Sets.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public boolean equals(Object obj) {
1:35fa73f:     if (obj == this) {
1:35fa73f:       return true;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     if (!(obj instanceof OpenHashSet)) {
1:35fa73f:       return false;
1:35fa73f:     }
1:35fa73f:     final OpenHashSet<T> other = (OpenHashSet<T>) obj;
1:35fa73f:     if (other.size() != size()) {
1:35fa73f:       return false;
1:35fa73f:     }
1:35fa73f: 
1:6d16230:     return forEachKey(new ObjectProcedure<T>() {
1:35fa73f:       @Override
1:35fa73f:       public boolean apply(T key) {
1:35fa73f:         return other.contains(key);
1:35fa73f:       }
1:6d16230:     });
1:35fa73f:   }
1:35fa73f: 
1:6d16230:   @Override
1:ca9b6d0:   public int hashCode() {
1:ca9b6d0:     ByteBuffer buf = ByteBuffer.allocate(size());
1:ca9b6d0:     for (int i = 0; i < table.length; i++) {
1:ca9b6d0:       Object v = table[i];
1:ca9b6d0:       if (state[i] == FULL) {
1:ca9b6d0:         buf.putInt(v.hashCode());
1:ca9b6d0:       }
1:ca9b6d0:     }
1:ca9b6d0:     return MurmurHash.hash(buf, this.getClass().getName().hashCode());
1:ca9b6d0:   }
1:ca9b6d0: 
1:35fa73f:   /**
1:35fa73f:    * Implement the standard Java Collections iterator. Note that 'remove' is silently
1:35fa73f:    * ineffectual here. This method is provided for convenience, only.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   public Iterator<T> iterator() {
1:02ff22f:     List<T> keyList = new ArrayList<>();
1:35fa73f:     keys(keyList);
1:35fa73f:     return keyList.iterator();
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @Override
1:35fa73f:   public Object[] toArray() {
1:02ff22f:     List<T> keyList = new ArrayList<>();
1:35fa73f:     keys(keyList);
1:35fa73f:     return keyList.toArray();
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @Override
1:35fa73f:   public boolean addAll(Collection<? extends T> c) {
1:35fa73f:     boolean anyAdded = false;
1:6d16230:     for (T o : c) {
1:35fa73f:       boolean added = add(o);
1:35fa73f:       anyAdded |= added;
1:35fa73f:     }
1:35fa73f:     return anyAdded;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @Override
1:35fa73f:   public boolean containsAll(Collection<?> c) {
1:35fa73f:     for (Object o : c) {
1:35fa73f:       if (!contains(o)) {
1:35fa73f:         return false;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:     return true;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @Override
1:35fa73f:   public boolean removeAll(Collection<?> c) {
1:35fa73f:     boolean anyRemoved = false;
1:6d16230:     for (Object o : c) {
1:35fa73f:       boolean removed = remove(o);
1:35fa73f:       anyRemoved |= removed;
1:35fa73f:     }
1:35fa73f:     return anyRemoved;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @Override
1:35fa73f:   public boolean retainAll(Collection<?> c) {
1:35fa73f:     final Collection<?> finalCollection = c;
1:35fa73f:     final boolean[] modified = new boolean[1];
1:35fa73f:     modified[0] = false;
1:35fa73f:     forEachKey(new ObjectProcedure<T>() {
1:35fa73f:       @Override
1:35fa73f:       public boolean apply(T element) {
1:35fa73f:         if (!finalCollection.contains(element)) {
1:35fa73f:           remove(element);
1:35fa73f:           modified[0] = true;
1:35fa73f:         }
1:35fa73f:         return true;
1:35fa73f:       }
1:6d16230:     });
1:35fa73f:     return modified[0];
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @Override
1:0844e69:   public <T1> T1[] toArray(T1[] a) {
1:229aeff:     return keys().toArray(a);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   public List<T> keys() {
1:02ff22f:     List<T> keys = new ArrayList<>();
2:35fa73f:     keys(keys);
1:35fa73f:     return keys;
1:35fa73f:   }
1:35fa73f: }
============================================================================
author:Karl Richter
-------------------------------------------------------------------------------
commit:02ff22f
/////////////////////////////////////////////////////////////////////////
1:     List<T> keyList = new ArrayList<>();
1:     List<T> keyList = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:     List<T> keys = new ArrayList<>();
author:Ted Dunning
-------------------------------------------------------------------------------
commit:0844e69
/////////////////////////////////////////////////////////////////////////
1:   protected final void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
/////////////////////////////////////////////////////////////////////////
1:   public <T1> T1[] toArray(T1[] a) {
commit:ca9b6d0
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.MurmurHash;
/////////////////////////////////////////////////////////////////////////
1: 
1:   @Override
1:   public int hashCode() {
1:     ByteBuffer buf = ByteBuffer.allocate(size());
1:     for (int i = 0; i < table.length; i++) {
1:       Object v = table[i];
1:       if (state[i] == FULL) {
1:         buf.putInt(v.hashCode());
1:       }
1:     }
1:     return MurmurHash.hash(buf, this.getClass().getName().hashCode());
1:   }
1: 
commit:35fa73f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements. See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership. The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License. You may obtain a copy of the License at
1:  *
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied. See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.mahout.math.set;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Set;
1: 
1: import org.apache.mahout.math.function.ObjectProcedure;
1: import org.apache.mahout.math.map.PrimeFinder;
1: 
1: /**
1:   * Open hashing alternative to java.util.HashSet.
1:  **/
1: public class OpenHashSet<T> extends AbstractSet implements Set<T>  {
1:   protected static final byte FREE = 0;
1:   protected static final byte FULL = 1;
1:   protected static final byte REMOVED = 2;
1:   protected static final char NO_KEY_VALUE = 0;
1: 
1:   /** The hash table keys. */
1:   private Object[] table;
1: 
1:   /** The state of each hash table entry (FREE, FULL, REMOVED). */
1:   private byte[] state;
1: 
1:   /** The number of table entries in state==FREE. */
1:   private int freeEntries;
1: 
1: 
1:   /** Constructs an empty map with default capacity and default load factors. */
1:   public OpenHashSet() {
0:     this(defaultCapacity);
1:   }
1: 
1:   /**
1:    * Constructs an empty map with the specified initial capacity and default load factors.
1:    *
1:    * @param initialCapacity the initial capacity of the map.
1:    * @throws IllegalArgumentException if the initial capacity is less than zero.
1:    */
1:   public OpenHashSet(int initialCapacity) {
0:     this(initialCapacity, defaultMinLoadFactor, defaultMaxLoadFactor);
1:   }
1: 
1:   /**
1:    * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.
1:    *
1:    * @param initialCapacity the initial capacity.
1:    * @param minLoadFactor   the minimum load factor.
1:    * @param maxLoadFactor   the maximum load factor.
1:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:    *                                  maxLoadFactor)</tt>.
1:    */
1:   public OpenHashSet(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:     setUp(initialCapacity, minLoadFactor, maxLoadFactor);
1:   }
1: 
1:   /** Removes all values associations from the receiver. Implicitly calls <tt>trimToSize()</tt>. */
1:   @Override
1:   public void clear() {
1:     Arrays.fill(this.state, 0, state.length - 1, FREE);
1:     distinct = 0;
1:     freeEntries = table.length; // delta
1:     trimToSize();
1:   }
1: 
1:   /**
1:    * Returns a deep copy of the receiver.
1:    *
1:    * @return a deep copy of the receiver.
1:    */
1:   @SuppressWarnings("unchecked")
1:   @Override
1:   public Object clone() {
1:     OpenHashSet<T> copy = (OpenHashSet<T>) super.clone();
1:     copy.table = copy.table.clone();
1:     copy.state = copy.state.clone();
1:     return copy;
1:   }
1: 
1:   /**
1:    * Returns <tt>true</tt> if the receiver contains the specified key.
1:    *
1:    * @return <tt>true</tt> if the receiver contains the specified key.
1:    */
1:   @Override
1:   @SuppressWarnings("unchecked")
1:   public boolean contains(Object key) {
1:     return indexOfKey((T)key) >= 0;
1:   }
1: 
1:   /**
1:    * Ensures that the receiver can hold at least the specified number of associations without needing to allocate new
1:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This
1:    * method never need be called; it is for performance tuning only. Calling this method before <tt>add()</tt>ing a
1:    * large number of associations boosts performance, because the receiver will grow only once instead of potentially
1:    * many times and hash collisions get less probable.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   @Override
1:   public void ensureCapacity(int minCapacity) {
1:     if (table.length < minCapacity) {
1:       int newCapacity = nextPrime(minCapacity);
1:       rehash(newCapacity);
1:     }
1:   }
1: 
1:   /**
1:    * Applies a procedure to each key of the receiver, if any. Note: Iterates over the keys in no particular order.
1:    * Subclasses can define a particular order, for example, "sorted by key". All methods which <i>can</i> be expressed
1:    * in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this
1:    * method, even if it is no particular order. This is necessary so that, for example, methods <tt>keys</tt> and
1:    * <tt>values</tt> will yield association pairs, not two uncorrelated lists.
1:    *
1:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
1:    *                  continues.
1:    * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.
1:    */
1:   @SuppressWarnings("unchecked")
1:   public boolean forEachKey(ObjectProcedure<T> procedure) {
1:     for (int i = table.length; i-- > 0;) {
1:       if (state[i] == FULL) {
1:         if (!procedure.apply((T)table[i])) {
1:           return false;
1:         }
1:       }
1:     }
1:     return true;
1:   }
1: 
1:   /**
1:    * @param key the key to be added to the receiver.
1:    * @return the index where the key would need to be inserted, if it is not already contained. Returns -index-1 if the
1:    *         key is already contained at slot index. Therefore, if the returned index < 0, then it is already contained
1:    *         at slot -index-1. If the returned index >= 0, then it is NOT already contained and should be inserted at
1:    *         slot index.
1:    */
1:   protected int indexOfInsertion(T key) {
1:     Object[] tab = table;
1:     byte[] stat = state;
1:     int length = tab.length;
1: 
1:     int hash = key.hashCode() & 0x7FFFFFFF;
1:     int i = hash % length;
1:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
1:     //int decrement = (hash / length) % length;
1:     if (decrement == 0) {
1:       decrement = 1;
1:     }
1: 
1:     // stop if we find a removed or free slot, or if we find the key itself
1:     // do NOT skip over removed slots (yes, open addressing is like that...)
1:     while (stat[i] == FULL && tab[i] != key) {
1:       i -= decrement;
1:       //hashCollisions++;
1:       if (i < 0) {
1:         i += length;
1:       }
1:     }
1: 
1:     if (stat[i] == REMOVED) {
1:       // stop if we find a free slot, or if we find the key itself.
1:       // do skip over removed slots (yes, open addressing is like that...)
1:       // assertion: there is at least one FREE slot.
1:       int j = i;
1:       while (stat[i] != FREE && (stat[i] == REMOVED || tab[i] != key)) {
1:         i -= decrement;
1:         //hashCollisions++;
1:         if (i < 0) {
1:           i += length;
1:         }
1:       }
1:       if (stat[i] == FREE) {
1:         i = j;
1:       }
1:     }
1: 
1: 
1:     if (stat[i] == FULL) {
1:       // key already contained at slot i.
1:       // return a negative number identifying the slot.
1:       return -i - 1;
1:     }
1:     // not already contained, should be inserted at slot i.
1:     // return a number >= 0 identifying the slot.
1:     return i;
1:   }
1: 
1:   /**
1:    * @param key the key to be searched in the receiver.
1:    * @return the index where the key is contained in the receiver, returns -1 if the key was not found.
1:    */
1:   protected int indexOfKey(T key) {
1:     Object[] tab = table;
1:     byte[] stat = state;
1:     int length = tab.length;
1: 
1:     int hash = key.hashCode() & 0x7FFFFFFF;
1:     int i = hash % length;
1:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
1:     //int decrement = (hash / length) % length;
1:     if (decrement == 0) {
1:       decrement = 1;
1:     }
1: 
1:     // stop if we find a free slot, or if we find the key itself.
1:     // do skip over removed slots (yes, open addressing is like that...)
1:     while (stat[i] != FREE && (stat[i] == REMOVED || (!key.equals(tab[i])))) {
1:       i -= decrement;
1:       //hashCollisions++;
1:       if (i < 0) {
1:         i += length;
1:       }
1:     }
1: 
1:     if (stat[i] == FREE) {
1:       return -1;
1:     } // not found
1:     return i; //found, return index where key is contained
1:   }
1: 
1:   /**
1:    * Fills all keys contained in the receiver into the specified list. Fills the list, starting at index 0. After this
1:    * call returns the specified list has a new size that equals <tt>this.size()</tt>. 
1:    * This method can be used
1:    * to iterate over the keys of the receiver.
1:    *
1:    * @param list the list to be filled, can have any size.
1:    */
1:   @SuppressWarnings("unchecked")
1:   public void keys(List<T> list) {
1:     list.clear();
1:   
1: 
1:     Object [] tab = table;
1:     byte[] stat = state;
1: 
1:     for (int i = tab.length; i-- > 0;) {
1:       if (stat[i] == FULL) {
1:         list.add((T)tab[i]);
1:       }
1:     }
1:   }
1: 
1:   @SuppressWarnings("unchecked")
1:   @Override
1:   public boolean add(Object key) {
1:     int i = indexOfInsertion((T)key);
1:     if (i < 0) { //already contained
1:       return false;
1:     }
1: 
1:     if (this.distinct > this.highWaterMark) {
1:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:       rehash(newCapacity);
1:       return add(key);
1:     }
1: 
1:     this.table[i] = key;
1:     if (this.state[i] == FREE) {
1:       this.freeEntries--;
1:     }
1:     this.state[i] = FULL;
1:     this.distinct++;
1: 
1:     if (this.freeEntries < 1) { //delta
1:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:       rehash(newCapacity);
1:       return add(key);
1:     }
1:     
1:     return true;
1:   }
1: 
1:   /**
1:    * Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called
1:    * automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water
1:    * mark.
1:    */
1:   @SuppressWarnings("unchecked")
1:   protected void rehash(int newCapacity) {
1:     int oldCapacity = table.length;
1:     //if (oldCapacity == newCapacity) return;
1: 
1:     Object[] oldTable = table;
1:     byte[] oldState = state;
1: 
1:     Object[] newTable = new Object[newCapacity];
1:     byte[] newState = new byte[newCapacity];
1: 
1:     this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
1:     this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);
1: 
1:     this.table = newTable;
1:     this.state = newState;
1:     this.freeEntries = newCapacity - this.distinct; // delta
1: 
1:     for (int i = oldCapacity; i-- > 0;) {
1:       if (oldState[i] == FULL) {
1:         Object element = oldTable[i];
1:         int index = indexOfInsertion((T)element);
1:         newTable[index] = element;
1:         newState[index] = FULL;
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Removes the given key with its associated element from the receiver, if present.
1:    *
1:    * @param key the key to be removed from the receiver.
1:    * @return <tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.
1:    */
1:   @SuppressWarnings("unchecked")
1:   @Override
1:   public boolean remove(Object key) {
1:     int i = indexOfKey((T)key);
1:     if (i < 0) {
1:       return false;
1:     } // key not contained
1: 
1:     this.state[i] = REMOVED;
1:     this.distinct--;
1: 
1:     if (this.distinct < this.lowWaterMark) {
1:       int newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);
1:       rehash(newCapacity);
1:     }
1: 
1:     return true;
1:   }
1: 
1:   /**
1:    * Initializes the receiver.
1:    *
1:    * @param initialCapacity the initial capacity of the receiver.
1:    * @param minLoadFactor   the minLoadFactor of the receiver.
1:    * @param maxLoadFactor   the maxLoadFactor of the receiver.
1:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:    *                                  maxLoadFactor)</tt>.
1:    */
1:   @Override
0:   protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:     int capacity = initialCapacity;
1:     super.setUp(capacity, minLoadFactor, maxLoadFactor);
1:     capacity = nextPrime(capacity);
1:     if (capacity == 0) {
1:       capacity = 1;
1:     } // open addressing needs at least one FREE slot at any time.
1: 
1:     this.table = new Object[capacity];
1:     this.state = new byte[capacity];
1: 
1:     // memory will be exhausted long before this pathological case happens, anyway.
1:     this.minLoadFactor = minLoadFactor;
0:     if (capacity == PrimeFinder.largestPrime) {
1:       this.maxLoadFactor = 1.0;
1:     } else {
1:       this.maxLoadFactor = maxLoadFactor;
1:     }
1: 
1:     this.distinct = 0;
1:     this.freeEntries = capacity; // delta
1: 
1:     // lowWaterMark will be established upon first expansion.
1:     // establishing it now (upon instance construction) would immediately make the table shrink upon first put(...).
1:     // After all the idea of an "initialCapacity" implies violating lowWaterMarks when an object is young.
1:     // See ensureCapacity(...)
1:     this.lowWaterMark = 0;
1:     this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);
1:   }
1: 
1:   /**
1:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
1:    * application can use this operation to minimize the storage of the receiver.
1:    */
1:   @Override
1:   public void trimToSize() {
1:     // * 1.2 because open addressing's performance exponentially degrades beyond that point
1:     // so that even rehashing the table can take very long
1:     int newCapacity = nextPrime((int) (1 + 1.2 * size()));
1:     if (table.length > newCapacity) {
1:       rehash(newCapacity);
1:     }
1:   }
1: 
1:   /**
1:    * Access for unit tests.
1:    * @param capacity
1:    * @param minLoadFactor
1:    * @param maxLoadFactor
1:    */
1:   void getInternalFactors(int[] capacity, 
1:       double[] minLoadFactor, 
1:       double[] maxLoadFactor) {
1:     capacity[0] = table.length;
1:     minLoadFactor[0] = this.minLoadFactor;
1:     maxLoadFactor[0] = this.maxLoadFactor;
1:   }
1: 
1:   @Override
1:   public boolean isEmpty() {
1:     return size() == 0;
1:   }
1:   
1:   /**
1:    * OpenHashSet instances are only equal to other OpenHashSet instances, not to 
1:    * any other collection. Hypothetically, we should check for and permit
1:    * equals on other Sets.
1:    */
1:   @SuppressWarnings("unchecked")
1:   public boolean equals(Object obj) {
1:     if (obj == this) {
1:       return true;
1:     }
1: 
1:     if (!(obj instanceof OpenHashSet)) {
1:       return false;
1:     }
1:     final OpenHashSet<T> other = (OpenHashSet<T>) obj;
1:     if (other.size() != size()) {
1:       return false;
1:     }
1: 
0:     return
0:         forEachKey(
0:             new ObjectProcedure<T>() {
1:               @Override
1:               public boolean apply(T key) {
1:                 return other.contains(key);
1:               }
1:             }
0:         );
1:   }
1:   
1:   /**
1:    * Implement the standard Java Collections iterator. Note that 'remove' is silently
1:    * ineffectual here. This method is provided for convenience, only.
1:    */
1:   @Override
1:   public Iterator<T> iterator() {
0:     List<T> keyList = new ArrayList<T>();
1:     keys(keyList);
1:     return keyList.iterator();
1:   }
1: 
1:   @Override
1:   public Object[] toArray() {
0:     List<T> keyList = new ArrayList<T>();
1:     keys(keyList);
1:     return keyList.toArray();
1:   }
1: 
1:   @Override
1:   public boolean addAll(Collection<? extends T> c) {
1:     boolean anyAdded = false;
0:     for(T o : c) {
1:       boolean added = add(o);
1:       anyAdded |= added;
1:     }
1:     return anyAdded;
1:   }
1: 
1:   @Override
1:   public boolean containsAll(Collection<?> c) {
1:     for (Object o : c) {
1:       if (!contains(o)) {
1:         return false;
1:       }
1:     }
1:     return true;
1:   }
1: 
1:   @Override
1:   public boolean removeAll(Collection<?> c) {
1:     boolean anyRemoved = false;
0:     for(Object o : c) {
1:       boolean removed = remove(o);
1:       anyRemoved |= removed;
1:     }
1:     return anyRemoved;
1:   }
1: 
1:   @Override
1:   public boolean retainAll(Collection<?> c) {
1:     final Collection<?> finalCollection = c;
1:     final boolean[] modified = new boolean[1];
1:     modified[0] = false;
1:     forEachKey(new ObjectProcedure<T>() {
1: 
1:       @Override
1:       public boolean apply(T element) {
1:         if (!finalCollection.contains(element)) {
1:           remove(element);
1:           modified[0] = true;
1:         }
1:         return true;
0:       }});
1:     return modified[0];
1:   }
1: 
1:   @Override
0:   public <T2> T2[] toArray(T2[] a) {
0:     List<T> keys = new ArrayList<T>();
1:     keys(keys);
0:     return keys.toArray(a);
1:   }
1: 
1:   public List<T> keys() {
0:     List<T> keys = new ArrayList<T>();
1:     keys(keys);
1:     return keys;
1:   }
1: }
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:     this(DEFAULT_CAPACITY);
/////////////////////////////////////////////////////////////////////////
1:     this(initialCapacity, DEFAULT_MIN_LOAD_FACTOR, DEFAULT_MAX_LOAD_FACTOR);
/////////////////////////////////////////////////////////////////////////
1:     if (capacity == PrimeFinder.LARGEST_PRIME) {
/////////////////////////////////////////////////////////////////////////
1:     return forEachKey(new ObjectProcedure<T>() {
1:       @Override
0:       public boolean apply(T key) {
0:         return other.contains(key);
0:       }
1:     });
/////////////////////////////////////////////////////////////////////////
1:     for (T o : c) {
/////////////////////////////////////////////////////////////////////////
1:     for (Object o : c) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       }
1:     });
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:229aeff
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   public <T> T[] toArray(T[] a) {
1:     return keys().toArray(a);
commit:ea65197
/////////////////////////////////////////////////////////////////////////
0:     OpenHashSet<T> copy = (OpenHashSet<T>) super.clone();
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     final OpenHashSet<T> other = (OpenHashSet<T>) obj;
author:Benson Margulies
-------------------------------------------------------------------------------
commit:ebf9a4d
/////////////////////////////////////////////////////////////////////////
commit:d7351cc
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements. See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership. The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License. You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: package org.apache.mahout.math.set;
0: 
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.Collection;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Set;
0: 
0: import org.apache.mahout.math.function.ObjectProcedure;
0: import org.apache.mahout.math.map.PrimeFinder;
0: 
0: /**
0:   * Open hashing alternative to java.util.HashSet.
0:  **/
0: public class OpenHashSet<T> extends AbstractSet implements Set<T>  {
0:   protected static final byte FREE = 0;
0:   protected static final byte FULL = 1;
0:   protected static final byte REMOVED = 2;
0:   protected static final char NO_KEY_VALUE = 0;
0: 
0:   /** The hash table keys. */
0:   protected Object[] table;
0: 
0:   /** The state of each hash table entry (FREE, FULL, REMOVED). */
0:   protected byte[] state;
0: 
0:   /** The number of table entries in state==FREE. */
0:   protected int freeEntries;
0: 
0: 
0:   /** Constructs an empty map with default capacity and default load factors. */
0:   public OpenHashSet() {
0:     this(defaultCapacity);
0:   }
0: 
0:   /**
0:    * Constructs an empty map with the specified initial capacity and default load factors.
0:    *
0:    * @param initialCapacity the initial capacity of the map.
0:    * @throws IllegalArgumentException if the initial capacity is less than zero.
0:    */
0:   public OpenHashSet(int initialCapacity) {
0:     this(initialCapacity, defaultMinLoadFactor, defaultMaxLoadFactor);
0:   }
0: 
0:   /**
0:    * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.
0:    *
0:    * @param initialCapacity the initial capacity.
0:    * @param minLoadFactor   the minimum load factor.
0:    * @param maxLoadFactor   the maximum load factor.
0:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
0:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
0:    *                                  maxLoadFactor)</tt>.
0:    */
0:   public OpenHashSet(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
0:     setUp(initialCapacity, minLoadFactor, maxLoadFactor);
0:   }
0: 
0:   /** Removes all values associations from the receiver. Implicitly calls <tt>trimToSize()</tt>. */
0:   @Override
0:   public void clear() {
0:     Arrays.fill(this.state, 0, state.length - 1, FREE);
0:     distinct = 0;
0:     freeEntries = table.length; // delta
0:     trimToSize();
0:   }
0: 
0:   /**
0:    * Returns a deep copy of the receiver.
0:    *
0:    * @return a deep copy of the receiver.
0:    */
0:   @SuppressWarnings("unchecked")
0:   @Override
0:   public Object clone() {
0:     OpenHashSet copy = (OpenHashSet) super.clone();
0:     copy.table = copy.table.clone();
0:     copy.state = copy.state.clone();
0:     return copy;
0:   }
0: 
0:   /**
0:    * Returns <tt>true</tt> if the receiver contains the specified key.
0:    *
0:    * @return <tt>true</tt> if the receiver contains the specified key.
0:    */
0:   @SuppressWarnings("unchecked")
0:   public boolean contains(Object key) {
0:     return indexOfKey((T)key) >= 0;
0:   }
0: 
0:   /**
0:    * Ensures that the receiver can hold at least the specified number of associations without needing to allocate new
0:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This
0:    * method never need be called; it is for performance tuning only. Calling this method before <tt>add()</tt>ing a
0:    * large number of associations boosts performance, because the receiver will grow only once instead of potentially
0:    * many times and hash collisions get less probable.
0:    *
0:    * @param minCapacity the desired minimum capacity.
0:    */
0:   @Override
0:   public void ensureCapacity(int minCapacity) {
0:     if (table.length < minCapacity) {
0:       int newCapacity = nextPrime(minCapacity);
0:       rehash(newCapacity);
0:     }
0:   }
0: 
0:   /**
0:    * Applies a procedure to each key of the receiver, if any. Note: Iterates over the keys in no particular order.
0:    * Subclasses can define a particular order, for example, "sorted by key". All methods which <i>can</i> be expressed
0:    * in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this
0:    * method, even if it is no particular order. This is necessary so that, for example, methods <tt>keys</tt> and
0:    * <tt>values</tt> will yield association pairs, not two uncorrelated lists.
0:    *
0:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
0:    *                  continues.
0:    * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.
0:    */
0:   @SuppressWarnings("unchecked")
0:   public boolean forEachKey(ObjectProcedure<T> procedure) {
0:     for (int i = table.length; i-- > 0;) {
0:       if (state[i] == FULL) {
0:         if (!procedure.apply((T)table[i])) {
0:           return false;
0:         }
0:       }
0:     }
0:     return true;
0:   }
0: 
0:   /**
0:    * @param key the key to be added to the receiver.
0:    * @return the index where the key would need to be inserted, if it is not already contained. Returns -index-1 if the
0:    *         key is already contained at slot index. Therefore, if the returned index < 0, then it is already contained
0:    *         at slot -index-1. If the returned index >= 0, then it is NOT already contained and should be inserted at
0:    *         slot index.
0:    */
0:   protected int indexOfInsertion(T key) {
0:     Object[] tab = table;
0:     byte[] stat = state;
0:     int length = tab.length;
0: 
0:     int hash = key.hashCode() & 0x7FFFFFFF;
0:     int i = hash % length;
0:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
0:     //int decrement = (hash / length) % length;
0:     if (decrement == 0) {
0:       decrement = 1;
0:     }
0: 
0:     // stop if we find a removed or free slot, or if we find the key itself
0:     // do NOT skip over removed slots (yes, open addressing is like that...)
0:     while (stat[i] == FULL && tab[i] != key) {
0:       i -= decrement;
0:       //hashCollisions++;
0:       if (i < 0) {
0:         i += length;
0:       }
0:     }
0: 
0:     if (stat[i] == REMOVED) {
0:       // stop if we find a free slot, or if we find the key itself.
0:       // do skip over removed slots (yes, open addressing is like that...)
0:       // assertion: there is at least one FREE slot.
0:       int j = i;
0:       while (stat[i] != FREE && (stat[i] == REMOVED || tab[i] != key)) {
0:         i -= decrement;
0:         //hashCollisions++;
0:         if (i < 0) {
0:           i += length;
0:         }
0:       }
0:       if (stat[i] == FREE) {
0:         i = j;
0:       }
0:     }
0: 
0: 
0:     if (stat[i] == FULL) {
0:       // key already contained at slot i.
0:       // return a negative number identifying the slot.
0:       return -i - 1;
0:     }
0:     // not already contained, should be inserted at slot i.
0:     // return a number >= 0 identifying the slot.
0:     return i;
0:   }
0: 
0:   /**
0:    * @param key the key to be searched in the receiver.
0:    * @return the index where the key is contained in the receiver, returns -1 if the key was not found.
0:    */
0:   protected int indexOfKey(T key) {
0:     Object[] tab = table;
0:     byte[] stat = state;
0:     int length = tab.length;
0: 
0:     int hash = key.hashCode() & 0x7FFFFFFF;
0:     int i = hash % length;
0:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
0:     //int decrement = (hash / length) % length;
0:     if (decrement == 0) {
0:       decrement = 1;
0:     }
0: 
0:     // stop if we find a free slot, or if we find the key itself.
0:     // do skip over removed slots (yes, open addressing is like that...)
0:     while (stat[i] != FREE && (stat[i] == REMOVED || (!key.equals(tab[i])))) {
0:       i -= decrement;
0:       //hashCollisions++;
0:       if (i < 0) {
0:         i += length;
0:       }
0:     }
0: 
0:     if (stat[i] == FREE) {
0:       return -1;
0:     } // not found
0:     return i; //found, return index where key is contained
0:   }
0: 
0:   /**
0:    * Fills all keys contained in the receiver into the specified list. Fills the list, starting at index 0. After this
0:    * call returns the specified list has a new size that equals <tt>this.size()</tt>. 
0:    * This method can be used
0:    * to iterate over the keys of the receiver.
0:    *
0:    * @param list the list to be filled, can have any size.
0:    */
0:   @SuppressWarnings("unchecked")
0:   public void keys(List<T> list) {
0:     list.clear();
0:   
0: 
0:     Object [] tab = table;
0:     byte[] stat = state;
0: 
0:     for (int i = tab.length; i-- > 0;) {
0:       if (stat[i] == FULL) {
0:         list.add((T)tab[i]);
0:       }
0:     }
0:   }
0: 
0: 
0:   /**
0:    * Associates the given key with the given value. Replaces any old <tt>(key,someOtherValue)</tt> association, if
0:    * existing.
0:    *
0:    * @param key   the key the value shall be associated with.
0:    * @param value the value to be associated.
0:    * @return <tt>true</tt> if the receiver did not already contain such a key; <tt>false</tt> if the receiver did
0:    *         already contain such a key - the new value has now replaced the formerly associated value.
0:    */
0:   @SuppressWarnings("unchecked")
0:   @Override
0:   public boolean add(Object key) {
0:     int i = indexOfInsertion((T)key);
0:     if (i < 0) { //already contained
0:       return false;
0:     }
0: 
0:     if (this.distinct > this.highWaterMark) {
0:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
0:       /*
0:       log.info("grow rehashing ");
0:       log.info("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");
0:       */
0:       rehash(newCapacity);
0:       return add(key);
0:     }
0: 
0:     this.table[i] = key;
0:     if (this.state[i] == FREE) {
0:       this.freeEntries--;
0:     }
0:     this.state[i] = FULL;
0:     this.distinct++;
0: 
0:     if (this.freeEntries < 1) { //delta
0:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
0:       rehash(newCapacity);
0:       return add(key);
0:     }
0:     
0:     return true;
0:   }
0: 
0:   /**
0:    * Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called
0:    * automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water
0:    * mark.
0:    */
0:   @SuppressWarnings("unchecked")
0:   protected void rehash(int newCapacity) {
0:     int oldCapacity = table.length;
0:     //if (oldCapacity == newCapacity) return;
0: 
0:     Object[] oldTable = table;
0:     byte[] oldState = state;
0: 
0:     Object[] newTable = new Object[newCapacity];
0:     byte[] newState = new byte[newCapacity];
0: 
0:     this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
0:     this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);
0: 
0:     this.table = newTable;
0:     this.state = newState;
0:     this.freeEntries = newCapacity - this.distinct; // delta
0: 
0:     for (int i = oldCapacity; i-- > 0;) {
0:       if (oldState[i] == FULL) {
0:         Object element = oldTable[i];
0:         int index = indexOfInsertion((T)element);
0:         newTable[index] = element;
0:         newState[index] = FULL;
0:       }
0:     }
0:   }
0: 
0:   /**
0:    * Removes the given key with its associated element from the receiver, if present.
0:    *
0:    * @param key the key to be removed from the receiver.
0:    * @return <tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.
0:    */
0:   @SuppressWarnings("unchecked")
0:   @Override
0:   public boolean remove(Object key) {
0:     int i = indexOfKey((T)key);
0:     if (i < 0) {
0:       return false;
0:     } // key not contained
0: 
0:     this.state[i] = REMOVED;
0:     this.distinct--;
0: 
0:     if (this.distinct < this.lowWaterMark) {
0:       int newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);
0:       /*
0:       if (table.length != newCapacity) {
0:         log.info("shrink rehashing ");
0:         log.info("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");
0:       }
0:       */
0:       rehash(newCapacity);
0:     }
0: 
0:     return true;
0:   }
0: 
0:   /**
0:    * Initializes the receiver.
0:    *
0:    * @param initialCapacity the initial capacity of the receiver.
0:    * @param minLoadFactor   the minLoadFactor of the receiver.
0:    * @param maxLoadFactor   the maxLoadFactor of the receiver.
0:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
0:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
0:    *                                  maxLoadFactor)</tt>.
0:    */
0:   @Override
0:   protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
0:     int capacity = initialCapacity;
0:     super.setUp(capacity, minLoadFactor, maxLoadFactor);
0:     capacity = nextPrime(capacity);
0:     if (capacity == 0) {
0:       capacity = 1;
0:     } // open addressing needs at least one FREE slot at any time.
0: 
0:     this.table = new Object[capacity];
0:     this.state = new byte[capacity];
0: 
0:     // memory will be exhausted long before this pathological case happens, anyway.
0:     this.minLoadFactor = minLoadFactor;
0:     if (capacity == PrimeFinder.largestPrime) {
0:       this.maxLoadFactor = 1.0;
0:     } else {
0:       this.maxLoadFactor = maxLoadFactor;
0:     }
0: 
0:     this.distinct = 0;
0:     this.freeEntries = capacity; // delta
0: 
0:     // lowWaterMark will be established upon first expansion.
0:     // establishing it now (upon instance construction) would immediately make the table shrink upon first put(...).
0:     // After all the idea of an "initialCapacity" implies violating lowWaterMarks when an object is young.
0:     // See ensureCapacity(...)
0:     this.lowWaterMark = 0;
0:     this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);
0:   }
0: 
0:   /**
0:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
0:    * application can use this operation to minimize the storage of the receiver.
0:    */
0:   @Override
0:   public void trimToSize() {
0:     // * 1.2 because open addressing's performance exponentially degrades beyond that point
0:     // so that even rehashing the table can take very long
0:     int newCapacity = nextPrime((int) (1 + 1.2 * size()));
0:     if (table.length > newCapacity) {
0:       rehash(newCapacity);
0:     }
0:   }
0: 
0:   /**
0:    * Access for unit tests.
0:    * @param capacity
0:    * @param minLoadFactor
0:    * @param maxLoadFactor
0:    */
0:   void getInternalFactors(int[] capacity, 
0:       double[] minLoadFactor, 
0:       double[] maxLoadFactor) {
0:     capacity[0] = table.length;
0:     minLoadFactor[0] = this.minLoadFactor;
0:     maxLoadFactor[0] = this.maxLoadFactor;
0:   }
0: 
0:   @Override
0:   public boolean isEmpty() {
0:     return size() == 0;
0:   }
0:   
0:   /**
0:    * OpenHashSet instances are only equal to other OpenHashSet instances, not to 
0:    * any other collection. Hypothetically, we should check for and permit
0:    * equals on other Sets.
0:    */
0:   @SuppressWarnings("unchecked")
0:   public boolean equals(Object obj) {
0:     if (obj == this) {
0:       return true;
0:     }
0: 
0:     if (!(obj instanceof OpenHashSet)) {
0:       return false;
0:     }
0:     final OpenHashSet other = (OpenHashSet) obj;
0:     if (other.size() != size()) {
0:       return false;
0:     }
0: 
0:     return
0:         forEachKey(
0:             new ObjectProcedure<T>() {
0:               @Override
0:               public boolean apply(T key) {
0:                 return other.contains(key);
0:               }
0:             }
0:         );
0:   }
0:   
0:   /**
0:    * Implement the standard Java Collections iterator. Note that 'remove' is silently
0:    * ineffectual here. This method is provided for convenience, only.
0:    */
0:   @Override
0:   public Iterator<T> iterator() {
0:     List<T> keyList = new ArrayList<T>();
0:     keys(keyList);
0:     return keyList.iterator();
0:   }
0: 
0:   @Override
0:   public Object[] toArray() {
0:     List<T> keyList = new ArrayList<T>();
0:     keys(keyList);
0:     return keyList.toArray();
0:   }
0: 
0:   @Override
0:   public boolean addAll(Collection<? extends T> c) {
0:     boolean anyAdded = false;
0:     for(T o : c) {
0:       boolean added = add(o);
0:       anyAdded |= added;
0:     }
0:     return anyAdded;
0:   }
0: 
0:   @Override
0:   public boolean containsAll(Collection<?> c) {
0:     for (Object o : c) {
0:       if (!contains(o)) {
0:         return false;
0:       }
0:     }
0:     return true;
0:   }
0: 
0:   @Override
0:   public boolean removeAll(Collection<?> c) {
0:     boolean anyRemoved = false;
0:     for(Object o : c) {
0:       boolean removed = remove(o);
0:       anyRemoved |= removed;
0:     }
0:     return anyRemoved;
0:   }
0: 
0:   @Override
0:   public boolean retainAll(Collection<?> c) {
0:     final Collection<?> finalCollection = c;
0:     final boolean[] modified = new boolean[1];
0:     modified[0] = false;
0:     forEachKey(new ObjectProcedure<T>() {
0: 
0:       @Override
0:       public boolean apply(T element) {
0:         if (!finalCollection.contains(element)) {
0:           remove(element);
0:           modified[0] = true;
0:         }
0:         return true;
0:       }});
0:     return modified[0];
0:   }
0: 
0:   @Override
0:   public <T2> T2[] toArray(T2[] a) {
0:     List<T> keys = new ArrayList<T>();
0:     keys(keys);
0:     return keys.toArray(a);
0:   }
0: 
0:   public List<T> keys() {
0:     List<T> keys = new ArrayList<T>();
0:     keys(keys);
0:     return keys;
0:   }
0: }
============================================================================