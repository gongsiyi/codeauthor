24:7926fcb: /**
1:35fa73f:  * Licensed to the Apache Software Foundation (ASF) under one
1:35fa73f:  * or more contributor license agreements. See the NOTICE file
1:35fa73f:  * distributed with this work for additional information
1:35fa73f:  * regarding copyright ownership. The ASF licenses this file
1:35fa73f:  * to you under the Apache License, Version 2.0 (the
1:35fa73f:  * "License"); you may not use this file except in compliance
1:35fa73f:  * with the License. You may obtain a copy of the License at
40:7926fcb:  *
1:35fa73f:  * http://www.apache.org/licenses/LICENSE-2.0
1:7926fcb:  *
1:35fa73f:  * Unless required by applicable law or agreed to in writing,
1:35fa73f:  * software distributed under the License is distributed on an
1:35fa73f:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:35fa73f:  * KIND, either express or implied. See the License for the
1:35fa73f:  * specific language governing permissions and limitations
1:35fa73f:  * under the License.
23:7926fcb:  */
1:35fa73f: /*
1:35fa73f: Copyright ï¿? 1999 CERN - European Organization for Nuclear Research.
1:35fa73f: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1:35fa73f: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1:35fa73f: that both that copyright notice and this permission notice appear in supporting documentation. 
1:35fa73f: CERN makes no representations about the suitability of this software for any purpose. 
1:35fa73f: It is provided "as is" without expressed or implied warranty.
1:7926fcb: */
1:35fa73f: package org.apache.mahout.math.list;
29:7926fcb: 
1:35fa73f: import org.apache.mahout.math.function.ObjectProcedure;
1:7926fcb: 
1:7926fcb: import java.util.Collection;
1:7926fcb: 
1:7926fcb: /**
1:35fa73f:  Resizable list holding <code>${valueType}</code> elements; implemented with arrays.
1:7926fcb: */
1:7926fcb: 
1:35fa73f: public class ObjectArrayList<T> extends AbstractObjectList<T> {
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * The array buffer into which the elements of the list are stored. The capacity of the list is the length of this
1:7926fcb:    * array buffer.
1:7926fcb:    */
1:35fa73f:   private Object[] elements;
1:35fa73f:   private int size;
1:7926fcb: 
1:7926fcb:   /** Constructs an empty list. */
1:7926fcb:   public ObjectArrayList() {
1:7926fcb:     this(10);
44:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Constructs a list containing the specified elements. The initial size and capacity of the list is the length of the
1:7926fcb:    * array.
1:7926fcb:    *
1:7926fcb:    * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>. So if
1:7926fcb:    * subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.
1:7926fcb:    *
1:7926fcb:    * @param elements the array to be backed by the the constructed list
1:7926fcb:    */
1:35fa73f:   public ObjectArrayList(T[] elements) {
1:7926fcb:     elements(elements);
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Constructs an empty list with the specified initial capacity.
1:7926fcb:    *
1:7926fcb:    * @param initialCapacity the number of elements the receiver can hold without auto-expanding itself by allocating new
1:7926fcb:    *                        internal memory.
1:7926fcb:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:7926fcb:   public ObjectArrayList(int initialCapacity) {
1:b285e2d:     elements = new Object[initialCapacity];
1:b285e2d:     size = 0;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Appends the specified element to the end of this list.
1:7926fcb:    *
1:7926fcb:    * @param element element to be appended to this list.
1:7926fcb:    */
1:35fa73f:   public void add(T element) {
1:fcbc54a:     // overridden for performance only.
1:7926fcb:     if (size == elements.length) {
1:7926fcb:       ensureCapacity(size + 1);
1:7926fcb:     }
1:7926fcb:     elements[size++] = element;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Inserts the specified element before the specified position into the receiver. Shifts the element currently at that
2:7926fcb:    * position (if any) and any subsequent elements to the right.
1:7926fcb:    *
1:7926fcb:    * @param index   index before which the specified element is to be inserted (must be in [0,size]).
1:7926fcb:    * @param element element to be inserted.
2:7926fcb:    * @throws IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).
1:7926fcb:    */
1:35fa73f:   public void beforeInsert(int index, T element) {
1:7926fcb:     // overridden for performance only.
1:35fa73f:     if (size == index) {
1:35fa73f:       add(element);
6:7926fcb:       return;
1:7926fcb:     }
2:7926fcb:     if (index > size || index < 0) {
2:7926fcb:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
1:7926fcb:     }
1:7926fcb:     ensureCapacity(size + 1);
1:7926fcb:     System.arraycopy(elements, index, elements, index + 1, size - index);
1:7926fcb:     elements[index] = element;
1:7926fcb:     size++;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb: 
1:7926fcb:   /**
1:35fa73f:    * Returns a deep copy of the receiver.
1:7926fcb:    *
1:35fa73f:    * @return a deep copy of the receiver.
1:7926fcb:    */
1:35fa73f:   @SuppressWarnings("unchecked")
3:7926fcb:   @Override
1:7926fcb:   public Object clone() {
3:35fa73f:     // overridden for performance only.
1:02ff22f:     return new ObjectArrayList<>((T[]) elements.clone());
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:35fa73f:    * Returns a deep copy of the receiver; uses <code>clone()</code> and casts the result.
1:7926fcb:    *
1:35fa73f:    * @return a deep copy of the receiver.
1:7926fcb:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public ObjectArrayList<T> copy() {
1:35fa73f:     return (ObjectArrayList<T>) clone();
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns the elements currently stored, including invalid elements between size and capacity, if any.
1:7926fcb:    *
1:7926fcb:    * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>. So if
1:7926fcb:    * subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing.
1:7926fcb:    *
1:7926fcb:    * @return the elements currently stored.
1:7926fcb:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:6d16230:   public <Q> Q[] elements() {
1:35fa73f:     return (Q[])elements;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Sets the receiver's elements to be the specified array (not a copy of it).
1:7926fcb:    *
1:7926fcb:    * The size and capacity of the list is the length of the array. <b>WARNING:</b> For efficiency reasons and to keep
1:7926fcb:    * memory usage low, <b>the array is not copied</b>. So if subsequently you modify the specified array directly via
1:7926fcb:    * the [] operator, be sure you know what you're doing.
1:7926fcb:    *
1:7926fcb:    * @param elements the new elements to be stored.
1:7926fcb:    */
1:35fa73f:   public void elements(T[] elements) {
1:7926fcb:     this.elements = elements;
1:7926fcb:     this.size = elements.length;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that the receiver can hold at least the specified number of elements without needing to allocate new
1:7926fcb:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public void ensureCapacity(int minCapacity) {
1:35fa73f:     elements = org.apache.mahout.math.Arrays.ensureCapacity(elements, minCapacity);
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:35fa73f:    * Compares the specified Object with the receiver. Returns true if and only if the specified Object is also an
1:35fa73f:    * ArrayList of the same type, both Lists have the same size, and all corresponding pairs of elements in the two Lists
1:35fa73f:    * are identical. In other words, two Lists are defined to be equal if they contain the same elements in the same
1:35fa73f:    * order.
1:7926fcb:    *
1:7926fcb:    * @param otherObj the Object to be compared for equality with the receiver.
2:7926fcb:    * @return true if the specified Object is equal to the receiver.
1:7926fcb:    */
1:229aeff:   @Override
1:35fa73f:   @SuppressWarnings("unchecked")
1:7926fcb:   public boolean equals(Object otherObj) { //delta
1:35fa73f:     // overridden for performance only.
1:7926fcb:     if (!(otherObj instanceof ObjectArrayList)) {
1:35fa73f:       return super.equals(otherObj);
1:7926fcb:     }
1:7926fcb:     if (this == otherObj) {
4:7926fcb:       return true;
1:7926fcb:     }
1:7926fcb:     if (otherObj == null) {
6:7926fcb:       return false;
1:7926fcb:     }
1:ea65197:     ObjectArrayList<?> other = (ObjectArrayList<?>) otherObj;
1:35fa73f:     if (size() != other.size()) {
1:7926fcb:       return false;
1:7926fcb:     }
1:7926fcb: 
1:35fa73f:     Object[] theElements = elements();
1:7926fcb:     Object[] otherElements = other.elements();
1:35fa73f:     for (int i = size(); --i >= 0;) {
1:7926fcb:       if (theElements[i] != otherElements[i]) {
1:7926fcb:         return false;
1:7926fcb:       }
1:7926fcb:     }
1:7926fcb:     return true;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Applies a procedure to each element of the receiver, if any. Starts at index 0, moving rightwards.
1:7926fcb:    *
1:7926fcb:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
1:7926fcb:    *                  continues.
1:7926fcb:    * @return <tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.
1:7926fcb:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public boolean forEach(ObjectProcedure<T> procedure) {
1:35fa73f:     T[] theElements = (T[]) elements;
1:7926fcb:     int theSize = size;
1:7926fcb: 
1:7926fcb:     for (int i = 0; i < theSize;) {
1:7926fcb:       if (!procedure.apply(theElements[i++])) {
1:7926fcb:         return false;
1:7926fcb:       }
1:7926fcb:     }
1:7926fcb:     return true;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns the element at the specified position in the receiver.
1:7926fcb:    *
1:7926fcb:    * @param index index of element to return.
2:7926fcb:    * @throws IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).
1:7926fcb:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public T get(int index) {
1:35fa73f:     // overridden for performance only.
1:7926fcb:     if (index >= size || index < 0) {
1:7926fcb:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
1:7926fcb:     }
1:35fa73f:     return (T) elements[index];
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns the element at the specified position in the receiver; <b>WARNING:</b> Does not check preconditions.
1:7926fcb:    * Provided with invalid parameters this method may return invalid elements without throwing any exception! <b>You
1:7926fcb:    * should only use this method when you are absolutely sure that the index is within bounds.</b> Precondition
1:7926fcb:    * (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.
1:7926fcb:    *
1:7926fcb:    * @param index index of element to return.
1:7926fcb:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public T getQuick(int index) {
1:35fa73f:     return (T) elements[index];
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
2:7926fcb:    * Returns the index of the first occurrence of the specified element. Returns <code>-1</code> if the receiver does
1:35fa73f:    * not contain this element. Searches between <code>from</code>, inclusive and <code>to</code>, inclusive. Tests for
1:35fa73f:    * identity.
1:7926fcb:    *
1:35fa73f:    * @param element element to search for.
1:35fa73f:    * @param from    the leftmost search position, inclusive.
1:35fa73f:    * @param to      the rightmost search position, inclusive.
2:7926fcb:    * @return the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is
3:7926fcb:    *         not found.
6:7926fcb:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
6:7926fcb:    *                                   to&gt;=size())</tt>).
1:7926fcb:    */
1:35fa73f:   public int indexOfFromTo(T element, int from, int to) {
1:35fa73f:     // overridden for performance only.
8:7926fcb:     if (size == 0) {
1:7926fcb:       return -1;
1:7926fcb:     }
9:7926fcb:     checkRangeFromTo(from, to, size);
1:7926fcb: 
9:7926fcb:     Object[] theElements = elements;
2:7926fcb:     for (int i = from; i <= to; i++) {
1:7926fcb:       if (element == theElements[i]) {
3:7926fcb:         return i;
3:7926fcb:       } //found
1:7926fcb:     }
1:7926fcb:     return -1; //not found
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
2:7926fcb:    * Returns the index of the last occurrence of the specified element. Returns <code>-1</code> if the receiver does not
1:7926fcb:    * contain this element. Searches beginning at <code>to</code>, inclusive until <code>from</code>, inclusive. Tests
1:35fa73f:    * for identity.
1:7926fcb:    *
1:35fa73f:    * @param element element to search for.
1:35fa73f:    * @param from    the leftmost search position, inclusive.
1:35fa73f:    * @param to      the rightmost search position, inclusive.
2:7926fcb:    * @return the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is
1:7926fcb:    *         not found.
1:7926fcb:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:7926fcb:    *                                   to&gt;=size())</tt>).
1:7926fcb:    */
1:35fa73f:   public int lastIndexOfFromTo(T element, int from, int to) {
1:35fa73f:     // overridden for performance only.
1:7926fcb:     if (size == 0) {
1:7926fcb:       return -1;
1:7926fcb:     }
1:7926fcb:     checkRangeFromTo(from, to, size);
1:7926fcb: 
1:7926fcb:     Object[] theElements = elements;
2:7926fcb:     for (int i = to; i >= from; i--) {
1:7926fcb:       if (element == theElements[i]) {
1:7926fcb:         return i;
1:7926fcb:       } //found
1:7926fcb:     }
1:7926fcb:     return -1; //not found
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a new list of the part of the receiver between <code>from</code>, inclusive, and <code>to</code>,
1:7926fcb:    * inclusive.
1:7926fcb:    *
1:7926fcb:    * @param from the index of the first element (inclusive).
1:7926fcb:    * @param to   the index of the last element (inclusive).
1:7926fcb:    * @return a new list
1:7926fcb:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:7926fcb:    *                                   to&gt;=size())</tt>).
1:7926fcb:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public AbstractObjectList<T> partFromTo(int from, int to) {
1:7926fcb:     if (size == 0) {
1:02ff22f:       return new ObjectArrayList<>(0);
1:7926fcb:     }
1:7926fcb: 
1:7926fcb:     checkRangeFromTo(from, to, size);
1:7926fcb: 
1:7926fcb:     Object[] part = new Object[to - from + 1];
1:7926fcb:     System.arraycopy(elements, from, part, 0, to - from + 1);
1:02ff22f:     return new ObjectArrayList<>((T[]) part);
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /** Reverses the elements of the receiver. Last becomes first, second last becomes second first, and so on. */
1:7926fcb:   @Override
1:7926fcb:   public void reverse() {
1:35fa73f:     // overridden for performance only.
1:7926fcb:     int limit = size / 2;
1:7926fcb:     int j = size - 1;
1:7926fcb: 
1:7926fcb:     Object[] theElements = elements;
1:7926fcb:     for (int i = 0; i < limit;) { //swap
1:7926fcb:       Object tmp = theElements[i];
1:7926fcb:       theElements[i++] = theElements[j];
1:7926fcb:       theElements[j--] = tmp;
1:7926fcb:     }
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Replaces the element at the specified position in the receiver with the specified element.
1:7926fcb:    *
1:7926fcb:    * @param index   index of element to replace.
1:7926fcb:    * @param element element to be stored at the specified position.
1:7926fcb:    * @throws IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).
1:7926fcb:    */
1:35fa73f:   public void set(int index, T element) {
1:35fa73f:     // overridden for performance only.
1:7926fcb:     if (index >= size || index < 0) {
1:7926fcb:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
1:7926fcb:     }
1:7926fcb:     elements[index] = element;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Replaces the element at the specified position in the receiver with the specified element; <b>WARNING:</b> Does not
1:7926fcb:    * check preconditions. Provided with invalid parameters this method may access invalid indexes without throwing any
1:7926fcb:    * exception! <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
1:b5c2879:    * Precondition (unchecked): {@code index >= 0 && index < size()}.
1:7926fcb:    *
1:7926fcb:    * @param index   index of element to replace.
1:7926fcb:    * @param element element to be stored at the specified position.
1:7926fcb:    */
1:35fa73f:   public void setQuick(int index, T element) {
1:7926fcb:     elements[index] = element;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:35fa73f:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
1:7926fcb:    * application can use this operation to minimize the storage of the receiver.
1:7926fcb:    */
1:7926fcb:   @Override
1:7926fcb:   public void trimToSize() {
1:35fa73f:     elements = org.apache.mahout.math.Arrays.trimToCapacity(elements, size());
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   @Override
1:35fa73f:   public void removeFromTo(int fromIndex, int toIndex) {
1:35fa73f:     throw new UnsupportedOperationException();
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   @Override
1:35fa73f:   public void replaceFromWith(int from, Collection<T> other) {
1:35fa73f:     throw new UnsupportedOperationException();
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   @Override
1:7926fcb:   protected void beforeInsertDummies(int index, int length) {
1:35fa73f:     throw new UnsupportedOperationException();
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   @Override
1:7926fcb:   public void mergeSortFromTo(int from, int to) {
1:35fa73f:     throw new UnsupportedOperationException();
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   @Override
1:7926fcb:   public void quickSortFromTo(int from, int to) {
1:35fa73f:     throw new UnsupportedOperationException();
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   @Override
1:7926fcb:   public int size() {
1:7926fcb:     return size;
1:7926fcb:   }
1:7926fcb: }
============================================================================
author:Karl Richter
-------------------------------------------------------------------------------
commit:b5c2879
/////////////////////////////////////////////////////////////////////////
1:    * Precondition (unchecked): {@code index >= 0 && index < size()}.
commit:02ff22f
/////////////////////////////////////////////////////////////////////////
1:     return new ObjectArrayList<>((T[]) elements.clone());
/////////////////////////////////////////////////////////////////////////
1:       return new ObjectArrayList<>(0);
1:     return new ObjectArrayList<>((T[]) part);
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:   public <Q> Q[] elements() {
commit:b285e2d
/////////////////////////////////////////////////////////////////////////
1:     elements = new Object[initialCapacity];
1:     size = 0;
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:229aeff
/////////////////////////////////////////////////////////////////////////
1:   @Override
commit:ea65197
/////////////////////////////////////////////////////////////////////////
0:     return new ObjectArrayList<T>((T[]) elements.clone());
/////////////////////////////////////////////////////////////////////////
1:     ObjectArrayList<?> other = (ObjectArrayList<?>) otherObj;
commit:7627de6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.jet.random.Uniform;
0: import org.apache.mahout.jet.random.engine.DRand;
0: import org.apache.mahout.matrix.Sorting;
0: import java.util.Date;
/////////////////////////////////////////////////////////////////////////
0:     Sorting.quickSort(elements, from, to + 1);
/////////////////////////////////////////////////////////////////////////
0:     Sorting.quickSort(elements, from, to + 1, c);
/////////////////////////////////////////////////////////////////////////
0:    *                                                                     a=[0, 1, 2, 3, 4, 5, 6, 7]
0:    *                                                                     b=[50, 60, 70, 80, 90]
0:    *                                                                     a.R(...)=a.replaceFromToWithFromTo(...)
0:    *                                                                     a.R(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90,
0:    *                  6, 7]
0:    *                                                                     a.R(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7]
0:    *                                                                     a.R(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7]
0:    *                                                                     a.R(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7]
0:    *                                                                     a.R(1,6,b,1,2)-->[0, 60, 70, 7]
0:    *                                                                     a.R(0,6,b,1,2)-->[60, 70, 7]
0:    *                                                                     a.R(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70,
0:    *                  80, 90, 5, 6, 7]
0:    *                                                                     a.R(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70,
0:    *                  80, 90, 5, 6, 7]
0:    *                                                                     a.R(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6,
0:    *                  7]
0:    *                                                                     a.R(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6,
0:    *                  7]
0:    *                                                                     Extreme cases:
0:    *                                                                     a.R(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7]
0:    *                                                                     a.R(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7]
0:    *                                                                     a.R(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7]
0:    *                                                                     a.R(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7]
0:    *                                                                     a.R(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7]
0:    *                                                                     a.R(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4,
0:    *                  5, 6, 7]
0:    *                                                                     a.R(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2,
0:    *                  3, 4, 5, 6, 7]
0:    *                                                                     a.R(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3,
0:    *                  4, 5, 6, 7]
0:    *                                                                     a.R(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1,
0:    *                  2, 3, 4]
0:    *                                                                     </pre>
/////////////////////////////////////////////////////////////////////////
0:     Uniform gen = new Uniform(new DRand(new Date()));
commit:a90e57e
/////////////////////////////////////////////////////////////////////////
0:     //log.info("from="+from);
0:     //log.info("to="+to);
0:     //log.info("diff="+diff);
commit:7926fcb
/////////////////////////////////////////////////////////////////////////
1: 
0: import java.util.ArrayList;
0: import java.util.Arrays;
1: import java.util.Collection;
0: import java.util.Comparator;
0: import java.util.Iterator;
0: import java.util.List;
0:  Resizable list holding <code>Object</code> elements; implemented with arrays.
0:  First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
1: 
0: /** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
0: public class ObjectArrayList extends AbstractList<Object[]> {
1: 
1:    * The array buffer into which the elements of the list are stored. The capacity of the list is the length of this
1:    * array buffer.
1: 
0:   /** The size of the list. */
1: 
1:   /** Constructs an empty list. */
1:   public ObjectArrayList() {
1:     this(10);
1:   /**
1:    * Constructs a list containing the specified elements. The initial size and capacity of the list is the length of the
1:    * array.
1:    *
1:    * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>. So if
1:    * subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.
1:    *
1:    * @param elements the array to be backed by the the constructed list
1:    */
0:   public ObjectArrayList(Object[] elements) {
1:     elements(elements);
1:   /**
1:    * Constructs an empty list with the specified initial capacity.
1:    *
1:    * @param initialCapacity the number of elements the receiver can hold without auto-expanding itself by allocating new
1:    *                        internal memory.
1:    */
1:   public ObjectArrayList(int initialCapacity) {
0:     this(new Object[initialCapacity]);
0:     size = 0;
1:   }
1: 
1:   /**
1:    * Appends the specified element to the end of this list.
1:    *
1:    * @param element element to be appended to this list.
1:    */
0:   public void add(Object element) {
1:     if (size == elements.length) {
1:       ensureCapacity(size + 1);
1:     elements[size++] = element;
1: 
1:   /**
0:    * Appends the part of the specified list between <code>from</code> (inclusive) and <code>to</code> (inclusive) to the
0:    * receiver.
1:    *
0:    * @param other the list to be added to the receiver.
0:    * @param from  the index of the first element to be appended (inclusive).
0:    * @param to    the index of the last element to be appended (inclusive).
0:    * @throws IndexOutOfBoundsException index is out of range (<tt>other.size()&gt;0 && (from&lt;0 || from&gt;to ||
0:    *                                   to&gt;=other.size())</tt>).
1:    */
0:   public void addAllOfFromTo(ObjectArrayList other, int from, int to) {
0:     beforeInsertAllOfFromTo(size, other, from, to);
1:   }
1: 
1:   /**
1:    * Inserts the specified element before the specified position into the receiver. Shifts the element currently at that
1:    * position (if any) and any subsequent elements to the right.
1:    *
1:    * @param index   index before which the specified element is to be inserted (must be in [0,size]).
1:    * @param element element to be inserted.
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).
1:    */
0:   public void beforeInsert(int index, Object element) {
1:     // overridden for performance only.
1:     if (index > size || index < 0) {
1:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
1:     }
1:     ensureCapacity(size + 1);
1:     System.arraycopy(elements, index, elements, index + 1, size - index);
1:     elements[index] = element;
1:     size++;
1:   }
1: 
1:   /**
0:    * Inserts the part of the specified list between <code>otherFrom</code> (inclusive) and <code>otherTo</code>
0:    * (inclusive) before the specified position into the receiver. Shifts the element currently at that position (if any)
0:    * and any subsequent elements to the right.
1:    *
0:    * @param index index before which to insert first element from the specified list (must be in [0,size])..
0:    * @param other list of which a part is to be inserted into the receiver.
0:    * @param from  the index of the first element to be inserted (inclusive).
0:    * @param to    the index of the last element to be inserted (inclusive).
0:    * @throws IndexOutOfBoundsException index is out of range (<tt>other.size()&gt;0 && (from&lt;0 || from&gt;to ||
0:    *                                   to&gt;=other.size())</tt>).
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).
1:    */
0:   public void beforeInsertAllOfFromTo(int index, ObjectArrayList other, int from, int to) {
0:     int length = to - from + 1;
0:     this.beforeInsertDummies(index, length);
0:     this.replaceFromToWithFrom(index, index + length - 1, other, from);
1:   }
1: 
1:   /**
0:    * Inserts length dummies before the specified position into the receiver. Shifts the element currently at that
1:    * position (if any) and any subsequent elements to the right.
1:    *
0:    * @param index  index before which to insert dummies (must be in [0,size])..
0:    * @param length number of dummies to be inserted.
1:    */
1:   @Override
1:   protected void beforeInsertDummies(int index, int length) {
1:     if (index > size || index < 0) {
1:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
1:     }
0:     if (length > 0) {
0:       ensureCapacity(size + length);
0:       System.arraycopy(elements, index, elements, index + length, size - index);
0:       size += length;
1:   /**
0:    * Searches the receiver for the specified value using the binary search algorithm. The receiver must be sorted into
0:    * ascending order according to the <i>natural ordering</i> of its elements (as by the sort method) prior to making
0:    * this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop.  If
0:    * the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be
0:    * found.
1:    *
0:    * @param key the value to be searched for.
0:    * @return index of the search key, if it is contained in the receiver; otherwise, <tt>(-(<i>insertion point</i>) -
0:    *         1)</tt>.  The <i>insertion point</i> is defined as the the point at which the value would be inserted into
0:    *         the receiver: the index of the first element greater than the key, or <tt>receiver.size()</tt>, if all
0:    *         elements in the receiver are less than the specified key.  Note that this guarantees that the return value
0:    *         will be &gt;= 0 if and only if the key is found.
0:    * @see Comparable
0:    * @see java.util.Arrays
1:    */
0:   public int binarySearch(Object key) {
0:     return this.binarySearchFromTo(key, 0, size - 1);
1:   }
1:   /**
0:    * Searches the receiver for the specified value using the binary search algorithm. The receiver must be sorted into
0:    * ascending order according to the <i>natural ordering</i> of its elements (as by the sort method) prior to making
0:    * this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop.  If
0:    * the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be
0:    * found.
1:    *
0:    * @param key  the value to be searched for.
0:    * @param from the leftmost search position, inclusive.
0:    * @param to   the rightmost search position, inclusive.
0:    * @return index of the search key, if it is contained in the receiver; otherwise, <tt>(-(<i>insertion point</i>) -
0:    *         1)</tt>.  The <i>insertion point</i> is defined as the the point at which the value would be inserted into
0:    *         the receiver: the index of the first element greater than the key, or <tt>receiver.size()</tt>, if all
0:    *         elements in the receiver are less than the specified key.  Note that this guarantees that the return value
0:    *         will be &gt;= 0 if and only if the key is found.
0:    * @see Comparable
0:    * @see java.util.Arrays
1:    */
0:   public int binarySearchFromTo(Object key, int from, int to) {
0:     int low = from;
0:     int high = to;
0:     while (low <= high) {
0:       int mid = (low + high) / 2;
0:       Object midVal = elements[mid];
0:       int cmp = ((Comparable<Object>) midVal).compareTo(key);
1: 
0:       if (cmp < 0) {
0:         low = mid + 1;
0:       } else if (cmp > 0) {
0:         high = mid - 1;
0:       } else {
0:         return mid;
0:       } // key found
0:     return -(low + 1);  // key not found.
1:   /**
0:    * Searches the receiver for the specified value using the binary search algorithm. The receiver must be sorted into
0:    * ascending order according to the specified comparator.  All elements in the range must be <i>mutually
0:    * comparable</i> by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not throw a
0:    * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and <tt>e2</tt> in the range).<p>
1:    *
0:    * If the receiver is not sorted, the results are undefined: in particular, the call may enter an infinite loop.  If
0:    * the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be
0:    * found.
1:    *
0:    * @param key        the value to be searched for.
0:    * @param from       the leftmost search position, inclusive.
0:    * @param to         the rightmost search position, inclusive.
0:    * @param comparator the comparator by which the receiver is sorted.
0:    * @return index of the search key, if it is contained in the receiver; otherwise, <tt>(-(<i>insertion point</i>) -
0:    *         1)</tt>.  The <i>insertion point</i> is defined as the the point at which the value would be inserted into
0:    *         the receiver: the index of the first element greater than the key, or <tt>receiver.size()</tt>, if all
0:    *         elements in the receiver are less than the specified key.  Note that this guarantees that the return value
0:    *         will be &gt;= 0 if and only if the key is found.
0:    * @throws ClassCastException if the receiver contains elements that are not <i>mutually comparable</i> using the
0:    *                            specified comparator.
0:    * @see org.apache.mahout.matrix.Sorting
0:    * @see java.util.Arrays
0:    * @see java.util.Comparator
1:    */
0:   public int binarySearchFromTo(Object key, int from, int to, Comparator<Object> comparator) {
0:     return org.apache.mahout.matrix.Sorting.binarySearchFromTo(this.elements, key, from, to, comparator);
1:   /**
0:    * Returns a copy of the receiver such that the copy and the receiver <i>share</i> the same elements, but do not share
0:    * the same array to index them; So modifying an object in the copy modifies the object in the receiver and vice
0:    * versa; However, structurally modifying the copy (for example changing its size, setting other objects at indexes,
0:    * etc.) does not affect the receiver and vice versa.
1:    *
0:    * @return a copy of the receiver.
1:    */
1:   @Override
1:   public Object clone() {
0:     ObjectArrayList v = (ObjectArrayList) super.clone();
0:     v.elements = elements.clone();
0:     return v;
1: 
1:   /**
0:    * Returns true if the receiver contains the specified element. Tests for equality or identity as specified by
0:    * testForEquality.
1:    *
0:    * @param elem            element to search for.
0:    * @param testForEquality if true -> test for equality, otherwise for identity.
1:    */
0:   public boolean contains(Object elem, boolean testForEquality) {
0:     return indexOfFromTo(elem, 0, size - 1, testForEquality) >= 0;
1: 
1:   /**
0:    * Returns a copy of the receiver; call <code>clone()</code> and casts the result. Returns a copy such that the copy
0:    * and the receiver <i>share</i> the same elements, but do not share the same array to index them; So modifying an
0:    * object in the copy modifies the object in the receiver and vice versa; However, structurally modifying the copy
0:    * (for example changing its size, setting other objects at indexes, etc.) does not affect the receiver and vice
0:    * versa.
1:    *
0:    * @return a copy of the receiver.
1:    */
0:   public ObjectArrayList copy() {
0:     return (ObjectArrayList) clone();
1:   }
1: 
1:   /**
0:    * Deletes the first element from the receiver that matches the specified element. Does nothing, if no such matching
0:    * element is contained.
1:    *
0:    * Tests elements for equality or identity as specified by <tt>testForEquality</tt>. When testing for equality, two
0:    * elements <tt>e1</tt> and <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null : e1.equals(e2))</tt>.)
1:    *
0:    * @param testForEquality if true -> tests for equality, otherwise for identity.
0:    * @param element         the element to be deleted.
1:    */
0:   public void delete(Object element, boolean testForEquality) {
0:     int index = indexOfFromTo(element, 0, size - 1, testForEquality);
0:     if (index >= 0) {
0:       removeFromTo(index, index);
1:   /**
1:    * Returns the elements currently stored, including invalid elements between size and capacity, if any.
1:    *
1:    * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>. So if
1:    * subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing.
1:    *
1:    * @return the elements currently stored.
1:    */
0:   public Object[] elements() {
0:     return elements;
1: 
1:   /**
1:    * Sets the receiver's elements to be the specified array (not a copy of it).
1:    *
1:    * The size and capacity of the list is the length of the array. <b>WARNING:</b> For efficiency reasons and to keep
1:    * memory usage low, <b>the array is not copied</b>. So if subsequently you modify the specified array directly via
1:    * the [] operator, be sure you know what you're doing.
1:    *
1:    * @param elements the new elements to be stored.
0:    * @return the receiver itself.
1:    */
0:   public ObjectArrayList elements(Object[] elements) {
1:     this.elements = elements;
1:     this.size = elements.length;
0:     return this;
1:   }
1: 
1:   /**
1:    * Ensures that the receiver can hold at least the specified number of elements without needing to allocate new
1:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public void ensureCapacity(int minCapacity) {
0:     elements = org.apache.mahout.matrix.Arrays.ensureCapacity(elements, minCapacity);
1:   }
1: 
1:   /**
0:    * Compares the specified Object with the receiver for equality. Returns true if and only if the specified Object is
0:    * also an ObjectArrayList, both lists have the same size, and all corresponding pairs of elements in the two lists
0:    * are equal. In other words, two lists are defined to be equal if they contain the same elements in the same order.
0:    * Two elements <tt>e1</tt> and <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null : e1.equals(e2))</tt>.)
1:    *
1:    * @param otherObj the Object to be compared for equality with the receiver.
1:    * @return true if the specified Object is equal to the receiver.
1:    */
1:   public boolean equals(Object otherObj) { //delta
0:     return equals(otherObj, true);
1:   }
1: 
1:   /**
0:    * Compares the specified Object with the receiver for equality. Returns true if and only if the specified Object is
0:    * also an ObjectArrayList, both lists have the same size, and all corresponding pairs of elements in the two lists
0:    * are the same. In other words, two lists are defined to be equal if they contain the same elements in the same
0:    * order. Tests elements for equality or identity as specified by <tt>testForEquality</tt>. When testing for equality,
0:    * two elements <tt>e1</tt> and <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null : e1.equals(e2))</tt>.)
1:    *
0:    * @param otherObj        the Object to be compared for equality with the receiver.
0:    * @param testForEquality if true -> tests for equality, otherwise for identity.
1:    * @return true if the specified Object is equal to the receiver.
1:    */
0:   public boolean equals(Object otherObj, boolean testForEquality) { //delta
1:     if (!(otherObj instanceof ObjectArrayList)) {
1:       return false;
1:     }
1:     if (this == otherObj) {
1:       return true;
1:     }
1:     if (otherObj == null) {
1:       return false;
1:     }
0:     ObjectArrayList other = (ObjectArrayList) otherObj;
0:     if (elements == other.elements()) {
1:       return true;
1:     }
0:     if (size != other.size()) {
1:       return false;
1:     }
1: 
1:     Object[] otherElements = other.elements();
1:     Object[] theElements = elements;
0:     if (!testForEquality) {
0:       for (int i = size; --i >= 0;) {
1:         if (theElements[i] != otherElements[i]) {
1:           return false;
1:         }
1:       }
0:     } else {
0:       for (int i = size; --i >= 0;) {
0:         if (!(theElements[i] == null ? otherElements[i] == null : theElements[i].equals(otherElements[i]))) {
1:           return false;
1:         }
1:       }
1:     }
1: 
1:     return true;
1: 
1:   }
1: 
1:   /**
0:    * Sets the specified range of elements in the specified array to the specified value.
1:    *
0:    * @param from the index of the first element (inclusive) to be filled with the specified value.
0:    * @param to   the index of the last element (inclusive) to be filled with the specified value.
0:    * @param val  the value to be stored in the specified elements of the receiver.
1:    */
0:   public void fillFromToWith(int from, int to, Object val) {
0:     checkRangeFromTo(from, to, this.size);
0:     for (int i = from; i <= to;) {
0:       setQuick(i++, val);
1:     }
1:   }
1: 
1:   /**
1:    * Applies a procedure to each element of the receiver, if any. Starts at index 0, moving rightwards.
1:    *
1:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
1:    *                  continues.
1:    * @return <tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.
1:    */
0:   public boolean forEach(ObjectProcedure procedure) {
1:     Object[] theElements = elements;
1:     int theSize = size;
1: 
1:     for (int i = 0; i < theSize;) {
1:       if (!procedure.apply(theElements[i++])) {
1:         return false;
1:       }
1:     }
1:   /**
1:    * Returns the element at the specified position in the receiver.
1:    *
1:    * @param index index of element to return.
1:    * @throws IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).
1:    */
0:   public Object get(int index) {
1:     if (index >= size || index < 0) {
1:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
1:     }
0:     return elements[index];
1:   /**
1:    * Returns the element at the specified position in the receiver; <b>WARNING:</b> Does not check preconditions.
1:    * Provided with invalid parameters this method may return invalid elements without throwing any exception! <b>You
1:    * should only use this method when you are absolutely sure that the index is within bounds.</b> Precondition
1:    * (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.
1:    *
1:    * @param index index of element to return.
1:    */
0:   public Object getQuick(int index) {
0:     return elements[index];
1:   /**
1:    * Returns the index of the first occurrence of the specified element. Returns <code>-1</code> if the receiver does
0:    * not contain this element.
1:    *
0:    * Tests for equality or identity as specified by testForEquality.
1:    *
0:    * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
1:    * @return the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is
1:    *         not found.
1:    */
0:   public int indexOf(Object element, boolean testForEquality) {
0:     return this.indexOfFromTo(element, 0, size - 1, testForEquality);
1: 
1:   /**
1:    * Returns the index of the first occurrence of the specified element. Returns <code>-1</code> if the receiver does
0:    * not contain this element. Searches between <code>from</code>, inclusive and <code>to</code>, inclusive.
1:    *
0:    * Tests for equality or identity as specified by <code>testForEquality</code>.
1:    *
0:    * @param element         element to search for.
0:    * @param from            the leftmost search position, inclusive.
0:    * @param to              the rightmost search position, inclusive.
0:    * @param testForEquality if </code>true</code> -> test for equality, otherwise for identity.
1:    * @return the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is
1:    *         not found.
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:    *                                   to&gt;=size())</tt>).
1:    */
0:   public int indexOfFromTo(Object element, int from, int to, boolean testForEquality) {
1:     if (size == 0) {
1:       return -1;
1:     }
1:     checkRangeFromTo(from, to, size);
1: 
1:     Object[] theElements = elements;
0:     if (testForEquality && element != null) {
1:       for (int i = from; i <= to; i++) {
0:         if (element.equals(theElements[i])) {
1:           return i;
1:         } //found
1:       }
1: 
0:     } else {
1:       for (int i = from; i <= to; i++) {
1:         if (element == theElements[i]) {
1:           return i;
1:         } //found
1:       }
1:     }
1:     return -1; //not found
1:   /**
0:    * Determines whether the receiver is sorted ascending, according to the <i>natural ordering</i> of its elements.  All
0:    * elements in this range must implement the <tt>Comparable</tt> interface.  Furthermore, all elements in this range
0:    * must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt> must not throw a <tt>ClassCastException</tt>
0:    * for any elements <tt>e1</tt> and <tt>e2</tt> in the array).<p>
1:    *
0:    * @param from the index of the first element (inclusive) to be sorted.
0:    * @param to   the index of the last element (inclusive) to be sorted.
0:    * @return <tt>true</tt> if the receiver is sorted ascending, <tt>false</tt> otherwise.
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:    *                                   to&gt;=size())</tt>).
1:    */
0:   public boolean isSortedFromTo(int from, int to) {
1:     if (size == 0) {
1:       return true;
1:     }
1:     checkRangeFromTo(from, to, size);
1:     Object[] theElements = elements;
0:     for (int i = from + 1; i <= to; i++) {
0:       if (((Comparable<Object>) theElements[i]).compareTo(theElements[i - 1]) < 0) {
1:         return false;
1:       }
1:     }
1:     return true;
1:   }
1:   /**
1:    * Returns the index of the last occurrence of the specified element. Returns <code>-1</code> if the receiver does not
0:    * contain this element. Tests for equality or identity as specified by <code>testForEquality</code>.
1:    *
0:    * @param element         the element to be searched for.
0:    * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
1:    * @return the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is
1:    *         not found.
1:    */
0:   public int lastIndexOf(Object element, boolean testForEquality) {
0:     return lastIndexOfFromTo(element, 0, size - 1, testForEquality);
1:   }
1: 
1:   /**
1:    * Returns the index of the last occurrence of the specified element. Returns <code>-1</code> if the receiver does not
1:    * contain this element. Searches beginning at <code>to</code>, inclusive until <code>from</code>, inclusive. Tests
0:    * for equality or identity as specified by <code>testForEquality</code>.
1:    *
0:    * @param element         element to search for.
0:    * @param from            the leftmost search position, inclusive.
0:    * @param to              the rightmost search position, inclusive.
0:    * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
1:    * @return the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is
1:    *         not found.
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:    *                                   to&gt;=size())</tt>).
1:    */
0:   public int lastIndexOfFromTo(Object element, int from, int to, boolean testForEquality) {
1:     if (size == 0) {
1:       return -1;
1:     }
1:     checkRangeFromTo(from, to, size);
1: 
1:     Object[] theElements = elements;
0:     if (testForEquality && element != null) {
1:       for (int i = to; i >= from; i--) {
0:         if (element.equals(theElements[i])) {
1:           return i;
1:         } //found
1:       }
1: 
0:     } else {
1:       for (int i = to; i >= from; i--) {
1:         if (element == theElements[i]) {
1:           return i;
1:         } //found
1:       }
1:     }
1:     return -1; //not found
1:   }
1: 
1:   /**
0:    * Sorts the specified range of the receiver into ascending order, according to the <i>natural ordering</i> of its
0:    * elements.  All elements in this range must implement the <tt>Comparable</tt> interface.  Furthermore, all elements
0:    * in this range must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt> must not throw a
0:    * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and <tt>e2</tt> in the array).<p>
1:    *
0:    * This sort is guaranteed to be <i>stable</i>:  equal elements will not be reordered as a result of the sort.<p>
1:    *
0:    * The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low
0:    * sublist is less than the lowest element in the high sublist).  This algorithm offers guaranteed n*log(n)
0:    * performance, and can approach linear performance on nearly sorted lists.
1:    *
0:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
0:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
0:    * those methods automatically choose the best sorting algorithm.
1:    *
0:    * @param from the index of the first element (inclusive) to be sorted.
0:    * @param to   the index of the last element (inclusive) to be sorted.
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:    *                                   to&gt;=size())</tt>).
1:    */
1:   @Override
1:   public void mergeSortFromTo(int from, int to) {
1:     if (size == 0) {
1:       return;
1:     }
1:     checkRangeFromTo(from, to, size);
0:     java.util.Arrays.sort(elements, from, to + 1);
1:   }
1: 
1:   /**
0:    * Sorts the receiver according to the order induced by the specified comparator.  All elements in the range must be
0:    * <i>mutually comparable</i> by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not throw a
0:    * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and <tt>e2</tt> in the range).<p>
1:    *
0:    * This sort is guaranteed to be <i>stable</i>:  equal elements will not be reordered as a result of the sort.<p>
1:    *
0:    * The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low
0:    * sublist is less than the lowest element in the high sublist).  This algorithm offers guaranteed n*log(n)
0:    * performance, and can approach linear performance on nearly sorted lists.
1:    *
0:    * @param from the index of the first element (inclusive) to be sorted.
0:    * @param to   the index of the last element (inclusive) to be sorted.
0:    * @param c    the comparator to determine the order of the receiver.
0:    * @throws ClassCastException             if the array contains elements that are not <i>mutually comparable</i> using
0:    *                                        the specified comparator.
0:    * @throws IllegalArgumentException       if <tt>fromIndex &gt; toIndex</tt>
0:    * @throws ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or <tt>toIndex &gt; a.length</tt>
0:    * @throws IndexOutOfBoundsException      index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
0:    *                                        to&gt;=size())</tt>).
0:    * @see Comparator
1:    */
0:   public void mergeSortFromTo(int from, int to, Comparator<Object> c) {
1:     if (size == 0) {
1:       return;
1:     }
1:     checkRangeFromTo(from, to, size);
0:     Arrays.sort(elements, from, to + 1, c);
1:   }
1: 
1:   /**
1:    * Returns a new list of the part of the receiver between <code>from</code>, inclusive, and <code>to</code>,
1:    * inclusive.
1:    *
1:    * @param from the index of the first element (inclusive).
1:    * @param to   the index of the last element (inclusive).
1:    * @return a new list
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:    *                                   to&gt;=size())</tt>).
1:    */
0:   public ObjectArrayList partFromTo(int from, int to) {
1:     if (size == 0) {
0:       return new ObjectArrayList(0);
1:     }
1: 
1:     checkRangeFromTo(from, to, size);
1: 
1:     Object[] part = new Object[to - from + 1];
1:     System.arraycopy(elements, from, part, 0, to - from + 1);
0:     return new ObjectArrayList(part);
1:   }
1: 
1:   /**
0:    * Sorts the specified range of the receiver into ascending order, according to the <i>natural ordering</i> of its
0:    * elements.  All elements in this range must implement the <tt>Comparable</tt> interface.  Furthermore, all elements
0:    * in this range must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt> must not throw a
0:    * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and <tt>e2</tt> in the array).<p>
1:    *
0:    * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
0:    * Sort Function", Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November 1993).  This algorithm offers
0:    * n*log(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance.
1:    *
0:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
0:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
0:    * those methods automatically choose the best sorting algorithm.
1:    *
0:    * @param from the index of the first element (inclusive) to be sorted.
0:    * @param to   the index of the last element (inclusive) to be sorted.
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:    *                                   to&gt;=size())</tt>).
1:    */
1:   @Override
1:   public void quickSortFromTo(int from, int to) {
1:     if (size == 0) {
1:       return;
1:     }
1:     checkRangeFromTo(from, to, size);
0:     org.apache.mahout.matrix.Sorting.quickSort(elements, from, to + 1);
1:   }
1: 
1:   /**
0:    * Sorts the receiver according to the order induced by the specified comparator.  All elements in the range must be
0:    * <i>mutually comparable</i> by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not throw a
0:    * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and <tt>e2</tt> in the range).<p>
1:    *
0:    * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
0:    * Sort Function", Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November 1993).  This algorithm offers
0:    * n*log(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance.
1:    *
0:    * @param from the index of the first element (inclusive) to be sorted.
0:    * @param to   the index of the last element (inclusive) to be sorted.
0:    * @param c    the comparator to determine the order of the receiver.
0:    * @throws ClassCastException             if the array contains elements that are not <i>mutually comparable</i> using
0:    *                                        the specified comparator.
0:    * @throws IllegalArgumentException       if <tt>fromIndex &gt; toIndex</tt>
0:    * @throws ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or <tt>toIndex &gt; a.length</tt>
0:    * @throws IndexOutOfBoundsException      index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
0:    *                                        to&gt;=size())</tt>).
0:    * @see Comparator
1:    */
0:   public void quickSortFromTo(int from, int to, Comparator<Object> c) {
1:     if (size == 0) {
1:       return;
1:     }
1:     checkRangeFromTo(from, to, size);
0:     org.apache.mahout.matrix.Sorting.quickSort(elements, from, to + 1, c);
1:   }
1: 
1:   /**
0:    * Removes from the receiver all elements that are contained in the specified list. Tests for equality or identity as
0:    * specified by <code>testForEquality</code>.
1:    *
0:    * @param other           the other list.
0:    * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
0:    * @return <code>true</code> if the receiver changed as a result of the call.
1:    */
0:   public boolean removeAll(ObjectArrayList other, boolean testForEquality) {
0:     if (other.size == 0) {
1:       return false;
0:     } //nothing to do
0:     int limit = other.size - 1;
0:     int j = 0;
1:     Object[] theElements = elements;
0:     for (int i = 0; i < size; i++) {
0:       if (other.indexOfFromTo(theElements[i], 0, limit, testForEquality) < 0) {
0:         theElements[j++] = theElements[i];
1:       }
1:     }
1: 
0:     boolean modified = (j != size);
0:     setSize(j);
0:     return modified;
1:   }
1: 
1:   /**
0:    * Removes from the receiver all elements whose index is between <code>from</code>, inclusive and <code>to</code>,
0:    * inclusive.  Shifts any succeeding elements to the left (reduces their index). This call shortens the list by
0:    * <tt>(to - from + 1)</tt> elements.
1:    *
0:    * @param from index of first element to be removed.
0:    * @param to   index of last element to be removed.
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:    *                                   to&gt;=size())</tt>).
1:    */
1:   @Override
0:   public void removeFromTo(int from, int to) {
1:     checkRangeFromTo(from, to, size);
0:     int numMoved = size - to - 1;
0:     if (numMoved >= 0) {
0:       System.arraycopy(elements, to + 1, elements, from, numMoved);
0:       fillFromToWith(from + numMoved, size - 1, null); //delta
1:     }
0:     int width = to - from + 1;
0:     if (width > 0) {
0:       size -= width;
1:     }
1:   }
1: 
1:   /**
0:    * Replaces a number of elements in the receiver with the same number of elements of another list. Replaces elements
0:    * in the receiver, between <code>from</code> (inclusive) and <code>to</code> (inclusive), with elements of
0:    * <code>other</code>, starting from <code>otherFrom</code> (inclusive).
1:    *
0:    * @param from      the position of the first element to be replaced in the receiver
0:    * @param to        the position of the last element to be replaced in the receiver
0:    * @param other     list holding elements to be copied into the receiver.
0:    * @param otherFrom position of first element within other list to be copied.
1:    */
0:   public void replaceFromToWithFrom(int from, int to, ObjectArrayList other, int otherFrom) {
0:     int length = to - from + 1;
0:     if (length > 0) {
1:       checkRangeFromTo(from, to, size);
0:       checkRangeFromTo(otherFrom, otherFrom + length - 1, other.size);
0:       System.arraycopy(other.elements, otherFrom, elements, from, length);
1:     }
1:   }
1: 
1:   /**
0:    * Replaces the part between <code>from</code> (inclusive) and <code>to</code> (inclusive) with the other list's part
0:    * between <code>otherFrom</code> and <code>otherTo</code>. Powerful (and tricky) method! Both parts need not be of
0:    * the same size (part A can both be smaller or larger than part B). Parts may overlap. Receiver and other list may
0:    * (but most not) be identical. If <code>from &gt; to</code>, then inserts other part before <code>from</code>.
1:    *
0:    * @param from      the first element of the receiver (inclusive)
0:    * @param to        the last element of the receiver (inclusive)
0:    * @param other     the other list (may be identical with receiver)
0:    * @param otherFrom the first element of the other list (inclusive)
0:    * @param otherTo   the last element of the other list (inclusive)
1:    *
0:    *                  <p><b>Examples:</b><pre>
0:    *                                                    a=[0, 1, 2, 3, 4, 5, 6, 7]
0:    *                                                    b=[50, 60, 70, 80, 90]
0:    *                                                    a.R(...)=a.replaceFromToWithFromTo(...)
1:    *
0:    *                                                    a.R(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
0:    *                                                    a.R(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7]
0:    *                                                    a.R(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7]
0:    *                                                    a.R(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7]
0:    *                                                    a.R(1,6,b,1,2)-->[0, 60, 70, 7]
0:    *                                                    a.R(0,6,b,1,2)-->[60, 70, 7]
0:    *                                                    a.R(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
0:    *                                                    a.R(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
0:    *                                                    a.R(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
0:    *                                                    a.R(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
1:    *
0:    *                                                    Extreme cases:
0:    *                                                    a.R(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7]
0:    *                                                    a.R(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7]
0:    *                                                    a.R(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7]
0:    *                                                    a.R(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7]
0:    *                                                    a.R(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7]
0:    *                                                    a.R(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
0:    *                                                    a.R(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
0:    *                                                    a.R(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
0:    *                                                    a.R(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
0:    *                                                    </pre>
1:    */
0:   public void replaceFromToWithFromTo(int from, int to, ObjectArrayList other, int otherFrom, int otherTo) {
0:     if (otherFrom > otherTo) {
0:       throw new IndexOutOfBoundsException("otherFrom: " + otherFrom + ", otherTo: " + otherTo);
1:     }
0:     if (this == other && to - from != otherTo - otherFrom) { // avoid stumbling over my own feet
0:       replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo - otherFrom);
1:       return;
1:     }
1: 
0:     int length = otherTo - otherFrom + 1;
0:     int diff = length;
0:     int theLast = from - 1;
1: 
0:     //System.out.println("from="+from);
0:     //System.out.println("to="+to);
0:     //System.out.println("diff="+diff);
1: 
0:     if (to >= from) {
0:       diff -= (to - from + 1);
0:       theLast = to;
1:     }
1: 
0:     if (diff > 0) {
0:       beforeInsertDummies(theLast + 1, diff);
0:     } else {
0:       if (diff < 0) {
0:         removeFromTo(theLast + diff, theLast - 1);
1:       }
1:     }
1: 
0:     if (length > 0) {
0:       System.arraycopy(other.elements, otherFrom, elements, from, length);
1:     }
1:   }
1: 
1:   /**
0:    * Replaces the part of the receiver starting at <code>from</code> (inclusive) with all the elements of the specified
0:    * collection. Does not alter the size of the receiver. Replaces exactly <tt>Math.max(0,Math.min(size()-from,
0:    * other.size()))</tt> elements.
1:    *
0:    * @param from  the index at which to copy the first element from the specified collection.
0:    * @param other Collection to replace part of the receiver
1:    * @throws IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).
1:    */
1:   @Override
0:   public void replaceFromWith(int from, Collection<Object[]> other) {
0:     checkRange(from, size);
0:     Iterator<Object[]> e = other.iterator();
0:     int index = from;
0:     int limit = Math.min(size - from, other.size());
0:     for (int i = 0; i < limit; i++) {
0:       elements[index++] = e.next();
0:     } //delta
1:   }
1: 
1:   /**
0:    * Retains (keeps) only the elements in the receiver that are contained in the specified other list. In other words,
0:    * removes from the receiver all of its elements that are not contained in the specified other list. Tests for
0:    * equality or identity as specified by <code>testForEquality</code>.
1:    *
0:    * @param other           the other list to test against.
0:    * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
0:    * @return <code>true</code> if the receiver changed as a result of the call.
1:    */
0:   public boolean retainAll(ObjectArrayList other, boolean testForEquality) {
0:     if (other.size == 0) {
1:       if (size == 0) {
1:         return false;
1:       }
0:       setSize(0);
1:       return true;
1:     }
1: 
0:     int limit = other.size - 1;
0:     int j = 0;
1:     Object[] theElements = elements;
1: 
0:     for (int i = 0; i < size; i++) {
0:       if (other.indexOfFromTo(theElements[i], 0, limit, testForEquality) >= 0) {
0:         theElements[j++] = theElements[i];
1:       }
1:     }
1: 
0:     boolean modified = (j != size);
0:     setSize(j);
0:     return modified;
1:   }
1: 
1:   /** Reverses the elements of the receiver. Last becomes first, second last becomes second first, and so on. */
1:   @Override
1:   public void reverse() {
1:     int limit = size / 2;
1:     int j = size - 1;
1: 
1:     Object[] theElements = elements;
1:     for (int i = 0; i < limit;) { //swap
1:       Object tmp = theElements[i];
1:       theElements[i++] = theElements[j];
1:       theElements[j--] = tmp;
1:     }
1:   }
1: 
1:   /**
1:    * Replaces the element at the specified position in the receiver with the specified element.
1:    *
1:    * @param index   index of element to replace.
1:    * @param element element to be stored at the specified position.
1:    * @throws IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).
1:    */
0:   public void set(int index, Object element) {
1:     if (index >= size || index < 0) {
1:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
1:     }
1:     elements[index] = element;
1:   }
1: 
1:   /**
1:    * Replaces the element at the specified position in the receiver with the specified element; <b>WARNING:</b> Does not
1:    * check preconditions. Provided with invalid parameters this method may access invalid indexes without throwing any
1:    * exception! <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
0:    * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.
1:    *
1:    * @param index   index of element to replace.
1:    * @param element element to be stored at the specified position.
1:    */
0:   public void setQuick(int index, Object element) {
1:     elements[index] = element;
1:   }
1: 
1:   /**
0:    * Randomly permutes the part of the receiver between <code>from</code> (inclusive) and <code>to</code> (inclusive).
1:    *
0:    * @param from the index of the first element (inclusive) to be permuted.
0:    * @param to   the index of the last element (inclusive) to be permuted.
1:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
1:    *                                   to&gt;=size())</tt>).
1:    */
1:   @Override
0:   public void shuffleFromTo(int from, int to) {
1:     if (size == 0) {
1:       return;
1:     }
1:     checkRangeFromTo(from, to, size);
1: 
0:     org.apache.mahout.jet.random.Uniform gen =
0:         new org.apache.mahout.jet.random.Uniform(new org.apache.mahout.jet.random.engine.DRand(new java.util.Date()));
1:     Object[] theElements = elements;
0:     for (int i = from; i < to; i++) {
0:       int random = gen.nextIntFromTo(i, to);
1: 
0:       //swap(i, random)
0:       Object tmpElement = theElements[random];
0:       theElements[random] = theElements[i];
0:       theElements[i] = tmpElement;
1:     }
1:   }
1: 
0:   /** Returns the number of elements contained in the receiver. */
1:   @Override
1:   public int size() {
1:     return size;
1:   }
1: 
1:   /**
0:    * Returns a list which is a concatenation of <code>times</code> times the receiver.
1:    *
0:    * @param times the number of times the receiver shall be copied.
1:    */
0:   public ObjectArrayList times(int times) {
0:     ObjectArrayList newList = new ObjectArrayList(times * size);
0:     for (int i = times; --i >= 0;) {
0:       newList.addAllOfFromTo(this, 0, size() - 1);
1:     }
0:     return newList;
1:   }
1: 
1:   /**
0:    * Returns an array containing all of the elements in the receiver in the correct order.  The runtime type of the
0:    * returned array is that of the specified array.  If the receiver fits in the specified array, it is returned
0:    * therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of the
0:    * receiver. <p> If the receiver fits in the specified array with room to spare (i.e., the array has more elements
0:    * than the receiver), the element in the array immediately following the end of the receiver is set to null.  This is
0:    * useful in determining the length of the receiver <em>only</em> if the caller knows that the receiver does not
0:    * contain any null elements.
1:    *
0:    * @param array the array into which the elements of the receiver are to be stored, if it is big enough; otherwise, a
0:    *              new array of the same runtime type is allocated for this purpose.
0:    * @return an array containing the elements of the receiver.
0:    * @throws ArrayStoreException the runtime type of <tt>array</tt> is not a supertype of the runtime type of every
0:    *                             element in the receiver.
1:    */
0:   public Object[] toArray(Object[] array) {
0:     if (array.length < size) {
0:       array = (Object[]) java.lang.reflect.Array.newInstance(array.getClass().getComponentType(), size);
1:     }
1: 
1:     Object[] theElements = elements;
0:     for (int i = size; --i >= 0;) {
0:       array[i] = theElements[i];
1:     }
1: 
0:     if (array.length > size) {
0:       array[size] = null;
1:     }
1: 
0:     return array;
1:   }
1: 
0:   /** Returns a <code>ArrayList</code> containing all the elements in the receiver. */
1:   @Override
0:   public List<Object[]> toList() {
0:     int mySize = size();
1:     Object[] theElements = elements;
0:     List<Object[]> list = new ArrayList<Object[]>(mySize);
0:     list.addAll(Arrays.<Object[]>asList(theElements).subList(0, mySize));
0:     return list;
1:   }
1: 
0:   /** Returns a string representation of the receiver, containing the String representation of each element. */
0:   public String toString() {
0:     return org.apache.mahout.matrix.Arrays.toString(partFromTo(0, size() - 1).elements());
1:   }
1: 
1:   /**
0:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluos internal memory. An
1:    * application can use this operation to minimize the storage of the receiver.
1:    */
1:   @Override
1:   public void trimToSize() {
0:     elements = org.apache.mahout.matrix.Arrays.trimToCapacity(elements, size());
1:   }
commit:fcbc54a
/////////////////////////////////////////////////////////////////////////
0:   /**
0:    * The array buffer into which the elements of the list are stored.
0:    * The capacity of the list is the length of this array buffer.
0:    * @serial
0:    */
0:   protected Object[] elements;
0:   
0:   /**
0:    * The size of the list.
0:    * @serial
0:    */
0:   protected int size;
0:   this(10);
/////////////////////////////////////////////////////////////////////////
0:   elements(elements);
/////////////////////////////////////////////////////////////////////////
0:   this(new Object[initialCapacity]);
0:   size=0;
/////////////////////////////////////////////////////////////////////////
0:   if (size == elements.length) ensureCapacity(size + 1); 
0:   elements[size++] = element;
/////////////////////////////////////////////////////////////////////////
0:   beforeInsertAllOfFromTo(size, other, from, to);
/////////////////////////////////////////////////////////////////////////
1:   // overridden for performance only.
0:   if (index > size || index < 0) 
0:     throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);
0:   ensureCapacity(size + 1);
0:   System.arraycopy(elements, index, elements, index+1, size-index);
0:   elements[index] = element;
0:   size++;
/////////////////////////////////////////////////////////////////////////
0:   int length=to-from+1;
0:   this.beforeInsertDummies(index, length);
0:   this.replaceFromToWithFrom(index, index+length-1, other, from);
/////////////////////////////////////////////////////////////////////////
0:   if (index > size || index < 0) 
0:     throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);
0:   if (length > 0) {
0:     ensureCapacity(size + length);
0:       System.arraycopy(elements, index, elements, index + length, size-index);
0:     size += length;
0:   }
/////////////////////////////////////////////////////////////////////////
0:  *         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
0:  *         point</i> is defined as the the point at which the value would
0:  *          be inserted into the receiver: the index of the first
0:  *         element greater than the key, or <tt>receiver.size()</tt>, if all
0:  *         elements in the receiver are less than the specified key.  Note
0:  *         that this guarantees that the return value will be &gt;= 0 if
0:  *         and only if the key is found.
0:   return this.binarySearchFromTo(key, 0, size-1);
/////////////////////////////////////////////////////////////////////////
0:  *         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
0:  *         point</i> is defined as the the point at which the value would
0:  *          be inserted into the receiver: the index of the first
0:  *         element greater than the key, or <tt>receiver.size()</tt>, if all
0:  *         elements in the receiver are less than the specified key.  Note
0:  *         that this guarantees that the return value will be &gt;= 0 if
0:  *         and only if the key is found.
0:   int low = from;
0:   int high = to;
0:   while (low <= high) {
0:     int mid =(low + high)/2;
0:     Object midVal = elements[mid];
0:     int cmp = ((Comparable)midVal).compareTo(key);
0:     if (cmp < 0) low = mid + 1;
0:     else if (cmp > 0) high = mid - 1;
0:     else return mid; // key found
0:   }
0:   return -(low + 1);  // key not found.
/////////////////////////////////////////////////////////////////////////
0:  *         <i>mutually comparable</i> using the specified comparator.
0:  *         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
0:  *         point</i> is defined as the the point at which the value would
0:  *          be inserted into the receiver: the index of the first
0:  *         element greater than the key, or <tt>receiver.size()</tt>, if all
0:  *         elements in the receiver are less than the specified key.  Note
0:  *         that this guarantees that the return value will be &gt;= 0 if
0:  *         and only if the key is found.
0:   return org.apache.mahout.matrix.Sorting.binarySearchFromTo(this.elements,key,from,to,comparator);
/////////////////////////////////////////////////////////////////////////
0:   ObjectArrayList v = (ObjectArrayList)super.clone();
0:   v.elements = (Object[]) elements.clone();
0:   return v;
/////////////////////////////////////////////////////////////////////////
0:   return indexOfFromTo(elem,0,size-1, testForEquality) >=0;
/////////////////////////////////////////////////////////////////////////
0:   return (ObjectArrayList) clone();
/////////////////////////////////////////////////////////////////////////
0:   int index = indexOfFromTo(element, 0, size-1, testForEquality);
0:   if (index>=0) removeFromTo(index,index);
/////////////////////////////////////////////////////////////////////////
0:   return elements;
/////////////////////////////////////////////////////////////////////////
0:   this.elements=elements;
0:   this.size=elements.length;
0:   return this;
/////////////////////////////////////////////////////////////////////////
0:   elements = org.apache.mahout.matrix.Arrays.ensureCapacity(elements,minCapacity);
/////////////////////////////////////////////////////////////////////////
0:   return equals(otherObj, true);
/////////////////////////////////////////////////////////////////////////
0:   if (! (otherObj instanceof ObjectArrayList)) {return false;}
0:   if (this==otherObj) return true;
0:   if (otherObj==null) return false;
0:   ObjectArrayList other = (ObjectArrayList) otherObj;
0:   if (elements==other.elements()) return true;
0:   if (size!=other.size()) return false;
0:   Object[] otherElements = other.elements();
0:   Object[] theElements = elements;
0:   if (! testForEquality) {
0:     for (int i=size; --i >= 0; ) {
0:       if (theElements[i] != otherElements[i]) return false;
0:     }
0:   }
0:   else {
0:     for (int i=size; --i >= 0; ) {
0:       if (!(theElements[i]==null ? otherElements[i]==null : theElements[i].equals(otherElements[i]))) return false;
0:     }
0:   }
0:   return true;
/////////////////////////////////////////////////////////////////////////
0:   checkRangeFromTo(from,to,this.size);
0:   for (int i=from; i<=to;) setQuick(i++,val); 
/////////////////////////////////////////////////////////////////////////
0:   Object[] theElements = elements;
0:   int theSize = size;
0:   
0:   for (int i=0; i<theSize;) if (! procedure.apply(theElements[i++])) return false;
0:   return true;
/////////////////////////////////////////////////////////////////////////
0:   if (index >= size || index < 0)
0:     throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);
0:   return elements[index];
/////////////////////////////////////////////////////////////////////////
0:   return elements[index];
/////////////////////////////////////////////////////////////////////////
0:   return this.indexOfFromTo(element, 0, size-1, testForEquality);
/////////////////////////////////////////////////////////////////////////
0:   if (size==0) return -1;
0:   checkRangeFromTo(from, to, size);
0:   Object[] theElements = elements;
0:   if (testForEquality && element!=null) {
0:     for (int i = from ; i <= to; i++) {
0:         if (element.equals(theElements[i])) {return i;} //found
0:     }
0:   }
0:   else {
0:     for (int i = from ; i <= to; i++) {
0:         if (element==theElements[i]) {return i;} //found
0:     }
0:   }
0:   return -1; //not found
/////////////////////////////////////////////////////////////////////////
0:   if (size==0) return true;
0:   checkRangeFromTo(from, to, size);
0:   
0:   Object[] theElements = elements;
0:   for (int i=from+1; i<=to; i++ ) {
0:     if (((Comparable)theElements[i]).compareTo((Comparable) theElements[i-1]) < 0) return false;
0:   }
0:   return true;
/////////////////////////////////////////////////////////////////////////
0:   return lastIndexOfFromTo(element, 0, size-1, testForEquality);
/////////////////////////////////////////////////////////////////////////
0:   if (size==0) return -1;
0:   checkRangeFromTo(from, to, size);
0:   Object[] theElements = elements;
0:   if (testForEquality && element!=null) {
0:     for (int i = to ; i >= from; i--) {
0:         if (element.equals(theElements[i])) {return i;} //found
0:     }
0:   }
0:   else {
0:     for (int i = to ; i >= from; i--) {
0:         if (element==theElements[i]) {return i;} //found
0:     }
0:   }
0:   return -1; //not found
/////////////////////////////////////////////////////////////////////////
0:   if (size==0) return;
0:   checkRangeFromTo(from, to, size);
0:   java.util.Arrays.sort(elements, from, to+1);
/////////////////////////////////////////////////////////////////////////
0:  *         <i>mutually comparable</i> using the specified comparator.
0:  *         <tt>toIndex &gt; a.length</tt>
0:   if (size==0) return;
0:   checkRangeFromTo(from, to, size);
0:   java.util.Arrays.sort(elements, from, to+1, c);
/////////////////////////////////////////////////////////////////////////
0:   if (size==0) return new ObjectArrayList(0);
0:   checkRangeFromTo(from, to, size);
0:   Object[] part = new Object[to-from+1];
0:   System.arraycopy(elements, from, part, 0, to-from+1);
0:   return new ObjectArrayList(part);
/////////////////////////////////////////////////////////////////////////
0:   if (size==0) return;
0:   checkRangeFromTo(from, to, size);
0:   org.apache.mahout.matrix.Sorting.quickSort(elements, from, to+1);
/////////////////////////////////////////////////////////////////////////
0:  *         <i>mutually comparable</i> using the specified comparator.
0:  *         <tt>toIndex &gt; a.length</tt>
0:   if (size==0) return;
0:   checkRangeFromTo(from, to, size);
0:   org.apache.mahout.matrix.Sorting.quickSort(elements, from, to+1, c);
/////////////////////////////////////////////////////////////////////////
0:   if (other.size==0) return false; //nothing to do
0:   int limit = other.size-1;
0:   int j=0;
0:   Object[] theElements = elements;
0:   for (int i=0; i<size ; i++) {
0:     if (other.indexOfFromTo(theElements[i], 0, limit, testForEquality) < 0) theElements[j++]=theElements[i];
0:   }
0:   boolean modified = (j!=size);
0:   setSize(j);
0:   return modified;
/////////////////////////////////////////////////////////////////////////
0:   checkRangeFromTo(from, to, size);
0:   int numMoved = size - to - 1;
0:   if (numMoved >= 0) {
0:     System.arraycopy(elements, to+1, elements, from, numMoved);
0:     fillFromToWith(from+numMoved, size-1, null); //delta
0:   }
0:   int width = to-from+1;
0:   if (width>0) size -= width;
/////////////////////////////////////////////////////////////////////////
0:   int length=to-from+1;
0:   if (length>0) {
0:     checkRangeFromTo(from, to, size);
0:     checkRangeFromTo(otherFrom,otherFrom+length-1,other.size);
0:     System.arraycopy(other.elements, otherFrom, elements, from, length);
0:   }
/////////////////////////////////////////////////////////////////////////
0:   if (otherFrom>otherTo) {
0:     throw new IndexOutOfBoundsException("otherFrom: "+otherFrom+", otherTo: "+otherTo);
0:   }
0:   if (this==other && to-from!=otherTo-otherFrom) { // avoid stumbling over my own feet
0:     replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo-otherFrom);
0:     return;
0:   }
0:   
0:   int length=otherTo-otherFrom+1;
0:   int diff=length;
0:   int theLast=from-1;
0:   //System.out.println("from="+from);
0:   //System.out.println("to="+to);
0:   //System.out.println("diff="+diff);
0:   
0:   if (to>=from) {
0:     diff -= (to-from+1);
0:     theLast=to;
0:   }
0:   
0:   if (diff>0) {
0:     beforeInsertDummies(theLast+1, diff);
0:   }
0:   else {
0:     if (diff<0) {
0:       removeFromTo(theLast+diff, theLast-1);
0:     }
0:   }
0:   if (length>0) {
0:     System.arraycopy(other.elements, otherFrom, elements, from, length);
0:   }
/////////////////////////////////////////////////////////////////////////
0:   checkRange(from,size);
0:   java.util.Iterator e = other.iterator();
0:   int index=from;
0:   int limit = Math.min(size-from, other.size());
0:   for (int i=0; i<limit; i++)
0:       elements[index++] = e.next(); //delta
/////////////////////////////////////////////////////////////////////////
0:   if (other.size==0) {
0:     if (size==0) return false;
0:     setSize(0);
0:     return true;
0:   }
0:   
0:   int limit = other.size-1;
0:   int j=0;
0:   Object[] theElements = elements;
0:   for (int i=0; i<size ; i++) {
0:     if (other.indexOfFromTo(theElements[i], 0, limit, testForEquality) >= 0) theElements[j++]=theElements[i];
0:   }
0:   boolean modified = (j!=size);
0:   setSize(j);
0:   return modified;
0:   Object tmp;
0:   int limit=size/2;
0:   int j=size-1;
0:   
0:   Object[] theElements = elements;
0:   for (int i=0; i<limit;) { //swap
0:     tmp=theElements[i];
0:     theElements[i++]=theElements[j];
0:     theElements[j--]=tmp;
0:   }
/////////////////////////////////////////////////////////////////////////
0:  *       &lt; 0 || index &gt;= size()).
0:   if (index >= size || index < 0)
0:     throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);
0:   elements[index] = element;
/////////////////////////////////////////////////////////////////////////
0:   elements[index] = element;
/////////////////////////////////////////////////////////////////////////
0:   if (size == 0) return;
0:   checkRangeFromTo(from, to, size);
0:   
0:   org.apache.mahout.jet.random.Uniform gen = new org.apache.mahout.jet.random.Uniform(new org.apache.mahout.jet.random.engine.DRand(new java.util.Date()));
0:   Object tmpElement;
0:   Object[] theElements = elements;
0:   int random;
0:   for (int i = from; i < to; i++) {
0:     random = gen.nextIntFromTo(i, to);
0:     //swap(i, random)
0:     tmpElement = theElements[random];
0:     theElements[random] = theElements[i];
0:     theElements[i] = tmpElement;
0:   }
/////////////////////////////////////////////////////////////////////////
0:   return size;
0:   ObjectArrayList newList = new ObjectArrayList(times*size);
0:   for (int i=times; --i >= 0; ) {
0:     newList.addAllOfFromTo(this,0,size()-1);
0:   }
0:   return newList;
/////////////////////////////////////////////////////////////////////////
0:  *    be stored, if it is big enough; otherwise, a new array of the
0:  *     same runtime type is allocated for this purpose.
0:   if (array.length < size)
0:     array = (Object[])java.lang.reflect.Array.newInstance(array.getClass().getComponentType(), size);
0:   Object[] theElements = elements;
0:   for (int i=size; --i >=0; ) array[i]=theElements[i];
0:   if (array.length > size) array[size] = null;
0:   return array;
0:   int mySize = size();
0:   Object[] theElements = elements;
0:   java.util.ArrayList list = new java.util.ArrayList(mySize);
0:   for (int i=0; i < mySize; i++) list.add(theElements[i]);
0:   return list;
0:   return org.apache.mahout.matrix.Arrays.toString(partFromTo(0, size()-1).elements());
/////////////////////////////////////////////////////////////////////////
0:   elements = org.apache.mahout.matrix.Arrays.trimToCapacity(elements,size());
author:Ted Dunning
-------------------------------------------------------------------------------
commit:35fa73f
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements. See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership. The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License. You may obtain a copy of the License at
0:  *
1:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied. See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  */
1: /*
1: Copyright ï¿? 1999 CERN - European Organization for Nuclear Research.
1: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1: that both that copyright notice and this permission notice appear in supporting documentation. 
1: CERN makes no representations about the suitability of this software for any purpose. 
1: It is provided "as is" without expressed or implied warranty.
0: */
1: package org.apache.mahout.math.list;
0: 
1: import org.apache.mahout.math.function.ObjectProcedure;
0: 
0: import java.util.Collection;
0: 
0: /**
1:  Resizable list holding <code>${valueType}</code> elements; implemented with arrays.
0: */
0: 
1: public class ObjectArrayList<T> extends AbstractObjectList<T> {
0: 
0:   /**
0:    * The array buffer into which the elements of the list are stored. The capacity of the list is the length of this
0:    * array buffer.
0:    */
1:   private Object[] elements;
1:   private int size;
0: 
0:   /** Constructs an empty list. */
0:   public ObjectArrayList() {
0:     this(10);
0:   }
0: 
0:   /**
0:    * Constructs a list containing the specified elements. The initial size and capacity of the list is the length of the
0:    * array.
0:    *
0:    * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>. So if
0:    * subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.
0:    *
0:    * @param elements the array to be backed by the the constructed list
0:    */
1:   public ObjectArrayList(T[] elements) {
0:     elements(elements);
0:   }
0: 
0:   /**
0:    * Constructs an empty list with the specified initial capacity.
0:    *
0:    * @param initialCapacity the number of elements the receiver can hold without auto-expanding itself by allocating new
0:    *                        internal memory.
0:    */
1:   @SuppressWarnings("unchecked")
0:   public ObjectArrayList(int initialCapacity) {
0:     elements((T[])new Object[initialCapacity]);
0:   }
0: 
0:   /**
0:    * Appends the specified element to the end of this list.
0:    *
0:    * @param element element to be appended to this list.
0:    */
1:   public void add(T element) {
1:     // overridden for performance only.
0:     if (size == elements.length) {
0:       ensureCapacity(size + 1);
0:     }
0:     elements[size++] = element;
0:   }
0: 
0:   /**
0:    * Inserts the specified element before the specified position into the receiver. Shifts the element currently at that
0:    * position (if any) and any subsequent elements to the right.
0:    *
0:    * @param index   index before which the specified element is to be inserted (must be in [0,size]).
0:    * @param element element to be inserted.
0:    * @throws IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).
0:    */
1:   public void beforeInsert(int index, T element) {
1:     // overridden for performance only.
1:     if (size == index) {
1:       add(element);
0:       return;
0:     }
0:     if (index > size || index < 0) {
0:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
0:     }
0:     ensureCapacity(size + 1);
0:     System.arraycopy(elements, index, elements, index + 1, size - index);
0:     elements[index] = element;
0:     size++;
0:   }
0: 
0: 
0:   /**
1:    * Returns a deep copy of the receiver.
0:    *
1:    * @return a deep copy of the receiver.
0:    */
1:   @SuppressWarnings("unchecked")
0:   @Override
0:   public Object clone() {
1:     // overridden for performance only.
0:     return new ObjectArrayList<T>((T[]) elements.clone());
0:   }
0: 
0:   /**
1:    * Returns a deep copy of the receiver; uses <code>clone()</code> and casts the result.
0:    *
1:    * @return a deep copy of the receiver.
0:    */
1:   @SuppressWarnings("unchecked")
1:   public ObjectArrayList<T> copy() {
1:     return (ObjectArrayList<T>) clone();
0:   }
0: 
0:   /**
0:    * Returns the elements currently stored, including invalid elements between size and capacity, if any.
0:    *
0:    * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>. So if
0:    * subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing.
0:    *
0:    * @return the elements currently stored.
0:    */
1:   @SuppressWarnings("unchecked")
0:   public<Q> Q[] elements() {
1:     return (Q[])elements;
0:   }
0: 
0:   /**
0:    * Sets the receiver's elements to be the specified array (not a copy of it).
0:    *
0:    * The size and capacity of the list is the length of the array. <b>WARNING:</b> For efficiency reasons and to keep
0:    * memory usage low, <b>the array is not copied</b>. So if subsequently you modify the specified array directly via
0:    * the [] operator, be sure you know what you're doing.
0:    *
0:    * @param elements the new elements to be stored.
0:    */
1:   public void elements(T[] elements) {
0:     this.elements = elements;
0:     this.size = elements.length;
0:   }
0: 
0:   /**
0:    * Ensures that the receiver can hold at least the specified number of elements without needing to allocate new
0:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver.
0:    *
0:    * @param minCapacity the desired minimum capacity.
0:    */
0:   public void ensureCapacity(int minCapacity) {
1:     elements = org.apache.mahout.math.Arrays.ensureCapacity(elements, minCapacity);
0:   }
0: 
0:   /**
1:    * Compares the specified Object with the receiver. Returns true if and only if the specified Object is also an
1:    * ArrayList of the same type, both Lists have the same size, and all corresponding pairs of elements in the two Lists
1:    * are identical. In other words, two Lists are defined to be equal if they contain the same elements in the same
1:    * order.
0:    *
0:    * @param otherObj the Object to be compared for equality with the receiver.
0:    * @return true if the specified Object is equal to the receiver.
0:    */
1:   @SuppressWarnings("unchecked")
0:   public boolean equals(Object otherObj) { //delta
1:     // overridden for performance only.
0:     if (!(otherObj instanceof ObjectArrayList)) {
1:       return super.equals(otherObj);
0:     }
0:     if (this == otherObj) {
0:       return true;
0:     }
0:     if (otherObj == null) {
0:       return false;
0:     }
0:     ObjectArrayList<?> other = (ObjectArrayList<?>) otherObj;
1:     if (size() != other.size()) {
0:       return false;
0:     }
0: 
1:     Object[] theElements = elements();
0:     Object[] otherElements = other.elements();
1:     for (int i = size(); --i >= 0;) {
0:       if (theElements[i] != otherElements[i]) {
0:         return false;
0:       }
0:     }
0:     return true;
0:   }
0: 
0:   /**
0:    * Applies a procedure to each element of the receiver, if any. Starts at index 0, moving rightwards.
0:    *
0:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
0:    *                  continues.
0:    * @return <tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.
0:    */
1:   @SuppressWarnings("unchecked")
1:   public boolean forEach(ObjectProcedure<T> procedure) {
1:     T[] theElements = (T[]) elements;
0:     int theSize = size;
0: 
0:     for (int i = 0; i < theSize;) {
0:       if (!procedure.apply(theElements[i++])) {
0:         return false;
0:       }
0:     }
0:     return true;
0:   }
0: 
0:   /**
0:    * Returns the element at the specified position in the receiver.
0:    *
0:    * @param index index of element to return.
0:    * @throws IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).
0:    */
1:   @SuppressWarnings("unchecked")
1:   public T get(int index) {
1:     // overridden for performance only.
0:     if (index >= size || index < 0) {
0:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
0:     }
1:     return (T) elements[index];
0:   }
0: 
0:   /**
0:    * Returns the element at the specified position in the receiver; <b>WARNING:</b> Does not check preconditions.
0:    * Provided with invalid parameters this method may return invalid elements without throwing any exception! <b>You
0:    * should only use this method when you are absolutely sure that the index is within bounds.</b> Precondition
0:    * (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.
0:    *
0:    * @param index index of element to return.
0:    */
1:   @SuppressWarnings("unchecked")
1:   public T getQuick(int index) {
1:     return (T) elements[index];
0:   }
0: 
0:   /**
0:    * Returns the index of the first occurrence of the specified element. Returns <code>-1</code> if the receiver does
1:    * not contain this element. Searches between <code>from</code>, inclusive and <code>to</code>, inclusive. Tests for
1:    * identity.
0:    *
1:    * @param element element to search for.
1:    * @param from    the leftmost search position, inclusive.
1:    * @param to      the rightmost search position, inclusive.
0:    * @return the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is
0:    *         not found.
0:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
0:    *                                   to&gt;=size())</tt>).
0:    */
1:   public int indexOfFromTo(T element, int from, int to) {
1:     // overridden for performance only.
0:     if (size == 0) {
0:       return -1;
0:     }
0:     checkRangeFromTo(from, to, size);
0: 
0:     Object[] theElements = elements;
0:     for (int i = from; i <= to; i++) {
0:       if (element == theElements[i]) {
0:         return i;
0:       } //found
0:     }
0:     return -1; //not found
0:   }
0: 
0:   /**
0:    * Returns the index of the last occurrence of the specified element. Returns <code>-1</code> if the receiver does not
0:    * contain this element. Searches beginning at <code>to</code>, inclusive until <code>from</code>, inclusive. Tests
1:    * for identity.
0:    *
1:    * @param element element to search for.
1:    * @param from    the leftmost search position, inclusive.
1:    * @param to      the rightmost search position, inclusive.
0:    * @return the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is
0:    *         not found.
0:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
0:    *                                   to&gt;=size())</tt>).
0:    */
1:   public int lastIndexOfFromTo(T element, int from, int to) {
1:     // overridden for performance only.
0:     if (size == 0) {
0:       return -1;
0:     }
0:     checkRangeFromTo(from, to, size);
0: 
0:     Object[] theElements = elements;
0:     for (int i = to; i >= from; i--) {
0:       if (element == theElements[i]) {
0:         return i;
0:       } //found
0:     }
0:     return -1; //not found
0:   }
0: 
0:   /**
0:    * Returns a new list of the part of the receiver between <code>from</code>, inclusive, and <code>to</code>,
0:    * inclusive.
0:    *
0:    * @param from the index of the first element (inclusive).
0:    * @param to   the index of the last element (inclusive).
0:    * @return a new list
0:    * @throws IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to ||
0:    *                                   to&gt;=size())</tt>).
0:    */
1:   @SuppressWarnings("unchecked")
1:   public AbstractObjectList<T> partFromTo(int from, int to) {
0:     if (size == 0) {
0:       return new ObjectArrayList<T>(0);
0:     }
0: 
0:     checkRangeFromTo(from, to, size);
0: 
0:     Object[] part = new Object[to - from + 1];
0:     System.arraycopy(elements, from, part, 0, to - from + 1);
0:     return new ObjectArrayList<T>((T[]) part);
0:   }
0: 
0:   /** Reverses the elements of the receiver. Last becomes first, second last becomes second first, and so on. */
0:   @Override
0:   public void reverse() {
1:     // overridden for performance only.
0:     int limit = size / 2;
0:     int j = size - 1;
0: 
0:     Object[] theElements = elements;
0:     for (int i = 0; i < limit;) { //swap
0:       Object tmp = theElements[i];
0:       theElements[i++] = theElements[j];
0:       theElements[j--] = tmp;
0:     }
0:   }
0: 
0:   /**
0:    * Replaces the element at the specified position in the receiver with the specified element.
0:    *
0:    * @param index   index of element to replace.
0:    * @param element element to be stored at the specified position.
0:    * @throws IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).
0:    */
1:   public void set(int index, T element) {
1:     // overridden for performance only.
0:     if (index >= size || index < 0) {
0:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
0:     }
0:     elements[index] = element;
0:   }
0: 
0:   /**
0:    * Replaces the element at the specified position in the receiver with the specified element; <b>WARNING:</b> Does not
0:    * check preconditions. Provided with invalid parameters this method may access invalid indexes without throwing any
0:    * exception! <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
0:    * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.
0:    *
0:    * @param index   index of element to replace.
0:    * @param element element to be stored at the specified position.
0:    */
1:   public void setQuick(int index, T element) {
0:     elements[index] = element;
0:   }
0: 
0:   /**
1:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
0:    * application can use this operation to minimize the storage of the receiver.
0:    */
0:   @Override
0:   public void trimToSize() {
1:     elements = org.apache.mahout.math.Arrays.trimToCapacity(elements, size());
0:   }
0: 
0:   @Override
1:   public void removeFromTo(int fromIndex, int toIndex) {
1:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
1:   public void replaceFromWith(int from, Collection<T> other) {
1:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
0:   protected void beforeInsertDummies(int index, int length) {
1:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
0:   public void mergeSortFromTo(int from, int to) {
1:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
0:   public void quickSortFromTo(int from, int to) {
1:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
0:   public int size() {
0:     return size;
0:   }
0: }
author:Benson Margulies
-------------------------------------------------------------------------------
commit:ebf9a4d
/////////////////////////////////////////////////////////////////////////
author:Robin Anil
-------------------------------------------------------------------------------
commit:a51dd9e
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements. See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership. The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License. You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
/////////////////////////////////////////////////////////////////////////
0:  Resizable list holding <code>${valueType}</code> elements; implemented with arrays.
0: */
0: public class ObjectArrayList<T> extends AbstractObjectList<T> {
0:   private Object[] elements;
0:   private int size;
/////////////////////////////////////////////////////////////////////////
0:   public ObjectArrayList(T[] elements) {
/////////////////////////////////////////////////////////////////////////
0:   @SuppressWarnings("unchecked")
0:     elements((T[])new Object[initialCapacity]);
/////////////////////////////////////////////////////////////////////////
0:   public void add(T element) {
0:     // overridden for performance only.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:   public void beforeInsert(int index, T element) {
0:     if (size == index) {
0:       add(element);
0:       return;
0:     }
/////////////////////////////////////////////////////////////////////////
0:    * Returns a deep copy of the receiver.
0:    * @return a deep copy of the receiver.
0:   @SuppressWarnings("unchecked")
0:     // overridden for performance only.
0:     ObjectArrayList<T> clone = new ObjectArrayList<T>((T[]) elements.clone());
0:     return clone;
0:    * Returns a deep copy of the receiver; uses <code>clone()</code> and casts the result.
0:    * @return a deep copy of the receiver.
0:   @SuppressWarnings("unchecked")
0:   public ObjectArrayList<T> copy() {
0:     return (ObjectArrayList<T>) clone();
/////////////////////////////////////////////////////////////////////////
0:   @SuppressWarnings("unchecked")
0:   public<Q> Q[] elements() {
0:     return (Q[])elements;
/////////////////////////////////////////////////////////////////////////
0:   public void elements(T[] elements) {
/////////////////////////////////////////////////////////////////////////
0:    * Compares the specified Object with the receiver. Returns true if and only if the specified Object is also an
0:    * ArrayList of the same type, both Lists have the same size, and all corresponding pairs of elements in the two Lists
0:    * are identical. In other words, two Lists are defined to be equal if they contain the same elements in the same
0:    * order.
0:   @SuppressWarnings("unchecked")
0:     // overridden for performance only.
0:       return super.equals(otherObj);
/////////////////////////////////////////////////////////////////////////
0:     if (size() != other.size()) {
0:     Object[] theElements = elements();
0:     for (int i = size(); --i >= 0;) {
0:       if (theElements[i] != otherElements[i]) {
0:         return false;
/////////////////////////////////////////////////////////////////////////
0:   @SuppressWarnings("unchecked")
0:   public boolean forEach(ObjectProcedure<T> procedure) {
0:     T[] theElements = (T[]) elements;
/////////////////////////////////////////////////////////////////////////
0:   @SuppressWarnings("unchecked")
0:   public T get(int index) {
0:     // overridden for performance only.
0:     return (T) elements[index];
/////////////////////////////////////////////////////////////////////////
0:   @SuppressWarnings("unchecked")
0:   public T getQuick(int index) {
0:     return (T) elements[index];
0:    * not contain this element. Searches between <code>from</code>, inclusive and <code>to</code>, inclusive. Tests for
0:    * identity.
0:    * @param element element to search for.
0:    * @param from    the leftmost search position, inclusive.
0:    * @param to      the rightmost search position, inclusive.
0:   public int indexOfFromTo(T element, int from, int to) {
0:     // overridden for performance only.
0:     for (int i = from; i <= to; i++) {
0:       if (element == theElements[i]) {
0:         return i;
0:       } //found
0:    * for identity.
0:    * @param element element to search for.
0:    * @param from    the leftmost search position, inclusive.
0:    * @param to      the rightmost search position, inclusive.
0:   public int lastIndexOfFromTo(T element, int from, int to) {
0:     // overridden for performance only.
0:     for (int i = to; i >= from; i--) {
0:       if (element == theElements[i]) {
0:         return i;
0:       } //found
/////////////////////////////////////////////////////////////////////////
0:   @SuppressWarnings("unchecked")
0:   public AbstractObjectList<T> partFromTo(int from, int to) {
0:       return new ObjectArrayList<T>(0);
0:     return new ObjectArrayList<T>((T[]) part);
0:     // overridden for performance only.
/////////////////////////////////////////////////////////////////////////
0:   public void set(int index, T element) {
0:     // overridden for performance only.
/////////////////////////////////////////////////////////////////////////
0:   public void setQuick(int index, T element) {
/////////////////////////////////////////////////////////////////////////
0:     // overridden for performance only.
/////////////////////////////////////////////////////////////////////////
0:   
0:   
0:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
0: 
0:   @Override
0:   public void removeFromTo(int fromIndex, int toIndex) {
0:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
0:   public void replaceFromWith(int from, Collection<T> other) {
0:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
0:   protected void beforeInsertDummies(int index, int length) {
0:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
0:   public void mergeSortFromTo(int from, int to) {
0:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
0:   public void quickSortFromTo(int from, int to) {
0:     throw new UnsupportedOperationException();
0:   }
0: 
0:   @Override
0:   public int size() {
0:     return size;
0:   }
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:a435efb
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.math.list;
0: import org.apache.mahout.math.Sorting;
0: import org.apache.mahout.math.function.ObjectProcedure;
0: import org.apache.mahout.math.jet.random.Uniform;
0: import org.apache.mahout.math.jet.random.engine.DRand;
/////////////////////////////////////////////////////////////////////////
0:    * @see org.apache.mahout.math.Sorting
0:     return org.apache.mahout.math.Sorting.binarySearchFromTo(this.elements, key, from, to, comparator);
/////////////////////////////////////////////////////////////////////////
0:     elements = org.apache.mahout.math.Arrays.ensureCapacity(elements, minCapacity);
/////////////////////////////////////////////////////////////////////////
0:     return org.apache.mahout.math.Arrays.toString(partFromTo(0, size() - 1).elements());
/////////////////////////////////////////////////////////////////////////
0:     elements = org.apache.mahout.math.Arrays.trimToCapacity(elements, size());
commit:f49424e
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.matrix.list;
0: import org.apache.mahout.matrix.function.ObjectProcedure;
/////////////////////////////////////////////////////////////////////////
0:  * @see org.apache.mahout.matrix.Sorting
0: 	return org.apache.mahout.matrix.Sorting.binarySearchFromTo(this.elements,key,from,to,comparator);
/////////////////////////////////////////////////////////////////////////
0: 	elements = org.apache.mahout.matrix.Arrays.ensureCapacity(elements,minCapacity);
/////////////////////////////////////////////////////////////////////////
0: 	org.apache.mahout.matrix.Sorting.quickSort(elements, from, to+1);
/////////////////////////////////////////////////////////////////////////
0: 	org.apache.mahout.matrix.Sorting.quickSort(elements, from, to+1, c);
/////////////////////////////////////////////////////////////////////////
0: 	return org.apache.mahout.matrix.Arrays.toString(partFromTo(0, size()-1).elements());
/////////////////////////////////////////////////////////////////////////
0: 	elements = org.apache.mahout.matrix.Arrays.trimToCapacity(elements,size());
commit:7550a10
/////////////////////////////////////////////////////////////////////////
0: /*
0: Copyright ï¿? 1999 CERN - European Organization for Nuclear Research.
0: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
0: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
0: that both that copyright notice and this permission notice appear in supporting documentation. 
0: CERN makes no representations about the suitability of this software for any purpose. 
0: It is provided "as is" without expressed or implied warranty.
0: */
0: package org.apache.mahout.colt.list;
0: 
0: import org.apache.mahout.colt.function.ObjectProcedure;
0: /**
0: Resizable list holding <code>Object</code> elements; implemented with arrays.
0: First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
0: */
0: /** 
0:  * @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported.
0:  */
0: @Deprecated
0: public class ObjectArrayList extends AbstractList {
0: 	/**
0: 	 * The array buffer into which the elements of the list are stored.
0: 	 * The capacity of the list is the length of this array buffer.
0: 	 * @serial
0: 	 */
0: 	protected Object[] elements;
0: 	
0: 	/**
0: 	 * The size of the list.
0: 	 * @serial
0: 	 */
0: 	protected int size;
0: /**
0:  * Constructs an empty list.
0:  */
0: public ObjectArrayList() {
0: 	this(10);
0: }
0: /**
0:  * Constructs a list containing the specified elements. 
0:  * The initial size and capacity of the list is the length of the array.
0:  *
0:  * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
0:  * So if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.
0:  * 
0:  * @param elements the array to be backed by the the constructed list
0:  */
0: public ObjectArrayList(Object[] elements) {
0: 	elements(elements);
0: }
0: /**
0:  * Constructs an empty list with the specified initial capacity.
0:  *
0:  * @param   initialCapacity   the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory.
0:  */
0: public ObjectArrayList(int initialCapacity) {
0: 	this(new Object[initialCapacity]);
0: 	size=0;
0: }
0: /**
0:  * Appends the specified element to the end of this list.
0:  *
0:  * @param element element to be appended to this list.
0:  */
0: public void add(Object element) {
0: 	if (size == elements.length) ensureCapacity(size + 1); 
0: 	elements[size++] = element;
0: }
0: /**
0:  * Appends the part of the specified list between <code>from</code> (inclusive) and <code>to</code> (inclusive) to the receiver.
0:  *
0:  * @param other the list to be added to the receiver.
0:  * @param from the index of the first element to be appended (inclusive).
0:  * @param to the index of the last element to be appended (inclusive).
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())</tt>).
0:  */
0: public void addAllOfFromTo(ObjectArrayList other, int from, int to) {
0: 	beforeInsertAllOfFromTo(size, other, from, to);
0: }
0: /**
0:  * Inserts the specified element before the specified position into the receiver. 
0:  * Shifts the element currently at that position (if any) and
0:  * any subsequent elements to the right.
0:  *
0:  * @param index index before which the specified element is to be inserted (must be in [0,size]).
0:  * @param element element to be inserted.
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).
0:  */
0: public void beforeInsert(int index, Object element) {
0: 	// overridden for performance only.
0: 	if (index > size || index < 0) 
0: 		throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);
0: 	ensureCapacity(size + 1);
0: 	System.arraycopy(elements, index, elements, index+1, size-index);
0: 	elements[index] = element;
0: 	size++;
0: }
0: /**
0:  * Inserts the part of the specified list between <code>otherFrom</code> (inclusive) and <code>otherTo</code> (inclusive) before the specified position into the receiver. 
0:  * Shifts the element currently at that position (if any) and
0:  * any subsequent elements to the right.
0:  *
0:  * @param index index before which to insert first element from the specified list (must be in [0,size])..
0:  * @param other list of which a part is to be inserted into the receiver.
0:  * @param from the index of the first element to be inserted (inclusive).
0:  * @param to the index of the last element to be inserted (inclusive).
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())</tt>).
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).
0:  */
0: public void beforeInsertAllOfFromTo(int index, ObjectArrayList other, int from, int to) {
0: 	int length=to-from+1;
0: 	this.beforeInsertDummies(index, length);
0: 	this.replaceFromToWithFrom(index, index+length-1, other, from);
0: }
0: /**
0:  * Inserts length dummies before the specified position into the receiver. 
0:  * Shifts the element currently at that position (if any) and
0:  * any subsequent elements to the right.
0:  *
0:  * @param index index before which to insert dummies (must be in [0,size])..
0:  * @param length number of dummies to be inserted.
0:  */
0: protected void beforeInsertDummies(int index, int length) {
0: 	if (index > size || index < 0) 
0: 		throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);
0: 	if (length > 0) {
0: 		ensureCapacity(size + length);
0: 	    System.arraycopy(elements, index, elements, index + length, size-index);
0: 		size += length;
0: 	}
0: }
0: /**
0:  * Searches the receiver for the specified value using
0:  * the binary search algorithm. The receiver must be sorted into ascending order
0:  * according to the <i>natural ordering</i> of its elements (as by the sort method)
0:  * prior to making this call.  
0:  * If it is not sorted, the results are undefined: in particular, the call
0:  * may enter an infinite loop.  If the receiver contains multiple elements
0:  * equal to the specified object, there is no guarantee which instance
0:  * will be found.
0:  *
0:  * @param key the value to be searched for.
0:  * @return index of the search key, if it is contained in the receiver;
0:  *	       otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
0:  *	       point</i> is defined as the the point at which the value would
0:  * 	       be inserted into the receiver: the index of the first
0:  *	       element greater than the key, or <tt>receiver.size()</tt>, if all
0:  *	       elements in the receiver are less than the specified key.  Note
0:  *	       that this guarantees that the return value will be &gt;= 0 if
0:  *	       and only if the key is found.
0:  * @see Comparable
0:  * @see java.util.Arrays
0:  */
0: public int binarySearch(Object key) {
0: 	return this.binarySearchFromTo(key, 0, size-1);
0: }
0: /**
0:  * Searches the receiver for the specified value using
0:  * the binary search algorithm. The receiver must be sorted into ascending order
0:  * according to the <i>natural ordering</i> of its elements (as by the sort method)
0:  * prior to making this call.  
0:  * If it is not sorted, the results are undefined: in particular, the call
0:  * may enter an infinite loop.  If the receiver contains multiple elements
0:  * equal to the specified object, there is no guarantee which instance
0:  * will be found.
0:  *
0:  *
0:  * @param key the value to be searched for.
0:  * @param from the leftmost search position, inclusive.
0:  * @param to the rightmost search position, inclusive.
0:  * @return index of the search key, if it is contained in the receiver;
0:  *	       otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
0:  *	       point</i> is defined as the the point at which the value would
0:  * 	       be inserted into the receiver: the index of the first
0:  *	       element greater than the key, or <tt>receiver.size()</tt>, if all
0:  *	       elements in the receiver are less than the specified key.  Note
0:  *	       that this guarantees that the return value will be &gt;= 0 if
0:  *	       and only if the key is found.
0:  * @see Comparable
0:  * @see java.util.Arrays
0:  */
0: public int binarySearchFromTo(Object key, int from, int to) {
0: 	int low = from;
0: 	int high = to;
0: 
0: 	while (low <= high) {
0: 		int mid =(low + high)/2;
0: 		Object midVal = elements[mid];
0: 		int cmp = ((Comparable)midVal).compareTo(key);
0: 
0: 		if (cmp < 0) low = mid + 1;
0: 		else if (cmp > 0) high = mid - 1;
0: 		else return mid; // key found
0: 	}
0: 	return -(low + 1);  // key not found.
0: }
0: /**
0:  * Searches the receiver for the specified value using
0:  * the binary search algorithm. The receiver must be sorted into ascending order
0:  * according to the specified comparator.  All elements in the
0:  * range must be <i>mutually comparable</i> by the specified comparator
0:  * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
0:  * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
0:  * <tt>e2</tt> in the range).<p>
0:  *
0:  * If the receiver is not sorted, the results are undefined: in particular, the call
0:  * may enter an infinite loop.  If the receiver contains multiple elements
0:  * equal to the specified object, there is no guarantee which instance
0:  * will be found.
0:  *
0:  *
0:  * @param key the value to be searched for.
0:  * @param from the leftmost search position, inclusive.
0:  * @param to the rightmost search position, inclusive.
0:  * @param comparator the comparator by which the receiver is sorted.
0:  * @throws ClassCastException if the receiver contains elements that are not
0:  *	       <i>mutually comparable</i> using the specified comparator.
0:  * @return index of the search key, if it is contained in the receiver;
0:  *	       otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
0:  *	       point</i> is defined as the the point at which the value would
0:  * 	       be inserted into the receiver: the index of the first
0:  *	       element greater than the key, or <tt>receiver.size()</tt>, if all
0:  *	       elements in the receiver are less than the specified key.  Note
0:  *	       that this guarantees that the return value will be &gt;= 0 if
0:  *	       and only if the key is found.
0:  * @see org.apache.mahout.colt.Sorting
0:  * @see java.util.Arrays
0:  * @see java.util.Comparator
0:  */
0: public int binarySearchFromTo(Object key, int from, int to, java.util.Comparator comparator) {
0: 	return org.apache.mahout.colt.Sorting.binarySearchFromTo(this.elements,key,from,to,comparator);
0: }
0: /**
0:  * Returns a copy of the receiver such that the copy and the receiver <i>share</i> the same elements, but do not share the same array to index them;
0:  * So modifying an object in the copy modifies the object in the receiver and vice versa;
0:  * However, structurally modifying the copy (for example changing its size, setting other objects at indexes, etc.) does not affect the receiver and vice versa.
0:  *
0:  * @return  a copy of the receiver.
0:  */
0: public Object clone() {
0: 	ObjectArrayList v = (ObjectArrayList)super.clone();
0: 	v.elements = (Object[]) elements.clone();
0: 	return v;
0: }
0: /**
0:  * Returns true if the receiver contains the specified element.
0:  * Tests for equality or identity as specified by testForEquality.
0:  *
0:  * @param element element to search for.
0:  * @param testForEquality if true -> test for equality, otherwise for identity.
0:  */
0: public boolean contains(Object elem, boolean testForEquality) {
0: 	return indexOfFromTo(elem,0,size-1, testForEquality) >=0;
0: }
0: /**
0:  * Returns a copy of the receiver; call <code>clone()</code> and casts the result.
0:  * Returns a copy such that the copy and the receiver <i>share</i> the same elements, but do not share the same array to index them;
0:  * So modifying an object in the copy modifies the object in the receiver and vice versa;
0:  * However, structurally modifying the copy (for example changing its size, setting other objects at indexes, etc.) does not affect the receiver and vice versa.
0:  *
0:  * @return  a copy of the receiver.
0:  */
0: public ObjectArrayList copy() {
0: 	return (ObjectArrayList) clone();
0: }
0: /**
0:  * Deletes the first element from the receiver that matches the specified element.
0:  * Does nothing, if no such matching element is contained.
0:  *
0:  * Tests elements for equality or identity as specified by <tt>testForEquality</tt>.
0:  * When testing for equality, two elements <tt>e1</tt> and
0:  * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :
0:  * e1.equals(e2))</tt>.)  
0:  *
0:  * @param testForEquality if true -> tests for equality, otherwise for identity.
0:  * @param element the element to be deleted.
0:  */
0: public void delete(Object element, boolean testForEquality) {
0: 	int index = indexOfFromTo(element, 0, size-1, testForEquality);
0: 	if (index>=0) removeFromTo(index,index);
0: }
0: /**
0:  * Returns the elements currently stored, including invalid elements between size and capacity, if any.
0:  *
0:  * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
0:  * So if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing.
0:  *
0:  * @return the elements currently stored.
0:  */
0: public Object[] elements() {
0: 	return elements;
0: }
0: /**
0:  * Sets the receiver's elements to be the specified array (not a copy of it).
0:  *
0:  * The size and capacity of the list is the length of the array.
0:  * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
0:  * So if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.
0:  *
0:  * @param elements the new elements to be stored.
0:  * @return the receiver itself.
0:  */
0: public ObjectArrayList elements(Object[] elements) {
0: 	this.elements=elements;
0: 	this.size=elements.length;
0: 	return this;
0: }
0: /**
0:  * Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
0:  * If necessary, allocates new internal memory and increases the capacity of the receiver.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public void ensureCapacity(int minCapacity) {
0: 	elements = org.apache.mahout.colt.Arrays.ensureCapacity(elements,minCapacity);
0: }
0: /**
0: * Compares the specified Object with the receiver for equality.
0: * Returns true if and only if the specified Object is also an ObjectArrayList, both lists have the
0: * same size, and all corresponding pairs of elements in the two lists are equal.
0: * In other words, two lists are defined to be equal if they contain the
0: * same elements in the same order.
0: * Two elements <tt>e1</tt> and
0: * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :
0: * e1.equals(e2))</tt>.)  
0: *
0: * @param otherObj the Object to be compared for equality with the receiver.
0: * @return true if the specified Object is equal to the receiver.
0: */
0: public boolean equals(Object otherObj) { //delta
0: 	return equals(otherObj, true);
0: }
0: /**
0: * Compares the specified Object with the receiver for equality.
0: * Returns true if and only if the specified Object is also an ObjectArrayList, both lists have the
0: * same size, and all corresponding pairs of elements in the two lists are the same.
0: * In other words, two lists are defined to be equal if they contain the
0: * same elements in the same order.
0: * Tests elements for equality or identity as specified by <tt>testForEquality</tt>.
0: * When testing for equality, two elements <tt>e1</tt> and
0: * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :
0: * e1.equals(e2))</tt>.)  
0: *
0: * @param otherObj the Object to be compared for equality with the receiver.
0: * @param testForEquality if true -> tests for equality, otherwise for identity.
0: * @return true if the specified Object is equal to the receiver.
0: */
0: public boolean equals(Object otherObj, boolean testForEquality) { //delta
0: 	if (! (otherObj instanceof ObjectArrayList)) {return false;}
0: 	if (this==otherObj) return true;
0: 	if (otherObj==null) return false;
0: 	ObjectArrayList other = (ObjectArrayList) otherObj;
0: 	if (elements==other.elements()) return true;
0: 	if (size!=other.size()) return false;
0: 
0: 	Object[] otherElements = other.elements();
0: 	Object[] theElements = elements;
0: 	if (! testForEquality) {
0: 		for (int i=size; --i >= 0; ) {
0: 			if (theElements[i] != otherElements[i]) return false;
0: 		}
0: 	}
0: 	else {
0: 		for (int i=size; --i >= 0; ) {
0: 			if (!(theElements[i]==null ? otherElements[i]==null : theElements[i].equals(otherElements[i]))) return false;
0: 		}
0: 	}
0: 
0: 	return true;
0: 
0: }
0: /**
0:  * Sets the specified range of elements in the specified array to the specified value.
0:  *
0:  * @param from the index of the first element (inclusive) to be filled with the specified value.
0:  * @param to the index of the last element (inclusive) to be filled with the specified value.
0:  * @param val the value to be stored in the specified elements of the receiver.
0:  */
0: public void fillFromToWith(int from, int to, Object val) {
0: 	checkRangeFromTo(from,to,this.size);
0: 	for (int i=from; i<=to;) setQuick(i++,val); 
0: }
0: /**
0:  * Applies a procedure to each element of the receiver, if any.
0:  * Starts at index 0, moving rightwards.
0:  * @param procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues. 
0:  * @return <tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise. 
0:  */
0: public boolean forEach(ObjectProcedure procedure) {
0: 	Object[] theElements = elements;
0: 	int theSize = size;
0: 	
0: 	for (int i=0; i<theSize;) if (! procedure.apply(theElements[i++])) return false;
0: 	return true;
0: }
0: /**
0:  * Returns the element at the specified position in the receiver.
0:  *
0:  * @param index index of element to return.
0:  * @exception IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).
0:  */
0: public Object get(int index) {
0: 	if (index >= size || index < 0)
0: 		throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);
0: 	return elements[index];
0: }
0: /**
0:  * Returns the element at the specified position in the receiver; <b>WARNING:</b> Does not check preconditions. 
0:  * Provided with invalid parameters this method may return invalid elements without throwing any exception!
0:  * <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
0:  * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.
0:  *
0:  * @param index index of element to return.
0:  */
0: public Object getQuick(int index) {
0: 	return elements[index];
0: }
0: /**
0:  * Returns the index of the first occurrence of the specified
0:  * element. Returns <code>-1</code> if the receiver does not contain this element.
0:  *
0:  * Tests for equality or identity as specified by testForEquality.
0:  *
0:  * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
0:  * @return  the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.
0:  */
0: public int indexOf(Object element, boolean testForEquality) {
0: 	return this.indexOfFromTo(element, 0, size-1, testForEquality);
0: }
0: /**
0:  * Returns the index of the first occurrence of the specified
0:  * element. Returns <code>-1</code> if the receiver does not contain this element.
0:  * Searches between <code>from</code>, inclusive and <code>to</code>, inclusive.
0:  *
0:  * Tests for equality or identity as specified by <code>testForEquality</code>.
0:  *
0:  * @param element element to search for.
0:  * @param from the leftmost search position, inclusive.
0:  * @param to the rightmost search position, inclusive.
0:  * @param testForEquality if </code>true</code> -> test for equality, otherwise for identity.
0:  * @return  the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0:  */
0: public int indexOfFromTo(Object element, int from, int to, boolean testForEquality) {
0: 	if (size==0) return -1;
0: 	checkRangeFromTo(from, to, size);
0: 
0: 	Object[] theElements = elements;
0: 	if (testForEquality && element!=null) {
0: 		for (int i = from ; i <= to; i++) {
0: 		    if (element.equals(theElements[i])) {return i;} //found
0: 		}
0: 
0: 	}
0: 	else {
0: 		for (int i = from ; i <= to; i++) {
0: 		    if (element==theElements[i]) {return i;} //found
0: 		}
0: 	}
0: 	return -1; //not found
0: }
0: /**
0:  * Determines whether the receiver is sorted ascending, according to the <i>natural ordering</i> of its
0:  * elements.  All elements in this range must implement the
0:  * <tt>Comparable</tt> interface.  Furthermore, all elements in this range
0:  * must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
0:  * must not throw a <tt>ClassCastException</tt> for any elements
0:  * <tt>e1</tt> and <tt>e2</tt> in the array).<p>
0:  *
0:  * @param from the index of the first element (inclusive) to be sorted.
0:  * @param to the index of the last element (inclusive) to be sorted.
0:  * @return <tt>true</tt> if the receiver is sorted ascending, <tt>false</tt> otherwise.
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0:  */
0: public boolean isSortedFromTo(int from, int to) {
0: 	if (size==0) return true;
0: 	checkRangeFromTo(from, to, size);
0: 	
0: 	Object[] theElements = elements;
0: 	for (int i=from+1; i<=to; i++ ) {
0: 		if (((Comparable)theElements[i]).compareTo((Comparable) theElements[i-1]) < 0) return false;
0: 	}
0: 	return true;
0: }
0: /**
0:  * Returns the index of the last occurrence of the specified
0:  * element. Returns <code>-1</code> if the receiver does not contain this element.
0:  * Tests for equality or identity as specified by <code>testForEquality</code>.
0:  *
0:  * @param   element   the element to be searched for.
0:  * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
0:  * @return  the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.
0:  */
0: public int lastIndexOf(Object element, boolean testForEquality) {
0: 	return lastIndexOfFromTo(element, 0, size-1, testForEquality);
0: }
0: /**
0:  * Returns the index of the last occurrence of the specified
0:  * element. Returns <code>-1</code> if the receiver does not contain this element.
0:  * Searches beginning at <code>to</code>, inclusive until <code>from</code>, inclusive.
0:  * Tests for equality or identity as specified by <code>testForEquality</code>.
0:  *
0:  * @param element element to search for.
0:  * @param from the leftmost search position, inclusive.
0:  * @param to the rightmost search position, inclusive.
0:  * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
0:  * @return  the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0:  */
0: public int lastIndexOfFromTo(Object element, int from, int to, boolean testForEquality) {
0: 	if (size==0) return -1;
0: 	checkRangeFromTo(from, to, size);
0: 
0: 	Object[] theElements = elements;
0: 	if (testForEquality && element!=null) {
0: 		for (int i = to ; i >= from; i--) {
0: 		    if (element.equals(theElements[i])) {return i;} //found
0: 		}
0: 
0: 	}
0: 	else {
0: 		for (int i = to ; i >= from; i--) {
0: 		    if (element==theElements[i]) {return i;} //found
0: 		}
0: 	}
0: 	return -1; //not found
0: }
0: /**
0:  * Sorts the specified range of the receiver into
0:  * ascending order, according to the <i>natural ordering</i> of its
0:  * elements.  All elements in this range must implement the
0:  * <tt>Comparable</tt> interface.  Furthermore, all elements in this range
0:  * must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
0:  * must not throw a <tt>ClassCastException</tt> for any elements
0:  * <tt>e1</tt> and <tt>e2</tt> in the array).<p>
0:  *
0:  * This sort is guaranteed to be <i>stable</i>:  equal elements will
0:  * not be reordered as a result of the sort.<p>
0:  *
0:  * The sorting algorithm is a modified mergesort (in which the merge is
0:  * omitted if the highest element in the low sublist is less than the
0:  * lowest element in the high sublist).  This algorithm offers guaranteed
0:  * n*log(n) performance, and can approach linear performance on nearly
0:  * sorted lists.
0:  *
0:  * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
0:  * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.
0:  *
0:  * @param from the index of the first element (inclusive) to be sorted.
0:  * @param to the index of the last element (inclusive) to be sorted.
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0:  */
0: public void mergeSortFromTo(int from, int to) {
0: 	if (size==0) return;
0: 	checkRangeFromTo(from, to, size);
0: 	java.util.Arrays.sort(elements, from, to+1);
0: }
0: /**
0:  * Sorts the receiver according
0:  * to the order induced by the specified comparator.  All elements in the
0:  * range must be <i>mutually comparable</i> by the specified comparator
0:  * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
0:  * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
0:  * <tt>e2</tt> in the range).<p>
0:  *
0:  * This sort is guaranteed to be <i>stable</i>:  equal elements will
0:  * not be reordered as a result of the sort.<p>
0:  *
0:  * The sorting algorithm is a modified mergesort (in which the merge is
0:  * omitted if the highest element in the low sublist is less than the
0:  * lowest element in the high sublist).  This algorithm offers guaranteed
0:  * n*log(n) performance, and can approach linear performance on nearly
0:  * sorted lists.
0:  *
0:  * @param from the index of the first element (inclusive) to be
0:  *        sorted.
0:  * @param to the index of the last element (inclusive) to be sorted.
0:  * @param c the comparator to determine the order of the receiver.
0:  * @throws ClassCastException if the array contains elements that are not
0:  *	       <i>mutually comparable</i> using the specified comparator.
0:  * @throws IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>
0:  * @throws ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
0:  *	       <tt>toIndex &gt; a.length</tt>
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0:  * @see Comparator
0:  */
0: public void mergeSortFromTo(int from, int to, java.util.Comparator c) {
0: 	if (size==0) return;
0: 	checkRangeFromTo(from, to, size);
0: 	java.util.Arrays.sort(elements, from, to+1, c);
0: }
0: /**
0:  * Returns a new list of the part of the receiver between <code>from</code>, inclusive, and <code>to</code>, inclusive.
0:  * @param from the index of the first element (inclusive).
0:  * @param to the index of the last element (inclusive).
0:  * @return a new list
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0: */
0: public ObjectArrayList partFromTo(int from, int to) {
0: 	if (size==0) return new ObjectArrayList(0);
0: 
0: 	checkRangeFromTo(from, to, size);
0: 
0: 	Object[] part = new Object[to-from+1];
0: 	System.arraycopy(elements, from, part, 0, to-from+1);
0: 	return new ObjectArrayList(part);
0: }
0: /**
0:  * Sorts the specified range of the receiver into
0:  * ascending order, according to the <i>natural ordering</i> of its
0:  * elements.  All elements in this range must implement the
0:  * <tt>Comparable</tt> interface.  Furthermore, all elements in this range
0:  * must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
0:  * must not throw a <tt>ClassCastException</tt> for any elements
0:  * <tt>e1</tt> and <tt>e2</tt> in the array).<p>
0:  
0:  * The sorting algorithm is a tuned quicksort,
0:  * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
0:  * Sort Function", Software-Practice and Experience, Vol. 23(11)
0:  * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
0:  * performance on many data sets that cause other quicksorts to degrade to
0:  * quadratic performance.
0:  *
0:  * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
0:  * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.
0:  *
0:  * @param from the index of the first element (inclusive) to be sorted.
0:  * @param to the index of the last element (inclusive) to be sorted.
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0:  */
0: public void quickSortFromTo(int from, int to) {
0: 	if (size==0) return;
0: 	checkRangeFromTo(from, to, size);
0: 	org.apache.mahout.colt.Sorting.quickSort(elements, from, to+1);
0: }
0: /**
0:  * Sorts the receiver according
0:  * to the order induced by the specified comparator.  All elements in the
0:  * range must be <i>mutually comparable</i> by the specified comparator
0:  * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
0:  * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
0:  * <tt>e2</tt> in the range).<p>
0:  
0:  * The sorting algorithm is a tuned quicksort,
0:  * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
0:  * Sort Function", Software-Practice and Experience, Vol. 23(11)
0:  * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
0:  * performance on many data sets that cause other quicksorts to degrade to
0:  * quadratic performance.
0:  *
0:  * @param from the index of the first element (inclusive) to be sorted.
0:  * @param to the index of the last element (inclusive) to be sorted.
0:  * @param c the comparator to determine the order of the receiver.
0:  * @throws ClassCastException if the array contains elements that are not
0:  *	       <i>mutually comparable</i> using the specified comparator.
0:  * @throws IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>
0:  * @throws ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
0:  *	       <tt>toIndex &gt; a.length</tt>
0:  * @see Comparator
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0:  */
0: public void quickSortFromTo(int from, int to, java.util.Comparator c) {
0: 	if (size==0) return;
0: 	checkRangeFromTo(from, to, size);
0: 	org.apache.mahout.colt.Sorting.quickSort(elements, from, to+1, c);
0: }
0: /**
0: * Removes from the receiver all elements that are contained in the specified list.
0: * Tests for equality or identity as specified by <code>testForEquality</code>.
0: *
0: * @param other the other list.
0: * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
0: * @return <code>true</code> if the receiver changed as a result of the call.
0: */
0: public boolean removeAll(ObjectArrayList other, boolean testForEquality) {
0: 	if (other.size==0) return false; //nothing to do
0: 	int limit = other.size-1;
0: 	int j=0;
0: 	Object[] theElements = elements;
0: 	for (int i=0; i<size ; i++) {
0: 		if (other.indexOfFromTo(theElements[i], 0, limit, testForEquality) < 0) theElements[j++]=theElements[i];
0: 	}
0: 
0: 	boolean modified = (j!=size);
0: 	setSize(j);
0: 	return modified;
0: }
0: /**
0:  * Removes from the receiver all elements whose index is between
0:  * <code>from</code>, inclusive and <code>to</code>, inclusive.  Shifts any succeeding
0:  * elements to the left (reduces their index).
0:  * This call shortens the list by <tt>(to - from + 1)</tt> elements.
0:  *
0:  * @param from index of first element to be removed.
0:  * @param to index of last element to be removed.
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0:  */
0: public void removeFromTo(int from, int to) {
0: 	checkRangeFromTo(from, to, size);
0: 	int numMoved = size - to - 1;
0: 	if (numMoved >= 0) {
0: 		System.arraycopy(elements, to+1, elements, from, numMoved);
0: 		fillFromToWith(from+numMoved, size-1, null); //delta
0: 	}
0: 	int width = to-from+1;
0: 	if (width>0) size -= width;
0: }
0: /**
0:  * Replaces a number of elements in the receiver with the same number of elements of another list.
0:  * Replaces elements in the receiver, between <code>from</code> (inclusive) and <code>to</code> (inclusive),
0:  * with elements of <code>other</code>, starting from <code>otherFrom</code> (inclusive).
0:  *
0:  * @param from the position of the first element to be replaced in the receiver
0:  * @param to the position of the last element to be replaced in the receiver
0:  * @param other list holding elements to be copied into the receiver.
0:  * @param otherFrom position of first element within other list to be copied.
0:  */
0: public void replaceFromToWithFrom(int from, int to, ObjectArrayList other, int otherFrom) {
0: 	int length=to-from+1;
0: 	if (length>0) {
0: 		checkRangeFromTo(from, to, size);
0: 		checkRangeFromTo(otherFrom,otherFrom+length-1,other.size);
0: 		System.arraycopy(other.elements, otherFrom, elements, from, length);
0: 	}
0: }
0: /**
0: * Replaces the part between <code>from</code> (inclusive) and <code>to</code> (inclusive) with the other list's
0: * part between <code>otherFrom</code> and <code>otherTo</code>. 
0: * Powerful (and tricky) method!
0: * Both parts need not be of the same size (part A can both be smaller or larger than part B).
0: * Parts may overlap.
0: * Receiver and other list may (but most not) be identical.
0: * If <code>from &gt; to</code>, then inserts other part before <code>from</code>.
0: *
0: * @param from the first element of the receiver (inclusive)
0: * @param to the last element of the receiver (inclusive)
0: * @param other the other list (may be identical with receiver)
0: * @param otherFrom the first element of the other list (inclusive)
0: * @param otherTo the last element of the other list (inclusive)
0: *
0: * <p><b>Examples:</b><pre>
0: * a=[0, 1, 2, 3, 4, 5, 6, 7]
0: * b=[50, 60, 70, 80, 90]
0: * a.R(...)=a.replaceFromToWithFromTo(...)
0: *
0: * a.R(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
0: * a.R(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7]
0: * a.R(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7]
0: * a.R(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7]
0: * a.R(1,6,b,1,2)-->[0, 60, 70, 7]
0: * a.R(0,6,b,1,2)-->[60, 70, 7]
0: * a.R(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
0: * a.R(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
0: * a.R(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
0: * a.R(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
0: *
0: * Extreme cases:
0: * a.R(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7]
0: * a.R(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7]
0: * a.R(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7]
0: * a.R(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7]
0: * a.R(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7]
0: * a.R(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
0: * a.R(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
0: * a.R(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
0: * a.R(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
0: * </pre>
0: */
0: public void replaceFromToWithFromTo(int from, int to, ObjectArrayList other, int otherFrom, int otherTo) {
0: 	if (otherFrom>otherTo) {
0: 		throw new IndexOutOfBoundsException("otherFrom: "+otherFrom+", otherTo: "+otherTo);
0: 	}
0: 	if (this==other && to-from!=otherTo-otherFrom) { // avoid stumbling over my own feet
0: 		replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo-otherFrom);
0: 		return;
0: 	}
0: 	
0: 	int length=otherTo-otherFrom+1;
0: 	int diff=length;
0: 	int theLast=from-1;
0: 
0: 	//System.out.println("from="+from);
0: 	//System.out.println("to="+to);
0: 	//System.out.println("diff="+diff);
0: 	
0: 	if (to>=from) {
0: 		diff -= (to-from+1);
0: 		theLast=to;
0: 	}
0: 	
0: 	if (diff>0) {
0: 		beforeInsertDummies(theLast+1, diff);
0: 	}
0: 	else {
0: 		if (diff<0) {
0: 			removeFromTo(theLast+diff, theLast-1);
0: 		}
0: 	}
0: 
0: 	if (length>0) {
0: 		System.arraycopy(other.elements, otherFrom, elements, from, length);
0: 	}
0: }
0: /**
0:  * Replaces the part of the receiver starting at <code>from</code> (inclusive) with all the elements of the specified collection.
0:  * Does not alter the size of the receiver.
0:  * Replaces exactly <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.
0:  *
0:  * @param from the index at which to copy the first element from the specified collection.
0:  * @param other Collection to replace part of the receiver
0:  * @exception IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).
0:  */
0: public void replaceFromWith(int from, java.util.Collection other) {
0: 	checkRange(from,size);
0: 	java.util.Iterator e = other.iterator();
0: 	int index=from;
0: 	int limit = Math.min(size-from, other.size());
0: 	for (int i=0; i<limit; i++)
0: 	    elements[index++] = e.next(); //delta
0: }
0: /**
0: * Retains (keeps) only the elements in the receiver that are contained in the specified other list.
0: * In other words, removes from the receiver all of its elements that are not contained in the
0: * specified other list. 
0: * Tests for equality or identity as specified by <code>testForEquality</code>.
0: * @param other the other list to test against.
0: * @param testForEquality if <code>true</code> -> test for equality, otherwise for identity.
0: * @return <code>true</code> if the receiver changed as a result of the call.
0: */
0: public boolean retainAll(ObjectArrayList other, boolean testForEquality) {
0: 	if (other.size==0) {
0: 		if (size==0) return false;
0: 		setSize(0);
0: 		return true;
0: 	}
0: 	
0: 	int limit = other.size-1;
0: 	int j=0;
0: 	Object[] theElements = elements;
0: 
0: 	for (int i=0; i<size ; i++) {
0: 		if (other.indexOfFromTo(theElements[i], 0, limit, testForEquality) >= 0) theElements[j++]=theElements[i];
0: 	}
0: 
0: 	boolean modified = (j!=size);
0: 	setSize(j);
0: 	return modified;
0: }
0: /**
0:  * Reverses the elements of the receiver.
0:  * Last becomes first, second last becomes second first, and so on.
0:  */
0: public void reverse() {
0: 	Object tmp;
0: 	int limit=size/2;
0: 	int j=size-1;
0: 	
0: 	Object[] theElements = elements;
0: 	for (int i=0; i<limit;) { //swap
0: 		tmp=theElements[i];
0: 		theElements[i++]=theElements[j];
0: 		theElements[j--]=tmp;
0: 	}
0: }
0: /**
0:  * Replaces the element at the specified position in the receiver with the specified element.
0:  *
0:  * @param index index of element to replace.
0:  * @param element element to be stored at the specified position.
0:  * @exception IndexOutOfBoundsException index is out of range (index
0:  * 		  &lt; 0 || index &gt;= size()).
0: */
0: public void set(int index, Object element) {
0: 	if (index >= size || index < 0)
0: 		throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);
0: 	elements[index] = element;
0: }
0: /**
0:  * Replaces the element at the specified position in the receiver with the specified element; <b>WARNING:</b> Does not check preconditions.
0:  * Provided with invalid parameters this method may access invalid indexes without throwing any exception!
0:  * <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
0:  * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.
0:  *
0:  * @param index index of element to replace.
0:  * @param element element to be stored at the specified position.
0:  */
0: public void setQuick(int index, Object element) {
0: 	elements[index] = element;
0: }
0: /**
0:  * Randomly permutes the part of the receiver between <code>from</code> (inclusive) and <code>to</code> (inclusive). 
0:  * @param from the index of the first element (inclusive) to be permuted.
0:  * @param to the index of the last element (inclusive) to be permuted.
0:  * @exception IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).
0:  */
0: public void shuffleFromTo(int from, int to) {
0: 	if (size == 0) return;
0: 	checkRangeFromTo(from, to, size);
0: 	
0: 	org.apache.mahout.jet.random.Uniform gen = new org.apache.mahout.jet.random.Uniform(new org.apache.mahout.jet.random.engine.DRand(new java.util.Date()));
0: 	Object tmpElement;
0: 	Object[] theElements = elements;
0: 	int random;
0: 	for (int i = from; i < to; i++) {
0: 		random = gen.nextIntFromTo(i, to);
0: 
0: 		//swap(i, random)
0: 		tmpElement = theElements[random];
0: 		theElements[random] = theElements[i];
0: 		theElements[i] = tmpElement;
0: 	}
0: }
0: /**
0:  * Returns the number of elements contained in the receiver.
0:  *
0:  * @returns  the number of elements contained in the receiver.
0:  */
0: public int size() {
0: 	return size;
0: }
0: /**
0:  * Returns a list which is a concatenation of <code>times</code> times the receiver.
0:  * @param times the number of times the receiver shall be copied.
0:  */
0: public ObjectArrayList times(int times) {
0: 	ObjectArrayList newList = new ObjectArrayList(times*size);
0: 	for (int i=times; --i >= 0; ) {
0: 		newList.addAllOfFromTo(this,0,size()-1);
0: 	}
0: 	return newList;
0: }
0: /**
0:  * Returns an array containing all of the elements in the receiver in the
0:  * correct order.  The runtime type of the returned array is that of the
0:  * specified array.  If the receiver fits in the specified array, it is
0:  * returned therein.  Otherwise, a new array is allocated with the runtime
0:  * type of the specified array and the size of the receiver.
0:  * <p>
0:  * If the receiver fits in the specified array with room to spare
0:  * (i.e., the array has more elements than the receiver),
0:  * the element in the array immediately following the end of the
0:  * receiver is set to null.  This is useful in determining the length
0:  * of the receiver <em>only</em> if the caller knows that the receiver
0:  * does not contain any null elements.
0:  *
0:  * @param array the array into which the elements of the receiver are to
0:  *		be stored, if it is big enough; otherwise, a new array of the
0:  * 		same runtime type is allocated for this purpose.
0:  * @return an array containing the elements of the receiver.
0:  * @exception ArrayStoreException the runtime type of <tt>array</tt> is not a supertype
0:  * of the runtime type of every element in the receiver.
0:  */
0: public Object[] toArray(Object array[]) {
0: 	if (array.length < size)
0: 		array = (Object[])java.lang.reflect.Array.newInstance(array.getClass().getComponentType(), size);
0: 
0: 	Object[] theElements = elements;
0: 	for (int i=size; --i >=0; ) array[i]=theElements[i];
0: 
0: 	if (array.length > size) array[size] = null;
0: 
0: 	return array;
0: }
0: /**
0:  * Returns a <code>java.util.ArrayList</code> containing all the elements in the receiver.
0:  */
0: public java.util.ArrayList toList() {
0: 	int mySize = size();
0: 	Object[] theElements = elements;
0: 	java.util.ArrayList list = new java.util.ArrayList(mySize);
0: 	for (int i=0; i < mySize; i++) list.add(theElements[i]);
0: 	return list;
0: }
0: /**
0: * Returns a string representation of the receiver, containing
0: * the String representation of each element.
0: */
0: public String toString() {
0: 	return org.apache.mahout.colt.Arrays.toString(partFromTo(0, size()-1).elements());
0: }
0: /**
0:  * Trims the capacity of the receiver to be the receiver's current 
0:  * size. Releases any superfluos internal memory. An application can use this operation to minimize the 
0:  * storage of the receiver.
0:  */
0: public void trimToSize() {
0: 	elements = org.apache.mahout.colt.Arrays.trimToCapacity(elements,size());
0: }
0: }
============================================================================