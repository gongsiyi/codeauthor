1:7a01e24: /*
1:7a01e24:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7a01e24:  * contributor license agreements.  See the NOTICE file distributed with
1:7a01e24:  * this work for additional information regarding copyright ownership.
1:7a01e24:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7a01e24:  * (the "License"); you may not use this file except in compliance with
1:7a01e24:  * the License.  You may obtain a copy of the License at
1:7a01e24:  *
1:7a01e24:  *     http://www.apache.org/licenses/LICENSE-2.0
1:7a01e24:  *
1:7a01e24:  * Unless required by applicable law or agreed to in writing, software
1:7a01e24:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7a01e24:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7a01e24:  * See the License for the specific language governing permissions and
1:7a01e24:  * limitations under the License.
1:7a01e24:  */
4:7a01e24: 
1:7a01e24: package org.apache.mahout.cf.taste.impl.model.hbase;
1:7a01e24: 
1:7a01e24: import org.apache.hadoop.conf.Configuration;
1:7a01e24: import org.apache.hadoop.hbase.HBaseConfiguration;
1:7a01e24: import org.apache.hadoop.hbase.HColumnDescriptor;
1:7a01e24: import org.apache.hadoop.hbase.HTableDescriptor;
1:7a01e24: import org.apache.hadoop.hbase.KeyValue;
1:7a01e24: import org.apache.hadoop.hbase.client.Delete;
1:7a01e24: import org.apache.hadoop.hbase.client.Get;
1:7a01e24: import org.apache.hadoop.hbase.client.HBaseAdmin;
1:7a01e24: import org.apache.hadoop.hbase.client.HTableFactory;
1:7a01e24: import org.apache.hadoop.hbase.client.HTableInterface;
1:7a01e24: import org.apache.hadoop.hbase.client.HTablePool;
1:7a01e24: import org.apache.hadoop.hbase.client.Put;
1:7a01e24: import org.apache.hadoop.hbase.client.Result;
1:7a01e24: import org.apache.hadoop.hbase.client.ResultScanner;
1:7a01e24: import org.apache.hadoop.hbase.client.Scan;
1:7a01e24: import org.apache.hadoop.hbase.filter.FilterList;
1:7a01e24: import org.apache.hadoop.hbase.filter.FirstKeyOnlyFilter;
1:85f9ece: import org.apache.hadoop.hbase.filter.KeyOnlyFilter;
1:7a01e24: import org.apache.hadoop.hbase.util.Bytes;
1:7a01e24: import org.apache.mahout.cf.taste.common.NoSuchItemException;
1:7a01e24: import org.apache.mahout.cf.taste.common.NoSuchUserException;
1:7a01e24: import org.apache.mahout.cf.taste.common.Refreshable;
1:7a01e24: import org.apache.mahout.cf.taste.common.TasteException;
1:7a01e24: import org.apache.mahout.cf.taste.impl.common.FastIDSet;
1:7a01e24: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1:7a01e24: import org.apache.mahout.cf.taste.impl.model.GenericItemPreferenceArray;
1:7a01e24: import org.apache.mahout.cf.taste.impl.model.GenericUserPreferenceArray;
1:7a01e24: import org.apache.mahout.cf.taste.model.DataModel;
1:7a01e24: import org.apache.mahout.cf.taste.model.PreferenceArray;
1:85f9ece: import org.slf4j.Logger;
1:85f9ece: import org.slf4j.LoggerFactory;
1:85f9ece: 
1:85f9ece: import java.io.Closeable;
1:85f9ece: import java.io.IOException;
1:85f9ece: import java.nio.ByteBuffer;
1:85f9ece: import java.util.ArrayList;
1:85f9ece: import java.util.Collection;
1:85f9ece: import java.util.LinkedList;
1:85f9ece: import java.util.List;
1:85f9ece: import java.util.Map;
1:85f9ece: import java.util.SortedMap;
1:7a01e24: 
1:7a01e24: /**
1:7a01e24:  * <p>Naive approach of storing one preference as one value in the table.
1:7a01e24:  * Preferences are indexed as (user, item) and (item, user) for O(1) lookups.</p>
1:7a01e24:  *
1:7a01e24:  * <p>The default table name is "taste", this can be set through a constructor
1:7a01e24:  * argument. Each row has a value starting with "i" or "u" followed by the
1:7a01e24:  * actual id encoded as a big endian long.</p>
1:7a01e24:  *
1:7a01e24:  * <p>E.g., "u\x00\x00\x00\x00\x00\x00\x04\xd2" is user 1234L</p>
1:7a01e24:  *
1:7a01e24:  * <p>There are two column families: "users" and "items".</p>
1:7a01e24:  *
1:7a01e24:  * <p>The "users" column family holds user->item preferences. Each userID is the
1:7a01e24:  * column qualifier and the value is the preference.</p>
1:7a01e24:  *
1:7a01e24:  * <p>The "items" column fmaily holds item->user preferences. Each itemID is the
1:7a01e24:  * column qualifier and the value is the preference.</p>
1:7a01e24:  *
1:7a01e24:  * <p>User IDs and item IDs are cached in a FastIDSet since it requires a full
1:7a01e24:  * table scan to build these sets. Preferences are not cached since they
1:7a01e24:  * are pretty cheap lookups in HBase (also caching the Preferences defeats
1:7a01e24:  * the purpose of a scalable storage engine like HBase).</p>
1:7a01e24:  */
1:7a01e24: public final class HBaseDataModel implements DataModel, Closeable {
1:7a01e24: 
1:7a01e24:   private static final Logger log = LoggerFactory.getLogger(HBaseDataModel.class);
1:7a01e24: 
1:7a01e24:   private static final String DEFAULT_TABLE = "taste";
1:7a01e24:   private static final byte[] USERS_CF = Bytes.toBytes("users");
1:7a01e24:   private static final byte[] ITEMS_CF = Bytes.toBytes("items");
1:7a01e24: 
1:7a01e24:   private final HTablePool pool;
1:7a01e24:   private final String tableName;
1:7a01e24: 
1:7a01e24:   // Cache of user and item ids
1:7a01e24:   private volatile FastIDSet itemIDs;
1:7a01e24:   private volatile FastIDSet userIDs;
1:7a01e24: 
1:7a01e24:   public HBaseDataModel(String zkConnect) throws IOException {
1:7a01e24:     this(zkConnect, DEFAULT_TABLE);
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   public HBaseDataModel(String zkConnect, String tableName) throws IOException {
1:7a01e24:     log.info("Using HBase table {}", tableName);
1:7a01e24:     Configuration conf = HBaseConfiguration.create();
1:7a01e24:     conf.set("hbase.zookeeper.quorum", zkConnect);
1:7a01e24:     HTableFactory tableFactory = new HTableFactory();
1:7a01e24:     this.pool = new HTablePool(conf, 8, tableFactory);
1:7a01e24:     this.tableName = tableName;
1:bdb1c48: 
1:bdb1c48:     bootstrap(conf);
1:7a01e24:     // Warm the cache
1:7a01e24:     refresh(null);
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   public HBaseDataModel(HTablePool pool, String tableName, Configuration conf) throws IOException {
1:7a01e24:     log.info("Using HBase table {}", tableName);
1:7a01e24:     this.pool = pool;
1:7a01e24:     this.tableName = tableName;
1:bdb1c48: 
1:bdb1c48:     bootstrap(conf);
1:7a01e24: 
1:7a01e24:     // Warm the cache
1:7a01e24:     refresh(null);
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   public String getTableName() {
1:7a01e24:     return tableName;
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   /**
1:7a01e24:    * Create the table if it doesn't exist
1:7a01e24:    */
1:bdb1c48:   private void bootstrap(Configuration conf) throws IOException {
1:7a01e24:     HTableDescriptor tDesc = new HTableDescriptor(Bytes.toBytes(tableName));
1:7a01e24:     tDesc.addFamily(new HColumnDescriptor(USERS_CF));
1:7a01e24:     tDesc.addFamily(new HColumnDescriptor(ITEMS_CF));
1:85f9ece:     try (HBaseAdmin admin = new HBaseAdmin(conf)) {
1:7a01e24:       admin.createTable(tDesc);
1:7a01e24:       log.info("Created table {}", tableName);
1:7a01e24:     }
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   /**
1:7a01e24:    * Prefix a user id with "u" and convert to byte[]
1:7a01e24:    */
1:7a01e24:   private static byte[] userToBytes(long userID) {
1:7a01e24:     ByteBuffer bb = ByteBuffer.allocate(9);
1:7a01e24:     bb.put((byte)0x75); // The letter "u"
1:7a01e24:     bb.putLong(userID);
1:7a01e24:     return bb.array();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   /**
1:7a01e24:    * Prefix an item id with "i" and convert to byte[]
1:7a01e24:    */
1:7a01e24:   private static byte[] itemToBytes(long itemID) {
1:7a01e24:     ByteBuffer bb = ByteBuffer.allocate(9);
1:7a01e24:     bb.put((byte)0x69); // The letter "i"
1:7a01e24:     bb.putLong(itemID);
1:7a01e24:     return bb.array();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   /**
1:7a01e24:    * Extract the id out of a prefix byte[] id
1:7a01e24:    */
1:7a01e24:   private static long bytesToUserOrItemID(byte[] ba) {
1:7a01e24:     ByteBuffer bb = ByteBuffer.wrap(ba);
1:7a01e24:     return bb.getLong(1);
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   /* DataModel interface */
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public LongPrimitiveIterator getUserIDs() {
1:7a01e24:     return userIDs.iterator();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public PreferenceArray getPreferencesFromUser(long userID) throws TasteException {
1:7a01e24:     Result result;
2:7a01e24:     try {
1:7a01e24:       HTableInterface table = pool.getTable(tableName);
1:7a01e24:       Get get = new Get(userToBytes(userID));
1:7a01e24:       get.addFamily(ITEMS_CF);
1:7a01e24:       result = table.get(get);
1:7a01e24:       table.close();
1:7a01e24:     } catch (IOException e) {
1:7a01e24:       throw new TasteException("Failed to retrieve user preferences from HBase", e);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     if (result.isEmpty()) {
1:7a01e24:       throw new NoSuchUserException(userID);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     SortedMap<byte[], byte[]> families = result.getFamilyMap(ITEMS_CF);
1:7a01e24:     PreferenceArray prefs = new GenericUserPreferenceArray(families.size());
1:7a01e24:     prefs.setUserID(0, userID);
1:7a01e24:     int i = 0;
1:7a01e24:     for (Map.Entry<byte[], byte[]> entry : families.entrySet()) {
1:7a01e24:       prefs.setItemID(i, Bytes.toLong(entry.getKey()));
1:7a01e24:       prefs.setValue(i, Bytes.toFloat(entry.getValue()));
1:7a01e24:       i++;
1:7a01e24:     }
1:7a01e24:     return prefs;
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public FastIDSet getItemIDsFromUser(long userID) throws TasteException {
1:7a01e24:     Result result;
1:7a01e24:     try {
1:7a01e24:       HTableInterface table = pool.getTable(tableName);
1:7a01e24:       Get get = new Get(userToBytes(userID));
1:7a01e24:       get.addFamily(ITEMS_CF);
1:7a01e24:       result = table.get(get);
1:7a01e24:       table.close();
1:7a01e24:     } catch (IOException e) {
1:7a01e24:       throw new TasteException("Failed to retrieve item IDs from HBase", e);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     if (result.isEmpty()) {
1:7a01e24:       throw new NoSuchUserException(userID);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     SortedMap<byte[],byte[]> families = result.getFamilyMap(ITEMS_CF);
1:7a01e24:     FastIDSet ids = new FastIDSet(families.size());
1:3c22856:     for (byte[] family : families.keySet()) {
1:7a01e24:       ids.add(Bytes.toLong(family));
1:7a01e24:     }
1:7a01e24:     return ids;
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public LongPrimitiveIterator getItemIDs() {
1:7a01e24:     return itemIDs.iterator();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public PreferenceArray getPreferencesForItem(long itemID) throws TasteException {
1:7a01e24:     Result result;
1:7a01e24:     try {
1:7a01e24:       HTableInterface table = pool.getTable(tableName);
1:7a01e24:       Get get = new Get(itemToBytes(itemID));
1:7a01e24:       get.addFamily(USERS_CF);
1:7a01e24:       result = table.get(get);
1:7a01e24:       table.close();
1:7a01e24:     } catch (IOException e) {
1:7a01e24:       throw new TasteException("Failed to retrieve item preferences from HBase", e);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     if (result.isEmpty()) {
1:7a01e24:       throw new NoSuchItemException(itemID);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     SortedMap<byte[], byte[]> families = result.getFamilyMap(USERS_CF);
1:7a01e24:     PreferenceArray prefs = new GenericItemPreferenceArray(families.size());
1:7a01e24:     prefs.setItemID(0, itemID);
1:7a01e24:     int i = 0;
1:7a01e24:     for (Map.Entry<byte[], byte[]> entry : families.entrySet()) {
1:7a01e24:       prefs.setUserID(i, Bytes.toLong(entry.getKey()));
1:7a01e24:       prefs.setValue(i, Bytes.toFloat(entry.getValue()));
1:7a01e24:       i++;
1:7a01e24:     }
1:7a01e24:     return prefs;
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public Float getPreferenceValue(long userID, long itemID) throws TasteException {
1:7a01e24:     Result result;
1:7a01e24:     try {
1:7a01e24:       HTableInterface table = pool.getTable(tableName);
1:7a01e24:       Get get = new Get(userToBytes(userID));
1:7a01e24:       get.addColumn(ITEMS_CF, Bytes.toBytes(itemID));
1:7a01e24:       result = table.get(get);
1:7a01e24:       table.close();
1:7a01e24:     } catch (IOException e) {
1:7a01e24:       throw new TasteException("Failed to retrieve user preferences from HBase", e);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     if (result.isEmpty()) {
1:7a01e24:       throw new NoSuchUserException(userID);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     if (result.containsColumn(ITEMS_CF, Bytes.toBytes(itemID))) {
1:7a01e24:       return Bytes.toFloat(result.getValue(ITEMS_CF, Bytes.toBytes(itemID)));
1:7a01e24:     } else {
1:7a01e24:       return null;
1:7a01e24:     }
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public Long getPreferenceTime(long userID, long itemID) throws TasteException {
1:7a01e24:     Result result;
1:7a01e24:     try {
1:7a01e24:       HTableInterface table = pool.getTable(tableName);
1:7a01e24:       Get get = new Get(userToBytes(userID));
1:7a01e24:       get.addColumn(ITEMS_CF, Bytes.toBytes(itemID));
1:7a01e24:       result = table.get(get);
1:7a01e24:       table.close();
1:7a01e24:     } catch (IOException e) {
1:7a01e24:       throw new TasteException("Failed to retrieve user preferences from HBase", e);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     if (result.isEmpty()) {
1:7a01e24:       throw new NoSuchUserException(userID);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     if (result.containsColumn(ITEMS_CF, Bytes.toBytes(itemID))) {
1:7a01e24:       KeyValue kv = result.getColumnLatest(ITEMS_CF, Bytes.toBytes(itemID));
1:7a01e24:       return kv.getTimestamp();
1:7a01e24:     } else {
1:7a01e24:       return null;
1:7a01e24:     }
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public int getNumItems() {
1:7a01e24:     return itemIDs.size();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public int getNumUsers() {
1:7a01e24:     return userIDs.size();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public int getNumUsersWithPreferenceFor(long itemID) throws TasteException {
1:7a01e24:     PreferenceArray prefs = getPreferencesForItem(itemID);
1:7a01e24:     return prefs.length();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException {
1:7a01e24:     Result[] results;
1:7a01e24:     try {
1:7a01e24:       HTableInterface table = pool.getTable(tableName);
1:85f9ece:       List<Get> gets = new ArrayList<>(2);
1:7a01e24:       gets.add(new Get(itemToBytes(itemID1)));
1:7a01e24:       gets.add(new Get(itemToBytes(itemID2)));
1:7a01e24:       gets.get(0).addFamily(USERS_CF);
1:7a01e24:       gets.get(1).addFamily(USERS_CF);
1:7a01e24:       results = table.get(gets);
1:7a01e24:       table.close();
1:7a01e24:     } catch (IOException e) {
1:7a01e24:       throw new TasteException("Failed to retrieve item preferences from HBase", e);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     if (results[0].isEmpty()) {
1:7a01e24:       throw new NoSuchItemException(itemID1);
1:7a01e24:     }
1:7a01e24:     if (results[1].isEmpty()) {
1:7a01e24:       throw new NoSuchItemException(itemID2);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     // First item
1:7a01e24:     Result result = results[0];
1:7a01e24:     SortedMap<byte[], byte[]> families = result.getFamilyMap(USERS_CF);
1:7a01e24:     FastIDSet idSet1 = new FastIDSet(families.size());
1:7a01e24:     for (byte[] id : families.keySet()) {
1:7a01e24:       idSet1.add(Bytes.toLong(id));
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     // Second item
1:7a01e24:     result = results[1];
1:7a01e24:     families = result.getFamilyMap(USERS_CF);
1:7a01e24:     FastIDSet idSet2 = new FastIDSet(families.size());
1:7a01e24:     for (byte[] id : families.keySet()) {
1:7a01e24:       idSet2.add(Bytes.toLong(id));
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     return idSet1.intersectionSize(idSet2);
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public void setPreference(long userID, long itemID, float value) throws TasteException {
1:7a01e24:     try {
1:7a01e24:       HTableInterface table = pool.getTable(tableName);
1:85f9ece:       List<Put> puts = new ArrayList<>(2);
1:7a01e24:       puts.add(new Put(userToBytes(userID)));
1:7a01e24:       puts.add(new Put(itemToBytes(itemID)));
1:7a01e24:       puts.get(0).add(ITEMS_CF, Bytes.toBytes(itemID), Bytes.toBytes(value));
1:7a01e24:       puts.get(1).add(USERS_CF, Bytes.toBytes(userID), Bytes.toBytes(value));
1:7a01e24:       table.put(puts);
1:7a01e24:       table.close();
1:7a01e24:     } catch (IOException e) {
1:7a01e24:       throw new TasteException("Failed to store preference in HBase", e);
1:7a01e24:     }
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public void removePreference(long userID, long itemID) throws TasteException {
1:7a01e24:     try {
1:7a01e24:       HTableInterface table = pool.getTable(tableName);
1:85f9ece:       List<Delete> deletes = new ArrayList<>(2);
1:7a01e24:       deletes.add(new Delete(userToBytes(userID)));
1:7a01e24:       deletes.add(new Delete(itemToBytes(itemID)));
1:7a01e24:       deletes.get(0).deleteColumns(ITEMS_CF, Bytes.toBytes(itemID));
1:7a01e24:       deletes.get(1).deleteColumns(USERS_CF, Bytes.toBytes(userID));
1:7a01e24:       table.delete(deletes);
1:7a01e24:       table.close();
1:7a01e24:     } catch (IOException e) {
1:7a01e24:       throw new TasteException("Failed to remove preference from HBase", e);
1:7a01e24:     }
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public boolean hasPreferenceValues() {
2:7a01e24:     return true;
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public float getMaxPreference() {
1:7a01e24:     throw new UnsupportedOperationException();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public float getMinPreference() {
1:7a01e24:     throw new UnsupportedOperationException();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   /* Closeable interface */
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public void close() throws IOException {
1:7a01e24:     pool.close();
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   /* Refreshable interface */
1:7a01e24: 
1:7a01e24:   @Override
1:7a01e24:   public void refresh(Collection<Refreshable> alreadyRefreshed) {
1:7a01e24:     if (alreadyRefreshed == null || !alreadyRefreshed.contains(this)) {
1:7a01e24:       try {
1:7a01e24:         log.info("Refreshing item and user ID caches");
1:7a01e24:         long t1 = System.currentTimeMillis();
1:7a01e24:         refreshItemIDs();
1:7a01e24:         refreshUserIDs();
1:7a01e24:         long t2 = System.currentTimeMillis();
1:7a01e24:         log.info("Finished refreshing caches in {} ms", t2 - t1);
1:7a01e24:       } catch (IOException e) {
1:7a01e24:         throw new IllegalStateException("Could not reload DataModel", e);
1:7a01e24:       }
1:7a01e24:     }
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   /*
1:7a01e24:    * Refresh the item id cache. Warning: this does a large table scan
1:7a01e24:    */
1:7a01e24:   private synchronized void refreshItemIDs() throws IOException {
1:7a01e24:     // Get the list of item ids
1:7a01e24:     HTableInterface table = pool.getTable(tableName);
1:7a01e24:     Scan scan = new Scan(new byte[]{0x69}, new byte[]{0x70});
1:7a01e24:     scan.setFilter(new FilterList(FilterList.Operator.MUST_PASS_ALL, new KeyOnlyFilter(), new FirstKeyOnlyFilter()));
1:7a01e24:     ResultScanner scanner = table.getScanner(scan);
1:85f9ece:     Collection<Long> ids = new LinkedList<>();
1:7a01e24:     for (Result result : scanner) {
1:7a01e24:       ids.add(bytesToUserOrItemID(result.getRow()));
1:7a01e24:     }
1:7a01e24:     table.close();
1:7a01e24: 
1:7a01e24:     // Copy into FastIDSet
1:7a01e24:     FastIDSet itemIDs = new FastIDSet(ids.size());
1:7a01e24:     for (long l : ids) {
1:7a01e24:       itemIDs.add(l);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     // Swap with the active
1:7a01e24:     this.itemIDs = itemIDs;
1:7a01e24:   }
1:7a01e24: 
1:7a01e24:   /*
1:7a01e24:    * Refresh the user id cache. Warning: this does a large table scan
1:7a01e24:    */
1:7a01e24:   private synchronized void refreshUserIDs() throws IOException {
1:7a01e24:     // Get the list of user ids
1:7a01e24:     HTableInterface table = pool.getTable(tableName);
1:7a01e24:     Scan scan = new Scan(new byte[]{0x75}, new byte[]{0x76});
1:7a01e24:     scan.setFilter(new FilterList(FilterList.Operator.MUST_PASS_ALL, new KeyOnlyFilter(), new FirstKeyOnlyFilter()));
1:7a01e24:     ResultScanner scanner = table.getScanner(scan);
1:85f9ece:     Collection<Long> ids = new LinkedList<>();
1:7a01e24:     for (Result result : scanner) {
1:7a01e24:       ids.add(bytesToUserOrItemID(result.getRow()));
1:7a01e24:     }
1:7a01e24:     table.close();
1:7a01e24: 
1:7a01e24:     // Copy into FastIDSet
1:7a01e24:     FastIDSet userIDs = new FastIDSet(ids.size());
1:3c22856:     for (long l : ids) {
1:7a01e24:       userIDs.add(l);
1:7a01e24:     }
1:7a01e24: 
1:7a01e24:     // Swap with the active
1:7a01e24:     this.userIDs = userIDs;
1:7a01e24:   }
1:7a01e24: 
1:7a01e24: }
============================================================================
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:85f9ece
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.hadoop.hbase.filter.KeyOnlyFilter;
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import java.io.Closeable;
1: import java.io.IOException;
1: import java.nio.ByteBuffer;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.SortedMap;
/////////////////////////////////////////////////////////////////////////
1:     try (HBaseAdmin admin = new HBaseAdmin(conf)) {
/////////////////////////////////////////////////////////////////////////
1:       List<Get> gets = new ArrayList<>(2);
/////////////////////////////////////////////////////////////////////////
1:       List<Put> puts = new ArrayList<>(2);
/////////////////////////////////////////////////////////////////////////
1:       List<Delete> deletes = new ArrayList<>(2);
/////////////////////////////////////////////////////////////////////////
1:     Collection<Long> ids = new LinkedList<>();
/////////////////////////////////////////////////////////////////////////
1:     Collection<Long> ids = new LinkedList<>();
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:b60c909
/////////////////////////////////////////////////////////////////////////
commit:58cc1ae
/////////////////////////////////////////////////////////////////////////
0:     Collection<Long> ids = Lists.newLinkedList();
/////////////////////////////////////////////////////////////////////////
0:     Collection<Long> ids = Lists.newLinkedList();
commit:bdb1c48
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     bootstrap(conf);
/////////////////////////////////////////////////////////////////////////
1: 
1:     bootstrap(conf);
/////////////////////////////////////////////////////////////////////////
1:   private void bootstrap(Configuration conf) throws IOException {
/////////////////////////////////////////////////////////////////////////
commit:6d16230
/////////////////////////////////////////////////////////////////////////
0:   private final boolean tableWasCreated;
commit:3c22856
/////////////////////////////////////////////////////////////////////////
1:     for (byte[] family : families.keySet()) {
/////////////////////////////////////////////////////////////////////////
1:     for (long l : ids) {
commit:210b265
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
0:       List<Get> gets = Lists.newArrayListWithCapacity(2);
/////////////////////////////////////////////////////////////////////////
0:       List<Put> puts = Lists.newArrayListWithCapacity(2);
/////////////////////////////////////////////////////////////////////////
0:       List<Delete> deletes = Lists.newArrayListWithCapacity(2);
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:bad258a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:7a01e24
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.cf.taste.impl.model.hbase;
1: 
0: import java.io.Closeable;
0: import java.io.IOException;
0: import java.nio.ByteBuffer;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.SortedMap;
1: 
1: import org.apache.hadoop.conf.Configuration;
1: import org.apache.hadoop.hbase.HBaseConfiguration;
1: import org.apache.hadoop.hbase.HColumnDescriptor;
1: import org.apache.hadoop.hbase.HTableDescriptor;
1: import org.apache.hadoop.hbase.KeyValue;
0: import org.apache.hadoop.hbase.TableExistsException;
1: import org.apache.hadoop.hbase.client.Delete;
1: import org.apache.hadoop.hbase.client.Get;
1: import org.apache.hadoop.hbase.client.HBaseAdmin;
1: import org.apache.hadoop.hbase.client.HTableFactory;
1: import org.apache.hadoop.hbase.client.HTableInterface;
1: import org.apache.hadoop.hbase.client.HTablePool;
1: import org.apache.hadoop.hbase.client.Put;
1: import org.apache.hadoop.hbase.client.Result;
1: import org.apache.hadoop.hbase.client.ResultScanner;
1: import org.apache.hadoop.hbase.client.Scan;
1: import org.apache.hadoop.hbase.filter.FilterList;
0: import org.apache.hadoop.hbase.filter.KeyOnlyFilter;
1: import org.apache.hadoop.hbase.filter.FirstKeyOnlyFilter;
1: import org.apache.hadoop.hbase.util.Bytes;
1: 
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.mahout.cf.taste.common.NoSuchItemException;
1: import org.apache.mahout.cf.taste.common.NoSuchUserException;
1: import org.apache.mahout.cf.taste.common.Refreshable;
1: import org.apache.mahout.cf.taste.common.TasteException;
1: import org.apache.mahout.cf.taste.impl.common.FastIDSet;
1: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1: import org.apache.mahout.cf.taste.impl.model.GenericItemPreferenceArray;
1: import org.apache.mahout.cf.taste.impl.model.GenericUserPreferenceArray;
1: import org.apache.mahout.cf.taste.model.DataModel;
1: import org.apache.mahout.cf.taste.model.PreferenceArray;
1: 
1: /**
1:  * <p>Naive approach of storing one preference as one value in the table.
1:  * Preferences are indexed as (user, item) and (item, user) for O(1) lookups.</p>
1:  *
1:  * <p>The default table name is "taste", this can be set through a constructor
1:  * argument. Each row has a value starting with "i" or "u" followed by the
1:  * actual id encoded as a big endian long.</p>
1:  *
1:  * <p>E.g., "u\x00\x00\x00\x00\x00\x00\x04\xd2" is user 1234L</p>
1:  *
1:  * <p>There are two column families: "users" and "items".</p>
1:  *
1:  * <p>The "users" column family holds user->item preferences. Each userID is the
1:  * column qualifier and the value is the preference.</p>
1:  *
1:  * <p>The "items" column fmaily holds item->user preferences. Each itemID is the
1:  * column qualifier and the value is the preference.</p>
1:  *
1:  * <p>User IDs and item IDs are cached in a FastIDSet since it requires a full
1:  * table scan to build these sets. Preferences are not cached since they
1:  * are pretty cheap lookups in HBase (also caching the Preferences defeats
1:  * the purpose of a scalable storage engine like HBase).</p>
1:  */
1: public final class HBaseDataModel implements DataModel, Closeable {
1: 
1:   private static final Logger log = LoggerFactory.getLogger(HBaseDataModel.class);
1: 
1:   private static final String DEFAULT_TABLE = "taste";
1:   private static final byte[] USERS_CF = Bytes.toBytes("users");
1:   private static final byte[] ITEMS_CF = Bytes.toBytes("items");
1: 
1:   private final HTablePool pool;
1:   private final String tableName;
0:   public final boolean tableWasCreated;
1: 
1:   // Cache of user and item ids
1:   private volatile FastIDSet itemIDs;
1:   private volatile FastIDSet userIDs;
1: 
1:   public HBaseDataModel(String zkConnect) throws IOException {
1:     this(zkConnect, DEFAULT_TABLE);
1:   }
1: 
1:   public HBaseDataModel(String zkConnect, String tableName) throws IOException {
1:     log.info("Using HBase table {}", tableName);
1:     Configuration conf = HBaseConfiguration.create();
1:     conf.set("hbase.zookeeper.quorum", zkConnect);
1:     HTableFactory tableFactory = new HTableFactory();
1:     this.pool = new HTablePool(conf, 8, tableFactory);
1:     this.tableName = tableName;
0:     this.tableWasCreated = bootstrap(conf);
1:     // Warm the cache
1:     refresh(null);
1:   }
1: 
1:   public HBaseDataModel(HTablePool pool, String tableName, Configuration conf) throws IOException {
1:     log.info("Using HBase table {}", tableName);
1:     this.pool = pool;
1:     this.tableName = tableName;
0:     this.tableWasCreated = bootstrap(conf);
1: 
1:     // Warm the cache
1:     refresh(null);
1:   }
1: 
1:   public String getTableName() {
1:     return tableName;
1:   }
1: 
1:   /**
1:    * Create the table if it doesn't exist
1:    */
0:   private boolean bootstrap(Configuration conf) throws IOException {
0:     HBaseAdmin admin = new HBaseAdmin(conf);
1:     HTableDescriptor tDesc = new HTableDescriptor(Bytes.toBytes(tableName));
1:     tDesc.addFamily(new HColumnDescriptor(USERS_CF));
1:     tDesc.addFamily(new HColumnDescriptor(ITEMS_CF));
1:     try {
1:       admin.createTable(tDesc);
1:       log.info("Created table {}", tableName);
1:       return true;
0:     } catch (TableExistsException e) {
0:       log.info("Table {} alreay exists", tableName);
0:       return false;
0:     } finally {
0:       admin.close();
1:     }
1:   }
1: 
1:   /**
1:    * Prefix a user id with "u" and convert to byte[]
1:    */
1:   private static byte[] userToBytes(long userID) {
1:     ByteBuffer bb = ByteBuffer.allocate(9);
1:     bb.put((byte)0x75); // The letter "u"
1:     bb.putLong(userID);
1:     return bb.array();
1:   }
1: 
1:   /**
1:    * Prefix an item id with "i" and convert to byte[]
1:    */
1:   private static byte[] itemToBytes(long itemID) {
1:     ByteBuffer bb = ByteBuffer.allocate(9);
1:     bb.put((byte)0x69); // The letter "i"
1:     bb.putLong(itemID);
1:     return bb.array();
1:   }
1: 
1:   /**
1:    * Extract the id out of a prefix byte[] id
1:    */
1:   private static long bytesToUserOrItemID(byte[] ba) {
1:     ByteBuffer bb = ByteBuffer.wrap(ba);
1:     return bb.getLong(1);
1:   }
1: 
1:   /* DataModel interface */
1: 
1:   @Override
1:   public LongPrimitiveIterator getUserIDs() {
1:     return userIDs.iterator();
1:   }
1: 
1:   @Override
1:   public PreferenceArray getPreferencesFromUser(long userID) throws TasteException {
1:     Result result;
1:     try {
1:       HTableInterface table = pool.getTable(tableName);
1:       Get get = new Get(userToBytes(userID));
1:       get.addFamily(ITEMS_CF);
1:       result = table.get(get);
1:       table.close();
1:     } catch (IOException e) {
1:       throw new TasteException("Failed to retrieve user preferences from HBase", e);
1:     }
1: 
1:     if (result.isEmpty()) {
1:       throw new NoSuchUserException(userID);
1:     }
1: 
1:     SortedMap<byte[], byte[]> families = result.getFamilyMap(ITEMS_CF);
1:     PreferenceArray prefs = new GenericUserPreferenceArray(families.size());
1:     prefs.setUserID(0, userID);
1:     int i = 0;
1:     for (Map.Entry<byte[], byte[]> entry : families.entrySet()) {
1:       prefs.setItemID(i, Bytes.toLong(entry.getKey()));
1:       prefs.setValue(i, Bytes.toFloat(entry.getValue()));
1:       i++;
1:     }
1:     return prefs;
1:   }
1: 
1:   @Override
1:   public FastIDSet getItemIDsFromUser(long userID) throws TasteException {
1:     Result result;
1:     try {
1:       HTableInterface table = pool.getTable(tableName);
1:       Get get = new Get(userToBytes(userID));
1:       get.addFamily(ITEMS_CF);
1:       result = table.get(get);
1:       table.close();
1:     } catch (IOException e) {
1:       throw new TasteException("Failed to retrieve item IDs from HBase", e);
1:     }
1: 
1:     if (result.isEmpty()) {
1:       throw new NoSuchUserException(userID);
1:     }
1: 
1:     SortedMap<byte[],byte[]> families = result.getFamilyMap(ITEMS_CF);
1:     FastIDSet ids = new FastIDSet(families.size());
0:     for (byte[] family: families.keySet()) {
1:       ids.add(Bytes.toLong(family));
1:     }
1:     return ids;
1:   }
1: 
1:   @Override
1:   public LongPrimitiveIterator getItemIDs() {
1:     return itemIDs.iterator();
1:   }
1: 
1:   @Override
1:   public PreferenceArray getPreferencesForItem(long itemID) throws TasteException {
1:     Result result;
1:     try {
1:       HTableInterface table = pool.getTable(tableName);
1:       Get get = new Get(itemToBytes(itemID));
1:       get.addFamily(USERS_CF);
1:       result = table.get(get);
1:       table.close();
1:     } catch (IOException e) {
1:       throw new TasteException("Failed to retrieve item preferences from HBase", e);
1:     }
1: 
1:     if (result.isEmpty()) {
1:       throw new NoSuchItemException(itemID);
1:     }
1: 
1:     SortedMap<byte[], byte[]> families = result.getFamilyMap(USERS_CF);
1:     PreferenceArray prefs = new GenericItemPreferenceArray(families.size());
1:     prefs.setItemID(0, itemID);
1:     int i = 0;
1:     for (Map.Entry<byte[], byte[]> entry : families.entrySet()) {
1:       prefs.setUserID(i, Bytes.toLong(entry.getKey()));
1:       prefs.setValue(i, Bytes.toFloat(entry.getValue()));
1:       i++;
1:     }
1:     return prefs;
1:   }
1: 
1:   @Override
1:   public Float getPreferenceValue(long userID, long itemID) throws TasteException {
1:     Result result;
1:     try {
1:       HTableInterface table = pool.getTable(tableName);
1:       Get get = new Get(userToBytes(userID));
1:       get.addColumn(ITEMS_CF, Bytes.toBytes(itemID));
1:       result = table.get(get);
1:       table.close();
1:     } catch (IOException e) {
1:       throw new TasteException("Failed to retrieve user preferences from HBase", e);
1:     }
1: 
1:     if (result.isEmpty()) {
1:       throw new NoSuchUserException(userID);
1:     }
1: 
1:     if (result.containsColumn(ITEMS_CF, Bytes.toBytes(itemID))) {
1:       return Bytes.toFloat(result.getValue(ITEMS_CF, Bytes.toBytes(itemID)));
1:     } else {
1:       return null;
1:     }
1:   }
1: 
1:   @Override
1:   public Long getPreferenceTime(long userID, long itemID) throws TasteException {
1:     Result result;
1:     try {
1:       HTableInterface table = pool.getTable(tableName);
1:       Get get = new Get(userToBytes(userID));
1:       get.addColumn(ITEMS_CF, Bytes.toBytes(itemID));
1:       result = table.get(get);
1:       table.close();
1:     } catch (IOException e) {
1:       throw new TasteException("Failed to retrieve user preferences from HBase", e);
1:     }
1: 
1:     if (result.isEmpty()) {
1:       throw new NoSuchUserException(userID);
1:     }
1: 
1:     if (result.containsColumn(ITEMS_CF, Bytes.toBytes(itemID))) {
1:       KeyValue kv = result.getColumnLatest(ITEMS_CF, Bytes.toBytes(itemID));
1:       return kv.getTimestamp();
1:     } else {
1:       return null;
1:     }
1:   }
1: 
1:   @Override
1:   public int getNumItems() {
1:     return itemIDs.size();
1:   }
1: 
1:   @Override
1:   public int getNumUsers() {
1:     return userIDs.size();
1:   }
1: 
1:   @Override
1:   public int getNumUsersWithPreferenceFor(long itemID) throws TasteException {
1:     PreferenceArray prefs = getPreferencesForItem(itemID);
1:     return prefs.length();
1:   }
1: 
1:   @Override
1:   public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException {
1:     Result[] results;
1:     try {
1:       HTableInterface table = pool.getTable(tableName);
0:       List<Get> gets = new ArrayList<Get>(2);
1:       gets.add(new Get(itemToBytes(itemID1)));
1:       gets.add(new Get(itemToBytes(itemID2)));
1:       gets.get(0).addFamily(USERS_CF);
1:       gets.get(1).addFamily(USERS_CF);
1:       results = table.get(gets);
1:       table.close();
1:     } catch (IOException e) {
1:       throw new TasteException("Failed to retrieve item preferences from HBase", e);
1:     }
1: 
1:     if (results[0].isEmpty()) {
1:       throw new NoSuchItemException(itemID1);
1:     }
1:     if (results[1].isEmpty()) {
1:       throw new NoSuchItemException(itemID2);
1:     }
1: 
1:     // First item
1:     Result result = results[0];
1:     SortedMap<byte[], byte[]> families = result.getFamilyMap(USERS_CF);
1:     FastIDSet idSet1 = new FastIDSet(families.size());
1:     for (byte[] id : families.keySet()) {
1:       idSet1.add(Bytes.toLong(id));
1:     }
1: 
1:     // Second item
1:     result = results[1];
1:     families = result.getFamilyMap(USERS_CF);
1:     FastIDSet idSet2 = new FastIDSet(families.size());
1:     for (byte[] id : families.keySet()) {
1:       idSet2.add(Bytes.toLong(id));
1:     }
1: 
1:     return idSet1.intersectionSize(idSet2);
1:   }
1: 
1:   @Override
1:   public void setPreference(long userID, long itemID, float value) throws TasteException {
1:     try {
1:       HTableInterface table = pool.getTable(tableName);
0:       List<Put> puts = new ArrayList<Put>(2);
1:       puts.add(new Put(userToBytes(userID)));
1:       puts.add(new Put(itemToBytes(itemID)));
1:       puts.get(0).add(ITEMS_CF, Bytes.toBytes(itemID), Bytes.toBytes(value));
1:       puts.get(1).add(USERS_CF, Bytes.toBytes(userID), Bytes.toBytes(value));
1:       table.put(puts);
1:       table.close();
1:     } catch (IOException e) {
1:       throw new TasteException("Failed to store preference in HBase", e);
1:     }
1:   }
1: 
1:   @Override
1:   public void removePreference(long userID, long itemID) throws TasteException {
1:     try {
1:       HTableInterface table = pool.getTable(tableName);
0:       List<Delete> deletes = new ArrayList<Delete>(2);
1:       deletes.add(new Delete(userToBytes(userID)));
1:       deletes.add(new Delete(itemToBytes(itemID)));
1:       deletes.get(0).deleteColumns(ITEMS_CF, Bytes.toBytes(itemID));
1:       deletes.get(1).deleteColumns(USERS_CF, Bytes.toBytes(userID));
1:       table.delete(deletes);
1:       table.close();
1:     } catch (IOException e) {
1:       throw new TasteException("Failed to remove preference from HBase", e);
1:     }
1:   }
1: 
1:   @Override
1:   public boolean hasPreferenceValues() {
1:     return true;
1:   }
1: 
1:   @Override
1:   public float getMaxPreference() {
1:     throw new UnsupportedOperationException();
1:   }
1: 
1:   @Override
1:   public float getMinPreference() {
1:     throw new UnsupportedOperationException();
1:   }
1: 
1:   /* Closeable interface */
1: 
1:   @Override
1:   public void close() throws IOException {
1:     pool.close();
1:   }
1: 
1:   /* Refreshable interface */
1: 
1:   @Override
1:   public void refresh(Collection<Refreshable> alreadyRefreshed) {
1:     if (alreadyRefreshed == null || !alreadyRefreshed.contains(this)) {
1:       try {
1:         log.info("Refreshing item and user ID caches");
1:         long t1 = System.currentTimeMillis();
1:         refreshItemIDs();
1:         refreshUserIDs();
1:         long t2 = System.currentTimeMillis();
1:         log.info("Finished refreshing caches in {} ms", t2 - t1);
1:       } catch (IOException e) {
1:         throw new IllegalStateException("Could not reload DataModel", e);
1:       }
1:     }
1:   }
1: 
1:   /*
1:    * Refresh the item id cache. Warning: this does a large table scan
1:    */
1:   private synchronized void refreshItemIDs() throws IOException {
1:     // Get the list of item ids
1:     HTableInterface table = pool.getTable(tableName);
1:     Scan scan = new Scan(new byte[]{0x69}, new byte[]{0x70});
1:     scan.setFilter(new FilterList(FilterList.Operator.MUST_PASS_ALL, new KeyOnlyFilter(), new FirstKeyOnlyFilter()));
1:     ResultScanner scanner = table.getScanner(scan);
0:     Collection<Long> ids = new LinkedList<Long>();
1:     for (Result result : scanner) {
1:       ids.add(bytesToUserOrItemID(result.getRow()));
1:     }
1:     table.close();
1: 
1:     // Copy into FastIDSet
1:     FastIDSet itemIDs = new FastIDSet(ids.size());
1:     for (long l : ids) {
1:       itemIDs.add(l);
1:     }
1: 
1:     // Swap with the active
1:     this.itemIDs = itemIDs;
1:   }
1: 
1:   /*
1:    * Refresh the user id cache. Warning: this does a large table scan
1:    */
1:   private synchronized void refreshUserIDs() throws IOException {
1:     // Get the list of user ids
1:     HTableInterface table = pool.getTable(tableName);
1:     Scan scan = new Scan(new byte[]{0x75}, new byte[]{0x76});
1:     scan.setFilter(new FilterList(FilterList.Operator.MUST_PASS_ALL, new KeyOnlyFilter(), new FirstKeyOnlyFilter()));
1:     ResultScanner scanner = table.getScanner(scan);
0:     Collection<Long> ids = new LinkedList<Long>();
1:     for (Result result : scanner) {
1:       ids.add(bytesToUserOrItemID(result.getRow()));
1:     }
1:     table.close();
1: 
1:     // Copy into FastIDSet
1:     FastIDSet userIDs = new FastIDSet(ids.size());
0:     for(long l : ids) {
1:       userIDs.add(l);
1:     }
1: 
1:     // Swap with the active
1:     this.userIDs = userIDs;
1:   }
1: 
1: }
author:Ted Dunning
-------------------------------------------------------------------------------
commit:402e296
/////////////////////////////////////////////////////////////////////////
============================================================================