1:e2620d3: /**
1:e2620d3:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:e2620d3:  * contributor license agreements.  See the NOTICE file distributed with
1:e2620d3:  * this work for additional information regarding copyright ownership.
1:e2620d3:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:e2620d3:  * (the "License"); you may not use this file except in compliance with
1:e2620d3:  * the License.  You may obtain a copy of the License at
1:e2620d3:  *
1:e2620d3:  *     http://www.apache.org/licenses/LICENSE-2.0
1:e2620d3:  *
1:e2620d3:  * Unless required by applicable law or agreed to in writing, software
1:e2620d3:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e2620d3:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e2620d3:  * See the License for the specific language governing permissions and
1:e2620d3:  * limitations under the License.
1:e2620d3:  */
3:e2620d3: 
1:e2620d3: package org.apache.mahout.cf.taste.impl.model.mongodb;
1:e2620d3: 
1:e2620d3: import com.google.common.base.Preconditions;
1:85f9ece: import com.mongodb.BasicDBObject;
1:85f9ece: import com.mongodb.DB;
1:85f9ece: import com.mongodb.DBCollection;
1:85f9ece: import com.mongodb.DBCursor;
1:85f9ece: import com.mongodb.DBObject;
1:85f9ece: import com.mongodb.Mongo;
1:85f9ece: import org.apache.mahout.cf.taste.common.NoSuchItemException;
1:85f9ece: import org.apache.mahout.cf.taste.common.NoSuchUserException;
1:e2620d3: import org.apache.mahout.cf.taste.common.Refreshable;
1:e2620d3: import org.apache.mahout.cf.taste.common.TasteException;
1:e2620d3: import org.apache.mahout.cf.taste.impl.common.FastByIDMap;
1:e2620d3: import org.apache.mahout.cf.taste.impl.common.FastIDSet;
1:e2620d3: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1:e2620d3: import org.apache.mahout.cf.taste.impl.model.GenericDataModel;
1:e2620d3: import org.apache.mahout.cf.taste.impl.model.GenericPreference;
1:e2620d3: import org.apache.mahout.cf.taste.impl.model.GenericUserPreferenceArray;
1:e2620d3: import org.apache.mahout.cf.taste.model.DataModel;
1:e2620d3: import org.apache.mahout.cf.taste.model.Preference;
1:e2620d3: import org.apache.mahout.cf.taste.model.PreferenceArray;
1:e2620d3: import org.bson.types.ObjectId;
1:e2620d3: import org.slf4j.Logger;
1:e2620d3: import org.slf4j.LoggerFactory;
1:e2620d3: 
1:85f9ece: import java.net.UnknownHostException;
1:85f9ece: import java.text.DateFormat;
1:85f9ece: import java.text.ParseException;
1:85f9ece: import java.text.SimpleDateFormat;
1:85f9ece: import java.util.ArrayList;
1:85f9ece: import java.util.Collection;
1:85f9ece: import java.util.Date;
1:85f9ece: import java.util.List;
1:85f9ece: import java.util.Locale;
1:85f9ece: import java.util.Map;
1:85f9ece: import java.util.concurrent.locks.ReentrantLock;
1:85f9ece: import java.util.regex.Pattern;
1:e2620d3: 
1:e2620d3: /**
1:e2620d3:  * <p>A {@link DataModel} backed by a MongoDB database. This class expects a
1:e2620d3:  * collection in the database which contains a user ID ({@code long} or
1:e2620d3:  * {@link ObjectId}), item ID ({@code long} or
1:e2620d3:  * {@link ObjectId}), preference value (optional) and timestamps
1:e2620d3:  * ("created_at", "deleted_at").</p>
1:e2620d3:  *
1:e2620d3:  * <p>An example of a document in MongoDB:</p>
1:e2620d3:  *
1:15925a5:  * <p>{@code { "_id" : ObjectId("4d7627bf6c7d47ade9fc7780"),
1:e2620d3:  * "user_id" : ObjectId("4c2209fef3924d31102bd84b"),
1:e2620d3:  * "item_id" : ObjectId(4c2209fef3924d31202bd853),
1:e2620d3:  * "preference" : 0.5,
1:e2620d3:  * "created_at" : "Tue Mar 23 2010 20:48:43 GMT-0400 (EDT)" }
1:e2620d3:  * }</p>
1:e2620d3:  *
1:e2620d3:  * <p>Preference value is optional to accommodate applications that have no notion
1:e2620d3:  * of a preference value (that is, the user simply expresses a preference for
1:e2620d3:  * an item, but no degree of preference).</p>
1:e2620d3:  *
1:e2620d3:  * <p>The preference value is assumed to be parseable as a {@code double}.</p>
1:e2620d3:  *
1:e2620d3:  * <p>The user IDs and item IDs are assumed to be parseable as {@code long}s
1:e2620d3:  * or {@link ObjectId}s. In case of {@link ObjectId}s, the
1:e2620d3:  * model creates a {@code Map<ObjectId>}, {@code long}>
1:e2620d3:  * (collection "mongo_data_model_map") inside the MongoDB database. This
1:e2620d3:  * conversion is needed since Mahout uses the long datatype to feed the
1:e2620d3:  * recommender, and MongoDB uses 12 bytes to create its identifiers.</p>
1:e2620d3:  *
1:e2620d3:  * <p>The timestamps ("created_at", "deleted_at"), if present, are assumed to be
1:e2620d3:  * parseable as a {@code long} or {@link Date}. To express
1:e2620d3:  * timestamps as {@link Date}s, a {@link DateFormat}
1:e2620d3:  * must be provided in the class constructor. The default Date format is
1:e2620d3:  * {@code "EE MMM dd yyyy HH:mm:ss 'GMT'Z (zzz)"}. If this parameter
1:e2620d3:  * is set to null, timestamps are assumed to be parseable as {@code long}s.
1:e2620d3:  * </p>
1:e2620d3:  *
1:e2620d3:  * <p>It is also acceptable for the documents to contain additional fields.
1:e2620d3:  * Those fields will be ignored.</p>
1:e2620d3:  *
1:e2620d3:  * <p>This class will reload data from the MondoDB database when
1:e2620d3:  * {@link #refresh(Collection)} is called. MongoDBDataModel keeps the
1:e2620d3:  * timestamp of the last update. This variable and the fields "created_at"
1:e2620d3:  * and "deleted_at" help the model to determine if the triple
1:e2620d3:  * (user, item, preference) must be added or deleted.</p>
1:e2620d3:  */
1:e2620d3: public final class MongoDBDataModel implements DataModel {
1:e2620d3: 
1:e2620d3:   private static final Logger log = LoggerFactory.getLogger(MongoDBDataModel.class);
1:e2620d3: 
1:e2620d3:   /** Default MongoDB host. Default: localhost */
1:e2620d3:   private static final String DEFAULT_MONGO_HOST = "localhost";
1:e2620d3: 
1:e2620d3:   /** Default MongoDB port. Default: 27017 */
1:e2620d3:   private static final int DEFAULT_MONGO_PORT = 27017;
1:e2620d3: 
1:e2620d3:   /** Default MongoDB database. Default: recommender */
1:e2620d3:   private static final String DEFAULT_MONGO_DB = "recommender";
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * Default MongoDB authentication flag.
1:e2620d3:    * Default: false (authentication is not required)
1:e2620d3:    */
1:e2620d3:   private static final boolean DEFAULT_MONGO_AUTH = false;
1:e2620d3: 
1:e2620d3:   /** Default MongoDB user. Default: recommender */
1:e2620d3:   private static final String DEFAULT_MONGO_USERNAME = "recommender";
1:e2620d3: 
1:e2620d3:   /** Default MongoDB password. Default: recommender */
1:e2620d3:   private static final String DEFAULT_MONGO_PASSWORD = "recommender";
1:e2620d3: 
1:e2620d3:   /** Default MongoDB table/collection. Default: items */
1:e2620d3:   private static final String DEFAULT_MONGO_COLLECTION = "items";
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * Default MongoDB update flag. When this flag is activated, the
1:e2620d3:    * DataModel updates both model and database. Default: true
1:e2620d3:    */
1:e2620d3:   private static final boolean DEFAULT_MONGO_MANAGE = true;
1:e2620d3: 
1:e2620d3:   /** Default MongoDB user ID field. Default: user_id */
1:e2620d3:   private static final String DEFAULT_MONGO_USER_ID = "user_id";
1:e2620d3: 
1:e2620d3:   /** Default MongoDB item ID field. Default: item_id */
1:e2620d3:   private static final String DEFAULT_MONGO_ITEM_ID = "item_id";
1:e2620d3: 
1:e2620d3:   /** Default MongoDB preference value field. Default: preference */
1:e2620d3:   private static final String DEFAULT_MONGO_PREFERENCE = "preference";
1:e2620d3: 
1:e2620d3:   /** Default MongoDB final remove flag. Default: false */
1:e2620d3:   private static final boolean DEFAULT_MONGO_FINAL_REMOVE = false;
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * Default MongoDB date format.
1:e2620d3:    * Default: "EE MMM dd yyyy HH:mm:ss 'GMT'Z (zzz)"
1:e2620d3:    */
1:e2620d3:   private static final DateFormat DEFAULT_DATE_FORMAT =
1:e2620d3:       new SimpleDateFormat("EE MMM dd yyyy HH:mm:ss 'GMT'Z (zzz)", Locale.ENGLISH);
1:e2620d3: 
1:b5c65a5:   public static final String DEFAULT_MONGO_MAP_COLLECTION = "mongo_data_model_map";
1:e2620d3: 
1:e2620d3:   private static final Pattern ID_PATTERN = Pattern.compile("[a-f0-9]{24}");
1:e2620d3: 
1:e2620d3:   /** MongoDB host */
1:e2620d3:   private String mongoHost = DEFAULT_MONGO_HOST;
1:e2620d3:   /** MongoDB port */
1:e2620d3:   private int mongoPort = DEFAULT_MONGO_PORT;
1:e2620d3:   /** MongoDB database */
1:e2620d3:   private String mongoDB = DEFAULT_MONGO_DB;
1:e2620d3:   /**
1:e2620d3:    * MongoDB authentication flag. If this flag is set to false,
1:e2620d3:    * authentication is not required.
1:e2620d3:    */
1:e2620d3:   private boolean mongoAuth = DEFAULT_MONGO_AUTH;
1:e2620d3:   /** MongoDB user */
1:e2620d3:   private String mongoUsername = DEFAULT_MONGO_USERNAME;
1:e2620d3:   /** MongoDB pass */
1:e2620d3:   private String mongoPassword = DEFAULT_MONGO_PASSWORD;
1:e2620d3:   /** MongoDB table/collection */
1:e2620d3:   private String mongoCollection = DEFAULT_MONGO_COLLECTION;
1:b5c65a5:   /** MongoDB mapping table/collection */
1:b5c65a5:   private String mongoMapCollection = DEFAULT_MONGO_MAP_COLLECTION;
1:e2620d3:   /**
1:e2620d3:    * MongoDB update flag. When this flag is activated, the
1:e2620d3:    * DataModel updates both model and database
1:e2620d3:    */
1:e2620d3:   private boolean mongoManage = DEFAULT_MONGO_MANAGE;
1:e2620d3:   /** MongoDB user ID field */
1:e2620d3:   private String mongoUserID = DEFAULT_MONGO_USER_ID;
1:e2620d3:   /** MongoDB item ID field */
1:e2620d3:   private String mongoItemID = DEFAULT_MONGO_ITEM_ID;
1:e2620d3:   /** MongoDB preference value field */
1:e2620d3:   private String mongoPreference = DEFAULT_MONGO_PREFERENCE;
1:e2620d3:   /** MongoDB final remove flag. Default: false */
1:e2620d3:   private boolean mongoFinalRemove = DEFAULT_MONGO_FINAL_REMOVE;
1:e2620d3:   /** MongoDB date format */
1:e2620d3:   private DateFormat dateFormat = DEFAULT_DATE_FORMAT;
1:e2620d3:   private DBCollection collection;
1:e2620d3:   private DBCollection collectionMap;
1:e2620d3:   private Date mongoTimestamp;
1:e2620d3:   private final ReentrantLock reloadLock;
1:e2620d3:   private DataModel delegate;
1:e2620d3:   private boolean userIsObject;
1:e2620d3:   private boolean itemIsObject;
1:e2620d3:   private boolean preferenceIsString;
1:e2620d3:   private long idCounter;
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * Creates a new MongoDBDataModel
1:e2620d3:    */
1:4ca6b86:   public MongoDBDataModel() throws UnknownHostException {
1:e2620d3:     this.reloadLock = new ReentrantLock();
1:e2620d3:     buildModel();
1:e2620d3:   }
1:e2620d3: 
1:b5c65a5:   /**
1:e2620d3:    * Creates a new MongoDBDataModel with MongoDB basic configuration
1:e2620d3:    * (without authentication)
1:e2620d3:    *
1:e2620d3:    * @param host        MongoDB host.
1:e2620d3:    * @param port        MongoDB port. Default: 27017
1:e2620d3:    * @param database    MongoDB database
1:e2620d3:    * @param collection  MongoDB collection/table
1:e2620d3:    * @param manage      If true, the model adds and removes users and items
1:e2620d3:    *                    from MongoDB database when the model is refreshed.
1:e2620d3:    * @param finalRemove If true, the model removes the user/item completely
1:e2620d3:    *                    from the MongoDB database. If false, the model adds the "deleted_at"
1:e2620d3:    *                    field with the current date to the "deleted" user/item.
1:e2620d3:    * @param format      MongoDB date format. If null, the model uses timestamps.
1:e2620d3:    * @throws UnknownHostException if the database host cannot be resolved
1:e2620d3:    */
1:e2620d3:   public MongoDBDataModel(String host,
1:e2620d3:                           int port,
1:e2620d3:                           String database,
1:e2620d3:                           String collection,
1:e2620d3:                           boolean manage,
1:e2620d3:                           boolean finalRemove,
1:4ca6b86:                           DateFormat format) throws UnknownHostException {
1:e2620d3:     mongoHost = host;
1:e2620d3:     mongoPort = port;
1:e2620d3:     mongoDB = database;
1:e2620d3:     mongoCollection = collection;
1:e2620d3:     mongoManage = manage;
1:e2620d3:     mongoFinalRemove = finalRemove;
1:e2620d3:     dateFormat = format;
1:e2620d3:     this.reloadLock = new ReentrantLock();
1:e2620d3:     buildModel();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * Creates a new MongoDBDataModel with MongoDB advanced configuration
1:e2620d3:    * (without authentication)
1:e2620d3:    *
1:e2620d3:    * @param userIDField     Mongo user ID field
1:e2620d3:    * @param itemIDField     Mongo item ID field
1:e2620d3:    * @param preferenceField Mongo preference value field
1:e2620d3:    * @throws UnknownHostException if the database host cannot be resolved
1:e2620d3:    * @see #MongoDBDataModel(String, int, String, String, boolean, boolean, DateFormat)
1:e2620d3:    */
1:e2620d3:   public MongoDBDataModel(String host,
1:e2620d3:                           int port,
1:e2620d3:                           String database,
1:e2620d3:                           String collection,
1:e2620d3:                           boolean manage,
1:e2620d3:                           boolean finalRemove,
1:e2620d3:                           DateFormat format,
1:e2620d3:                           String userIDField,
1:e2620d3:                           String itemIDField,
1:b5c65a5:                           String preferenceField,
1:4ca6b86:                           String mappingCollection) throws UnknownHostException {
1:e2620d3:     mongoHost = host;
1:e2620d3:     mongoPort = port;
1:e2620d3:     mongoDB = database;
1:e2620d3:     mongoCollection = collection;
1:e2620d3:     mongoManage = manage;
1:e2620d3:     mongoFinalRemove = finalRemove;
1:e2620d3:     dateFormat = format;
1:e2620d3:     mongoUserID = userIDField;
1:e2620d3:     mongoItemID = itemIDField;
1:e2620d3:     mongoPreference = preferenceField;
1:b5c65a5:     mongoMapCollection = mappingCollection;
1:e2620d3:     this.reloadLock = new ReentrantLock();
1:e2620d3:     buildModel();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * Creates a new MongoDBDataModel with MongoDB basic configuration
1:e2620d3:    * (with authentication)
1:e2620d3:    *
1:e2620d3:    * @param user     Mongo username (authentication)
1:e2620d3:    * @param password Mongo password (authentication)
1:e2620d3:    * @throws UnknownHostException if the database host cannot be resolved
1:e2620d3:    * @see #MongoDBDataModel(String, int, String, String, boolean, boolean, DateFormat)
1:e2620d3:    */
1:e2620d3:   public MongoDBDataModel(String host,
1:e2620d3:                           int port,
1:e2620d3:                           String database,
1:e2620d3:                           String collection,
1:e2620d3:                           boolean manage,
1:e2620d3:                           boolean finalRemove,
1:e2620d3:                           DateFormat format,
1:e2620d3:                           String user,
1:4ca6b86:                           String password) throws UnknownHostException {
1:e2620d3:     mongoHost = host;
1:e2620d3:     mongoPort = port;
1:e2620d3:     mongoDB = database;
1:e2620d3:     mongoCollection = collection;
1:e2620d3:     mongoManage = manage;
1:e2620d3:     mongoFinalRemove = finalRemove;
1:e2620d3:     dateFormat = format;
1:e2620d3:     mongoAuth = true;
1:e2620d3:     mongoUsername = user;
1:e2620d3:     mongoPassword = password;
1:e2620d3:     this.reloadLock = new ReentrantLock();
1:e2620d3:     buildModel();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * Creates a new MongoDBDataModel with MongoDB advanced configuration
1:e2620d3:    * (with authentication)
1:e2620d3:    *
1:e2620d3:    * @throws UnknownHostException if the database host cannot be resolved
1:e2620d3:    * @see #MongoDBDataModel(String, int, String, String, boolean, boolean, DateFormat, String, String)
1:e2620d3:    */
1:e2620d3:   public MongoDBDataModel(String host,
1:e2620d3:                           int port,
1:e2620d3:                           String database,
1:e2620d3:                           String collection,
1:e2620d3:                           boolean manage,
1:e2620d3:                           boolean finalRemove,
1:e2620d3:                           DateFormat format,
1:e2620d3:                           String user,
1:e2620d3:                           String password,
1:e2620d3:                           String userIDField,
1:e2620d3:                           String itemIDField,
1:b5c65a5:                           String preferenceField,
1:4ca6b86:                           String mappingCollection) throws UnknownHostException {
1:e2620d3:     mongoHost = host;
1:e2620d3:     mongoPort = port;
1:e2620d3:     mongoDB = database;
1:e2620d3:     mongoCollection = collection;
1:e2620d3:     mongoManage = manage;
1:e2620d3:     mongoFinalRemove = finalRemove;
1:e2620d3:     dateFormat = format;
1:e2620d3:     mongoAuth = true;
1:e2620d3:     mongoUsername = user;
1:e2620d3:     mongoPassword = password;
1:e2620d3:     mongoUserID = userIDField;
1:e2620d3:     mongoItemID = itemIDField;
1:e2620d3:     mongoPreference = preferenceField;
1:b5c65a5:     mongoMapCollection = mappingCollection;
1:e2620d3:     this.reloadLock = new ReentrantLock();
1:e2620d3:     buildModel();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * <p>
1:e2620d3:    * Adds/removes (user, item) pairs to/from the model.
1:e2620d3:    * </p>
1:e2620d3:    *
1:e2620d3:    * @param userID MongoDB user identifier
1:e2620d3:    * @param items  List of pairs (item, preference) which want to be added or
1:e2620d3:    *               deleted
1:e2620d3:    * @param add    If true, this flag indicates that the    pairs (user, item)
1:e2620d3:    *               must be added to the model. If false, it indicates deletion.
1:e2620d3:    * @see #refresh(Collection)
1:e2620d3:    */
1:e2620d3:   public void refreshData(String userID,
1:e2620d3:                           Iterable<List<String>> items,
1:e2620d3:                           boolean add) throws NoSuchUserException, NoSuchItemException {
1:e2620d3:     checkData(userID, items, add);
1:e2620d3:     long id = Long.parseLong(fromIdToLong(userID, true));
1:e2620d3:     for (List<String> item : items) {
1:e2620d3:       item.set(0, fromIdToLong(item.get(0), false));
1:e2620d3:     }
1:e2620d3:     if (reloadLock.tryLock()) {
1:e2620d3:       try {
1:e2620d3:         if (add) {
1:e2620d3:           delegate = addUserItem(id, items);
1:e2620d3:         } else {
1:e2620d3:           delegate = removeUserItem(id, items);
1:e2620d3:         }
1:e2620d3:       } finally {
1:e2620d3:         reloadLock.unlock();
1:e2620d3:       }
1:e2620d3:     }
1:e2620d3:   }
1:e2620d3: 
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * <p>
1:e2620d3:    * Triggers "refresh" -- whatever that means -- of the implementation.
1:e2620d3:    * The general contract is that any should always leave itself in a
1:e2620d3:    * consistent, operational state, and that the refresh atomically updates
1:e2620d3:    * internal state from old to new.
1:e2620d3:    * </p>
1:e2620d3:    *
1:e2620d3:    * @param alreadyRefreshed s that are known to have already been refreshed as
1:e2620d3:    *                         a result of an initial call to a method on some object. This ensures
1:e2620d3:    *                         that objects in a refresh dependency graph aren't refreshed twice
1:e2620d3:    *                         needlessly.
1:e2620d3:    * @see #refreshData(String, Iterable, boolean)
1:e2620d3:    */
1:e2620d3:   @Override
1:e2620d3:   public void refresh(Collection<Refreshable> alreadyRefreshed) {
1:e2620d3:     BasicDBObject query = new BasicDBObject();
1:e2620d3:     query.put("deleted_at", new BasicDBObject("$gt", mongoTimestamp));
1:e2620d3:     DBCursor cursor = collection.find(query);
1:4ca6b86:     Date ts = new Date(0);
1:e2620d3:     while (cursor.hasNext()) {
1:e2620d3:       Map<String,Object> user = (Map<String,Object>) cursor.next().toMap();
1:e2620d3:       String userID = getID(user.get(mongoUserID), true);
1:85f9ece:       Collection<List<String>> items = new ArrayList<>();
1:85f9ece:       List<String> item = new ArrayList<>();
1:e2620d3:       item.add(getID(user.get(mongoItemID), false));
1:e2620d3:       item.add(Float.toString(getPreference(user.get(mongoPreference))));
1:e2620d3:       items.add(item);
1:e2620d3:       try {
1:e2620d3:         refreshData(userID, items, false);
1:e2620d3:       } catch (NoSuchUserException e) {
1:e2620d3:         log.warn("No such user ID: {}", userID);
1:e2620d3:       } catch (NoSuchItemException e) {
1:e2620d3:         log.warn("No such items: {}", items);
1:e2620d3:       }
1:e2620d3:       if (ts.compareTo(getDate(user.get("created_at"))) < 0) {
1:e2620d3:         ts = getDate(user.get("created_at"));
1:e2620d3:       }
1:e2620d3:     }
1:e2620d3:     query = new BasicDBObject();
1:e2620d3:     query.put("created_at", new BasicDBObject("$gt", mongoTimestamp));
1:e2620d3:     cursor = collection.find(query);
1:e2620d3:     while (cursor.hasNext()) {
1:e2620d3:       Map<String,Object> user = (Map<String,Object>) cursor.next().toMap();
1:e2620d3:       if (!user.containsKey("deleted_at")) {
1:e2620d3:         String userID = getID(user.get(mongoUserID), true);
1:85f9ece:         Collection<List<String>> items = new ArrayList<>();
1:85f9ece:         List<String> item = new ArrayList<>();
1:e2620d3:         item.add(getID(user.get(mongoItemID), false));
1:e2620d3:         item.add(Float.toString(getPreference(user.get(mongoPreference))));
1:e2620d3:         items.add(item);
1:e2620d3:         try {
1:e2620d3:           refreshData(userID, items, true);
1:e2620d3:         } catch (NoSuchUserException e) {
1:e2620d3:           log.warn("No such user ID: {}", userID);
1:e2620d3:         } catch (NoSuchItemException e) {
1:e2620d3:           log.warn("No such items: {}", items);
1:e2620d3:         }
1:e2620d3:         if (ts.compareTo(getDate(user.get("created_at"))) < 0) {
1:e2620d3:           ts = getDate(user.get("created_at"));
1:e2620d3:         }
1:e2620d3:       }
1:e2620d3:     }
1:e2620d3:     if (mongoTimestamp.compareTo(ts) < 0) {
1:e2620d3:       mongoTimestamp = ts;
1:e2620d3:     }
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * <p>
1:e2620d3:    * Translates the MongoDB identifier to Mahout/MongoDBDataModel's internal
1:e2620d3:    * identifier, if required.
1:e2620d3:    * </p>
1:e2620d3:    * <p>
1:e2620d3:    * If MongoDB identifiers are long datatypes, it returns the id.
1:e2620d3:    * </p>
1:e2620d3:    * <p>
1:e2620d3:    * This conversion is needed since Mahout uses the long datatype to feed the
1:e2620d3:    * recommender, and MongoDB uses 12 bytes to create its identifiers.
1:e2620d3:    * </p>
1:e2620d3:    *
1:e2620d3:    * @param id     MongoDB identifier
1:e2620d3:    * @param isUser
1:e2620d3:    * @return String containing the translation of the external MongoDB ID to
1:e2620d3:    *         internal long ID (mapping).
1:e2620d3:    * @see #fromLongToId(long)
1:e2620d3:    * @see <a href="http://www.mongodb.org/display/DOCS/Object%20IDs">
1:e2620d3:    *      Mongo Object IDs</a>
1:e2620d3:    */
1:e2620d3:   public String fromIdToLong(String id, boolean isUser) {
1:e2620d3:     DBObject objectIdLong = collectionMap.findOne(new BasicDBObject("element_id", id));
1:e2620d3:     if (objectIdLong != null) {
1:e2620d3:       Map<String,Object> idLong = (Map<String,Object>) objectIdLong.toMap();
1:89720ce:       Object value = idLong.get("long_value");
1:89720ce:       return value == null ? null : value.toString();
1:e2620d3:     } else {
1:e2620d3:       objectIdLong = new BasicDBObject();
1:e2620d3:       String longValue = Long.toString(idCounter++);
1:e2620d3:       objectIdLong.put("element_id", id);
1:e2620d3:       objectIdLong.put("long_value", longValue);
1:e2620d3:       collectionMap.insert(objectIdLong);
1:e2620d3:       log.info("Adding Translation {}: {} long_value: {}",
1:8396a27:                isUser ? "User ID" : "Item ID", id, longValue);
1:e2620d3:       return longValue;
1:e2620d3:     }
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * <p>
1:e2620d3:    * Translates the Mahout/MongoDBDataModel's internal identifier to MongoDB
1:e2620d3:    * identifier, if required.
1:e2620d3:    * </p>
1:e2620d3:    * <p>
1:e2620d3:    * If MongoDB identifiers are long datatypes, it returns the id in String
1:e2620d3:    * format.
1:e2620d3:    * </p>
1:e2620d3:    * <p>
1:e2620d3:    * This conversion is needed since Mahout uses the long datatype to feed the
1:e2620d3:    * recommender, and MongoDB uses 12 bytes to create its identifiers.
1:e2620d3:    * </p>
1:e2620d3:    *
1:e2620d3:    * @param id Mahout's internal identifier
1:e2620d3:    * @return String containing the translation of the internal long ID to
1:e2620d3:    *         external MongoDB ID (mapping).
1:e2620d3:    * @see #fromIdToLong(String, boolean)
1:e2620d3:    * @see <a href="http://www.mongodb.org/display/DOCS/Object%20IDs">
1:e2620d3:    *      Mongo Object IDs</a>
1:e2620d3:    */
1:e2620d3:   public String fromLongToId(long id) {
1:e2620d3:     DBObject objectIdLong = collectionMap.findOne(new BasicDBObject("long_value", Long.toString(id)));
1:e2620d3:     Map<String,Object> idLong = (Map<String,Object>) objectIdLong.toMap();
1:89720ce:     Object value = idLong.get("element_id");
1:89720ce:     return value == null ? null : value.toString();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * <p>
1:e2620d3:    * Checks if an ID is currently in the model.
1:e2620d3:    * </p>
1:e2620d3:    *
1:e2620d3:    * @param ID user or item ID
1:e2620d3:    * @return true: if ID is into the model; false: if it's not.
1:e2620d3:    */
1:e2620d3:   public boolean isIDInModel(String ID) {
1:e2620d3:     DBObject objectIdLong = collectionMap.findOne(new BasicDBObject("element_id", ID));
1:e2620d3:     return objectIdLong != null;
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   /**
1:e2620d3:    * <p>
1:e2620d3:    * Date of the latest update of the model.
1:e2620d3:    * </p>
1:e2620d3:    *
1:e2620d3:    * @return Date with the latest update of the model.
1:e2620d3:    */
1:e2620d3:   public Date mongoUpdateDate() {
1:e2620d3:     return mongoTimestamp;
1:e2620d3:   }
1:e2620d3: 
1:4ca6b86:   private void buildModel() throws UnknownHostException {
1:e2620d3:     userIsObject = false;
1:e2620d3:     itemIsObject = false;
1:e2620d3:     idCounter = 0;
1:e2620d3:     preferenceIsString = true;
1:e2620d3:     Mongo mongoDDBB = new Mongo(mongoHost, mongoPort);
1:e2620d3:     DB db = mongoDDBB.getDB(mongoDB);
1:e2620d3:     mongoTimestamp = new Date(0);
1:85f9ece:     FastByIDMap<Collection<Preference>> userIDPrefMap = new FastByIDMap<>();
1:210b265:     if (!mongoAuth || db.authenticate(mongoUsername, mongoPassword.toCharArray())) {
1:e2620d3:       collection = db.getCollection(mongoCollection);
1:b5c65a5:       collectionMap = db.getCollection(mongoMapCollection);
1:e2620d3:       DBObject indexObj = new BasicDBObject();
1:e2620d3:       indexObj.put("element_id", 1);
1:e2620d3:       collectionMap.ensureIndex(indexObj);
1:e2620d3:       indexObj = new BasicDBObject();
1:e2620d3:       indexObj.put("long_value", 1);
1:e2620d3:       collectionMap.ensureIndex(indexObj);
1:e2620d3:       collectionMap.remove(new BasicDBObject());
1:e2620d3:       DBCursor cursor = collection.find();
1:e2620d3:       while (cursor.hasNext()) {
1:e2620d3:         Map<String,Object> user = (Map<String,Object>) cursor.next().toMap();
1:e2620d3:         if (!user.containsKey("deleted_at")) {
1:e2620d3:           long userID = Long.parseLong(fromIdToLong(getID(user.get(mongoUserID), true), true));
1:e2620d3:           long itemID = Long.parseLong(fromIdToLong(getID(user.get(mongoItemID), false), false));
1:e2620d3:           float ratingValue = getPreference(user.get(mongoPreference));
1:e2620d3:           Collection<Preference> userPrefs = userIDPrefMap.get(userID);
1:e2620d3:           if (userPrefs == null) {
1:85f9ece:             userPrefs = new ArrayList<>(2);
1:e2620d3:             userIDPrefMap.put(userID, userPrefs);
1:e2620d3:           }
1:e2620d3:           userPrefs.add(new GenericPreference(userID, itemID, ratingValue));
1:6d16230:           if (user.containsKey("created_at")
1:6d16230:               && mongoTimestamp.compareTo(getDate(user.get("created_at"))) < 0) {
1:e2620d3:             mongoTimestamp = getDate(user.get("created_at"));
1:e2620d3:           }
1:e2620d3:         }
1:e2620d3:       }
1:e2620d3:     }
1:e2620d3:     delegate = new GenericDataModel(GenericDataModel.toDataMap(userIDPrefMap, true));
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   private void removeMongoUserItem(String userID, String itemID) {
1:e2620d3:     String userId = fromLongToId(Long.parseLong(userID));
1:e2620d3:     String itemId = fromLongToId(Long.parseLong(itemID));
1:e2620d3:     if (isUserItemInDB(userId, itemId)) {
1:e2620d3:       mongoTimestamp = new Date();
1:e2620d3:       BasicDBObject query = new BasicDBObject();
1:e2620d3:       query.put(mongoUserID, userIsObject ? new ObjectId(userId) : userId);
1:e2620d3:       query.put(mongoItemID, itemIsObject ? new ObjectId(itemId) : itemId);
1:e2620d3:       if (mongoFinalRemove) {
1:e2620d3:         log.info(collection.remove(query).toString());
1:e2620d3:       } else {
1:e2620d3:         BasicDBObject update = new BasicDBObject();
1:e2620d3:         update.put("$set", new BasicDBObject("deleted_at", mongoTimestamp));
1:e2620d3:         log.info(collection.update(query, update).toString());
1:e2620d3:       }
1:e2620d3:       log.info("Removing userID: {} itemID: {}", userID, itemId);
1:e2620d3:     }
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   private void addMongoUserItem(String userID, String itemID, String preferenceValue) {
1:e2620d3:     String userId = fromLongToId(Long.parseLong(userID));
1:e2620d3:     String itemId = fromLongToId(Long.parseLong(itemID));
1:e2620d3:     if (!isUserItemInDB(userId, itemId)) {
1:e2620d3:       mongoTimestamp = new Date();
1:e2620d3:       BasicDBObject user = new BasicDBObject();
1:e2620d3:       Object userIdObject = userIsObject ? new ObjectId(userId) : userId;
1:e2620d3:       Object itemIdObject = itemIsObject ? new ObjectId(itemId) : itemId;
1:e2620d3:       user.put(mongoUserID, userIdObject);
1:e2620d3:       user.put(mongoItemID, itemIdObject);
1:e2620d3:       user.put(mongoPreference, preferenceIsString ? preferenceValue : Double.parseDouble(preferenceValue));
1:e2620d3:       user.put("created_at", mongoTimestamp);
1:e2620d3:       collection.insert(user);
1:8396a27:       log.info("Adding userID: {} itemID: {} preferenceValue: {}", userID, itemID, preferenceValue);
1:e2620d3:     }
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   private boolean isUserItemInDB(String userID, String itemID) {
1:e2620d3:     BasicDBObject query = new BasicDBObject();
1:e2620d3:     Object userId = userIsObject ? new ObjectId(userID) : userID;
1:e2620d3:     Object itemId = itemIsObject ? new ObjectId(itemID) : itemID;
1:e2620d3:     query.put(mongoUserID, userId);
1:e2620d3:     query.put(mongoItemID, itemId);
1:e2620d3:     return collection.findOne(query) != null;
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   private DataModel removeUserItem(long userID, Iterable<List<String>> items) {
1:e2620d3:     FastByIDMap<PreferenceArray> rawData = ((GenericDataModel) delegate).getRawUserData();
1:e2620d3:     for (List<String> item : items) {
1:e2620d3:       PreferenceArray prefs = rawData.get(userID);
1:e2620d3:       long itemID = Long.parseLong(item.get(0));
1:e2620d3:       if (prefs != null) {
1:e2620d3:         boolean exists = false;
1:e2620d3:         int length = prefs.length();
1:e2620d3:         for (int i = 0; i < length; i++) {
1:e2620d3:           if (prefs.getItemID(i) == itemID) {
1:e2620d3:             exists = true;
1:e2620d3:             break;
1:e2620d3:           }
1:e2620d3:         }
1:e2620d3:         if (exists) {
1:e2620d3:           rawData.remove(userID);
1:e2620d3:           if (length > 1) {
1:e2620d3:             PreferenceArray newPrefs = new GenericUserPreferenceArray(length - 1);
1:e2620d3:             for (int i = 0, j = 0; i < length; i++, j++) {
1:e2620d3:               if (prefs.getItemID(i) == itemID) {
1:e2620d3:                 j--;
1:e2620d3:               } else {
1:e2620d3:                 newPrefs.set(j, prefs.get(i));
1:e2620d3:               }
1:e2620d3:             }
1:e2620d3:             rawData.put(userID, newPrefs);
1:e2620d3:           }
1:e2620d3:           log.info("Removing userID: {} itemID: {}", userID, itemID);
1:e2620d3:           if (mongoManage) {
1:e2620d3:             removeMongoUserItem(Long.toString(userID), Long.toString(itemID));
1:e2620d3:           }
1:e2620d3:         }
1:e2620d3:       }
1:e2620d3:     }
1:e2620d3:     return new GenericDataModel(rawData);
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   private DataModel addUserItem(long userID, Iterable<List<String>> items) {
1:e2620d3:     FastByIDMap<PreferenceArray> rawData = ((GenericDataModel) delegate).getRawUserData();
1:e2620d3:     PreferenceArray prefs = rawData.get(userID);
1:e2620d3:     for (List<String> item : items) {
1:e2620d3:       long itemID = Long.parseLong(item.get(0));
1:e2620d3:       float preferenceValue = Float.parseFloat(item.get(1));
1:e2620d3:       boolean exists = false;
1:e2620d3:       if (prefs != null) {
1:e2620d3:         for (int i = 0; i < prefs.length(); i++) {
1:e2620d3:           if (prefs.getItemID(i) == itemID) {
1:e2620d3:             exists = true;
1:e2620d3:             prefs.setValue(i, preferenceValue);
1:e2620d3:             break;
1:e2620d3:           }
1:e2620d3:         }
1:e2620d3:       }
1:e2620d3:       if (!exists) {
1:e2620d3:         if (prefs == null) {
1:e2620d3:           prefs = new GenericUserPreferenceArray(1);
1:e2620d3:         } else {
1:e2620d3:           PreferenceArray newPrefs = new GenericUserPreferenceArray(prefs.length() + 1);
1:e2620d3:           for (int i = 0, j = 1; i < prefs.length(); i++, j++) {
1:e2620d3:             newPrefs.set(j, prefs.get(i));
1:e2620d3:           }
1:e2620d3:           prefs = newPrefs;
1:e2620d3:         }
1:e2620d3:         prefs.setUserID(0, userID);
1:e2620d3:         prefs.setItemID(0, itemID);
1:e2620d3:         prefs.setValue(0, preferenceValue);
1:8396a27:         log.info("Adding userID: {} itemID: {} preferenceValue: {}", userID, itemID, preferenceValue);
1:e2620d3:         rawData.put(userID, prefs);
1:e2620d3:         if (mongoManage) {
1:e2620d3:           addMongoUserItem(Long.toString(userID),
1:e2620d3:                            Long.toString(itemID),
1:e2620d3:                            Float.toString(preferenceValue));
1:e2620d3:         }
1:e2620d3:       }
1:e2620d3:     }
1:e2620d3:     return new GenericDataModel(rawData);
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   private Date getDate(Object date) {
1:e2620d3:     if (date.getClass().getName().contains("Date")) {
1:e2620d3:       return (Date) date;
1:4194a28:     }
1:4194a28:     if (date.getClass().getName().contains("String")) {
1:e2620d3:       try {
1:1499411:         synchronized (dateFormat) {
1:1499411:           return dateFormat.parse(date.toString());
1:1499411:         }
1:e2620d3:       } catch (ParseException ioe) {
1:e2620d3:         log.warn("Error parsing timestamp", ioe);
1:e2620d3:       }
1:e2620d3:     }
1:e2620d3:     return new Date(0);
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   private float getPreference(Object value) {
1:e2620d3:     if (value != null) {
1:e2620d3:       if (value.getClass().getName().contains("String")) {
1:e2620d3:         preferenceIsString = true;
1:89720ce:         return Float.parseFloat(value.toString());
1:e2620d3:       } else {
1:e2620d3:         preferenceIsString = false;
1:e2620d3:         return Double.valueOf(value.toString()).floatValue();
1:e2620d3:       }
1:e2620d3:     } else {
1:e2620d3:       return 0.5f;
1:e2620d3:     }
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   private String getID(Object id, boolean isUser) {
1:e2620d3:     if (id.getClass().getName().contains("ObjectId")) {
1:e2620d3:       if (isUser) {
1:e2620d3:         userIsObject = true;
1:e2620d3:       } else {
1:e2620d3:         itemIsObject = true;
1:e2620d3:       }
1:e2620d3:       return ((ObjectId) id).toStringMongod();
1:e2620d3:     } else {
1:89720ce:       return id.toString();
1:e2620d3:     }
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   private void checkData(String userID,
1:e2620d3:                          Iterable<List<String>> items,
1:e2620d3:                          boolean add) throws NoSuchUserException, NoSuchItemException {
1:e2620d3:     Preconditions.checkNotNull(userID);
1:e2620d3:     Preconditions.checkNotNull(items);
1:cd167f9:     Preconditions.checkArgument(!userID.isEmpty(), "userID is empty");
1:e2620d3:     for (List<String> item : items) {
1:e2620d3:       Preconditions.checkNotNull(item.get(0));
1:cd167f9:       Preconditions.checkArgument(!item.get(0).isEmpty(), "item is empty");
1:e2620d3:     }
1:e2620d3:     if (userIsObject && !ID_PATTERN.matcher(userID).matches()) {
1:e2620d3:       throw new IllegalArgumentException();
1:e2620d3:     }
1:e2620d3:     for (List<String> item : items) {
1:e2620d3:       if (itemIsObject && !ID_PATTERN.matcher(item.get(0)).matches()) {
1:e2620d3:         throw new IllegalArgumentException();
1:e2620d3:       }
1:e2620d3:     }
1:e2620d3:     if (!add && !isIDInModel(userID)) {
1:e2620d3:       throw new NoSuchUserException();
1:e2620d3:     }
1:e2620d3:     for (List<String> item : items) {
1:e2620d3:       if (!add && !isIDInModel(item.get(0))) {
1:e2620d3:         throw new NoSuchItemException();
1:e2620d3:       }
1:e2620d3:     }
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   /**
1:b5c65a5:    * Cleanup mapping collection.
1:b5c65a5:    */
1:b5c65a5:   public void cleanupMappingCollection() {
1:b5c65a5:     collectionMap.drop();
1:b5c65a5:   }
1:b5c65a5: 
1:e2620d3:   @Override
1:e2620d3:   public LongPrimitiveIterator getUserIDs() throws TasteException {
1:e2620d3:     return delegate.getUserIDs();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public PreferenceArray getPreferencesFromUser(long id) throws TasteException {
1:e2620d3:     return delegate.getPreferencesFromUser(id);
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public FastIDSet getItemIDsFromUser(long userID) throws TasteException {
1:e2620d3:     return delegate.getItemIDsFromUser(userID);
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public LongPrimitiveIterator getItemIDs() throws TasteException {
1:e2620d3:     return delegate.getItemIDs();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public PreferenceArray getPreferencesForItem(long itemID) throws TasteException {
1:e2620d3:     return delegate.getPreferencesForItem(itemID);
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public Float getPreferenceValue(long userID, long itemID) throws TasteException {
1:e2620d3:     return delegate.getPreferenceValue(userID, itemID);
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public Long getPreferenceTime(long userID, long itemID) throws TasteException {
1:e2620d3:     return delegate.getPreferenceTime(userID, itemID);
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public int getNumItems() throws TasteException {
1:e2620d3:     return delegate.getNumItems();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public int getNumUsers() throws TasteException {
1:e2620d3:     return delegate.getNumUsers();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:68f00b0:   public int getNumUsersWithPreferenceFor(long itemID) throws TasteException {
1:68f00b0:     return delegate.getNumUsersWithPreferenceFor(itemID);
1:68f00b0:   }
1:68f00b0: 
1:68f00b0:   @Override
1:68f00b0:   public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException {
1:68f00b0:     return delegate.getNumUsersWithPreferenceFor(itemID1, itemID2);
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public void setPreference(long userID, long itemID, float value) {
1:e2620d3:     throw new UnsupportedOperationException();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public void removePreference(long userID, long itemID) {
1:e2620d3:     throw new UnsupportedOperationException();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public boolean hasPreferenceValues() {
1:e2620d3:     return delegate.hasPreferenceValues();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public float getMaxPreference() {
1:e2620d3:     return delegate.getMaxPreference();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public float getMinPreference() {
1:e2620d3:     return delegate.getMinPreference();
1:e2620d3:   }
1:e2620d3: 
1:e2620d3:   @Override
1:e2620d3:   public String toString() {
1:e2620d3:     return "MongoDBDataModel";
1:e2620d3:   }
1:e2620d3: 
1:e2620d3: }
============================================================================
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:85f9ece
/////////////////////////////////////////////////////////////////////////
1: import com.mongodb.BasicDBObject;
1: import com.mongodb.DB;
1: import com.mongodb.DBCollection;
1: import com.mongodb.DBCursor;
1: import com.mongodb.DBObject;
1: import com.mongodb.Mongo;
1: import org.apache.mahout.cf.taste.common.NoSuchItemException;
1: import org.apache.mahout.cf.taste.common.NoSuchUserException;
/////////////////////////////////////////////////////////////////////////
1: import java.net.UnknownHostException;
1: import java.text.DateFormat;
1: import java.text.ParseException;
1: import java.text.SimpleDateFormat;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Date;
1: import java.util.List;
1: import java.util.Locale;
1: import java.util.Map;
1: import java.util.concurrent.locks.ReentrantLock;
1: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
1:       Collection<List<String>> items = new ArrayList<>();
1:       List<String> item = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         Collection<List<String>> items = new ArrayList<>();
1:         List<String> item = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:     FastByIDMap<Collection<Preference>> userIDPrefMap = new FastByIDMap<>();
/////////////////////////////////////////////////////////////////////////
1:             userPrefs = new ArrayList<>(2);
author:smarthi
-------------------------------------------------------------------------------
commit:cd167f9
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkArgument(!userID.isEmpty(), "userID is empty");
1:       Preconditions.checkArgument(!item.get(0).isEmpty(), "item is empty");
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:4ca6b86
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   public MongoDBDataModel() throws UnknownHostException {
/////////////////////////////////////////////////////////////////////////
1:                           DateFormat format) throws UnknownHostException {
/////////////////////////////////////////////////////////////////////////
1:                           String mappingCollection) throws UnknownHostException {
/////////////////////////////////////////////////////////////////////////
1:                           String password) throws UnknownHostException {
/////////////////////////////////////////////////////////////////////////
1:                           String mappingCollection) throws UnknownHostException {
/////////////////////////////////////////////////////////////////////////
1:     Date ts = new Date(0);
/////////////////////////////////////////////////////////////////////////
1:   private void buildModel() throws UnknownHostException {
commit:8396a27
/////////////////////////////////////////////////////////////////////////
1:                isUser ? "User ID" : "Item ID", id, longValue);
/////////////////////////////////////////////////////////////////////////
1:       log.info("Adding userID: {} itemID: {} preferenceValue: {}", userID, itemID, preferenceValue);
/////////////////////////////////////////////////////////////////////////
1:         log.info("Adding userID: {} itemID: {} preferenceValue: {}", userID, itemID, preferenceValue);
commit:b5c65a5
/////////////////////////////////////////////////////////////////////////
1:   public static final String DEFAULT_MONGO_MAP_COLLECTION = "mongo_data_model_map";
/////////////////////////////////////////////////////////////////////////
1:   /** MongoDB mapping table/collection */
1:   private String mongoMapCollection = DEFAULT_MONGO_MAP_COLLECTION;
/////////////////////////////////////////////////////////////////////////
1:                           String preferenceField,
0:                           String mappingCollection) throws UnknownHostException, MongoException {
/////////////////////////////////////////////////////////////////////////
1:     mongoMapCollection = mappingCollection;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                           String preferenceField,
0:                           String mappingCollection) throws UnknownHostException, MongoException {
/////////////////////////////////////////////////////////////////////////
1:     mongoMapCollection = mappingCollection;
/////////////////////////////////////////////////////////////////////////
1:       collectionMap = db.getCollection(mongoMapCollection);
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Cleanup mapping collection.
1:    */
1:   public void cleanupMappingCollection() {
1:     collectionMap.drop();
1:   }
1: 
commit:15925a5
/////////////////////////////////////////////////////////////////////////
1:  * <p>{@code { "_id" : ObjectId("4d7627bf6c7d47ade9fc7780"),
commit:e0ec7c1
/////////////////////////////////////////////////////////////////////////
0:     Preconditions.checkArgument(!userID.isEmpty());
0:       Preconditions.checkArgument(!item.get(0).isEmpty());
commit:4194a28
/////////////////////////////////////////////////////////////////////////
1:     }
1:     if (date.getClass().getName().contains("String")) {
commit:1499411
/////////////////////////////////////////////////////////////////////////
1:         synchronized (dateFormat) {
1:           return dateFormat.parse(date.toString());
1:         }
commit:89720ce
/////////////////////////////////////////////////////////////////////////
1:       Object value = idLong.get("long_value");
1:       return value == null ? null : value.toString();
/////////////////////////////////////////////////////////////////////////
1:     Object value = idLong.get("element_id");
1:     return value == null ? null : value.toString();
/////////////////////////////////////////////////////////////////////////
0:         return dateFormat.parse(date.toString());
/////////////////////////////////////////////////////////////////////////
1:         return Float.parseFloat(value.toString());
/////////////////////////////////////////////////////////////////////////
1:       return id.toString();
commit:68f00b0
/////////////////////////////////////////////////////////////////////////
1:   public int getNumUsersWithPreferenceFor(long itemID) throws TasteException {
1:     return delegate.getNumUsersWithPreferenceFor(itemID);
1:   }
1: 
1:   @Override
1:   public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException {
1:     return delegate.getNumUsersWithPreferenceFor(itemID1, itemID2);
commit:9d93d27
/////////////////////////////////////////////////////////////////////////
0:     Preconditions.checkArgument(userID.length() > 0);
0:       Preconditions.checkArgument(item.get(0).length() > 0);
commit:e2620d3
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.cf.taste.impl.model.mongodb;
1: 
0: import java.text.DateFormat;
0: import java.text.ParseException;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.Date;
0: import java.util.List;
0: import java.util.Locale;
0: import java.util.Map;
0: import java.util.concurrent.locks.ReentrantLock;
0: import java.net.UnknownHostException;
0: import java.text.SimpleDateFormat;
0: import java.util.regex.Pattern;
1: 
1: import com.google.common.base.Preconditions;
1: import org.apache.mahout.cf.taste.common.Refreshable;
1: import org.apache.mahout.cf.taste.common.TasteException;
1: import org.apache.mahout.cf.taste.impl.common.FastByIDMap;
1: import org.apache.mahout.cf.taste.impl.common.FastIDSet;
1: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1: import org.apache.mahout.cf.taste.impl.model.GenericDataModel;
1: import org.apache.mahout.cf.taste.impl.model.GenericPreference;
1: import org.apache.mahout.cf.taste.impl.model.GenericUserPreferenceArray;
1: import org.apache.mahout.cf.taste.model.DataModel;
1: import org.apache.mahout.cf.taste.model.Preference;
1: import org.apache.mahout.cf.taste.model.PreferenceArray;
0: import org.apache.mahout.cf.taste.common.NoSuchUserException;
0: import org.apache.mahout.cf.taste.common.NoSuchItemException;
1: 
1: import org.bson.types.ObjectId;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: import com.mongodb.BasicDBObject;
0: import com.mongodb.DBObject;
0: import com.mongodb.Mongo;
0: import com.mongodb.DB;
0: import com.mongodb.DBCollection;
0: import com.mongodb.DBCursor;
0: import com.mongodb.MongoException;
1: 
1: /**
1:  * <p>A {@link DataModel} backed by a MongoDB database. This class expects a
1:  * collection in the database which contains a user ID ({@code long} or
1:  * {@link ObjectId}), item ID ({@code long} or
1:  * {@link ObjectId}), preference value (optional) and timestamps
1:  * ("created_at", "deleted_at").</p>
1:  *
1:  * <p>An example of a document in MongoDB:</p>
1:  *
0:  * <p>{@code{ "_id" : ObjectId("4d7627bf6c7d47ade9fc7780"),
1:  * "user_id" : ObjectId("4c2209fef3924d31102bd84b"),
1:  * "item_id" : ObjectId(4c2209fef3924d31202bd853),
1:  * "preference" : 0.5,
1:  * "created_at" : "Tue Mar 23 2010 20:48:43 GMT-0400 (EDT)" }
1:  * }</p>
1:  *
1:  * <p>Preference value is optional to accommodate applications that have no notion
1:  * of a preference value (that is, the user simply expresses a preference for
1:  * an item, but no degree of preference).</p>
1:  *
1:  * <p>The preference value is assumed to be parseable as a {@code double}.</p>
1:  *
1:  * <p>The user IDs and item IDs are assumed to be parseable as {@code long}s
1:  * or {@link ObjectId}s. In case of {@link ObjectId}s, the
1:  * model creates a {@code Map<ObjectId>}, {@code long}>
1:  * (collection "mongo_data_model_map") inside the MongoDB database. This
1:  * conversion is needed since Mahout uses the long datatype to feed the
1:  * recommender, and MongoDB uses 12 bytes to create its identifiers.</p>
1:  *
1:  * <p>The timestamps ("created_at", "deleted_at"), if present, are assumed to be
1:  * parseable as a {@code long} or {@link Date}. To express
1:  * timestamps as {@link Date}s, a {@link DateFormat}
1:  * must be provided in the class constructor. The default Date format is
1:  * {@code "EE MMM dd yyyy HH:mm:ss 'GMT'Z (zzz)"}. If this parameter
1:  * is set to null, timestamps are assumed to be parseable as {@code long}s.
1:  * </p>
1:  *
1:  * <p>It is also acceptable for the documents to contain additional fields.
1:  * Those fields will be ignored.</p>
1:  *
1:  * <p>This class will reload data from the MondoDB database when
1:  * {@link #refresh(Collection)} is called. MongoDBDataModel keeps the
1:  * timestamp of the last update. This variable and the fields "created_at"
1:  * and "deleted_at" help the model to determine if the triple
1:  * (user, item, preference) must be added or deleted.</p>
1:  */
1: public final class MongoDBDataModel implements DataModel {
1: 
1:   private static final Logger log = LoggerFactory.getLogger(MongoDBDataModel.class);
1: 
1:   /** Default MongoDB host. Default: localhost */
1:   private static final String DEFAULT_MONGO_HOST = "localhost";
1: 
1:   /** Default MongoDB port. Default: 27017 */
1:   private static final int DEFAULT_MONGO_PORT = 27017;
1: 
1:   /** Default MongoDB database. Default: recommender */
1:   private static final String DEFAULT_MONGO_DB = "recommender";
1: 
1:   /**
1:    * Default MongoDB authentication flag.
1:    * Default: false (authentication is not required)
1:    */
1:   private static final boolean DEFAULT_MONGO_AUTH = false;
1: 
1:   /** Default MongoDB user. Default: recommender */
1:   private static final String DEFAULT_MONGO_USERNAME = "recommender";
1: 
1:   /** Default MongoDB password. Default: recommender */
1:   private static final String DEFAULT_MONGO_PASSWORD = "recommender";
1: 
1:   /** Default MongoDB table/collection. Default: items */
1:   private static final String DEFAULT_MONGO_COLLECTION = "items";
1: 
1:   /**
1:    * Default MongoDB update flag. When this flag is activated, the
1:    * DataModel updates both model and database. Default: true
1:    */
1:   private static final boolean DEFAULT_MONGO_MANAGE = true;
1: 
1:   /** Default MongoDB user ID field. Default: user_id */
1:   private static final String DEFAULT_MONGO_USER_ID = "user_id";
1: 
1:   /** Default MongoDB item ID field. Default: item_id */
1:   private static final String DEFAULT_MONGO_ITEM_ID = "item_id";
1: 
1:   /** Default MongoDB preference value field. Default: preference */
1:   private static final String DEFAULT_MONGO_PREFERENCE = "preference";
1: 
1:   /** Default MongoDB final remove flag. Default: false */
1:   private static final boolean DEFAULT_MONGO_FINAL_REMOVE = false;
1: 
1:   /**
1:    * Default MongoDB date format.
1:    * Default: "EE MMM dd yyyy HH:mm:ss 'GMT'Z (zzz)"
1:    */
1:   private static final DateFormat DEFAULT_DATE_FORMAT =
1:       new SimpleDateFormat("EE MMM dd yyyy HH:mm:ss 'GMT'Z (zzz)", Locale.ENGLISH);
1: 
0:   private static final String MONGO_MAP_COLLECTION = "mongo_data_model_map";
1: 
1:   private static final Pattern ID_PATTERN = Pattern.compile("[a-f0-9]{24}");
1: 
1:   /** MongoDB host */
1:   private String mongoHost = DEFAULT_MONGO_HOST;
1:   /** MongoDB port */
1:   private int mongoPort = DEFAULT_MONGO_PORT;
1:   /** MongoDB database */
1:   private String mongoDB = DEFAULT_MONGO_DB;
1:   /**
1:    * MongoDB authentication flag. If this flag is set to false,
1:    * authentication is not required.
1:    */
1:   private boolean mongoAuth = DEFAULT_MONGO_AUTH;
1:   /** MongoDB user */
1:   private String mongoUsername = DEFAULT_MONGO_USERNAME;
1:   /** MongoDB pass */
1:   private String mongoPassword = DEFAULT_MONGO_PASSWORD;
1:   /** MongoDB table/collection */
1:   private String mongoCollection = DEFAULT_MONGO_COLLECTION;
1:   /**
1:    * MongoDB update flag. When this flag is activated, the
1:    * DataModel updates both model and database
1:    */
1:   private boolean mongoManage = DEFAULT_MONGO_MANAGE;
1:   /** MongoDB user ID field */
1:   private String mongoUserID = DEFAULT_MONGO_USER_ID;
1:   /** MongoDB item ID field */
1:   private String mongoItemID = DEFAULT_MONGO_ITEM_ID;
1:   /** MongoDB preference value field */
1:   private String mongoPreference = DEFAULT_MONGO_PREFERENCE;
1:   /** MongoDB final remove flag. Default: false */
1:   private boolean mongoFinalRemove = DEFAULT_MONGO_FINAL_REMOVE;
1:   /** MongoDB date format */
1:   private DateFormat dateFormat = DEFAULT_DATE_FORMAT;
1:   private DBCollection collection;
1:   private DBCollection collectionMap;
1:   private Date mongoTimestamp;
1:   private final ReentrantLock reloadLock;
1:   private DataModel delegate;
1:   private boolean userIsObject;
1:   private boolean itemIsObject;
1:   private boolean preferenceIsString;
1:   private long idCounter;
1: 
1:   /**
1:    * Creates a new MongoDBDataModel
1:    */
0:   public MongoDBDataModel() throws UnknownHostException, MongoException {
1:     this.reloadLock = new ReentrantLock();
1:     buildModel();
1:   }
1: 
1:   /**
1:    * Creates a new MongoDBDataModel with MongoDB basic configuration
1:    * (without authentication)
1:    *
1:    * @param host        MongoDB host.
1:    * @param port        MongoDB port. Default: 27017
1:    * @param database    MongoDB database
1:    * @param collection  MongoDB collection/table
1:    * @param manage      If true, the model adds and removes users and items
1:    *                    from MongoDB database when the model is refreshed.
1:    * @param finalRemove If true, the model removes the user/item completely
1:    *                    from the MongoDB database. If false, the model adds the "deleted_at"
1:    *                    field with the current date to the "deleted" user/item.
1:    * @param format      MongoDB date format. If null, the model uses timestamps.
1:    * @throws UnknownHostException if the database host cannot be resolved
1:    */
1:   public MongoDBDataModel(String host,
1:                           int port,
1:                           String database,
1:                           String collection,
1:                           boolean manage,
1:                           boolean finalRemove,
0:                           DateFormat format) throws UnknownHostException, MongoException {
1:     mongoHost = host;
1:     mongoPort = port;
1:     mongoDB = database;
1:     mongoCollection = collection;
1:     mongoManage = manage;
1:     mongoFinalRemove = finalRemove;
1:     dateFormat = format;
1:     this.reloadLock = new ReentrantLock();
1:     buildModel();
1:   }
1: 
1:   /**
1:    * Creates a new MongoDBDataModel with MongoDB advanced configuration
1:    * (without authentication)
1:    *
1:    * @param userIDField     Mongo user ID field
1:    * @param itemIDField     Mongo item ID field
1:    * @param preferenceField Mongo preference value field
1:    * @throws UnknownHostException if the database host cannot be resolved
1:    * @see #MongoDBDataModel(String, int, String, String, boolean, boolean, DateFormat)
1:    */
1:   public MongoDBDataModel(String host,
1:                           int port,
1:                           String database,
1:                           String collection,
1:                           boolean manage,
1:                           boolean finalRemove,
1:                           DateFormat format,
1:                           String userIDField,
1:                           String itemIDField,
0:                           String preferenceField) throws UnknownHostException, MongoException {
1:     mongoHost = host;
1:     mongoPort = port;
1:     mongoDB = database;
1:     mongoCollection = collection;
1:     mongoManage = manage;
1:     mongoFinalRemove = finalRemove;
1:     dateFormat = format;
1:     mongoUserID = userIDField;
1:     mongoItemID = itemIDField;
1:     mongoPreference = preferenceField;
1:     this.reloadLock = new ReentrantLock();
1:     buildModel();
1:   }
1: 
1:   /**
1:    * Creates a new MongoDBDataModel with MongoDB basic configuration
1:    * (with authentication)
1:    *
1:    * @param user     Mongo username (authentication)
1:    * @param password Mongo password (authentication)
1:    * @throws UnknownHostException if the database host cannot be resolved
1:    * @see #MongoDBDataModel(String, int, String, String, boolean, boolean, DateFormat)
1:    */
1:   public MongoDBDataModel(String host,
1:                           int port,
1:                           String database,
1:                           String collection,
1:                           boolean manage,
1:                           boolean finalRemove,
1:                           DateFormat format,
1:                           String user,
0:                           String password) throws UnknownHostException, MongoException {
1:     mongoHost = host;
1:     mongoPort = port;
1:     mongoDB = database;
1:     mongoCollection = collection;
1:     mongoManage = manage;
1:     mongoFinalRemove = finalRemove;
1:     dateFormat = format;
1:     mongoAuth = true;
1:     mongoUsername = user;
1:     mongoPassword = password;
1:     this.reloadLock = new ReentrantLock();
1:     buildModel();
1:   }
1: 
1:   /**
1:    * Creates a new MongoDBDataModel with MongoDB advanced configuration
1:    * (with authentication)
1:    *
1:    * @throws UnknownHostException if the database host cannot be resolved
0:    * @see #MongoDBDataModel(String, int, String, String, boolean, boolean, DateFormat, String, String, String)
1:    * @see #MongoDBDataModel(String, int, String, String, boolean, boolean, DateFormat, String, String)
1:    */
1:   public MongoDBDataModel(String host,
1:                           int port,
1:                           String database,
1:                           String collection,
1:                           boolean manage,
1:                           boolean finalRemove,
1:                           DateFormat format,
1:                           String user,
1:                           String password,
1:                           String userIDField,
1:                           String itemIDField,
0:                           String preferenceField) throws UnknownHostException, MongoException {
1:     mongoHost = host;
1:     mongoPort = port;
1:     mongoDB = database;
1:     mongoCollection = collection;
1:     mongoManage = manage;
1:     mongoFinalRemove = finalRemove;
1:     dateFormat = format;
1:     mongoAuth = true;
1:     mongoUsername = user;
1:     mongoPassword = password;
1:     mongoUserID = userIDField;
1:     mongoItemID = itemIDField;
1:     mongoPreference = preferenceField;
1:     this.reloadLock = new ReentrantLock();
1:     buildModel();
1:   }
1: 
1:   /**
1:    * <p>
1:    * Adds/removes (user, item) pairs to/from the model.
1:    * </p>
1:    *
1:    * @param userID MongoDB user identifier
1:    * @param items  List of pairs (item, preference) which want to be added or
1:    *               deleted
1:    * @param add    If true, this flag indicates that the    pairs (user, item)
1:    *               must be added to the model. If false, it indicates deletion.
1:    * @see #refresh(Collection)
1:    */
1:   public void refreshData(String userID,
1:                           Iterable<List<String>> items,
1:                           boolean add) throws NoSuchUserException, NoSuchItemException {
1:     checkData(userID, items, add);
1:     long id = Long.parseLong(fromIdToLong(userID, true));
1:     for (List<String> item : items) {
1:       item.set(0, fromIdToLong(item.get(0), false));
1:     }
1:     if (reloadLock.tryLock()) {
1:       try {
1:         if (add) {
1:           delegate = addUserItem(id, items);
1:         } else {
1:           delegate = removeUserItem(id, items);
1:         }
1:       } finally {
1:         reloadLock.unlock();
1:       }
1:     }
1:   }
1: 
1: 
1:   /**
1:    * <p>
1:    * Triggers "refresh" -- whatever that means -- of the implementation.
1:    * The general contract is that any should always leave itself in a
1:    * consistent, operational state, and that the refresh atomically updates
1:    * internal state from old to new.
1:    * </p>
1:    *
1:    * @param alreadyRefreshed s that are known to have already been refreshed as
1:    *                         a result of an initial call to a method on some object. This ensures
1:    *                         that objects in a refresh dependency graph aren't refreshed twice
1:    *                         needlessly.
1:    * @see #refreshData(String, Iterable, boolean)
1:    */
1:   @Override
1:   public void refresh(Collection<Refreshable> alreadyRefreshed) {
0:     Date ts = new Date(0);
1:     BasicDBObject query = new BasicDBObject();
1:     query.put("deleted_at", new BasicDBObject("$gt", mongoTimestamp));
1:     DBCursor cursor = collection.find(query);
1:     while (cursor.hasNext()) {
1:       Map<String,Object> user = (Map<String,Object>) cursor.next().toMap();
1:       String userID = getID(user.get(mongoUserID), true);
0:       Collection<List<String>> items = new ArrayList<List<String>>();
0:       List<String> item = new ArrayList<String>();
1:       item.add(getID(user.get(mongoItemID), false));
1:       item.add(Float.toString(getPreference(user.get(mongoPreference))));
1:       items.add(item);
1:       try {
1:         refreshData(userID, items, false);
1:       } catch (NoSuchUserException e) {
1:         log.warn("No such user ID: {}", userID);
1:       } catch (NoSuchItemException e) {
1:         log.warn("No such items: {}", items);
1:       }
1:       if (ts.compareTo(getDate(user.get("created_at"))) < 0) {
1:         ts = getDate(user.get("created_at"));
1:       }
1:     }
1:     query = new BasicDBObject();
1:     query.put("created_at", new BasicDBObject("$gt", mongoTimestamp));
1:     cursor = collection.find(query);
1:     while (cursor.hasNext()) {
1:       Map<String,Object> user = (Map<String,Object>) cursor.next().toMap();
1:       if (!user.containsKey("deleted_at")) {
1:         String userID = getID(user.get(mongoUserID), true);
0:         Collection<List<String>> items = new ArrayList<List<String>>();
0:         List<String> item = new ArrayList<String>();
1:         item.add(getID(user.get(mongoItemID), false));
1:         item.add(Float.toString(getPreference(user.get(mongoPreference))));
1:         items.add(item);
1:         try {
1:           refreshData(userID, items, true);
1:         } catch (NoSuchUserException e) {
1:           log.warn("No such user ID: {}", userID);
1:         } catch (NoSuchItemException e) {
1:           log.warn("No such items: {}", items);
1:         }
1:         if (ts.compareTo(getDate(user.get("created_at"))) < 0) {
1:           ts = getDate(user.get("created_at"));
1:         }
1:       }
1:     }
1:     if (mongoTimestamp.compareTo(ts) < 0) {
1:       mongoTimestamp = ts;
1:     }
1:   }
1: 
1:   /**
1:    * <p>
1:    * Translates the MongoDB identifier to Mahout/MongoDBDataModel's internal
1:    * identifier, if required.
1:    * </p>
1:    * <p>
1:    * If MongoDB identifiers are long datatypes, it returns the id.
1:    * </p>
1:    * <p>
1:    * This conversion is needed since Mahout uses the long datatype to feed the
1:    * recommender, and MongoDB uses 12 bytes to create its identifiers.
1:    * </p>
1:    *
1:    * @param id     MongoDB identifier
1:    * @param isUser
1:    * @return String containing the translation of the external MongoDB ID to
1:    *         internal long ID (mapping).
1:    * @see #fromLongToId(long)
1:    * @see <a href="http://www.mongodb.org/display/DOCS/Object%20IDs">
1:    *      Mongo Object IDs</a>
1:    */
1:   public String fromIdToLong(String id, boolean isUser) {
1:     DBObject objectIdLong = collectionMap.findOne(new BasicDBObject("element_id", id));
1:     if (objectIdLong != null) {
1:       Map<String,Object> idLong = (Map<String,Object>) objectIdLong.toMap();
0:       return (String) idLong.get("long_value");
1:     } else {
1:       objectIdLong = new BasicDBObject();
1:       String longValue = Long.toString(idCounter++);
1:       objectIdLong.put("element_id", id);
1:       objectIdLong.put("long_value", longValue);
1:       collectionMap.insert(objectIdLong);
1:       log.info("Adding Translation {}: {} long_value: {}",
0:                new Object[] {isUser ? "User ID" : "Item ID", id, longValue});
1:       return longValue;
1:     }
1:   }
1: 
1:   /**
1:    * <p>
1:    * Translates the Mahout/MongoDBDataModel's internal identifier to MongoDB
1:    * identifier, if required.
1:    * </p>
1:    * <p>
1:    * If MongoDB identifiers are long datatypes, it returns the id in String
1:    * format.
1:    * </p>
1:    * <p>
1:    * This conversion is needed since Mahout uses the long datatype to feed the
1:    * recommender, and MongoDB uses 12 bytes to create its identifiers.
1:    * </p>
1:    *
1:    * @param id Mahout's internal identifier
1:    * @return String containing the translation of the internal long ID to
1:    *         external MongoDB ID (mapping).
1:    * @see #fromIdToLong(String, boolean)
1:    * @see <a href="http://www.mongodb.org/display/DOCS/Object%20IDs">
1:    *      Mongo Object IDs</a>
1:    */
1:   public String fromLongToId(long id) {
1:     DBObject objectIdLong = collectionMap.findOne(new BasicDBObject("long_value", Long.toString(id)));
1:     Map<String,Object> idLong = (Map<String,Object>) objectIdLong.toMap();
0:     return (String) idLong.get("element_id");
1:   }
1: 
1:   /**
1:    * <p>
1:    * Checks if an ID is currently in the model.
1:    * </p>
1:    *
1:    * @param ID user or item ID
1:    * @return true: if ID is into the model; false: if it's not.
1:    */
1:   public boolean isIDInModel(String ID) {
1:     DBObject objectIdLong = collectionMap.findOne(new BasicDBObject("element_id", ID));
1:     return objectIdLong != null;
1:   }
1: 
1:   /**
1:    * <p>
1:    * Date of the latest update of the model.
1:    * </p>
1:    *
1:    * @return Date with the latest update of the model.
1:    */
1:   public Date mongoUpdateDate() {
1:     return mongoTimestamp;
1:   }
1: 
0:   private void buildModel() throws UnknownHostException, MongoException {
1:     userIsObject = false;
1:     itemIsObject = false;
1:     idCounter = 0;
1:     preferenceIsString = true;
1:     Mongo mongoDDBB = new Mongo(mongoHost, mongoPort);
1:     DB db = mongoDDBB.getDB(mongoDB);
1:     mongoTimestamp = new Date(0);
0:     FastByIDMap<Collection<Preference>> userIDPrefMap = new FastByIDMap<Collection<Preference>>();
0:     if (!mongoAuth || (mongoAuth && db.authenticate(mongoUsername, mongoPassword.toCharArray()))) {
1:       collection = db.getCollection(mongoCollection);
0:       collectionMap = db.getCollection(MONGO_MAP_COLLECTION);
1:       DBObject indexObj = new BasicDBObject();
1:       indexObj.put("element_id", 1);
1:       collectionMap.ensureIndex(indexObj);
1:       indexObj = new BasicDBObject();
1:       indexObj.put("long_value", 1);
1:       collectionMap.ensureIndex(indexObj);
1:       collectionMap.remove(new BasicDBObject());
1:       DBCursor cursor = collection.find();
1:       while (cursor.hasNext()) {
1:         Map<String,Object> user = (Map<String,Object>) cursor.next().toMap();
1:         if (!user.containsKey("deleted_at")) {
1:           long userID = Long.parseLong(fromIdToLong(getID(user.get(mongoUserID), true), true));
1:           long itemID = Long.parseLong(fromIdToLong(getID(user.get(mongoItemID), false), false));
1:           float ratingValue = getPreference(user.get(mongoPreference));
1:           Collection<Preference> userPrefs = userIDPrefMap.get(userID);
1:           if (userPrefs == null) {
0:             userPrefs = new ArrayList<Preference>(2);
1:             userIDPrefMap.put(userID, userPrefs);
1:           }
1:           userPrefs.add(new GenericPreference(userID, itemID, ratingValue));
0:           if (user.containsKey("created_at") &&
0:               mongoTimestamp.compareTo(getDate(user.get("created_at"))) < 0) {
1:             mongoTimestamp = getDate(user.get("created_at"));
1:           }
1:         }
1:       }
1:     }
1:     delegate = new GenericDataModel(GenericDataModel.toDataMap(userIDPrefMap, true));
1:   }
1: 
1:   private void removeMongoUserItem(String userID, String itemID) {
1:     String userId = fromLongToId(Long.parseLong(userID));
1:     String itemId = fromLongToId(Long.parseLong(itemID));
1:     if (isUserItemInDB(userId, itemId)) {
1:       mongoTimestamp = new Date();
1:       BasicDBObject query = new BasicDBObject();
1:       query.put(mongoUserID, userIsObject ? new ObjectId(userId) : userId);
1:       query.put(mongoItemID, itemIsObject ? new ObjectId(itemId) : itemId);
1:       if (mongoFinalRemove) {
1:         log.info(collection.remove(query).toString());
1:       } else {
1:         BasicDBObject update = new BasicDBObject();
1:         update.put("$set", new BasicDBObject("deleted_at", mongoTimestamp));
1:         log.info(collection.update(query, update).toString());
1:       }
1:       log.info("Removing userID: {} itemID: {}", userID, itemId);
1:     }
1:   }
1: 
1:   private void addMongoUserItem(String userID, String itemID, String preferenceValue) {
1:     String userId = fromLongToId(Long.parseLong(userID));
1:     String itemId = fromLongToId(Long.parseLong(itemID));
1:     if (!isUserItemInDB(userId, itemId)) {
1:       mongoTimestamp = new Date();
1:       BasicDBObject user = new BasicDBObject();
1:       Object userIdObject = userIsObject ? new ObjectId(userId) : userId;
1:       Object itemIdObject = itemIsObject ? new ObjectId(itemId) : itemId;
1:       user.put(mongoUserID, userIdObject);
1:       user.put(mongoItemID, itemIdObject);
1:       user.put(mongoPreference, preferenceIsString ? preferenceValue : Double.parseDouble(preferenceValue));
1:       user.put("created_at", mongoTimestamp);
1:       collection.insert(user);
0:       log.info("Adding userID: {} itemID: {} preferenceValue: {}", new Object[] {userID, itemID, preferenceValue});
1:     }
1:   }
1: 
1:   private boolean isUserItemInDB(String userID, String itemID) {
1:     BasicDBObject query = new BasicDBObject();
1:     Object userId = userIsObject ? new ObjectId(userID) : userID;
1:     Object itemId = itemIsObject ? new ObjectId(itemID) : itemID;
1:     query.put(mongoUserID, userId);
1:     query.put(mongoItemID, itemId);
1:     return collection.findOne(query) != null;
1:   }
1: 
1:   private DataModel removeUserItem(long userID, Iterable<List<String>> items) {
1:     FastByIDMap<PreferenceArray> rawData = ((GenericDataModel) delegate).getRawUserData();
1:     for (List<String> item : items) {
1:       PreferenceArray prefs = rawData.get(userID);
1:       long itemID = Long.parseLong(item.get(0));
1:       if (prefs != null) {
1:         boolean exists = false;
1:         int length = prefs.length();
1:         for (int i = 0; i < length; i++) {
1:           if (prefs.getItemID(i) == itemID) {
1:             exists = true;
1:             break;
1:           }
1:         }
1:         if (exists) {
1:           rawData.remove(userID);
1:           if (length > 1) {
1:             PreferenceArray newPrefs = new GenericUserPreferenceArray(length - 1);
1:             for (int i = 0, j = 0; i < length; i++, j++) {
1:               if (prefs.getItemID(i) == itemID) {
1:                 j--;
1:               } else {
1:                 newPrefs.set(j, prefs.get(i));
1:               }
1:             }
1:             rawData.put(userID, newPrefs);
1:           }
1:           log.info("Removing userID: {} itemID: {}", userID, itemID);
1:           if (mongoManage) {
1:             removeMongoUserItem(Long.toString(userID), Long.toString(itemID));
1:           }
1:         }
1:       }
1:     }
1:     return new GenericDataModel(rawData);
1:   }
1: 
1:   private DataModel addUserItem(long userID, Iterable<List<String>> items) {
1:     FastByIDMap<PreferenceArray> rawData = ((GenericDataModel) delegate).getRawUserData();
1:     PreferenceArray prefs = rawData.get(userID);
1:     for (List<String> item : items) {
1:       long itemID = Long.parseLong(item.get(0));
1:       float preferenceValue = Float.parseFloat(item.get(1));
1:       boolean exists = false;
1:       if (prefs != null) {
1:         for (int i = 0; i < prefs.length(); i++) {
1:           if (prefs.getItemID(i) == itemID) {
1:             exists = true;
1:             prefs.setValue(i, preferenceValue);
1:             break;
1:           }
1:         }
1:       }
1:       if (!exists) {
1:         if (prefs == null) {
1:           prefs = new GenericUserPreferenceArray(1);
1:         } else {
1:           PreferenceArray newPrefs = new GenericUserPreferenceArray(prefs.length() + 1);
1:           for (int i = 0, j = 1; i < prefs.length(); i++, j++) {
1:             newPrefs.set(j, prefs.get(i));
1:           }
1:           prefs = newPrefs;
1:         }
1:         prefs.setUserID(0, userID);
1:         prefs.setItemID(0, itemID);
1:         prefs.setValue(0, preferenceValue);
0:         log.info("Adding userID: {} itemID: {} preferenceValue: {}", new Object[] {userID, itemID, preferenceValue});
1:         rawData.put(userID, prefs);
1:         if (mongoManage) {
1:           addMongoUserItem(Long.toString(userID),
1:                            Long.toString(itemID),
1:                            Float.toString(preferenceValue));
1:         }
1:       }
1:     }
1:     return new GenericDataModel(rawData);
1:   }
1: 
1:   private Date getDate(Object date) {
1:     if (date.getClass().getName().contains("Date")) {
1:       return (Date) date;
0:     } else if (date.getClass().getName().contains("String")) {
1:       try {
0:         return dateFormat.parse((String) date);
1:       } catch (ParseException ioe) {
1:         log.warn("Error parsing timestamp", ioe);
1:       }
1:     }
1:     return new Date(0);
1:   }
1: 
1:   private float getPreference(Object value) {
1:     if (value != null) {
1:       if (value.getClass().getName().contains("String")) {
1:         preferenceIsString = true;
0:         return Float.parseFloat((String) value);
1:       } else {
1:         preferenceIsString = false;
1:         return Double.valueOf(value.toString()).floatValue();
1:       }
1:     } else {
1:       return 0.5f;
1:     }
1:   }
1: 
1:   private String getID(Object id, boolean isUser) {
1:     if (id.getClass().getName().contains("ObjectId")) {
1:       if (isUser) {
1:         userIsObject = true;
1:       } else {
1:         itemIsObject = true;
1:       }
1:       return ((ObjectId) id).toStringMongod();
1:     } else {
0:       return (String) id;
1:     }
1:   }
1: 
1:   private void checkData(String userID,
1:                          Iterable<List<String>> items,
1:                          boolean add) throws NoSuchUserException, NoSuchItemException {
1:     Preconditions.checkNotNull(userID);
1:     Preconditions.checkNotNull(items);
1:     for (List<String> item : items) {
1:       Preconditions.checkNotNull(item.get(0));
1:     }
1:     if (userIsObject && !ID_PATTERN.matcher(userID).matches()) {
1:       throw new IllegalArgumentException();
1:     }
1:     for (List<String> item : items) {
1:       if (itemIsObject && !ID_PATTERN.matcher(item.get(0)).matches()) {
1:         throw new IllegalArgumentException();
1:       }
1:     }
1:     if (!add && !isIDInModel(userID)) {
1:       throw new NoSuchUserException();
1:     }
1:     for (List<String> item : items) {
1:       if (!add && !isIDInModel(item.get(0))) {
1:         throw new NoSuchItemException();
1:       }
1:     }
1:   }
1: 
1:   @Override
1:   public LongPrimitiveIterator getUserIDs() throws TasteException {
1:     return delegate.getUserIDs();
1:   }
1: 
1:   @Override
1:   public PreferenceArray getPreferencesFromUser(long id) throws TasteException {
1:     return delegate.getPreferencesFromUser(id);
1:   }
1: 
1:   @Override
1:   public FastIDSet getItemIDsFromUser(long userID) throws TasteException {
1:     return delegate.getItemIDsFromUser(userID);
1:   }
1: 
1:   @Override
1:   public LongPrimitiveIterator getItemIDs() throws TasteException {
1:     return delegate.getItemIDs();
1:   }
1: 
1:   @Override
1:   public PreferenceArray getPreferencesForItem(long itemID) throws TasteException {
1:     return delegate.getPreferencesForItem(itemID);
1:   }
1: 
1:   @Override
1:   public Float getPreferenceValue(long userID, long itemID) throws TasteException {
1:     return delegate.getPreferenceValue(userID, itemID);
1:   }
1: 
1:   @Override
1:   public Long getPreferenceTime(long userID, long itemID) throws TasteException {
1:     return delegate.getPreferenceTime(userID, itemID);
1:   }
1: 
1:   @Override
1:   public int getNumItems() throws TasteException {
1:     return delegate.getNumItems();
1:   }
1: 
1:   @Override
1:   public int getNumUsers() throws TasteException {
1:     return delegate.getNumUsers();
1:   }
1: 
1:   @Override
0:   public int getNumUsersWithPreferenceFor(long... itemIDs) throws TasteException {
0:     return delegate.getNumUsersWithPreferenceFor(itemIDs);
1:   }
1: 
1:   @Override
1:   public void setPreference(long userID, long itemID, float value) {
1:     throw new UnsupportedOperationException();
1:   }
1: 
1:   @Override
1:   public void removePreference(long userID, long itemID) {
1:     throw new UnsupportedOperationException();
1:   }
1: 
1:   @Override
1:   public boolean hasPreferenceValues() {
1:     return delegate.hasPreferenceValues();
1:   }
1: 
1:   @Override
1:   public float getMaxPreference() {
1:     return delegate.getMaxPreference();
1:   }
1: 
1:   @Override
1:   public float getMinPreference() {
1:     return delegate.getMinPreference();
1:   }
1: 
1:   @Override
1:   public String toString() {
1:     return "MongoDBDataModel";
1:   }
1: 
1: }
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:           if (user.containsKey("created_at")
1:               && mongoTimestamp.compareTo(getDate(user.get("created_at"))) < 0) {
commit:210b265
/////////////////////////////////////////////////////////////////////////
1:     if (!mongoAuth || db.authenticate(mongoUsername, mongoPassword.toCharArray())) {
commit:74f849b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
0:       Collection<List<String>> items = Lists.newArrayList();
0:       List<String> item = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
0:         Collection<List<String>> items = Lists.newArrayList();
0:         List<String> item = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
0:             userPrefs = Lists.newArrayListWithCapacity(2);
============================================================================