1:35fa73f: /**
1:35fa73f:  * Licensed to the Apache Software Foundation (ASF) under one
1:35fa73f:  * or more contributor license agreements. See the NOTICE file
1:35fa73f:  * distributed with this work for additional information
1:35fa73f:  * regarding copyright ownership. The ASF licenses this file
1:35fa73f:  * to you under the Apache License, Version 2.0 (the
1:35fa73f:  * "License"); you may not use this file except in compliance
1:35fa73f:  * with the License. You may obtain a copy of the License at
1:35fa73f:  *
1:35fa73f:  * http://www.apache.org/licenses/LICENSE-2.0
1:35fa73f:  *
1:35fa73f:  * Unless required by applicable law or agreed to in writing,
1:35fa73f:  * software distributed under the License is distributed on an
1:35fa73f:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:35fa73f:  * KIND, either express or implied. See the License for the
1:35fa73f:  * specific language governing permissions and limitations
1:35fa73f:  * under the License.
1:35fa73f:  */
6:35fa73f: 
1:35fa73f: /*
1:35fa73f: Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
1:35fa73f: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1:35fa73f: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1:35fa73f: that both that copyright notice and this permission notice appear in supporting documentation. 
1:35fa73f: CERN makes no representations about the suitability of this software for any purpose. 
1:35fa73f: It is provided "as is" without expressed or implied warranty.
1:35fa73f: */
1:35fa73f: package org.apache.mahout.math.map;
1:35fa73f: 
1:35fa73f: import java.util.ArrayList;
1:35fa73f: import java.util.Arrays;
1:35fa73f: import java.util.Collection;
1:35fa73f: import java.util.List;
1:35fa73f: import java.util.Map;
1:35fa73f: import java.util.Set;
1:35fa73f: 
1:35fa73f: import org.apache.mahout.math.function.ObjectObjectProcedure;
1:35fa73f: import org.apache.mahout.math.function.ObjectProcedure;
1:35fa73f: import org.apache.mahout.math.set.AbstractSet;
1:35fa73f: import org.apache.mahout.math.set.OpenHashSet;
1:35fa73f: 
1:35fa73f: /**
1:35fa73f:   * Open hash map. This implements Map, but it does not respect several aspects of the Map contract
1:35fa73f:   * that impose the very sorts of performance penalities that this class exists to avoid.
1:35fa73f:   * {@link #entrySet}, {@link #values}, and {@link #keySet()} do <strong>not</strong> return
1:35fa73f:   * collections that share storage with the main map, and changes to those returned objects
1:35fa73f:   * are <strong>not</strong> reflected in the container.
1:35fa73f:  **/
1:35fa73f: public class OpenHashMap<K,V> extends AbstractSet implements Map<K,V> {
1:35fa73f:   protected static final byte FREE = 0;
1:35fa73f:   protected static final byte FULL = 1;
1:35fa73f:   protected static final byte REMOVED = 2;
1:35fa73f:   protected static final Object NO_KEY_VALUE = null;
1:35fa73f: 
1:35fa73f:   /** The hash table keys. */
1:35fa73f:   protected Object[] table;
1:35fa73f: 
1:35fa73f:   /** The hash table values. */
1:35fa73f:   protected Object[] values;
1:35fa73f: 
1:35fa73f:   /** The state of each hash table entry (FREE, FULL, REMOVED). */
1:35fa73f:   protected byte[] state;
1:35fa73f: 
1:35fa73f:   /** The number of table entries in state==FREE. */
1:35fa73f:   protected int freeEntries;
1:35fa73f: 
1:35fa73f: 
1:35fa73f:   /** Constructs an empty map with default capacity and default load factors. */
1:35fa73f:   public OpenHashMap() {
1:6d16230:     this(DEFAULT_CAPACITY);
3:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Constructs an empty map with the specified initial capacity and default load factors.
1:35fa73f:    *
1:35fa73f:    * @param initialCapacity the initial capacity of the map.
1:35fa73f:    * @throws IllegalArgumentException if the initial capacity is less than zero.
1:35fa73f:    */
1:35fa73f:   public OpenHashMap(int initialCapacity) {
1:6d16230:     this(initialCapacity, DEFAULT_MIN_LOAD_FACTOR, DEFAULT_MAX_LOAD_FACTOR);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.
1:35fa73f:    *
1:35fa73f:    * @param initialCapacity the initial capacity.
1:35fa73f:    * @param minLoadFactor   the minimum load factor.
1:35fa73f:    * @param maxLoadFactor   the maximum load factor.
1:35fa73f:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:35fa73f:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:35fa73f:    *                                  maxLoadFactor)</tt>.
1:35fa73f:    */
1:35fa73f:   public OpenHashMap(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:35fa73f:     setUp(initialCapacity, minLoadFactor, maxLoadFactor);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /** Removes all (key,value) associations from the receiver. Implicitly calls <tt>trimToSize()</tt>. */
1:35fa73f:   @Override
1:35fa73f:   public void clear() {
1:35fa73f:     Arrays.fill(this.state, FREE);
1:35fa73f:     distinct = 0;
1:35fa73f:     freeEntries = table.length; // delta
1:35fa73f:     trimToSize();
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns a deep copy of the receiver.
1:35fa73f:    *
1:35fa73f:    * @return a deep copy of the receiver.
1:35fa73f:    */
1:35fa73f:   @Override
2:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public Object clone() {
1:35fa73f:     OpenHashMap<K,V> copy = (OpenHashMap<K,V>) super.clone();
1:35fa73f:     copy.table = copy.table.clone();
1:35fa73f:     copy.values = copy.values.clone();
1:35fa73f:     copy.state = copy.state.clone();
1:35fa73f:     return copy;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns <tt>true</tt> if the receiver contains the specified key.
1:35fa73f:    *
1:35fa73f:    * @return <tt>true</tt> if the receiver contains the specified key.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   @Override
1:35fa73f:   public boolean containsKey(Object key) {
1:35fa73f:     return indexOfKey((K)key) >= 0;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns <tt>true</tt> if the receiver contains the specified value.
1:35fa73f:    *
1:35fa73f:    * @return <tt>true</tt> if the receiver contains the specified value.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   @Override
1:35fa73f:   public boolean containsValue(Object value) {
1:35fa73f:     return indexOfValue((V)value) >= 0;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Ensures that the receiver can hold at least the specified number of associations without needing to allocate new
1:35fa73f:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This
1:35fa73f:    * method never need be called; it is for performance tuning only. Calling this method before <tt>put()</tt>ing a
1:35fa73f:    * large number of associations boosts performance, because the receiver will grow only once instead of potentially
1:35fa73f:    * many times and hash collisions get less probable.
1:35fa73f:    *
1:35fa73f:    * @param minCapacity the desired minimum capacity.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   public void ensureCapacity(int minCapacity) {
1:35fa73f:     if (table.length < minCapacity) {
1:35fa73f:       int newCapacity = nextPrime(minCapacity);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Applies a procedure to each key of the receiver, if any. Note: Iterates over the keys in no particular order.
1:35fa73f:    * Subclasses can define a particular order, for example, "sorted by key". All methods which <i>can</i> be expressed
1:35fa73f:    * in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this
1:35fa73f:    * method, even if it is no particular order. This is necessary so that, for example, methods <tt>keys</tt> and
1:35fa73f:    * <tt>values</tt> will yield association pairs, not two uncorrelated lists.
1:35fa73f:    *
1:35fa73f:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
1:35fa73f:    *                  continues.
1:35fa73f:    * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.
1:35fa73f:    */
1:6d16230:   @SuppressWarnings("unchecked")
1:35fa73f:   public boolean forEachKey(ObjectProcedure<K> procedure) {
1:35fa73f:     for (int i = table.length; i-- > 0;) {
1:308d034:       if (state[i] == FULL && !procedure.apply((K)table[i])) {
1:308d034:         return false;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:     return true;
1:6d16230:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Applies a procedure to each (key,value) pair of the receiver, if any. Iteration order is guaranteed to be
1:35fa73f:    * <i>identical</i> to the order used by method {@link #forEachKey(ObjectProcedure)}.
1:35fa73f:    *
1:35fa73f:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
1:35fa73f:    *                  continues.
1:35fa73f:    * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public boolean forEachPair(ObjectObjectProcedure<K,V> procedure) {
1:35fa73f:     for (int i = table.length; i-- > 0;) {
1:308d034:       if (state[i] == FULL && !procedure.apply((K)table[i], (V)values[i])) {
1:308d034:         return false;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:     return true;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns the value associated with the specified key. It is often a good idea to first check with {@link
1:35fa73f:    * #containsKey(Object)} whether the given key has a value associated or not, i.e. whether there exists an association
1:35fa73f:    * for the given key or not.
1:35fa73f:    *
1:35fa73f:    * @param key the key to be searched for.
1:35fa73f:    * @return the value associated with the specified key; <tt>0</tt> if no such key is present.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   @Override
1:35fa73f:   public V get(Object key) {
1:35fa73f:     int i = indexOfKey((K)key);
1:35fa73f:     if (i < 0) {
1:35fa73f:       return null;
1:35fa73f:     } //not contained
1:35fa73f:     return (V)values[i];
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * @param key the key to be added to the receiver.
1:35fa73f:    * @return the index where the key would need to be inserted, if it is not already contained. Returns -index-1 if the
1:35fa73f:    *         key is already contained at slot index. Therefore, if the returned index < 0, then it is already contained
1:35fa73f:    *         at slot -index-1. If the returned index >= 0, then it is NOT already contained and should be inserted at
1:35fa73f:    *         slot index.
1:35fa73f:    */
1:35fa73f:   protected int indexOfInsertion(K key) {
1:35fa73f:     Object[] tab = table;
1:35fa73f:     byte[] stat = state;
1:35fa73f:     int length = tab.length;
1:35fa73f: 
1:35fa73f:     int hash = key.hashCode() & 0x7FFFFFFF;
1:35fa73f:     int i = hash % length;
1:35fa73f:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
1:35fa73f:     //int decrement = (hash / length) % length;
1:35fa73f:     if (decrement == 0) {
1:35fa73f:       decrement = 1;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     // stop if we find a removed or free slot, or if we find the key itself
1:35fa73f:     // do NOT skip over removed slots (yes, open addressing is like that...)
1:35fa73f:     while (stat[i] == FULL && !equalsMindTheNull(key, tab[i])) {
1:35fa73f:       i -= decrement;
1:35fa73f:       //hashCollisions++;
1:35fa73f:       if (i < 0) {
1:35fa73f:         i += length;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     if (stat[i] == REMOVED) {
1:35fa73f:       // stop if we find a free slot, or if we find the key itself.
1:35fa73f:       // do skip over removed slots (yes, open addressing is like that...)
1:35fa73f:       // assertion: there is at least one FREE slot.
1:35fa73f:       int j = i;
1:35fa73f:       while (stat[i] != FREE && (stat[i] == REMOVED || tab[i] != key)) {
1:35fa73f:         i -= decrement;
1:35fa73f:         //hashCollisions++;
1:35fa73f:         if (i < 0) {
1:35fa73f:           i += length;
1:35fa73f:         }
1:35fa73f:       }
1:35fa73f:       if (stat[i] == FREE) {
1:35fa73f:         i = j;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f: 
1:35fa73f: 
1:35fa73f:     if (stat[i] == FULL) {
1:35fa73f:       // key already contained at slot i.
1:35fa73f:       // return a negative number identifying the slot.
1:35fa73f:       return -i - 1;
1:35fa73f:     }
1:35fa73f:     // not already contained, should be inserted at slot i.
1:35fa73f:     // return a number >= 0 identifying the slot.
1:35fa73f:     return i;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * @param key the key to be searched in the receiver.
1:35fa73f:    * @return the index where the key is contained in the receiver, returns -1 if the key was not found.
1:35fa73f:    */
1:35fa73f:   protected int indexOfKey(K key) {
1:35fa73f:     Object[] tab = table;
1:35fa73f:     byte[] stat = state;
1:35fa73f:     int length = tab.length;
1:35fa73f: 
1:35fa73f:     int hash = key.hashCode() & 0x7FFFFFFF;
1:35fa73f:     int i = hash % length;
1:35fa73f:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
1:35fa73f:     //int decrement = (hash / length) % length;
1:35fa73f:     if (decrement == 0) {
1:35fa73f:       decrement = 1;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     // stop if we find a free slot, or if we find the key itself.
1:35fa73f:     // do skip over removed slots (yes, open addressing is like that...)
1:35fa73f:     while (stat[i] != FREE && (stat[i] == REMOVED || !equalsMindTheNull(key, tab[i]))) {
1:35fa73f:       i -= decrement;
1:35fa73f:       //hashCollisions++;
1:35fa73f:       if (i < 0) {
1:35fa73f:         i += length;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     if (stat[i] == FREE) {
1:35fa73f:       return -1;
1:35fa73f:     } // not found
1:35fa73f:     return i; //found, return index where key is contained
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * @param value the value to be searched in the receiver.
1:35fa73f:    * @return the index where the value is contained in the receiver, returns -1 if the value was not found.
1:35fa73f:    */
1:35fa73f:   protected int indexOfValue(V value) {
1:35fa73f:     Object[] val = values;
1:35fa73f:     byte[] stat = state;
1:35fa73f: 
1:35fa73f:     for (int i = stat.length; --i >= 0;) {
1:35fa73f:       if (stat[i] == FULL && equalsMindTheNull(val[i], value)) {
1:35fa73f:         return i;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     return -1; // not found
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Fills all keys contained in the receiver into the specified list. Fills the list, starting at index 0. After this
1:35fa73f:    * call returns the specified list has a new size that equals <tt>this.size()</tt>. 
1:35fa73f:    * This method can be used
1:35fa73f:    * to iterate over the keys of the receiver.
1:35fa73f:    *
1:35fa73f:    * @param list the list to be filled, can have any size.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   public void keys(List<K> list) {
1:35fa73f:     list.clear();
1:35fa73f:   
1:35fa73f: 
1:35fa73f:     Object [] tab = table;
1:35fa73f:     byte[] stat = state;
1:35fa73f: 
1:35fa73f:     for (int i = tab.length; i-- > 0;) {
1:35fa73f:       if (stat[i] == FULL) {
1:35fa73f:         list.add((K)tab[i]);
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Associates the given key with the given value. Replaces any old <tt>(key,someOtherValue)</tt> association, if
1:35fa73f:    * existing.
1:35fa73f:    *
1:35fa73f:    * @param key   the key the value shall be associated with.
1:35fa73f:    * @param value the value to be associated.
1:35fa73f:    * @return <tt>true</tt> if the receiver did not already contain such a key; <tt>false</tt> if the receiver did
1:35fa73f:    *         already contain such a key - the new value has now replaced the formerly associated value.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   @Override
1:35fa73f:   public V put(K key, V value) {
1:35fa73f:     int i = indexOfInsertion(key);
1:35fa73f:     if (i < 0) { //already contained
1:35fa73f:       i = -i - 1;
1:35fa73f:       V previous = (V) this.values[i];
1:35fa73f:       this.values[i] = value;
1:35fa73f:       return previous;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     if (this.distinct > this.highWaterMark) {
1:35fa73f:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:       return put(key, value);
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     this.table[i] = key;
1:35fa73f:     this.values[i] = value;
1:35fa73f:     if (this.state[i] == FREE) {
1:35fa73f:       this.freeEntries--;
1:35fa73f:     }
1:35fa73f:     this.state[i] = FULL;
1:35fa73f:     this.distinct++;
1:35fa73f: 
1:35fa73f:     if (this.freeEntries < 1) { //delta
1:35fa73f:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     return null;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called
1:35fa73f:    * automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water
1:35fa73f:    * mark.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   protected void rehash(int newCapacity) {
1:35fa73f:     int oldCapacity = table.length;
1:35fa73f:     //if (oldCapacity == newCapacity) return;
1:35fa73f: 
1:35fa73f:     Object[] oldTable = table;
1:35fa73f:     Object[] oldValues = values;
1:35fa73f:     byte[] oldState = state;
1:35fa73f: 
1:35fa73f:     Object[] newTable = new Object[newCapacity];
1:35fa73f:     Object[] newValues = new Object[newCapacity];
1:35fa73f:     byte[] newState = new byte[newCapacity];
1:35fa73f: 
1:35fa73f:     this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
1:35fa73f:     this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);
1:35fa73f: 
1:35fa73f:     this.table = newTable;
1:35fa73f:     this.values = newValues;
1:35fa73f:     this.state = newState;
1:35fa73f:     this.freeEntries = newCapacity - this.distinct; // delta
1:35fa73f: 
1:35fa73f:     for (int i = oldCapacity; i-- > 0;) {
1:35fa73f:       if (oldState[i] == FULL) {
1:35fa73f:         Object element = oldTable[i];
1:35fa73f:         int index = indexOfInsertion((K)element);
1:35fa73f:         newTable[index] = element;
1:35fa73f:         newValues[index] = oldValues[i];
1:35fa73f:         newState[index] = FULL;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Removes the given key with its associated element from the receiver, if present.
1:35fa73f:    *
1:35fa73f:    * @param key the key to be removed from the receiver.
1:35fa73f:    * @return <tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.
1:35fa73f:    */
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   @Override
1:35fa73f:   public V remove(Object key) {
1:35fa73f:     int i = indexOfKey((K)key);
1:35fa73f:     if (i < 0) {
1:35fa73f:       return null;
1:35fa73f:     }
1:35fa73f:     // key not contained
1:35fa73f:     V removed = (V) values[i];
1:35fa73f: 
1:35fa73f:     this.state[i] = REMOVED;
1:35fa73f:     //this.values[i]=0; // delta
1:35fa73f:     this.distinct--;
1:35fa73f: 
1:35fa73f:     if (this.distinct < this.lowWaterMark) {
1:35fa73f:       int newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     return removed;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Initializes the receiver.
1:35fa73f:    *
1:35fa73f:    * @param initialCapacity the initial capacity of the receiver.
1:35fa73f:    * @param minLoadFactor   the minLoadFactor of the receiver.
1:35fa73f:    * @param maxLoadFactor   the maxLoadFactor of the receiver.
1:35fa73f:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:35fa73f:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:35fa73f:    *                                  maxLoadFactor)</tt>.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:35fa73f:     int capacity = initialCapacity;
1:35fa73f:     super.setUp(capacity, minLoadFactor, maxLoadFactor);
1:35fa73f:     capacity = nextPrime(capacity);
1:35fa73f:     if (capacity == 0) {
1:35fa73f:       capacity = 1;
1:35fa73f:     } // open addressing needs at least one FREE slot at any time.
1:35fa73f: 
1:35fa73f:     this.table = new Object[capacity];
1:35fa73f:     this.values = new Object[capacity];
1:35fa73f:     this.state = new byte[capacity];
1:35fa73f: 
1:35fa73f:     // memory will be exhausted long before this pathological case happens, anyway.
1:35fa73f:     this.minLoadFactor = minLoadFactor;
1:6d16230:     if (capacity == PrimeFinder.LARGEST_PRIME) {
1:35fa73f:       this.maxLoadFactor = 1.0;
1:35fa73f:     } else {
1:35fa73f:       this.maxLoadFactor = maxLoadFactor;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     this.distinct = 0;
1:35fa73f:     this.freeEntries = capacity; // delta
1:35fa73f: 
1:35fa73f:     // lowWaterMark will be established upon first expansion.
1:35fa73f:     // establishing it now (upon instance construction) would immediately make the table shrink upon first put(...).
1:35fa73f:     // After all the idea of an "initialCapacity" implies violating lowWaterMarks when an object is young.
1:35fa73f:     // See ensureCapacity(...)
1:35fa73f:     this.lowWaterMark = 0;
1:35fa73f:     this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
1:35fa73f:    * application can use this operation to minimize the storage of the receiver.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   public void trimToSize() {
1:35fa73f:     // * 1.2 because open addressing's performance exponentially degrades beyond that point
1:35fa73f:     // so that even rehashing the table can take very long
1:35fa73f:     int newCapacity = nextPrime((int) (1 + 1.2 * size()));
1:35fa73f:     if (table.length > newCapacity) {
1:35fa73f:       rehash(newCapacity);
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Access for unit tests.
1:35fa73f:    * @param capacity
1:35fa73f:    * @param minLoadFactor
1:35fa73f:    * @param maxLoadFactor
1:35fa73f:    */
1:35fa73f:   void getInternalFactors(int[] capacity, 
1:35fa73f:       double[] minLoadFactor, 
1:35fa73f:       double[] maxLoadFactor) {
1:35fa73f:     capacity[0] = table.length;
1:35fa73f:     minLoadFactor[0] = this.minLoadFactor;
1:35fa73f:     maxLoadFactor[0] = this.maxLoadFactor;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   private class MapEntry implements Map.Entry<K,V> {
1:35fa73f:     private final K key;
1:35fa73f:     private final V value;
1:35fa73f:     
1:35fa73f:     MapEntry(K key, V value) {
1:35fa73f:       this.key = key;
1:35fa73f:       this.value = value;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     @Override
1:35fa73f:     public K getKey() {
1:35fa73f:       return key;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     @Override
1:35fa73f:     public V getValue() {
1:35fa73f:       return value;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     @Override
1:35fa73f:     public V setValue(V value) {
1:35fa73f:       throw new UnsupportedOperationException("Map.Entry.setValue not supported for OpenHashMap");
1:35fa73f:     }
1:35fa73f:     
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Allocate a set to contain Map.Entry objects for the pairs and return it.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   public Set<java.util.Map.Entry<K,V>> entrySet() {
1:02ff22f:     final Set<Entry<K, V>> entries = new OpenHashSet<>();
1:35fa73f:     forEachPair(new ObjectObjectProcedure<K,V>() {
1:35fa73f:       @Override
1:35fa73f:       public boolean apply(K key, V value) {
1:35fa73f:         entries.add(new MapEntry(key, value));
1:35fa73f:         return true;
1:6d16230:       }
1:6d16230:     });
1:35fa73f:     return entries;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Allocate a set to contain keys and return it.
1:35fa73f:    * This violates the 'backing' provisions of the map interface.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   public Set<K> keySet() {
1:02ff22f:     final Set<K> keys = new OpenHashSet<>();
1:35fa73f:     forEachKey(new ObjectProcedure<K>() {
1:35fa73f:       @Override
1:35fa73f:       public boolean apply(K element) {
1:35fa73f:         keys.add(element);
1:35fa73f:         return true;
1:6d16230:       }
1:6d16230:     });
1:35fa73f:     return keys;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @Override
1:35fa73f:   public void putAll(Map<? extends K,? extends V> m) {
1:35fa73f:     for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
1:35fa73f:       put(e.getKey(), e.getValue());
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Allocate a list to contain the values and return it.
1:35fa73f:    * This violates the 'backing' provision of the Map interface.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   public Collection<V> values() {
1:02ff22f:     final List<V> valueList = new ArrayList<>();
1:35fa73f:     forEachPair(new ObjectObjectProcedure<K,V>() {
1:35fa73f:       @Override
1:35fa73f:       public boolean apply(K key, V value) {
1:35fa73f:         valueList.add(value);
1:35fa73f:         return true;
1:6d16230:       }
1:6d16230:     });
1:35fa73f:     return valueList;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @SuppressWarnings("unchecked")
1:35fa73f:   @Override
1:35fa73f:   public boolean equals(Object obj) {
1:6d16230:     if (!(obj instanceof OpenHashMap)) {
3:35fa73f:       return false;
1:35fa73f:     }
1:35fa73f:     final OpenHashMap<K,V> o = (OpenHashMap<K,V>) obj;
1:35fa73f:     if (o.size() != size()) {
1:35fa73f:       return false;
1:35fa73f:     }
1:35fa73f:     final boolean[] equal = new boolean[1];
1:35fa73f:     equal[0] = true;
1:35fa73f:     forEachPair(new ObjectObjectProcedure<K,V>() {
1:35fa73f:       @Override
1:35fa73f:       public boolean apply(K key, V value) {
1:35fa73f:         Object ov = o.get(key);
1:35fa73f:         if (!value.equals(ov)) {
1:35fa73f:           equal[0] = false;
1:35fa73f:           return false;
1:35fa73f:         }
1:35fa73f:         return true;
1:35fa73f:       }
1:6d16230:     });
1:35fa73f:     return equal[0];
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   @Override
1:35fa73f:   public String toString() {
1:35fa73f:     final StringBuilder sb = new StringBuilder();
1:35fa73f:     sb.append('{');
1:35fa73f:     forEachPair(new ObjectObjectProcedure<K,V>() {
1:35fa73f:       @Override
1:35fa73f:       public boolean apply(K key, V value) {
1:35fa73f:         sb.append('[');
1:35fa73f:         sb.append(key);
1:35fa73f:         sb.append(" -> ");
1:35fa73f:         sb.append(value);
1:35fa73f:         sb.append("] ");
1:35fa73f:         return true;
1:6d16230:       }
1:6d16230:     });
1:35fa73f:     sb.append('}');
1:35fa73f:     return sb.toString();
1:35fa73f:   }
1:35fa73f: }
============================================================================
author:Karl Richter
-------------------------------------------------------------------------------
commit:02ff22f
/////////////////////////////////////////////////////////////////////////
1:     final Set<Entry<K, V>> entries = new OpenHashSet<>();
/////////////////////////////////////////////////////////////////////////
1:     final Set<K> keys = new OpenHashSet<>();
/////////////////////////////////////////////////////////////////////////
1:     final List<V> valueList = new ArrayList<>();
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:     this(DEFAULT_CAPACITY);
/////////////////////////////////////////////////////////////////////////
1:     this(initialCapacity, DEFAULT_MIN_LOAD_FACTOR, DEFAULT_MAX_LOAD_FACTOR);
/////////////////////////////////////////////////////////////////////////
1:   @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1:     if (capacity == PrimeFinder.LARGEST_PRIME) {
/////////////////////////////////////////////////////////////////////////
1:       }
1:     });
/////////////////////////////////////////////////////////////////////////
1:       }
1:     });
/////////////////////////////////////////////////////////////////////////
1:       }
1:     });
1:     if (!(obj instanceof OpenHashMap)) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       }
1:     });
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       }
1:     });
author:Ted Dunning
-------------------------------------------------------------------------------
commit:308d034
/////////////////////////////////////////////////////////////////////////
1:       if (state[i] == FULL && !procedure.apply((K)table[i])) {
1:         return false;
/////////////////////////////////////////////////////////////////////////
1:       if (state[i] == FULL && !procedure.apply((K)table[i], (V)values[i])) {
1:         return false;
commit:35fa73f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements. See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership. The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License. You may obtain a copy of the License at
1:  *
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied. See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: /*
1: Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
1: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1: that both that copyright notice and this permission notice appear in supporting documentation. 
1: CERN makes no representations about the suitability of this software for any purpose. 
1: It is provided "as is" without expressed or implied warranty.
1: */
1: package org.apache.mahout.math.map;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: 
1: import org.apache.mahout.math.function.ObjectObjectProcedure;
1: import org.apache.mahout.math.function.ObjectProcedure;
1: import org.apache.mahout.math.set.AbstractSet;
1: import org.apache.mahout.math.set.OpenHashSet;
1: 
1: /**
1:   * Open hash map. This implements Map, but it does not respect several aspects of the Map contract
1:   * that impose the very sorts of performance penalities that this class exists to avoid.
1:   * {@link #entrySet}, {@link #values}, and {@link #keySet()} do <strong>not</strong> return
1:   * collections that share storage with the main map, and changes to those returned objects
1:   * are <strong>not</strong> reflected in the container.
1:  **/
1: public class OpenHashMap<K,V> extends AbstractSet implements Map<K,V> {
1:   protected static final byte FREE = 0;
1:   protected static final byte FULL = 1;
1:   protected static final byte REMOVED = 2;
1:   protected static final Object NO_KEY_VALUE = null;
1: 
1:   /** The hash table keys. */
1:   protected Object[] table;
1: 
1:   /** The hash table values. */
1:   protected Object[] values;
1: 
1:   /** The state of each hash table entry (FREE, FULL, REMOVED). */
1:   protected byte[] state;
1: 
1:   /** The number of table entries in state==FREE. */
1:   protected int freeEntries;
1: 
1: 
1:   /** Constructs an empty map with default capacity and default load factors. */
1:   public OpenHashMap() {
0:     this(defaultCapacity);
1:   }
1: 
1:   /**
1:    * Constructs an empty map with the specified initial capacity and default load factors.
1:    *
1:    * @param initialCapacity the initial capacity of the map.
1:    * @throws IllegalArgumentException if the initial capacity is less than zero.
1:    */
1:   public OpenHashMap(int initialCapacity) {
0:     this(initialCapacity, defaultMinLoadFactor, defaultMaxLoadFactor);
1:   }
1: 
1:   /**
1:    * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.
1:    *
1:    * @param initialCapacity the initial capacity.
1:    * @param minLoadFactor   the minimum load factor.
1:    * @param maxLoadFactor   the maximum load factor.
1:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:    *                                  maxLoadFactor)</tt>.
1:    */
1:   public OpenHashMap(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:     setUp(initialCapacity, minLoadFactor, maxLoadFactor);
1:   }
1: 
1:   /** Removes all (key,value) associations from the receiver. Implicitly calls <tt>trimToSize()</tt>. */
1:   @Override
1:   public void clear() {
1:     Arrays.fill(this.state, FREE);
1:     distinct = 0;
1:     freeEntries = table.length; // delta
1:     trimToSize();
1:   }
1: 
1:   /**
1:    * Returns a deep copy of the receiver.
1:    *
1:    * @return a deep copy of the receiver.
1:    */
1:   @Override
1:   @SuppressWarnings("unchecked")
1:   public Object clone() {
1:     OpenHashMap<K,V> copy = (OpenHashMap<K,V>) super.clone();
1:     copy.table = copy.table.clone();
1:     copy.values = copy.values.clone();
1:     copy.state = copy.state.clone();
1:     return copy;
1:   }
1: 
1:   /**
1:    * Returns <tt>true</tt> if the receiver contains the specified key.
1:    *
1:    * @return <tt>true</tt> if the receiver contains the specified key.
1:    */
1:   @SuppressWarnings("unchecked")
1:   @Override
1:   public boolean containsKey(Object key) {
1:     return indexOfKey((K)key) >= 0;
1:   }
1: 
1:   /**
1:    * Returns <tt>true</tt> if the receiver contains the specified value.
1:    *
1:    * @return <tt>true</tt> if the receiver contains the specified value.
1:    */
1:   @SuppressWarnings("unchecked")
1:   @Override
1:   public boolean containsValue(Object value) {
1:     return indexOfValue((V)value) >= 0;
1:   }
1: 
1:   /**
1:    * Ensures that the receiver can hold at least the specified number of associations without needing to allocate new
1:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This
1:    * method never need be called; it is for performance tuning only. Calling this method before <tt>put()</tt>ing a
1:    * large number of associations boosts performance, because the receiver will grow only once instead of potentially
1:    * many times and hash collisions get less probable.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   @Override
1:   public void ensureCapacity(int minCapacity) {
1:     if (table.length < minCapacity) {
1:       int newCapacity = nextPrime(minCapacity);
1:       rehash(newCapacity);
1:     }
1:   }
1: 
1:   /**
1:    * Applies a procedure to each key of the receiver, if any. Note: Iterates over the keys in no particular order.
1:    * Subclasses can define a particular order, for example, "sorted by key". All methods which <i>can</i> be expressed
1:    * in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this
1:    * method, even if it is no particular order. This is necessary so that, for example, methods <tt>keys</tt> and
1:    * <tt>values</tt> will yield association pairs, not two uncorrelated lists.
1:    *
1:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
1:    *                  continues.
1:    * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.
1:    */
1:   @SuppressWarnings("unchecked")
1:   public boolean forEachKey(ObjectProcedure<K> procedure) {
1:     for (int i = table.length; i-- > 0;) {
0:       if (state[i] == FULL) {
0:         if (!procedure.apply((K)table[i])) {
1:           return false;
1:         }
1:       }
1:     }
1:     return true;
1:   }
1: 
1:   /**
1:    * Applies a procedure to each (key,value) pair of the receiver, if any. Iteration order is guaranteed to be
1:    * <i>identical</i> to the order used by method {@link #forEachKey(ObjectProcedure)}.
1:    *
1:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
1:    *                  continues.
1:    * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.
1:    */
1:     @SuppressWarnings("unchecked")
1:   public boolean forEachPair(ObjectObjectProcedure<K,V> procedure) {
1:     for (int i = table.length; i-- > 0;) {
0:       if (state[i] == FULL) {
0:         if (!procedure.apply((K)table[i], (V)values[i])) {
1:           return false;
1:         }
1:       }
1:     }
1:     return true;
1:   }
1: 
1:   /**
1:    * Returns the value associated with the specified key. It is often a good idea to first check with {@link
1:    * #containsKey(Object)} whether the given key has a value associated or not, i.e. whether there exists an association
1:    * for the given key or not.
1:    *
1:    * @param key the key to be searched for.
1:    * @return the value associated with the specified key; <tt>0</tt> if no such key is present.
1:    */
1:   @SuppressWarnings("unchecked")
1:   @Override
1:   public V get(Object key) {
1:     int i = indexOfKey((K)key);
1:     if (i < 0) {
1:       return null;
1:     } //not contained
1:     return (V)values[i];
1:   }
1: 
1:   /**
1:    * @param key the key to be added to the receiver.
1:    * @return the index where the key would need to be inserted, if it is not already contained. Returns -index-1 if the
1:    *         key is already contained at slot index. Therefore, if the returned index < 0, then it is already contained
1:    *         at slot -index-1. If the returned index >= 0, then it is NOT already contained and should be inserted at
1:    *         slot index.
1:    */
1:   protected int indexOfInsertion(K key) {
1:     Object[] tab = table;
1:     byte[] stat = state;
1:     int length = tab.length;
1: 
1:     int hash = key.hashCode() & 0x7FFFFFFF;
1:     int i = hash % length;
1:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
1:     //int decrement = (hash / length) % length;
1:     if (decrement == 0) {
1:       decrement = 1;
1:     }
1: 
1:     // stop if we find a removed or free slot, or if we find the key itself
1:     // do NOT skip over removed slots (yes, open addressing is like that...)
1:     while (stat[i] == FULL && !equalsMindTheNull(key, tab[i])) {
1:       i -= decrement;
1:       //hashCollisions++;
1:       if (i < 0) {
1:         i += length;
1:       }
1:     }
1: 
1:     if (stat[i] == REMOVED) {
1:       // stop if we find a free slot, or if we find the key itself.
1:       // do skip over removed slots (yes, open addressing is like that...)
1:       // assertion: there is at least one FREE slot.
1:       int j = i;
1:       while (stat[i] != FREE && (stat[i] == REMOVED || tab[i] != key)) {
1:         i -= decrement;
1:         //hashCollisions++;
1:         if (i < 0) {
1:           i += length;
1:         }
1:       }
1:       if (stat[i] == FREE) {
1:         i = j;
1:       }
1:     }
1: 
1: 
1:     if (stat[i] == FULL) {
1:       // key already contained at slot i.
1:       // return a negative number identifying the slot.
1:       return -i - 1;
1:     }
1:     // not already contained, should be inserted at slot i.
1:     // return a number >= 0 identifying the slot.
1:     return i;
1:   }
1: 
1:   /**
1:    * @param key the key to be searched in the receiver.
1:    * @return the index where the key is contained in the receiver, returns -1 if the key was not found.
1:    */
1:   protected int indexOfKey(K key) {
1:     Object[] tab = table;
1:     byte[] stat = state;
1:     int length = tab.length;
1: 
1:     int hash = key.hashCode() & 0x7FFFFFFF;
1:     int i = hash % length;
1:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
1:     //int decrement = (hash / length) % length;
1:     if (decrement == 0) {
1:       decrement = 1;
1:     }
1: 
1:     // stop if we find a free slot, or if we find the key itself.
1:     // do skip over removed slots (yes, open addressing is like that...)
1:     while (stat[i] != FREE && (stat[i] == REMOVED || !equalsMindTheNull(key, tab[i]))) {
1:       i -= decrement;
1:       //hashCollisions++;
1:       if (i < 0) {
1:         i += length;
1:       }
1:     }
1: 
1:     if (stat[i] == FREE) {
1:       return -1;
1:     } // not found
1:     return i; //found, return index where key is contained
1:   }
1: 
1:   /**
1:    * @param value the value to be searched in the receiver.
1:    * @return the index where the value is contained in the receiver, returns -1 if the value was not found.
1:    */
1:   protected int indexOfValue(V value) {
1:     Object[] val = values;
1:     byte[] stat = state;
1: 
1:     for (int i = stat.length; --i >= 0;) {
1:       if (stat[i] == FULL && equalsMindTheNull(val[i], value)) {
1:         return i;
1:       }
1:     }
1: 
1:     return -1; // not found
1:   }
1: 
1:   /**
1:    * Fills all keys contained in the receiver into the specified list. Fills the list, starting at index 0. After this
1:    * call returns the specified list has a new size that equals <tt>this.size()</tt>. 
1:    * This method can be used
1:    * to iterate over the keys of the receiver.
1:    *
1:    * @param list the list to be filled, can have any size.
1:    */
1:   @SuppressWarnings("unchecked")
1:   public void keys(List<K> list) {
1:     list.clear();
1:   
1: 
1:     Object [] tab = table;
1:     byte[] stat = state;
1: 
1:     for (int i = tab.length; i-- > 0;) {
1:       if (stat[i] == FULL) {
1:         list.add((K)tab[i]);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Associates the given key with the given value. Replaces any old <tt>(key,someOtherValue)</tt> association, if
1:    * existing.
1:    *
1:    * @param key   the key the value shall be associated with.
1:    * @param value the value to be associated.
1:    * @return <tt>true</tt> if the receiver did not already contain such a key; <tt>false</tt> if the receiver did
1:    *         already contain such a key - the new value has now replaced the formerly associated value.
1:    */
1:   @SuppressWarnings("unchecked")
1:   @Override
1:   public V put(K key, V value) {
1:     int i = indexOfInsertion(key);
1:     if (i < 0) { //already contained
1:       i = -i - 1;
1:       V previous = (V) this.values[i];
1:       this.values[i] = value;
1:       return previous;
1:     }
1: 
1:     if (this.distinct > this.highWaterMark) {
1:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:       rehash(newCapacity);
1:       return put(key, value);
1:     }
1: 
1:     this.table[i] = key;
1:     this.values[i] = value;
1:     if (this.state[i] == FREE) {
1:       this.freeEntries--;
1:     }
1:     this.state[i] = FULL;
1:     this.distinct++;
1: 
1:     if (this.freeEntries < 1) { //delta
1:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:       rehash(newCapacity);
1:     }
1: 
1:     return null;
1:   }
1: 
1:   /**
1:    * Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called
1:    * automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water
1:    * mark.
1:    */
1:   @SuppressWarnings("unchecked")
1:   protected void rehash(int newCapacity) {
1:     int oldCapacity = table.length;
1:     //if (oldCapacity == newCapacity) return;
1: 
1:     Object[] oldTable = table;
1:     Object[] oldValues = values;
1:     byte[] oldState = state;
1: 
1:     Object[] newTable = new Object[newCapacity];
1:     Object[] newValues = new Object[newCapacity];
1:     byte[] newState = new byte[newCapacity];
1: 
1:     this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
1:     this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);
1: 
1:     this.table = newTable;
1:     this.values = newValues;
1:     this.state = newState;
1:     this.freeEntries = newCapacity - this.distinct; // delta
1: 
1:     for (int i = oldCapacity; i-- > 0;) {
1:       if (oldState[i] == FULL) {
1:         Object element = oldTable[i];
1:         int index = indexOfInsertion((K)element);
1:         newTable[index] = element;
1:         newValues[index] = oldValues[i];
1:         newState[index] = FULL;
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Removes the given key with its associated element from the receiver, if present.
1:    *
1:    * @param key the key to be removed from the receiver.
1:    * @return <tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.
1:    */
1:   @SuppressWarnings("unchecked")
1:   @Override
1:   public V remove(Object key) {
1:     int i = indexOfKey((K)key);
1:     if (i < 0) {
1:       return null;
1:     }
1:     // key not contained
1:     V removed = (V) values[i];
1: 
1:     this.state[i] = REMOVED;
1:     //this.values[i]=0; // delta
1:     this.distinct--;
1: 
1:     if (this.distinct < this.lowWaterMark) {
1:       int newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);
1:       rehash(newCapacity);
1:     }
1: 
1:     return removed;
1:   }
1: 
1:   /**
1:    * Initializes the receiver.
1:    *
1:    * @param initialCapacity the initial capacity of the receiver.
1:    * @param minLoadFactor   the minLoadFactor of the receiver.
1:    * @param maxLoadFactor   the maxLoadFactor of the receiver.
1:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:    *                                  maxLoadFactor)</tt>.
1:    */
1:   @Override
1:   protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:     int capacity = initialCapacity;
1:     super.setUp(capacity, minLoadFactor, maxLoadFactor);
1:     capacity = nextPrime(capacity);
1:     if (capacity == 0) {
1:       capacity = 1;
1:     } // open addressing needs at least one FREE slot at any time.
1: 
1:     this.table = new Object[capacity];
1:     this.values = new Object[capacity];
1:     this.state = new byte[capacity];
1: 
1:     // memory will be exhausted long before this pathological case happens, anyway.
1:     this.minLoadFactor = minLoadFactor;
0:     if (capacity == PrimeFinder.largestPrime) {
1:       this.maxLoadFactor = 1.0;
1:     } else {
1:       this.maxLoadFactor = maxLoadFactor;
1:     }
1: 
1:     this.distinct = 0;
1:     this.freeEntries = capacity; // delta
1: 
1:     // lowWaterMark will be established upon first expansion.
1:     // establishing it now (upon instance construction) would immediately make the table shrink upon first put(...).
1:     // After all the idea of an "initialCapacity" implies violating lowWaterMarks when an object is young.
1:     // See ensureCapacity(...)
1:     this.lowWaterMark = 0;
1:     this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);
1:   }
1: 
1:   /**
1:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
1:    * application can use this operation to minimize the storage of the receiver.
1:    */
1:   @Override
1:   public void trimToSize() {
1:     // * 1.2 because open addressing's performance exponentially degrades beyond that point
1:     // so that even rehashing the table can take very long
1:     int newCapacity = nextPrime((int) (1 + 1.2 * size()));
1:     if (table.length > newCapacity) {
1:       rehash(newCapacity);
1:     }
1:   }
1: 
1:   /**
1:    * Access for unit tests.
1:    * @param capacity
1:    * @param minLoadFactor
1:    * @param maxLoadFactor
1:    */
1:   void getInternalFactors(int[] capacity, 
1:       double[] minLoadFactor, 
1:       double[] maxLoadFactor) {
1:     capacity[0] = table.length;
1:     minLoadFactor[0] = this.minLoadFactor;
1:     maxLoadFactor[0] = this.maxLoadFactor;
1:   }
1: 
1:   private class MapEntry implements Map.Entry<K,V> {
1:     private final K key;
1:     private final V value;
1:     
1:     MapEntry(K key, V value) {
1:       this.key = key;
1:       this.value = value;
1:     }
1: 
1:     @Override
1:     public K getKey() {
1:       return key;
1:     }
1: 
1:     @Override
1:     public V getValue() {
1:       return value;
1:     }
1: 
1:     @Override
1:     public V setValue(V value) {
1:       throw new UnsupportedOperationException("Map.Entry.setValue not supported for OpenHashMap");
1:     }
1:     
1:   }
1: 
1:   /**
1:    * Allocate a set to contain Map.Entry objects for the pairs and return it.
1:    */
1:   @Override
1:   public Set<java.util.Map.Entry<K,V>> entrySet() {
0:     final Set<Entry<K, V>> entries = new OpenHashSet<Map.Entry<K,V>>();
1:     forEachPair(new ObjectObjectProcedure<K,V>() {
1: 
1:       @Override
1:       public boolean apply(K key, V value) {
1:         entries.add(new MapEntry(key, value));
1:         return true;
0:       }});
1:     return entries;
1:   }
1: 
1:   /**
1:    * Allocate a set to contain keys and return it.
1:    * This violates the 'backing' provisions of the map interface.
1:    */
1:   @Override
1:   public Set<K> keySet() {
0:     final Set<K> keys = new OpenHashSet<K>();
1:     forEachKey(new ObjectProcedure<K>() {
1: 
1:       @Override
1:       public boolean apply(K element) {
1:         keys.add(element);
1:         return true;
0:       }});
1:     return keys;
1:   }
1: 
1:   @Override
1:   public void putAll(Map<? extends K,? extends V> m) {
1:     for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
1:       put(e.getKey(), e.getValue());
1:     }
1:   }
1: 
1:   /**
1:    * Allocate a list to contain the values and return it.
1:    * This violates the 'backing' provision of the Map interface.
1:    */
1:   @Override
1:   public Collection<V> values() {
0:     final List<V> valueList = new ArrayList<V>();
1:     forEachPair(new ObjectObjectProcedure<K,V>() {
1: 
1:       @Override
1:       public boolean apply(K key, V value) {
1:         valueList.add(value);
1:         return true;
0:       }});
1:     return valueList;
1:   }
1: 
1:   @SuppressWarnings("unchecked")
1:   @Override
1:   public boolean equals(Object obj) {
0:     if (! (obj instanceof OpenHashMap)) {
1:       return false;
1:     }
1:     final OpenHashMap<K,V> o = (OpenHashMap<K,V>) obj;
1:     if (o.size() != size()) {
1:       return false;
1:     }
1:     final boolean[] equal = new boolean[1];
1:     equal[0] = true;
1:     forEachPair(new ObjectObjectProcedure<K,V>() {
1: 
1:       @Override
1:       public boolean apply(K key, V value) {
1:         Object ov = o.get(key);
1:         if (!value.equals(ov)) {
1:           equal[0] = false;
1:           return false;
1:         }
1:         return true;
0:       }});
1:     return equal[0];
1:   }
1: 
1:   @Override
1:   public String toString() {
1:     final StringBuilder sb = new StringBuilder();
1:     sb.append('{');
1:     forEachPair(new ObjectObjectProcedure<K,V>() {
1: 
1:       @Override
1:       public boolean apply(K key, V value) {
1:         sb.append('[');
1:         sb.append(key);
1:         sb.append(" -> ");
1:         sb.append(value);
1:         sb.append("] ");
1:         return true;
0:       }});
1:     sb.append('}');
1:     return sb.toString();
1:   }
1: }
author:Benson Margulies
-------------------------------------------------------------------------------
commit:ebf9a4d
/////////////////////////////////////////////////////////////////////////
commit:d7351cc
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements. See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership. The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License. You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: /*
0: Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
0: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
0: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
0: that both that copyright notice and this permission notice appear in supporting documentation. 
0: CERN makes no representations about the suitability of this software for any purpose. 
0: It is provided "as is" without expressed or implied warranty.
0: */
0: package org.apache.mahout.math.map;
0: 
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.Collection;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: 
0: import org.apache.mahout.math.function.ObjectObjectProcedure;
0: import org.apache.mahout.math.function.ObjectProcedure;
0: import org.apache.mahout.math.set.AbstractSet;
0: import org.apache.mahout.math.set.OpenHashSet;
0: 
0: /**
0:   * Open hash map. This implements Map, but it does not respect several aspects of the Map contract
0:   * that impose the very sorts of performance penalities that this class exists to avoid.
0:   * {@link #entrySet}, {@link #values}, and {@link #keySet()} do <strong>not</strong> return
0:   * collections that share storage with the main map, and changes to those returned objects
0:   * are <strong>not</strong> reflected in the container.
0:  **/
0: public class OpenHashMap<K,V> extends AbstractSet implements Map<K,V> {
0:   protected static final byte FREE = 0;
0:   protected static final byte FULL = 1;
0:   protected static final byte REMOVED = 2;
0:   protected static final Object NO_KEY_VALUE = null;
0: 
0:   /** The hash table keys. */
0:   protected Object[] table;
0: 
0:   /** The hash table values. */
0:   protected Object[] values;
0: 
0:   /** The state of each hash table entry (FREE, FULL, REMOVED). */
0:   protected byte[] state;
0: 
0:   /** The number of table entries in state==FREE. */
0:   protected int freeEntries;
0: 
0: 
0:   /** Constructs an empty map with default capacity and default load factors. */
0:   public OpenHashMap() {
0:     this(defaultCapacity);
0:   }
0: 
0:   /**
0:    * Constructs an empty map with the specified initial capacity and default load factors.
0:    *
0:    * @param initialCapacity the initial capacity of the map.
0:    * @throws IllegalArgumentException if the initial capacity is less than zero.
0:    */
0:   public OpenHashMap(int initialCapacity) {
0:     this(initialCapacity, defaultMinLoadFactor, defaultMaxLoadFactor);
0:   }
0: 
0:   /**
0:    * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.
0:    *
0:    * @param initialCapacity the initial capacity.
0:    * @param minLoadFactor   the minimum load factor.
0:    * @param maxLoadFactor   the maximum load factor.
0:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
0:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
0:    *                                  maxLoadFactor)</tt>.
0:    */
0:   public OpenHashMap(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
0:     setUp(initialCapacity, minLoadFactor, maxLoadFactor);
0:   }
0: 
0:   /** Removes all (key,value) associations from the receiver. Implicitly calls <tt>trimToSize()</tt>. */
0:   @Override
0:   public void clear() {
0:     Arrays.fill(this.state, 0, state.length - 1, FREE);
0:     distinct = 0;
0:     freeEntries = table.length; // delta
0:     trimToSize();
0:   }
0: 
0:   /**
0:    * Returns a deep copy of the receiver.
0:    *
0:    * @return a deep copy of the receiver.
0:    */
0:   @Override
0:   @SuppressWarnings("unchecked")
0:   public Object clone() {
0:     OpenHashMap copy = (OpenHashMap) super.clone();
0:     copy.table = copy.table.clone();
0:     copy.values = copy.values.clone();
0:     copy.state = copy.state.clone();
0:     return copy;
0:   }
0: 
0:   /**
0:    * Returns <tt>true</tt> if the receiver contains the specified key.
0:    *
0:    * @return <tt>true</tt> if the receiver contains the specified key.
0:    */
0:   @SuppressWarnings("unchecked")
0:   @Override
0:   public boolean containsKey(Object key) {
0:     return indexOfKey((K)key) >= 0;
0:   }
0: 
0:   /**
0:    * Returns <tt>true</tt> if the receiver contains the specified value.
0:    *
0:    * @return <tt>true</tt> if the receiver contains the specified value.
0:    */
0:   @SuppressWarnings("unchecked")
0:   @Override
0:   public boolean containsValue(Object value) {
0:     return indexOfValue((V)value) >= 0;
0:   }
0: 
0:   /**
0:    * Ensures that the receiver can hold at least the specified number of associations without needing to allocate new
0:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This
0:    * method never need be called; it is for performance tuning only. Calling this method before <tt>put()</tt>ing a
0:    * large number of associations boosts performance, because the receiver will grow only once instead of potentially
0:    * many times and hash collisions get less probable.
0:    *
0:    * @param minCapacity the desired minimum capacity.
0:    */
0:   @Override
0:   public void ensureCapacity(int minCapacity) {
0:     if (table.length < minCapacity) {
0:       int newCapacity = nextPrime(minCapacity);
0:       rehash(newCapacity);
0:     }
0:   }
0: 
0:   /**
0:    * Applies a procedure to each key of the receiver, if any. Note: Iterates over the keys in no particular order.
0:    * Subclasses can define a particular order, for example, "sorted by key". All methods which <i>can</i> be expressed
0:    * in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this
0:    * method, even if it is no particular order. This is necessary so that, for example, methods <tt>keys</tt> and
0:    * <tt>values</tt> will yield association pairs, not two uncorrelated lists.
0:    *
0:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
0:    *                  continues.
0:    * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.
0:    */
0:   @SuppressWarnings("unchecked")
0:   public boolean forEachKey(ObjectProcedure<K> procedure) {
0:     for (int i = table.length; i-- > 0;) {
0:       if (state[i] == FULL) {
0:         if (!procedure.apply((K)table[i])) {
0:           return false;
0:         }
0:       }
0:     }
0:     return true;
0:   }
0: 
0:   /**
0:    * Applies a procedure to each (key,value) pair of the receiver, if any. Iteration order is guaranteed to be
0:    * <i>identical</i> to the order used by method {@link #forEachKey(ObjectProcedure)}.
0:    *
0:    * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise
0:    *                  continues.
0:    * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.
0:    */
0:     @SuppressWarnings("unchecked")
0:   public boolean forEachPair(ObjectObjectProcedure<K,V> procedure) {
0:     for (int i = table.length; i-- > 0;) {
0:       if (state[i] == FULL) {
0:         if (!procedure.apply((K)table[i], (V)values[i])) {
0:           return false;
0:         }
0:       }
0:     }
0:     return true;
0:   }
0: 
0:   /**
0:    * Returns the value associated with the specified key. It is often a good idea to first check with {@link
0:    * #containsKey(double)} whether the given key has a value associated or not, i.e. whether there exists an association
0:    * for the given key or not.
0:    *
0:    * @param key the key to be searched for.
0:    * @return the value associated with the specified key; <tt>0</tt> if no such key is present.
0:    */
0:   @SuppressWarnings("unchecked")
0:   @Override
0:   public V get(Object key) {
0:     int i = indexOfKey((K)key);
0:     if (i < 0) {
0:       return null;
0:     } //not contained
0:     return (V)values[i];
0:   }
0: 
0:   /**
0:    * @param key the key to be added to the receiver.
0:    * @return the index where the key would need to be inserted, if it is not already contained. Returns -index-1 if the
0:    *         key is already contained at slot index. Therefore, if the returned index < 0, then it is already contained
0:    *         at slot -index-1. If the returned index >= 0, then it is NOT already contained and should be inserted at
0:    *         slot index.
0:    */
0:   protected int indexOfInsertion(K key) {
0:     Object[] tab = table;
0:     byte[] stat = state;
0:     int length = tab.length;
0: 
0:     int hash = key.hashCode() & 0x7FFFFFFF;
0:     int i = hash % length;
0:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
0:     //int decrement = (hash / length) % length;
0:     if (decrement == 0) {
0:       decrement = 1;
0:     }
0: 
0:     // stop if we find a removed or free slot, or if we find the key itself
0:     // do NOT skip over removed slots (yes, open addressing is like that...)
0:     while (stat[i] == FULL && !equalsMindTheNull(key, tab[i])) {
0:       i -= decrement;
0:       //hashCollisions++;
0:       if (i < 0) {
0:         i += length;
0:       }
0:     }
0: 
0:     if (stat[i] == REMOVED) {
0:       // stop if we find a free slot, or if we find the key itself.
0:       // do skip over removed slots (yes, open addressing is like that...)
0:       // assertion: there is at least one FREE slot.
0:       int j = i;
0:       while (stat[i] != FREE && (stat[i] == REMOVED || tab[i] != key)) {
0:         i -= decrement;
0:         //hashCollisions++;
0:         if (i < 0) {
0:           i += length;
0:         }
0:       }
0:       if (stat[i] == FREE) {
0:         i = j;
0:       }
0:     }
0: 
0: 
0:     if (stat[i] == FULL) {
0:       // key already contained at slot i.
0:       // return a negative number identifying the slot.
0:       return -i - 1;
0:     }
0:     // not already contained, should be inserted at slot i.
0:     // return a number >= 0 identifying the slot.
0:     return i;
0:   }
0: 
0:   /**
0:    * @param key the key to be searched in the receiver.
0:    * @return the index where the key is contained in the receiver, returns -1 if the key was not found.
0:    */
0:   protected int indexOfKey(K key) {
0:     Object[] tab = table;
0:     byte[] stat = state;
0:     int length = tab.length;
0: 
0:     int hash = key.hashCode() & 0x7FFFFFFF;
0:     int i = hash % length;
0:     int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html
0:     //int decrement = (hash / length) % length;
0:     if (decrement == 0) {
0:       decrement = 1;
0:     }
0: 
0:     // stop if we find a free slot, or if we find the key itself.
0:     // do skip over removed slots (yes, open addressing is like that...)
0:     while (stat[i] != FREE && (stat[i] == REMOVED || !equalsMindTheNull(key, tab[i]))) {
0:       i -= decrement;
0:       //hashCollisions++;
0:       if (i < 0) {
0:         i += length;
0:       }
0:     }
0: 
0:     if (stat[i] == FREE) {
0:       return -1;
0:     } // not found
0:     return i; //found, return index where key is contained
0:   }
0: 
0:   /**
0:    * @param value the value to be searched in the receiver.
0:    * @return the index where the value is contained in the receiver, returns -1 if the value was not found.
0:    */
0:   protected int indexOfValue(V value) {
0:     Object[] val = values;
0:     byte[] stat = state;
0: 
0:     for (int i = stat.length; --i >= 0;) {
0:       if (stat[i] == FULL && equalsMindTheNull(val[i], value)) {
0:         return i;
0:       }
0:     }
0: 
0:     return -1; // not found
0:   }
0: 
0:   /**
0:    * Fills all keys contained in the receiver into the specified list. Fills the list, starting at index 0. After this
0:    * call returns the specified list has a new size that equals <tt>this.size()</tt>. 
0:    * This method can be used
0:    * to iterate over the keys of the receiver.
0:    *
0:    * @param list the list to be filled, can have any size.
0:    */
0:   @SuppressWarnings("unchecked")
0:   public void keys(List<K> list) {
0:     list.clear();
0:   
0: 
0:     Object [] tab = table;
0:     byte[] stat = state;
0: 
0:     for (int i = tab.length; i-- > 0;) {
0:       if (stat[i] == FULL) {
0:         list.add((K)tab[i]);
0:       }
0:     }
0:   }
0: 
0:   /**
0:    * Associates the given key with the given value. Replaces any old <tt>(key,someOtherValue)</tt> association, if
0:    * existing.
0:    *
0:    * @param key   the key the value shall be associated with.
0:    * @param value the value to be associated.
0:    * @return <tt>true</tt> if the receiver did not already contain such a key; <tt>false</tt> if the receiver did
0:    *         already contain such a key - the new value has now replaced the formerly associated value.
0:    */
0:   @SuppressWarnings("unchecked")
0:   @Override
0:   public V put(K key, V value) {
0:     int i = indexOfInsertion(key);
0:     V previous = null;
0:     if (i < 0) { //already contained
0:       i = -i - 1;
0:       previous = (V) this.values[i];
0:       this.values[i] = value;
0:       return previous;
0:     }
0: 
0:     if (this.distinct > this.highWaterMark) {
0:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
0:       /*
0:       log.info("grow rehashing ");
0:       log.info("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");
0:       */
0:       rehash(newCapacity);
0:       return put(key, value);
0:     }
0: 
0:     this.table[i] = key;
0:     this.values[i] = value;
0:     if (this.state[i] == FREE) {
0:       this.freeEntries--;
0:     }
0:     this.state[i] = FULL;
0:     this.distinct++;
0: 
0:     if (this.freeEntries < 1) { //delta
0:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
0:       rehash(newCapacity);
0:     }
0: 
0:     return null;
0:   }
0: 
0:   /**
0:    * Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called
0:    * automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water
0:    * mark.
0:    */
0:   @SuppressWarnings("unchecked")
0:   protected void rehash(int newCapacity) {
0:     int oldCapacity = table.length;
0:     //if (oldCapacity == newCapacity) return;
0: 
0:     Object[] oldTable = table;
0:     Object[] oldValues = values;
0:     byte[] oldState = state;
0: 
0:     Object[] newTable = new Object[newCapacity];
0:     Object[] newValues = new Object[newCapacity];
0:     byte[] newState = new byte[newCapacity];
0: 
0:     this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
0:     this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);
0: 
0:     this.table = newTable;
0:     this.values = newValues;
0:     this.state = newState;
0:     this.freeEntries = newCapacity - this.distinct; // delta
0: 
0:     for (int i = oldCapacity; i-- > 0;) {
0:       if (oldState[i] == FULL) {
0:         Object element = oldTable[i];
0:         int index = indexOfInsertion((K)element);
0:         newTable[index] = element;
0:         newValues[index] = oldValues[i];
0:         newState[index] = FULL;
0:       }
0:     }
0:   }
0: 
0:   /**
0:    * Removes the given key with its associated element from the receiver, if present.
0:    *
0:    * @param key the key to be removed from the receiver.
0:    * @return <tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.
0:    */
0:   @SuppressWarnings("unchecked")
0:   @Override
0:   public V remove(Object key) {
0:     V removed = null;
0:     int i = indexOfKey((K)key);
0:     if (i < 0) {
0:       return null;
0:     } else {// key not contained
0:       removed = (V)values[i];
0:     }
0: 
0:     this.state[i] = REMOVED;
0:     //this.values[i]=0; // delta
0:     this.distinct--;
0: 
0:     if (this.distinct < this.lowWaterMark) {
0:       int newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);
0:       /*
0:       if (table.length != newCapacity) {
0:         log.info("shrink rehashing ");
0:         log.info("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");
0:       }
0:       */
0:       rehash(newCapacity);
0:     }
0: 
0:     return removed;
0:   }
0: 
0:   /**
0:    * Initializes the receiver.
0:    *
0:    * @param initialCapacity the initial capacity of the receiver.
0:    * @param minLoadFactor   the minLoadFactor of the receiver.
0:    * @param maxLoadFactor   the maxLoadFactor of the receiver.
0:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
0:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
0:    *                                  maxLoadFactor)</tt>.
0:    */
0:   @Override
0:   protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
0:     int capacity = initialCapacity;
0:     super.setUp(capacity, minLoadFactor, maxLoadFactor);
0:     capacity = nextPrime(capacity);
0:     if (capacity == 0) {
0:       capacity = 1;
0:     } // open addressing needs at least one FREE slot at any time.
0: 
0:     this.table = new Object[capacity];
0:     this.values = new Object[capacity];
0:     this.state = new byte[capacity];
0: 
0:     // memory will be exhausted long before this pathological case happens, anyway.
0:     this.minLoadFactor = minLoadFactor;
0:     if (capacity == PrimeFinder.largestPrime) {
0:       this.maxLoadFactor = 1.0;
0:     } else {
0:       this.maxLoadFactor = maxLoadFactor;
0:     }
0: 
0:     this.distinct = 0;
0:     this.freeEntries = capacity; // delta
0: 
0:     // lowWaterMark will be established upon first expansion.
0:     // establishing it now (upon instance construction) would immediately make the table shrink upon first put(...).
0:     // After all the idea of an "initialCapacity" implies violating lowWaterMarks when an object is young.
0:     // See ensureCapacity(...)
0:     this.lowWaterMark = 0;
0:     this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);
0:   }
0: 
0:   /**
0:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
0:    * application can use this operation to minimize the storage of the receiver.
0:    */
0:   @Override
0:   public void trimToSize() {
0:     // * 1.2 because open addressing's performance exponentially degrades beyond that point
0:     // so that even rehashing the table can take very long
0:     int newCapacity = nextPrime((int) (1 + 1.2 * size()));
0:     if (table.length > newCapacity) {
0:       rehash(newCapacity);
0:     }
0:   }
0: 
0:   /**
0:    * Access for unit tests.
0:    * @param capacity
0:    * @param minLoadFactor
0:    * @param maxLoadFactor
0:    */
0:   void getInternalFactors(int[] capacity, 
0:       double[] minLoadFactor, 
0:       double[] maxLoadFactor) {
0:     capacity[0] = table.length;
0:     minLoadFactor[0] = this.minLoadFactor;
0:     maxLoadFactor[0] = this.maxLoadFactor;
0:   }
0: 
0:   private class MapEntry implements Map.Entry<K,V> {
0:     private K key;
0:     private V value;
0:     
0:     MapEntry(K key, V value) {
0:       this.key = key;
0:       this.value = value;
0:     }
0: 
0:     @Override
0:     public K getKey() {
0:       return key;
0:     }
0: 
0:     @Override
0:     public V getValue() {
0:       return value;
0:     }
0: 
0:     @Override
0:     public V setValue(V value) {
0:       throw new UnsupportedOperationException("Map.Entry.setValue not supported for OpenHashMap");
0:     }
0:     
0:   }
0: 
0:   /**
0:    * Allocate a set to contain Map.Entry objects for the pairs and return it.
0:    */
0:   @Override
0:   public Set<java.util.Map.Entry<K,V>> entrySet() {
0:     final OpenHashSet<Map.Entry<K,V>> entries = new OpenHashSet<Map.Entry<K,V>>();
0:     forEachPair(new ObjectObjectProcedure<K,V>() {
0: 
0:       @Override
0:       public boolean apply(K key, V value) {
0:         entries.add(new MapEntry(key, value));
0:         return true;
0:       }});
0:     return entries;
0:   }
0: 
0:   /**
0:    * Allocate a set to contain keys and return it.
0:    * This violates the 'backing' provisions of the map interface.
0:    */
0:   @Override
0:   public Set<K> keySet() {
0:     final OpenHashSet<K> keys = new OpenHashSet<K>();
0:     forEachKey(new ObjectProcedure<K>() {
0: 
0:       @Override
0:       public boolean apply(K element) {
0:         keys.add(element);
0:         return true;
0:       }});
0:     return keys;
0:   }
0: 
0:   @Override
0:   public void putAll(Map<? extends K,? extends V> m) {
0:     for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
0:       put(e.getKey(), e.getValue());
0:     }
0:   }
0: 
0:   /**
0:    * Allocate a list to contain the values and return it.
0:    * This violates the 'backing' provision of the Map interface.
0:    */
0:   @Override
0:   public Collection<V> values() {
0:     final List<V> valueList = new ArrayList<V>();
0:     forEachPair(new ObjectObjectProcedure<K,V>() {
0: 
0:       @Override
0:       public boolean apply(K key, V value) {
0:         valueList.add(value);
0:         return true;
0:       }});
0:     return valueList;
0:   }
0: 
0:   @SuppressWarnings("unchecked")
0:   @Override
0:   public boolean equals(Object obj) {
0:     if (! (obj instanceof OpenHashMap)) {
0:       return false;
0:     }
0:     final OpenHashMap o = (OpenHashMap) obj;
0:     if (o.size() != size()) {
0:       return false;
0:     }
0:     final boolean[] equal = new boolean[1];
0:     equal[0] = true;
0:     forEachPair(new ObjectObjectProcedure<K,V>() {
0: 
0:       @Override
0:       public boolean apply(K key, V value) {
0:         Object ov = o.get(key);
0:         if (!value.equals(ov)) {
0:           equal[0] = false;
0:           return false;
0:         }
0:         return true;
0:       }});
0:     return equal[0];
0:   }
0: 
0:   @Override
0:   public String toString() {
0:     final StringBuilder sb = new StringBuilder();
0:     sb.append("{");
0:     forEachPair(new ObjectObjectProcedure<K,V>() {
0: 
0:       @Override
0:       public boolean apply(K key, V value) {
0:         sb.append("[");
0:         sb.append(key);
0:         sb.append(" -> ");
0:         sb.append(value);
0:         sb.append("] ");
0:         return true;
0:       }});
0:     sb.append("}");
0:     return sb.toString();
0:   }
0: }
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:ea65197
/////////////////////////////////////////////////////////////////////////
0:     OpenHashMap<K,V> copy = (OpenHashMap<K,V>) super.clone();
/////////////////////////////////////////////////////////////////////////
0:       V previous = (V) this.values[i];
/////////////////////////////////////////////////////////////////////////
0:     // key not contained
0:     V removed = (V) values[i];
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final K key;
0:     private final V value;
/////////////////////////////////////////////////////////////////////////
0:     final Set<Entry<K, V>> entries = new OpenHashSet<Map.Entry<K,V>>();
/////////////////////////////////////////////////////////////////////////
0:     final Set<K> keys = new OpenHashSet<K>();
/////////////////////////////////////////////////////////////////////////
0:     final OpenHashMap<K,V> o = (OpenHashMap<K,V>) obj;
/////////////////////////////////////////////////////////////////////////
0:     sb.append('{');
0:         sb.append('[');
0:     sb.append('}');
author:Jacob Alexander Mannix
-------------------------------------------------------------------------------
commit:a258fa2
/////////////////////////////////////////////////////////////////////////
0:     Arrays.fill(this.state, FREE);
============================================================================