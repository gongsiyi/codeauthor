1:8049eff: /**
1:8049eff:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:8049eff:  * contributor license agreements.  See the NOTICE file distributed with
1:8049eff:  * this work for additional information regarding copyright ownership.
1:8049eff:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:8049eff:  * (the "License"); you may not use this file except in compliance with
1:8049eff:  * the License.  You may obtain a copy of the License at
1:8049eff:  *
1:8049eff:  *     http://www.apache.org/licenses/LICENSE-2.0
1:8049eff:  *
1:8049eff:  * Unless required by applicable law or agreed to in writing, software
1:8049eff:  * distributed under the License is distributed on an "AS IS" BASIS,
1:8049eff:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8049eff:  * See the License for the specific language governing permissions and
1:8049eff:  * limitations under the License.
1:8049eff:  */
1:529b114: 
1:8d102ea: package org.apache.mahout.clustering.iterator;
1:529b114: 
1:8049eff: import java.io.IOException;
1:8049eff: import java.util.List;
1:529b114: 
1:8049eff: import org.apache.hadoop.conf.Configuration;
1:8049eff: import org.apache.hadoop.fs.FileSystem;
1:8049eff: import org.apache.hadoop.fs.Path;
1:8d102ea: import org.apache.mahout.clustering.AbstractCluster;
1:8d102ea: import org.apache.mahout.clustering.Cluster;
1:8d102ea: import org.apache.mahout.clustering.ClusteringTestUtils;
1:8d102ea: import org.apache.mahout.clustering.classify.ClusterClassifier;
1:8049eff: import org.apache.mahout.clustering.fuzzykmeans.SoftCluster;
1:8049eff: import org.apache.mahout.clustering.kmeans.TestKmeansClustering;
1:8049eff: import org.apache.mahout.common.MahoutTestCase;
1:d521b72: import org.apache.mahout.common.distance.CosineDistanceMeasure;
1:8049eff: import org.apache.mahout.common.distance.DistanceMeasure;
1:8049eff: import org.apache.mahout.common.distance.ManhattanDistanceMeasure;
1:8049eff: import org.apache.mahout.math.DenseVector;
1:8049eff: import org.apache.mahout.math.Vector;
1:4dd8881: import org.apache.mahout.math.VectorWritable;
1:8049eff: import org.junit.Test;
1:529b114: 
1:74f849b: import com.google.common.collect.Lists;
1:529b114: 
1:8049eff: public final class TestClusterClassifier extends MahoutTestCase {
1:529b114:   
1:a6bdcbb:   private static ClusterClassifier newDMClassifier() {
1:74f849b:     List<Cluster> models = Lists.newArrayList();
3:8049eff:     DistanceMeasure measure = new ManhattanDistanceMeasure();
1:2153bb9:     models.add(new DistanceMeasureCluster(new DenseVector(2).assign(1), 0, measure));
1:8049eff:     models.add(new DistanceMeasureCluster(new DenseVector(2), 1, measure));
1:2153bb9:     models.add(new DistanceMeasureCluster(new DenseVector(2).assign(-1), 2, measure));
1:76e80dc:     return new ClusterClassifier(models, new KMeansClusteringPolicy());
1:d608a88:   }
1:529b114:   
1:76e80dc:   private static ClusterClassifier newKlusterClassifier() {
1:74f849b:     List<Cluster> models = Lists.newArrayList();
1:8049eff:     DistanceMeasure measure = new ManhattanDistanceMeasure();
1:1ac30a4:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(1), 0, measure));
1:1ac30a4:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2), 1, measure));
1:1ac30a4:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(-1), 2, measure));
1:76e80dc:     return new ClusterClassifier(models, new KMeansClusteringPolicy());
1:d608a88:   }
1:529b114:   
1:d521b72:   private static ClusterClassifier newCosineKlusterClassifier() {
1:74f849b:     List<Cluster> models = Lists.newArrayList();
1:d521b72:     DistanceMeasure measure = new CosineDistanceMeasure();
1:d521b72:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(1), 0, measure));
1:d521b72:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2), 1, measure));
1:d521b72:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(-1), 2, measure));
1:d521b72:     return new ClusterClassifier(models, new KMeansClusteringPolicy());
1:d521b72:   }
1:d521b72: 
1:a6bdcbb:   private static ClusterClassifier newSoftClusterClassifier() {
1:74f849b:     List<Cluster> models = Lists.newArrayList();
1:8049eff:     DistanceMeasure measure = new ManhattanDistanceMeasure();
1:8049eff:     models.add(new SoftCluster(new DenseVector(2).assign(1), 0, measure));
1:8049eff:     models.add(new SoftCluster(new DenseVector(2), 1, measure));
1:8049eff:     models.add(new SoftCluster(new DenseVector(2).assign(-1), 2, measure));
1:76e80dc:     return new ClusterClassifier(models, new FuzzyKMeansClusteringPolicy());
11:8049eff:   }
1:529b114:   
1:2153bb9:   private ClusterClassifier writeAndRead(ClusterClassifier classifier) throws IOException {
1:8049eff:     Path path = new Path(getTestTempDirPath(), "output");
1:76e80dc:     classifier.writeToSeqFiles(path);
1:76e80dc:     ClusterClassifier newClassifier = new ClusterClassifier();
1:e3ec9d8:     newClassifier.readFromSeqFiles(getConfiguration(), path);
1:76e80dc:     return newClassifier;
1:4dd8881:   }
1:529b114:   
5:8049eff:   @Test
1:8049eff:   public void testDMClusterClassification() {
1:8049eff:     ClusterClassifier classifier = newDMClassifier();
3:8049eff:     Vector pdf = classifier.classify(new DenseVector(2));
1:e0751ea:     assertEquals("[0,0]", "[0.2,0.6,0.2]", AbstractCluster.formatVector(pdf, null));
3:8049eff:     pdf = classifier.classify(new DenseVector(2).assign(2));
1:e0751ea:     assertEquals("[2,2]", "[0.493,0.296,0.211]", AbstractCluster.formatVector(pdf, null));
1:4dd8881:   }
1:529b114:   
1:8049eff:   @Test
1:8049eff:   public void testClusterClassification() {
1:76e80dc:     ClusterClassifier classifier = newKlusterClassifier();
1:8049eff:     Vector pdf = classifier.classify(new DenseVector(2));
2:e0751ea:     assertEquals("[0,0]", "[0.2,0.6,0.2]", AbstractCluster.formatVector(pdf, null));
1:8049eff:     pdf = classifier.classify(new DenseVector(2).assign(2));
2:e0751ea:     assertEquals("[2,2]", "[0.493,0.296,0.211]", AbstractCluster.formatVector(pdf, null));
1:8049eff:   }
1:529b114:   
1:8049eff:   @Test
1:8049eff:   public void testSoftClusterClassification() {
1:8049eff:     ClusterClassifier classifier = newSoftClusterClassifier();
1:8049eff:     Vector pdf = classifier.classify(new DenseVector(2));
1:e0751ea:     assertEquals("[0,0]", "[0.0,1.0,0.0]", AbstractCluster.formatVector(pdf, null));
1:8049eff:     pdf = classifier.classify(new DenseVector(2).assign(2));
1:e0751ea:     assertEquals("[2,2]", "[0.735,0.184,0.082]", AbstractCluster.formatVector(pdf, null));
1:8049eff:   }
1:529b114:   
1:8049eff:   @Test
1:8049eff:   public void testDMClassifierSerialization() throws Exception {
1:8049eff:     ClusterClassifier classifier = newDMClassifier();
2:8049eff:     ClusterClassifier classifierOut = writeAndRead(classifier);
2:2153bb9:     assertEquals(classifier.getModels().size(), classifierOut.getModels().size());
2:2153bb9:     assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass()
2:2153bb9:         .getName());
1:8049eff:   }
1:529b114:   
1:8049eff:   @Test
1:8049eff:   public void testClusterClassifierSerialization() throws Exception {
1:76e80dc:     ClusterClassifier classifier = newKlusterClassifier();
1:8049eff:     ClusterClassifier classifierOut = writeAndRead(classifier);
1:2153bb9:     assertEquals(classifier.getModels().size(), classifierOut.getModels().size());
1:2153bb9:     assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass()
1:2153bb9:         .getName());
1:8049eff:   }
1:529b114:   
1:8049eff:   @Test
1:8049eff:   public void testSoftClusterClassifierSerialization() throws Exception {
1:8049eff:     ClusterClassifier classifier = newSoftClusterClassifier();
1:8049eff:     ClusterClassifier classifierOut = writeAndRead(classifier);
1:2153bb9:     assertEquals(classifier.getModels().size(), classifierOut.getModels().size());
1:2153bb9:     assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass()
1:2153bb9:         .getName());
1:8049eff:   }
1:529b114:   
1:8049eff:   @Test
1:8049eff:   public void testClusterIteratorKMeans() {
1:2153bb9:     List<Vector> data = TestKmeansClustering.getPoints(TestKmeansClustering.REFERENCE);
1:76e80dc:     ClusterClassifier prior = newKlusterClassifier();
1:229aeff:     ClusterClassifier posterior = ClusterIterator.iterate(data, prior, 5);
1:8049eff:     assertEquals(3, posterior.getModels().size());
1:8049eff:     for (Cluster cluster : posterior.getModels()) {
1:4dd8881:       System.out.println(cluster.asFormatString(null));
1:d521b72:     }
1:4dd8881:   }
1:d521b72:   
1:d521b72:   @Test
1:8049eff:   public void testClusterIteratorDirichlet() {
1:2153bb9:     List<Vector> data = TestKmeansClustering.getPoints(TestKmeansClustering.REFERENCE);
1:76e80dc:     ClusterClassifier prior = newKlusterClassifier();
1:229aeff:     ClusterClassifier posterior = ClusterIterator.iterate(data, prior, 5);
1:8049eff:     assertEquals(3, posterior.getModels().size());
1:8049eff:     for (Cluster cluster : posterior.getModels()) {
1:4dd8881:       System.out.println(cluster.asFormatString(null));
1:4dd8881:     }
1:8049eff:   }
1:529b114:   
1:4dd8881:   @Test
1:4dd8881:   public void testSeqFileClusterIteratorKMeans() throws IOException {
1:4dd8881:     Path pointsPath = getTestTempDirPath("points");
1:4dd8881:     Path priorPath = getTestTempDirPath("prior");
1:4dd8881:     Path outPath = getTestTempDirPath("output");
1:e3ec9d8:     Configuration conf = getConfiguration();
1:1de8cec:     FileSystem fs = FileSystem.get(pointsPath.toUri(), conf);
1:2153bb9:     List<VectorWritable> points = TestKmeansClustering.getPointsWritable(TestKmeansClustering.REFERENCE);
1:2153bb9:     ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);
1:4dd8881:     Path path = new Path(priorPath, "priorClassifier");
1:76e80dc:     ClusterClassifier prior = newKlusterClassifier();
1:76e80dc:     prior.writeToSeqFiles(path);
1:4dd8881:     assertEquals(3, prior.getModels().size());
1:4dd8881:     System.out.println("Prior");
1:4dd8881:     for (Cluster cluster : prior.getModels()) {
1:4dd8881:       System.out.println(cluster.asFormatString(null));
1:4dd8881:     }
1:229aeff:     ClusterIterator.iterateSeq(conf, pointsPath, path, outPath, 5);
1:529b114:     
1:3eba6f2:     for (int i = 1; i <= 4; i++) {
1:4dd8881:       System.out.println("Classifier-" + i);
1:76e80dc:       ClusterClassifier posterior = new ClusterClassifier();
1:3eba6f2:       String name = i == 4 ? "clusters-4-final" : "clusters-" + i;
1:590ffed:       posterior.readFromSeqFiles(conf, new Path(outPath, name));
1:4dd8881:       assertEquals(3, posterior.getModels().size());
1:4dd8881:       for (Cluster cluster : posterior.getModels()) {
1:2153bb9:         System.out.println(cluster.asFormatString(null));
1:2153bb9:       }
1:529b114:       
1:2153bb9:     }
1:2153bb9:   }
1:529b114:   
1:2153bb9:   @Test
1:229aeff:   public void testMRFileClusterIteratorKMeans() throws Exception {
1:2153bb9:     Path pointsPath = getTestTempDirPath("points");
1:2153bb9:     Path priorPath = getTestTempDirPath("prior");
1:2153bb9:     Path outPath = getTestTempDirPath("output");
1:e3ec9d8:     Configuration conf = getConfiguration();
1:2153bb9:     FileSystem fs = FileSystem.get(pointsPath.toUri(), conf);
1:2153bb9:     List<VectorWritable> points = TestKmeansClustering.getPointsWritable(TestKmeansClustering.REFERENCE);
1:2153bb9:     ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);
1:2153bb9:     Path path = new Path(priorPath, "priorClassifier");
1:76e80dc:     ClusterClassifier prior = newKlusterClassifier();
1:76e80dc:     prior.writeToSeqFiles(path);
1:3eba6f2:     ClusteringPolicy policy = new KMeansClusteringPolicy();
1:3eba6f2:     ClusterClassifier.writePolicy(policy, path);
1:2153bb9:     assertEquals(3, prior.getModels().size());
1:2153bb9:     System.out.println("Prior");
1:2153bb9:     for (Cluster cluster : prior.getModels()) {
1:2153bb9:       System.out.println(cluster.asFormatString(null));
1:2153bb9:     }
1:229aeff:     ClusterIterator.iterateMR(conf, pointsPath, path, outPath, 5);
1:529b114:     
1:3eba6f2:     for (int i = 1; i <= 4; i++) {
1:2153bb9:       System.out.println("Classifier-" + i);
1:76e80dc:       ClusterClassifier posterior = new ClusterClassifier();
1:3eba6f2:       String name = i == 4 ? "clusters-4-final" : "clusters-" + i;
1:590ffed:       posterior.readFromSeqFiles(conf, new Path(outPath, name));
1:2153bb9:       assertEquals(3, posterior.getModels().size());
1:2153bb9:       for (Cluster cluster : posterior.getModels()) {
1:4dd8881:         System.out.println(cluster.asFormatString(null));
1:4dd8881:       }     
1:8049eff:     }
1:8049eff:   }
1:529b114:   
1:8049eff:   @Test
1:d521b72:   public void testCosineKlusterClassification() {
1:d521b72:     ClusterClassifier classifier = newCosineKlusterClassifier();
1:d521b72:     Vector pdf = classifier.classify(new DenseVector(2));
1:e0751ea:     assertEquals("[0,0]", "[0.333,0.333,0.333]", AbstractCluster.formatVector(pdf, null));
1:d521b72:     pdf = classifier.classify(new DenseVector(2).assign(2));
1:e0751ea:     assertEquals("[2,2]", "[0.429,0.429,0.143]", AbstractCluster.formatVector(pdf, null));
1:d521b72:   }
1:8049eff: }
============================================================================
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:Andrew Musselman
-------------------------------------------------------------------------------
commit:88bddb0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e0751ea
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("[0,0]", "[0.2,0.6,0.2]", AbstractCluster.formatVector(pdf, null));
1:     assertEquals("[2,2]", "[0.493,0.296,0.211]", AbstractCluster.formatVector(pdf, null));
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("[0,0]", "[0.2,0.6,0.2]", AbstractCluster.formatVector(pdf, null));
1:     assertEquals("[2,2]", "[0.493,0.296,0.211]", AbstractCluster.formatVector(pdf, null));
1:     assertEquals("[0,0]", "[0.2,0.6,0.2]", AbstractCluster.formatVector(pdf, null));
1:     assertEquals("[2,2]", "[0.493,0.296,0.211]", AbstractCluster.formatVector(pdf, null));
1:     assertEquals("[0,0]", "[0.0,1.0,0.0]", AbstractCluster.formatVector(pdf, null));
1:     assertEquals("[2,2]", "[0.735,0.184,0.082]", AbstractCluster.formatVector(pdf, null));
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("[0,0]", "[0.333,0.333,0.333]", AbstractCluster.formatVector(pdf, null));
1:     assertEquals("[2,2]", "[0.429,0.429,0.143]", AbstractCluster.formatVector(pdf, null));
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:b60c909
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:74f849b
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
1:     List<Cluster> models = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:     List<Cluster> models = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:     List<Cluster> models = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:     List<Cluster> models = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
0:     List<Cluster> models = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
0:     List<Cluster> models = Lists.newArrayList();
commit:d608a88
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.io.Closeables;
/////////////////////////////////////////////////////////////////////////
0:     try {
0:       writer.append(key, classifier);
0:     } finally {
0:       Closeables.closeQuietly(writer);
1:     }
/////////////////////////////////////////////////////////////////////////
0:     try {
0:       reader.next(key, classifierOut);
0:     } finally {
0:       Closeables.closeQuietly(reader);
1:     }
author:Isabel Drost
-------------------------------------------------------------------------------
commit:e3ec9d8
/////////////////////////////////////////////////////////////////////////
1:     newClassifier.readFromSeqFiles(getConfiguration(), path);
/////////////////////////////////////////////////////////////////////////
1:     Configuration conf = getConfiguration();
/////////////////////////////////////////////////////////////////////////
1:     Configuration conf = getConfiguration();
author:dfilimon
-------------------------------------------------------------------------------
commit:e5ee197
/////////////////////////////////////////////////////////////////////////
0:     assertEquals("[2,2]", "[0.429, 0.429, 0.143]", AbstractCluster.formatVector(pdf, null));
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:229aeff
/////////////////////////////////////////////////////////////////////////
1:     ClusterClassifier posterior = ClusterIterator.iterate(data, prior, 5);
/////////////////////////////////////////////////////////////////////////
1:     ClusterClassifier posterior = ClusterIterator.iterate(data, prior, 5);
/////////////////////////////////////////////////////////////////////////
1:     ClusterIterator.iterateSeq(conf, pointsPath, path, outPath, 5);
/////////////////////////////////////////////////////////////////////////
1:   public void testMRFileClusterIteratorKMeans() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     ClusterIterator.iterateMR(conf, pointsPath, path, outPath, 5);
commit:1de8cec
/////////////////////////////////////////////////////////////////////////
1:     FileSystem fs = FileSystem.get(pointsPath.toUri(), conf);
commit:3f3cc8a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:   @Test(expected = UnsupportedOperationException.class)
/////////////////////////////////////////////////////////////////////////
0:     classifier.classify(new DenseVector(2));
commit:a6bdcbb
/////////////////////////////////////////////////////////////////////////
1:   private static ClusterClassifier newDMClassifier() {
/////////////////////////////////////////////////////////////////////////
0:     return new ClusterClassifier(models);
0:   private static ClusterClassifier newClusterClassifier() {
/////////////////////////////////////////////////////////////////////////
0:     return new ClusterClassifier(models);
1:   private static ClusterClassifier newSoftClusterClassifier() {
0:     return new ClusterClassifier(models);
0:   private static ClusterClassifier newGaussianClassifier() {
/////////////////////////////////////////////////////////////////////////
0:     return new ClusterClassifier(models);
/////////////////////////////////////////////////////////////////////////
0:   private static void writeClassifier(ClusterClassifier classifier,
0:                                       Configuration config,
0:                                       Path path,
0:                                       FileSystem fs) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:   private static ClusterClassifier readClassifier(Configuration config,
0:                                                   Path path,
0:                                                   FileSystem fs) throws IOException {
0:     Writable key = new Text();
author:Jeff Eastman
-------------------------------------------------------------------------------
commit:d521b72
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.common.distance.CosineDistanceMeasure;
/////////////////////////////////////////////////////////////////////////
1:   private static ClusterClassifier newCosineKlusterClassifier() {
0:     List<Cluster> models = Lists.newArrayList();
1:     DistanceMeasure measure = new CosineDistanceMeasure();
1:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(1), 0, measure));
1:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2), 1, measure));
1:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(-1), 2, measure));
1:     return new ClusterClassifier(models, new KMeansClusteringPolicy());
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:       }     
1:   
1:   @Test
1:   public void testCosineKlusterClassification() {
1:     ClusterClassifier classifier = newCosineKlusterClassifier();
1:     Vector pdf = classifier.classify(new DenseVector(2));
0:     assertEquals("[0,0]", "[0.333, 0.333, 0.333]", AbstractCluster.formatVector(pdf, null));
1:     pdf = classifier.classify(new DenseVector(2).assign(2));
0:     assertEquals("[2,2]", "[0.545, 0.273, 0.182]", AbstractCluster.formatVector(pdf, null));
1:   }
commit:590ffed
/////////////////////////////////////////////////////////////////////////
0:     newClassifier.readFromSeqFiles(new Configuration(), path);
/////////////////////////////////////////////////////////////////////////
0:     new ClusterIterator().iterateSeq(conf, pointsPath, path, outPath, 5);
1:       posterior.readFromSeqFiles(conf, new Path(outPath, name));
/////////////////////////////////////////////////////////////////////////
0:     new ClusterIterator().iterateMR(conf, pointsPath, path, outPath, 5);
1:       posterior.readFromSeqFiles(conf, new Path(outPath, name));
commit:3eba6f2
/////////////////////////////////////////////////////////////////////////
0:     ClusterIterator iterator = new ClusterIterator();
/////////////////////////////////////////////////////////////////////////
0:     ClusterIterator iterator = new ClusterIterator();
/////////////////////////////////////////////////////////////////////////
0:     new ClusterIterator().iterateSeq(pointsPath, path, outPath, 5);
1:     for (int i = 1; i <= 4; i++) {
1:       String name = i == 4 ? "clusters-4-final" : "clusters-" + i;
0:       posterior.readFromSeqFiles(new Path(outPath, name));
/////////////////////////////////////////////////////////////////////////
1:     ClusteringPolicy policy = new KMeansClusteringPolicy();
1:     ClusterClassifier.writePolicy(policy, path);
0:     new ClusterIterator().iterateMR(pointsPath, path, outPath, 5);
1:     for (int i = 1; i <= 4; i++) {
1:       String name = i == 4 ? "clusters-4-final" : "clusters-" + i;
0:       posterior.readFromSeqFiles(new Path(outPath, name));
commit:8d102ea
/////////////////////////////////////////////////////////////////////////
1: package org.apache.mahout.clustering.iterator;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.clustering.AbstractCluster;
1: import org.apache.mahout.clustering.Cluster;
1: import org.apache.mahout.clustering.ClusteringTestUtils;
1: import org.apache.mahout.clustering.classify.ClusterClassifier;
0: import org.apache.mahout.clustering.iterator.CanopyClusteringPolicy;
0: import org.apache.mahout.clustering.iterator.ClusterIterator;
0: import org.apache.mahout.clustering.iterator.ClusteringPolicy;
0: import org.apache.mahout.clustering.iterator.DirichletClusteringPolicy;
0: import org.apache.mahout.clustering.iterator.DistanceMeasureCluster;
0: import org.apache.mahout.clustering.iterator.FuzzyKMeansClusteringPolicy;
0: import org.apache.mahout.clustering.iterator.KMeansClusteringPolicy;
0: import org.apache.mahout.clustering.iterator.MeanShiftClusteringPolicy;
commit:76e80dc
/////////////////////////////////////////////////////////////////////////
1:     return new ClusterClassifier(models, new KMeansClusteringPolicy());
1:   private static ClusterClassifier newKlusterClassifier() {
1:     return new ClusterClassifier(models, new KMeansClusteringPolicy());
/////////////////////////////////////////////////////////////////////////
1:     return new ClusterClassifier(models, new FuzzyKMeansClusteringPolicy());
/////////////////////////////////////////////////////////////////////////
0:     return new ClusterClassifier(models, new DirichletClusteringPolicy(3, 1.0));
1:     classifier.writeToSeqFiles(path);
1:     ClusterClassifier newClassifier = new ClusterClassifier();
0:     newClassifier.readFromSeqFiles(path);
1:     return newClassifier;
/////////////////////////////////////////////////////////////////////////
0:     ClusterClassifier classifier = new ClusterClassifier(models, new CanopyClusteringPolicy());
/////////////////////////////////////////////////////////////////////////
1:     ClusterClassifier classifier = newKlusterClassifier();
/////////////////////////////////////////////////////////////////////////
0:     ClusterClassifier classifier = new ClusterClassifier(models, new MeanShiftClusteringPolicy());
/////////////////////////////////////////////////////////////////////////
1:     ClusterClassifier classifier = newKlusterClassifier();
/////////////////////////////////////////////////////////////////////////
1:     ClusterClassifier prior = newKlusterClassifier();
/////////////////////////////////////////////////////////////////////////
1:     ClusterClassifier prior = newKlusterClassifier();
/////////////////////////////////////////////////////////////////////////
1:     ClusterClassifier prior = newKlusterClassifier();
1:     prior.writeToSeqFiles(path);
0:     ClusterIterator iterator = new ClusterIterator(prior.getPolicy());
1:       ClusterClassifier posterior = new ClusterClassifier();
0:       posterior.readFromSeqFiles(new Path(outPath, "classifier-" + i));
/////////////////////////////////////////////////////////////////////////
1:     ClusterClassifier prior = newKlusterClassifier();
1:     prior.writeToSeqFiles(path);
/////////////////////////////////////////////////////////////////////////
0:     iterator.iterateMR(pointsPath, path, outPath, 3);
0:     for (int i = 1; i <= 3; i++) {
1:       ClusterClassifier posterior = new ClusterClassifier();
0:       posterior.readFromSeqFiles(new Path(outPath, "clusters-" + i));
commit:1ac30a4
/////////////////////////////////////////////////////////////////////////
1:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(1), 0, measure));
1:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2), 1, measure));
1:     models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(-1), 2, measure));
commit:529b114
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:       
1:   
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
0:       
commit:2153bb9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Lists;
0: 
0: 
1:     models.add(new DistanceMeasureCluster(new DenseVector(2).assign(1), 0, measure));
1:     models.add(new DistanceMeasureCluster(new DenseVector(2).assign(-1), 2, measure));
0: 
0:     models.add(new org.apache.mahout.clustering.kmeans.Cluster(new DenseVector(2).assign(1), 0, measure));
0:     models.add(new org.apache.mahout.clustering.kmeans.Cluster(new DenseVector(2), 1, measure));
0:     models.add(new org.apache.mahout.clustering.kmeans.Cluster(new DenseVector(2).assign(-1), 2, measure));
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     models.add(new GaussianCluster(new DenseVector(2).assign(1), new DenseVector(2).assign(1), 0));
0:     models.add(new GaussianCluster(new DenseVector(2), new DenseVector(2).assign(1), 1));
0:     models.add(new GaussianCluster(new DenseVector(2).assign(-1), new DenseVector(2).assign(1), 2));
0: 
1:   private ClusterClassifier writeAndRead(ClusterClassifier classifier) throws IOException {
0:     ClusterIterator.writeClassifier(classifier, path);
0:     return ClusterIterator.readClassifier(path);
0: 
0:     assertEquals("[0,0]", "[0.200, 0.600, 0.200]", AbstractCluster.formatVector(pdf, null));
0:     assertEquals("[2,2]", "[0.493, 0.296, 0.211]", AbstractCluster.formatVector(pdf, null));
0: 
/////////////////////////////////////////////////////////////////////////
0:     assertEquals("[0,0]", "[0.200, 0.600, 0.200]", AbstractCluster.formatVector(pdf, null));
0:     assertEquals("[2,2]", "[0.493, 0.296, 0.211]", AbstractCluster.formatVector(pdf, null));
0: 
0:     assertEquals("[0,0]", "[0.200, 0.600, 0.200]", AbstractCluster.formatVector(pdf, null));
0:     assertEquals("[2,2]", "[0.493, 0.296, 0.211]", AbstractCluster.formatVector(pdf, null));
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     assertEquals("[0,0]", "[0.000, 1.000, 0.000]", AbstractCluster.formatVector(pdf, null));
0:     assertEquals("[2,2]", "[0.735, 0.184, 0.082]", AbstractCluster.formatVector(pdf, null));
0: 
0:     assertEquals("[0,0]", "[0.212, 0.576, 0.212]", AbstractCluster.formatVector(pdf, null));
0:     assertEquals("[2,2]", "[0.952, 0.047, 0.000]", AbstractCluster.formatVector(pdf, null));
0: 
1:     assertEquals(classifier.getModels().size(), classifierOut.getModels().size());
1:     assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass()
1:         .getName());
0: 
1:     assertEquals(classifier.getModels().size(), classifierOut.getModels().size());
1:     assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass()
1:         .getName());
0: 
1:     assertEquals(classifier.getModels().size(), classifierOut.getModels().size());
1:     assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass()
1:         .getName());
0: 
1:     assertEquals(classifier.getModels().size(), classifierOut.getModels().size());
1:     assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass()
1:         .getName());
0: 
1:     List<Vector> data = TestKmeansClustering.getPoints(TestKmeansClustering.REFERENCE);
/////////////////////////////////////////////////////////////////////////
0: 
1:     List<Vector> data = TestKmeansClustering.getPoints(TestKmeansClustering.REFERENCE);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     List<VectorWritable> points = TestKmeansClustering.getPointsWritable(TestKmeansClustering.REFERENCE);
1:     ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);
0:     ClusterIterator.writeClassifier(prior, path);
/////////////////////////////////////////////////////////////////////////
0: 
0:       ClusterClassifier posterior = ClusterIterator.readClassifier(new Path(outPath, "classifier-" + i));
0: 
1:     }
1:   }
0: 
1:   @Test
0:   public void testMRFileClusterIteratorKMeans() throws IOException, InterruptedException, ClassNotFoundException {
1:     Path pointsPath = getTestTempDirPath("points");
1:     Path priorPath = getTestTempDirPath("prior");
1:     Path outPath = getTestTempDirPath("output");
0:     Configuration conf = new Configuration();
1:     FileSystem fs = FileSystem.get(pointsPath.toUri(), conf);
1:     List<VectorWritable> points = TestKmeansClustering.getPointsWritable(TestKmeansClustering.REFERENCE);
1:     ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);
1:     Path path = new Path(priorPath, "priorClassifier");
0:     ClusterClassifier prior = newClusterClassifier();
0:     ClusterIterator.writeClassifier(prior, path);
1:     assertEquals(3, prior.getModels().size());
1:     System.out.println("Prior");
1:     for (Cluster cluster : prior.getModels()) {
1:       System.out.println(cluster.asFormatString(null));
1:     }
0:     ClusteringPolicy policy = new KMeansClusteringPolicy();
0:     ClusterIterator iterator = new ClusterIterator(policy);
0:     iterator.iterateMR(pointsPath, path, outPath, 5);
0: 
0:     for (int i = 1; i <= 5; i++) {
1:       System.out.println("Classifier-" + i);
0:       ClusterClassifier posterior = ClusterIterator.readClassifier(new Path(outPath, "clusters-" + i));
1:       assertEquals(3, posterior.getModels().size());
1:       for (Cluster cluster : posterior.getModels()) {
1:         System.out.println(cluster.asFormatString(null));
1:       }
0: 
commit:dc637e8
/////////////////////////////////////////////////////////////////////////
0:     iterator.iterateSeq(pointsPath, path, outPath, 5);
commit:0873421
/////////////////////////////////////////////////////////////////////////
0:     assertEquals("[0,0]", "[0.200, 0.600, 0.200]",
0:     assertEquals("[2,2]", "[0.493, 0.296, 0.211]",
/////////////////////////////////////////////////////////////////////////
0:     assertEquals("[0,0]", "[0.200, 0.600, 0.200]",
0:     assertEquals("[2,2]", "[0.493, 0.296, 0.211]",
/////////////////////////////////////////////////////////////////////////
0:     assertEquals("[0,0]", "[0.200, 0.600, 0.200]",
0:     assertEquals("[2,2]", "[0.493, 0.296, 0.211]",
commit:4dd8881
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.VectorWritable;
/////////////////////////////////////////////////////////////////////////
0:     writeClassifier(classifier, config, path, fs);
0:     return readClassifier(config, path, fs);
1:   }
0:   
0:   private void writeClassifier(ClusterClassifier classifier,
0:       Configuration config, Path path, FileSystem fs) throws IOException {
1:   }
0:   
0:   private ClusterClassifier readClassifier(Configuration config, Path path,
0:       FileSystem fs) throws IOException {
0:     Writable key;
/////////////////////////////////////////////////////////////////////////
1:       System.out.println(cluster.asFormatString(null));
0:   
/////////////////////////////////////////////////////////////////////////
1:       System.out.println(cluster.asFormatString(null));
1:     }
1:   }
0:   
1:   @Test
1:   public void testSeqFileClusterIteratorKMeans() throws IOException {
1:     Path pointsPath = getTestTempDirPath("points");
1:     Path priorPath = getTestTempDirPath("prior");
1:     Path outPath = getTestTempDirPath("output");
0:     Configuration conf = new Configuration();
0:     FileSystem fs = FileSystem.get(conf);
0:     List<VectorWritable> points = TestKmeansClustering
0:         .getPointsWritable(TestKmeansClustering.REFERENCE);
0:     ClusteringTestUtils.writePointsToFile(points,
0:         new Path(pointsPath, "file1"), fs, conf);
1:     Path path = new Path(priorPath, "priorClassifier");
0:     ClusterClassifier prior = newClusterClassifier();
0:     writeClassifier(prior, conf, path, fs);
1:     assertEquals(3, prior.getModels().size());
1:     System.out.println("Prior");
1:     for (Cluster cluster : prior.getModels()) {
1:       System.out.println(cluster.asFormatString(null));
1:     }
0:     ClusteringPolicy policy = new KMeansClusteringPolicy();
0:     ClusterIterator iterator = new ClusterIterator(policy);
0:     iterator.iterate(pointsPath, path, outPath, 5);
0:     
0:     for (int i = 1; i <= 5; i++) {
1:       System.out.println("Classifier-" + i);
0:       ClusterClassifier posterior = readClassifier(conf, new Path(outPath,
0:           "classifier-" + i), fs);
1:       assertEquals(3, posterior.getModels().size());
1:       for (Cluster cluster : posterior.getModels()) {
1:         System.out.println(cluster.asFormatString(null));
1:       }
0:       
commit:8049eff
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
0: package org.apache.mahout.clustering;
0: 
1: import java.io.IOException;
0: import java.util.ArrayList;
1: import java.util.List;
0: 
0: import org.apache.commons.lang.NotImplementedException;
1: import org.apache.hadoop.conf.Configuration;
1: import org.apache.hadoop.fs.FileSystem;
1: import org.apache.hadoop.fs.Path;
0: import org.apache.hadoop.io.SequenceFile;
0: import org.apache.hadoop.io.Text;
0: import org.apache.hadoop.io.Writable;
0: import org.apache.mahout.clustering.canopy.Canopy;
0: import org.apache.mahout.clustering.dirichlet.models.GaussianCluster;
1: import org.apache.mahout.clustering.fuzzykmeans.SoftCluster;
1: import org.apache.mahout.clustering.kmeans.TestKmeansClustering;
0: import org.apache.mahout.clustering.meanshift.MeanShiftCanopy;
1: import org.apache.mahout.common.MahoutTestCase;
1: import org.apache.mahout.common.distance.DistanceMeasure;
1: import org.apache.mahout.common.distance.ManhattanDistanceMeasure;
1: import org.apache.mahout.math.DenseVector;
1: import org.apache.mahout.math.Vector;
1: import org.junit.Test;
0: 
1: public final class TestClusterClassifier extends MahoutTestCase {
0:   
0:   private ClusterClassifier newDMClassifier() {
0:     List<Cluster> models = new ArrayList<Cluster>();
1:     DistanceMeasure measure = new ManhattanDistanceMeasure();
0:     models.add(new DistanceMeasureCluster(new DenseVector(2).assign(1), 0,
0:         measure));
1:     models.add(new DistanceMeasureCluster(new DenseVector(2), 1, measure));
0:     models.add(new DistanceMeasureCluster(new DenseVector(2).assign(-1), 2,
0:         measure));
0:     ClusterClassifier classifier = new ClusterClassifier(models);
0:     return classifier;
1:   }
0:   
0:   private ClusterClassifier newClusterClassifier() {
0:     List<Cluster> models = new ArrayList<Cluster>();
1:     DistanceMeasure measure = new ManhattanDistanceMeasure();
0:     models.add(new org.apache.mahout.clustering.kmeans.Cluster(new DenseVector(
0:         2).assign(1), 0, measure));
0:     models.add(new org.apache.mahout.clustering.kmeans.Cluster(new DenseVector(
0:         2), 1, measure));
0:     models.add(new org.apache.mahout.clustering.kmeans.Cluster(new DenseVector(
0:         2).assign(-1), 2, measure));
0:     ClusterClassifier classifier = new ClusterClassifier(models);
0:     return classifier;
1:   }
0:   
0:   private ClusterClassifier newSoftClusterClassifier() {
0:     List<Cluster> models = new ArrayList<Cluster>();
1:     DistanceMeasure measure = new ManhattanDistanceMeasure();
1:     models.add(new SoftCluster(new DenseVector(2).assign(1), 0, measure));
1:     models.add(new SoftCluster(new DenseVector(2), 1, measure));
1:     models.add(new SoftCluster(new DenseVector(2).assign(-1), 2, measure));
0:     ClusterClassifier classifier = new ClusterClassifier(models);
0:     return classifier;
1:   }
0:   
0:   private ClusterClassifier newGaussianClassifier() {
0:     List<Cluster> models = new ArrayList<Cluster>();
0:     models.add(new GaussianCluster(new DenseVector(2).assign(1),
0:         new DenseVector(2).assign(1), 0));
0:     models.add(new GaussianCluster(new DenseVector(2), new DenseVector(2)
0:         .assign(1), 1));
0:     models.add(new GaussianCluster(new DenseVector(2).assign(-1),
0:         new DenseVector(2).assign(1), 2));
0:     ClusterClassifier classifier = new ClusterClassifier(models);
0:     return classifier;
1:   }
0:   
0:   private ClusterClassifier writeAndRead(ClusterClassifier classifier)
0:       throws IOException {
0:     Configuration config = new Configuration();
1:     Path path = new Path(getTestTempDirPath(), "output");
0:     FileSystem fs = FileSystem.get(path.toUri(), config);
0:     SequenceFile.Writer writer = new SequenceFile.Writer(fs, config, path,
0:         Text.class, ClusterClassifier.class);
0:     Writable key = new Text("test");
0:     writer.append(key, classifier);
0:     writer.close();
0:     
0:     SequenceFile.Reader reader = new SequenceFile.Reader(fs, path, config);
0:     key = new Text();
0:     ClusterClassifier classifierOut = new ClusterClassifier();
0:     reader.next(key, classifierOut);
0:     reader.close();
0:     return classifierOut;
1:   }
0:   
1:   @Test
1:   public void testDMClusterClassification() {
1:     ClusterClassifier classifier = newDMClassifier();
1:     Vector pdf = classifier.classify(new DenseVector(2));
0:     assertEquals("[0,0]", "[0.107, 0.787, 0.107]",
0:         AbstractCluster.formatVector(pdf, null));
1:     pdf = classifier.classify(new DenseVector(2).assign(2));
0:     assertEquals("[2,2]", "[0.867, 0.117, 0.016]",
0:         AbstractCluster.formatVector(pdf, null));
1:   }
0:   
1:   @Test
0:   public void testCanopyClassification() {
0:     List<Cluster> models = new ArrayList<Cluster>();
1:     DistanceMeasure measure = new ManhattanDistanceMeasure();
0:     models.add(new Canopy(new DenseVector(2).assign(1), 0, measure));
0:     models.add(new Canopy(new DenseVector(2), 1, measure));
0:     models.add(new Canopy(new DenseVector(2).assign(-1), 2, measure));
0:     ClusterClassifier classifier = new ClusterClassifier(models);
1:     Vector pdf = classifier.classify(new DenseVector(2));
0:     assertEquals("[0,0]", "[0.107, 0.787, 0.107]",
0:         AbstractCluster.formatVector(pdf, null));
1:     pdf = classifier.classify(new DenseVector(2).assign(2));
0:     assertEquals("[2,2]", "[0.867, 0.117, 0.016]",
0:         AbstractCluster.formatVector(pdf, null));
1:   }
0:   
1:   @Test
1:   public void testClusterClassification() {
0:     ClusterClassifier classifier = newClusterClassifier();
1:     Vector pdf = classifier.classify(new DenseVector(2));
0:     assertEquals("[0,0]", "[0.107, 0.787, 0.107]",
0:         AbstractCluster.formatVector(pdf, null));
1:     pdf = classifier.classify(new DenseVector(2).assign(2));
0:     assertEquals("[2,2]", "[0.867, 0.117, 0.016]",
0:         AbstractCluster.formatVector(pdf, null));
1:   }
0:   
1:   @Test
0:   public void testMSCanopyClassification() {
0:     List<Cluster> models = new ArrayList<Cluster>();
1:     DistanceMeasure measure = new ManhattanDistanceMeasure();
0:     models.add(new MeanShiftCanopy(new DenseVector(2).assign(1), 0, measure));
0:     models.add(new MeanShiftCanopy(new DenseVector(2), 1, measure));
0:     models.add(new MeanShiftCanopy(new DenseVector(2).assign(-1), 2, measure));
0:     ClusterClassifier classifier = new ClusterClassifier(models);
0:     try {
0:       classifier.classify(new DenseVector(2));
0:       fail("Expected NotImplementedException");
0:     } catch (NotImplementedException e) {}
1:   }
0:   
1:   @Test
1:   public void testSoftClusterClassification() {
1:     ClusterClassifier classifier = newSoftClusterClassifier();
1:     Vector pdf = classifier.classify(new DenseVector(2));
0:     assertEquals("[0,0]", "[0.000, 1.000, 0.000]",
0:         AbstractCluster.formatVector(pdf, null));
1:     pdf = classifier.classify(new DenseVector(2).assign(2));
0:     assertEquals("[2,2]", "[0.735, 0.184, 0.082]",
0:         AbstractCluster.formatVector(pdf, null));
1:   }
0:   
1:   @Test
0:   public void testGaussianClusterClassification() {
0:     ClusterClassifier classifier = newGaussianClassifier();
1:     Vector pdf = classifier.classify(new DenseVector(2));
0:     assertEquals("[0,0]", "[0.212, 0.576, 0.212]",
0:         AbstractCluster.formatVector(pdf, null));
1:     pdf = classifier.classify(new DenseVector(2).assign(2));
0:     assertEquals("[2,2]", "[0.952, 0.047, 0.000]",
0:         AbstractCluster.formatVector(pdf, null));
1:   }
0:   
1:   @Test
1:   public void testDMClassifierSerialization() throws Exception {
1:     ClusterClassifier classifier = newDMClassifier();
1:     ClusterClassifier classifierOut = writeAndRead(classifier);
0:     assertEquals(classifier.getModels().size(), classifierOut.getModels()
0:         .size());
0:     assertEquals(classifier.getModels().get(0).getClass().getName(),
0:         classifierOut.getModels().get(0).getClass().getName());
1:   }
0:   
1:   @Test
1:   public void testClusterClassifierSerialization() throws Exception {
0:     ClusterClassifier classifier = newClusterClassifier();
1:     ClusterClassifier classifierOut = writeAndRead(classifier);
0:     assertEquals(classifier.getModels().size(), classifierOut.getModels()
0:         .size());
0:     assertEquals(classifier.getModels().get(0).getClass().getName(),
0:         classifierOut.getModels().get(0).getClass().getName());
1:   }
0:   
1:   @Test
1:   public void testSoftClusterClassifierSerialization() throws Exception {
1:     ClusterClassifier classifier = newSoftClusterClassifier();
1:     ClusterClassifier classifierOut = writeAndRead(classifier);
0:     assertEquals(classifier.getModels().size(), classifierOut.getModels()
0:         .size());
0:     assertEquals(classifier.getModels().get(0).getClass().getName(),
0:         classifierOut.getModels().get(0).getClass().getName());
1:   }
0:   
1:   @Test
0:   public void testGaussianClassifierSerialization() throws Exception {
0:     ClusterClassifier classifier = newGaussianClassifier();
1:     ClusterClassifier classifierOut = writeAndRead(classifier);
0:     assertEquals(classifier.getModels().size(), classifierOut.getModels()
0:         .size());
0:     assertEquals(classifier.getModels().get(0).getClass().getName(),
0:         classifierOut.getModels().get(0).getClass().getName());
1:   }
0:   
1:   @Test
1:   public void testClusterIteratorKMeans() {
0:     List<Vector> data = TestKmeansClustering
0:         .getPoints(TestKmeansClustering.REFERENCE);
0:     ClusteringPolicy policy = new KMeansClusteringPolicy();
0:     ClusterClassifier prior = newClusterClassifier();
0:     ClusterIterator iterator = new ClusterIterator(policy);
0:     ClusterClassifier posterior = iterator.iterate(data, prior, 5);
1:     assertEquals(3, posterior.getModels().size());
1:     for (Cluster cluster : posterior.getModels()) {
0:       System.out
0:           .println(cluster.asFormatString(null));
1:     }
1:   }
0: 
1:   @Test
1:   public void testClusterIteratorDirichlet() {
0:     List<Vector> data = TestKmeansClustering
0:         .getPoints(TestKmeansClustering.REFERENCE);
0:     ClusteringPolicy policy = new DirichletClusteringPolicy(3, 1);
0:     ClusterClassifier prior = newClusterClassifier();
0:     ClusterIterator iterator = new ClusterIterator(policy);
0:     ClusterClassifier posterior = iterator.iterate(data, prior, 5);
1:     assertEquals(3, posterior.getModels().size());
1:     for (Cluster cluster : posterior.getModels()) {
0:       System.out
0:           .println(cluster.asFormatString(null));
1:     }
1:   }
1: }
============================================================================