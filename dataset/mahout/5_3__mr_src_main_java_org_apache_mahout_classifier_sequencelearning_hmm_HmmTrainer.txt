1:27d33a2: /**
1:27d33a2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:27d33a2:  * contributor license agreements.  See the NOTICE file distributed with
1:27d33a2:  * this work for additional information regarding copyright ownership.
1:27d33a2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:27d33a2:  * (the "License"); you may not use this file except in compliance with
1:27d33a2:  * the License.  You may obtain a copy of the License at
2:27d33a2:  *
1:27d33a2:  *     http://www.apache.org/licenses/LICENSE-2.0
1:27d33a2:  *
1:27d33a2:  * Unless required by applicable law or agreed to in writing, software
1:27d33a2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:27d33a2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:27d33a2:  * See the License for the specific language governing permissions and
1:27d33a2:  * limitations under the License.
1:27d33a2:  */
1:27d33a2: 
1:27d33a2: package org.apache.mahout.classifier.sequencelearning.hmm;
1:27d33a2: 
1:27d33a2: import java.util.Collection;
1:27d33a2: import java.util.Iterator;
1:27d33a2: 
1:27d33a2: import org.apache.mahout.math.DenseMatrix;
1:27d33a2: import org.apache.mahout.math.DenseVector;
1:27d33a2: import org.apache.mahout.math.Matrix;
1:27d33a2: import org.apache.mahout.math.Vector;
1:27d33a2: 
1:27d33a2: /**
1:27d33a2:  * Class containing several algorithms used to train a Hidden Markov Model. The
1:27d33a2:  * three main algorithms are: supervised learning, unsupervised Viterbi and
1:27d33a2:  * unsupervised Baum-Welch.
1:27d33a2:  */
1:27d33a2: public final class HmmTrainer {
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * No public constructor for utility classes.
1:27d33a2:    */
1:27d33a2:   private HmmTrainer() {
1:27d33a2:     // nothing to do here really.
3:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Create an supervised initial estimate of an HMM Model based on a sequence
1:27d33a2:    * of observed and hidden states.
1:27d33a2:    *
1:27d33a2:    * @param nrOfHiddenStates The total number of hidden states
1:27d33a2:    * @param nrOfOutputStates The total number of output states
1:27d33a2:    * @param observedSequence Integer array containing the observed sequence
1:27d33a2:    * @param hiddenSequence   Integer array containing the hidden sequence
1:27d33a2:    * @param pseudoCount      Value that is assigned to non-occurring transitions to avoid zero
1:27d33a2:    *                         probabilities.
1:27d33a2:    * @return An initial model using the estimated parameters
1:27d33a2:    */
1:74f849b:   public static HmmModel trainSupervised(int nrOfHiddenStates, int nrOfOutputStates, int[] observedSequence,
1:74f849b:       int[] hiddenSequence, double pseudoCount) {
1:27d33a2:     // make sure the pseudo count is not zero
1:39fe224:     pseudoCount = pseudoCount == 0 ? Double.MIN_VALUE : pseudoCount;
1:27d33a2: 
1:27d33a2:     // initialize the parameters
1:d53cf4a:     DenseMatrix transitionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfHiddenStates);
1:d53cf4a:     DenseMatrix emissionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfOutputStates);
1:27d33a2:     // assign a small initial probability that is larger than zero, so
1:27d33a2:     // unseen states will not get a zero probability
1:27d33a2:     transitionMatrix.assign(pseudoCount);
1:27d33a2:     emissionMatrix.assign(pseudoCount);
1:27d33a2:     // given no prior knowledge, we have to assume that all initial hidden
1:27d33a2:     // states are equally likely
1:27d33a2:     DenseVector initialProbabilities = new DenseVector(nrOfHiddenStates);
1:4ca6b86:     initialProbabilities.assign(1.0 / nrOfHiddenStates);
1:27d33a2: 
1:27d33a2:     // now loop over the sequences to count the number of transitions
1:27d33a2:     countTransitions(transitionMatrix, emissionMatrix, observedSequence,
1:27d33a2:         hiddenSequence);
1:27d33a2: 
1:27d33a2:     // make sure that probabilities are normalized
1:27d33a2:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:27d33a2:       // compute sum of probabilities for current row of transition matrix
1:27d33a2:       double sum = 0;
1:d53cf4a:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:27d33a2:         sum += transitionMatrix.getQuick(i, j);
1:d53cf4a:       }
1:27d33a2:       // normalize current row of transition matrix
1:d53cf4a:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:27d33a2:         transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j) / sum);
1:d53cf4a:       }
1:27d33a2:       // compute sum of probabilities for current row of emission matrix
1:27d33a2:       sum = 0;
1:d53cf4a:       for (int j = 0; j < nrOfOutputStates; j++) {
1:27d33a2:         sum += emissionMatrix.getQuick(i, j);
1:d53cf4a:       }
1:27d33a2:       // normalize current row of emission matrix
1:d53cf4a:       for (int j = 0; j < nrOfOutputStates; j++) {
1:27d33a2:         emissionMatrix.setQuick(i, j, emissionMatrix.getQuick(i, j) / sum);
1:d53cf4a:       }
1:d53cf4a:     }
1:27d33a2: 
1:27d33a2:     // return a new model using the parameter estimations
1:27d33a2:     return new HmmModel(transitionMatrix, emissionMatrix, initialProbabilities);
1:d53cf4a:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Function that counts the number of state->state and state->output
1:27d33a2:    * transitions for the given observed/hidden sequence.
1:27d33a2:    *
1:27d33a2:    * @param transitionMatrix transition matrix to use.
1:27d33a2:    * @param emissionMatrix emission matrix to use for counting.
1:27d33a2:    * @param observedSequence observation sequence to use.
1:27d33a2:    * @param hiddenSequence sequence of hidden states to use.
1:27d33a2:    */
1:27d33a2:   private static void countTransitions(Matrix transitionMatrix,
1:27d33a2:                                        Matrix emissionMatrix, int[] observedSequence, int[] hiddenSequence) {
1:27d33a2:     emissionMatrix.setQuick(hiddenSequence[0], observedSequence[0],
1:27d33a2:         emissionMatrix.getQuick(hiddenSequence[0], observedSequence[0]) + 1);
1:27d33a2:     for (int i = 1; i < observedSequence.length; ++i) {
1:27d33a2:       transitionMatrix
1:27d33a2:           .setQuick(hiddenSequence[i - 1], hiddenSequence[i], transitionMatrix
1:27d33a2:               .getQuick(hiddenSequence[i - 1], hiddenSequence[i]) + 1);
1:27d33a2:       emissionMatrix.setQuick(hiddenSequence[i], observedSequence[i],
1:27d33a2:           emissionMatrix.getQuick(hiddenSequence[i], observedSequence[i]) + 1);
1:27d33a2:     }
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Create an supervised initial estimate of an HMM Model based on a number of
1:27d33a2:    * sequences of observed and hidden states.
1:27d33a2:    *
1:27d33a2:    * @param nrOfHiddenStates The total number of hidden states
1:27d33a2:    * @param nrOfOutputStates The total number of output states
1:27d33a2:    * @param hiddenSequences Collection of hidden sequences to use for training
1:27d33a2:    * @param observedSequences Collection of observed sequences to use for training associated with hidden sequences.
1:27d33a2:    * @param pseudoCount      Value that is assigned to non-occurring transitions to avoid zero
1:27d33a2:    *                         probabilities.
1:27d33a2:    * @return An initial model using the estimated parameters
1:27d33a2:    */
1:27d33a2:   public static HmmModel trainSupervisedSequence(int nrOfHiddenStates,
1:27d33a2:                                                  int nrOfOutputStates, Collection<int[]> hiddenSequences,
1:27d33a2:                                                  Collection<int[]> observedSequences, double pseudoCount) {
1:27d33a2: 
1:27d33a2:     // make sure the pseudo count is not zero
1:39fe224:     pseudoCount = pseudoCount == 0 ? Double.MIN_VALUE : pseudoCount;
1:27d33a2: 
1:27d33a2:     // initialize parameters
2:27d33a2:     DenseMatrix transitionMatrix = new DenseMatrix(nrOfHiddenStates,
2:27d33a2:         nrOfHiddenStates);
2:27d33a2:     DenseMatrix emissionMatrix = new DenseMatrix(nrOfHiddenStates,
2:27d33a2:         nrOfOutputStates);
1:27d33a2:     DenseVector initialProbabilities = new DenseVector(nrOfHiddenStates);
1:27d33a2: 
1:27d33a2:     // assign pseudo count to avoid zero probabilities
1:27d33a2:     transitionMatrix.assign(pseudoCount);
1:27d33a2:     emissionMatrix.assign(pseudoCount);
1:27d33a2:     initialProbabilities.assign(pseudoCount);
1:27d33a2: 
1:27d33a2:     // now loop over the sequences to count the number of transitions
1:27d33a2:     Iterator<int[]> hiddenSequenceIt = hiddenSequences.iterator();
1:27d33a2:     Iterator<int[]> observedSequenceIt = observedSequences.iterator();
1:27d33a2:     while (hiddenSequenceIt.hasNext() && observedSequenceIt.hasNext()) {
1:27d33a2:       // fetch the current set of sequences
1:27d33a2:       int[] hiddenSequence = hiddenSequenceIt.next();
1:27d33a2:       int[] observedSequence = observedSequenceIt.next();
1:27d33a2:       // increase the count for initial probabilities
1:27d33a2:       initialProbabilities.setQuick(hiddenSequence[0], initialProbabilities
1:27d33a2:           .getQuick(hiddenSequence[0]) + 1);
1:27d33a2:       countTransitions(transitionMatrix, emissionMatrix, observedSequence,
1:27d33a2:           hiddenSequence);
1:27d33a2:     }
1:27d33a2: 
1:27d33a2:     // make sure that probabilities are normalized
1:27d33a2:     double isum = 0; // sum of initial probabilities
1:27d33a2:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:27d33a2:       isum += initialProbabilities.getQuick(i);
1:27d33a2:       // compute sum of probabilities for current row of transition matrix
1:27d33a2:       double sum = 0;
1:d53cf4a:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:27d33a2:         sum += transitionMatrix.getQuick(i, j);
1:d53cf4a:       }
1:27d33a2:       // normalize current row of transition matrix
1:d53cf4a:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:27d33a2:         transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j) / sum);
1:d53cf4a:       }
1:27d33a2:       // compute sum of probabilities for current row of emission matrix
1:27d33a2:       sum = 0;
1:d53cf4a:       for (int j = 0; j < nrOfOutputStates; j++) {
1:27d33a2:         sum += emissionMatrix.getQuick(i, j);
1:27d33a2:       }
1:27d33a2:       // normalize current row of emission matrix
1:d53cf4a:       for (int j = 0; j < nrOfOutputStates; j++) {
1:27d33a2:         emissionMatrix.setQuick(i, j, emissionMatrix.getQuick(i, j) / sum);
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:     // normalize the initial probabilities
1:d53cf4a:     for (int i = 0; i < nrOfHiddenStates; ++i) {
1:27d33a2:       initialProbabilities.setQuick(i, initialProbabilities.getQuick(i) / isum);
1:d53cf4a:     }
1:27d33a2: 
1:27d33a2:     // return a new model using the parameter estimates
1:27d33a2:     return new HmmModel(transitionMatrix, emissionMatrix, initialProbabilities);
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Iteratively train the parameters of the given initial model wrt to the
1:27d33a2:    * observed sequence using Viterbi training.
1:27d33a2:    *
1:27d33a2:    * @param initialModel     The initial model that gets iterated
1:27d33a2:    * @param observedSequence The sequence of observed states
1:27d33a2:    * @param pseudoCount      Value that is assigned to non-occurring transitions to avoid zero
1:27d33a2:    *                         probabilities.
1:27d33a2:    * @param epsilon          Convergence criteria
1:27d33a2:    * @param maxIterations    The maximum number of training iterations
1:27d33a2:    * @param scaled           Use Log-scaled implementation, this is computationally more
1:27d33a2:    *                         expensive but offers better numerical stability for large observed
1:27d33a2:    *                         sequences
1:27d33a2:    * @return The iterated model
1:27d33a2:    */
1:27d33a2:   public static HmmModel trainViterbi(HmmModel initialModel,
1:27d33a2:                                       int[] observedSequence, double pseudoCount, double epsilon,
1:27d33a2:                                       int maxIterations, boolean scaled) {
1:27d33a2: 
1:27d33a2:     // make sure the pseudo count is not zero
1:39fe224:     pseudoCount = pseudoCount == 0 ? Double.MIN_VALUE : pseudoCount;
1:27d33a2: 
1:27d33a2:     // allocate space for iteration models
1:d0dbdfb:     HmmModel lastIteration = initialModel.clone();
1:d0dbdfb:     HmmModel iteration = initialModel.clone();
1:27d33a2: 
1:27d33a2:     // allocate space for Viterbi path calculation
1:27d33a2:     int[] viterbiPath = new int[observedSequence.length];
1:27d33a2:     int[][] phi = new int[observedSequence.length - 1][initialModel
1:27d33a2:         .getNrOfHiddenStates()];
1:27d33a2:     double[][] delta = new double[observedSequence.length][initialModel
1:27d33a2:         .getNrOfHiddenStates()];
1:27d33a2: 
1:27d33a2:     // now run the Viterbi training iteration
1:27d33a2:     for (int i = 0; i < maxIterations; ++i) {
1:27d33a2:       // compute the Viterbi path
1:27d33a2:       HmmAlgorithms.viterbiAlgorithm(viterbiPath, delta, phi, lastIteration,
1:27d33a2:           observedSequence, scaled);
1:27d33a2:       // Viterbi iteration uses the viterbi path to update
1:27d33a2:       // the probabilities
1:27d33a2:       Matrix emissionMatrix = iteration.getEmissionMatrix();
1:27d33a2:       Matrix transitionMatrix = iteration.getTransitionMatrix();
1:27d33a2: 
1:27d33a2:       // first, assign the pseudo count
1:27d33a2:       emissionMatrix.assign(pseudoCount);
1:27d33a2:       transitionMatrix.assign(pseudoCount);
1:27d33a2: 
1:27d33a2:       // now count the transitions
1:27d33a2:       countTransitions(transitionMatrix, emissionMatrix, observedSequence,
1:27d33a2:           viterbiPath);
1:27d33a2: 
1:27d33a2:       // and normalize the probabilities
1:27d33a2:       for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {
1:27d33a2:         double sum = 0;
1:27d33a2:         // normalize the rows of the transition matrix
1:d53cf4a:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {
1:27d33a2:           sum += transitionMatrix.getQuick(j, k);
1:d53cf4a:         }
1:d53cf4a:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {
1:27d33a2:           transitionMatrix
1:27d33a2:               .setQuick(j, k, transitionMatrix.getQuick(j, k) / sum);
1:d53cf4a:         }
1:27d33a2:         // normalize the rows of the emission matrix
1:27d33a2:         sum = 0;
1:d53cf4a:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {
1:27d33a2:           sum += emissionMatrix.getQuick(j, k);
1:d53cf4a:         }
1:d53cf4a:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {
1:27d33a2:           emissionMatrix.setQuick(j, k, emissionMatrix.getQuick(j, k) / sum);
1:d53cf4a:         }
1:d53cf4a:       }
1:27d33a2:       // check for convergence
1:d53cf4a:       if (checkConvergence(lastIteration, iteration, epsilon)) {
1:27d33a2:         break;
1:d53cf4a:       }
1:27d33a2:       // overwrite the last iterated model by the new iteration
1:27d33a2:       lastIteration.assign(iteration);
1:d53cf4a:     }
1:27d33a2:     // we are done :)
1:27d33a2:     return iteration;
1:d53cf4a:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Iteratively train the parameters of the given initial model wrt the
1:27d33a2:    * observed sequence using Baum-Welch training.
1:27d33a2:    *
1:27d33a2:    * @param initialModel     The initial model that gets iterated
1:27d33a2:    * @param observedSequence The sequence of observed states
1:27d33a2:    * @param epsilon          Convergence criteria
1:27d33a2:    * @param maxIterations    The maximum number of training iterations
1:27d33a2:    * @param scaled           Use log-scaled implementations of forward/backward algorithm. This
1:27d33a2:    *                         is computationally more expensive, but offers better numerical
1:27d33a2:    *                         stability for long output sequences.
1:27d33a2:    * @return The iterated model
1:27d33a2:    */
1:27d33a2:   public static HmmModel trainBaumWelch(HmmModel initialModel,
1:27d33a2:                                         int[] observedSequence, double epsilon, int maxIterations, boolean scaled) {
1:27d33a2:     // allocate space for the iterations
1:d0dbdfb:     HmmModel lastIteration = initialModel.clone();
1:d0dbdfb:     HmmModel iteration = initialModel.clone();
1:d0dbdfb: 
1:27d33a2:     // allocate space for baum-welch factors
1:27d33a2:     int hiddenCount = initialModel.getNrOfHiddenStates();
1:27d33a2:     int visibleCount = observedSequence.length;
1:d53cf4a:     Matrix alpha = new DenseMatrix(visibleCount, hiddenCount);
1:d53cf4a:     Matrix beta = new DenseMatrix(visibleCount, hiddenCount);
1:27d33a2: 
1:27d33a2:     // now run the baum Welch training iteration
1:27d33a2:     for (int it = 0; it < maxIterations; ++it) {
1:27d33a2:       // fetch emission and transition matrix of current iteration
1:27d33a2:       Vector initialProbabilities = iteration.getInitialProbabilities();
1:27d33a2:       Matrix emissionMatrix = iteration.getEmissionMatrix();
1:27d33a2:       Matrix transitionMatrix = iteration.getTransitionMatrix();
1:27d33a2: 
1:27d33a2:       // compute forward and backward factors
1:27d33a2:       HmmAlgorithms.forwardAlgorithm(alpha, iteration, observedSequence, scaled);
1:27d33a2:       HmmAlgorithms.backwardAlgorithm(beta, iteration, observedSequence, scaled);
1:27d33a2: 
1:27d33a2:       if (scaled) {
1:27d33a2:         logScaledBaumWelch(observedSequence, iteration, alpha, beta);
1:27d33a2:       } else {
1:27d33a2:         unscaledBaumWelch(observedSequence, iteration, alpha, beta);
1:d53cf4a:       }
1:27d33a2:       // normalize transition/emission probabilities
1:27d33a2:       // and normalize the probabilities
1:27d33a2:       double isum = 0;
1:27d33a2:       for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {
1:27d33a2:         double sum = 0;
1:27d33a2:         // normalize the rows of the transition matrix
1:d53cf4a:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {
1:27d33a2:           sum += transitionMatrix.getQuick(j, k);
1:27d33a2:         }
1:d53cf4a:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {
1:27d33a2:           transitionMatrix
1:27d33a2:               .setQuick(j, k, transitionMatrix.getQuick(j, k) / sum);
1:27d33a2:         }
1:27d33a2:         // normalize the rows of the emission matrix
1:27d33a2:         sum = 0;
1:d53cf4a:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {
1:27d33a2:           sum += emissionMatrix.getQuick(j, k);
1:27d33a2:         }
1:d53cf4a:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {
1:27d33a2:           emissionMatrix.setQuick(j, k, emissionMatrix.getQuick(j, k) / sum);
1:27d33a2:         }
1:27d33a2:         // normalization parameter for initial probabilities
1:27d33a2:         isum += initialProbabilities.getQuick(j);
1:27d33a2:       }
1:27d33a2:       // normalize initial probabilities
1:27d33a2:       for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:27d33a2:         initialProbabilities.setQuick(i, initialProbabilities.getQuick(i)
1:27d33a2:             / isum);
1:d53cf4a:       }
1:27d33a2:       // check for convergence
1:d53cf4a:       if (checkConvergence(lastIteration, iteration, epsilon)) {
1:27d33a2:         break;
1:27d33a2:       }
1:27d33a2:       // overwrite the last iterated model by the new iteration
1:27d33a2:       lastIteration.assign(iteration);
1:27d33a2:     }
1:27d33a2:     // we are done :)
1:27d33a2:     return iteration;
1:27d33a2:   }
1:27d33a2: 
1:d53cf4a:   private static void unscaledBaumWelch(int[] observedSequence, HmmModel iteration, Matrix alpha, Matrix beta) {
1:27d33a2:     Vector initialProbabilities = iteration.getInitialProbabilities();
1:27d33a2:     Matrix emissionMatrix = iteration.getEmissionMatrix();
1:27d33a2:     Matrix transitionMatrix = iteration.getTransitionMatrix();
1:27d33a2:     double modelLikelihood = HmmEvaluator.modelLikelihood(alpha, false);
1:27d33a2: 
1:27d33a2:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:27d33a2:       initialProbabilities.setQuick(i, alpha.getQuick(0, i)
1:27d33a2:           * beta.getQuick(0, i));
1:27d33a2:     }
1:27d33a2: 
1:27d33a2:     // recompute transition probabilities
1:27d33a2:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:27d33a2:       for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {
1:27d33a2:         double temp = 0;
1:27d33a2:         for (int t = 0; t < observedSequence.length - 1; ++t) {
1:27d33a2:           temp += alpha.getQuick(t, i)
1:27d33a2:               * emissionMatrix.getQuick(j, observedSequence[t + 1])
1:27d33a2:               * beta.getQuick(t + 1, j);
1:27d33a2:         }
1:27d33a2:         transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j)
1:27d33a2:             * temp / modelLikelihood);
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:     // recompute emission probabilities
1:27d33a2:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:27d33a2:       for (int j = 0; j < iteration.getNrOfOutputStates(); ++j) {
1:27d33a2:         double temp = 0;
1:27d33a2:         for (int t = 0; t < observedSequence.length; ++t) {
1:27d33a2:           // delta tensor
1:27d33a2:           if (observedSequence[t] == j) {
1:27d33a2:             temp += alpha.getQuick(t, i) * beta.getQuick(t, i);
1:27d33a2:           }
1:27d33a2:         }
1:27d33a2:         emissionMatrix.setQuick(i, j, temp / modelLikelihood);
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:   }
1:27d33a2: 
1:d53cf4a:   private static void logScaledBaumWelch(int[] observedSequence, HmmModel iteration, Matrix alpha, Matrix beta) {
1:27d33a2:     Vector initialProbabilities = iteration.getInitialProbabilities();
1:27d33a2:     Matrix emissionMatrix = iteration.getEmissionMatrix();
1:27d33a2:     Matrix transitionMatrix = iteration.getTransitionMatrix();
1:27d33a2:     double modelLikelihood = HmmEvaluator.modelLikelihood(alpha, true);
1:27d33a2: 
1:27d33a2:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:27d33a2:       initialProbabilities.setQuick(i, Math.exp(alpha.getQuick(0, i) + beta.getQuick(0, i)));
1:27d33a2:     }
1:27d33a2: 
1:27d33a2:     // recompute transition probabilities
1:27d33a2:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:27d33a2:       for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {
1:27d33a2:         double sum = Double.NEGATIVE_INFINITY; // log(0)
1:27d33a2:         for (int t = 0; t < observedSequence.length - 1; ++t) {
1:27d33a2:           double temp = alpha.getQuick(t, i)
1:27d33a2:               + Math.log(emissionMatrix.getQuick(j, observedSequence[t + 1]))
1:27d33a2:               + beta.getQuick(t + 1, j);
1:d53cf4a:           if (temp > Double.NEGATIVE_INFINITY) {
1:d53cf4a:             // handle 0-probabilities
1:971a56d:             sum = temp + Math.log1p(Math.exp(sum - temp));
1:d53cf4a:           }
1:27d33a2:         }
1:27d33a2:         transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j)
1:27d33a2:             * Math.exp(sum - modelLikelihood));
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:     // recompute emission probabilities
1:27d33a2:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:27d33a2:       for (int j = 0; j < iteration.getNrOfOutputStates(); ++j) {
1:27d33a2:         double sum = Double.NEGATIVE_INFINITY; // log(0)
1:27d33a2:         for (int t = 0; t < observedSequence.length; ++t) {
1:27d33a2:           // delta tensor
1:27d33a2:           if (observedSequence[t] == j) {
1:27d33a2:             double temp = alpha.getQuick(t, i) + beta.getQuick(t, i);
1:d53cf4a:             if (temp > Double.NEGATIVE_INFINITY) {
1:d53cf4a:               // handle 0-probabilities
1:971a56d:               sum = temp + Math.log1p(Math.exp(sum - temp));
1:d53cf4a:             }
1:27d33a2:           }
1:27d33a2:         }
1:27d33a2:         emissionMatrix.setQuick(i, j, Math.exp(sum - modelLikelihood));
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Check convergence of two HMM models by computing a simple distance between
1:27d33a2:    * emission / transition matrices
1:27d33a2:    *
1:27d33a2:    * @param oldModel Old HMM Model
1:27d33a2:    * @param newModel New HMM Model
1:27d33a2:    * @param epsilon  Convergence Factor
1:27d33a2:    * @return true if training converged to a stable state.
1:27d33a2:    */
1:27d33a2:   private static boolean checkConvergence(HmmModel oldModel, HmmModel newModel,
1:27d33a2:                                           double epsilon) {
1:27d33a2:     // check convergence of transitionProbabilities
1:27d33a2:     Matrix oldTransitionMatrix = oldModel.getTransitionMatrix();
1:27d33a2:     Matrix newTransitionMatrix = newModel.getTransitionMatrix();
1:27d33a2:     double diff = 0;
1:27d33a2:     for (int i = 0; i < oldModel.getNrOfHiddenStates(); ++i) {
1:27d33a2:       for (int j = 0; j < oldModel.getNrOfHiddenStates(); ++j) {
1:27d33a2:         double tmp = oldTransitionMatrix.getQuick(i, j)
1:27d33a2:             - newTransitionMatrix.getQuick(i, j);
1:27d33a2:         diff += tmp * tmp;
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:     double norm = Math.sqrt(diff);
1:27d33a2:     diff = 0;
1:27d33a2:     // check convergence of emissionProbabilities
1:27d33a2:     Matrix oldEmissionMatrix = oldModel.getEmissionMatrix();
1:27d33a2:     Matrix newEmissionMatrix = newModel.getEmissionMatrix();
1:27d33a2:     for (int i = 0; i < oldModel.getNrOfHiddenStates(); i++) {
1:27d33a2:       for (int j = 0; j < oldModel.getNrOfOutputStates(); j++) {
1:27d33a2: 
1:27d33a2:         double tmp = oldEmissionMatrix.getQuick(i, j)
1:27d33a2:             - newEmissionMatrix.getQuick(i, j);
1:27d33a2:         diff += tmp * tmp;
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:     norm += Math.sqrt(diff);
1:27d33a2:     // iteration has converged :)
1:27d33a2:     return norm < epsilon;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2: }
============================================================================
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:4ca6b86
/////////////////////////////////////////////////////////////////////////
1:     initialProbabilities.assign(1.0 / nrOfHiddenStates);
commit:971a56d
/////////////////////////////////////////////////////////////////////////
1:             sum = temp + Math.log1p(Math.exp(sum - temp));
/////////////////////////////////////////////////////////////////////////
1:               sum = temp + Math.log1p(Math.exp(sum - temp));
commit:d0dbdfb
/////////////////////////////////////////////////////////////////////////
1:     HmmModel lastIteration = initialModel.clone();
1:     HmmModel iteration = initialModel.clone();
/////////////////////////////////////////////////////////////////////////
1:     HmmModel lastIteration = initialModel.clone();
1:     HmmModel iteration = initialModel.clone();
1: 
commit:39fe224
/////////////////////////////////////////////////////////////////////////
1:     pseudoCount = pseudoCount == 0 ? Double.MIN_VALUE : pseudoCount;
/////////////////////////////////////////////////////////////////////////
1:     pseudoCount = pseudoCount == 0 ? Double.MIN_VALUE : pseudoCount;
/////////////////////////////////////////////////////////////////////////
1:     pseudoCount = pseudoCount == 0 ? Double.MIN_VALUE : pseudoCount;
commit:d53cf4a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     DenseMatrix transitionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfHiddenStates);
1:     DenseMatrix emissionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfOutputStates);
/////////////////////////////////////////////////////////////////////////
1:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:       }
1:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:       }
1:       for (int j = 0; j < nrOfOutputStates; j++) {
1:       }
1:       for (int j = 0; j < nrOfOutputStates; j++) {
1:       }
/////////////////////////////////////////////////////////////////////////
1:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:       }
1:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:       }
1:       for (int j = 0; j < nrOfOutputStates; j++) {
1:       }
1:       for (int j = 0; j < nrOfOutputStates; j++) {
1:       }
1:     for (int i = 0; i < nrOfHiddenStates; ++i) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {
1:         }
1:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {
1:         }
1:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {
1:         }
1:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {
1:         }
1:       if (checkConvergence(lastIteration, iteration, epsilon)) {
1:       }
/////////////////////////////////////////////////////////////////////////
1:     Matrix alpha = new DenseMatrix(visibleCount, hiddenCount);
1:     Matrix beta = new DenseMatrix(visibleCount, hiddenCount);
/////////////////////////////////////////////////////////////////////////
1:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {
1:         }
1:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {
1:         }
1:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {
1:         }
1:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:       if (checkConvergence(lastIteration, iteration, epsilon)) {
1:       }
/////////////////////////////////////////////////////////////////////////
1:   private static void unscaledBaumWelch(int[] observedSequence, HmmModel iteration, Matrix alpha, Matrix beta) {
/////////////////////////////////////////////////////////////////////////
1:   private static void logScaledBaumWelch(int[] observedSequence, HmmModel iteration, Matrix alpha, Matrix beta) {
/////////////////////////////////////////////////////////////////////////
1:           if (temp > Double.NEGATIVE_INFINITY) {
1:             // handle 0-probabilities
1:           }
/////////////////////////////////////////////////////////////////////////
1:             if (temp > Double.NEGATIVE_INFINITY) {
1:               // handle 0-probabilities
1:             }
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:74f849b
/////////////////////////////////////////////////////////////////////////
1:   public static HmmModel trainSupervised(int nrOfHiddenStates, int nrOfOutputStates, int[] observedSequence,
1:       int[] hiddenSequence, double pseudoCount) {
author:Isabel Drost
-------------------------------------------------------------------------------
commit:27d33a2
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.classifier.sequencelearning.hmm;
1: 
1: import java.util.Collection;
1: import java.util.Iterator;
1: 
1: import org.apache.mahout.math.DenseMatrix;
1: import org.apache.mahout.math.DenseVector;
1: import org.apache.mahout.math.Matrix;
1: import org.apache.mahout.math.Vector;
1: 
1: /**
1:  * Class containing several algorithms used to train a Hidden Markov Model. The
1:  * three main algorithms are: supervised learning, unsupervised Viterbi and
1:  * unsupervised Baum-Welch.
1:  *
0:  * @author mheimel
1:  */
1: public final class HmmTrainer {
1: 
1:   /**
1:    * No public constructor for utility classes.
1:    */
1:   private HmmTrainer() {
1:     // nothing to do here really.
1:   }
1: 
1:   /**
1:    * Create an supervised initial estimate of an HMM Model based on a sequence
1:    * of observed and hidden states.
1:    *
1:    * @param nrOfHiddenStates The total number of hidden states
1:    * @param nrOfOutputStates The total number of output states
1:    * @param observedSequence Integer array containing the observed sequence
1:    * @param hiddenSequence   Integer array containing the hidden sequence
1:    * @param pseudoCount      Value that is assigned to non-occurring transitions to avoid zero
1:    *                         probabilities.
1:    * @return An initial model using the estimated parameters
1:    */
0:   public static HmmModel trainSupervised(int nrOfHiddenStates,
0:                                          int nrOfOutputStates, int[] observedSequence, int[] hiddenSequence,
0:                                          double pseudoCount) {
1:     // make sure the pseudo count is not zero
0:     pseudoCount = (pseudoCount == 0) ? Double.MIN_VALUE : pseudoCount;
1: 
1:     // initialize the parameters
1:     DenseMatrix transitionMatrix = new DenseMatrix(nrOfHiddenStates,
1:         nrOfHiddenStates);
1:     DenseMatrix emissionMatrix = new DenseMatrix(nrOfHiddenStates,
1:         nrOfOutputStates);
1:     // assign a small initial probability that is larger than zero, so
1:     // unseen states will not get a zero probability
1:     transitionMatrix.assign(pseudoCount);
1:     emissionMatrix.assign(pseudoCount);
1:     // given no prior knowledge, we have to assume that all initial hidden
1:     // states are equally likely
1:     DenseVector initialProbabilities = new DenseVector(nrOfHiddenStates);
0:     initialProbabilities.assign(1.0 / (double) nrOfHiddenStates);
1: 
1:     // now loop over the sequences to count the number of transitions
1:     countTransitions(transitionMatrix, emissionMatrix, observedSequence,
1:         hiddenSequence);
1: 
1:     // make sure that probabilities are normalized
1:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:       // compute sum of probabilities for current row of transition matrix
1:       double sum = 0;
0:       for (int j = 0; j < nrOfHiddenStates; j++)
1:         sum += transitionMatrix.getQuick(i, j);
1:       // normalize current row of transition matrix
0:       for (int j = 0; j < nrOfHiddenStates; j++)
1:         transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j) / sum);
1:       // compute sum of probabilities for current row of emission matrix
1:       sum = 0;
0:       for (int j = 0; j < nrOfOutputStates; j++)
1:         sum += emissionMatrix.getQuick(i, j);
1:       // normalize current row of emission matrix
0:       for (int j = 0; j < nrOfOutputStates; j++)
1:         emissionMatrix.setQuick(i, j, emissionMatrix.getQuick(i, j) / sum);
1:     }
1: 
1:     // return a new model using the parameter estimations
1:     return new HmmModel(transitionMatrix, emissionMatrix, initialProbabilities);
1:   }
1: 
1:   /**
1:    * Function that counts the number of state->state and state->output
1:    * transitions for the given observed/hidden sequence.
1:    *
1:    * @param transitionMatrix transition matrix to use.
1:    * @param emissionMatrix emission matrix to use for counting.
1:    * @param observedSequence observation sequence to use.
1:    * @param hiddenSequence sequence of hidden states to use.
1:    */
1:   private static void countTransitions(Matrix transitionMatrix,
1:                                        Matrix emissionMatrix, int[] observedSequence, int[] hiddenSequence) {
1:     emissionMatrix.setQuick(hiddenSequence[0], observedSequence[0],
1:         emissionMatrix.getQuick(hiddenSequence[0], observedSequence[0]) + 1);
1:     for (int i = 1; i < observedSequence.length; ++i) {
1:       transitionMatrix
1:           .setQuick(hiddenSequence[i - 1], hiddenSequence[i], transitionMatrix
1:               .getQuick(hiddenSequence[i - 1], hiddenSequence[i]) + 1);
1:       emissionMatrix.setQuick(hiddenSequence[i], observedSequence[i],
1:           emissionMatrix.getQuick(hiddenSequence[i], observedSequence[i]) + 1);
1:     }
1:   }
1: 
1:   /**
1:    * Create an supervised initial estimate of an HMM Model based on a number of
1:    * sequences of observed and hidden states.
1:    *
1:    * @param nrOfHiddenStates The total number of hidden states
1:    * @param nrOfOutputStates The total number of output states
1:    * @param hiddenSequences Collection of hidden sequences to use for training
1:    * @param observedSequences Collection of observed sequences to use for training associated with hidden sequences.
1:    * @param pseudoCount      Value that is assigned to non-occurring transitions to avoid zero
1:    *                         probabilities.
1:    * @return An initial model using the estimated parameters
1:    */
1:   public static HmmModel trainSupervisedSequence(int nrOfHiddenStates,
1:                                                  int nrOfOutputStates, Collection<int[]> hiddenSequences,
1:                                                  Collection<int[]> observedSequences, double pseudoCount) {
1: 
1:     // make sure the pseudo count is not zero
0:     pseudoCount = (pseudoCount == 0) ? Double.MIN_VALUE : pseudoCount;
1: 
1:     // initialize parameters
1:     DenseMatrix transitionMatrix = new DenseMatrix(nrOfHiddenStates,
1:         nrOfHiddenStates);
1:     DenseMatrix emissionMatrix = new DenseMatrix(nrOfHiddenStates,
1:         nrOfOutputStates);
1:     DenseVector initialProbabilities = new DenseVector(nrOfHiddenStates);
1: 
1:     // assign pseudo count to avoid zero probabilities
1:     transitionMatrix.assign(pseudoCount);
1:     emissionMatrix.assign(pseudoCount);
1:     initialProbabilities.assign(pseudoCount);
1: 
1:     // now loop over the sequences to count the number of transitions
1:     Iterator<int[]> hiddenSequenceIt = hiddenSequences.iterator();
1:     Iterator<int[]> observedSequenceIt = observedSequences.iterator();
1:     while (hiddenSequenceIt.hasNext() && observedSequenceIt.hasNext()) {
1:       // fetch the current set of sequences
1:       int[] hiddenSequence = hiddenSequenceIt.next();
1:       int[] observedSequence = observedSequenceIt.next();
1:       // increase the count for initial probabilities
1:       initialProbabilities.setQuick(hiddenSequence[0], initialProbabilities
1:           .getQuick(hiddenSequence[0]) + 1);
1:       countTransitions(transitionMatrix, emissionMatrix, observedSequence,
1:           hiddenSequence);
1:     }
1: 
1:     // make sure that probabilities are normalized
1:     double isum = 0; // sum of initial probabilities
1:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:       isum += initialProbabilities.getQuick(i);
1:       // compute sum of probabilities for current row of transition matrix
1:       double sum = 0;
0:       for (int j = 0; j < nrOfHiddenStates; j++)
1:         sum += transitionMatrix.getQuick(i, j);
1:       // normalize current row of transition matrix
0:       for (int j = 0; j < nrOfHiddenStates; j++)
1:         transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j) / sum);
1:       // compute sum of probabilities for current row of emission matrix
1:       sum = 0;
0:       for (int j = 0; j < nrOfOutputStates; j++)
1:         sum += emissionMatrix.getQuick(i, j);
1:       // normalize current row of emission matrix
0:       for (int j = 0; j < nrOfOutputStates; j++)
1:         emissionMatrix.setQuick(i, j, emissionMatrix.getQuick(i, j) / sum);
1:     }
1:     // normalize the initial probabilities
0:     for (int i = 0; i < nrOfHiddenStates; ++i)
1:       initialProbabilities.setQuick(i, initialProbabilities.getQuick(i) / isum);
1: 
1:     // return a new model using the parameter estimates
1:     return new HmmModel(transitionMatrix, emissionMatrix, initialProbabilities);
1:   }
1: 
1:   /**
1:    * Iteratively train the parameters of the given initial model wrt to the
1:    * observed sequence using Viterbi training.
1:    *
1:    * @param initialModel     The initial model that gets iterated
1:    * @param observedSequence The sequence of observed states
1:    * @param pseudoCount      Value that is assigned to non-occurring transitions to avoid zero
1:    *                         probabilities.
1:    * @param epsilon          Convergence criteria
1:    * @param maxIterations    The maximum number of training iterations
1:    * @param scaled           Use Log-scaled implementation, this is computationally more
1:    *                         expensive but offers better numerical stability for large observed
1:    *                         sequences
1:    * @return The iterated model
1:    */
1:   public static HmmModel trainViterbi(HmmModel initialModel,
1:                                       int[] observedSequence, double pseudoCount, double epsilon,
1:                                       int maxIterations, boolean scaled) {
1: 
1:     // make sure the pseudo count is not zero
0:     pseudoCount = (pseudoCount == 0) ? Double.MIN_VALUE : pseudoCount;
1: 
1:     // allocate space for iteration models
0:     HmmModel lastIteration;
0:     HmmModel iteration;
0:     try {
0:       lastIteration = initialModel.clone();
0:       iteration = initialModel.clone();
0:     } catch (CloneNotSupportedException e) {
0:       throw new UnknownError("Cloning HmmModels broke. Check for programming errors, changed APIs.");
1:     }
1: 
1:     // allocate space for Viterbi path calculation
1:     int[] viterbiPath = new int[observedSequence.length];
1:     int[][] phi = new int[observedSequence.length - 1][initialModel
1:         .getNrOfHiddenStates()];
1:     double[][] delta = new double[observedSequence.length][initialModel
1:         .getNrOfHiddenStates()];
1: 
1:     // now run the Viterbi training iteration
1:     for (int i = 0; i < maxIterations; ++i) {
1:       // compute the Viterbi path
1:       HmmAlgorithms.viterbiAlgorithm(viterbiPath, delta, phi, lastIteration,
1:           observedSequence, scaled);
1:       // Viterbi iteration uses the viterbi path to update
1:       // the probabilities
1:       Matrix emissionMatrix = iteration.getEmissionMatrix();
1:       Matrix transitionMatrix = iteration.getTransitionMatrix();
1: 
1:       // first, assign the pseudo count
1:       emissionMatrix.assign(pseudoCount);
1:       transitionMatrix.assign(pseudoCount);
1: 
1:       // now count the transitions
1:       countTransitions(transitionMatrix, emissionMatrix, observedSequence,
1:           viterbiPath);
1: 
1:       // and normalize the probabilities
1:       for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {
1:         double sum = 0;
1:         // normalize the rows of the transition matrix
0:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k)
1:           sum += transitionMatrix.getQuick(j, k);
0:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k)
1:           transitionMatrix
1:               .setQuick(j, k, transitionMatrix.getQuick(j, k) / sum);
1:         // normalize the rows of the emission matrix
1:         sum = 0;
0:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k)
1:           sum += emissionMatrix.getQuick(j, k);
0:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k)
1:           emissionMatrix.setQuick(j, k, emissionMatrix.getQuick(j, k) / sum);
1:       }
1:       // check for convergence
0:       if (checkConvergence(lastIteration, iteration, epsilon))
1:         break;
1:       // overwrite the last iterated model by the new iteration
1:       lastIteration.assign(iteration);
1:     }
1:     // we are done :)
1:     return iteration;
1:   }
1: 
1:   /**
1:    * Iteratively train the parameters of the given initial model wrt the
1:    * observed sequence using Baum-Welch training.
1:    *
1:    * @param initialModel     The initial model that gets iterated
1:    * @param observedSequence The sequence of observed states
1:    * @param epsilon          Convergence criteria
1:    * @param maxIterations    The maximum number of training iterations
1:    * @param scaled           Use log-scaled implementations of forward/backward algorithm. This
1:    *                         is computationally more expensive, but offers better numerical
1:    *                         stability for long output sequences.
1:    * @return The iterated model
1:    */
1:   public static HmmModel trainBaumWelch(HmmModel initialModel,
1:                                         int[] observedSequence, double epsilon, int maxIterations, boolean scaled) {
1:     // allocate space for the iterations
0:     HmmModel lastIteration;
0:     HmmModel iteration;
0:     try {
0:       lastIteration = initialModel.clone();
0:       iteration = initialModel.clone();
0:     } catch (CloneNotSupportedException e) {
0:       throw new UnknownError("Cloning HmmModels broke. Check for programming errors, changed APIs etc.");
1:     }
1:     // allocate space for baum-welch factors
1:     int hiddenCount = initialModel.getNrOfHiddenStates();
1:     int visibleCount = observedSequence.length;
0:     DenseMatrix alpha = new DenseMatrix(visibleCount, hiddenCount);
0:     DenseMatrix beta = new DenseMatrix(visibleCount, hiddenCount);
1: 
1:     // now run the baum Welch training iteration
1:     for (int it = 0; it < maxIterations; ++it) {
1:       // fetch emission and transition matrix of current iteration
1:       Vector initialProbabilities = iteration.getInitialProbabilities();
1:       Matrix emissionMatrix = iteration.getEmissionMatrix();
1:       Matrix transitionMatrix = iteration.getTransitionMatrix();
1: 
1:       // compute forward and backward factors
1:       HmmAlgorithms.forwardAlgorithm(alpha, iteration, observedSequence, scaled);
1:       HmmAlgorithms.backwardAlgorithm(beta, iteration, observedSequence, scaled);
1: 
1:       if (scaled) {
1:         logScaledBaumWelch(observedSequence, iteration, alpha, beta);
1:       } else {
1:         unscaledBaumWelch(observedSequence, iteration, alpha, beta);
1:       }
1:       // normalize transition/emission probabilities
1:       // and normalize the probabilities
1:       double isum = 0;
1:       for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {
1:         double sum = 0;
1:         // normalize the rows of the transition matrix
0:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k)
1:           sum += transitionMatrix.getQuick(j, k);
0:         for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k)
1:           transitionMatrix
1:               .setQuick(j, k, transitionMatrix.getQuick(j, k) / sum);
1:         // normalize the rows of the emission matrix
1:         sum = 0;
0:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k)
1:           sum += emissionMatrix.getQuick(j, k);
0:         for (int k = 0; k < iteration.getNrOfOutputStates(); ++k)
1:           emissionMatrix.setQuick(j, k, emissionMatrix.getQuick(j, k) / sum);
1:         // normalization parameter for initial probabilities
1:         isum += initialProbabilities.getQuick(j);
1:       }
1:       // normalize initial probabilities
1:       for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:         initialProbabilities.setQuick(i, initialProbabilities.getQuick(i)
1:             / isum);
1:       }
1:       // check for convergence
0:       if (checkConvergence(lastIteration, iteration, epsilon))
1:         break;
1:       // overwrite the last iterated model by the new iteration
1:       lastIteration.assign(iteration);
1:     }
1:     // we are done :)
1:     return iteration;
1:   }
1: 
0:   private static void unscaledBaumWelch(int[] observedSequence, HmmModel iteration, DenseMatrix alpha, DenseMatrix beta) {
1:     Vector initialProbabilities = iteration.getInitialProbabilities();
1:     Matrix emissionMatrix = iteration.getEmissionMatrix();
1:     Matrix transitionMatrix = iteration.getTransitionMatrix();
1:     double modelLikelihood = HmmEvaluator.modelLikelihood(alpha, false);
1: 
1:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:       initialProbabilities.setQuick(i, alpha.getQuick(0, i)
1:           * beta.getQuick(0, i));
1:     }
1: 
1:     // recompute transition probabilities
1:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:       for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {
1:         double temp = 0;
1:         for (int t = 0; t < observedSequence.length - 1; ++t) {
1:           temp += alpha.getQuick(t, i)
1:               * emissionMatrix.getQuick(j, observedSequence[t + 1])
1:               * beta.getQuick(t + 1, j);
1:         }
1:         transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j)
1:             * temp / modelLikelihood);
1:       }
1:     }
1:     // recompute emission probabilities
1:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:       for (int j = 0; j < iteration.getNrOfOutputStates(); ++j) {
1:         double temp = 0;
1:         for (int t = 0; t < observedSequence.length; ++t) {
1:           // delta tensor
1:           if (observedSequence[t] == j) {
1:             temp += alpha.getQuick(t, i) * beta.getQuick(t, i);
1:           }
1:         }
1:         emissionMatrix.setQuick(i, j, temp / modelLikelihood);
1:       }
1:     }
1:   }
1: 
0:   private static void logScaledBaumWelch(int[] observedSequence, HmmModel iteration, DenseMatrix alpha, DenseMatrix beta) {
1:     Vector initialProbabilities = iteration.getInitialProbabilities();
1:     Matrix emissionMatrix = iteration.getEmissionMatrix();
1:     Matrix transitionMatrix = iteration.getTransitionMatrix();
1:     double modelLikelihood = HmmEvaluator.modelLikelihood(alpha, true);
1: 
1:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:       initialProbabilities.setQuick(i, Math.exp(alpha.getQuick(0, i) + beta.getQuick(0, i)));
1:     }
1: 
1:     // recompute transition probabilities
1:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:       for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {
1:         double sum = Double.NEGATIVE_INFINITY; // log(0)
1:         for (int t = 0; t < observedSequence.length - 1; ++t) {
1:           double temp = alpha.getQuick(t, i)
1:               + Math.log(emissionMatrix.getQuick(j, observedSequence[t + 1]))
1:               + beta.getQuick(t + 1, j);
0:           if (temp > Double.NEGATIVE_INFINITY) // handle
0:             // 0-probabilities
0:             sum = temp + Math.log(1 + Math.exp(sum - temp));
1:         }
1:         transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j)
1:             * Math.exp(sum - modelLikelihood));
1:       }
1:     }
1:     // recompute emission probabilities
1:     for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {
1:       for (int j = 0; j < iteration.getNrOfOutputStates(); ++j) {
1:         double sum = Double.NEGATIVE_INFINITY; // log(0)
1:         for (int t = 0; t < observedSequence.length; ++t) {
1:           // delta tensor
1:           if (observedSequence[t] == j) {
1:             double temp = alpha.getQuick(t, i) + beta.getQuick(t, i);
0:             if (temp > Double.NEGATIVE_INFINITY) // handle
0:               // 0-probabilities
0:               sum = temp + Math.log(1 + Math.exp(sum - temp));
1:           }
1:         }
1:         emissionMatrix.setQuick(i, j, Math.exp(sum - modelLikelihood));
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Check convergence of two HMM models by computing a simple distance between
1:    * emission / transition matrices
1:    *
1:    * @param oldModel Old HMM Model
1:    * @param newModel New HMM Model
1:    * @param epsilon  Convergence Factor
1:    * @return true if training converged to a stable state.
1:    */
1:   private static boolean checkConvergence(HmmModel oldModel, HmmModel newModel,
1:                                           double epsilon) {
1:     // check convergence of transitionProbabilities
1:     Matrix oldTransitionMatrix = oldModel.getTransitionMatrix();
1:     Matrix newTransitionMatrix = newModel.getTransitionMatrix();
1:     double diff = 0;
1:     for (int i = 0; i < oldModel.getNrOfHiddenStates(); ++i) {
1:       for (int j = 0; j < oldModel.getNrOfHiddenStates(); ++j) {
1:         double tmp = oldTransitionMatrix.getQuick(i, j)
1:             - newTransitionMatrix.getQuick(i, j);
1:         diff += tmp * tmp;
1:       }
1:     }
1:     double norm = Math.sqrt(diff);
1:     diff = 0;
1:     // check convergence of emissionProbabilities
1:     Matrix oldEmissionMatrix = oldModel.getEmissionMatrix();
1:     Matrix newEmissionMatrix = newModel.getEmissionMatrix();
1:     for (int i = 0; i < oldModel.getNrOfHiddenStates(); i++) {
1:       for (int j = 0; j < oldModel.getNrOfOutputStates(); j++) {
1: 
1:         double tmp = oldEmissionMatrix.getQuick(i, j)
1:             - newEmissionMatrix.getQuick(i, j);
1:         diff += tmp * tmp;
1:       }
1:     }
1:     norm += Math.sqrt(diff);
1:     // iteration has converged :)
1:     return norm < epsilon;
1:   }
1: 
1: }
============================================================================