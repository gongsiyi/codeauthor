1:1cdd095: /*
1:1cdd095:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:1cdd095:  * contributor license agreements.  See the NOTICE file distributed with
1:1cdd095:  * this work for additional information regarding copyright ownership.
1:1cdd095:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:1cdd095:  * (the "License"); you may not use this file except in compliance with
1:1cdd095:  * the License.  You may obtain a copy of the License at
1:1cdd095:  *
1:1cdd095:  *     http://www.apache.org/licenses/LICENSE-2.0
1:1cdd095:  *
1:1cdd095:  * Unless required by applicable law or agreed to in writing, software
1:1cdd095:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1cdd095:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1cdd095:  * See the License for the specific language governing permissions and
1:1cdd095:  * limitations under the License.
1:1cdd095:  */
1:1cdd095: 
1:a8d3dbd: package org.apache.mahout.math;
1:a8d3dbd: 
1:a8d3dbd: import org.apache.mahout.math.function.DoubleDoubleFunction;
1:a8d3dbd: import org.apache.mahout.math.set.OpenIntHashSet;
1:a8d3dbd: 
1:a8d3dbd: import java.util.Iterator;
1:a8d3dbd: 
1:a8d3dbd: /**
1:8b194c8:  * Abstract class encapsulating different algorithms that perform the Vector operations aggregate().
1:a8d3dbd:  * x.aggregte(y, fa, fc), for x and y Vectors and fa, fc DoubleDouble functions:
1:a8d3dbd:  * - applies the function fc to every element in x and y, fc(xi, yi)
1:a8d3dbd:  * - constructs a result iteratively, r0 = fc(x0, y0), ri = fc(r_{i-1}, fc(xi, yi)).
1:a8d3dbd:  * This works essentially like a map/reduce functional combo.
1:a8d3dbd:  *
1:a8d3dbd:  * The names of variables, methods and classes used here follow the following conventions:
1:a8d3dbd:  * The vector being assigned to (the left hand side) is called this or x.
1:a8d3dbd:  * The right hand side is called that or y.
1:a8d3dbd:  * The aggregating (reducing) function to be applied is called fa.
1:a8d3dbd:  * The combining (mapping) function to be applied is called fc.
1:a8d3dbd:  *
1:a8d3dbd:  * The different algorithms take into account the different characteristics of vector classes:
1:a8d3dbd:  * - whether the vectors support sequential iteration (isSequential())
1:a8d3dbd:  * - what the lookup cost is (getLookupCost())
1:a8d3dbd:  * - what the iterator advancement cost is (getIteratorAdvanceCost())
1:a8d3dbd:  *
1:a8d3dbd:  * The names of the actual classes (they're nested in VectorBinaryAssign) describe the used for assignment.
1:a8d3dbd:  * The most important optimization is iterating just through the nonzeros (only possible if f(0, 0) = 0).
1:a8d3dbd:  * There are 4 main possibilities:
1:a8d3dbd:  * - iterating through the nonzeros of just one vector and looking up the corresponding elements in the other
1:a8d3dbd:  * - iterating through the intersection of nonzeros (those indices where both vectors have nonzero values)
1:a8d3dbd:  * - iterating through the union of nonzeros (those indices where at least one of the vectors has a nonzero value)
1:a8d3dbd:  * - iterating through all the elements in some way (either through both at the same time, both one after the other,
1:a8d3dbd:  *   looking up both, looking up just one).
1:a8d3dbd:  *
1:a8d3dbd:  * The internal details are not important and a particular algorithm should generally not be called explicitly.
1:a8d3dbd:  * The best one will be selected through assignBest(), which is itself called through Vector.assign().
1:a8d3dbd:  *
1:a8d3dbd:  * See https://docs.google.com/document/d/1g1PjUuvjyh2LBdq2_rKLIcUiDbeOORA1sCJiSsz-JVU/edit# for a more detailed
1:a8d3dbd:  * explanation.
1:a8d3dbd:  */
1:a8d3dbd: public abstract class VectorBinaryAggregate {
1:58cc1ae:   public static final VectorBinaryAggregate[] OPERATIONS = {
1:58cc1ae:     new AggregateNonzerosIterateThisLookupThat(),
1:58cc1ae:     new AggregateNonzerosIterateThatLookupThis(),
1:a8d3dbd: 
1:58cc1ae:     new AggregateIterateIntersection(),
1:a8d3dbd: 
1:58cc1ae:     new AggregateIterateUnionSequential(),
1:58cc1ae:     new AggregateIterateUnionRandom(),
1:a8d3dbd: 
1:58cc1ae:     new AggregateAllIterateSequential(),
1:58cc1ae:     new AggregateAllIterateThisLookupThat(),
1:58cc1ae:     new AggregateAllIterateThatLookupThis(),
1:58cc1ae:     new AggregateAllLoop(),
1:a8d3dbd:   };
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * Returns true iff we can use this algorithm to apply fc to x and y component-wise and aggregate the result using fa.
1:a8d3dbd:    */
1:a8d3dbd:   public abstract boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc);
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * Estimates the cost of using this algorithm to compute the aggregation. The algorithm is assumed to be valid.
1:a8d3dbd:    */
1:a8d3dbd:   public abstract double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc);
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * Main method that applies fc to x and y component-wise aggregating the results with fa. It returns the result of
1:a8d3dbd:    * the aggregation.
1:a8d3dbd:    */
1:a8d3dbd:   public abstract double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc);
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * The best operation is the least expensive valid one.
1:a8d3dbd:    */
1:58cc1ae:   public static VectorBinaryAggregate getBestOperation(Vector x, Vector y, DoubleDoubleFunction fa,
1:58cc1ae:                                                        DoubleDoubleFunction fc) {
1:a8d3dbd:     int bestOperationIndex = -1;
1:a8d3dbd:     double bestCost = Double.POSITIVE_INFINITY;
1:58cc1ae:     for (int i = 0; i < OPERATIONS.length; ++i) {
1:58cc1ae:       if (OPERATIONS[i].isValid(x, y, fa, fc)) {
1:58cc1ae:         double cost = OPERATIONS[i].estimateCost(x, y, fa, fc);
1:a8d3dbd:         if (cost < bestCost) {
1:a8d3dbd:           bestCost = cost;
1:a8d3dbd:           bestOperationIndex = i;
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:     }
1:58cc1ae:     return OPERATIONS[bestOperationIndex];
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * This is the method that should be used when aggregating. It selects the best algorithm and applies it.
1:a8d3dbd:    */
1:a8d3dbd:   public static double aggregateBest(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:     return getBestOperation(x, y, fa, fc).aggregate(x, y, fa, fc);
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AggregateNonzerosIterateThisLookupThat extends VectorBinaryAggregate {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return fa.isLikeRightPlus() && (fa.isAssociativeAndCommutative() || x.isSequentialAccess())
1:a8d3dbd:           && fc.isLikeLeftMult();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:dc62944:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:a8d3dbd:       if (!xi.hasNext()) {
1:a8d3dbd:         return 0;
1:a8d3dbd:       }
1:a8d3dbd:       Vector.Element xe = xi.next();
1:a8d3dbd:       double result = fc.apply(xe.get(), y.getQuick(xe.index()));
1:a8d3dbd:       while (xi.hasNext()) {
4:a8d3dbd:         xe = xi.next();
1:a8d3dbd:         result = fa.apply(result, fc.apply(xe.get(), y.getQuick(xe.index())));
1:a8d3dbd:       }
1:a8d3dbd:       return result;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AggregateNonzerosIterateThatLookupThis extends VectorBinaryAggregate {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return fa.isLikeRightPlus() && (fa.isAssociativeAndCommutative() || y.isSequentialAccess())
1:a8d3dbd:           && fc.isLikeRightMult();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost() * x.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:dc62944:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
1:a8d3dbd:       if (!yi.hasNext()) {
1:a8d3dbd:         return 0;
1:a8d3dbd:       }
1:a8d3dbd:       Vector.Element ye = yi.next();
1:a8d3dbd:       double result = fc.apply(x.getQuick(ye.index()), ye.get());
1:a8d3dbd:       while (yi.hasNext()) {
3:a8d3dbd:         ye = yi.next();
1:a8d3dbd:         result = fa.apply(result, fc.apply(x.getQuick(ye.index()), ye.get()));
1:a8d3dbd:       }
1:a8d3dbd:       return result;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AggregateIterateIntersection extends VectorBinaryAggregate {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return fa.isLikeRightPlus() && fc.isLikeMult() && x.isSequentialAccess() && y.isSequentialAccess();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return Math.min(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:a8d3dbd:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:dc62944:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:dc62944:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
1:a8d3dbd:       Vector.Element xe = null;
1:a8d3dbd:       Vector.Element ye = null;
1:a8d3dbd:       boolean advanceThis = true;
1:a8d3dbd:       boolean advanceThat = true;
1:a8d3dbd:       boolean validResult = false;
1:a8d3dbd:       double result = 0;
1:a8d3dbd:       while (true) {
1:a8d3dbd:         if (advanceThis) {
1:a8d3dbd:           if (xi.hasNext()) {
1:a8d3dbd:             xe = xi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             break;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:         if (advanceThat) {
1:a8d3dbd:           if (yi.hasNext()) {
1:a8d3dbd:             ye = yi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             break;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:         if (xe.index() == ye.index()) {
1:4ca6b86:           double thisResult = fc.apply(xe.get(), ye.get());
1:a8d3dbd:           if (validResult) {
1:a8d3dbd:             result = fa.apply(result, thisResult);
1:a8d3dbd:           } else {
1:a8d3dbd:             result = thisResult;
1:a8d3dbd:             validResult = true;
1:a8d3dbd:           }
1:a8d3dbd:           advanceThis = true;
1:a8d3dbd:           advanceThat = true;
1:a8d3dbd:         } else {
1:a8d3dbd:           if (xe.index() < ye.index()) { // f(x, 0) = 0
1:a8d3dbd:             advanceThis = true;
1:a8d3dbd:             advanceThat = false;
1:a8d3dbd:           } else { // f(0, y) = 0
1:a8d3dbd:             advanceThis = false;
1:a8d3dbd:             advanceThat = true;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       return result;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AggregateIterateUnionSequential extends VectorBinaryAggregate {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return fa.isLikeRightPlus() && !fc.isDensifying()
1:a8d3dbd:           && x.isSequentialAccess() && y.isSequentialAccess();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:a8d3dbd:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:dc62944:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:dc62944:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
1:a8d3dbd:       Vector.Element xe = null;
1:a8d3dbd:       Vector.Element ye = null;
1:a8d3dbd:       boolean advanceThis = true;
1:a8d3dbd:       boolean advanceThat = true;
1:a8d3dbd:       boolean validResult = false;
1:a8d3dbd:       double result = 0;
1:a8d3dbd:       while (true) {
1:a8d3dbd:         if (advanceThis) {
1:a8d3dbd:           if (xi.hasNext()) {
1:a8d3dbd:             xe = xi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             xe = null;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:         if (advanceThat) {
1:a8d3dbd:           if (yi.hasNext()) {
1:a8d3dbd:             ye = yi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             ye = null;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:4ca6b86:         double thisResult;
1:a8d3dbd:         if (xe != null && ye != null) { // both vectors have nonzero elements
1:a8d3dbd:           if (xe.index() == ye.index()) {
2:a8d3dbd:             thisResult = fc.apply(xe.get(), ye.get());
1:a8d3dbd:             advanceThis = true;
1:a8d3dbd:             advanceThat = true;
1:a8d3dbd:           } else {
1:a8d3dbd:             if (xe.index() < ye.index()) { // f(x, 0)
1:a8d3dbd:               thisResult = fc.apply(xe.get(), 0);
1:a8d3dbd:               advanceThis = true;
1:a8d3dbd:               advanceThat = false;
1:a8d3dbd:             } else {
1:a8d3dbd:               thisResult = fc.apply(0, ye.get());
1:a8d3dbd:               advanceThis = false;
1:a8d3dbd:               advanceThat = true;
1:a8d3dbd:             }
1:a8d3dbd:           }
1:a8d3dbd:         } else if (xe != null) { // just the first one still has nonzeros
1:a8d3dbd:           thisResult = fc.apply(xe.get(), 0);
1:a8d3dbd:           advanceThis = true;
1:a8d3dbd:           advanceThat = false;
1:a8d3dbd:         } else if (ye != null) { // just the second one has nonzeros
1:a8d3dbd:           thisResult = fc.apply(0, ye.get());
1:a8d3dbd:           advanceThis = false;
1:a8d3dbd:           advanceThat = true;
1:a8d3dbd:         } else { // we're done, both are empty
1:a8d3dbd:           break;
1:a8d3dbd:         }
1:a8d3dbd:         if (validResult) {
1:a8d3dbd:           result = fa.apply(result, thisResult);
1:a8d3dbd:         } else {
1:a8d3dbd:           result = thisResult;
1:a8d3dbd:           validResult =  true;
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       return result;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AggregateIterateUnionRandom extends VectorBinaryAggregate {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return fa.isLikeRightPlus() && !fc.isDensifying()
1:a8d3dbd:           && (fa.isAssociativeAndCommutative() || (x.isSequentialAccess() && y.isSequentialAccess()));
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost(),
1:a8d3dbd:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       OpenIntHashSet visited = new OpenIntHashSet();
1:dc62944:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:a8d3dbd:       boolean validResult = false;
1:a8d3dbd:       double result = 0;
6:a8d3dbd:       double thisResult;
1:a8d3dbd:       while (xi.hasNext()) {
1:4ca6b86:         Vector.Element xe = xi.next();
2:a8d3dbd:         thisResult = fc.apply(xe.get(), y.getQuick(xe.index()));
1:a8d3dbd:         if (validResult) {
1:a8d3dbd:           result = fa.apply(result, thisResult);
1:a8d3dbd:         } else {
1:a8d3dbd:           result = thisResult;
1:a8d3dbd:           validResult = true;
1:a8d3dbd:         }
1:a8d3dbd:         visited.add(xe.index());
1:a8d3dbd:       }
1:dc62944:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
1:a8d3dbd:       while (yi.hasNext()) {
1:4ca6b86:         Vector.Element ye = yi.next();
1:a8d3dbd:         if (!visited.contains(ye.index())) {
2:a8d3dbd:           thisResult = fc.apply(x.getQuick(ye.index()), ye.get());
1:a8d3dbd:           if (validResult) {
1:a8d3dbd:             result = fa.apply(result, thisResult);
1:a8d3dbd:           } else {
1:a8d3dbd:             result = thisResult;
1:a8d3dbd:             validResult = true;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       return result;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AggregateAllIterateSequential extends VectorBinaryAggregate {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return x.isSequentialAccess() && y.isSequentialAccess() && !x.isDense() && !y.isDense();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return Math.max(x.size() * x.getIteratorAdvanceCost(), y.size() * y.getIteratorAdvanceCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:dc62944:       Iterator<Vector.Element> xi = x.all().iterator();
1:dc62944:       Iterator<Vector.Element> yi = y.all().iterator();
1:a8d3dbd:       boolean validResult = false;
1:a8d3dbd:       double result = 0;
1:a8d3dbd:       while (xi.hasNext() && yi.hasNext()) {
1:4ca6b86:         Vector.Element xe = xi.next();
1:4ca6b86:         double thisResult = fc.apply(xe.get(), yi.next().get());
1:a8d3dbd:         if (validResult) {
1:a8d3dbd:           result = fa.apply(result, thisResult);
1:a8d3dbd:         } else {
1:a8d3dbd:           result = thisResult;
1:a8d3dbd:           validResult = true;
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       return result;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AggregateAllIterateThisLookupThat extends VectorBinaryAggregate {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return (fa.isAssociativeAndCommutative() || x.isSequentialAccess())
1:a8d3dbd:           && !x.isDense();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return x.size() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:dc62944:       Iterator<Vector.Element> xi = x.all().iterator();
1:a8d3dbd:       boolean validResult = false;
1:a8d3dbd:       double result = 0;
1:a8d3dbd:       while (xi.hasNext()) {
1:4ca6b86:         Vector.Element xe = xi.next();
1:4ca6b86:         double thisResult = fc.apply(xe.get(), y.getQuick(xe.index()));
1:a8d3dbd:         if (validResult) {
1:a8d3dbd:           result = fa.apply(result, thisResult);
1:a8d3dbd:         } else {
1:a8d3dbd:           result = thisResult;
1:a8d3dbd:           validResult = true;
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       return result;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AggregateAllIterateThatLookupThis extends VectorBinaryAggregate {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return (fa.isAssociativeAndCommutative() || y.isSequentialAccess())
1:a8d3dbd:           && !y.isDense();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return y.size() * y.getIteratorAdvanceCost() * x.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:dc62944:       Iterator<Vector.Element> yi = y.all().iterator();
1:a8d3dbd:       boolean validResult = false;
1:a8d3dbd:       double result = 0;
1:a8d3dbd:       while (yi.hasNext()) {
1:4ca6b86:         Vector.Element ye = yi.next();
1:4ca6b86:         double thisResult = fc.apply(x.getQuick(ye.index()), ye.get());
1:a8d3dbd:         if (validResult) {
1:a8d3dbd:           result = fa.apply(result, thisResult);
1:a8d3dbd:         } else {
1:a8d3dbd:           result = thisResult;
1:a8d3dbd:           validResult = true;
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       return result;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AggregateAllLoop extends VectorBinaryAggregate {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return true;
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       return x.size() * x.getLookupCost() * y.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:a8d3dbd:       double result = fc.apply(x.getQuick(0), y.getQuick(0));
1:509c966:       int s = x.size();
1:509c966:       for (int i = 1; i < s; ++i) {
1:a8d3dbd:         result = fa.apply(result, fc.apply(x.getQuick(i), y.getQuick(i)));
1:a8d3dbd:       }
1:a8d3dbd:       return result;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: }
============================================================================
author:smarthi
-------------------------------------------------------------------------------
commit:509c966
/////////////////////////////////////////////////////////////////////////
1:       int s = x.size();
1:       for (int i = 1; i < s; ++i) {
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:1cdd095
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
commit:4ca6b86
/////////////////////////////////////////////////////////////////////////
0:   public static final VectorBinaryAggregate[] operations = {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:           double thisResult = fc.apply(xe.get(), ye.get());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         double thisResult;
/////////////////////////////////////////////////////////////////////////
1:         Vector.Element xe = xi.next();
/////////////////////////////////////////////////////////////////////////
1:         Vector.Element ye = yi.next();
/////////////////////////////////////////////////////////////////////////
1:         Vector.Element xe = xi.next();
1:         double thisResult = fc.apply(xe.get(), yi.next().get());
/////////////////////////////////////////////////////////////////////////
1:         Vector.Element xe = xi.next();
1:         double thisResult = fc.apply(xe.get(), y.getQuick(xe.index()));
/////////////////////////////////////////////////////////////////////////
1:         Vector.Element ye = yi.next();
1:         double thisResult = fc.apply(x.getQuick(ye.index()), ye.get());
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:8b194c8
/////////////////////////////////////////////////////////////////////////
1:  * Abstract class encapsulating different algorithms that perform the Vector operations aggregate().
commit:58cc1ae
/////////////////////////////////////////////////////////////////////////
0:  * Abstract class encapsulating different algorithms that perform the Vector OPERATIONS aggregate().
/////////////////////////////////////////////////////////////////////////
1:   public static final VectorBinaryAggregate[] OPERATIONS = {
1:     new AggregateNonzerosIterateThisLookupThat(),
1:     new AggregateNonzerosIterateThatLookupThis(),
1:     new AggregateIterateIntersection(),
1:     new AggregateIterateUnionSequential(),
1:     new AggregateIterateUnionRandom(),
1:     new AggregateAllIterateSequential(),
1:     new AggregateAllIterateThisLookupThat(),
1:     new AggregateAllIterateThatLookupThis(),
1:     new AggregateAllLoop(),
/////////////////////////////////////////////////////////////////////////
1:   public static VectorBinaryAggregate getBestOperation(Vector x, Vector y, DoubleDoubleFunction fa,
1:                                                        DoubleDoubleFunction fc) {
1:     for (int i = 0; i < OPERATIONS.length; ++i) {
1:       if (OPERATIONS[i].isValid(x, y, fa, fc)) {
1:         double cost = OPERATIONS[i].estimateCost(x, y, fa, fc);
1:     return OPERATIONS[bestOperationIndex];
author:Jacob Alexander Mannix
-------------------------------------------------------------------------------
commit:dc62944
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.all().iterator();
1:       Iterator<Vector.Element> yi = y.all().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.all().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> yi = y.all().iterator();
author:dfilimon
-------------------------------------------------------------------------------
commit:a8d3dbd
/////////////////////////////////////////////////////////////////////////
1: package org.apache.mahout.math;
1: 
1: import org.apache.mahout.math.function.DoubleDoubleFunction;
1: import org.apache.mahout.math.set.OpenIntHashSet;
1: 
1: import java.util.Iterator;
1: 
1: /**
0:  * Abstract class encapsulating different algorithms that perform the Vector operations aggregate().
1:  * x.aggregte(y, fa, fc), for x and y Vectors and fa, fc DoubleDouble functions:
1:  * - applies the function fc to every element in x and y, fc(xi, yi)
1:  * - constructs a result iteratively, r0 = fc(x0, y0), ri = fc(r_{i-1}, fc(xi, yi)).
1:  * This works essentially like a map/reduce functional combo.
1:  *
1:  * The names of variables, methods and classes used here follow the following conventions:
1:  * The vector being assigned to (the left hand side) is called this or x.
1:  * The right hand side is called that or y.
1:  * The aggregating (reducing) function to be applied is called fa.
1:  * The combining (mapping) function to be applied is called fc.
1:  *
1:  * The different algorithms take into account the different characteristics of vector classes:
1:  * - whether the vectors support sequential iteration (isSequential())
1:  * - what the lookup cost is (getLookupCost())
1:  * - what the iterator advancement cost is (getIteratorAdvanceCost())
1:  *
1:  * The names of the actual classes (they're nested in VectorBinaryAssign) describe the used for assignment.
1:  * The most important optimization is iterating just through the nonzeros (only possible if f(0, 0) = 0).
1:  * There are 4 main possibilities:
1:  * - iterating through the nonzeros of just one vector and looking up the corresponding elements in the other
1:  * - iterating through the intersection of nonzeros (those indices where both vectors have nonzero values)
1:  * - iterating through the union of nonzeros (those indices where at least one of the vectors has a nonzero value)
1:  * - iterating through all the elements in some way (either through both at the same time, both one after the other,
1:  *   looking up both, looking up just one).
1:  *
1:  * The internal details are not important and a particular algorithm should generally not be called explicitly.
1:  * The best one will be selected through assignBest(), which is itself called through Vector.assign().
1:  *
1:  * See https://docs.google.com/document/d/1g1PjUuvjyh2LBdq2_rKLIcUiDbeOORA1sCJiSsz-JVU/edit# for a more detailed
1:  * explanation.
1:  */
1: public abstract class VectorBinaryAggregate {
0:   public static final VectorBinaryAggregate[] operations = new VectorBinaryAggregate[] {
0:       new AggregateNonzerosIterateThisLookupThat(),
0:       new AggregateNonzerosIterateThatLookupThis(),
1: 
0:       new AggregateIterateIntersection(),
1: 
0:       new AggregateIterateUnionSequential(),
0:       new AggregateIterateUnionRandom(),
1: 
0:       new AggregateAllIterateSequential(),
0:       new AggregateAllIterateThisLookupThat(),
0:       new AggregateAllIterateThatLookupThis(),
0:       new AggregateAllLoop(),
1:   };
1: 
1:   /**
1:    * Returns true iff we can use this algorithm to apply fc to x and y component-wise and aggregate the result using fa.
1:    */
1:   public abstract boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc);
1: 
1:   /**
1:    * Estimates the cost of using this algorithm to compute the aggregation. The algorithm is assumed to be valid.
1:    */
1:   public abstract double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc);
1: 
1:   /**
1:    * Main method that applies fc to x and y component-wise aggregating the results with fa. It returns the result of
1:    * the aggregation.
1:    */
1:   public abstract double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc);
1: 
1:   /**
1:    * The best operation is the least expensive valid one.
1:    */
0:   public static VectorBinaryAggregate getBestOperation(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:     int bestOperationIndex = -1;
1:     double bestCost = Double.POSITIVE_INFINITY;
0:     for (int i = 0; i < operations.length; ++i) {
0:       if (operations[i].isValid(x, y, fa, fc)) {
0:         double cost = operations[i].estimateCost(x, y, fa, fc);
1:         if (cost < bestCost) {
1:           bestCost = cost;
1:           bestOperationIndex = i;
1:         }
1:       }
1:     }
0:     return operations[bestOperationIndex];
1:   }
1: 
1:   /**
1:    * This is the method that should be used when aggregating. It selects the best algorithm and applies it.
1:    */
1:   public static double aggregateBest(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:     return getBestOperation(x, y, fa, fc).aggregate(x, y, fa, fc);
1:   }
1: 
1:   public static class AggregateNonzerosIterateThisLookupThat extends VectorBinaryAggregate {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return fa.isLikeRightPlus() && (fa.isAssociativeAndCommutative() || x.isSequentialAccess())
1:           && fc.isLikeLeftMult();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:     }
1: 
1:     @Override
1:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
1:       if (!xi.hasNext()) {
1:         return 0;
1:       }
1:       Vector.Element xe = xi.next();
1:       double result = fc.apply(xe.get(), y.getQuick(xe.index()));
1:       while (xi.hasNext()) {
1:         xe = xi.next();
1:         result = fa.apply(result, fc.apply(xe.get(), y.getQuick(xe.index())));
1:       }
1:       return result;
1:     }
1:   }
1: 
1:   public static class AggregateNonzerosIterateThatLookupThis extends VectorBinaryAggregate {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return fa.isLikeRightPlus() && (fa.isAssociativeAndCommutative() || y.isSequentialAccess())
1:           && fc.isLikeRightMult();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost() * x.getLookupCost();
1:     }
1: 
1:     @Override
1:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
1:       if (!yi.hasNext()) {
1:         return 0;
1:       }
1:       Vector.Element ye = yi.next();
1:       double result = fc.apply(x.getQuick(ye.index()), ye.get());
1:       while (yi.hasNext()) {
1:         ye = yi.next();
1:         result = fa.apply(result, fc.apply(x.getQuick(ye.index()), ye.get()));
1:       }
1:       return result;
1:     }
1:   }
1: 
1:   public static class AggregateIterateIntersection extends VectorBinaryAggregate {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return fa.isLikeRightPlus() && fc.isLikeMult() && x.isSequentialAccess() && y.isSequentialAccess();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return Math.min(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:     }
1: 
1:     @Override
1:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
1:       Vector.Element xe = null;
1:       Vector.Element ye = null;
1:       boolean advanceThis = true;
1:       boolean advanceThat = true;
1:       boolean validResult = false;
1:       double result = 0;
1:       double thisResult;
1:       while (true) {
1:         if (advanceThis) {
1:           if (xi.hasNext()) {
1:             xe = xi.next();
1:           } else {
1:             break;
1:           }
1:         }
1:         if (advanceThat) {
1:           if (yi.hasNext()) {
1:             ye = yi.next();
1:           } else {
1:             break;
1:           }
1:         }
1:         if (xe.index() == ye.index()) {
1:           thisResult = fc.apply(xe.get(), ye.get());
1:           if (validResult) {
1:             result = fa.apply(result, thisResult);
1:           } else {
1:             result = thisResult;
1:             validResult = true;
1:           }
1:           advanceThis = true;
1:           advanceThat = true;
1:         } else {
1:           if (xe.index() < ye.index()) { // f(x, 0) = 0
1:             advanceThis = true;
1:             advanceThat = false;
1:           } else { // f(0, y) = 0
1:             advanceThis = false;
1:             advanceThat = true;
1:           }
1:         }
1:       }
1:       return result;
1:     }
1:   }
1: 
1:   public static class AggregateIterateUnionSequential extends VectorBinaryAggregate {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return fa.isLikeRightPlus() && !fc.isDensifying()
1:           && x.isSequentialAccess() && y.isSequentialAccess();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:     }
1: 
1:     @Override
1:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
1:       Vector.Element xe = null;
1:       Vector.Element ye = null;
1:       boolean advanceThis = true;
1:       boolean advanceThat = true;
1:       boolean validResult = false;
1:       double result = 0;
1:       double thisResult;
1:       while (true) {
1:         if (advanceThis) {
1:           if (xi.hasNext()) {
1:             xe = xi.next();
1:           } else {
1:             xe = null;
1:           }
1:         }
1:         if (advanceThat) {
1:           if (yi.hasNext()) {
1:             ye = yi.next();
1:           } else {
1:             ye = null;
1:           }
1:         }
1:         if (xe != null && ye != null) { // both vectors have nonzero elements
1:           if (xe.index() == ye.index()) {
1:             thisResult = fc.apply(xe.get(), ye.get());
1:             advanceThis = true;
1:             advanceThat = true;
1:           } else {
1:             if (xe.index() < ye.index()) { // f(x, 0)
1:               thisResult = fc.apply(xe.get(), 0);
1:               advanceThis = true;
1:               advanceThat = false;
1:             } else {
1:               thisResult = fc.apply(0, ye.get());
1:               advanceThis = false;
1:               advanceThat = true;
1:             }
1:           }
1:         } else if (xe != null) { // just the first one still has nonzeros
1:           thisResult = fc.apply(xe.get(), 0);
1:           advanceThis = true;
1:           advanceThat = false;
1:         } else if (ye != null) { // just the second one has nonzeros
1:           thisResult = fc.apply(0, ye.get());
1:           advanceThis = false;
1:           advanceThat = true;
1:         } else { // we're done, both are empty
1:           break;
1:         }
1:         if (validResult) {
1:           result = fa.apply(result, thisResult);
1:         } else {
1:           result = thisResult;
1:           validResult =  true;
1:         }
1:       }
1:       return result;
1:     }
1:   }
1: 
1:   public static class AggregateIterateUnionRandom extends VectorBinaryAggregate {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return fa.isLikeRightPlus() && !fc.isDensifying()
1:           && (fa.isAssociativeAndCommutative() || (x.isSequentialAccess() && y.isSequentialAccess()));
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost(),
1:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost());
1:     }
1: 
1:     @Override
1:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       OpenIntHashSet visited = new OpenIntHashSet();
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
0:       Vector.Element xe;
1:       boolean validResult = false;
1:       double result = 0;
1:       double thisResult;
1:       while (xi.hasNext()) {
1:         xe = xi.next();
1:         thisResult = fc.apply(xe.get(), y.getQuick(xe.index()));
1:         if (validResult) {
1:           result = fa.apply(result, thisResult);
1:         } else {
1:           result = thisResult;
1:           validResult = true;
1:         }
1:         visited.add(xe.index());
1:       }
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
0:       Vector.Element ye;
1:       while (yi.hasNext()) {
1:         ye = yi.next();
1:         if (!visited.contains(ye.index())) {
1:           thisResult = fc.apply(x.getQuick(ye.index()), ye.get());
1:           if (validResult) {
1:             result = fa.apply(result, thisResult);
1:           } else {
1:             result = thisResult;
1:             validResult = true;
1:           }
1:         }
1:       }
1:       return result;
1:     }
1:   }
1: 
1:   public static class AggregateAllIterateSequential extends VectorBinaryAggregate {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return x.isSequentialAccess() && y.isSequentialAccess() && !x.isDense() && !y.isDense();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return Math.max(x.size() * x.getIteratorAdvanceCost(), y.size() * y.getIteratorAdvanceCost());
1:     }
1: 
1:     @Override
1:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
0:       Iterator<Vector.Element> xi = x.iterator();
0:       Iterator<Vector.Element> yi = y.iterator();
0:       Vector.Element xe;
1:       boolean validResult = false;
1:       double result = 0;
1:       double thisResult;
1:       while (xi.hasNext() && yi.hasNext()) {
1:         xe = xi.next();
0:         thisResult = fc.apply(xe.get(), yi.next().get());
1:         if (validResult) {
1:           result = fa.apply(result, thisResult);
1:         } else {
1:           result = thisResult;
1:           validResult = true;
1:         }
1:       }
1:       return result;
1:     }
1:   }
1: 
1:   public static class AggregateAllIterateThisLookupThat extends VectorBinaryAggregate {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return (fa.isAssociativeAndCommutative() || x.isSequentialAccess())
1:           && !x.isDense();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return x.size() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:     }
1: 
1:     @Override
1:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
0:       Iterator<Vector.Element> xi = x.iterator();
0:       Vector.Element xe;
1:       boolean validResult = false;
1:       double result = 0;
1:       double thisResult;
1:       while (xi.hasNext()) {
1:         xe = xi.next();
1:         thisResult = fc.apply(xe.get(), y.getQuick(xe.index()));
1:         if (validResult) {
1:           result = fa.apply(result, thisResult);
1:         } else {
1:           result = thisResult;
1:           validResult = true;
1:         }
1:       }
1:       return result;
1:     }
1:   }
1: 
1:   public static class AggregateAllIterateThatLookupThis extends VectorBinaryAggregate {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return (fa.isAssociativeAndCommutative() || y.isSequentialAccess())
1:           && !y.isDense();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return y.size() * y.getIteratorAdvanceCost() * x.getLookupCost();
1:     }
1: 
1:     @Override
1:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
0:       Iterator<Vector.Element> yi = y.iterator();
0:       Vector.Element ye;
1:       boolean validResult = false;
1:       double result = 0;
1:       double thisResult;
1:       while (yi.hasNext()) {
1:         ye = yi.next();
1:         thisResult = fc.apply(x.getQuick(ye.index()), ye.get());
1:         if (validResult) {
1:           result = fa.apply(result, thisResult);
1:         } else {
1:           result = thisResult;
1:           validResult = true;
1:         }
1:       }
1:       return result;
1:     }
1:   }
1: 
1:   public static class AggregateAllLoop extends VectorBinaryAggregate {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return true;
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       return x.size() * x.getLookupCost() * y.getLookupCost();
1:     }
1: 
1:     @Override
1:     public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc) {
1:       double result = fc.apply(x.getQuick(0), y.getQuick(0));
0:       for (int i = 1; i < x.size(); ++i) {
1:         result = fa.apply(result, fc.apply(x.getQuick(i), y.getQuick(i)));
1:       }
1:       return result;
1:     }
1:   }
1: }
============================================================================