2:7926fcb: /*
1:7550a10: Copyright ï¿? 1999 CERN - European Organization for Nuclear Research.
1:7550a10: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1:7550a10: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1:7550a10: that both that copyright notice and this permission notice appear in supporting documentation. 
1:7550a10: CERN makes no representations about the suitability of this software for any purpose. 
1:7550a10: It is provided "as is" without expressed or implied warranty.
3:7926fcb: */
1:a435efb: package org.apache.mahout.math.jet.random.sampling;
1:e50fbd5: 
1:22726e8: import org.apache.mahout.common.RandomUtils;
1:e50fbd5: 
1:22726e8: import java.util.Random;
14:7926fcb: 
3:7926fcb: /**
1:8a99d75:  * Space and time efficiently computes a sorted <i>Simple Random Sample Without Replacement
1:8a99d75:  * (SRSWOR)</i>, that is, a sorted set of <tt>n</tt> random numbers from an interval of <tt>N</tt> numbers;
1:8a99d75:  * Example: Computing <tt>n=3</tt> random numbers from the interval <tt>[1,50]</tt> may yield
1:8a99d75:  * the sorted random set <tt>(7,13,47)</tt>.
1:7550a10:  * Since we are talking about a set (sampling without replacement), no element will occur more than once.
1:7550a10:  * Each number from the <tt>N</tt> numbers has the same probability to be included in the <tt>n</tt> chosen numbers.
22:7550a10:  *
1:7550a10:  * <p><b>Problem:</b> This class solves problems including the following: <i>
1:7550a10:  * Suppose we have a file containing 10^12 objects.
1:7550a10:  * We would like to take a truly random subset of 10^6 objects and do something with it, 
1:7550a10:  * for example, compute the sum over some instance field, or whatever.
1:8a99d75:  * How do we choose the subset? In particular, how do we avoid multiple equal elements?
1:8a99d75:  * How do we do this quick and without consuming excessive memory?
1:8a99d75:  * How do we avoid slowly jumping back and forth within the file? </i>
1:7926fcb:  *
1:7550a10:  * <p><b>Sorted Simple Random Sample Without Replacement (SRSWOR):</b>
1:7550a10:  * What are the exact semantics of this class? What is a SRSWOR? In which sense exactly is a returned set "random"?
1:8a99d75:  * It is random in the sense, that each number from the <tt>N</tt> numbers has the
1:8a99d75:  * same probability to be included in the <tt>n</tt> chosen numbers.
1:7550a10:  * For those who think in implementations rather than abstract interfaces:
1:7550a10:  * <i>Suppose, we have an empty list.
1:8a99d75:  * We pick a random number between 1 and 10^12 and add it to the list only if it was not
1:8a99d75:  * already picked before, i.e. if it is not already contained in the list.
1:7550a10:  * We then do the same thing again and again until we have eventually collected 10^6 distinct numbers.
1:7550a10:  * Now we sort the set ascending and return it.</i>
1:b5c2879:  * <dl>
1:7550a10:  * <dt>It is exactly in this sense that this class returns "random" sets.
1:8a99d75:  * <b>Note, however, that the implementation of this class uses a technique orders of magnitudes
1:b5c2879:  * better (both in time and space) than the one outlined above.</b></dt></dl>
1:7926fcb:  *
1:8a99d75:  * <p><b>Performance:</b> Space requirements are zero. Running time is <tt>O(n)</tt> on average,
1:8a99d75:  * <tt>O(N)</tt> in the worst case.
1:b5c2879:  * <h2>Performance (200Mhz Pentium Pro, JDK 1.2, NT)</h2>
1:7550a10:  * <center>
1:b5c2879:  *   <table border="1" summary="performance table">
1:7550a10:  *     <tr> 
1:7550a10:  *       <td align="center" width="20%">n</td>
1:7550a10:  *       <td align="center" width="20%">N</td>
1:7550a10:  *       <td align="center" width="20%">Speed [seconds]</td>
1:7550a10:  *     </tr>
1:7550a10:  *     <tr> 
1:7550a10:  *       <td align="center" width="20%">10<sup>3</sup></td>
1:7550a10:  *       <td align="center" width="20%">1.2*10<sup>3</sup></td>
1:7550a10:  *       <td align="center" width="20">0.0014</td>
1:7550a10:  *     </tr>
1:7550a10:  *     <tr> 
1:7550a10:  *       <td align="center" width="20%">10<sup>3</sup></td>
1:7550a10:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:7550a10:  *       <td align="center" width="20">0.006</td>
1:7550a10:  *     </tr>
1:7550a10:  *     <tr> 
1:7550a10:  *       <td align="center" width="20%">10<sup>5</sup></td>
1:7550a10:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:7550a10:  *       <td align="center" width="20">0.7</td>
1:7550a10:  *     </tr>
1:7550a10:  *     <tr> 
1:7550a10:  *       <td align="center" width="20%">9.0*10<sup>6</sup></td>
1:7550a10:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:7550a10:  *       <td align="center" width="20">8.5</td>
1:7550a10:  *     </tr>
1:7550a10:  *     <tr> 
1:7550a10:  *       <td align="center" width="20%">9.9*10<sup>6</sup></td>
1:7550a10:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:7550a10:  *       <td align="center" width="20">2.0 (samples more than 95%)</td>
1:7550a10:  *     </tr>
1:7550a10:  *     <tr> 
1:7550a10:  *       <td align="center" width="20%">10<sup>4</sup></td>
1:7550a10:  *       <td align="center" width="20%">10<sup>12</sup></td>
1:7550a10:  *       <td align="center" width="20">0.07</td>
1:7550a10:  *     </tr>
1:7550a10:  *     <tr> 
1:7550a10:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:7550a10:  *       <td align="center" width="20%">10<sup>12</sup></td>
1:7550a10:  *       <td align="center" width="20">60</td>
1:7550a10:  *     </tr>
1:7550a10:  *   </table>
1:7550a10:  * </center>
1:7926fcb:  *
1:8a99d75:  * <p><b>Scalability:</b> This random sampler is designed to be scalable. In iterator style,
1:8a99d75:  * it is able to compute and deliver sorted random sets stepwise in units called <i>blocks</i>.
1:8a99d75:  * Example: Computing <tt>n=9</tt> random numbers from the interval <tt>[1,50]</tt> in
1:8a99d75:  * 3 blocks may yield the blocks <tt>(7,13,14), (27,37,42), (45,46,49)</tt>.
1:8a99d75:  * (The maximum of a block is guaranteed to be less than the minimum of its successor block.
1:8a99d75:  * Every block is sorted ascending. No element will ever occur twice, both within a block and among blocks.)
1:7550a10:  * A block can be computed and retrieved with method <tt>nextBlock</tt>.
2:7550a10:  * Successive calls to method <tt>nextBlock</tt> will deliver as many random numbers as required.
1:7926fcb:  *
1:8a99d75:  * <p>Computing and retrieving samples in blocks is useful if you need very many random
1:8a99d75:  * numbers that cannot be stored in main memory at the same time.
1:8a99d75:  * For example, if you want to compute 10^10 such numbers you can do this by computing
1:8a99d75:  * them in blocks of, say, 500 elements each.
1:7550a10:  * You then need only space to keep one block of 500 elements (i.e. 4 KB).
1:8a99d75:  * When you are finished processing the first 500 elements you call <tt>nextBlock</tt> to
1:8a99d75:  * fill the next 500 elements into the block, process them, and so on.
1:8a99d75:  * If you have the time and need, by using such blocks you can compute random sets
1:8a99d75:  * up to <tt>n=10^19</tt> random numbers.
1:7550a10:  *
1:7550a10:  * <p>If you do not need the block feature, you can also directly call 
1:7550a10:  * the static methods of this class without needing to construct a <tt>RandomSampler</tt> instance first.
1:7550a10:  *
1:8a99d75:  * <p><b>Random number generation:</b> By default uses <tt>MersenneTwister</tt>, a very
1:8a99d75:  * strong random number generator, much better than <tt>java.util.Random</tt>.
2:7550a10:  * You can also use other strong random number generators of Paul Houle's RngPack package.
1:8a99d75:  * For example, <tt>Ranecu</tt>, <tt>Ranmar</tt> and <tt>Ranlux</tt> are strong well
1:8a99d75:  * analyzed research grade pseudo-random number generators with known periods.
1:7550a10:  *
1:7550a10:  * <p><b>Implementation:</b> after J.S. Vitter, An Efficient Algorithm for Sequential Random Sampling,
1:7550a10:  * ACM Transactions on Mathematical Software, Vol 13, 1987.
1:7550a10:  * Paper available <A HREF="http://www.cs.duke.edu/~jsv"> here</A>.
1:7926fcb:  */
1:3d44c1e: public final class RandomSampler {
1:7926fcb: 
1:3d44c1e:   private RandomSampler() {
7:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Efficiently computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>. Since
1:7926fcb:    * we are talking about a random set, no element will occur more than once.
1:7926fcb:    *
1:7926fcb:    * <p>Running time is <tt>O(count)</tt>, on average. Space requirements are zero.
1:7926fcb:    *
2:7926fcb:    * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right. The array is
2:7926fcb:    * returned sorted ascending in the range filled with numbers.
1:7926fcb:    *
1:7926fcb:    * @param n               the total number of elements to choose (must be &gt;= 0).
2:7926fcb:    * @param N               the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
1:7926fcb:    * @param count           the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and
1:39fe224:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
2:7926fcb:    * @param low             the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If
1:39fe224:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:7926fcb:    * @param values          the array into which the random numbers are to be filled; must have a length <tt>&gt;=
1:39fe224:    *                        count+fromIndex</tt>.
1:7926fcb:    * @param fromIndex       the first index within <tt>values</tt> to be filled with numbers (inclusive).
1:7926fcb:    * @param randomGenerator a random number generator.
1:7926fcb:    */
1:3d44c1e:   private static void rejectMethodD(long n, long N, int count, long low, long[] values, int fromIndex,
1:3d44c1e:                                     Random randomGenerator) {
1:7926fcb:     /*  This algorithm is applicable if a large percentage (90%..100%) of N shall be sampled.
1:7926fcb:       In such cases it is more efficient than sampleMethodA() and sampleMethodD().
1:7926fcb:         The idea is that it is more efficient to express
1:7926fcb:       sample(n,N,count) in terms of reject(N-n,N,count)
1:7926fcb:        and then invert the result.
1:7926fcb:       For example, sampling 99% turns into sampling 1% plus inversion.
1:7926fcb: 
1:8a99d75:       This algorithm is the same as method sampleMethodD(...) with the exception that sampled elements are rejected,
1:8a99d75:       and not sampled elements included in the result set.
1:7926fcb:     */
1:7926fcb:     n = N - n; // IMPORTANT !!!
1:7926fcb: 
1:7926fcb:     //long threshold;
1:7926fcb:     long chosen = -1 + low;
1:7926fcb: 
1:e50fbd5:     //long negalphainv =
1:8a99d75:     //    -13;  //tuning paramter, determines when to switch from method D to method A. Dependent on programming
1:8a99d75:     // language, platform, etc.
1:7926fcb: 
1:7926fcb:     double nreal = n;
1:7926fcb:     double ninv = 1.0 / nreal;
1:7926fcb:     double Nreal = N;
1:22726e8:     double Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
1:7926fcb:     long qu1 = -n + 1 + N;
1:7926fcb:     double qu1real = -nreal + 1.0 + Nreal;
1:7926fcb:     //threshold = -negalphainv * n;
1:7926fcb: 
1:7926fcb:     long S;
1:7926fcb:     while (n > 1 && count > 0) { //&& threshold<N) {
1:7926fcb:       double nmin1inv = 1.0 / (-1.0 + nreal);
1:7926fcb:       double negSreal;
1:7926fcb:       while (true) {
1:7926fcb:         double X;
1:7926fcb:         while (true) { // step D2: generate U and X
2:7926fcb:           X = Nreal * (-Vprime + 1.0);
1:7926fcb:           S = (long) X;
1:7926fcb:           if (S < qu1) {
1:7926fcb:             break;
1:7926fcb:           }
1:22726e8:           Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
1:7926fcb:         }
1:22726e8:         double U = randomGenerator.nextDouble();
1:7926fcb:         negSreal = -S;
1:7926fcb: 
1:7926fcb:         //step D3: Accept?
1:7926fcb:         double y1 = Math.exp(Math.log(U * Nreal / qu1real) * nmin1inv);
1:39fe224:         Vprime = y1 * (-X / Nreal + 1.0) * qu1real / (negSreal + qu1real);
2:7926fcb:         if (Vprime <= 1.0) {
1:7926fcb:           break;
1:7926fcb:         } //break inner loop
1:7926fcb: 
1:7926fcb:         //step D4: Accept?
1:7926fcb:         double top = -1.0 + Nreal;
1:7926fcb:         long limit;
1:7926fcb:         double bottom;
1:7926fcb:         if (n - 1 > S) {
1:7926fcb:           bottom = -nreal + Nreal;
1:7926fcb:           limit = -S + N;
1:7926fcb:         } else {
1:7926fcb:           bottom = -1.0 + negSreal + Nreal;
1:7926fcb:           limit = qu1;
1:7926fcb:         }
1:7926fcb:         double y2 = 1.0;
1:7926fcb:         for (long t = N - 1; t >= limit; t--) {
1:39fe224:           y2 *= top / bottom;
1:7926fcb:           top--;
1:7926fcb:           bottom--;
1:7926fcb:         }
1:7926fcb:         if (Nreal / (-X + Nreal) >= y1 * Math.exp(Math.log(y2) * nmin1inv)) {
1:7926fcb:           // accept !
1:22726e8:           Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * nmin1inv);
1:7926fcb:           break; //break inner loop
1:7926fcb:         }
1:22726e8:         Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
1:7926fcb:       }
1:7926fcb: 
1:7926fcb:       //step D5: reject the (S+1)st record !
1:7926fcb:       int iter = count; //int iter = (int) (Math.min(S,count));
1:7926fcb:       if (S < iter) {
1:7926fcb:         iter = (int) S;
1:7926fcb:       }
1:7926fcb: 
1:7926fcb:       count -= iter;
1:7926fcb:       while (--iter >= 0) {
1:7926fcb:         values[fromIndex++] = ++chosen;
1:7926fcb:       }
1:7926fcb:       chosen++;
1:7926fcb: 
1:7926fcb:       N -= S + 1;
1:39fe224:       Nreal = negSreal - 1.0 + Nreal;
1:7926fcb:       n--;
1:7926fcb:       nreal--;
1:7926fcb:       ninv = nmin1inv;
1:7926fcb:       qu1 = -S + qu1;
1:7926fcb:       qu1real = negSreal + qu1real;
1:7926fcb:       //threshold += negalphainv;
1:7926fcb:     } //end while
1:7926fcb: 
1:7926fcb: 
1:7926fcb:     if (count > 0) { //special case n==1
1:7926fcb:       //reject the (S+1)st record !
2:7926fcb:       S = (long) (N * Vprime);
1:7926fcb: 
1:7926fcb:       int iter = count; //int iter = (int) (Math.min(S,count));
1:7926fcb:       if (S < iter) {
1:7926fcb:         iter = (int) S;
1:7926fcb:       }
1:7926fcb: 
1:7926fcb:       count -= iter;
1:7926fcb:       while (--iter >= 0) {
1:7926fcb:         values[fromIndex++] = ++chosen;
1:7926fcb:       }
1:7926fcb: 
1:7926fcb:       chosen++;
1:7926fcb: 
1:7926fcb:       // fill the rest
1:7926fcb:       while (--count >= 0) {
1:7926fcb:         values[fromIndex++] = ++chosen;
1:7926fcb:       }
1:7926fcb:     }
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Efficiently computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>. Since
1:7926fcb:    * we are talking about a random set, no element will occur more than once.
1:7926fcb:    *
1:7926fcb:    * <p>Running time is <tt>O(count)</tt>, on average. Space requirements are zero.
1:7926fcb:    *
1:7926fcb:    * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right. The array is
1:7926fcb:    * returned sorted ascending in the range filled with numbers.
1:7926fcb:    *
1:7926fcb:    * <p><b>Random number generation:</b> By default uses <tt>MersenneTwister</tt>, a very strong random number
1:7926fcb:    * generator, much better than <tt>java.util.Random</tt>. You can also use other strong random number generators of
1:7926fcb:    * Paul Houle's RngPack package. For example, <tt>Ranecu</tt>, <tt>Ranmar</tt> and <tt>Ranlux</tt> are strong well
1:7926fcb:    * analyzed research grade pseudo-random number generators with known periods.
1:7926fcb:    *
2:7926fcb:    * @param n               the total number of elements to choose (must be <tt>n &gt;= 0</tt> and <tt>n &lt;= N</tt>).
1:7926fcb:    * @param N               the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
1:7926fcb:    * @param count           the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and
1:39fe224:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:7926fcb:    * @param low             the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If
1:39fe224:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:7926fcb:    * @param values          the array into which the random numbers are to be filled; must have a length <tt>&gt;=
1:39fe224:    *                        count+fromIndex</tt>.
1:7926fcb:    * @param fromIndex       the first index within <tt>values</tt> to be filled with numbers (inclusive).
2:7926fcb:    * @param randomGenerator a random number generator. Set this parameter to <tt>null</tt> to use the default random
2:7926fcb:    *                        number generator.
1:7926fcb:    */
1:7926fcb:   public static void sample(long n, long N, int count, long low, long[] values, int fromIndex,
1:22726e8:                             Random randomGenerator) {
1:7926fcb:     if (n <= 0 || count <= 0) {
2:7926fcb:       return;
1:7926fcb:     }
1:7627de6:     if (count > n) {
1:7926fcb:       throw new IllegalArgumentException("count must not be greater than n");
1:7926fcb:     }
2:7926fcb:     if (randomGenerator == null) {
1:22726e8:       randomGenerator = RandomUtils.getRandom();
1:7627de6:     }
1:7627de6: 
1:7926fcb:     if (count == N) { // rare case treated quickly
1:7926fcb:       long val = low;
1:7926fcb:       int limit = fromIndex + count;
1:3d44c1e:       for (int i = fromIndex; i < limit; i++) {
1:3d44c1e:         values[i] = val++;
1:7926fcb:       }
1:7926fcb:       return;
1:7926fcb:     }
1:7926fcb: 
1:7926fcb:     if (n < N * 0.95) { // || Math.min(count,N-n)>maxTmpMemoryAllowed) {
1:7926fcb:       sampleMethodD(n, N, count, low, values, fromIndex, randomGenerator);
1:7926fcb:     } else { // More than 95% of all numbers shall be sampled.
1:7926fcb:       rejectMethodD(n, N, count, low, values, fromIndex, randomGenerator);
1:7926fcb:     }
1:7926fcb: 
1:7926fcb: 
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>. Since we are
1:7926fcb:    * talking about a random set, no element will occur more than once.
1:7926fcb:    *
1:7926fcb:    * <p>Running time is <tt>O(N)</tt>, on average. Space requirements are zero.
1:7926fcb:    *
1:7926fcb:    * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right. The array is
1:7926fcb:    * returned sorted ascending in the range filled with numbers.
1:7926fcb:    *
1:7926fcb:    * @param n               the total number of elements to choose (must be &gt;= 0).
1:7926fcb:    * @param N               the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
1:7926fcb:    * @param count           the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and
1:39fe224:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:7926fcb:    * @param low             the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If
1:39fe224:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:7926fcb:    * @param values          the array into which the random numbers are to be filled; must have a length <tt>&gt;=
1:39fe224:    *                        count+fromIndex</tt>.
1:7926fcb:    * @param fromIndex       the first index within <tt>values</tt> to be filled with numbers (inclusive).
1:7926fcb:    * @param randomGenerator a random number generator.
1:7926fcb:    */
1:3d44c1e:   private static void sampleMethodA(long n, long N, int count, long low, long[] values, int fromIndex,
1:3d44c1e:                                     Random randomGenerator) {
1:7926fcb:     long chosen = -1 + low;
1:7926fcb: 
1:7926fcb:     double top = N - n;
1:7926fcb:     double Nreal = N;
1:7926fcb:     long S;
1:7926fcb:     while (n >= 2 && count > 0) {
1:22726e8:       double V = randomGenerator.nextDouble();
1:7926fcb:       S = 0;
1:7926fcb:       double quot = top / Nreal;
1:7926fcb:       while (quot > V) {
1:7926fcb:         S++;
1:7926fcb:         top--;
1:7926fcb:         Nreal--;
1:39fe224:         quot *= top / Nreal;
1:7926fcb:       }
1:7926fcb:       chosen += S + 1;
2:7a9ecf4:       values[fromIndex++] = chosen;
1:7926fcb:       count--;
1:7926fcb:       Nreal--;
1:7926fcb:       n--;
1:7926fcb:     }
1:7926fcb: 
1:7926fcb:     if (count > 0) {
1:7926fcb:       // special case n==1
1:22726e8:       S = (long) (Math.round(Nreal) * randomGenerator.nextDouble());
1:7926fcb:       chosen += S + 1;
1:7926fcb:       values[fromIndex] = chosen;
1:7926fcb:     }
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Efficiently computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>. Since
1:7926fcb:    * we are talking about a random set, no element will occur more than once.
1:7926fcb:    *
1:7926fcb:    * <p>Running time is <tt>O(count)</tt>, on average. Space requirements are zero.
1:7926fcb:    *
1:7926fcb:    * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right. The array is
1:7926fcb:    * returned sorted ascending in the range filled with numbers.
1:7926fcb:    *
1:7926fcb:    * @param n               the total number of elements to choose (must be &gt;= 0).
1:7926fcb:    * @param N               the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
1:7926fcb:    * @param count           the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and
4:7926fcb:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:7926fcb:    * @param low             the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If
4:7926fcb:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:7926fcb:    * @param values          the array into which the random numbers are to be filled; must have a length <tt>&gt;=
4:7926fcb:    *                        count+fromIndex</tt>.
1:7926fcb:    * @param fromIndex       the first index within <tt>values</tt> to be filled with numbers (inclusive).
1:7926fcb:    * @param randomGenerator a random number generator.
1:7926fcb:    */
1:3d44c1e:   private static void sampleMethodD(long n, long N, int count, long low, long[] values, int fromIndex,
1:3d44c1e:                                     Random randomGenerator) {
1:7926fcb:     long chosen = -1 + low;
1:7926fcb: 
1:7926fcb:     double nreal = n;
1:7926fcb:     double ninv = 1.0 / nreal;
1:7926fcb:     double Nreal = N;
1:8a99d75:     double vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
1:7926fcb:     long qu1 = -n + 1 + N;
1:7926fcb:     double qu1real = -nreal + 1.0 + Nreal;
1:8a99d75:     long negalphainv = -13;
1:8a99d75:     //tuning paramter, determines when to switch from method D to method A. Dependent on programming
1:8a99d75:     // language, platform, etc.
1:7926fcb:     long threshold = -negalphainv * n;
1:7926fcb: 
1:7926fcb:     long S;
1:7926fcb:     while (n > 1 && count > 0 && threshold < N) {
1:7926fcb:       double nmin1inv = 1.0 / (-1.0 + nreal);
1:7926fcb:       double negSreal;
1:7926fcb:       while (true) {
1:7926fcb:         double X;
1:7926fcb:         while (true) { // step D2: generate U and X
1:8a99d75:           X = Nreal * (-vprime + 1.0);
1:7926fcb:           S = (long) X;
1:7926fcb:           if (S < qu1) {
1:7926fcb:             break;
1:7926fcb:           }
1:8a99d75:           vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
1:7926fcb:         }
1:22726e8:         double U = randomGenerator.nextDouble();
1:7926fcb:         negSreal = -S;
1:7926fcb: 
1:7926fcb:         //step D3: Accept?
1:7926fcb:         double y1 = Math.exp(Math.log(U * Nreal / qu1real) * nmin1inv);
1:39fe224:         vprime = y1 * (-X / Nreal + 1.0) * qu1real / (negSreal + qu1real);
1:8a99d75:         if (vprime <= 1.0) {
1:7926fcb:           break;
1:7926fcb:         } //break inner loop
1:7926fcb: 
1:7926fcb:         //step D4: Accept?
1:7926fcb:         double top = -1.0 + Nreal;
1:7926fcb:         long limit;
1:7926fcb:         double bottom;
1:7926fcb:         if (n - 1 > S) {
1:7926fcb:           bottom = -nreal + Nreal;
1:7926fcb:           limit = -S + N;
1:7926fcb:         } else {
1:7926fcb:           bottom = -1.0 + negSreal + Nreal;
1:7926fcb:           limit = qu1;
1:7926fcb:         }
1:7926fcb:         double y2 = 1.0;
1:7926fcb:         for (long t = N - 1; t >= limit; t--) {
1:39fe224:           y2 *= top / bottom;
1:7926fcb:           top--;
1:7926fcb:           bottom--;
1:7926fcb:         }
1:7926fcb:         if (Nreal / (-X + Nreal) >= y1 * Math.exp(Math.log(y2) * nmin1inv)) {
1:7926fcb:           // accept !
1:8a99d75:           vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * nmin1inv);
1:7926fcb:           break; //break inner loop
1:7926fcb:         }
1:8a99d75:         vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
1:7926fcb:       }
1:7926fcb: 
1:7926fcb:       //step D5: select the (S+1)st record !
1:7926fcb:       chosen += S + 1;
1:7926fcb:       values[fromIndex++] = chosen;
1:7926fcb:       /*
1:7926fcb:       // invert
1:7926fcb:       for (int iter=0; iter<S && count > 0; iter++) {
1:7926fcb:         values[fromIndex++] = ++chosen;
1:7926fcb:         count--;
1:7926fcb:       }
1:7926fcb:       chosen++;
1:7926fcb:       */
1:7926fcb:       count--;
1:7926fcb: 
1:7926fcb:       N -= S + 1;
1:39fe224:       Nreal = negSreal - 1.0 + Nreal;
1:7926fcb:       n--;
1:7926fcb:       nreal--;
1:7926fcb:       ninv = nmin1inv;
1:7926fcb:       qu1 = -S + qu1;
1:7926fcb:       qu1real = negSreal + qu1real;
1:7926fcb:       threshold += negalphainv;
1:7926fcb:     } //end while
1:7926fcb: 
1:7926fcb: 
1:7926fcb:     if (count > 0) {
1:7926fcb:       if (n > 1) { //faster to use method A to finish the sampling
1:7926fcb:         sampleMethodA(n, N, count, chosen + 1, values, fromIndex, randomGenerator);
1:7926fcb:       } else {
1:7926fcb:         //special case n==1
1:8a99d75:         S = (long) (N * vprime);
1:7926fcb:         chosen += S + 1;
1:7926fcb:         values[fromIndex++] = chosen;
1:7926fcb:       }
1:7926fcb:     }
1:7926fcb:   }
1:7926fcb: 
1:7926fcb: }
============================================================================
author:Karl Richter
-------------------------------------------------------------------------------
commit:b5c2879
/////////////////////////////////////////////////////////////////////////
1:  * <dl>
1:  * better (both in time and space) than the one outlined above.</b></dt></dl>
1:  * <h2>Performance (200Mhz Pentium Pro, JDK 1.2, NT)</h2>
1:  *   <table border="1" summary="performance table">
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:3d44c1e
/////////////////////////////////////////////////////////////////////////
1: public final class RandomSampler {
1:   private RandomSampler() {
/////////////////////////////////////////////////////////////////////////
1:   private static void rejectMethodD(long n, long N, int count, long low, long[] values, int fromIndex,
1:                                     Random randomGenerator) {
/////////////////////////////////////////////////////////////////////////
1:       for (int i = fromIndex; i < limit; i++) {
1:         values[i] = val++;
/////////////////////////////////////////////////////////////////////////
1:   private static void sampleMethodA(long n, long N, int count, long low, long[] values, int fromIndex,
1:                                     Random randomGenerator) {
/////////////////////////////////////////////////////////////////////////
1:   private static void sampleMethodD(long n, long N, int count, long low, long[] values, int fromIndex,
1:                                     Random randomGenerator) {
commit:39fe224
/////////////////////////////////////////////////////////////////////////
1:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:    *                        count+fromIndex</tt>.
/////////////////////////////////////////////////////////////////////////
1:         Vprime = y1 * (-X / Nreal + 1.0) * qu1real / (negSreal + qu1real);
/////////////////////////////////////////////////////////////////////////
1:           y2 *= top / bottom;
/////////////////////////////////////////////////////////////////////////
1:       Nreal = negSreal - 1.0 + Nreal;
/////////////////////////////////////////////////////////////////////////
1:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:    *                        count+fromIndex</tt>.
/////////////////////////////////////////////////////////////////////////
1:         quot *= top / Nreal;
/////////////////////////////////////////////////////////////////////////
1:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:    *                        count+fromIndex</tt>.
/////////////////////////////////////////////////////////////////////////
1:         vprime = y1 * (-X / Nreal + 1.0) * qu1real / (negSreal + qu1real);
/////////////////////////////////////////////////////////////////////////
1:           y2 *= top / bottom;
/////////////////////////////////////////////////////////////////////////
1:       Nreal = negSreal - 1.0 + Nreal;
commit:85ec3a3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class RandomSampler {
commit:6430188
/////////////////////////////////////////////////////////////////////////
0:   private final Random randomGenerator;
commit:8a99d75
/////////////////////////////////////////////////////////////////////////
1:  * Space and time efficiently computes a sorted <i>Simple Random Sample Without Replacement
1:  * (SRSWOR)</i>, that is, a sorted set of <tt>n</tt> random numbers from an interval of <tt>N</tt> numbers;
1:  * Example: Computing <tt>n=3</tt> random numbers from the interval <tt>[1,50]</tt> may yield
1:  * the sorted random set <tt>(7,13,47)</tt>.
/////////////////////////////////////////////////////////////////////////
1:  * How do we choose the subset? In particular, how do we avoid multiple equal elements?
1:  * How do we do this quick and without consuming excessive memory?
1:  * How do we avoid slowly jumping back and forth within the file? </i>
1:  * It is random in the sense, that each number from the <tt>N</tt> numbers has the
1:  * same probability to be included in the <tt>n</tt> chosen numbers.
1:  * We pick a random number between 1 and 10^12 and add it to the list only if it was not
1:  * already picked before, i.e. if it is not already contained in the list.
1:  * <b>Note, however, that the implementation of this class uses a technique orders of magnitudes
0:  * better (both in time and space) than the one outlined above.</b>
1:  * <p><b>Performance:</b> Space requirements are zero. Running time is <tt>O(n)</tt> on average,
1:  * <tt>O(N)</tt> in the worst case.
/////////////////////////////////////////////////////////////////////////
1:  * <p><b>Scalability:</b> This random sampler is designed to be scalable. In iterator style,
1:  * it is able to compute and deliver sorted random sets stepwise in units called <i>blocks</i>.
1:  * Example: Computing <tt>n=9</tt> random numbers from the interval <tt>[1,50]</tt> in
1:  * 3 blocks may yield the blocks <tt>(7,13,14), (27,37,42), (45,46,49)</tt>.
1:  * (The maximum of a block is guaranteed to be less than the minimum of its successor block.
1:  * Every block is sorted ascending. No element will ever occur twice, both within a block and among blocks.)
1:  * <p>Computing and retrieving samples in blocks is useful if you need very many random
1:  * numbers that cannot be stored in main memory at the same time.
1:  * For example, if you want to compute 10^10 such numbers you can do this by computing
1:  * them in blocks of, say, 500 elements each.
1:  * When you are finished processing the first 500 elements you call <tt>nextBlock</tt> to
1:  * fill the next 500 elements into the block, process them, and so on.
1:  * If you have the time and need, by using such blocks you can compute random sets
1:  * up to <tt>n=10^19</tt> random numbers.
1:  * <p><b>Random number generation:</b> By default uses <tt>MersenneTwister</tt>, a very
1:  * strong random number generator, much better than <tt>java.util.Random</tt>.
1:  * For example, <tt>Ranecu</tt>, <tt>Ranmar</tt> and <tt>Ranlux</tt> are strong well
1:  * analyzed research grade pseudo-random number generators with known periods.
/////////////////////////////////////////////////////////////////////////
1:       This algorithm is the same as method sampleMethodD(...) with the exception that sampled elements are rejected,
1:       and not sampled elements included in the result set.
/////////////////////////////////////////////////////////////////////////
1:     //    -13;  //tuning paramter, determines when to switch from method D to method A. Dependent on programming
1:     // language, platform, etc.
/////////////////////////////////////////////////////////////////////////
1:     double vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
1:     long negalphainv = -13;
1:     //tuning paramter, determines when to switch from method D to method A. Dependent on programming
1:     // language, platform, etc.
/////////////////////////////////////////////////////////////////////////
1:           X = Nreal * (-vprime + 1.0);
1:           vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
0:         vprime = y1 * (-X / Nreal + 1.0) * (qu1real / (negSreal + qu1real));
1:         if (vprime <= 1.0) {
/////////////////////////////////////////////////////////////////////////
1:           vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * nmin1inv);
1:         vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
/////////////////////////////////////////////////////////////////////////
1:         S = (long) (N * vprime);
commit:306b4d0
commit:ea65197
/////////////////////////////////////////////////////////////////////////
commit:86b2516
/////////////////////////////////////////////////////////////////////////
commit:7627de6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.matrix.PersistentObject;
0: import org.apache.mahout.matrix.Timer;
/////////////////////////////////////////////////////////////////////////
0: public class RandomSampler extends PersistentObject {
0:   private long n;
0:   private long N;
0:   private long low;
0:   private RandomEngine randomGenerator;
/////////////////////////////////////////////////////////////////////////
0:     this.n = n;
0:     this.N = N;
0:     this.low = low;
0:     this.randomGenerator = randomGenerator;
1:   }
1: 
0:   RandomEngine getRandomGenerator() {
0:     return randomGenerator;
0:     copy.randomGenerator = (RandomEngine) this.randomGenerator.clone();
/////////////////////////////////////////////////////////////////////////
1:     if (count > n) {
/////////////////////////////////////////////////////////////////////////
0:     sample(n, N, count, low, values, fromIndex, randomGenerator);
0:     n -= count;
0:     N = N - lastSample - 1 + low;
0:     low = lastSample + 1;
/////////////////////////////////////////////////////////////////////////
commit:e50fbd5
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1: 
0:   private static final Logger log = LoggerFactory.getLogger(RandomSampler.class);
1: 
/////////////////////////////////////////////////////////////////////////
1:     //long negalphainv =
0:     //    -13;  //tuning paramter, determines when to switch from method D to method A. Dependent on programming language, platform, etc.
/////////////////////////////////////////////////////////////////////////
0:     log.info("single run took " + timer.elapsedTime() / times);
0:     log.info("Good bye.\n");
/////////////////////////////////////////////////////////////////////////
0:       log.info("\n\nnegalphainv="+negalphainv);
0:       log.info(" n="+N/80+" --> ");
0:       log.info(" n="+N/40+" --> ");
0:       log.info(" n="+N/20+" --> ");
0:       log.info(" n="+N/10+" --> ");
0:       log.info(" n="+N/5+" --> ");
0:       log.info(" n="+N/2+" --> ");
0:       log.info(" n="+(N-3)+" --> ");
commit:7926fcb
/////////////////////////////////////////////////////////////////////////
1:  *
1: 
0: /** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
0:   //public class RandomSampler extends Object implements java.io.Serializable {
1: 
1:   /**
0:    * Constructs a random sampler that computes and delivers sorted random sets in blocks. A set block can be retrieved
0:    * with method <tt>nextBlock</tt>. Successive calls to method <tt>nextBlock</tt> will deliver as many random numbers
0:    * as required.
1:    *
1:    * @param n               the total number of elements to choose (must be <tt>n &gt;= 0</tt> and <tt>n &lt;= N</tt>).
1:    * @param N               the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
1:    * @param low             the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If
0:    *                        <tt>low==0</tt>, then random numbers will be drawn from the interval <tt>[0,N-1]</tt>.
1:    * @param randomGenerator a random number generator. Set this parameter to <tt>null</tt> to use the default random
1:    *                        number generator.
1:    */
0:   public RandomSampler(long n, long N, long low, RandomEngine randomGenerator) {
0:     if (n < 0) {
0:       throw new IllegalArgumentException("n must be >= 0");
0:     if (n > N) {
0:       throw new IllegalArgumentException("n must by <= N");
0:     this.my_n = n;
0:     this.my_N = N;
0:     this.my_low = low;
1: 
1:     if (randomGenerator == null) {
0:       randomGenerator = org.apache.mahout.jet.random.AbstractDistribution.makeDefaultGenerator();
1:     }
0:     this.my_RandomGenerator = randomGenerator;
1:   }
1: 
0:   /** Returns a deep copy of the receiver. */
0:   @Override
0:   public Object clone() {
0:     RandomSampler copy = (RandomSampler) super.clone();
0:     copy.my_RandomGenerator = (RandomEngine) this.my_RandomGenerator.clone();
0:     return copy;
1:   }
1: 
0:   /** Tests this class. */
0:   public static void main(String[] args) {
0:     long n = Long.parseLong(args[0]);
0:     long N = Long.parseLong(args[1]);
0:     long low = Long.parseLong(args[2]);
0:     int chunkSize = Integer.parseInt(args[3]);
0:     int times = Integer.parseInt(args[4]);
1: 
0:     test(n, N, low, chunkSize, times);
0:     //testNegAlphaInv(args);
1:   }
1: 
1:   /**
0:    * Computes the next <tt>count</tt> random numbers of the sorted random set specified on instance construction and
0:    * fills them into <tt>values</tt>, starting at index <tt>fromIndex</tt>.
1:    *
1:    * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right. The array is
1:    * returned sorted ascending in the range filled with numbers.
1:    *
0:    * @param count     the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0).
0:    * @param values    the array into which the random numbers are to be filled; must have a length <tt>&gt;=
0:    *                  count+fromIndex</tt>.
0:    * @param fromIndex the first index within <tt>values</tt> to be filled with numbers (inclusive).
1:    */
0:   public void nextBlock(int count, long[] values, int fromIndex) {
0:     if (count > my_n) {
0:       throw new IllegalArgumentException("Random sample exhausted.");
1:     }
0:     if (count < 0) {
0:       throw new IllegalArgumentException("Negative count.");
1:     }
1: 
0:     if (count == 0) {
1:       return;
0:     } //nothing to do
1: 
0:     sample(my_n, my_N, count, my_low, values, fromIndex, my_RandomGenerator);
1: 
0:     long lastSample = values[fromIndex + count - 1];
0:     my_n -= count;
0:     my_N = my_N - lastSample - 1 + my_low;
0:     my_low = lastSample + 1;
1:   }
1: 
1:   /**
1:    * Efficiently computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>. Since
1:    * we are talking about a random set, no element will occur more than once.
1:    *
1:    * <p>Running time is <tt>O(count)</tt>, on average. Space requirements are zero.
1:    *
1:    * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right. The array is
1:    * returned sorted ascending in the range filled with numbers.
1:    *
1:    * @param n               the total number of elements to choose (must be &gt;= 0).
1:    * @param N               the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
1:    * @param count           the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and
1:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:    * @param low             the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If
1:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:    * @param values          the array into which the random numbers are to be filled; must have a length <tt>&gt;=
1:    *                        count+fromIndex</tt>.
1:    * @param fromIndex       the first index within <tt>values</tt> to be filled with numbers (inclusive).
1:    * @param randomGenerator a random number generator.
1:    */
0:   protected static void rejectMethodD(long n, long N, int count, long low, long[] values, int fromIndex,
0:                                       RandomEngine randomGenerator) {
1:     /*  This algorithm is applicable if a large percentage (90%..100%) of N shall be sampled.
1:       In such cases it is more efficient than sampleMethodA() and sampleMethodD().
1:         The idea is that it is more efficient to express
1:       sample(n,N,count) in terms of reject(N-n,N,count)
1:        and then invert the result.
1:       For example, sampling 99% turns into sampling 1% plus inversion.
1: 
0:       This algorithm is the same as method sampleMethodD(...) with the exception that sampled elements are rejected, and not sampled elements included in the result set.
1:     n = N - n; // IMPORTANT !!!
1:     //long threshold;
1:     long chosen = -1 + low;
1: 
0:     long negalphainv =
0:         -13;  //tuning paramter, determines when to switch from method D to method A. Dependent on programming language, platform, etc.
1: 
1:     double nreal = n;
1:     double ninv = 1.0 / nreal;
1:     double Nreal = N;
0:     double Vprime = Math.exp(Math.log(randomGenerator.raw()) * ninv);
1:     long qu1 = -n + 1 + N;
1:     double qu1real = -nreal + 1.0 + Nreal;
1:     //threshold = -negalphainv * n;
1: 
1:     long S;
1:     while (n > 1 && count > 0) { //&& threshold<N) {
1:       double nmin1inv = 1.0 / (-1.0 + nreal);
1:       double negSreal;
1:       while (true) {
1:         double X;
1:         while (true) { // step D2: generate U and X
1:           X = Nreal * (-Vprime + 1.0);
1:           S = (long) X;
1:           if (S < qu1) {
1:             break;
1:           }
0:           Vprime = Math.exp(Math.log(randomGenerator.raw()) * ninv);
1:         }
0:         double U = randomGenerator.raw();
1:         negSreal = -S;
1: 
1:         //step D3: Accept?
1:         double y1 = Math.exp(Math.log(U * Nreal / qu1real) * nmin1inv);
0:         Vprime = y1 * (-X / Nreal + 1.0) * (qu1real / (negSreal + qu1real));
1:         if (Vprime <= 1.0) {
1:           break;
1:         } //break inner loop
1: 
1:         //step D4: Accept?
1:         double top = -1.0 + Nreal;
1:         long limit;
1:         double bottom;
1:         if (n - 1 > S) {
1:           bottom = -nreal + Nreal;
1:           limit = -S + N;
1:         } else {
1:           bottom = -1.0 + negSreal + Nreal;
1:           limit = qu1;
1:         }
1:         double y2 = 1.0;
1:         for (long t = N - 1; t >= limit; t--) {
0:           y2 = (y2 * top) / bottom;
1:           top--;
1:           bottom--;
1:         }
1:         if (Nreal / (-X + Nreal) >= y1 * Math.exp(Math.log(y2) * nmin1inv)) {
1:           // accept !
0:           Vprime = Math.exp(Math.log(randomGenerator.raw()) * nmin1inv);
1:           break; //break inner loop
1:         }
0:         Vprime = Math.exp(Math.log(randomGenerator.raw()) * ninv);
1:       }
1: 
1:       //step D5: reject the (S+1)st record !
1:       int iter = count; //int iter = (int) (Math.min(S,count));
1:       if (S < iter) {
1:         iter = (int) S;
1:       }
1: 
1:       count -= iter;
1:       while (--iter >= 0) {
1:         values[fromIndex++] = ++chosen;
1:       }
1:       chosen++;
1: 
1:       N -= S + 1;
0:       Nreal = negSreal + (-1.0 + Nreal);
1:       n--;
1:       nreal--;
1:       ninv = nmin1inv;
1:       qu1 = -S + qu1;
1:       qu1real = negSreal + qu1real;
1:       //threshold += negalphainv;
1:     } //end while
1:     if (count > 0) { //special case n==1
1:       //reject the (S+1)st record !
1:       S = (long) (N * Vprime);
1: 
1:       int iter = count; //int iter = (int) (Math.min(S,count));
1:       if (S < iter) {
1:         iter = (int) S;
1:       }
1: 
1:       count -= iter;
1:       while (--iter >= 0) {
1:         values[fromIndex++] = ++chosen;
1:       }
1: 
1:       chosen++;
1: 
1:       // fill the rest
1:       while (--count >= 0) {
1:         values[fromIndex++] = ++chosen;
1:       }
1:   }
1: 
1:   /**
1:    * Efficiently computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>. Since
1:    * we are talking about a random set, no element will occur more than once.
1:    *
1:    * <p>Running time is <tt>O(count)</tt>, on average. Space requirements are zero.
1:    *
1:    * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right. The array is
1:    * returned sorted ascending in the range filled with numbers.
1:    *
1:    * <p><b>Random number generation:</b> By default uses <tt>MersenneTwister</tt>, a very strong random number
1:    * generator, much better than <tt>java.util.Random</tt>. You can also use other strong random number generators of
1:    * Paul Houle's RngPack package. For example, <tt>Ranecu</tt>, <tt>Ranmar</tt> and <tt>Ranlux</tt> are strong well
1:    * analyzed research grade pseudo-random number generators with known periods.
1:    *
1:    * @param n               the total number of elements to choose (must be <tt>n &gt;= 0</tt> and <tt>n &lt;= N</tt>).
1:    * @param N               the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
1:    * @param count           the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and
1:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:    * @param low             the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If
1:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:    * @param values          the array into which the random numbers are to be filled; must have a length <tt>&gt;=
1:    *                        count+fromIndex</tt>.
1:    * @param fromIndex       the first index within <tt>values</tt> to be filled with numbers (inclusive).
1:    * @param randomGenerator a random number generator. Set this parameter to <tt>null</tt> to use the default random
1:    *                        number generator.
1:    */
1:   public static void sample(long n, long N, int count, long low, long[] values, int fromIndex,
0:                             RandomEngine randomGenerator) {
1:     if (n <= 0 || count <= 0) {
1:       return;
1:     }
0:     if (count > n) {
1:       throw new IllegalArgumentException("count must not be greater than n");
1:     }
1:     if (randomGenerator == null) {
0:       randomGenerator = org.apache.mahout.jet.random.AbstractDistribution.makeDefaultGenerator();
1:     }
1: 
1:     if (count == N) { // rare case treated quickly
1:       long val = low;
1:       int limit = fromIndex + count;
0:       for (int i = fromIndex; i < limit;) {
0:         values[i++] = val++;
1:       }
1:       return;
1:     }
1: 
1:     if (n < N * 0.95) { // || Math.min(count,N-n)>maxTmpMemoryAllowed) {
1:       sampleMethodD(n, N, count, low, values, fromIndex, randomGenerator);
1:     } else { // More than 95% of all numbers shall be sampled.
1:       rejectMethodD(n, N, count, low, values, fromIndex, randomGenerator);
1:     }
1: 
1: 
1:   }
1: 
1:   /**
1:    * Computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>. Since we are
1:    * talking about a random set, no element will occur more than once.
1:    *
1:    * <p>Running time is <tt>O(N)</tt>, on average. Space requirements are zero.
1:    *
1:    * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right. The array is
1:    * returned sorted ascending in the range filled with numbers.
1:    *
1:    * @param n               the total number of elements to choose (must be &gt;= 0).
1:    * @param N               the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
1:    * @param count           the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and
1:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:    * @param low             the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If
1:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:    * @param values          the array into which the random numbers are to be filled; must have a length <tt>&gt;=
1:    *                        count+fromIndex</tt>.
1:    * @param fromIndex       the first index within <tt>values</tt> to be filled with numbers (inclusive).
1:    * @param randomGenerator a random number generator.
1:    */
0:   protected static void sampleMethodA(long n, long N, int count, long low, long[] values, int fromIndex,
0:                                       RandomEngine randomGenerator) {
1:     long chosen = -1 + low;
1: 
1:     double top = N - n;
1:     double Nreal = N;
1:     long S;
1:     while (n >= 2 && count > 0) {
0:       double V = randomGenerator.raw();
1:       S = 0;
1:       double quot = top / Nreal;
1:       while (quot > V) {
1:         S++;
1:         top--;
1:         Nreal--;
0:         quot = (quot * top) / Nreal;
1:       }
1:       chosen += S + 1;
1:       count--;
1:       Nreal--;
1:       n--;
1:     }
1: 
1:     if (count > 0) {
1:       // special case n==1
0:       S = (long) (Math.round(Nreal) * randomGenerator.raw());
1:       chosen += S + 1;
1:       values[fromIndex] = chosen;
1:   /**
1:    * Efficiently computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>. Since
1:    * we are talking about a random set, no element will occur more than once.
1:    *
1:    * <p>Running time is <tt>O(count)</tt>, on average. Space requirements are zero.
1:    *
1:    * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right. The array is
1:    * returned sorted ascending in the range filled with numbers.
1:    *
1:    * @param n               the total number of elements to choose (must be &gt;= 0).
1:    * @param N               the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
1:    * @param count           the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and
1:    *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
1:    * @param low             the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If
1:    *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
1:    * @param values          the array into which the random numbers are to be filled; must have a length <tt>&gt;=
1:    *                        count+fromIndex</tt>.
1:    * @param fromIndex       the first index within <tt>values</tt> to be filled with numbers (inclusive).
1:    * @param randomGenerator a random number generator.
1:    */
0:   protected static void sampleMethodD(long n, long N, int count, long low, long[] values, int fromIndex,
0:                                       RandomEngine randomGenerator) {
1:     long chosen = -1 + low;
1: 
1:     double nreal = n;
1:     double ninv = 1.0 / nreal;
1:     double Nreal = N;
0:     double Vprime = Math.exp(Math.log(randomGenerator.raw()) * ninv);
1:     long qu1 = -n + 1 + N;
1:     double qu1real = -nreal + 1.0 + Nreal;
0:     long negalphainv =
0:         -13;  //tuning paramter, determines when to switch from method D to method A. Dependent on programming language, platform, etc.
1:     long threshold = -negalphainv * n;
1: 
1:     long S;
1:     while (n > 1 && count > 0 && threshold < N) {
1:       double nmin1inv = 1.0 / (-1.0 + nreal);
1:       double negSreal;
1:       while (true) {
1:         double X;
1:         while (true) { // step D2: generate U and X
1:           X = Nreal * (-Vprime + 1.0);
1:           S = (long) X;
1:           if (S < qu1) {
1:             break;
1:           }
0:           Vprime = Math.exp(Math.log(randomGenerator.raw()) * ninv);
1:         }
0:         double U = randomGenerator.raw();
1:         negSreal = -S;
1: 
1:         //step D3: Accept?
1:         double y1 = Math.exp(Math.log(U * Nreal / qu1real) * nmin1inv);
0:         Vprime = y1 * (-X / Nreal + 1.0) * (qu1real / (negSreal + qu1real));
1:         if (Vprime <= 1.0) {
1:           break;
1:         } //break inner loop
1: 
1:         //step D4: Accept?
1:         double top = -1.0 + Nreal;
1:         long limit;
1:         double bottom;
1:         if (n - 1 > S) {
1:           bottom = -nreal + Nreal;
1:           limit = -S + N;
1:         } else {
1:           bottom = -1.0 + negSreal + Nreal;
1:           limit = qu1;
1:         }
1:         double y2 = 1.0;
1:         for (long t = N - 1; t >= limit; t--) {
0:           y2 = (y2 * top) / bottom;
1:           top--;
1:           bottom--;
1:         }
1:         if (Nreal / (-X + Nreal) >= y1 * Math.exp(Math.log(y2) * nmin1inv)) {
1:           // accept !
0:           Vprime = Math.exp(Math.log(randomGenerator.raw()) * nmin1inv);
1:           break; //break inner loop
1:         }
0:         Vprime = Math.exp(Math.log(randomGenerator.raw()) * ninv);
1:       }
1: 
1:       //step D5: select the (S+1)st record !
1:       chosen += S + 1;
1:       values[fromIndex++] = chosen;
1:       // invert
1:       for (int iter=0; iter<S && count > 0; iter++) {
1:         values[fromIndex++] = ++chosen;
1:         count--;
1:       }
1:       chosen++;
1:       count--;
1: 
1:       N -= S + 1;
0:       Nreal = negSreal + (-1.0 + Nreal);
1:       n--;
1:       nreal--;
1:       ninv = nmin1inv;
1:       qu1 = -S + qu1;
1:       qu1real = negSreal + qu1real;
1:       threshold += negalphainv;
1:     } //end while
1: 
1: 
1:     if (count > 0) {
1:       if (n > 1) { //faster to use method A to finish the sampling
1:         sampleMethodA(n, N, count, chosen + 1, values, fromIndex, randomGenerator);
1:       } else {
1:         //special case n==1
1:         S = (long) (N * Vprime);
1:         chosen += S + 1;
1:         values[fromIndex++] = chosen;
1:       }
0:   /** Tests the methods of this class. To do benchmarking, comment the lines printing stuff to the console. */
0:   public static void test(long n, long N, long low, int chunkSize, int times) {
0:     long[] values = new long[chunkSize];
0:     long chunks = n / chunkSize;
0:     org.apache.mahout.matrix.Timer timer = new org.apache.mahout.matrix.Timer().start();
0:     for (long t = times; --t >= 0;) {
0:       RandomSampler sampler =
0:           new RandomSampler(n, N, low, org.apache.mahout.jet.random.AbstractDistribution.makeDefaultGenerator());
0:       for (long i = 0; i < chunks; i++) {
0:         sampler.nextBlock(chunkSize, values, 0);
1:         /*
0:         Log.print("Chunk #"+i+" = [");
0:         for (int j=0; j<chunkSize-1; j++) Log.print(values[j]+", ");
0:         Log.print(String.valueOf(values[chunkSize-1]));
0:         Log.println("]");
1:         */
1:       }
0:       int toDo = (int) (n - chunkSize * chunks);
0:       if (toDo > 0) { // sample remaining part, if necessary
0:         sampler.nextBlock(toDo, values, 0);
1:         /*
0:         Log.print("Chunk #"+chunks+" = [");
0:         for (int j=0; j<toDo-1; j++) Log.print(values[j]+", ");
0:         Log.print(String.valueOf(values[toDo-1]));
0:         Log.println("]");
1:         */
1:       }
1:     }
0:     timer.stop();
0:     System.out.println("single run took " + timer.elapsedTime() / times);
0:     System.out.println("Good bye.\n");
1: 
1:   /**
0:    * Tests different values for negaalphainv. Result: J.S. Vitter's recommendation for negalphainv=-13 is also good in
0:    * the JDK 1.2 environment.
1:    */
0:   protected static void testNegAlphaInv(String[] args) {
1:     /*
0:     long N = Long.parseLong(args[0]);
0:     int chunkSize = Integer.parseInt(args[1]);
1: 
0:     long[] alphas = {-104, -52, -26, -13, -8, -4, -2};
0:     for (int i=0; i<alphas.length; i++) {
0:       negalphainv = alphas[i];
0:       System.out.println("\n\nnegalphainv="+negalphainv);
1: 
0:       System.out.print(" n="+N/80+" --> ");
0:       test(N/80,N,0,chunkSize);
1: 
0:       System.out.print(" n="+N/40+" --> ");
0:       test(N/40,N,0,chunkSize);
1: 
0:       System.out.print(" n="+N/20+" --> ");
0:       test(N/20,N,0,chunkSize);
1: 
0:       System.out.print(" n="+N/10+" --> ");
0:       test(N/10,N,0,chunkSize);
1: 
0:       System.out.print(" n="+N/5+" --> ");
0:       test(N/5,N,0,chunkSize);
1: 
0:       System.out.print(" n="+N/2+" --> ");
0:       test(N/2,N,0,chunkSize);
1: 
0:       System.out.print(" n="+(N-3)+" --> ");
0:       test(N-3,N,0,chunkSize);
1:     }
1:     */
1:   }
commit:7a9ecf4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:   long my_n;
0:   long my_N;
0:   long my_low;
0:   RandomEngine my_RandomGenerator;
0:   //static long negalphainv; // just to determine once and for all the best value for negalphainv
/////////////////////////////////////////////////////////////////////////
0:   if (n<0) throw new IllegalArgumentException("n must be >= 0");
0:   if (n>N) throw new IllegalArgumentException("n must by <= N");
0:   this.my_n=n;
0:   this.my_N=N;
0:   this.my_low=low;
0:   if (randomGenerator==null) randomGenerator = org.apache.mahout.jet.random.AbstractDistribution.makeDefaultGenerator();
0:   this.my_RandomGenerator=randomGenerator;
0:   RandomSampler copy = (RandomSampler) super.clone();
0:   copy.my_RandomGenerator = (RandomEngine) this.my_RandomGenerator.clone();
0:   return copy;
0:   long n = Long.parseLong(args[0]);
0:   long N = Long.parseLong(args[1]);
0:   long low = Long.parseLong(args[2]);
0:   int chunkSize = Integer.parseInt(args[3]);
0:   int times = Integer.parseInt(args[4]);
0:   test(n,N,low,chunkSize,times);
0:   //testNegAlphaInv(args);
/////////////////////////////////////////////////////////////////////////
0:   if (count > my_n) throw new IllegalArgumentException("Random sample exhausted.");
0:   if (count < 0) throw new IllegalArgumentException("Negative count.");
0:   if (count==0) return; //nothing to do
0:   sample(my_n,my_N,count,my_low,values,fromIndex,my_RandomGenerator);
0:     
0:   long lastSample=values[fromIndex+count-1];
0:   my_n -= count;
0:   my_N = my_N - lastSample - 1 + my_low ;
0:   my_low = lastSample+1;
/////////////////////////////////////////////////////////////////////////
0:   /*  This algorithm is applicable if a large percentage (90%..100%) of N shall be sampled.
0:     In such cases it is more efficient than sampleMethodA() and sampleMethodD().
0:       The idea is that it is more efficient to express
0:     sample(n,N,count) in terms of reject(N-n,N,count)
0:      and then invert the result.
0:     For example, sampling 99% turns into sampling 1% plus inversion.
0:     This algorithm is the same as method sampleMethodD(...) with the exception that sampled elements are rejected, and not sampled elements included in the result set.
0:   */
0:   n = N-n; // IMPORTANT !!!
0:   
0:   double nreal, Nreal, ninv, nmin1inv, U, X, Vprime, y1, y2, top, bottom, negSreal, qu1real;
0:   long qu1, t, limit;
0:   //long threshold;
0:   long S;
0:   long chosen = -1+low;
0:   
0:   long negalphainv = -13;  //tuning paramter, determines when to switch from method D to method A. Dependent on programming language, platform, etc.
0:   nreal = n; ninv = 1.0/nreal; Nreal = N;
0:   Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0:   qu1 = -n + 1 + N; qu1real = -nreal + 1.0 + Nreal;
0:   //threshold = -negalphainv * n;
0:   
0:   while (n>1 && count>0) { //&& threshold<N) {
0:     nmin1inv = 1.0/(-1.0 + nreal);
0:     for (;;) {
0:       for (;;) { // step D2: generate U and X
0:         X = Nreal * (-Vprime + 1.0); S = (long) X;
0:         if (S<qu1) break;
0:         Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0:       }
0:       U = randomGenerator.raw(); negSreal = -S;
0:       
0:       //step D3: Accept?
0:       y1 = Math.exp(Math.log(U*Nreal/qu1real) * nmin1inv);
0:       Vprime = y1*(-X/Nreal + 1.0) * (qu1real/(negSreal + qu1real));
0:       if (Vprime <= 1.0) break; //break inner loop
0:       //step D4: Accept?
0:       y2 = 1.0; top = -1.0 + Nreal;
0:       if (n-1>S) {
0:         bottom = -nreal + Nreal; limit = -S+N;
0:       }
0:       else {
0:         bottom = -1.0 + negSreal + Nreal; limit=qu1;
0:       }
0:       for (t=N-1; t>=limit; t--) {
0:         y2 = (y2*top)/bottom;
0:         top--;
0:         bottom--;
0:       }
0:       if (Nreal/(-X+Nreal) >= y1*Math.exp(Math.log(y2)*nmin1inv)) {
0:         // accept !
0:         Vprime = Math.exp(Math.log(randomGenerator.raw())*nmin1inv);
0:         break; //break inner loop
0:       }
0:       Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0:     } //end for
0:     //step D5: reject the (S+1)st record !      
0:     int iter = count; //int iter = (int) (Math.min(S,count));
0:     if (S<iter) iter=(int)S;
0:     
0:     count -= iter;
0:     for (; --iter >= 0 ;) values[fromIndex++] = ++chosen;
0:     chosen++;
0:     N -= S+1; Nreal=negSreal+(-1.0+Nreal);
0:     n--; nreal--; ninv = nmin1inv;
0:     qu1 = -S+qu1; qu1real = negSreal+qu1real;
0:     //threshold += negalphainv;
0:   } //end while
0:   if (count>0) { //special case n==1
0:     //reject the (S+1)st record !
0:     S = (long) (N*Vprime);
0:     
0:     int iter = count; //int iter = (int) (Math.min(S,count));
0:     if (S<iter) iter=(int)S;
0:     
0:     count -= iter;
0:     for (; --iter >= 0 ;) values[fromIndex++] = ++chosen;
0:     chosen++;
0:     // fill the rest
0:     for (; --count >= 0; ) values[fromIndex++] = ++chosen;
0:   }
/////////////////////////////////////////////////////////////////////////
0:   if (n<=0 || count<=0) return;
0:   if (count>n) throw new IllegalArgumentException("count must not be greater than n");
0:   if (randomGenerator==null) randomGenerator = org.apache.mahout.jet.random.AbstractDistribution.makeDefaultGenerator();
0:   if (count==N) { // rare case treated quickly
0:     long val = low;
0:     int limit= fromIndex+count;
0:     for (int i=fromIndex; i<limit; ) values[i++] = val++;
0:     return;
0:   } 
0:   if (n<N*0.95) { // || Math.min(count,N-n)>maxTmpMemoryAllowed) {
0:     sampleMethodD(n,N,count,low,values,fromIndex,randomGenerator);
0:   }  
0:   else { // More than 95% of all numbers shall be sampled.  
0:     rejectMethodD(n,N,count,low,values,fromIndex,randomGenerator);
0:   }
0:   
0:   
/////////////////////////////////////////////////////////////////////////
0:   double V, quot, Nreal, top;
0:   long S;
0:   long chosen = -1+low;
0:   
0:   top = N-n;
0:   Nreal = N;
0:   while (n>=2 && count>0) {
0:     V = randomGenerator.raw();
0:     S = 0;
0:     quot = top/Nreal;
0:     while (quot > V) {
0:       S++;
0:       top--;
0:       Nreal--;
0:       quot = (quot*top)/Nreal;
0:     }
0:     chosen += S+1;
0:     values[fromIndex++]=chosen;
0:     count--;
0:     Nreal--;
0:     n--;
0:   }
0:   if (count>0) {
0:     // special case n==1
0:     S = (long) (Math.round(Nreal) * randomGenerator.raw());
0:     chosen += S+1;
0:     values[fromIndex]=chosen;
0:   }
/////////////////////////////////////////////////////////////////////////
0:   double nreal, Nreal, ninv, nmin1inv, U, X, Vprime, y1, y2, top, bottom, negSreal, qu1real;
0:   long qu1, threshold, t, limit;
0:   long S;
0:   long chosen = -1+low;
0:   
0:   long negalphainv = -13;  //tuning paramter, determines when to switch from method D to method A. Dependent on programming language, platform, etc.
0:   nreal = n; ninv = 1.0/nreal; Nreal = N;
0:   Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0:   qu1 = -n + 1 + N; qu1real = -nreal + 1.0 + Nreal;
0:   threshold = -negalphainv * n;
0:   
0:   while (n>1 && count>0 && threshold<N) {
0:     nmin1inv = 1.0/(-1.0 + nreal);
0:     for (;;) {
0:       for (;;) { // step D2: generate U and X
0:         X = Nreal * (-Vprime + 1.0); S = (long) X;
0:         if (S<qu1) break;
0:         Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0:       }
0:       U = randomGenerator.raw(); negSreal = -S;
0:       
0:       //step D3: Accept?
0:       y1 = Math.exp(Math.log(U*Nreal/qu1real) * nmin1inv);
0:       Vprime = y1*(-X/Nreal + 1.0) * (qu1real/(negSreal + qu1real));
0:       if (Vprime <= 1.0) break; //break inner loop
0:       //step D4: Accept?
0:       y2 = 1.0; top = -1.0 + Nreal;
0:       if (n-1>S) {
0:         bottom = -nreal + Nreal; limit = -S+N;
0:       }
0:       else {
0:         bottom = -1.0 + negSreal + Nreal; limit=qu1;
0:       }
0:       for (t=N-1; t>=limit; t--) {
0:         y2 = (y2*top)/bottom;
0:         top--;
0:         bottom--;
0:       }
0:       if (Nreal/(-X+Nreal) >= y1*Math.exp(Math.log(y2)*nmin1inv)) {
0:         // accept !
0:         Vprime = Math.exp(Math.log(randomGenerator.raw())*nmin1inv);
0:         break; //break inner loop
0:       }
0:       Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0:     } //end for
0:     //step D5: select the (S+1)st record !
0:     chosen += S+1;
1:     values[fromIndex++] = chosen;
0:     /*
0:     // invert
0:     for (int iter=0; iter<S && count > 0; iter++) {
0:       values[fromIndex++] = ++chosen;
0:       count--;
0:     }
0:     chosen++;
0:     */
0:     count--;
0:     N -= S+1; Nreal=negSreal+(-1.0+Nreal);
0:     n--; nreal--; ninv = nmin1inv;
0:     qu1 = -S+qu1; qu1real = negSreal+qu1real;
0:     threshold += negalphainv;
0:   } //end while
0:   if (count>0) {
0:     if (n>1) { //faster to use method A to finish the sampling
0:       sampleMethodA(n,N,count,chosen+1,values,fromIndex,randomGenerator);
0:     }
0:     else {
0:       //special case n==1
0:       S = (long) (N*Vprime);
0:       chosen += S+1;
1:       values[fromIndex++] = chosen;
0:     }
0:   }
0:   long[] values = new long[chunkSize];
0:   long chunks = n/chunkSize;
0:   
0:   org.apache.mahout.matrix.Timer timer = new org.apache.mahout.matrix.Timer().start();
0:   for (long t=times; --t >=0;) {
0:     RandomSampler sampler = new RandomSampler(n,N,low, org.apache.mahout.jet.random.AbstractDistribution.makeDefaultGenerator());
0:     for (long i=0; i<chunks; i++) {
0:       sampler.nextBlock(chunkSize,values,0);
0:       /*
0:       Log.print("Chunk #"+i+" = [");
0:       for (int j=0; j<chunkSize-1; j++) Log.print(values[j]+", ");
0:       Log.print(String.valueOf(values[chunkSize-1]));
0:       Log.println("]");
0:       */
0:       
0:     }
0:     
0:     int toDo=(int) (n-chunkSize*chunks);
0:     if (toDo > 0) { // sample remaining part, if necessary
0:       sampler.nextBlock(toDo,values,0);  
0:       
0:       /*  
0:       Log.print("Chunk #"+chunks+" = [");
0:       for (int j=0; j<toDo-1; j++) Log.print(values[j]+", ");
0:       Log.print(String.valueOf(values[toDo-1]));
0:       Log.println("]");
0:       */
0:       
0:       
0:     }
0:   }
0:   timer.stop();
0:   System.out.println("single run took "+timer.elapsedTime()/times);
0:   System.out.println("Good bye.\n");
0:   /*
0:   long N = Long.parseLong(args[0]);
0:   int chunkSize = Integer.parseInt(args[1]);
0:   long[] alphas = {-104, -52, -26, -13, -8, -4, -2};
0:   for (int i=0; i<alphas.length; i++) {
0:     negalphainv = alphas[i];
0:     System.out.println("\n\nnegalphainv="+negalphainv);
0:     System.out.print(" n="+N/80+" --> ");
0:     test(N/80,N,0,chunkSize);
0:     System.out.print(" n="+N/40+" --> ");
0:     test(N/40,N,0,chunkSize);
0:     System.out.print(" n="+N/20+" --> ");
0:     test(N/20,N,0,chunkSize);
0:     System.out.print(" n="+N/10+" --> ");
0:     test(N/10,N,0,chunkSize);
0:     System.out.print(" n="+N/5+" --> ");
0:     test(N/5,N,0,chunkSize);
0:     System.out.print(" n="+N/2+" --> ");
0:     test(N/2,N,0,chunkSize);
0:     System.out.print(" n="+(N-3)+" --> ");
0:     test(N-3,N,0,chunkSize);
0:   }
0:   */
author:Ted Dunning
-------------------------------------------------------------------------------
commit:22726e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.common.RandomUtils;
1: import java.util.Random;
0: 
/////////////////////////////////////////////////////////////////////////
0:   private Random randomGenerator;
/////////////////////////////////////////////////////////////////////////
0:   public RandomSampler(long n, long N, long low, Random randomGenerator) {
/////////////////////////////////////////////////////////////////////////
1:       randomGenerator = RandomUtils.getRandom();
0:   Random getRandomGenerator() {
/////////////////////////////////////////////////////////////////////////
0: *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
0: *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
0: *                        count+fromIndex</tt>.
1:                                       Random randomGenerator) {
/////////////////////////////////////////////////////////////////////////
1:     double Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
/////////////////////////////////////////////////////////////////////////
1:           Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
1:         double U = randomGenerator.nextDouble();
/////////////////////////////////////////////////////////////////////////
1:           Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * nmin1inv);
1:         Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
/////////////////////////////////////////////////////////////////////////
0:                             Random randomGenerator) {
/////////////////////////////////////////////////////////////////////////
0:       randomGenerator = RandomUtils.getRandom();
/////////////////////////////////////////////////////////////////////////
0: *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
0: *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
0: *                        count+fromIndex</tt>.
0:                                       Random randomGenerator) {
1:       double V = randomGenerator.nextDouble();
/////////////////////////////////////////////////////////////////////////
1:       S = (long) (Math.round(Nreal) * randomGenerator.nextDouble());
/////////////////////////////////////////////////////////////////////////
0: *                        &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
0: *                        <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
0: *                        count+fromIndex</tt>.
0:                                       Random randomGenerator) {
0:     double Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
/////////////////////////////////////////////////////////////////////////
0:           Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
1:         double U = randomGenerator.nextDouble();
/////////////////////////////////////////////////////////////////////////
0:           Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * nmin1inv);
0:         Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:a435efb
/////////////////////////////////////////////////////////////////////////
1: package org.apache.mahout.math.jet.random.sampling;
0: import org.apache.mahout.math.PersistentObject;
0: import org.apache.mahout.math.Timer;
0: import org.apache.mahout.math.jet.random.engine.RandomEngine;
/////////////////////////////////////////////////////////////////////////
0:       randomGenerator = org.apache.mahout.math.jet.random.AbstractDistribution.makeDefaultGenerator();
/////////////////////////////////////////////////////////////////////////
0:       randomGenerator = org.apache.mahout.math.jet.random.AbstractDistribution.makeDefaultGenerator();
commit:f49424e
/////////////////////////////////////////////////////////////////////////
0: public class RandomSampler extends org.apache.mahout.matrix.PersistentObject {
/////////////////////////////////////////////////////////////////////////
0: 	org.apache.mahout.matrix.Timer timer = new org.apache.mahout.matrix.Timer().start();
commit:7550a10
/////////////////////////////////////////////////////////////////////////
0: /*
1: Copyright ï¿? 1999 CERN - European Organization for Nuclear Research.
1: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1: that both that copyright notice and this permission notice appear in supporting documentation. 
1: CERN makes no representations about the suitability of this software for any purpose. 
1: It is provided "as is" without expressed or implied warranty.
0: */
0: package org.apache.mahout.jet.random.sampling;
0: 
0: import org.apache.mahout.jet.random.engine.RandomEngine;
0: /**
0:  * Space and time efficiently computes a sorted <i>Simple Random Sample Without Replacement (SRSWOR)</i>, that is, a sorted set of <tt>n</tt> random numbers from an interval of <tt>N</tt> numbers;
0:  * Example: Computing <tt>n=3</tt> random numbers from the interval <tt>[1,50]</tt> may yield the sorted random set <tt>(7,13,47)</tt>.
1:  * Since we are talking about a set (sampling without replacement), no element will occur more than once.
1:  * Each number from the <tt>N</tt> numbers has the same probability to be included in the <tt>n</tt> chosen numbers.
1:  *
1:  * <p><b>Problem:</b> This class solves problems including the following: <i>
1:  * Suppose we have a file containing 10^12 objects.
1:  * We would like to take a truly random subset of 10^6 objects and do something with it, 
1:  * for example, compute the sum over some instance field, or whatever.
0:  * How do we choose the subset? In particular, how do we avoid multiple equal elements? How do we do this quick and without consuming excessive memory? How do we avoid slowly jumping back and forth within the file? </i>
1:  *
1:  * <p><b>Sorted Simple Random Sample Without Replacement (SRSWOR):</b>
1:  * What are the exact semantics of this class? What is a SRSWOR? In which sense exactly is a returned set "random"?
0:  * It is random in the sense, that each number from the <tt>N</tt> numbers has the same probability to be included in the <tt>n</tt> chosen numbers.
1:  * For those who think in implementations rather than abstract interfaces:
1:  * <i>Suppose, we have an empty list.
0:  * We pick a random number between 1 and 10^12 and add it to the list only if it was not already picked before, i.e. if it is not already contained in the list.
1:  * We then do the same thing again and again until we have eventually collected 10^6 distinct numbers.
1:  * Now we sort the set ascending and return it.</i>
1:  * <dt>It is exactly in this sense that this class returns "random" sets.
0:  * <b>Note, however, that the implementation of this class uses a technique orders of magnitudes better (both in time and space) than the one outlined above.</b> 
1:  *
0:  * <p><b>Performance:</b> Space requirements are zero. Running time is <tt>O(n)</tt> on average, <tt>O(N)</tt> in the worst case.
0:  * <h2 align=center>Performance (200Mhz Pentium Pro, JDK 1.2, NT)</h2>
1:  * <center>
0:  *   <table border="1">
1:  *     <tr> 
1:  *       <td align="center" width="20%">n</td>
1:  *       <td align="center" width="20%">N</td>
1:  *       <td align="center" width="20%">Speed [seconds]</td>
1:  *     </tr>
1:  *     <tr> 
1:  *       <td align="center" width="20%">10<sup>3</sup></td>
1:  *       <td align="center" width="20%">1.2*10<sup>3</sup></td>
1:  *       <td align="center" width="20">0.0014</td>
1:  *     </tr>
1:  *     <tr> 
1:  *       <td align="center" width="20%">10<sup>3</sup></td>
1:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:  *       <td align="center" width="20">0.006</td>
1:  *     </tr>
1:  *     <tr> 
1:  *       <td align="center" width="20%">10<sup>5</sup></td>
1:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:  *       <td align="center" width="20">0.7</td>
1:  *     </tr>
1:  *     <tr> 
1:  *       <td align="center" width="20%">9.0*10<sup>6</sup></td>
1:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:  *       <td align="center" width="20">8.5</td>
1:  *     </tr>
1:  *     <tr> 
1:  *       <td align="center" width="20%">9.9*10<sup>6</sup></td>
1:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:  *       <td align="center" width="20">2.0 (samples more than 95%)</td>
1:  *     </tr>
1:  *     <tr> 
1:  *       <td align="center" width="20%">10<sup>4</sup></td>
1:  *       <td align="center" width="20%">10<sup>12</sup></td>
1:  *       <td align="center" width="20">0.07</td>
1:  *     </tr>
1:  *     <tr> 
1:  *       <td align="center" width="20%">10<sup>7</sup></td>
1:  *       <td align="center" width="20%">10<sup>12</sup></td>
1:  *       <td align="center" width="20">60</td>
1:  *     </tr>
1:  *   </table>
1:  * </center>
1:  *
0:  * <p><b>Scalability:</b> This random sampler is designed to be scalable. In iterator style, it is able to compute and deliver sorted random sets stepwise in units called <i>blocks</i>.
0:  * Example: Computing <tt>n=9</tt> random numbers from the interval <tt>[1,50]</tt> in 3 blocks may yield the blocks <tt>(7,13,14), (27,37,42), (45,46,49)</tt>.
0:  * (The maximum of a block is guaranteed to be less than the minimum of its successor block. Every block is sorted ascending. No element will ever occur twice, both within a block and among blocks.)
1:  * A block can be computed and retrieved with method <tt>nextBlock</tt>.
1:  * Successive calls to method <tt>nextBlock</tt> will deliver as many random numbers as required.
1:  *
0:  * <p>Computing and retrieving samples in blocks is useful if you need very many random numbers that cannot be stored in main memory at the same time.
0:  * For example, if you want to compute 10^10 such numbers you can do this by computing them in blocks of, say, 500 elements each.
1:  * You then need only space to keep one block of 500 elements (i.e. 4 KB).
0:  * When you are finished processing the first 500 elements you call <tt>nextBlock</tt> to fill the next 500 elements into the block, process them, and so on.
0:  * If you have the time and need, by using such blocks you can compute random sets up to <tt>n=10^19</tt> random numbers.
1:  *
1:  * <p>If you do not need the block feature, you can also directly call 
1:  * the static methods of this class without needing to construct a <tt>RandomSampler</tt> instance first.
1:  *
0:  * <p><b>Random number generation:</b> By default uses <tt>MersenneTwister</tt>, a very strong random number generator, much better than <tt>java.util.Random</tt>.
1:  * You can also use other strong random number generators of Paul Houle's RngPack package.
0:  * For example, <tt>Ranecu</tt>, <tt>Ranmar</tt> and <tt>Ranlux</tt> are strong well analyzed research grade pseudo-random number generators with known periods.
1:  *
1:  * <p><b>Implementation:</b> after J.S. Vitter, An Efficient Algorithm for Sequential Random Sampling,
1:  * ACM Transactions on Mathematical Software, Vol 13, 1987.
1:  * Paper available <A HREF="http://www.cs.duke.edu/~jsv"> here</A>.
1:  * 
0:  * @see RandomSamplingAssistant
0:  * @author  wolfgang.hoschek@cern.ch
0:  * @version 1.1 05/26/99
0:  */
0: /** 
0:  * @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported.
0:  */
0: @Deprecated
0: public class RandomSampler extends org.apache.mahout.colt.PersistentObject {
0: //public class RandomSampler extends Object implements java.io.Serializable {
0: 	long my_n;
0: 	long my_N;
0: 	long my_low;
0: 	RandomEngine my_RandomGenerator;
0: 	//static long negalphainv; // just to determine once and for all the best value for negalphainv
0: /**
0:  * Constructs a random sampler that computes and delivers sorted random sets in blocks.
0:  * A set block can be retrieved with method <tt>nextBlock</tt>.
1:  * Successive calls to method <tt>nextBlock</tt> will deliver as many random numbers as required.
1:  *
0:  * @param n the total number of elements to choose (must be <tt>n &gt;= 0</tt> and <tt>n &lt;= N</tt>).
0:  * @param N the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
0:  * @param low the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If <tt>low==0</tt>, then random numbers will be drawn from the interval <tt>[0,N-1]</tt>.
0:  * @param randomGenerator a random number generator. Set this parameter to <tt>null</tt> to use the default random number generator.
0:  */
0: public RandomSampler(long n, long N, long low, RandomEngine randomGenerator) {
0: 	if (n<0) throw new IllegalArgumentException("n must be >= 0");
0: 	if (n>N) throw new IllegalArgumentException("n must by <= N");
0: 	this.my_n=n;
0: 	this.my_N=N;
0: 	this.my_low=low;
0: 
0: 	if (randomGenerator==null) randomGenerator = org.apache.mahout.jet.random.AbstractDistribution.makeDefaultGenerator();
0: 	this.my_RandomGenerator=randomGenerator;
0: }
0: /**
0:  * Returns a deep copy of the receiver.
0:  */
0: public Object clone() {
0: 	RandomSampler copy = (RandomSampler) super.clone();
0: 	copy.my_RandomGenerator = (RandomEngine) this.my_RandomGenerator.clone();
0: 	return copy;
0: }
0: /**
0:  * Tests this class.
0:  */
0: public static void main(String args[]) {
0: 	long n = Long.parseLong(args[0]);
0: 	long N = Long.parseLong(args[1]);
0: 	long low = Long.parseLong(args[2]);
0: 	int chunkSize = Integer.parseInt(args[3]);
0: 	int times = Integer.parseInt(args[4]);
0: 
0: 	test(n,N,low,chunkSize,times);
0: 	//testNegAlphaInv(args);
0: }
0: /**
0:  * Computes the next <tt>count</tt> random numbers of the sorted random set specified on instance construction
0:  * and fills them into <tt>values</tt>, starting at index <tt>fromIndex</tt>.
1:  *
0:  * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right.
0:  * The array is returned sorted ascending in the range filled with numbers.
1:  *
0:  * @param count the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0).
0:  * @param values the array into which the random numbers are to be filled; must have a length <tt>&gt;= count+fromIndex</tt>.
0:  * @param fromIndex the first index within <tt>values</tt> to be filled with numbers (inclusive).
0:  */
0: public void nextBlock(int count, long[] values, int fromIndex) {
0: 	if (count > my_n) throw new IllegalArgumentException("Random sample exhausted.");
0: 	if (count < 0) throw new IllegalArgumentException("Negative count.");
0: 
0: 	if (count==0) return; //nothing to do
0: 
0: 	sample(my_n,my_N,count,my_low,values,fromIndex,my_RandomGenerator);
0: 		
0: 	long lastSample=values[fromIndex+count-1];
0: 	my_n -= count;
0: 	my_N = my_N - lastSample - 1 + my_low ;
0: 	my_low = lastSample+1;
0: }
0: /**
0:  * Efficiently computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>.
0:  * Since we are talking about a random set, no element will occur more than once.
1:  *
0:  * <p>Running time is <tt>O(count)</tt>, on average. Space requirements are zero.
1:  *
0:  * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right.
0:  * The array is returned sorted ascending in the range filled with numbers.
1:  *
0:  * @param n the total number of elements to choose (must be &gt;= 0).
0:  * @param N the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
0:  * @param count the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
0:  * @param low the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
0:  * @param values the array into which the random numbers are to be filled; must have a length <tt>&gt;= count+fromIndex</tt>.
0:  * @param fromIndex the first index within <tt>values</tt> to be filled with numbers (inclusive).
0:  * @param randomGenerator a random number generator.
0:  */
0: protected static void rejectMethodD(long n, long N, int count, long low, long[] values, int fromIndex, RandomEngine randomGenerator) {
0: 	/*  This algorithm is applicable if a large percentage (90%..100%) of N shall be sampled.
0: 		In such cases it is more efficient than sampleMethodA() and sampleMethodD().
0: 	    The idea is that it is more efficient to express
0: 		sample(n,N,count) in terms of reject(N-n,N,count)
0: 	 	and then invert the result.
0: 		For example, sampling 99% turns into sampling 1% plus inversion.
0: 
0: 		This algorithm is the same as method sampleMethodD(...) with the exception that sampled elements are rejected, and not sampled elements included in the result set.
0: 	*/
0: 	n = N-n; // IMPORTANT !!!
0: 	
0: 	double nreal, Nreal, ninv, nmin1inv, U, X, Vprime, y1, y2, top, bottom, negSreal, qu1real;
0: 	long qu1, t, limit;
0: 	//long threshold;
0: 	long S;
0: 	long chosen = -1+low;
0: 	
0: 	long negalphainv = -13;  //tuning paramter, determines when to switch from method D to method A. Dependent on programming language, platform, etc.
0: 
0: 	nreal = n; ninv = 1.0/nreal; Nreal = N;
0: 	Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0: 	qu1 = -n + 1 + N; qu1real = -nreal + 1.0 + Nreal;
0: 	//threshold = -negalphainv * n;
0: 	
0: 	while (n>1 && count>0) { //&& threshold<N) {
0: 		nmin1inv = 1.0/(-1.0 + nreal);
0: 		for (;;) {
0: 			for (;;) { // step D2: generate U and X
0: 				X = Nreal * (-Vprime + 1.0); S = (long) X;
0: 				if (S<qu1) break;
0: 				Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0: 			}
0: 			U = randomGenerator.raw(); negSreal = -S;
0: 			
0: 			//step D3: Accept?
0: 			y1 = Math.exp(Math.log(U*Nreal/qu1real) * nmin1inv);
0: 			Vprime = y1*(-X/Nreal + 1.0) * (qu1real/(negSreal + qu1real));
0: 			if (Vprime <= 1.0) break; //break inner loop
0: 
0: 			//step D4: Accept?
0: 			y2 = 1.0; top = -1.0 + Nreal;
0: 			if (n-1>S) {
0: 				bottom = -nreal + Nreal; limit = -S+N;
0: 			}
0: 			else {
0: 				bottom = -1.0 + negSreal + Nreal; limit=qu1;
0: 			}
0: 			for (t=N-1; t>=limit; t--) {
0: 				y2 = (y2*top)/bottom;
0: 				top--;
0: 				bottom--;
0: 			}
0: 			if (Nreal/(-X+Nreal) >= y1*Math.exp(Math.log(y2)*nmin1inv)) {
0: 				// accept !
0: 				Vprime = Math.exp(Math.log(randomGenerator.raw())*nmin1inv);
0: 				break; //break inner loop
0: 			}
0: 			Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0: 		} //end for
0: 
0: 		//step D5: reject the (S+1)st record !			
0: 		int iter = count; //int iter = (int) (Math.min(S,count));
0: 		if (S<iter) iter=(int)S;
0: 		
0: 		count -= iter;
0: 		for (; --iter >= 0 ;) values[fromIndex++] = ++chosen;
0: 		chosen++;
0: 
0: 		N -= S+1; Nreal=negSreal+(-1.0+Nreal);
0: 		n--; nreal--; ninv = nmin1inv;
0: 		qu1 = -S+qu1; qu1real = negSreal+qu1real;
0: 		//threshold += negalphainv;
0: 	} //end while
0: 
0: 
0: 	if (count>0) { //special case n==1
0: 		//reject the (S+1)st record !
0: 		S = (long) (N*Vprime);
0: 		
0: 		int iter = count; //int iter = (int) (Math.min(S,count));
0: 		if (S<iter) iter=(int)S;
0: 		
0: 		count -= iter;
0: 		for (; --iter >= 0 ;) values[fromIndex++] = ++chosen;
0: 
0: 		chosen++;
0: 
0: 		// fill the rest
0: 		for (; --count >= 0; ) values[fromIndex++] = ++chosen;
0: 	}
0: }
0: /**
0:  * Efficiently computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>.
0:  * Since we are talking about a random set, no element will occur more than once.
1:  *
0:  * <p>Running time is <tt>O(count)</tt>, on average. Space requirements are zero.
1:  *
0:  * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right.
0:  * The array is returned sorted ascending in the range filled with numbers.
1:  *
0:  * <p><b>Random number generation:</b> By default uses <tt>MersenneTwister</tt>, a very strong random number generator, much better than <tt>java.util.Random</tt>.
1:  * You can also use other strong random number generators of Paul Houle's RngPack package.
0:  * For example, <tt>Ranecu</tt>, <tt>Ranmar</tt> and <tt>Ranlux</tt> are strong well analyzed research grade pseudo-random number generators with known periods.
1:  *
0:  * @param n the total number of elements to choose (must be <tt>n &gt;= 0</tt> and <tt>n &lt;= N</tt>).
0:  * @param N the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
0:  * @param count the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
0:  * @param low the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
0:  * @param values the array into which the random numbers are to be filled; must have a length <tt>&gt;= count+fromIndex</tt>.
0:  * @param fromIndex the first index within <tt>values</tt> to be filled with numbers (inclusive).
0:  * @param randomGenerator a random number generator. Set this parameter to <tt>null</tt> to use the default random number generator.
0:  */
0: public static void sample(long n, long N, int count, long low, long[] values, int fromIndex, RandomEngine randomGenerator) {
0: 	if (n<=0 || count<=0) return;
0: 	if (count>n) throw new IllegalArgumentException("count must not be greater than n");
0: 	if (randomGenerator==null) randomGenerator = org.apache.mahout.jet.random.AbstractDistribution.makeDefaultGenerator();
0: 
0: 	if (count==N) { // rare case treated quickly
0: 		long val = low;
0: 		int limit= fromIndex+count;
0: 		for (int i=fromIndex; i<limit; ) values[i++] = val++;
0: 		return;
0: 	} 
0: 
0: 	if (n<N*0.95) { // || Math.min(count,N-n)>maxTmpMemoryAllowed) {
0: 		sampleMethodD(n,N,count,low,values,fromIndex,randomGenerator);
0: 	}  
0: 	else { // More than 95% of all numbers shall be sampled.	
0: 		rejectMethodD(n,N,count,low,values,fromIndex,randomGenerator);
0: 	}
0: 	
0: 	
0: }
0: /**
0:  * Computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>.
0:  * Since we are talking about a random set, no element will occur more than once.
1:  *
0:  * <p>Running time is <tt>O(N)</tt>, on average. Space requirements are zero.
1:  *
0:  * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right.
0:  * The array is returned sorted ascending in the range filled with numbers.
1:  *
0:  * @param n the total number of elements to choose (must be &gt;= 0).
0:  * @param N the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
0:  * @param count the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
0:  * @param low the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
0:  * @param values the array into which the random numbers are to be filled; must have a length <tt>&gt;= count+fromIndex</tt>.
0:  * @param fromIndex the first index within <tt>values</tt> to be filled with numbers (inclusive).
0:  * @param randomGenerator a random number generator.
0:  */
0: protected static void sampleMethodA(long n, long N, int count, long low, long[] values, int fromIndex, RandomEngine randomGenerator) {
0: 	double V, quot, Nreal, top;
0: 	long S;
0: 	long chosen = -1+low;
0: 	
0: 	top = N-n;
0: 	Nreal = N;
0: 	while (n>=2 && count>0) {
0: 		V = randomGenerator.raw();
0: 		S = 0;
0: 		quot = top/Nreal;
0: 		while (quot > V) {
0: 			S++;
0: 			top--;
0: 			Nreal--;
0: 			quot = (quot*top)/Nreal;
0: 		}
0: 		chosen += S+1;
0: 		values[fromIndex++]=chosen;
0: 		count--;
0: 		Nreal--;
0: 		n--;
0: 	}
0: 
0: 	if (count>0) {
0: 		// special case n==1
0: 		S = (long) (Math.round(Nreal) * randomGenerator.raw());
0: 		chosen += S+1;
0: 		values[fromIndex]=chosen;
0: 	}
0: }
0: /**
0:  * Efficiently computes a sorted random set of <tt>count</tt> elements from the interval <tt>[low,low+N-1]</tt>.
0:  * Since we are talking about a random set, no element will occur more than once.
1:  *
0:  * <p>Running time is <tt>O(count)</tt>, on average. Space requirements are zero.
1:  *
0:  * <p>Numbers are filled into the specified array starting at index <tt>fromIndex</tt> to the right.
0:  * The array is returned sorted ascending in the range filled with numbers.
1:  *
0:  * @param n the total number of elements to choose (must be &gt;= 0).
0:  * @param N the interval to choose random numbers from is <tt>[low,low+N-1]</tt>.
0:  * @param count the number of elements to be filled into <tt>values</tt> by this call (must be &gt;= 0 and &lt;=<tt>n</tt>). Normally, you will set <tt>count=n</tt>.
0:  * @param low the interval to choose random numbers from is <tt>[low,low+N-1]</tt>. Hint: If <tt>low==0</tt>, then draws random numbers from the interval <tt>[0,N-1]</tt>.
0:  * @param values the array into which the random numbers are to be filled; must have a length <tt>&gt;= count+fromIndex</tt>.
0:  * @param fromIndex the first index within <tt>values</tt> to be filled with numbers (inclusive).
0:  * @param randomGenerator a random number generator.
0:  */
0: protected static void sampleMethodD(long n, long N, int count, long low, long[] values, int fromIndex, RandomEngine randomGenerator) {
0: 	double nreal, Nreal, ninv, nmin1inv, U, X, Vprime, y1, y2, top, bottom, negSreal, qu1real;
0: 	long qu1, threshold, t, limit;
0: 	long S;
0: 	long chosen = -1+low;
0: 	
0: 	long negalphainv = -13;  //tuning paramter, determines when to switch from method D to method A. Dependent on programming language, platform, etc.
0: 
0: 	nreal = n; ninv = 1.0/nreal; Nreal = N;
0: 	Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0: 	qu1 = -n + 1 + N; qu1real = -nreal + 1.0 + Nreal;
0: 	threshold = -negalphainv * n;
0: 	
0: 	while (n>1 && count>0 && threshold<N) {
0: 		nmin1inv = 1.0/(-1.0 + nreal);
0: 		for (;;) {
0: 			for (;;) { // step D2: generate U and X
0: 				X = Nreal * (-Vprime + 1.0); S = (long) X;
0: 				if (S<qu1) break;
0: 				Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0: 			}
0: 			U = randomGenerator.raw(); negSreal = -S;
0: 			
0: 			//step D3: Accept?
0: 			y1 = Math.exp(Math.log(U*Nreal/qu1real) * nmin1inv);
0: 			Vprime = y1*(-X/Nreal + 1.0) * (qu1real/(negSreal + qu1real));
0: 			if (Vprime <= 1.0) break; //break inner loop
0: 
0: 			//step D4: Accept?
0: 			y2 = 1.0; top = -1.0 + Nreal;
0: 			if (n-1>S) {
0: 				bottom = -nreal + Nreal; limit = -S+N;
0: 			}
0: 			else {
0: 				bottom = -1.0 + negSreal + Nreal; limit=qu1;
0: 			}
0: 			for (t=N-1; t>=limit; t--) {
0: 				y2 = (y2*top)/bottom;
0: 				top--;
0: 				bottom--;
0: 			}
0: 			if (Nreal/(-X+Nreal) >= y1*Math.exp(Math.log(y2)*nmin1inv)) {
0: 				// accept !
0: 				Vprime = Math.exp(Math.log(randomGenerator.raw())*nmin1inv);
0: 				break; //break inner loop
0: 			}
0: 			Vprime = Math.exp(Math.log(randomGenerator.raw())*ninv);
0: 		} //end for
0: 
0: 		//step D5: select the (S+1)st record !
0: 		chosen += S+1;
0: 		values[fromIndex++] = chosen;
0: 		/*
0: 		// invert
0: 		for (int iter=0; iter<S && count > 0; iter++) {
0: 			values[fromIndex++] = ++chosen;
0: 			count--;
0: 		}
0: 		chosen++;
0: 		*/
0: 		count--;
0: 
0: 		N -= S+1; Nreal=negSreal+(-1.0+Nreal);
0: 		n--; nreal--; ninv = nmin1inv;
0: 		qu1 = -S+qu1; qu1real = negSreal+qu1real;
0: 		threshold += negalphainv;
0: 	} //end while
0: 
0: 
0: 	if (count>0) {
0: 		if (n>1) { //faster to use method A to finish the sampling
0: 			sampleMethodA(n,N,count,chosen+1,values,fromIndex,randomGenerator);
0: 		}
0: 		else {
0: 			//special case n==1
0: 			S = (long) (N*Vprime);
0: 			chosen += S+1;
0: 			values[fromIndex++] = chosen;
0: 		}
0: 	}
0: }
0: /**
0:  * Tests the methods of this class.
0:  * To do benchmarking, comment the lines printing stuff to the console.
0:  */
0: public static void test(long n, long N, long low, int chunkSize, int times) {
0: 	long[] values = new long[chunkSize];
0: 	long chunks = n/chunkSize;
0: 	
0: 	org.apache.mahout.colt.Timer timer = new org.apache.mahout.colt.Timer().start();
0: 	for (long t=times; --t >=0;) {
0: 		RandomSampler sampler = new RandomSampler(n,N,low, org.apache.mahout.jet.random.AbstractDistribution.makeDefaultGenerator());
0: 		for (long i=0; i<chunks; i++) {
0: 			sampler.nextBlock(chunkSize,values,0);
0: 
0: 			/*
0: 			Log.print("Chunk #"+i+" = [");
0: 			for (int j=0; j<chunkSize-1; j++) Log.print(values[j]+", ");
0: 			Log.print(String.valueOf(values[chunkSize-1]));
0: 			Log.println("]");
0: 			*/
0: 			
0: 		}
0: 		
0: 		int toDo=(int) (n-chunkSize*chunks);
0: 		if (toDo > 0) { // sample remaining part, if necessary
0: 			sampler.nextBlock(toDo,values,0);	
0: 			
0: 			/*	
0: 			Log.print("Chunk #"+chunks+" = [");
0: 			for (int j=0; j<toDo-1; j++) Log.print(values[j]+", ");
0: 			Log.print(String.valueOf(values[toDo-1]));
0: 			Log.println("]");
0: 			*/
0: 			
0: 			
0: 		}
0: 	}
0: 	timer.stop();
0: 	System.out.println("single run took "+timer.elapsedTime()/times);
0: 	System.out.println("Good bye.\n");
0: }
0: /**
0:  * Tests different values for negaalphainv.
0:  * Result: J.S. Vitter's recommendation for negalphainv=-13 is also good in the JDK 1.2 environment.
0:  */
0: protected static void testNegAlphaInv(String args[]) {
0: 	/*
0: 	long N = Long.parseLong(args[0]);
0: 	int chunkSize = Integer.parseInt(args[1]);
0: 
0: 	long[] alphas = {-104, -52, -26, -13, -8, -4, -2};
0: 	for (int i=0; i<alphas.length; i++) {
0: 		negalphainv = alphas[i];
0: 		System.out.println("\n\nnegalphainv="+negalphainv);
0: 
0: 		System.out.print(" n="+N/80+" --> ");
0: 		test(N/80,N,0,chunkSize);
0: 
0: 		System.out.print(" n="+N/40+" --> ");
0: 		test(N/40,N,0,chunkSize);
0: 
0: 		System.out.print(" n="+N/20+" --> ");
0: 		test(N/20,N,0,chunkSize);
0: 
0: 		System.out.print(" n="+N/10+" --> ");
0: 		test(N/10,N,0,chunkSize);
0: 
0: 		System.out.print(" n="+N/5+" --> ");
0: 		test(N/5,N,0,chunkSize);
0: 
0: 		System.out.print(" n="+N/2+" --> ");
0: 		test(N/2,N,0,chunkSize);
0: 
0: 		System.out.print(" n="+(N-3)+" --> ");
0: 		test(N-3,N,0,chunkSize);
0: 	}
0: 	*/
0: }
0: }
============================================================================