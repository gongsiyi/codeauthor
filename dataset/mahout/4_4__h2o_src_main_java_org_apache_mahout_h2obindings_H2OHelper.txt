3:f870a63: /*
1:f870a63:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:f870a63:  *  contributor license agreements.  See the NOTICE file distributed with
1:f870a63:  *  this work for additional information regarding copyright ownership.
1:f870a63:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:f870a63:  *  (the "License"); you may not use this file except in compliance with
1:f870a63:  *  the License.  You may obtain a copy of the License at
1:f870a63:  *
1:f870a63:  *      http://www.apache.org/licenses/LICENSE-2.0
1:f870a63:  *
1:f870a63:  *  Unless required by applicable law or agreed to in writing, software
1:f870a63:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:f870a63:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f870a63:  *  See the License for the specific language governing permissions and
1:f870a63:  *  limitations under the License.
8:f870a63:  */
12:f870a63: 
1:f870a63: package org.apache.mahout.h2obindings;
1:f870a63: 
1:f870a63: import org.apache.mahout.math.Matrix;
1:f870a63: import org.apache.mahout.math.Vector;
1:f870a63: import org.apache.mahout.math.DenseMatrix;
1:f870a63: import org.apache.mahout.math.SparseMatrix;
1:f870a63: import org.apache.mahout.math.DenseVector;
1:f870a63: 
1:f870a63: import water.MRTask;
1:f870a63: import water.Futures;
1:f870a63: import water.fvec.Frame;
1:f870a63: import water.fvec.Vec;
1:f870a63: import water.fvec.Chunk;
1:f870a63: import water.parser.ValueString;
1:f870a63: import water.util.ArrayUtils;
1:f870a63: 
1:f870a63: import java.util.Map;
1:f870a63: import java.util.HashMap;
1:5924e16: import java.io.Serializable;
1:f870a63: 
1:f870a63: import org.apache.mahout.h2obindings.drm.H2ODrm;
1:5924e16: import org.apache.mahout.h2obindings.drm.H2OBCast;
1:f870a63: 
1:5197ac9: // for makeEmptyStrVec
1:5197ac9: import water.Key;
1:5197ac9: import water.DKV;
1:5197ac9: import water.fvec.CStrChunk;
1:5197ac9: 
1:5924e16: import scala.Function1;
1:5924e16: import scala.Function2;
1:5924e16: 
1:2d1b0bf: /**
1:2d1b0bf:  * Collection of helper methods for H2O backend.
1:2d1b0bf:  */
1:f870a63: public class H2OHelper {
1:2d1b0bf:   /**
1:2d1b0bf:    * Predicate to check if data is sparse in Frame.
1:2d1b0bf:    *
1:2d1b0bf:    * If the number of missing elements is 32x times the number of present
1:2d1b0bf:    * elements, consider it as sparse.
1:2d1b0bf:    *
1:2d1b0bf:    * @param frame Frame storing matrix data.
1:2d1b0bf:    * @return True if data is sparse in Frame.
1:2d1b0bf:    */
1:c964986:   public static boolean isSparse(Frame frame) {
1:f870a63:     long rows = frame.numRows();
1:f870a63:     long cols = frame.numCols();
1:f870a63: 
1:2d1b0bf:     /**
1:2d1b0bf:      * MRTask to aggregate precalculated per-chunk sparse lengths
1:2d1b0bf:      */
1:f870a63:     class MRTaskNZ extends MRTask<MRTaskNZ> {
1:f870a63:       long sparselen;
1:2d1b0bf:       @Override
1:f870a63:       public void map(Chunk chks[]) {
1:f870a63:         for (Chunk chk : chks) {
1:f870a63:           sparselen += chk.sparseLen();
2:f870a63:         }
1:f870a63:       }
1:2d1b0bf:       @Override
1:f870a63:       public void reduce(MRTaskNZ other) {
1:f870a63:         sparselen += other.sparselen;
1:f870a63:       }
1:f870a63:     }
1:f870a63: 
1:f870a63:     long sparselen = new MRTaskNZ().doAll(frame).sparselen;
1:f870a63: 
1:f870a63:     return (((rows * cols) / (sparselen + 1)) > 32);
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Create a Mahout Matrix from a DRM.
1:2d1b0bf:    *
1:2d1b0bf:    * Create either Sparse or Dense Matrix depending on number of missing
1:2d1b0bf:    * elements in DRM.
1:2d1b0bf:    *
1:2d1b0bf:    * @param drm DRM object to create Matrix from.
1:2d1b0bf:    * @return created Matrix.
1:2d1b0bf:    */
1:c964986:   public static Matrix matrixFromDrm(H2ODrm drm) {
1:f870a63:     Frame frame = drm.frame;
1:f870a63:     Vec labels = drm.keys;
1:f870a63:     Matrix m;
1:f870a63: 
1:c964986:     if (isSparse(frame)) {
1:f870a63:       m = new SparseMatrix((int)frame.numRows(), frame.numCols());
1:f870a63:     } else {
1:f870a63:       m = new DenseMatrix((int)frame.numRows(), frame.numCols());
1:f870a63:     }
1:f870a63: 
1:f870a63:     int c = 0;
1:2d1b0bf:     // Fill matrix, column at a time.
1:f870a63:     for (Vec v : frame.vecs()) {
1:f870a63:       for (int r = 0; r < frame.numRows(); r++) {
1:4ef9d31:         double d;
1:f870a63:         if (!v.isNA(r) && ((d = v.at(r)) != 0.0)) {
1:f870a63:           m.setQuick(r, c, d);
1:f870a63:         }
1:f870a63:       }
1:f870a63:       c++;
1:f870a63:     }
1:f870a63: 
1:2d1b0bf:     // If string keyed, set the stings as rowlabels.
1:f870a63:     if (labels != null) {
1:4ef9d31:       Map<String,Integer> map = new HashMap<>();
1:f870a63:       ValueString vstr = new ValueString();
1:f870a63:       for (long i = 0; i < labels.length(); i++) {
1:f870a63:         map.put(labels.atStr(vstr, i).toString(), (int)i);
1:f870a63:       }
1:f870a63:       m.setRowLabelBindings(map);
1:f870a63:     }
1:f870a63:     return m;
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Calculate Means of elements in a column, and return as a Vector.
1:2d1b0bf:    *
1:2d1b0bf:    * H2O precalculates means in a Vec, and a Vec corresponds to a column.
1:2d1b0bf:    *
1:2d1b0bf:    * @param frame Frame backing the H2O DRM.
1:2d1b0bf:    * @return Vector of pre-calculated means.
1:2d1b0bf:    */
1:f870a63:   public static Vector colMeans(Frame frame) {
1:f870a63:     double means[] = new double[frame.numCols()];
1:f870a63:     for (int i = 0; i < frame.numCols(); i++) {
1:f870a63:       means[i] = frame.vecs()[i].mean();
1:f870a63:     }
1:f870a63:     return new DenseVector(means);
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Calculate Sums of elements in a column, and return as a Vector.
1:2d1b0bf:    *
1:2d1b0bf:    * Run an MRTask Job to add up sums.
1:2d1b0bf:    * WARNING: Vulnerable to overflow. No way around it.
1:2d1b0bf:    *
1:2d1b0bf:    * @param frame Frame backing the H2O DRM.
1:2d1b0bf:    * @return Vector of calculated sums.
1:2d1b0bf:    */
1:f870a63:   public static Vector colSums(Frame frame) {
1:2d1b0bf:     /**
1:2d1b0bf:      * MRTask to calculate sums of elements in all columns.
1:2d1b0bf:      */
1:f870a63:     class MRTaskSum extends MRTask<MRTaskSum> {
1:f870a63:       public double sums[];
1:2d1b0bf:       @Override
1:f870a63:       public void map(Chunk chks[]) {
1:f870a63:         sums = new double[chks.length];
1:f870a63: 
2:f870a63:         for (int c = 0; c < chks.length; c++) {
2:f870a63:           for (int r = 0; r < chks[c].len(); r++) {
1:f5f54a1:             sums[c] += chks[c].atd(r);
1:f870a63:           }
1:f870a63:         }
1:f870a63:       }
1:2d1b0bf:       @Override
1:f870a63:       public void reduce(MRTaskSum other) {
1:f870a63:         ArrayUtils.add(sums, other.sums);
1:f870a63:       }
1:f870a63:     }
1:f870a63:     return new DenseVector(new MRTaskSum().doAll(frame).sums);
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Calculate Sum of squares of all elements in the DRM.
1:2d1b0bf:    *
1:2d1b0bf:    * Run an MRTask Job to add up sums of squares.
1:2d1b0bf:    * WARNING: Vulnerable to overflow. No way around it.
1:2d1b0bf:    *
1:2d1b0bf:    * @param frame Frame backing the H2O DRM.
1:2d1b0bf:    * @return Sum of squares of all elements in the DRM.
1:2d1b0bf:    */
1:f870a63:   public static double sumSqr(Frame frame) {
1:2d1b0bf:     /**
1:2d1b0bf:      * MRTask to calculate sums of squares of all elements.
1:2d1b0bf:      */
1:f870a63:     class MRTaskSumSqr extends MRTask<MRTaskSumSqr> {
1:f870a63:       public double sumSqr;
1:2d1b0bf:       @Override
1:f870a63:       public void map(Chunk chks[]) {
1:4ef9d31:         for (Chunk chk : chks) {
1:4ef9d31:           for (int r = 0; r < chk.len(); r++) {
1:4ef9d31:             sumSqr += (chk.atd(r) * chk.atd(r));
1:f870a63:           }
1:f870a63:         }
1:f870a63:       }
1:2d1b0bf:       @Override
1:f870a63:       public void reduce(MRTaskSumSqr other) {
1:f870a63:         sumSqr += other.sumSqr;
1:f870a63:       }
1:f870a63:     }
1:f870a63:     return new MRTaskSumSqr().doAll(frame).sumSqr;
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Count non-zero elements in all columns, and return as a Vector.
1:2d1b0bf:    *
1:2d1b0bf:    * Run an MRTask Job to count non-zero elements per column.
1:2d1b0bf:    *
1:2d1b0bf:    * @param frame Frame backing the H2O DRM.
1:2d1b0bf:    * @return Vector of counted non-zero elements.
1:2d1b0bf:    */
1:f870a63:   public static Vector nonZeroCnt(Frame frame) {
1:2d1b0bf:     /**
1:2d1b0bf:      * MRTask to count all non-zero elements.
1:2d1b0bf:      */
1:f870a63:     class MRTaskNonZero extends MRTask<MRTaskNonZero> {
1:f870a63:       public double sums[];
1:2d1b0bf:       @Override
1:f870a63:       public void map(Chunk chks[]) {
1:f870a63:         sums = new double[chks.length];
1:f870a63: 
1:f870a63:         for (int c = 0; c < chks.length; c++) {
1:f870a63:           for (int r = 0; r < chks[c].len(); r++) {
1:f5f54a1:             if ((long)chks[c].atd(r) != 0) {
1:f870a63:               sums[c] ++;
1:f870a63:             }
1:f870a63:           }
1:f870a63:         }
1:f870a63:       }
1:2d1b0bf:       @Override
1:f870a63:       public void reduce(MRTaskNonZero other) {
1:f870a63:         ArrayUtils.add(sums, other.sums);
1:f870a63:       }
1:f870a63:     }
1:f870a63:     return new DenseVector(new MRTaskNonZero().doAll(frame).sums);
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /** Convert String->Integer map to Integer->String map */
1:c964986:   private static Map<Integer,String> reverseMap(Map<String, Integer> map) {
1:f870a63:     if (map == null) {
1:f870a63:       return null;
1:f870a63:     }
1:f870a63: 
1:4ef9d31:     Map<Integer,String> rmap = new HashMap<>();
1:f870a63: 
1:f870a63:     for(Map.Entry<String,Integer> entry : map.entrySet()) {
1:f870a63:       rmap.put(entry.getValue(),entry.getKey());
1:f870a63:     }
1:f870a63: 
1:f870a63:     return rmap;
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Calculate optimum chunk size for given parameters.
1:2d1b0bf:    *
1:2d1b0bf:    * Chunk size is the number of elements stored per partition per column.
1:2d1b0bf:    *
1:2d1b0bf:    * @param nrow Number of rows in the DRM.
1:2d1b0bf:    * @param minHint Minimum number of partitions to create, if passed value is not -1.
1:2d1b0bf:    * @param exactHint Exact number of partitions to create, if passed value is not -1.
1:2d1b0bf:    * @return Calculated optimum chunk size.
1:2d1b0bf:    */
1:4ef9d31:   private static int chunkSize(long nrow, int minHint, int exactHint) {
1:2d1b0bf:     int chunkSz;
1:2d1b0bf:     int partsHint = Math.max(minHint, exactHint);
1:f870a63: 
1:2d1b0bf:     if (partsHint < 1) {
1:f870a63:       /* XXX: calculate based on cloud size and # of cpu */
1:2d1b0bf:       partsHint = 4;
1:f870a63:     }
1:f870a63: 
1:2d1b0bf:     chunkSz = (int)(((nrow - 1) / partsHint) + 1);
1:2d1b0bf:     if (exactHint > 0) {
1:2d1b0bf:       return chunkSz;
1:f870a63:     }
1:f870a63: 
1:2d1b0bf:     if (chunkSz > 1e6) {
1:2d1b0bf:       chunkSz = (int)1e6;
1:f870a63:     }
1:f870a63: 
1:2d1b0bf:     if (minHint > 0) {
1:2d1b0bf:       return chunkSz;
1:f870a63:     }
1:f870a63: 
1:2d1b0bf:     if (chunkSz < 1e3) {
1:2d1b0bf:       chunkSz = (int)1e3;
1:f870a63:     }
1:f870a63: 
1:2d1b0bf:     return chunkSz;
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Ingest a Mahout Matrix into an H2O DRM.
1:2d1b0bf:    *
1:2d1b0bf:    * Frame is the backing data structure behind CheckpointedDrm.
1:2d1b0bf:    *
1:2d1b0bf:    * @param m Mahout Matrix to ingest data from.
1:2d1b0bf:    * @param minHint Hint for minimum number of partitions in created DRM.
1:2d1b0bf:    * @param exactHint Hint for exact number of partitions in created DRM.
1:2d1b0bf:    * @return Created H2O backed DRM.
1:2d1b0bf:    */
1:2d1b0bf:   public static H2ODrm drmFromMatrix(Matrix m, int minHint, int exactHint) {
1:2d1b0bf:     // First create an empty (0-filled) frame of the required dimensions
1:2d1b0bf:     Frame frame = emptyFrame(m.rowSize(), m.columnSize(), minHint, exactHint);
1:f870a63:     Vec labels = null;
1:f870a63:     Vec.Writer writers[] = new Vec.Writer[m.columnSize()];
1:f870a63:     Futures closer = new Futures();
1:f870a63: 
1:2d1b0bf:     // "open" vectors for writing efficiently in bulk
1:f870a63:     for (int i = 0; i < writers.length; i++) {
1:f870a63:       writers[i] = frame.vecs()[i].open();
1:f870a63:     }
1:f870a63: 
1:f870a63:     for (int r = 0; r < m.rowSize(); r++) {
1:f870a63:       for (int c = 0; c < m.columnSize(); c++) {
1:f870a63:         writers[c].set(r, m.getQuick(r, c));
1:f870a63:       }
1:f870a63:     }
1:f870a63: 
1:f870a63:     for (int c = 0; c < m.columnSize(); c++) {
1:f870a63:       writers[c].close(closer);
1:f870a63:     }
1:2d1b0bf:     // If string labeled matrix, create aux Vec
1:f870a63:     Map<String,Integer> map = m.getRowLabelBindings();
1:f870a63:     if (map != null) {
1:2d1b0bf:       // label vector must be similarly partitioned like the Frame
1:5197ac9:       labels = makeEmptyStrVec(frame.anyVec());
1:f870a63:       Vec.Writer writer = labels.open();
1:c964986:       Map<Integer,String> rmap = reverseMap(map);
1:3105343:       for (int r = 0; r < m.rowSize(); r++) {
1:f870a63:         writer.set(r, rmap.get(r));
1:f870a63:       }
1:f870a63: 
1:f870a63:       writer.close(closer);
1:f870a63:     }
1:f870a63: 
1:f870a63:     closer.blockForPending();
1:f870a63: 
1:f870a63:     return new H2ODrm(frame, labels);
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Create an empty (zero-filled) H2O Frame efficiently.
1:2d1b0bf:    *
1:2d1b0bf:    * Create a zero filled Frame with specified cardinality.
1:2d1b0bf:    * Do not actually fill zeroes in each cell, create pre-compressed chunks.
1:2d1b0bf:    * Time taken per column asymptotically at O(nChunks), not O(nrow).
1:2d1b0bf:    *
1:2d1b0bf:    * @param nrow Number of rows in the Frame.
1:2d1b0bf:    * @param ncol Number of columns in the Frame.
1:2d1b0bf:    * @param minHint Hint for minimum number of chunks per column in created Frame.
1:2d1b0bf:    * @param exactHint Hint for exact number of chunks per column in created Frame.
1:2d1b0bf:    * @return Created Frame.
1:2d1b0bf:    */
1:2d1b0bf:   public static Frame emptyFrame(long nrow, int ncol, int minHint, int exactHint) {
1:f870a63:     Vec.VectorGroup vg = new Vec.VectorGroup();
1:f870a63: 
1:2d1b0bf:     return emptyFrame(nrow, ncol, minHint, exactHint, vg);
1:f870a63:   }
1:f870a63: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Create an empty (zero-filled) H2O Frame efficiently.
1:2d1b0bf:    *
1:2d1b0bf:    * Create a zero filled Frame with specified cardinality.
1:2d1b0bf:    * Do not actually fill zeroes in each cell, create pre-compressed chunks.
1:2d1b0bf:    * Time taken per column asymptotically at O(nChunks), not O(nrow).
1:2d1b0bf:    *
1:2d1b0bf:    * @param nrow Number of rows in the Frame.
1:2d1b0bf:    * @param ncol Number of columns in the Frame.
1:2d1b0bf:    * @param minHint Hint for minimum number of chunks per column in created Frame.
1:2d1b0bf:    * @param exactHint Hint for exact number of chunks per column in created Frame.
1:2d1b0bf:    * @param vg Shared VectorGroup so that all columns are similarly partitioned.
1:2d1b0bf:    * @return Created Frame.
1:2d1b0bf:    */
1:2d1b0bf:   public static Frame emptyFrame(long nrow, int ncol, int minHint, int exactHint, Vec.VectorGroup vg) {
1:4ef9d31:     int chunkSz = chunkSize(nrow, minHint, exactHint);
1:2d1b0bf:     int nchunks = (int)((nrow - 1) / chunkSz) + 1; // Final number of Chunks per Vec
1:f870a63:     long espc[] = new long[nchunks + 1];
1:f870a63: 
1:f870a63:     for (int i = 0; i < nchunks; i++) {
1:2d1b0bf:       espc[i] = i * chunkSz;
1:f870a63:     }
1:f870a63:     espc[nchunks] = nrow;
1:c3936fd:     // Create a vector template for new vectors
1:c3936fd:     Vec vtemplate = new Vec(vg.addVec(), espc);
1:c3936fd:     // Make ncol-numeric vectors
1:c3936fd:     Vec[] vecs = vtemplate.makeCons(ncol, 0, null, null);
1:f870a63: 
1:f870a63:     return new Frame(vecs);
1:f870a63:   }
1:5197ac9: 
1:f870a63: 
1:5197ac9:   /**
1:5197ac9:    * The following two methods: vecChunkLen and makeEmptyStrVec
1:5197ac9:    * are h2o-0.1.25 specific.
1:5197ac9:    */
1:5197ac9:   public static Vec makeEmptyStrVec(final Vec template) {
1:5197ac9:     final int nChunks = template.nChunks();
1:5197ac9:     Key<Vec> key = template.group().addVec();
1:5197ac9:     final Vec emptystr = new Vec(key, template._espc, null, Vec.T_NUM);
1:5197ac9: 
1:5197ac9:     new MRTask() {
1:5197ac9:       @Override protected void setupLocal() {
1:5197ac9:         for (int i = 0; i < nChunks; i++) {
1:5197ac9:           Key k = emptystr.chunkKey(i);
1:5197ac9:           int chklen = vecChunkLen(template, i);
1:5197ac9:           int stridx[] = new int[chklen];
1:5197ac9:           byte b[] = new byte[1]; b[0] = 0;
1:5197ac9:           for (int j = 0; j < chklen; j++) stridx[j] = -1;
1:5197ac9:           if (k.home()) DKV.put(k, new CStrChunk(1, b, chklen, stridx), _fs);
1:5197ac9:         }
1:5197ac9:         if (emptystr._key.home()) DKV.put(emptystr._key, emptystr, _fs);
1:5197ac9:       }
1:5197ac9:     }.doAllNodes();
1:5197ac9:     return emptystr;
1:5197ac9:   }
1:5197ac9: 
1:5197ac9:   public static int vecChunkLen(Vec template, int chunk) {
1:5197ac9:     return (int) (template._espc[chunk + 1] - template._espc[chunk]);
1:5197ac9:   }
1:5197ac9: 
1:2d1b0bf:   /**
1:2d1b0bf:    * Create an empty (zero-filled) H2O DRM.
1:2d1b0bf:    *
1:2d1b0bf:    * Create a zero filled DRM with specified cardinality.
1:2d1b0bf:    * Use the efficient emptyFrame() method internally.
1:2d1b0bf:    *
1:2d1b0bf:    * @param nrow Number of rows in the Frame.
1:2d1b0bf:    * @param ncol Number of columns in the Frame.
1:2d1b0bf:    * @param minHint Hint for minimum number of chunks per column in created Frame.
1:2d1b0bf:    * @param exactHint Hint for exact number of chunks per column in created Frame.
1:2d1b0bf:    * @return Created DRM.
1:2d1b0bf:    */
1:2d1b0bf:   public static H2ODrm emptyDrm(long nrow, int ncol, int minHint, int exactHint) {
1:2d1b0bf:     return new H2ODrm(emptyFrame(nrow, ncol, minHint, exactHint));
1:f870a63:   }
1:5924e16: 
1:5924e16:   public static Matrix allreduceBlock(H2ODrm drmA, Object bmfn, Object rfn) {
1:5924e16:     class MRTaskMR extends MRTask<MRTaskMR> {
1:5924e16:       H2OBCast<Matrix> bmf_out;
1:5924e16:       Serializable bmf;
1:5924e16:       Serializable rf;
1:5924e16: 
1:5924e16:       public MRTaskMR(Object _bmf, Object _rf) {
1:5924e16:         bmf = (Serializable) _bmf;
1:5924e16:         rf = (Serializable) _rf;
1:5924e16:       }
1:5924e16: 
1:5924e16:       @Override
1:5924e16:       public void map(Chunk chks[]) {
1:5924e16:         Function1 f = (Function1) bmf;
1:5924e16:         bmf_out = new H2OBCast((Matrix)f.apply(new scala.Tuple2(null, new H2OBlockMatrix(chks))));
1:5924e16:       }
1:5924e16: 
1:5924e16:       @Override
1:5924e16:       public void reduce(MRTaskMR that) {
1:5924e16:         Function2 f = (Function2) rf;
1:5924e16:         bmf_out = new H2OBCast((Matrix)f.apply(this.bmf_out.value(), that.bmf_out.value()));
1:5924e16:       }
1:5924e16:     }
1:5924e16: 
1:5924e16:     return new MRTaskMR(bmfn, rfn).doAll(drmA.frame).bmf_out.value();
1:5924e16:   }
1:f870a63: }
============================================================================
author:Anand Avati
-------------------------------------------------------------------------------
commit:5924e16
/////////////////////////////////////////////////////////////////////////
1: import java.io.Serializable;
1: import org.apache.mahout.h2obindings.drm.H2OBCast;
1: import scala.Function1;
1: import scala.Function2;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:   public static Matrix allreduceBlock(H2ODrm drmA, Object bmfn, Object rfn) {
1:     class MRTaskMR extends MRTask<MRTaskMR> {
1:       H2OBCast<Matrix> bmf_out;
1:       Serializable bmf;
1:       Serializable rf;
1: 
1:       public MRTaskMR(Object _bmf, Object _rf) {
1:         bmf = (Serializable) _bmf;
1:         rf = (Serializable) _rf;
1:       }
1: 
1:       @Override
1:       public void map(Chunk chks[]) {
1:         Function1 f = (Function1) bmf;
1:         bmf_out = new H2OBCast((Matrix)f.apply(new scala.Tuple2(null, new H2OBlockMatrix(chks))));
1:       }
1: 
1:       @Override
1:       public void reduce(MRTaskMR that) {
1:         Function2 f = (Function2) rf;
1:         bmf_out = new H2OBCast((Matrix)f.apply(this.bmf_out.value(), that.bmf_out.value()));
1:       }
1:     }
1: 
1:     return new MRTaskMR(bmfn, rfn).doAll(drmA.frame).bmf_out.value();
1:   }
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:4ef9d31
/////////////////////////////////////////////////////////////////////////
1:         double d;
/////////////////////////////////////////////////////////////////////////
1:       Map<String,Integer> map = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         for (Chunk chk : chks) {
1:           for (int r = 0; r < chk.len(); r++) {
1:             sumSqr += (chk.atd(r) * chk.atd(r));
/////////////////////////////////////////////////////////////////////////
1:     Map<Integer,String> rmap = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:   private static int chunkSize(long nrow, int minHint, int exactHint) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     int chunkSz = chunkSize(nrow, minHint, exactHint);
author:Andrew Palumbo
-------------------------------------------------------------------------------
commit:5197ac9
/////////////////////////////////////////////////////////////////////////
1: // for makeEmptyStrVec
1: import water.Key;
1: import water.DKV;
1: import water.fvec.CStrChunk;
1: 
/////////////////////////////////////////////////////////////////////////
1:       labels = makeEmptyStrVec(frame.anyVec());
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * The following two methods: vecChunkLen and makeEmptyStrVec
1:    * are h2o-0.1.25 specific.
1:    */
1:   public static Vec makeEmptyStrVec(final Vec template) {
1:     final int nChunks = template.nChunks();
1:     Key<Vec> key = template.group().addVec();
1:     final Vec emptystr = new Vec(key, template._espc, null, Vec.T_NUM);
1: 
1:     new MRTask() {
1:       @Override protected void setupLocal() {
1:         for (int i = 0; i < nChunks; i++) {
1:           Key k = emptystr.chunkKey(i);
1:           int chklen = vecChunkLen(template, i);
1:           int stridx[] = new int[chklen];
1:           byte b[] = new byte[1]; b[0] = 0;
1:           for (int j = 0; j < chklen; j++) stridx[j] = -1;
1:           if (k.home()) DKV.put(k, new CStrChunk(1, b, chklen, stridx), _fs);
1:         }
1:         if (emptystr._key.home()) DKV.put(emptystr._key, emptystr, _fs);
1:       }
1:     }.doAllNodes();
1:     return emptystr;
1:   }
1: 
1:   public static int vecChunkLen(Vec template, int chunk) {
1:     return (int) (template._espc[chunk + 1] - template._espc[chunk]);
1:   }
1: 
commit:c3936fd
/////////////////////////////////////////////////////////////////////////
1:     // Create a vector template for new vectors
1:     Vec vtemplate = new Vec(vg.addVec(), espc);
1:     // Make ncol-numeric vectors
1:     Vec[] vecs = vtemplate.makeCons(ncol, 0, null, null);
commit:3105343
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       for (int r = 0; r < m.rowSize(); r++) {
0:         // TODO: fix bug here... Exception is being thrown when setting Strings
commit:2d1b0bf
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Collection of helper methods for H2O backend.
1:  */
1:   /**
1:    * Predicate to check if data is sparse in Frame.
1:    *
1:    * If the number of missing elements is 32x times the number of present
1:    * elements, consider it as sparse.
1:    *
1:    * @param frame Frame storing matrix data.
1:    * @return True if data is sparse in Frame.
1:    */
1:     /**
1:      * MRTask to aggregate precalculated per-chunk sparse lengths
1:      */
1:       @Override
1:       @Override
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Create a Mahout Matrix from a DRM.
1:    *
1:    * Create either Sparse or Dense Matrix depending on number of missing
1:    * elements in DRM.
1:    *
1:    * @param drm DRM object to create Matrix from.
1:    * @return created Matrix.
1:    */
/////////////////////////////////////////////////////////////////////////
1:     // Fill matrix, column at a time.
/////////////////////////////////////////////////////////////////////////
1:     // If string keyed, set the stings as rowlabels.
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Calculate Means of elements in a column, and return as a Vector.
1:    *
1:    * H2O precalculates means in a Vec, and a Vec corresponds to a column.
1:    *
1:    * @param frame Frame backing the H2O DRM.
1:    * @return Vector of pre-calculated means.
1:    */
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Calculate Sums of elements in a column, and return as a Vector.
1:    *
1:    * Run an MRTask Job to add up sums.
1:    * WARNING: Vulnerable to overflow. No way around it.
1:    *
1:    * @param frame Frame backing the H2O DRM.
1:    * @return Vector of calculated sums.
1:    */
1:     /**
1:      * MRTask to calculate sums of elements in all columns.
1:      */
1:       @Override
/////////////////////////////////////////////////////////////////////////
1:       @Override
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Calculate Sum of squares of all elements in the DRM.
1:    *
1:    * Run an MRTask Job to add up sums of squares.
1:    * WARNING: Vulnerable to overflow. No way around it.
1:    *
1:    * @param frame Frame backing the H2O DRM.
1:    * @return Sum of squares of all elements in the DRM.
1:    */
1:     /**
1:      * MRTask to calculate sums of squares of all elements.
1:      */
1:       @Override
/////////////////////////////////////////////////////////////////////////
1:       @Override
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Count non-zero elements in all columns, and return as a Vector.
1:    *
1:    * Run an MRTask Job to count non-zero elements per column.
1:    *
1:    * @param frame Frame backing the H2O DRM.
1:    * @return Vector of counted non-zero elements.
1:    */
1:     /**
1:      * MRTask to count all non-zero elements.
1:      */
1:       @Override
/////////////////////////////////////////////////////////////////////////
1:       @Override
/////////////////////////////////////////////////////////////////////////
1:   /** Convert String->Integer map to Integer->String map */
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Calculate optimum chunk size for given parameters.
1:    *
1:    * Chunk size is the number of elements stored per partition per column.
1:    *
1:    * @param nrow Number of rows in the DRM.
0:    * @param ncol Number of columns in the DRM.
1:    * @param minHint Minimum number of partitions to create, if passed value is not -1.
1:    * @param exactHint Exact number of partitions to create, if passed value is not -1.
1:    * @return Calculated optimum chunk size.
1:    */
0:   private static int chunkSize(long nrow, int ncol, int minHint, int exactHint) {
1:     int chunkSz;
1:     int partsHint = Math.max(minHint, exactHint);
1:     if (partsHint < 1) {
1:       partsHint = 4;
1:     chunkSz = (int)(((nrow - 1) / partsHint) + 1);
1:     if (exactHint > 0) {
1:       return chunkSz;
1:     if (chunkSz > 1e6) {
1:       chunkSz = (int)1e6;
1:     if (minHint > 0) {
1:       return chunkSz;
1:     if (chunkSz < 1e3) {
1:       chunkSz = (int)1e3;
1:     return chunkSz;
1:   /**
1:    * Ingest a Mahout Matrix into an H2O DRM.
1:    *
1:    * Frame is the backing data structure behind CheckpointedDrm.
1:    *
1:    * @param m Mahout Matrix to ingest data from.
1:    * @param minHint Hint for minimum number of partitions in created DRM.
1:    * @param exactHint Hint for exact number of partitions in created DRM.
1:    * @return Created H2O backed DRM.
1:    */
1:   public static H2ODrm drmFromMatrix(Matrix m, int minHint, int exactHint) {
1:     // First create an empty (0-filled) frame of the required dimensions
1:     Frame frame = emptyFrame(m.rowSize(), m.columnSize(), minHint, exactHint);
1:     // "open" vectors for writing efficiently in bulk
/////////////////////////////////////////////////////////////////////////
1:     // If string labeled matrix, create aux Vec
1:       // label vector must be similarly partitioned like the Frame
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Create an empty (zero-filled) H2O Frame efficiently.
1:    *
1:    * Create a zero filled Frame with specified cardinality.
1:    * Do not actually fill zeroes in each cell, create pre-compressed chunks.
1:    * Time taken per column asymptotically at O(nChunks), not O(nrow).
1:    *
1:    * @param nrow Number of rows in the Frame.
1:    * @param ncol Number of columns in the Frame.
1:    * @param minHint Hint for minimum number of chunks per column in created Frame.
1:    * @param exactHint Hint for exact number of chunks per column in created Frame.
1:    * @return Created Frame.
1:    */
1:   public static Frame emptyFrame(long nrow, int ncol, int minHint, int exactHint) {
1:     return emptyFrame(nrow, ncol, minHint, exactHint, vg);
1:   /**
1:    * Create an empty (zero-filled) H2O Frame efficiently.
1:    *
1:    * Create a zero filled Frame with specified cardinality.
1:    * Do not actually fill zeroes in each cell, create pre-compressed chunks.
1:    * Time taken per column asymptotically at O(nChunks), not O(nrow).
1:    *
1:    * @param nrow Number of rows in the Frame.
1:    * @param ncol Number of columns in the Frame.
1:    * @param minHint Hint for minimum number of chunks per column in created Frame.
1:    * @param exactHint Hint for exact number of chunks per column in created Frame.
1:    * @param vg Shared VectorGroup so that all columns are similarly partitioned.
1:    * @return Created Frame.
1:    */
1:   public static Frame emptyFrame(long nrow, int ncol, int minHint, int exactHint, Vec.VectorGroup vg) {
0:     int chunkSz = chunkSize(nrow, ncol, minHint, exactHint);
1:     int nchunks = (int)((nrow - 1) / chunkSz) + 1; // Final number of Chunks per Vec
1:       espc[i] = i * chunkSz;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Create an empty (zero-filled) H2O DRM.
1:    *
1:    * Create a zero filled DRM with specified cardinality.
1:    * Use the efficient emptyFrame() method internally.
1:    *
1:    * @param nrow Number of rows in the Frame.
1:    * @param ncol Number of columns in the Frame.
1:    * @param minHint Hint for minimum number of chunks per column in created Frame.
1:    * @param exactHint Hint for exact number of chunks per column in created Frame.
1:    * @return Created DRM.
1:    */
1:   public static H2ODrm emptyDrm(long nrow, int ncol, int minHint, int exactHint) {
1:     return new H2ODrm(emptyFrame(nrow, ncol, minHint, exactHint));
commit:c964986
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   public static boolean isSparse(Frame frame) {
/////////////////////////////////////////////////////////////////////////
1:   public static Matrix matrixFromDrm(H2ODrm drm) {
1:     if (isSparse(frame)) {
/////////////////////////////////////////////////////////////////////////
1:   private static Map<Integer,String> reverseMap(Map<String, Integer> map) {
/////////////////////////////////////////////////////////////////////////
0:   private static int chunkSize(long nrow, int ncol, int min, int exact) {
/////////////////////////////////////////////////////////////////////////
0:   public static H2ODrm drmFromMatrix(Matrix m, int min_hint, int exact_hint) {
0:     Frame frame = emptyFrame(m.rowSize(), m.columnSize(), min_hint, exact_hint);
/////////////////////////////////////////////////////////////////////////
1:       Map<Integer,String> rmap = reverseMap(map);
/////////////////////////////////////////////////////////////////////////
0:   public static Frame emptyFrame(long nrow, int ncol, int min_hint, int exact_hint) {
0:     return emptyFrame(nrow, ncol, min_hint, exact_hint, vg);
0:   public static Frame emptyFrame(long nrow, int ncol, int min_hint, int exact_hint, Vec.VectorGroup vg) {
0:     int chunk_sz = chunkSize(nrow, ncol, min_hint, exact_hint);
/////////////////////////////////////////////////////////////////////////
0:   public static H2ODrm emptyDrm(long nrow, int ncol, int min_hint, int exact_hint) {
0:     return new H2ODrm(emptyFrame(nrow, ncol, min_hint, exact_hint));
commit:f870a63
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
1: 
1: package org.apache.mahout.h2obindings;
1: 
1: import org.apache.mahout.math.Matrix;
1: import org.apache.mahout.math.Vector;
1: import org.apache.mahout.math.DenseMatrix;
1: import org.apache.mahout.math.SparseMatrix;
1: import org.apache.mahout.math.DenseVector;
1: 
1: import water.MRTask;
1: import water.Futures;
1: import water.fvec.Frame;
1: import water.fvec.Vec;
1: import water.fvec.Chunk;
1: import water.parser.ValueString;
1: import water.util.ArrayUtils;
1: 
0: import java.io.File;
0: import java.io.IOException;
1: import java.util.Map;
1: import java.util.HashMap;
0: import java.util.Arrays;
1: 
1: import org.apache.mahout.h2obindings.drm.H2ODrm;
1: 
1: public class H2OHelper {
1: 
1:   /*
0:     Is the matrix sparse? If the number of missing elements is
0:     32 x times the number of present elements, treat it as sparse
1:   */
0:   public static boolean is_sparse(Frame frame) {
1:     long rows = frame.numRows();
1:     long cols = frame.numCols();
1: 
0:     /* MRTask to aggregate precalculated per-chunk sparse lengths */
1:     class MRTaskNZ extends MRTask<MRTaskNZ> {
1:       long sparselen;
1:       public void map(Chunk chks[]) {
1:         for (Chunk chk : chks) {
1:           sparselen += chk.sparseLen();
1:         }
1:       }
1:       public void reduce(MRTaskNZ other) {
1:         sparselen += other.sparselen;
1:       }
1:     }
1: 
1:     long sparselen = new MRTaskNZ().doAll(frame).sparselen;
1: 
1:     return (((rows * cols) / (sparselen + 1)) > 32);
1:   }
1: 
1:   /*
0:     Extract a Matrix from a Frame. Create either Sparse or
0:     Dense Matrix depending on number of missing elements
0:     in Frame.
1:   */
0:   public static Matrix matrix_from_drm(H2ODrm drm) {
1:     Frame frame = drm.frame;
1:     Vec labels = drm.keys;
1:     Matrix m;
1: 
0:     if (is_sparse(frame)) {
1:       m = new SparseMatrix((int)frame.numRows(), frame.numCols());
1:     } else {
1:       m = new DenseMatrix((int)frame.numRows(), frame.numCols());
1:     }
1: 
1:     int c = 0;
0:     /* Fill matrix, column at a time */
1:     for (Vec v : frame.vecs()) {
1:       for (int r = 0; r < frame.numRows(); r++) {
0:         double d = 0.0;
1:         if (!v.isNA(r) && ((d = v.at(r)) != 0.0)) {
1:           m.setQuick(r, c, d);
1:         }
1:       }
1:       c++;
1:     }
1: 
0:     /* If string keyed, set the stings as rowlabels */
1:     if (labels != null) {
0:       HashMap<String,Integer> map = new HashMap<String,Integer>();
1:       ValueString vstr = new ValueString();
1:       for (long i = 0; i < labels.length(); i++) {
1:         map.put(labels.atStr(vstr, i).toString(), (int)i);
1:       }
1:       m.setRowLabelBindings(map);
1:     }
1:     return m;
1:   }
1: 
0:   /* Calculate Means of elements in a column, and return
0:      as a vector.
1: 
0:      H2O precalculates means in a Vec, and a Vec corresponds
0:      to a column.
1:   */
1:   public static Vector colMeans(Frame frame) {
1:     double means[] = new double[frame.numCols()];
1:     for (int i = 0; i < frame.numCols(); i++) {
1:       means[i] = frame.vecs()[i].mean();
1:     }
1:     return new DenseVector(means);
1:   }
1: 
0:   /* Calculate Sum of all elements in a column, and
0:      return as a Vector
1: 
0:      Run an MRTask Job to add up sums in @_sums
1: 
0:      WARNING: Vulnerable to overflow. No way around it.
1:   */
1:   public static Vector colSums(Frame frame) {
1:     class MRTaskSum extends MRTask<MRTaskSum> {
1:       public double sums[];
1:       public void map(Chunk chks[]) {
1:         sums = new double[chks.length];
1: 
1:         for (int c = 0; c < chks.length; c++) {
1:           for (int r = 0; r < chks[c].len(); r++) {
0:             sums[c] += chks[c].at0(r);
1:           }
1:         }
1:       }
1:       public void reduce(MRTaskSum other) {
1:         ArrayUtils.add(sums, other.sums);
1:       }
1:     }
1:     return new DenseVector(new MRTaskSum().doAll(frame).sums);
1:   }
1: 
1: 
0:   /* Calculate Sum of squares of all elements in the Matrix
1: 
0:      WARNING: Vulnerable to overflow. No way around it.
1:   */
1:   public static double sumSqr(Frame frame) {
1:     class MRTaskSumSqr extends MRTask<MRTaskSumSqr> {
1:       public double sumSqr;
1:       public void map(Chunk chks[]) {
1:         for (int c = 0; c < chks.length; c++) {
1:           for (int r = 0; r < chks[c].len(); r++) {
0:             sumSqr += (chks[c].at0(r) * chks[c].at0(r));
1:           }
1:         }
1:       }
1:       public void reduce(MRTaskSumSqr other) {
1:         sumSqr += other.sumSqr;
1:       }
1:     }
1:     return new MRTaskSumSqr().doAll(frame).sumSqr;
1:   }
1: 
0:   /* Calculate Sum of all elements in a column, and
0:      return as a Vector
1: 
0:      Run an MRTask Job to add up sums in @_sums
1: 
0:      WARNING: Vulnerable to overflow. No way around it.
1:   */
1:   public static Vector nonZeroCnt(Frame frame) {
1:     class MRTaskNonZero extends MRTask<MRTaskNonZero> {
1:       public double sums[];
1:       public void map(Chunk chks[]) {
1:         sums = new double[chks.length];
1: 
1:         for (int c = 0; c < chks.length; c++) {
1:           for (int r = 0; r < chks[c].len(); r++) {
0:             if ((long)chks[c].at0(r) != 0) {
1:               sums[c] ++;
1:             }
1:           }
1:         }
1:       }
1:       public void reduce(MRTaskNonZero other) {
1:         ArrayUtils.add(sums, other.sums);
1:       }
1:     }
1:     return new DenseVector(new MRTaskNonZero().doAll(frame).sums);
1:   }
1: 
0:   /* Convert String->Integer map to Integer->String map */
0:   private static Map<Integer,String> reverse_map(Map<String,Integer> map) {
1:     if (map == null) {
1:       return null;
1:     }
1: 
0:     Map<Integer,String> rmap = new HashMap<Integer,String>();
1: 
1:     for(Map.Entry<String,Integer> entry : map.entrySet()) {
1:       rmap.put(entry.getValue(),entry.getKey());
1:     }
1: 
1:     return rmap;
1:   }
1: 
0:   private static int chunk_size(long nrow, int ncol, int min, int exact) {
0:     int chunk_sz;
0:     int parts_hint = Math.max(min, exact);
1: 
0:     if (parts_hint < 1) {
1:       /* XXX: calculate based on cloud size and # of cpu */
0:       parts_hint = 4;
1:     }
1: 
0:     chunk_sz = (int)(((nrow - 1) / parts_hint) + 1);
0:     if (exact > 0) {
0:       return chunk_sz;
1:     }
1: 
0:     if (chunk_sz > 1e6) {
0:       chunk_sz = (int)1e6;
1:     }
1: 
0:     if (min > 0) {
0:       return chunk_sz;
1:     }
1: 
0:     if (chunk_sz < 1e3) {
0:       chunk_sz = (int)1e3;
1:     }
1: 
0:     return chunk_sz;
1:   }
1: 
0:   /* Ingest a Matrix into an H2O Frame. H2O Frame is the "backing"
0:      data structure behind CheckpointedDrm. Steps:
1:   */
0:   public static H2ODrm drm_from_matrix(Matrix m, int min_hint, int exact_hint) {
0:     /* First create an empty (0-filled) frame of the required dimensions */
0:     Frame frame = empty_frame(m.rowSize(), m.columnSize(), min_hint, exact_hint);
1:     Vec labels = null;
1:     Vec.Writer writers[] = new Vec.Writer[m.columnSize()];
1:     Futures closer = new Futures();
1: 
0:     /* "open" vectors for writing efficiently in bulk */
1:     for (int i = 0; i < writers.length; i++) {
1:       writers[i] = frame.vecs()[i].open();
1:     }
1: 
1:     for (int r = 0; r < m.rowSize(); r++) {
1:       for (int c = 0; c < m.columnSize(); c++) {
1:         writers[c].set(r, m.getQuick(r, c));
1:       }
1:     }
1: 
1:     for (int c = 0; c < m.columnSize(); c++) {
1:       writers[c].close(closer);
1:     }
1: 
0:     /* If string labeled matrix, create aux Vec */
1:     Map<String,Integer> map = m.getRowLabelBindings();
1:     if (map != null) {
0:       /* label vector must be similarly partitioned like the Frame */
0:       labels = frame.anyVec().makeZero();
1:       Vec.Writer writer = labels.open();
0:       Map<Integer,String> rmap = reverse_map(map);
1: 
0:       for (long r = 0; r < m.rowSize(); r++) {
1:         writer.set(r, rmap.get(r));
1:       }
1: 
1:       writer.close(closer);
1:     }
1: 
1:     closer.blockForPending();
1: 
1:     return new H2ODrm(frame, labels);
1:   }
1: 
0:   public static Frame empty_frame(long nrow, int ncol, int min_hint, int exact_hint) {
1:     Vec.VectorGroup vg = new Vec.VectorGroup();
1: 
0:     return empty_frame(nrow, ncol, min_hint, exact_hint, vg);
1:   }
1: 
0:   public static Frame empty_frame(long nrow, int ncol, int min_hint, int exact_hint, Vec.VectorGroup vg) {
0:     int chunk_sz = chunk_size(nrow, ncol, min_hint, exact_hint);
0:     int nchunks = (int)((nrow - 1) / chunk_sz) + 1; /* Final number of Chunks per Vec */
1:     long espc[] = new long[nchunks + 1];
0:     final Vec[] vecs = new Vec[ncol];
1: 
1:     for (int i = 0; i < nchunks; i++) {
0:       espc[i] = i * chunk_sz;
1:     }
1:     espc[nchunks] = nrow;
1: 
0:     for (int i = 0; i < vecs.length; i++) {
0:       vecs[i] = Vec.makeCon(0, null, vg, espc);
1:     }
1: 
1:     return new Frame(vecs);
1:   }
1: 
0:   public static H2ODrm empty_drm(long nrow, int ncol, int min_hint, int exact_hint) {
0:     return new H2ODrm(empty_frame(nrow, ncol, min_hint, exact_hint));
1:   }
1: }
author:Stevo Slavic
-------------------------------------------------------------------------------
commit:f5f54a1
/////////////////////////////////////////////////////////////////////////
1:             sums[c] += chks[c].atd(r);
/////////////////////////////////////////////////////////////////////////
0:             sumSqr += (chks[c].atd(r) * chks[c].atd(r));
/////////////////////////////////////////////////////////////////////////
1:             if ((long)chks[c].atd(r) != 0) {
============================================================================