1:151de0d: /**
1:151de0d:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:151de0d:  * contributor license agreements.  See the NOTICE file distributed with
1:151de0d:  * this work for additional information regarding copyright ownership.
1:151de0d:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:151de0d:  * (the "License"); you may not use this file except in compliance with
1:151de0d:  * the License.  You may obtain a copy of the License at
2:151de0d:  *
1:151de0d:  *     http://www.apache.org/licenses/LICENSE-2.0
1:151de0d:  *
1:151de0d:  * Unless required by applicable law or agreed to in writing, software
1:151de0d:  * distributed under the License is distributed on an "AS IS" BASIS,
1:151de0d:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:151de0d:  * See the License for the specific language governing permissions and
1:151de0d:  * limitations under the License.
1:151de0d:  */
10:151de0d: 
1:ffc7fab: package org.apache.mahout.math.hadoop.stochasticsvd.qr;
1:151de0d: 
1:151de0d: import java.util.Arrays;
1:151de0d: import java.util.Iterator;
1:151de0d: import java.util.List;
1:151de0d: 
1:74f849b: import com.google.common.collect.Lists;
1:151de0d: import org.apache.mahout.math.AbstractVector;
1:151de0d: import org.apache.mahout.math.DenseVector;
1:151de0d: import org.apache.mahout.math.Matrix;
1:a8d3dbd: import org.apache.mahout.math.OrderedIntDoubleMapping;
1:151de0d: import org.apache.mahout.math.Vector;
1:f43adfe: import org.apache.mahout.math.UpperTriangular;
1:151de0d: 
1:151de0d: /**
1:151de0d:  * Givens Thin solver. Standard Givens operations are reordered in a way that
1:151de0d:  * helps us to push them thru MapReduce operations in a block fashion.
1:151de0d:  */
1:151de0d: public class GivensThinSolver {
1:151de0d: 
1:151de0d:   private double[] vARow;
1:151de0d:   private double[] vQtRow;
1:4194a28:   private final double[][] mQt;
1:4194a28:   private final double[][] mR;
1:151de0d:   private int qtStartRow;
1:151de0d:   private int rStartRow;
1:151de0d:   private int m;
1:a13b4b7:   private final int n; // m-row cnt, n- column count, m>=n
1:151de0d:   private int cnt;
1:a13b4b7:   private final double[] cs = new double[2];
1:151de0d: 
1:151de0d:   public GivensThinSolver(int m, int n) {
1:a13b4b7:     if (!(m >= n)) {
1:151de0d:       throw new IllegalArgumentException("Givens thin QR: must be true: m>=n");
1:a13b4b7:     }
1:151de0d: 
1:151de0d:     this.m = m;
1:151de0d:     this.n = n;
1:151de0d: 
1:151de0d:     mQt = new double[n][];
1:151de0d:     mR = new double[n][];
1:151de0d:     vARow = new double[n];
1:151de0d:     vQtRow = new double[m];
1:151de0d: 
1:151de0d:     for (int i = 0; i < n; i++) {
1:151de0d:       mQt[i] = new double[this.m];
1:151de0d:       mR[i] = new double[this.n];
1:151de0d:     }
1:151de0d:     cnt = 0;
1:151de0d:   }
1:151de0d: 
1:151de0d:   public void reset() {
1:151de0d:     cnt = 0;
1:151de0d:   }
1:151de0d: 
1:151de0d:   public void solve(Matrix a) {
1:151de0d: 
1:151de0d:     assert a.rowSize() == m;
1:151de0d:     assert a.columnSize() == n;
1:151de0d: 
1:151de0d:     double[] aRow = new double[n];
1:151de0d:     for (int i = 0; i < m; i++) {
1:528ffcd:       Vector aRowV = a.viewRow(i);
1:a13b4b7:       for (int j = 0; j < n; j++) {
1:151de0d:         aRow[j] = aRowV.getQuick(j);
1:a13b4b7:       }
1:151de0d:       appendRow(aRow);
1:151de0d:     }
1:151de0d:   }
1:151de0d: 
1:151de0d:   public boolean isFull() {
1:151de0d:     return cnt == m;
1:151de0d:   }
1:151de0d: 
1:151de0d:   public int getM() {
1:151de0d:     return m;
1:151de0d:   }
1:151de0d: 
1:151de0d:   public int getN() {
1:151de0d:     return n;
1:151de0d:   }
1:151de0d: 
1:151de0d:   public int getCnt() {
1:151de0d:     return cnt;
1:151de0d:   }
1:151de0d: 
1:151de0d:   public void adjust(int newM) {
1:a13b4b7:     if (newM == m) {
1:5a2250c:       // no adjustment is required.
1:5a2250c:       return; 
1:a13b4b7:     }
1:a13b4b7:     if (newM < n) {
1:151de0d:       throw new IllegalArgumentException("new m can't be less than n");
1:a13b4b7:     }
1:a13b4b7:     if (newM < cnt) {
1:151de0d:       throw new IllegalArgumentException(
1:151de0d:           "new m can't be less than rows accumulated");
1:a13b4b7:     }
1:151de0d:     vQtRow = new double[newM];
1:151de0d: 
1:151de0d:     // grow or shrink qt rows
1:151de0d:     if (newM > m) {
1:151de0d:       // grow qt rows
1:151de0d:       for (int i = 0; i < n; i++) {
1:151de0d:         mQt[i] = Arrays.copyOf(mQt[i], newM);
1:151de0d:         System.arraycopy(mQt[i], 0, mQt[i], newM - m, m);
1:151de0d:         Arrays.fill(mQt[i], 0, newM - m, 0);
1:151de0d:       }
1:151de0d:     } else {
1:151de0d:       // shrink qt rows
1:151de0d:       for (int i = 0; i < n; i++) {
1:151de0d:         mQt[i] = Arrays.copyOfRange(mQt[i], m - newM, m);
1:151de0d:       }
1:151de0d:     }
1:151de0d: 
1:151de0d:     m = newM;
1:151de0d: 
1:151de0d:   }
1:151de0d: 
1:151de0d:   public void trim() {
1:151de0d:     adjust(cnt);
1:151de0d:   }
1:151de0d: 
1:151de0d:   /**
1:151de0d:    * api for row-by-row addition
1:151de0d:    * 
1:151de0d:    * @param aRow
1:151de0d:    */
1:151de0d:   public void appendRow(double[] aRow) {
1:a13b4b7:     if (cnt >= m) {
1:a13b4b7:       throw new IllegalStateException("thin QR solver fed more rows than initialized for");
1:a13b4b7:     }
1:151de0d:     try {
1:5a2250c:       /*
1:5a2250c:        * moving pointers around is inefficient but for the sanity's sake i am
1:5a2250c:        * keeping it this way so i don't have to guess how R-tilde index maps to
1:5a2250c:        * actual block index
1:5a2250c:        */
1:151de0d:       Arrays.fill(vQtRow, 0);
1:151de0d:       vQtRow[m - cnt - 1] = 1;
1:151de0d:       int height = cnt > n ? n : cnt;
1:151de0d:       System.arraycopy(aRow, 0, vARow, 0, n);
1:151de0d: 
1:151de0d:       if (height > 0) {
1:151de0d:         givens(vARow[0], getRRow(0)[0], cs);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], vARow, getRRow(0), 0, n);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], vQtRow, getQtRow(0), 0, m);
1:151de0d:       }
1:151de0d: 
1:151de0d:       for (int i = 1; i < height; i++) {
1:151de0d:         givens(getRRow(i - 1)[i], getRRow(i)[i], cs);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], getRRow(i - 1), getRRow(i), i,
1:151de0d:             n - i);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], getQtRow(i - 1), getQtRow(i), 0,
1:151de0d:             m);
1:151de0d:       }
1:5a2250c:       /*
1:5a2250c:        * push qt and r-tilde 1 row down
1:5a2250c:        * 
1:5a2250c:        * just swap the references to reduce GC churning
1:5a2250c:        */
1:151de0d:       pushQtDown();
1:151de0d:       double[] swap = getQtRow(0);
1:151de0d:       setQtRow(0, vQtRow);
1:151de0d:       vQtRow = swap;
1:151de0d: 
1:151de0d:       pushRDown();
1:151de0d:       swap = getRRow(0);
1:151de0d:       setRRow(0, vARow);
1:151de0d:       vARow = swap;
1:151de0d: 
1:151de0d:     } finally {
1:151de0d:       cnt++;
1:151de0d:     }
1:151de0d:   }
1:151de0d: 
1:151de0d:   private double[] getQtRow(int row) {
1:151de0d: 
1:151de0d:     return mQt[(row += qtStartRow) >= n ? row - n : row];
1:151de0d:   }
1:151de0d: 
1:151de0d:   private void setQtRow(int row, double[] qtRow) {
1:151de0d:     mQt[(row += qtStartRow) >= n ? row - n : row] = qtRow;
1:151de0d:   }
1:151de0d: 
1:151de0d:   private void pushQtDown() {
1:151de0d:     qtStartRow = qtStartRow == 0 ? n - 1 : qtStartRow - 1;
1:151de0d:   }
1:151de0d: 
1:151de0d:   private double[] getRRow(int row) {
1:33414e6:     row += rStartRow;
1:33414e6:     return mR[row >= n ? row - n : row];
1:151de0d:   }
1:151de0d: 
1:151de0d:   private void setRRow(int row, double[] rrow) {
1:151de0d:     mR[(row += rStartRow) >= n ? row - n : row] = rrow;
1:151de0d:   }
1:151de0d: 
1:151de0d:   private void pushRDown() {
1:151de0d:     rStartRow = rStartRow == 0 ? n - 1 : rStartRow - 1;
1:151de0d:   }
1:151de0d: 
1:5a2250c:   /*
1:5a2250c:    * warning: both of these return actually n+1 rows with the last one being //
1:5a2250c:    * not interesting.
1:5a2250c:    */
1:151de0d:   public UpperTriangular getRTilde() {
1:151de0d:     UpperTriangular packedR = new UpperTriangular(n);
1:a13b4b7:     for (int i = 0; i < n; i++) {
1:33414e6:       packedR.assignNonZeroElementsInRow(i, getRRow(i));
1:a13b4b7:     }
1:151de0d:     return packedR;
1:151de0d:   }
1:151de0d: 
1:151de0d:   public double[][] getThinQtTilde() {
1:151de0d:     if (qtStartRow != 0) {
1:5a2250c:       /*
1:5a2250c:        * rotate qt rows into place
1:5a2250c:        * 
1:5a2250c:        * double[~500][], once per block, not a big deal.
1:5a2250c:        */
1:5a2250c:       double[][] qt = new double[n][]; 
1:151de0d:       System.arraycopy(mQt, qtStartRow, qt, 0, n - qtStartRow);
1:151de0d:       System.arraycopy(mQt, 0, qt, n - qtStartRow, qtStartRow);
1:151de0d:       return qt;
1:151de0d:     }
1:151de0d:     return mQt;
1:151de0d:   }
1:151de0d: 
1:151de0d:   public static void applyGivensInPlace(double c, double s, double[] row1,
1:151de0d:       double[] row2, int offset, int len) {
1:151de0d: 
1:151de0d:     int n = offset + len;
1:151de0d:     for (int j = offset; j < n; j++) {
1:151de0d:       double tau1 = row1[j];
1:151de0d:       double tau2 = row2[j];
1:151de0d:       row1[j] = c * tau1 - s * tau2;
1:151de0d:       row2[j] = s * tau1 + c * tau2;
1:151de0d:     }
1:151de0d:   }
1:151de0d: 
1:151de0d:   public static void applyGivensInPlace(double c, double s, Vector row1,
1:151de0d:       Vector row2, int offset, int len) {
1:151de0d: 
1:151de0d:     int n = offset + len;
1:151de0d:     for (int j = offset; j < n; j++) {
1:151de0d:       double tau1 = row1.getQuick(j);
1:151de0d:       double tau2 = row2.getQuick(j);
1:151de0d:       row1.setQuick(j, c * tau1 - s * tau2);
1:151de0d:       row2.setQuick(j, s * tau1 + c * tau2);
1:151de0d:     }
1:151de0d:   }
1:151de0d: 
1:151de0d:   public static void applyGivensInPlace(double c, double s, int i, int k,
1:151de0d:       Matrix mx) {
1:151de0d:     int n = mx.columnSize();
1:151de0d: 
1:151de0d:     for (int j = 0; j < n; j++) {
1:151de0d:       double tau1 = mx.get(i, j);
1:151de0d:       double tau2 = mx.get(k, j);
1:151de0d:       mx.set(i, j, c * tau1 - s * tau2);
1:151de0d:       mx.set(k, j, s * tau1 + c * tau2);
1:151de0d:     }
1:151de0d:   }
1:151de0d: 
1:151de0d:   public static void fromRho(double rho, double[] csOut) {
1:151de0d:     if (rho == 1) {
1:151de0d:       csOut[0] = 0;
1:151de0d:       csOut[1] = 1;
1:151de0d:       return;
1:151de0d:     }
1:151de0d:     if (Math.abs(rho) < 1) {
1:151de0d:       csOut[1] = 2 * rho;
1:151de0d:       csOut[0] = Math.sqrt(1 - csOut[1] * csOut[1]);
1:151de0d:       return;
1:151de0d:     }
1:151de0d:     csOut[0] = 2 / rho;
1:151de0d:     csOut[1] = Math.sqrt(1 - csOut[0] * csOut[0]);
1:151de0d:   }
1:151de0d: 
1:151de0d:   public static void givens(double a, double b, double[] csOut) {
1:151de0d:     if (b == 0) {
1:151de0d:       csOut[0] = 1;
1:151de0d:       csOut[1] = 0;
1:151de0d:       return;
1:151de0d:     }
1:151de0d:     if (Math.abs(b) > Math.abs(a)) {
1:151de0d:       double tau = -a / b;
1:151de0d:       csOut[1] = 1 / Math.sqrt(1 + tau * tau);
1:151de0d:       csOut[0] = csOut[1] * tau;
1:151de0d:     } else {
1:151de0d:       double tau = -b / a;
1:151de0d:       csOut[0] = 1 / Math.sqrt(1 + tau * tau);
1:151de0d:       csOut[1] = csOut[0] * tau;
1:151de0d:     }
1:151de0d:   }
1:151de0d: 
1:151de0d:   public static double toRho(double c, double s) {
1:a13b4b7:     if (c == 0) {
1:151de0d:       return 1;
1:a13b4b7:     }
1:a13b4b7:     if (Math.abs(s) < Math.abs(c)) {
1:151de0d:       return Math.signum(c) * s / 2;
1:a13b4b7:     } else {
1:151de0d:       return Math.signum(s) * 2 / c;
1:151de0d:     }
1:a13b4b7:   }
1:151de0d: 
1:151de0d:   public static void mergeR(UpperTriangular r1, UpperTriangular r2) {
1:151de0d:     TriangularRowView r1Row = new TriangularRowView(r1);
1:151de0d:     TriangularRowView r2Row = new TriangularRowView(r2);
1:151de0d:     
1:151de0d:     int kp = r1Row.size();
1:151de0d:     assert kp == r2Row.size();
1:151de0d: 
1:151de0d:     double[] cs = new double[2];
1:151de0d: 
1:151de0d:     for (int v = 0; v < kp; v++) {
1:151de0d:       for (int u = v; u < kp; u++) {
1:151de0d:         givens(r1Row.setViewedRow(u).get(u), r2Row.setViewedRow(u - v).get(u),
1:151de0d:             cs);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], r1Row, r2Row, u, kp - u);
1:151de0d:       }
1:151de0d:     }
1:151de0d:   }
1:151de0d: 
1:151de0d:   public static void mergeR(double[][] r1, double[][] r2) {
1:151de0d:     int kp = r1[0].length;
1:151de0d:     assert kp == r2[0].length;
1:151de0d: 
1:151de0d:     double[] cs = new double[2];
1:151de0d: 
1:151de0d:     for (int v = 0; v < kp; v++) {
1:151de0d:       for (int u = v; u < kp; u++) {
1:151de0d:         givens(r1[u][u], r2[u - v][u], cs);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], r1[u], r2[u - v], u, kp - u);
1:151de0d:       }
1:151de0d:     }
1:151de0d: 
1:151de0d:   }
1:151de0d: 
1:151de0d:   public static void mergeRonQ(UpperTriangular r1, UpperTriangular r2,
1:151de0d:       double[][] qt1, double[][] qt2) {
1:151de0d:     TriangularRowView r1Row = new TriangularRowView(r1);
1:151de0d:     TriangularRowView r2Row = new TriangularRowView(r2);
1:151de0d:     int kp = r1Row.size();
1:151de0d:     assert kp == r2Row.size();
1:151de0d:     assert kp == qt1.length;
1:151de0d:     assert kp == qt2.length;
1:151de0d: 
1:151de0d:     int r = qt1[0].length;
1:151de0d:     assert qt2[0].length == r;
1:151de0d: 
1:151de0d:     double[] cs = new double[2];
1:151de0d: 
1:151de0d:     for (int v = 0; v < kp; v++) {
1:151de0d:       for (int u = v; u < kp; u++) {
1:151de0d:         givens(r1Row.setViewedRow(u).get(u), r2Row.setViewedRow(u - v).get(u),
1:151de0d:             cs);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], r1Row, r2Row, u, kp - u);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], qt1[u], qt2[u - v], 0, r);
1:151de0d:       }
1:151de0d:     }
1:151de0d:   }
1:151de0d: 
1:151de0d:   public static void mergeRonQ(double[][] r1, double[][] r2, double[][] qt1,
1:151de0d:       double[][] qt2) {
1:151de0d: 
1:151de0d:     int kp = r1[0].length;
1:151de0d:     assert kp == r2[0].length;
1:151de0d:     assert kp == qt1.length;
1:151de0d:     assert kp == qt2.length;
1:151de0d: 
1:151de0d:     int r = qt1[0].length;
1:151de0d:     assert qt2[0].length == r;
1:151de0d:     double[] cs = new double[2];
1:151de0d: 
1:5a2250c:     /*
1:5a2250c:      * pairwise givens(a,b) so that a come off main diagonal in r1 and bs come
1:5a2250c:      * off u-th upper subdiagonal in r2.
1:5a2250c:      */
1:151de0d:     for (int v = 0; v < kp; v++) {
1:151de0d:       for (int u = v; u < kp; u++) {
1:151de0d:         givens(r1[u][u], r2[u - v][u], cs);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], r1[u], r2[u - v], u, kp - u);
1:151de0d:         applyGivensInPlace(cs[0], cs[1], qt1[u], qt2[u - v], 0, r);
1:151de0d:       }
1:151de0d:     }
1:151de0d:   }
1:151de0d: 
1:151de0d:   // returns merged Q (which in this case is the qt1)
1:151de0d:   public static double[][] mergeQrUp(double[][] qt1, double[][] r1,
2:151de0d:       double[][] r2) {
1:151de0d:     int kp = qt1.length;
1:151de0d:     int r = qt1[0].length;
1:151de0d: 
1:151de0d:     double[][] qTilde = new double[kp][];
1:a13b4b7:     for (int i = 0; i < kp; i++) {
1:151de0d:       qTilde[i] = new double[r];
1:a13b4b7:     }
1:151de0d:     mergeRonQ(r1, r2, qt1, qTilde);
1:151de0d:     return qt1;
1:151de0d:   }
1:151de0d: 
1:151de0d:   // returns merged Q (which in this case is the qt1)
1:a13b4b7:   public static double[][] mergeQrUp(double[][] qt1, UpperTriangular r1, UpperTriangular r2) {
1:151de0d:     int kp = qt1.length;
1:151de0d:     int r = qt1[0].length;
1:151de0d: 
1:151de0d:     double[][] qTilde = new double[kp][];
1:a13b4b7:     for (int i = 0; i < kp; i++) {
1:151de0d:       qTilde[i] = new double[r];
1:151de0d:     }
1:151de0d:     mergeRonQ(r1, r2, qt1, qTilde);
1:151de0d:     return qt1;
1:a13b4b7:   }
1:151de0d: 
1:a13b4b7:   public static double[][] mergeQrDown(double[][] r1, double[][] qt2, double[][] r2) {
1:151de0d:     int kp = qt2.length;
1:151de0d:     int r = qt2[0].length;
1:151de0d: 
1:151de0d:     double[][] qTilde = new double[kp][];
1:a13b4b7:     for (int i = 0; i < kp; i++) {
1:151de0d:       qTilde[i] = new double[r];
1:a13b4b7:     }
1:151de0d:     mergeRonQ(r1, r2, qTilde, qt2);
1:151de0d:     return qTilde;
1:151de0d: 
1:151de0d:   }
1:151de0d: 
1:a13b4b7:   public static double[][] mergeQrDown(UpperTriangular r1, double[][] qt2, UpperTriangular r2) {
1:151de0d:     int kp = qt2.length;
1:151de0d:     int r = qt2[0].length;
1:151de0d: 
1:151de0d:     double[][] qTilde = new double[kp][];
1:a13b4b7:     for (int i = 0; i < kp; i++) {
1:151de0d:       qTilde[i] = new double[r];
1:151de0d:     }
1:151de0d:     mergeRonQ(r1, r2, qTilde, qt2);
1:151de0d:     return qTilde;
1:151de0d: 
1:a13b4b7:   }
1:151de0d: 
1:151de0d:   public static double[][] computeQtHat(double[][] qt, int i,
1:151de0d:       Iterator<UpperTriangular> rIter) {
1:151de0d:     UpperTriangular rTilde = rIter.next();
1:a13b4b7:     for (int j = 1; j < i; j++) {
1:151de0d:       mergeR(rTilde, rIter.next());
1:a13b4b7:     }
1:a13b4b7:     if (i > 0) {
1:151de0d:       qt = mergeQrDown(rTilde, qt, rIter.next());
1:a13b4b7:     }
1:a13b4b7:     while (rIter.hasNext()) {
1:151de0d:       qt = mergeQrUp(qt, rTilde, rIter.next());
1:151de0d:     }
1:151de0d:     return qt;
1:a13b4b7:   }
1:151de0d: 
1:151de0d:   // test helpers
1:a13b4b7:   public static boolean isOrthonormal(double[][] qt, boolean insufficientRank, double epsilon) {
1:151de0d:     int n = qt.length;
1:151de0d:     int rank = 0;
1:151de0d:     for (int i = 0; i < n; i++) {
1:151de0d:       Vector ei = new DenseVector(qt[i], true);
1:151de0d: 
1:151de0d:       double norm = ei.norm(2);
1:151de0d: 
1:39fe224:       if (Math.abs(1.0 - norm) < epsilon) {
1:151de0d:         rank++;
1:a13b4b7:       } else if (Math.abs(norm) > epsilon) {
1:151de0d:         return false; // not a rank deficiency, either
1:a13b4b7:       }
1:151de0d: 
1:151de0d:       for (int j = 0; j <= i; j++) {
1:151de0d:         Vector ej = new DenseVector(qt[j], true);
1:151de0d:         double dot = ei.dot(ej);
1:39fe224:         if (!(Math.abs((i == j && rank > j ? 1.0 : 0.0) - dot) < epsilon)) {
1:151de0d:           return false;
1:151de0d:         }
1:151de0d:       }
1:151de0d:     }
1:39fe224:     return insufficientRank ? rank < n : rank == n;
1:a13b4b7:   }
1:151de0d: 
1:151de0d:   public static boolean isOrthonormalBlocked(Iterable<double[][]> qtHats,
1:151de0d:       boolean insufficientRank, double epsilon) {
1:151de0d:     int n = qtHats.iterator().next().length;
1:151de0d:     int rank = 0;
1:151de0d:     for (int i = 0; i < n; i++) {
1:74f849b:       List<Vector> ei = Lists.newArrayList();
1:151de0d:       // Vector e_i=new DenseVector (qt[i],true);
1:a13b4b7:       for (double[][] qtHat : qtHats) {
1:151de0d:         ei.add(new DenseVector(qtHat[i], true));
1:a13b4b7:       }
1:151de0d: 
1:151de0d:       double norm = 0;
1:a13b4b7:       for (Vector v : ei) {
1:151de0d:         norm += v.dot(v);
1:a13b4b7:       }
1:151de0d:       norm = Math.sqrt(norm);
1:a13b4b7:       if (Math.abs(1 - norm) < epsilon) {
1:151de0d:         rank++;
1:a13b4b7:       } else if (Math.abs(norm) > epsilon) {
1:151de0d:         return false; // not a rank deficiency, either
1:a13b4b7:       }
1:151de0d: 
1:151de0d:       for (int j = 0; j <= i; j++) {
1:74f849b:         List<Vector> ej = Lists.newArrayList();
1:a13b4b7:         for (double[][] qtHat : qtHats) {
1:151de0d:           ej.add(new DenseVector(qtHat[j], true));
1:a13b4b7:         }
1:151de0d: 
1:151de0d:         // Vector e_j = new DenseVector ( qt[j], true);
1:151de0d:         double dot = 0;
1:a13b4b7:         for (int k = 0; k < ei.size(); k++) {
1:151de0d:           dot += ei.get(k).dot(ej.get(k));
1:151de0d:         }
1:a13b4b7:         if (!(Math.abs((i == j && rank > j ? 1 : 0) - dot) < epsilon)) {
1:151de0d:           return false;
1:151de0d:         }
1:151de0d:       }
1:a13b4b7:     }
1:39fe224:     return insufficientRank ? rank < n : rank == n;
1:a13b4b7:   }
1:151de0d: 
1:3218e95:   private static final class TriangularRowView extends AbstractVector {
1:a13b4b7:     private final UpperTriangular viewed;
1:151de0d:     private int rowNum;
1:151de0d: 
1:a13b4b7:     private TriangularRowView(UpperTriangular viewed) {
1:151de0d:       super(viewed.columnSize());
1:151de0d:       this.viewed = viewed;
1:151de0d: 
1:151de0d:     }
1:151de0d: 
1:151de0d:     TriangularRowView setViewedRow(int row) {
1:151de0d:       rowNum = row;
1:151de0d:       return this;
1:151de0d:     }
1:151de0d: 
1:151de0d:     @Override
1:151de0d:     public boolean isDense() {
1:151de0d:       return true;
1:151de0d:     }
1:151de0d: 
1:151de0d:     @Override
1:151de0d:     public boolean isSequentialAccess() {
1:151de0d:       return false;
1:151de0d:     }
1:151de0d: 
1:151de0d:     @Override
1:151de0d:     public Iterator<Element> iterator() {
1:151de0d:       throw new UnsupportedOperationException();
1:151de0d:     }
1:151de0d: 
1:151de0d:     @Override
1:151de0d:     public Iterator<Element> iterateNonZero() {
1:151de0d:       throw new UnsupportedOperationException();
1:151de0d:     }
1:151de0d: 
1:151de0d:     @Override
1:151de0d:     public double getQuick(int index) {
1:151de0d:       return viewed.getQuick(rowNum, index);
1:151de0d:     }
1:151de0d: 
1:151de0d:     @Override
1:151de0d:     public Vector like() {
1:151de0d:       throw new UnsupportedOperationException();
1:151de0d:     }
1:151de0d: 
1:151de0d:     @Override
1:0b564c7:     public Vector like(int cardinality) {
1:0b564c7:       throw new UnsupportedOperationException();
1:0b564c7:     }
1:0b564c7: 
1:0b564c7:     @Override
1:151de0d:     public void setQuick(int index, double value) {
1:151de0d:       viewed.setQuick(rowNum, index, value);
1:151de0d: 
1:151de0d:     }
1:151de0d: 
1:151de0d:     @Override
1:151de0d:     public int getNumNondefaultElements() {
1:151de0d:       throw new UnsupportedOperationException();
1:151de0d:     }
1:151de0d: 
1:151de0d:     @Override
1:a8d3dbd:     public double getLookupCost() {
1:a8d3dbd:       return 1;
1:151de0d:     }
1:151de0d: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double getIteratorAdvanceCost() {
1:a8d3dbd:       return 1;
1:151de0d:     }
1:151de0d: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isAddConstantTime() {
1:a8d3dbd:       return true;
1:151de0d:     }
1:151de0d: 
1:a8d3dbd:     @Override
1:3218e95:     public Matrix matrixLike(int rows, int columns) {
1:151de0d:       throw new UnsupportedOperationException();
1:151de0d:     }
1:151de0d: 
1:a8d3dbd:     /**
1:a8d3dbd:      * Used internally by assign() to update multiple indices and values at once.
1:a8d3dbd:      * Only really useful for sparse vectors (especially SequentialAccessSparseVector).
1:a8d3dbd:      * <p/>
1:a8d3dbd:      * If someone ever adds a new type of sparse vectors, this method must merge (index, value) pairs into the vector.
1:151de0d:      *
1:a8d3dbd:      * @param updates a mapping of indices to values to merge in the vector.
1:a8d3dbd:      */
1:a8d3dbd:     @Override
1:a8d3dbd:     public void mergeUpdates(OrderedIntDoubleMapping updates) {
1:4ca6b86:       int[] indices = updates.getIndices();
1:4ca6b86:       double[] values = updates.getValues();
1:a8d3dbd:       for (int i = 0; i < updates.getNumMappings(); ++i) {
1:a8d3dbd:         viewed.setQuick(rowNum, indices[i], values[i]);
1:151de0d:       }
1:151de0d:     }
1:151de0d: 
1:151de0d:   }
1:151de0d: 
1:151de0d: }
============================================================================
author:Dmitriy Lyubimov
-------------------------------------------------------------------------------
commit:0b564c7
/////////////////////////////////////////////////////////////////////////
1:     public Vector like(int cardinality) {
1:       throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
commit:f43adfe
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.UpperTriangular;
commit:5a2250c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       // no adjustment is required.
1:       return; 
/////////////////////////////////////////////////////////////////////////
1:       /*
1:        * moving pointers around is inefficient but for the sanity's sake i am
1:        * keeping it this way so i don't have to guess how R-tilde index maps to
1:        * actual block index
1:        */
/////////////////////////////////////////////////////////////////////////
1:       /*
1:        * push qt and r-tilde 1 row down
1:        * 
1:        * just swap the references to reduce GC churning
1:        */
/////////////////////////////////////////////////////////////////////////
1:   /*
1:    * warning: both of these return actually n+1 rows with the last one being //
1:    * not interesting.
1:    */
/////////////////////////////////////////////////////////////////////////
1:       /*
1:        * rotate qt rows into place
1:        * 
1:        * double[~500][], once per block, not a big deal.
1:        */
1:       double[][] qt = new double[n][]; 
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * pairwise givens(a,b) so that a come off main diagonal in r1 and bs come
1:      * off u-th upper subdiagonal in r2.
1:      */
commit:ffc7fab
/////////////////////////////////////////////////////////////////////////
1: package org.apache.mahout.math.hadoop.stochasticsvd.qr;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.math.hadoop.stochasticsvd.UpperTriangular;
commit:151de0d
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
0: package org.apache.mahout.math.hadoop.stochasticsvd;
1: 
0: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Iterator;
1: import java.util.List;
1: 
1: import org.apache.mahout.math.AbstractVector;
1: import org.apache.mahout.math.DenseVector;
1: import org.apache.mahout.math.Matrix;
1: import org.apache.mahout.math.Vector;
1: 
1: /**
1:  * Givens Thin solver. Standard Givens operations are reordered in a way that
1:  * helps us to push them thru MapReduce operations in a block fashion.
1:  * 
1:  * 
1:  */
1: public class GivensThinSolver {
1: 
0:   // private static final double s_epsilon = 1e-10;
1: 
0:   // private double[][] m_rTilde;
0:   // private Vector m_aRowV;
1:   private double[] vARow;
1:   private double[] vQtRow;
0:   // private UpperTriangular m_rTilde;
0:   // private TriangularRowView m_rTildeRowView, m_rTildeRowView2;
0:   private double[][] mQt;
0:   private double[][] mR;
1:   private int qtStartRow;
1:   private int rStartRow;
1:   private int m;
0:   private int n; // m-row cnt, n- column count, m>=n
1:   private int cnt;
0:   private double[] cs = new double[2];
1: 
1:   public GivensThinSolver(int m, int n) {
0:     super();
1: 
0:     if (!(m >= n))
1:       throw new IllegalArgumentException("Givens thin QR: must be true: m>=n");
1: 
1:     this.m = m;
1:     this.n = n;
1: 
1:     mQt = new double[n][];
1:     mR = new double[n][];
1:     vARow = new double[n];
0:     // m_aRowV = new DenseVector(m_aRow, true);
1:     vQtRow = new double[m];
1: 
1:     for (int i = 0; i < n; i++) {
1:       mQt[i] = new double[this.m];
1:       mR[i] = new double[this.n];
1:     }
1:     cnt = 0;
1:   }
1: 
1:   public void reset() {
1:     cnt = 0;
1:   }
1: 
1:   public void solve(Matrix a) {
1: 
1:     assert a.rowSize() == m;
1:     assert a.columnSize() == n;
1: 
1:     double[] aRow = new double[n];
1:     for (int i = 0; i < m; i++) {
0:       Vector aRowV = a.getRow(i);
0:       for (int j = 0; j < n; j++)
1:         aRow[j] = aRowV.getQuick(j);
1:       appendRow(aRow);
1:     }
1:   }
1: 
1:   public boolean isFull() {
1:     return cnt == m;
1:   }
1: 
1:   public int getM() {
1:     return m;
1:   }
1: 
1:   public int getN() {
1:     return n;
1:   }
1: 
1:   public int getCnt() {
1:     return cnt;
1:   }
1: 
1:   public void adjust(int newM) {
0:     if (newM == m)
0:       return; // no adjustment is required.
0:     if (newM < n)
1:       throw new IllegalArgumentException("new m can't be less than n");
0:     if (newM < cnt)
1:       throw new IllegalArgumentException(
1:           "new m can't be less than rows accumulated");
1:     vQtRow = new double[newM];
1: 
1:     // grow or shrink qt rows
1:     if (newM > m) {
1:       // grow qt rows
1:       for (int i = 0; i < n; i++) {
1:         mQt[i] = Arrays.copyOf(mQt[i], newM);
1:         System.arraycopy(mQt[i], 0, mQt[i], newM - m, m);
1:         Arrays.fill(mQt[i], 0, newM - m, 0);
1:       }
1:     } else {
1:       // shrink qt rows
1:       for (int i = 0; i < n; i++) {
1:         mQt[i] = Arrays.copyOfRange(mQt[i], m - newM, m);
1:       }
1:     }
1: 
1:     m = newM;
1: 
1:   }
1: 
1:   public void trim() {
1:     adjust(cnt);
1:   }
1: 
1:   /**
1:    * api for row-by-row addition
1:    * 
1:    * @param aRow
1:    */
1:   public void appendRow(double[] aRow) {
0:     if (cnt >= m)
0:       throw new RuntimeException(
0:           "thin QR solver fed more rows than initialized for");
1:     try {
0:       // moving pointers around is inefficient but
0:       // for the sanity's sake i am keeping it this way so i don't
0:       // have to guess how R-tilde index maps to actual block index
1: 
1:       Arrays.fill(vQtRow, 0);
1:       vQtRow[m - cnt - 1] = 1;
1:       int height = cnt > n ? n : cnt;
1:       System.arraycopy(aRow, 0, vARow, 0, n);
1: 
1:       if (height > 0) {
1:         givens(vARow[0], getRRow(0)[0], cs);
1:         applyGivensInPlace(cs[0], cs[1], vARow, getRRow(0), 0, n);
1:         applyGivensInPlace(cs[0], cs[1], vQtRow, getQtRow(0), 0, m);
1:       }
1: 
1:       for (int i = 1; i < height; i++) {
1:         givens(getRRow(i - 1)[i], getRRow(i)[i], cs);
1:         applyGivensInPlace(cs[0], cs[1], getRRow(i - 1), getRRow(i), i,
1:             n - i);
1:         applyGivensInPlace(cs[0], cs[1], getQtRow(i - 1), getQtRow(i), 0,
1:             m);
1:       }
0:       // push qt and r-tilde 1 row down
0:       // just sqp the references to reduce GC churning
1:       pushQtDown();
1:       double[] swap = getQtRow(0);
1:       setQtRow(0, vQtRow);
1:       vQtRow = swap;
1: 
0:       // triangular push -- obviously, less efficient than
0:       // this is terribly inefficient. for each row we are basically
0:       // moving ~ 2-4Mb of memory around.
0:       // for (int i = m_n - 1; i > 0; i--) {
0:       // // copy (i-1)th row into i-th row ignoring main diagonal item
0:       // // which must be 0 now
0:       // assert m_rTilde.getQuick(i - 1, i - 1) <= s_epsilon;
0:       // for (int j = i; j < m_n; j++)
0:       // m_rTilde.setQuick(i, j, m_rTilde.getQuick(i - 1, j));
0:       // }
0:       // for (int i = 0; i < m_n; i++)
0:       // m_rTilde.setQuick(0, i, m_aRow[i]);
1:       pushRDown();
1:       swap = getRRow(0);
1:       setRRow(0, vARow);
1:       vARow = swap;
1: 
1:     } finally {
1:       cnt++;
1:     }
1:   }
1: 
1:   private double[] getQtRow(int row) {
1: 
1:     return mQt[(row += qtStartRow) >= n ? row - n : row];
1:   }
1: 
1:   private void setQtRow(int row, double[] qtRow) {
1:     mQt[(row += qtStartRow) >= n ? row - n : row] = qtRow;
1:   }
1: 
1:   private void pushQtDown() {
1:     qtStartRow = qtStartRow == 0 ? n - 1 : qtStartRow - 1;
1:   }
1: 
1:   private double[] getRRow(int row) {
0:     return mR[(row += rStartRow) >= n ? row - n : row];
1:   }
1: 
1:   private void setRRow(int row, double[] rrow) {
1:     mR[(row += rStartRow) >= n ? row - n : row] = rrow;
1:   }
1: 
1:   private void pushRDown() {
1:     rStartRow = rStartRow == 0 ? n - 1 : rStartRow - 1;
1:   }
1: 
0:   // warning: both of these return actually n+1 rows with the last one being
0:   // not interesting.
1:   public UpperTriangular getRTilde() {
1:     UpperTriangular packedR = new UpperTriangular(n);
0:     for (int i = 0; i < n; i++)
0:       packedR.assignRow(i, getRRow(i));
1:     return packedR;
1:   }
1: 
1:   public double[][] getThinQtTilde() {
1:     if (qtStartRow != 0) {
0:       // rotate qt rows into place
0:       double[][] qt = new double[n][]; // double[~500][], once per block, not
0:                                          // a big deal.
1:       System.arraycopy(mQt, qtStartRow, qt, 0, n - qtStartRow);
1:       System.arraycopy(mQt, 0, qt, n - qtStartRow, qtStartRow);
1:       return qt;
1:     }
1:     return mQt;
1:   }
1: 
1:   public static void applyGivensInPlace(double c, double s, double[] row1,
1:       double[] row2, int offset, int len) {
1: 
1:     int n = offset + len;
1:     for (int j = offset; j < n; j++) {
1:       double tau1 = row1[j];
1:       double tau2 = row2[j];
1:       row1[j] = c * tau1 - s * tau2;
1:       row2[j] = s * tau1 + c * tau2;
1:     }
1:   }
1: 
1:   public static void applyGivensInPlace(double c, double s, Vector row1,
1:       Vector row2, int offset, int len) {
1: 
1:     int n = offset + len;
1:     for (int j = offset; j < n; j++) {
1:       double tau1 = row1.getQuick(j);
1:       double tau2 = row2.getQuick(j);
1:       row1.setQuick(j, c * tau1 - s * tau2);
1:       row2.setQuick(j, s * tau1 + c * tau2);
1:     }
1:   }
1: 
1:   public static void applyGivensInPlace(double c, double s, int i, int k,
1:       Matrix mx) {
1:     int n = mx.columnSize();
1: 
1:     for (int j = 0; j < n; j++) {
1:       double tau1 = mx.get(i, j);
1:       double tau2 = mx.get(k, j);
1:       mx.set(i, j, c * tau1 - s * tau2);
1:       mx.set(k, j, s * tau1 + c * tau2);
1:     }
1:   }
1: 
1:   public static void fromRho(double rho, double[] csOut) {
1:     if (rho == 1) {
1:       csOut[0] = 0;
1:       csOut[1] = 1;
1:       return;
1:     }
1:     if (Math.abs(rho) < 1) {
1:       csOut[1] = 2 * rho;
1:       csOut[0] = Math.sqrt(1 - csOut[1] * csOut[1]);
1:       return;
1:     }
1:     csOut[0] = 2 / rho;
1:     csOut[1] = Math.sqrt(1 - csOut[0] * csOut[0]);
1:   }
1: 
1:   public static void givens(double a, double b, double[] csOut) {
1:     if (b == 0) {
1:       csOut[0] = 1;
1:       csOut[1] = 0;
1:       return;
1:     }
1:     if (Math.abs(b) > Math.abs(a)) {
1:       double tau = -a / b;
1:       csOut[1] = 1 / Math.sqrt(1 + tau * tau);
1:       csOut[0] = csOut[1] * tau;
1:     } else {
1:       double tau = -b / a;
1:       csOut[0] = 1 / Math.sqrt(1 + tau * tau);
1:       csOut[1] = csOut[0] * tau;
1:     }
1:   }
1: 
1:   public static double toRho(double c, double s) {
0:     if (c == 0)
1:       return 1;
0:     if (Math.abs(s) < Math.abs(c))
1:       return Math.signum(c) * s / 2;
0:     else
1:       return Math.signum(s) * 2 / c;
1:   }
1: 
1:   public static void mergeR(UpperTriangular r1, UpperTriangular r2) {
1:     TriangularRowView r1Row = new TriangularRowView(r1);
1:     TriangularRowView r2Row = new TriangularRowView(r2);
1:     
1:     int kp = r1Row.size();
1:     assert kp == r2Row.size();
1: 
1:     double[] cs = new double[2];
1: 
1:     for (int v = 0; v < kp; v++) {
1:       for (int u = v; u < kp; u++) {
1:         givens(r1Row.setViewedRow(u).get(u), r2Row.setViewedRow(u - v).get(u),
1:             cs);
1:         applyGivensInPlace(cs[0], cs[1], r1Row, r2Row, u, kp - u);
1:       }
1:     }
1:   }
1: 
1:   public static void mergeR(double[][] r1, double[][] r2) {
1:     int kp = r1[0].length;
1:     assert kp == r2[0].length;
1: 
1:     double[] cs = new double[2];
1: 
1:     for (int v = 0; v < kp; v++) {
1:       for (int u = v; u < kp; u++) {
1:         givens(r1[u][u], r2[u - v][u], cs);
1:         applyGivensInPlace(cs[0], cs[1], r1[u], r2[u - v], u, kp - u);
1:       }
1:     }
1: 
1:   }
1: 
1:   public static void mergeRonQ(UpperTriangular r1, UpperTriangular r2,
1:       double[][] qt1, double[][] qt2) {
1:     TriangularRowView r1Row = new TriangularRowView(r1);
1:     TriangularRowView r2Row = new TriangularRowView(r2);
1:     int kp = r1Row.size();
1:     assert kp == r2Row.size();
1:     assert kp == qt1.length;
1:     assert kp == qt2.length;
1: 
1:     int r = qt1[0].length;
1:     assert qt2[0].length == r;
1: 
1:     double[] cs = new double[2];
1: 
1:     for (int v = 0; v < kp; v++) {
1:       for (int u = v; u < kp; u++) {
1:         givens(r1Row.setViewedRow(u).get(u), r2Row.setViewedRow(u - v).get(u),
1:             cs);
1:         applyGivensInPlace(cs[0], cs[1], r1Row, r2Row, u, kp - u);
1:         applyGivensInPlace(cs[0], cs[1], qt1[u], qt2[u - v], 0, r);
1:       }
1:     }
1:   }
1: 
1:   public static void mergeRonQ(double[][] r1, double[][] r2, double[][] qt1,
1:       double[][] qt2) {
1: 
1:     int kp = r1[0].length;
1:     assert kp == r2[0].length;
1:     assert kp == qt1.length;
1:     assert kp == qt2.length;
1: 
1:     int r = qt1[0].length;
1:     assert qt2[0].length == r;
1:     double[] cs = new double[2];
1: 
0:     // pairwise givens(a,b) so that a come off main diagonal in r1
0:     // and bs come off u-th upper subdiagonal in r2.
1:     for (int v = 0; v < kp; v++) {
1:       for (int u = v; u < kp; u++) {
1:         givens(r1[u][u], r2[u - v][u], cs);
1:         applyGivensInPlace(cs[0], cs[1], r1[u], r2[u - v], u, kp - u);
1:         applyGivensInPlace(cs[0], cs[1], qt1[u], qt2[u - v], 0, r);
1:       }
1:     }
1:   }
1: 
1:   // returns merged Q (which in this case is the qt1)
1:   public static double[][] mergeQrUp(double[][] qt1, double[][] r1,
1:       double[][] r2) {
1:     int kp = qt1.length;
1:     int r = qt1[0].length;
1: 
1:     double[][] qTilde = new double[kp][];
0:     for (int i = 0; i < kp; i++)
1:       qTilde[i] = new double[r];
1:     mergeRonQ(r1, r2, qt1, qTilde);
1:     return qt1;
1:   }
1: 
1:   // returns merged Q (which in this case is the qt1)
0:   public static double[][] mergeQrUp(double[][] qt1, UpperTriangular r1,
0:       UpperTriangular r2) {
1:     int kp = qt1.length;
1:     int r = qt1[0].length;
1: 
1:     double[][] qTilde = new double[kp][];
0:     for (int i = 0; i < kp; i++)
1:       qTilde[i] = new double[r];
1:     mergeRonQ(r1, r2, qt1, qTilde);
1:     return qt1;
1:   }
1: 
0:   public static double[][] mergeQrDown(double[][] r1, double[][] qt2,
1:       double[][] r2) {
1:     int kp = qt2.length;
1:     int r = qt2[0].length;
1: 
1:     double[][] qTilde = new double[kp][];
0:     for (int i = 0; i < kp; i++)
1:       qTilde[i] = new double[r];
1:     mergeRonQ(r1, r2, qTilde, qt2);
1:     return qTilde;
1: 
1:   }
1: 
0:   public static double[][] mergeQrDown(UpperTriangular r1, double[][] qt2,
0:       UpperTriangular r2) {
1:     int kp = qt2.length;
1:     int r = qt2[0].length;
1: 
1:     double[][] qTilde = new double[kp][];
0:     for (int i = 0; i < kp; i++)
1:       qTilde[i] = new double[r];
1:     mergeRonQ(r1, r2, qTilde, qt2);
1:     return qTilde;
1: 
1:   }
1: 
1:   public static double[][] computeQtHat(double[][] qt, int i,
1:       Iterator<UpperTriangular> rIter) {
1:     UpperTriangular rTilde = rIter.next();
0:     for (int j = 1; j < i; j++)
1:       mergeR(rTilde, rIter.next());
0:     if (i > 0)
1:       qt = mergeQrDown(rTilde, qt, rIter.next());
0:     for (int j = i + 1; rIter.hasNext(); j++)
1:       qt = mergeQrUp(qt, rTilde, rIter.next());
1:     return qt;
1:   }
1: 
1:   // test helpers
0:   public static boolean isOrthonormal(double[][] qt, boolean insufficientRank,
0:       double epsilon) {
1:     int n = qt.length;
1:     int rank = 0;
1:     for (int i = 0; i < n; i++) {
1:       Vector ei = new DenseVector(qt[i], true);
1: 
1:       double norm = ei.norm(2);
1: 
0:       if (Math.abs(1 - norm) < epsilon)
1:         rank++;
0:       else if (Math.abs(norm) > epsilon)
1:         return false; // not a rank deficiency, either
1: 
1:       for (int j = 0; j <= i; j++) {
1:         Vector ej = new DenseVector(qt[j], true);
1:         double dot = ei.dot(ej);
0:         if (!(Math.abs((i == j && rank > j ? 1 : 0) - dot) < epsilon))
1:           return false;
1:       }
1:     }
0:     return (!insufficientRank && rank == n) || (insufficientRank && rank < n);
1: 
1:   }
1: 
1:   public static boolean isOrthonormalBlocked(Iterable<double[][]> qtHats,
1:       boolean insufficientRank, double epsilon) {
1:     int n = qtHats.iterator().next().length;
1:     int rank = 0;
1:     for (int i = 0; i < n; i++) {
0:       List<Vector> ei = new ArrayList<Vector>();
1:       // Vector e_i=new DenseVector (qt[i],true);
0:       for (double[][] qtHat : qtHats)
1:         ei.add(new DenseVector(qtHat[i], true));
1: 
1:       double norm = 0;
0:       for (Vector v : ei)
1:         norm += v.dot(v);
1:       norm = Math.sqrt(norm);
0:       if (Math.abs(1 - norm) < epsilon)
1:         rank++;
0:       else if (Math.abs(norm) > epsilon)
1:         return false; // not a rank deficiency, either
1: 
1:       for (int j = 0; j <= i; j++) {
0:         List<Vector> ej = new ArrayList<Vector>();
0:         for (double[][] qtHat : qtHats)
1:           ej.add(new DenseVector(qtHat[j], true));
1: 
1:         // Vector e_j = new DenseVector ( qt[j], true);
1:         double dot = 0;
0:         for (int k = 0; k < ei.size(); k++)
1:           dot += ei.get(k).dot(ej.get(k));
0:         if (!(Math.abs((i == j && rank > j ? 1 : 0) - dot) < epsilon))
1:           return false;
1:       }
1:     }
0:     return (!insufficientRank && rank == n) || (insufficientRank && rank < n);
1: 
1:   }
1: 
0:   private static class TriangularRowView extends AbstractVector {
0:     private UpperTriangular viewed;
1:     private int rowNum;
1: 
0:     public TriangularRowView(UpperTriangular viewed) {
1:       super(viewed.columnSize());
1:       this.viewed = viewed;
1: 
1:     }
1: 
1:     TriangularRowView setViewedRow(int row) {
1:       rowNum = row;
1:       return this;
1:     }
1: 
1:     @Override
1:     public boolean isDense() {
1:       return true;
1:     }
1: 
1:     @Override
1:     public boolean isSequentialAccess() {
1:       return false;
1:     }
1: 
1:     @Override
1:     public Iterator<Element> iterator() {
1:       throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public Iterator<Element> iterateNonZero() {
1:       throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public double getQuick(int index) {
1:       return viewed.getQuick(rowNum, index);
1:     }
1: 
1:     @Override
1:     public Vector like() {
1:       throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public void setQuick(int index, double value) {
1:       viewed.setQuick(rowNum, index, value);
1: 
1:     }
1: 
1:     @Override
1:     public int getNumNondefaultElements() {
1:       throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
0:     protected Matrix matrixLike(int rows, int columns) {
1:       throw new UnsupportedOperationException();
1:     }
1: 
1:   }
1: 
0:   public static class DeepCopyUTIterator implements Iterator<UpperTriangular> {
1: 
0:     private Iterator<UpperTriangular> delegate;
1: 
0:     public DeepCopyUTIterator(Iterator<UpperTriangular> del) {
0:       super();
0:       delegate = del;
1:     }
1: 
0:     public boolean hasNext() {
0:       return delegate.hasNext();
1:     }
1: 
0:     public UpperTriangular next() {
1: 
0:       return new UpperTriangular(delegate.next());
1:     }
1: 
0:     public void remove() {
0:       delegate.remove();
1:     }
1: 
1:   }
1: 
1: }
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:8b194c8
/////////////////////////////////////////////////////////////////////////
0:  * Givens Thin solver. Standard Givens operations are reordered in a way that
0:  * helps us to push them thru MapReduce operations in a block fashion.
commit:58cc1ae
/////////////////////////////////////////////////////////////////////////
0:  * Givens Thin solver. Standard Givens OPERATIONS are reordered in a way that
0:  * helps us to push them thru MapReduce OPERATIONS in a block fashion.
commit:74f849b
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
1:       List<Vector> ei = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:         List<Vector> ej = Lists.newArrayList();
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:4ca6b86
/////////////////////////////////////////////////////////////////////////
1:       int[] indices = updates.getIndices();
1:       double[] values = updates.getValues();
commit:4194a28
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private final double[][] mQt;
1:   private final double[][] mR;
commit:39fe224
/////////////////////////////////////////////////////////////////////////
1:       if (Math.abs(1.0 - norm) < epsilon) {
/////////////////////////////////////////////////////////////////////////
1:         if (!(Math.abs((i == j && rank > j ? 1.0 : 0.0) - dot) < epsilon)) {
1:     return insufficientRank ? rank < n : rank == n;
/////////////////////////////////////////////////////////////////////////
1:     return insufficientRank ? rank < n : rank == n;
commit:3218e95
/////////////////////////////////////////////////////////////////////////
1:   private static final class TriangularRowView extends AbstractVector {
/////////////////////////////////////////////////////////////////////////
1:     public Matrix matrixLike(int rows, int columns) {
commit:a13b4b7
/////////////////////////////////////////////////////////////////////////
1:   private final int n; // m-row cnt, n- column count, m>=n
1:   private final double[] cs = new double[2];
1:     if (!(m >= n)) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:       for (int j = 0; j < n; j++) {
1:       }
/////////////////////////////////////////////////////////////////////////
1:     if (newM == m) {
1:     }
1:     if (newM < n) {
1:     }
1:     if (newM < cnt) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     if (cnt >= m) {
1:       throw new IllegalStateException("thin QR solver fed more rows than initialized for");
1:     }
/////////////////////////////////////////////////////////////////////////
1:     for (int i = 0; i < n; i++) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     if (c == 0) {
1:     }
1:     if (Math.abs(s) < Math.abs(c)) {
1:     } else {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     for (int i = 0; i < kp; i++) {
1:     }
1:   public static double[][] mergeQrUp(double[][] qt1, UpperTriangular r1, UpperTriangular r2) {
1:     for (int i = 0; i < kp; i++) {
1:     }
1:   public static double[][] mergeQrDown(double[][] r1, double[][] qt2, double[][] r2) {
1:     for (int i = 0; i < kp; i++) {
1:     }
1:   public static double[][] mergeQrDown(UpperTriangular r1, double[][] qt2, UpperTriangular r2) {
1:     for (int i = 0; i < kp; i++) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     for (int j = 1; j < i; j++) {
1:     }
1:     if (i > 0) {
1:     }
1:     while (rIter.hasNext()) {
1:     }
1:   public static boolean isOrthonormal(double[][] qt, boolean insufficientRank, double epsilon) {
/////////////////////////////////////////////////////////////////////////
1:       if (Math.abs(1 - norm) < epsilon) {
1:       } else if (Math.abs(norm) > epsilon) {
1:       }
1:         if (!(Math.abs((i == j && rank > j ? 1 : 0) - dot) < epsilon)) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:       for (double[][] qtHat : qtHats) {
1:       }
1:       for (Vector v : ei) {
1:       }
0:       if (Math.abs(1 - norm) < epsilon) {
1:       } else if (Math.abs(norm) > epsilon) {
1:       }
1:         for (double[][] qtHat : qtHats) {
1:         }
1:         for (int k = 0; k < ei.size(); k++) {
1:         }
0:         if (!(Math.abs((i == j && rank > j ? 1 : 0) - dot) < epsilon)) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private final UpperTriangular viewed;
1:     private TriangularRowView(UpperTriangular viewed) {
/////////////////////////////////////////////////////////////////////////
author:dfilimon
-------------------------------------------------------------------------------
commit:a8d3dbd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.OrderedIntDoubleMapping;
/////////////////////////////////////////////////////////////////////////
1:     public double getLookupCost() {
1:       return 1;
0:     }
0: 
1:     @Override
1:     public double getIteratorAdvanceCost() {
1:       return 1;
0:     }
0: 
1:     @Override
1:     public boolean isAddConstantTime() {
1:       return true;
0:     }
0: 
1:     @Override
1:     /**
1:      * Used internally by assign() to update multiple indices and values at once.
1:      * Only really useful for sparse vectors (especially SequentialAccessSparseVector).
1:      * <p/>
1:      * If someone ever adds a new type of sparse vectors, this method must merge (index, value) pairs into the vector.
0:      *
1:      * @param updates a mapping of indices to values to merge in the vector.
1:      */
1:     @Override
1:     public void mergeUpdates(OrderedIntDoubleMapping updates) {
0:       int indices[] = updates.getIndices();
0:       double values[] = updates.getValues();
1:       for (int i = 0; i < updates.getNumMappings(); ++i) {
1:         viewed.setQuick(rowNum, indices[i], values[i]);
0:       }
0:     }
0: 
author:Ted Dunning
-------------------------------------------------------------------------------
commit:33414e6
/////////////////////////////////////////////////////////////////////////
1:     row += rStartRow;
1:     return mR[row >= n ? row - n : row];
/////////////////////////////////////////////////////////////////////////
1:       packedR.assignNonZeroElementsInRow(i, getRRow(i));
commit:528ffcd
/////////////////////////////////////////////////////////////////////////
1:       Vector aRowV = a.viewRow(i);
============================================================================