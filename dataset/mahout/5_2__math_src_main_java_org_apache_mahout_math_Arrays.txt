1:35fa73f: /*
1:35fa73f: Copyright 1999 CERN - European Organization for Nuclear Research.
1:35fa73f: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1:35fa73f: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1:35fa73f: that both that copyright notice and this permission notice appear in supporting documentation. 
1:35fa73f: CERN makes no representations about the suitability of this software for any purpose. 
1:35fa73f: It is provided "as is" without expressed or implied warranty.
35:35fa73f: */
1:35fa73f: package org.apache.mahout.math;
1:7926fcb: 
35:35fa73f: /**
1:35fa73f:  * Array manipulations; complements <tt>java.util.Arrays</tt>.
37:35fa73f:  *
1:35fa73f:  * @see java.util.Arrays
1:35fa73f:  * @see org.apache.mahout.math.Sorting
1:35fa73f:  *
1:35fa73f:  */
1:35fa73f: public final class Arrays {
1:7926fcb: 
1:7926fcb:   private Arrays() {
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:7926fcb:    *
1:7926fcb:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:7926fcb:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:7926fcb:    * elements specified by the minimum capacity argument.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public static byte[] ensureCapacity(byte[] array, int minCapacity) {
1:7926fcb:     int oldCapacity = array.length;
1:7926fcb:     byte[] newArray;
1:7926fcb:     if (minCapacity > oldCapacity) {
1:7926fcb:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:7926fcb:       if (newCapacity < minCapacity) {
1:7926fcb:         newCapacity = minCapacity;
1:7926fcb:       }
1:7926fcb: 
1:fcbc54a:       newArray = new byte[newCapacity];
1:fcbc54a:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:7926fcb:     } else {
1:7926fcb:       newArray = array;
1:fcbc54a:     }
1:7926fcb:     return newArray;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:7926fcb:    *
1:7926fcb:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:7926fcb:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:7926fcb:    * elements specified by the minimum capacity argument.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public static char[] ensureCapacity(char[] array, int minCapacity) {
1:7926fcb:     int oldCapacity = array.length;
1:7926fcb:     char[] newArray;
1:7926fcb:     if (minCapacity > oldCapacity) {
1:7926fcb:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:7926fcb:       if (newCapacity < minCapacity) {
1:7926fcb:         newCapacity = minCapacity;
1:7926fcb:       }
1:7926fcb: 
1:fcbc54a:       newArray = new char[newCapacity];
1:fcbc54a:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:7926fcb:     } else {
1:7926fcb:       newArray = array;
1:7926fcb:     }
1:7926fcb:     return newArray;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:7926fcb:    *
1:7926fcb:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:7926fcb:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:7926fcb:    * elements specified by the minimum capacity argument.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public static double[] ensureCapacity(double[] array, int minCapacity) {
1:7926fcb:     int oldCapacity = array.length;
1:7926fcb:     double[] newArray;
1:7926fcb:     if (minCapacity > oldCapacity) {
1:7926fcb:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:7926fcb:       if (newCapacity < minCapacity) {
1:7926fcb:         newCapacity = minCapacity;
1:7926fcb:       }
1:7926fcb: 
1:fcbc54a:       newArray = new double[newCapacity];
1:fcbc54a:       //for (int i = oldCapacity; --i >= 0; ) newArray[i] = array[i];
1:fcbc54a:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:7926fcb:     } else {
1:7926fcb:       newArray = array;
1:7926fcb:     }
1:7926fcb:     return newArray;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:7926fcb:    *
1:7926fcb:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:7926fcb:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:7926fcb:    * elements specified by the minimum capacity argument.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public static float[] ensureCapacity(float[] array, int minCapacity) {
1:7926fcb:     int oldCapacity = array.length;
1:7926fcb:     float[] newArray;
1:7926fcb:     if (minCapacity > oldCapacity) {
1:7926fcb:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:7926fcb:       if (newCapacity < minCapacity) {
1:7926fcb:         newCapacity = minCapacity;
1:7926fcb:       }
1:7926fcb: 
1:fcbc54a:       newArray = new float[newCapacity];
1:fcbc54a:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:7926fcb:     } else {
1:7926fcb:       newArray = array;
1:7926fcb:     }
1:7926fcb:     return newArray;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:7926fcb:    *
1:7926fcb:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:7926fcb:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:7926fcb:    * elements specified by the minimum capacity argument.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public static int[] ensureCapacity(int[] array, int minCapacity) {
1:7926fcb:     int oldCapacity = array.length;
1:7926fcb:     int[] newArray;
1:7926fcb:     if (minCapacity > oldCapacity) {
1:7926fcb:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:7926fcb:       if (newCapacity < minCapacity) {
1:7926fcb:         newCapacity = minCapacity;
1:7926fcb:       }
1:7926fcb: 
1:fcbc54a:       newArray = new int[newCapacity];
1:fcbc54a:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:7926fcb:     } else {
1:7926fcb:       newArray = array;
1:7926fcb:     }
1:7926fcb:     return newArray;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:7926fcb:    *
1:7926fcb:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:7926fcb:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:7926fcb:    * elements specified by the minimum capacity argument.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public static long[] ensureCapacity(long[] array, int minCapacity) {
1:7926fcb:     int oldCapacity = array.length;
1:7926fcb:     long[] newArray;
1:7926fcb:     if (minCapacity > oldCapacity) {
1:7926fcb:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:7926fcb:       if (newCapacity < minCapacity) {
1:7926fcb:         newCapacity = minCapacity;
1:7926fcb:       }
1:7926fcb: 
1:fcbc54a:       newArray = new long[newCapacity];
1:fcbc54a:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:7926fcb:     } else {
1:7926fcb:       newArray = array;
1:7926fcb:     }
1:7926fcb:     return newArray;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:7926fcb:    *
1:7926fcb:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:7926fcb:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:7926fcb:    * elements specified by the minimum capacity argument.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public static Object[] ensureCapacity(Object[] array, int minCapacity) {
1:7926fcb:     int oldCapacity = array.length;
1:7926fcb:     Object[] newArray;
1:7926fcb:     if (minCapacity > oldCapacity) {
1:7926fcb:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:7926fcb:       if (newCapacity < minCapacity) {
1:7926fcb:         newCapacity = minCapacity;
1:7926fcb:       }
1:7926fcb: 
1:fcbc54a:       newArray = new Object[newCapacity];
1:fcbc54a:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:7926fcb:     } else {
1:7926fcb:       newArray = array;
1:7926fcb:     }
1:7926fcb:     return newArray;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:7926fcb:    *
1:7926fcb:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:7926fcb:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:7926fcb:    * elements specified by the minimum capacity argument.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public static short[] ensureCapacity(short[] array, int minCapacity) {
1:7926fcb:     int oldCapacity = array.length;
1:7926fcb:     short[] newArray;
1:7926fcb:     if (minCapacity > oldCapacity) {
1:7926fcb:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:7926fcb:       if (newCapacity < minCapacity) {
1:7926fcb:         newCapacity = minCapacity;
1:7926fcb:       }
1:7926fcb: 
1:fcbc54a:       newArray = new short[newCapacity];
1:fcbc54a:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:7926fcb:     } else {
1:7926fcb:       newArray = array;
1:7926fcb:     }
1:7926fcb:     return newArray;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:7926fcb:    *
1:7926fcb:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:7926fcb:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:7926fcb:    * elements specified by the minimum capacity argument.
1:7926fcb:    *
1:7926fcb:    * @param minCapacity the desired minimum capacity.
1:7926fcb:    */
1:7926fcb:   public static boolean[] ensureCapacity(boolean[] array, int minCapacity) {
1:7926fcb:     int oldCapacity = array.length;
1:7926fcb:     boolean[] newArray;
1:7926fcb:     if (minCapacity > oldCapacity) {
1:7926fcb:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:7926fcb:       if (newCapacity < minCapacity) {
1:7926fcb:         newCapacity = minCapacity;
1:7926fcb:       }
1:7926fcb: 
1:fcbc54a:       newArray = new boolean[newCapacity];
1:fcbc54a:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:7926fcb:     } else {
1:7926fcb:       newArray = array;
1:7926fcb:     }
1:7926fcb:     return newArray;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:7926fcb:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:7926fcb:    * <tt>", "</tt> (comma and space).
1:7926fcb:    *
1:7926fcb:    * @return a string representation of the specified array.
1:7926fcb:    */
1:7926fcb:   public static String toString(byte[] array) {
1:7926fcb:     StringBuilder buf = new StringBuilder();
1:a90e57e:     buf.append('[');
1:7926fcb:     int maxIndex = array.length - 1;
1:7926fcb:     for (int i = 0; i <= maxIndex; i++) {
1:fcbc54a:       buf.append(array[i]);
1:7926fcb:       if (i < maxIndex) {
1:7926fcb:         buf.append(", ");
1:7926fcb:       }
1:7926fcb:     }
1:a90e57e:     buf.append(']');
1:7926fcb:     return buf.toString();
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:7926fcb:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:7926fcb:    * <tt>", "</tt> (comma and space).
1:7926fcb:    *
1:7926fcb:    * @return a string representation of the specified array.
1:7926fcb:    */
1:7926fcb:   public static String toString(char[] array) {
1:7926fcb:     StringBuilder buf = new StringBuilder();
1:a90e57e:     buf.append('[');
1:7926fcb:     int maxIndex = array.length - 1;
1:7926fcb:     for (int i = 0; i <= maxIndex; i++) {
1:fcbc54a:       buf.append(array[i]);
1:7926fcb:       if (i < maxIndex) {
1:7926fcb:         buf.append(", ");
1:7926fcb:       }
1:7926fcb:     }
1:a90e57e:     buf.append(']');
1:7926fcb:     return buf.toString();
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:7926fcb:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:7926fcb:    * <tt>", "</tt> (comma and space).
1:7926fcb:    *
1:7926fcb:    * @return a string representation of the specified array.
1:7926fcb:    */
1:7926fcb:   public static String toString(double[] array) {
1:7926fcb:     StringBuilder buf = new StringBuilder();
1:a90e57e:     buf.append('[');
1:7926fcb:     int maxIndex = array.length - 1;
1:7926fcb:     for (int i = 0; i <= maxIndex; i++) {
1:fcbc54a:       buf.append(array[i]);
1:7926fcb:       if (i < maxIndex) {
1:7926fcb:         buf.append(", ");
1:7926fcb:       }
1:7926fcb:     }
1:a90e57e:     buf.append(']');
1:7926fcb:     return buf.toString();
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:7926fcb:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:7926fcb:    * <tt>", "</tt> (comma and space).
1:7926fcb:    *
1:7926fcb:    * @return a string representation of the specified array.
1:7926fcb:    */
1:7926fcb:   public static String toString(float[] array) {
1:7926fcb:     StringBuilder buf = new StringBuilder();
1:a90e57e:     buf.append('[');
1:7926fcb:     int maxIndex = array.length - 1;
1:7926fcb:     for (int i = 0; i <= maxIndex; i++) {
1:fcbc54a:       buf.append(array[i]);
1:7926fcb:       if (i < maxIndex) {
1:7926fcb:         buf.append(", ");
1:7926fcb:       }
1:7926fcb:     }
1:a90e57e:     buf.append(']');
1:7926fcb:     return buf.toString();
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:7926fcb:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:7926fcb:    * <tt>", "</tt> (comma and space).
1:7926fcb:    *
1:7926fcb:    * @return a string representation of the specified array.
1:7926fcb:    */
1:7926fcb:   public static String toString(int[] array) {
1:7926fcb:     StringBuilder buf = new StringBuilder();
1:a90e57e:     buf.append('[');
1:7926fcb:     int maxIndex = array.length - 1;
1:7926fcb:     for (int i = 0; i <= maxIndex; i++) {
1:fcbc54a:       buf.append(array[i]);
1:7926fcb:       if (i < maxIndex) {
1:7926fcb:         buf.append(", ");
1:7926fcb:       }
1:7926fcb:     }
1:a90e57e:     buf.append(']');
1:7926fcb:     return buf.toString();
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:7926fcb:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:7926fcb:    * <tt>", "</tt> (comma and space).
1:7926fcb:    *
1:7926fcb:    * @return a string representation of the specified array.
1:7926fcb:    */
1:7926fcb:   public static String toString(long[] array) {
1:7926fcb:     StringBuilder buf = new StringBuilder();
1:a90e57e:     buf.append('[');
1:7926fcb:     int maxIndex = array.length - 1;
1:7926fcb:     for (int i = 0; i <= maxIndex; i++) {
1:fcbc54a:       buf.append(array[i]);
1:7926fcb:       if (i < maxIndex) {
1:7926fcb:         buf.append(", ");
1:7926fcb:       }
1:7926fcb:     }
1:a90e57e:     buf.append(']');
1:7926fcb:     return buf.toString();
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:7926fcb:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:7926fcb:    * <tt>", "</tt> (comma and space).
1:7926fcb:    *
1:7926fcb:    * @return a string representation of the specified array.
1:7926fcb:    */
1:7926fcb:   public static String toString(Object[] array) {
1:7926fcb:     StringBuilder buf = new StringBuilder();
1:a90e57e:     buf.append('[');
1:7926fcb:     int maxIndex = array.length - 1;
1:7926fcb:     for (int i = 0; i <= maxIndex; i++) {
1:fcbc54a:       buf.append(array[i]);
1:7926fcb:       if (i < maxIndex) {
1:7926fcb:         buf.append(", ");
1:7926fcb:       }
1:7926fcb:     }
1:a90e57e:     buf.append(']');
1:7926fcb:     return buf.toString();
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:7926fcb:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:7926fcb:    * <tt>", "</tt> (comma and space).
1:7926fcb:    *
1:7926fcb:    * @return a string representation of the specified array.
1:7926fcb:    */
1:7926fcb:   public static String toString(short[] array) {
1:7926fcb:     StringBuilder buf = new StringBuilder();
1:a90e57e:     buf.append('[');
1:7926fcb:     int maxIndex = array.length - 1;
1:7926fcb:     for (int i = 0; i <= maxIndex; i++) {
1:fcbc54a:       buf.append(array[i]);
1:7926fcb:       if (i < maxIndex) {
1:7926fcb:         buf.append(", ");
1:7926fcb:       }
1:7926fcb:     }
1:a90e57e:     buf.append(']');
1:7926fcb:     return buf.toString();
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:7926fcb:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:7926fcb:    * <tt>", "</tt> (comma and space).
1:7926fcb:    *
1:7926fcb:    * @return a string representation of the specified array.
1:7926fcb:    */
1:7926fcb:   public static String toString(boolean[] array) {
1:7926fcb:     StringBuilder buf = new StringBuilder();
1:a90e57e:     buf.append('[');
1:7926fcb:     int maxIndex = array.length - 1;
1:7926fcb:     for (int i = 0; i <= maxIndex; i++) {
1:fcbc54a:       buf.append(array[i]);
1:7926fcb:       if (i < maxIndex) {
1:7926fcb:         buf.append(", ");
1:7926fcb:       }
1:7926fcb:     }
1:a90e57e:     buf.append(']');
1:7926fcb:     return buf.toString();
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:7926fcb:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:7926fcb:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:7926fcb:    * elements of <tt>array</tt>.
1:7926fcb:    *
1:7926fcb:    * @param maxCapacity the desired maximum capacity.
1:7926fcb:    */
1:7926fcb:   public static byte[] trimToCapacity(byte[] array, int maxCapacity) {
1:7926fcb:     if (array.length > maxCapacity) {
1:7926fcb:       byte[] oldArray = array;
1:fcbc54a:       array = new byte[maxCapacity];
1:fcbc54a:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
1:7926fcb:     }
1:7926fcb:     return array;
1:fcbc54a:   }
1:e244bca: 
1:e244bca:   /**
1:7926fcb:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:7926fcb:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:7926fcb:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:7926fcb:    * elements of <tt>array</tt>.
1:7926fcb:    *
1:7926fcb:    * @param maxCapacity the desired maximum capacity.
1:7926fcb:    */
1:7926fcb:   public static char[] trimToCapacity(char[] array, int maxCapacity) {
1:7926fcb:     if (array.length > maxCapacity) {
1:7926fcb:       char[] oldArray = array;
1:fcbc54a:       array = new char[maxCapacity];
1:fcbc54a:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
1:7926fcb:     }
1:7926fcb:     return array;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:7926fcb:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:7926fcb:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:7926fcb:    * elements of <tt>array</tt>.
1:7926fcb:    *
1:7926fcb:    * @param maxCapacity the desired maximum capacity.
1:7926fcb:    */
1:7926fcb:   public static double[] trimToCapacity(double[] array, int maxCapacity) {
1:7926fcb:     if (array.length > maxCapacity) {
1:7926fcb:       double[] oldArray = array;
1:fcbc54a:       array = new double[maxCapacity];
1:fcbc54a:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
1:7926fcb:     }
1:7926fcb:     return array;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:7926fcb:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:7926fcb:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:7926fcb:    * elements of <tt>array</tt>.
1:7926fcb:    *
1:7926fcb:    * @param maxCapacity the desired maximum capacity.
1:7926fcb:    */
1:7926fcb:   public static float[] trimToCapacity(float[] array, int maxCapacity) {
1:7926fcb:     if (array.length > maxCapacity) {
1:7926fcb:       float[] oldArray = array;
1:fcbc54a:       array = new float[maxCapacity];
1:fcbc54a:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
1:7926fcb:     }
1:7926fcb:     return array;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:7926fcb:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:7926fcb:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:7926fcb:    * elements of <tt>array</tt>.
1:7926fcb:    *
1:7926fcb:    * @param maxCapacity the desired maximum capacity.
1:7926fcb:    */
1:7926fcb:   public static int[] trimToCapacity(int[] array, int maxCapacity) {
1:7926fcb:     if (array.length > maxCapacity) {
1:7926fcb:       int[] oldArray = array;
1:fcbc54a:       array = new int[maxCapacity];
1:fcbc54a:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
1:7926fcb:     }
1:7926fcb:     return array;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:7926fcb:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:7926fcb:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:7926fcb:    * elements of <tt>array</tt>.
1:7926fcb:    *
1:7926fcb:    * @param maxCapacity the desired maximum capacity.
1:7926fcb:    */
1:7926fcb:   public static long[] trimToCapacity(long[] array, int maxCapacity) {
1:7926fcb:     if (array.length > maxCapacity) {
1:7926fcb:       long[] oldArray = array;
1:fcbc54a:       array = new long[maxCapacity];
1:fcbc54a:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
1:7926fcb:     }
1:7926fcb:     return array;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:7926fcb:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:7926fcb:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:7926fcb:    * elements of <tt>array</tt>.
1:7926fcb:    *
1:7926fcb:    * @param maxCapacity the desired maximum capacity.
1:7926fcb:    */
1:7926fcb:   public static Object[] trimToCapacity(Object[] array, int maxCapacity) {
1:7926fcb:     if (array.length > maxCapacity) {
1:7926fcb:       Object[] oldArray = array;
1:fcbc54a:       array = new Object[maxCapacity];
1:fcbc54a:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
1:7926fcb:     }
1:7926fcb:     return array;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:7926fcb:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:7926fcb:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:7926fcb:    * elements of <tt>array</tt>.
1:7926fcb:    *
1:7926fcb:    * @param maxCapacity the desired maximum capacity.
1:7926fcb:    */
1:7926fcb:   public static short[] trimToCapacity(short[] array, int maxCapacity) {
1:7926fcb:     if (array.length > maxCapacity) {
1:7926fcb:       short[] oldArray = array;
1:fcbc54a:       array = new short[maxCapacity];
1:fcbc54a:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
1:7926fcb:     }
1:7926fcb:     return array;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:7926fcb:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:7926fcb:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:7926fcb:    * elements of <tt>array</tt>.
1:7926fcb:    *
1:7926fcb:    * @param maxCapacity the desired maximum capacity.
1:7926fcb:    */
1:7926fcb:   public static boolean[] trimToCapacity(boolean[] array, int maxCapacity) {
1:7926fcb:     if (array.length > maxCapacity) {
1:7926fcb:       boolean[] oldArray = array;
1:fcbc54a:       array = new boolean[maxCapacity];
1:fcbc54a:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
1:7926fcb:     }
1:7926fcb:     return array;
1:fcbc54a:   }
1:7926fcb: 
1:7926fcb:   /**
1:e244bca:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:e244bca:    */
1:e244bca:   public static byte[] copyOf(byte[] src, int length) {
1:229aeff:     byte[] result = new byte [length];
1:229aeff:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:229aeff:     return result;
1:e244bca:   }
1:e244bca:   
1:e244bca:   /**
1:e244bca:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:e244bca:    */
1:e244bca:   public static char[] copyOf(char[] src, int length) {
1:229aeff:     char[] result = new char [length];
1:229aeff:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:229aeff:     return result;
1:e244bca:   }
1:e244bca:   
1:e244bca:   /**
1:e244bca:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:e244bca:    */
1:e244bca:   public static short[] copyOf(short[] src, int length) {
1:229aeff:     short[] result = new short [length];
1:229aeff:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:229aeff:     return result;
1:e244bca:   }
1:e244bca:   
1:e244bca:   /**
1:e244bca:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5. 
1:e244bca:    */
1:e244bca:   public static int[] copyOf(int[] src, int length) {
1:229aeff:     int[] result = new int [length];
1:229aeff:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:229aeff:     return result;
1:e244bca:   }
1:e244bca:   
1:e244bca:   /**
1:e244bca:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:e244bca:    */
1:e244bca:   public static float[] copyOf(float[] src, int length) {
1:229aeff:     float[] result = new float [length];
1:229aeff:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:229aeff:     return result;
1:e244bca:   }
1:e244bca: 
1:e244bca:   /**
1:e244bca:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:e244bca:    */
1:e244bca:   public static double[] copyOf(double[] src, int length) {
1:229aeff:     double[] result = new double [length];
1:229aeff:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:229aeff:     return result;
1:e244bca:   }
1:e244bca:   
1:e244bca:   /**
1:e244bca:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:e244bca:    */
1:e244bca:   public static long[] copyOf(long[] src, int length) {
1:229aeff:     long[] result = new long [length];
1:229aeff:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:229aeff:     return result;
1:e244bca:   }
1:fcbc54a: }
============================================================================
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:229aeff
/////////////////////////////////////////////////////////////////////////
1:     byte[] result = new byte [length];
1:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:     return result;
1:     char[] result = new char [length];
1:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:     return result;
1:     short[] result = new short [length];
1:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:     return result;
1:     int[] result = new int [length];
1:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:     return result;
1:     float[] result = new float [length];
1:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:     return result;
1:     double[] result = new double [length];
1:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:     return result;
1:     long[] result = new long [length];
1:     System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
1:     return result;
commit:e244bca
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
1:   public static byte[] copyOf(byte[] src, int length) {
0:       byte[] result = new byte [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
1:   }
1:   
1:   /**
1:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
1:   public static char[] copyOf(char[] src, int length) {
0:       char[] result = new char [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
1:   }
1:   
1:   /**
1:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
1:   public static short[] copyOf(short[] src, int length) {
0:       short[] result = new short [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
1:   }
1:   
1:   /**
1:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5. 
1:    */
1:   public static int[] copyOf(int[] src, int length) {
0:       int[] result = new int [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
1:   }
1:   
1:   /**
1:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
1:   public static float[] copyOf(float[] src, int length) {
0:       float[] result = new float [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
1:   }
1: 
1:   /**
1:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
1:   public static double[] copyOf(double[] src, int length) {
0:       double[] result = new double [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
1:   }
1:   
1:   /**
1:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
1:   public static long[] copyOf(long[] src, int length) {
0:       long[] result = new long [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
1:   }
commit:a90e57e
/////////////////////////////////////////////////////////////////////////
1:     buf.append('[');
/////////////////////////////////////////////////////////////////////////
1:     buf.append(']');
/////////////////////////////////////////////////////////////////////////
1:     buf.append('[');
/////////////////////////////////////////////////////////////////////////
1:     buf.append(']');
/////////////////////////////////////////////////////////////////////////
1:     buf.append('[');
/////////////////////////////////////////////////////////////////////////
1:     buf.append(']');
/////////////////////////////////////////////////////////////////////////
1:     buf.append('[');
/////////////////////////////////////////////////////////////////////////
1:     buf.append(']');
/////////////////////////////////////////////////////////////////////////
1:     buf.append('[');
/////////////////////////////////////////////////////////////////////////
1:     buf.append(']');
/////////////////////////////////////////////////////////////////////////
1:     buf.append('[');
/////////////////////////////////////////////////////////////////////////
1:     buf.append(']');
/////////////////////////////////////////////////////////////////////////
1:     buf.append('[');
/////////////////////////////////////////////////////////////////////////
1:     buf.append(']');
/////////////////////////////////////////////////////////////////////////
1:     buf.append('[');
/////////////////////////////////////////////////////////////////////////
1:     buf.append(']');
/////////////////////////////////////////////////////////////////////////
1:     buf.append('[');
/////////////////////////////////////////////////////////////////////////
1:     buf.append(']');
commit:7926fcb
/////////////////////////////////////////////////////////////////////////
1: 
0: /** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
0: public class Arrays {
1: 
0:   /** Makes this class non instantiable, but still let's others inherit from it. */
1:   private Arrays() {
1:   }
1: 
1:   /**
1:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
1:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:    * elements specified by the minimum capacity argument.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public static byte[] ensureCapacity(byte[] array, int minCapacity) {
1:     int oldCapacity = array.length;
1:     byte[] newArray;
1:     if (minCapacity > oldCapacity) {
1:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:       if (newCapacity < minCapacity) {
1:         newCapacity = minCapacity;
1:       }
1: 
1:     } else {
1:       newArray = array;
1:     return newArray;
1:   }
1: 
1:   /**
1:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
1:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:    * elements specified by the minimum capacity argument.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public static char[] ensureCapacity(char[] array, int minCapacity) {
1:     int oldCapacity = array.length;
1:     char[] newArray;
1:     if (minCapacity > oldCapacity) {
1:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:       if (newCapacity < minCapacity) {
1:         newCapacity = minCapacity;
1:       }
1: 
1:     } else {
1:       newArray = array;
1:     return newArray;
1:   }
1: 
1:   /**
1:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
1:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:    * elements specified by the minimum capacity argument.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public static double[] ensureCapacity(double[] array, int minCapacity) {
1:     int oldCapacity = array.length;
1:     double[] newArray;
1:     if (minCapacity > oldCapacity) {
1:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:       if (newCapacity < minCapacity) {
1:         newCapacity = minCapacity;
1:       }
1: 
1:     } else {
1:       newArray = array;
1:     return newArray;
1:   }
1: 
1:   /**
1:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
1:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:    * elements specified by the minimum capacity argument.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public static float[] ensureCapacity(float[] array, int minCapacity) {
1:     int oldCapacity = array.length;
1:     float[] newArray;
1:     if (minCapacity > oldCapacity) {
1:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:       if (newCapacity < minCapacity) {
1:         newCapacity = minCapacity;
1:       }
1: 
1:     } else {
1:       newArray = array;
1:     return newArray;
1:   }
1: 
1:   /**
1:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
1:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:    * elements specified by the minimum capacity argument.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public static int[] ensureCapacity(int[] array, int minCapacity) {
1:     int oldCapacity = array.length;
1:     int[] newArray;
1:     if (minCapacity > oldCapacity) {
1:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:       if (newCapacity < minCapacity) {
1:         newCapacity = minCapacity;
1:       }
1: 
1:     } else {
1:       newArray = array;
1:     return newArray;
1:   }
1: 
1:   /**
1:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
1:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:    * elements specified by the minimum capacity argument.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public static long[] ensureCapacity(long[] array, int minCapacity) {
1:     int oldCapacity = array.length;
1:     long[] newArray;
1:     if (minCapacity > oldCapacity) {
1:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:       if (newCapacity < minCapacity) {
1:         newCapacity = minCapacity;
1:       }
1: 
1:     } else {
1:       newArray = array;
1:     return newArray;
1:   }
1: 
1:   /**
1:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
1:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:    * elements specified by the minimum capacity argument.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public static Object[] ensureCapacity(Object[] array, int minCapacity) {
1:     int oldCapacity = array.length;
1:     Object[] newArray;
1:     if (minCapacity > oldCapacity) {
1:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:       if (newCapacity < minCapacity) {
1:         newCapacity = minCapacity;
1:       }
1: 
1:     } else {
1:       newArray = array;
1:     return newArray;
1:   }
1: 
1:   /**
1:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
1:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:    * elements specified by the minimum capacity argument.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public static short[] ensureCapacity(short[] array, int minCapacity) {
1:     int oldCapacity = array.length;
1:     short[] newArray;
1:     if (minCapacity > oldCapacity) {
1:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:       if (newCapacity < minCapacity) {
1:         newCapacity = minCapacity;
1:       }
1: 
1:     } else {
1:       newArray = array;
1:     return newArray;
1:   }
1: 
1:   /**
1:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
1:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
1:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
1:    * elements specified by the minimum capacity argument.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public static boolean[] ensureCapacity(boolean[] array, int minCapacity) {
1:     int oldCapacity = array.length;
1:     boolean[] newArray;
1:     if (minCapacity > oldCapacity) {
1:       int newCapacity = (oldCapacity * 3) / 2 + 1;
1:       if (newCapacity < minCapacity) {
1:         newCapacity = minCapacity;
1:       }
1: 
1:     } else {
1:       newArray = array;
1:     }
1:     return newArray;
1: 
1:   /**
1:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:    * <tt>", "</tt> (comma and space).
1:    *
1:    * @return a string representation of the specified array.
1:    */
1:   public static String toString(byte[] array) {
1:     StringBuilder buf = new StringBuilder();
0:     buf.append("[");
1:     int maxIndex = array.length - 1;
1:     for (int i = 0; i <= maxIndex; i++) {
1:       if (i < maxIndex) {
1:         buf.append(", ");
1:       }
1:     }
0:     buf.append("]");
1:     return buf.toString();
1: 
1:   /**
1:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:    * <tt>", "</tt> (comma and space).
1:    *
1:    * @return a string representation of the specified array.
1:    */
1:   public static String toString(char[] array) {
1:     StringBuilder buf = new StringBuilder();
0:     buf.append("[");
1:     int maxIndex = array.length - 1;
1:     for (int i = 0; i <= maxIndex; i++) {
1:       if (i < maxIndex) {
1:         buf.append(", ");
1:       }
1:     }
0:     buf.append("]");
1:     return buf.toString();
1: 
1:   /**
1:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:    * <tt>", "</tt> (comma and space).
1:    *
1:    * @return a string representation of the specified array.
1:    */
1:   public static String toString(double[] array) {
1:     StringBuilder buf = new StringBuilder();
0:     buf.append("[");
1:     int maxIndex = array.length - 1;
1:     for (int i = 0; i <= maxIndex; i++) {
1:       if (i < maxIndex) {
1:         buf.append(", ");
1:       }
1:     }
0:     buf.append("]");
1:     return buf.toString();
1: 
1:   /**
1:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:    * <tt>", "</tt> (comma and space).
1:    *
1:    * @return a string representation of the specified array.
1:    */
1:   public static String toString(float[] array) {
1:     StringBuilder buf = new StringBuilder();
0:     buf.append("[");
1:     int maxIndex = array.length - 1;
1:     for (int i = 0; i <= maxIndex; i++) {
1:       if (i < maxIndex) {
1:         buf.append(", ");
1:       }
1:     }
0:     buf.append("]");
1:     return buf.toString();
1: 
1:   /**
1:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:    * <tt>", "</tt> (comma and space).
1:    *
1:    * @return a string representation of the specified array.
1:    */
1:   public static String toString(int[] array) {
1:     StringBuilder buf = new StringBuilder();
0:     buf.append("[");
1:     int maxIndex = array.length - 1;
1:     for (int i = 0; i <= maxIndex; i++) {
1:       if (i < maxIndex) {
1:         buf.append(", ");
1:       }
1:     }
0:     buf.append("]");
1:     return buf.toString();
1: 
1:   /**
1:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:    * <tt>", "</tt> (comma and space).
1:    *
1:    * @return a string representation of the specified array.
1:    */
1:   public static String toString(long[] array) {
1:     StringBuilder buf = new StringBuilder();
0:     buf.append("[");
1:     int maxIndex = array.length - 1;
1:     for (int i = 0; i <= maxIndex; i++) {
1:       if (i < maxIndex) {
1:         buf.append(", ");
1:       }
1:     }
0:     buf.append("]");
1:     return buf.toString();
1: 
1:   /**
1:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:    * <tt>", "</tt> (comma and space).
1:    *
1:    * @return a string representation of the specified array.
1:    */
1:   public static String toString(Object[] array) {
1:     StringBuilder buf = new StringBuilder();
0:     buf.append("[");
1:     int maxIndex = array.length - 1;
1:     for (int i = 0; i <= maxIndex; i++) {
1:       if (i < maxIndex) {
1:         buf.append(", ");
1:       }
1:     }
0:     buf.append("]");
1:     return buf.toString();
1: 
1:   /**
1:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:    * <tt>", "</tt> (comma and space).
1:    *
1:    * @return a string representation of the specified array.
1:    */
1:   public static String toString(short[] array) {
1:     StringBuilder buf = new StringBuilder();
0:     buf.append("[");
1:     int maxIndex = array.length - 1;
1:     for (int i = 0; i <= maxIndex; i++) {
1:       if (i < maxIndex) {
1:         buf.append(", ");
1:       }
1:     }
0:     buf.append("]");
1:     return buf.toString();
1: 
1:   /**
1:    * Returns a string representation of the specified array.  The string representation consists of a list of the
1:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
1:    * <tt>", "</tt> (comma and space).
1:    *
1:    * @return a string representation of the specified array.
1:    */
1:   public static String toString(boolean[] array) {
1:     StringBuilder buf = new StringBuilder();
0:     buf.append("[");
1:     int maxIndex = array.length - 1;
1:     for (int i = 0; i <= maxIndex; i++) {
1:       if (i < maxIndex) {
1:         buf.append(", ");
1:       }
1:     }
0:     buf.append("]");
1:     return buf.toString();
1: 
1:   /**
1:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:    * elements of <tt>array</tt>.
1:    *
1:    * @param maxCapacity the desired maximum capacity.
1:    */
1:   public static byte[] trimToCapacity(byte[] array, int maxCapacity) {
1:     if (array.length > maxCapacity) {
1:       byte[] oldArray = array;
1:     }
1:     return array;
1: 
1:   /**
1:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:    * elements of <tt>array</tt>.
1:    *
1:    * @param maxCapacity the desired maximum capacity.
1:    */
1:   public static char[] trimToCapacity(char[] array, int maxCapacity) {
1:     if (array.length > maxCapacity) {
1:       char[] oldArray = array;
1:     }
1:     return array;
1: 
1:   /**
1:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:    * elements of <tt>array</tt>.
1:    *
1:    * @param maxCapacity the desired maximum capacity.
1:    */
1:   public static double[] trimToCapacity(double[] array, int maxCapacity) {
1:     if (array.length > maxCapacity) {
1:       double[] oldArray = array;
1:     }
1:     return array;
1: 
1:   /**
1:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:    * elements of <tt>array</tt>.
1:    *
1:    * @param maxCapacity the desired maximum capacity.
1:    */
1:   public static float[] trimToCapacity(float[] array, int maxCapacity) {
1:     if (array.length > maxCapacity) {
1:       float[] oldArray = array;
1:     }
1:     return array;
1: 
1:   /**
1:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:    * elements of <tt>array</tt>.
1:    *
1:    * @param maxCapacity the desired maximum capacity.
1:    */
1:   public static int[] trimToCapacity(int[] array, int maxCapacity) {
1:     if (array.length > maxCapacity) {
1:       int[] oldArray = array;
1:     }
1:     return array;
1: 
1:   /**
1:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:    * elements of <tt>array</tt>.
1:    *
1:    * @param maxCapacity the desired maximum capacity.
1:    */
1:   public static long[] trimToCapacity(long[] array, int maxCapacity) {
1:     if (array.length > maxCapacity) {
1:       long[] oldArray = array;
1:     }
1:     return array;
1: 
1:   /**
1:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:    * elements of <tt>array</tt>.
1:    *
1:    * @param maxCapacity the desired maximum capacity.
1:    */
1:   public static Object[] trimToCapacity(Object[] array, int maxCapacity) {
1:     if (array.length > maxCapacity) {
1:       Object[] oldArray = array;
1:     }
1:     return array;
1: 
1:   /**
1:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:    * elements of <tt>array</tt>.
1:    *
1:    * @param maxCapacity the desired maximum capacity.
1:    */
1:   public static short[] trimToCapacity(short[] array, int maxCapacity) {
1:     if (array.length > maxCapacity) {
1:       short[] oldArray = array;
1:     }
1:     return array;
1: 
1:   /**
1:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
1:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
1:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
1:    * elements of <tt>array</tt>.
1:    *
1:    * @param maxCapacity the desired maximum capacity.
1:    */
1:   public static boolean[] trimToCapacity(boolean[] array, int maxCapacity) {
1:     if (array.length > maxCapacity) {
1:       boolean[] oldArray = array;
1:     }
1:     return array;
commit:fcbc54a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = array.length;
0:   byte[] newArray;
0:   if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3)/2 + 1;
0:     if (newCapacity < minCapacity) {
0:       newCapacity = minCapacity;
1:     }
0:     
1:       newArray = new byte[newCapacity];
1:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:   }
0:   else {
0:     newArray=array;
1:   }
0:   return newArray;
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = array.length;
0:   char[] newArray;
0:   if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3)/2 + 1;
0:     if (newCapacity < minCapacity) {
0:       newCapacity = minCapacity;
1:     }
0:     
1:       newArray = new char[newCapacity];
1:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:   }
0:   else {
0:     newArray=array;
1:   }
0:   return newArray;
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = array.length;
0:   double[] newArray;
0:   if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3)/2 + 1;
0:     if (newCapacity < minCapacity) {
0:       newCapacity = minCapacity;
1:     }
0:     
1:       newArray = new double[newCapacity];
1:       //for (int i = oldCapacity; --i >= 0; ) newArray[i] = array[i];
1:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:   }
0:   else {
0:     newArray=array;
1:   }
0:   return newArray;
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = array.length;
0:   float[] newArray;
0:   if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3)/2 + 1;
0:     if (newCapacity < minCapacity) {
0:       newCapacity = minCapacity;
1:     }
0:     
1:       newArray = new float[newCapacity];
1:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:   }
0:   else {
0:     newArray=array;
1:   }
0:   return newArray;
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = array.length;
0:   int[] newArray;
0:   if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3)/2 + 1;
0:     if (newCapacity < minCapacity) {
0:       newCapacity = minCapacity;
1:     }
0:     
1:       newArray = new int[newCapacity];
1:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:   }
0:   else {
0:     newArray=array;
1:   }
0:   return newArray;
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = array.length;
0:   long[] newArray;
0:   if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3)/2 + 1;
0:     if (newCapacity < minCapacity) {
0:       newCapacity = minCapacity;
1:     }
0:     
1:       newArray = new long[newCapacity];
1:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:   }
0:   else {
0:     newArray=array;
1:   }
0:   return newArray;
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = array.length;
0:   Object[] newArray;
0:   if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3)/2 + 1;
0:     if (newCapacity < minCapacity) {
0:       newCapacity = minCapacity;
1:     }
0:     
1:       newArray = new Object[newCapacity];
1:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:   }
0:   else {
0:     newArray=array;
1:   }
0:   return newArray;
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = array.length;
0:   short[] newArray;
0:   if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3)/2 + 1;
0:     if (newCapacity < minCapacity) {
0:       newCapacity = minCapacity;
1:     }
0:     
1:       newArray = new short[newCapacity];
1:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:   }
0:   else {
0:     newArray=array;
1:   }
0:   return newArray;
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = array.length;
0:   boolean[] newArray;
0:   if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3)/2 + 1;
0:     if (newCapacity < minCapacity) {
0:       newCapacity = minCapacity;
1:     }
0:     
1:       newArray = new boolean[newCapacity];
1:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
1:   }
0:   else {
0:     newArray=array;
1:   }
0:   return newArray;
/////////////////////////////////////////////////////////////////////////
0:   StringBuffer buf = new StringBuffer();
0:   buf.append("[");
0:   int maxIndex = array.length - 1;
0:   for (int i = 0; i <= maxIndex; i++) {
1:       buf.append(array[i]);
0:       if (i < maxIndex)
0:     buf.append(", ");
1:   }
0:   buf.append("]");
0:   return buf.toString();
/////////////////////////////////////////////////////////////////////////
0:   StringBuffer buf = new StringBuffer();
0:   buf.append("[");
0:   int maxIndex = array.length - 1;
0:   for (int i = 0; i <= maxIndex; i++) {
1:       buf.append(array[i]);
0:       if (i < maxIndex)
0:     buf.append(", ");
0:   }
0:   buf.append("]");
0:   return buf.toString();
/////////////////////////////////////////////////////////////////////////
0:   StringBuffer buf = new StringBuffer();
0:   buf.append("[");
0:   int maxIndex = array.length - 1;
0:   for (int i = 0; i <= maxIndex; i++) {
1:       buf.append(array[i]);
0:       if (i < maxIndex)
0:     buf.append(", ");
0:   }
0:   buf.append("]");
0:   return buf.toString();
/////////////////////////////////////////////////////////////////////////
0:   StringBuffer buf = new StringBuffer();
0:   buf.append("[");
0:   int maxIndex = array.length - 1;
0:   for (int i = 0; i <= maxIndex; i++) {
1:       buf.append(array[i]);
0:       if (i < maxIndex)
0:     buf.append(", ");
0:   }
0:   buf.append("]");
0:   return buf.toString();
/////////////////////////////////////////////////////////////////////////
0:   StringBuffer buf = new StringBuffer();
0:   buf.append("[");
0:   int maxIndex = array.length - 1;
0:   for (int i = 0; i <= maxIndex; i++) {
1:       buf.append(array[i]);
0:       if (i < maxIndex)
0:     buf.append(", ");
0:   }
0:   buf.append("]");
0:   return buf.toString();
/////////////////////////////////////////////////////////////////////////
0:   StringBuffer buf = new StringBuffer();
0:   buf.append("[");
0:   int maxIndex = array.length - 1;
0:   for (int i = 0; i <= maxIndex; i++) {
1:       buf.append(array[i]);
0:       if (i < maxIndex)
0:     buf.append(", ");
0:   }
0:   buf.append("]");
0:   return buf.toString();
/////////////////////////////////////////////////////////////////////////
0:   StringBuffer buf = new StringBuffer();
0:   buf.append("[");
0:   int maxIndex = array.length - 1;
0:   for (int i = 0; i <= maxIndex; i++) {
1:       buf.append(array[i]);
0:       if (i < maxIndex)
0:     buf.append(", ");
0:   }
0:   buf.append("]");
0:   return buf.toString();
/////////////////////////////////////////////////////////////////////////
0:   StringBuffer buf = new StringBuffer();
0:   buf.append("[");
0:   int maxIndex = array.length - 1;
0:   for (int i = 0; i <= maxIndex; i++) {
1:       buf.append(array[i]);
0:       if (i < maxIndex)
0:     buf.append(", ");
0:   }
0:   buf.append("]");
0:   return buf.toString();
/////////////////////////////////////////////////////////////////////////
0:   StringBuffer buf = new StringBuffer();
0:   buf.append("[");
0:   int maxIndex = array.length - 1;
0:   for (int i = 0; i <= maxIndex; i++) {
1:       buf.append(array[i]);
0:       if (i < maxIndex)
0:     buf.append(", ");
0:   }
0:   buf.append("]");
0:   return buf.toString();
/////////////////////////////////////////////////////////////////////////
0:   if (array.length > maxCapacity) {
0:       byte oldArray[] = array;
1:       array = new byte[maxCapacity];
1:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:   }
0:   return array;
/////////////////////////////////////////////////////////////////////////
0:   if (array.length > maxCapacity) {
0:       char oldArray[] = array;
1:       array = new char[maxCapacity];
1:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:   }
0:   return array;
/////////////////////////////////////////////////////////////////////////
0:   if (array.length > maxCapacity) {
0:       double oldArray[] = array;
1:       array = new double[maxCapacity];
1:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:   }
0:   return array;
/////////////////////////////////////////////////////////////////////////
0:   if (array.length > maxCapacity) {
0:       float oldArray[] = array;
1:       array = new float[maxCapacity];
1:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:   }
0:   return array;
/////////////////////////////////////////////////////////////////////////
0:   if (array.length > maxCapacity) {
0:       int oldArray[] = array;
1:       array = new int[maxCapacity];
1:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:   }
0:   return array;
/////////////////////////////////////////////////////////////////////////
0:   if (array.length > maxCapacity) {
0:       long oldArray[] = array;
1:       array = new long[maxCapacity];
1:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:   }
0:   return array;
/////////////////////////////////////////////////////////////////////////
0:   if (array.length > maxCapacity) {
0:       Object oldArray[] = array;
1:       array = new Object[maxCapacity];
1:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:   }
0:   return array;
/////////////////////////////////////////////////////////////////////////
0:   if (array.length > maxCapacity) {
0:       short oldArray[] = array;
1:       array = new short[maxCapacity];
1:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:   }
0:   return array;
/////////////////////////////////////////////////////////////////////////
0:   if (array.length > maxCapacity) {
0:       boolean oldArray[] = array;
1:       array = new boolean[maxCapacity];
1:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:   }
0:   return array;
author:Ted Dunning
-------------------------------------------------------------------------------
commit:35fa73f
/////////////////////////////////////////////////////////////////////////
1: /*
1: Copyright 1999 CERN - European Organization for Nuclear Research.
1: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1: that both that copyright notice and this permission notice appear in supporting documentation. 
1: CERN makes no representations about the suitability of this software for any purpose. 
1: It is provided "as is" without expressed or implied warranty.
1: */
1: package org.apache.mahout.math;
0: 
1: /**
1:  * Array manipulations; complements <tt>java.util.Arrays</tt>.
1:  *
1:  * @see java.util.Arrays
1:  * @see org.apache.mahout.math.Sorting
1:  *
1:  */
1: public final class Arrays {
0: 
0:   private Arrays() {
0:   }
0: 
1:   /**
0:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
0:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
0:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
0:    * elements specified by the minimum capacity argument.
1:    *
0:    * @param minCapacity the desired minimum capacity.
1:    */
0:   public static byte[] ensureCapacity(byte[] array, int minCapacity) {
0:     int oldCapacity = array.length;
0:     byte[] newArray;
0:     if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3) / 2 + 1;
0:       if (newCapacity < minCapacity) {
0:         newCapacity = minCapacity;
0:       }
0: 
0:       newArray = new byte[newCapacity];
0:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
0:     } else {
0:       newArray = array;
0:     }
0:     return newArray;
0:   }
0: 
1:   /**
0:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
0:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
0:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
0:    * elements specified by the minimum capacity argument.
1:    *
0:    * @param minCapacity the desired minimum capacity.
1:    */
0:   public static char[] ensureCapacity(char[] array, int minCapacity) {
0:     int oldCapacity = array.length;
0:     char[] newArray;
0:     if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3) / 2 + 1;
0:       if (newCapacity < minCapacity) {
0:         newCapacity = minCapacity;
0:       }
0: 
0:       newArray = new char[newCapacity];
0:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
0:     } else {
0:       newArray = array;
0:     }
0:     return newArray;
0:   }
0: 
1:   /**
0:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
0:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
0:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
0:    * elements specified by the minimum capacity argument.
1:    *
0:    * @param minCapacity the desired minimum capacity.
1:    */
0:   public static double[] ensureCapacity(double[] array, int minCapacity) {
0:     int oldCapacity = array.length;
0:     double[] newArray;
0:     if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3) / 2 + 1;
0:       if (newCapacity < minCapacity) {
0:         newCapacity = minCapacity;
0:       }
0: 
0:       newArray = new double[newCapacity];
0:       //for (int i = oldCapacity; --i >= 0; ) newArray[i] = array[i];
0:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
0:     } else {
0:       newArray = array;
0:     }
0:     return newArray;
0:   }
0: 
1:   /**
0:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
0:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
0:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
0:    * elements specified by the minimum capacity argument.
1:    *
0:    * @param minCapacity the desired minimum capacity.
1:    */
0:   public static float[] ensureCapacity(float[] array, int minCapacity) {
0:     int oldCapacity = array.length;
0:     float[] newArray;
0:     if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3) / 2 + 1;
0:       if (newCapacity < minCapacity) {
0:         newCapacity = minCapacity;
0:       }
0: 
0:       newArray = new float[newCapacity];
0:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
0:     } else {
0:       newArray = array;
0:     }
0:     return newArray;
0:   }
0: 
1:   /**
0:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
0:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
0:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
0:    * elements specified by the minimum capacity argument.
1:    *
0:    * @param minCapacity the desired minimum capacity.
1:    */
0:   public static int[] ensureCapacity(int[] array, int minCapacity) {
0:     int oldCapacity = array.length;
0:     int[] newArray;
0:     if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3) / 2 + 1;
0:       if (newCapacity < minCapacity) {
0:         newCapacity = minCapacity;
0:       }
0: 
0:       newArray = new int[newCapacity];
0:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
0:     } else {
0:       newArray = array;
0:     }
0:     return newArray;
0:   }
0: 
1:   /**
0:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
0:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
0:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
0:    * elements specified by the minimum capacity argument.
1:    *
0:    * @param minCapacity the desired minimum capacity.
1:    */
0:   public static long[] ensureCapacity(long[] array, int minCapacity) {
0:     int oldCapacity = array.length;
0:     long[] newArray;
0:     if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3) / 2 + 1;
0:       if (newCapacity < minCapacity) {
0:         newCapacity = minCapacity;
0:       }
0: 
0:       newArray = new long[newCapacity];
0:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
0:     } else {
0:       newArray = array;
0:     }
0:     return newArray;
0:   }
0: 
1:   /**
0:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
0:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
0:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
0:    * elements specified by the minimum capacity argument.
1:    *
0:    * @param minCapacity the desired minimum capacity.
1:    */
0:   public static Object[] ensureCapacity(Object[] array, int minCapacity) {
0:     int oldCapacity = array.length;
0:     Object[] newArray;
0:     if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3) / 2 + 1;
0:       if (newCapacity < minCapacity) {
0:         newCapacity = minCapacity;
0:       }
0: 
0:       newArray = new Object[newCapacity];
0:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
0:     } else {
0:       newArray = array;
0:     }
0:     return newArray;
0:   }
0: 
1:   /**
0:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
0:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
0:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
0:    * elements specified by the minimum capacity argument.
1:    *
0:    * @param minCapacity the desired minimum capacity.
1:    */
0:   public static short[] ensureCapacity(short[] array, int minCapacity) {
0:     int oldCapacity = array.length;
0:     short[] newArray;
0:     if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3) / 2 + 1;
0:       if (newCapacity < minCapacity) {
0:         newCapacity = minCapacity;
0:       }
0: 
0:       newArray = new short[newCapacity];
0:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
0:     } else {
0:       newArray = array;
0:     }
0:     return newArray;
0:   }
0: 
1:   /**
0:    * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
1:    *
0:    * Returns the identical array if it can hold at least the number of elements specified. Otherwise, returns a new
0:    * array with increased capacity containing the same elements, ensuring that it can hold at least the number of
0:    * elements specified by the minimum capacity argument.
1:    *
0:    * @param minCapacity the desired minimum capacity.
1:    */
0:   public static boolean[] ensureCapacity(boolean[] array, int minCapacity) {
0:     int oldCapacity = array.length;
0:     boolean[] newArray;
0:     if (minCapacity > oldCapacity) {
0:       int newCapacity = (oldCapacity * 3) / 2 + 1;
0:       if (newCapacity < minCapacity) {
0:         newCapacity = minCapacity;
0:       }
0: 
0:       newArray = new boolean[newCapacity];
0:       System.arraycopy(array, 0, newArray, 0, oldCapacity);
0:     } else {
0:       newArray = array;
0:     }
0:     return newArray;
0:   }
0: 
1:   /**
0:    * Returns a string representation of the specified array.  The string representation consists of a list of the
0:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:    * <tt>", "</tt> (comma and space).
1:    *
0:    * @return a string representation of the specified array.
1:    */
0:   public static String toString(byte[] array) {
0:     StringBuilder buf = new StringBuilder();
0:     buf.append('[');
0:     int maxIndex = array.length - 1;
0:     for (int i = 0; i <= maxIndex; i++) {
0:       buf.append(array[i]);
0:       if (i < maxIndex) {
0:         buf.append(", ");
0:       }
0:     }
0:     buf.append(']');
0:     return buf.toString();
0:   }
0: 
1:   /**
0:    * Returns a string representation of the specified array.  The string representation consists of a list of the
0:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:    * <tt>", "</tt> (comma and space).
1:    *
0:    * @return a string representation of the specified array.
1:    */
0:   public static String toString(char[] array) {
0:     StringBuilder buf = new StringBuilder();
0:     buf.append('[');
0:     int maxIndex = array.length - 1;
0:     for (int i = 0; i <= maxIndex; i++) {
0:       buf.append(array[i]);
0:       if (i < maxIndex) {
0:         buf.append(", ");
0:       }
0:     }
0:     buf.append(']');
0:     return buf.toString();
0:   }
0: 
1:   /**
0:    * Returns a string representation of the specified array.  The string representation consists of a list of the
0:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:    * <tt>", "</tt> (comma and space).
1:    *
0:    * @return a string representation of the specified array.
1:    */
0:   public static String toString(double[] array) {
0:     StringBuilder buf = new StringBuilder();
0:     buf.append('[');
0:     int maxIndex = array.length - 1;
0:     for (int i = 0; i <= maxIndex; i++) {
0:       buf.append(array[i]);
0:       if (i < maxIndex) {
0:         buf.append(", ");
0:       }
0:     }
0:     buf.append(']');
0:     return buf.toString();
0:   }
0: 
1:   /**
0:    * Returns a string representation of the specified array.  The string representation consists of a list of the
0:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:    * <tt>", "</tt> (comma and space).
1:    *
0:    * @return a string representation of the specified array.
1:    */
0:   public static String toString(float[] array) {
0:     StringBuilder buf = new StringBuilder();
0:     buf.append('[');
0:     int maxIndex = array.length - 1;
0:     for (int i = 0; i <= maxIndex; i++) {
0:       buf.append(array[i]);
0:       if (i < maxIndex) {
0:         buf.append(", ");
0:       }
0:     }
0:     buf.append(']');
0:     return buf.toString();
0:   }
0: 
1:   /**
0:    * Returns a string representation of the specified array.  The string representation consists of a list of the
0:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:    * <tt>", "</tt> (comma and space).
1:    *
0:    * @return a string representation of the specified array.
1:    */
0:   public static String toString(int[] array) {
0:     StringBuilder buf = new StringBuilder();
0:     buf.append('[');
0:     int maxIndex = array.length - 1;
0:     for (int i = 0; i <= maxIndex; i++) {
0:       buf.append(array[i]);
0:       if (i < maxIndex) {
0:         buf.append(", ");
0:       }
0:     }
0:     buf.append(']');
0:     return buf.toString();
0:   }
0: 
1:   /**
0:    * Returns a string representation of the specified array.  The string representation consists of a list of the
0:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:    * <tt>", "</tt> (comma and space).
1:    *
0:    * @return a string representation of the specified array.
1:    */
0:   public static String toString(long[] array) {
0:     StringBuilder buf = new StringBuilder();
0:     buf.append('[');
0:     int maxIndex = array.length - 1;
0:     for (int i = 0; i <= maxIndex; i++) {
0:       buf.append(array[i]);
0:       if (i < maxIndex) {
0:         buf.append(", ");
0:       }
0:     }
0:     buf.append(']');
0:     return buf.toString();
0:   }
0: 
1:   /**
0:    * Returns a string representation of the specified array.  The string representation consists of a list of the
0:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:    * <tt>", "</tt> (comma and space).
1:    *
0:    * @return a string representation of the specified array.
1:    */
0:   public static String toString(Object[] array) {
0:     StringBuilder buf = new StringBuilder();
0:     buf.append('[');
0:     int maxIndex = array.length - 1;
0:     for (int i = 0; i <= maxIndex; i++) {
0:       buf.append(array[i]);
0:       if (i < maxIndex) {
0:         buf.append(", ");
0:       }
0:     }
0:     buf.append(']');
0:     return buf.toString();
0:   }
0: 
1:   /**
0:    * Returns a string representation of the specified array.  The string representation consists of a list of the
0:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:    * <tt>", "</tt> (comma and space).
1:    *
0:    * @return a string representation of the specified array.
1:    */
0:   public static String toString(short[] array) {
0:     StringBuilder buf = new StringBuilder();
0:     buf.append('[');
0:     int maxIndex = array.length - 1;
0:     for (int i = 0; i <= maxIndex; i++) {
0:       buf.append(array[i]);
0:       if (i < maxIndex) {
0:         buf.append(", ");
0:       }
0:     }
0:     buf.append(']');
0:     return buf.toString();
0:   }
0: 
1:   /**
0:    * Returns a string representation of the specified array.  The string representation consists of a list of the
0:    * arrays's elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:    * <tt>", "</tt> (comma and space).
1:    *
0:    * @return a string representation of the specified array.
1:    */
0:   public static String toString(boolean[] array) {
0:     StringBuilder buf = new StringBuilder();
0:     buf.append('[');
0:     int maxIndex = array.length - 1;
0:     for (int i = 0; i <= maxIndex; i++) {
0:       buf.append(array[i]);
0:       if (i < maxIndex) {
0:         buf.append(", ");
0:       }
0:     }
0:     buf.append(']');
0:     return buf.toString();
0:   }
0: 
1:   /**
0:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
0:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
0:    * elements of <tt>array</tt>.
1:    *
0:    * @param maxCapacity the desired maximum capacity.
1:    */
0:   public static byte[] trimToCapacity(byte[] array, int maxCapacity) {
0:     if (array.length > maxCapacity) {
0:       byte[] oldArray = array;
0:       array = new byte[maxCapacity];
0:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:     }
0:     return array;
0:   }
0: 
1:   /**
0:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
0:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
0:    * elements of <tt>array</tt>.
1:    *
0:    * @param maxCapacity the desired maximum capacity.
1:    */
0:   public static char[] trimToCapacity(char[] array, int maxCapacity) {
0:     if (array.length > maxCapacity) {
0:       char[] oldArray = array;
0:       array = new char[maxCapacity];
0:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:     }
0:     return array;
0:   }
0: 
1:   /**
0:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
0:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
0:    * elements of <tt>array</tt>.
1:    *
0:    * @param maxCapacity the desired maximum capacity.
1:    */
0:   public static double[] trimToCapacity(double[] array, int maxCapacity) {
0:     if (array.length > maxCapacity) {
0:       double[] oldArray = array;
0:       array = new double[maxCapacity];
0:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:     }
0:     return array;
0:   }
0: 
1:   /**
0:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
0:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
0:    * elements of <tt>array</tt>.
1:    *
0:    * @param maxCapacity the desired maximum capacity.
1:    */
0:   public static float[] trimToCapacity(float[] array, int maxCapacity) {
0:     if (array.length > maxCapacity) {
0:       float[] oldArray = array;
0:       array = new float[maxCapacity];
0:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:     }
0:     return array;
0:   }
0: 
1:   /**
0:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
0:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
0:    * elements of <tt>array</tt>.
1:    *
0:    * @param maxCapacity the desired maximum capacity.
1:    */
0:   public static int[] trimToCapacity(int[] array, int maxCapacity) {
0:     if (array.length > maxCapacity) {
0:       int[] oldArray = array;
0:       array = new int[maxCapacity];
0:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:     }
0:     return array;
0:   }
0: 
1:   /**
0:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
0:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
0:    * elements of <tt>array</tt>.
1:    *
0:    * @param maxCapacity the desired maximum capacity.
1:    */
0:   public static long[] trimToCapacity(long[] array, int maxCapacity) {
0:     if (array.length > maxCapacity) {
0:       long[] oldArray = array;
0:       array = new long[maxCapacity];
0:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:     }
0:     return array;
0:   }
0: 
1:   /**
0:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
0:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
0:    * elements of <tt>array</tt>.
1:    *
0:    * @param maxCapacity the desired maximum capacity.
1:    */
0:   public static Object[] trimToCapacity(Object[] array, int maxCapacity) {
0:     if (array.length > maxCapacity) {
0:       Object[] oldArray = array;
0:       array = new Object[maxCapacity];
0:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:     }
0:     return array;
0:   }
0: 
1:   /**
0:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
0:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
0:    * elements of <tt>array</tt>.
1:    *
0:    * @param maxCapacity the desired maximum capacity.
1:    */
0:   public static short[] trimToCapacity(short[] array, int maxCapacity) {
0:     if (array.length > maxCapacity) {
0:       short[] oldArray = array;
0:       array = new short[maxCapacity];
0:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:     }
0:     return array;
0:   }
0: 
1:   /**
0:    * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements. An application can use this
0:    * operation to minimize array storage. <p> Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:    * Otherwise, returns a new array with a length of <tt>maxCapacity</tt> containing the first <tt>maxCapacity</tt>
0:    * elements of <tt>array</tt>.
1:    *
0:    * @param maxCapacity the desired maximum capacity.
1:    */
0:   public static boolean[] trimToCapacity(boolean[] array, int maxCapacity) {
0:     if (array.length > maxCapacity) {
0:       boolean[] oldArray = array;
0:       array = new boolean[maxCapacity];
0:       System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0:     }
0:     return array;
0:   }
0: 
1:   /**
0:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
0:   public static byte[] copyOf(byte[] src, int length) {
0:       byte[] result = new byte [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
0:   }
0:   
1:   /**
0:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
0:   public static char[] copyOf(char[] src, int length) {
0:       char[] result = new char [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
0:   }
0:   
1:   /**
0:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
0:   public static short[] copyOf(short[] src, int length) {
0:       short[] result = new short [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
0:   }
0:   
1:   /**
0:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5. 
1:    */
0:   public static int[] copyOf(int[] src, int length) {
0:       int[] result = new int [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
0:   }
0:   
1:   /**
0:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
0:   public static float[] copyOf(float[] src, int length) {
0:       float[] result = new float [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
0:   }
0: 
1:   /**
0:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
0:   public static double[] copyOf(double[] src, int length) {
0:       double[] result = new double [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
0:   }
0:   
1:   /**
0:    * {@link java.util.Arrays#copyOf} compatibility with Java 1.5.
1:    */
0:   public static long[] copyOf(long[] src, int length) {
0:       long[] result = new long [length];
0:       System.arraycopy(src, 0, result, 0, Math.min(length, src.length));
0:       return result;
0:   }
0: }
author:Benson Margulies
-------------------------------------------------------------------------------
commit:ebf9a4d
/////////////////////////////////////////////////////////////////////////
author:Robin Anil
-------------------------------------------------------------------------------
commit:a51dd9e
/////////////////////////////////////////////////////////////////////////
0: public final class Arrays {
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:a435efb
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.math;
0:  * @see org.apache.mahout.math.Sorting
commit:f49424e
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.matrix;
0:  * @see org.apache.mahout.matrix.Sorting
commit:7550a10
/////////////////////////////////////////////////////////////////////////
0: /*
0: Copyright 1999 CERN - European Organization for Nuclear Research.
0: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
0: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
0: that both that copyright notice and this permission notice appear in supporting documentation. 
0: CERN makes no representations about the suitability of this software for any purpose. 
0: It is provided "as is" without expressed or implied warranty.
0: */
0: package org.apache.mahout.colt;
0: 
0: /**
0:  * Array manipulations; complements <tt>java.util.Arrays</tt>.
0:  *
0:  * @see java.util.Arrays
0:  * @see org.apache.mahout.colt.Sorting
0:  *
0:  * @author wolfgang.hoschek@cern.ch
0:  * @version 1.0, 03-Jul-99
0:  */
0: /** 
0:  * @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported.
0:  */
0: @Deprecated
0: public class Arrays extends Object {
0: /**
0:  * Makes this class non instantiable, but still let's others inherit from it.
0:  */
0: protected Arrays() {}
0: /**
0:  * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
0:  *
0:  * Returns the identical array if it can hold at least the number of elements specified.
0:  * Otherwise, returns a new array with increased capacity containing the same elements, ensuring  
0:  * that it can hold at least the number of elements specified by 
0:  * the minimum capacity argument.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public static byte[] ensureCapacity(byte[] array, int minCapacity) {
0: 	int oldCapacity = array.length;
0: 	byte[] newArray;
0: 	if (minCapacity > oldCapacity) {
0: 	    int newCapacity = (oldCapacity * 3)/2 + 1;
0: 		if (newCapacity < minCapacity) {
0: 			newCapacity = minCapacity;
0: 		}
0: 		
0: 	    newArray = new byte[newCapacity];
0: 	    System.arraycopy(array, 0, newArray, 0, oldCapacity);
0: 	}
0: 	else {
0: 		newArray=array;
0: 	}
0: 	return newArray;
0: }
0: /**
0:  * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
0:  *
0:  * Returns the identical array if it can hold at least the number of elements specified.
0:  * Otherwise, returns a new array with increased capacity containing the same elements, ensuring  
0:  * that it can hold at least the number of elements specified by 
0:  * the minimum capacity argument.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public static char[] ensureCapacity(char[] array, int minCapacity) {
0: 	int oldCapacity = array.length;
0: 	char[] newArray;
0: 	if (minCapacity > oldCapacity) {
0: 	    int newCapacity = (oldCapacity * 3)/2 + 1;
0: 		if (newCapacity < minCapacity) {
0: 			newCapacity = minCapacity;
0: 		}
0: 		
0: 	    newArray = new char[newCapacity];
0: 	    System.arraycopy(array, 0, newArray, 0, oldCapacity);
0: 	}
0: 	else {
0: 		newArray=array;
0: 	}
0: 	return newArray;
0: }
0: /**
0:  * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
0:  *
0:  * Returns the identical array if it can hold at least the number of elements specified.
0:  * Otherwise, returns a new array with increased capacity containing the same elements, ensuring  
0:  * that it can hold at least the number of elements specified by 
0:  * the minimum capacity argument.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public static double[] ensureCapacity(double[] array, int minCapacity) {
0: 	int oldCapacity = array.length;
0: 	double[] newArray;
0: 	if (minCapacity > oldCapacity) {
0: 	    int newCapacity = (oldCapacity * 3)/2 + 1;
0: 		if (newCapacity < minCapacity) {
0: 			newCapacity = minCapacity;
0: 		}
0: 		
0: 	    newArray = new double[newCapacity];
0: 	    //for (int i = oldCapacity; --i >= 0; ) newArray[i] = array[i];
0: 	    System.arraycopy(array, 0, newArray, 0, oldCapacity);
0: 	}
0: 	else {
0: 		newArray=array;
0: 	}
0: 	return newArray;
0: }
0: /**
0:  * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
0:  *
0:  * Returns the identical array if it can hold at least the number of elements specified.
0:  * Otherwise, returns a new array with increased capacity containing the same elements, ensuring  
0:  * that it can hold at least the number of elements specified by 
0:  * the minimum capacity argument.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public static float[] ensureCapacity(float[] array, int minCapacity) {
0: 	int oldCapacity = array.length;
0: 	float[] newArray;
0: 	if (minCapacity > oldCapacity) {
0: 	    int newCapacity = (oldCapacity * 3)/2 + 1;
0: 		if (newCapacity < minCapacity) {
0: 			newCapacity = minCapacity;
0: 		}
0: 		
0: 	    newArray = new float[newCapacity];
0: 	    System.arraycopy(array, 0, newArray, 0, oldCapacity);
0: 	}
0: 	else {
0: 		newArray=array;
0: 	}
0: 	return newArray;
0: }
0: /**
0:  * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
0:  *
0:  * Returns the identical array if it can hold at least the number of elements specified.
0:  * Otherwise, returns a new array with increased capacity containing the same elements, ensuring  
0:  * that it can hold at least the number of elements specified by 
0:  * the minimum capacity argument.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public static int[] ensureCapacity(int[] array, int minCapacity) {
0: 	int oldCapacity = array.length;
0: 	int[] newArray;
0: 	if (minCapacity > oldCapacity) {
0: 	    int newCapacity = (oldCapacity * 3)/2 + 1;
0: 		if (newCapacity < minCapacity) {
0: 			newCapacity = minCapacity;
0: 		}
0: 		
0: 	    newArray = new int[newCapacity];
0: 	    System.arraycopy(array, 0, newArray, 0, oldCapacity);
0: 	}
0: 	else {
0: 		newArray=array;
0: 	}
0: 	return newArray;
0: }
0: /**
0:  * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
0:  *
0:  * Returns the identical array if it can hold at least the number of elements specified.
0:  * Otherwise, returns a new array with increased capacity containing the same elements, ensuring  
0:  * that it can hold at least the number of elements specified by 
0:  * the minimum capacity argument.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public static long[] ensureCapacity(long[] array, int minCapacity) {
0: 	int oldCapacity = array.length;
0: 	long[] newArray;
0: 	if (minCapacity > oldCapacity) {
0: 	    int newCapacity = (oldCapacity * 3)/2 + 1;
0: 		if (newCapacity < minCapacity) {
0: 			newCapacity = minCapacity;
0: 		}
0: 		
0: 	    newArray = new long[newCapacity];
0: 	    System.arraycopy(array, 0, newArray, 0, oldCapacity);
0: 	}
0: 	else {
0: 		newArray=array;
0: 	}
0: 	return newArray;
0: }
0: /**
0:  * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
0:  *
0:  * Returns the identical array if it can hold at least the number of elements specified.
0:  * Otherwise, returns a new array with increased capacity containing the same elements, ensuring  
0:  * that it can hold at least the number of elements specified by 
0:  * the minimum capacity argument.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public static Object[] ensureCapacity(Object[] array, int minCapacity) {
0: 	int oldCapacity = array.length;
0: 	Object[] newArray;
0: 	if (minCapacity > oldCapacity) {
0: 	    int newCapacity = (oldCapacity * 3)/2 + 1;
0: 		if (newCapacity < minCapacity) {
0: 			newCapacity = minCapacity;
0: 		}
0: 		
0: 	    newArray = new Object[newCapacity];
0: 	    System.arraycopy(array, 0, newArray, 0, oldCapacity);
0: 	}
0: 	else {
0: 		newArray=array;
0: 	}
0: 	return newArray;
0: }
0: /**
0:  * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
0:  *
0:  * Returns the identical array if it can hold at least the number of elements specified.
0:  * Otherwise, returns a new array with increased capacity containing the same elements, ensuring  
0:  * that it can hold at least the number of elements specified by 
0:  * the minimum capacity argument.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public static short[] ensureCapacity(short[] array, int minCapacity) {
0: 	int oldCapacity = array.length;
0: 	short[] newArray;
0: 	if (minCapacity > oldCapacity) {
0: 	    int newCapacity = (oldCapacity * 3)/2 + 1;
0: 		if (newCapacity < minCapacity) {
0: 			newCapacity = minCapacity;
0: 		}
0: 		
0: 	    newArray = new short[newCapacity];
0: 	    System.arraycopy(array, 0, newArray, 0, oldCapacity);
0: 	}
0: 	else {
0: 		newArray=array;
0: 	}
0: 	return newArray;
0: }
0: /**
0:  * Ensures that a given array can hold up to <tt>minCapacity</tt> elements.
0:  *
0:  * Returns the identical array if it can hold at least the number of elements specified.
0:  * Otherwise, returns a new array with increased capacity containing the same elements, ensuring  
0:  * that it can hold at least the number of elements specified by 
0:  * the minimum capacity argument.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public static boolean[] ensureCapacity(boolean[] array, int minCapacity) {
0: 	int oldCapacity = array.length;
0: 	boolean[] newArray;
0: 	if (minCapacity > oldCapacity) {
0: 	    int newCapacity = (oldCapacity * 3)/2 + 1;
0: 		if (newCapacity < minCapacity) {
0: 			newCapacity = minCapacity;
0: 		}
0: 		
0: 	    newArray = new boolean[newCapacity];
0: 	    System.arraycopy(array, 0, newArray, 0, oldCapacity);
0: 	}
0: 	else {
0: 		newArray=array;
0: 	}
0: 	return newArray;
0: }
0: /**
0:  * Returns a string representation of the specified array.  The string
0:  * representation consists of a list of the arrays's elements, enclosed in square brackets
0:  * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:  * <tt>", "</tt> (comma and space).
0:  * @return a string representation of the specified array.
0:  */
0: public static String toString(byte[] array) {
0: 	StringBuffer buf = new StringBuffer();
0: 	buf.append("[");
0: 	int maxIndex = array.length - 1;
0: 	for (int i = 0; i <= maxIndex; i++) {
0: 	    buf.append(array[i]);
0: 	    if (i < maxIndex)
0: 		buf.append(", ");
0: 	}
0: 	buf.append("]");
0: 	return buf.toString();
0: }
0: /**
0:  * Returns a string representation of the specified array.  The string
0:  * representation consists of a list of the arrays's elements, enclosed in square brackets
0:  * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:  * <tt>", "</tt> (comma and space).
0:  * @return a string representation of the specified array.
0:  */
0: public static String toString(char[] array) {
0: 	StringBuffer buf = new StringBuffer();
0: 	buf.append("[");
0: 	int maxIndex = array.length - 1;
0: 	for (int i = 0; i <= maxIndex; i++) {
0: 	    buf.append(array[i]);
0: 	    if (i < maxIndex)
0: 		buf.append(", ");
0: 	}
0: 	buf.append("]");
0: 	return buf.toString();
0: }
0: /**
0:  * Returns a string representation of the specified array.  The string
0:  * representation consists of a list of the arrays's elements, enclosed in square brackets
0:  * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:  * <tt>", "</tt> (comma and space).
0:  * @return a string representation of the specified array.
0:  */
0: public static String toString(double[] array) {
0: 	StringBuffer buf = new StringBuffer();
0: 	buf.append("[");
0: 	int maxIndex = array.length - 1;
0: 	for (int i = 0; i <= maxIndex; i++) {
0: 	    buf.append(array[i]);
0: 	    if (i < maxIndex)
0: 		buf.append(", ");
0: 	}
0: 	buf.append("]");
0: 	return buf.toString();
0: }
0: /**
0:  * Returns a string representation of the specified array.  The string
0:  * representation consists of a list of the arrays's elements, enclosed in square brackets
0:  * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:  * <tt>", "</tt> (comma and space).
0:  * @return a string representation of the specified array.
0:  */
0: public static String toString(float[] array) {
0: 	StringBuffer buf = new StringBuffer();
0: 	buf.append("[");
0: 	int maxIndex = array.length - 1;
0: 	for (int i = 0; i <= maxIndex; i++) {
0: 	    buf.append(array[i]);
0: 	    if (i < maxIndex)
0: 		buf.append(", ");
0: 	}
0: 	buf.append("]");
0: 	return buf.toString();
0: }
0: /**
0:  * Returns a string representation of the specified array.  The string
0:  * representation consists of a list of the arrays's elements, enclosed in square brackets
0:  * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:  * <tt>", "</tt> (comma and space).
0:  * @return a string representation of the specified array.
0:  */
0: public static String toString(int[] array) {
0: 	StringBuffer buf = new StringBuffer();
0: 	buf.append("[");
0: 	int maxIndex = array.length - 1;
0: 	for (int i = 0; i <= maxIndex; i++) {
0: 	    buf.append(array[i]);
0: 	    if (i < maxIndex)
0: 		buf.append(", ");
0: 	}
0: 	buf.append("]");
0: 	return buf.toString();
0: }
0: /**
0:  * Returns a string representation of the specified array.  The string
0:  * representation consists of a list of the arrays's elements, enclosed in square brackets
0:  * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:  * <tt>", "</tt> (comma and space).
0:  * @return a string representation of the specified array.
0:  */
0: public static String toString(long[] array) {
0: 	StringBuffer buf = new StringBuffer();
0: 	buf.append("[");
0: 	int maxIndex = array.length - 1;
0: 	for (int i = 0; i <= maxIndex; i++) {
0: 	    buf.append(array[i]);
0: 	    if (i < maxIndex)
0: 		buf.append(", ");
0: 	}
0: 	buf.append("]");
0: 	return buf.toString();
0: }
0: /**
0:  * Returns a string representation of the specified array.  The string
0:  * representation consists of a list of the arrays's elements, enclosed in square brackets
0:  * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:  * <tt>", "</tt> (comma and space).
0:  * @return a string representation of the specified array.
0:  */
0: public static String toString(Object[] array) {
0: 	StringBuffer buf = new StringBuffer();
0: 	buf.append("[");
0: 	int maxIndex = array.length - 1;
0: 	for (int i = 0; i <= maxIndex; i++) {
0: 	    buf.append(array[i]);
0: 	    if (i < maxIndex)
0: 		buf.append(", ");
0: 	}
0: 	buf.append("]");
0: 	return buf.toString();
0: }
0: /**
0:  * Returns a string representation of the specified array.  The string
0:  * representation consists of a list of the arrays's elements, enclosed in square brackets
0:  * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:  * <tt>", "</tt> (comma and space).
0:  * @return a string representation of the specified array.
0:  */
0: public static String toString(short[] array) {
0: 	StringBuffer buf = new StringBuffer();
0: 	buf.append("[");
0: 	int maxIndex = array.length - 1;
0: 	for (int i = 0; i <= maxIndex; i++) {
0: 	    buf.append(array[i]);
0: 	    if (i < maxIndex)
0: 		buf.append(", ");
0: 	}
0: 	buf.append("]");
0: 	return buf.toString();
0: }
0: /**
0:  * Returns a string representation of the specified array.  The string
0:  * representation consists of a list of the arrays's elements, enclosed in square brackets
0:  * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
0:  * <tt>", "</tt> (comma and space).
0:  * @return a string representation of the specified array.
0:  */
0: public static String toString(boolean[] array) {
0: 	StringBuffer buf = new StringBuffer();
0: 	buf.append("[");
0: 	int maxIndex = array.length - 1;
0: 	for (int i = 0; i <= maxIndex; i++) {
0: 	    buf.append(array[i]);
0: 	    if (i < maxIndex)
0: 		buf.append(", ");
0: 	}
0: 	buf.append("]");
0: 	return buf.toString();
0: }
0: /**
0:  * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements.
0:  * An application can use this operation to minimize array storage.
0:  * <p>
0:  * Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:  * Otherwise, returns a new array with a length of <tt>maxCapacity</tt>
0:  * containing the first <tt>maxCapacity</tt> elements of <tt>array</tt>.
0:  *
0:  * @param   maxCapacity   the desired maximum capacity.
0:  */
0: public static byte[] trimToCapacity(byte[] array, int maxCapacity) {
0: 	if (array.length > maxCapacity) {
0: 	    byte oldArray[] = array;
0: 	    array = new byte[maxCapacity];
0: 	    System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0: 	}
0: 	return array;
0: }
0: /**
0:  * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements.
0:  * An application can use this operation to minimize array storage.
0:  * <p>
0:  * Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:  * Otherwise, returns a new array with a length of <tt>maxCapacity</tt>
0:  * containing the first <tt>maxCapacity</tt> elements of <tt>array</tt>.
0:  *
0:  * @param   maxCapacity   the desired maximum capacity.
0:  */
0: public static char[] trimToCapacity(char[] array, int maxCapacity) {
0: 	if (array.length > maxCapacity) {
0: 	    char oldArray[] = array;
0: 	    array = new char[maxCapacity];
0: 	    System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0: 	}
0: 	return array;
0: }
0: /**
0:  * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements.
0:  * An application can use this operation to minimize array storage.
0:  * <p>
0:  * Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:  * Otherwise, returns a new array with a length of <tt>maxCapacity</tt>
0:  * containing the first <tt>maxCapacity</tt> elements of <tt>array</tt>.
0:  *
0:  * @param   maxCapacity   the desired maximum capacity.
0:  */
0: public static double[] trimToCapacity(double[] array, int maxCapacity) {
0: 	if (array.length > maxCapacity) {
0: 	    double oldArray[] = array;
0: 	    array = new double[maxCapacity];
0: 	    System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0: 	}
0: 	return array;
0: }
0: /**
0:  * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements.
0:  * An application can use this operation to minimize array storage.
0:  * <p>
0:  * Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:  * Otherwise, returns a new array with a length of <tt>maxCapacity</tt>
0:  * containing the first <tt>maxCapacity</tt> elements of <tt>array</tt>.
0:  *
0:  * @param   maxCapacity   the desired maximum capacity.
0:  */
0: public static float[] trimToCapacity(float[] array, int maxCapacity) {
0: 	if (array.length > maxCapacity) {
0: 	    float oldArray[] = array;
0: 	    array = new float[maxCapacity];
0: 	    System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0: 	}
0: 	return array;
0: }
0: /**
0:  * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements.
0:  * An application can use this operation to minimize array storage.
0:  * <p>
0:  * Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:  * Otherwise, returns a new array with a length of <tt>maxCapacity</tt>
0:  * containing the first <tt>maxCapacity</tt> elements of <tt>array</tt>.
0:  *
0:  * @param   maxCapacity   the desired maximum capacity.
0:  */
0: public static int[] trimToCapacity(int[] array, int maxCapacity) {
0: 	if (array.length > maxCapacity) {
0: 	    int oldArray[] = array;
0: 	    array = new int[maxCapacity];
0: 	    System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0: 	}
0: 	return array;
0: }
0: /**
0:  * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements.
0:  * An application can use this operation to minimize array storage.
0:  * <p>
0:  * Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:  * Otherwise, returns a new array with a length of <tt>maxCapacity</tt>
0:  * containing the first <tt>maxCapacity</tt> elements of <tt>array</tt>.
0:  *
0:  * @param   maxCapacity   the desired maximum capacity.
0:  */
0: public static long[] trimToCapacity(long[] array, int maxCapacity) {
0: 	if (array.length > maxCapacity) {
0: 	    long oldArray[] = array;
0: 	    array = new long[maxCapacity];
0: 	    System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0: 	}
0: 	return array;
0: }
0: /**
0:  * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements.
0:  * An application can use this operation to minimize array storage.
0:  * <p>
0:  * Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:  * Otherwise, returns a new array with a length of <tt>maxCapacity</tt>
0:  * containing the first <tt>maxCapacity</tt> elements of <tt>array</tt>.
0:  *
0:  * @param   maxCapacity   the desired maximum capacity.
0:  */
0: public static Object[] trimToCapacity(Object[] array, int maxCapacity) {
0: 	if (array.length > maxCapacity) {
0: 	    Object oldArray[] = array;
0: 	    array = new Object[maxCapacity];
0: 	    System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0: 	}
0: 	return array;
0: }
0: /**
0:  * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements.
0:  * An application can use this operation to minimize array storage.
0:  * <p>
0:  * Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:  * Otherwise, returns a new array with a length of <tt>maxCapacity</tt>
0:  * containing the first <tt>maxCapacity</tt> elements of <tt>array</tt>.
0:  *
0:  * @param   maxCapacity   the desired maximum capacity.
0:  */
0: public static short[] trimToCapacity(short[] array, int maxCapacity) {
0: 	if (array.length > maxCapacity) {
0: 	    short oldArray[] = array;
0: 	    array = new short[maxCapacity];
0: 	    System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0: 	}
0: 	return array;
0: }
0: /**
0:  * Ensures that the specified array cannot hold more than <tt>maxCapacity</tt> elements.
0:  * An application can use this operation to minimize array storage.
0:  * <p>
0:  * Returns the identical array if <tt>array.length &lt;= maxCapacity</tt>.
0:  * Otherwise, returns a new array with a length of <tt>maxCapacity</tt>
0:  * containing the first <tt>maxCapacity</tt> elements of <tt>array</tt>.
0:  *
0:  * @param   maxCapacity   the desired maximum capacity.
0:  */
0: public static boolean[] trimToCapacity(boolean[] array, int maxCapacity) {
0: 	if (array.length > maxCapacity) {
0: 	    boolean oldArray[] = array;
0: 	    array = new boolean[maxCapacity];
0: 	    System.arraycopy(oldArray, 0, array, 0, maxCapacity);
0: 	}
0: 	return array;
0: }
0: }
============================================================================