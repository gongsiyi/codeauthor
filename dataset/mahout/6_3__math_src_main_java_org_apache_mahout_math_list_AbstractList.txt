4:7926fcb: /**
1:35fa73f:  * Licensed to the Apache Software Foundation (ASF) under one
1:35fa73f:  * or more contributor license agreements. See the NOTICE file
1:35fa73f:  * distributed with this work for additional information
1:35fa73f:  * regarding copyright ownership. The ASF licenses this file
1:35fa73f:  * to you under the Apache License, Version 2.0 (the
1:35fa73f:  * "License"); you may not use this file except in compliance
1:35fa73f:  * with the License. You may obtain a copy of the License at
3:7926fcb:  *
1:35fa73f:  * http://www.apache.org/licenses/LICENSE-2.0
1:7926fcb:  *
1:35fa73f:  * Unless required by applicable law or agreed to in writing,
1:35fa73f:  * software distributed under the License is distributed on an
1:35fa73f:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:35fa73f:  * KIND, either express or implied. See the License for the
1:35fa73f:  * specific language governing permissions and limitations
1:35fa73f:  * under the License.
1:7926fcb:  */
1:35fa73f:  /*
1:35fa73f: Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
1:35fa73f: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1:35fa73f: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1:35fa73f: that both that copyright notice and this permission notice appear in supporting documentation. 
1:35fa73f: CERN makes no representations about the suitability of this software for any purpose. 
1:35fa73f: It is provided "as is" without expressed or implied warranty.
1:7926fcb: */
1:35fa73f: /*
1:35fa73f: Copyright 1999 CERN - European Organization for Nuclear Research.
1:35fa73f: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1:35fa73f: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1:35fa73f: that both that copyright notice and this permission notice appear in supporting documentation. 
1:35fa73f: CERN makes no representations about the suitability of this software for any purpose. 
1:35fa73f: It is provided "as is" without expressed or implied warranty.
1:7926fcb: */
1:35fa73f: package org.apache.mahout.math.list;
3:7926fcb: 
1:35fa73f: import org.apache.mahout.math.PersistentObject;
1:7926fcb: 
1:7926fcb: /**
1:229aeff:  * Abstract base class for resizable lists holding objects or primitive data types such as
1:229aeff:  * {@code int}, {@code float}, etc.
1:229aeff:  * First see the <a href="package-summary.html">package summary</a> and javadoc
1:229aeff:  * <a href="package-tree.html">tree view</a> to get the broad picture.
1:229aeff:  * <p>
1:229aeff:  * <b>Note that this implementation is not synchronized.</b>
1:229aeff:  *
1:229aeff:  * @author wolfgang.hoschek@cern.ch
1:229aeff:  * @version 1.0, 09/24/99
1:229aeff:  * @see     java.util.ArrayList
1:229aeff:  * @see      java.util.Vector
1:229aeff:  * @see      java.util.Arrays
1:7926fcb:  */
1:35fa73f: public abstract class AbstractList extends PersistentObject {
1:7926fcb:   
1:35fa73f:   public abstract int size();
1:7926fcb:   
1:35fa73f:   public boolean isEmpty() {
1:ea65197:     return size() == 0;
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Inserts <tt>length</tt> dummy elements before the specified position into the receiver. Shifts the element
1:7926fcb:    * currently at that position (if any) and any subsequent elements to the right. <b>This method must set the new size
1:b5c2879:    * to be <tt>size()+length</tt></b>.
1:7926fcb:    *
1:7926fcb:    * @param index  index before which to insert dummy elements (must be in [0,size])..
1:7926fcb:    * @param length number of dummy elements to be inserted.
2:7926fcb:    * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt; size()</tt>.
1:7926fcb:    */
1:7926fcb:   protected abstract void beforeInsertDummies(int index, int length);
1:7926fcb: 
1:7926fcb:   /** Checks if the given index is in range. */
1:7926fcb:   protected static void checkRange(int index, int theSize) {
1:7926fcb:     if (index >= theSize || index < 0) {
1:7926fcb:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + theSize);
1:7926fcb:     }
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Checks if the given range is within the contained array's bounds.
1:7926fcb:    *
1:7926fcb:    * @throws IndexOutOfBoundsException if <tt>to!=from-1 || from&lt;0 || from&gt;to || to&gt;=size()</tt>.
1:7926fcb:    */
1:7926fcb:   protected static void checkRangeFromTo(int from, int to, int theSize) {
1:7926fcb:     if (to == from - 1) {
1:7926fcb:       return;
1:7926fcb:     }
1:7926fcb:     if (from < 0 || from > to || to >= theSize) {
1:7926fcb:       throw new IndexOutOfBoundsException("from: " + from + ", to: " + to + ", size=" + theSize);
1:7926fcb:     }
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Removes all elements from the receiver.  The receiver will be empty after this call returns, but keep its current
1:7926fcb:    * capacity.
1:7926fcb:    */
1:7926fcb:   public void clear() {
1:7926fcb:     removeFromTo(0, size() - 1);
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Sorts the receiver into ascending order. This sort is guaranteed to be <i>stable</i>:  equal elements will not be
1:7926fcb:    * reordered as a result of the sort.<p>
1:7926fcb:    *
1:7926fcb:    * The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low
1:7926fcb:    * sublist is less than the lowest element in the high sublist).  This algorithm offers guaranteed n*log(n)
1:7926fcb:    * performance, and can approach linear performance on nearly sorted lists.
1:7926fcb:    *
1:7926fcb:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
1:7926fcb:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
1:7926fcb:    * those methods automatically choose the best sorting algorithm.
1:7926fcb:    */
1:7926fcb:   public final void mergeSort() {
1:7926fcb:     mergeSortFromTo(0, size() - 1);
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Sorts the receiver into ascending order. This sort is guaranteed to be <i>stable</i>:  equal elements will not be
1:7926fcb:    * reordered as a result of the sort.<p>
1:7926fcb:    *
1:7926fcb:    * The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low
1:7926fcb:    * sublist is less than the lowest element in the high sublist).  This algorithm offers guaranteed n*log(n)
1:7926fcb:    * performance, and can approach linear performance on nearly sorted lists.
1:7926fcb:    *
1:7926fcb:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
1:7926fcb:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
1:7926fcb:    * those methods automatically choose the best sorting algorithm.
1:7926fcb:    *
1:7926fcb:    * @param from the index of the first element (inclusive) to be sorted.
1:7926fcb:    * @param to   the index of the last element (inclusive) to be sorted.
2:7926fcb:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
1:7926fcb:    */
1:7926fcb:   public abstract void mergeSortFromTo(int from, int to);
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Sorts the receiver into ascending order.  The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
1:7926fcb:    * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice and Experience, Vol. 23(11) P. 1249-1265
1:7926fcb:    * (November 1993).  This algorithm offers n*log(n) performance on many data sets that cause other quicksorts to
1:7926fcb:    * degrade to quadratic performance.
1:7926fcb:    *
1:7926fcb:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
1:7926fcb:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
1:7926fcb:    * those methods automatically choose the best sorting algorithm.
1:7926fcb:    */
1:7926fcb:   public final void quickSort() {
1:7926fcb:     quickSortFromTo(0, size() - 1);
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Sorts the specified range of the receiver into ascending order.  The sorting algorithm is a tuned quicksort,
1:7926fcb:    * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice and
1:7926fcb:    * Experience, Vol. 23(11) P. 1249-1265 (November 1993).  This algorithm offers n*log(n) performance on many data sets
1:7926fcb:    * that cause other quicksorts to degrade to quadratic performance.
1:7926fcb:    *
1:7926fcb:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
1:7926fcb:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
1:7926fcb:    * those methods automatically choose the best sorting algorithm.
1:7926fcb:    *
1:7926fcb:    * @param from the index of the first element (inclusive) to be sorted.
1:7926fcb:    * @param to   the index of the last element (inclusive) to be sorted.
1:7926fcb:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
1:7926fcb:    */
1:7926fcb:   public abstract void quickSortFromTo(int from, int to);
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Removes the element at the specified position from the receiver. Shifts any subsequent elements to the left.
1:7926fcb:    *
1:7926fcb:    * @param index the index of the element to removed.
2:7926fcb:    * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt;= size()</tt>.
1:7926fcb:    */
1:7926fcb:   public void remove(int index) {
1:7926fcb:     removeFromTo(index, index);
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Removes from the receiver all elements whose index is between <code>from</code>, inclusive and <code>to</code>,
1:7926fcb:    * inclusive.  Shifts any succeeding elements to the left (reduces their index). This call shortens the list by
1:7926fcb:    * <tt>(to - from + 1)</tt> elements.
1:7926fcb:    *
1:7926fcb:    * @param fromIndex index of first element to be removed.
1:7926fcb:    * @param toIndex   index of last element to be removed.
1:7926fcb:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
1:7926fcb:    */
1:7926fcb:   public abstract void removeFromTo(int fromIndex, int toIndex);
1:7926fcb: 
1:7926fcb:   /** Reverses the elements of the receiver. Last becomes first, second last becomes second first, and so on. */
1:7926fcb:   public abstract void reverse();
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Sets the size of the receiver. If the new size is greater than the current size, new null or zero items are added
1:7926fcb:    * to the end of the receiver. If the new size is less than the current size, all components at index newSize and
1:7926fcb:    * greater are discarded. This method does not release any superfluos internal memory. Use method <tt>trimToSize</tt>
1:7926fcb:    * to release superfluos internal memory.
1:7926fcb:    *
1:7926fcb:    * @param newSize the new size of the receiver.
1:7926fcb:    * @throws IndexOutOfBoundsException if <tt>newSize &lt; 0</tt>.
1:7926fcb:    */
1:7926fcb:   public void setSize(int newSize) {
1:7926fcb:     if (newSize < 0) {
1:7926fcb:       throw new IndexOutOfBoundsException("newSize:" + newSize);
1:7926fcb:     }
1:7926fcb: 
1:7926fcb:     int currentSize = size();
1:7926fcb:     if (newSize != currentSize) {
1:7926fcb:       if (newSize > currentSize) {
1:7926fcb:         beforeInsertDummies(currentSize, newSize - currentSize);
1:7926fcb:       } else if (newSize < currentSize) {
1:7926fcb:         removeFromTo(newSize, currentSize - 1);
1:7926fcb:       }
1:7926fcb:     }
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Sorts the receiver into ascending order.
1:7926fcb:    *
1:7926fcb:    * The sorting algorithm is dynamically chosen according to the characteristics of the data set.
1:7926fcb:    *
1:7926fcb:    * This implementation simply calls <tt>sortFromTo(...)</tt>. Override <tt>sortFromTo(...)</tt> if you can determine
1:7926fcb:    * which sort is most appropriate for the given data set.
1:7926fcb:    */
1:7926fcb:   public final void sort() {
1:7926fcb:     sortFromTo(0, size() - 1);
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Sorts the specified range of the receiver into ascending order.
1:7926fcb:    *
1:7926fcb:    * The sorting algorithm is dynamically chosen according to the characteristics of the data set. This default
1:7926fcb:    * implementation simply calls quickSort. Override this method if you can determine which sort is most appropriate for
1:7926fcb:    * the given data set.
1:7926fcb:    *
1:7926fcb:    * @param from the index of the first element (inclusive) to be sorted.
1:7926fcb:    * @param to   the index of the last element (inclusive) to be sorted.
1:7926fcb:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
1:7926fcb:    */
1:7926fcb:   public void sortFromTo(int from, int to) {
1:7926fcb:     quickSortFromTo(from, to);
1:7926fcb:   }
1:7926fcb: 
1:7926fcb:   /**
1:7926fcb:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluos internal memory. An
1:7926fcb:    * application can use this operation to minimize the storage of the receiver. <p> This default implementation does
1:7926fcb:    * nothing. Override this method in space efficient implementations.
1:7926fcb:    */
1:7926fcb:   public void trimToSize() {
1:7926fcb:   }
1:7926fcb: }
============================================================================
author:Karl Richter
-------------------------------------------------------------------------------
commit:b5c2879
/////////////////////////////////////////////////////////////////////////
1:    * to be <tt>size()+length</tt></b>.
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:229aeff
/////////////////////////////////////////////////////////////////////////
1:  * Abstract base class for resizable lists holding objects or primitive data types such as
1:  * {@code int}, {@code float}, etc.
1:  * First see the <a href="package-summary.html">package summary</a> and javadoc
1:  * <a href="package-tree.html">tree view</a> to get the broad picture.
1:  * <p>
1:  * <b>Note that this implementation is not synchronized.</b>
1:  *
1:  * @author wolfgang.hoschek@cern.ch
1:  * @version 1.0, 09/24/99
1:  * @see     java.util.ArrayList
1:  * @see      java.util.Vector
1:  * @see      java.util.Arrays
commit:ea65197
/////////////////////////////////////////////////////////////////////////
0:  @see     java.util.ArrayList
/////////////////////////////////////////////////////////////////////////
1:     return size() == 0;
commit:7926fcb
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
1: /**
0:  Abstract base class for resizable lists holding objects or primitive data types such as <code>int</code>, <code>float</code>, etc.
0:  First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
0:  <p>
0:  <b>Note that this implementation is not synchronized.</b>
1: 
0:  @author wolfgang.hoschek@cern.ch
0:  @version 1.0, 09/24/99
0:  @see     ArrayList
0:  @see      java.util.Vector
0:  @see      java.util.Arrays
1: 
0: /** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
0: public abstract class AbstractList<T> extends AbstractCollection<T> {
1:   /**
0:    * Appends all of the elements of the specified Collection to the receiver.
1:    *
0:    * @throws ClassCastException if an element in the collection is not of the same parameter type of the receiver.
1:    */
0:   public void addAllOf(Collection<T> collection) {
0:     this.beforeInsertAllOf(size(), collection);
1: 
1:   /**
0:    * Inserts all elements of the specified collection before the specified position into the receiver. Shifts the
0:    * element currently at that position (if any) and any subsequent elements to the right (increases their indices).
1:    *
0:    * @param index      index before which to insert first element from the specified collection.
0:    * @param collection the collection to be inserted
0:    * @throws ClassCastException        if an element in the collection is not of the same parameter type of the
0:    *                                   receiver.
1:    * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt; size()</tt>.
1:    */
0:   public void beforeInsertAllOf(int index, Collection<T> collection) {
0:     this.beforeInsertDummies(index, collection.size());
0:     this.replaceFromWith(index, collection);
1:   }
1: 
1:   /**
1:    * Inserts <tt>length</tt> dummy elements before the specified position into the receiver. Shifts the element
1:    * currently at that position (if any) and any subsequent elements to the right. <b>This method must set the new size
0:    * to be <tt>size()+length</tt>.
1:    *
1:    * @param index  index before which to insert dummy elements (must be in [0,size])..
1:    * @param length number of dummy elements to be inserted.
1:    * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt; size()</tt>.
1:    */
1:   protected abstract void beforeInsertDummies(int index, int length);
1: 
1:   /** Checks if the given index is in range. */
1:   protected static void checkRange(int index, int theSize) {
1:     if (index >= theSize || index < 0) {
1:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + theSize);
1:     }
1:   }
1: 
1:   /**
1:    * Checks if the given range is within the contained array's bounds.
1:    *
1:    * @throws IndexOutOfBoundsException if <tt>to!=from-1 || from&lt;0 || from&gt;to || to&gt;=size()</tt>.
1:    */
1:   protected static void checkRangeFromTo(int from, int to, int theSize) {
1:     if (to == from - 1) {
1:       return;
1:     }
1:     if (from < 0 || from > to || to >= theSize) {
1:       throw new IndexOutOfBoundsException("from: " + from + ", to: " + to + ", size=" + theSize);
1:     }
1:   }
1: 
1:   /**
1:    * Removes all elements from the receiver.  The receiver will be empty after this call returns, but keep its current
1:    * capacity.
1:    */
0:   @Override
1:   public void clear() {
1:     removeFromTo(0, size() - 1);
1:   }
1: 
1:   /**
1:    * Sorts the receiver into ascending order. This sort is guaranteed to be <i>stable</i>:  equal elements will not be
1:    * reordered as a result of the sort.<p>
1:    *
1:    * The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low
1:    * sublist is less than the lowest element in the high sublist).  This algorithm offers guaranteed n*log(n)
1:    * performance, and can approach linear performance on nearly sorted lists.
1:    *
1:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
1:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
1:    * those methods automatically choose the best sorting algorithm.
1:    */
1:   public final void mergeSort() {
1:     mergeSortFromTo(0, size() - 1);
1:   }
1: 
1:   /**
1:    * Sorts the receiver into ascending order. This sort is guaranteed to be <i>stable</i>:  equal elements will not be
1:    * reordered as a result of the sort.<p>
1:    *
1:    * The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low
1:    * sublist is less than the lowest element in the high sublist).  This algorithm offers guaranteed n*log(n)
1:    * performance, and can approach linear performance on nearly sorted lists.
1:    *
1:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
1:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
1:    * those methods automatically choose the best sorting algorithm.
1:    *
1:    * @param from the index of the first element (inclusive) to be sorted.
1:    * @param to   the index of the last element (inclusive) to be sorted.
1:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
1:    */
1:   public abstract void mergeSortFromTo(int from, int to);
1: 
1:   /**
1:    * Sorts the receiver into ascending order.  The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
1:    * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice and Experience, Vol. 23(11) P. 1249-1265
1:    * (November 1993).  This algorithm offers n*log(n) performance on many data sets that cause other quicksorts to
1:    * degrade to quadratic performance.
1:    *
1:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
1:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
1:    * those methods automatically choose the best sorting algorithm.
1:    */
1:   public final void quickSort() {
1:     quickSortFromTo(0, size() - 1);
1:   }
1: 
1:   /**
1:    * Sorts the specified range of the receiver into ascending order.  The sorting algorithm is a tuned quicksort,
1:    * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice and
1:    * Experience, Vol. 23(11) P. 1249-1265 (November 1993).  This algorithm offers n*log(n) performance on many data sets
1:    * that cause other quicksorts to degrade to quadratic performance.
1:    *
1:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
1:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
1:    * those methods automatically choose the best sorting algorithm.
1:    *
1:    * @param from the index of the first element (inclusive) to be sorted.
1:    * @param to   the index of the last element (inclusive) to be sorted.
1:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
1:    */
1:   public abstract void quickSortFromTo(int from, int to);
1: 
1:   /**
1:    * Removes the element at the specified position from the receiver. Shifts any subsequent elements to the left.
1:    *
1:    * @param index the index of the element to removed.
1:    * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt;= size()</tt>.
1:    */
1:   public void remove(int index) {
1:     removeFromTo(index, index);
1:   }
1: 
1:   /**
1:    * Removes from the receiver all elements whose index is between <code>from</code>, inclusive and <code>to</code>,
1:    * inclusive.  Shifts any succeeding elements to the left (reduces their index). This call shortens the list by
1:    * <tt>(to - from + 1)</tt> elements.
1:    *
1:    * @param fromIndex index of first element to be removed.
1:    * @param toIndex   index of last element to be removed.
1:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
1:    */
1:   public abstract void removeFromTo(int fromIndex, int toIndex);
1: 
1:   /**
0:    * Replaces the part of the receiver starting at <code>from</code> (inclusive) with all the elements of the specified
0:    * collection. Does not alter the size of the receiver. Replaces exactly <tt>Math.max(0,Math.min(size()-from,
0:    * other.size()))</tt> elements.
1:    *
0:    * @param from  the index at which to copy the first element from the specified collection.
0:    * @param other Collection to replace part of the receiver
1:    * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt;= size()</tt>.
1:    */
0:   public abstract void replaceFromWith(int from, Collection<T> other);
1: 
1:   /** Reverses the elements of the receiver. Last becomes first, second last becomes second first, and so on. */
1:   public abstract void reverse();
1: 
1:   /**
1:    * Sets the size of the receiver. If the new size is greater than the current size, new null or zero items are added
1:    * to the end of the receiver. If the new size is less than the current size, all components at index newSize and
1:    * greater are discarded. This method does not release any superfluos internal memory. Use method <tt>trimToSize</tt>
1:    * to release superfluos internal memory.
1:    *
1:    * @param newSize the new size of the receiver.
1:    * @throws IndexOutOfBoundsException if <tt>newSize &lt; 0</tt>.
1:    */
1:   public void setSize(int newSize) {
1:     if (newSize < 0) {
1:       throw new IndexOutOfBoundsException("newSize:" + newSize);
1:     }
1: 
1:     int currentSize = size();
1:     if (newSize != currentSize) {
1:       if (newSize > currentSize) {
1:         beforeInsertDummies(currentSize, newSize - currentSize);
1:       } else if (newSize < currentSize) {
1:         removeFromTo(newSize, currentSize - 1);
1:       }
1:     }
1:   }
1: 
0:   /** Randomly permutes the receiver. After invocation, all elements will be at random positions. */
0:   public final void shuffle() {
0:     shuffleFromTo(0, size() - 1);
1:   }
1: 
1:   /**
0:    * Randomly permutes the receiver between <code>from</code> (inclusive) and <code>to</code> (inclusive).
1:    *
0:    * @param from the start position (inclusive)
0:    * @param to   the end position (inclusive)
1:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
1:    */
0:   public abstract void shuffleFromTo(int from, int to);
1: 
1:   /**
1:    * Sorts the receiver into ascending order.
1:    *
1:    * The sorting algorithm is dynamically chosen according to the characteristics of the data set.
1:    *
1:    * This implementation simply calls <tt>sortFromTo(...)</tt>. Override <tt>sortFromTo(...)</tt> if you can determine
1:    * which sort is most appropriate for the given data set.
1:    */
1:   public final void sort() {
1:     sortFromTo(0, size() - 1);
1:   }
1: 
1:   /**
1:    * Sorts the specified range of the receiver into ascending order.
1:    *
1:    * The sorting algorithm is dynamically chosen according to the characteristics of the data set. This default
1:    * implementation simply calls quickSort. Override this method if you can determine which sort is most appropriate for
1:    * the given data set.
1:    *
1:    * @param from the index of the first element (inclusive) to be sorted.
1:    * @param to   the index of the last element (inclusive) to be sorted.
1:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
1:    */
1:   public void sortFromTo(int from, int to) {
1:     quickSortFromTo(from, to);
1:   }
1: 
1:   /**
1:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluos internal memory. An
1:    * application can use this operation to minimize the storage of the receiver. <p> This default implementation does
1:    * nothing. Override this method in space efficient implementations.
1:    */
1:   public void trimToSize() {
1:   }
commit:fcbc54a
/////////////////////////////////////////////////////////////////////////
0: @see      java.util.Vector
0: @see      java.util.Arrays
/////////////////////////////////////////////////////////////////////////
0:   this.beforeInsertAllOf(size(), collection);
/////////////////////////////////////////////////////////////////////////
0:   this.beforeInsertDummies(index, collection.size());
0:   this.replaceFromWith(index, collection);
/////////////////////////////////////////////////////////////////////////
0:   if (index >= theSize || index < 0)
0:     throw new IndexOutOfBoundsException("Index: "+index+", Size: "+theSize);
0:   if (to==from-1) return;
0:   if (from<0 || from>to || to>=theSize)
0:     throw new IndexOutOfBoundsException("from: "+from+", to: "+to+", size="+theSize);
0:   removeFromTo(0,size()-1);
/////////////////////////////////////////////////////////////////////////
0:   mergeSortFromTo(0, size()-1);
/////////////////////////////////////////////////////////////////////////
0:   quickSortFromTo(0, size()-1);
/////////////////////////////////////////////////////////////////////////
0:   removeFromTo(index, index);
/////////////////////////////////////////////////////////////////////////
0:   if (newSize<0) throw new IndexOutOfBoundsException("newSize:"+newSize);
0:   int currentSize = size();
0:   if (newSize!=currentSize) {
0:     if (newSize>currentSize) beforeInsertDummies(currentSize,newSize-currentSize);
0:     else if (newSize<currentSize) removeFromTo(newSize, currentSize-1);
0:   }
0:   shuffleFromTo(0, size()-1);
/////////////////////////////////////////////////////////////////////////
0:   sortFromTo(0, size()-1);
/////////////////////////////////////////////////////////////////////////
0:   quickSortFromTo(from, to);
author:Ted Dunning
-------------------------------------------------------------------------------
commit:35fa73f
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements. See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership. The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License. You may obtain a copy of the License at
0:  *
1:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied. See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  */
1:  /*
1: Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
1: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1: that both that copyright notice and this permission notice appear in supporting documentation. 
1: CERN makes no representations about the suitability of this software for any purpose. 
1: It is provided "as is" without expressed or implied warranty.
0: */
1: /*
1: Copyright 1999 CERN - European Organization for Nuclear Research.
1: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1: that both that copyright notice and this permission notice appear in supporting documentation. 
1: CERN makes no representations about the suitability of this software for any purpose. 
1: It is provided "as is" without expressed or implied warranty.
0: */
1: package org.apache.mahout.math.list;
0: 
1: import org.apache.mahout.math.PersistentObject;
0: 
0: /**
0:  Abstract base class for resizable lists holding objects or primitive data types such as <code>int</code>, <code>float</code>, etc.
0:  First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
0:  <p>
0:  <b>Note that this implementation is not synchronized.</b>
0: 
0:  @author wolfgang.hoschek@cern.ch
0:  @version 1.0, 09/24/99
0:  @see     java.util.ArrayList
0:  @see      java.util.Vector
0:  @see      java.util.Arrays
0:  */
1: public abstract class AbstractList extends PersistentObject {
0:   
1:   public abstract int size();
0:   
1:   public boolean isEmpty() {
0:     return size() == 0;
0:   }
0: 
0:   /**
0:    * Inserts <tt>length</tt> dummy elements before the specified position into the receiver. Shifts the element
0:    * currently at that position (if any) and any subsequent elements to the right. <b>This method must set the new size
0:    * to be <tt>size()+length</tt>.
0:    *
0:    * @param index  index before which to insert dummy elements (must be in [0,size])..
0:    * @param length number of dummy elements to be inserted.
0:    * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt; size()</tt>.
0:    */
0:   protected abstract void beforeInsertDummies(int index, int length);
0: 
0:   /** Checks if the given index is in range. */
0:   protected static void checkRange(int index, int theSize) {
0:     if (index >= theSize || index < 0) {
0:       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + theSize);
0:     }
0:   }
0: 
0:   /**
0:    * Checks if the given range is within the contained array's bounds.
0:    *
0:    * @throws IndexOutOfBoundsException if <tt>to!=from-1 || from&lt;0 || from&gt;to || to&gt;=size()</tt>.
0:    */
0:   protected static void checkRangeFromTo(int from, int to, int theSize) {
0:     if (to == from - 1) {
0:       return;
0:     }
0:     if (from < 0 || from > to || to >= theSize) {
0:       throw new IndexOutOfBoundsException("from: " + from + ", to: " + to + ", size=" + theSize);
0:     }
0:   }
0: 
0:   /**
0:    * Removes all elements from the receiver.  The receiver will be empty after this call returns, but keep its current
0:    * capacity.
0:    */
0:   public void clear() {
0:     removeFromTo(0, size() - 1);
0:   }
0: 
0:   /**
0:    * Sorts the receiver into ascending order. This sort is guaranteed to be <i>stable</i>:  equal elements will not be
0:    * reordered as a result of the sort.<p>
0:    *
0:    * The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low
0:    * sublist is less than the lowest element in the high sublist).  This algorithm offers guaranteed n*log(n)
0:    * performance, and can approach linear performance on nearly sorted lists.
0:    *
0:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
0:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
0:    * those methods automatically choose the best sorting algorithm.
0:    */
0:   public final void mergeSort() {
0:     mergeSortFromTo(0, size() - 1);
0:   }
0: 
0:   /**
0:    * Sorts the receiver into ascending order. This sort is guaranteed to be <i>stable</i>:  equal elements will not be
0:    * reordered as a result of the sort.<p>
0:    *
0:    * The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low
0:    * sublist is less than the lowest element in the high sublist).  This algorithm offers guaranteed n*log(n)
0:    * performance, and can approach linear performance on nearly sorted lists.
0:    *
0:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
0:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
0:    * those methods automatically choose the best sorting algorithm.
0:    *
0:    * @param from the index of the first element (inclusive) to be sorted.
0:    * @param to   the index of the last element (inclusive) to be sorted.
0:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
0:    */
0:   public abstract void mergeSortFromTo(int from, int to);
0: 
0:   /**
0:    * Sorts the receiver into ascending order.  The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
0:    * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice and Experience, Vol. 23(11) P. 1249-1265
0:    * (November 1993).  This algorithm offers n*log(n) performance on many data sets that cause other quicksorts to
0:    * degrade to quadratic performance.
0:    *
0:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
0:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
0:    * those methods automatically choose the best sorting algorithm.
0:    */
0:   public final void quickSort() {
0:     quickSortFromTo(0, size() - 1);
0:   }
0: 
0:   /**
0:    * Sorts the specified range of the receiver into ascending order.  The sorting algorithm is a tuned quicksort,
0:    * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice and
0:    * Experience, Vol. 23(11) P. 1249-1265 (November 1993).  This algorithm offers n*log(n) performance on many data sets
0:    * that cause other quicksorts to degrade to quadratic performance.
0:    *
0:    * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one
0:    * for your data set.</b> It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because
0:    * those methods automatically choose the best sorting algorithm.
0:    *
0:    * @param from the index of the first element (inclusive) to be sorted.
0:    * @param to   the index of the last element (inclusive) to be sorted.
0:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
0:    */
0:   public abstract void quickSortFromTo(int from, int to);
0: 
0:   /**
0:    * Removes the element at the specified position from the receiver. Shifts any subsequent elements to the left.
0:    *
0:    * @param index the index of the element to removed.
0:    * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt;= size()</tt>.
0:    */
0:   public void remove(int index) {
0:     removeFromTo(index, index);
0:   }
0: 
0:   /**
0:    * Removes from the receiver all elements whose index is between <code>from</code>, inclusive and <code>to</code>,
0:    * inclusive.  Shifts any succeeding elements to the left (reduces their index). This call shortens the list by
0:    * <tt>(to - from + 1)</tt> elements.
0:    *
0:    * @param fromIndex index of first element to be removed.
0:    * @param toIndex   index of last element to be removed.
0:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
0:    */
0:   public abstract void removeFromTo(int fromIndex, int toIndex);
0: 
0:   /** Reverses the elements of the receiver. Last becomes first, second last becomes second first, and so on. */
0:   public abstract void reverse();
0: 
0:   /**
0:    * Sets the size of the receiver. If the new size is greater than the current size, new null or zero items are added
0:    * to the end of the receiver. If the new size is less than the current size, all components at index newSize and
0:    * greater are discarded. This method does not release any superfluos internal memory. Use method <tt>trimToSize</tt>
0:    * to release superfluos internal memory.
0:    *
0:    * @param newSize the new size of the receiver.
0:    * @throws IndexOutOfBoundsException if <tt>newSize &lt; 0</tt>.
0:    */
0:   public void setSize(int newSize) {
0:     if (newSize < 0) {
0:       throw new IndexOutOfBoundsException("newSize:" + newSize);
0:     }
0: 
0:     int currentSize = size();
0:     if (newSize != currentSize) {
0:       if (newSize > currentSize) {
0:         beforeInsertDummies(currentSize, newSize - currentSize);
0:       } else if (newSize < currentSize) {
0:         removeFromTo(newSize, currentSize - 1);
0:       }
0:     }
0:   }
0: 
0:   /**
0:    * Sorts the receiver into ascending order.
0:    *
0:    * The sorting algorithm is dynamically chosen according to the characteristics of the data set.
0:    *
0:    * This implementation simply calls <tt>sortFromTo(...)</tt>. Override <tt>sortFromTo(...)</tt> if you can determine
0:    * which sort is most appropriate for the given data set.
0:    */
0:   public final void sort() {
0:     sortFromTo(0, size() - 1);
0:   }
0: 
0:   /**
0:    * Sorts the specified range of the receiver into ascending order.
0:    *
0:    * The sorting algorithm is dynamically chosen according to the characteristics of the data set. This default
0:    * implementation simply calls quickSort. Override this method if you can determine which sort is most appropriate for
0:    * the given data set.
0:    *
0:    * @param from the index of the first element (inclusive) to be sorted.
0:    * @param to   the index of the last element (inclusive) to be sorted.
0:    * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
0:    */
0:   public void sortFromTo(int from, int to) {
0:     quickSortFromTo(from, to);
0:   }
0: 
0:   /**
0:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluos internal memory. An
0:    * application can use this operation to minimize the storage of the receiver. <p> This default implementation does
0:    * nothing. Override this method in space efficient implementations.
0:    */
0:   public void trimToSize() {
0:   }
0: }
author:Benson Margulies
-------------------------------------------------------------------------------
commit:ebf9a4d
/////////////////////////////////////////////////////////////////////////
commit:fa9b2b1
/////////////////////////////////////////////////////////////////////////
author:Robin Anil
-------------------------------------------------------------------------------
commit:a51dd9e
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements. See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership. The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License. You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0:  /*
0: Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
0: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
0: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
0: that both that copyright notice and this permission notice appear in supporting documentation. 
0: CERN makes no representations about the suitability of this software for any purpose. 
0: It is provided "as is" without expressed or implied warranty.
0: */
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.math.PersistentObject;
/////////////////////////////////////////////////////////////////////////
0: public abstract class AbstractList extends PersistentObject {
0:   
0:   public abstract int size();
0:   
0:   public boolean isEmpty() {
0:     return 0 == size();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:a435efb
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.math.list;
commit:f49424e
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.matrix.list;
commit:7550a10
/////////////////////////////////////////////////////////////////////////
0: /*
0: Copyright 1999 CERN - European Organization for Nuclear Research.
0: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
0: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
0: that both that copyright notice and this permission notice appear in supporting documentation. 
0: CERN makes no representations about the suitability of this software for any purpose. 
0: It is provided "as is" without expressed or implied warranty.
0: */
0: package org.apache.mahout.colt.list;
0: 
0: /**
0: Abstract base class for resizable lists holding objects or primitive data types such as <code>int</code>, <code>float</code>, etc.
0: First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
0: <p>
0: <b>Note that this implementation is not synchronized.</b>
0: 
0: @author wolfgang.hoschek@cern.ch
0: @version 1.0, 09/24/99
0: @see     java.util.ArrayList
0: @see	    java.util.Vector
0: @see	    java.util.Arrays
0: */
0: /** 
0:  * @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported.
0:  */
0: @Deprecated
0: public abstract class AbstractList extends AbstractCollection {
0: /**
0:  * Makes this class non instantiable, but still let's others inherit from it.
0:  */
0: protected AbstractList() {}
0: /** 
0:  * Appends all of the elements of the specified Collection to the
0:  * receiver.
0:  *
0:  * @exception ClassCastException if an element in the collection is not
0:  * of the same parameter type of the receiver.
0:  */
0: public void addAllOf(java.util.Collection collection) {
0: 	this.beforeInsertAllOf(size(), collection);
0: }
0: /** Inserts all elements of the specified collection before the specified position into the receiver. 
0:  * Shifts the element
0:  * currently at that position (if any) and any subsequent elements to
0:  * the right (increases their indices). 
0:  *
0:  * @param index index before which to insert first element from the specified collection.
0:  * @param collection the collection to be inserted
0:  * @exception ClassCastException if an element in the collection is not
0:  * of the same parameter type of the receiver.
0:  * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt; size()</tt>.
0:  */
0: public void beforeInsertAllOf(int index, java.util.Collection collection) {
0: 	this.beforeInsertDummies(index, collection.size());
0: 	this.replaceFromWith(index, collection);
0: }
0: /**
0:  * Inserts <tt>length</tt> dummy elements before the specified position into the receiver. 
0:  * Shifts the element currently at that position (if any) and
0:  * any subsequent elements to the right.
0:  * <b>This method must set the new size to be <tt>size()+length</tt>.
0:  *
0:  * @param index index before which to insert dummy elements (must be in [0,size])..
0:  * @param length number of dummy elements to be inserted.
0:  * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt; size()</tt>.
0:  */
0: protected abstract void beforeInsertDummies(int index, int length);
0: /**
0:  * Checks if the given index is in range.
0:  */
0: protected static void checkRange(int index, int theSize) {
0: 	if (index >= theSize || index < 0)
0: 		throw new IndexOutOfBoundsException("Index: "+index+", Size: "+theSize);
0: }
0: /**
0:  * Checks if the given range is within the contained array's bounds.
0:  * @throws IndexOutOfBoundsException if <tt>to!=from-1 || from&lt;0 || from&gt;to || to&gt;=size()</tt>.
0:  */
0: protected static void checkRangeFromTo(int from, int to, int theSize) {
0: 	if (to==from-1) return;
0: 	if (from<0 || from>to || to>=theSize)
0: 		throw new IndexOutOfBoundsException("from: "+from+", to: "+to+", size="+theSize);
0: }
0: /**
0:  * Removes all elements from the receiver.  The receiver will
0:  * be empty after this call returns, but keep its current capacity.
0:  */
0: public void clear() {
0: 	removeFromTo(0,size()-1);
0: }
0: /**
0:  * Sorts the receiver into ascending order.  
0:  * This sort is guaranteed to be <i>stable</i>:  equal elements will
0:  * not be reordered as a result of the sort.<p>
0:  *
0:  * The sorting algorithm is a modified mergesort (in which the merge is
0:  * omitted if the highest element in the low sublist is less than the
0:  * lowest element in the high sublist).  This algorithm offers guaranteed
0:  * n*log(n) performance, and can approach linear performance on nearly
0:  * sorted lists.
0:  *
0:  * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
0:  * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.
0:  */
0: public final void mergeSort() {
0: 	mergeSortFromTo(0, size()-1);
0: }
0: /**
0:  * Sorts the receiver into ascending order.  
0:  * This sort is guaranteed to be <i>stable</i>:  equal elements will
0:  * not be reordered as a result of the sort.<p>
0:  *
0:  * The sorting algorithm is a modified mergesort (in which the merge is
0:  * omitted if the highest element in the low sublist is less than the
0:  * lowest element in the high sublist).  This algorithm offers guaranteed
0:  * n*log(n) performance, and can approach linear performance on nearly
0:  * sorted lists.
0:  *
0:  * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
0:  * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.
0:  *
0:  * @param from the index of the first element (inclusive) to be sorted.
0:  * @param to the index of the last element (inclusive) to be sorted.
0:  * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
0:  */
0: public abstract void mergeSortFromTo(int from, int to);
0: /**
0:  * Sorts the receiver into
0:  * ascending order.  The sorting algorithm is a tuned quicksort,
0:  * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
0:  * Sort Function", Software-Practice and Experience, Vol. 23(11)
0:  * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
0:  * performance on many data sets that cause other quicksorts to degrade to
0:  * quadratic performance.
0:  *
0:  * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
0:  * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.
0:  */
0: public final void quickSort() {
0: 	quickSortFromTo(0, size()-1);
0: }
0: /**
0:  * Sorts the specified range of the receiver into
0:  * ascending order.  The sorting algorithm is a tuned quicksort,
0:  * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
0:  * Sort Function", Software-Practice and Experience, Vol. 23(11)
0:  * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
0:  * performance on many data sets that cause other quicksorts to degrade to
0:  * quadratic performance.
0:  *
0:  * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
0:  * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.
0:  *
0:  * @param from the index of the first element (inclusive) to be sorted.
0:  * @param to the index of the last element (inclusive) to be sorted.
0:  * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
0:  */ 
0: public abstract void quickSortFromTo(int from, int to);
0: /**
0:  * Removes the element at the specified position from the receiver.
0:  * Shifts any subsequent elements to the left.
0:  *
0:  * @param index the index of the element to removed.
0:  * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt;= size()</tt>.
0:  */
0: public void remove(int index) {
0: 	removeFromTo(index, index);
0: }
0: /**
0:  * Removes from the receiver all elements whose index is between
0:  * <code>from</code>, inclusive and <code>to</code>, inclusive.  Shifts any succeeding
0:  * elements to the left (reduces their index).
0:  * This call shortens the list by <tt>(to - from + 1)</tt> elements.
0:  *
0:  * @param from index of first element to be removed.
0:  * @param to index of last element to be removed.
0:  * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
0:  */
0: public abstract void removeFromTo(int fromIndex, int toIndex);
0: /**
0:  * Replaces the part of the receiver starting at <code>from</code> (inclusive) with all the elements of the specified collection.
0:  * Does not alter the size of the receiver.
0:  * Replaces exactly <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.
0:  *
0:  * @param from the index at which to copy the first element from the specified collection.
0:  * @param other Collection to replace part of the receiver
0:  * @throws IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt;= size()</tt>.
0:  */
0: public abstract void replaceFromWith(int from, java.util.Collection other);
0: /**
0:  * Reverses the elements of the receiver.
0:  * Last becomes first, second last becomes second first, and so on.
0:  */
0: public abstract void reverse();
0: /**
0:  * Sets the size of the receiver.
0:  * If the new size is greater than the current size, new null or zero items are added to the end of the receiver.
0:  * If the new size is less than the current size, all components at index newSize and greater are discarded.
0:  * This method does not release any superfluos internal memory. Use method <tt>trimToSize</tt> to release superfluos internal memory.
0:  * @param newSize the new size of the receiver.
0:  * @throws IndexOutOfBoundsException if <tt>newSize &lt; 0</tt>.
0:  */
0: public void setSize(int newSize) {
0: 	if (newSize<0) throw new IndexOutOfBoundsException("newSize:"+newSize);
0: 
0: 	int currentSize = size();
0: 	if (newSize!=currentSize) {
0: 		if (newSize>currentSize) beforeInsertDummies(currentSize,newSize-currentSize);
0: 		else if (newSize<currentSize) removeFromTo(newSize, currentSize-1);
0: 	}
0: }
0: /**
0:  * Randomly permutes the receiver. After invocation, all elements will be at random positions.
0:  */
0: public final void shuffle() {
0: 	shuffleFromTo(0, size()-1);
0: }
0: /**
0:  * Randomly permutes the receiver between <code>from</code> (inclusive) and <code>to</code> (inclusive). 
0:  * @param from the start position (inclusive)
0:  * @param to the end position (inclusive)
0:  * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
0:  */
0: public abstract void shuffleFromTo(int from, int to);
0: /**
0:  * Sorts the receiver into ascending order. 
0:  *
0:  * The sorting algorithm is dynamically chosen according to the characteristics of the data set.
0:  *
0:  * This implementation simply calls <tt>sortFromTo(...)</tt>.
0:  * Override <tt>sortFromTo(...)</tt> if you can determine which sort is most appropriate for the given data set.
0:  */
0: public final void sort() {
0: 	sortFromTo(0, size()-1);
0: }
0: /**
0:  * Sorts the specified range of the receiver into ascending order. 
0:  *
0:  * The sorting algorithm is dynamically chosen according to the characteristics of the data set.
0:  * This default implementation simply calls quickSort.
0:  * Override this method if you can determine which sort is most appropriate for the given data set.
0:  *
0:  * @param from the index of the first element (inclusive) to be sorted.
0:  * @param to the index of the last element (inclusive) to be sorted.
0:  * @throws IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.
0:  */
0: public void sortFromTo(int from, int to) {
0: 	quickSortFromTo(from, to);
0: }
0: /**
0:  * Trims the capacity of the receiver to be the receiver's current 
0:  * size. Releases any superfluos internal memory. An application can use this operation to minimize the 
0:  * storage of the receiver.
0:  * <p>
0:  * This default implementation does nothing. Override this method in space efficient implementations.
0:  */
0: public void trimToSize() {
0: }
0: }
============================================================================