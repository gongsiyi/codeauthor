1:27d33a2: /**
1:27d33a2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:27d33a2:  * contributor license agreements.  See the NOTICE file distributed with
1:27d33a2:  * this work for additional information regarding copyright ownership.
1:27d33a2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:27d33a2:  * (the "License"); you may not use this file except in compliance with
1:27d33a2:  * the License.  You may obtain a copy of the License at
2:27d33a2:  *
1:27d33a2:  *     http://www.apache.org/licenses/LICENSE-2.0
1:27d33a2:  *
1:27d33a2:  * Unless required by applicable law or agreed to in writing, software
1:27d33a2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:27d33a2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:27d33a2:  * See the License for the specific language governing permissions and
1:27d33a2:  * limitations under the License.
1:27d33a2:  */
4:27d33a2: 
1:27d33a2: package org.apache.mahout.classifier.sequencelearning.hmm;
1:27d33a2: 
1:85f9ece: import java.util.ArrayList;
1:27d33a2: import java.util.Collection;
1:27d33a2: import java.util.Iterator;
1:d53cf4a: import java.util.List;
1:27d33a2: 
1:85f9ece: import com.google.common.base.Preconditions;
1:27d33a2: import org.apache.mahout.math.DenseMatrix;
1:27d33a2: import org.apache.mahout.math.DenseVector;
1:27d33a2: import org.apache.mahout.math.Matrix;
1:27d33a2: import org.apache.mahout.math.RandomAccessSparseVector;
1:27d33a2: import org.apache.mahout.math.SparseMatrix;
1:27d33a2: import org.apache.mahout.math.Vector;
1:69ba194: 
1:27d33a2: /**
1:27d33a2:  * A collection of utilities for handling HMMModel objects.
1:27d33a2:  */
1:27d33a2: public final class HmmUtils {
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * No public constructor for utility classes.
1:27d33a2:    */
1:27d33a2:   private HmmUtils() {
1:27d33a2:     // nothing to do here really.
16:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Compute the cumulative transition probability matrix for the given HMM
1:27d33a2:    * model. Matrix where each row i is the cumulative distribution of the
1:27d33a2:    * transition probability distribution for hidden state i.
1:27d33a2:    *
1:27d33a2:    * @param model The HMM model for which the cumulative transition matrix should be
1:27d33a2:    *              computed
1:27d33a2:    * @return The computed cumulative transition matrix.
1:27d33a2:    */
1:27d33a2:   public static Matrix getCumulativeTransitionMatrix(HmmModel model) {
1:27d33a2:     // fetch the needed parameters from the model
1:27d33a2:     int hiddenStates = model.getNrOfHiddenStates();
1:27d33a2:     Matrix transitionMatrix = model.getTransitionMatrix();
1:27d33a2:     // now compute the cumulative transition matrix
1:27d33a2:     Matrix resultMatrix = new DenseMatrix(hiddenStates, hiddenStates);
1:27d33a2:     for (int i = 0; i < hiddenStates; ++i) {
1:27d33a2:       double sum = 0;
1:27d33a2:       for (int j = 0; j < hiddenStates; ++j) {
1:27d33a2:         sum += transitionMatrix.get(i, j);
1:27d33a2:         resultMatrix.set(i, j, sum);
1:27d33a2:       }
1:27d33a2:       resultMatrix.set(i, hiddenStates - 1, 1.0);
1:27d33a2:       // make sure the last
1:27d33a2:       // state has always a
1:27d33a2:       // cumulative
1:27d33a2:       // probability of
1:27d33a2:       // exactly 1.0
1:27d33a2:     }
1:27d33a2:     return resultMatrix;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Compute the cumulative output probability matrix for the given HMM model.
1:27d33a2:    * Matrix where each row i is the cumulative distribution of the output
1:27d33a2:    * probability distribution for hidden state i.
1:27d33a2:    *
1:27d33a2:    * @param model The HMM model for which the cumulative output matrix should be
1:27d33a2:    *              computed
1:27d33a2:    * @return The computed cumulative output matrix.
1:27d33a2:    */
1:27d33a2:   public static Matrix getCumulativeOutputMatrix(HmmModel model) {
1:27d33a2:     // fetch the needed parameters from the model
1:27d33a2:     int hiddenStates = model.getNrOfHiddenStates();
1:27d33a2:     int outputStates = model.getNrOfOutputStates();
1:27d33a2:     Matrix outputMatrix = model.getEmissionMatrix();
1:27d33a2:     // now compute the cumulative output matrix
1:27d33a2:     Matrix resultMatrix = new DenseMatrix(hiddenStates, outputStates);
1:27d33a2:     for (int i = 0; i < hiddenStates; ++i) {
1:27d33a2:       double sum = 0;
1:27d33a2:       for (int j = 0; j < outputStates; ++j) {
1:27d33a2:         sum += outputMatrix.get(i, j);
1:27d33a2:         resultMatrix.set(i, j, sum);
1:27d33a2:       }
1:27d33a2:       resultMatrix.set(i, outputStates - 1, 1.0);
1:27d33a2:       // make sure the last
1:27d33a2:       // output state has
1:27d33a2:       // always a cumulative
1:27d33a2:       // probability of 1.0
1:27d33a2:     }
1:27d33a2:     return resultMatrix;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Compute the cumulative distribution of the initial hidden state
1:27d33a2:    * probabilities for the given HMM model.
1:27d33a2:    *
1:27d33a2:    * @param model The HMM model for which the cumulative initial state probabilities
1:27d33a2:    *              should be computed
1:27d33a2:    * @return The computed cumulative initial state probability vector.
1:27d33a2:    */
1:27d33a2:   public static Vector getCumulativeInitialProbabilities(HmmModel model) {
1:27d33a2:     // fetch the needed parameters from the model
1:27d33a2:     int hiddenStates = model.getNrOfHiddenStates();
1:27d33a2:     Vector initialProbabilities = model.getInitialProbabilities();
1:27d33a2:     // now compute the cumulative output matrix
1:27d33a2:     Vector resultVector = new DenseVector(initialProbabilities.size());
1:27d33a2:     double sum = 0;
1:27d33a2:     for (int i = 0; i < hiddenStates; ++i) {
1:27d33a2:       sum += initialProbabilities.get(i);
1:27d33a2:       resultVector.set(i, sum);
1:27d33a2:     }
1:27d33a2:     resultVector.set(hiddenStates - 1, 1.0); // make sure the last initial
1:27d33a2:     // hidden state probability
1:27d33a2:     // has always a cumulative
1:27d33a2:     // probability of 1.0
1:27d33a2:     return resultVector;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Validates an HMM model set
1:27d33a2:    *
1:27d33a2:    * @param model model to sanity check.
1:27d33a2:    */
1:27d33a2:   public static void validate(HmmModel model) {
1:27d33a2:     if (model == null) {
1:27d33a2:       return; // empty models are valid
1:27d33a2:     }
1:27d33a2: 
1:27d33a2:     /*
1:27d33a2:      * The number of hidden states is positive.
1:27d33a2:      */
1:69ba194:     Preconditions.checkArgument(model.getNrOfHiddenStates() > 0,
1:69ba194:       "Error: The number of hidden states has to be greater than 0");
1:69ba194:     
1:27d33a2:     /*
1:27d33a2:      * The number of output states is positive.
1:27d33a2:      */
1:69ba194:     Preconditions.checkArgument(model.getNrOfOutputStates() > 0,
1:69ba194:       "Error: The number of output states has to be greater than 0!");
1:27d33a2: 
1:27d33a2:     /*
1:27d33a2:      * The size of the vector of initial probabilities is equal to the number of
1:27d33a2:      * the hidden states. Each initial probability is non-negative. The sum of
1:27d33a2:      * initial probabilities is equal to 1.
1:27d33a2:      */
1:69ba194:     Preconditions.checkArgument(model.getInitialProbabilities() != null
1:69ba194:       && model.getInitialProbabilities().size() == model.getNrOfHiddenStates(),
1:69ba194:       "Error: The vector of initial probabilities is not initialized!");
1:69ba194:     
1:27d33a2:     double sum = 0;
1:27d33a2:     for (int i = 0; i < model.getInitialProbabilities().size(); i++) {
1:69ba194:       Preconditions.checkArgument(model.getInitialProbabilities().get(i) >= 0,
1:69ba194:         "Error: Initial probability of state %d is negative", i);
1:27d33a2:       sum += model.getInitialProbabilities().get(i);
1:27d33a2:     }
1:2deba36:     Preconditions.checkArgument(Math.abs(sum - 1) <= 0.00001,
1:3218e95:                                 "Error: Initial probabilities do not add up to 1");
1:27d33a2:     /*
1:27d33a2:      * The row size of the output matrix is equal to the number of the hidden
1:27d33a2:      * states. The column size is equal to the number of output states. Each
1:27d33a2:      * probability of the matrix is non-negative. The sum of each row is equal
1:27d33a2:      * to 1.
1:27d33a2:      */
1:74f849b:     Preconditions.checkNotNull(model.getEmissionMatrix(), "Error: The output state matrix is not initialized!");
1:69ba194:     Preconditions.checkArgument(model.getEmissionMatrix().numRows() == model.getNrOfHiddenStates()
1:69ba194:         && model.getEmissionMatrix().numCols() == model.getNrOfOutputStates(),
1:69ba194:         "Error: The output state matrix is not of the form nrOfHiddenStates x nrOfOutputStates");
1:27d33a2:     for (int i = 0; i < model.getEmissionMatrix().numRows(); i++) {
1:27d33a2:       sum = 0;
1:27d33a2:       for (int j = 0; j < model.getEmissionMatrix().numCols(); j++) {
1:69ba194:         Preconditions.checkArgument(model.getEmissionMatrix().get(i, j) >= 0,
1:d61a0ee:             "The output state probability from hidden state " + i + " to output state " + j + " is negative");
1:27d33a2:         sum += model.getEmissionMatrix().get(i, j);
1:27d33a2:       }
1:2deba36:       Preconditions.checkArgument(Math.abs(sum - 1) <= 0.00001,
1:69ba194:         "Error: The output state probabilities for hidden state %d don't add up to 1", i);
1:27d33a2:     }
1:27d33a2: 
1:27d33a2:     /*
1:27d33a2:      * The size of both dimension of the transition matrix is equal to the
1:27d33a2:      * number of the hidden states. Each probability of the matrix is
1:27d33a2:      * non-negative. The sum of each row in transition matrix is equal to 1.
1:27d33a2:      */
1:69ba194:     Preconditions.checkArgument(model.getTransitionMatrix() != null,
1:69ba194:       "Error: The hidden state matrix is not initialized!");
1:69ba194:     Preconditions.checkArgument(model.getTransitionMatrix().numRows() == model.getNrOfHiddenStates()
1:69ba194:       && model.getTransitionMatrix().numCols() == model.getNrOfHiddenStates(),
1:69ba194:       "Error: The output state matrix is not of the form nrOfHiddenStates x nrOfHiddenStates");
1:27d33a2:     for (int i = 0; i < model.getTransitionMatrix().numRows(); i++) {
1:27d33a2:       sum = 0;
1:27d33a2:       for (int j = 0; j < model.getTransitionMatrix().numCols(); j++) {
1:69ba194:         Preconditions.checkArgument(model.getTransitionMatrix().get(i, j) >= 0,
1:74f849b:           "Error: The transition probability from hidden state %d to hidden state %d is negative", i, j);
1:27d33a2:         sum += model.getTransitionMatrix().get(i, j);
1:27d33a2:       }
1:2deba36:       Preconditions.checkArgument(Math.abs(sum - 1) <= 0.00001,
1:69ba194:         "Error: The transition probabilities for hidden state " + i + " don't add up to 1.");
1:27d33a2:     }
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Encodes a given collection of state names by the corresponding state IDs
1:27d33a2:    * registered in a given model.
1:27d33a2:    *
1:27d33a2:    * @param model        Model to provide the encoding for
1:27d33a2:    * @param sequence     Collection of state names
1:27d33a2:    * @param observed     If set, the sequence is encoded as a sequence of observed states,
1:27d33a2:    *                     else it is encoded as sequence of hidden states
1:27d33a2:    * @param defaultValue The default value in case a state is not known
1:27d33a2:    * @return integer array containing the encoded state IDs
1:27d33a2:    */
1:27d33a2:   public static int[] encodeStateSequence(HmmModel model,
1:27d33a2:                                           Collection<String> sequence, boolean observed, int defaultValue) {
1:27d33a2:     int[] encoded = new int[sequence.size()];
1:27d33a2:     Iterator<String> seqIter = sequence.iterator();
1:27d33a2:     for (int i = 0; i < sequence.size(); ++i) {
1:27d33a2:       String nextState = seqIter.next();
1:27d33a2:       int nextID;
1:d53cf4a:       if (observed) {
1:27d33a2:         nextID = model.getOutputStateID(nextState);
1:d53cf4a:       } else {
1:27d33a2:         nextID = model.getHiddenStateID(nextState);
1:d53cf4a:       }
1:27d33a2:       // if the ID is -1, use the default value
1:39fe224:       encoded[i] = nextID < 0 ? defaultValue : nextID;
1:27d33a2:     }
1:27d33a2:     return encoded;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Decodes a given collection of state IDs into the corresponding state names
1:27d33a2:    * registered in a given model.
1:27d33a2:    *
1:27d33a2:    * @param model        model to use for retrieving state names
1:27d33a2:    * @param sequence     int array of state IDs
1:27d33a2:    * @param observed     If set, the sequence is encoded as a sequence of observed states,
1:27d33a2:    *                     else it is encoded as sequence of hidden states
1:27d33a2:    * @param defaultValue The default value in case a state is not known
1:d53cf4a:    * @return list containing the decoded state names
1:27d33a2:    */
1:61ae2e7:   public static List<String> decodeStateSequence(HmmModel model,
1:61ae2e7:                                                  int[] sequence,
1:61ae2e7:                                                  boolean observed,
1:61ae2e7:                                                  String defaultValue) {
1:85f9ece:     List<String> decoded = new ArrayList<>(sequence.length);
1:27d33a2:     for (int position : sequence) {
1:27d33a2:       String nextState;
1:d53cf4a:       if (observed) {
1:27d33a2:         nextState = model.getOutputStateName(position);
1:d53cf4a:       } else {
1:27d33a2:         nextState = model.getHiddenStateName(position);
1:d53cf4a:       }
1:27d33a2:       // if null was returned, use the default value
1:27d33a2:       decoded.add(nextState == null ? defaultValue : nextState);
1:27d33a2:     }
1:27d33a2:     return decoded;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Function used to normalize the probabilities of a given HMM model
1:27d33a2:    *
1:27d33a2:    * @param model model to normalize
1:27d33a2:    */
1:27d33a2:   public static void normalizeModel(HmmModel model) {
1:27d33a2:     Vector ip = model.getInitialProbabilities();
1:27d33a2:     Matrix emission = model.getEmissionMatrix();
1:27d33a2:     Matrix transition = model.getTransitionMatrix();
1:27d33a2:     // check normalization for all probabilities
1:27d33a2:     double isum = 0;
1:27d33a2:     for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
1:27d33a2:       isum += ip.getQuick(i);
1:27d33a2:       double sum = 0;
1:d53cf4a:       for (int j = 0; j < model.getNrOfHiddenStates(); ++j) {
1:27d33a2:         sum += transition.getQuick(i, j);
1:d53cf4a:       }
1:27d33a2:       if (sum != 1.0) {
1:d53cf4a:         for (int j = 0; j < model.getNrOfHiddenStates(); ++j) {
1:27d33a2:           transition.setQuick(i, j, transition.getQuick(i, j) / sum);
1:d53cf4a:         }
1:27d33a2:       }
1:27d33a2:       sum = 0;
1:d53cf4a:       for (int j = 0; j < model.getNrOfOutputStates(); ++j) {
1:27d33a2:         sum += emission.getQuick(i, j);
1:d53cf4a:       }
1:27d33a2:       if (sum != 1.0) {
1:d53cf4a:         for (int j = 0; j < model.getNrOfOutputStates(); ++j) {
1:27d33a2:           emission.setQuick(i, j, emission.getQuick(i, j) / sum);
1:d53cf4a:         }
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:     if (isum != 1.0) {
1:d53cf4a:       for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
1:27d33a2:         ip.setQuick(i, ip.getQuick(i) / isum);
1:d53cf4a:       }
1:27d33a2:     }
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Method to reduce the size of an HMMmodel by converting the models
1:27d33a2:    * DenseMatrix/DenseVectors to sparse implementations and setting every value
1:27d33a2:    * < threshold to 0
1:27d33a2:    *
1:27d33a2:    * @param model model to truncate
1:27d33a2:    * @param threshold minimum value a model entry must have to be retained.
1:27d33a2:    * @return Truncated model
1:27d33a2:    */
1:27d33a2:   public static HmmModel truncateModel(HmmModel model, double threshold) {
1:27d33a2:     Vector ip = model.getInitialProbabilities();
1:27d33a2:     Matrix em = model.getEmissionMatrix();
1:27d33a2:     Matrix tr = model.getTransitionMatrix();
1:27d33a2:     // allocate the sparse data structures
1:27d33a2:     RandomAccessSparseVector sparseIp = new RandomAccessSparseVector(model
1:27d33a2:         .getNrOfHiddenStates());
1:95f836b:     SparseMatrix sparseEm = new SparseMatrix(model.getNrOfHiddenStates(), model.getNrOfOutputStates());
1:95f836b:     SparseMatrix sparseTr = new SparseMatrix(model.getNrOfHiddenStates(), model.getNrOfHiddenStates());
1:27d33a2:     // now transfer the values
1:27d33a2:     for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
1:27d33a2:       double value = ip.getQuick(i);
1:d53cf4a:       if (value > threshold) {
1:27d33a2:         sparseIp.setQuick(i, value);
1:d53cf4a:       }
1:27d33a2:       for (int j = 0; j < model.getNrOfHiddenStates(); ++j) {
1:27d33a2:         value = tr.getQuick(i, j);
1:d53cf4a:         if (value > threshold) {
1:27d33a2:           sparseTr.setQuick(i, j, value);
1:d53cf4a:         }
1:27d33a2:       }
1:27d33a2: 
1:27d33a2:       for (int j = 0; j < model.getNrOfOutputStates(); ++j) {
1:27d33a2:         value = em.getQuick(i, j);
1:d53cf4a:         if (value > threshold) {
1:27d33a2:           sparseEm.setQuick(i, j, value);
1:d53cf4a:         }
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:     // create a new model
1:27d33a2:     HmmModel sparseModel = new HmmModel(sparseTr, sparseEm, sparseIp);
1:27d33a2:     // normalize the model
1:d53cf4a:     normalizeModel(sparseModel);
1:27d33a2:     // register the names
1:27d33a2:     sparseModel.registerHiddenStateNames(model.getHiddenStateNames());
1:27d33a2:     sparseModel.registerOutputStateNames(model.getOutputStateNames());
1:27d33a2:     // and return
1:27d33a2:     return sparseModel;
1:69ba194:   }
1:27d33a2: }
============================================================================
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:85f9ece
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import com.google.common.base.Preconditions;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     List<String> decoded = new ArrayList<>(sequence.length);
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:2deba36
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkArgument(Math.abs(sum - 1) <= 0.00001,
/////////////////////////////////////////////////////////////////////////
1:       Preconditions.checkArgument(Math.abs(sum - 1) <= 0.00001,
/////////////////////////////////////////////////////////////////////////
1:       Preconditions.checkArgument(Math.abs(sum - 1) <= 0.00001,
commit:39fe224
/////////////////////////////////////////////////////////////////////////
1:       encoded[i] = nextID < 0 ? defaultValue : nextID;
commit:3218e95
/////////////////////////////////////////////////////////////////////////
0:     Preconditions.checkArgument(Maths.approxEquals(sum, 1, 0.00001),
1:                                 "Error: Initial probabilities do not add up to 1");
0:     Preconditions.checkArgument(model.getEmissionMatrix() != null,
0:                                 "Error: The output state matrix is not initialized!");
commit:d61a0ee
/////////////////////////////////////////////////////////////////////////
0:         Preconditions.checkArgument(
0:             model.getEmissionMatrix().get(i, j) >= 0,
1:             "The output state probability from hidden state " + i + " to output state " + j + " is negative");
commit:69ba194
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.base.Preconditions;
1: 
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkArgument(model.getNrOfHiddenStates() > 0,
1:       "Error: The number of hidden states has to be greater than 0");
1:     
1:     Preconditions.checkArgument(model.getNrOfOutputStates() > 0,
1:       "Error: The number of output states has to be greater than 0!");
1:     Preconditions.checkArgument(model.getInitialProbabilities() != null
1:       && model.getInitialProbabilities().size() == model.getNrOfHiddenStates(),
1:       "Error: The vector of initial probabilities is not initialized!");
1:     
1:       Preconditions.checkArgument(model.getInitialProbabilities().get(i) >= 0,
1:         "Error: Initial probability of state %d is negative", i);
0:     Preconditions.checkArgument(Maths.approxEquals(sum, 1, 0.00001), "Error: Initial probabilities do not add up to 1");
0:     Preconditions.checkArgument(model.getEmissionMatrix() != null, "Error: The output state matrix is not initialized!");
1:     Preconditions.checkArgument(model.getEmissionMatrix().numRows() == model.getNrOfHiddenStates()
1:       && model.getEmissionMatrix().numCols() == model.getNrOfOutputStates(),
1:       "Error: The output state matrix is not of the form nrOfHiddenStates x nrOfOutputStates");
1:         Preconditions.checkArgument(model.getEmissionMatrix().get(i, j) >= 0,
0:           "Error: The output state probability from hidden state " + i +
0:             " to output state " + j + " is negative");
0:       Preconditions.checkArgument(Maths.approxEquals(sum, 1, 0.00001),
1:         "Error: The output state probabilities for hidden state %d don't add up to 1", i);
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkArgument(model.getTransitionMatrix() != null,
1:       "Error: The hidden state matrix is not initialized!");
1:     Preconditions.checkArgument(model.getTransitionMatrix().numRows() == model.getNrOfHiddenStates()
1:       && model.getTransitionMatrix().numCols() == model.getNrOfHiddenStates(),
1:       "Error: The output state matrix is not of the form nrOfHiddenStates x nrOfHiddenStates");
1:         Preconditions.checkArgument(model.getTransitionMatrix().get(i, j) >= 0,
0:           "Error: The transition probability from hidden state %d to hidden state %d is negative",
0:           i, j);
0:       Preconditions.checkArgument(Maths.approxEquals(sum, 1, 0.00001),
1:         "Error: The transition probabilities for hidden state " + i + " don't add up to 1.");
/////////////////////////////////////////////////////////////////////////
1: }
commit:61ae2e7
/////////////////////////////////////////////////////////////////////////
1:   public static List<String> decodeStateSequence(HmmModel model,
1:                                                  int[] sequence,
1:                                                  boolean observed,
1:                                                  String defaultValue) {
commit:d53cf4a
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       if (observed) {
1:       } else {
1:       }
/////////////////////////////////////////////////////////////////////////
1:    * @return list containing the decoded state names
0:   public static List<String> decodeStateSequence(HmmModel model, int[] sequence, boolean observed, String defaultValue) {
0:     List<String> decoded = new ArrayList<String>(sequence.length);
1:       if (observed) {
1:       } else {
1:       }
/////////////////////////////////////////////////////////////////////////
1:       for (int j = 0; j < model.getNrOfHiddenStates(); ++j) {
1:       }
1:         for (int j = 0; j < model.getNrOfHiddenStates(); ++j) {
1:         }
1:       for (int j = 0; j < model.getNrOfOutputStates(); ++j) {
1:       }
1:         for (int j = 0; j < model.getNrOfOutputStates(); ++j) {
1:         }
1:       for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
1:       }
/////////////////////////////////////////////////////////////////////////
1:       if (value > threshold) {
1:       }
1:         if (value > threshold) {
1:         }
1:         if (value > threshold) {
1:         }
1:     normalizeModel(sparseModel);
author:Ted Dunning
-------------------------------------------------------------------------------
commit:95f836b
/////////////////////////////////////////////////////////////////////////
1:     SparseMatrix sparseEm = new SparseMatrix(model.getNrOfHiddenStates(), model.getNrOfOutputStates());
1:     SparseMatrix sparseTr = new SparseMatrix(model.getNrOfHiddenStates(), model.getNrOfHiddenStates());
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:74f849b
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkNotNull(model.getEmissionMatrix(), "Error: The output state matrix is not initialized!");
0:         && model.getEmissionMatrix().numCols() == model.getNrOfOutputStates(),
0:         "Error: The output state matrix is not of the form nrOfHiddenStates x nrOfOutputStates");
0:         Preconditions.checkArgument(model.getEmissionMatrix().get(i, j) >= 0,
/////////////////////////////////////////////////////////////////////////
1:           "Error: The transition probability from hidden state %d to hidden state %d is negative", i, j);
/////////////////////////////////////////////////////////////////////////
0:     List<String> decoded = Lists.newArrayListWithCapacity(sequence.length);
author:Isabel Drost
-------------------------------------------------------------------------------
commit:27d33a2
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.classifier.sequencelearning.hmm;
1: 
1: import java.util.Collection;
1: import java.util.Iterator;
1: 
1: import org.apache.mahout.math.DenseMatrix;
1: import org.apache.mahout.math.DenseVector;
1: import org.apache.mahout.math.Matrix;
1: import org.apache.mahout.math.RandomAccessSparseVector;
1: import org.apache.mahout.math.SparseMatrix;
1: import org.apache.mahout.math.Vector;
0: import org.uncommons.maths.Maths;
1: 
1: /**
1:  * A collection of utilities for handling HMMModel objects.
1:  *
0:  * @author mheimel
1:  */
1: public final class HmmUtils {
1: 
1:   /**
1:    * No public constructor for utility classes.
1:    */
1:   private HmmUtils() {
1:     // nothing to do here really.
1:   }
1: 
1:   /**
1:    * Compute the cumulative transition probability matrix for the given HMM
1:    * model. Matrix where each row i is the cumulative distribution of the
1:    * transition probability distribution for hidden state i.
1:    *
1:    * @param model The HMM model for which the cumulative transition matrix should be
1:    *              computed
1:    * @return The computed cumulative transition matrix.
1:    */
1:   public static Matrix getCumulativeTransitionMatrix(HmmModel model) {
1:     // fetch the needed parameters from the model
1:     int hiddenStates = model.getNrOfHiddenStates();
1:     Matrix transitionMatrix = model.getTransitionMatrix();
1:     // now compute the cumulative transition matrix
1:     Matrix resultMatrix = new DenseMatrix(hiddenStates, hiddenStates);
1:     for (int i = 0; i < hiddenStates; ++i) {
1:       double sum = 0;
1:       for (int j = 0; j < hiddenStates; ++j) {
1:         sum += transitionMatrix.get(i, j);
1:         resultMatrix.set(i, j, sum);
1:       }
1:       resultMatrix.set(i, hiddenStates - 1, 1.0);
1:       // make sure the last
1:       // state has always a
1:       // cumulative
1:       // probability of
1:       // exactly 1.0
1:     }
1:     return resultMatrix;
1:   }
1: 
1:   /**
1:    * Compute the cumulative output probability matrix for the given HMM model.
1:    * Matrix where each row i is the cumulative distribution of the output
1:    * probability distribution for hidden state i.
1:    *
1:    * @param model The HMM model for which the cumulative output matrix should be
1:    *              computed
1:    * @return The computed cumulative output matrix.
1:    */
1:   public static Matrix getCumulativeOutputMatrix(HmmModel model) {
1:     // fetch the needed parameters from the model
1:     int hiddenStates = model.getNrOfHiddenStates();
1:     int outputStates = model.getNrOfOutputStates();
1:     Matrix outputMatrix = model.getEmissionMatrix();
1:     // now compute the cumulative output matrix
1:     Matrix resultMatrix = new DenseMatrix(hiddenStates, outputStates);
1:     for (int i = 0; i < hiddenStates; ++i) {
1:       double sum = 0;
1:       for (int j = 0; j < outputStates; ++j) {
1:         sum += outputMatrix.get(i, j);
1:         resultMatrix.set(i, j, sum);
1:       }
1:       resultMatrix.set(i, outputStates - 1, 1.0);
1:       // make sure the last
1:       // output state has
1:       // always a cumulative
1:       // probability of 1.0
1:     }
1:     return resultMatrix;
1:   }
1: 
1:   /**
1:    * Compute the cumulative distribution of the initial hidden state
1:    * probabilities for the given HMM model.
1:    *
1:    * @param model The HMM model for which the cumulative initial state probabilities
1:    *              should be computed
1:    * @return The computed cumulative initial state probability vector.
1:    */
1:   public static Vector getCumulativeInitialProbabilities(HmmModel model) {
1:     // fetch the needed parameters from the model
1:     int hiddenStates = model.getNrOfHiddenStates();
1:     Vector initialProbabilities = model.getInitialProbabilities();
1:     // now compute the cumulative output matrix
1:     Vector resultVector = new DenseVector(initialProbabilities.size());
1:     double sum = 0;
1:     for (int i = 0; i < hiddenStates; ++i) {
1:       sum += initialProbabilities.get(i);
1:       resultVector.set(i, sum);
1:     }
1:     resultVector.set(hiddenStates - 1, 1.0); // make sure the last initial
1:     // hidden state probability
1:     // has always a cumulative
1:     // probability of 1.0
1:     return resultVector;
1:   }
1: 
1:   /**
1:    * Validates an HMM model set
1:    *
1:    * @param model model to sanity check.
1:    */
1:   public static void validate(HmmModel model) {
1:     if (model == null) {
1:       return; // empty models are valid
1:     }
1: 
1:     /*
1:      * The number of hidden states is positive.
1:      */
0:     if (model.getNrOfHiddenStates() <= 0) {
0:       throw new IllegalArgumentException(
0:           "Error: The number of hidden states has to be greater than 0!");
1:     }
1: 
1:     /*
1:      * The number of output states is positive.
1:      */
0:     if (model.getNrOfOutputStates() <= 0) {
0:       throw new IllegalArgumentException(
0:           "Error: The number of output states has to be greater than 0!");
1:     }
1: 
1:     /*
1:      * The size of the vector of initial probabilities is equal to the number of
1:      * the hidden states. Each initial probability is non-negative. The sum of
1:      * initial probabilities is equal to 1.
1:      */
0:     if (model.getInitialProbabilities() == null) {
0:       throw new IllegalArgumentException(
0:           "Error: The vector of initial probabilities is not initialized!");
1:     }
0:     if (model.getInitialProbabilities().size() != model.getNrOfHiddenStates()) {
0:       throw new IllegalArgumentException(
0:           "Error: The vector of initial probabilities is not initialized!");
1:     }
1:     double sum = 0;
1:     for (int i = 0; i < model.getInitialProbabilities().size(); i++) {
0:       if (model.getInitialProbabilities().get(i) < 0) {
0:         throw new IllegalArgumentException(
0:             "Error: Initial probability of state " + i + " is negative!");
1:       }
1:       sum += model.getInitialProbabilities().get(i);
1:     }
0:     if (!Maths.approxEquals(sum, 1, 0.00001)) {
0:       throw new IllegalArgumentException(
0:           "Error: Initial probabilities do not add up to 1!");
1:     }
1: 
1:     /*
1:      * The row size of the output matrix is equal to the number of the hidden
1:      * states. The column size is equal to the number of output states. Each
1:      * probability of the matrix is non-negative. The sum of each row is equal
1:      * to 1.
1:      */
0:     if (model.getEmissionMatrix() == null) {
0:       throw new IllegalArgumentException(
0:           "Error: The output state matrix is not initialized!");
1:     }
0:     if (model.getEmissionMatrix().numRows() != model.getNrOfHiddenStates()
0:         || model.getEmissionMatrix().numCols() != model.getNrOfOutputStates()) {
0:       throw new IllegalArgumentException(
0:           "Error: The output state matrix is not of the form nrOfHiddenStates x nrOfOutputStates!");
1:     }
1:     for (int i = 0; i < model.getEmissionMatrix().numRows(); i++) {
1:       sum = 0;
1:       for (int j = 0; j < model.getEmissionMatrix().numCols(); j++) {
0:         if (model.getEmissionMatrix().get(i, j) < 0) {
0:           throw new IllegalArgumentException(
0:               "Error: The output state probability from hidden state " + i
0:                   + " to output state " + j + " is negative!");
1:         }
1:         sum += model.getEmissionMatrix().get(i, j);
1:       }
0:       if (!Maths.approxEquals(sum, 1, 0.00001)) {
0:         throw new IllegalArgumentException(
0:             "Error: The output state probabilities for hidden state " + i
0:                 + " don't add up to 1.");
1:       }
1:     }
1: 
1:     /*
1:      * The size of both dimension of the transition matrix is equal to the
1:      * number of the hidden states. Each probability of the matrix is
1:      * non-negative. The sum of each row in transition matrix is equal to 1.
1:      */
0:     if (model.getTransitionMatrix() == null) {
0:       throw new IllegalArgumentException(
0:           "Error: The hidden state matrix is not initialized!");
1:     }
0:     if (model.getTransitionMatrix().numRows() != model.getNrOfHiddenStates()
0:         || model.getTransitionMatrix().numCols() != model.getNrOfHiddenStates()) {
0:       throw new IllegalArgumentException(
0:           "Error: The output state matrix is not of the form nrOfHiddenStates x nrOfHiddenStates!");
1:     }
1:     for (int i = 0; i < model.getTransitionMatrix().numRows(); i++) {
1:       sum = 0;
1:       for (int j = 0; j < model.getTransitionMatrix().numCols(); j++) {
0:         if (model.getTransitionMatrix().get(i, j) < 0) {
0:           throw new IllegalArgumentException(
0:               "Error: The transition probability from hidden state " + i
0:                   + " to hidden state " + j + " is negative!");
1:         }
1:         sum += model.getTransitionMatrix().get(i, j);
1:       }
0:       if (!Maths.approxEquals(sum, 1, 0.00001)) {
0:         throw new IllegalArgumentException(
0:             "Error: The transition probabilities for hidden state " + i
0:                 + " don't add up to 1.");
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Encodes a given collection of state names by the corresponding state IDs
1:    * registered in a given model.
1:    *
1:    * @param model        Model to provide the encoding for
1:    * @param sequence     Collection of state names
1:    * @param observed     If set, the sequence is encoded as a sequence of observed states,
1:    *                     else it is encoded as sequence of hidden states
1:    * @param defaultValue The default value in case a state is not known
1:    * @return integer array containing the encoded state IDs
1:    */
1:   public static int[] encodeStateSequence(HmmModel model,
1:                                           Collection<String> sequence, boolean observed, int defaultValue) {
1:     int[] encoded = new int[sequence.size()];
1:     Iterator<String> seqIter = sequence.iterator();
1:     for (int i = 0; i < sequence.size(); ++i) {
1:       String nextState = seqIter.next();
1:       int nextID;
0:       if (observed)
1:         nextID = model.getOutputStateID(nextState);
0:       else
1:         nextID = model.getHiddenStateID(nextState);
1:       // if the ID is -1, use the default value
0:       encoded[i] = (nextID < 0) ? defaultValue : nextID;
1:     }
1:     return encoded;
1:   }
1: 
1:   /**
1:    * Decodes a given collection of state IDs into the corresponding state names
1:    * registered in a given model.
1:    *
1:    * @param model        model to use for retrieving state names
1:    * @param sequence     int array of state IDs
1:    * @param observed     If set, the sequence is encoded as a sequence of observed states,
1:    *                     else it is encoded as sequence of hidden states
1:    * @param defaultValue The default value in case a state is not known
0:    * @return java.util.Vector containing the decoded state names
1:    */
0:   public static java.util.Vector<String> decodeStateSequence(HmmModel model,
0:                                                              int[] sequence, boolean observed, String defaultValue) {
0:     java.util.Vector<String> decoded = new java.util.Vector<String>(
0:         sequence.length);
1:     for (int position : sequence) {
1:       String nextState;
0:       if (observed)
1:         nextState = model.getOutputStateName(position);
0:       else
1:         nextState = model.getHiddenStateName(position);
1:       // if null was returned, use the default value
1:       decoded.add(nextState == null ? defaultValue : nextState);
1:     }
1:     return decoded;
1:   }
1: 
1:   /**
1:    * Function used to normalize the probabilities of a given HMM model
1:    *
1:    * @param model model to normalize
1:    */
1:   public static void normalizeModel(HmmModel model) {
1:     Vector ip = model.getInitialProbabilities();
1:     Matrix emission = model.getEmissionMatrix();
1:     Matrix transition = model.getTransitionMatrix();
1:     // check normalization for all probabilities
1:     double isum = 0;
1:     for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
1:       isum += ip.getQuick(i);
1:       double sum = 0;
0:       for (int j = 0; j < model.getNrOfHiddenStates(); ++j)
1:         sum += transition.getQuick(i, j);
1:       if (sum != 1.0) {
0:         for (int j = 0; j < model.getNrOfHiddenStates(); ++j)
1:           transition.setQuick(i, j, transition.getQuick(i, j) / sum);
1:       }
1:       sum = 0;
0:       for (int j = 0; j < model.getNrOfOutputStates(); ++j)
1:         sum += emission.getQuick(i, j);
1:       if (sum != 1.0) {
0:         for (int j = 0; j < model.getNrOfOutputStates(); ++j)
1:           emission.setQuick(i, j, emission.getQuick(i, j) / sum);
1:       }
1:     }
1:     if (isum != 1.0) {
0:       for (int i = 0; i < model.getNrOfHiddenStates(); ++i)
1:         ip.setQuick(i, ip.getQuick(i) / isum);
1:     }
1:   }
1: 
1:   /**
1:    * Method to reduce the size of an HMMmodel by converting the models
1:    * DenseMatrix/DenseVectors to sparse implementations and setting every value
1:    * < threshold to 0
1:    *
1:    * @param model model to truncate
1:    * @param threshold minimum value a model entry must have to be retained.
1:    * @return Truncated model
1:    */
1:   public static HmmModel truncateModel(HmmModel model, double threshold) {
1:     Vector ip = model.getInitialProbabilities();
1:     Matrix em = model.getEmissionMatrix();
1:     Matrix tr = model.getTransitionMatrix();
1:     // allocate the sparse data structures
1:     RandomAccessSparseVector sparseIp = new RandomAccessSparseVector(model
1:         .getNrOfHiddenStates());
0:     SparseMatrix sparseEm = new SparseMatrix(new int[]{
0:         model.getNrOfHiddenStates(), model.getNrOfOutputStates()});
0:     SparseMatrix sparseTr = new SparseMatrix(new int[]{
0:         model.getNrOfHiddenStates(), model.getNrOfHiddenStates()});
1:     // now transfer the values
1:     for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {
1:       double value = ip.getQuick(i);
0:       if (value > threshold)
1:         sparseIp.setQuick(i, value);
1:       for (int j = 0; j < model.getNrOfHiddenStates(); ++j) {
1:         value = tr.getQuick(i, j);
0:         if (value > threshold)
1:           sparseTr.setQuick(i, j, value);
1:       }
1: 
1:       for (int j = 0; j < model.getNrOfOutputStates(); ++j) {
1:         value = em.getQuick(i, j);
0:         if (value > threshold)
1:           sparseEm.setQuick(i, j, value);
1:       }
1:     }
1:     // create a new model
1:     HmmModel sparseModel = new HmmModel(sparseTr, sparseEm, sparseIp);
1:     // normalize the model
0:     HmmUtils.normalizeModel(sparseModel);
1:     // register the names
1:     sparseModel.registerHiddenStateNames(model.getHiddenStateNames());
1:     sparseModel.registerOutputStateNames(model.getOutputStateNames());
1:     // and return
1:     return sparseModel;
1:   }
1: }
============================================================================