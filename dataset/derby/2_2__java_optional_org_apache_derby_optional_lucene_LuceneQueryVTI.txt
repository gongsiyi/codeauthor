1:d847ced: /*
1:0b71ff5: 
1:fbf176c:    Class org.apache.derby.optional.lucene.LuceneQueryVTI
9:d847ced: 
1:d847ced:    Licensed to the Apache Software Foundation (ASF) under one or more
1:d847ced:    contributor license agreements.  See the NOTICE file distributed with
1:d847ced:    this work for additional information regarding copyright ownership.
1:d847ced:    The ASF licenses this file to You under the Apache License, Version 2.0
1:d847ced:    (the "License"); you may not use this file except in compliance with
1:d847ced:    the License.  You may obtain a copy of the License at
1:d847ced: 
1:d847ced:       http://www.apache.org/licenses/LICENSE-2.0
1:d847ced: 
1:d847ced:    Unless required by applicable law or agreed to in writing, software
1:d847ced:    distributed under the License is distributed on an "AS IS" BASIS,
1:d847ced:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d847ced:    See the License for the specific language governing permissions and
1:d847ced:    limitations under the License.
1:d847ced: 
2:d847ced: */
1:d847ced: 
1:fbf176c: package org.apache.derby.optional.lucene;
1:d847ced: 
1:d847ced: import java.io.IOException;
1:2277df2: import java.lang.reflect.InvocationTargetException;
1:9344889: import java.lang.reflect.Method;
1:9344889: import java.security.AccessController;
1:d847ced: import java.security.PrivilegedActionException;
1:9344889: import java.security.PrivilegedExceptionAction;
1:d847ced: import java.sql.Connection;
1:d847ced: import java.sql.Date;
1:d847ced: import java.sql.SQLException;
1:d847ced: import java.sql.Time;
1:d847ced: import java.sql.Timestamp;
1:2277df2: import java.util.Properties;
1:d847ced: 
1:a409436: import org.apache.derby.iapi.services.loader.ClassInspector;
1:5cf7a46: import org.apache.derby.io.StorageFile;
1:d847ced: import org.apache.derby.shared.common.reference.SQLState;
1:a4e6298: import org.apache.derby.optional.api.LuceneIndexDescriptor;
1:fbf176c: import org.apache.derby.optional.api.LuceneUtils;
1:d847ced: import org.apache.derby.vti.StringColumnVTI;
1:d847ced: import org.apache.derby.vti.VTIContext;
1:d847ced: import org.apache.derby.vti.VTITemplate;
1:d847ced: 
1:d847ced: import org.apache.lucene.analysis.Analyzer;
1:d847ced: import org.apache.lucene.document.Document;
1:d847ced: import org.apache.lucene.index.DirectoryReader;
1:d847ced: import org.apache.lucene.index.IndexableField;
1:d847ced: import org.apache.lucene.index.IndexReader;
1:d847ced: import org.apache.lucene.queryparser.classic.ParseException;
1:d847ced: import org.apache.lucene.queryparser.classic.QueryParser;
1:d847ced: import org.apache.lucene.search.IndexSearcher;
1:d847ced: import org.apache.lucene.search.Query;
1:d847ced: import org.apache.lucene.search.ScoreDoc;
1:d847ced: import org.apache.lucene.search.TopDocs;
1:d847ced: import org.apache.lucene.search.TopScoreDocCollector;
1:d847ced: import org.apache.lucene.util.BytesRef;
1:d847ced: import org.apache.lucene.util.Version;
1:d847ced: 
1:6b8ad38: import org.apache.derby.optional.utils.ToolUtilities;
1:6b8ad38: 
1:9344889: /**
1:d847ced:  * A VTI that provides the results of Lucene queries and
1:d847ced:  * associated Lucene assigned document ids. 
1:9344889:  * 
1:d847ced:  * This is intended for use through the provided query function
1:d847ced:  * LuceneSupport.luceneQuery.
2:d847ced:  * 
1:9344889:  */
1:eb79cc0: class LuceneQueryVTI extends StringColumnVTI
4:d847ced: {
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     //  CONSTANTS
1:d847ced:     //
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced: 
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     //  STATE
1:d847ced:     //
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced: 
1:d847ced:     // constructor args
1:d847ced:     private Connection  _connection;
1:d847ced:     private String  _queryText;
1:9cc25e2:     private int         _windowSize;
1:4cedf31:     private Float   _scoreCeiling;
1:d847ced: 
1:d847ced:     private String      _schema;
1:d847ced:     private String      _table;
1:d847ced:     private String      _column;
1:d847ced:     
1:d847ced: 	private ScoreDoc[] _hits;
1:d847ced: 	private IndexReader _indexReader;
1:d847ced: 	private IndexSearcher _searcher;
1:d847ced: 	private int _hitIndex = -1;
1:d847ced: 
1:d847ced:     // ids (1-based positions) of the columns
1:d847ced:     private int _minKeyID;
1:d847ced:     private int _maxKeyID;
1:d847ced:     private int _docIDColumnID;
1:cbdf827:     private int _scoreColumnID;
1:abb2084: 
1:abb2084:     // true if last column read was null
1:abb2084:     private boolean _wasNull;
1:d847ced: 	
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     //  CONSTRUCTOR
1:d847ced:     //
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced: 
2:d847ced: 	/**
1:d847ced: 	 * Return a LuceneQueryVTI based on the given Lucene query text.
1:d847ced: 	 */
1:d847ced: 	LuceneQueryVTI
1:9344889:         (
1:d847ced:          String queryText,
1:9cc25e2:          int    windowSize,
1:4cedf31:          Float scoreCeiling
1:9344889:          )
1:d847ced:         throws SQLException
1:d847ced:     {
1:d847ced:         super( null );
1:4f7c143: 
1:4f7c143:         LuceneSupport.checkNotNull( "QUERY", queryText );
1:0b71ff5:         
1:d847ced:         _connection = LuceneSupport.getDefaultConnection();
1:d847ced:         _queryText = queryText;
1:9cc25e2:         _windowSize = windowSize;
1:cbdf827:         _scoreCeiling = scoreCeiling;
1:d847ced: 	}
1:9344889: 
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     //  StringColumnVTI BEHAVIOR
1:d847ced:     //
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced: 
1:d847ced: 	/**
1:d847ced: 	 * columns:
1:d847ced: 	 * 1 ... $_maxKeyID == key columns
1:d847ced: 	 * $_maxKeyID + 1 == lucene docId
1:cbdf827: 	 * $_maxKeyID + 2 == lucene score
1:d847ced: 	 */
1:d847ced: 	public String getRawColumn( int columnid ) throws SQLException
1:9344889:     {
1:abb2084:         _wasNull = false;
1:abb2084:         
1:d847ced: 		try {
1:d847ced:             ScoreDoc    scoreDoc = getScoreDoc();
1:d847ced:             int     docID = scoreDoc.doc;
1:d847ced:             
1:d847ced: 			if ( isKeyID( columnid ) ) { return _searcher.doc( docID ).get( getColumnName( columnid ) ); }
1:d847ced: 			else { throw invalidColumnPosition( columnid ); }
1:9344889: 		}
1:6b8ad38:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:d847ced: 	}
1:d847ced: 
1:abb2084:     /** Handle boolean columns */
1:abb2084:     public  boolean getBoolean( int columnid ) throws SQLException
1:abb2084:     {
1:abb2084:         String  stringValue = getRawColumn( columnid );
1:abb2084: 
1:abb2084:         if ( stringValue == null )
1:abb2084:         {
1:abb2084:             _wasNull = true;
1:abb2084:             return false;
1:abb2084:         }
1:abb2084:         else
1:abb2084:         {
1:abb2084:             return Boolean.valueOf( stringValue );
1:abb2084:         }
1:abb2084:     }
1:abb2084: 
1:d847ced:     /** Handle float columns */
1:d847ced:     public  float   getFloat( int columnid )    throws SQLException
1:9344889:     {
1:d847ced: 		try {
1:cbdf827:             if ( columnid == _scoreColumnID ) { return getScoreDoc().score; }
1:d847ced: 			else if ( isKeyID( columnid ) )
1:9344889:             {
1:d847ced:                 Number  number = getNumberValue( columnid );
1:d847ced: 
1:d847ced:                 if ( number == null ) { return 0; }
1:d847ced:                 else { return number.floatValue(); }
1:d847ced:             }
1:d847ced: 			else { throw invalidColumnPosition( columnid ); }
1:d847ced: 		}
1:6b8ad38:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** Handle double columns */
1:d847ced:     public  double   getDouble( int columnid )    throws SQLException
1:d847ced:     {
1:d847ced: 		try {
1:d847ced: 			if ( isKeyID( columnid ) )
1:d847ced:             {
1:d847ced:                 Number  number = getNumberValue( columnid );
1:d847ced: 
1:d847ced:                 if ( number == null ) { return 0; }
1:d847ced:                 else { return number.doubleValue(); }
1:d847ced:             }
1:d847ced: 			else { throw invalidColumnPosition( columnid ); }
1:d847ced: 		}
1:6b8ad38:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** Handle bytecolumns */
1:d847ced:     public  byte    getByte( int columnid )  throws SQLException
1:d847ced:     {
1:d847ced:         return (byte) getInt( columnid );
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** Handle short columns */
1:d847ced:     public  short getShort( int columnid )  throws SQLException
1:d847ced:     {
1:d847ced:         return (short) getInt( columnid );
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** Handle long columns */
1:d847ced:     public  long    getLong( int columnid )  throws SQLException
1:d847ced:     {
1:d847ced: 		try {
1:d847ced:             ScoreDoc    scoreDoc = getScoreDoc();
1:d847ced:             int     docID = scoreDoc.doc;
1:d847ced: 			if ( isKeyID( columnid ) )
1:d847ced:             {
1:d847ced:                 Number  number = getNumberValue( columnid );
1:d847ced: 
1:d847ced:                 if ( number == null ) { return 0; }
1:d847ced:                 else { return number.longValue(); }
1:d847ced:             }
1:d847ced: 			else { throw invalidColumnPosition( columnid ); }
1:d847ced: 		}
1:6b8ad38:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:d847ced:     }
1:d847ced:     
1:d847ced:     /** Handle Date columns */
1:d847ced:     public  Date    getDate( int columnid )  throws SQLException
1:d847ced:     {
1:d847ced: 		try {
1:d847ced:             ScoreDoc    scoreDoc = getScoreDoc();
1:d847ced:             int     docID = scoreDoc.doc;
1:d847ced: 			if ( isKeyID( columnid ) )
1:d847ced:             {
1:d847ced:                 Number  number = getNumberValue( columnid );
1:d847ced: 
1:d847ced:                 if ( number == null ) { return null; }
1:d847ced:                 else { return new Date( number.longValue() ); }
1:d847ced:             }
1:d847ced: 			else { throw invalidColumnPosition( columnid ); }
1:d847ced: 		}
1:6b8ad38:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:d847ced:     }
1:d847ced:     
1:d847ced:     /** Handle Time columns */
1:d847ced:     public  Time    getTime( int columnid )  throws SQLException
1:d847ced:     {
1:d847ced: 		try {
1:d847ced:             ScoreDoc    scoreDoc = getScoreDoc();
1:d847ced:             int     docID = scoreDoc.doc;
1:d847ced: 			if ( isKeyID( columnid ) )
1:d847ced:             {
1:d847ced:                 Number  number = getNumberValue( columnid );
1:d847ced: 
1:d847ced:                 if ( number == null ) { return null; }
1:d847ced:                 else { return new Time( number.longValue() ); }
1:d847ced:             }
1:d847ced: 			else { throw invalidColumnPosition( columnid ); }
1:d847ced: 		}
1:6b8ad38:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:d847ced:     }
1:d847ced:     
1:d847ced:     /** Handle Timestamp columns */
1:d847ced:     public  Timestamp    getTimestamp( int columnid )  throws SQLException
1:d847ced:     {
1:d847ced: 		try {
1:d847ced:             ScoreDoc    scoreDoc = getScoreDoc();
1:d847ced:             int     docID = scoreDoc.doc;
1:d847ced: 			if ( isKeyID( columnid ) )
1:d847ced:             {
1:d847ced:                 Number  number = getNumberValue( columnid );
1:d847ced: 
1:d847ced:                 if ( number == null ) { return null; }
1:d847ced:                 else { return new Timestamp( number.longValue() ); }
1:d847ced:             }
1:d847ced: 			else { throw invalidColumnPosition( columnid ); }
1:d847ced: 		}
1:6b8ad38:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:d847ced:     }
1:d847ced:     
1:d847ced:     /** Handle integer columns */
1:d847ced:     public  int getInt( int columnid )  throws SQLException
1:d847ced:     {
1:abb2084:         _wasNull = false;
1:abb2084:         
1:d847ced: 		try {
1:d847ced:             ScoreDoc    scoreDoc = getScoreDoc();
1:d847ced:             int     docID = scoreDoc.doc;
1:d847ced: 			if ( columnid == _docIDColumnID ) { return docID; }
1:d847ced: 			else if ( isKeyID( columnid ) )
1:d847ced:             {
1:d847ced:                 Number  number = getNumberValue( columnid );
1:d847ced: 
1:d847ced:                 if ( number == null ) { return 0; }
1:d847ced:                 else { return number.intValue(); }
1:d847ced:             }
1:d847ced: 			else { throw invalidColumnPosition( columnid ); }
1:d847ced: 		}
1:6b8ad38:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:d847ced:     }
1:d847ced:     private Number getNumberValue( int columnid ) throws IOException
1:d847ced:     {
1:d847ced:         IndexableField  field = _searcher.doc( getScoreDoc().doc ).getField( getColumnName( columnid ) );
1:d847ced: 
1:abb2084:         if ( field == null )
1:abb2084:         {
1:abb2084:             _wasNull = true;
1:abb2084:             return null;
1:abb2084:         }
1:d847ced:         else
1:d847ced:         {
1:abb2084:             _wasNull = false;
1:d847ced:             Number  number = field.numericValue();
1:d847ced: 
1:d847ced:             return number;
1:d847ced:         }
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** Handle byte columns */
1:d847ced:     public  byte[]  getBytes( int columnid ) throws SQLException
1:d847ced:     {
1:d847ced: 		try {
1:d847ced:             ScoreDoc    scoreDoc = getScoreDoc();
1:d847ced:             int     docID = scoreDoc.doc;
1:d847ced:             
1:d847ced: 			if ( isKeyID( columnid ) )
1:d847ced:             {
1:d847ced:                 Document    doc = _searcher.doc( docID );
1:d847ced:                 String          columnName = getColumnName( columnid );
1:d847ced: 
1:d847ced:                 if ( columnName != null )
1:d847ced:                 {
1:d847ced:                     BytesRef        ref = doc.getBinaryValue( columnName );
1:d847ced: 
1:d847ced:                     if ( ref != null )  { return ref.bytes; }
1:d847ced:                 }
1:d847ced: 
1:abb2084:                 _wasNull = true;
1:d847ced:                 return null;
1:d847ced:             }
1:d847ced: 			else { throw invalidColumnPosition( columnid ); }
1:d847ced: 		}
1:6b8ad38:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:d847ced:     }
1:d847ced: 
1:d847ced:     private SQLException    invalidColumnPosition( int columnid )
1:d847ced:     {
1:6b8ad38:         return ToolUtilities.newSQLException
1:9344889:             (
1:d847ced:              SQLState.LANG_INVALID_COLUMN_POSITION,
1:ce40a31:              columnid,
1:ce40a31:              getColumnCount()
1:9344889:              );
1:9344889:     }
1:0b71ff5: 
1:d847ced:     private ScoreDoc    getScoreDoc()   throws IOException
1:d847ced:     {
1:d847ced:         return _hits[ _hitIndex ];
1:d847ced:     }
1:d847ced: 	
1:d847ced: 	public boolean next()
1:d847ced:         throws SQLException
1:d847ced:     {
1:abb2084:         _wasNull = false;
1:d847ced:         if ( _schema == null ) { initScan(); }
1:d847ced:         
1:d847ced: 		_hitIndex++;
1:d847ced: 		if (_hitIndex < _hits.length) {
1:d847ced: 			return true;
1:d847ced: 		}
1:d847ced: 
1:d847ced:         closeReader();
1:d847ced: 		return false;
1:d847ced: 	}
1:abb2084: 	
1:d847ced: 	public void close()
1:d847ced:         throws SQLException
1:d847ced:     {
1:d847ced: 		_hits = null;
1:d847ced: 		_hitIndex = 0;
1:d847ced: 
1:d847ced:         closeReader();
1:d847ced: 	}
1:d847ced: 
1:abb2084:     public  boolean wasNull() throws SQLException
1:abb2084:     {
1:abb2084:         return _wasNull;
1:abb2084:     }
1:abb2084:     
1:d847ced: 	/**
1:d847ced: 	 * Be sure to close the Lucene IndexReader
1:d847ced: 	 */
1:5b79ae0: 	protected void finalize()
1:d847ced:     {
1:d847ced: 		try {
1:d847ced: 			if ( _indexReader != null ) { _indexReader.close(); }
1:d847ced: 		} catch (IOException e) {
1:d847ced: 			e.printStackTrace();
1:d847ced: 		}
1:d847ced: 	}
1:d847ced: 
1:d847ced: 	private void closeReader()
1:d847ced:         throws SQLException
1:d847ced:     {
1:d847ced: 		if ( _indexReader == null ) { return; }
1:d847ced:         
1:d847ced: 		try {
1:d847ced: 			_indexReader.close();
1:d847ced: 		}
1:6b8ad38:         catch (IOException e) { throw ToolUtilities.wrap( e ); }
1:d847ced:         finally
1:d847ced:         {
1:d847ced:             _indexReader = null;
1:d847ced:         }
1:d847ced: 	}
1:d847ced: 	
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     //  MINIONS
1:d847ced:     //
1:d847ced:     /////////////////////////////////////////////////////////////////////
1:d847ced: 
1:d847ced:     /** Initialize the metadata and scan */
1:d847ced:     private void    initScan()  throws SQLException
1:d847ced:     {
1:d847ced:         try {
1:d847ced:             // read the execution context for this AwareVTI
1:d847ced:             VTIContext  context = getContext();
1:d847ced:             _schema = context.vtiSchema();
1:d847ced:             String[]    nameParts = LuceneSupport.decodeFunctionName( context.vtiTable() );
1:d847ced:             _table = nameParts[ LuceneSupport.TABLE_PART ];
1:d847ced:             _column = nameParts[ LuceneSupport.COLUMN_PART ];
1:d847ced: 
1:d847ced:             // divine the column names
1:d847ced:             VTITemplate.ColumnDescriptor[]  returnColumns = getReturnTableSignature( _connection );
1:d847ced:             String[]    columnNames = new String[ returnColumns.length ];
1:d847ced:             for ( int i = 0; i < returnColumns.length; i++ ) { columnNames[ i ] = returnColumns[ i ].columnName; }
1:d847ced:             setColumnNames( columnNames );
1:d847ced: 
1:cbdf827:             _scoreColumnID = getColumnCount();
1:cbdf827:             _docIDColumnID = _scoreColumnID - 1;
1:d847ced:             _maxKeyID = _docIDColumnID - 1;
1:d847ced:             _minKeyID = 1;
1:d847ced:             
1:d847ced:             // make sure the user has SELECT privilege on all relevant columns of the underlying table
1:d847ced:             vetPrivileges();
1:3240e21: 
1:3240e21:             String      delimitedColumnName = LuceneSupport.delimitID( _column );
1:3240e21:             DerbyLuceneDir  derbyLuceneDir = LuceneSupport.getDerbyLuceneDir( _connection, _schema, _table, delimitedColumnName );
1:5cf7a46:             StorageFile propertiesFile = LuceneSupport.getIndexPropertiesFile( derbyLuceneDir );
1:9344889:             Properties  indexProperties = readIndexProperties( propertiesFile );
1:a4e6298:             String          indexDescriptorMaker = indexProperties.getProperty( LuceneSupport.INDEX_DESCRIPTOR_MAKER );
1:a4e6298:             LuceneIndexDescriptor   indexDescriptor = getIndexDescriptor( indexDescriptorMaker );
1:a4e6298:             Analyzer    analyzer = indexDescriptor.getAnalyzer( );
1:a4e6298:             QueryParser qp = indexDescriptor.getQueryParser();
1:2277df2: 
1:7d889ca:             vetLuceneVersion( indexProperties.getProperty( LuceneSupport.LUCENE_VERSION ) );
1:7d889ca: 
1:5cf7a46:             _indexReader = getIndexReader( derbyLuceneDir );
1:5cf7a46:             _searcher = new IndexSearcher( _indexReader );
1:d847ced: 
1:d847ced:             Query luceneQuery = qp.parse( _queryText );
1:9cc25e2:             TopScoreDocCollector tsdc = TopScoreDocCollector.create( _windowSize, true);
1:4cedf31:             if ( _scoreCeiling != null ) {
1:9cc25e2:                 tsdc = TopScoreDocCollector.create( _windowSize, new ScoreDoc( 0, _scoreCeiling ), true );
1:d847ced:             }
1:5cf7a46: 
1:5cf7a46:             searchAndScore( luceneQuery, tsdc );
1:d847ced:         }
1:6b8ad38:         catch (IOException ioe) { throw ToolUtilities.wrap( ioe ); }
1:6b8ad38:         catch (ParseException pe) { throw ToolUtilities.wrap( pe ); }
1:6b8ad38:         catch (PrivilegedActionException pae) { throw ToolUtilities.wrap( pae ); }
1:d847ced:     }
1:d847ced: 
1:d847ced:     /**
1:d847ced:      * <p>
1:7d889ca:      * Make sure that the index wasn't created with a Lucene version from
1:7d889ca:      * the future.
1:7d889ca:      * </p>
1:7d889ca:      */
1:7d889ca:     private void    vetLuceneVersion( String indexVersionString )
1:7d889ca:         throws SQLException
1:7d889ca:     {
1:7d889ca:         Version     currentVersion = LuceneUtils.currentVersion();
1:7d889ca:         Version     indexVersion = null;
1:7d889ca: 
1:7d889ca:         try {
1:c316147:             indexVersion = Version.parseLeniently(indexVersionString);
1:7d889ca:         }
1:7d889ca:         catch (Exception e) {}
1:7d889ca: 
1:7d889ca:         if ( (indexVersion == null) || !currentVersion.onOrAfter( indexVersion ) )
1:7d889ca:         {
1:6b8ad38:             throw ToolUtilities.newSQLException
1:7d889ca:                 ( SQLState.LUCENE_BAD_VERSION, currentVersion.toString(), indexVersionString );
1:7d889ca:         }
1:7d889ca:     }
1:7d889ca: 
1:7d889ca:     /**
1:7d889ca:      * <p>
1:d847ced:      * Make sure that the user has SELECT privilege on the text column and on all
1:d847ced:      * the key columns of the underlying table.
1:7d889ca:      * </p>
1:d847ced:      */
1:d847ced:     private void    vetPrivileges() throws SQLException
1:d847ced:     {
1:d847ced:         StringBuilder   buffer = new StringBuilder();
1:d847ced:         int _maxKeyID = getColumnCount() - 2;
1:d847ced: 
1:d847ced:         buffer.append( "select " );
1:d847ced:         for ( int i = 0; i < _maxKeyID; i++ )
1:d847ced:         {
1:d847ced:             if ( i > 0 ) { buffer.append( ", " ); }
1:3240e21:             buffer.append( LuceneSupport.delimitID( getColumnName( i + 1 ) ) );
1:d847ced:         }
1:3240e21:         buffer.append( ", " + LuceneSupport.delimitID( _column ) );
1:d847ced:         buffer.append( " from " + LuceneSupport.makeTableName( _schema, _table ) );
1:d847ced:         buffer.append( " where 1=2" );
1:d847ced: 
1:d847ced:         _connection.prepareStatement( buffer.toString() ).executeQuery().close();
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** Return true if the 1-based column ID is the ID of a key column */
1:d847ced:     private boolean isKeyID( int columnid )
1:d847ced:     {
1:d847ced:         return ( (columnid > 0) && (columnid <= _maxKeyID) );
1:9344889:     }
1:9344889:     
1:9344889: 	/**
1:9344889: 	 * Returns a Lucene IndexReader, which reads from the indicated Lucene index.
1:9344889: 	 * 
1:9344889: 	 * @param indexHome The directory holding the Lucene index.
1:9344889: 	 */
1:5cf7a46: 	private static IndexReader getIndexReader( final DerbyLuceneDir dir )
1:5cf7a46:         throws IOException, PrivilegedActionException
1:9344889:     {
1:7234498:         try {
2:9344889:             return AccessController.doPrivileged
1:9344889:             (
1:9344889:              new PrivilegedExceptionAction<IndexReader>()
1:9344889:              {
1:7234498:                  public IndexReader run() throws IOException
1:9344889:                  {
1:5cf7a46:                      return DirectoryReader.open( dir );
1:9344889:                  }
1:9344889:              }
1:9344889:              );
1:7234498:         } catch (PrivilegedActionException pae) {
1:7234498:             throw (IOException) pae.getCause();
1:9344889:         }
1:d847ced: 	}
1:9344889: 	
1:5cf7a46:     /** Read the index properties file */
1:5cf7a46:     private static  Properties readIndexProperties( final StorageFile file )
1:7234498:         throws IOException
1:9344889:     {
1:7234498:         try {
1:9344889:             return AccessController.doPrivileged
1:9344889:             (
1:9344889:              new PrivilegedExceptionAction<Properties>()
1:9344889:              {
1:9344889:                 public Properties run() throws IOException
1:9344889:                 {
1:9344889:                     return LuceneSupport.readIndexPropertiesNoPrivs( file );
1:9344889:                 }
1:9344889:              }
1:9344889:              );
1:7234498:         } catch (PrivilegedActionException pae) {
1:7234498:             throw (IOException) pae.getCause();
1:9344889:         }
1:d847ced:     }
1:9344889: 
1:9344889: 	/**
1:a4e6298: 	 * Invoke a static method (possibly supplied by the user) to instantiate an index descriptor.
1:9344889:      * The method has no arguments.
1:9344889: 	 */
1:a4e6298: 	private static LuceneIndexDescriptor getIndexDescriptor( final String indexDescriptorMaker )
1:a409436:         throws PrivilegedActionException, SQLException
1:9344889:     {
1:9344889:         return AccessController.doPrivileged
1:9344889:             (
1:a4e6298:              new PrivilegedExceptionAction<LuceneIndexDescriptor>()
1:9344889:              {
1:a4e6298:                  public LuceneIndexDescriptor run()
1:a409436:                      throws ClassNotFoundException, IllegalAccessException,
1:a409436:                      InvocationTargetException, NoSuchMethodException,
1:a409436:                      SQLException
1:9344889:                  {
1:a4e6298:                      return LuceneSupport.getIndexDescriptorNoPrivs( indexDescriptorMaker );
1:9344889:                  }
1:9344889:              }
1:9344889:              );
1:9344889: 	}
1:9344889: 	
1:9344889:     /** Read the index properties file */
1:5cf7a46:     private void    searchAndScore( final Query luceneQuery, final TopScoreDocCollector tsdc )
1:7234498:         throws IOException
1:5cf7a46:     {
1:7234498:         try {
1:5cf7a46:             AccessController.doPrivileged
1:5cf7a46:             (
1:5cf7a46:              new PrivilegedExceptionAction<Object>()
1:5cf7a46:              {
1:5cf7a46:                 public Object run() throws IOException
1:5cf7a46:                 {
1:5cf7a46:                     _searcher.search( luceneQuery, tsdc );
1:5cf7a46:                     TopDocs topdocs = tsdc.topDocs();
1:5cf7a46:                     _hits = topdocs.scoreDocs;
1:5cf7a46: 
1:5cf7a46:                     return null;
1:5cf7a46:                 }
1:5cf7a46:              }
1:5cf7a46:              );
1:7234498:         } catch (PrivilegedActionException pae) {
1:7234498:             throw (IOException) pae.getCause();
1:5cf7a46:         }
1:d847ced:     }
1:5cf7a46: 
1:d847ced: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:              columnid,
1:              getColumnCount()
commit:6b8ad38
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.optional.utils.ToolUtilities;
1: 
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e)   { throw ToolUtilities.wrap( e ); }
1:         return ToolUtilities.newSQLException
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException e) { throw ToolUtilities.wrap( e ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (IOException ioe) { throw ToolUtilities.wrap( ioe ); }
1:         catch (ParseException pe) { throw ToolUtilities.wrap( pe ); }
1:         catch (PrivilegedActionException pae) { throw ToolUtilities.wrap( pae ); }
/////////////////////////////////////////////////////////////////////////
1:             throw ToolUtilities.newSQLException
commit:3240e21
/////////////////////////////////////////////////////////////////////////
1: 
1:             String      delimitedColumnName = LuceneSupport.delimitID( _column );
1:             DerbyLuceneDir  derbyLuceneDir = LuceneSupport.getDerbyLuceneDir( _connection, _schema, _table, delimitedColumnName );
/////////////////////////////////////////////////////////////////////////
1:             buffer.append( LuceneSupport.delimitID( getColumnName( i + 1 ) ) );
1:         buffer.append( ", " + LuceneSupport.delimitID( _column ) );
commit:a4e6298
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.optional.api.LuceneIndexDescriptor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             String          indexDescriptorMaker = indexProperties.getProperty( LuceneSupport.INDEX_DESCRIPTOR_MAKER );
1:             LuceneIndexDescriptor   indexDescriptor = getIndexDescriptor( indexDescriptorMaker );
1:             Analyzer    analyzer = indexDescriptor.getAnalyzer( );
1:             QueryParser qp = indexDescriptor.getQueryParser();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * Invoke a static method (possibly supplied by the user) to instantiate an index descriptor.
1: 	private static LuceneIndexDescriptor getIndexDescriptor( final String indexDescriptorMaker )
1:              new PrivilegedExceptionAction<LuceneIndexDescriptor>()
1:                  public LuceneIndexDescriptor run()
1:                      return LuceneSupport.getIndexDescriptorNoPrivs( indexDescriptorMaker );
commit:eb79cc0
/////////////////////////////////////////////////////////////////////////
1: class LuceneQueryVTI extends StringColumnVTI
commit:4f7c143
/////////////////////////////////////////////////////////////////////////
1: 
1:         LuceneSupport.checkNotNull( "QUERY", queryText );
commit:abb2084
/////////////////////////////////////////////////////////////////////////
1: 
1:     // true if last column read was null
1:     private boolean _wasNull;
/////////////////////////////////////////////////////////////////////////
1:         _wasNull = false;
1:         
/////////////////////////////////////////////////////////////////////////
1:     /** Handle boolean columns */
1:     public  boolean getBoolean( int columnid ) throws SQLException
1:     {
1:         String  stringValue = getRawColumn( columnid );
1: 
1:         if ( stringValue == null )
1:         {
1:             _wasNull = true;
1:             return false;
1:         }
1:         else
1:         {
1:             return Boolean.valueOf( stringValue );
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         _wasNull = false;
1:         
/////////////////////////////////////////////////////////////////////////
1:         if ( field == null )
1:         {
1:             _wasNull = true;
1:             return null;
1:         }
1:             _wasNull = false;
/////////////////////////////////////////////////////////////////////////
1:                 _wasNull = true;
/////////////////////////////////////////////////////////////////////////
1:         _wasNull = false;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public  boolean wasNull() throws SQLException
1:     {
1:         return _wasNull;
1:     }
1:     
commit:a409436
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.loader.ClassInspector;
/////////////////////////////////////////////////////////////////////////
1:         throws PrivilegedActionException, SQLException
1:                      throws ClassNotFoundException, IllegalAccessException,
1:                      InvocationTargetException, NoSuchMethodException,
1:                      SQLException
0:                      String className = queryParserMaker.substring( 0, lastDotIdx );
0:                      ClassInspector  ci = LuceneSupport.getClassFactory().getClassInspector();
0:                      Class<? extends Object>  klass = ci.getClass( className );
/////////////////////////////////////////////////////////////////////////
0:         throws PrivilegedActionException, SQLException
0:                      throws ClassNotFoundException, IllegalAccessException,
0:                      InvocationTargetException, NoSuchMethodException,
0:                      SQLException
commit:4cedf31
/////////////////////////////////////////////////////////////////////////
1:     private Float   _scoreCeiling;
/////////////////////////////////////////////////////////////////////////
1:          Float scoreCeiling
/////////////////////////////////////////////////////////////////////////
1:             if ( _scoreCeiling != null ) {
commit:5cf7a46
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.io.StorageFile;
/////////////////////////////////////////////////////////////////////////
0:             DerbyLuceneDir  derbyLuceneDir = LuceneSupport.getDerbyLuceneDir( _connection, _schema, _table, _column );
1:             StorageFile propertiesFile = LuceneSupport.getIndexPropertiesFile( derbyLuceneDir );
1:             _indexReader = getIndexReader( derbyLuceneDir );
1:             _searcher = new IndexSearcher( _indexReader );
/////////////////////////////////////////////////////////////////////////
1: 
1:             searchAndScore( luceneQuery, tsdc );
/////////////////////////////////////////////////////////////////////////
1: 	private static IndexReader getIndexReader( final DerbyLuceneDir dir )
/////////////////////////////////////////////////////////////////////////
1:                      return DirectoryReader.open( dir );
1:     private static  Properties readIndexProperties( final StorageFile file )
/////////////////////////////////////////////////////////////////////////
1:     /** Read the index properties file */
1:     private void    searchAndScore( final Query luceneQuery, final TopScoreDocCollector tsdc )
1:         throws IOException, PrivilegedActionException
1:     {
1:         AccessController.doPrivileged
1:             (
1:              new PrivilegedExceptionAction<Object>()
1:              {
1:                 public Object run() throws IOException
1:                 {
1:                     _searcher.search( luceneQuery, tsdc );
1:                     TopDocs topdocs = tsdc.topDocs();
1:                     _hits = topdocs.scoreDocs;
1: 
1:                     return null;
1:                 }
1:              }
1:              );
1:     }
1: 
commit:9344889
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Method;
1: import java.security.AccessController;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1:             Properties  indexProperties = readIndexProperties( propertiesFile );
0:             Analyzer    analyzer = getAnalyzer( analyzerMaker );
0:             _indexReader = getIndexReader( new File( indexhome.toString() ) );
0:             QueryParser qp = getQueryParser
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Invoke a static method (possibly supplied by the user) to instantiate a QueryParser.
1:      *
0:      * @param queryParserMaker  Full name of public, static method whicn instantiates a QueryParser given the following arguments.
0:      * @param version   Lucene version.
0:      * @param fieldName Name of field holding the indexed text.
0:      * @param analyzer  Analyzer used to index the text.
1: 	 */
0: 	private static QueryParser getQueryParser
1:         (
0:          final String queryParserMaker,
0:          final Version version,
0:          final String fieldName,
0:          final Analyzer analyzer
1:          )
0:         throws ClassNotFoundException, IllegalAccessException, InvocationTargetException,
0:                NoSuchMethodException, PrivilegedActionException
1:     {
1:         return AccessController.doPrivileged
1:             (
0:              new PrivilegedExceptionAction<QueryParser>()
1:              {
0:                  public QueryParser run()
0:                      throws ClassNotFoundException, IllegalAccessException, InvocationTargetException, NoSuchMethodException
1:                  {
0:                      int    lastDotIdx = queryParserMaker.lastIndexOf( "." );
0:                      Class<? extends Object>  klass = Class.forName( queryParserMaker.substring( 0, lastDotIdx ) );
0:                      String methodName = queryParserMaker.substring( lastDotIdx + 1, queryParserMaker.length() );
0:                      Method method = klass.getDeclaredMethod( methodName, Version.class, String.class, Analyzer.class );
1:                      
0:                      return (QueryParser) method.invoke( null, version, fieldName, analyzer );
1:                  }
1:              }
1:              );
1: 	}
1: 	
1: 	/**
1: 	 * Returns a Lucene IndexReader, which reads from the indicated Lucene index.
1: 	 * 
1: 	 * @param indexHome The directory holding the Lucene index.
1: 	 */
0: 	private static IndexReader getIndexReader( final File indexHome )
0:         throws IOException, PrivilegedActionException
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedExceptionAction<IndexReader>()
1:              {
0:                  public IndexReader run() throws SQLException, IOException
1:                  {
0:                      return DirectoryReader.open( FSDirectory.open( indexHome ) );
1:                  }
1:              }
1:              );
1: 	}
1: 	
1:     /** Read the index properties file */
0:     private static  Properties readIndexProperties( final File file )
0:         throws IOException, PrivilegedActionException
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedExceptionAction<Properties>()
1:              {
1:                 public Properties run() throws IOException
1:                 {
1:                     return LuceneSupport.readIndexPropertiesNoPrivs( file );
1:                 }
1:              }
1:              );
1:     }
1: 
1: 	/**
0: 	 * Invoke a static method (possibly supplied by the user) to instantiate an Analyzer.
1:      * The method has no arguments.
1: 	 */
0: 	private static Analyzer getAnalyzer( final String analyzerMaker )
0:         throws ClassNotFoundException, IllegalAccessException, InvocationTargetException,
0:                NoSuchMethodException, PrivilegedActionException
1:     {
1:         return AccessController.doPrivileged
1:             (
0:              new PrivilegedExceptionAction<Analyzer>()
1:              {
0:                  public Analyzer run()
0:                      throws ClassNotFoundException, IllegalAccessException, InvocationTargetException, NoSuchMethodException
1:                  {
0:                      return LuceneSupport.getAnalyzerNoPrivs( analyzerMaker );
1:                  }
1:              }
1:              );
1: 	}
1: 	
commit:7d889ca
/////////////////////////////////////////////////////////////////////////
1:             vetLuceneVersion( indexProperties.getProperty( LuceneSupport.LUCENE_VERSION ) );
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Make sure that the index wasn't created with a Lucene version from
1:      * the future.
1:      * </p>
1:      */
1:     private void    vetLuceneVersion( String indexVersionString )
1:         throws SQLException
1:     {
1:         Version     currentVersion = LuceneUtils.currentVersion();
1:         Version     indexVersion = null;
1: 
1:         try {
0:             indexVersion = Version.valueOf( indexVersionString );
1:         }
1:         catch (Exception e) {}
1: 
1:         if ( (indexVersion == null) || !currentVersion.onOrAfter( indexVersion ) )
1:         {
0:             throw LuceneSupport.newSQLException
1:                 ( SQLState.LUCENE_BAD_VERSION, currentVersion.toString(), indexVersionString );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * </p>
commit:0b71ff5
/////////////////////////////////////////////////////////////////////////
0:     private String  _queryParserMaker;
/////////////////////////////////////////////////////////////////////////
0:          String queryParserMaker,
/////////////////////////////////////////////////////////////////////////
0:         _queryParserMaker = queryParserMaker;
/////////////////////////////////////////////////////////////////////////
1: 
0:             QueryParser qp = LuceneSupport.getQueryParser
0:                 (
0:                  _queryParserMaker == null ?
0:                  LuceneUtils.class.getName() + ".defaultQueryParser" : _queryParserMaker,
1:                  
0:                  LuceneUtils.currentVersion(),
0:                  TEXT_FIELD_NAME,
0:                  analyzer
0:                  );
1: 				
commit:9cc25e2
/////////////////////////////////////////////////////////////////////////
1:     private int         _windowSize;
/////////////////////////////////////////////////////////////////////////
1:          int    windowSize,
/////////////////////////////////////////////////////////////////////////
1:         _windowSize = windowSize;
/////////////////////////////////////////////////////////////////////////
1:             TopScoreDocCollector tsdc = TopScoreDocCollector.create( _windowSize, true);
1:                 tsdc = TopScoreDocCollector.create( _windowSize, new ScoreDoc( 0, _scoreCeiling ), true );
commit:cbdf827
/////////////////////////////////////////////////////////////////////////
0:     private float   _scoreCeiling;
/////////////////////////////////////////////////////////////////////////
1:     private int _scoreColumnID;
/////////////////////////////////////////////////////////////////////////
0:          float scoreCeiling
/////////////////////////////////////////////////////////////////////////
1:         _scoreCeiling = scoreCeiling;
/////////////////////////////////////////////////////////////////////////
1: 	 * $_maxKeyID + 2 == lucene score
/////////////////////////////////////////////////////////////////////////
1:             if ( columnid == _scoreColumnID ) { return getScoreDoc().score; }
/////////////////////////////////////////////////////////////////////////
1:             _scoreColumnID = getColumnCount();
1:             _docIDColumnID = _scoreColumnID - 1;
/////////////////////////////////////////////////////////////////////////
0:             if ( _scoreCeiling != 0 ) {
0:                 tsdc = TopScoreDocCollector.create(1000, new ScoreDoc(0, _scoreCeiling ), true);
commit:fbf176c
/////////////////////////////////////////////////////////////////////////
1:    Class org.apache.derby.optional.lucene.LuceneQueryVTI
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.optional.lucene;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.optional.api.LuceneUtils;
commit:2277df2
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
0: import org.apache.derby.optional.LuceneUtils;
/////////////////////////////////////////////////////////////////////////
0:             String          indexhome = LuceneSupport.getIndexLocation( _connection, _schema, _table, _column);
0:             File            propertiesFile = LuceneSupport.getIndexPropertiesFile( _connection, _schema, _table, _column );
0:             Properties  indexProperties = LuceneSupport.readIndexProperties( propertiesFile );
0:             String          analyzerMaker = indexProperties.getProperty( LuceneSupport.ANALYZER_MAKER );
0:             Analyzer    analyzer = LuceneSupport.getAnalyzer( analyzerMaker );
1: 
0:             QueryParser qp = new QueryParser( LuceneUtils.currentVersion(), TEXT_FIELD_NAME, analyzer );
/////////////////////////////////////////////////////////////////////////
0:         catch (ClassNotFoundException cnfe) { throw LuceneSupport.wrap( cnfe ); }
0:         catch (IllegalAccessException iae) { throw LuceneSupport.wrap( iae ); }
0:         catch (InvocationTargetException ite) { throw LuceneSupport.wrap( ite ); }
0:         catch (NoSuchMethodException nsme) { throw LuceneSupport.wrap( nsme ); }
commit:5b79ae0
/////////////////////////////////////////////////////////////////////////
1: 	protected void finalize()
commit:d847ced
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Class org.apache.derby.impl.optional.lucene.LuceneQueryVTI
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
0: package org.apache.derby.impl.optional.lucene;
1: 
0: import java.io.File;
1: import java.io.IOException;
1: import java.security.PrivilegedActionException;
1: import java.sql.Connection;
1: import java.sql.Date;
0: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: 
1: import org.apache.derby.shared.common.reference.SQLState;
0: import org.apache.derby.vti.RestrictedVTI;
0: import org.apache.derby.vti.Restriction;
0: import org.apache.derby.vti.Restriction.ColumnQualifier;
1: import org.apache.derby.vti.StringColumnVTI;
1: import org.apache.derby.vti.VTIContext;
1: import org.apache.derby.vti.VTITemplate;
1: 
1: import org.apache.lucene.analysis.Analyzer;
0: import org.apache.lucene.analysis.standard.StandardAnalyzer;
1: import org.apache.lucene.document.Document;
1: import org.apache.lucene.index.DirectoryReader;
1: import org.apache.lucene.index.IndexableField;
1: import org.apache.lucene.index.IndexReader;
1: import org.apache.lucene.queryparser.classic.ParseException;
1: import org.apache.lucene.queryparser.classic.QueryParser;
1: import org.apache.lucene.search.IndexSearcher;
1: import org.apache.lucene.search.Query;
1: import org.apache.lucene.search.ScoreDoc;
1: import org.apache.lucene.search.TopDocs;
1: import org.apache.lucene.search.TopScoreDocCollector;
0: import org.apache.lucene.store.FSDirectory;
1: import org.apache.lucene.util.BytesRef;
1: import org.apache.lucene.util.Version;
1: 
1: /**
1:  * A VTI that provides the results of Lucene queries and
1:  * associated Lucene assigned document ids. 
1:  * 
1:  * This is intended for use through the provided query function
1:  * LuceneSupport.luceneQuery.
1:  * 
1:  */
0: public class LuceneQueryVTI extends StringColumnVTI
1: {
1:     /////////////////////////////////////////////////////////////////////
1:     //
1:     //  CONSTANTS
1:     //
1:     /////////////////////////////////////////////////////////////////////
1: 
0:     public  static  final   String  TEXT_FIELD_NAME = "luceneTextField";
1: 
1:     /////////////////////////////////////////////////////////////////////
1:     //
1:     //  STATE
1:     //
1:     /////////////////////////////////////////////////////////////////////
1: 
1:     // constructor args
1:     private Connection  _connection;
1:     private String  _queryText;
0:     private double  _rankCutoff;
1: 
1:     private String      _schema;
1:     private String      _table;
1:     private String      _column;
1:     
1: 	private ScoreDoc[] _hits;
1: 	private IndexReader _indexReader;
1: 	private IndexSearcher _searcher;
1: 	private int _hitIndex = -1;
1: 
1:     // ids (1-based positions) of the columns
1:     private int _minKeyID;
1:     private int _maxKeyID;
1:     private int _docIDColumnID;
0:     private int _rankColumnID;
1: 	
1:     /////////////////////////////////////////////////////////////////////
1:     //
1:     //  CONSTRUCTOR
1:     //
1:     /////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Return a LuceneQueryVTI based on the given Lucene query text.
1: 	 */
1: 	LuceneQueryVTI
0:         (
1:          String queryText,
0:          double rankCutoff
0:          )
1:         throws SQLException
1:     {
1:         super( null );
1:         
1:         _connection = LuceneSupport.getDefaultConnection();
1:         _queryText = queryText;
0:         _rankCutoff = rankCutoff;
1: 	}
1: 
1:     /////////////////////////////////////////////////////////////////////
1:     //
1:     //  StringColumnVTI BEHAVIOR
1:     //
1:     /////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * columns:
1: 	 * 1 ... $_maxKeyID == key columns
1: 	 * $_maxKeyID + 1 == lucene docId
0: 	 * $_maxKeyID + 2 == lucene rank
1: 	 */
1: 	public String getRawColumn( int columnid ) throws SQLException
1:     {
1: 		try {
1:             ScoreDoc    scoreDoc = getScoreDoc();
1:             int     docID = scoreDoc.doc;
1:             
1: 			if ( isKeyID( columnid ) ) { return _searcher.doc( docID ).get( getColumnName( columnid ) ); }
1: 			else { throw invalidColumnPosition( columnid ); }
1: 		}
0:         catch (IOException e)   { throw LuceneSupport.wrap( e ); }
1: 	}
1: 
1:     /** Handle float columns */
1:     public  float   getFloat( int columnid )    throws SQLException
1:     {
1: 		try {
0:             if ( columnid == _rankColumnID ) { return getScoreDoc().score; }
1: 			else if ( isKeyID( columnid ) )
1:             {
1:                 Number  number = getNumberValue( columnid );
1: 
1:                 if ( number == null ) { return 0; }
1:                 else { return number.floatValue(); }
1:             }
1: 			else { throw invalidColumnPosition( columnid ); }
1: 		}
0:         catch (IOException e)   { throw LuceneSupport.wrap( e ); }
1:     }
1: 
1:     /** Handle double columns */
1:     public  double   getDouble( int columnid )    throws SQLException
1:     {
1: 		try {
1: 			if ( isKeyID( columnid ) )
1:             {
1:                 Number  number = getNumberValue( columnid );
1: 
1:                 if ( number == null ) { return 0; }
1:                 else { return number.doubleValue(); }
1:             }
1: 			else { throw invalidColumnPosition( columnid ); }
1: 		}
0:         catch (IOException e)   { throw LuceneSupport.wrap( e ); }
1:     }
1: 
1:     /** Handle bytecolumns */
1:     public  byte    getByte( int columnid )  throws SQLException
1:     {
1:         return (byte) getInt( columnid );
1:     }
1: 
1:     /** Handle short columns */
1:     public  short getShort( int columnid )  throws SQLException
1:     {
1:         return (short) getInt( columnid );
1:     }
1: 
1:     /** Handle long columns */
1:     public  long    getLong( int columnid )  throws SQLException
1:     {
1: 		try {
1:             ScoreDoc    scoreDoc = getScoreDoc();
1:             int     docID = scoreDoc.doc;
1: 			if ( isKeyID( columnid ) )
1:             {
1:                 Number  number = getNumberValue( columnid );
1: 
1:                 if ( number == null ) { return 0; }
1:                 else { return number.longValue(); }
1:             }
1: 			else { throw invalidColumnPosition( columnid ); }
1: 		}
0:         catch (IOException e)   { throw LuceneSupport.wrap( e ); }
1:     }
1:     
1:     /** Handle Date columns */
1:     public  Date    getDate( int columnid )  throws SQLException
1:     {
1: 		try {
1:             ScoreDoc    scoreDoc = getScoreDoc();
1:             int     docID = scoreDoc.doc;
1: 			if ( isKeyID( columnid ) )
1:             {
1:                 Number  number = getNumberValue( columnid );
1: 
1:                 if ( number == null ) { return null; }
1:                 else { return new Date( number.longValue() ); }
1:             }
1: 			else { throw invalidColumnPosition( columnid ); }
1: 		}
0:         catch (IOException e)   { throw LuceneSupport.wrap( e ); }
1:     }
1:     
1:     /** Handle Time columns */
1:     public  Time    getTime( int columnid )  throws SQLException
1:     {
1: 		try {
1:             ScoreDoc    scoreDoc = getScoreDoc();
1:             int     docID = scoreDoc.doc;
1: 			if ( isKeyID( columnid ) )
1:             {
1:                 Number  number = getNumberValue( columnid );
1: 
1:                 if ( number == null ) { return null; }
1:                 else { return new Time( number.longValue() ); }
1:             }
1: 			else { throw invalidColumnPosition( columnid ); }
1: 		}
0:         catch (IOException e)   { throw LuceneSupport.wrap( e ); }
1:     }
1:     
1:     /** Handle Timestamp columns */
1:     public  Timestamp    getTimestamp( int columnid )  throws SQLException
1:     {
1: 		try {
1:             ScoreDoc    scoreDoc = getScoreDoc();
1:             int     docID = scoreDoc.doc;
1: 			if ( isKeyID( columnid ) )
1:             {
1:                 Number  number = getNumberValue( columnid );
1: 
1:                 if ( number == null ) { return null; }
1:                 else { return new Timestamp( number.longValue() ); }
1:             }
1: 			else { throw invalidColumnPosition( columnid ); }
1: 		}
0:         catch (IOException e)   { throw LuceneSupport.wrap( e ); }
1:     }
1:     
1:     /** Handle integer columns */
1:     public  int getInt( int columnid )  throws SQLException
1:     {
1: 		try {
1:             ScoreDoc    scoreDoc = getScoreDoc();
1:             int     docID = scoreDoc.doc;
1: 			if ( columnid == _docIDColumnID ) { return docID; }
1: 			else if ( isKeyID( columnid ) )
1:             {
1:                 Number  number = getNumberValue( columnid );
1: 
1:                 if ( number == null ) { return 0; }
1:                 else { return number.intValue(); }
1:             }
1: 			else { throw invalidColumnPosition( columnid ); }
1: 		}
0:         catch (IOException e)   { throw LuceneSupport.wrap( e ); }
1:     }
1:     private Number getNumberValue( int columnid ) throws IOException
1:     {
1:         IndexableField  field = _searcher.doc( getScoreDoc().doc ).getField( getColumnName( columnid ) );
1: 
0:         if ( field == null ) { return null; }
1:         else
1:         {
1:             Number  number = field.numericValue();
1: 
1:             return number;
1:         }
1:     }
1: 
1:     /** Handle byte columns */
1:     public  byte[]  getBytes( int columnid ) throws SQLException
1:     {
1: 		try {
1:             ScoreDoc    scoreDoc = getScoreDoc();
1:             int     docID = scoreDoc.doc;
1:             
1: 			if ( isKeyID( columnid ) )
1:             {
1:                 Document    doc = _searcher.doc( docID );
1:                 String          columnName = getColumnName( columnid );
1: 
1:                 if ( columnName != null )
1:                 {
1:                     BytesRef        ref = doc.getBinaryValue( columnName );
1: 
1:                     if ( ref != null )  { return ref.bytes; }
1:                 }
1: 
1:                 return null;
1:             }
1: 			else { throw invalidColumnPosition( columnid ); }
1: 		}
0:         catch (IOException e)   { throw LuceneSupport.wrap( e ); }
1:     }
1: 
1:     private SQLException    invalidColumnPosition( int columnid )
1:     {
0:         return LuceneSupport.newSQLException
0:             (
1:              SQLState.LANG_INVALID_COLUMN_POSITION,
0:              new Integer( columnid ),
0:              new Integer( getColumnCount() )
0:              );
1:     }
1: 
1:     private ScoreDoc    getScoreDoc()   throws IOException
1:     {
1:         return _hits[ _hitIndex ];
1:     }
1: 	
1: 	public boolean next()
1:         throws SQLException
1:     {
1:         if ( _schema == null ) { initScan(); }
1:         
1: 		_hitIndex++;
1: 		if (_hitIndex < _hits.length) {
1: 			return true;
1: 		}
1: 
1:         closeReader();
1: 		return false;
1: 	}
1: 	
1: 	public void close()
1:         throws SQLException
1:     {
1: 		_hits = null;
1: 		_hitIndex = 0;
1: 
1:         closeReader();
1: 	}
1: 	
1: 	/**
1: 	 * Be sure to close the Lucene IndexReader
1: 	 */
0: 	public void finalize()
1:     {
1: 		try {
1: 			if ( _indexReader != null ) { _indexReader.close(); }
1: 		} catch (IOException e) {
1: 			e.printStackTrace();
1: 		}
1: 	}
1: 
1: 	private void closeReader()
1:         throws SQLException
1:     {
1: 		if ( _indexReader == null ) { return; }
1:         
1: 		try {
1: 			_indexReader.close();
1: 		}
0:         catch (IOException e) { throw LuceneSupport.wrap( e ); }
1:         finally
1:         {
1:             _indexReader = null;
1:         }
1: 	}
1: 	
1:     /////////////////////////////////////////////////////////////////////
1:     //
1:     //  MINIONS
1:     //
1:     /////////////////////////////////////////////////////////////////////
1: 
1:     /** Initialize the metadata and scan */
1:     private void    initScan()  throws SQLException
1:     {
1:         try {
1:             // read the execution context for this AwareVTI
1:             VTIContext  context = getContext();
1:             _schema = context.vtiSchema();
1:             String[]    nameParts = LuceneSupport.decodeFunctionName( context.vtiTable() );
1:             _table = nameParts[ LuceneSupport.TABLE_PART ];
1:             _column = nameParts[ LuceneSupport.COLUMN_PART ];
1: 
1:             // divine the column names
1:             VTITemplate.ColumnDescriptor[]  returnColumns = getReturnTableSignature( _connection );
1:             String[]    columnNames = new String[ returnColumns.length ];
1:             for ( int i = 0; i < returnColumns.length; i++ ) { columnNames[ i ] = returnColumns[ i ].columnName; }
1:             setColumnNames( columnNames );
1: 
0:             _rankColumnID = getColumnCount();
0:             _docIDColumnID = _rankColumnID - 1;
1:             _maxKeyID = _docIDColumnID - 1;
1:             _minKeyID = 1;
1:             
1:             // make sure the user has SELECT privilege on all relevant columns of the underlying table
1:             vetPrivileges();
1:         
0:             String indexhome = LuceneSupport.getIndexLocation( _connection, _schema, _table, _column);
1: 				
0:             _indexReader = LuceneSupport.getIndexReader( new File( indexhome.toString() ) );
0:             _searcher = new IndexSearcher(_indexReader);
0:             Analyzer analyzer = new StandardAnalyzer( Version.LUCENE_45 );
0:             QueryParser qp = new QueryParser( Version.LUCENE_45, TEXT_FIELD_NAME, analyzer );
1:             Query luceneQuery = qp.parse( _queryText );
0:             TopScoreDocCollector tsdc = TopScoreDocCollector.create(1000, true);
0:             if ( _rankCutoff != 0 ) {
0:                 tsdc = TopScoreDocCollector.create(1000, new ScoreDoc(0, (float) _rankCutoff ), true);
1:             }
0:             _searcher.search(luceneQuery, tsdc);
0:             TopDocs topdocs = tsdc.topDocs();
0:             _hits = topdocs.scoreDocs;
1:         }
0:         catch (IOException ioe) { throw LuceneSupport.wrap( ioe ); }
0:         catch (ParseException pe) { throw LuceneSupport.wrap( pe ); }
0:         catch (PrivilegedActionException pae) { throw LuceneSupport.wrap( pae ); }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Make sure that the user has SELECT privilege on the text column and on all
1:      * the key columns of the underlying table.
1:      */
1:     private void    vetPrivileges() throws SQLException
1:     {
1:         StringBuilder   buffer = new StringBuilder();
1:         int _maxKeyID = getColumnCount() - 2;
1: 
1:         buffer.append( "select " );
1:         for ( int i = 0; i < _maxKeyID; i++ )
1:         {
1:             if ( i > 0 ) { buffer.append( ", " ); }
0:             buffer.append( getColumnName( i + 1 ) );
1:         }
0:         buffer.append( ", " + _column );
1:         buffer.append( " from " + LuceneSupport.makeTableName( _schema, _table ) );
1:         buffer.append( " where 1=2" );
1: 
1:         _connection.prepareStatement( buffer.toString() ).executeQuery().close();
1:     }
1: 
1:     /** Return true if the 1-based column ID is the ID of a key column */
1:     private boolean isKeyID( int columnid )
1:     {
1:         return ( (columnid > 0) && (columnid <= _maxKeyID) );
1:     }
1:     
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c316147
/////////////////////////////////////////////////////////////////////////
1:             indexVersion = Version.parseLeniently(indexVersionString);
commit:7234498
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         throws PrivilegedActionException
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             return AccessController.doPrivileged
1:                  public IndexReader run() throws IOException
1:         } catch (PrivilegedActionException pae) {
1:             throw (IOException) pae.getCause();
0:         }
1:         throws IOException
1:         try {
0:             return AccessController.doPrivileged
/////////////////////////////////////////////////////////////////////////
1:         } catch (PrivilegedActionException pae) {
1:             throw (IOException) pae.getCause();
0:         }
/////////////////////////////////////////////////////////////////////////
0:         throws PrivilegedActionException
/////////////////////////////////////////////////////////////////////////
1:         throws IOException
1:         try {
0:             AccessController.doPrivileged
/////////////////////////////////////////////////////////////////////////
1:         } catch (PrivilegedActionException pae) {
1:             throw (IOException) pae.getCause();
0:         }
============================================================================