1:41d69da: /*
1:41d69da: 
1:41d69da:    Derby - Class org.apache.derby.impl.services.locks.ConcurrentLockSet
1:41d69da: 
1:41d69da:    Licensed to the Apache Software Foundation (ASF) under one or more
1:41d69da:    contributor license agreements.  See the NOTICE file distributed with
1:41d69da:    this work for additional information regarding copyright ownership.
1:41d69da:    The ASF licenses this file to you under the Apache License, Version 2.0
1:41d69da:    (the "License"); you may not use this file except in compliance with
1:41d69da:    the License.  You may obtain a copy of the License at
1:41d69da: 
1:41d69da:       http://www.apache.org/licenses/LICENSE-2.0
1:41d69da: 
1:41d69da:    Unless required by applicable law or agreed to in writing, software
1:41d69da:    distributed under the License is distributed on an "AS IS" BASIS,
1:41d69da:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41d69da:    See the License for the specific language governing permissions and
1:41d69da:    limitations under the License.
1:41d69da: 
1:41d69da:  */
1:41d69da: 
1:41d69da: package org.apache.derby.impl.services.locks;
1:41d69da: 
1:41d69da: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
1:41d69da: import org.apache.derby.iapi.services.locks.Latch;
1:41d69da: import org.apache.derby.iapi.services.locks.Lockable;
1:41d69da: import org.apache.derby.iapi.services.locks.C_LockFactory;
1:41d69da: 
1:41d69da: import org.apache.derby.iapi.error.StandardException;
1:41d69da: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:41d69da: import org.apache.derby.iapi.services.diag.DiagnosticUtil;
1:41d69da: 
1:41d69da: import org.apache.derby.iapi.reference.Property;
1:41d69da: import org.apache.derby.iapi.reference.SQLState;
1:41d69da: 
1:41d69da: import java.util.concurrent.atomic.AtomicInteger;
1:41d69da: import java.util.concurrent.locks.Condition;
1:41d69da: import java.util.concurrent.locks.ReentrantLock;
1:41d69da: import java.util.concurrent.ConcurrentHashMap;
1:41d69da: import java.util.ArrayList;
1:41d69da: import java.util.HashMap;
1:41d69da: import java.util.Enumeration;
1:41d69da: import java.util.Map;
1:41d69da: 
1:41d69da: 
1:41d69da: /**
1:41d69da:     A ConcurrentLockSet is a complete lock table which maps
1:41d69da:     <code>Lockable</code>s to <code>LockControl</code> objects.
1:41d69da: 
1:41d69da: 	<P>
1:41d69da: 	A LockControl contains information about the locks held on a Lockable.
1:41d69da: 
1:41d69da: 	<BR>
1:41d69da:     MT - Mutable : All public methods of this class, except addWaiters, are
1:41d69da:     thread safe. addWaiters can only be called from the thread which performs
1:41d69da:     deadlock detection. Only one thread can perform deadlock detection at a
1:41d69da:     time.
1:41d69da: 
1:41d69da: 	<BR>
1:41d69da: 	The class creates ActiveLock and LockControl objects.
1:41d69da: 	
1:41d69da: 	LockControl objects are never passed out of this class, All the methods of 
1:41d69da:     LockControl are called while holding a ReentrantLock associated with the
1:41d69da:     Lockable controlled by the LockControl, thus providing the
1:41d69da:     single threading that LockControl required.
1:41d69da: 
1:41d69da: 	Methods of Lockables are only called by this class or LockControl, and 
1:41d69da:     always while holding the corresponding ReentrantLock, thus providing the
1:41d69da:     single threading that Lockable requires.
1:41d69da: 	
1:41d69da: 	@see LockControl
1:41d69da: */
1:41d69da: 
1:41d69da: final class ConcurrentLockSet implements LockTable {
1:41d69da: 	/*
1:41d69da: 	** Fields
1:41d69da: 	*/
1:41d69da: 	private final AbstractPool factory;
1:41d69da: 
1:41d69da:     /** Hash table which maps <code>Lockable</code> objects to
1:41d69da:      * <code>Lock</code>s. */
1:41d69da:     private final ConcurrentHashMap<Lockable, Entry> locks;
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * List containing all entries seen by the last call to
1:41d69da:      * <code>addWaiters()</code>. Makes it possible for the deadlock detection
1:41d69da:      * thread to lock all the entries it has visited until it has
1:41d69da:      * finished. This prevents false deadlocks from being reported (because all
1:41d69da:      * observed waiters must still be waiting when the deadlock detection has
1:41d69da:      * completed).
1:41d69da:      */
1:41d69da:     private ArrayList<Entry> seenByDeadlockDetection;
1:41d69da: 
1:41d69da: 	/**
1:41d69da: 		Timeout for deadlocks, in ms.
1:41d69da: 		<BR>
1:41d69da: 		MT - immutable
1:41d69da: 	*/
1:41d69da: 	private int deadlockTimeout = Property.DEADLOCK_TIMEOUT_DEFAULT * 1000;
1:41d69da: 	private int waitTimeout = Property.WAIT_TIMEOUT_DEFAULT * 1000;
1:41d69da: 
1:41d69da: //EXCLUDE-START-lockdiag- 
1:41d69da: 
1:41d69da: 	// this varible is set and get without synchronization.  
1:41d69da: 	// Only one thread should be setting it at one time.
1:41d69da: 	private boolean deadlockTrace;
1:41d69da: 
1:41d69da: //EXCLUDE-END-lockdiag- 
1:41d69da: 
1:41d69da: 	// The number of waiters for locks
1:41d69da: 	private final AtomicInteger blockCount;
1:41d69da: 
1:41d69da: 	/*
1:41d69da: 	** Constructor
1:41d69da: 	*/
1:41d69da: 
1:41d69da: 	ConcurrentLockSet(AbstractPool factory) {
1:41d69da: 		this.factory = factory;
1:41d69da:         blockCount = new AtomicInteger();
1:41d69da: 		locks = new ConcurrentHashMap<Lockable, Entry>();
1:41d69da: 	}
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * Class representing an entry in the lock table.
1:41d69da:      */
1:41d69da:     private static final class Entry {
1:41d69da:         /** The lock control. */
1:41d69da:         Control control;
1:41d69da:         /**
1:41d69da:          * Mutex used to ensure single-threaded access to the LockControls. To
1:41d69da:          * avoid Java deadlocks, no thread should ever hold the mutex of more
1:41d69da:          * than one entry. Excepted from this requirement is a thread which
1:41d69da:          * performs deadlock detection. During deadlock detection, a thread
1:41d69da:          * might hold several mutexes, but it is not allowed to hold any mutex
1:41d69da:          * when entering the deadlock detection. Only one thread is allowed to
1:41d69da:          * perform deadlock detection at a time.
1:41d69da:          */
1:41d69da:         private final ReentrantLock mutex = new ReentrantLock();
1:41d69da:         /**
1:41d69da:          * Condition variable which prevents calls to <code>lock()</code> from
1:41d69da:          * locking the entry. If it is not <code>null</code>, only the thread
1:41d69da:          * performing deadlock detection may lock the entry (by calling
1:41d69da:          * <code>lockForDeadlockDetection()</code>).
1:41d69da:          */
1:41d69da:         private Condition deadlockDetection;
1:41d69da: 
1:41d69da:         /**
1:41d69da:          * Lock the entry, ensuring exclusive access to the contained
1:41d69da:          * <code>Control</code> object. The call will block until the entry can
1:41d69da:          * be locked. If the entry is unlocked and
1:41d69da:          * <code>deadlockDetection</code> is not <code>null</code>, the entry
1:41d69da:          * belongs to a thread which waits for deadlock detection to be
1:41d69da:          * initiated, and the call will block until that thread has finished
1:41d69da:          * its deadlock detection.
1:41d69da:          */
1:41d69da:         void lock() {
1:41d69da:             if (SanityManager.DEBUG) {
1:41d69da:                 SanityManager.ASSERT(!mutex.isHeldByCurrentThread());
1:41d69da:             }
1:41d69da:             mutex.lock();
1:41d69da:             while (deadlockDetection != null) {
1:41d69da:                 deadlockDetection.awaitUninterruptibly();
1:41d69da:             }
1:41d69da:         }
1:41d69da: 
1:41d69da:         /**
1:41d69da:          * Unlock the entry, allowing other threads to lock and access the
1:41d69da:          * contained <code>Control</code> object.
1:41d69da:          */
1:41d69da:         void unlock() {
1:41d69da:             mutex.unlock();
1:41d69da:         }
1:41d69da: 
1:41d69da:         /**
1:41d69da:          * Lock the entry while performing deadlock detection. This method will
1:41d69da:          * lock the entry even when <code>deadlockDetection</code> is not
1:41d69da:          * <code>null</code>. If <code>deadlockDetection</code> is not
1:41d69da:          * <code>null</code>, we know the entry and its <code>Control</code>
1:41d69da:          * will not be accessed by others until we have finished the deadlock
1:41d69da:          * detection, so it's OK for us to access it.
2:41d69da:          *
1:41d69da:          */
1:41d69da:         void lockForDeadlockDetection() {
1:41d69da:             if (SanityManager.DEBUG) {
1:41d69da:                 SanityManager.ASSERT(!mutex.isHeldByCurrentThread());
1:41d69da:             }
1:41d69da:             mutex.lock();
1:41d69da:         }
1:41d69da: 
1:41d69da:         /**
1:41d69da:          * Notify that the lock request that is currently accessing the entry
1:41d69da:          * will be entering deadlock detection. Unlock the entry to allow the
1:41d69da:          * current thread or other threads to lock the entry for deadlock
1:41d69da:          * detection, but set the condition variable to prevent regular locking
1:41d69da:          * of the entry.
1:41d69da:          */
1:41d69da:         void enterDeadlockDetection() {
1:41d69da:             deadlockDetection = mutex.newCondition();
1:41d69da:             mutex.unlock();
1:41d69da:         }
1:41d69da: 
1:41d69da:         /**
1:41d69da:          * Notify that the deadlock detection triggered by the current thread
1:41d69da:          * has finished. Re-lock the entry and notify any waiters that the
1:41d69da:          * deadlock detection has completed.
1:41d69da:          */
1:41d69da:         void exitDeadlockDetection() {
1:41d69da:             if (SanityManager.DEBUG) {
1:41d69da:                 SanityManager.ASSERT(!mutex.isHeldByCurrentThread());
1:41d69da:             }
1:41d69da:             mutex.lock();
1:41d69da:             deadlockDetection.signalAll();
1:41d69da:             deadlockDetection = null;
1:41d69da:         }
1:41d69da:     }
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * Get an entry from the lock table. If no entry exists for the
1:41d69da:      * <code>Lockable</code>, insert an entry. The returned entry will be
1:41d69da:      * locked and is guaranteed to still be present in the table.
1:41d69da:      *
1:41d69da:      * @param ref the <code>Lockable</code> whose entry to return
1:41d69da:      * @return the entry for the <code>Lockable</code>, locked for exclusive
1:41d69da:      * access
1:41d69da:      */
1:41d69da:     private Entry getEntry(Lockable ref) {
1:41d69da:         Entry e = locks.get(ref);
1:41d69da:         while (true) {
1:41d69da:             if (e != null) {
1:41d69da:                 e.lock();
1:41d69da:                 if (e.control != null) {
1:41d69da:                     // entry is found and in use, return it
1:41d69da:                     return e;
1:41d69da:                 }
1:41d69da:                 // entry is empty, hence it was removed from the table after we
1:41d69da:                 // retrieved it. Try to reuse it later.
1:41d69da:             } else {
1:41d69da:                 // no entry found, create a new one
1:41d69da:                 e = new Entry();
1:41d69da:                 e.lock();
1:41d69da:             }
1:41d69da:             // reinsert empty entry, or insert the new entry
1:41d69da:             Entry current = locks.putIfAbsent(ref, e);
1:41d69da:             if (current == null) {
1:41d69da:                 // successfully (re-)inserted entry, return it
1:41d69da:                 return e;
1:41d69da:             }
1:41d69da:             // someone beat us, unlock the old entry and retry with the entry
1:41d69da:             // they inserted
1:41d69da:             e.unlock();
1:41d69da:             e = current;
1:41d69da:         }
1:41d69da:     }
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * Check whether there is a deadlock. Make sure that only one thread enters
1:41d69da:      * deadlock detection at a time.
1:41d69da:      *
1:41d69da:      * @param entry the entry in the lock table for the lock request that
1:41d69da:      * triggered deadlock detection
1:41d69da:      * @param waitingLock the waiting lock
1:41d69da:      * @param wakeupReason the reason for waking up the waiter
1:41d69da:      * @return an object describing the deadlock
1:41d69da:      */
1:41d69da:     private Object[] checkDeadlock(Entry entry, ActiveLock waitingLock,
1:41d69da:                                    byte wakeupReason) {
1:41d69da:         LockControl control = (LockControl) entry.control;
1:41d69da:         // make sure that the entry is not blocking other threads performing
1:41d69da:         // deadlock detection since we have to wait for them to finish
1:41d69da:         entry.enterDeadlockDetection();
1:41d69da:         synchronized (Deadlock.class) {
1:41d69da:             try {
1:41d69da:                 return Deadlock.look(factory, this, control, waitingLock,
1:41d69da:                                      wakeupReason);
1:41d69da:             } finally {
1:41d69da:                 // unlock all entries we visited
1:41d69da:                 for (Entry e : seenByDeadlockDetection) {
1:41d69da:                     e.unlock();
1:41d69da:                 }
1:41d69da:                 seenByDeadlockDetection = null;
1:41d69da:                 // re-lock the entry
1:41d69da:                 entry.exitDeadlockDetection();
1:41d69da:             }
1:41d69da:         }
1:41d69da:     }
1:41d69da: 
1:41d69da: 	/*
1:41d69da: 	** Public Methods
1:41d69da: 	*/
1:41d69da: 
1:41d69da: 	/**
1:41d69da: 	 *	Lock an object within a specific compatibility space.
1:41d69da: 	 *
1:41d69da: 	 *	@param	compatibilitySpace Compatibility space.
1:41d69da: 	 *	@param	ref Lockable reference.
1:41d69da: 	 *	@param	qualifier Qualifier.
1:41d69da: 	 *	@param	timeout Timeout in milli-seconds
1:41d69da: 	 *
1:41d69da: 	 *	@return	Object that represents the lock.
1:41d69da: 	 *
1:41d69da: 	 *	@exception	StandardException Standard Derby policy.
1:41d69da: 
1:41d69da: 	*/
1:41d69da: 	public Lock lockObject(CompatibilitySpace compatibilitySpace, Lockable ref,
1:41d69da: 						   Object qualifier, int timeout)
1:41d69da: 		throws StandardException
1:41d69da: 	{		
1:41d69da: 		if (SanityManager.DEBUG) {
1:41d69da: 
1:41d69da: 			if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
1:41d69da: 
1:41d69da: 				if (locks.size() > 1000)
1:41d69da: 					System.out.println("memoryLeakTrace:LockSet: " +
1:41d69da:                                            locks.size());
1:41d69da: 			}
1:41d69da: 		}
1:41d69da: 
1:41d69da: 		LockControl control;
1:41d69da: 		Lock lockItem;
1:41d69da:         String  lockDebug = null;
1:9819cf8:         boolean blockedByParent = false;
1:41d69da: 
1:41d69da:         Entry entry = getEntry(ref);
1:41d69da:         try {
1:41d69da: 
1:41d69da:             Control gc = entry.control;
1:41d69da: 
1:41d69da: 			if (gc == null) {
1:41d69da: 
1:41d69da: 				// object is not locked, can be granted
1:41d69da: 				Lock gl = new Lock(compatibilitySpace, ref, qualifier);
1:41d69da: 
1:41d69da: 				gl.grant();
1:41d69da: 
1:41d69da: 				entry.control = gl;
1:41d69da: 
1:41d69da: 				return gl;
1:41d69da: 			}
1:41d69da: 
1:41d69da: 			control = gc.getLockControl();
1:41d69da: 			if (control != gc) {
1:41d69da: 				entry.control = control;
1:41d69da: 			}
1:41d69da: 
1:41d69da: 			if (SanityManager.DEBUG) {
1:41d69da: 				SanityManager.ASSERT(ref.equals(control.getLockable()));
1:41d69da: 				// ASSERT item is in the list
1:41d69da:                 SanityManager.ASSERT(
1:41d69da:                     locks.get(control.getLockable()).control == control);
1:41d69da: 			}
1:41d69da: 
1:41d69da: 			lockItem = control.addLock(this, compatibilitySpace, qualifier);
1:41d69da: 
1:41d69da: 			if (lockItem.getCount() != 0) {
1:41d69da: 				return lockItem;
1:41d69da: 			}
1:41d69da: 
1:9819cf8:             //
1:9819cf8:             // This logic supports the use-case of DERBY-6554.
1:9819cf8:             //
1:9819cf8:             blockedByParent =
1:9819cf8:                 (timeout == 0) &&
1:9819cf8:                 compatibilitySpace.getOwner().isNestedOwner() &&
1:9819cf8:                 control.blockedByParent( lockItem );
1:41d69da: 
1:9819cf8: 			if (
1:9819cf8:                 AbstractPool.noLockWait(timeout, compatibilitySpace) ||
1:9819cf8:                 blockedByParent
1:9819cf8:                 )
1:9819cf8:             {
1:41d69da:     			// remove all trace of lock
1:41d69da:     			control.giveUpWait(lockItem, this);
1:41d69da: 
1:9819cf8:                if (SanityManager.DEBUG) 
1:41d69da:                 {
1:41d69da:                     if (SanityManager.DEBUG_ON("DeadlockTrace"))
1:41d69da:                     {
1:41d69da: 
1:41d69da:                         SanityManager.showTrace(new Throwable());
1:41d69da: 
1:41d69da:                         // The following dumps the lock table as it 
1:41d69da:                         // exists at the time a timeout is about to 
1:41d69da:                         // cause a deadlock exception to be thrown.
1:41d69da: 
1:41d69da:                         lockDebug = 
1:41d69da:                             DiagnosticUtil.toDiagString(lockItem)   +
1:41d69da:                             "\nCould not grant lock with zero timeout, " +
1:41d69da:                             "here's the table";
1:41d69da: 
1:41d69da:                         // We cannot hold a lock on an entry while calling
1:41d69da:                         // toDebugString() since it will lock other entries in
1:41d69da:                         // the lock table. Holding the lock could cause a
1:41d69da:                         // deadlock.
1:41d69da:                         entry.unlock();
1:41d69da:                         try {
1:41d69da:                             lockDebug += toDebugString();
1:41d69da:                         } finally {
1:41d69da:                             // Re-lock the entry so that the outer finally
1:41d69da:                             // clause doesn't fail.
1:41d69da:                             entry.lock();
1:41d69da:                         }
1:41d69da:                     }
1:41d69da:                 }
1:41d69da: 
1:9819cf8:                return null;
1:41d69da: 			}
1:9819cf8: 
1:41d69da:         } finally {
1:41d69da:             entry.unlock();
1:41d69da:             
1:9819cf8:             if ( blockedByParent )
1:9819cf8:             {
1:9819cf8:                 throw StandardException.newException
1:9819cf8:                     ( SQLState.SELF_DEADLOCK );
1:9819cf8:             }
1:41d69da:         }
1:41d69da: 
1:41d69da: 		boolean deadlockWait = false;
1:41d69da: 		int actualTimeout;
1:41d69da: 
1:41d69da: 		if (timeout == C_LockFactory.WAIT_FOREVER)
1:41d69da: 		{
1:41d69da: 			// always check for deadlocks as there should not be any
1:41d69da: 			deadlockWait = true;
1:41d69da: 			if ((actualTimeout = deadlockTimeout) == C_LockFactory.WAIT_FOREVER)
1:41d69da: 				actualTimeout = Property.DEADLOCK_TIMEOUT_DEFAULT * 1000;
1:41d69da: 		}
1:41d69da: 		else
1:41d69da: 		{
1:41d69da: 
1:41d69da: 			if (timeout == C_LockFactory.TIMED_WAIT)
1:41d69da: 				timeout = actualTimeout = waitTimeout;
1:41d69da: 			else
1:41d69da: 				actualTimeout = timeout;
1:41d69da: 
1:41d69da: 
1:41d69da: 			// five posible cases
1:41d69da: 			// i)   timeout -1, deadlock -1         -> 
1:41d69da:             //          just wait forever, no deadlock check
1:41d69da: 			// ii)  timeout >= 0, deadlock -1       -> 
1:41d69da:             //          just wait for timeout, no deadlock check
1:41d69da: 			// iii) timeout -1, deadlock >= 0       -> 
1:41d69da:             //          wait for deadlock, then deadlock check, 
1:41d69da:             //          then infinite timeout
1:41d69da: 			// iv)  timeout >=0, deadlock < timeout -> 
1:41d69da:             //          wait for deadlock, then deadlock check, 
1:41d69da:             //          then wait for (timeout - deadlock)
1:41d69da: 			// v)   timeout >=0, deadlock >= timeout -> 
1:41d69da:             //          just wait for timeout, no deadlock check
1:41d69da: 
1:41d69da: 
1:41d69da: 			if (deadlockTimeout >= 0) {
1:41d69da: 
1:41d69da: 				if (actualTimeout < 0) {
1:41d69da: 					// infinite wait but perform a deadlock check first
1:41d69da: 					deadlockWait = true;
1:41d69da: 					actualTimeout = deadlockTimeout;
1:41d69da: 				} else if (deadlockTimeout < actualTimeout) {
1:41d69da: 
1:41d69da: 					// deadlock wait followed by a timeout wait
1:41d69da: 
1:41d69da: 					deadlockWait = true;
1:41d69da: 					actualTimeout = deadlockTimeout;
1:41d69da: 
1:41d69da: 					// leave timeout as the remaining time
1:41d69da: 					timeout -= deadlockTimeout;
1:41d69da: 				}
1:41d69da: 			}
1:41d69da: 		}
1:41d69da: 
1:41d69da: 
1:41d69da:         ActiveLock waitingLock = (ActiveLock) lockItem;
1:41d69da:         lockItem = null;
1:41d69da: 
1:41d69da:         int earlyWakeupCount = 0;
1:41d69da:         long startWaitTime = 0;
1:41d69da: 
1:41d69da: forever:	for (;;) {
1:41d69da: 
1:780c0c3:                 byte wakeupReason = 0;
1:41d69da:                 ActiveLock nextWaitingLock = null;
1:41d69da:                 Object[] deadlockData = null;
1:41d69da: 
1:780c0c3:                 try {
1:41d69da:                     try {
1:780c0c3:                         wakeupReason = waitingLock.waitForGrant(actualTimeout);
1:780c0c3:                     } catch(StandardException e) {
1:557bdf2:                         // DERBY-4711: If waitForGrant() fails, we need to
1:557bdf2:                         // remove ourselves from the queue so that those
1:557bdf2:                         // behind us in the queue don't get stuck waiting for
1:557bdf2:                         // us.
1:780c0c3:                         nextWaitingLock = control.getNextWaiter(waitingLock, true, this);
1:780c0c3:                         throw e;
1:780c0c3:                     }
1:780c0c3: 
1:41d69da:                     boolean willQuitWait;
1:41d69da:                     Enumeration timeoutLockTable = null;
1:41d69da:                     long currentTime = 0;
1:41d69da:         
1:41d69da:                     entry.lock();
1:41d69da:                     try {
1:41d69da: 
1:41d69da:                         if (control.isGrantable(
1:41d69da:                                 control.firstWaiter() == waitingLock,
1:41d69da:                                 compatibilitySpace,
1:41d69da:                                 qualifier)) {
1:41d69da: 
1:41d69da:                             // Yes, we are granted, put us on the granted queue.
1:41d69da:                             control.grant(waitingLock);
1:41d69da: 
1:41d69da:                             // Remove from the waiting queue & get next waiter
1:41d69da:                             nextWaitingLock = 
1:41d69da:                                 control.getNextWaiter(waitingLock, true, this);
1:41d69da: 
1:41d69da:                             return waitingLock;
1:41d69da:                         }
1:41d69da: 
1:41d69da:                         // try again later
1:41d69da:                         waitingLock.clearPotentiallyGranted(); 
1:41d69da: 
1:41d69da:                         willQuitWait = 
1:41d69da:                             (wakeupReason != Constants.WAITING_LOCK_GRANT);
1:41d69da: 
1:41d69da:                         if (((wakeupReason == Constants.WAITING_LOCK_IN_WAIT) &&
1:41d69da:                                     deadlockWait) ||
1:41d69da:                             (wakeupReason == Constants.WAITING_LOCK_DEADLOCK))
1:41d69da:                         {
1:41d69da: 
1:41d69da:                             // check for a deadlock, even if we were woken up 
1:41d69da:                             // because we were selected as a victim we still 
1:41d69da:                             // check because the situation may have changed.
1:41d69da:                             deadlockData = 
1:41d69da:                                 checkDeadlock(entry, waitingLock, wakeupReason);
1:41d69da: 
1:41d69da:                             if (deadlockData == null) {
1:41d69da:                                 // we don't have a deadlock
1:41d69da:                                 deadlockWait = false;
1:41d69da: 
1:41d69da:                                 actualTimeout = timeout;
1:41d69da:                                 startWaitTime = 0;
1:41d69da:                                 willQuitWait = false;
1:41d69da:                             } else {
1:41d69da:                                 willQuitWait = true;
1:41d69da:                             }
1:41d69da:                         }
1:41d69da: 
1:41d69da:                         nextWaitingLock = 
1:41d69da:                             control.getNextWaiter(
1:41d69da:                                 waitingLock, willQuitWait, this);
1:41d69da: 
1:41d69da: 
1:41d69da:                         // If we were not woken by another then we have
1:41d69da:                         // timed out. Either deadlock out or timeout
1:41d69da:                         if (SanityManager.DEBUG &&
1:41d69da:                                 SanityManager.DEBUG_ON("DeadlockTrace") &&
1:41d69da:                                 willQuitWait) {
1:41d69da:                             // Generate the first part of the debug message
1:41d69da:                             // while holding the lock on entry, so that we have
1:41d69da:                             // exclusive access to waitingLock. Wait until the
1:41d69da:                             // entry has been unlocked before appending the
1:41d69da:                             // contents of the lock table (to avoid deadlocks).
1:41d69da:                             lockDebug =
1:41d69da:                                 DiagnosticUtil.toDiagString(waitingLock) +
1:41d69da:                                 "\nGot deadlock/timeout, here's the table";
1:41d69da:                         }
1:41d69da: 
1:41d69da:                     } finally {
1:41d69da:                         entry.unlock();
1:41d69da:                     }
1:41d69da: 
1:41d69da:                     // need to do this outside of the synchronized block as the
1:41d69da:                     // message text building (timeouts and deadlocks) may 
1:41d69da:                     // involve getting locks to look up table names from 
1:41d69da:                     // identifiers.
1:41d69da: 
1:41d69da:                     if (willQuitWait)
1:41d69da:                     {
1:41d69da:                         if (deadlockTrace && (deadlockData == null)) {
1:41d69da:                             // if ending lock request due to lock timeout
1:41d69da:                             // want a copy of the LockTable and the time,
1:41d69da:                             // in case of deadlock deadlockData has the
1:41d69da:                             // info we need.
1:41d69da:                             currentTime = System.currentTimeMillis();
1:41d69da:                             timeoutLockTable =
1:41d69da:                                 factory.makeVirtualLockTable();
1:41d69da:                         }
1:41d69da: 
2:41d69da:                         if (SanityManager.DEBUG)
1:41d69da:                         {
1:41d69da:                             if (SanityManager.DEBUG_ON("DeadlockTrace")) {
1:41d69da:                                 SanityManager.showTrace(new Throwable());
1:41d69da: 
1:41d69da:                                 // The following dumps the lock table as it
1:41d69da:                                 // exists at the time a timeout is about to
1:41d69da:                                 // cause a deadlock exception to be thrown.
1:41d69da: 
1:41d69da:                                 lockDebug += toDebugString();
1:41d69da:                             }
1:41d69da: 
1:41d69da:                             if (lockDebug != null)
1:41d69da:                             {
1:41d69da:                                 String type = 
1:41d69da:                                     ((deadlockData != null) ? 
1:41d69da:                                          "deadlock:" : "timeout:"); 
1:41d69da: 
1:41d69da:                                 SanityManager.DEBUG_PRINT(
1:41d69da:                                     type,
1:41d69da:                                     "wait on lockitem caused " + type + 
1:41d69da:                                     lockDebug);
1:41d69da:                             }
1:41d69da: 
1:41d69da:                         }
1:41d69da: 
1:41d69da:                         if (deadlockData == null)
1:41d69da:                         {
1:c952843:                             // ending wait because of lock timeout or interrupt
1:41d69da: 
1:245a922:                             if (wakeupReason ==
1:245a922:                                     Constants.WAITING_LOCK_INTERRUPTED) {
1:41d69da: 
1:245a922:                                 throw StandardException.
1:245a922:                                     newException(SQLState.CONN_INTERRUPT);
2:c952843: 
1:c952843:                             } else if (deadlockTrace)
1:41d69da:                             {   
1:41d69da:                                 // Turn ON derby.locks.deadlockTrace to build 
1:41d69da:                                 // the lockTable.
1:41d69da:                                     
1:41d69da:                                 
1:41d69da:                                 throw Timeout.buildException(
1:41d69da:                                     waitingLock, timeoutLockTable, currentTime);
1:41d69da:                             }
1:41d69da:                             else
1:41d69da:                             {
1:41d69da:                                 StandardException se = 
1:41d69da:                                     StandardException.newException(
1:41d69da:                                         SQLState.LOCK_TIMEOUT);
1:41d69da: 
1:41d69da:                                 throw se;
1:41d69da:                             }
1:41d69da:                         }
1:41d69da:                         else 
1:41d69da:                         {
1:41d69da:                             // ending wait because of lock deadlock.
1:41d69da: 
1:41d69da:                             throw Deadlock.buildException(
1:41d69da:                                     factory, deadlockData);
1:41d69da:                         }
1:41d69da:                     }
1:41d69da:                 } finally {
1:41d69da:                     if (nextWaitingLock != null) {
1:41d69da:                         nextWaitingLock.wakeUp(Constants.WAITING_LOCK_GRANT);
1:41d69da:                         nextWaitingLock = null;
1:41d69da:                     }
1:41d69da:                 }
1:41d69da: 
1:41d69da:                 if (actualTimeout != C_LockFactory.WAIT_FOREVER) {
1:41d69da: 
1:41d69da:                     if (wakeupReason != Constants.WAITING_LOCK_IN_WAIT)
1:41d69da:                         earlyWakeupCount++;
1:41d69da: 
1:41d69da:                     if (earlyWakeupCount > 5) {
1:41d69da: 
1:41d69da:                         long now = System.currentTimeMillis();
1:41d69da: 
1:41d69da:                         if (startWaitTime != 0) {
1:41d69da: 
1:41d69da:                             long sleepTime = now - startWaitTime;
1:41d69da: 
1:41d69da:                             actualTimeout -= sleepTime;
1:41d69da:                         }
1:41d69da: 
1:41d69da:                         startWaitTime = now;
1:41d69da:                     }
1:41d69da:                 }
1:41d69da: 
1:41d69da: 
1:41d69da:             } // for(;;)
1:41d69da: 	}
1:41d69da: 
1:41d69da: 	/**
1:41d69da: 		Unlock an object, previously locked by lockObject(). 
1:41d69da: 
1:41d69da: 		If unlockCOunt is not zero then the lock will be unlocked
1:41d69da: 		that many times, otherwise the unlock count is taken from
1:41d69da: 		item.
1:41d69da: 
1:41d69da: 	*/
1:41d69da: 	public void unlock(Latch item, int unlockCount) {
1:41d69da:         // assume LockEntry is there
1:41d69da:         Entry entry = locks.get(item.getLockable());
1:41d69da:         entry.lock();
1:41d69da:         try {
1:41d69da:             unlock(entry, item, unlockCount);
1:41d69da:         } finally {
1:41d69da:             entry.unlock();
1:41d69da:         }
1:41d69da:     }
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * Unlock an object, previously locked by lockObject().
1:41d69da:      *
1:41d69da:      * @param entry the entry in which the lock is contained (the current
1:41d69da:      * thread must have locked the entry)
1:41d69da:      * @param item the item to unlock
1:41d69da:      * @param unlockCount the number of times to unlock the item (if zero, take
1:41d69da:      * the unlock count from item)
1:41d69da:      */
1:41d69da:     private void unlock(Entry entry, Latch item, int unlockCount) {
1:41d69da: 		if (SanityManager.DEBUG) {
1:41d69da:             SanityManager.ASSERT(entry.mutex.isHeldByCurrentThread());
1:41d69da: 			if (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {
1:41d69da: 				/*
1:41d69da: 				** I don't like checking the trace flag twice, but SanityManager
1:41d69da: 				** doesn't provide a way to get to the debug trace stream
1:41d69da: 				** directly.
1:41d69da: 				*/
1:41d69da: 				SanityManager.DEBUG(
1:41d69da:                     Constants.LOCK_TRACE, 
1:41d69da:                     "Release lock: " + DiagnosticUtil.toDiagString(item));
1:41d69da: 			}
1:41d69da: 		}
1:41d69da: 
1:41d69da: 		boolean tryGrant = false;
1:41d69da: 		ActiveLock nextGrant = null;
1:41d69da: 
1:41d69da:         Control control = entry.control;
1:41d69da: 			
1:41d69da: 			if (SanityManager.DEBUG) {
1:41d69da: 
1:41d69da:                 // only valid Lock's expected
1:41d69da:                 if (item.getLockable() == null)
1:41d69da:                 {
1:41d69da:                     SanityManager.THROWASSERT(
1:41d69da:                         "item.getLockable() = null." +
1:41d69da:                         "unlockCount " + unlockCount + 
1:41d69da:                         "item = " + DiagnosticUtil.toDiagString(item));
1:41d69da:                 }
1:41d69da: 
1:41d69da:                 // only valid Lock's expected
1:41d69da:                 if (control == null)
1:41d69da:                 {
1:41d69da:                     SanityManager.THROWASSERT(
1:41d69da:                         "control = null." +
1:41d69da:                         "unlockCount " + unlockCount + 
1:41d69da:                         "item = " + DiagnosticUtil.toDiagString(item));
1:41d69da:                 }
1:41d69da: 
1:41d69da:                 SanityManager.ASSERT(
1:41d69da:                     locks.get(control.getLockable()).control == control);
1:41d69da: 
1:41d69da: 				if ((unlockCount != 0) && (unlockCount > item.getCount()))
1:41d69da: 					SanityManager.THROWASSERT("unlockCount " + unlockCount +
1:41d69da: 						" larger than actual lock count " + item.getCount() + " item " + item);
1:41d69da: 			}
1:41d69da: 
1:41d69da: 			tryGrant = control.unlock(item, unlockCount);
1:41d69da: 			item = null;
1:41d69da: 
1:41d69da: 			boolean mayBeEmpty = true;
1:41d69da: 			if (tryGrant) {
1:41d69da: 				nextGrant = control.firstWaiter();
1:41d69da: 				if (nextGrant != null) {
1:41d69da: 					mayBeEmpty = false;
1:41d69da: 					if (!nextGrant.setPotentiallyGranted())
1:41d69da: 						nextGrant = null;
1:41d69da: 				}
1:41d69da: 			}
1:41d69da: 
1:41d69da: 			if (mayBeEmpty) {
1:41d69da: 				if (control.isEmpty()) {
1:41d69da: 					// no-one granted, no-one waiting, remove lock control
1:41d69da: 					locks.remove(control.getLockable());
1:41d69da:                     entry.control = null;
1:41d69da: 				}
1:41d69da: 				return;
1:41d69da: 			}
1:41d69da: 
1:41d69da: 		if (tryGrant && (nextGrant != null)) {
1:41d69da: 			nextGrant.wakeUp(Constants.WAITING_LOCK_GRANT);
1:41d69da: 		}
1:41d69da: 	}
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * Unlock an object once if it is present in the specified group. Also
1:41d69da:      * remove the object from the group.
1:41d69da:      *
2:41d69da:      * @param space the compatibility space
2:41d69da:      * @param ref a reference to the locked object
2:41d69da:      * @param qualifier qualifier of the lock
1:41d69da:      * @param group a map representing the locks in a group
1:41d69da:      * @return the corresponding lock in the group map, or <code>null</code> if
1:41d69da:      * the object was not unlocked
1:41d69da:      */
1:41d69da:     public Lock unlockReference(CompatibilitySpace space, Lockable ref,
1:41d69da:                                 Object qualifier, Map group) {
1:41d69da: 
1:41d69da:         Entry entry = locks.get(ref);
1:41d69da:         if (entry == null) {
2:41d69da:             return null;
1:41d69da:         }
1:41d69da: 
1:41d69da:         entry.lock();
1:41d69da:         try {
1:41d69da:             Control control = entry.control;
1:41d69da:             if (control == null) {
1:41d69da:                 return null;
1:41d69da:             }
1:41d69da: 
1:41d69da:             Lock setLock = control.getLock(space, qualifier);
1:41d69da:             if (setLock == null) {
1:41d69da:                 return null;
1:41d69da:             }
1:41d69da: 
1:41d69da:             Lock lockInGroup = (Lock) group.remove(setLock);
1:41d69da:             if (lockInGroup != null) {
1:41d69da:                 unlock(entry, lockInGroup, 1);
1:41d69da:             }
1:41d69da: 
1:41d69da:             return lockInGroup;
1:41d69da: 
1:41d69da:         } finally {
1:41d69da:             entry.unlock();
1:41d69da:         }
1:41d69da:     }
1:41d69da: 
1:41d69da:     /**
1:85e3e12:      * {@inheritDoc}
1:41d69da:      */
1:41d69da:     public boolean zeroDurationLockObject(
1:41d69da:         CompatibilitySpace space, Lockable ref, Object qualifier, int timeout)
1:41d69da:             throws StandardException {
1:41d69da: 
1:41d69da:         if (SanityManager.DEBUG) {
1:41d69da:             if (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {
1:41d69da:                 D_LockControl.debugLock(
1:41d69da:                     "Zero Duration Lock Request before Grant: ",
1:41d69da:                     space, null, ref, qualifier, timeout);
1:41d69da:                 if (SanityManager.DEBUG_ON(Constants.LOCK_STACK_TRACE)) {
1:41d69da:                     // The following will print the stack trace of the lock
1:41d69da:                     // request to the log.
1:41d69da:                     Throwable t = new Throwable();
1:41d69da:                     java.io.PrintWriter istream =
1:41d69da:                         SanityManager.GET_DEBUG_STREAM();
1:41d69da:                     istream.println("Stack trace of lock request:");
1:41d69da:                     t.printStackTrace(istream);
1:41d69da:                 }
1:41d69da:             }
1:41d69da:         }
1:41d69da: 
1:41d69da:         // Very fast zeroDurationLockObject() for unlocked objects.
1:41d69da:         // If no entry exists in the lock manager for this reference
1:41d69da:         // then it must be unlocked.
1:41d69da:         // If the object is locked then we perform a grantable
1:41d69da:         // check, skipping over any waiters.
1:41d69da:         // If the caller wants to wait and the lock cannot
1:41d69da:         // be granted then we do the slow join the queue and
1:41d69da:         // release the lock method.
1:41d69da: 
1:41d69da:         Entry entry = locks.get(ref);
1:41d69da:         if (entry == null) {
1:41d69da:             return true;
1:41d69da:         }
1:41d69da: 
1:41d69da:         entry.lock();
1:41d69da:         try {
1:41d69da:             Control control = entry.control;
1:41d69da:             if (control == null) {
1:41d69da:                 return true;
1:41d69da:             }
1:41d69da: 
1:41d69da:             // If we are grantable, ignoring waiting locks then
1:41d69da:             // we can also grant this request now, as skipping
1:41d69da:             // over the waiters won't block them as we release
1:41d69da:             // the lock rightway.
1:41d69da:             if (control.isGrantable(true, space, qualifier)) {
1:41d69da:                 return true;
1:41d69da:             }
1:41d69da: 
1:41d69da:             // can't be granted and are not willing to wait.
1:85e3e12:             if (AbstractPool.noLockWait(timeout, space)) {
1:41d69da:                 return false;
1:41d69da:             }
1:41d69da:         } finally {
1:41d69da:             entry.unlock();
1:41d69da:         }
1:41d69da: 
1:41d69da:         Lock lock = lockObject(space, ref, qualifier, timeout);
1:41d69da: 
1:41d69da:         if (SanityManager.DEBUG) {
1:41d69da:             if (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {
1:41d69da:                 D_LockControl.debugLock(
1:41d69da:                     "Zero Lock Request Granted: ",
1:41d69da:                     space, null, ref, qualifier, timeout);
1:41d69da:             }
1:41d69da:         }
1:41d69da: 
1:41d69da:         // and simply unlock it once
1:41d69da:         unlock(lock, 1);
1:41d69da: 
1:41d69da:         return true;
1:41d69da:     }
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * Set the deadlock timeout.
1:41d69da:      *
1:41d69da:      * @param timeout deadlock timeout in milliseconds
1:41d69da:      */
1:41d69da:     public void setDeadlockTimeout(int timeout) {
1:41d69da:         deadlockTimeout = timeout;
1:41d69da:     }
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * Set the wait timeout.
1:41d69da:      *
1:41d69da:      * @param timeout wait timeout in milliseconds
1:41d69da:      */
1:41d69da:     public void setWaitTimeout(int timeout) {
1:41d69da:         waitTimeout = timeout;
1:41d69da:     }
1:41d69da: 	
1:39c6ffc:     /**
1:39c6ffc:      * Get the wait timeout in milliseconds.
1:39c6ffc:      */
1:39c6ffc:     public int getWaitTimeout() { return waitTimeout; }
1:39c6ffc:     
1:41d69da: 	/*
1:41d69da: 	** Non public methods
1:41d69da: 	*/
1:41d69da: //EXCLUDE-START-lockdiag- 
1:41d69da: 
1:41d69da: 	public void setDeadlockTrace(boolean val)
1:41d69da: 	{
1:41d69da: 		// set this without synchronization
1:41d69da: 		deadlockTrace = val;
1:41d69da: 	}			
1:41d69da: //EXCLUDE-END-lockdiag- 
1:41d69da: 
1:41d69da:     private String toDebugString()
1:41d69da:     {
1:41d69da:         if (SanityManager.DEBUG)
1:41d69da:         {
1:4a4b0a8:             String str = "";
1:41d69da: 
1:41d69da:             int i = 0;
1:41d69da:             for (Entry entry : locks.values())
1:41d69da:             {
1:41d69da:                 entry.lock();
1:41d69da:                 try {
1:41d69da:                     str += "\n  lock[" + i + "]: " +
1:41d69da:                         DiagnosticUtil.toDiagString(entry.control);
1:41d69da:                 } finally {
1:41d69da:                     entry.unlock();
1:41d69da:                 }
1:41d69da:             }
1:41d69da: 
1:41d69da:             return(str);
1:41d69da:         }
1:41d69da:         else
1:41d69da:         {
1:41d69da:             return(null);
1:41d69da:         }
1:41d69da:     }
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * Add all waiters in this lock table to a <code>Map</code> object.
1:41d69da:      * This method can only be called by the thread that is currently
1:41d69da:      * performing deadlock detection. All entries that are visited in the lock
1:41d69da:      * table will be locked when this method returns. The entries that have
1:41d69da:      * been seen and locked will be unlocked after the deadlock detection has
1:41d69da:      * finished.
1:41d69da:      */
1:a15a470:     public void addWaiters(Map<Object,Object> waiters) {
1:41d69da:         seenByDeadlockDetection = new ArrayList<Entry>(locks.size());
1:41d69da:         for (Entry entry : locks.values()) {
1:41d69da:             seenByDeadlockDetection.add(entry);
1:41d69da:             entry.lockForDeadlockDetection();
1:41d69da:             if (entry.control != null) {
1:41d69da:                 entry.control.addWaiters(waiters);
1:41d69da:             }
1:41d69da:         }
1:41d69da:     }
1:41d69da: 
1:41d69da: //EXCLUDE-START-lockdiag- 
1:41d69da: 	/**
1:41d69da: 	 * make a shallow clone of myself and my lock controls
1:41d69da: 	 */
1:41d69da:     public Map<Lockable, Control> shallowClone() {
1:41d69da:         HashMap<Lockable, Control> clone = new HashMap<Lockable, Control>();
1:41d69da: 
1:41d69da:         for (Entry entry : locks.values()) {
1:41d69da:             entry.lock();
1:41d69da:             try {
1:41d69da:                 Control control = entry.control;
1:41d69da:                 if (control != null) {
1:41d69da:                     clone.put(control.getLockable(), control.shallowClone());
1:41d69da:                 }
1:41d69da:             } finally {
1:41d69da:                 entry.unlock();
1:41d69da:             }
1:41d69da: 		}
1:41d69da: 
1:41d69da: 		return clone;
1:41d69da: 	}
1:41d69da: //EXCLUDE-END-lockdiag- 
1:41d69da: 
1:41d69da: 	/**
1:41d69da: 	 * Increase blockCount by one.
1:41d69da: 	 */
1:41d69da: 	public void oneMoreWaiter() {
1:41d69da:         blockCount.incrementAndGet();
1:41d69da: 	}
1:41d69da: 
1:41d69da: 	/**
1:41d69da: 	 * Decrease blockCount by one.
1:41d69da: 	 */
1:41d69da: 	public void oneLessWaiter() {
1:41d69da: 		blockCount.decrementAndGet();
1:41d69da: 	}
1:41d69da: 
1:41d69da:     /**
1:41d69da:      * Check whether anyone is blocked.
1:41d69da:      * @return <code>true</code> if someone is blocked, <code>false</code>
1:41d69da:      * otherwise
1:41d69da:      */
1:41d69da: 	public boolean anyoneBlocked() {
1:41d69da:         int blocked = blockCount.get();
1:41d69da: 		if (SanityManager.DEBUG) {
1:41d69da: 			SanityManager.ASSERT(
1:41d69da: 				blocked >= 0, "blockCount should not be negative");
1:41d69da: 		}
1:41d69da: 		return blocked != 0;
1:41d69da: 	}
1:41d69da: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9819cf8
/////////////////////////////////////////////////////////////////////////
1:         boolean blockedByParent = false;
/////////////////////////////////////////////////////////////////////////
1:             //
1:             // This logic supports the use-case of DERBY-6554.
1:             //
1:             blockedByParent =
1:                 (timeout == 0) &&
1:                 compatibilitySpace.getOwner().isNestedOwner() &&
1:                 control.blockedByParent( lockItem );
1: 			if (
1:                 AbstractPool.noLockWait(timeout, compatibilitySpace) ||
1:                 blockedByParent
1:                 )
1:             {
1:                if (SanityManager.DEBUG) 
/////////////////////////////////////////////////////////////////////////
1:                return null;
1:             
1:             if ( blockedByParent )
1:             {
1:                 throw StandardException.newException
1:                     ( SQLState.SELF_DEADLOCK );
1:             }
commit:a15a470
/////////////////////////////////////////////////////////////////////////
1:     public void addWaiters(Map<Object,Object> waiters) {
commit:39c6ffc
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the wait timeout in milliseconds.
1:      */
1:     public int getWaitTimeout() { return waitTimeout; }
1:     
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4a4b0a8
/////////////////////////////////////////////////////////////////////////
1:             String str = "";
commit:557bdf2
/////////////////////////////////////////////////////////////////////////
1:                         // DERBY-4711: If waitForGrant() fails, we need to
1:                         // remove ourselves from the queue so that those
1:                         // behind us in the queue don't get stuck waiting for
1:                         // us.
commit:780c0c3
/////////////////////////////////////////////////////////////////////////
1:                 byte wakeupReason = 0;
1:                     try {
1:                         wakeupReason = waitingLock.waitForGrant(actualTimeout);
1:                     } catch(StandardException e) {
1:                         nextWaitingLock = control.getNextWaiter(waitingLock, true, this);
1:                         throw e;
1:                     }
1: 
commit:85e3e12
/////////////////////////////////////////////////////////////////////////
0: 			if (AbstractPool.noLockWait(timeout, compatibilitySpace)) {
/////////////////////////////////////////////////////////////////////////
1:      * {@inheritDoc}
/////////////////////////////////////////////////////////////////////////
1:             if (AbstractPool.noLockWait(timeout, space)) {
commit:41d69da
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.services.locks.ConcurrentLockSet
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.services.locks;
1: 
1: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
1: import org.apache.derby.iapi.services.locks.Latch;
1: import org.apache.derby.iapi.services.locks.Lockable;
1: import org.apache.derby.iapi.services.locks.C_LockFactory;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.diag.DiagnosticUtil;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.locks.Condition;
1: import java.util.concurrent.locks.ReentrantLock;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.Enumeration;
1: import java.util.Map;
1: 
1: 
1: /**
1:     A ConcurrentLockSet is a complete lock table which maps
1:     <code>Lockable</code>s to <code>LockControl</code> objects.
1: 
1: 	<P>
1: 	A LockControl contains information about the locks held on a Lockable.
1: 
1: 	<BR>
1:     MT - Mutable : All public methods of this class, except addWaiters, are
1:     thread safe. addWaiters can only be called from the thread which performs
1:     deadlock detection. Only one thread can perform deadlock detection at a
1:     time.
1: 
1: 	<BR>
1: 	The class creates ActiveLock and LockControl objects.
1: 	
1: 	LockControl objects are never passed out of this class, All the methods of 
1:     LockControl are called while holding a ReentrantLock associated with the
1:     Lockable controlled by the LockControl, thus providing the
1:     single threading that LockControl required.
1: 
1: 	Methods of Lockables are only called by this class or LockControl, and 
1:     always while holding the corresponding ReentrantLock, thus providing the
1:     single threading that Lockable requires.
1: 	
1: 	@see LockControl
1: */
1: 
1: final class ConcurrentLockSet implements LockTable {
1: 	/*
1: 	** Fields
1: 	*/
1: 	private final AbstractPool factory;
1: 
1:     /** Hash table which maps <code>Lockable</code> objects to
1:      * <code>Lock</code>s. */
1:     private final ConcurrentHashMap<Lockable, Entry> locks;
1: 
1:     /**
1:      * List containing all entries seen by the last call to
1:      * <code>addWaiters()</code>. Makes it possible for the deadlock detection
1:      * thread to lock all the entries it has visited until it has
1:      * finished. This prevents false deadlocks from being reported (because all
1:      * observed waiters must still be waiting when the deadlock detection has
1:      * completed).
1:      */
1:     private ArrayList<Entry> seenByDeadlockDetection;
1: 
1: 	/**
1: 		Timeout for deadlocks, in ms.
1: 		<BR>
1: 		MT - immutable
1: 	*/
1: 	private int deadlockTimeout = Property.DEADLOCK_TIMEOUT_DEFAULT * 1000;
1: 	private int waitTimeout = Property.WAIT_TIMEOUT_DEFAULT * 1000;
1: 
1: //EXCLUDE-START-lockdiag- 
1: 
1: 	// this varible is set and get without synchronization.  
1: 	// Only one thread should be setting it at one time.
1: 	private boolean deadlockTrace;
1: 
1: //EXCLUDE-END-lockdiag- 
1: 
1: 	// The number of waiters for locks
1: 	private final AtomicInteger blockCount;
1: 
1: 	/*
1: 	** Constructor
1: 	*/
1: 
1: 	ConcurrentLockSet(AbstractPool factory) {
1: 		this.factory = factory;
1:         blockCount = new AtomicInteger();
1: 		locks = new ConcurrentHashMap<Lockable, Entry>();
1: 	}
1: 
1:     /**
1:      * Class representing an entry in the lock table.
1:      */
1:     private static final class Entry {
1:         /** The lock control. */
1:         Control control;
1:         /**
1:          * Mutex used to ensure single-threaded access to the LockControls. To
1:          * avoid Java deadlocks, no thread should ever hold the mutex of more
1:          * than one entry. Excepted from this requirement is a thread which
1:          * performs deadlock detection. During deadlock detection, a thread
1:          * might hold several mutexes, but it is not allowed to hold any mutex
1:          * when entering the deadlock detection. Only one thread is allowed to
1:          * perform deadlock detection at a time.
1:          */
1:         private final ReentrantLock mutex = new ReentrantLock();
1:         /**
1:          * Condition variable which prevents calls to <code>lock()</code> from
1:          * locking the entry. If it is not <code>null</code>, only the thread
1:          * performing deadlock detection may lock the entry (by calling
1:          * <code>lockForDeadlockDetection()</code>).
1:          */
1:         private Condition deadlockDetection;
1: 
1:         /**
1:          * Lock the entry, ensuring exclusive access to the contained
1:          * <code>Control</code> object. The call will block until the entry can
1:          * be locked. If the entry is unlocked and
1:          * <code>deadlockDetection</code> is not <code>null</code>, the entry
1:          * belongs to a thread which waits for deadlock detection to be
1:          * initiated, and the call will block until that thread has finished
1:          * its deadlock detection.
1:          */
1:         void lock() {
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(!mutex.isHeldByCurrentThread());
1:             }
1:             mutex.lock();
1:             while (deadlockDetection != null) {
1:                 deadlockDetection.awaitUninterruptibly();
1:             }
1:         }
1: 
1:         /**
1:          * Unlock the entry, allowing other threads to lock and access the
1:          * contained <code>Control</code> object.
1:          */
1:         void unlock() {
1:             mutex.unlock();
1:         }
1: 
1:         /**
1:          * Lock the entry while performing deadlock detection. This method will
1:          * lock the entry even when <code>deadlockDetection</code> is not
1:          * <code>null</code>. If <code>deadlockDetection</code> is not
1:          * <code>null</code>, we know the entry and its <code>Control</code>
1:          * will not be accessed by others until we have finished the deadlock
1:          * detection, so it's OK for us to access it.
1:          *
1:          */
1:         void lockForDeadlockDetection() {
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(!mutex.isHeldByCurrentThread());
1:             }
1:             mutex.lock();
1:         }
1: 
1:         /**
1:          * Notify that the lock request that is currently accessing the entry
1:          * will be entering deadlock detection. Unlock the entry to allow the
1:          * current thread or other threads to lock the entry for deadlock
1:          * detection, but set the condition variable to prevent regular locking
1:          * of the entry.
1:          */
1:         void enterDeadlockDetection() {
1:             deadlockDetection = mutex.newCondition();
1:             mutex.unlock();
1:         }
1: 
1:         /**
1:          * Notify that the deadlock detection triggered by the current thread
1:          * has finished. Re-lock the entry and notify any waiters that the
1:          * deadlock detection has completed.
1:          */
1:         void exitDeadlockDetection() {
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(!mutex.isHeldByCurrentThread());
1:             }
1:             mutex.lock();
1:             deadlockDetection.signalAll();
1:             deadlockDetection = null;
1:         }
1:     }
1: 
1:     /**
1:      * Get an entry from the lock table. If no entry exists for the
1:      * <code>Lockable</code>, insert an entry. The returned entry will be
1:      * locked and is guaranteed to still be present in the table.
1:      *
1:      * @param ref the <code>Lockable</code> whose entry to return
1:      * @return the entry for the <code>Lockable</code>, locked for exclusive
1:      * access
1:      */
1:     private Entry getEntry(Lockable ref) {
1:         Entry e = locks.get(ref);
1:         while (true) {
1:             if (e != null) {
1:                 e.lock();
1:                 if (e.control != null) {
1:                     // entry is found and in use, return it
1:                     return e;
1:                 }
1:                 // entry is empty, hence it was removed from the table after we
1:                 // retrieved it. Try to reuse it later.
1:             } else {
1:                 // no entry found, create a new one
1:                 e = new Entry();
1:                 e.lock();
1:             }
1:             // reinsert empty entry, or insert the new entry
1:             Entry current = locks.putIfAbsent(ref, e);
1:             if (current == null) {
1:                 // successfully (re-)inserted entry, return it
1:                 return e;
1:             }
1:             // someone beat us, unlock the old entry and retry with the entry
1:             // they inserted
1:             e.unlock();
1:             e = current;
1:         }
1:     }
1: 
1:     /**
1:      * Check whether there is a deadlock. Make sure that only one thread enters
1:      * deadlock detection at a time.
1:      *
1:      * @param entry the entry in the lock table for the lock request that
1:      * triggered deadlock detection
1:      * @param waitingLock the waiting lock
1:      * @param wakeupReason the reason for waking up the waiter
1:      * @return an object describing the deadlock
1:      */
1:     private Object[] checkDeadlock(Entry entry, ActiveLock waitingLock,
1:                                    byte wakeupReason) {
1:         LockControl control = (LockControl) entry.control;
1:         // make sure that the entry is not blocking other threads performing
1:         // deadlock detection since we have to wait for them to finish
1:         entry.enterDeadlockDetection();
1:         synchronized (Deadlock.class) {
1:             try {
1:                 return Deadlock.look(factory, this, control, waitingLock,
1:                                      wakeupReason);
1:             } finally {
1:                 // unlock all entries we visited
1:                 for (Entry e : seenByDeadlockDetection) {
1:                     e.unlock();
1:                 }
1:                 seenByDeadlockDetection = null;
1:                 // re-lock the entry
1:                 entry.exitDeadlockDetection();
1:             }
1:         }
1:     }
1: 
1: 	/*
1: 	** Public Methods
1: 	*/
1: 
1: 	/**
1: 	 *	Lock an object within a specific compatibility space.
1: 	 *
1: 	 *	@param	compatibilitySpace Compatibility space.
1: 	 *	@param	ref Lockable reference.
1: 	 *	@param	qualifier Qualifier.
1: 	 *	@param	timeout Timeout in milli-seconds
1: 	 *
1: 	 *	@return	Object that represents the lock.
1: 	 *
1: 	 *	@exception	StandardException Standard Derby policy.
1: 
1: 	*/
1: 	public Lock lockObject(CompatibilitySpace compatibilitySpace, Lockable ref,
1: 						   Object qualifier, int timeout)
1: 		throws StandardException
1: 	{		
1: 		if (SanityManager.DEBUG) {
1: 
1: 			if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
1: 
1: 				if (locks.size() > 1000)
1: 					System.out.println("memoryLeakTrace:LockSet: " +
1:                                            locks.size());
1: 			}
1: 		}
1: 
1: 		LockControl control;
1: 		Lock lockItem;
1:         String  lockDebug = null;
1: 
1:         Entry entry = getEntry(ref);
1:         try {
1: 
1:             Control gc = entry.control;
1: 
1: 			if (gc == null) {
1: 
1: 				// object is not locked, can be granted
1: 				Lock gl = new Lock(compatibilitySpace, ref, qualifier);
1: 
1: 				gl.grant();
1: 
1: 				entry.control = gl;
1: 
1: 				return gl;
1: 			}
1: 
1: 			control = gc.getLockControl();
1: 			if (control != gc) {
1: 				entry.control = control;
1: 			}
1: 
1: 			if (SanityManager.DEBUG) {
1: 				SanityManager.ASSERT(ref.equals(control.getLockable()));
1: 				// ASSERT item is in the list
1:                 SanityManager.ASSERT(
1:                     locks.get(control.getLockable()).control == control);
1: 			}
1: 
1: 			lockItem = control.addLock(this, compatibilitySpace, qualifier);
1: 
1: 			if (lockItem.getCount() != 0) {
1: 				return lockItem;
1: 			}
1: 
0: 			if (timeout == C_LockFactory.NO_WAIT) {
1: 
1:     			// remove all trace of lock
1:     			control.giveUpWait(lockItem, this);
1: 
1:                 if (SanityManager.DEBUG) 
1:                 {
1:                     if (SanityManager.DEBUG_ON("DeadlockTrace"))
1:                     {
1: 
1:                         SanityManager.showTrace(new Throwable());
1: 
1:                         // The following dumps the lock table as it 
1:                         // exists at the time a timeout is about to 
1:                         // cause a deadlock exception to be thrown.
1: 
1:                         lockDebug = 
1:                             DiagnosticUtil.toDiagString(lockItem)   +
1:                             "\nCould not grant lock with zero timeout, " +
1:                             "here's the table";
1: 
1:                         // We cannot hold a lock on an entry while calling
1:                         // toDebugString() since it will lock other entries in
1:                         // the lock table. Holding the lock could cause a
1:                         // deadlock.
1:                         entry.unlock();
1:                         try {
1:                             lockDebug += toDebugString();
1:                         } finally {
1:                             // Re-lock the entry so that the outer finally
1:                             // clause doesn't fail.
1:                             entry.lock();
1:                         }
1:                     }
1:                 }
1: 
1: 				return null;
1: 			}
1: 
1:         } finally {
1:             entry.unlock();
1:         }
1: 
1: 		boolean deadlockWait = false;
1: 		int actualTimeout;
1: 
1: 		if (timeout == C_LockFactory.WAIT_FOREVER)
1: 		{
1: 			// always check for deadlocks as there should not be any
1: 			deadlockWait = true;
1: 			if ((actualTimeout = deadlockTimeout) == C_LockFactory.WAIT_FOREVER)
1: 				actualTimeout = Property.DEADLOCK_TIMEOUT_DEFAULT * 1000;
1: 		}
1: 		else
1: 		{
1: 
1: 			if (timeout == C_LockFactory.TIMED_WAIT)
1: 				timeout = actualTimeout = waitTimeout;
1: 			else
1: 				actualTimeout = timeout;
1: 
1: 
1: 			// five posible cases
1: 			// i)   timeout -1, deadlock -1         -> 
1:             //          just wait forever, no deadlock check
1: 			// ii)  timeout >= 0, deadlock -1       -> 
1:             //          just wait for timeout, no deadlock check
1: 			// iii) timeout -1, deadlock >= 0       -> 
1:             //          wait for deadlock, then deadlock check, 
1:             //          then infinite timeout
1: 			// iv)  timeout >=0, deadlock < timeout -> 
1:             //          wait for deadlock, then deadlock check, 
1:             //          then wait for (timeout - deadlock)
1: 			// v)   timeout >=0, deadlock >= timeout -> 
1:             //          just wait for timeout, no deadlock check
1: 
1: 
1: 			if (deadlockTimeout >= 0) {
1: 
1: 				if (actualTimeout < 0) {
1: 					// infinite wait but perform a deadlock check first
1: 					deadlockWait = true;
1: 					actualTimeout = deadlockTimeout;
1: 				} else if (deadlockTimeout < actualTimeout) {
1: 
1: 					// deadlock wait followed by a timeout wait
1: 
1: 					deadlockWait = true;
1: 					actualTimeout = deadlockTimeout;
1: 
1: 					// leave timeout as the remaining time
1: 					timeout -= deadlockTimeout;
1: 				}
1: 			}
1: 		}
1: 
1: 
1:         ActiveLock waitingLock = (ActiveLock) lockItem;
1:         lockItem = null;
1: 
1:         int earlyWakeupCount = 0;
1:         long startWaitTime = 0;
1: 
1: forever:	for (;;) {
1: 
0:                 byte wakeupReason = waitingLock.waitForGrant(actualTimeout);
1:                 
1:                 ActiveLock nextWaitingLock = null;
1:                 Object[] deadlockData = null;
1: 
1:                 try {
1:                     boolean willQuitWait;
1:                     Enumeration timeoutLockTable = null;
1:                     long currentTime = 0;
1:         
1:                     entry.lock();
1:                     try {
1: 
1:                         if (control.isGrantable(
1:                                 control.firstWaiter() == waitingLock,
1:                                 compatibilitySpace,
1:                                 qualifier)) {
1: 
1:                             // Yes, we are granted, put us on the granted queue.
1:                             control.grant(waitingLock);
1: 
1:                             // Remove from the waiting queue & get next waiter
1:                             nextWaitingLock = 
1:                                 control.getNextWaiter(waitingLock, true, this);
1: 
1:                             return waitingLock;
1:                         }
1: 
1:                         // try again later
1:                         waitingLock.clearPotentiallyGranted(); 
1: 
1:                         willQuitWait = 
1:                             (wakeupReason != Constants.WAITING_LOCK_GRANT);
1: 
1:                         if (((wakeupReason == Constants.WAITING_LOCK_IN_WAIT) &&
1:                                     deadlockWait) ||
1:                             (wakeupReason == Constants.WAITING_LOCK_DEADLOCK))
1:                         {
1: 
1:                             // check for a deadlock, even if we were woken up 
1:                             // because we were selected as a victim we still 
1:                             // check because the situation may have changed.
1:                             deadlockData = 
1:                                 checkDeadlock(entry, waitingLock, wakeupReason);
1: 
1:                             if (deadlockData == null) {
1:                                 // we don't have a deadlock
1:                                 deadlockWait = false;
1: 
1:                                 actualTimeout = timeout;
1:                                 startWaitTime = 0;
1:                                 willQuitWait = false;
1:                             } else {
1:                                 willQuitWait = true;
1:                             }
1:                         }
1: 
1:                         nextWaitingLock = 
1:                             control.getNextWaiter(
1:                                 waitingLock, willQuitWait, this);
1: 
1: 
1:                         // If we were not woken by another then we have
1:                         // timed out. Either deadlock out or timeout
1:                         if (SanityManager.DEBUG &&
1:                                 SanityManager.DEBUG_ON("DeadlockTrace") &&
1:                                 willQuitWait) {
1:                             // Generate the first part of the debug message
1:                             // while holding the lock on entry, so that we have
1:                             // exclusive access to waitingLock. Wait until the
1:                             // entry has been unlocked before appending the
1:                             // contents of the lock table (to avoid deadlocks).
1:                             lockDebug =
1:                                 DiagnosticUtil.toDiagString(waitingLock) +
1:                                 "\nGot deadlock/timeout, here's the table";
1:                         }
1: 
1:                     } finally {
1:                         entry.unlock();
1:                     }
1: 
1:                     // need to do this outside of the synchronized block as the
1:                     // message text building (timeouts and deadlocks) may 
1:                     // involve getting locks to look up table names from 
1:                     // identifiers.
1: 
1:                     if (willQuitWait)
1:                     {
1:                         if (deadlockTrace && (deadlockData == null)) {
1:                             // if ending lock request due to lock timeout
1:                             // want a copy of the LockTable and the time,
1:                             // in case of deadlock deadlockData has the
1:                             // info we need.
1:                             currentTime = System.currentTimeMillis();
1:                             timeoutLockTable =
1:                                 factory.makeVirtualLockTable();
1:                         }
1: 
1:                         if (SanityManager.DEBUG)
1:                         {
1:                             if (SanityManager.DEBUG_ON("DeadlockTrace")) {
1:                                 SanityManager.showTrace(new Throwable());
1: 
1:                                 // The following dumps the lock table as it
1:                                 // exists at the time a timeout is about to
1:                                 // cause a deadlock exception to be thrown.
1: 
1:                                 lockDebug += toDebugString();
1:                             }
1: 
1:                             if (lockDebug != null)
1:                             {
1:                                 String type = 
1:                                     ((deadlockData != null) ? 
1:                                          "deadlock:" : "timeout:"); 
1: 
1:                                 SanityManager.DEBUG_PRINT(
1:                                     type,
1:                                     "wait on lockitem caused " + type + 
1:                                     lockDebug);
1:                             }
1: 
1:                         }
1: 
1:                         if (deadlockData == null)
1:                         {
0:                             // ending wait because of lock timeout.
1: 
0:                             if (deadlockTrace)
1:                             {   
1:                                 // Turn ON derby.locks.deadlockTrace to build 
1:                                 // the lockTable.
1:                                     
1:                                 
1:                                 throw Timeout.buildException(
1:                                     waitingLock, timeoutLockTable, currentTime);
1:                             }
1:                             else
1:                             {
1:                                 StandardException se = 
1:                                     StandardException.newException(
1:                                         SQLState.LOCK_TIMEOUT);
1: 
1:                                 throw se;
1:                             }
1:                         }
1:                         else 
1:                         {
1:                             // ending wait because of lock deadlock.
1: 
1:                             throw Deadlock.buildException(
1:                                     factory, deadlockData);
1:                         }
1:                     }
1:                 } finally {
1:                     if (nextWaitingLock != null) {
1:                         nextWaitingLock.wakeUp(Constants.WAITING_LOCK_GRANT);
1:                         nextWaitingLock = null;
1:                     }
1:                 }
1: 
1:                 if (actualTimeout != C_LockFactory.WAIT_FOREVER) {
1: 
1:                     if (wakeupReason != Constants.WAITING_LOCK_IN_WAIT)
1:                         earlyWakeupCount++;
1: 
1:                     if (earlyWakeupCount > 5) {
1: 
1:                         long now = System.currentTimeMillis();
1: 
1:                         if (startWaitTime != 0) {
1: 
1:                             long sleepTime = now - startWaitTime;
1: 
1:                             actualTimeout -= sleepTime;
1:                         }
1: 
1:                         startWaitTime = now;
1:                     }
1:                 }
1: 
1: 
1:             } // for(;;)
1: 	}
1: 
1: 	/**
1: 		Unlock an object, previously locked by lockObject(). 
1: 
1: 		If unlockCOunt is not zero then the lock will be unlocked
1: 		that many times, otherwise the unlock count is taken from
1: 		item.
1: 
1: 	*/
1: 	public void unlock(Latch item, int unlockCount) {
1:         // assume LockEntry is there
1:         Entry entry = locks.get(item.getLockable());
1:         entry.lock();
1:         try {
1:             unlock(entry, item, unlockCount);
1:         } finally {
1:             entry.unlock();
1:         }
1:     }
1: 
1:     /**
1:      * Unlock an object, previously locked by lockObject().
1:      *
1:      * @param entry the entry in which the lock is contained (the current
1:      * thread must have locked the entry)
1:      * @param item the item to unlock
1:      * @param unlockCount the number of times to unlock the item (if zero, take
1:      * the unlock count from item)
1:      */
1:     private void unlock(Entry entry, Latch item, int unlockCount) {
1: 		if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(entry.mutex.isHeldByCurrentThread());
1: 			if (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {
1: 				/*
1: 				** I don't like checking the trace flag twice, but SanityManager
1: 				** doesn't provide a way to get to the debug trace stream
1: 				** directly.
1: 				*/
1: 				SanityManager.DEBUG(
1:                     Constants.LOCK_TRACE, 
1:                     "Release lock: " + DiagnosticUtil.toDiagString(item));
1: 			}
1: 		}
1: 
1: 		boolean tryGrant = false;
1: 		ActiveLock nextGrant = null;
1: 
1:         Control control = entry.control;
1: 			
1: 			if (SanityManager.DEBUG) {
1: 
1:                 // only valid Lock's expected
1:                 if (item.getLockable() == null)
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "item.getLockable() = null." +
1:                         "unlockCount " + unlockCount + 
1:                         "item = " + DiagnosticUtil.toDiagString(item));
1:                 }
1: 
1:                 // only valid Lock's expected
1:                 if (control == null)
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "control = null." +
1:                         "unlockCount " + unlockCount + 
1:                         "item = " + DiagnosticUtil.toDiagString(item));
1:                 }
1: 
1:                 SanityManager.ASSERT(
1:                     locks.get(control.getLockable()).control == control);
1: 
1: 				if ((unlockCount != 0) && (unlockCount > item.getCount()))
1: 					SanityManager.THROWASSERT("unlockCount " + unlockCount +
1: 						" larger than actual lock count " + item.getCount() + " item " + item);
1: 			}
1: 
1: 			tryGrant = control.unlock(item, unlockCount);
1: 			item = null;
1: 
1: 			boolean mayBeEmpty = true;
1: 			if (tryGrant) {
1: 				nextGrant = control.firstWaiter();
1: 				if (nextGrant != null) {
1: 					mayBeEmpty = false;
1: 					if (!nextGrant.setPotentiallyGranted())
1: 						nextGrant = null;
1: 				}
1: 			}
1: 
1: 			if (mayBeEmpty) {
1: 				if (control.isEmpty()) {
1: 					// no-one granted, no-one waiting, remove lock control
1: 					locks.remove(control.getLockable());
1:                     entry.control = null;
1: 				}
1: 				return;
1: 			}
1: 
1: 		if (tryGrant && (nextGrant != null)) {
1: 			nextGrant.wakeUp(Constants.WAITING_LOCK_GRANT);
1: 		}
1: 	}
1: 
1:     /**
1:      * Unlock an object once if it is present in the specified group. Also
1:      * remove the object from the group.
1:      *
1:      * @param space the compatibility space
1:      * @param ref a reference to the locked object
1:      * @param qualifier qualifier of the lock
1:      * @param group a map representing the locks in a group
1:      * @return the corresponding lock in the group map, or <code>null</code> if
1:      * the object was not unlocked
1:      */
1:     public Lock unlockReference(CompatibilitySpace space, Lockable ref,
1:                                 Object qualifier, Map group) {
1: 
1:         Entry entry = locks.get(ref);
1:         if (entry == null) {
1:             return null;
1:         }
1: 
1:         entry.lock();
1:         try {
1:             Control control = entry.control;
1:             if (control == null) {
1:                 return null;
1:             }
1: 
1:             Lock setLock = control.getLock(space, qualifier);
1:             if (setLock == null) {
1:                 return null;
1:             }
1: 
1:             Lock lockInGroup = (Lock) group.remove(setLock);
1:             if (lockInGroup != null) {
1:                 unlock(entry, lockInGroup, 1);
1:             }
1: 
1:             return lockInGroup;
1: 
1:         } finally {
1:             entry.unlock();
1:         }
1:     }
1: 
1:     /**
0:      * Lock an object and release the lock immediately. Equivalent to
0:      * <pre>
0:      * Lock lock = lockTable.lockObject(space, ref, qualifier, timeout);
0:      * lockTable.unlock(lock, 1);
0:      * </pre>
0:      * except that the implementation is more efficient.
1:      *
1:      * @param space the compatibility space
1:      * @param ref a reference to the locked object
1:      * @param qualifier qualifier of the lock
0:      * @param timeout maximum time to wait in milliseconds
0:      * (<code>LockFactory.NO_WAIT</code> means don't wait)
0:      * @return <code>true</code> if the object was locked, or
0:      * <code>false</code>if the timeout was <code>NO_WAIT</code> and the lock
0:      * couldn't be obtained immediately
0:      * @exception StandardException if the lock could not be obtained
1:      */
1:     public boolean zeroDurationLockObject(
1:         CompatibilitySpace space, Lockable ref, Object qualifier, int timeout)
1:             throws StandardException {
1: 
1:         if (SanityManager.DEBUG) {
1:             if (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {
1:                 D_LockControl.debugLock(
1:                     "Zero Duration Lock Request before Grant: ",
1:                     space, null, ref, qualifier, timeout);
1:                 if (SanityManager.DEBUG_ON(Constants.LOCK_STACK_TRACE)) {
1:                     // The following will print the stack trace of the lock
1:                     // request to the log.
1:                     Throwable t = new Throwable();
1:                     java.io.PrintWriter istream =
1:                         SanityManager.GET_DEBUG_STREAM();
1:                     istream.println("Stack trace of lock request:");
1:                     t.printStackTrace(istream);
1:                 }
1:             }
1:         }
1: 
1:         // Very fast zeroDurationLockObject() for unlocked objects.
1:         // If no entry exists in the lock manager for this reference
1:         // then it must be unlocked.
1:         // If the object is locked then we perform a grantable
1:         // check, skipping over any waiters.
1:         // If the caller wants to wait and the lock cannot
1:         // be granted then we do the slow join the queue and
1:         // release the lock method.
1: 
1:         Entry entry = locks.get(ref);
1:         if (entry == null) {
1:             return true;
1:         }
1: 
1:         entry.lock();
1:         try {
1:             Control control = entry.control;
1:             if (control == null) {
1:                 return true;
1:             }
1: 
1:             // If we are grantable, ignoring waiting locks then
1:             // we can also grant this request now, as skipping
1:             // over the waiters won't block them as we release
1:             // the lock rightway.
1:             if (control.isGrantable(true, space, qualifier)) {
1:                 return true;
1:             }
1: 
1:             // can't be granted and are not willing to wait.
0:             if (timeout == C_LockFactory.NO_WAIT) {
1:                 return false;
1:             }
1:         } finally {
1:             entry.unlock();
1:         }
1: 
1:         Lock lock = lockObject(space, ref, qualifier, timeout);
1: 
1:         if (SanityManager.DEBUG) {
1:             if (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {
1:                 D_LockControl.debugLock(
1:                     "Zero Lock Request Granted: ",
1:                     space, null, ref, qualifier, timeout);
1:             }
1:         }
1: 
1:         // and simply unlock it once
1:         unlock(lock, 1);
1: 
1:         return true;
1:     }
1: 
1:     /**
1:      * Set the deadlock timeout.
1:      *
1:      * @param timeout deadlock timeout in milliseconds
1:      */
1:     public void setDeadlockTimeout(int timeout) {
1:         deadlockTimeout = timeout;
1:     }
1: 
1:     /**
1:      * Set the wait timeout.
1:      *
1:      * @param timeout wait timeout in milliseconds
1:      */
1:     public void setWaitTimeout(int timeout) {
1:         waitTimeout = timeout;
1:     }
1: 	
1: 	/*
1: 	** Non public methods
1: 	*/
1: //EXCLUDE-START-lockdiag- 
1: 
1: 	public void setDeadlockTrace(boolean val)
1: 	{
1: 		// set this without synchronization
1: 		deadlockTrace = val;
1: 	}			
1: //EXCLUDE-END-lockdiag- 
1: 
1:     private String toDebugString()
1:     {
1:         if (SanityManager.DEBUG)
1:         {
0:             String str = new String();
1: 
1:             int i = 0;
1:             for (Entry entry : locks.values())
1:             {
1:                 entry.lock();
1:                 try {
1:                     str += "\n  lock[" + i + "]: " +
1:                         DiagnosticUtil.toDiagString(entry.control);
1:                 } finally {
1:                     entry.unlock();
1:                 }
1:             }
1: 
1:             return(str);
1:         }
1:         else
1:         {
1:             return(null);
1:         }
1:     }
1: 
1:     /**
1:      * Add all waiters in this lock table to a <code>Map</code> object.
1:      * This method can only be called by the thread that is currently
1:      * performing deadlock detection. All entries that are visited in the lock
1:      * table will be locked when this method returns. The entries that have
1:      * been seen and locked will be unlocked after the deadlock detection has
1:      * finished.
1:      */
0:     public void addWaiters(Map waiters) {
1:         seenByDeadlockDetection = new ArrayList<Entry>(locks.size());
1:         for (Entry entry : locks.values()) {
1:             seenByDeadlockDetection.add(entry);
1:             entry.lockForDeadlockDetection();
1:             if (entry.control != null) {
1:                 entry.control.addWaiters(waiters);
1:             }
1:         }
1:     }
1: 
1: //EXCLUDE-START-lockdiag- 
1: 	/**
1: 	 * make a shallow clone of myself and my lock controls
1: 	 */
1:     public Map<Lockable, Control> shallowClone() {
1:         HashMap<Lockable, Control> clone = new HashMap<Lockable, Control>();
1: 
1:         for (Entry entry : locks.values()) {
1:             entry.lock();
1:             try {
1:                 Control control = entry.control;
1:                 if (control != null) {
1:                     clone.put(control.getLockable(), control.shallowClone());
1:                 }
1:             } finally {
1:                 entry.unlock();
1:             }
1: 		}
1: 
1: 		return clone;
1: 	}
1: //EXCLUDE-END-lockdiag- 
1: 
1: 	/**
1: 	 * Increase blockCount by one.
1: 	 */
1: 	public void oneMoreWaiter() {
1:         blockCount.incrementAndGet();
1: 	}
1: 
1: 	/**
1: 	 * Decrease blockCount by one.
1: 	 */
1: 	public void oneLessWaiter() {
1: 		blockCount.decrementAndGet();
1: 	}
1: 
1:     /**
1:      * Check whether anyone is blocked.
1:      * @return <code>true</code> if someone is blocked, <code>false</code>
1:      * otherwise
1:      */
1: 	public boolean anyoneBlocked() {
1:         int blocked = blockCount.get();
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(
1: 				blocked >= 0, "blockCount should not be negative");
1: 		}
1: 		return blocked != 0;
1: 	}
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:c8e3030
/////////////////////////////////////////////////////////////////////////
commit:245a922
/////////////////////////////////////////////////////////////////////////
1:                             if (wakeupReason ==
1:                                     Constants.WAITING_LOCK_INTERRUPTED) {
1:                                 throw StandardException.
1:                                     newException(SQLState.CONN_INTERRUPT);
commit:c952843
/////////////////////////////////////////////////////////////////////////
1:                             // ending wait because of lock timeout or interrupt
0:                             if (wakeupReason == Constants.WAITING_LOCK_INTERRUPTED) {
1: 
0:                                 Thread.currentThread().interrupt();
0:                                 throw StandardException.newException(SQLState.CONN_INTERRUPT);
1: 
1:                             } else if (deadlockTrace)
============================================================================