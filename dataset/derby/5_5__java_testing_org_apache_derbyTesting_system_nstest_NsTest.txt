2:b8d1d8a: /*
8:b8d1d8a: 
1:b8d1d8a:  Derby - Class org.apache.derbyTesting.system.nstest.NsTest
1:b8d1d8a: 
1:b8d1d8a:  Licensed to the Apache Software Foundation (ASF) under one or more
1:b8d1d8a:  contributor license agreements.  See the NOTICE file distributed with
1:b8d1d8a:  this work for additional information regarding copyright ownership.
1:b8d1d8a:  The ASF licenses this file to You under the Apache License, Version 2.0
1:b8d1d8a:  (the "License"); you may not use this file except in compliance with
1:b8d1d8a:  the License.  You may obtain a copy of the License at
1:b8d1d8a: 
1:b8d1d8a:  http://www.apache.org/licenses/LICENSE-2.0
1:b8d1d8a: 
1:b8d1d8a:  Unless required by applicable law or agreed to in writing, software
1:b8d1d8a:  distributed under the License is distributed on an "AS IS" BASIS,
1:b8d1d8a:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b8d1d8a:  See the License for the specific language governing permissions and
1:b8d1d8a:  limitations under the License.
1:b8d1d8a: 
2:b8d1d8a:  */
1:b8d1d8a: package org.apache.derbyTesting.system.nstest;
1:b8d1d8a: 
1:2c381e0: import java.util.Arrays;
1:c043274: import java.util.HashMap;
1:b8d1d8a: import java.util.Properties;
1:e225bfb: import java.util.Date;
1:b8d1d8a: import java.sql.SQLException;
1:b8d1d8a: import java.sql.DriverManager;
1:b8d1d8a: import java.io.IOException;
1:c043274: import java.io.PrintStream;
1:c043274: import java.io.PrintWriter;
1:c043274: import java.io.StringWriter;
1:b8d1d8a: import java.sql.Connection;
1:b13fb1c: import java.sql.Timestamp;
1:b8d1d8a: 
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.init.DbSetup;
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.init.Initializer;
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.init.NWServerThread;
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.tester.BackupRestoreReEncryptTester;
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.tester.Tester1;
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.tester.Tester2;
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.tester.Tester3;
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.utils.MemCheck;
1:b13fb1c: import org.apache.derbyTesting.system.nstest.utils.SequenceReader;
1:b8d1d8a: 
1:b8d1d8a: /**
1:b8d1d8a:  * NsTest - the main class to start the tests The main test settings are as
1:b8d1d8a:  * follows: INIT_THREADS = Initializer threads MAX_INITIAL_ROWS = Initial set of
1:b8d1d8a:  * rows inserted before test begins MAX_ITERATIONS = Each client does these many
1:b8d1d8a:  * transactions in the test MAX_LOW_STRESS_ROWS = Num of rows worked over in a
1:b8d1d8a:  * transaction MAX_OPERATIONS_PER_CONN = Num of transaction batches made by a
1:b8d1d8a:  * client before closing the connection NUMTESTER1 = Number of Tester1 testers
1:b8d1d8a:  * NUMTESTER2 = Number of Tester2 testers NUMTESTER3 = Number of Tester3 testers
1:b8d1d8a:  * NUM_HIGH_STRESS_ROWS = Maximum rows to be selected NUM_UNTOUCHED_ROWS =
1:b8d1d8a:  * Number of rows on which Update/Delete operations are not performed
1:b8d1d8a:  *
1:b8d1d8a:  * START_SERVER_IN_SAME_VM= Set to true/false to start Network Server in the
1:b8d1d8a:  * same VM.
1:b8d1d8a:  *
1:b8d1d8a:  * The System property 'derby.nstest.backupRestore' can be set to false for
1:b8d1d8a:  * turning off Backup/Restore/Re-Encryption.
1:b8d1d8a:  */
1:b8d1d8a: 
1:c043274: public class NsTest extends Thread
1:c043274: {
1:c043274:     private static  final   String  BACKUP_FLAG = "derby.nstest.backupRestore";
1:c043274:     private static  final   String  OUTPUT_FILE = "derby.nstest.outputFile";
1:c043274:     private static  final   String  JUST_COUNT_ERRORS = "derby.nstest.justCountErrors";
1:c043274:     private static  final   String  QUIET = "derby.nstest.quiet";
1:777a463:     private static  final   String  DURATION = "derby.nstest.durationInMinutes";
1:b13fb1c: 
1:b13fb1c:     private static  final   long    MILLIS_PER_MINUTE = 1000L * 60L;
1:c043274:     
1:c043274:     private static  final   String  USAGE =
1:c043274:         "Usage:\n" +
1:c043274:         "\n" +
1:c043274:         "    java org.apache.derbyTesting.system.nstest.NsTest [ DerbyClient | Embedded [ small ] ]\n" +
1:c043274:         "\n" +
1:c043274:         "If no arguments are specified, the test defaults to a client/server configuration (DerbyClient)\n" +
1:c043274:         "\n" +
1:c043274:         "The following flags can be set:\n" +
1:c043274:         "\n" +
1:c043274:         "    -D" + BACKUP_FLAG + "=false    Turns off backup, restore, and re-encryption.\n" +
1:c043274:         "\n" +
1:c043274:         "    -D" + OUTPUT_FILE + "=fileName    Redirects output and errors to a file.\n" +
1:c043274:         "\n" +
1:777a463:         "    -D" + JUST_COUNT_ERRORS + "=true    Makes the test run quietly at steady-state, counting errors, and printing a summary at the end.\n" +
1:777a463:         "\n" +
1:777a463:         "    -D" + DURATION + "=$number    Run for this number of minutes.\n";
1:b8d1d8a: 
1:c043274:     private static  final   String  ERROR_BANNER1 = "//////////////////////////////////////////////////////////////\n";
1:c043274:     private static  final   String  ERROR_BANNER2 = "//    ";
1:5a56bcc: 
1:5a56bcc:     public  static  final   String  DEAD_CONNECTION = "08003";
1:c043274:     
1:c043274:     
1:b8d1d8a: 	public static final String dbName = "nstestdb";
1:b8d1d8a: 
1:b8d1d8a: 	public static final String user = "nstest";
1:b8d1d8a: 
1:b8d1d8a: 	public static final String password = "nstest";
1:b8d1d8a: 
1:b8d1d8a: 	public static final String clientURL = "jdbc:derby://localhost:1900/";
1:b8d1d8a: 
1:b8d1d8a: 	public static final String embedURL = "jdbc:derby:";
1:b8d1d8a: 
1:b8d1d8a: 	public static final String dataEncypt = "dataEncryption=true";
1:b8d1d8a: 
1:b8d1d8a: 	public static final String bootPwd = "bootPassword=12345678";
1:b8d1d8a: 
1:b8d1d8a: 	public static final String clientDbURL = new String(clientURL + dbName
1:b8d1d8a: 			+ ";create=true");
1:b8d1d8a: 
1:b8d1d8a: 	public static final String retrieveMessagePart = "retrieveMessagesFromServerOnGetMessage=true;";
1:b8d1d8a: 
1:b8d1d8a: 	public static final String embedDbURL = new String(embedURL + dbName
1:b8d1d8a: 			+ ";create=true");
1:b8d1d8a: 
1:b8d1d8a: 	public static boolean embeddedMode = false; // true is to run the test in
1:b8d1d8a: 	// embedded mode
1:b8d1d8a: 
1:b8d1d8a: 	public static final String driver = new String(
1:b8d1d8a: 	"org.apache.derby.jdbc.ClientDriver");
1:b8d1d8a: 
1:b8d1d8a: 	public static final String embedDriver = new String(
1:b8d1d8a: 	"org.apache.derby.jdbc.EmbeddedDriver");
1:b8d1d8a: 
1:c043274:     /* where to log messages */
1:c043274:     private static  PrintStream         statisticsLogger;
1:c043274:     public static NsTestPrintStream   logger;
1:c043274:     
1:b8d1d8a: 	public static Properties prop = new Properties();
1:b8d1d8a: 
1:b8d1d8a: 	public static int INIT = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int TESTER1 = 1;
1:b8d1d8a: 
1:b8d1d8a: 	public static int TESTER2 = 2;
1:b8d1d8a: 
1:b8d1d8a: 	public static int TESTER3 = 3;
1:b8d1d8a: 
1:b8d1d8a: 	public static int BACKUP = 4;
1:b8d1d8a: 
1:b8d1d8a: 	public static String BACKUPDIR = "backupdir";
1:b8d1d8a: 
1:b8d1d8a: 	public static String RESTOREDIR = "restoredir";
1:b8d1d8a: 
1:b8d1d8a: 	public static boolean START_SERVER_IN_SAME_VM = false;// If the server
1:e276048: 	// also needs to be started as a thread
1:b8d1d8a: 
1:b8d1d8a: 	public static boolean AUTO_COMMIT_OFF = false; // true is autocommit off
1:b8d1d8a: 
1:b8d1d8a: 	public static boolean CREATE_DATABASE_ONLY = false;
1:b8d1d8a: 
1:b8d1d8a: 	public static boolean schemaCreated = false; // initially schema is
1:b8d1d8a: 	// assumed to not exist
1:b8d1d8a: 
1:e276048: 	// Default configuration; can be overwritten by
1:e276048: 	// adding the argument 'small' to the call of this class - 
1:e276048: 	// see setSmallConfig()
1:b8d1d8a: 	public static int INIT_THREADS = 6; // keep this low to avoid deadlocks
1:b8d1d8a: 
1:2f32608: 	public static int MAX_INITIAL_ROWS = 6000;
1:b8d1d8a: 
1:b8d1d8a: 	public static int MAX_ITERATIONS = 2000; // Each client does these many
1:b8d1d8a: 	// transactions in the test.
1:b8d1d8a: 
1:2f32608: 	// num of rows worked over in a transaction
1:2f32608: 	public static int MAX_LOW_STRESS_ROWS = 30; 
1:b8d1d8a: 
1:2f32608: 	// num of transaction batches
1:2f32608: 	public static int MAX_OPERATIONS_PER_CONN = 25; 
1:b8d1d8a: 
1:2f32608: 	public static int NUMTESTER1 = 15;
1:b8d1d8a: 
1:2f32608: 	public static int NUMTESTER2 = 45;
1:b8d1d8a: 
1:2f32608: 	public static int NUMTESTER3 = 10;
1:b8d1d8a: 
1:2f32608: 	public static int NUM_HIGH_STRESS_ROWS = 25000;
1:b8d1d8a: 
1:2f32608: 	public static int NUM_UNTOUCHED_ROWS = 6000;
1:b8d1d8a: 
1:b8d1d8a: 	// ***End of full test block
1:b8d1d8a: 
1:b8d1d8a: 	// The following are to keep statistics of the number of
1:b8d1d8a: 	// Insert/Updates/Deletes & Selects
1:b8d1d8a: 	public static int numInserts = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int numUpdates = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int numDeletes = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int numSelects = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int numFailedInserts = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int numFailedUpdates = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int numFailedDeletes = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int numFailedSelects = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int numConnections = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int INSERT = 0;
1:b8d1d8a: 
1:b8d1d8a: 	public static int UPDATE = 1;
1:b8d1d8a: 
1:b8d1d8a: 	public static int DELETE = 2;
1:b8d1d8a: 
1:b8d1d8a: 	public static int SELECT = 3;
1:b8d1d8a: 
1:b8d1d8a: 	public static int FAILED_INSERT = 4;
1:b8d1d8a: 
1:b8d1d8a: 	public static int FAILED_UPDATE = 5;
1:b8d1d8a: 
1:b8d1d8a: 	public static int FAILED_DELETE = 6;
1:b8d1d8a: 
1:b8d1d8a: 	public static int FAILED_SELECT = 7;
1:b8d1d8a: 
1:b8d1d8a: 	public static int CONNECTIONS_MADE = 8;
1:b8d1d8a: 
1:b8d1d8a: 	public static final String SUCCESS = " *** SUCCESS *** ";
1:b8d1d8a: 
1:b8d1d8a: 	public static String driver_type = null;
1:b8d1d8a: 
1:b8d1d8a: 	private int type;
1:e276048:     
1:e276048: 	private static NsTest[] testThreads = null;
1:e276048: 
1:c043274:     private static  boolean _justCountErrors;
1:c043274:     private static  HashMap<String,NsTestError> _errors = new HashMap<String,NsTestError>();
1:c043274: 
1:777a463:     private static  long    _duration;
1:777a463:     
1:c043274:     private static  boolean _statisticsAlreadyPrinted = false;
1:b13fb1c:     private static  long        _maxSequenceCounter;
1:b13fb1c:     private static  long        _startTimestamp;
1:b13fb1c:     private static  long        _endTimestamp;
1:c043274: 
1:e225bfb:     private static  long        _totalMemory;
1:e225bfb:     private static  long        _freeMemory;
1:e225bfb:     private static  Date        _lastMemoryCheckTime;
1:e225bfb: 
1:e276048: 	public static int numActiveTestThreads() {
1:e276048: 		int activeThreadCount=0;
1:c043274: 
1:c043274:         if ( testThreads != null )
1:c043274:         {
1:c043274:             for (int i = 0; i < testThreads.length ; i++)
1:c043274:             {
1:c043274:                 if (testThreads[i] != null && testThreads[i].isAlive())
1:c043274:                     activeThreadCount++;
1:c043274:             }
1:c043274:         }
1:c043274:         
1:e276048: 		return activeThreadCount;
1:e276048: 	}
1:b8d1d8a: 
1:e225bfb:     public  static  void    updateMemoryTracker
1:e225bfb:         ( long newTotalMemory, long newFreeMemory, Date newTimestamp )
1:e225bfb:     {
1:e225bfb:         _totalMemory = newTotalMemory;
1:e225bfb:         _freeMemory = newFreeMemory;
1:e225bfb:         _lastMemoryCheckTime = newTimestamp;
1:e225bfb:     }
1:e225bfb: 
1:b13fb1c:     public  static  void    updateSequenceTracker( long newValue )
1:b13fb1c:     {
1:b13fb1c:         _maxSequenceCounter = newValue;
1:b13fb1c:     }
1:b13fb1c: 
1:c043274:     public  static  boolean justCountErrors() { return _justCountErrors; }
1:c043274: 
1:c043274: 	public static synchronized void addError( Throwable t )
1:c043274:     {
1:c043274:         String  key = getStackTrace( t );
1:c043274: 
1:c043274:         NsTestError error = _errors.get( key );
1:c043274:         if ( error != null ) { error.increment(); }
1:c043274:         else
1:c043274:         {
1:c043274:             error = new NsTestError( t );
1:c043274:             _errors.put( key, error );
1:c043274:         }
1:c043274: 	}
1:c043274:     private static  String  getStackTrace( Throwable t )
1:c043274:     {
1:c043274:         StringWriter    sw = new StringWriter();
1:c043274:         PrintWriter     pw = new PrintWriter( sw );
1:c043274: 
1:c043274:         t.printStackTrace( pw );
1:c043274:         pw.flush();
1:c043274:         sw.flush();
1:c043274: 
1:c043274:         return sw.toString();
1:c043274:     }
1:c043274: 
1:b8d1d8a: 	public static synchronized void addStats(int type, int addValue) {
1:b8d1d8a: 		switch (type) {
1:b8d1d8a: 		case 0:
1:b8d1d8a: 			numInserts += addValue;
1:b8d1d8a: 			break;
1:b8d1d8a: 		case 1:
1:b8d1d8a: 			numUpdates += addValue;
1:b8d1d8a: 			break;
1:b8d1d8a: 		case 2:
1:b8d1d8a: 			numDeletes += addValue;
1:b8d1d8a: 			break;
1:b8d1d8a: 		case 3:
1:b8d1d8a: 			numSelects += addValue;
1:b8d1d8a: 			break;
1:b8d1d8a: 		case 4:
1:b8d1d8a: 			numFailedInserts += addValue;
1:b8d1d8a: 			break;
1:b8d1d8a: 		case 5:
1:b8d1d8a: 			numFailedUpdates += addValue;
1:b8d1d8a: 			break;
1:b8d1d8a: 		case 6:
1:b8d1d8a: 			numFailedDeletes += addValue;
1:b8d1d8a: 			break;
1:b8d1d8a: 		case 7:
1:b8d1d8a: 			numFailedSelects += addValue;
1:b8d1d8a: 			break;
1:b8d1d8a: 		case 8:
1:b8d1d8a: 			numConnections += addValue;
1:b8d1d8a: 			break;
1:e276048: 		}
4:b8d1d8a: 	}
1:b8d1d8a: 
1:b8d1d8a: 	NsTest(int ttype, int k) throws Exception {
1:b8d1d8a: 		this.type = ttype; // INIT or TESTER1/2/3
1:b8d1d8a: 
1:b8d1d8a: 		if (ttype == INIT)
1:b8d1d8a: 			this.setName("InitThread " + k);
1:b8d1d8a: 		else if ((ttype == TESTER1) || (ttype == TESTER2) || (ttype == TESTER3))
1:b8d1d8a: 			this.setName("Thread " + k);
1:b8d1d8a: 	}
1:b8d1d8a: 
1:e276048: 	private static void setSmallConfig() {
1:e276048:         
1:e276048: 		INIT_THREADS = 3; //keep this low to avoid deadlocks
1:2f32608: 		MAX_INITIAL_ROWS = 150; //for a small test
1:2f32608: 		MAX_ITERATIONS = 50; //for a small test
1:2f32608: 		MAX_LOW_STRESS_ROWS = 10; //for a small test
1:2f32608: 		MAX_OPERATIONS_PER_CONN = 10; //for a small test
1:e276048: 		NUMTESTER1 = 3; //for a small test 
1:e276048: 		NUMTESTER2 = 4;//for a small test
1:e276048: 		NUMTESTER3 = 3; //for a small test
1:2f32608: 		NUM_HIGH_STRESS_ROWS = 20; //for a small test
1:e276048: 		NUM_UNTOUCHED_ROWS = 50; //for a small test
1:e276048: 	}
1:e276048:     
1:b8d1d8a: 	// ****************************************************************************
1:b8d1d8a: 	//
1:b8d1d8a: 	// main - will load the Derby embedded or client, invoke the
1:b8d1d8a: 	// database setup, initialize the
1:b8d1d8a: 	// tables and then kick off the test threads.
1:b8d1d8a: 	//
1:b8d1d8a: 	// ****************************************************************************
1:b8d1d8a: 	public static void main(String[] args) throws SQLException, IOException,
1:c043274: 	InterruptedException, Exception, Throwable
1:c043274:     {
1:b13fb1c:         _startTimestamp = System.currentTimeMillis();
1:b13fb1c: 
1:c043274: 		String outputFile = System.getProperty( OUTPUT_FILE );
1:c043274:         statisticsLogger = System.out;
1:c043274:         if ( outputFile != null )
1:c043274:         {
1:c043274:             statisticsLogger = new PrintStream( outputFile );
1:c043274:         }
1:c043274: 
1:777a463: 		String duration = System.getProperty( DURATION );
1:777a463:         if ( duration != null )
1:777a463:         {
1:777a463:             _duration = Long.parseLong( duration ) * MILLIS_PER_MINUTE;
1:777a463:         }
1:777a463: 
1:c043274:         _justCountErrors = Boolean.getBoolean( JUST_COUNT_ERRORS );
1:c043274: 
1:c043274:         logger = new NsTestPrintStream( statisticsLogger, !_justCountErrors );
1:c043274: 
1:c043274:         // add a shutdown hook to print statistics if someone types control-c to kill the test
1:c043274:         Runtime.getRuntime().addShutdownHook( new Thread( new ShutdownHook() ) );
1:b8d1d8a: 
1:b8d1d8a: 		Connection conn = null;
1:e276048: 		if (args.length >= 1) {
1:b8d1d8a: 			driver_type = args[0];
1:b8d1d8a: 			if (!((driver_type.equalsIgnoreCase("DerbyClient"))
1:b8d1d8a: 					|| (driver_type
1:b8d1d8a: 							.equalsIgnoreCase("Embedded")))) {
1:b8d1d8a: 				printUsage();
1:b8d1d8a: 				return;
1:b8d1d8a: 			}
1:c043274: 			logger.println("Test nstest starting....., using driver: "
1:b8d1d8a: 					+ driver_type);
1:b8d1d8a: 		} else {
1:b8d1d8a: 			driver_type = "DerbyClient";
1:b8d1d8a: 		}
1:e276048: 		if (args.length >= 2) {
1:2f32608: 			String testConfiguration = args [1];
1:2f32608: 			if (testConfiguration.equalsIgnoreCase("small"))
1:2f32608: 			{
1:c043274: 				logger.println("using small config");
1:2f32608: 				setSmallConfig();
1:2f32608: 			}    
1:2f32608: 		}
1:e276048:         
1:777a463: 		TimerThread timerThread = null;
1:777a463:         if ( _duration > 0L )
1:777a463:         {
1:777a463:             timerThread = new TimerThread( _duration );
1:777a463:             timerThread.start();
1:777a463:         }
1:777a463: 
1:b8d1d8a: 		// Load the driver and get a connection to the database
1:b8d1d8a: 		String jdbcUrl = "";
1:4469400:         Class<?> clazz;
1:b8d1d8a: 		try {
1:b8d1d8a: 			if (driver_type.equalsIgnoreCase("Embedded")) {
1:c043274: 				// logger.println("Driver embedd : " + driver_type);
1:c043274: 				logger.println("Loading the embedded driver...");
1:4469400: 				clazz = Class.forName(embedDriver);
1:4469400:                 clazz.getConstructor().newInstance();
1:b8d1d8a: 				jdbcUrl = embedDbURL + ";" + dataEncypt + ";" + bootPwd;
1:b8d1d8a: 				embeddedMode = true;
1:b8d1d8a: 			} else {
1:c043274: 				logger.println("Driver type : " + driver_type);
1:c043274: 				logger.println("Loading the Derby Client driver..."
1:b8d1d8a: 						+ driver);
1:4469400: 				clazz = Class.forName(driver);
1:4469400:                 clazz.getConstructor().newInstance();
1:c043274: 				logger.println("Client Driver loaded");
1:b8d1d8a: 				jdbcUrl = clientDbURL + ";" + dataEncypt + ";" + bootPwd;
1:e276048: 			}
1:b8d1d8a: 			if ((!embeddedMode) && START_SERVER_IN_SAME_VM) {
1:b8d1d8a: 				startNetworkServer();
1:e276048: 			}
1:b8d1d8a: 			prop.setProperty("user", user);
1:b8d1d8a: 			prop.setProperty("password", password);
1:c043274: 			logger
1:b8d1d8a: 			.println("Getting a connection using the url: " + jdbcUrl);
1:c043274: 			logger.println("JDBC url= " + jdbcUrl);
1:b8d1d8a: 			conn = DriverManager.getConnection(jdbcUrl, prop);
1:b8d1d8a: 
1:b8d1d8a: 		} catch (SQLException sqe) {
1:b8d1d8a: 
1:c043274: 			logger.println("\n\n " + sqe + sqe.getErrorCode() + " "
1:b8d1d8a: 					+ sqe.getSQLState());
1:cb47a36: 			if ((sqe.getErrorCode() == 40000)
1:b8d1d8a: 					|| sqe.getSQLState().equalsIgnoreCase("08001")) {
1:c043274: 				logger
1:b8d1d8a: 				.println("\n Unable to connect, test cannot proceed. Please verify if the Network Server is started on port 1900.");
1:b8d1d8a: 				// sqe.printStackTrace();
1:b8d1d8a: 				return;
1:b8d1d8a: 			}
1:b8d1d8a: 
1:b8d1d8a: 		} catch (ClassNotFoundException cnfe) {
1:c043274: 			logger.println("Driver not found: " + cnfe.getMessage());
1:c043274: 			cnfe.printStackTrace( logger );
1:b8d1d8a: 			return;
1:b8d1d8a: 
1:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			e.printStackTrace( logger );
1:c043274: 			logger.println("Unexpected Failure");
1:b8d1d8a: 			printException("nstest.main() method ==> ", e);
1:b8d1d8a: 		}
1:b8d1d8a: 
1:b8d1d8a: 		// create test schema if it does not already exist
1:b8d1d8a: 		if (DbSetup.doIt(conn) == false) {
1:c043274: 			logger.println("Error in dbSetup, test will exit");
1:b8d1d8a: 			System.exit(1);
1:b8d1d8a: 		}
1:b8d1d8a: 
1:b8d1d8a: 		// Note that the connection is still open, we can safely close it now
1:b8d1d8a: 		try {
1:b8d1d8a: 			conn.close();
1:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			logger
1:b8d1d8a: 			.println("FAIL - Error closing the connection in nstest.main():");
1:b8d1d8a: 			printException("Closing connection in nstest.main()", e);
1:b8d1d8a: 		}
1:b8d1d8a: 
1:b8d1d8a: 		// check memory in separate thread-- allows us to monitor usage during
1:b8d1d8a: 		// database calls
1:b8d1d8a: 		// 200,000 msec = 3min, 20 sec delay between checks
1:c043274: 		logger.println("Starting memory checker thread");
1:b8d1d8a: 		MemCheck mc = new MemCheck(200000);
1:b8d1d8a: 		mc.start();
1:b8d1d8a: 
1:b8d1d8a: 		// Now populate the tables using INIT_THREADS number of threads only if
1:e276048: 		// the schemaCreated flag has not been set. If so, then we assume that 
1:e276048: 		// some other thread from possibly another jvm reached here and has
1:e276048: 		// already created the schema and loaded the tables.
1:b8d1d8a: 		// Note that we kick off threads of this object type (nstest) and use
1:e276048: 		// the run method to do the work. The key to starting the init threads
1:e276048: 		// is the use of the constructor to indicate to the thread that it is
1:e276048: 		// an init thread. In this case, we pass the value INIT to the
1:e276048: 		// constructor and in the run method we go to the right section of the
1:b8d1d8a: 		// code based on what value is passed in. The other possible value that
1:e276048: 		// a thread can get is TESTER which indicates that these are the main 
1:e276048: 		// test threads.
1:b8d1d8a: 
1:b8d1d8a: 		if (NsTest.schemaCreated == false) {
1:b8d1d8a: 			// Table was created by this object, so we need to load it
1:c043274: 			logger
1:b8d1d8a: 			.println("Kicking off initialization threads that will populate the test table");
1:b8d1d8a: 			NsTest initThreads[] = new NsTest[INIT_THREADS];
1:b8d1d8a: 
1:b8d1d8a: 			for (int i = 0; i < INIT_THREADS; i++) {
1:b8d1d8a: 				initThreads[i] = new NsTest(INIT, i);
1:b8d1d8a: 				initThreads[i].start();
1:b8d1d8a: 				sleep(3000);
1:b8d1d8a: 			}
1:b8d1d8a: 
2:b8d1d8a: 			// Wait for the init threads to finish and join back
1:b8d1d8a: 			for (int i = 0; i < INIT_THREADS; i++) {
1:b8d1d8a: 				initThreads[i].join();
1:b8d1d8a: 			}
1:b8d1d8a: 		}// end of if(nstest.schemaCreated==false)
1:b8d1d8a: 
1:b8d1d8a: 		// For informational/debug purposes, print out whether this process
1:b8d1d8a: 		// created the schema
1:b8d1d8a: 		if (NsTest.schemaCreated) // true means that the schema was created by
1:b8d1d8a: 			// another jvm
1:c043274: 			logger
1:b8d1d8a: 			.println("Schema has already been created by another process!");
1:b8d1d8a: 
1:b8d1d8a: 		// The following 2 lines are used when you want to only create the test
1:e276048: 		// database that can be used as a reference so that subsequent tests do
1:e276048: 		// not need to create one of their own.
1:b8d1d8a: 		// The CREATE_DATABASE_ONLY FLAG is set with the rest of the flags
1:b8d1d8a: 		if (CREATE_DATABASE_ONLY) {
1:c043274: 			logger
1:b8d1d8a: 			.println("Finished creating the database, TEST THREADS WILL NOT RUN!!");
1:b13fb1c: 			// Finally also stop the memory checker and sequence threads, else the test will
1:b8d1d8a: 			// remain hung!
1:b8d1d8a: 			mc.stopNow = true;
1:b8d1d8a: 			mc.join();
1:b8d1d8a: 			return;
1:b8d1d8a: 		}
1:b8d1d8a: 
1:b8d1d8a: 		// Table was created by some other object, so we assume it is already
1:b8d1d8a: 		// loaded
1:b8d1d8a: 		// Now kick off the actual test threads that will do the work for us.
1:e276048: 		// Note that we use the value TESTER when initializing the threads.
1:b8d1d8a: 		// The total number of threads is NUMTESTER1+NUMTESTER2+NUMTESTER3
1:c043274: 		logger
1:b8d1d8a: 		.println("Kicking off test threads that will work over the test table");
1:b8d1d8a: 
1:b8d1d8a: 		int numTestThread = 0;
1:2f32608: 		int maxTestThreads = 0;
1:c043274: 		String runBackup = System.getProperty( BACKUP_FLAG );
1:2f32608: 		if ((runBackup != null) && (runBackup.equalsIgnoreCase("false")))
1:2f32608: 				maxTestThreads = NUMTESTER1 + NUMTESTER2 + NUMTESTER3;
1:2f32608: 		else
1:2f32608: 				maxTestThreads = 1 + NUMTESTER1 + NUMTESTER2 + NUMTESTER3;
1:e276048: 		testThreads = new NsTest[maxTestThreads];
1:b8d1d8a: 
1:b8d1d8a: 		// This loop is made of 3 subloops that will initialize the required
1:b8d1d8a: 		// amount of tester threads
1:b8d1d8a: 		// It uses the numTestThread variable as the array index which gets
1:b8d1d8a: 		// incremented in each subloop
1:b8d1d8a: 		while (numTestThread < maxTestThreads) {
1:b8d1d8a: 			// Check for property setting to decide the need for starting
1:b8d1d8a: 			// BackupRestore thread
1:b8d1d8a: 			if ((runBackup != null) && (runBackup.equalsIgnoreCase("false"))) {
1:c043274: 				logger.println("BackupRestore Thread not started...");
1:b8d1d8a: 			} else {
1:b8d1d8a: 				// Otherwise, start the BackupRestore Thread by default
1:b8d1d8a: 				testThreads[numTestThread] = new NsTest(BACKUP, numTestThread);
1:b8d1d8a: 				testThreads[numTestThread].start();
1:b8d1d8a: 				numTestThread++;
1:b8d1d8a: 			}
1:b8d1d8a: 
1:b8d1d8a: 			for (int j = 0; j < NUMTESTER1; j++) {
1:b8d1d8a: 				testThreads[numTestThread] = new NsTest(TESTER1, numTestThread);
1:b8d1d8a: 				testThreads[numTestThread].start();
1:b8d1d8a: 				sleep(3000);
1:b8d1d8a: 				numTestThread++;
1:b8d1d8a: 			}
1:b8d1d8a: 			for (int j = 0; j < NUMTESTER2; j++) {
1:b8d1d8a: 				testThreads[numTestThread] = new NsTest(TESTER2, numTestThread);
1:b8d1d8a: 				testThreads[numTestThread].start();
1:b8d1d8a: 				sleep(3000);
1:b8d1d8a: 				numTestThread++;
1:b8d1d8a: 			}
1:b8d1d8a: 			for (int j = 0; j < NUMTESTER3; j++) {
1:b8d1d8a: 				testThreads[numTestThread] = new NsTest(TESTER3, numTestThread);
1:b8d1d8a: 				testThreads[numTestThread].start();
1:b8d1d8a: 				sleep(3000);
1:b8d1d8a: 				numTestThread++;
1:b8d1d8a: 			}
1:b8d1d8a: 
1:b8d1d8a: 		}
1:b8d1d8a: 
1:b13fb1c: 		// check sequence value thread
1:b13fb1c: 		// 60,000 msec = 1 minute delay between checks
1:b13fb1c: 		logger.println("Starting sequence reader thread");
1:b13fb1c: 		SequenceReader  sequenceReader = new SequenceReader( DriverManager.getConnection( jdbcUrl, prop ), 60000 );
1:b13fb1c: 		sequenceReader.start();
1:b13fb1c: 
1:e276048: 		// Wait for the test threads to finish and join back
1:c043274: 		for (int j = 0; j < maxTestThreads; j++)
1:c043274:         {
1:c043274:             logger.println("Waiting for thread " + j+ " to join back/finish");
1:b8d1d8a: 			testThreads[j].join();
1:b8d1d8a: 		}
1:b8d1d8a: 
1:777a463:         if ( timerThread != null )
1:777a463:         {
1:777a463:             timerThread.stopNow();
1:777a463:             timerThread.interrupt();
1:777a463:             timerThread.join();
1:777a463:         }
1:777a463: 
1:b13fb1c:         // stop the sequence reader thread
1:b13fb1c: 		sequenceReader.stopNow = true;
1:777a463: 		sequenceReader.interrupt();
1:b13fb1c: 		sequenceReader.join();
1:b13fb1c: 
1:b8d1d8a: 		// Print statistics
1:c043274:         printStatistics();
1:b8d1d8a: 
1:b8d1d8a: 		// Finally also stop the memory checker thread
1:b8d1d8a: 		mc.stopNow = true;
1:b8d1d8a: 		mc.join();
1:b8d1d8a: 
1:c043274: 		logger
1:b8d1d8a: 		.println("End of test nstest! Look for 'FAIL' messages in the output and derby.log");
1:b8d1d8a: 
1:b8d1d8a: 	}// end of main
1:b8d1d8a: 
1:c043274:     public  static  void    printStatistics()
1:c043274:     {
1:c043274:         if ( _statisticsAlreadyPrinted ) { return; }
1:c043274:         else { _statisticsAlreadyPrinted = true; }
1:c043274: 
1:b13fb1c:         _endTimestamp = System.currentTimeMillis();
1:b13fb1c: 
2:c043274: 		statisticsLogger.println("");
1:c043274: 		statisticsLogger.println("STATISTICS OF OPERATIONS DONE");
1:c043274: 		statisticsLogger.println("-----------------------------");
1:b13fb1c: 		statisticsLogger.println("\n\n");
1:b13fb1c: 		statisticsLogger.println( "Start time = " + (new Timestamp( _startTimestamp )).toString() );
1:b13fb1c: 		statisticsLogger.println( "End time = " + (new Timestamp( _endTimestamp )).toString() );
1:b13fb1c: 		statisticsLogger.println( "Duration = " + ( (_endTimestamp - _startTimestamp) / MILLIS_PER_MINUTE ) + " minutes" );
1:b13fb1c: 		statisticsLogger.println("\n\n");
1:c043274: 		statisticsLogger.println("SUCCESSFUL: ");
1:c043274: 		statisticsLogger.println("	Number of INSERTS = " + numInserts);
1:c043274: 		statisticsLogger.println("	Number of UPDATES = " + numUpdates);
1:c043274: 		statisticsLogger.println("	Number of DELETES = " + numDeletes);
1:c043274: 		statisticsLogger.println("	Number of SELECTS = " + numSelects);
1:c043274: 		statisticsLogger.println("");
1:c043274: 		statisticsLogger.println("FAILED: ");
1:c043274: 		statisticsLogger.println("	Number of failed INSERTS = " + numFailedInserts);
1:c043274: 		statisticsLogger.println("	Number of failed UPDATES = " + numFailedUpdates);
1:c043274: 		statisticsLogger.println("	Number of failed DELETES = " + numFailedDeletes);
1:c043274: 		statisticsLogger.println("	Number of failed SELECTS = " + numFailedSelects);
1:c043274: 		statisticsLogger.println("");
1:c043274: 		statisticsLogger.println("  Note that this may not be the same as the server side connections made\n"
1:c043274: 				+ "   to the database especially if connection pooling is employed");
1:c043274: 		statisticsLogger.println("");
1:c043274: 		statisticsLogger
1:c043274: 		.println("NOTE: Failing operations could be because of locking issue that are\n"
1:c043274: 				+ "directly related to the application logic.  They are not necessarily bugs.");
1:c043274: 
1:b13fb1c:         statisticsLogger.println( "\nMax sequence counter peeked at = " + _maxSequenceCounter + "\n" );
1:b13fb1c:         
1:e225bfb:         statisticsLogger.println( "\nLast total memory = " + _totalMemory + ", last free memory = " + _freeMemory + " as measured at " + _lastMemoryCheckTime + "\n" );
1:e225bfb: 
1:c043274:         if ( _errors.size() > 0 )
1:c043274:         {
1:2c381e0:             // sort the errors by the timestamps of their first occurrences
1:2c381e0:             NsTestError[]   errors = new NsTestError[ _errors.size() ];
1:2c381e0:             _errors.values().toArray( errors );
1:2c381e0:             Arrays.sort( errors );
1:2c381e0:             
1:c043274:             countAndPrintSQLStates();
1:2c381e0:             for ( NsTestError error  : errors )
1:c043274:             {
1:2c381e0:                 printError( error );
1:c043274:             }
1:c043274:         }
1:c043274:     }
1:c043274: 
1:c043274:     /** Count and print the number of times each SQLState was seen in an error */
1:c043274:     private static  void    countAndPrintSQLStates()
1:c043274:     {
1:c043274:         HashMap<String,int[]>   results = new HashMap<String,int[]>();
1:c043274: 
1:c043274:         // count the number of times each SQL state was seen
2:c043274:         for ( String key  : _errors.keySet() )
1:c043274:         {
2:c043274:             NsTestError error = _errors.get( key );
1:c043274:             int         count = error.count();
1:c043274:             Throwable   throwable = error.throwable();
1:c043274:             if ( throwable instanceof SQLException )
1:c043274:             {
1:c043274:                 SQLException    se = (SQLException) throwable;
1:c043274:                 String          sqlState = se.getSQLState();
1:c043274: 
1:c043274:                 if ( sqlState != null )
1:c043274:                 {
1:c043274:                     int[]   holder = results.get( sqlState );
1:c043274:                     if ( holder == null )
1:c043274:                     {
1:c043274:                         holder = new int[] { count };
1:c043274:                         results.put( sqlState, holder );
1:c043274:                     }
1:c043274:                     else { holder[ 0 ] += count; }
1:c043274:                 }
1:c043274:             }
1:c043274:         }
1:c043274: 
1:c043274:         // now print the counts
1:c043274:         statisticsLogger.println( "\n" );
1:c043274:         for ( String sqlState : results.keySet() )
1:c043274:         {
1:c043274:             statisticsLogger.println("	Number of " + sqlState + " = " + results.get( sqlState )[ 0 ] );
1:c043274:         }
1:c043274:         statisticsLogger.println( "\n" );
1:c043274:     }
1:c043274: 
1:2c381e0:     private static  void    printError( NsTestError error )
1:c043274:     {
1:c043274:         Throwable   throwable = error.throwable();
1:2c381e0:         String          stackTrace = getStackTrace( throwable );
1:c043274:         int             count = error.count();
1:5ccbc16:         Timestamp   firstOccurrenceTime = new Timestamp( error.getFirstOccurrenceTime() );
1:5ccbc16:         Timestamp   lastOccurrenceTime = new Timestamp( error.getLastOccurrenceTime() );
1:c043274:         String      sqlState = (throwable instanceof SQLException) ? 
1:c043274:             ((SQLException) throwable).getSQLState() : null;
1:c043274: 
1:c043274:         StringBuilder   buffer = new StringBuilder();
1:c043274: 
1:c043274:         buffer.append( ERROR_BANNER1 );
1:c043274:         buffer.append( ERROR_BANNER2 );
1:c043274:         buffer.append( "\n" );
1:5ccbc16:         buffer.append( ERROR_BANNER2 );
1:c043274:         buffer.append( "Count = " + count );
1:c043274:         if ( sqlState != null ) { buffer.append( ", SQLState = " + sqlState ); }
1:c043274:         buffer.append( ", Message = " + throwable.getMessage() );
1:c043274:         buffer.append( "\n" );
1:c043274:         buffer.append( ERROR_BANNER2 );
1:c043274:         buffer.append( "\n" );
1:c043274:         buffer.append( ERROR_BANNER2 );
1:5ccbc16:         buffer.append( "First occurrence at " + firstOccurrenceTime );
1:5ccbc16:         buffer.append( ", last occurrence at " + lastOccurrenceTime );
1:5ccbc16:         buffer.append( "\n" );
1:5ccbc16:         buffer.append( ERROR_BANNER2 );
1:5ccbc16:         buffer.append( "\n" );
1:c043274:         buffer.append( ERROR_BANNER1 );
1:c043274:         buffer.append( "\n" );
1:c043274:         buffer.append( stackTrace );
1:c043274:         buffer.append( "\n" );
1:c043274: 
1:c043274:         statisticsLogger.println( buffer.toString() );
1:c043274:     }
1:c043274: 
1:b8d1d8a: 	// ****************************************************************************
1:b8d1d8a: 	//
1:b8d1d8a: 	// run() - the main workhorse method of the threads that will either
1:e276048: 	// initialize the table data or work over it as part of the test process.
1:b8d1d8a: 	// Table data initialization threads are of the following type
1:b8d1d8a: 	// Initializer -
1:b8d1d8a: 	// Bulk Insert client type that deals with a large(stress)
1:b8d1d8a: 	// number of rows with the connection being closed after the insert.
1:b8d1d8a: 	// Max rows inserted is based on the parameter MAX_INITIAL_ROWS
1:b8d1d8a: 	// Note that the run method will also instantiate tester objects of
1:e276048: 	// different types based on the following criteria
1:b8d1d8a: 	// Tester1 -
1:b8d1d8a: 	// The connection to the database is open forever. This client
1:b8d1d8a: 	// will do Insert/Update/Delete and simple Select queries over
1:b8d1d8a: 	// a small to medium set of data determined randomly as 1 row to
1:b8d1d8a: 	// MAX_LOW_STRESS_ROWS. Autocommit is left on.
1:b8d1d8a: 	// Tester2 -
1:b8d1d8a: 	// The connection is frequently opened and closed based on
1:b8d1d8a: 	// a random choice between 1 and MAX_OPERATIONS_PER_CONN number of
1:b8d1d8a: 	// transaction batches committed by this client type. This client will
1:b8d1d8a: 	// do Insert/Update/Delete and simple Select queries over a
1:b8d1d8a: 	// small to medium set of data determined randomly as 1 row to
1:b8d1d8a: 	// MAX_LOW_STRESS_ROWS.
1:b8d1d8a: 	// Tester3 -
1:b8d1d8a: 	// Query only kind of client that deals with a large result
1:b8d1d8a: 	// set based on a select query that returns a large number of
1:b8d1d8a: 	// rows (stress condition). Connection is closed after each
1:b8d1d8a: 	// query. The query will need to run in a DIRTY_READ mode, i.e.
1:b8d1d8a: 	// READ UNCOMMITTED isolation level. We work over the untouched
1:b8d1d8a: 	// portion of rows in the table (i.e. serialkey 1 to NUM_UNTOUCHED_ROWS)
1:b8d1d8a: 	//
1:b8d1d8a: 	// The mix of the tester types is based on the parameters NUMTESTER1,
1:b8d1d8a: 	// NUMTESTER2, NUMTESTER3.
1:b8d1d8a: 	//
1:b8d1d8a: 	//
1:b8d1d8a: 	// ****************************************************************************
1:b8d1d8a: 	public void run() {
1:b8d1d8a: 
1:c043274: 		logger.println(this.getName() + " is now running");
1:b8d1d8a: 
1:b8d1d8a: 		if (this.type == INIT) {
1:b8d1d8a: 			Initializer Init = new Initializer(this.getName());
1:b8d1d8a: 			Init.startInserts(); // this method only returns when the thread
1:b8d1d8a: 			// is done
1:b8d1d8a: 		} else if (this.type == TESTER1) {
1:b8d1d8a: 			Tester1 Tstr1 = new Tester1("Tester1" + this.getName());
1:b8d1d8a: 			Tstr1.startTesting(); // this method only returns when the thread
1:b8d1d8a: 			// is done
1:b8d1d8a: 		} else if (this.type == TESTER2) {
1:b8d1d8a: 			Tester2 Tstr2 = new Tester2("Tester2" + this.getName());
1:b8d1d8a: 			Tstr2.startTesting(); // this method only returns when the thread
1:b8d1d8a: 			// is done
1:b8d1d8a: 		} else if (this.type == TESTER3) {
1:b8d1d8a: 			Tester3 Tstr3 = new Tester3("Tester3" + this.getName());
1:b8d1d8a: 			Tstr3.startTesting(); // this method only returns when the thread
1:b8d1d8a: 			// is done
1:b8d1d8a: 		} else if (this.type == BACKUP) {
1:b8d1d8a: 			BackupRestoreReEncryptTester Tstr4 = null;
1:b8d1d8a: 			try {
1:b8d1d8a: 				Tstr4 = new BackupRestoreReEncryptTester(
1:b8d1d8a: 						"BackupRestoreReEncrypt" + this.getName());
1:b8d1d8a: 			} catch (IOException ioe) {
1:c043274: 				logger
1:b8d1d8a: 				.println(ioe
1:b8d1d8a: 						+ "=====> Unable to create backup log file, test cannot proceed ");
1:c043274: 				ioe.printStackTrace( logger );
1:b8d1d8a: 				return;
1:b8d1d8a: 			}
1:b8d1d8a: 			Tstr4.startTesting();
1:b8d1d8a: 
1:b8d1d8a: 		} else {
1:c043274: 			logger
1:b8d1d8a: 			.println("FAIL: Invalid thread type, should be INIT or TESTERx or BACKUP");
1:c043274: 			logger.println("You should check the code and restart");
1:b8d1d8a: 			return;
1:b8d1d8a: 		}
1:b8d1d8a: 
1:c043274: 		logger.println(this.getName() + " finished and is now exiting");
1:b8d1d8a: 
1:b8d1d8a: 	}// end of run()
1:b8d1d8a: 
1:b8d1d8a: 	// ** This method abstracts exception message printing for all exception
1:b8d1d8a: 	// messages. You may want to change
1:b8d1d8a: 	// ****it if more detailed exception messages are desired.
1:b8d1d8a: 	// ***Method is synchronized so that the output file will contain sensible
1:b8d1d8a: 	// stack traces that are not
1:b8d1d8a: 	// ****mixed but rather one exception printed at a time
1:c043274:     public static synchronized void printException(String where, Exception e)
1:c043274:     {
1:c043274:         if ( justCountErrors() )
1:c043274:         {
1:c043274:             addError( e );
1:e225bfb:             vetError( e );
1:c043274:             return;
1:c043274:         }
1:c043274:         
1:b8d1d8a: 		if (e instanceof SQLException) {
1:b8d1d8a: 			SQLException se = (SQLException) e;
1:b8d1d8a: 			if (se.getSQLState() != null) { // SQLSTATE is NULL for a
1:b8d1d8a: 				if (se.getSQLState().equals("40001"))
1:c043274: 					logger.println("deadlocked detected");
1:b8d1d8a: 				if (se.getSQLState().equals("40XL1"))
1:c043274: 					logger.println(" lock timeout exception");
1:b8d1d8a: 				if (se.getSQLState().equals("23500"))
1:c043274: 					logger.println(" duplicate key violation");
1:b8d1d8a: 			}
1:b8d1d8a: 			if (se.getNextException() != null) {
1:b8d1d8a: 				String m = se.getNextException().getSQLState();
1:c043274: 				logger.println(se.getNextException().getMessage()
1:b8d1d8a: 						+ " SQLSTATE: " + m);
1:b8d1d8a: 			}
1:b8d1d8a: 		}
1:5dcbe31: 		if (e.getMessage() == null) {
1:c043274: 			logger.println("NULL error message detected");
1:c043274: 			logger.println("Here is the NULL exection - " + e.toString());
1:c043274: 			logger.println("Stack trace of the NULL exception - ");
1:c043274: 			e.printStackTrace( logger );
1:b8d1d8a: 		}
1:c043274: 		logger.println("At this point - " + where
1:b8d1d8a: 				+ ", exception thrown was : " + e.getMessage());
1:b8d1d8a: 
1:e225bfb:         vetError( e );
1:b8d1d8a: 	}
1:b8d1d8a: 
1:e225bfb:     /**
1:e225bfb:      * Analyze an error which is being reported. Currently, all this
1:e225bfb:      * does is check for OutOfMemoryErrors. If we see an OutOfMemoryError,
1:e225bfb:      * we kill the JVM since we will just get cascading noise after we exhaust
1:e225bfb:      * memory.
1:e225bfb:      */
1:e225bfb:     private static  void    vetError( Throwable t )
1:e225bfb:     {
1:e225bfb:         if ( t == null ) { return; }
1:e225bfb:         
1:e225bfb:         if ( t instanceof OutOfMemoryError )
1:e225bfb:         {
1:e225bfb:             printStatistics();
1:e225bfb:             Runtime.getRuntime().halt( 0 );
1:e225bfb:         }
1:e225bfb: 
1:e225bfb:         vetError( t.getCause() );
1:e225bfb: 
1:e225bfb:         if ( t instanceof SQLException )
1:e225bfb:         {
1:e225bfb:             SQLException    sqlException = (SQLException) t;
1:e225bfb:             vetError( sqlException.getNextException() );
1:e225bfb:         }
1:e225bfb:     }
1:e225bfb: 
1:b8d1d8a: 	public static String getDriverURL() {
1:b8d1d8a: 		if (driver_type.equalsIgnoreCase("DerbyClient")) {
1:b8d1d8a: 			return clientURL;
1:b8d1d8a: 		} else {
1:b8d1d8a: 			return embedURL;
1:b8d1d8a: 		}
1:b8d1d8a: 	}
1:b8d1d8a: 
1:b8d1d8a: 	public static void startNetworkServer() throws Exception {
1:b8d1d8a: 		try {
1:b8d1d8a: 			NWServerThread nsw = new NWServerThread("localhost", 1900);
1:b8d1d8a: 			nsw.start();
1:b8d1d8a: 			Thread.sleep(10000);
1:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			e.printStackTrace( logger );
1:b8d1d8a: 			throw e;
1:b8d1d8a: 		}
1:b8d1d8a: 
1:b8d1d8a: 	}
1:b8d1d8a: 
1:5a56bcc:     /** Return true if the connection is dead */
1:5a56bcc:     public  static  boolean deadConnection( Throwable t )
1:5a56bcc:     {
1:5a56bcc:         if ( t instanceof SQLException )
1:5a56bcc:         {
1:5a56bcc:             SQLException    se = (SQLException) t;
1:5a56bcc: 
1:5a56bcc:             if ( DEAD_CONNECTION.equals( se.getSQLState() ) ) { return true; }
1:5a56bcc:         }
1:5a56bcc: 
1:5a56bcc:         return false;
1:5a56bcc:     }
1:5a56bcc: 
1:c043274: 	public static void printUsage()
1:c043274:     {
1:c043274:         _statisticsAlreadyPrinted = true;
1:c043274:         System.out.println( USAGE );
1:b8d1d8a: 	}
1:c043274: 
1:c043274:     public  static  class   ShutdownHook    implements  Runnable
1:c043274:     {
1:c043274:         public  void    run()
1:c043274:         {
1:c043274:             NsTest.printStatistics();
1:c043274:         }
1:c043274:     }
1:c043274:     
1:b8d1d8a: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz;
1: 				clazz = Class.forName(embedDriver);
1:                 clazz.getConstructor().newInstance();
1: 				clazz = Class.forName(driver);
1:                 clazz.getConstructor().newInstance();
commit:2c381e0
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:             // sort the errors by the timestamps of their first occurrences
1:             NsTestError[]   errors = new NsTestError[ _errors.size() ];
1:             _errors.values().toArray( errors );
1:             Arrays.sort( errors );
1:             
1:             for ( NsTestError error  : errors )
1:                 printError( error );
/////////////////////////////////////////////////////////////////////////
1:     private static  void    printError( NsTestError error )
1:         String          stackTrace = getStackTrace( throwable );
commit:5ccbc16
/////////////////////////////////////////////////////////////////////////
1:         Timestamp   firstOccurrenceTime = new Timestamp( error.getFirstOccurrenceTime() );
1:         Timestamp   lastOccurrenceTime = new Timestamp( error.getLastOccurrenceTime() );
/////////////////////////////////////////////////////////////////////////
1:         buffer.append( ERROR_BANNER2 );
1:         buffer.append( "First occurrence at " + firstOccurrenceTime );
1:         buffer.append( ", last occurrence at " + lastOccurrenceTime );
1:         buffer.append( "\n" );
1:         buffer.append( ERROR_BANNER2 );
1:         buffer.append( "\n" );
commit:5a56bcc
/////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  final   String  DEAD_CONNECTION = "08003";
/////////////////////////////////////////////////////////////////////////
1:     /** Return true if the connection is dead */
1:     public  static  boolean deadConnection( Throwable t )
1:     {
1:         if ( t instanceof SQLException )
1:         {
1:             SQLException    se = (SQLException) t;
1: 
1:             if ( DEAD_CONNECTION.equals( se.getSQLState() ) ) { return true; }
1:         }
1: 
1:         return false;
1:     }
1: 
commit:e225bfb
/////////////////////////////////////////////////////////////////////////
1: import java.util.Date;
/////////////////////////////////////////////////////////////////////////
1:     private static  long        _totalMemory;
1:     private static  long        _freeMemory;
1:     private static  Date        _lastMemoryCheckTime;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public  static  void    updateMemoryTracker
1:         ( long newTotalMemory, long newFreeMemory, Date newTimestamp )
1:     {
1:         _totalMemory = newTotalMemory;
1:         _freeMemory = newFreeMemory;
1:         _lastMemoryCheckTime = newTimestamp;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         statisticsLogger.println( "\nLast total memory = " + _totalMemory + ", last free memory = " + _freeMemory + " as measured at " + _lastMemoryCheckTime + "\n" );
1: 
/////////////////////////////////////////////////////////////////////////
1:             vetError( e );
/////////////////////////////////////////////////////////////////////////
1:         vetError( e );
1:     /**
1:      * Analyze an error which is being reported. Currently, all this
1:      * does is check for OutOfMemoryErrors. If we see an OutOfMemoryError,
1:      * we kill the JVM since we will just get cascading noise after we exhaust
1:      * memory.
1:      */
1:     private static  void    vetError( Throwable t )
1:     {
1:         if ( t == null ) { return; }
1:         
1:         if ( t instanceof OutOfMemoryError )
1:         {
1:             printStatistics();
1:             Runtime.getRuntime().halt( 0 );
1:         }
1: 
1:         vetError( t.getCause() );
1: 
1:         if ( t instanceof SQLException )
1:         {
1:             SQLException    sqlException = (SQLException) t;
1:             vetError( sqlException.getNextException() );
1:         }
1:     }
1: 
commit:777a463
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  DURATION = "derby.nstest.durationInMinutes";
/////////////////////////////////////////////////////////////////////////
1:         "    -D" + JUST_COUNT_ERRORS + "=true    Makes the test run quietly at steady-state, counting errors, and printing a summary at the end.\n" +
1:         "\n" +
1:         "    -D" + DURATION + "=$number    Run for this number of minutes.\n";
/////////////////////////////////////////////////////////////////////////
1:     private static  long    _duration;
1:     
/////////////////////////////////////////////////////////////////////////
1: 		String duration = System.getProperty( DURATION );
1:         if ( duration != null )
1:         {
1:             _duration = Long.parseLong( duration ) * MILLIS_PER_MINUTE;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		TimerThread timerThread = null;
1:         if ( _duration > 0L )
1:         {
1:             timerThread = new TimerThread( _duration );
1:             timerThread.start();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ( timerThread != null )
1:         {
1:             timerThread.stopNow();
1:             timerThread.interrupt();
1:             timerThread.join();
1:         }
1: 
1: 		sequenceReader.interrupt();
commit:b13fb1c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Timestamp;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.system.nstest.utils.SequenceReader;
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   long    MILLIS_PER_MINUTE = 1000L * 60L;
/////////////////////////////////////////////////////////////////////////
1:     private static  long        _maxSequenceCounter;
1:     private static  long        _startTimestamp;
1:     private static  long        _endTimestamp;
/////////////////////////////////////////////////////////////////////////
1:     public  static  void    updateSequenceTracker( long newValue )
1:     {
1:         _maxSequenceCounter = newValue;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         _startTimestamp = System.currentTimeMillis();
1: 
/////////////////////////////////////////////////////////////////////////
1: 			// Finally also stop the memory checker and sequence threads, else the test will
/////////////////////////////////////////////////////////////////////////
1: 		// check sequence value thread
1: 		// 60,000 msec = 1 minute delay between checks
1: 		logger.println("Starting sequence reader thread");
1: 		SequenceReader  sequenceReader = new SequenceReader( DriverManager.getConnection( jdbcUrl, prop ), 60000 );
1: 		sequenceReader.start();
1: 
/////////////////////////////////////////////////////////////////////////
1:         // stop the sequence reader thread
1: 		sequenceReader.stopNow = true;
1: 		sequenceReader.join();
1: 
/////////////////////////////////////////////////////////////////////////
1:         _endTimestamp = System.currentTimeMillis();
1: 
1: 		statisticsLogger.println("\n\n");
1: 		statisticsLogger.println( "Start time = " + (new Timestamp( _startTimestamp )).toString() );
1: 		statisticsLogger.println( "End time = " + (new Timestamp( _endTimestamp )).toString() );
1: 		statisticsLogger.println( "Duration = " + ( (_endTimestamp - _startTimestamp) / MILLIS_PER_MINUTE ) + " minutes" );
1: 		statisticsLogger.println("\n\n");
/////////////////////////////////////////////////////////////////////////
1:         statisticsLogger.println( "\nMax sequence counter peeked at = " + _maxSequenceCounter + "\n" );
1:         
commit:c043274
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.io.PrintStream;
1: import java.io.PrintWriter;
1: import java.io.StringWriter;
/////////////////////////////////////////////////////////////////////////
1: public class NsTest extends Thread
1: {
1:     private static  final   String  BACKUP_FLAG = "derby.nstest.backupRestore";
1:     private static  final   String  OUTPUT_FILE = "derby.nstest.outputFile";
1:     private static  final   String  JUST_COUNT_ERRORS = "derby.nstest.justCountErrors";
1:     private static  final   String  QUIET = "derby.nstest.quiet";
1:     
1:     private static  final   String  USAGE =
1:         "Usage:\n" +
1:         "\n" +
1:         "    java org.apache.derbyTesting.system.nstest.NsTest [ DerbyClient | Embedded [ small ] ]\n" +
1:         "\n" +
1:         "If no arguments are specified, the test defaults to a client/server configuration (DerbyClient)\n" +
1:         "\n" +
1:         "The following flags can be set:\n" +
1:         "\n" +
1:         "    -D" + BACKUP_FLAG + "=false    Turns off backup, restore, and re-encryption.\n" +
1:         "\n" +
1:         "    -D" + OUTPUT_FILE + "=fileName    Redirects output and errors to a file.\n" +
1:         "\n" +
0:         "    -D" + JUST_COUNT_ERRORS + "=true    Makes the test run quietly at steady-state, counting errors, and printing a summary at the end.\n";
1:     private static  final   String  ERROR_BANNER1 = "//////////////////////////////////////////////////////////////\n";
1:     private static  final   String  ERROR_BANNER2 = "//    ";
1:     
1:     
/////////////////////////////////////////////////////////////////////////
1:     /* where to log messages */
1:     private static  PrintStream         statisticsLogger;
1:     public static NsTestPrintStream   logger;
1:     
/////////////////////////////////////////////////////////////////////////
1:     private static  boolean _justCountErrors;
1:     private static  HashMap<String,NsTestError> _errors = new HashMap<String,NsTestError>();
1: 
1:     private static  boolean _statisticsAlreadyPrinted = false;
1: 
1: 
1:         if ( testThreads != null )
1:         {
1:             for (int i = 0; i < testThreads.length ; i++)
1:             {
1:                 if (testThreads[i] != null && testThreads[i].isAlive())
1:                     activeThreadCount++;
1:             }
1:         }
1:         
1:     public  static  boolean justCountErrors() { return _justCountErrors; }
1: 
1: 	public static synchronized void addError( Throwable t )
1:     {
1:         String  key = getStackTrace( t );
1: 
1:         NsTestError error = _errors.get( key );
1:         if ( error != null ) { error.increment(); }
1:         else
1:         {
1:             error = new NsTestError( t );
1:             _errors.put( key, error );
1:         }
1: 	}
1:     private static  String  getStackTrace( Throwable t )
1:     {
1:         StringWriter    sw = new StringWriter();
1:         PrintWriter     pw = new PrintWriter( sw );
1: 
1:         t.printStackTrace( pw );
1:         pw.flush();
1:         sw.flush();
1: 
1:         return sw.toString();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 	InterruptedException, Exception, Throwable
1:     {
1: 		String outputFile = System.getProperty( OUTPUT_FILE );
1:         statisticsLogger = System.out;
1:         if ( outputFile != null )
1:         {
1:             statisticsLogger = new PrintStream( outputFile );
1:         }
1: 
1:         _justCountErrors = Boolean.getBoolean( JUST_COUNT_ERRORS );
1: 
1:         logger = new NsTestPrintStream( statisticsLogger, !_justCountErrors );
1: 
1:         // add a shutdown hook to print statistics if someone types control-c to kill the test
1:         Runtime.getRuntime().addShutdownHook( new Thread( new ShutdownHook() ) );
/////////////////////////////////////////////////////////////////////////
1: 			logger.println("Test nstest starting....., using driver: "
/////////////////////////////////////////////////////////////////////////
1: 				logger.println("using small config");
/////////////////////////////////////////////////////////////////////////
1: 				// logger.println("Driver embedd : " + driver_type);
1: 				logger.println("Loading the embedded driver...");
1: 				logger.println("Driver type : " + driver_type);
1: 				logger.println("Loading the Derby Client driver..."
1: 				logger.println("Client Driver loaded");
/////////////////////////////////////////////////////////////////////////
1: 			logger
1: 			logger.println("JDBC url= " + jdbcUrl);
1: 			logger.println("\n\n " + sqe + sqe.getErrorCode() + " "
1: 				logger
1: 			logger.println("Driver not found: " + cnfe.getMessage());
1: 			cnfe.printStackTrace( logger );
1: 			e.printStackTrace( logger );
1: 			logger.println("Unexpected Failure");
1: 			logger.println("Error in dbSetup, test will exit");
/////////////////////////////////////////////////////////////////////////
1: 			logger
/////////////////////////////////////////////////////////////////////////
1: 		logger.println("Starting memory checker thread");
/////////////////////////////////////////////////////////////////////////
1: 			logger
/////////////////////////////////////////////////////////////////////////
1: 			logger
/////////////////////////////////////////////////////////////////////////
1: 			logger
/////////////////////////////////////////////////////////////////////////
1: 		logger
1: 		String runBackup = System.getProperty( BACKUP_FLAG );
/////////////////////////////////////////////////////////////////////////
1: 				logger.println("BackupRestore Thread not started...");
/////////////////////////////////////////////////////////////////////////
1: 		for (int j = 0; j < maxTestThreads; j++)
1:         {
1:             logger.println("Waiting for thread " + j+ " to join back/finish");
1:         printStatistics();
1: 		logger
1:     public  static  void    printStatistics()
1:     {
1:         if ( _statisticsAlreadyPrinted ) { return; }
1:         else { _statisticsAlreadyPrinted = true; }
1: 
1: 		statisticsLogger.println("");
1: 		statisticsLogger.println("STATISTICS OF OPERATIONS DONE");
1: 		statisticsLogger.println("-----------------------------");
1: 		statisticsLogger.println("");
1: 		statisticsLogger.println("SUCCESSFUL: ");
1: 		statisticsLogger.println("	Number of INSERTS = " + numInserts);
1: 		statisticsLogger.println("	Number of UPDATES = " + numUpdates);
1: 		statisticsLogger.println("	Number of DELETES = " + numDeletes);
1: 		statisticsLogger.println("	Number of SELECTS = " + numSelects);
1: 		statisticsLogger.println("");
1: 		statisticsLogger.println("FAILED: ");
1: 		statisticsLogger.println("	Number of failed INSERTS = " + numFailedInserts);
1: 		statisticsLogger.println("	Number of failed UPDATES = " + numFailedUpdates);
1: 		statisticsLogger.println("	Number of failed DELETES = " + numFailedDeletes);
1: 		statisticsLogger.println("	Number of failed SELECTS = " + numFailedSelects);
1: 		statisticsLogger.println("");
1: 		statisticsLogger.println("  Note that this may not be the same as the server side connections made\n"
1: 				+ "   to the database especially if connection pooling is employed");
1: 		statisticsLogger.println("");
1: 		statisticsLogger
1: 		.println("NOTE: Failing operations could be because of locking issue that are\n"
1: 				+ "directly related to the application logic.  They are not necessarily bugs.");
1: 
1:         if ( _errors.size() > 0 )
1:         {
1:             countAndPrintSQLStates();
1:             for ( String key  : _errors.keySet() )
1:             {
0:                 printError( key );
1:             }
1:         }
1:     }
1: 
1:     /** Count and print the number of times each SQLState was seen in an error */
1:     private static  void    countAndPrintSQLStates()
1:     {
1:         HashMap<String,int[]>   results = new HashMap<String,int[]>();
1: 
1:         // count the number of times each SQL state was seen
1:         for ( String key  : _errors.keySet() )
1:         {
1:             NsTestError error = _errors.get( key );
1:             int         count = error.count();
1:             Throwable   throwable = error.throwable();
1:             if ( throwable instanceof SQLException )
1:             {
1:                 SQLException    se = (SQLException) throwable;
1:                 String          sqlState = se.getSQLState();
1: 
1:                 if ( sqlState != null )
1:                 {
1:                     int[]   holder = results.get( sqlState );
1:                     if ( holder == null )
1:                     {
1:                         holder = new int[] { count };
1:                         results.put( sqlState, holder );
1:                     }
1:                     else { holder[ 0 ] += count; }
1:                 }
1:             }
1:         }
1: 
1:         // now print the counts
1:         statisticsLogger.println( "\n" );
1:         for ( String sqlState : results.keySet() )
1:         {
1:             statisticsLogger.println("	Number of " + sqlState + " = " + results.get( sqlState )[ 0 ] );
1:         }
1:         statisticsLogger.println( "\n" );
1:     }
1: 
0:     private static  void    printError( String key )
1:     {
0:         String          stackTrace = key;
1:         NsTestError error = _errors.get( key );
1:         Throwable   throwable = error.throwable();
1:         int             count = error.count();
1:         String      sqlState = (throwable instanceof SQLException) ? 
1:             ((SQLException) throwable).getSQLState() : null;
1: 
1:         StringBuilder   buffer = new StringBuilder();
1: 
1:         buffer.append( ERROR_BANNER1 );
1:         buffer.append( ERROR_BANNER2 );
1:         buffer.append( "\n" );
1:         buffer.append( ERROR_BANNER2 );
1:         buffer.append( "Count = " + count );
1:         if ( sqlState != null ) { buffer.append( ", SQLState = " + sqlState ); }
1:         buffer.append( ", Message = " + throwable.getMessage() );
1:         buffer.append( "\n" );
1:         buffer.append( ERROR_BANNER2 );
1:         buffer.append( "\n" );
1:         buffer.append( ERROR_BANNER1 );
1:         buffer.append( "\n" );
1:         buffer.append( stackTrace );
1:         buffer.append( "\n" );
1: 
1:         statisticsLogger.println( buffer.toString() );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		logger.println(this.getName() + " is now running");
/////////////////////////////////////////////////////////////////////////
1: 				logger
1: 				ioe.printStackTrace( logger );
1: 			logger
1: 			logger.println("You should check the code and restart");
1: 		logger.println(this.getName() + " finished and is now exiting");
/////////////////////////////////////////////////////////////////////////
1:     public static synchronized void printException(String where, Exception e)
1:     {
1:         if ( justCountErrors() )
1:         {
1:             addError( e );
1:             return;
1:         }
1:         
1: 					logger.println("deadlocked detected");
1: 					logger.println(" lock timeout exception");
1: 					logger.println(" duplicate key violation");
1: 				logger.println(se.getNextException().getMessage()
1: 			logger.println("NULL error message detected");
1: 			logger.println("Here is the NULL exection - " + e.toString());
1: 			logger.println("Stack trace of the NULL exception - ");
1: 			e.printStackTrace( logger );
1: 		logger.println("At this point - " + where
/////////////////////////////////////////////////////////////////////////
1: 			e.printStackTrace( logger );
1: 	public static void printUsage()
1:     {
1:         _statisticsAlreadyPrinted = true;
1:         System.out.println( USAGE );
1: 
1:     public  static  class   ShutdownHook    implements  Runnable
1:     {
1:         public  void    run()
1:         {
1:             NsTest.printStatistics();
1:         }
1:     }
1:     
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2f32608
/////////////////////////////////////////////////////////////////////////
1: 	public static int MAX_INITIAL_ROWS = 6000;
1: 	// num of rows worked over in a transaction
1: 	public static int MAX_LOW_STRESS_ROWS = 30; 
1: 	// num of transaction batches
1: 	public static int MAX_OPERATIONS_PER_CONN = 25; 
1: 	public static int NUMTESTER1 = 15;
1: 	public static int NUMTESTER2 = 45;
1: 	public static int NUMTESTER3 = 10;
1: 	public static int NUM_HIGH_STRESS_ROWS = 25000;
1: 	public static int NUM_UNTOUCHED_ROWS = 6000;
/////////////////////////////////////////////////////////////////////////
1: 		MAX_INITIAL_ROWS = 150; //for a small test
1: 		MAX_ITERATIONS = 50; //for a small test
1: 		MAX_LOW_STRESS_ROWS = 10; //for a small test
1: 		MAX_OPERATIONS_PER_CONN = 10; //for a small test
1: 		NUM_HIGH_STRESS_ROWS = 20; //for a small test
/////////////////////////////////////////////////////////////////////////
1: 			String testConfiguration = args [1];
1: 			if (testConfiguration.equalsIgnoreCase("small"))
1: 			{
0: 				System.out.println("using small config");
1: 				setSmallConfig();
1: 			}    
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		int maxTestThreads = 0;
0: 		String runBackup = System.getProperty("derby.nstest.backupRestore");
1: 		if ((runBackup != null) && (runBackup.equalsIgnoreCase("false")))
1: 				maxTestThreads = NUMTESTER1 + NUMTESTER2 + NUMTESTER3;
1: 		else
1: 				maxTestThreads = 1 + NUMTESTER1 + NUMTESTER2 + NUMTESTER3;
/////////////////////////////////////////////////////////////////////////
commit:e276048
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	// also needs to be started as a thread
1: 	// Default configuration; can be overwritten by
1: 	// adding the argument 'small' to the call of this class - 
1: 	// see setSmallConfig()
/////////////////////////////////////////////////////////////////////////
1:     
1: 	private static NsTest[] testThreads = null;
1: 
1: 	public static int numActiveTestThreads() {
1: 		int activeThreadCount=0;
0: 		for (int i = 0; i < testThreads.length ; i++)
0: 		{
0: 			if (testThreads[i] != null && testThreads[i].isAlive())
0: 			activeThreadCount++;
1: 		}
1: 		return activeThreadCount;
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 	private static void setSmallConfig() {
1:         
1: 		INIT_THREADS = 3; //keep this low to avoid deadlocks
0: 		MAX_INITIAL_ROWS = 150; //for a small test public
0: 		MAX_ITERATIONS = 50; //for a small test public static int
0: 		MAX_LOW_STRESS_ROWS = 10; //for a small test public static int
0: 		MAX_OPERATIONS_PER_CONN = 10; //for a small test public static int
1: 		NUMTESTER1 = 3; //for a small test 
1: 		NUMTESTER2 = 4;//for a small test
1: 		NUMTESTER3 = 3; //for a small test
0: 		NUM_HIGH_STRESS_ROWS = 20; //for a small test public
1: 		NUM_UNTOUCHED_ROWS = 50; //for a small test
1: 	}
1:     
/////////////////////////////////////////////////////////////////////////
1: 		if (args.length >= 1) {
/////////////////////////////////////////////////////////////////////////
1: 		if (args.length >= 2) {
0: 		String testConfiguration = args [1];
0: 		if (testConfiguration.equalsIgnoreCase("small"))
0: 		{
0: 			System.out.println("using small config");
0: 			setSmallConfig();
1: 		}    
1: 	}
1:         
/////////////////////////////////////////////////////////////////////////
1: 		// the schemaCreated flag has not been set. If so, then we assume that 
1: 		// some other thread from possibly another jvm reached here and has
1: 		// already created the schema and loaded the tables.
1: 		// the run method to do the work. The key to starting the init threads
1: 		// is the use of the constructor to indicate to the thread that it is
1: 		// an init thread. In this case, we pass the value INIT to the
1: 		// constructor and in the run method we go to the right section of the
1: 		// a thread can get is TESTER which indicates that these are the main 
1: 		// test threads.
/////////////////////////////////////////////////////////////////////////
1: 		// database that can be used as a reference so that subsequent tests do
1: 		// not need to create one of their own.
/////////////////////////////////////////////////////////////////////////
1: 		// Note that we use the value TESTER when initializing the threads.
1: 		testThreads = new NsTest[maxTestThreads];
/////////////////////////////////////////////////////////////////////////
1: 		// Wait for the test threads to finish and join back
/////////////////////////////////////////////////////////////////////////
0: 		System.out.println("  Note that this may not be the same as the server side connections made\n"
0: 		.println("NOTE: Failing operations could be because of locking issue that are\n"
/////////////////////////////////////////////////////////////////////////
1: 	// initialize the table data or work over it as part of the test process.
1: 	// different types based on the following criteria
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5dcbe31
/////////////////////////////////////////////////////////////////////////
1: 		if (e.getMessage() == null) {
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:cb47a36
/////////////////////////////////////////////////////////////////////////
1: 			if ((sqe.getErrorCode() == 40000)
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:b8d1d8a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:  Derby - Class org.apache.derbyTesting.system.nstest.NsTest
1: 
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
1: 
1:  http://www.apache.org/licenses/LICENSE-2.0
1: 
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.system.nstest;
1: 
1: import java.util.Properties;
1: import java.sql.SQLException;
1: import java.sql.DriverManager;
1: import java.io.IOException;
1: import java.sql.Connection;
1: 
1: import org.apache.derbyTesting.system.nstest.init.DbSetup;
1: import org.apache.derbyTesting.system.nstest.init.Initializer;
1: import org.apache.derbyTesting.system.nstest.init.NWServerThread;
1: import org.apache.derbyTesting.system.nstest.tester.BackupRestoreReEncryptTester;
1: import org.apache.derbyTesting.system.nstest.tester.Tester1;
1: import org.apache.derbyTesting.system.nstest.tester.Tester2;
1: import org.apache.derbyTesting.system.nstest.tester.Tester3;
1: import org.apache.derbyTesting.system.nstest.utils.MemCheck;
1: 
1: /**
1:  * NsTest - the main class to start the tests The main test settings are as
1:  * follows: INIT_THREADS = Initializer threads MAX_INITIAL_ROWS = Initial set of
1:  * rows inserted before test begins MAX_ITERATIONS = Each client does these many
1:  * transactions in the test MAX_LOW_STRESS_ROWS = Num of rows worked over in a
1:  * transaction MAX_OPERATIONS_PER_CONN = Num of transaction batches made by a
1:  * client before closing the connection NUMTESTER1 = Number of Tester1 testers
1:  * NUMTESTER2 = Number of Tester2 testers NUMTESTER3 = Number of Tester3 testers
1:  * NUM_HIGH_STRESS_ROWS = Maximum rows to be selected NUM_UNTOUCHED_ROWS =
1:  * Number of rows on which Update/Delete operations are not performed
1:  *
1:  * START_SERVER_IN_SAME_VM= Set to true/false to start Network Server in the
1:  * same VM.
1:  *
1:  * The System property 'derby.nstest.backupRestore' can be set to false for
1:  * turning off Backup/Restore/Re-Encryption.
1:  */
1: 
0: public class NsTest extends Thread {
1: 
1: 	public static final String dbName = "nstestdb";
1: 
1: 	public static final String user = "nstest";
1: 
1: 	public static final String password = "nstest";
1: 
1: 	public static final String clientURL = "jdbc:derby://localhost:1900/";
1: 
1: 	public static final String embedURL = "jdbc:derby:";
1: 
1: 	public static final String dataEncypt = "dataEncryption=true";
1: 
1: 	public static final String bootPwd = "bootPassword=12345678";
1: 
1: 	public static final String clientDbURL = new String(clientURL + dbName
1: 			+ ";create=true");
1: 
1: 	public static final String retrieveMessagePart = "retrieveMessagesFromServerOnGetMessage=true;";
1: 
1: 	public static final String embedDbURL = new String(embedURL + dbName
1: 			+ ";create=true");
1: 
1: 	public static boolean embeddedMode = false; // true is to run the test in
1: 
1: 	// embedded mode
1: 
1: 	public static final String driver = new String(
1: 	"org.apache.derby.jdbc.ClientDriver");
1: 
1: 	public static final String embedDriver = new String(
1: 	"org.apache.derby.jdbc.EmbeddedDriver");
1: 
1: 	public static Properties prop = new Properties();
1: 
1: 	public static int INIT = 0;
1: 
1: 	public static int TESTER1 = 1;
1: 
1: 	public static int TESTER2 = 2;
1: 
1: 	public static int TESTER3 = 3;
1: 
1: 	public static int BACKUP = 4;
1: 
1: 	public static String BACKUPDIR = "backupdir";
1: 
1: 	public static String RESTOREDIR = "restoredir";
1: 
1: 	public static boolean START_SERVER_IN_SAME_VM = false;// If the server
1: 
0: 	// also needs to be
0: 	// started as a
0: 	// thread
1: 
1: 	public static boolean AUTO_COMMIT_OFF = false; // true is autocommit off
1: 
1: 	public static boolean CREATE_DATABASE_ONLY = false;
1: 
1: 	public static boolean schemaCreated = false; // initially schema is
1: 
1: 	// assumed to not exist
1: 
0: 	// *********Uncomment this block for a small test scenario, comment it for
0: 	// full testing
1: 	/*
0: 	 * public static int INIT_THREADS = 3; //keep this low to avoid deadlocks
0: 	 * public static int MAX_INITIAL_ROWS = 150; //for a small test public
0: 	 * static int MAX_ITERATIONS = 50; //for a small test public static int
0: 	 * MAX_LOW_STRESS_ROWS = 10; //for a small test public static int
0: 	 * MAX_OPERATIONS_PER_CONN = 10; //for a small test public static int
0: 	 * NUMTESTER1 = 3; //for a small test public static int NUMTESTER2 = 4;
0: 	 * //for a small test public static int NUMTESTER3 = 3; //for a small test
0: 	 * public static int NUM_HIGH_STRESS_ROWS = 20; //for a small test public
0: 	 * static int NUM_UNTOUCHED_ROWS = 50; //for a small test
1: 	 */
0: 	// ***End of small test scenario block
0: 	// ****Comment this block for a small test scenario, uncomment it for full
0: 	// testing
1: 	public static int INIT_THREADS = 6; // keep this low to avoid deadlocks
1: 
0: 	// public static int MAX_INITIAL_ROWS = 60000; //for network server mode
0: 	public static int MAX_INITIAL_ROWS = 6000; // for network server mode
1: 
1: 	public static int MAX_ITERATIONS = 2000; // Each client does these many
1: 
1: 	// transactions in the test.
1: 
0: 	// for network server mode
0: 	public static int MAX_LOW_STRESS_ROWS = 30; // num of rows worked over in a
1: 
0: 	// transaction
1: 
0: 	// for network server mode
0: 	public static int MAX_OPERATIONS_PER_CONN = 25; // num of transaction
1: 
0: 	// batches made by a client
1: 
0: 	// before closing the connection
0: 	// for network server mode
0: 	public static int NUMTESTER1 = 15; // for network server mode
1: 
0: 	// ***public static int NUMTESTER1 = 45; //for embedded mode
0: 	public static int NUMTESTER2 = 45; // for network server mode
1: 
0: 	// ***public static int NUMTESTER2 = 135; //for embedded server mode
0: 	public static int NUMTESTER3 = 10; // for network server mode
1: 
0: 	// ***public static int NUMTESTER3 = 30; //for network server mode
0: 	public static int NUM_HIGH_STRESS_ROWS = 25000; // for network server mode
1: 
0: 	public static int NUM_UNTOUCHED_ROWS = 6000; // for network server mode
1: 
1: 	// ***End of full test block
1: 
1: 	// The following are to keep statistics of the number of
1: 	// Insert/Updates/Deletes & Selects
1: 	public static int numInserts = 0;
1: 
1: 	public static int numUpdates = 0;
1: 
1: 	public static int numDeletes = 0;
1: 
1: 	public static int numSelects = 0;
1: 
1: 	public static int numFailedInserts = 0;
1: 
1: 	public static int numFailedUpdates = 0;
1: 
1: 	public static int numFailedDeletes = 0;
1: 
1: 	public static int numFailedSelects = 0;
1: 
1: 	public static int numConnections = 0;
1: 
1: 	public static int INSERT = 0;
1: 
1: 	public static int UPDATE = 1;
1: 
1: 	public static int DELETE = 2;
1: 
1: 	public static int SELECT = 3;
1: 
1: 	public static int FAILED_INSERT = 4;
1: 
1: 	public static int FAILED_UPDATE = 5;
1: 
1: 	public static int FAILED_DELETE = 6;
1: 
1: 	public static int FAILED_SELECT = 7;
1: 
1: 	public static int CONNECTIONS_MADE = 8;
1: 
1: 	public static final String SUCCESS = " *** SUCCESS *** ";
1: 
1: 	public static String driver_type = null;
1: 
1: 	private int type;
1: 
1: 	public static synchronized void addStats(int type, int addValue) {
1: 		switch (type) {
1: 		case 0:
1: 			numInserts += addValue;
1: 			break;
1: 		case 1:
1: 			numUpdates += addValue;
1: 			break;
1: 		case 2:
1: 			numDeletes += addValue;
1: 			break;
1: 		case 3:
1: 			numSelects += addValue;
1: 			break;
1: 		case 4:
1: 			numFailedInserts += addValue;
1: 			break;
1: 		case 5:
1: 			numFailedUpdates += addValue;
1: 			break;
1: 		case 6:
1: 			numFailedDeletes += addValue;
1: 			break;
1: 		case 7:
1: 			numFailedSelects += addValue;
1: 			break;
1: 		case 8:
1: 			numConnections += addValue;
1: 			break;
1: 		}
1: 	}
1: 
1: 	NsTest(int ttype, int k) throws Exception {
1: 		this.type = ttype; // INIT or TESTER1/2/3
1: 
1: 		if (ttype == INIT)
1: 			this.setName("InitThread " + k);
1: 		else if ((ttype == TESTER1) || (ttype == TESTER2) || (ttype == TESTER3))
1: 			this.setName("Thread " + k);
1: 	}
1: 
1: 	// ****************************************************************************
1: 	//
1: 	// main - will load the Derby embedded or client, invoke the
1: 	// database setup, initialize the
1: 	// tables and then kick off the test threads.
1: 	//
1: 	// ****************************************************************************
1: 	public static void main(String[] args) throws SQLException, IOException,
0: 	InterruptedException, Exception, Throwable {
1: 
1: 		Connection conn = null;
0: 		if (args.length == 1) {
1: 			driver_type = args[0];
1: 			if (!((driver_type.equalsIgnoreCase("DerbyClient"))
1: 					|| (driver_type
1: 							.equalsIgnoreCase("Embedded")))) {
1: 				printUsage();
1: 				return;
1: 			}
0: 			System.out.println("Test nstest starting....., using driver: "
1: 					+ driver_type);
1: 		} else {
1: 			driver_type = "DerbyClient";
1: 		}
1: 
1: 		// Load the driver and get a connection to the database
1: 		String jdbcUrl = "";
1: 		try {
1: 			if (driver_type.equalsIgnoreCase("Embedded")) {
0: 				// System.out.println("Driver embedd : " + driver_type);
0: 				System.out.println("Loading the embedded driver...");
0: 				Class.forName(embedDriver).newInstance();
1: 				jdbcUrl = embedDbURL + ";" + dataEncypt + ";" + bootPwd;
1: 				embeddedMode = true;
1: 			} else {
0: 				System.out.println("Driver type : " + driver_type);
0: 				System.out.println("Loading the Derby Client driver..."
1: 						+ driver);
0: 				Class.forName(driver).newInstance();
0: 				System.out.println("Client Driver loaded");
1: 				jdbcUrl = clientDbURL + ";" + dataEncypt + ";" + bootPwd;
1: 			}
1: 			if ((!embeddedMode) && START_SERVER_IN_SAME_VM) {
1: 				startNetworkServer();
1: 			}
1: 			prop.setProperty("user", user);
1: 			prop.setProperty("password", password);
0: 			System.out
1: 			.println("Getting a connection using the url: " + jdbcUrl);
0: 			System.out.println("JDBC url= " + jdbcUrl);
1: 			conn = DriverManager.getConnection(jdbcUrl, prop);
1: 
1: 		} catch (SQLException sqe) {
1: 
0: 			System.out.println("\n\n " + sqe + sqe.getErrorCode() + " "
1: 					+ sqe.getSQLState());
0: 			if ((sqe.getErrorCode() == -4499)
1: 					|| sqe.getSQLState().equalsIgnoreCase("08001")) {
0: 				System.out
1: 				.println("\n Unable to connect, test cannot proceed. Please verify if the Network Server is started on port 1900.");
1: 				// sqe.printStackTrace();
1: 				return;
1: 			}
1: 
1: 		} catch (ClassNotFoundException cnfe) {
0: 			System.out.println("Driver not found: " + cnfe.getMessage());
0: 			cnfe.printStackTrace();
1: 			return;
1: 
1: 		} catch (Exception e) {
0: 			e.printStackTrace();
0: 			System.out.println("Unexpected Failure");
1: 			printException("nstest.main() method ==> ", e);
1: 		}
1: 
1: 		// create test schema if it does not already exist
1: 		if (DbSetup.doIt(conn) == false) {
0: 			System.out.println("Error in dbSetup, test will exit");
1: 			System.exit(1);
1: 		}
1: 
1: 		// Note that the connection is still open, we can safely close it now
1: 		try {
1: 			conn.close();
1: 		} catch (Exception e) {
0: 			System.out
1: 			.println("FAIL - Error closing the connection in nstest.main():");
1: 			printException("Closing connection in nstest.main()", e);
1: 		}
1: 
1: 		// check memory in separate thread-- allows us to monitor usage during
1: 		// database calls
1: 		// 200,000 msec = 3min, 20 sec delay between checks
0: 		System.out.println("Starting memory checker thread");
1: 		MemCheck mc = new MemCheck(200000);
1: 		mc.start();
1: 
1: 		// Now populate the tables using INIT_THREADS number of threads only if
0: 		// the schemaCreated
0: 		// flag has not been set. If so, then we assume that some other thread
0: 		// from possibly
0: 		// another jvm reached here and has already created the schema and
0: 		// loaded the tables.
1: 		// Note that we kick off threads of this object type (nstest) and use
0: 		// the run method to
0: 		// do the work. The key to starting the init threads is the use of the
0: 		// constructor
0: 		// to indicate to the thread that it is an init thread. In this case, we
0: 		// pass the
0: 		// value INIT to the constructor and in the run method we go to the
0: 		// right section of the
1: 		// code based on what value is passed in. The other possible value that
0: 		// a thread can get
0: 		// is TESTER which indicates that these are the main test threads.
1: 
1: 		if (NsTest.schemaCreated == false) {
1: 			// Table was created by this object, so we need to load it
0: 			System.out
1: 			.println("Kicking off initialization threads that will populate the test table");
1: 			NsTest initThreads[] = new NsTest[INIT_THREADS];
1: 
1: 			for (int i = 0; i < INIT_THREADS; i++) {
1: 				initThreads[i] = new NsTest(INIT, i);
1: 				initThreads[i].start();
1: 				sleep(3000);
1: 			}
1: 
1: 			// Wait for the init threads to finish and join back
1: 			for (int i = 0; i < INIT_THREADS; i++) {
1: 				initThreads[i].join();
1: 			}
1: 		}// end of if(nstest.schemaCreated==false)
1: 
1: 		// For informational/debug purposes, print out whether this process
1: 		// created the schema
1: 		if (NsTest.schemaCreated) // true means that the schema was created by
1: 			// another jvm
0: 			System.out
1: 			.println("Schema has already been created by another process!");
1: 
1: 		// The following 2 lines are used when you want to only create the test
0: 		// database that can be
0: 		// used as a reference so that subsequent tests do not need to create
0: 		// one of their own.
1: 		// The CREATE_DATABASE_ONLY FLAG is set with the rest of the flags
1: 		if (CREATE_DATABASE_ONLY) {
0: 			System.out
1: 			.println("Finished creating the database, TEST THREADS WILL NOT RUN!!");
0: 			// Finally also stop the memory checker thread, else the test will
1: 			// remain hung!
1: 			mc.stopNow = true;
1: 			mc.join();
1: 			return;
1: 		}
1: 
1: 		// Table was created by some other object, so we assume it is already
1: 		// loaded
1: 		// Now kick off the actual test threads that will do the work for us.
0: 		// Note that we use
0: 		// the value TESTER when initializing the threads.
1: 		// The total number of threads is NUMTESTER1+NUMTESTER2+NUMTESTER3
0: 		System.out
1: 		.println("Kicking off test threads that will work over the test table");
1: 
1: 		int numTestThread = 0;
0: 		int maxTestThreads = 1 + NUMTESTER1 + NUMTESTER2 + NUMTESTER3;
0: 		NsTest testThreads[] = new NsTest[maxTestThreads];
1: 
1: 		// This loop is made of 3 subloops that will initialize the required
1: 		// amount of tester threads
1: 		// It uses the numTestThread variable as the array index which gets
1: 		// incremented in each subloop
1: 		while (numTestThread < maxTestThreads) {
0: 			String runBackup = System.getProperty("derby.nstest.backupRestore");
1: 			// Check for property setting to decide the need for starting
1: 			// BackupRestore thread
1: 			if ((runBackup != null) && (runBackup.equalsIgnoreCase("false"))) {
0: 				System.out.println("BackupRestore Thread not started...");
1: 			} else {
1: 				// Otherwise, start the BackupRestore Thread by default
1: 				testThreads[numTestThread] = new NsTest(BACKUP, numTestThread);
1: 				testThreads[numTestThread].start();
1: 				numTestThread++;
1: 			}
1: 
1: 			for (int j = 0; j < NUMTESTER1; j++) {
1: 				testThreads[numTestThread] = new NsTest(TESTER1, numTestThread);
1: 				testThreads[numTestThread].start();
1: 				sleep(3000);
1: 				numTestThread++;
1: 			}
1: 			for (int j = 0; j < NUMTESTER2; j++) {
1: 				testThreads[numTestThread] = new NsTest(TESTER2, numTestThread);
1: 				testThreads[numTestThread].start();
1: 				sleep(3000);
1: 				numTestThread++;
1: 			}
1: 			for (int j = 0; j < NUMTESTER3; j++) {
1: 				testThreads[numTestThread] = new NsTest(TESTER3, numTestThread);
1: 				testThreads[numTestThread].start();
1: 				sleep(3000);
1: 				numTestThread++;
1: 			}
1: 
1: 		}
1: 
1: 		// Wait for the init threads to finish and join back
0: 		for (int j = 0; j < maxTestThreads; j++) {
0: 			System.out.println("Waiting for thread " + j
0: 					+ " to join back/finish");
1: 			testThreads[j].join();
1: 		}
1: 
1: 		// Print statistics
0: 		System.out.println("");
0: 		System.out.println("STATISTICS OF OPERATIONS DONE");
0: 		System.out.println("-----------------------------");
0: 		System.out.println("");
0: 		System.out.println("SUCCESSFUL: ");
0: 		System.out.println("	Number of INSERTS = " + numInserts);
0: 		System.out.println("	Number of UPDATES = " + numUpdates);
0: 		System.out.println("	Number of DELETES = " + numDeletes);
0: 		System.out.println("	Number of SELECTS = " + numSelects);
0: 		System.out.println("");
0: 		System.out.println("FAILED: ");
0: 		System.out.println("	Number of failed INSERTS = " + numFailedInserts);
0: 		System.out.println("	Number of failed UPDATES = " + numFailedUpdates);
0: 		System.out.println("	Number of failed DELETES = " + numFailedDeletes);
0: 		System.out.println("	Number of failed SELECTS = " + numFailedSelects);
0: 		System.out.println("");
0: 		System.out.println("  Note that this may not be the same as the server side connections made "
0: 				+ "   to the database especially if connection pooling is employed");
0: 		System.out.println("");
0: 		System.out
0: 		.println("NOTE: Failing operations could be because of locking issue that are "
0: 				+ "directly related to the application logic.  They are not necessarily bugs.");
1: 
1: 		// Finally also stop the memory checker thread
1: 		mc.stopNow = true;
1: 		mc.join();
1: 
0: 		System.out
1: 		.println("End of test nstest! Look for 'FAIL' messages in the output and derby.log");
1: 
1: 	}// end of main
1: 
1: 	// ****************************************************************************
1: 	//
1: 	// run() - the main workhorse method of the threads that will either
0: 	// initialize
0: 	// the table data or work over it as part of the test process.
1: 	// Table data initialization threads are of the following type
1: 	// Initializer -
1: 	// Bulk Insert client type that deals with a large(stress)
1: 	// number of rows with the connection being closed after the insert.
1: 	// Max rows inserted is based on the parameter MAX_INITIAL_ROWS
1: 	// Note that the run method will also instantiate tester objects of
0: 	// different
0: 	// types based on the following criteria
1: 	// Tester1 -
1: 	// The connection to the database is open forever. This client
1: 	// will do Insert/Update/Delete and simple Select queries over
1: 	// a small to medium set of data determined randomly as 1 row to
1: 	// MAX_LOW_STRESS_ROWS. Autocommit is left on.
1: 	// Tester2 -
1: 	// The connection is frequently opened and closed based on
1: 	// a random choice between 1 and MAX_OPERATIONS_PER_CONN number of
1: 	// transaction batches committed by this client type. This client will
1: 	// do Insert/Update/Delete and simple Select queries over a
1: 	// small to medium set of data determined randomly as 1 row to
1: 	// MAX_LOW_STRESS_ROWS.
1: 	// Tester3 -
1: 	// Query only kind of client that deals with a large result
1: 	// set based on a select query that returns a large number of
1: 	// rows (stress condition). Connection is closed after each
1: 	// query. The query will need to run in a DIRTY_READ mode, i.e.
1: 	// READ UNCOMMITTED isolation level. We work over the untouched
1: 	// portion of rows in the table (i.e. serialkey 1 to NUM_UNTOUCHED_ROWS)
1: 	//
1: 	// The mix of the tester types is based on the parameters NUMTESTER1,
1: 	// NUMTESTER2, NUMTESTER3.
1: 	//
1: 	//
1: 	// ****************************************************************************
1: 	public void run() {
1: 
0: 		System.out.println(this.getName() + " is now running");
1: 
1: 		if (this.type == INIT) {
1: 			Initializer Init = new Initializer(this.getName());
1: 			Init.startInserts(); // this method only returns when the thread
1: 			// is done
1: 		} else if (this.type == TESTER1) {
1: 			Tester1 Tstr1 = new Tester1("Tester1" + this.getName());
1: 			Tstr1.startTesting(); // this method only returns when the thread
1: 			// is done
1: 		} else if (this.type == TESTER2) {
1: 			Tester2 Tstr2 = new Tester2("Tester2" + this.getName());
1: 			Tstr2.startTesting(); // this method only returns when the thread
1: 			// is done
1: 		} else if (this.type == TESTER3) {
1: 			Tester3 Tstr3 = new Tester3("Tester3" + this.getName());
1: 			Tstr3.startTesting(); // this method only returns when the thread
1: 			// is done
1: 		} else if (this.type == BACKUP) {
1: 			BackupRestoreReEncryptTester Tstr4 = null;
1: 			try {
1: 				Tstr4 = new BackupRestoreReEncryptTester(
1: 						"BackupRestoreReEncrypt" + this.getName());
1: 			} catch (IOException ioe) {
0: 				System.out
1: 				.println(ioe
1: 						+ "=====> Unable to create backup log file, test cannot proceed ");
0: 				ioe.printStackTrace();
1: 				return;
1: 			}
1: 			Tstr4.startTesting();
1: 
1: 		} else {
0: 			System.out
1: 			.println("FAIL: Invalid thread type, should be INIT or TESTERx or BACKUP");
0: 			System.out.println("You should check the code and restart");
1: 			return;
1: 		}
1: 
0: 		System.out.println(this.getName() + " finished and is now exiting");
1: 
1: 	}// end of run()
1: 
1: 	// ** This method abstracts exception message printing for all exception
1: 	// messages. You may want to change
1: 	// ****it if more detailed exception messages are desired.
1: 	// ***Method is synchronized so that the output file will contain sensible
1: 	// stack traces that are not
1: 	// ****mixed but rather one exception printed at a time
0: 	public static synchronized void printException(String where, Exception e) {
1: 		if (e instanceof SQLException) {
1: 			SQLException se = (SQLException) e;
1: 			if (se.getSQLState() != null) { // SQLSTATE is NULL for a
1: 				if (se.getSQLState().equals("40001"))
0: 					System.out.println("deadlocked detected");
1: 				if (se.getSQLState().equals("40XL1"))
0: 					System.out.println(" lock timeout exception");
1: 				if (se.getSQLState().equals("23500"))
0: 					System.out.println(" duplicate key violation");
1: 			}
1: 			if (se.getNextException() != null) {
1: 				String m = se.getNextException().getSQLState();
0: 				System.out.println(se.getNextException().getMessage()
1: 						+ " SQLSTATE: " + m);
1: 			}
1: 		}
0: 		if (e.getMessage().equals(null)) {
0: 			System.out.println("NULL error message detected");
0: 			System.out.println("Here is the NULL exection - " + e.toString());
0: 			System.out.println("Stack trace of the NULL exception - ");
0: 			e.printStackTrace(System.out);
1: 		}
0: 		System.out.println("At this point - " + where
1: 				+ ", exception thrown was : " + e.getMessage());
1: 
1: 	}
1: 
1: 	public static String getDriverURL() {
1: 		if (driver_type.equalsIgnoreCase("DerbyClient")) {
1: 			return clientURL;
1: 		} else {
1: 			return embedURL;
1: 		}
1: 	}
1: 
1: 	public static void startNetworkServer() throws Exception {
1: 		try {
1: 			NWServerThread nsw = new NWServerThread("localhost", 1900);
1: 			nsw.start();
1: 			Thread.sleep(10000);
1: 		} catch (Exception e) {
0: 			e.printStackTrace();
1: 			throw e;
1: 		}
1: 
1: 	}
1: 
0: 	public static void printUsage() {
0: 		System.out.println("Usage:");
0: 		System.out
0: 		.println("java org.apache.derbyTesting.system.nstest.NsTest DerbyClient|Embedded");
0: 		System.out.println("\nNo argument/Default value is 'DerbyClient'");
1: 	}
1: }
============================================================================