1:a86bac7: /*
62:a86bac7: 
1:a86bac7:    Derby - Class 
1:a86bac7:        org.apache.derbyTesting.functionTests.tests.jdbcapi.BatchUpdateTest
1:a86bac7: 
1:a86bac7:    Licensed to the Apache Software Foundation (ASF) under one or more
1:a86bac7:    contributor license agreements.  See the NOTICE file distributed with
1:a86bac7:    this work for additional information regarding copyright ownership.
1:a86bac7:    The ASF licenses this file to You under the Apache License, Version 2.0
1:a86bac7:    (the "License"); you may not use this file except in compliance with
1:a86bac7:    the License.  You may obtain a copy of the License at
1:a86bac7: 
1:a86bac7:       http://www.apache.org/licenses/LICENSE-2.0
1:a86bac7: 
1:a86bac7:    Unless required by applicable law or agreed to in writing, software
1:a86bac7:    distributed under the License is distributed on an "AS IS" BASIS,
1:a86bac7:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a86bac7:    See the License for the specific language governing permissions and
1:a86bac7:    limitations under the License.
1:a86bac7: 
7:a86bac7:  */
1:a86bac7: 
1:a86bac7: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:a86bac7: 
1:465c7c7: import java.io.PrintWriter;
1:465c7c7: import java.io.StringWriter;
1:b54918e: import java.lang.reflect.Method;
1:a86bac7: import java.sql.BatchUpdateException;
1:a86bac7: import java.sql.CallableStatement;
1:a86bac7: import java.sql.Connection;
1:a86bac7: import java.sql.Date;
1:a86bac7: import java.sql.PreparedStatement;
1:a86bac7: import java.sql.ResultSet;
1:a86bac7: import java.sql.SQLException;
1:d3fbd72: import java.sql.SQLWarning;
1:a86bac7: import java.sql.Statement;
1:a86bac7: import java.sql.Time;
1:a86bac7: import java.sql.Timestamp;
1:a86bac7: import java.sql.Types;
1:0225aac: import java.util.Arrays;
1:a86bac7: import junit.framework.Test;
1:a86bac7: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a86bac7: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:a86bac7: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:a86bac7: import org.apache.derbyTesting.junit.JDBC;
1:a86bac7: import org.apache.derbyTesting.junit.TestConfiguration;
1:a86bac7: 
7:a86bac7: /**
1:a86bac7:  * Test BatchUpdate functionality.
1:a86bac7:  * <P>
1:a86bac7:  * This test examines the behavior fo BatchUpdate test.
1:b8c1e09:  * One fixture tests creating tables in batch, the other fixtures can be grouped
1:b8c1e09:  * into 5 rough categories:
1:b8c1e09:  *  - tests that verify that correct usage with Statements work as expected
1:b8c1e09:  *    - testEmptyStatementBatch()
1:b8c1e09:  *      try executing a batch which nothing in it.
1:b8c1e09:  *    - testSingleStatementBatch()
1:b8c1e09:  *      try executing a batch which one statement in it.
1:b8c1e09:  *    - testMultipleStatementsBatch()
1:b8c1e09:  *      try executing a batch with 3 different statements in it.
1:b8c1e09:  *    - test1000StatementsBatch()
1:b8c1e09:  *      try executing a batch with 1000 statements in it.
1:b8c1e09:  *    - testAutoCommitTrueBatch()
1:b8c1e09:  *      try batch with autocommit true
1:b8c1e09:  *    - testCombinationsOfClearBatch()
1:b8c1e09:  *      try clear batch
1:b8c1e09:  *    - testAssociatedParams()
1:b8c1e09:  *      confirm associated parameters run ok with batches
1:b8c1e09:  *   
1:b8c1e09:  *  - tests that verify that incorrect usage with Statments give appropriate
1:b8c1e09:  *    errors
1:b8c1e09:  *    - testStatementWithResultSetBatch()
1:b8c1e09:  *      statements which will return a resultset are not allowed in batch
1:b8c1e09:  *      update. The following case should throw an exception for select.
1:b8c1e09:  *      Below trying various placements of select statement in the batch,
1:b8c1e09:  *      i.e. as 1st stmt, nth stmt and last stmt
1:b8c1e09:  *    - testStatementNonBatchStuffInBatch()
1:b8c1e09:  *      try executing a batch with regular statement intermingled.
1:b8c1e09:  *    - testStatementWithErrorsBatch()
1:b8c1e09:  *      Below trying various placements of overflow update statement
1:b8c1e09:  *      in the batch, i.e. as 1st stmt, nth stat and last stmt
1:b8c1e09:  *    - testTransactionErrorBatch()
1:b8c1e09:  *      try transaction error, i.e. time out while getting the lock
1:b8c1e09:  *    
1:b8c1e09:  *  - tests that verify that usage with callableStatements work as expected
1:b8c1e09:  *    - testCallableStatementBatch()
1:b8c1e09:  *      try callable statements
1:b8c1e09:  *    - testCallableStatementWithOutputParamBatch()
1:b8c1e09:  *      try callable statement with output parameters
1:b8c1e09:  *      
1:b8c1e09:  *  - tests that verify that correct usage with preparedStatements work as
1:b8c1e09:  *    expected
1:b8c1e09:  *    - testEmptyValueSetPreparedBatch()
1:b8c1e09:  *      try executing a batch which nothing in it.
1:b8c1e09:  *    - testNoParametersPreparedBatch()
1:b8c1e09:  *      try executing a batch with no parameters. 
1:b8c1e09:  *    - testSingleValueSetPreparedBatch()
1:b8c1e09:  *      try executing a batch which one parameter set in it.
1:b8c1e09:  *    - testMultipleValueSetPreparedBatch()
1:b8c1e09:  *      try executing a batch with 3 parameter sets in it.
1:b8c1e09:  *    - testMultipleValueSetNullPreparedBatch()
1:b8c1e09:  *      try executing a batch with 2 parameter sets in it and they are set 
1:b8c1e09:  *      to null.
1:b8c1e09:  *    - test1000ValueSetPreparedBatch()
1:b8c1e09:  *      try executing a batch with 1000 statements in it.
1:b8c1e09:  *    - testPreparedStatRollbackAndCommitCombinations()
1:b8c1e09:  *      try executing batches with various rollback and commit combinations.
1:b8c1e09:  *    - testAutoCommitTruePreparedStatBatch()
1:b8c1e09:  *      try prepared statement batch with autocommit true
1:b8c1e09:  *    - testCombinationsOfClearPreparedStatBatch()
1:b8c1e09:  *      try clear batch
1:b8c1e09:  *      
1:b8c1e09:  *  - tests that verify that incorrect use with preparedStatements give 
1:b8c1e09:  *    appropriate errors
1:b8c1e09:  *    - testPreparedStmtWithResultSetBatch()
1:b8c1e09:  *      statements which will return a resultset are not allowed in batch
1:b8c1e09:  *      update. The following case should throw an exception for select.
1:b8c1e09:  *    - testPreparedStmtNonBatchStuffInBatch();
1:b8c1e09:  *      try executing a batch with regular statement intermingled.
1:b8c1e09:  *    - testPreparedStmtWithErrorsBatch();
1:b8c1e09:  *      trying various placements of overflow update statement
1:b8c1e09:  *      in the batch
1:b8c1e09:  *    - testTransactionErrorPreparedStmtBatch()
1:b8c1e09:  *      try transaction error, in this particular case time out while
1:b8c1e09:  *      getting the lock
9:a86bac7:  * 
1:b8c1e09:  * Almost all fixtures but 1 execute with embedded and 
1:b8c1e09:  * NetworkServer/DerbyNetClient - however, there is a difference in 
1:b8c1e09:  * functionality between the two when an error condition is reaches. Thus,
1:a86bac7:  * the negative tests have if / else if blocks for embedded and client.
1:a86bac7:  * 
1:b8c1e09:  * The 1 fixture that ise not running with network server is 
1:b8c1e09:  * identified with //TODO: tags and has an if (usingEmbedded()) block and
1:b8c1e09:  * a JIRA issue attached to it.
1:a86bac7:  * 
1:a86bac7:  */
1:a86bac7: 
1:a86bac7: public class BatchUpdateTest extends BaseJDBCTestCase {
1:a86bac7: 	
1:a86bac7:     /** Creates a new instance of BatchUpdateTest */
1:a86bac7:     public BatchUpdateTest(String name) {
1:a86bac7:         super(name);
23:a86bac7:     }
1:a86bac7: 
1:c53d18a:     /**
1:a86bac7:      * Set up the conection to the database.
1:a86bac7:      *  This is itself a test of statements creating tables in batch. 
1:a86bac7:      */
1:a86bac7:     public void setUp() throws  Exception {
1:b8c1e09:         getConnection().setAutoCommit(false);
1:b8c1e09:         Statement s = createStatement();
1:7383383:         s.execute("delete from t1");
1:b8c1e09:         s.close();
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("BatchUpdateTest");
1:b8c1e09:         suite.addTest(baseSuite("BatchUpdateTest:embedded"));
1:b8c1e09:         suite.addTest(TestConfiguration.clientServerDecorator(
1:b8c1e09:             baseSuite("BatchUpdateTest:client")));
1:b8c1e09:         return suite;
1:b8c1e09:     }
1:c53d18a:     
1:b8c1e09:     
1:d3fbd72:     /**
1:c53d18a:      * embeddedSuite runs tests only in embedded mode. 
1:c53d18a:      * Used by CollationTest
1:b3691c2:      * @return embedded Test suite
1:c53d18a:      */
1:c53d18a:     public static Test embeddedSuite() {
1:c53d18a:         
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("BatchUpdateTest");
1:c53d18a:         suite.addTest(baseSuite("BatchUpdateTest:embedded"));
1:c53d18a:         return suite;
1:c53d18a:     }
1:c53d18a:     
1:b8c1e09:     protected static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:b8c1e09:         suite.addTestSuite(BatchUpdateTest.class);
1:a86bac7:         return new CleanDatabaseTestSetup(
1:b8c1e09:                 DatabasePropertyTestSetup.setLockTimeouts(suite, 2, 4)) 
1:b8c1e09:         {
1:b8c1e09:             /**
1:b8c1e09:              * Creates the tables used in the test cases.
1:b8c1e09:              * @exception SQLException if a database error occurs
1:b8c1e09:              */
1:b8c1e09:             protected void decorateSQL(Statement stmt) throws SQLException
1:b8c1e09:             {
1:b8c1e09:                 stmt.execute("create table t1(c1 int)");
1:b8c1e09:                 // for fixture testCallableStatementBatch
1:b8c1e09:                 stmt.execute("create table datetab(c1 date)");
1:b8c1e09:                 stmt.execute("create table timetab(c1 time)");
1:b8c1e09:                 stmt.execute("create table timestamptab(c1 timestamp)");
1:b8c1e09:                 stmt.execute("create table usertypetab(c1 DATE)");
1:b8c1e09:                 // for fixture testAssociatedParams
1:b8c1e09:                 stmt.execute("create table assoc" +
1:b8c1e09:                     "(x char(10) not null primary key, y char(100))");
1:b8c1e09:                 stmt.execute("create table assocout(x char(10))");
1:b8c1e09:             }
1:b8c1e09:         };
1:b8c1e09:     } 
1:a86bac7:     
1:a86bac7:     /* 
1:b54918e:      * helper method to check each count in the return array of a BatchUpdateException
1:b54918e:      */
1:b54918e:     public  static   void assertBatchUpdateCounts
1:b54918e:         ( long[] expectedBatchResult, BatchUpdateException bue )
1:b54918e:     {
1:b54918e:         assertBatchUpdateCounts( squashLongs( expectedBatchResult ), bue.getUpdateCounts() );
1:b54918e:         
1:85038ef:         if (JDBC.vmSupportsJDBC42())
1:b54918e:         {
1:b54918e:             BatchUpdateExceptionWrapper wrapper = new BatchUpdateExceptionWrapper( bue );
1:b54918e: 
1:b54918e:             assertEquals( expectedBatchResult, wrapper.getLargeUpdateCounts() );
1:b54918e:         }
1:b54918e:     }
1:b54918e:    
1:b54918e:     /** Squash an array of longs into an array of ints */
1:b54918e:     public static  int[]   squashLongs( long[] longs )
1:b54918e:     {
1:b54918e:         int count = (longs == null) ? 0 : longs.length;
1:b54918e:         int[]   ints = new int[ count ];
1:b54918e:         for ( int i = 0; i < count; i++ ) { ints[ i ] = (int) longs[ i ]; }
1:b54918e: 
1:b54918e:         return ints;
1:b54918e:     }
1:b54918e:     
1:b54918e:     /* 
1:a86bac7:      * helper method to check each count in the return array of batchExecute
1:a86bac7:      */
1:b54918e:     private static void assertBatchUpdateCounts( 
1:a86bac7:         int[] expectedBatchResult, int[] executeBatchResult )
19:a86bac7:     {
1:a86bac7:         assertEquals("length of array should be identical", 
1:a86bac7:             expectedBatchResult.length, executeBatchResult.length);
1:a86bac7:         
1:a86bac7:         for (int i=0; i<expectedBatchResult.length; i++)
1:a86bac7:         {
1:a86bac7:             String msg = "mismatch for array index [" + i + "] ; ";
1:a86bac7:             assertEquals(msg,expectedBatchResult[i],executeBatchResult[i]);
1:a86bac7:             println("expectedUpdate result #" + i + " : " +
1:a86bac7:                 expectedBatchResult[i]);
1:a86bac7:             println("actual result #" + i + " : " + executeBatchResult[i]);
1:a86bac7:         }
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     /** 
2:a86bac7:      * helper method to evaluate negative tests where we expect a 
1:a86bac7:      * batchExecuteException to be returned.
1:a86bac7:      * @exception SQLException     Thrown if the expected error occurs
2:a86bac7:      *                             We expect a BatchUpdateException, and
2:a86bac7:      *                             verify it is so.
1:a86bac7:      *
1:df4020d:      * @param expectedError The sqlstate to look for.
1:df4020d:      * @param stmt The Statement that contains the Batch to
1:a86bac7:      *                             be executed.
1:df4020d:      * @param expectedUpdateCount The expectedUpdateCount array.
1:a86bac7:      */
1:b54918e:     public static void assertBatchExecuteError( 
1:b8c1e09:         String expectedError,
1:b8c1e09:         Statement stmt,
1:b54918e:         long[] expectedUpdateCount) 
1:b8c1e09:     throws SQLException 
1:b54918e:     { 
1:b54918e:        try {
1:b54918e:             stmt.executeBatch();
1:b8c1e09:             fail("Expected batchExecute to fail");
1:b8c1e09:         } catch (BatchUpdateException bue) {
1:b8c1e09:             assertSQLState(expectedError, bue);
1:b54918e:             assertBatchUpdateCounts(expectedUpdateCount, bue);
1:b8c1e09:         } 
1:a86bac7:     }
1:a86bac7:     
1:b8c1e09:     /* Fixture that verifies tables can be created in batch */
1:b8c1e09:     public void testMinimalDDLInBatch() throws SQLException {
1:b8c1e09:         
1:b8c1e09:         Statement stmt = createStatement();
1:b8c1e09:         stmt.addBatch("create table ddltsttable1(c1 int)");
1:b8c1e09:         stmt.addBatch("create procedure ddlinteg() language java " +
1:b8c1e09:             "parameter style java external name 'java.lang.Integer'");
1:b8c1e09:         stmt.addBatch("create table ddltable2(c1 date)");
1:b8c1e09:         int expectedCount[] = {0,0,0};
1:b8c1e09:         assertBatchUpdateCounts(expectedCount, stmt.executeBatch());
1:b8c1e09:         ResultSet rs = stmt.executeQuery(
1:96c3cce:             "select count(*) from SYS.SYSTABLES where CAST(tablename AS VARCHAR(128)) like 'DDL%'");
1:7383383:         JDBC.assertSingleValueResultSet(rs, "2");
1:b8c1e09:         rs = stmt.executeQuery(
1:96c3cce:             "select count(*) from SYS.SYSALIASES where CAST(alias AS VARCHAR(128)) like 'DDL%'");
1:7383383:         JDBC.assertSingleValueResultSet(rs, "1");
1:7383383:         stmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7: 
1:a86bac7:     
1:b8c1e09:     /* Fixtures that test correct usage of batch handling with Statements */
1:a86bac7:     
1:a86bac7:     // try executing a batch which nothing in it. Should work.
1:b8c1e09:     public void testEmptyStatementBatch() throws SQLException {
1:b8c1e09:         Statement stmt = createStatement();
1:0225aac:  
1:a86bac7:         // try executing a batch which nothing in it. Should work.
1:a86bac7:         println("Positive Statement: clear the batch and run the empty batch");
5:a86bac7:         stmt.clearBatch();
1:0225aac:         assertBatchUpdateCounts(new int[0], stmt.executeBatch());
1:a86bac7: 
1:7383383:         stmt.close();
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7: 
1:a86bac7:     // try executing a batch which single statement in it. Should work.
1:b8c1e09:     public void testSingleStatementBatch() throws SQLException {
1:a86bac7: 
1:b8c1e09:         Statement stmt = createStatement();
1:a86bac7:         println("Positive Statement: testing 1 statement batch");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7: 
1:a86bac7:         assertBatchUpdateCounts(new int[] {1}, stmt.executeBatch());
1:7383383:         stmt.close();
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
2:a86bac7:     // try executing a batch with 3 different statements in it.
1:b8c1e09:     public void testMultipleStatementsBatch() throws SQLException {
1:b8c1e09: 
1:b8c1e09:         Statement stmt = createStatement();
15:a86bac7:         ResultSet rs;
1:a86bac7: 
1:a86bac7:         println("Positive Statement: testing 2 inserts and 1 update batch");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7:         stmt.addBatch("update t1 set c1=4");
1:a86bac7:         stmt.addBatch("insert into t1 values(3)");
1:a86bac7: 
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1,1}, stmt.executeBatch());
1:a86bac7:         
1:a86bac7:         rs = stmt.executeQuery("select count(*) from t1 where c1=2");
35:a86bac7:         rs.next();
1:a86bac7:         assertEquals("expect 0 rows with c1 = 2", 0, rs.getInt(1));
36:a86bac7:         rs.close();
1:7383383: 
1:a86bac7:         rs = stmt.executeQuery("select count(*) from t1 where c1=4");
1:a86bac7:         rs.next();
1:a86bac7:         assertEquals("expect 1 row with c1 = 4", 1, rs.getInt(1));
1:a86bac7:         rs.close();
1:7383383: 
1:a86bac7:         rs = stmt.executeQuery("select count(*) from t1 where c1=3");
1:a86bac7:         rs.next();
1:a86bac7:         assertEquals("expect 1 row with c1 = 3", 1, rs.getInt(1));
1:a86bac7:         rs.close();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 2);
1:a86bac7:         
1:7383383:         stmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7: 
1:a86bac7:     /**
1:d3fbd72:      * Regression test case for DERBY-6373.
1:d3fbd72:      */
1:d3fbd72:     public void testMultipleStatementsBatchWithWarnings() throws SQLException {
1:d3fbd72:         Statement s = createStatement();
1:d3fbd72:         s.execute("insert into t1 values 1");
1:d3fbd72: 
1:d3fbd72:         // Execute a batch of three deletes. All of them should get a warning
1:d3fbd72:         // because no rows matched the WHERE clause.
1:d3fbd72:         s.addBatch("delete from t1 where c1 in (select 0 from t1)");
1:d3fbd72:         s.addBatch("delete from t1 where c1 in (select 0 from t1)");
1:d3fbd72:         s.addBatch("delete from t1 where c1 in (select 0 from t1)");
1:d3fbd72:         s.executeBatch();
1:d3fbd72: 
1:d3fbd72:         // Used to fail with NullPointerException on the client.
1:d3fbd72:         SQLWarning w = s.getWarnings();
1:d3fbd72: 
1:d3fbd72:         // Expect one warning per delete on the client. Embedded gives only
1:d3fbd72:         // a single warning.
1:d3fbd72:         assertSQLState("02000", w);
1:d3fbd72:         w = w.getNextWarning();
1:d3fbd72:         if (usingEmbedded()) {
1:d3fbd72:             assertNull(w);
1:d3fbd72:         } else {
1:d3fbd72:             assertSQLState("02000", w);
1:d3fbd72:             w = w.getNextWarning();
1:d3fbd72:             assertSQLState("02000", w);
1:d3fbd72:             w = w.getNextWarning();
1:d3fbd72:             assertNull(w);
1:d3fbd72:         }
1:d3fbd72:     }
1:d3fbd72: 
3:a86bac7:     // try executing a batch with 1000 statements in it.
1:b8c1e09:     public void test1000StatementsBatch() throws SQLException {
2:a86bac7:         int updateCount[];
1:b8c1e09: 
1:b8c1e09:         Statement stmt = createStatement();
1:b8c1e09: 
1:a86bac7:         println("Positive Statement: 1000 statements batch");
1:a86bac7:         for (int i=0; i<1000; i++){
3:a86bac7:             stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         }
3:a86bac7:         updateCount = stmt.executeBatch();
1:0225aac:         
1:0225aac:         int[] expectedUpdateCount = new int[1000];
1:0225aac:         Arrays.fill(expectedUpdateCount, 1);
1:0225aac:         assertBatchUpdateCounts(expectedUpdateCount, updateCount);
1:0225aac:         
1:0225aac:         assertTableRowCount("T1", 1000);
1:a86bac7: 
1:7383383:         stmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7: 
2:a86bac7:     // try batch with autocommit true
1:b8c1e09:     public void testAutoCommitTrueBatch() throws SQLException {
1:b8c1e09: 
1:b8c1e09:         getConnection().setAutoCommit(true);    
1:b8c1e09:         Statement stmt = createStatement();
1:a86bac7: 
1:a86bac7:         // try batch with autocommit true
1:a86bac7:         println("Positive Statement: stmt testing with autocommit true");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         stmt.addBatch("delete from t1");
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1,2}, stmt.executeBatch());
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7:         
1:7383383:         stmt.close();
1:a86bac7:     }
1:a86bac7: 
1:a86bac7:     //  try combinations of clear batch.
1:b8c1e09:     public void testCombinationsOfClearBatch() throws SQLException {
1:b8c1e09: 
1:b8c1e09:         Statement stmt = createStatement();
1:a86bac7: 
1:a86bac7:         println("Positive Statement: add 3 statements, clear and execute batch");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7:         stmt.clearBatch();
1:a86bac7: 
1:0225aac:         // Batch should be cleared, there should be no update count
1:0225aac:         assertBatchUpdateCounts(new int[0], stmt.executeBatch());
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7: 
1:a86bac7:         println("Positive Statement: add 3 statements, clear batch, " +
1:a86bac7:             "add 3 more statements and execute batch");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7:         stmt.clearBatch();
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7:         stmt.addBatch("insert into t1 values(2)");
1:a86bac7: 
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1,1}, stmt.executeBatch());
1:0225aac:         assertTableRowCount("T1", 3);
1:a86bac7: 
1:7383383:         stmt.close();
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7: 
1:a86bac7:     /*
1:a86bac7:      ** Associated parameters are extra parameters that are created
1:a86bac7:      ** and associated with the root parameter (the user one) to
1:a86bac7:      ** improve the performance of like.       For something like
1:a86bac7:      ** where c1 like ?, we generate extra 'associated' parameters 
1:a86bac7:      ** that we use for predicates that we give to the access
1:a86bac7:      ** manager. 
1:a86bac7:      */
1:b8c1e09:     public void testAssociatedParams() throws SQLException 
1:a86bac7:     {
1:b8c1e09: 
1:b8c1e09:         Statement stmt = createStatement();
1:a86bac7:         int i;
1:a86bac7:         println("Positive Statement: testing associated parameters");
1:b8c1e09:         PreparedStatement checkps = prepareStatement(
1:a86bac7:             "select x from assocout order by x");
1:b8c1e09:         PreparedStatement ps = prepareStatement(
1:a86bac7:             "insert into assoc values (?, 'hello')");
1:a86bac7:         for ( i = 10; i < 60; i++)
1:a86bac7:         {
1:39b3237:             ps.setString(1, Integer.toString(i));
1:a86bac7:             ps.executeUpdate();     
1:a86bac7:         }
1:ad0df6f:         ps.close();
1:a86bac7: 
1:b8c1e09:         ps = prepareStatement(
1:a86bac7:             "insert into assocout select x from assoc where x like ?");
1:a86bac7:         ps.setString(1, "33%");
1:a86bac7:         ps.addBatch();
1:a86bac7:         ps.setString(1, "21%");
1:a86bac7:         ps.addBatch();
1:a86bac7:         ps.setString(1, "49%");
1:a86bac7:         ps.addBatch();
1:a86bac7:         
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1,1}, ps.executeBatch());
1:7383383:         ps.close();
1:a86bac7:         checkps.execute();
1:a86bac7:         ResultSet rs = checkps.getResultSet();
1:a86bac7:         JDBC.assertFullResultSet(
1:a86bac7:             rs, new String[][] {{"21"},{"33"},{"49"}}, true);
1:a86bac7:                 
1:a86bac7:         stmt.executeUpdate("delete from assocout");
1:a86bac7: 
1:b8c1e09:         ps = prepareStatement(
1:a86bac7:                 "insert into assocout select x from assoc where x like ?");
1:a86bac7:         ps.setString(1, "3%");
1:a86bac7:         ps.addBatch(); // expectedCount 10: values 10-19
1:a86bac7:         ps.setString(1, "2%");
1:a86bac7:         ps.addBatch(); // values 20-29
1:a86bac7:         ps.setString(1, "1%");
1:a86bac7:         ps.addBatch(); // values 30-39
1:a86bac7: 
1:a86bac7:         // set up expected values for check
1:a86bac7:         String expectedStrArray[][] = new String[30][1];
1:a86bac7:         for (i=10 ; i < 40 ; i++)
1:a86bac7:         {
1:a86bac7:             expectedStrArray[i-10][0] = String.valueOf(i);
1:a86bac7:         }
1:a86bac7:    
1:a86bac7:         assertBatchUpdateCounts( new int[] {10,10,10}, ps.executeBatch());
1:7383383:         ps.close();
1:a86bac7:         checkps.execute();
1:a86bac7:         rs = checkps.getResultSet();
1:a86bac7:         JDBC.assertFullResultSet(rs, expectedStrArray, true);
1:a86bac7:                 
1:a86bac7:         stmt.executeUpdate("delete from assocout");
1:b8c1e09:         ps = prepareStatement(
1:a86bac7:             "insert into assocout select x from assoc where x like ?");
1:a86bac7:         ps.setString(1, "%");// values 10-59
1:a86bac7:         ps.addBatch();
1:a86bac7:         ps.setString(1, "666666");
1:a86bac7:         ps.addBatch();
1:a86bac7:         ps.setString(1, "%");// values 10-59
1:a86bac7:         ps.addBatch();
1:a86bac7:         
1:a86bac7:         // set up expected values for check
1:a86bac7:         String expectedStrArray2[][] = new String[100][1];
1:a86bac7:         int j = 0;
1:a86bac7:         for (i=10 ; i < 60 ; i++)
1:a86bac7:         {  
1:a86bac7:             for (int twice = 0; twice < 2; twice++)
1:a86bac7:             {
1:a86bac7:                 expectedStrArray2[j][0] = String.valueOf(i);
1:a86bac7:                 j++;
1:a86bac7:             }
1:a86bac7:         }
1:a86bac7:         
1:a86bac7:         assertBatchUpdateCounts (new int[] {50,0,50}, ps.executeBatch());
1:7383383:         ps.close();
1:a86bac7:         checkps.execute();
1:a86bac7:         rs = checkps.getResultSet();
1:a86bac7:         JDBC.assertFullResultSet(rs, expectedStrArray2, true);
1:7383383:         checkps.close();
1:7383383:         stmt.close();
1:a86bac7:     }
1:a86bac7: 
1:b8c1e09:     /* Fixtures that test incorrect batch usage with Statements */
1:a86bac7: 
3:a86bac7:     // statements which will return a resultset are not allowed in batch
3:a86bac7:     // update. The following case should throw an exception for select. 
2:a86bac7:     // Below trying various placements of select statement in the batch,
1:a86bac7:     // i.e. as 1st stmt, nth stat and last stmt
1:b8c1e09:     public void testStatementWithResultSetBatch() throws SQLException {
1:a86bac7:         
1:b8c1e09:         Statement stmt = createStatement();
1:a86bac7: 
1:a86bac7:         // trying select as the first statement
1:a86bac7:         println("Negative Statement: statement testing select as first " +
1:a86bac7:             "statement in the batch");
1:a86bac7:         stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
12:a86bac7:         if (usingEmbedded())
1:a86bac7:             /* Ensure the exception is the ResultSetReturnNotAllowed */
1:b54918e:             assertBatchExecuteError("X0Y79", stmt, new long[] {});
6:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ208", stmt, new long[] {-3, 1});
1:a86bac7:         
1:0225aac:         assertTableRowCount("T1",
1:0225aac:                 usingEmbedded() ? 0 : 1);
1:a86bac7:         
1:a86bac7:         // trying select as the nth statement
3:a86bac7:         println("Negative Statement: " +
1:a86bac7:             "statement testing select as nth stat in the batch");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         if (usingEmbedded())
1:a86bac7:             /* Ensure the exception is the ResultSetReturnNotAllowed */
1:b54918e:             assertBatchExecuteError("X0Y79", stmt, new long[] {1});
1:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ208", stmt, new long[] {1,-3,1});
1:a86bac7:             
1:0225aac:         assertTableRowCount("T1",
1:0225aac:                 usingEmbedded() ? 1 : 3);
1:a86bac7: 
1:a86bac7:         // trying select as the last statement
1:a86bac7:         println("Negative Statement: statement testing select" +
1:a86bac7:             " as last stat in the batch");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
1:a86bac7:         if (usingEmbedded())
1:a86bac7:             /* Ensure the exception is the ResultSetReturnNotAllowed */
1:b54918e:             assertBatchExecuteError("X0Y79", stmt, new long[] {1,1});
1:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ208", stmt, new long[] {1,1,-3});
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1",
1:0225aac:                 usingEmbedded() ? 3 : 5);
1:a86bac7: 
1:b8c1e09:         rollback();
1:0225aac: 
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7: 
1:7383383:         stmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
3:a86bac7:     // try executing a batch with regular statement intermingled.
1:b8c1e09:     public void testStatementNonBatchStuffInBatch() throws SQLException {
1:b8c1e09:         
1:b8c1e09:         Statement stmt = createStatement();
1:a86bac7:         int[] updateCount=null;
1:b8c1e09: 
1:a86bac7:         // trying execute after addBatch
1:a86bac7:         println("Negative Statement:" +
1:a86bac7:             " statement testing execute in the middle of batch");
1:a86bac7:         stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
2:a86bac7:         /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:a86bac7:         /* assertStatementError will do the execute() */
1:a86bac7:         if (usingEmbedded())
1:a86bac7:             assertStatementError("XJ068",stmt,"insert into t1 values(1)");
1:a86bac7:         else if (usingDerbyNetClient())
1:a86bac7:         {
1:a86bac7:             stmt.addBatch("insert into t1 values(1)"); 
1:b54918e:             assertBatchExecuteError("XJ208",stmt, new long[] {-3,1});           
1:a86bac7:             // pull level with embedded situation
1:b8c1e09:             rollback();
1:a86bac7:         }
5:a86bac7:         // do clearBatch so we can proceed
1:a86bac7:         stmt.clearBatch();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7: 
1:b8c1e09:         // trying executeQuery after addBatch
1:b8c1e09:         println("Negative Statement: " +
1:b8c1e09:             "statement testing executeQuery in the middle of batch");
1:b8c1e09:         stmt.addBatch("insert into t1 values(1)");
1:b8c1e09:         if (usingEmbedded())
1:a86bac7:         {
1:b8c1e09:             try
1:b8c1e09:             {
1:b8c1e09:                 stmt.executeQuery("SELECT * FROM SYS.SYSTABLES");
1:b8c1e09:                 fail("Expected executeQuerywith embedded");
1:b8c1e09:             } catch (SQLException sqle) {
1:b8c1e09:                 /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:b8c1e09:                 assertSQLState("XJ068", sqle);
1:b8c1e09:                 // do clearBatch so we can proceed
1:b8c1e09:                 stmt.clearBatch();
1:b8c1e09:             }
1:b8c1e09:         }
1:b8c1e09:         else if (usingDerbyNetClient())
1:b8c1e09:         {
1:a86bac7:             stmt.executeQuery("SELECT * FROM SYS.SYSTABLES");
1:a86bac7:             updateCount = stmt.executeBatch();
1:b8c1e09:             assertBatchUpdateCounts(new int[] {1}, updateCount);
1:b8c1e09:             // set to same spot as embedded
1:b8c1e09:             rollback();
1:a86bac7:         }
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7: 
1:a86bac7:         println("Negative Statement: " +
2:a86bac7:             "statement testing executeUpdate in the middle of batch");
1:b8c1e09:         // trying executeUpdate after addBatch
1:b8c1e09:         println("Negative Statement: " +
1:b8c1e09:         "statement testing executeUpdate in the middle of batch");
1:b8c1e09:         stmt.addBatch("insert into t1 values(1)");
7:a86bac7:         try
1:a86bac7:         {
1:a86bac7:             stmt.executeUpdate("insert into t1 values(1)");
1:a86bac7:             stmt.addBatch("insert into t1 values(1)");
1:a86bac7:             stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
4:a86bac7:             if (usingDerbyNetClient())
1:a86bac7:             {
1:b54918e:                 assertBatchExecuteError("XJ208", stmt, new long[] {1,1,-3});
1:a86bac7:             }
1:a86bac7:             else if (usingEmbedded())
1:a86bac7:             {
1:a86bac7:                 updateCount = stmt.executeBatch();
4:a86bac7:                 fail("Expected executeBatch to fail");
1:a86bac7:             }
6:a86bac7:         } catch (SQLException sqle) {
1:a86bac7:             /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:a86bac7:             if (usingEmbedded())
2:a86bac7:                 assertSQLState("XJ068", sqle);
1:a86bac7:             else if (usingDerbyNetClient())
1:a86bac7:                 assertSQLState("XJ208", sqle);
1:a86bac7:             
1:a86bac7:             stmt.clearBatch();
1:a86bac7:         }
1:a86bac7:         
1:0225aac:         assertTableRowCount("T1",
1:0225aac:                 usingEmbedded() ? 0 : 3);
1:a86bac7: 
1:b8c1e09:         rollback();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 0);
1:7383383:         stmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // Below trying various placements of overflow update statement in the 
1:a86bac7:     // batch, i.e. as 1st stmt, nth stmt and last stmt
1:b8c1e09:     public void testStatementWithErrorsBatch() throws SQLException {
1:a86bac7:         
1:b8c1e09:         Statement stmt = createStatement();
1:a86bac7: 
1:a86bac7:         stmt.executeUpdate("insert into t1 values(1)");
1:a86bac7: 
1:a86bac7:         // trying update as the first statement
1:a86bac7:         println("Negative Statement: statement testing overflow error" +
1:a86bac7:             " as first statement in the batch");
1:a86bac7:         stmt.addBatch("update t1 set c1=2147483647 + 1");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         /* Check to be sure the exception is the one we expect */
1:a86bac7:         /* Overflow is first stmt in the batch, so expect no update count */
1:a86bac7:         if (usingEmbedded())
1:b54918e:             assertBatchExecuteError("22003", stmt, new long[] {});
1:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ208", stmt, new long[] {-3,1});
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1",
1:0225aac:                 usingEmbedded() ? 1 : 2);
1:a86bac7: 
1:a86bac7:         // trying update as the nth statement
1:a86bac7:         println("Negative Statement: statement testing overflow error" +
1:a86bac7:             " as nth statement in the batch");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         stmt.addBatch("update t1 set c1=2147483647 + 1");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         /* Check to be sure the exception is the one we expect */
1:a86bac7:         /* Update is second statement in the batch, expect 1 update count */
1:a86bac7:         if (usingEmbedded())
1:b54918e:             assertBatchExecuteError("22003", stmt, new long[] {1});
1:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ208", stmt, new long[] {1,-3,1});
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1",
1:0225aac:                 usingEmbedded() ? 2 : 4);
1:a86bac7: 
1:a86bac7:         // trying select as the last statement
1:a86bac7:         println("Negative Statement: statement testing overflow error" +
1:a86bac7:             " as last stat in the batch");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         stmt.addBatch("insert into t1 values(1)");
1:a86bac7:         stmt.addBatch("update t1 set c1=2147483647 + 1");
1:a86bac7:         /* Check to be sure the exception is the one we expect */
1:a86bac7:         /* Update is last statement in the batch, expect 2 update counts */
1:a86bac7:         if (usingEmbedded())
1:b54918e:             assertBatchExecuteError("22003", stmt, new long[] {1,1});
1:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ208", stmt, new long[] {1,1,-3});
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1",
1:0225aac:                 usingEmbedded() ? 4 : 6);
1:7383383:         stmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
2:a86bac7:     // try transaction error, in this particular case time out while
2:a86bac7:     // getting the lock
1:b8c1e09:     public void testTransactionErrorBatch() throws SQLException {
1:a86bac7: 
1:b8c1e09:         // conn is just default connection
1:b8c1e09:         Connection conn = getConnection();
1:b8c1e09:         Connection conn2 = openDefaultConnection();
1:b8c1e09:         conn.setAutoCommit(false);
1:b8c1e09:         conn2.setAutoCommit(false);        
1:b8c1e09:         Statement stmt = conn.createStatement();
1:b8c1e09:         Statement stmt2 = conn2.createStatement();
1:b8c1e09:         
1:a86bac7:         int[] updateCount = null;
1:a86bac7: 
1:b8c1e09:         println("Negative Statement: statement testing time out" +
1:b8c1e09:             " while getting the lock in the batch");
1:b8c1e09: 
1:b8c1e09:         stmt.execute("insert into t1 values(1)");
1:b8c1e09:         stmt2.execute("insert into t1 values(2)");
1:b8c1e09: 
1:b8c1e09:         stmt.addBatch("update t1 set c1=3 where c1=2");
1:b8c1e09:         stmt2.addBatch("update t1 set c1=4 where c1=1");
1:b8c1e09: 
1:a86bac7:         try
1:a86bac7:         {
1:a86bac7:             stmt.executeBatch();
1:a86bac7:             fail ("Batch is expected to fail");
1:b8c1e09:             updateCount = stmt2.executeBatch();
1:b8c1e09:         } catch (BatchUpdateException bue) {
1:a86bac7:             /* Ensure the exception is time out while getting lock */
1:b8c1e09:             if (usingEmbedded())
1:b8c1e09:                 assertSQLState("40XL1", bue);
1:b8c1e09:             else if (usingDerbyNetClient())
1:b8c1e09:                 assertSQLState("XJ208", bue);
1:b8c1e09:             updateCount = ((BatchUpdateException)bue).getUpdateCounts();
1:a86bac7:             if (updateCount != null) {
1:b8c1e09:                 if (usingEmbedded())
1:b8c1e09:                     assertEquals("first statement in the batch caused time out" +
1:b8c1e09:                         " while getting the lock, there should be no update count", 
1:b8c1e09:                         0, updateCount.length);
1:b8c1e09:                 else if (usingDerbyNetClient())
1:b8c1e09:                     /* first statement in the batch caused time out while getting
1:b8c1e09:                      *  the lock, there should be 1 update count of -3 */
1:b8c1e09:                     assertBatchUpdateCounts(new int[] {-3}, updateCount);
1:a86bac7:             }
1:a86bac7:         }
10:a86bac7:         conn.rollback();
1:a86bac7:         conn2.rollback();
1:a86bac7:         stmt.clearBatch();
1:a86bac7:         stmt2.clearBatch();
1:7383383:         stmt.close();
1:7383383:         stmt2.close();
1:b8c1e09:         commit();
1:1ccacc8:         conn2.close();
1:2c140d8:     }
1:465c7c7:     
1:b8c1e09:     /* Fixtures that test batch updates with CallableStatements */
1:7383383: 
2:a86bac7:     // try callable statements
1:b8c1e09:     public void testCallableStatementBatch() throws SQLException {
1:b8c1e09: 
1:a86bac7:         println("Positive Callable Statement: " +
1:a86bac7:             "statement testing callable statement batch");
1:b8c1e09:         CallableStatement cs = prepareCall("insert into t1 values(?)");
1:b8c1e09: 
1:a86bac7:         cs.setInt(1, 1);
1:a86bac7:         cs.addBatch();
1:a86bac7:         cs.setInt(1,2);
1:a86bac7:         cs.addBatch();
1:7383383:         executeBatchCallableStatement(cs);
1:7383383: 
1:b8c1e09:         cleanUpCallableStatement(cs, "t1");
1:a86bac7: 
1:a86bac7:         /* For 'beetle' bug 2813 - setDate/setTime/setTimestamp
1:a86bac7:          * calls on callableStatement throws ClassNotFoundException 
1:a86bac7:          * verify setXXXX() works with Date, Time and Timestamp 
1:a86bac7:          * on CallableStatement.
1:a86bac7:          */
1:b8c1e09:         cs = prepareCall("insert into datetab values(?)");
1:a86bac7: 
1:a86bac7:         cs.setDate(1, Date.valueOf("1990-05-05"));
1:a86bac7:         cs.addBatch();
1:a86bac7:         cs.setDate(1,Date.valueOf("1990-06-06"));
1:a86bac7:         cs.addBatch();
1:7383383: 
1:7383383:         executeBatchCallableStatement(cs);
1:7383383: 
1:b8c1e09:         cleanUpCallableStatement(cs, "datetab");
1:a86bac7: 
1:b8c1e09:         cs = prepareCall("insert into timetab values(?)");
1:a86bac7: 
1:a86bac7:         cs.setTime(1, Time.valueOf("11:11:11"));
1:a86bac7:         cs.addBatch();
1:a86bac7:         cs.setTime(1, Time.valueOf("12:12:12"));
1:a86bac7:         cs.addBatch();
1:7383383:         executeBatchCallableStatement(cs);
1:7383383: 
1:b8c1e09:         cleanUpCallableStatement(cs, "timestamptab");
1:a86bac7: 
1:b8c1e09:         cs = prepareCall("insert into timestamptab values(?)");
1:a86bac7: 
1:a86bac7:         cs.setTimestamp(1, Timestamp.valueOf("1990-05-05 11:11:11.1"));
1:a86bac7:         cs.addBatch();
1:a86bac7:         cs.setTimestamp(1, Timestamp.valueOf("1992-07-07 12:12:12.2"));
1:a86bac7:         cs.addBatch();
1:7383383:         executeBatchCallableStatement(cs);
1:7383383: 
1:b8c1e09:         cleanUpCallableStatement(cs, "timestamptab");
1:a86bac7: 
1:a86bac7:         // Try with a user type
1:b8c1e09:         cs = prepareCall("insert into usertypetab values(?)");
1:a86bac7: 
1:a86bac7:         cs.setObject(1, Date.valueOf("1990-05-05"));
1:a86bac7:         cs.addBatch();
1:a86bac7:         cs.setObject(1,Date.valueOf("1990-06-06"));
1:a86bac7:         cs.addBatch();
1:7383383:         executeBatchCallableStatement(cs);
1:7383383: 
1:b8c1e09:         cleanUpCallableStatement(cs, "usertypetab");
1:a86bac7:     }
1:a86bac7:     
1:b8c1e09:     // helper method to testCallableStatementBatch 
1:a86bac7:     // executes and evaluates callable statement
1:a86bac7:     private static void executeBatchCallableStatement(CallableStatement cs)
5:a86bac7:     throws SQLException
1:a86bac7:     {
1:a86bac7:         int updateCount[];
1:a86bac7: 
1:a86bac7:         updateCount = cs.executeBatch();
1:a86bac7:         assertEquals("there were 2 statements in the batch", 
1:b8c1e09:             2, updateCount.length);
1:a86bac7:         for (int i=0; i<updateCount.length; i++) 
1:a86bac7:         {
1:a86bac7:             assertEquals("update count should be 1", 1, updateCount[i]);
1:a86bac7:         }
1:a86bac7:     }
1:a86bac7: 
1:b8c1e09:     // helper method to testCallableStatementBatch - 
1:a86bac7:     // removes all rows from table
1:b8c1e09:     protected void cleanUpCallableStatement(
1:b8c1e09:         CallableStatement cs, String tableName)
1:a86bac7:     throws SQLException
1:a86bac7:     {
1:a86bac7:         cs.close();
1:b8c1e09:         rollback();
1:b8c1e09:         cs = prepareCall("delete from " + tableName);
1:a86bac7:         cs.executeUpdate();
1:a86bac7:         cs.close();
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // try callable statements with output parameters
1:b8c1e09:     public void testCallableStatementWithOutputParamBatch() 
7:a86bac7:     throws SQLException {
1:a86bac7: 
1:a86bac7:         println("Negative Callable Statement: " +
1:a86bac7:             "callable statement with output parameters in the batch");
1:b8c1e09:         Statement s = createStatement();
1:a86bac7: 
1:a86bac7:         s.execute("CREATE PROCEDURE " +
1:b8c1e09:             "takesString(OUT P1 VARCHAR(40), IN P2 INT) " +
1:b8c1e09:             "EXTERNAL NAME '" + this.getClass().getName() + ".takesString'" +
1:a86bac7:         " NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:a86bac7: 
1:b8c1e09:         CallableStatement cs = prepareCall("call takesString(?,?)");
1:b8c1e09:         cs.registerOutParameter(1, Types.CHAR);
1:b8c1e09:         cs.setInt(2, Types.INTEGER);
1:a86bac7:         try
1:a86bac7:         {
1:a86bac7:             cs.addBatch();
1:a86bac7:             if (usingEmbedded())
1:a86bac7:                 fail("Expected to see error XJ04C");
1:a86bac7:             else if (usingDerbyNetClient()) {
6:a86bac7:                 executeBatchCallableStatement(cs);       
1:a86bac7:             }
1:a86bac7:         }
6:a86bac7:         catch (SQLException sqle)
1:a86bac7:         {
1:a86bac7:             // Check to be sure the exception is callback related
1:a86bac7:             assertSQLState("XJ04C", sqle);
1:a86bac7:         }
1:a86bac7: 
1:a86bac7:         cs.close();
1:a86bac7:         s.execute("drop procedure takesString");
1:a86bac7:         s.close();
1:b8c1e09:         rollback();
1:b8c1e09:     }
1:b8c1e09:     
1:b8c1e09:     // helper method to be used as procedure in test 
1:b8c1e09:     // testCallableStatementWithOutputParamBatch
1:b8c1e09:     public static void takesString(String[] outparam, int type) 
1:b8c1e09:     throws Throwable
1:b8c1e09:     {
1:b8c1e09:         // method is stripped from takesString in jdbcapi/outparams.java
1:b8c1e09:         outparam[0] = "3";
1:a86bac7:     }
1:a86bac7: 
1:b8c1e09:     /* Fixtures that test correct usage with PreparedStatements */    
1:a86bac7:     
1:a86bac7:     // try executing a batch which nothing in it. Should work.
1:b8c1e09:     public void testEmptyValueSetPreparedBatch() throws SQLException {
1:b8c1e09:         
1:a86bac7:         // try executing a batch which nothing in it. Should work.
1:a86bac7:         println("Positive Prepared Stat: " +
1:a86bac7:             "set no parameter values and run the batch");
4:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("insert into t1 values(?)");
1:a86bac7: 
1:a86bac7:         assertBatchUpdateCounts(new int[] {}, pStmt.executeBatch());
1:a86bac7: 
1:0225aac:         pStmt.close();
1:b8c1e09:         commit();
1:a86bac7:     }
1:7383383:     
1:2c140d8:     // try prepared statement batch without settable parameters.
1:b8c1e09:     public void testNoParametersPreparedBatch() throws SQLException {
1:7383383: 
1:2c140d8:         // Note: also tests for fix of NPE of DERBY-2112
1:b8c1e09:      
1:7383383:         Statement stmt = createStatement();
1:a86bac7:         ResultSet rs;
1:b8c1e09: 
1:a86bac7:         println("Positive Prepared Stat: no settable parameters");
1:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("insert into t1 values(5)");
4:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* 3 parameters were set in the batch, update count length
1:a86bac7:          *  should be 3 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1,1}, pStmt.executeBatch());
1:0225aac: 
1:0225aac:         pStmt.close();
1:a86bac7:         rs = stmt.executeQuery("select count(*) from t1 where c1=5");
1:a86bac7:         rs.next();
1:a86bac7:         assertEquals("There should be 3 rows with c1 = 5", 3, rs.getInt(1));
1:a86bac7:         rs.close();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 3);
1:7383383:         stmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // try prepared statement batch with just one set of values.
1:b8c1e09:     public void testSingleValueSetPreparedBatch() throws SQLException {
1:b8c1e09: 
1:b8c1e09:         Statement stmt = createStatement();
1:a86bac7:         ResultSet rs;
1:a86bac7: 
1:a86bac7:         // try prepared statement batch with just one set of values
1:a86bac7:         println("Positive Prepared Stat: " +
1:a86bac7:             "set one set of parameter values and run the batch");
1:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("insert into t1 values(?)");
4:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* 1 parameter was set in batch, update count length should be 1 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1}, pStmt.executeBatch());
1:a86bac7: 
1:7383383:         pStmt.close();
1:a86bac7:         rs = stmt.executeQuery("select count(*) from t1 where c1=1");
1:a86bac7:         rs.next();
1:a86bac7:         assertEquals("There should be 1 row with c1=1", 1, rs.getInt(1));
1:a86bac7:         
1:a86bac7:         rs.close();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 1);
1:0225aac: 
1:7383383:         stmt.close();
1:0225aac: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // try executing a batch with 3 different parameter sets in it.
1:b8c1e09:     public void testMultipleValueSetPreparedBatch() throws SQLException {
1:b8c1e09: 
1:a86bac7:         // try prepared statement batch with just one set of values
1:a86bac7:         println("Positive Prepared Stat: " +
1:a86bac7:             "set 3 set of parameter values and run the batch");
1:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("insert into t1 values(?)");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 2);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 3);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* 3 parameters were set , update count length should be 3 */
1:0225aac:         assertBatchUpdateCounts(new int[] {1,1,1}, pStmt.executeBatch());
1:0225aac: 
1:7383383:         pStmt.close();
1:0225aac:         
1:0225aac:         assertTableRowCount("T1", 3);
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // try prepared statement batch with just 2 set of values 
1:a86bac7:     // and there value is null. 
1:a86bac7:     // tests fix for 'beetle' bug 4002: Execute batch for
1:a86bac7:     // preparedStatement gives nullPointerException
1:b8c1e09:     public void testMultipleValueSetNullPreparedBatch() throws SQLException {
1:b8c1e09: 
1:b8c1e09:         Statement stmt = createStatement();
1:a86bac7:         ResultSet rs;
1:a86bac7: 
1:a86bac7:         // try prepared statement batch with just one set of values
1:a86bac7:         println("Positive Prepared Stat: " +
1:a86bac7:             "set one set of parameter values to null and run the batch");
1:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("insert into t1 values(?)");
1:a86bac7:         pStmt.setNull(1, Types.INTEGER);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setNull(1, Types.INTEGER);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* 2 parameters were set in the batch, 
1:a86bac7:          * update count length should be 2 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1:0225aac: 
2:a86bac7:         pStmt.close();
1:a86bac7:         rs = stmt.executeQuery("select count(*) from t1 where c1 is null");
1:a86bac7:         rs.next();
1:a86bac7:         assertEquals("There should be 2 rows with c1 is null",
2:a86bac7:             2, rs.getInt(1));
1:a86bac7:         rs.close();
1:0225aac: 
1:0225aac:         assertTableRowCount("T1", 2);
1:a86bac7: 
1:7383383:         stmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // try executing a batch with 1000 statements in it.
1:b8c1e09:     public void test1000ValueSetPreparedBatch() throws SQLException {
1:a86bac7:         
1:a86bac7:         int updateCount[];
1:a86bac7: 
1:a86bac7:         println("Positive Prepared Stat: 1000 parameter set batch");
1:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("insert into t1 values(?)");
1:a86bac7:         for (int i=0; i<1000; i++){
1:a86bac7:             pStmt.setInt(1, 1);
1:a86bac7:             pStmt.addBatch();
1:a86bac7:         }
5:a86bac7:         updateCount = pStmt.executeBatch();
1:0225aac: 
1:0225aac:         int[] expectedUpdateCount = new int[1000];
1:0225aac:         Arrays.fill(expectedUpdateCount, 1);
1:0225aac:         assertBatchUpdateCounts(expectedUpdateCount, updateCount);
1:a86bac7:         
1:0225aac:         assertTableRowCount("T1", 1000);
1:a86bac7: 
1:a86bac7:         pStmt.close();
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7: 
2:a86bac7:     // try executing batches with various rollback and commit combinations.
1:b8c1e09:     public void testPreparedStatRollbackAndCommitCombinations() 
1:b8c1e09:     throws SQLException {
1:a86bac7: 
1:a86bac7:         println("Positive Prepared Stat: batch, rollback," +
1:b8c1e09:             " batch and commit combinations");
1:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("insert into t1 values(?)");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* there were 2 statements in the batch, 
1:a86bac7:          * update count length should be 2 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1:a86bac7: 
1:b8c1e09:         rollback();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7: 
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* there were 2 statements in the batch, 
1:a86bac7:          * update count length should be 2 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:         
1:0225aac:         assertTableRowCount("T1", 2);
1:a86bac7: 
1:a86bac7:         // try batch and commit
1:a86bac7:         println("Positive Prepared Stat: batch and commit combinations");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* there were 2 statements in the batch, 
1:a86bac7:          * update count length should be 2 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 4);
1:a86bac7: 
1:a86bac7:         // try batch, batch and rollback
1:a86bac7:         println("Positive Prepared Stat: batch, " +
1:a86bac7:             "batch and rollback combinations");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* there were 2 statements in the batch, 
1:a86bac7:          * update count should be 2 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1:a86bac7: 
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* there were 2 statements in the batch, 
1:a86bac7:          * update count length should be 2 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1:a86bac7: 
1:b8c1e09:         rollback();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 4);
1:a86bac7: 
1:a86bac7:         // try batch, batch and commit
1:a86bac7:         println("Positive Prepared Stat: " +
1:a86bac7:             "batch, batch and commit combinations");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* there were 2 statements in the batch, 
1:a86bac7:          * update count length should be 2 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1:a86bac7: 
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* there were 2 statements in the batch, 
1:a86bac7:          * update count length should be 2 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:         
1:0225aac:         assertTableRowCount("T1", 8);
1:a86bac7: 
1:a86bac7:         pStmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7: 
2:a86bac7:     // try prepared statement batch with autocommit true
1:b8c1e09:     public void testAutoCommitTruePreparedStatBatch() throws SQLException {
1:b8c1e09: 
1:b8c1e09:         getConnection().setAutoCommit(true);    
1:b8c1e09: 
1:a86bac7:         // prepared statement batch with autocommit true
1:a86bac7:         println("Positive Prepared Stat: testing batch with autocommit true");
1:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("insert into t1 values(?)");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         /* there were 3 statements in the batch, 
1:a86bac7:          * update count length should be 3 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1,1}, pStmt.executeBatch());
1:0225aac: 
1:0225aac:         assertTableRowCount("T1", 3);
1:a86bac7: 
1:0225aac:         pStmt.close();       
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // try combinations of clear batch.
1:b8c1e09:     public void testCombinationsOfClearPreparedStatBatch() 
1:b8c1e09:     throws SQLException {
1:a86bac7: 
1:a86bac7:         int updateCount[];
1:a86bac7: 
1:a86bac7:         println("Positive Prepared Stat: add 3 statements, " +
1:a86bac7:             "clear batch and execute batch");
1:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("insert into t1 values(?)");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 2);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 3);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.clearBatch();
1:a86bac7:         /* there were 0 statements in the batch, 
1:a86bac7:          * update count length should be 0 */
1:a86bac7:         assertBatchUpdateCounts(new int[] {}, pStmt.executeBatch());
1:a86bac7: 
1:a86bac7:         println("Positive Prepared Stat: " +
1:a86bac7:             "add 3 statements, clear batch, add 3 and execute batch");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 2);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 3);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.clearBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 2);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 3);
1:a86bac7:         pStmt.addBatch();
1:a86bac7: 
1:a86bac7:         assertBatchUpdateCounts(new int[] {1,1,1}, pStmt.executeBatch());
1:a86bac7:         
1:0225aac:         assertTableRowCount("T1", 3);
1:a86bac7: 
1:a86bac7:         pStmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:b8c1e09:     /* Fixtures that test incorrect usage with PreparedStatements */
1:a86bac7:     
1:a86bac7:     // statements which will return a resultset are not allowed in
1:a86bac7:     // batch Updates. Following case should throw an exception for select.
1:b8c1e09:     public void testPreparedStmtWithResultSetBatch() throws SQLException {
1:a86bac7: 
1:a86bac7: 
1:a86bac7:         println("Negative Prepared Stat: testing select in the batch");
1:a86bac7:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("select * from t1 where c1=?");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         if (usingEmbedded())
1:a86bac7:             /* Ensure the exception is the ResultSetReturnNotAllowed */
1:a86bac7:             /* "Select is first statement in the batch, 
1:a86bac7:              * so there should not be any update counts */
1:b54918e:             assertBatchExecuteError("X0Y79", pStmt, new long[] {});
1:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ117", pStmt, new long[] {-3});
1:a86bac7:         pStmt.close();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // try executing a batch with regular statement intermingled.
1:b8c1e09:     public void testPreparedStmtNonBatchStuffInBatch() throws SQLException {
1:a86bac7:         
1:a86bac7:         int updateCount[] = null;
1:a86bac7: 
1:b8c1e09:         // trying execute in the middle of batch
1:b8c1e09:         println("Negative Prepared Stat: " +
1:b8c1e09:             "testing execute in the middle of batch");
1:b8c1e09:         PreparedStatement pStmt = 
1:b8c1e09:             prepareStatement("select * from t1 where c1=?");
1:b8c1e09:         pStmt.setInt(1, 1);
1:b8c1e09:         pStmt.addBatch();
1:a86bac7:         try
1:a86bac7:         {
1:a86bac7:             pStmt.execute();
1:b8c1e09:             if (usingEmbedded())
1:b8c1e09:                 fail("Expected executeBatch to fail");
1:b8c1e09:             else if (usingDerbyNetClient())
1:b8c1e09:                 updateCount = pStmt.executeBatch();
1:a86bac7:         } catch (SQLException sqle) {
1:a86bac7:             if (usingEmbedded())
1:a86bac7:                 /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:a86bac7:                 assertSQLState("XJ068", sqle);
1:a86bac7:             else if (usingDerbyNetClient())
1:a86bac7:                 assertSQLState("XJ117", sqle);
1:a86bac7:         }
1:0225aac:         pStmt.close();
1:0225aac:         
1:0225aac:         
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7: 
1:b8c1e09:         // trying executeQuery in the middle of batch
1:b8c1e09:         println("Negative Prepared Statement: " +
1:b8c1e09:             "testing executeQuery in the middle of batch");
1:b8c1e09:         pStmt = 
1:b8c1e09:             prepareStatement("select * from t1 where c1=?");
1:b8c1e09:         pStmt.setInt(1, 1);
1:b8c1e09:         pStmt.addBatch();
1:a86bac7:         try
1:a86bac7:         {
1:a86bac7:             pStmt.executeQuery();
1:b8c1e09:             if (usingEmbedded())
1:b8c1e09:                 fail("Expected executeBatch to fail");
1:b8c1e09:             else if (usingDerbyNetClient())
1:b8c1e09:                 updateCount = pStmt.executeBatch();
1:a86bac7:         } catch (SQLException sqle) {
1:a86bac7:             if (usingEmbedded())
1:a86bac7:                 /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:a86bac7:                 assertSQLState("XJ068", sqle);
1:a86bac7:             else if (usingDerbyNetClient())
1:a86bac7:                 assertSQLState("XJ117", sqle);
1:a86bac7:         }
1:0225aac:         pStmt.close();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7: 
1:b8c1e09:         //  trying executeUpdate in the middle of batch
1:b8c1e09:         println("Negative Prepared Stat: " +
1:b8c1e09:             "testing executeUpdate in the middle of batch");
1:b8c1e09:         pStmt = 
1:b8c1e09:             prepareStatement("select * from t1 where c1=?");
1:b8c1e09:         pStmt.setInt(1, 1);
1:b8c1e09:         pStmt.addBatch();
1:a86bac7:         try
1:a86bac7:         {
1:a86bac7:             pStmt.executeUpdate();
1:b8c1e09:             if (usingEmbedded())
1:b8c1e09:                 fail("Expected executeBatch to fail");
1:b8c1e09:             else if (usingDerbyNetClient())
1:b8c1e09:                 updateCount = pStmt.executeBatch();
1:a86bac7:         } catch (SQLException sqle) {
1:a86bac7:             if (usingEmbedded())
1:a86bac7:                 /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:a86bac7:                 assertSQLState("XJ068", sqle);
1:a86bac7:             else if (usingDerbyNetClient())
1:a86bac7:                 assertSQLState("X0Y79", sqle);
1:a86bac7:         }
1:a86bac7:         pStmt.close();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 0);
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // Below trying placements of overflow update statement in the batch
1:b8c1e09:     public void testPreparedStmtWithErrorsBatch() throws SQLException {
1:0225aac: 
1:b8c1e09:         Statement stmt = createStatement();
1:b8c1e09: 
1:a86bac7:         PreparedStatement pStmt = null;
1:a86bac7: 
1:a86bac7:         stmt.executeUpdate("insert into t1 values(1)");
1:a86bac7: 
3:a86bac7:         println("Negative Prepared Stat: " +
1:a86bac7:             "testing overflow as first set of values");
1:b8c1e09:         pStmt = prepareStatement("update t1 set c1=(? + 1)");
1:a86bac7:         pStmt.setInt(1, java.lang.Integer.MAX_VALUE);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         if (usingEmbedded())
1:a86bac7:             /* Check to be sure the exception is the one we expect */
1:a86bac7:             /* Overflow is first statement in the batch, 
1:a86bac7:              * so there should not be any update count */
1:b54918e:             assertBatchExecuteError("22003", pStmt, new long[] {});
1:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ208", pStmt, new long[] {-3});
1:a86bac7:         pStmt.close();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 1);
1:a86bac7: 
1:a86bac7:         println("Negative Prepared Stat: " +
1:a86bac7:             "testing overflow as nth set of values");
1:b8c1e09:         pStmt = prepareStatement("update t1 set c1=(? + 1)");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, java.lang.Integer.MAX_VALUE);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         if (usingEmbedded())
1:a86bac7:             /* Check to be sure the exception is the one we expect */
1:a86bac7:             /* Overflow is second statement in the batch, 
1:a86bac7:              * so there should be only 1 update count */
1:b54918e:             assertBatchExecuteError("22003", pStmt, new long[] {1});
1:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ208", pStmt, new long[] {1,-3,1});
1:a86bac7:         pStmt.close();
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 1);
1:a86bac7: 
1:a86bac7:         // trying select as the last statement
1:a86bac7:         println("Negative Prepared Stat: " +
1:a86bac7:             "testing overflow as last set of values");
1:b8c1e09:         pStmt = prepareStatement("update t1 set c1=(? + 1)");
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, 1);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         pStmt.setInt(1, java.lang.Integer.MAX_VALUE);
1:a86bac7:         pStmt.addBatch();
1:a86bac7:         if (usingEmbedded())
1:a86bac7:             /* Check to be sure the exception is the one we expect */
1:a86bac7:             /* Overflow is last statement in the batch, 
1:a86bac7:              * so there should be 2 update counts */
1:b54918e:             assertBatchExecuteError("22003", pStmt, new long[] {1,1});
1:a86bac7:         else if (usingDerbyNetClient())
1:b54918e:             assertBatchExecuteError("XJ208", pStmt, new long[] {1,1,-3});
1:a86bac7: 
1:0225aac:         assertTableRowCount("T1", 1);
1:a86bac7:         
1:a86bac7:         pStmt.close();
1:7383383:         stmt.close();
1:a86bac7: 
1:b8c1e09:         commit();
1:a86bac7:     }
1:a86bac7:     
1:a86bac7:     // try transaction error, in this particular case 
1:a86bac7:     // time out while getting the lock
1:b8c1e09:     public void testTransactionErrorPreparedStmtBatch() throws SQLException {
1:b8c1e09: 
1:b8c1e09:         Connection conn = getConnection();
1:b8c1e09:         Connection conn2 = openDefaultConnection();
1:b8c1e09:         conn.setAutoCommit(false);
1:b8c1e09:         conn2.setAutoCommit(false);        
1:b8c1e09:         Statement stmt = createStatement();
1:b8c1e09:         Statement stmt2 = conn2.createStatement();
1:b8c1e09: 
1:a86bac7:         int updateCount[] = null;
1:a86bac7: 
1:b8c1e09:         println("Negative Prepared Statement: " +
1:b8c1e09:             "testing transaction error, time out while getting the lock");
1:b8c1e09: 
1:b8c1e09:         stmt.execute("insert into t1 values(1)");
1:b8c1e09:         stmt2.execute("insert into t1 values(2)");
1:b8c1e09: 
1:b8c1e09:         PreparedStatement pStmt1 = 
1:7383383:             prepareStatement("update t1 set c1=3 where c1=?");
1:b8c1e09:         pStmt1.setInt(1, 2);
1:b8c1e09:         pStmt1.addBatch();
1:b8c1e09: 
1:b8c1e09:         PreparedStatement pStmt2 = 
1:b8c1e09:             conn.prepareStatement("update t1 set c1=4 where c1=?");
1:b8c1e09:         pStmt2.setInt(1, 1);
1:b8c1e09:         pStmt2.addBatch();
1:b8c1e09: 
1:a86bac7:         try
1:a86bac7:         {
1:a86bac7:             pStmt1.executeBatch();
1:a86bac7:             updateCount = pStmt2.executeBatch();
1:a86bac7:             fail ("Batch is expected to fail");
1:b8c1e09:         } catch (BatchUpdateException bue) {
1:a86bac7:             /* Check that the exception is time out while 
1:a86bac7:              * getting the lock */
1:b8c1e09:             if (usingEmbedded())
1:b8c1e09:                 assertSQLState("40XL1", bue);
1:b8c1e09:             else if (usingDerbyNetClient())
1:b8c1e09:                 assertSQLState("XJ208", bue);
1:b8c1e09:             updateCount = ((BatchUpdateException)bue).getUpdateCounts();
1:a86bac7:             if (updateCount != null) {
1:b8c1e09:                 if (usingEmbedded())
1:b8c1e09:                     assertEquals("first statement in the batch caused time out" +
1:b8c1e09:                         " while getting the lock, there should be no update count", 
1:b8c1e09:                         0, updateCount.length);
1:b8c1e09:                 else if (usingDerbyNetClient())
1:b8c1e09:                     /* first statement in the batch caused time out while getting
1:b8c1e09:                      *  the lock, there should be 1 update count of -3 */
1:b8c1e09:                     assertBatchUpdateCounts(new int[] {-3}, updateCount);
1:b8c1e09:             }
1:a86bac7:         }
1:a86bac7:         
1:7383383:         pStmt1.close();
1:7383383:         pStmt2.close();
1:7383383:         
1:7383383:         stmt.close();
1:7383383:         stmt2.close();
1:a86bac7: 
1:7383383:         rollback();
1:a86bac7:         conn2.rollback();
1:1ccacc8:         conn2.close();
1:a86bac7:     }
1:a86bac7: 
1:465c7c7:     /**
1:465c7c7:      * Test that the underlying exception is included in the output when we
1:465c7c7:      * call printStackTrace() on a BatchUpdateException. Earlier, with the
1:465c7c7:      * client driver, the underlying cause of a BatchUpdateException could not
1:465c7c7:      * be seen without calling getNextException().
1:465c7c7:      */
1:465c7c7:     public void testUnderlyingExceptionIsVisible() throws SQLException {
1:465c7c7:         setAutoCommit(false);
1:465c7c7:         Statement s = createStatement();
1:465c7c7:         s.addBatch("create table t(x int unique not null)");
1:465c7c7:         for (int i = 0; i < 3; i++) {
1:465c7c7:             s.addBatch("insert into t values 1");
1:465c7c7:         }
1:465c7c7: 
1:465c7c7:         BatchUpdateException bue = null;
1:465c7c7:         try {
1:465c7c7:             s.executeBatch();
1:465c7c7:         } catch (BatchUpdateException e) {
1:465c7c7:             bue = e;
1:465c7c7:         }
1:465c7c7:         assertNotNull("Did not get duplicate key exception", bue);
1:465c7c7: 
1:465c7c7:         StringWriter w = new StringWriter();
1:465c7c7:         bue.printStackTrace(new PrintWriter(w, true));
1:465c7c7: 
1:465c7c7:         String stackTrace = w.toString();
1:465c7c7:         if (stackTrace.indexOf("duplicate key") == -1) {
1:465c7c7:             fail("Could not see 'duplicate key' in printStackTrace()", bue);
1:465c7c7:         }
1:465c7c7:     }
1:4e1fb4c: 
1:4e1fb4c:     /**
1:4e1fb4c:      * Test the behaviour when one of the statements in a batch fails. The
1:4e1fb4c:      * embedded driver stops executing the batch when that happens, whereas
1:4e1fb4c:      * the client driver continues. The difference between embedded and
1:4e1fb4c:      * client is logged as DERBY-4316.
1:4e1fb4c:      */
1:4e1fb4c:     public void testContinueAfterError() throws SQLException {
1:4e1fb4c:         // Turn off auto-commit so that the tables added by the test can be
1:4e1fb4c:         // rolled back in tearDown().
1:4e1fb4c:         setAutoCommit(false);
1:4e1fb4c: 
1:4e1fb4c:         Statement s = createStatement();
1:4e1fb4c:         s.execute("create table a(x int)");
1:4e1fb4c:         s.execute("create table b(x int primary key)");
1:4e1fb4c:         s.execute("create table c(x int references b(x))");
1:4e1fb4c: 
1:4e1fb4c:         // Drop the three tables in a batch. Since B is referenced by C, it
1:4e1fb4c:         // cannot be dropped before C is dropped. Hence DROP TABLE B will fail.
1:4e1fb4c:         s.addBatch("drop table a");
1:4e1fb4c:         s.addBatch("drop table b");
1:4e1fb4c:         s.addBatch("drop table c");
1:4e1fb4c: 
1:4e1fb4c:         // Embedded stops processing the batch on the first failure, and only
1:4e1fb4c:         // the update count from the successful statement is returned. The
1:4e1fb4c:         // client driver continues after the failure, so it'll also drop C.
1:b54918e:         long[] expectedCounts = usingEmbedded() ?
1:b54918e:             new long[]{0} : new long[]{0, Statement.EXECUTE_FAILED, 0};
1:4e1fb4c: 
1:4e1fb4c:         assertBatchExecuteError("X0Y25", s, expectedCounts);
1:4e1fb4c: 
1:4e1fb4c:         // Table A should not exist after the batch was executed.
1:4e1fb4c:         assertStatementError("42X05", s, "select * from a");
1:4e1fb4c:         // Table B should still exist, since DROP TABLE B failed.
1:4e1fb4c:         assertTableRowCount("B", 0);
1:4e1fb4c: 
1:4e1fb4c:         // Embedded driver stops after failure, so expect table C to exist,
1:4e1fb4c:         // whereas the client driver continues after failure, so expect that
1:4e1fb4c:         // it does not exist.
1:4e1fb4c:         if (usingEmbedded()) {
1:4e1fb4c:             assertTableRowCount("C", 0);
1:4e1fb4c:         } else {
1:4e1fb4c:             assertStatementError("42X05", s, "select * from c");
1:4e1fb4c:         }
1:4e1fb4c:     }
1:b54918e:     ////////////////////////////////////////////////////////////////////////
1:b54918e:     //
1:b54918e:     // NESTED JDBC 4.2 WRAPPER AROUND A BatchUpdateException
1:b54918e:     //
1:b54918e:     ////////////////////////////////////////////////////////////////////////
1:b54918e: 
1:b54918e:     /**
1:b54918e:      * <p>
1:b54918e:      * This wrapper is used to expose JDBC 4.2 methods which can run on
1:b54918e:      * VM rev levels lower than Java 8.
1:b54918e:      * </p>
1:b54918e:      */
1:b54918e:     public  static  class   BatchUpdateExceptionWrapper
1:b54918e:     {
1:b54918e:         private BatchUpdateException    _wrappedException;
1:b54918e: 
1:b54918e:         public BatchUpdateExceptionWrapper( BatchUpdateException wrappedException )
1:b54918e:         {
1:b54918e:             _wrappedException = wrappedException;
1:b54918e:         }
1:b54918e: 
1:b54918e:         public  BatchUpdateException   getWrappedException() { return _wrappedException; }
1:b54918e: 
1:b54918e:         // New methods added by JDBC 4.2
1:b54918e:         public  long[] getLargeUpdateCounts()
1:b54918e:         {
1:b54918e:             return ((long[]) invoke
1:b54918e:                 (
1:b54918e:                  "getLargeUpdateCounts",
1:b54918e:                  new Class[] {},
1:b54918e:                  new Object[] {}
1:b54918e:                  ));
1:b54918e:         }
1:b54918e: 
1:b54918e:         // Reflection minion
1:b54918e:         protected Object  invoke( String methodName, Class[] argTypes, Object[] argValues )
1:b54918e:         {
1:b54918e:             try {
1:b54918e:                 Method  method = _wrappedException.getClass().getMethod( methodName, argTypes );
1:b54918e: 
1:b54918e:                 return method.invoke( _wrappedException, argValues );
1:b54918e:             }
1:b54918e:             catch (Exception nsme) { printException( nsme ); }
1:b54918e: 
1:b54918e:             return null;
1:b54918e:         }
1:b54918e:         private void    printException( Throwable t ) { BaseJDBCTestCase.println( t.getMessage() ); }
1:b54918e:     }
1:b54918e:     
1:a86bac7: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:             ps.setString(1, Integer.toString(i));
commit:b54918e
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
1:      * helper method to check each count in the return array of a BatchUpdateException
1:      */
1:     public  static   void assertBatchUpdateCounts
1:         ( long[] expectedBatchResult, BatchUpdateException bue )
1:     {
1:         assertBatchUpdateCounts( squashLongs( expectedBatchResult ), bue.getUpdateCounts() );
1:         
0:         if ( isJava8() )
1:         {
1:             BatchUpdateExceptionWrapper wrapper = new BatchUpdateExceptionWrapper( bue );
1: 
1:             assertEquals( expectedBatchResult, wrapper.getLargeUpdateCounts() );
1:         }
1:     }
1:    
1:     /** Squash an array of longs into an array of ints */
1:     public static  int[]   squashLongs( long[] longs )
1:     {
1:         int count = (longs == null) ? 0 : longs.length;
1:         int[]   ints = new int[ count ];
1:         for ( int i = 0; i < count; i++ ) { ints[ i ] = (int) longs[ i ]; }
1: 
1:         return ints;
1:     }
1:     
1:     /* 
1:     private static void assertBatchUpdateCounts( 
/////////////////////////////////////////////////////////////////////////
1:     public static void assertBatchExecuteError( 
1:         long[] expectedUpdateCount) 
1:     { 
1:        try {
1:             stmt.executeBatch();
1:             assertBatchUpdateCounts(expectedUpdateCount, bue);
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("X0Y79", stmt, new long[] {});
1:             assertBatchExecuteError("XJ208", stmt, new long[] {-3, 1});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("X0Y79", stmt, new long[] {1});
1:             assertBatchExecuteError("XJ208", stmt, new long[] {1,-3,1});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("X0Y79", stmt, new long[] {1,1});
1:             assertBatchExecuteError("XJ208", stmt, new long[] {1,1,-3});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("XJ208",stmt, new long[] {-3,1});           
/////////////////////////////////////////////////////////////////////////
1:                 assertBatchExecuteError("XJ208", stmt, new long[] {1,1,-3});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("22003", stmt, new long[] {});
1:             assertBatchExecuteError("XJ208", stmt, new long[] {-3,1});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("22003", stmt, new long[] {1});
1:             assertBatchExecuteError("XJ208", stmt, new long[] {1,-3,1});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("22003", stmt, new long[] {1,1});
1:             assertBatchExecuteError("XJ208", stmt, new long[] {1,1,-3});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("X0Y79", pStmt, new long[] {});
1:             assertBatchExecuteError("XJ117", pStmt, new long[] {-3});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("22003", pStmt, new long[] {});
1:             assertBatchExecuteError("XJ208", pStmt, new long[] {-3});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("22003", pStmt, new long[] {1});
1:             assertBatchExecuteError("XJ208", pStmt, new long[] {1,-3,1});
/////////////////////////////////////////////////////////////////////////
1:             assertBatchExecuteError("22003", pStmt, new long[] {1,1});
1:             assertBatchExecuteError("XJ208", pStmt, new long[] {1,1,-3});
/////////////////////////////////////////////////////////////////////////
1:         long[] expectedCounts = usingEmbedded() ?
1:             new long[]{0} : new long[]{0, Statement.EXECUTE_FAILED, 0};
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     // NESTED JDBC 4.2 WRAPPER AROUND A BatchUpdateException
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * This wrapper is used to expose JDBC 4.2 methods which can run on
1:      * VM rev levels lower than Java 8.
1:      * </p>
1:      */
1:     public  static  class   BatchUpdateExceptionWrapper
1:     {
1:         private BatchUpdateException    _wrappedException;
1: 
1:         public BatchUpdateExceptionWrapper( BatchUpdateException wrappedException )
1:         {
1:             _wrappedException = wrappedException;
1:         }
1: 
1:         public  BatchUpdateException   getWrappedException() { return _wrappedException; }
1: 
1:         // New methods added by JDBC 4.2
1:         public  long[] getLargeUpdateCounts()
1:         {
1:             return ((long[]) invoke
1:                 (
1:                  "getLargeUpdateCounts",
1:                  new Class[] {},
1:                  new Object[] {}
1:                  ));
1:         }
1: 
1:         // Reflection minion
1:         protected Object  invoke( String methodName, Class[] argTypes, Object[] argValues )
1:         {
1:             try {
1:                 Method  method = _wrappedException.getClass().getMethod( methodName, argTypes );
1: 
1:                 return method.invoke( _wrappedException, argValues );
1:             }
1:             catch (Exception nsme) { printException( nsme ); }
1: 
1:             return null;
1:         }
1:         private void    printException( Throwable t ) { BaseJDBCTestCase.println( t.getMessage() ); }
1:     }
1:     
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("BatchUpdateTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("BatchUpdateTest");
1:         BaseTestSuite suite = new BaseTestSuite(name);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:85038ef
/////////////////////////////////////////////////////////////////////////
1:         if (JDBC.vmSupportsJDBC42())
commit:d3fbd72
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Regression test case for DERBY-6373.
1:      */
1:     public void testMultipleStatementsBatchWithWarnings() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("insert into t1 values 1");
1: 
1:         // Execute a batch of three deletes. All of them should get a warning
1:         // because no rows matched the WHERE clause.
1:         s.addBatch("delete from t1 where c1 in (select 0 from t1)");
1:         s.addBatch("delete from t1 where c1 in (select 0 from t1)");
1:         s.addBatch("delete from t1 where c1 in (select 0 from t1)");
1:         s.executeBatch();
1: 
1:         // Used to fail with NullPointerException on the client.
1:         SQLWarning w = s.getWarnings();
1: 
1:         // Expect one warning per delete on the client. Embedded gives only
1:         // a single warning.
1:         assertSQLState("02000", w);
1:         w = w.getNextWarning();
1:         if (usingEmbedded()) {
1:             assertNull(w);
1:         } else {
1:             assertSQLState("02000", w);
1:             w = w.getNextWarning();
1:             assertSQLState("02000", w);
1:             w = w.getNextWarning();
1:             assertNull(w);
1:         }
1:     }
1: 
commit:4e1fb4c
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test the behaviour when one of the statements in a batch fails. The
1:      * embedded driver stops executing the batch when that happens, whereas
1:      * the client driver continues. The difference between embedded and
1:      * client is logged as DERBY-4316.
1:      */
1:     public void testContinueAfterError() throws SQLException {
1:         // Turn off auto-commit so that the tables added by the test can be
1:         // rolled back in tearDown().
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1:         s.execute("create table a(x int)");
1:         s.execute("create table b(x int primary key)");
1:         s.execute("create table c(x int references b(x))");
1: 
1:         // Drop the three tables in a batch. Since B is referenced by C, it
1:         // cannot be dropped before C is dropped. Hence DROP TABLE B will fail.
1:         s.addBatch("drop table a");
1:         s.addBatch("drop table b");
1:         s.addBatch("drop table c");
1: 
1:         // Embedded stops processing the batch on the first failure, and only
1:         // the update count from the successful statement is returned. The
1:         // client driver continues after the failure, so it'll also drop C.
0:         int[] expectedCounts = usingEmbedded() ?
0:             new int[]{0} : new int[]{0, Statement.EXECUTE_FAILED, 0};
1: 
1:         assertBatchExecuteError("X0Y25", s, expectedCounts);
1: 
1:         // Table A should not exist after the batch was executed.
1:         assertStatementError("42X05", s, "select * from a");
1:         // Table B should still exist, since DROP TABLE B failed.
1:         assertTableRowCount("B", 0);
1: 
1:         // Embedded driver stops after failure, so expect table C to exist,
1:         // whereas the client driver continues after failure, so expect that
1:         // it does not exist.
1:         if (usingEmbedded()) {
1:             assertTableRowCount("C", 0);
1:         } else {
1:             assertStatementError("42X05", s, "select * from c");
1:         }
1:     }
commit:465c7c7
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
1: import java.io.StringWriter;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that the underlying exception is included in the output when we
1:      * call printStackTrace() on a BatchUpdateException. Earlier, with the
1:      * client driver, the underlying cause of a BatchUpdateException could not
1:      * be seen without calling getNextException().
1:      */
1:     public void testUnderlyingExceptionIsVisible() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         s.addBatch("create table t(x int unique not null)");
1:         for (int i = 0; i < 3; i++) {
1:             s.addBatch("insert into t values 1");
1:         }
1: 
1:         BatchUpdateException bue = null;
1:         try {
1:             s.executeBatch();
1:         } catch (BatchUpdateException e) {
1:             bue = e;
1:         }
1:         assertNotNull("Did not get duplicate key exception", bue);
1: 
1:         StringWriter w = new StringWriter();
1:         bue.printStackTrace(new PrintWriter(w, true));
1: 
1:         String stackTrace = w.toString();
1:         if (stackTrace.indexOf("duplicate key") == -1) {
1:             fail("Could not see 'duplicate key' in printStackTrace()", bue);
1:         }
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:b3691c2
/////////////////////////////////////////////////////////////////////////
1:      * @return embedded Test suite
commit:c53d18a
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * embeddedSuite runs tests only in embedded mode. 
1:      * Used by CollationTest
0:      * @return
1:      */
1:     public static Test embeddedSuite() {
1:         
0:         TestSuite suite = new TestSuite("BatchUpdateTest");
1:         suite.addTest(baseSuite("BatchUpdateTest:embedded"));
1:         return suite;
1:     }
1:     
commit:96c3cce
/////////////////////////////////////////////////////////////////////////
1:             "select count(*) from SYS.SYSTABLES where CAST(tablename AS VARCHAR(128)) like 'DDL%'");
1:             "select count(*) from SYS.SYSALIASES where CAST(alias AS VARCHAR(128)) like 'DDL%'");
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1:      * @param expectedError The sqlstate to look for.
1:      * @param stmt The Statement that contains the Batch to
1:      * @param expectedUpdateCount The expectedUpdateCount array.
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1ccacc8
/////////////////////////////////////////////////////////////////////////
1:         conn2.close();
/////////////////////////////////////////////////////////////////////////
1:         conn2.close();
commit:ad0df6f
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
commit:0225aac
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:             updateCount = bue.getUpdateCounts();
/////////////////////////////////////////////////////////////////////////
1:  
1:         assertBatchUpdateCounts(new int[0], stmt.executeBatch());
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 2);
/////////////////////////////////////////////////////////////////////////
1:         
1:         int[] expectedUpdateCount = new int[1000];
1:         Arrays.fill(expectedUpdateCount, 1);
1:         assertBatchUpdateCounts(expectedUpdateCount, updateCount);
1:         
1:         assertTableRowCount("T1", 1000);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Batch should be cleared, there should be no update count
1:         assertBatchUpdateCounts(new int[0], stmt.executeBatch());
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 3);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1",
1:                 usingEmbedded() ? 0 : 1);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1",
1:                 usingEmbedded() ? 1 : 3);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1",
1:                 usingEmbedded() ? 3 : 5);
1:         assertTableRowCount("T1", 0);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1",
1:                 usingEmbedded() ? 0 : 3);
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1",
1:                 usingEmbedded() ? 1 : 2);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1",
1:                 usingEmbedded() ? 2 : 4);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1",
1:                 usingEmbedded() ? 4 : 6);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 3);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 1);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
1:         assertTableRowCount("T1", 3);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 2);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         int[] expectedUpdateCount = new int[1000];
1:         Arrays.fill(expectedUpdateCount, 1);
1:         assertBatchUpdateCounts(expectedUpdateCount, updateCount);
1:         
1:         assertTableRowCount("T1", 1000);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 2);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 4);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 4);
/////////////////////////////////////////////////////////////////////////
1:         
1:         assertTableRowCount("T1", 8);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 3);
1: 
1:         pStmt.close();       
/////////////////////////////////////////////////////////////////////////
1:         assertBatchUpdateCounts(new int[] {1,1,1}, pStmt.executeBatch());
1:         
1:         assertTableRowCount("T1", 3);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         pStmt.close();
1:         
1:         
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
1:         pStmt.close();
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 0);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         pStmt.close();
1:         assertTableRowCount("T1", 1);
/////////////////////////////////////////////////////////////////////////
1:         pStmt.close();
1:         assertTableRowCount("T1", 1);
/////////////////////////////////////////////////////////////////////////
1:         assertTableRowCount("T1", 1);
1:         
commit:7383383
/////////////////////////////////////////////////////////////////////////
1:         s.execute("delete from t1");
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertSingleValueResultSet(rs, "2");
1:         JDBC.assertSingleValueResultSet(rs, "1");
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
1:         checkps.close();
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
1:         stmt2.close();
/////////////////////////////////////////////////////////////////////////
1:         executeBatchCallableStatement(cs);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         executeBatchCallableStatement(cs);
1: 
/////////////////////////////////////////////////////////////////////////
1:         executeBatchCallableStatement(cs);
1: 
/////////////////////////////////////////////////////////////////////////
1:         executeBatchCallableStatement(cs);
1: 
/////////////////////////////////////////////////////////////////////////
1:         executeBatchCallableStatement(cs);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
0:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         
0:         stmt.close();
1:         
/////////////////////////////////////////////////////////////////////////
0:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         pStmt.close();
0:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         pStmt.close();
0:         stmt.close();
/////////////////////////////////////////////////////////////////////////
0:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("update t1 set c1=3 where c1=?");
/////////////////////////////////////////////////////////////////////////
1:         
1:         pStmt1.close();
1:         pStmt2.close();
1:         
0:         stmt.close();
1:         stmt2.close();
1:         rollback();
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2c140d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // try prepared statement batch without settable parameters.
1:         // Note: also tests for fix of NPE of DERBY-2112
/////////////////////////////////////////////////////////////////////////
1: }
commit:b8c1e09
/////////////////////////////////////////////////////////////////////////
1:  * One fixture tests creating tables in batch, the other fixtures can be grouped
1:  * into 5 rough categories:
1:  *  - tests that verify that correct usage with Statements work as expected
1:  *    - testEmptyStatementBatch()
1:  *      try executing a batch which nothing in it.
1:  *    - testSingleStatementBatch()
1:  *      try executing a batch which one statement in it.
1:  *    - testMultipleStatementsBatch()
1:  *      try executing a batch with 3 different statements in it.
1:  *    - test1000StatementsBatch()
1:  *      try executing a batch with 1000 statements in it.
1:  *    - testAutoCommitTrueBatch()
1:  *      try batch with autocommit true
1:  *    - testCombinationsOfClearBatch()
1:  *      try clear batch
1:  *    - testAssociatedParams()
1:  *      confirm associated parameters run ok with batches
1:  *   
1:  *  - tests that verify that incorrect usage with Statments give appropriate
1:  *    errors
1:  *    - testStatementWithResultSetBatch()
1:  *      statements which will return a resultset are not allowed in batch
1:  *      update. The following case should throw an exception for select.
1:  *      Below trying various placements of select statement in the batch,
1:  *      i.e. as 1st stmt, nth stmt and last stmt
1:  *    - testStatementNonBatchStuffInBatch()
1:  *      try executing a batch with regular statement intermingled.
1:  *    - testStatementWithErrorsBatch()
1:  *      Below trying various placements of overflow update statement
1:  *      in the batch, i.e. as 1st stmt, nth stat and last stmt
1:  *    - testTransactionErrorBatch()
1:  *      try transaction error, i.e. time out while getting the lock
1:  *    
1:  *  - tests that verify that usage with callableStatements work as expected
1:  *    - testCallableStatementBatch()
1:  *      try callable statements
1:  *    - testCallableStatementWithOutputParamBatch()
1:  *      try callable statement with output parameters
1:  *      
1:  *  - tests that verify that correct usage with preparedStatements work as
1:  *    expected
1:  *    - testEmptyValueSetPreparedBatch()
1:  *      try executing a batch which nothing in it.
1:  *    - testNoParametersPreparedBatch()
1:  *      try executing a batch with no parameters. 
0:  *      (fails with NullPointerException with NetworkServer. See DERBY-2112
1:  *    - testSingleValueSetPreparedBatch()
1:  *      try executing a batch which one parameter set in it.
1:  *    - testMultipleValueSetPreparedBatch()
1:  *      try executing a batch with 3 parameter sets in it.
1:  *    - testMultipleValueSetNullPreparedBatch()
1:  *      try executing a batch with 2 parameter sets in it and they are set 
1:  *      to null.
1:  *    - test1000ValueSetPreparedBatch()
1:  *      try executing a batch with 1000 statements in it.
1:  *    - testPreparedStatRollbackAndCommitCombinations()
1:  *      try executing batches with various rollback and commit combinations.
1:  *    - testAutoCommitTruePreparedStatBatch()
1:  *      try prepared statement batch with autocommit true
1:  *    - testCombinationsOfClearPreparedStatBatch()
1:  *      try clear batch
1:  *      
1:  *  - tests that verify that incorrect use with preparedStatements give 
1:  *    appropriate errors
1:  *    - testPreparedStmtWithResultSetBatch()
1:  *      statements which will return a resultset are not allowed in batch
1:  *      update. The following case should throw an exception for select.
1:  *    - testPreparedStmtNonBatchStuffInBatch();
1:  *      try executing a batch with regular statement intermingled.
1:  *    - testPreparedStmtWithErrorsBatch();
1:  *      trying various placements of overflow update statement
1:  *      in the batch
1:  *    - testTransactionErrorPreparedStmtBatch()
1:  *      try transaction error, in this particular case time out while
1:  *      getting the lock
1:  * Almost all fixtures but 1 execute with embedded and 
1:  * NetworkServer/DerbyNetClient - however, there is a difference in 
1:  * functionality between the two when an error condition is reaches. Thus,
1:  * The 1 fixture that ise not running with network server is 
1:  * identified with //TODO: tags and has an if (usingEmbedded()) block and
1:  * a JIRA issue attached to it.
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setAutoCommit(false);
1:         Statement s = createStatement();
0:         try {
0:             s.execute("delete from t1");
0:         } catch (SQLException e) {} // ignore if this fails, 
0:         // if it's the first time, it *will* fail, thereafter, other things
0:         // will fail anyway.
1:         s.close();
1:         suite.addTest(baseSuite("BatchUpdateTest:embedded"));
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:             baseSuite("BatchUpdateTest:client")));
1:         return suite;
1:     }
1:     
1:     protected static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
1:         suite.addTestSuite(BatchUpdateTest.class);
1:                 DatabasePropertyTestSetup.setLockTimeouts(suite, 2, 4)) 
1:         {
1:             /**
1:              * Creates the tables used in the test cases.
1:              * @exception SQLException if a database error occurs
1:              */
1:             protected void decorateSQL(Statement stmt) throws SQLException
1:             {
1:                 stmt.execute("create table t1(c1 int)");
1:                 // for fixture testCallableStatementBatch
1:                 stmt.execute("create table datetab(c1 date)");
1:                 stmt.execute("create table timetab(c1 time)");
1:                 stmt.execute("create table timestamptab(c1 timestamp)");
1:                 stmt.execute("create table usertypetab(c1 DATE)");
1:                 // for fixture testAssociatedParams
1:                 stmt.execute("create table assoc" +
1:                     "(x char(10) not null primary key, y char(100))");
1:                 stmt.execute("create table assocout(x char(10))");
1:             }
1:         };
1:     } 
0:     private void assertBatchUpdateCounts( 
/////////////////////////////////////////////////////////////////////////
1:         String expectedError,
1:         Statement stmt,
0:         int[] expectedUpdateCount) 
1:     throws SQLException 
1:             fail("Expected batchExecute to fail");
1:         } catch (BatchUpdateException bue) {
1:             assertSQLState(expectedError, bue);
1:             updateCount = ((BatchUpdateException)bue).getUpdateCounts();
1:         } 
1:     /* Fixture that verifies tables can be created in batch */
1:     public void testMinimalDDLInBatch() throws SQLException {
1:         
1:         stmt.addBatch("create table ddltsttable1(c1 int)");
1:         stmt.addBatch("create procedure ddlinteg() language java " +
1:             "parameter style java external name 'java.lang.Integer'");
1:         stmt.addBatch("create table ddltable2(c1 date)");
1:         int expectedCount[] = {0,0,0};
1:         assertBatchUpdateCounts(expectedCount, stmt.executeBatch());
1:         ResultSet rs = stmt.executeQuery(
0:             "select count(*) from SYS.SYSTABLES where tablename like 'DDL%'");
0:         JDBC.assertFullResultSet(rs, new String[][] {{"2"}}, true);
1:         rs = stmt.executeQuery(
0:             "select count(*) from SYS.SYSALIASES where alias like 'DDL%'");
0:         JDBC.assertFullResultSet(rs, new String[][] {{"1"}}, true);
1: 
1:         commit();
1:     /* Fixtures that test correct usage of batch handling with Statements */
1:     public void testEmptyStatementBatch() throws SQLException {
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void testSingleStatementBatch() throws SQLException {
1:         Statement stmt = createStatement();
1:         commit();
1:     public void testMultipleStatementsBatch() throws SQLException {
1: 
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void test1000StatementsBatch() throws SQLException {
1: 
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void testAutoCommitTrueBatch() throws SQLException {
1: 
1:         getConnection().setAutoCommit(true);    
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
0:         // turn it false again after the above negative test. 
0:         // should happen automatically, but just in case
0:         getConnection().setAutoCommit(false);    
1:         commit();
1:     public void testCombinationsOfClearBatch() throws SQLException {
1: 
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     public void testAssociatedParams() throws SQLException 
1: 
1:         Statement stmt = createStatement();
1:         PreparedStatement checkps = prepareStatement(
1:         PreparedStatement ps = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         ps = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         ps = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         ps = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:     /* Fixtures that test incorrect batch usage with Statements */
1:     public void testStatementWithResultSetBatch() throws SQLException {
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         rollback();
0:             0, rs.getInt(1));
1:         commit();
1:     public void testStatementNonBatchStuffInBatch() throws SQLException {
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:             rollback();
/////////////////////////////////////////////////////////////////////////
1:         // trying executeQuery after addBatch
1:         println("Negative Statement: " +
1:             "statement testing executeQuery in the middle of batch");
1:         stmt.addBatch("insert into t1 values(1)");
1:         if (usingEmbedded())
1:             try
1:             {
1:                 stmt.executeQuery("SELECT * FROM SYS.SYSTABLES");
1:                 fail("Expected executeQuerywith embedded");
1:             } catch (SQLException sqle) {
1:                 /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:                 assertSQLState("XJ068", sqle);
1:                 // do clearBatch so we can proceed
1:                 stmt.clearBatch();
1:             }
1:         }
1:         else if (usingDerbyNetClient())
1:         {
1:             assertBatchUpdateCounts(new int[] {1}, updateCount);
1:             // set to same spot as embedded
1:             rollback();
/////////////////////////////////////////////////////////////////////////
1:         // trying executeUpdate after addBatch
1:         println("Negative Statement: " +
1:         "statement testing executeUpdate in the middle of batch");
1:         stmt.addBatch("insert into t1 values(1)");
/////////////////////////////////////////////////////////////////////////
1:         rollback();
1:         commit();
1:     public void testStatementWithErrorsBatch() throws SQLException {
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void testTransactionErrorBatch() throws SQLException {
1:         // conn is just default connection
1:         Connection conn = getConnection();
1:         Connection conn2 = openDefaultConnection();
1:         conn.setAutoCommit(false);
1:         conn2.setAutoCommit(false);        
1:         Statement stmt = conn.createStatement();
1:         Statement stmt2 = conn2.createStatement();
1:         
1:         println("Negative Statement: statement testing time out" +
1:             " while getting the lock in the batch");
1: 
1:         stmt.execute("insert into t1 values(1)");
1:         stmt2.execute("insert into t1 values(2)");
1: 
1:         stmt.addBatch("update t1 set c1=3 where c1=2");
1:         stmt2.addBatch("update t1 set c1=4 where c1=1");
1: 
1:             updateCount = stmt2.executeBatch();
1:         } catch (BatchUpdateException bue) {
1:             if (usingEmbedded())
1:                 assertSQLState("40XL1", bue);
1:             else if (usingDerbyNetClient())
1:                 assertSQLState("XJ208", bue);
1:             updateCount = ((BatchUpdateException)bue).getUpdateCounts();
1:                 if (usingEmbedded())
1:                     assertEquals("first statement in the batch caused time out" +
1:                         " while getting the lock, there should be no update count", 
1:                         0, updateCount.length);
1:                 else if (usingDerbyNetClient())
1:                     /* first statement in the batch caused time out while getting
1:                      *  the lock, there should be 1 update count of -3 */
1:                     assertBatchUpdateCounts(new int[] {-3}, updateCount);
1:         commit();
1:     /* Fixtures that test batch updates with CallableStatements */
1:     public void testCallableStatementBatch() throws SQLException {
1: 
1:         CallableStatement cs = prepareCall("insert into t1 values(?)");
/////////////////////////////////////////////////////////////////////////
1:         cleanUpCallableStatement(cs, "t1");
1:         cs = prepareCall("insert into datetab values(?)");
/////////////////////////////////////////////////////////////////////////
1:         cleanUpCallableStatement(cs, "datetab");
1:         cs = prepareCall("insert into timetab values(?)");
/////////////////////////////////////////////////////////////////////////
1:         cleanUpCallableStatement(cs, "timestamptab");
1:         cs = prepareCall("insert into timestamptab values(?)");
/////////////////////////////////////////////////////////////////////////
1:         cleanUpCallableStatement(cs, "timestamptab");
1:         cs = prepareCall("insert into usertypetab values(?)");
/////////////////////////////////////////////////////////////////////////
1:         cleanUpCallableStatement(cs, "usertypetab");
1:     // helper method to testCallableStatementBatch 
/////////////////////////////////////////////////////////////////////////
1:             2, updateCount.length);
1:     // helper method to testCallableStatementBatch - 
1:     protected void cleanUpCallableStatement(
1:         CallableStatement cs, String tableName)
0:         getConnection();
1:         rollback();
1:         cs = prepareCall("delete from " + tableName);
1:         commit();
1:     public void testCallableStatementWithOutputParamBatch() 
1:         Statement s = createStatement();
1:             "takesString(OUT P1 VARCHAR(40), IN P2 INT) " +
1:             "EXTERNAL NAME '" + this.getClass().getName() + ".takesString'" +
1:         CallableStatement cs = prepareCall("call takesString(?,?)");
1:         cs.registerOutParameter(1, Types.CHAR);
1:         cs.setInt(2, Types.INTEGER);
/////////////////////////////////////////////////////////////////////////
1:         rollback();
1:         commit();
1:     }
1:     
1:     // helper method to be used as procedure in test 
1:     // testCallableStatementWithOutputParamBatch
1:     public static void takesString(String[] outparam, int type) 
1:     throws Throwable
1:     {
1:         // method is stripped from takesString in jdbcapi/outparams.java
1:         outparam[0] = "3";
1:     /* Fixtures that test correct usage with PreparedStatements */    
1:     public void testEmptyValueSetPreparedBatch() throws SQLException {
1:         Statement stmt = createStatement();
1:         
1:             prepareStatement("insert into t1 values(?)");
1:         commit();
1:     public void testNoParametersPreparedBatch() throws SQLException {
1: 
0:         // TODO: analyze & implement for NetworkServer when DERBY-2112 is fixed
0:         // test fails with NullPointerException with NetworkServer
0:         // see DERBY-2112
0:         if (!usingEmbedded())
0:             return;
1:      
1:         Statement stmt = createStatement();
1:             prepareStatement("insert into t1 values(5)");
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void testSingleValueSetPreparedBatch() throws SQLException {
1: 
1:         Statement stmt = createStatement();
1:             prepareStatement("insert into t1 values(?)");
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void testMultipleValueSetPreparedBatch() throws SQLException {
1: 
1:         Statement stmt = createStatement();
1:             prepareStatement("insert into t1 values(?)");
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void testMultipleValueSetNullPreparedBatch() throws SQLException {
1: 
1:         Statement stmt = createStatement();
1:             prepareStatement("insert into t1 values(?)");
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void test1000ValueSetPreparedBatch() throws SQLException {
1:         
0:         Statement stmt = createStatement();
1:             prepareStatement("insert into t1 values(?)");
/////////////////////////////////////////////////////////////////////////
0:             1000, rs.getInt(1));
1:         commit();
1:     public void testPreparedStatRollbackAndCommitCombinations() 
1:     throws SQLException {
0:         Statement stmt = createStatement();
1:             " batch and commit combinations");
1:             prepareStatement("insert into t1 values(?)");
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void testAutoCommitTruePreparedStatBatch() throws SQLException {
1: 
1:         getConnection().setAutoCommit(true);    
0:         Statement stmt = createStatement();
1: 
1:             prepareStatement("insert into t1 values(?)");
/////////////////////////////////////////////////////////////////////////
0:         // turn it false again after the above negative test
0:         // should happen automatically, but doesn't hurt
0:         getConnection().setAutoCommit(false);    
1:         commit();
1:     public void testCombinationsOfClearPreparedStatBatch() 
1:     throws SQLException {
0:         Statement stmt = createStatement();
1:             prepareStatement("insert into t1 values(?)");
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     /* Fixtures that test incorrect usage with PreparedStatements */
1:     public void testPreparedStmtWithResultSetBatch() throws SQLException {
0:         Statement stmt = createStatement();
1:             prepareStatement("select * from t1 where c1=?");
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:     public void testPreparedStmtNonBatchStuffInBatch() throws SQLException {
1:         
0:         Statement stmt = createStatement();
1: 
1:         // trying execute in the middle of batch
1:         println("Negative Prepared Stat: " +
1:             "testing execute in the middle of batch");
1:         PreparedStatement pStmt = 
1:             prepareStatement("select * from t1 where c1=?");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:             if (usingEmbedded())
1:                 fail("Expected executeBatch to fail");
1:             else if (usingDerbyNetClient())
1:                 updateCount = pStmt.executeBatch();
/////////////////////////////////////////////////////////////////////////
1:         // trying executeQuery in the middle of batch
1:         println("Negative Prepared Statement: " +
1:             "testing executeQuery in the middle of batch");
1:         pStmt = 
1:             prepareStatement("select * from t1 where c1=?");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:             if (usingEmbedded())
1:                 fail("Expected executeBatch to fail");
1:             else if (usingDerbyNetClient())
1:                 updateCount = pStmt.executeBatch();
/////////////////////////////////////////////////////////////////////////
1:         //  trying executeUpdate in the middle of batch
1:         println("Negative Prepared Stat: " +
1:             "testing executeUpdate in the middle of batch");
1:         pStmt = 
1:             prepareStatement("select * from t1 where c1=?");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:             if (usingEmbedded())
1:                 fail("Expected executeBatch to fail");
1:             else if (usingDerbyNetClient())
1:                 updateCount = pStmt.executeBatch();
/////////////////////////////////////////////////////////////////////////
0:         commit();
1:     public void testPreparedStmtWithErrorsBatch() throws SQLException {
1: 
0:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         pStmt = prepareStatement("update t1 set c1=(? + 1)");
/////////////////////////////////////////////////////////////////////////
1:         pStmt = prepareStatement("update t1 set c1=(? + 1)");
/////////////////////////////////////////////////////////////////////////
1:         pStmt = prepareStatement("update t1 set c1=(? + 1)");
/////////////////////////////////////////////////////////////////////////
0:         commit();
1:     public void testTransactionErrorPreparedStmtBatch() throws SQLException {
1: 
1:         Connection conn = getConnection();
1:         Connection conn2 = openDefaultConnection();
1:         conn.setAutoCommit(false);
1:         conn2.setAutoCommit(false);        
0:         Statement stmt = conn.createStatement();
1:         Statement stmt2 = conn2.createStatement();
1: 
1:         println("Negative Prepared Statement: " +
1:             "testing transaction error, time out while getting the lock");
1: 
1:         stmt.execute("insert into t1 values(1)");
1:         stmt2.execute("insert into t1 values(2)");
1: 
1:         PreparedStatement pStmt1 = 
0:             conn.prepareStatement("update t1 set c1=3 where c1=?");
1:         pStmt1.setInt(1, 2);
1:         pStmt1.addBatch();
1: 
1:         PreparedStatement pStmt2 = 
1:             conn.prepareStatement("update t1 set c1=4 where c1=?");
1:         pStmt2.setInt(1, 1);
1:         pStmt2.addBatch();
1: 
1:         } catch (BatchUpdateException bue) {
1:             if (usingEmbedded())
1:                 assertSQLState("40XL1", bue);
1:             else if (usingDerbyNetClient())
1:                 assertSQLState("XJ208", bue);
0:             updateCount = ((BatchUpdateException)bue).getUpdateCounts();
1:                 if (usingEmbedded())
1:                     assertEquals("first statement in the batch caused time out" +
1:                         " while getting the lock, there should be no update count", 
1:                         0, updateCount.length);
1:                 else if (usingDerbyNetClient())
1:                     /* first statement in the batch caused time out while getting
1:                      *  the lock, there should be 1 update count of -3 */
1:                     assertBatchUpdateCounts(new int[] {-3}, updateCount);
0:         commit();
1: }
commit:a86bac7
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class 
1:        org.apache.derbyTesting.functionTests.tests.jdbcapi.BatchUpdateTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.BatchUpdateException;
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.Date;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.sql.Types;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: 
1: /**
1:  * Test BatchUpdate functionality.
1:  * <P>
1:  * This test examines the behavior fo BatchUpdate test.
0:  * There are 5 actual fixtures, and even the setup is executing in batch, to 
0:  * verify basic create table and insert statements also work in batch.
0:  * The five actual fixtures are:
0:  * testStatementBatchUpdatePositive - verifies correct usage with Statements 
0:  *                                work as expected 
0:  * testStatementBatchUpdateNegative - verifies incorrect usage with Statments
0:  *                                gives appropriate errors
0:  * testCallableStatementBatchUpdate - verifies usage with callableStatements
0:  *                                works as expected
0:  * testPreparedStatementBatchUpdatePositive
0:  *                              - verifies correct usage with preparedStatements
0:  * testPreparedStatementBatchUpdateNegative
0:  *                              - verifies incorrect use with preparedStatements
1:  * 
0:  * The test executes almost all submethods of these fixtures with both
0:  * embedded and NetworkServer/DerbyNetClient - however, there is a difference
0:  * in functionality between the two when an error condition is reaches. Thus,
1:  * the negative tests have if / else if blocks for embedded and client.
1:  * 
0:  * The three subtests that are not running with network server are 
0:  * identified with //TODO: tags and have an if (usingEmbedded()) block.
1:  * 
1:  */
1: 
1: public class BatchUpdateTest extends BaseJDBCTestCase {
1: 	
1:     /** Creates a new instance of BatchUpdateTest */
1:     public BatchUpdateTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Set up the conection to the database.
1:      *  This is itself a test of statements creating tables in batch. 
1:      */
1:     public void setUp() throws  Exception {
0:         Connection conn = getConnection();
0:         conn.setAutoCommit(false);
0:         Statement stmt = createStatement();
0:         stmt.addBatch("create table t1(c1 int)");
0:         stmt.addBatch("create procedure Integ() language java " +
0:             "parameter style java external name 'java.lang.Integer'");
0:         stmt.addBatch("create table datetab(c1 date)");
0:         stmt.addBatch("create table timetab(c1 time)");
0:         stmt.addBatch("create table timestamptab(c1 timestamp)");
0:         stmt.addBatch("create table usertypetab(c1 DATE)");
1: 
0:         int expectedCount[] = {0,0,0,0,0,0};
0:         assertBatchUpdateCounts(expectedCount, stmt.executeBatch());
1:         
0:         // for method checkAssociatedParams
0:         stmt.executeUpdate("create table assoc" +
0:                 "(x char(10) not null primary key, y char(100))");
0:         stmt.executeUpdate("create table assocout(x char(10))");
1:         
0:         conn.commit();
1:     }
1: 
0:     protected void tearDown() throws Exception {
0:         Statement stmt = createStatement();
0:         stmt.executeUpdate("DROP TABLE datetab");
0:         stmt.executeUpdate("DROP TABLE timetab");
0:         stmt.executeUpdate("DROP TABLE timestamptab");
0:         stmt.executeUpdate("DROP TABLE usertypetab");
0:         stmt.executeUpdate("DROP PROCEDURE Integ");
0:         stmt.executeUpdate("DROP TABLE t1");
0:         // for method checkAssociatedParams
0:         stmt.executeUpdate("drop table assoc");
0:         stmt.executeUpdate("drop table assocout");
0:         commit();
0:         super.tearDown();
1:     }
1:     
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("BatchUpdateTest");
0:         suite.addTest(
0:             TestConfiguration.defaultSuite(BatchUpdateTest.class));
1: 
1:         return new CleanDatabaseTestSetup(
0:             DatabasePropertyTestSetup.setLockTimeouts(suite, 2, 4));
1:      }
1:     
1:     /* 
1:      * helper method to check each count in the return array of batchExecute
1:      */
0:     public void assertBatchUpdateCounts( 
1:         int[] expectedBatchResult, int[] executeBatchResult )
1:     {
1:         assertEquals("length of array should be identical", 
1:             expectedBatchResult.length, executeBatchResult.length);
1:         
1:         for (int i=0; i<expectedBatchResult.length; i++)
1:         {
1:             String msg = "mismatch for array index [" + i + "] ; ";
1:             assertEquals(msg,expectedBatchResult[i],executeBatchResult[i]);
1:             println("expectedUpdate result #" + i + " : " +
1:                 expectedBatchResult[i]);
1:             println("actual result #" + i + " : " + executeBatchResult[i]);
1:         }
1:     }
1:     
1:     /** 
1:      * helper method to evaluate negative tests where we expect a 
1:      * batchExecuteException to be returned.
1:      * @exception SQLException     Thrown if the expected error occurs
1:      *                             We expect a BatchUpdateException, and
1:      *                             verify it is so.
1:      *
0:      * @param String               The sqlstate to look for.
0:      * @param Statement            The Statement that contains the Batch to
1:      *                             be executed.
0:      * @param int[]                The expectedUpdateCount array.
1:      */
0:     protected void assertBatchExecuteError( 
0:             String expectedError,
0:             Statement stmt,
0:             int[] expectedUpdateCount) throws SQLException 
1:     {
0:         int[] updateCount;    
0:         try {
1:             updateCount = stmt.executeBatch();
0:             fail("Expected stmt.batchExecute to fail");
1:         } catch (SQLException sqle) {
0:             assertSQLState(expectedError, sqle);
0:             assertTrue("Expect BatchUpdateException", 
0:                 (sqle instanceof BatchUpdateException));
0:             updateCount = ((BatchUpdateException)sqle).getUpdateCounts();
0:             assertBatchUpdateCounts(expectedUpdateCount, updateCount);
1:         }
1:     }
1: 
1: 
1:     /** 
1:      * helper method to evaluate negative tests where we expect a
0:      * batchExecuteException to be returned
1:      * 
0:      * @exception SQLException     Thrown if the expected error occurs.
1:      *                             We expect a BatchUpdateException, and
1:      *                             verify it is so.
1:      *
0:      * @param String               The sqlstate to look for.
0:      * @param PreparedStatement    The PreparedStatement that contains the 
0:      *                             batch to be executed.
0:      * @param int[]                The expectedUpdateCount array.
1:      *                             
1:      */
0:     protected void assertBatchExecuteError( 
0:             String expectedError,
0:             PreparedStatement pstmt,
0:             int[] expectedUpdateCount) throws SQLException 
1:     {
0:         int[] updateCount;    
0:         try {
0:             updateCount = pstmt.executeBatch();
0:             fail("Expected pstmt.batchExecute to fail");
1:         } catch (SQLException sqle) {
0:             assertSQLState(expectedError, sqle);
0:             assertTrue("Expect BatchUpdateException", 
0:                 (sqle instanceof BatchUpdateException));
0:             updateCount = ((BatchUpdateException)sqle).getUpdateCounts();
0:             assertBatchUpdateCounts(expectedUpdateCount, updateCount);
1:         }
1:     }
1:     
1:     /**
0:      * Positive tests for statement batch update.
1:      *
0:      * @exception SQLException      Thrown if some unexpected error happens
1:      */
0:     public void testStatementBatchUpdatePositive()
1:     throws SQLException
1:     {
0:         Connection conn = getConnection();
0:         Statement stmt = createStatement();
0:         // try executing a batch which nothing in it.
0:         runEmptyStatementBatch(conn, stmt);
0:         // try executing a batch which one statement in it.
0:         runSingleStatementBatch(conn, stmt);
1:         // try executing a batch with 3 different statements in it.
0:         runMultipleStatementsBatch(conn, stmt);
1:         // try executing a batch with 1000 statements in it.
0:         run1000StatementsBatch(conn, stmt);
1:         // try batch with autocommit true
0:         runAutoCommitTrueBatch(conn, stmt);
0:         // try clear batch
0:         runCombinationsOfClearBatch(conn, stmt);
0:         // confirm associated parameters run ok with batches
0:         checkAssociatedParams(conn, stmt);
0:         conn.commit();
1:     }
1: 
1:     /**
0:      * Negative tests for statement batch update.
1:      * 
0:      * @exception SQLException      Thrown if some unexpected error happens
1:      */
0:     public void testStatementBatchUpdateNegative() throws SQLException 
1:     {
0:         Connection conn = getConnection();
0:         Connection conn2 = openDefaultConnection();
0:         conn.setAutoCommit(false);
0:         conn2.setAutoCommit(false);        
0:         Statement stmt = conn.createStatement();
0:         Statement stmt2 = conn2.createStatement();
1: 
1:         // statements which will return a resultset are not allowed in batch
1:         // update. The following case should throw an exception for select.
1:         // Below trying various placements of select statement in the batch,
0:         // i.e. as 1st stmt, nth stmt and last stmt
0:         runStatementWithResultSetBatch(conn, stmt);
1: 
1:         // try executing a batch with regular statement intermingled.
0:         runStatementNonBatchStuffInBatch(conn, stmt);
1: 
0:         // Below trying various placements of overflow update statement 
0:         // in the batch, i.e. as 1st stmt, nth stat and last stmt
0:         runStatementWithErrorsBatch(conn, stmt);
1: 
0:         // TODO: When running this with networkserver, we won't be able
0:         // to drop t1 afterwards. Needs researching.
1:         if (usingEmbedded())
0:             // try transaction error, i.e. time out while getting the lock
0:             runTransactionErrorBatch(conn, stmt, conn2, stmt2);
1:         
1:      }
1: 
1:     /**
0:      * Tests for callable statement batch update.
1:      *
0:      * @exception SQLException      Thrown if some unexpected error happens
1:      */
0:     public void testCallableStatementBatchUpdate()
1:     throws SQLException
1:     {
0:         Connection conn = getConnection();
1:         
1:         // try callable statements
0:         runCallableStatementBatch(conn);
1: 
0:         // try callable statement with output parameters
0:         runCallableStatementWithOutputParamBatch(conn);
1:     }
1:     
1:     /**
0:      * Positive tests for prepared statement batch update.
1:      *
0:      *  @exception SQLException      Thrown if some unexpected error happens
1:      */
0:     public void testPreparedStatementBatchUpdatePositive()
1:     throws SQLException 
1:     {
0:         Connection conn = getConnection();
0:         Statement stmt = createStatement();
1: 
0:         //try executing a batch which nothing in it.
0:         runEmptyValueSetPreparedBatch(conn, stmt);
1: 
0:         // following fails with NullPointerException with NetworkServer
0:         // see DERBY-2112
1:         if (usingEmbedded())
0:         // try executing a batch with no parameters.
0:             runNoParametersPreparedBatch(conn, stmt);
1: 
0:         // try executing a batch which one parameter set in it.
0:         runSingleValueSetPreparedBatch(conn, stmt);
1: 
0:         // try executing a batch with 3 parameter sets in it.
0:         runMultipleValueSetPreparedBatch(conn, stmt);
1: 
0:         // try executing a batch with 2 parameter sets in it 
0:         // and they are set to null.
0:         runMultipleValueSetNullPreparedBatch(conn, stmt);
1: 
1:         // try executing a batch with 1000 statements in it.
0:         run1000ValueSetPreparedBatch(conn, stmt);
1: 
1:         // try executing batches with various rollback and commit combinations.
0:         runPreparedStatRollbackAndCommitCombinations(conn, stmt);
1: 
1:         // try prepared statement batch with autocommit true
0:         runAutoCommitTruePreparedStatBatch(conn, stmt);
1: 
0:         // try clear batch
0:         runCombinationsOfClearPreparedStatBatch(conn, stmt);
1: 
1:     }
1:        
1:     /**
0:      * Negative tests for prepared statement batch update.
1:      *
0:      *  @exception SQLException      Thrown if some unexpected error happens
1:      */
0:     public void testPreparedStatementBatchUpdateNegative() throws SQLException 
1:     {
1: 
0:         Connection conn = getConnection();
0:         Connection conn2 = openDefaultConnection();
0:         conn.setAutoCommit(false);
0:         conn2.setAutoCommit(false);        
0:         Statement stmt = conn.createStatement();
0:         Statement stmt2 = conn2.createStatement();
1:         
1:         // statements which will return a resultset are not allowed in batch
1:         // update. The following case should throw an exception for select.
0:         runPreparedStmtWithResultSetBatch(conn, stmt);
1: 
1:         // try executing a batch with regular statement intermingled.
0:         runPreparedStmtNonBatchStuffInBatch(conn, stmt);
1: 
0:         // Below trying various placements of overflow update statement 
0:         // in the batch
0:         runPreparedStmtWithErrorsBatch(conn, stmt);
1: 
0:         // TODO: when running this test with NetworkServer, t1 can
0:         //       no longer be dropped. Needs research.
1:         if (usingEmbedded())
1:             // try transaction error, in this particular case time out while 
1:             // getting the lock
0:             runTransactionErrorPreparedStmtBatch(conn, stmt, conn2, stmt2);
1:     }
1: 	
0:     /* Following are methods used in testStatementUpdateBatchPositive */
1:     
1:     // try executing a batch which nothing in it. Should work.
0:     protected void runEmptyStatementBatch(Connection conn, Statement stmt) 
1:     throws SQLException {
1:         int updateCount[];
1: 
1:         // try executing a batch which nothing in it. Should work.
1:         println("Positive Statement: clear the batch and run the empty batch");
1:         stmt.clearBatch();
1:         updateCount = stmt.executeBatch();
0:         assertEquals("expected updateCount of 0", 0, updateCount.length);
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1: 
1:     // try executing a batch which single statement in it. Should work.
0:     protected void runSingleStatementBatch(Connection conn, Statement stmt) 
1:     throws SQLException {
1: 
1:         println("Positive Statement: testing 1 statement batch");
1:         stmt.addBatch("insert into t1 values(2)");
1: 
1:         assertBatchUpdateCounts(new int[] {1}, stmt.executeBatch());
1:             
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try executing a batch with 3 different statements in it.
0:     protected void runMultipleStatementsBatch(
0:             Connection conn, Statement stmt) throws SQLException {
1:         ResultSet rs;
1: 
1:         println("Positive Statement: testing 2 inserts and 1 update batch");
1:         stmt.addBatch("insert into t1 values(2)");
1:         stmt.addBatch("update t1 set c1=4");
1:         stmt.addBatch("insert into t1 values(3)");
1: 
1:         assertBatchUpdateCounts(new int[] {1,1,1}, stmt.executeBatch());
1:         
1:         rs = stmt.executeQuery("select count(*) from t1 where c1=2");
1:         rs.next();
1:         assertEquals("expect 0 rows with c1 = 2", 0, rs.getInt(1));
1:         rs.close();
1: 
1:         rs = stmt.executeQuery("select count(*) from t1 where c1=4");
1:         rs.next();
1:         assertEquals("expect 1 row with c1 = 4", 1, rs.getInt(1));
1:         rs.close();
1: 
1:         rs = stmt.executeQuery("select count(*) from t1 where c1=3");
1:         rs.next();
1:         assertEquals("expect 1 row with c1 = 3", 1, rs.getInt(1));
1:         rs.close();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("expect 2 rows total", 2, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1: 
1:     // try executing a batch with 1000 statements in it.
0:     protected void run1000StatementsBatch(Connection conn, Statement stmt) 
1:     throws SQLException {
1:         int updateCount[];
1:         ResultSet rs;
1: 
1:         println("Positive Statement: 1000 statements batch");
1:         for (int i=0; i<1000; i++){
1:             stmt.addBatch("insert into t1 values(1)");
1:         }
1:         updateCount = stmt.executeBatch();
0:         assertEquals("1000 statement in the batch, expect update count 1000", 
0:             1000, updateCount.length);
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("1000 statement in the batch, expect 1000 rows",
0:             1000, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1: 
1:     // try batch with autocommit true
0:     protected void runAutoCommitTrueBatch(Connection conn, Statement stmt) 
1:     throws SQLException {
1:         ResultSet rs;
1: 
0:         conn.setAutoCommit(true);
1:         // try batch with autocommit true
1:         println("Positive Statement: stmt testing with autocommit true");
1:         stmt.addBatch("insert into t1 values(1)");
1:         stmt.addBatch("insert into t1 values(1)");
1:         stmt.addBatch("delete from t1");
1:         assertBatchUpdateCounts(new int[] {1,1,2}, stmt.executeBatch());
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("expect 0 rows", 0,rs.getInt(1));
1:         rs.close();
1: 
0:         //turn it true again after the above negative test
0:         conn.setAutoCommit(false);
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1: 
1:     //  try combinations of clear batch.
0:     protected void runCombinationsOfClearBatch(
0:             Connection conn, Statement stmt) throws SQLException {
1:         ResultSet rs;
1: 
1:         println("Positive Statement: add 3 statements, clear and execute batch");
1:         stmt.addBatch("insert into t1 values(2)");
1:         stmt.addBatch("insert into t1 values(2)");
1:         stmt.addBatch("insert into t1 values(2)");
1:         stmt.clearBatch();
1: 
0:         assertEquals("Batch should be cleared, there should be no update count",
0:             0, stmt.executeBatch().length);
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         JDBC.assertEmpty(rs);
1:         rs.close();
1: 
1:         println("Positive Statement: add 3 statements, clear batch, " +
1:             "add 3 more statements and execute batch");
1:         stmt.addBatch("insert into t1 values(2)");
1:         stmt.addBatch("insert into t1 values(2)");
1:         stmt.addBatch("insert into t1 values(2)");
1:         stmt.clearBatch();
1:         stmt.addBatch("insert into t1 values(2)");
1:         stmt.addBatch("insert into t1 values(2)");
1:         stmt.addBatch("insert into t1 values(2)");
1: 
1:         assertBatchUpdateCounts(new int[] {1,1,1}, stmt.executeBatch());
0:         rs = stmt.executeQuery("select count(*) from t1");
0:         JDBC.assertFullResultSet(rs, new String[][] {{"3"}}, true);
1: 
1:         rs.close();
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1: 
1:     /*
1:      ** Associated parameters are extra parameters that are created
1:      ** and associated with the root parameter (the user one) to
1:      ** improve the performance of like.       For something like
1:      ** where c1 like ?, we generate extra 'associated' parameters 
1:      ** that we use for predicates that we give to the access
1:      ** manager. 
1:      */
0:     protected void checkAssociatedParams(Connection conn, Statement stmt)
1:     throws SQLException 
1:     {
1:         int i;
0:         conn.setAutoCommit(false);
1:         println("Positive Statement: testing associated parameters");
0:         PreparedStatement checkps = conn.prepareStatement(
1:             "select x from assocout order by x");
0:         PreparedStatement ps = conn.prepareStatement(
1:             "insert into assoc values (?, 'hello')");
1:         for ( i = 10; i < 60; i++)
1:         {
0:             ps.setString(1, new Integer(i).toString());
1:             ps.executeUpdate();     
1:         }
1: 
0:         ps = conn.prepareStatement(
1:             "insert into assocout select x from assoc where x like ?");
1:         ps.setString(1, "33%");
1:         ps.addBatch();
1:         ps.setString(1, "21%");
1:         ps.addBatch();
1:         ps.setString(1, "49%");
1:         ps.addBatch();
1:         
1:         assertBatchUpdateCounts(new int[] {1,1,1}, ps.executeBatch());
1:         checkps.execute();
1:         ResultSet rs = checkps.getResultSet();
1:         JDBC.assertFullResultSet(
1:             rs, new String[][] {{"21"},{"33"},{"49"}}, true);
1:                 
1:         stmt.executeUpdate("delete from assocout");
1: 
0:         ps = conn.prepareStatement(
1:                 "insert into assocout select x from assoc where x like ?");
1:         ps.setString(1, "3%");
1:         ps.addBatch(); // expectedCount 10: values 10-19
1:         ps.setString(1, "2%");
1:         ps.addBatch(); // values 20-29
1:         ps.setString(1, "1%");
1:         ps.addBatch(); // values 30-39
1: 
1:         // set up expected values for check
1:         String expectedStrArray[][] = new String[30][1];
1:         for (i=10 ; i < 40 ; i++)
1:         {
1:             expectedStrArray[i-10][0] = String.valueOf(i);
1:         }
1:    
1:         assertBatchUpdateCounts( new int[] {10,10,10}, ps.executeBatch());
1:         checkps.execute();
1:         rs = checkps.getResultSet();
1:         JDBC.assertFullResultSet(rs, expectedStrArray, true);
1:                 
1:         stmt.executeUpdate("delete from assocout");
0:         ps = conn.prepareStatement(
1:             "insert into assocout select x from assoc where x like ?");
1:         ps.setString(1, "%");// values 10-59
1:         ps.addBatch();
1:         ps.setString(1, "666666");
1:         ps.addBatch();
1:         ps.setString(1, "%");// values 10-59
1:         ps.addBatch();
1:         
1:         // set up expected values for check
1:         String expectedStrArray2[][] = new String[100][1];
1:         int j = 0;
1:         for (i=10 ; i < 60 ; i++)
1:         {  
1:             for (int twice = 0; twice < 2; twice++)
1:             {
1:                 expectedStrArray2[j][0] = String.valueOf(i);
1:                 j++;
1:             }
1:         }
1:         
1:         assertBatchUpdateCounts (new int[] {50,0,50}, ps.executeBatch());
1:         checkps.execute();
1:         rs = checkps.getResultSet();
1:         JDBC.assertFullResultSet(rs, expectedStrArray2, true);
1:     }
1: 
0:     /* Following are methods used in testStatementBatchUpdateNegative */
1: 
1:     // statements which will return a resultset are not allowed in batch
1:     // update. The following case should throw an exception for select. 
1:     // Below trying various placements of select statement in the batch,
1:     // i.e. as 1st stmt, nth stat and last stmt
0:     protected void runStatementWithResultSetBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1:         
1:         ResultSet rs;
1: 
1:         // trying select as the first statement
1:         println("Negative Statement: statement testing select as first " +
1:             "statement in the batch");
1:         stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
1:         stmt.addBatch("insert into t1 values(1)");
1:         if (usingEmbedded())
1:             /* Ensure the exception is the ResultSetReturnNotAllowed */
0:             assertBatchExecuteError("X0Y79", stmt, new int[] {});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ208", stmt, new int[] {-3, 1});
1:         
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
1:         if (usingEmbedded())
0:             assertEquals(
0:                 "There should be no rows in the table", 0, rs.getInt(1));
1:         else if (usingDerbyNetClient())
0:             assertEquals("There will be 1 row in the table", 1, rs.getInt(1));
1:         rs.close();
1:         
1:         // trying select as the nth statement
1:         println("Negative Statement: " +
1:             "statement testing select as nth stat in the batch");
1:         stmt.addBatch("insert into t1 values(1)");
1:         stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
1:         stmt.addBatch("insert into t1 values(1)");
1:         if (usingEmbedded())
1:             /* Ensure the exception is the ResultSetReturnNotAllowed */
0:             assertBatchExecuteError("X0Y79", stmt, new int[] {1});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ208", stmt, new int[] {1,-3,1});
1:             
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
1:         if (usingEmbedded())
0:             assertEquals(
0:                 "There should be 1 row in the table", 1, rs.getInt(1));
1:         else if (usingDerbyNetClient())
0:             assertEquals("There are 3 rows in the table", 3, rs.getInt(1));
1:         rs.close();
1: 
1:         // trying select as the last statement
1:         println("Negative Statement: statement testing select" +
1:             " as last stat in the batch");
1:         stmt.addBatch("insert into t1 values(1)");
1:         stmt.addBatch("insert into t1 values(1)");
1:         stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
1:         if (usingEmbedded())
1:             /* Ensure the exception is the ResultSetReturnNotAllowed */
0:             assertBatchExecuteError("X0Y79", stmt, new int[] {1,1});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ208", stmt, new int[] {1,1,-3});
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
1:         if (usingEmbedded())
0:             assertEquals(
0:                 "There should now be 3 rows in the table", 3, rs.getInt(1));
1:         else if (usingDerbyNetClient())
0:             assertEquals(
0:                 "There should now be 5 rows in the table", 5, rs.getInt(1));
1:         rs.close();
1: 
1:         conn.rollback();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be no rows in the table after rollback", 
0:                 0, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try executing a batch with regular statement intermingled.
0:     protected void runStatementNonBatchStuffInBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1:         
1:         int[] updateCount=null;
1:         ResultSet rs;
1: 
1:         // trying execute after addBatch
1:         println("Negative Statement:" +
1:             " statement testing execute in the middle of batch");
1:         stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
1:         /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:         /* assertStatementError will do the execute() */
1:         if (usingEmbedded())
1:             assertStatementError("XJ068",stmt,"insert into t1 values(1)");
1:         else if (usingDerbyNetClient())
1:         {
1:             stmt.addBatch("insert into t1 values(1)"); 
0:             assertBatchExecuteError("XJ208",stmt, new int[] {-3,1});           
1:             // pull level with embedded situation
1:             conn.rollback();
1:         }
1:         // do clearBatch so we can proceed
1:         stmt.clearBatch();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be no rows in the table", 0, rs.getInt(1));
1:         rs.close();
1: 
1:         try
1:         {
0:             // trying executeQuery after addBatch
1:             println("Negative Statement: " +
0:                 "statement testing executeQuery in the middle of batch");
1:             stmt.addBatch("insert into t1 values(1)");
1:             stmt.executeQuery("SELECT * FROM SYS.SYSTABLES");
1:             updateCount = stmt.executeBatch();
1:             if (usingEmbedded())
0:                 fail("Expected executeBatch to fail with embedded");
1:             else if (usingDerbyNetClient())
1:             {   
0:                 assertBatchUpdateCounts(new int[] {1}, updateCount);
0:                 // set to same spot as embedded
1:                 conn.rollback();
1:             }
1:         } catch (SQLException sqle) {
1:             /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:             assertSQLState("XJ068", sqle);
1:             // do clearBatch so we can proceed
1:             stmt.clearBatch();
1:         }
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be no rows in the table", 0, rs.getInt(1));
1:         rs.close();
1: 
1:         println("Negative Statement: " +
1:             "statement testing executeUpdate in the middle of batch");
1:         try
1:         {
0:             // trying executeUpdate after addBatch
1:             println("Negative Statement: " +
1:                 "statement testing executeUpdate in the middle of batch");
1:             stmt.addBatch("insert into t1 values(1)");
1:             stmt.executeUpdate("insert into t1 values(1)");
1:             stmt.addBatch("insert into t1 values(1)");
1:             stmt.addBatch("SELECT * FROM SYS.SYSCOLUMNS");
1:             if (usingDerbyNetClient())
1:             {
0:                 assertBatchExecuteError("XJ208", stmt, new int[] {1,1,-3});
1:             }
1:             else if (usingEmbedded())
1:             {
1:                 updateCount = stmt.executeBatch();
1:                 fail("Expected executeBatch to fail");
1:             }
1:         } catch (SQLException sqle) {
1:             /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:             if (usingEmbedded())
1:                 assertSQLState("XJ068", sqle);
1:             else if (usingDerbyNetClient())
1:                 assertSQLState("XJ208", sqle);
1:             
1:             stmt.clearBatch();
1:         }
1:         
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
1:         if (usingEmbedded())
0:             assertEquals("There should be no rows in the table", 
0:                 0, rs.getInt(1));
1:         else if (usingDerbyNetClient())
0:             assertEquals("There should be 3 rows in the table", 
0:                 3, rs.getInt(1));
1:         rs.close();
1: 
1:         conn.rollback();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be no rows in the table", 0, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // Below trying various placements of overflow update statement in the 
1:     // batch, i.e. as 1st stmt, nth stmt and last stmt
0:     protected void runStatementWithErrorsBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1:         
1:         ResultSet rs;
1: 
1:         stmt.executeUpdate("insert into t1 values(1)");
1: 
1:         // trying update as the first statement
1:         println("Negative Statement: statement testing overflow error" +
1:             " as first statement in the batch");
1:         stmt.addBatch("update t1 set c1=2147483647 + 1");
1:         stmt.addBatch("insert into t1 values(1)");
1:         /* Check to be sure the exception is the one we expect */
1:         /* Overflow is first stmt in the batch, so expect no update count */
1:         if (usingEmbedded())
0:             assertBatchExecuteError("22003", stmt, new int[] {});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ208", stmt, new int[] {-3,1});
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
1:         if (usingEmbedded())
0:             assertEquals("there should be 1 row in the table", 
0:                     1, rs.getInt(1));
1:         if (usingDerbyNetClient())
0:             assertEquals("there should be 2 rows in the table", 
1:                     2, rs.getInt(1));
1:         rs.close();
1: 
1:         // trying update as the nth statement
1:         println("Negative Statement: statement testing overflow error" +
1:             " as nth statement in the batch");
1:         stmt.addBatch("insert into t1 values(1)");
1:         stmt.addBatch("update t1 set c1=2147483647 + 1");
1:         stmt.addBatch("insert into t1 values(1)");
1:         /* Check to be sure the exception is the one we expect */
1:         /* Update is second statement in the batch, expect 1 update count */
1:         if (usingEmbedded())
0:             assertBatchExecuteError("22003", stmt, new int[] {1});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ208", stmt, new int[] {1,-3,1});
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
1:         if (usingEmbedded())
0:             assertEquals("expected: 2 rows", 2, rs.getInt(1));
1:         if (usingDerbyNetClient())
0:             assertEquals("expected: 4 rows", 4, rs.getInt(1));
1:         rs.close();
1: 
1:         // trying select as the last statement
1:         println("Negative Statement: statement testing overflow error" +
1:             " as last stat in the batch");
1:         stmt.addBatch("insert into t1 values(1)");
1:         stmt.addBatch("insert into t1 values(1)");
1:         stmt.addBatch("update t1 set c1=2147483647 + 1");
1:         /* Check to be sure the exception is the one we expect */
1:         /* Update is last statement in the batch, expect 2 update counts */
1:         if (usingEmbedded())
0:             assertBatchExecuteError("22003", stmt, new int[] {1,1});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ208", stmt, new int[] {1,1,-3});
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
1:         if (usingEmbedded())
0:             assertEquals("expected: 4 rows", 4, rs.getInt(1));
1:         if (usingDerbyNetClient())
0:             assertEquals("expected: 6 rows", 6, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try transaction error, in this particular case time out while
1:     // getting the lock
0:     protected void runTransactionErrorBatch(
0:         Connection conn, Statement stmt,
0:         Connection conn2, Statement stmt2) throws SQLException {
1: 
1:         int[] updateCount = null;
1: 
1:         try
1:         {
0:             println("Negative Statement: statement testing time out" +
0:                 " while getting the lock in the batch");
1: 
0:             stmt.execute("insert into t1 values(1)");
0:             stmt2.execute("insert into t1 values(2)");
1: 
0:             stmt.addBatch("update t1 set c1=3 where c1=2");
0:             stmt2.addBatch("update t1 set c1=4 where c1=1");
1:                       
1:             stmt.executeBatch();
0:             updateCount = stmt2.executeBatch();
1:             fail ("Batch is expected to fail");
1:         } catch (SQLException sqle) {
1:             /* Ensure the exception is time out while getting lock */
0:             assertSQLState("40XL1",sqle);
0:             assertTrue("we should get a BatchUpdateException", 
0:                 (sqle instanceof BatchUpdateException));
0:             updateCount = ((BatchUpdateException)sqle).getUpdateCounts();
1:             if (updateCount != null) {
0:                 assertEquals("first statement in the batch caused time out" +
0:                     " while getting the lock, expect no update count",
0:                     0, updateCount.length);
1:             }
1:         }
1:         conn.rollback();
1:         conn2.rollback();
1:         stmt.clearBatch();
1:         stmt2.clearBatch();
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
0:     /* Following are methods used in testCallableStatementBatchUpdate */
1: 
1:     // try callable statements
0:     protected void runCallableStatementBatch(Connection conn)
1:     throws SQLException {
0:         conn.setAutoCommit(false);
1:         
1:         println("Positive Callable Statement: " +
1:             "statement testing callable statement batch");
0:         CallableStatement cs = conn.prepareCall("insert into t1 values(?)");
1: 
1:         cs.setInt(1, 1);
1:         cs.addBatch();
1:         cs.setInt(1,2);
1:         cs.addBatch();
1:         try
1:         {
1:             executeBatchCallableStatement(cs);
1:         }
1:         catch (SQLException sqle)
1:         {   
0:             fail("The executeBatch should have succeeded");
1:         }
0:         cleanUpCallableStatement(conn, cs, "t1");
1: 
1:         /* For 'beetle' bug 2813 - setDate/setTime/setTimestamp
1:          * calls on callableStatement throws ClassNotFoundException 
1:          * verify setXXXX() works with Date, Time and Timestamp 
1:          * on CallableStatement.
1:          */
0:         cs = conn.prepareCall("insert into datetab values(?)");
1: 
1:         cs.setDate(1, Date.valueOf("1990-05-05"));
1:         cs.addBatch();
1:         cs.setDate(1,Date.valueOf("1990-06-06"));
1:         cs.addBatch();
1:         try
1:         {
1:             executeBatchCallableStatement(cs);
1:         }
1:         catch (SQLException sqle)
1:         {   
0:             fail("The executeBatch should have succeeded");
1:         }
0:         cleanUpCallableStatement(conn, cs, "datetab");
1: 
0:         cs = conn.prepareCall("insert into timetab values(?)");
1: 
1:         cs.setTime(1, Time.valueOf("11:11:11"));
1:         cs.addBatch();
1:         cs.setTime(1, Time.valueOf("12:12:12"));
1:         cs.addBatch();
1:         try
1:         {
1:             executeBatchCallableStatement(cs);
1:         }
1:         catch (SQLException sqle)
1:         {   
0:             fail("The executeBatch should have succeeded");
1:         }
0:         cleanUpCallableStatement(conn, cs, "timestamptab");
1: 
0:         cs = conn.prepareCall("insert into timestamptab values(?)");
1: 
1:         cs.setTimestamp(1, Timestamp.valueOf("1990-05-05 11:11:11.1"));
1:         cs.addBatch();
1:         cs.setTimestamp(1, Timestamp.valueOf("1992-07-07 12:12:12.2"));
1:         cs.addBatch();
1:         try
1:         {
1:             executeBatchCallableStatement(cs);
1:         }
1:         catch (SQLException sqle)
1:         {   
0:             fail("The executeBatch should have succeeded");
1:         }
0:         cleanUpCallableStatement(conn, cs, "timestamptab");
1: 
1:         // Try with a user type
0:         cs = conn.prepareCall("insert into usertypetab values(?)");
1: 
1:         cs.setObject(1, Date.valueOf("1990-05-05"));
1:         cs.addBatch();
1:         cs.setObject(1,Date.valueOf("1990-06-06"));
1:         cs.addBatch();
1:         try
1:         {
1:             executeBatchCallableStatement(cs);
1:         }
1:         catch (SQLException sqle)
1:         {   
0:             fail("The executeBatch should have succeeded");
1:         }
0:         cleanUpCallableStatement(conn, cs, "usertypetab");
1:     }
1:     
0:     // helper method to runCallableStatementBatch 
1:     // executes and evaluates callable statement
1:     private static void executeBatchCallableStatement(CallableStatement cs)
1:     throws SQLException
1:     {
1:         int updateCount[];
1: 
1:         updateCount = cs.executeBatch();
1:         assertEquals("there were 2 statements in the batch", 
0:                 2, updateCount.length);
1:         for (int i=0; i<updateCount.length; i++) 
1:         {
1:             assertEquals("update count should be 1", 1, updateCount[i]);
1:         }
1:     }
1: 
0:     // helper method to runCallableStatementBatch - 
1:     // removes all rows from table
0:     protected static void cleanUpCallableStatement(
0:         Connection conn, CallableStatement cs, String tableName)
1:     throws SQLException
1:     {
1:         cs.close();
1:         conn.rollback();
0:         cs = conn.prepareCall("delete from " + tableName);
1:         cs.executeUpdate();
1:         cs.close();
0:         conn.commit();
1:     }
1:     
1:     // try callable statements with output parameters
0:     // TODO: isolate the procedure(s) from lang/outparams? 
0:     protected void runCallableStatementWithOutputParamBatch(Connection conn) 
1:     throws SQLException {
0:         String CLASS_NAME;
0:         if(JDBC.vmSupportsJDBC3())
0:             CLASS_NAME = 
0:                "org.apache.derbyTesting.functionTests.tests.lang.outparams30.";
0:         else
0:             CLASS_NAME = 
0:                 "org.apache.derbyTesting.functionTests.tests.lang.outparams.";
1: 
1:         println("Negative Callable Statement: " +
1:             "callable statement with output parameters in the batch");
0:         Statement s = conn.createStatement();
1: 
1:         s.execute("CREATE PROCEDURE " +
0:                 "takesString(OUT P1 VARCHAR(40), IN P2 INT) " +
0:                 "EXTERNAL NAME '" + CLASS_NAME + "takesString'" +
1:         " NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
0:         CallableStatement cs = conn.prepareCall("call takesString(?,?)");
1:         try
1:         {
0:             cs.registerOutParameter(1, Types.CHAR);
0:             cs.setInt(2, Types.INTEGER);
1:             cs.addBatch();
1:             if (usingEmbedded())
1:                 fail("Expected to see error XJ04C");
1:             else if (usingDerbyNetClient()) {
1:                 executeBatchCallableStatement(cs);       
1:             }
1:         }
1:         catch (SQLException sqle)
1:         {
1:             // Check to be sure the exception is callback related
1:             assertSQLState("XJ04C", sqle);
1:         }
1: 
1:         cs.close();
1:         s.execute("drop procedure takesString");
1:         s.close();
1:         conn.rollback();
0:         conn.commit();
1:     }
1: 
0:     /* Following are methods used in 
0:      * testPreparedStatementBatchUpdatePositive */    
1:     
1:     // try executing a batch which nothing in it. Should work.
0:     protected void runEmptyValueSetPreparedBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1: 
1:         // try executing a batch which nothing in it. Should work.
1:         println("Positive Prepared Stat: " +
1:             "set no parameter values and run the batch");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("insert into t1 values(?)");
1: 
1:         assertBatchUpdateCounts(new int[] {}, pStmt.executeBatch());
1: 
1:         pStmt.close();
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
0:     // try prepared statement batch with just no settable parameters.
0:     protected void runNoParametersPreparedBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1:         ResultSet rs;
1: 
1:         println("Positive Prepared Stat: no settable parameters");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("insert into t1 values(5)");
1:         pStmt.addBatch();
1:         pStmt.addBatch();
1:         pStmt.addBatch();
1:         /* 3 parameters were set in the batch, update count length
1:          *  should be 3 */
1:         assertBatchUpdateCounts(new int[] {1,1,1}, pStmt.executeBatch());
1: 
1:         pStmt.close();
1:         rs = stmt.executeQuery("select count(*) from t1 where c1=5");
1:         rs.next();
1:         assertEquals("There should be 3 rows with c1 = 5", 3, rs.getInt(1));
1:         rs.close();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 3 rows", 3, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try prepared statement batch with just one set of values.
0:     protected void runSingleValueSetPreparedBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1:         ResultSet rs;
1: 
1:         // try prepared statement batch with just one set of values
1:         println("Positive Prepared Stat: " +
1:             "set one set of parameter values and run the batch");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("insert into t1 values(?)");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         /* 1 parameter was set in batch, update count length should be 1 */
1:         assertBatchUpdateCounts(new int[] {1}, pStmt.executeBatch());
1: 
1:         pStmt.close();
1:         rs = stmt.executeQuery("select count(*) from t1 where c1=1");
1:         rs.next();
1:         assertEquals("There should be 1 row with c1=1", 1, rs.getInt(1));
1:         
1:         rs.close();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 1 row", 1, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try executing a batch with 3 different parameter sets in it.
0:     protected void runMultipleValueSetPreparedBatch(
0:             Connection conn, Statement stmt) throws SQLException {
1:         ResultSet rs;
1: 
1:         // try prepared statement batch with just one set of values
1:         println("Positive Prepared Stat: " +
1:             "set 3 set of parameter values and run the batch");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("insert into t1 values(?)");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 2);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 3);
1:         pStmt.addBatch();
1:         /* 3 parameters were set , update count length should be 3 */
1:         assertBatchUpdateCounts(new int[] {1,1,1}, pStmt.executeBatch());
1: 
1:         pStmt.close();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 3 rows", 3, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try prepared statement batch with just 2 set of values 
1:     // and there value is null. 
1:     // tests fix for 'beetle' bug 4002: Execute batch for
1:     // preparedStatement gives nullPointerException
0:     protected void runMultipleValueSetNullPreparedBatch(
0:             Connection conn, Statement stmt) throws SQLException {
1:         ResultSet rs;
1: 
1:         // try prepared statement batch with just one set of values
1:         println("Positive Prepared Stat: " +
1:             "set one set of parameter values to null and run the batch");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("insert into t1 values(?)");
1:         pStmt.setNull(1, Types.INTEGER);
1:         pStmt.addBatch();
1:         pStmt.setNull(1, Types.INTEGER);
1:         pStmt.addBatch();
1:         /* 2 parameters were set in the batch, 
1:          * update count length should be 2 */
1:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1: 
1:         pStmt.close();
1:         rs = stmt.executeQuery("select count(*) from t1 where c1 is null");
1:         rs.next();
1:         assertEquals("There should be 2 rows with c1 is null",
1:             2, rs.getInt(1));
1:         rs.close();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 2 rows", 2, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try executing a batch with 1000 statements in it.
0:     protected void run1000ValueSetPreparedBatch(
0:         Connection conn, Statement stmt) 
1:     throws SQLException {
1:         int updateCount[];
1:         ResultSet rs;
1: 
1:         println("Positive Prepared Stat: 1000 parameter set batch");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("insert into t1 values(?)");
1:         for (int i=0; i<1000; i++){
1:             pStmt.setInt(1, 1);
1:             pStmt.addBatch();
1:         }
1:         updateCount = pStmt.executeBatch();
1: 
0:         assertEquals("there were 1000 parameters set in the batch," +
0:             " update count length should be 1000",
0:             1000, updateCount.length);
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 1000 rows in the table",
0:                 1000, rs.getInt(1));
1:         rs.close();
1: 
1:         pStmt.close();
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1: 
1:     // try executing batches with various rollback and commit combinations.
0:     protected void runPreparedStatRollbackAndCommitCombinations(
0:         Connection conn, Statement stmt) throws SQLException {
1: 
1:         ResultSet rs;
1: 
1:         println("Positive Prepared Stat: batch, rollback," +
0:                 " batch and commit combinations");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("insert into t1 values(?)");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         /* there were 2 statements in the batch, 
1:          * update count length should be 2 */
1:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1: 
1:         conn.rollback();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 0 rows after rollback", 0, rs.getInt(1));
1:         rs.close();
1: 
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         /* there were 2 statements in the batch, 
1:          * update count length should be 2 */
1:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1: 
0:         conn.commit();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 2 rows", 2, rs.getInt(1));
1:         
1:         rs.close();
1: 
1:         // try batch and commit
1:         println("Positive Prepared Stat: batch and commit combinations");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         /* there were 2 statements in the batch, 
1:          * update count length should be 2 */
1:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1: 
0:         conn.commit();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 4 rows", 4, rs.getInt(1));
1:         rs.close();
1: 
1:         // try batch, batch and rollback
1:         println("Positive Prepared Stat: batch, " +
1:             "batch and rollback combinations");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         /* there were 2 statements in the batch, 
1:          * update count should be 2 */
1:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1: 
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         /* there were 2 statements in the batch, 
1:          * update count length should be 2 */
1:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1: 
1:         conn.rollback();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 4 rows", 4, rs.getInt(1));
1:         rs.close();
1: 
1:         // try batch, batch and commit
1:         println("Positive Prepared Stat: " +
1:             "batch, batch and commit combinations");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         /* there were 2 statements in the batch, 
1:          * update count length should be 2 */
1:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1: 
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         /* there were 2 statements in the batch, 
1:          * update count length should be 2 */
1:         assertBatchUpdateCounts(new int[] {1,1}, pStmt.executeBatch());
1: 
0:         conn.commit();
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 8 rows", 8, rs.getInt(1));
1: 
1:         rs.close();
1:         pStmt.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1: 
1:     // try prepared statement batch with autocommit true
0:     protected void runAutoCommitTruePreparedStatBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1:         ResultSet rs;
1: 
0:         conn.setAutoCommit(true);
1:         // prepared statement batch with autocommit true
1:         println("Positive Prepared Stat: testing batch with autocommit true");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("insert into t1 values(?)");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         /* there were 3 statements in the batch, 
1:          * update count length should be 3 */
1:         assertBatchUpdateCounts(new int[] {1,1,1}, pStmt.executeBatch());
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 3 rows in the table", 3, rs.getInt(1));
1:         rs.close();
1:         pStmt.close();
1: 
0:         // turn it true again after the above negative test
0:         conn.setAutoCommit(false);
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try combinations of clear batch.
0:     protected void runCombinationsOfClearPreparedStatBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1: 
1:         int updateCount[];
1:         ResultSet rs;
1: 
1:         println("Positive Prepared Stat: add 3 statements, " +
1:             "clear batch and execute batch");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("insert into t1 values(?)");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 2);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 3);
1:         pStmt.addBatch();
1:         pStmt.clearBatch();
1:         /* there were 0 statements in the batch, 
1:          * update count length should be 0 */
1:         assertBatchUpdateCounts(new int[] {}, pStmt.executeBatch());
1: 
1:         println("Positive Prepared Stat: " +
1:             "add 3 statements, clear batch, add 3 and execute batch");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 2);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 3);
1:         pStmt.addBatch();
1:         pStmt.clearBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 2);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 3);
1:         pStmt.addBatch();
1:         updateCount = pStmt.executeBatch();
1: 
0:         assertEquals("there were 3 statements in the batch, " +
0:             "update count should be 3",
0:             3, updateCount.length);
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 3 rows in the table", 3, rs.getInt(1));
1:         rs.close();
1:         pStmt.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
0:     /* Methods used in testPreparedStatementBatchUpdateNegative */
1:     
1:     // statements which will return a resultset are not allowed in
1:     // batch Updates. Following case should throw an exception for select.
0:     protected void runPreparedStmtWithResultSetBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1: 
1:         ResultSet rs;
1: 
1:         println("Negative Prepared Stat: testing select in the batch");
1:         PreparedStatement pStmt = 
0:             conn.prepareStatement("select * from t1 where c1=?");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         if (usingEmbedded())
1:             /* Ensure the exception is the ResultSetReturnNotAllowed */
1:             /* "Select is first statement in the batch, 
1:              * so there should not be any update counts */
0:             assertBatchExecuteError("X0Y79", pStmt, new int[] {});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ117", pStmt, new int[] {-3});
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be no rows in the table",
0:             0, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try executing a batch with regular statement intermingled.
0:     protected void runPreparedStmtNonBatchStuffInBatch(
0:             Connection conn, Statement stmt) throws SQLException {
1:         int updateCount[] = null;
1:         ResultSet rs;
1: 
1:         try
1:         {
0:             // trying execute in the middle of batch
1:             println("Negative Prepared Stat: " +
0:                 "testing execute in the middle of batch");
1:             PreparedStatement pStmt = 
0:                 conn.prepareStatement("select * from t1 where c1=?");
1:             pStmt.setInt(1, 1);
1:             pStmt.addBatch();
1:             pStmt.execute();
1:             updateCount = pStmt.executeBatch();
1:             fail("Expected executeBatch to fail");
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded())
1:                 /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:                 assertSQLState("XJ068", sqle);
1:             else if (usingDerbyNetClient())
1:                 assertSQLState("XJ117", sqle);
1:             // do clearBatch so we can proceed
1:             stmt.clearBatch();
1:         }
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be no rows in the table", 
0:             0, rs.getInt(1));
1:         rs.close();
1: 
1:         try
1:         {
0:             // trying executeQuery in the middle of batch
0:             println("Negative Prepared Statement: " +
0:                 "testing executeQuery in the middle of batch");
1:             PreparedStatement pStmt = 
0:                 conn.prepareStatement("select * from t1 where c1=?");
1:             pStmt.setInt(1, 1);
1:             pStmt.addBatch();
1:             pStmt.executeQuery();
1:             updateCount = pStmt.executeBatch();
1:             fail("Expected executeBatch to fail");
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded())
1:                 /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:                 assertSQLState("XJ068", sqle);
1:             else if (usingDerbyNetClient())
1:                 assertSQLState("XJ117", sqle);
1:             // do clearBatch so we can proceed
1:             stmt.clearBatch();
1:         }
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be no rows in the table", 
0:             0, rs.getInt(1));
1:         rs.close();
1: 
1:         try
1:         {
0:             //  trying executeUpdate in the middle of batch
1:             println("Negative Prepared Stat: " +
0:                         "testing executeUpdate in the middle of batch");
1:             PreparedStatement pStmt = 
0:                 conn.prepareStatement("select * from t1 where c1=?");
1:             pStmt.setInt(1, 1);
1:             pStmt.addBatch();
1:             pStmt.executeUpdate();
1:             updateCount = pStmt.executeBatch();
1:             fail("Expected executeBatch to fail");
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded())
1:                 /* Check to be sure the exception is the MIDDLE_OF_BATCH */
1:                 assertSQLState("XJ068", sqle);
1:             else if (usingDerbyNetClient())
1:                 assertSQLState("X0Y79", sqle);
1:             // do clearBatch so we can proceed
1:             stmt.clearBatch();
1:         }
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be no rows in the table", 
0:             0, rs.getInt(1));
1:         rs.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // Below trying placements of overflow update statement in the batch
0:     protected void runPreparedStmtWithErrorsBatch(
0:         Connection conn, Statement stmt) throws SQLException {
1:         
1:         ResultSet rs;
1:         PreparedStatement pStmt = null;
1: 
1:         stmt.executeUpdate("insert into t1 values(1)");
1: 
1:         println("Negative Prepared Stat: " +
1:             "testing overflow as first set of values");
0:         pStmt = conn.prepareStatement("update t1 set c1=(? + 1)");
1:         pStmt.setInt(1, java.lang.Integer.MAX_VALUE);
1:         pStmt.addBatch();
1:         if (usingEmbedded())
1:             /* Check to be sure the exception is the one we expect */
1:             /* Overflow is first statement in the batch, 
1:              * so there should not be any update count */
0:             assertBatchExecuteError("22003", pStmt, new int[] {});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ208", pStmt, new int[] {-3});
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 1 row in the table", 1, rs.getInt(1));
1:         rs.close();
1: 
1:         println("Negative Prepared Stat: " +
1:             "testing overflow as nth set of values");
0:         pStmt = conn.prepareStatement("update t1 set c1=(? + 1)");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, java.lang.Integer.MAX_VALUE);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         if (usingEmbedded())
1:             /* Check to be sure the exception is the one we expect */
1:             /* Overflow is second statement in the batch, 
1:              * so there should be only 1 update count */
0:             assertBatchExecuteError("22003", pStmt, new int[] {1});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ208", pStmt, new int[] {1,-3,1});
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 1 row in the table", 1, rs.getInt(1));
1:         rs.close();
1: 
1:         // trying select as the last statement
1:         println("Negative Prepared Stat: " +
1:             "testing overflow as last set of values");
0:         pStmt = conn.prepareStatement("update t1 set c1=(? + 1)");
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, 1);
1:         pStmt.addBatch();
1:         pStmt.setInt(1, java.lang.Integer.MAX_VALUE);
1:         pStmt.addBatch();
1:         if (usingEmbedded())
1:             /* Check to be sure the exception is the one we expect */
1:             /* Overflow is last statement in the batch, 
1:              * so there should be 2 update counts */
0:             assertBatchExecuteError("22003", pStmt, new int[] {1,1});
1:         else if (usingDerbyNetClient())
0:             assertBatchExecuteError("XJ208", pStmt, new int[] {1,1,-3});
1: 
0:         rs = stmt.executeQuery("select count(*) from t1");
1:         rs.next();
0:         assertEquals("There should be 1 row in the table", 1, rs.getInt(1));
1:         rs.close();
1:         pStmt.close();
1: 
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1:     
1:     // try transaction error, in this particular case 
1:     // time out while getting the lock
0:     protected void runTransactionErrorPreparedStmtBatch(
0:             Connection conn, Statement stmt,
0:             Connection conn2, Statement stmt2) throws SQLException {
1: 
1:         int updateCount[] = null;
1:         
1:         try
1:         {
0:             println("Negative Prepared Statement: " +
0:                 "testing transaction error, time out while getting the lock");
1: 
0:             stmt.execute("insert into t1 values(1)");
0:             stmt2.execute("insert into t1 values(2)");
1: 
0:             PreparedStatement pStmt1 = 
0:                 conn.prepareStatement("update t1 set c1=3 where c1=?");
0:             pStmt1.setInt(1, 2);
0:             pStmt1.addBatch();
1: 
0:             PreparedStatement pStmt2 = 
0:                 conn.prepareStatement("update t1 set c1=4 where c1=?");
0:             pStmt2.setInt(1, 1);
0:             pStmt2.addBatch();
1: 
1:             pStmt1.executeBatch();
1:             updateCount = pStmt2.executeBatch();
1:             fail ("Batch is expected to fail");
1:         } catch (SQLException sqle) {
1:             /* Check that the exception is time out while 
1:              * getting the lock */
0:             assertSQLState("40XL1", sqle);
0:             assertTrue("Expect BatchUpdateException", 
0:                 (sqle instanceof BatchUpdateException));
0:             updateCount = ((BatchUpdateException)sqle).getUpdateCounts();
1:             if (updateCount != null) {
0:                 assertEquals("first statement in the batch caused time out" +
0:                     " while getting the lock, there should be no update count", 
0:                     0, updateCount.length);
1:             }
1:         }
1: 
1:         conn.rollback();
1:         conn2.rollback();
0:         stmt.executeUpdate("delete from t1");
0:         conn.commit();
1:     }
1: }
============================================================================