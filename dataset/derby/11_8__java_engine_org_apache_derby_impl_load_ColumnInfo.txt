1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.load.ColumnInfo
1:345de35: 
1:6d913c6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6d913c6:    contributor license agreements.  See the NOTICE file distributed with
1:6d913c6:    this work for additional information regarding copyright ownership.
1:6d913c6:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6d913c6:    (the "License"); you may not use this file except in compliance with
1:6d913c6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.load;
1:be12a80: 
1:2732872: import org.apache.derby.iapi.util.IdUtil;
1:eac0369: 
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Connection;
1:eac0369: import java.sql.DatabaseMetaData;
1:e33b8d8: import java.sql.Types;
1:eac0369: import java.util.*;
1:161e9cc: import org.apache.derby.iapi.jdbc.EngineConnection;
1:bb55cc3: import org.apache.derby.iapi.reference.SQLState;
1:bb55cc3: import org.apache.derby.iapi.error.StandardException;
1:bb55cc3: import org.apache.derby.iapi.error.PublicAPI;
2:eac0369: /**
1:eac0369:  *	
1:eac0369:  * This class provides supportto  create casting/conversions required to 
1:eac0369:  * perform import. Import VTI  gives all the data in VARCHAR type becuase data
1:eac0369:  * in the files is in CHAR format. There is no implicit cast availabile from
1:eac0369:  * VARCHAR to some of the types. In cases where explicit casting is allowed, 
1:eac0369:  * columns are casted with  explict cast to the type of table column; in case of 
1:eac0369:  * double/real explicit casting is also not allowd , scalar fuction DOUBLE is
1:eac0369:  * used in those cases.
1:eac0369:  *  
1:eac0369:  */
1:eac0369: class ColumnInfo {
1:eac0369: 
1:400f6eb: 	private ArrayList<String> vtiColumnNames ;
1:400f6eb:     private ArrayList<String> insertColumnNames;
1:400f6eb:     private ArrayList<String> columnTypes ;
1:400f6eb:     private ArrayList<Integer> jdbcColumnTypes;
1:eac0369: 	private int noOfColumns;
1:eac0369: 	private ArrayList columnPositions;
1:eac0369: 	private boolean createolumnNames = true;
1:eac0369: 	private int expectedNumberOfCols ; //number of Columns that are suppose
1:eac0369:                                        // to be in the file to imported  
1:eac0369: 	private Connection conn;
1:eac0369: 	private String tableName;
1:eac0369: 	private String schemaName;
1:bb55cc3:         private String[] headerColumnNames;
1:400f6eb:     private HashMap<String,String> udtClassNames;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Initialize the column type and name  information
1:eac0369: 	 * @param conn  - connection to use for metadata queries
1:eac0369: 	 * @param sName - table's schema
1:eac0369: 	 * @param tName - table Name
1:6b50965: 	 * @param insertColumnList - comma seperared insert statement column list 
1:6b50965: 	 * @param  vtiColumnIndexes - Indexes in the file
1:eac0369: 	 * @param  vtiColumnPrefix - Prefix to use to generate column names to select from VTI
1:eac0369: 	 * @exception Exception on error 
1:eac0369: 	 */
1:eac0369: 	public ColumnInfo(Connection conn,
1:eac0369: 					  String sName, 
1:eac0369: 					  String tName,
1:eac0369: 					  String insertColumnList, 
1:eac0369: 					  String vtiColumnIndexes,
1:bb55cc3: 					  String vtiColumnPrefix,
1:bb55cc3: 					  String[] headerColumnNames)
1:eac0369: 		throws SQLException 
1:eac0369: 	{
1:eac0369: 
1:400f6eb: 		vtiColumnNames = new ArrayList<String>(1);
1:400f6eb: 		insertColumnNames = new ArrayList<String>(1);
1:400f6eb: 		columnTypes = new ArrayList<String>(1);
1:400f6eb:         jdbcColumnTypes = new ArrayList<Integer>(1);
1:400f6eb:         udtClassNames = new HashMap<String,String>();
1:eac0369: 		noOfColumns = 0;
1:eac0369: 		this.conn = conn;
1:bb55cc3: 		this.headerColumnNames=headerColumnNames;
1:161e9cc:         if (sName == null) {
1:161e9cc:             // Use the current schema if no schema is specified.
1:161e9cc:             sName = ((EngineConnection) conn).getCurrentSchemaName();
1:161e9cc:         }
1:161e9cc: 
1:c47d471: 		this.schemaName = sName;
1:c47d471: 		this.tableName =  tName;
1:eac0369: 
1:eac0369: 		if(insertColumnList!=null)
1:eac0369: 		{
1:eac0369: 			//break the comma seperated column list and initialze column info
1:c47d471: 			//eg: C2 , C1 , C3
1:eac0369: 			StringTokenizer st = new StringTokenizer(insertColumnList , ",");
1:eac0369: 			while (st.hasMoreTokens()) 
1:eac0369: 			{
1:eac0369: 				String columnName = (st.nextToken()).trim();
1:eac0369: 				if(!initializeColumnInfo(columnName))
1:eac0369: 				{
1:eac0369: 					if(tableExists())
1:eac0369: 						throw  LoadError.invalidColumnName(columnName);
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						String entityName = (schemaName !=null ? 
1:eac0369: 											 schemaName + "." + tableName :tableName); 
1:eac0369: 						throw LoadError.tableNotFound(entityName);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}else
1:eac0369: 		{
1:eac0369: 			//All columns in the table
1:eac0369: 			if(!initializeColumnInfo(null))
1:eac0369: 			{
1:eac0369: 				String entityName = (schemaName !=null ? 
1:eac0369: 									 schemaName + "." + tableName :tableName); 
1:eac0369: 				throw LoadError.tableNotFound(entityName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 				
1:eac0369: 		//break the comma seperated column indexes for import file give by the user
1:eac0369: 		//eg: "1, 3, 5, 7"
1:eac0369: 		if(vtiColumnIndexes !=null)
1:eac0369: 		{
1:eac0369: 			
1:eac0369: 			StringTokenizer st = new StringTokenizer(vtiColumnIndexes, ",");
1:eac0369: 			while (st.hasMoreTokens()) 
1:eac0369: 			{
1:bb55cc3: 				int cIndex;
1:bb55cc3: 				String columnIndex = (st.nextToken()).trim();
1:bb55cc3: 				if("\"".equals(columnIndex.substring(0,1))){
1:bb55cc3: 					
1:bb55cc3: 					cIndex = readHeaders((columnIndex.replace('"', ' ')).trim());
1:bb55cc3: 					vtiColumnNames.add(vtiColumnPrefix + cIndex);
1:bb55cc3: 
1:bb55cc3: 				}
1:bb55cc3: 				else{
1:bb55cc3: 					
1:bb55cc3: 					vtiColumnNames.add(vtiColumnPrefix + columnIndex);
1:bb55cc3: 					cIndex = Integer.parseInt(columnIndex );
1:bb55cc3: 				}
1:eac0369: 				if(cIndex > expectedNumberOfCols )
1:eac0369: 					expectedNumberOfCols= cIndex ;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		//if column indexes are not specified  ; create names for all collumns requested
1:eac0369: 		if(vtiColumnNames.size() < 1)
1:eac0369: 		{
1:eac0369: 			for(int index = 1 ; index <= noOfColumns; index++)
1:eac0369: 			{
1:eac0369: 				vtiColumnNames.add(vtiColumnPrefix + index);
1:eac0369: 			}
1:eac0369: 			expectedNumberOfCols = noOfColumns ;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:bb55cc3: 	//Check for matchng patterns of column names
1:bb55cc3: 	private int readHeaders(String columnPattern) 
1:bb55cc3: 		throws SQLException
1:bb55cc3: 	{
1:bb55cc3: 	    	if(headerColumnNames!=null){
1:bb55cc3: 		
1:bb55cc3: 			for(int i=0;i<headerColumnNames.length;i++){
1:bb55cc3: 				if(headerColumnNames[i].equals(columnPattern)){
1:bb55cc3: 					return i+1;
1:bb55cc3: 				}
1:bb55cc3:  			}
1:bb55cc3: 				
1:bb55cc3: 	       		throw PublicAPI.wrapStandardException(StandardException.newException
1:bb55cc3: 				(SQLState.LANG_INVALID_INPUT_COLUMN_NAME, columnPattern));
1:bb55cc3: 		}
1:bb55cc3: 		throw PublicAPI.wrapStandardException(StandardException.newException
1:bb55cc3: 				(SQLState.LANG_INVALID_NUMBEROF_HEADER_LINES));
1:bb55cc3: 	}
1:eac0369: 
1:eac0369: 	private boolean initializeColumnInfo(String columnPattern)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:eac0369: 		DatabaseMetaData dmd = conn.getMetaData();
1:eac0369: 		ResultSet rs = dmd.getColumns(null, 
1:eac0369: 									  schemaName,
1:eac0369: 									  tableName,
1:c47d471: 									  columnPattern);
1:eac0369: 		boolean foundTheColumn=false;
1:eac0369: 		while (rs.next())
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			// 4.COLUMN_NAME String => column name
1:eac0369: 			String columnName = rs.getString(4);
1:eac0369: 
1:eac0369: 			// 5.DATA_TYPE short => SQL type from java.sql.Types
1:eac0369: 			short dataType = rs.getShort(5);
1:eac0369: 
1:eac0369: 			// 6.TYPE_NAME String => Data source dependent type name
1:eac0369: 			String typeName = rs.getString(6);
1:eac0369: 
1:eac0369: 			
1:eac0369: 			// 7.COLUMN_SIZE int => column size. For char or date types
1:eac0369: 			// this is the maximum number of characters, for numeric or
1:eac0369: 			// decimal types this is precision.
1:eac0369: 			int columnSize = rs.getInt(7);
1:eac0369: 
1:eac0369: 			// 9.DECIMAL_DIGITS int => the number of fractional digits
1:eac0369: 			int decimalDigits = rs.getInt(9);
1:eac0369: 
1:eac0369: 			// 10.NUM_PREC_RADIX int => Radix (typically either 10 or 2)
1:eac0369: 			int numPrecRadix = rs.getInt(10);
1:eac0369: 			foundTheColumn = true;
1:eac0369: 			if(importExportSupportedType(dataType))
1:eac0369: 			{
1:eac0369: 
1:eac0369: 				insertColumnNames.add(columnName);
1:eac0369: 				String sqlType = typeName + getTypeOption(typeName , columnSize , columnSize , decimalDigits);
1:84e347a: 				columnTypes.add(sqlType);
1:ce40a31:                 jdbcColumnTypes.add((int) dataType);
1:eac0369: 				noOfColumns++;
1:2732872: 
1:2732872:                 if ( dataType == java.sql.Types.JAVA_OBJECT )
1:2732872:                 {
1:2732872:                     udtClassNames.put( "COLUMN" +  noOfColumns, getUDTClassName( dmd, typeName ) );
1:2732872:                 }
1:eac0369: 			}else
1:eac0369: 			{
1:eac0369: 				rs.close();
1:eac0369: 				throw
1:eac0369: 					LoadError.nonSupportedTypeColumn(columnName,typeName);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		rs.close();
1:eac0369: 		return foundTheColumn;
1:eac0369: 	}
1:eac0369: 
1:2732872:     // look up the class name of a UDT
1:2732872:     private String getUDTClassName( DatabaseMetaData dmd, String sqlTypeName )
1:2732872:         throws SQLException
1:2732872:     {
1:2732872:         String className = null;
1:2732872:         
1:2732872:         try {
1:2732872:             // special case for system defined types
1:2732872:             if ( sqlTypeName.charAt( 0 ) != '"' ) { return sqlTypeName; }
1:2732872: 
1:2732872:             String[] nameParts = IdUtil.parseMultiPartSQLIdentifier( sqlTypeName );
1:2732872: 
1:2732872:             String schemaName = nameParts[ 0 ];
1:2732872:             String unqualifiedName = nameParts[ 1 ];
1:2732872: 
1:2732872:             ResultSet rs = dmd.getUDTs( null, schemaName, unqualifiedName, new int[] { java.sql.Types.JAVA_OBJECT } );
1:2732872: 
1:2732872:             if ( rs.next() )
1:2732872:             {
1:2732872:                 className = rs.getString( 4 );
1:2732872:             }
1:2732872:             rs.close();
1:2732872:         }
1:2a5922a:         catch (Exception e) { throw LoadError.unexpectedError( e ); }
1:2732872: 
1:2732872:         if ( className == null ) { className = "???"; }
1:2732872:         
1:2732872:         return className;
1:2732872:     }
1:2732872: 
1:eac0369: 
1:eac0369: 	//return true if the given type is supported by import/export
1:eac0369: 	public  static final boolean importExportSupportedType(int type){
1:eac0369: 
1:ea980d3: 		return !(type == java.sql.Types.BIT ||
1:eac0369: 				 type == java.sql.Types.OTHER ||
1:e33b8d8:                  type == Types.SQLXML );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private String getTypeOption(String type , int length , int precision , int scale)
1:eac0369: 	{
1:eac0369: 
1:eac0369: 			if ((type.equals("CHAR") ||
1:eac0369: 				 type.equals("BLOB") ||
1:eac0369: 				 type.equals("CLOB") ||
1:eac0369: 				 type.equals("VARCHAR")) && length != 0)
1:eac0369: 			{
1:eac0369: 				 return "(" + length + ")";
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (type.equals("FLOAT")  && precision != 0)
1:eac0369: 				return  "(" + precision + ")";
1:eac0369: 
1:eac0369: 			//there are three format of decimal and numeric. Plain decimal, decimal(x)
1:eac0369: 			//and decimal(x,y). x is precision and y is scale.
1:eac0369: 			if (type.equals("DECIMAL") ||
1:eac0369: 				type.equals("NUMERIC")) 
1:eac0369: 			{
1:eac0369: 				if ( precision != 0 && scale == 0)
1:eac0369: 					return "(" + precision + ")";
1:eac0369: 				else if (precision != 0 && scale != 0)
1:eac0369: 					return "(" + precision + "," + scale + ")";
1:eac0369: 				else if(precision == 0 && scale!=0)
1:eac0369: 					return "(" + scale + ")";
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if ((type.equals("DECIMAL") ||
1:eac0369: 				 type.equals("NUMERIC")) && scale != 0)
1:eac0369: 				return "(" + scale + ")";
1:eac0369: 
1:eac0369: 			//no special type option
1:eac0369: 			return "";
1:eac0369: 	}
1:eac0369: 
1:2732872:     /**
1:2732872:      * Get the column type names.
1:2732872:      */
1:2732872:     public String getColumnTypeNames()
1:2732872:         throws Exception
1:2732872:     {
1:2732872:         // we use the object serializer logic
1:2732872:         return ExportAbstract.stringifyObject( columnTypes );
1:2732872:     }
1:2732872: 
1:2732872:     /**
1:2732872:      * Get the class names of udt columns as a string.
1:2732872:      */
1:2732872:     public String getUDTClassNames()
1:2732872:         throws Exception
1:2732872:     {
1:2732872:         // we use the object serializer logic
1:2732872:         return ExportAbstract.stringifyObject( udtClassNames );
1:2732872:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Returns a  string of columns with proper casting/conversion
1:eac0369: 	 * to be used to select from import VTI.
1:eac0369: 	 */
1:eac0369: 	public String getColumnNamesWithCasts()
1:eac0369: 	{
1:eac0369: 		StringBuffer sb = new StringBuffer();
1:eac0369: 		boolean first = true;
1:eac0369: 		int noOfVtiCols =  vtiColumnNames.size();
1:eac0369: 		for(int index = 0 ; index < noOfColumns && index < noOfVtiCols; index++)
1:eac0369: 		{
1:eac0369: 			if(!first)
1:eac0369: 				sb.append(", ");
1:eac0369: 			else
1:eac0369: 				first = false;
1:eac0369: 			String type = (String) columnTypes.get(index);
1:eac0369: 			String columnName = (String) vtiColumnNames.get(index);
1:eac0369: 		   
1:eac0369: 			if(type.startsWith("SMALLINT") ||
1:eac0369: 			   type.startsWith("INTEGER") ||
1:eac0369: 			   type.startsWith("DECIMAL") ||
1:eac0369: 			   type.startsWith("BIGINT") ||
1:eac0369: 			   type.startsWith("NUMERIC"))							  
1:eac0369: 			{
1:eac0369: 				//these types require explicit casting
1:eac0369: 				sb.append(" cast" + "(" + columnName + " AS " + type + ") "); 
1:eac0369: 
1:eac0369: 			}else
1:eac0369: 			{
1:eac0369: 				//if it is DOUBLE use scalar DOUBLE function no explicit casting allowed
1:eac0369: 				if(type.startsWith("DOUBLE"))
1:eac0369: 				{
1:eac0369: 					sb.append(" DOUBLE" + "(" + columnName + ") ");
1:eac0369: 
1:eac0369: 				}else
1:eac0369: 				{
1:eac0369: 					//REAL: use DOUBLE function to convert from string and the cast to REAL
1:eac0369: 					if(type.startsWith("REAL"))
1:eac0369: 					{
1:eac0369: 						sb.append("cast" + "(" + 
1:eac0369: 								  " DOUBLE" + "(" + columnName + ") " + 
1:eac0369: 								  " AS " +  "REAL" + ") ");
1:eac0369: 					}else
1:eac0369: 					{
1:eac0369: 						//all other types does  not need any special casting
1:eac0369: 						sb.append(" " + columnName +  " "); 
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//there is no column info available
1:eac0369: 		if(first)
1:eac0369: 			return " * ";
1:eac0369: 		else
1:eac0369: 			return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:c47d471: 	/* returns comma seperated column Names delimited by quotes for the insert 
1:c47d471:      * statement
1:c47d471: 	 * eg: "C1", "C2" , "C3" , "C4" 
1:eac0369: 	 */
1:eac0369: 	public String getInsertColumnNames()
1:eac0369: 	{
1:eac0369: 		StringBuffer sb = new StringBuffer();
1:eac0369: 		boolean first = true;
1:eac0369: 		for(int index = 0 ; index < noOfColumns; index++)
1:eac0369: 		{
1:eac0369: 			if(!first)
1:eac0369: 				sb.append(", ");
1:eac0369: 			else
1:eac0369: 				first = false;
1:9e89a51:             // Column names can be SQL reserved words, or they can contain
1:9e89a51:             // spaces and special characters, so it is necessary delimit them
1:9e89a51:             // for insert to work correctly.
1:9e89a51:             String name = (String) insertColumnNames.get(index);
1:9e89a51:             sb.append(IdUtil.normalToDelimited(name));
1:eac0369: 		}
1:eac0369: 	
1:eac0369: 		//there is no column info available
1:eac0369: 		if(first)
1:eac0369: 			return null;
1:eac0369: 		else
1:eac0369: 			return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	  Returns number of columns expected to be in  the file from the user input paramters.
1:eac0369: 	 */
1:eac0369: 	public int getExpectedNumberOfColumnsInFile()
1:eac0369: 	{
1:eac0369: 		return expectedNumberOfCols;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//Return true if the given table exists in the database
1:eac0369: 	private boolean tableExists() throws SQLException
1:eac0369: 	{
1:eac0369: 		DatabaseMetaData dmd = conn.getMetaData();
1:eac0369: 		ResultSet rs = dmd.getTables(null, schemaName, tableName, null);
1:eac0369: 		boolean foundTable = false;
1:eac0369: 		if(rs.next())
1:eac0369: 		{
1:eac0369: 			//found the entry
1:eac0369: 			foundTable = true;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		rs.close();
1:eac0369: 		return foundTable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:84e347a:     /*
1:84e347a:      * Returns the the expected vti data column types in a String format. 
1:84e347a:      * Format : (COLUMN NAME : TYPE [, COLUMN NAME : TYPE]*)
1:84e347a:      * eg: COLUMN1:1 (java.sql.Types.CHAR) , COLUMN2: -1(LONGVARCHAR) , 
1:84e347a:      * COLUMN3 : 2004 (BLOB)
1:eac0369:      */
1:84e347a: 	public String getExpectedVtiColumnTypesAsString() {
1:eac0369: 
1:84e347a:         StringBuffer vtiColumnTypes = new StringBuffer();
1:84e347a:         // expected types of data in the import file, based on 
1:84e347a:         // the how columns in the data file are  mapped to 
1:84e347a:         // the table  columns. 
1:84e347a:         boolean first = true;
1:84e347a:         for (int i =0 ; i < noOfColumns && i < vtiColumnNames.size(); i++) {
1:84e347a:             if (first) 
1:84e347a:                 first = false;
1:84e347a:             else
1:84e347a:                 vtiColumnTypes.append(",");
1:eac0369: 
1:84e347a:             vtiColumnTypes.append(vtiColumnNames.get(i) + ":" + 
1:84e347a:                                   jdbcColumnTypes.get(i));
1:eac0369:         }   
1:eac0369: 
1:84e347a: 		if(first) {
1:84e347a:             // there is no information about column types.
1:84e347a: 			return null;
1:84e347a:         }
1:84e347a: 		else
1:84e347a: 			return vtiColumnTypes.toString();
1:84e347a: 	}
1:eac0369: 
1:eac0369: 
1:84e347a:     /*
1:84e347a:      * Get the expected vti data column types. This information was 
1:2732872:      * earlier passed as a string to the vti. This routine extracts the 
1:84e347a:      * information from the string.
1:84e347a:      * @param columnTypesStr  import data column type information , 
1:84e347a:      *                        encoded as string. 
1:84e347a:      * @param noOfColumns     number of columns in the import file.
1:84e347a:      * 
1:84e347a:      * @see getExpectedVtiColumnTypesAsString()
2:84e347a:      */
1:84e347a:     public static int[] getExpectedVtiColumnTypes(String columnTypesStr, 
1:84e347a:                                                   int noOfColumns) 
1:84e347a:     {
1:84e347a:         // extract the table column types. Break the comma seperated 
1:84e347a:         // column types into java.sql.Types int values from the columnTypes 
1:84e347a:         // string that got passed to the import VTI.
1:eac0369: 
1:84e347a:         //eg: COLUMN1:1 (java.sql.Types.CHAR) , COLUMN2: -1(LONGVARCHAR) , 
1:84e347a:         //COLUMN3 : 2004 (BLOB)
1:eac0369: 
1:84e347a:         int[] vtiColumnTypes = new int[noOfColumns];
1:eac0369: 
1:84e347a:         // expected column type information is only available 
1:84e347a:         // for the columns that are being imported from the file.
1:84e347a:         // columns type information is not required when 
1:84e347a:         // a column in the data file is not one of the 
1:84e347a:         // imported column, just assume they are of VARCHAR type. 
1:eac0369:         
1:84e347a:         for (int i = 0 ; i < noOfColumns ; i++)
1:84e347a:             vtiColumnTypes[i] = java.sql.Types.VARCHAR;
8:84e347a: 
1:84e347a:         StringTokenizer st = new StringTokenizer(columnTypesStr , ",");
1:2732872: 
1:84e347a:         while (st.hasMoreTokens()) 
1:84e347a:         {
1:84e347a:             String colTypeInfo = (st.nextToken()).trim();
1:84e347a:             int colTypeOffset = colTypeInfo.indexOf(":");
1:84e347a: 
1:84e347a:             // column names format is "COLUMN" + columnNumner
1:ce40a31:             int colIndex = Integer.parseInt(colTypeInfo.substring(6, colTypeOffset));
1:ce40a31:             int colType = Integer.parseInt(colTypeInfo.substring(colTypeOffset+1));
1:84e347a: 
1:84e347a:             // column numbers start with 1. Check if user by mistake has 
1:84e347a:             // specified a column number that is large than than the 
1:84e347a:             // number of columns exist in the file, if that is the case
1:84e347a:             // don't assign the type.
1:84e347a:             if (colIndex <=  noOfColumns) 
1:84e347a:                 vtiColumnTypes[colIndex-1] = colType;
1:2732872:             
1:84e347a:         }
1:84e347a:         
1:84e347a:         return vtiColumnTypes;
1:84e347a:     }
1:2732872: 
1:2732872: 
1:2732872:     /*
1:2732872:      * Get the expected vti column type names. This information was 
1:2732872:      * passed earlier as a string to the vti. This routine extracts the 
1:2732872:      * information from the string.
1:2732872:      * @param columnTypeNamesString  import data column type information, encoded as string. 
1:2732872:      * @param noOfColumns     number of columns in the import file.
1:2732872:      * 
1:2732872:      * @see getColumnTypeNames()
1:2732872:      */
1:2732872:     public static String[] getExpectedColumnTypeNames
1:2732872:         ( String columnTypeNamesString, int noOfColumns )
1:2732872:         throws Exception
1:2732872:     {
1:a784994:         ArrayList list = (ArrayList)
1:a784994:                 ImportAbstract.destringifyObject( columnTypeNamesString );
1:2732872: 
1:2732872:         String[] retval = new String[ list.size() ];
1:2732872: 
1:a784994:         for (int i = 0; i < retval.length; i++) {
1:a784994:             retval[i] = (String) list.get(i);
1:a784994:         }
1:2732872: 
1:2732872:         return retval;
1:2732872:     }
1:2732872: 
1:2732872:     /*
1:2732872:      * Get the expected classes bound to UDT columns. This information was 
1:2732872:      * passed earlier as a string to the vti. This routine extracts the 
1:2732872:      * information from the string.
1:2732872:      * @param stringVersion The result of calling toString() on the original HashMap<String><String>.
1:2732872:      * @return a HashMap<String><Class> mapping column names to their udt classes
1:2732872:      * 
1:2732872:      * @see initializeColumnInfo()
1:2732872:      */
1:2732872:     public static HashMap getExpectedUDTClasses( String stringVersion )
1:2732872:         throws Exception
1:2732872:     {
1:2732872:         // deserialize the original HashMap<String><String>
1:2732872:         HashMap stringMap = deserializeHashMap( stringVersion );
1:2732872: 
1:2732872:         if ( stringMap == null ) { return null; }
1:2732872:         
1:400f6eb:         HashMap<String,Class<?>> retval = new HashMap<String,Class<?>>();
1:fc54674:         Iterator entries = stringMap.entrySet().iterator();
1:2732872: 
1:fc54674:         while ( entries.hasNext() )
1:2732872:         {
1:fc54674:             Map.Entry entry = (Map.Entry)entries.next();
1:fc54674:             String columnName = (String) entry.getKey();
1:fc54674:             String className = (String) entry.getValue();
1:2732872: 
1:400f6eb:             Class<?> classValue = Class.forName( className );
1:2732872: 
1:2732872:             retval.put( columnName, classValue );
1:2732872:         }
1:2732872: 
1:2732872:         return retval;
1:2732872:     }
1:2732872:     
1:2732872:     /*
1:2732872:      * Deserialize a HashMap produced by ExportAbstract.stringifyObject()
1:2732872:      */
1:2732872:     public static HashMap deserializeHashMap( String stringVersion )
1:2732872:         throws Exception
1:2732872:     {
1:2732872:         if ( stringVersion == null ) { return null; }
1:2732872: 
1:2732872:         HashMap retval = (HashMap) ImportAbstract.destringifyObject( stringVersion );
1:2732872: 
1:2732872:         return retval;
1:2732872:     }
1:2732872:     
1:84e347a: }
1:a784994: 
1:84e347a: 
1:84e347a: 
1:84e347a: 
1:84e347a: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:bb55cc3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.error.PublicAPI;
/////////////////////////////////////////////////////////////////////////
1:         private String[] headerColumnNames;
/////////////////////////////////////////////////////////////////////////
1: 					  String vtiColumnPrefix,
1: 					  String[] headerColumnNames)
/////////////////////////////////////////////////////////////////////////
1: 		this.headerColumnNames=headerColumnNames;
/////////////////////////////////////////////////////////////////////////
1: 				int cIndex;
1: 				String columnIndex = (st.nextToken()).trim();
1: 				if("\"".equals(columnIndex.substring(0,1))){
1: 					
1: 					cIndex = readHeaders((columnIndex.replace('"', ' ')).trim());
1: 					vtiColumnNames.add(vtiColumnPrefix + cIndex);
1: 
1: 				}
1: 				else{
1: 					
1: 					vtiColumnNames.add(vtiColumnPrefix + columnIndex);
1: 					cIndex = Integer.parseInt(columnIndex );
1: 				}
/////////////////////////////////////////////////////////////////////////
1: 	//Check for matchng patterns of column names
1: 	private int readHeaders(String columnPattern) 
1: 		throws SQLException
1: 	{
1: 	    	if(headerColumnNames!=null){
1: 		
1: 			for(int i=0;i<headerColumnNames.length;i++){
1: 				if(headerColumnNames[i].equals(columnPattern)){
1: 					return i+1;
1: 				}
1:  			}
1: 				
1: 	       		throw PublicAPI.wrapStandardException(StandardException.newException
1: 				(SQLState.LANG_INVALID_INPUT_COLUMN_NAME, columnPattern));
1: 		}
1: 		throw PublicAPI.wrapStandardException(StandardException.newException
1: 				(SQLState.LANG_INVALID_NUMBEROF_HEADER_LINES));
1: 	}
commit:be12a80
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
/////////////////////////////////////////////////////////////////////////
0: 				 type == java.sql.Types.BLOB ||
0: 				 type == StoredFormatIds.XML_TYPE_ID); 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
0: 				int cIndex = Integer.parseInt(columnIndex );
/////////////////////////////////////////////////////////////////////////
1:                 jdbcColumnTypes.add((int) dataType);
/////////////////////////////////////////////////////////////////////////
1:             int colIndex = Integer.parseInt(colTypeInfo.substring(6, colTypeOffset));
1:             int colType = Integer.parseInt(colTypeInfo.substring(colTypeOffset+1));
commit:400f6eb
/////////////////////////////////////////////////////////////////////////
1: 	private ArrayList<String> vtiColumnNames ;
1:     private ArrayList<String> insertColumnNames;
1:     private ArrayList<String> columnTypes ;
1:     private ArrayList<Integer> jdbcColumnTypes;
/////////////////////////////////////////////////////////////////////////
1:     private HashMap<String,String> udtClassNames;
/////////////////////////////////////////////////////////////////////////
1: 		vtiColumnNames = new ArrayList<String>(1);
1: 		insertColumnNames = new ArrayList<String>(1);
1: 		columnTypes = new ArrayList<String>(1);
1:         jdbcColumnTypes = new ArrayList<Integer>(1);
1:         udtClassNames = new HashMap<String,String>();
/////////////////////////////////////////////////////////////////////////
0:         @SuppressWarnings({"unchecked"})
0:         ArrayList<String> list = (ArrayList<String>) ImportAbstract.destringifyObject( columnTypeNamesString );
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String,Class<?>> retval = new HashMap<String,Class<?>>();
/////////////////////////////////////////////////////////////////////////
1:             Class<?> classValue = Class.forName( className );
commit:2a5922a
/////////////////////////////////////////////////////////////////////////
1:         catch (Exception e) { throw LoadError.unexpectedError( e ); }
commit:2732872
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.IdUtil;
/////////////////////////////////////////////////////////////////////////
0:     private HashMap udtClassNames;
/////////////////////////////////////////////////////////////////////////
0:         udtClassNames = new HashMap();
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if ( dataType == java.sql.Types.JAVA_OBJECT )
1:                 {
1:                     udtClassNames.put( "COLUMN" +  noOfColumns, getUDTClassName( dmd, typeName ) );
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     // look up the class name of a UDT
1:     private String getUDTClassName( DatabaseMetaData dmd, String sqlTypeName )
1:         throws SQLException
1:     {
1:         String className = null;
1:         
1:         try {
1:             // special case for system defined types
1:             if ( sqlTypeName.charAt( 0 ) != '"' ) { return sqlTypeName; }
1: 
1:             String[] nameParts = IdUtil.parseMultiPartSQLIdentifier( sqlTypeName );
1: 
1:             String schemaName = nameParts[ 0 ];
1:             String unqualifiedName = nameParts[ 1 ];
1: 
1:             ResultSet rs = dmd.getUDTs( null, schemaName, unqualifiedName, new int[] { java.sql.Types.JAVA_OBJECT } );
1: 
1:             if ( rs.next() )
1:             {
1:                 className = rs.getString( 4 );
1:             }
1:             rs.close();
1:         }
0:         catch (Exception e) { throw new SQLException( e.getMessage() ); }
1: 
1:         if ( className == null ) { className = "???"; }
1:         
1:         return className;
1:     }
1: 
0: 				 type == JDBC40Translation.SQLXML ); 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the column type names.
1:      */
1:     public String getColumnTypeNames()
1:         throws Exception
1:     {
1:         // we use the object serializer logic
1:         return ExportAbstract.stringifyObject( columnTypes );
1:     }
1: 
1:     /**
1:      * Get the class names of udt columns as a string.
1:      */
1:     public String getUDTClassNames()
1:         throws Exception
1:     {
1:         // we use the object serializer logic
1:         return ExportAbstract.stringifyObject( udtClassNames );
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * earlier passed as a string to the vti. This routine extracts the 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         
1: 
1: 
1:     /*
1:      * Get the expected vti column type names. This information was 
1:      * passed earlier as a string to the vti. This routine extracts the 
1:      * information from the string.
1:      * @param columnTypeNamesString  import data column type information, encoded as string. 
1:      * @param noOfColumns     number of columns in the import file.
1:      * 
1:      * @see getColumnTypeNames()
1:      */
1:     public static String[] getExpectedColumnTypeNames
1:         ( String columnTypeNamesString, int noOfColumns )
1:         throws Exception
1:     {
0:         ArrayList list = (ArrayList) ImportAbstract.destringifyObject( columnTypeNamesString );
1: 
1:         String[] retval = new String[ list.size() ];
1: 
0:         list.toArray( retval );
1:         
1:         return retval;
1:     }
1: 
1:     /*
1:      * Get the expected classes bound to UDT columns. This information was 
1:      * passed earlier as a string to the vti. This routine extracts the 
1:      * information from the string.
1:      * @param stringVersion The result of calling toString() on the original HashMap<String><String>.
1:      * @return a HashMap<String><Class> mapping column names to their udt classes
1:      * 
1:      * @see initializeColumnInfo()
1:      */
1:     public static HashMap getExpectedUDTClasses( String stringVersion )
1:         throws Exception
1:     {
1:         // deserialize the original HashMap<String><String>
1:         HashMap stringMap = deserializeHashMap( stringVersion );
1: 
1:         if ( stringMap == null ) { return null; }
1:         
0:         HashMap retval = new HashMap();
0:         Iterator keys = stringMap.keySet().iterator();
1: 
0:         while ( keys.hasNext() )
1:         {
0:             String columnName = (String) keys.next();
0:             String className = (String) stringMap.get( columnName );
1: 
0:             Class classValue = Class.forName( className );
1: 
1:             retval.put( columnName, classValue );
1:         }
1: 
1:         return retval;
1:     }
1:     
1:     /*
1:      * Deserialize a HashMap produced by ExportAbstract.stringifyObject()
1:      */
1:     public static HashMap deserializeHashMap( String stringVersion )
1:         throws Exception
1:     {
1:         if ( stringVersion == null ) { return null; }
1: 
1:         HashMap retval = (HashMap) ImportAbstract.destringifyObject( stringVersion );
1: 
1:         return retval;
1:     }
1:     
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:                  type == Types.SQLXML );
commit:a784994
/////////////////////////////////////////////////////////////////////////
1:         ArrayList list = (ArrayList)
1:                 ImportAbstract.destringifyObject( columnTypeNamesString );
1:         for (int i = 0; i < retval.length; i++) {
1:             retval[i] = (String) list.get(i);
1:         }
1: 
commit:fc54674
/////////////////////////////////////////////////////////////////////////
1:         Iterator entries = stringMap.entrySet().iterator();
1:         while ( entries.hasNext() )
1:             Map.Entry entry = (Map.Entry)entries.next();
1:             String columnName = (String) entry.getKey();
1:             String className = (String) entry.getValue();
commit:9e89a51
/////////////////////////////////////////////////////////////////////////
1:             // Column names can be SQL reserved words, or they can contain
1:             // spaces and special characters, so it is necessary delimit them
1:             // for insert to work correctly.
1:             String name = (String) insertColumnNames.get(index);
1:             sb.append(IdUtil.normalToDelimited(name));
commit:161e9cc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EngineConnection;
/////////////////////////////////////////////////////////////////////////
1:         if (sName == null) {
1:             // Use the current schema if no schema is specified.
1:             sName = ((EngineConnection) conn).getCurrentSchemaName();
1:         }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:01b5961
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0: 				 type == JDBC40Translation.SQLXML); 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.load.ColumnInfo
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:bff3c2e
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.load;
1: 
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
1: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.ResultSetMetaData;
1: import java.sql.DatabaseMetaData;
1: import java.util.*;
1: 
1: /**
1:  *	
1:  * This class provides supportto  create casting/conversions required to 
1:  * perform import. Import VTI  gives all the data in VARCHAR type becuase data
1:  * in the files is in CHAR format. There is no implicit cast availabile from
1:  * VARCHAR to some of the types. In cases where explicit casting is allowed, 
1:  * columns are casted with  explict cast to the type of table column; in case of 
1:  * double/real explicit casting is also not allowd , scalar fuction DOUBLE is
1:  * used in those cases.
1:  *  
0:  * @author suresht
1:  */
1: class ColumnInfo {
1: 	/**
0: 	   IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
0: 	private ArrayList vtiColumnNames ;
0: 	private ArrayList insertColumnNames;
0:     private ArrayList columnTypes ;
1: 	private int noOfColumns;
1: 	private ArrayList columnPositions;
1: 	private boolean createolumnNames = true;
1: 	private int expectedNumberOfCols ; //number of Columns that are suppose
1: 	                                       // to be in the file to imported  
1: 	private Connection conn;
1: 	private String tableName;
1: 	private String schemaName;
1: 
1: 	/**
1: 	 * Initialize the column type and name  information
1: 	 * @param conn  - connection to use for metadata queries
1: 	 * @param sName - table's schema
1: 	 * @param tName - table Name
0: 	 * @param columnList - comma seperared insert statement column list 
0: 	 * @param  vtiColumnIndex - Indexes in the file
1: 	 * @param  vtiColumnPrefix - Prefix to use to generate column names to select from VTI
1: 	 * @exception Exception on error 
1: 	 */
1: 	public ColumnInfo(Connection conn,
1: 					  String sName, 
1: 					  String tName,
1: 					  String insertColumnList, 
1: 					  String vtiColumnIndexes,
0: 					  String vtiColumnPrefix)
1: 		throws SQLException 
1: 	{
1: 
0: 		vtiColumnNames = new ArrayList(1);
0: 		insertColumnNames = new ArrayList(1);
0: 		columnTypes = new ArrayList(1);
1: 		noOfColumns = 0;
1: 		this.conn = conn;
0: 		this.schemaName = (sName !=null ? sName.toUpperCase(java.util.Locale.ENGLISH):sName);
0: 		this.tableName =  (tName !=null ? tName.toUpperCase(java.util.Locale.ENGLISH):tName);
1: 
1: 		if(insertColumnList!=null)
1: 		{
1: 			//break the comma seperated column list and initialze column info
0: 			//eg: c2 , c1 , c3
1: 			StringTokenizer st = new StringTokenizer(insertColumnList , ",");
1: 			while (st.hasMoreTokens()) 
1: 			{
1: 				String columnName = (st.nextToken()).trim();
1: 				if(!initializeColumnInfo(columnName))
1: 				{
1: 					if(tableExists())
1: 						throw  LoadError.invalidColumnName(columnName);
1: 					else
1: 					{
1: 						String entityName = (schemaName !=null ? 
1: 											 schemaName + "." + tableName :tableName); 
1: 						throw LoadError.tableNotFound(entityName);
1: 					}
1: 				}
1: 			}
1: 		}else
1: 		{
1: 			//All columns in the table
1: 			if(!initializeColumnInfo(null))
1: 			{
1: 				String entityName = (schemaName !=null ? 
1: 									 schemaName + "." + tableName :tableName); 
1: 				throw LoadError.tableNotFound(entityName);
1: 			}
1: 		}
1: 		
1: 				
1: 		//break the comma seperated column indexes for import file give by the user
1: 		//eg: "1, 3, 5, 7"
1: 		if(vtiColumnIndexes !=null)
1: 		{
1: 			
1: 			StringTokenizer st = new StringTokenizer(vtiColumnIndexes, ",");
1: 			while (st.hasMoreTokens()) 
1: 			{
0: 				String columnIndex  = (st.nextToken()).trim();
0: 				vtiColumnNames.add(vtiColumnPrefix + columnIndex);
0: 				int cIndex = (new Integer(columnIndex )).intValue();
1: 				if(cIndex > expectedNumberOfCols )
1: 					expectedNumberOfCols= cIndex ;
1: 			}
1: 
1: 		}
1: 
1: 
1: 		//if column indexes are not specified  ; create names for all collumns requested
1: 		if(vtiColumnNames.size() < 1)
1: 		{
1: 			for(int index = 1 ; index <= noOfColumns; index++)
1: 			{
1: 				vtiColumnNames.add(vtiColumnPrefix + index);
1: 			}
1: 			expectedNumberOfCols = noOfColumns ;
1: 		}
1: 	}
1: 
1: 
1: 	private boolean initializeColumnInfo(String columnPattern)
1: 		throws SQLException
1: 	{
1: 		DatabaseMetaData dmd = conn.getMetaData();
1: 		ResultSet rs = dmd.getColumns(null, 
1: 									  schemaName,
1: 									  tableName,
0: 									  (columnPattern !=null ? columnPattern.toUpperCase(java.util.Locale.ENGLISH):columnPattern));
1: 		boolean foundTheColumn=false;
1: 		while (rs.next())
1: 		{
1: 
1: 			// 4.COLUMN_NAME String => column name
1: 			String columnName = rs.getString(4);
1: 
1: 			// 5.DATA_TYPE short => SQL type from java.sql.Types
1: 			short dataType = rs.getShort(5);
1: 
1: 			// 6.TYPE_NAME String => Data source dependent type name
1: 			String typeName = rs.getString(6);
1: 
1: 			
1: 			// 7.COLUMN_SIZE int => column size. For char or date types
1: 			// this is the maximum number of characters, for numeric or
1: 			// decimal types this is precision.
1: 			int columnSize = rs.getInt(7);
1: 
1: 			// 9.DECIMAL_DIGITS int => the number of fractional digits
1: 			int decimalDigits = rs.getInt(9);
1: 
1: 			// 10.NUM_PREC_RADIX int => Radix (typically either 10 or 2)
1: 			int numPrecRadix = rs.getInt(10);
1: 			foundTheColumn = true;
1: 			if(importExportSupportedType(dataType))
1: 			{
1: 
1: 				insertColumnNames.add(columnName);
1: 				String sqlType = typeName + getTypeOption(typeName , columnSize , columnSize , decimalDigits);
0: 				columnTypes.add(noOfColumns , sqlType);
1: 				noOfColumns++;
1: 			}else
1: 			{
1: 				rs.close();
1: 				throw
1: 					LoadError.nonSupportedTypeColumn(columnName,typeName);
1: 			}
1: 
1: 		}
1: 
1: 		rs.close();
1: 		return foundTheColumn;
1: 	}
1: 
1: 
1: 	//return true if the given type is supported by import/export
1: 	public  static final boolean importExportSupportedType(int type){
1: 
0: 		return !(type == java.sql.Types.BINARY ||
0: 				 type == java.sql.Types.BIT ||
0: 				 type == java.sql.Types.JAVA_OBJECT ||
1: 				 type == java.sql.Types.OTHER ||
0: 				 type == java.sql.Types.CLOB ||
0: 				 type == java.sql.Types.BLOB); 
1: 	}
1: 
1: 
1: 	private String getTypeOption(String type , int length , int precision , int scale)
1: 	{
1: 
1: 			if ((type.equals("CHAR") ||
1: 				 type.equals("BLOB") ||
1: 				 type.equals("CLOB") ||
1: 				 type.equals("VARCHAR")) && length != 0)
1: 			{
1: 				 return "(" + length + ")";
1: 			}
1: 
1: 			if (type.equals("FLOAT")  && precision != 0)
1: 				return  "(" + precision + ")";
1: 
1: 			//there are three format of decimal and numeric. Plain decimal, decimal(x)
1: 			//and decimal(x,y). x is precision and y is scale.
1: 			if (type.equals("DECIMAL") ||
1: 				type.equals("NUMERIC")) 
1: 			{
1: 				if ( precision != 0 && scale == 0)
1: 					return "(" + precision + ")";
1: 				else if (precision != 0 && scale != 0)
1: 					return "(" + precision + "," + scale + ")";
1: 				else if(precision == 0 && scale!=0)
1: 					return "(" + scale + ")";
1: 			}
1: 
1: 			if ((type.equals("DECIMAL") ||
1: 				 type.equals("NUMERIC")) && scale != 0)
1: 				return "(" + scale + ")";
1: 
1: 			//no special type option
1: 			return "";
1: 	}
1: 
1: 
1: 	/*
1: 	 * Returns a  string of columns with proper casting/conversion
1: 	 * to be used to select from import VTI.
1: 	 */
1: 	public String getColumnNamesWithCasts()
1: 	{
1: 		StringBuffer sb = new StringBuffer();
1: 		boolean first = true;
1: 		int noOfVtiCols =  vtiColumnNames.size();
1: 		for(int index = 0 ; index < noOfColumns && index < noOfVtiCols; index++)
1: 		{
1: 			if(!first)
1: 				sb.append(", ");
1: 			else
1: 				first = false;
1: 			String type = (String) columnTypes.get(index);
1: 			String columnName = (String) vtiColumnNames.get(index);
1: 		   
1: 			if(type.startsWith("SMALLINT") ||
1: 			   type.startsWith("INTEGER") ||
1: 			   type.startsWith("DECIMAL") ||
1: 			   type.startsWith("BIGINT") ||
1: 			   type.startsWith("NUMERIC"))							  
1: 			{
1: 				//these types require explicit casting
1: 				sb.append(" cast" + "(" + columnName + " AS " + type + ") "); 
1: 
1: 			}else
1: 			{
1: 				//if it is DOUBLE use scalar DOUBLE function no explicit casting allowed
1: 				if(type.startsWith("DOUBLE"))
1: 				{
1: 					sb.append(" DOUBLE" + "(" + columnName + ") ");
1: 
1: 				}else
1: 				{
1: 					//REAL: use DOUBLE function to convert from string and the cast to REAL
1: 					if(type.startsWith("REAL"))
1: 					{
1: 						sb.append("cast" + "(" + 
1: 								  " DOUBLE" + "(" + columnName + ") " + 
1: 								  " AS " +  "REAL" + ") ");
1: 					}else
1: 					{
1: 						//all other types does  not need any special casting
1: 						sb.append(" " + columnName +  " "); 
1: 					}
1: 				}
1: 
1: 			}
1: 		}
1: 
1: 		//there is no column info available
1: 		if(first)
1: 			return " * ";
1: 		else
1: 			return sb.toString();
1: 	}
1: 
0: 	/* returns comma seperated column Names for insert statement
0: 	 * eg: c1, c2 , c3 , c4 
1: 	 */
1: 	public String getInsertColumnNames()
1: 	{
1: 		StringBuffer sb = new StringBuffer();
1: 		boolean first = true;
1: 		for(int index = 0 ; index < noOfColumns; index++)
1: 		{
1: 			if(!first)
1: 				sb.append(", ");
1: 			else
1: 				first = false;
0: 			sb.append(insertColumnNames.get(index));
1: 		}
1: 	
1: 		//there is no column info available
1: 		if(first)
1: 			return null;
1: 		else
1: 			return sb.toString();
1: 	}
1: 
1: 	/*
1: 	  Returns number of columns expected to be in  the file from the user input paramters.
1: 	 */
1: 	public int getExpectedNumberOfColumnsInFile()
1: 	{
1: 		return expectedNumberOfCols;
1: 	}
1: 
1: 	//Return true if the given table exists in the database
1: 	private boolean tableExists() throws SQLException
1: 	{
1: 		DatabaseMetaData dmd = conn.getMetaData();
1: 		ResultSet rs = dmd.getTables(null, schemaName, tableName, null);
1: 		boolean foundTable = false;
1: 		if(rs.next())
1: 		{
1: 			//found the entry
1: 			foundTable = true;
1: 		}
1: 		
1: 		rs.close();
1: 		return foundTable;
1: 	}
1: 
1: }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:ea980d3
/////////////////////////////////////////////////////////////////////////
1: 		return !(type == java.sql.Types.BIT ||
commit:84e347a
/////////////////////////////////////////////////////////////////////////
0:     private ArrayList insertColumnNames;
0:     private ArrayList jdbcColumnTypes;
0:                                        // to be in the file to imported  
/////////////////////////////////////////////////////////////////////////
0:         jdbcColumnTypes = new ArrayList(1);
/////////////////////////////////////////////////////////////////////////
1: 				columnTypes.add(sqlType);
0:                 jdbcColumnTypes.add(new Integer(dataType));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /*
1:      * Returns the the expected vti data column types in a String format. 
1:      * Format : (COLUMN NAME : TYPE [, COLUMN NAME : TYPE]*)
1:      * eg: COLUMN1:1 (java.sql.Types.CHAR) , COLUMN2: -1(LONGVARCHAR) , 
1:      * COLUMN3 : 2004 (BLOB)
1:      */
1: 	public String getExpectedVtiColumnTypesAsString() {
1: 
1:         StringBuffer vtiColumnTypes = new StringBuffer();
1:         // expected types of data in the import file, based on 
1:         // the how columns in the data file are  mapped to 
1:         // the table  columns. 
1:         boolean first = true;
1:         for (int i =0 ; i < noOfColumns && i < vtiColumnNames.size(); i++) {
1:             if (first) 
1:                 first = false;
1:             else
1:                 vtiColumnTypes.append(",");
1: 
1:             vtiColumnTypes.append(vtiColumnNames.get(i) + ":" + 
1:                                   jdbcColumnTypes.get(i));
1:         }   
1: 
1: 		if(first) {
1:             // there is no information about column types.
1: 			return null;
1:         }
1: 		else
1: 			return vtiColumnTypes.toString();
1: 	}
1: 
1: 
1:     /*
1:      * Get the expected vti data column types. This information was 
0:      * passed earlies as string to the vti. This rourine extract the 
1:      * information from the string.
1:      * @param columnTypesStr  import data column type information , 
1:      *                        encoded as string. 
1:      * @param noOfColumns     number of columns in the import file.
1:      * 
1:      * @see getExpectedVtiColumnTypesAsString()
1:      */
1:     public static int[] getExpectedVtiColumnTypes(String columnTypesStr, 
1:                                                   int noOfColumns) 
1:     {
1: 
1:         // extract the table column types. Break the comma seperated 
1:         // column types into java.sql.Types int values from the columnTypes 
1:         // string that got passed to the import VTI.
1: 
1:         //eg: COLUMN1:1 (java.sql.Types.CHAR) , COLUMN2: -1(LONGVARCHAR) , 
1:         //COLUMN3 : 2004 (BLOB)
1: 
1:         int[] vtiColumnTypes = new int[noOfColumns];
1: 
1:         // expected column type information is only available 
1:         // for the columns that are being imported from the file.
1:         // columns type information is not required when 
1:         // a column in the data file is not one of the 
1:         // imported column, just assume they are of VARCHAR type. 
1:         
1:         for (int i = 0 ; i < noOfColumns ; i++)
1:             vtiColumnTypes[i] = java.sql.Types.VARCHAR;
1: 
1:         StringTokenizer st = new StringTokenizer(columnTypesStr , ",");
1:         while (st.hasMoreTokens()) 
1:         {
1:             String colTypeInfo = (st.nextToken()).trim();
1:             int colTypeOffset = colTypeInfo.indexOf(":");
1: 
1:             // column names format is "COLUMN" + columnNumner
0:             int colIndex = (new Integer(colTypeInfo.substring(6, 
0:                                         colTypeOffset))).intValue();
0:             int colType = (new Integer(colTypeInfo.substring(
0:                                           colTypeOffset+1))).intValue();
1: 
1:             // column numbers start with 1. Check if user by mistake has 
1:             // specified a column number that is large than than the 
1:             // number of columns exist in the file, if that is the case
1:             // don't assign the type.
1:             if (colIndex <=  noOfColumns) 
1:                 vtiColumnTypes[colIndex-1] = colType;
1:             
1:         }
1:         return vtiColumnTypes;
1:     }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:6d913c6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param insertColumnList - comma seperared insert statement column list 
1: 	 * @param  vtiColumnIndexes - Indexes in the file
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c47d471
/////////////////////////////////////////////////////////////////////////
0: 
1: 		this.schemaName = sName;
1: 		this.tableName =  tName;
1: 			//eg: C2 , C1 , C3
/////////////////////////////////////////////////////////////////////////
1: 									  columnPattern);
/////////////////////////////////////////////////////////////////////////
1: 	/* returns comma seperated column Names delimited by quotes for the insert 
1:      * statement
1: 	 * eg: "C1", "C2" , "C3" , "C4" 
/////////////////////////////////////////////////////////////////////////
0: 			// column names can be SQL reserved words, so it 
0: 			// is necessary delimit them using quotes for insert to work correctly. 
0: 			sb.append("\"");
0: 			sb.append("\"");
/////////////////////////////////////////////////////////////////////////
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.load;
0: 
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.ResultSetMetaData;
0: import java.sql.DatabaseMetaData;
0: import java.util.*;
0: 
0: /**
0:  *	
0:  * This class provides supportto  create casting/conversions required to 
0:  * perform import. Import VTI  gives all the data in VARCHAR type becuase data
0:  * in the files is in CHAR format. There is no implicit cast availabile from
0:  * VARCHAR to some of the types. In cases where explicit casting is allowed, 
0:  * columns are casted with  explict cast to the type of table column; in case of 
0:  * double/real explicit casting is also not allowd , scalar fuction DOUBLE is
0:  * used in those cases.
0:  *  
0:  * @author suresht
0:  */
0: class ColumnInfo {
0: 	/**
0: 	   IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
0: 
0: 	private ArrayList vtiColumnNames ;
0: 	private ArrayList insertColumnNames;
0:     private ArrayList columnTypes ;
0: 	private int noOfColumns;
0: 	private ArrayList columnPositions;
0: 	private boolean createolumnNames = true;
0: 	private int expectedNumberOfCols ; //number of Columns that are suppose
0: 	                                       // to be in the file to imported  
0: 	private Connection conn;
0: 	private String tableName;
0: 	private String schemaName;
0: 
0: 	/**
0: 	 * Initialize the column type and name  information
0: 	 * @param conn  - connection to use for metadata queries
0: 	 * @param sName - table's schema
0: 	 * @param tName - table Name
0: 	 * @param columnList - comma seperared insert statement column list 
0: 	 * @param  vtiColumnIndex - Indexes in the file
0: 	 * @param  vtiColumnPrefix - Prefix to use to generate column names to select from VTI
0: 	 * @exception Exception on error 
0: 	 */
0: 	public ColumnInfo(Connection conn,
0: 					  String sName, 
0: 					  String tName,
0: 					  String insertColumnList, 
0: 					  String vtiColumnIndexes,
0: 					  String vtiColumnPrefix)
0: 		throws SQLException 
0: 	{
0: 
0: 		vtiColumnNames = new ArrayList(1);
0: 		insertColumnNames = new ArrayList(1);
0: 		columnTypes = new ArrayList(1);
0: 		noOfColumns = 0;
0: 		this.conn = conn;
0: 		this.schemaName = (sName !=null ? sName.toUpperCase(java.util.Locale.ENGLISH):sName);
0: 		this.tableName =  (tName !=null ? tName.toUpperCase(java.util.Locale.ENGLISH):tName);
0: 
0: 		if(insertColumnList!=null)
0: 		{
0: 			//break the comma seperated column list and initialze column info
0: 			//eg: c2 , c1 , c3
0: 			StringTokenizer st = new StringTokenizer(insertColumnList , ",");
0: 			while (st.hasMoreTokens()) 
0: 			{
0: 				String columnName = (st.nextToken()).trim();
0: 				if(!initializeColumnInfo(columnName))
0: 				{
0: 					if(tableExists())
0: 						throw  LoadError.invalidColumnName(columnName);
0: 					else
0: 					{
0: 						String entityName = (schemaName !=null ? 
0: 											 schemaName + "." + tableName :tableName); 
0: 						throw LoadError.tableNotFound(entityName);
0: 					}
0: 				}
0: 			}
0: 		}else
0: 		{
0: 			//All columns in the table
0: 			if(!initializeColumnInfo(null))
0: 			{
0: 				String entityName = (schemaName !=null ? 
0: 									 schemaName + "." + tableName :tableName); 
0: 				throw LoadError.tableNotFound(entityName);
0: 			}
0: 		}
0: 		
0: 				
0: 		//break the comma seperated column indexes for import file give by the user
0: 		//eg: "1, 3, 5, 7"
0: 		if(vtiColumnIndexes !=null)
0: 		{
0: 			
0: 			StringTokenizer st = new StringTokenizer(vtiColumnIndexes, ",");
0: 			while (st.hasMoreTokens()) 
0: 			{
0: 				String columnIndex  = (st.nextToken()).trim();
0: 				vtiColumnNames.add(vtiColumnPrefix + columnIndex);
0: 				int cIndex = (new Integer(columnIndex )).intValue();
0: 				if(cIndex > expectedNumberOfCols )
0: 					expectedNumberOfCols= cIndex ;
0: 			}
0: 
0: 		}
0: 
0: 
0: 		//if column indexes are not specified  ; create names for all collumns requested
0: 		if(vtiColumnNames.size() < 1)
0: 		{
0: 			for(int index = 1 ; index <= noOfColumns; index++)
0: 			{
0: 				vtiColumnNames.add(vtiColumnPrefix + index);
0: 			}
0: 			expectedNumberOfCols = noOfColumns ;
0: 		}
0: 	}
0: 
0: 
0: 	private boolean initializeColumnInfo(String columnPattern)
0: 		throws SQLException
0: 	{
0: 		DatabaseMetaData dmd = conn.getMetaData();
0: 		ResultSet rs = dmd.getColumns(null, 
0: 									  schemaName,
0: 									  tableName,
0: 									  (columnPattern !=null ? columnPattern.toUpperCase(java.util.Locale.ENGLISH):columnPattern));
0: 		boolean foundTheColumn=false;
0: 		while (rs.next())
0: 		{
0: 
0: 			// 4.COLUMN_NAME String => column name
0: 			String columnName = rs.getString(4);
0: 
0: 			// 5.DATA_TYPE short => SQL type from java.sql.Types
0: 			short dataType = rs.getShort(5);
0: 
0: 			// 6.TYPE_NAME String => Data source dependent type name
0: 			String typeName = rs.getString(6);
0: 
0: 			
0: 			// 7.COLUMN_SIZE int => column size. For char or date types
0: 			// this is the maximum number of characters, for numeric or
0: 			// decimal types this is precision.
0: 			int columnSize = rs.getInt(7);
0: 
0: 			// 9.DECIMAL_DIGITS int => the number of fractional digits
0: 			int decimalDigits = rs.getInt(9);
0: 
0: 			// 10.NUM_PREC_RADIX int => Radix (typically either 10 or 2)
0: 			int numPrecRadix = rs.getInt(10);
0: 			foundTheColumn = true;
0: 			if(importExportSupportedType(dataType))
0: 			{
0: 
0: 				insertColumnNames.add(columnName);
0: 				String sqlType = typeName + getTypeOption(typeName , columnSize , columnSize , decimalDigits);
0: 				columnTypes.add(noOfColumns , sqlType);
0: 				noOfColumns++;
0: 			}else
0: 			{
0: 				rs.close();
0: 				throw
0: 					LoadError.nonSupportedTypeColumn(columnName,typeName);
0: 			}
0: 
0: 		}
0: 
0: 		rs.close();
0: 		return foundTheColumn;
0: 	}
0: 
0: 
0: 	//return true if the given type is supported by import/export
0: 	public  static final boolean importExportSupportedType(int type){
0: 
0: 		return !(type == java.sql.Types.BINARY ||
0: 				 type == java.sql.Types.BIT ||
0: 				 type == java.sql.Types.JAVA_OBJECT ||
0: 				 type == java.sql.Types.OTHER ||
0: 				 type == java.sql.Types.CLOB ||
0: 				 type == java.sql.Types.BLOB); 
0: 	}
0: 
0: 
0: 	private String getTypeOption(String type , int length , int precision , int scale)
0: 	{
0: 
0: 			if ((type.equals("CHAR") ||
0: 				 type.equals("BLOB") ||
0: 				 type.equals("CLOB") ||
0: 				 type.equals("VARCHAR")) && length != 0)
0: 			{
0: 				 return "(" + length + ")";
0: 			}
0: 
0: 			if (type.equals("FLOAT")  && precision != 0)
0: 				return  "(" + precision + ")";
0: 
0: 			//there are three format of decimal and numeric. Plain decimal, decimal(x)
0: 			//and decimal(x,y). x is precision and y is scale.
0: 			if (type.equals("DECIMAL") ||
0: 				type.equals("NUMERIC")) 
0: 			{
0: 				if ( precision != 0 && scale == 0)
0: 					return "(" + precision + ")";
0: 				else if (precision != 0 && scale != 0)
0: 					return "(" + precision + "," + scale + ")";
0: 				else if(precision == 0 && scale!=0)
0: 					return "(" + scale + ")";
0: 			}
0: 
0: 			if ((type.equals("DECIMAL") ||
0: 				 type.equals("NUMERIC")) && scale != 0)
0: 				return "(" + scale + ")";
0: 
0: 			//no special type option
0: 			return "";
0: 	}
0: 
0: 
0: 	/*
0: 	 * Returns a  string of columns with proper casting/conversion
0: 	 * to be used to select from import VTI.
0: 	 */
0: 	public String getColumnNamesWithCasts()
0: 	{
0: 		StringBuffer sb = new StringBuffer();
0: 		boolean first = true;
0: 		int noOfVtiCols =  vtiColumnNames.size();
0: 		for(int index = 0 ; index < noOfColumns && index < noOfVtiCols; index++)
0: 		{
0: 			if(!first)
0: 				sb.append(", ");
0: 			else
0: 				first = false;
0: 			String type = (String) columnTypes.get(index);
0: 			String columnName = (String) vtiColumnNames.get(index);
0: 		   
0: 			if(type.startsWith("SMALLINT") ||
0: 			   type.startsWith("INTEGER") ||
0: 			   type.startsWith("DECIMAL") ||
0: 			   type.startsWith("BIGINT") ||
0: 			   type.startsWith("NUMERIC"))							  
0: 			{
0: 				//these types require explicit casting
0: 				sb.append(" cast" + "(" + columnName + " AS " + type + ") "); 
0: 
0: 			}else
0: 			{
0: 				//if it is DOUBLE use scalar DOUBLE function no explicit casting allowed
0: 				if(type.startsWith("DOUBLE"))
0: 				{
0: 					sb.append(" DOUBLE" + "(" + columnName + ") ");
0: 
0: 				}else
0: 				{
0: 					//REAL: use DOUBLE function to convert from string and the cast to REAL
0: 					if(type.startsWith("REAL"))
0: 					{
0: 						sb.append("cast" + "(" + 
0: 								  " DOUBLE" + "(" + columnName + ") " + 
0: 								  " AS " +  "REAL" + ") ");
0: 					}else
0: 					{
0: 						//all other types does  not need any special casting
0: 						sb.append(" " + columnName +  " "); 
0: 					}
0: 				}
0: 
0: 			}
0: 		}
0: 
0: 		//there is no column info available
0: 		if(first)
0: 			return " * ";
0: 		else
0: 			return sb.toString();
0: 	}
0: 
0: 	/* returns comma seperated column Names for insert statement
0: 	 * eg: c1, c2 , c3 , c4 
0: 	 */
0: 	public String getInsertColumnNames()
0: 	{
0: 		StringBuffer sb = new StringBuffer();
0: 		boolean first = true;
0: 		for(int index = 0 ; index < noOfColumns; index++)
0: 		{
0: 			if(!first)
0: 				sb.append(", ");
0: 			else
0: 				first = false;
0: 			sb.append(insertColumnNames.get(index));
0: 		}
0: 	
0: 		//there is no column info available
0: 		if(first)
0: 			return null;
0: 		else
0: 			return sb.toString();
0: 	}
0: 
0: 	/*
0: 	  Returns number of columns expected to be in  the file from the user input paramters.
0: 	 */
0: 	public int getExpectedNumberOfColumnsInFile()
0: 	{
0: 		return expectedNumberOfCols;
0: 	}
0: 
0: 	//Return true if the given table exists in the database
0: 	private boolean tableExists() throws SQLException
0: 	{
0: 		DatabaseMetaData dmd = conn.getMetaData();
0: 		ResultSet rs = dmd.getTables(null, schemaName, tableName, null);
0: 		boolean foundTable = false;
0: 		if(rs.next())
0: 		{
0: 			//found the entry
0: 			foundTable = true;
0: 		}
0: 		
0: 		rs.close();
0: 		return foundTable;
0: 	}
0: 
0: }
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================