1:eac0369: /*
11:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.services.locks.LockSpace
1:345de35: 
1:93fea34:    Licensed to the Apache Software Foundation (ASF) under one or more
1:93fea34:    contributor license agreements.  See the NOTICE file distributed with
1:93fea34:    this work for additional information regarding copyright ownership.
1:93fea34:    The ASF licenses this file to you under the Apache License, Version 2.0
1:93fea34:    (the "License"); you may not use this file except in compliance with
1:93fea34:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.services.locks;
1:eac0369: 
1:3c1f634: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
1:eac0369: import org.apache.derby.iapi.services.locks.Lockable;
1:eac0369: import org.apache.derby.iapi.services.locks.Limit;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.util.Matchable;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:f9a152b: import java.util.ArrayDeque;
1:eac0369: import java.util.Enumeration;
1:eac0369: import java.util.HashMap;
1:eac0369: import java.util.Iterator;
1:85e3e12: import org.apache.derby.iapi.services.locks.LockOwner;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: 	A LockSpace represents the complete set of locks held within
1:3c1f634: 	a single compatibility space, broken into groups of locks.
1:eac0369: 
1:3c1f634:     A LockSpace contains a HashMap keyed by the group reference,
1:7a0cbb4:     the data for each key is a HashMap of Lock's.
1:eac0369: 
1:3c1f634:     <p> A <code>LockSpace</code> can have an owner (for instance a
1:3c1f634:     transaction). Currently, the owner is used by the virtual lock table to
1:3c1f634:     find out which transaction a lock belongs to. Some parts of the code also
1:3c1f634:     use the owner as a group object which guarantees that the lock is released
1:3c1f634:     on a commit or an abort. The owner has no special meaning to the lock
1:3c1f634:     manager and can be any object, including <code>null</code>. </p>
1:eac0369: */
1:3c1f634: final class LockSpace implements CompatibilitySpace {
1:eac0369: 
1:7a0cbb4: 	/** Map from group references to groups of locks. */
1:a045b63:     private final HashMap<Object, HashMap<Lock, Lock>> groups;
1:3c1f634: 	/** Reference to the owner of this compatibility space. */
1:85e3e12: 	private final LockOwner owner;
1:eac0369: 
1:f9a152b:     /** The maximum number of elements to cache in {@link #spareGroups}. */
1:f9a152b:     private static final int MAX_CACHED_GROUPS = 3;
1:f9a152b: 
1:f9a152b:     /** Cached HashMaps for storing lock groups. */
1:a045b63:     private final ArrayDeque<HashMap<Lock, Lock>> spareGroups =
1:a045b63:             new ArrayDeque<HashMap<Lock, Lock>>(MAX_CACHED_GROUPS);
1:eac0369: 
1:eac0369: 	// the Limit info.
1:eac0369: 	private Object callbackGroup;
1:eac0369: 	private int    limit;
1:eac0369: 	private int    nextLimitCall;
1:eac0369: 	private Limit  callback;
1:eac0369: 
1:3c1f634: 	/**
1:3c1f634: 	 * Creates a new <code>LockSpace</code> instance.
1:3c1f634: 	 *
1:3c1f634: 	 * @param owner an object representing the owner of the compatibility space
1:3c1f634: 	 */
1:85e3e12: 	LockSpace(LockOwner owner) {
1:a045b63:         groups = new HashMap<Object, HashMap<Lock, Lock>>();
1:3c1f634: 		this.owner = owner;
1:3c1f634: 	}
1:3c1f634: 
1:3c1f634: 	/**
1:3c1f634: 	 * Get the object representing the owner of the compatibility space.
1:3c1f634: 	 *
1:3c1f634: 	 * @return the owner of the compatibility space
1:3c1f634: 	 */
1:85e3e12: 	public LockOwner getOwner() {
1:3c1f634: 		return owner;
5:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add a lock to a group.
1:eac0369: 	*/
1:eac0369: 	protected synchronized void addLock(Object group, Lock lock)
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		Lock lockInGroup = null;
1:eac0369: 
1:a045b63:         HashMap<Lock, Lock> dl = groups.get(group);
1:eac0369: 		if (dl == null)	{
1:eac0369: 			dl = getGroupMap(group);
1:eac0369: 		} else if (lock.getCount() != 1) {
1:a045b63:             lockInGroup = dl.get(lock);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (lockInGroup == null) {
1:eac0369: 			lockInGroup = lock.copy();
1:eac0369: 			dl.put(lockInGroup, lockInGroup);
1:eac0369: 		}
1:eac0369: 		lockInGroup.count++;
1:eac0369: 
1:eac0369: 		if (inLimit)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		if (!group.equals(callbackGroup))
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		int groupSize = dl.size();
1:eac0369: 		
1:eac0369: 		if (groupSize > nextLimitCall) {
1:eac0369: 
1:eac0369: 			inLimit = true;
1:3c1f634: 			callback.reached(this, group, limit,
1:eac0369: 				new LockList(java.util.Collections.enumeration(dl.keySet())), groupSize);
1:eac0369: 			inLimit = false;
1:eac0369: 
1:eac0369: 			// see when the next callback should occur, if the callback
1:eac0369: 			// failed to release a sufficent amount of locks then
1:eac0369: 			// delay until another "limit" locks are obtained.
1:eac0369: 			int newGroupSize = dl.size();
1:eac0369: 			if (newGroupSize < (limit / 2))
1:eac0369: 				nextLimitCall = limit;
1:eac0369: 			else if (newGroupSize < (nextLimitCall / 2))
1:eac0369: 				nextLimitCall -= limit;
1:eac0369: 			else
1:eac0369: 				nextLimitCall += limit;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	private boolean inLimit;
1:eac0369: 	/**
1:eac0369: 		Unlock all the locks in a group and then remove the group.
1:eac0369: 	*/
1:eac0369: 
1:b3eb01a: 	synchronized void unlockGroup(LockTable lset, Object group) {
1:a045b63:         HashMap<Lock, Lock> dl = groups.remove(group);
1:eac0369: 		if (dl == null)
1:eac0369: 			return;
1:eac0369: 
1:f9a152b:         for (Lock lock : dl.keySet()) {
1:f9a152b:             lset.unlock(lock, 0);
1:eac0369: 		}
1:eac0369: 
1:3c1f634: 		if ((callbackGroup != null) && group.equals(callbackGroup)) {
1:eac0369: 			nextLimitCall = limit;
1:3c1f634: 		}
1:eac0369: 
1:eac0369: 		saveGroup(dl);
1:eac0369: 	}
1:eac0369: 
1:a045b63:     private HashMap<Lock, Lock> getGroupMap(Object group) {
1:a045b63:         HashMap<Lock, Lock> dl = spareGroups.poll();
1:eac0369: 
1:eac0369: 		if (dl == null)
1:a045b63:             dl = new HashMap<Lock, Lock>(5, 0.8f);
1:eac0369: 
1:7a0cbb4: 		groups.put(group, dl);
1:eac0369: 		return dl;
1:eac0369: 	}
1:f9a152b: 
1:a045b63:     private void saveGroup(HashMap<Lock, Lock> dl) {
1:f9a152b:         if (spareGroups.size() < MAX_CACHED_GROUPS) {
1:f9a152b:             spareGroups.offer(dl);
1:f9a152b:             dl.clear();
1:f9a152b:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Unlock all locks in the group that match the key
1:eac0369: 	*/
1:b3eb01a: 	synchronized void unlockGroup(LockTable lset, Object group, Matchable key) {
1:a045b63:         HashMap<Lock, Lock> dl = groups.get(group);
1:eac0369: 		if (dl == null)
1:eac0369: 			return; //  no group at all
1:eac0369: 
1:eac0369: 		boolean allUnlocked = true;
1:f9a152b:         for (Iterator<Lock> e = dl.keySet().iterator(); e.hasNext(); ) {
1:f9a152b:             Lock lock = e.next();
1:eac0369: 			if (!key.match(lock.getLockable())) {
1:eac0369: 				allUnlocked = false;
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 			lset.unlock(lock, 0);
1:eac0369: 			e.remove();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (allUnlocked) {
1:7a0cbb4: 			groups.remove(group);
1:eac0369: 			saveGroup(dl);
1:3c1f634: 			if ((callbackGroup != null) && group.equals(callbackGroup)) {
1:eac0369: 				nextLimitCall = limit;
1:3c1f634: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	synchronized void transfer(Object oldGroup, Object newGroup) {
1:a045b63:         HashMap<Lock, Lock> from = groups.get(oldGroup);
1:eac0369: 		if (from == null)
1:eac0369: 			return;
1:eac0369: 
1:a045b63:         HashMap<Lock, Lock> to = groups.get(newGroup);
1:eac0369: 		if (to == null) {
1:eac0369: 			// simple case 
1:7a0cbb4: 			groups.put(newGroup, from);
1:eac0369: 			clearLimit(oldGroup);
1:7a0cbb4: 			groups.remove(oldGroup);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (to.size() < from.size()) {
1:eac0369: 
1:eac0369: 			// place the contents of to into from
1:eac0369: 			mergeGroups(to, from);
1:eac0369: 
1:7a0cbb4: 			Object oldTo = groups.put(newGroup, from);
1:eac0369: 			if (SanityManager.DEBUG) {
1:eac0369: 				SanityManager.ASSERT(oldTo == to, "inconsistent state in LockSpace");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		} else {
1:eac0369: 			mergeGroups(from, to);
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		clearLimit(oldGroup);
1:7a0cbb4: 		groups.remove(oldGroup);
1:eac0369: 	}
1:eac0369: 
1:a045b63:     private void mergeGroups(HashMap<Lock, Lock> from, HashMap<Lock, Lock> into) {
1:eac0369: 
1:f9a152b:         for (Lock lock : from.keySet()) {
1:eac0369: 
1:a045b63:             Lock lockI = into.get(lock);
1:eac0369: 
1:eac0369: 			if (lockI == null) {
1:eac0369: 				// lock is only in from list
1:eac0369: 				into.put(lock, lock);
1:eac0369: 			} else {
1:eac0369: 				// merge the locks
1:a15a470: 				Lock fromL = lock;
1:a045b63:                 Lock intoL = lockI;
1:eac0369: 
1:eac0369: 				intoL.count += fromL.getCount();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:b3eb01a: 	synchronized int unlockReference(LockTable lset, Lockable ref,
1:b3eb01a: 									 Object qualifier, Object group) {
1:eac0369: 
1:eac0369: 		// look for locks matching our reference and qualifier.
1:a045b63:         HashMap<Lock, Lock> dl = groups.get(group);
1:eac0369: 		if (dl == null)
4:eac0369: 			return 0;
1:eac0369: 
1:b3eb01a: 		Lock lockInGroup = lset.unlockReference(this, ref, qualifier, dl);
1:b3eb01a: 		if (lockInGroup == null) {
1:b3eb01a: 			return 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (lockInGroup.getCount() == 1) {
1:eac0369: 
1:eac0369: 			if (dl.isEmpty()) {
1:7a0cbb4: 				groups.remove(group);
1:eac0369: 				saveGroup(dl);
1:3c1f634: 				if ((callbackGroup != null) && group.equals(callbackGroup)) {
1:eac0369: 					nextLimitCall = limit;
1:3c1f634: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return 1;
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		// the lock item will be left in the group
1:eac0369: 		lockInGroup.count--;
1:eac0369: 		dl.put(lockInGroup, lockInGroup);
1:eac0369: 		return 1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return true if locks are held in a group
1:eac0369: 	*/
1:eac0369: 	synchronized boolean areLocksHeld(Object group) {
1:7a0cbb4: 		return groups.containsKey(group);
1:7a0cbb4: 	}
1:7a0cbb4: 
1:7a0cbb4: 	/**
1:7a0cbb4: 	 * Return true if locks are held in this compatibility space.
1:7a0cbb4: 	 * @return true if locks are held, false otherwise
1:7a0cbb4: 	 */
1:7a0cbb4: 	synchronized boolean areLocksHeld() {
1:7a0cbb4: 		return !groups.isEmpty();
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	synchronized boolean isLockHeld(Object group, Lockable ref, Object qualifier) {
1:eac0369: 
1:eac0369: 		// look for locks matching our reference and qualifier.
1:a045b63:         HashMap<Lock, Lock> dl = groups.get(group);
1:eac0369: 		if (dl == null)
1:eac0369: 			return false;
1:eac0369: 
1:a045b63:         return dl.containsKey(new Lock(this, ref, qualifier));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	synchronized void setLimit(Object group, int limit, Limit callback) {
1:eac0369: 		callbackGroup = group;
1:eac0369: 		this.nextLimitCall = this.limit = limit;
1:eac0369: 		this.callback = callback;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Clear a limit set by setLimit.
1:eac0369: 	*/
1:eac0369: 	synchronized void clearLimit(Object group) {
1:eac0369: 		if (group.equals(callbackGroup)) {
1:eac0369: 			callbackGroup = null;
1:eac0369: 			nextLimitCall = limit = Integer.MAX_VALUE;
1:eac0369: 			callback = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a count of the number of locks
1:eac0369: 		held by this space. The argument bail
1:eac0369: 		indicates at which point the counting
1:eac0369: 		should bail out and return the current
1:eac0369: 		count. This routine will bail if the
1:eac0369: 		count is greater than bail. Thus this
1:eac0369: 		routine is intended to for deadlock
1:eac0369: 		code to find the space with the
1:eac0369: 		fewest number of locks.
1:eac0369: 	*/
1:eac0369: 	synchronized int deadlockCount(int bail) {
1:eac0369: 
1:eac0369: 		int count = 0;
1:eac0369: 
1:a045b63:         for (HashMap<Lock, Lock> group: groups.values()) {
1:f9a152b:             for (Lock lock: group.keySet()) {
1:eac0369: 					count += lock.getCount();
1:eac0369: 					if (count > bail)
1:eac0369: 						return count;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return count;
1:eac0369: 
1:eac0369: 	}
1:eac0369: }
1:eac0369: 
1:eac0369: /**
1:eac0369: 	An Enumeration that returns the the Lockables
1:eac0369: 	in a group.
1:eac0369: */
1:eac0369: 
1:a15a470: class LockList implements Enumeration<Lockable> {
1:eac0369: 
1:a15a470: 	private Enumeration<Lock> lockGroup;
1:eac0369: 
1:a15a470: 	LockList(Enumeration<Lock> lockGroup) {
1:eac0369: 		this.lockGroup = lockGroup;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean hasMoreElements() {
1:eac0369: 		return lockGroup.hasMoreElements();
1:eac0369: 	}
1:eac0369: 
1:a15a470: 	public Lockable nextElement() {
1:a15a470: 		return (lockGroup.nextElement()).getLockable();
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a045b63
/////////////////////////////////////////////////////////////////////////
1:     private final HashMap<Object, HashMap<Lock, Lock>> groups;
/////////////////////////////////////////////////////////////////////////
1:     private final ArrayDeque<HashMap<Lock, Lock>> spareGroups =
1:             new ArrayDeque<HashMap<Lock, Lock>>(MAX_CACHED_GROUPS);
/////////////////////////////////////////////////////////////////////////
1:         groups = new HashMap<Object, HashMap<Lock, Lock>>();
/////////////////////////////////////////////////////////////////////////
1:         HashMap<Lock, Lock> dl = groups.get(group);
1:             lockInGroup = dl.get(lock);
/////////////////////////////////////////////////////////////////////////
1:         HashMap<Lock, Lock> dl = groups.remove(group);
/////////////////////////////////////////////////////////////////////////
1:     private HashMap<Lock, Lock> getGroupMap(Object group) {
1:         HashMap<Lock, Lock> dl = spareGroups.poll();
1:             dl = new HashMap<Lock, Lock>(5, 0.8f);
1:     private void saveGroup(HashMap<Lock, Lock> dl) {
/////////////////////////////////////////////////////////////////////////
1:         HashMap<Lock, Lock> dl = groups.get(group);
/////////////////////////////////////////////////////////////////////////
1:         HashMap<Lock, Lock> from = groups.get(oldGroup);
1:         HashMap<Lock, Lock> to = groups.get(newGroup);
/////////////////////////////////////////////////////////////////////////
1:     private void mergeGroups(HashMap<Lock, Lock> from, HashMap<Lock, Lock> into) {
1:             Lock lockI = into.get(lock);
/////////////////////////////////////////////////////////////////////////
1:                 Lock intoL = lockI;
/////////////////////////////////////////////////////////////////////////
1:         HashMap<Lock, Lock> dl = groups.get(group);
/////////////////////////////////////////////////////////////////////////
1:         HashMap<Lock, Lock> dl = groups.get(group);
1:         return dl.containsKey(new Lock(this, ref, qualifier));
/////////////////////////////////////////////////////////////////////////
1:         for (HashMap<Lock, Lock> group: groups.values()) {
commit:f9a152b
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayDeque;
/////////////////////////////////////////////////////////////////////////
1:     /** The maximum number of elements to cache in {@link #spareGroups}. */
1:     private static final int MAX_CACHED_GROUPS = 3;
1: 
1:     /** Cached HashMaps for storing lock groups. */
0:     private final ArrayDeque<HashMap<Lock, Object>> spareGroups =
0:             new ArrayDeque<HashMap<Lock, Object>>(MAX_CACHED_GROUPS);
/////////////////////////////////////////////////////////////////////////
1:         for (Lock lock : dl.keySet()) {
1:             lset.unlock(lock, 0);
/////////////////////////////////////////////////////////////////////////
0:         HashMap<Lock,Object> dl = spareGroups.poll();
/////////////////////////////////////////////////////////////////////////
1: 
0:     private void saveGroup(HashMap<Lock, Object> dl) {
1:         if (spareGroups.size() < MAX_CACHED_GROUPS) {
1:             spareGroups.offer(dl);
1:             dl.clear();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<Lock> e = dl.keySet().iterator(); e.hasNext(); ) {
1:             Lock lock = e.next();
/////////////////////////////////////////////////////////////////////////
1:         for (Lock lock : from.keySet()) {
/////////////////////////////////////////////////////////////////////////
0:         for (HashMap<Lock,Object> group: groups.values()) {
1:             for (Lock lock: group.keySet()) {
commit:85e3e12
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.locks.LockOwner;
/////////////////////////////////////////////////////////////////////////
1: 	private final LockOwner owner;
/////////////////////////////////////////////////////////////////////////
1: 	LockSpace(LockOwner owner) {
/////////////////////////////////////////////////////////////////////////
1: 	public LockOwner getOwner() {
commit:b3eb01a
/////////////////////////////////////////////////////////////////////////
1: 	synchronized void unlockGroup(LockTable lset, Object group) {
/////////////////////////////////////////////////////////////////////////
1: 	synchronized void unlockGroup(LockTable lset, Object group, Matchable key) {
/////////////////////////////////////////////////////////////////////////
1: 	synchronized int unlockReference(LockTable lset, Lockable ref,
1: 									 Object qualifier, Object group) {
1: 		Lock lockInGroup = lset.unlockReference(this, ref, qualifier, dl);
1: 		if (lockInGroup == null) {
1: 			return 0;
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
/////////////////////////////////////////////////////////////////////////
1: 	a single compatibility space, broken into groups of locks.
1:     A LockSpace contains a HashMap keyed by the group reference,
1:     <p> A <code>LockSpace</code> can have an owner (for instance a
1:     transaction). Currently, the owner is used by the virtual lock table to
1:     find out which transaction a lock belongs to. Some parts of the code also
1:     use the owner as a group object which guarantees that the lock is released
1:     on a commit or an abort. The owner has no special meaning to the lock
1:     manager and can be any object, including <code>null</code>. </p>
1: final class LockSpace implements CompatibilitySpace {
1: 	/** Reference to the owner of this compatibility space. */
0: 	private final Object owner;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Creates a new <code>LockSpace</code> instance.
1: 	 *
1: 	 * @param owner an object representing the owner of the compatibility space
1: 	 */
0: 	LockSpace(Object owner) {
1: 		this.owner = owner;
1: 	}
1: 
1: 	/**
1: 	 * Get the object representing the owner of the compatibility space.
1: 	 *
1: 	 * @return the owner of the compatibility space
1: 	 */
0: 	public Object getOwner() {
1: 		return owner;
/////////////////////////////////////////////////////////////////////////
1: 			callback.reached(this, group, limit,
/////////////////////////////////////////////////////////////////////////
1: 		if ((callbackGroup != null) && group.equals(callbackGroup)) {
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			if ((callbackGroup != null) && group.equals(callbackGroup)) {
1: 			}
/////////////////////////////////////////////////////////////////////////
0: 			Lock setLock = control.getLock(this, qualifier);
/////////////////////////////////////////////////////////////////////////
1: 				if ((callbackGroup != null) && group.equals(callbackGroup)) {
1: 				}
/////////////////////////////////////////////////////////////////////////
0: 		Object heldLock = dl.get(new Lock(this, ref, qualifier));
/////////////////////////////////////////////////////////////////////////
commit:7a0cbb4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     A LockSpace contains a hashtable keyed by the group reference,
1:     the data for each key is a HashMap of Lock's.
0: final class LockSpace {
1: 	/** Map from group references to groups of locks. */
0: 	private final HashMap groups;
/////////////////////////////////////////////////////////////////////////
0: 		groups = new HashMap();
/////////////////////////////////////////////////////////////////////////
0: 		HashMap dl = (HashMap) groups.get(group);
/////////////////////////////////////////////////////////////////////////
0: 		HashMap dl = (HashMap) groups.remove(group);
/////////////////////////////////////////////////////////////////////////
0: 		if ((callbackGroup == null) && groups.isEmpty())
/////////////////////////////////////////////////////////////////////////
1: 		groups.put(group, dl);
/////////////////////////////////////////////////////////////////////////
0: 		HashMap dl = (HashMap) groups.get(group);
/////////////////////////////////////////////////////////////////////////
1: 			groups.remove(group);
0: 			if ((callbackGroup == null) && groups.isEmpty())
/////////////////////////////////////////////////////////////////////////
0: 		HashMap from = (HashMap) groups.get(oldGroup);
0: 		HashMap to = (HashMap) groups.get(newGroup);
1: 			groups.put(newGroup, from);
1: 			groups.remove(oldGroup);
/////////////////////////////////////////////////////////////////////////
1: 			Object oldTo = groups.put(newGroup, from);
/////////////////////////////////////////////////////////////////////////
1: 		groups.remove(oldGroup);
/////////////////////////////////////////////////////////////////////////
0: 		HashMap dl = (HashMap) groups.get(group);
/////////////////////////////////////////////////////////////////////////
1: 				groups.remove(group);
0: 				if ((callbackGroup == null) && groups.isEmpty())
/////////////////////////////////////////////////////////////////////////
1: 		return groups.containsKey(group);
1: 	}
1: 
1: 	/**
1: 	 * Return true if locks are held in this compatibility space.
1: 	 * @return true if locks are held, false otherwise
1: 	 */
1: 	synchronized boolean areLocksHeld() {
1: 		return !groups.isEmpty();
0: 		HashMap dl = (HashMap) groups.get(group);
/////////////////////////////////////////////////////////////////////////
0: 			if (groups.isEmpty())
/////////////////////////////////////////////////////////////////////////
0: 		for (Iterator it = groups.values().iterator(); it.hasNext(); ) {
0: 			HashMap group = (HashMap) it.next();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a15a470
/////////////////////////////////////////////////////////////////////////
0: 	private final HashMap<Object,HashMap<Lock,Object>> groups;
/////////////////////////////////////////////////////////////////////////
0: 		groups = new HashMap<Object,HashMap<Lock,Object>>();
/////////////////////////////////////////////////////////////////////////
0: 		HashMap<Lock,Object> dl = groups.get(group);
/////////////////////////////////////////////////////////////////////////
0: 		HashMap<Lock,Object> dl = groups.remove(group);
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("unchecked")
0: 	private HashMap<Lock,Object> getGroupMap(Object group) {
0: 		HashMap<Lock,Object> dl = null;
0: 			dl = (HashMap<Lock,Object>) sg[i];
/////////////////////////////////////////////////////////////////////////
0: 			dl = new HashMap<Lock,Object>(5, 0.8f);
/////////////////////////////////////////////////////////////////////////
0: 		HashMap<Lock,Object> dl = groups.get(group);
/////////////////////////////////////////////////////////////////////////
0: 		HashMap<Lock,Object> from = groups.get(oldGroup);
0: 		HashMap<Lock,Object> to = groups.get(newGroup);
/////////////////////////////////////////////////////////////////////////
0: 	private void mergeGroups(HashMap<Lock,Object> from, HashMap<Lock,Object> into) {
0: 		for (Iterator<Lock> e = from.keySet().iterator(); e.hasNext(); ) {
0: 			Lock lock = e.next();
/////////////////////////////////////////////////////////////////////////
1: 				Lock fromL = lock;
/////////////////////////////////////////////////////////////////////////
0: 		HashMap<Lock,Object> dl = groups.get(group);
/////////////////////////////////////////////////////////////////////////
0: 		HashMap<Lock,Object> dl = groups.get(group);
/////////////////////////////////////////////////////////////////////////
0: 		for (Iterator<HashMap<Lock,Object>> it = groups.values().iterator(); it.hasNext(); ) {
0: 			HashMap<Lock,Object> group = it.next();
0: 			for (Iterator<Lock> locks = group.keySet().iterator(); locks.hasNext(); ) {
0: 					Lock lock = locks.next();
/////////////////////////////////////////////////////////////////////////
1: class LockList implements Enumeration<Lockable> {
1: 	private Enumeration<Lock> lockGroup;
1: 	LockList(Enumeration<Lock> lockGroup) {
/////////////////////////////////////////////////////////////////////////
1: 	public Lockable nextElement() {
1: 		return (lockGroup.nextElement()).getLockable();
commit:93fea34
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.services.locks.LockSpace
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.locks
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.services.locks;
1: 
1: import org.apache.derby.iapi.services.locks.Lockable;
1: import org.apache.derby.iapi.services.locks.Limit;
1: 
1: import org.apache.derby.iapi.util.Matchable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import java.util.Hashtable;
1: import java.util.Enumeration;
0: import java.util.Dictionary;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: 
1: /**
1: 
1: 	A LockSpace represents the complete set of locks held within
0: 	a single compatability space, broken into groups of locks.
1: 
0:     A LockSpace is a hashtable keyed by the group reference,
0: 	the data for each key is a Hashtable of Lock's.
1: 
1: */
0: class LockSpace extends Hashtable {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
0: 	private final Object compatSpace;
0: 	// the object I live in
0: 	private final Dictionary holder;
1: 
0: 	private HashMap spareGroups[] = new HashMap[3];
1: 
1: 	// the Limit info.
1: 	private Object callbackGroup;
1: 	private int    limit;
1: 	private int    nextLimitCall;
1: 	private Limit  callback;
1: 
0: 	LockSpace(Dictionary holder, Object compatSpace) {
0: 		super();
0: 		this.compatSpace = compatSpace;
0: 		this.holder = holder;
1: 	}
1: 
1: 	/**
1: 		Add a lock to a group.
1: 	*/
1: 	protected synchronized void addLock(Object group, Lock lock)
1: 		throws StandardException {
1: 
1: 		Lock lockInGroup = null;
1: 
0: 		HashMap dl = (HashMap) get(group);
1: 		if (dl == null)	{
1: 			dl = getGroupMap(group);
1: 		} else if (lock.getCount() != 1) {
0: 			lockInGroup = (Lock) dl.get(lock);
1: 		}
1: 
1: 		if (lockInGroup == null) {
1: 			lockInGroup = lock.copy();
1: 			dl.put(lockInGroup, lockInGroup);
1: 		}
1: 		lockInGroup.count++;
1: 
1: 		if (inLimit)
1: 			return;
1: 
1: 		if (!group.equals(callbackGroup))
1: 			return;
1: 
1: 		int groupSize = dl.size();
1: 		
1: 		if (groupSize > nextLimitCall) {
1: 
1: 			inLimit = true;
0: 			callback.reached(compatSpace, group, limit,
1: 				new LockList(java.util.Collections.enumeration(dl.keySet())), groupSize);
1: 			inLimit = false;
1: 
1: 			// see when the next callback should occur, if the callback
1: 			// failed to release a sufficent amount of locks then
1: 			// delay until another "limit" locks are obtained.
1: 			int newGroupSize = dl.size();
1: 			if (newGroupSize < (limit / 2))
1: 				nextLimitCall = limit;
1: 			else if (newGroupSize < (nextLimitCall / 2))
1: 				nextLimitCall -= limit;
1: 			else
1: 				nextLimitCall += limit;
1: 
1: 		}
1: 	}
1: 	
1: 	private boolean inLimit;
1: 	/**
1: 		Unlock all the locks in a group and then remove the group.
1: 	*/
1: 
0: 	synchronized void unlockGroup(LockSet lset, Object group) {
0: 		HashMap dl = (HashMap) remove(group);
1: 		if (dl == null)
1: 			return;
1: 
0: 		for (Iterator list = dl.keySet().iterator(); list.hasNext(); ) {
0: 			lset.unlock((Lock) list.next(), 0);
1: 		}
1: 
0: 		if ((callbackGroup == null) && isEmpty())
0: 			holder.remove(compatSpace);
0: 		else if (group.equals(callbackGroup))
1: 			nextLimitCall = limit;
1: 
1: 		saveGroup(dl);
1: 	}
1: 
0: 	private HashMap getGroupMap(Object group) {
0: 		HashMap[] sg = spareGroups;
0: 		HashMap dl = null;
0: 		for (int i = 0; i < 3; i++) {
0: 			dl = sg[i];
0: 			if (dl != null) {
0: 				sg[i] = null;
0: 				break;
1: 			}
1: 		}
1: 
1: 		if (dl == null)
0: 			dl = new HashMap(5, 0.8f);
1: 
0: 		put(group, dl);
1: 		return dl;
1: 	}
0: 	private void saveGroup(HashMap dl) {
0: 		HashMap[] sg = spareGroups;
0: 		for (int i = 0; i < 3; i++) {
0: 			if (sg[i] == null) {
0: 				sg[i] = dl;
0: 				dl.clear();
0: 				break;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 		Unlock all locks in the group that match the key
1: 	*/
0: 	synchronized void unlockGroup(LockSet lset, Object group, Matchable key) {
0: 		HashMap dl = (HashMap) get(group);
1: 		if (dl == null)
1: 			return; //  no group at all
1: 
1: 		boolean allUnlocked = true;
0: 		for (Iterator e = dl.keySet().iterator(); e.hasNext(); ) {
1: 
0: 			Lock lock = (Lock) e.next();
1: 			if (!key.match(lock.getLockable())) {
1: 				allUnlocked = false;
1: 				continue;
1: 			}
1: 			lset.unlock(lock, 0);
1: 			e.remove();
1: 		}
1: 
1: 		if (allUnlocked) {
0: 			remove(group);
1: 			saveGroup(dl);
0: 			if ((callbackGroup == null) && isEmpty())
0: 				holder.remove(compatSpace);
0: 			else if (group.equals(callbackGroup))
1: 				nextLimitCall = limit;
1: 
1: 		}
1: 	}
1: 
1: 	synchronized void transfer(Object oldGroup, Object newGroup) {
0: 		HashMap from = (HashMap) get(oldGroup);
1: 		if (from == null)
1: 			return;
1: 
0: 		HashMap to = (HashMap) get(newGroup);
1: 		if (to == null) {
1: 			// simple case 
0: 			put(newGroup, from);
1: 			clearLimit(oldGroup);
0: 			remove(oldGroup);
1: 			return;
1: 		}
1: 
1: 		if (to.size() < from.size()) {
1: 
1: 			// place the contents of to into from
1: 			mergeGroups(to, from);
1: 
0: 			Object oldTo = put(newGroup, from);
1: 			if (SanityManager.DEBUG) {
1: 				SanityManager.ASSERT(oldTo == to, "inconsistent state in LockSpace");
1: 			}
1: 
1: 		} else {
1: 			mergeGroups(from, to);
1: 		}
1: 		
1: 		clearLimit(oldGroup);
0: 		remove(oldGroup);
1: 	}
1: 
0: 	private void mergeGroups(HashMap from, HashMap into) {
1: 
0: 		for (Iterator e = from.keySet().iterator(); e.hasNext(); ) {
1: 
0: 			Object lock = e.next();
1: 
0: 			Object lockI = into.get(lock);
1: 
1: 			if (lockI == null) {
1: 				// lock is only in from list
1: 				into.put(lock, lock);
1: 			} else {
1: 				// merge the locks
0: 				Lock fromL = (Lock) lock;
0: 				Lock intoL = (Lock) lockI;
1: 
1: 				intoL.count += fromL.getCount();
1: 			}
1: 		}
1: 
1: 	}
1: 
0: 	synchronized int unlockReference(LockSet lset, Lockable ref, Object qualifier, Object group) {
1: 
1: 		// look for locks matching our reference and qualifier.
0: 		HashMap dl = (HashMap) get(group);
1: 		if (dl == null)
1: 			return 0;
1: 
0: 		Lock lockInGroup;
0: 		synchronized (lset) {
0: 			Control control = lset.getControl(ref);
0: 			if (control == null)
1: 				return 0;
1: 
0: 			Lock setLock = control.getLock(compatSpace, qualifier);
0: 			if (setLock == null)
1: 				return 0;
1: 
0: 			lockInGroup = (Lock) dl.remove(setLock);
0: 			if (lockInGroup == null)
1: 				return 0;
0: 			setLock = null;
1: 
0: 			lset.unlock(lockInGroup, 1);
1: 		}
1: 
1: 		if (lockInGroup.getCount() == 1) {
1: 
1: 			if (dl.isEmpty()) {
0: 				remove(group);
1: 				saveGroup(dl);
0: 				if ((callbackGroup == null) && isEmpty())
0: 					holder.remove(compatSpace);
0: 				else if (group.equals(callbackGroup))
1: 					nextLimitCall = limit;
1: 
1: 			}
1: 
1: 			return 1;
1: 		}
1: 			
1: 		// the lock item will be left in the group
1: 		lockInGroup.count--;
1: 		dl.put(lockInGroup, lockInGroup);
1: 		return 1;
1: 	}
1: 
1: 	/**
1: 		Return true if locks are held in a group
1: 	*/
1: 	synchronized boolean areLocksHeld(Object group) {
0: 		return  (get(group) != null);
1: 	}
1: 	
1: 	synchronized boolean isLockHeld(Object group, Lockable ref, Object qualifier) {
1: 
1: 		// look for locks matching our reference and qualifier.
0: 		HashMap dl = (HashMap) get(group);
1: 		if (dl == null)
1: 			return false;
1: 
0: 		Object heldLock = dl.get(new Lock(compatSpace, ref, qualifier));
0: 		return (heldLock != null);
1: 	}
1: 
1: 	synchronized void setLimit(Object group, int limit, Limit callback) {
1: 		callbackGroup = group;
1: 		this.nextLimitCall = this.limit = limit;
1: 		this.callback = callback;
1: 	}
1: 
1: 	/**
1: 		Clear a limit set by setLimit.
1: 	*/
1: 	synchronized void clearLimit(Object group) {
1: 
1: 		if (group.equals(callbackGroup)) {
1: 			callbackGroup = null;
1: 			nextLimitCall = limit = Integer.MAX_VALUE;
1: 			callback = null;
1: 
0: 			if (isEmpty())
0: 				holder.remove(compatSpace);
1: 		}
1: 	}
1: 
1: 	/**
1: 		Return a count of the number of locks
1: 		held by this space. The argument bail
1: 		indicates at which point the counting
1: 		should bail out and return the current
1: 		count. This routine will bail if the
1: 		count is greater than bail. Thus this
1: 		routine is intended to for deadlock
1: 		code to find the space with the
1: 		fewest number of locks.
1: 	*/
1: 	synchronized int deadlockCount(int bail) {
1: 
1: 		int count = 0;
1: 
0: 		for (Enumeration groups = elements(); groups.hasMoreElements(); ) {
0: 			HashMap group = (HashMap) groups.nextElement();
0: 			for (Iterator locks = group.keySet().iterator(); locks.hasNext(); ) {
0: 					Lock lock = (Lock) locks.next();
1: 					count += lock.getCount();
1: 					if (count > bail)
1: 						return count;
1: 			}
1: 		}
1: 		return count;
1: 
1: 	}
1: }
1: 
1: /**
1: 	An Enumeration that returns the the Lockables
1: 	in a group.
1: */
1: 
0: class LockList implements Enumeration {
1: 
0: 	private Enumeration lockGroup;
1: 
0: 	LockList(Enumeration lockGroup) {
1: 		this.lockGroup = lockGroup;
1: 	}
1: 
1: 	public boolean hasMoreElements() {
1: 		return lockGroup.hasMoreElements();
1: 	}
1: 
0: 	public Object nextElement() {
0: 		return ((Lock) lockGroup.nextElement()).getLockable();
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.locks
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.services.locks;
0: 
0: import org.apache.derby.iapi.services.locks.Lockable;
0: import org.apache.derby.iapi.services.locks.Limit;
0: 
0: import org.apache.derby.iapi.util.Matchable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: import java.util.Dictionary;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: 
0: /**
0: 
0: 	A LockSpace represents the complete set of locks held within
0: 	a single compatability space, broken into groups of locks.
0: 
0:     A LockSpace is a hashtable keyed by the group reference,
0: 	the data for each key is a Hashtable of Lock's.
0: 
0: */
0: class LockSpace extends Hashtable {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private final Object compatSpace;
0: 	// the object I live in
0: 	private final Dictionary holder;
0: 
0: 	private HashMap spareGroups[] = new HashMap[3];
0: 
0: 	// the Limit info.
0: 	private Object callbackGroup;
0: 	private int    limit;
0: 	private int    nextLimitCall;
0: 	private Limit  callback;
0: 
0: 	LockSpace(Dictionary holder, Object compatSpace) {
0: 		super();
0: 		this.compatSpace = compatSpace;
0: 		this.holder = holder;
0: 	}
0: 
0: 	/**
0: 		Add a lock to a group.
0: 	*/
0: 	protected synchronized void addLock(Object group, Lock lock)
0: 		throws StandardException {
0: 
0: 		Lock lockInGroup = null;
0: 
0: 		HashMap dl = (HashMap) get(group);
0: 		if (dl == null)	{
0: 			dl = getGroupMap(group);
0: 		} else if (lock.getCount() != 1) {
0: 			lockInGroup = (Lock) dl.get(lock);
0: 		}
0: 
0: 		if (lockInGroup == null) {
0: 			lockInGroup = lock.copy();
0: 			dl.put(lockInGroup, lockInGroup);
0: 		}
0: 		lockInGroup.count++;
0: 
0: 		if (inLimit)
0: 			return;
0: 
0: 		if (!group.equals(callbackGroup))
0: 			return;
0: 
0: 		int groupSize = dl.size();
0: 		
0: 		if (groupSize > nextLimitCall) {
0: 
0: 			inLimit = true;
0: 			callback.reached(compatSpace, group, limit,
0: 				new LockList(java.util.Collections.enumeration(dl.keySet())), groupSize);
0: 			inLimit = false;
0: 
0: 			// see when the next callback should occur, if the callback
0: 			// failed to release a sufficent amount of locks then
0: 			// delay until another "limit" locks are obtained.
0: 			int newGroupSize = dl.size();
0: 			if (newGroupSize < (limit / 2))
0: 				nextLimitCall = limit;
0: 			else if (newGroupSize < (nextLimitCall / 2))
0: 				nextLimitCall -= limit;
0: 			else
0: 				nextLimitCall += limit;
0: 
0: 		}
0: 	}
0: 	
0: 	private boolean inLimit;
0: 	/**
0: 		Unlock all the locks in a group and then remove the group.
0: 	*/
0: 
0: 	synchronized void unlockGroup(LockSet lset, Object group) {
0: 		HashMap dl = (HashMap) remove(group);
0: 		if (dl == null)
0: 			return;
0: 
0: 		for (Iterator list = dl.keySet().iterator(); list.hasNext(); ) {
0: 			lset.unlock((Lock) list.next(), 0);
0: 		}
0: 
0: 		if ((callbackGroup == null) && isEmpty())
0: 			holder.remove(compatSpace);
0: 		else if (group.equals(callbackGroup))
0: 			nextLimitCall = limit;
0: 
0: 		saveGroup(dl);
0: 	}
0: 
0: 	private HashMap getGroupMap(Object group) {
0: 		HashMap[] sg = spareGroups;
0: 		HashMap dl = null;
0: 		for (int i = 0; i < 3; i++) {
0: 			dl = sg[i];
0: 			if (dl != null) {
0: 				sg[i] = null;
0: 				break;
0: 			}
0: 		}
0: 
0: 		if (dl == null)
0: 			dl = new HashMap(5, 0.8f);
0: 
0: 		put(group, dl);
0: 		return dl;
0: 	}
0: 	private void saveGroup(HashMap dl) {
0: 		HashMap[] sg = spareGroups;
0: 		for (int i = 0; i < 3; i++) {
0: 			if (sg[i] == null) {
0: 				sg[i] = dl;
0: 				dl.clear();
0: 				break;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Unlock all locks in the group that match the key
0: 	*/
0: 	synchronized void unlockGroup(LockSet lset, Object group, Matchable key) {
0: 		HashMap dl = (HashMap) get(group);
0: 		if (dl == null)
0: 			return; //  no group at all
0: 
0: 		boolean allUnlocked = true;
0: 		for (Iterator e = dl.keySet().iterator(); e.hasNext(); ) {
0: 
0: 			Lock lock = (Lock) e.next();
0: 			if (!key.match(lock.getLockable())) {
0: 				allUnlocked = false;
0: 				continue;
0: 			}
0: 			lset.unlock(lock, 0);
0: 			e.remove();
0: 		}
0: 
0: 		if (allUnlocked) {
0: 			remove(group);
0: 			saveGroup(dl);
0: 			if ((callbackGroup == null) && isEmpty())
0: 				holder.remove(compatSpace);
0: 			else if (group.equals(callbackGroup))
0: 				nextLimitCall = limit;
0: 
0: 		}
0: 	}
0: 
0: 	synchronized void transfer(Object oldGroup, Object newGroup) {
0: 		HashMap from = (HashMap) get(oldGroup);
0: 		if (from == null)
0: 			return;
0: 
0: 		HashMap to = (HashMap) get(newGroup);
0: 		if (to == null) {
0: 			// simple case 
0: 			put(newGroup, from);
0: 			clearLimit(oldGroup);
0: 			remove(oldGroup);
0: 			return;
0: 		}
0: 
0: 		if (to.size() < from.size()) {
0: 
0: 			// place the contents of to into from
0: 			mergeGroups(to, from);
0: 
0: 			Object oldTo = put(newGroup, from);
0: 			if (SanityManager.DEBUG) {
0: 				SanityManager.ASSERT(oldTo == to, "inconsistent state in LockSpace");
0: 			}
0: 
0: 		} else {
0: 			mergeGroups(from, to);
0: 		}
0: 		
0: 		clearLimit(oldGroup);
0: 		remove(oldGroup);
0: 	}
0: 
0: 	private void mergeGroups(HashMap from, HashMap into) {
0: 
0: 		for (Iterator e = from.keySet().iterator(); e.hasNext(); ) {
0: 
0: 			Object lock = e.next();
0: 
0: 			Object lockI = into.get(lock);
0: 
0: 			if (lockI == null) {
0: 				// lock is only in from list
0: 				into.put(lock, lock);
0: 			} else {
0: 				// merge the locks
0: 				Lock fromL = (Lock) lock;
0: 				Lock intoL = (Lock) lockI;
0: 
0: 				intoL.count += fromL.getCount();
0: 			}
0: 		}
0: 
0: 	}
0: 
0: 	synchronized int unlockReference(LockSet lset, Lockable ref, Object qualifier, Object group) {
0: 
0: 		// look for locks matching our reference and qualifier.
0: 		HashMap dl = (HashMap) get(group);
0: 		if (dl == null)
0: 			return 0;
0: 
0: 		Lock lockInGroup;
0: 		synchronized (lset) {
0: 			Control control = lset.getControl(ref);
0: 			if (control == null)
0: 				return 0;
0: 
0: 			Lock setLock = control.getLock(compatSpace, qualifier);
0: 			if (setLock == null)
0: 				return 0;
0: 
0: 			lockInGroup = (Lock) dl.remove(setLock);
0: 			if (lockInGroup == null)
0: 				return 0;
0: 			setLock = null;
0: 
0: 			lset.unlock(lockInGroup, 1);
0: 		}
0: 
0: 		if (lockInGroup.getCount() == 1) {
0: 
0: 			if (dl.isEmpty()) {
0: 				remove(group);
0: 				saveGroup(dl);
0: 				if ((callbackGroup == null) && isEmpty())
0: 					holder.remove(compatSpace);
0: 				else if (group.equals(callbackGroup))
0: 					nextLimitCall = limit;
0: 
0: 			}
0: 
0: 			return 1;
0: 		}
0: 			
0: 		// the lock item will be left in the group
0: 		lockInGroup.count--;
0: 		dl.put(lockInGroup, lockInGroup);
0: 		return 1;
0: 	}
0: 
0: 	/**
0: 		Return true if locks are held in a group
0: 	*/
0: 	synchronized boolean areLocksHeld(Object group) {
0: 		return  (get(group) != null);
0: 	}
0: 	
0: 	synchronized boolean isLockHeld(Object group, Lockable ref, Object qualifier) {
0: 
0: 		// look for locks matching our reference and qualifier.
0: 		HashMap dl = (HashMap) get(group);
0: 		if (dl == null)
0: 			return false;
0: 
0: 		Object heldLock = dl.get(new Lock(compatSpace, ref, qualifier));
0: 		return (heldLock != null);
0: 	}
0: 
0: 	synchronized void setLimit(Object group, int limit, Limit callback) {
0: 		callbackGroup = group;
0: 		this.nextLimitCall = this.limit = limit;
0: 		this.callback = callback;
0: 	}
0: 
0: 	/**
0: 		Clear a limit set by setLimit.
0: 	*/
0: 	synchronized void clearLimit(Object group) {
0: 
0: 		if (group.equals(callbackGroup)) {
0: 			callbackGroup = null;
0: 			nextLimitCall = limit = Integer.MAX_VALUE;
0: 			callback = null;
0: 
0: 			if (isEmpty())
0: 				holder.remove(compatSpace);
0: 		}
0: 	}
0: 
0: 	/**
0: 		Return a count of the number of locks
0: 		held by this space. The argument bail
0: 		indicates at which point the counting
0: 		should bail out and return the current
0: 		count. This routine will bail if the
0: 		count is greater than bail. Thus this
0: 		routine is intended to for deadlock
0: 		code to find the space with the
0: 		fewest number of locks.
0: 	*/
0: 	synchronized int deadlockCount(int bail) {
0: 
0: 		int count = 0;
0: 
0: 		for (Enumeration groups = elements(); groups.hasMoreElements(); ) {
0: 			HashMap group = (HashMap) groups.nextElement();
0: 			for (Iterator locks = group.keySet().iterator(); locks.hasNext(); ) {
0: 					Lock lock = (Lock) locks.next();
0: 					count += lock.getCount();
0: 					if (count > bail)
0: 						return count;
0: 			}
0: 		}
0: 		return count;
0: 
0: 	}
0: }
0: 
0: /**
0: 	An Enumeration that returns the the Lockables
0: 	in a group.
0: */
0: 
0: class LockList implements Enumeration {
0: 
0: 	private Enumeration lockGroup;
0: 
0: 	LockList(Enumeration lockGroup) {
0: 		this.lockGroup = lockGroup;
0: 	}
0: 
0: 	public boolean hasMoreElements() {
0: 		return lockGroup.hasMoreElements();
0: 	}
0: 
0: 	public Object nextElement() {
0: 		return ((Lock) lockGroup.nextElement()).getLockable();
0: 	}
0: }
============================================================================