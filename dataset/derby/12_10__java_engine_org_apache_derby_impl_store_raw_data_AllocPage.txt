1:eac0369: /*
5:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.AllocPage
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.TypedFormat;
1:eac0369: import org.apache.derby.iapi.services.io.FormatIdUtil;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.Loggable;
1:eac0369: import org.apache.derby.iapi.store.raw.PageKey;
1:eac0369: import org.apache.derby.iapi.store.raw.PageTimeStamp;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.raw.data.BaseContainerHandle;
1:eac0369: import org.apache.derby.impl.store.raw.data.BasePage;
1:eac0369: import org.apache.derby.impl.store.raw.data.PageVersion;
1:eac0369: 
1:eac0369: import java.io.IOException;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:eac0369: 
3:eac0369: /**
1:eac0369: 	An allocation page of the file container.
1:eac0369: 	<P>
1:eac0369: 	This class extends a normal Stored page, with the exception that a hunk of
1:eac0369: 	space may be 'borrowed' by the file container to store the file header.
1:eac0369: 	<P>
1:eac0369: 	The borrowed space is not visible to the alloc page even though it is
1:eac0369: 	present in the page data array.  It is accessed directly by the
1:eac0369: 	FileContainer.  Any change made to the borrowed space is not managed or
1:eac0369: 	seen by the allocation page.
1:7ecfe40: 	<P>
1:eac0369: 	The reason for having this borrowed space is so that the container header
1:eac0369: 	does not need to have a page of its own.
1:eac0369: 
1:eac0369: 	<P><B>Page Format</B><BR>
1:eac0369: 	An allocation page extends a stored page, the on disk format is different
1:eac0369: 	from a stored page in that N bytes are 'borrowed' by the container and the
1:eac0369: 	page header of an allocation page will be slightly bigger than a normal
1:eac0369: 	stored page.  This N bytes are stored between the page header and the 
1:eac0369:     record space.
1:eac0369: 	<P>
1:eac0369: 	The reason why this N bytes can't simply be a row is because it needs to be
1:eac0369: 	statically accessible by the container object to avoid a chicken and egg
1:eac0369: 	problem of the container object needing to instantiate an alloc page object
1:eac0369: 	before it can be objectified, and an alloc page object needing to
1:eac0369: 	instantiate a container object before it can be objectified.  So this N
1:eac0369: 	bytes must be stored outside of the normal record interface yet it must be
1:eac0369: 	settable because only the first alloc page has this borrowed space.  Other
1:eac0369: 	(non-first) alloc page have N == 0.
1:eac0369: 
1:eac0369: 	<PRE>
1:dbed020:                              [ borrowed ]
1:eac0369: 	+----------+-------------+---+---------+-------------------+-------------+--------+
1:eac0369: 	| FormatId | page header | N | N bytes | alloc extend rows | slot offset |checksum|
1:eac0369: 	+----------+-------------+---+---------+-------------------+-------------+--------+
1:eac0369: 	</PRE>
1:eac0369: 
1:eac0369: 	N is a byte that indicates the size of the borrowed space.  Once an alloc
1:eac0369: 	page is initialized, the value of N cannot change.
1:eac0369: 	<P>
1:eac0369: 	The maximum space that can be borrowed by the container is 256 bytes.
1:eac0369: 	<P>
1:eac0369: 	The allocation page are of the same page size as any other pages in the
1:eac0369: 	container. The first allocation page of the FileContainer starts at the
1:eac0369: 	first physical byte of the container.  Subsequent allocation pages are
1:eac0369: 	chained via the nextAllocPageOffset.  Each allocation page is expected to
1:eac0369: 	manage at least 1000 user pages (for 1K page size) so this chaining may not
1:dbed020: 	be a severe performance hit.  The logical -&gt; physical mapping of an
1:eac0369: 	allocation page is stored in the previous allocation page.  The container
1:eac0369: 	object will need to maintain this mapping.
1:eac0369: 	<P>
1:eac0369: 	The following fields are stored in the page header
1:eac0369: 	<PRE>
1:787ceb4: 	@derby.formatId	RAW_STORE_ALLOC_PAGE
1:787ceb4: 	@derby.purpose	manage page allocation
1:787ceb4: 	@derby.upgrade
1:787ceb4: 	@derby.diskLayout
1:eac0369: 		FormatId(int)
1:eac0369: 		StoredPageHeader	see StoredPage
1:eac0369: 		nextAllocPageNubmer(long)	the next allocation page's number
1:eac0369: 		nextAllocPageOffset(long)	the file offset of the next allocation page
1:eac0369: 		reserved1(long)				reserved for future usage
1:eac0369: 		reserved2(long)				reserved for future usage
1:eac0369: 		reserved3(long)				reserved for future usage
1:eac0369: 		reserved4(long)				reserved for future usage
1:eac0369: 		N(byte)						the size of the borrowed container info
1:eac0369: 		containerInfo(byte[N])		the content of the borrowed container info
1:eac0369: 		AllocExtent					the one and only extent on this alloc page
1:eac0369: 
1:787ceb4: 	@derby.endFormat
1:eac0369: 	</PRE>
1:eac0369: 
1:eac0369: 	<P>
1:eac0369: 	The allocation page contains allocation extent rows.  In this first cut
1:eac0369: 	implementation, there is only 1 allocation extent row per allocation page.
1:eac0369: 	<P>
1:eac0369: 	The allocation extent row is an externalizable object and is directly
1:eac0369: 	written on to the page by the alloc page.  In other words, it will not be
1:eac0369: 	converted in to a storeableRow.  This is to cut down overhead, enhance
1:eac0369: 	performance and gives more control of the size and layout of the allocation
1:eac0369: 	extent row to the alloc page.
1:eac0369: 	<P>
1:eac0369: 	<HR WIDTH="100%">
1:eac0369: 	<BR> DETAIL implmentation notes <BR>
1:eac0369: 	<HR WIDTH="100%">
1:eac0369: 	<P>
1:eac0369: 	Create Container - an embryonic allocation page is formatted on disk by a
1:eac0369: 	spcial static function to avoid instantiating a full AllocPage object.
1:eac0369: 	This embryonic allocation has enough information that it can find the
1:eac0369: 	file header and not much else.  Then the allocation page is perperly
1:eac0369: 	initiated by creating the first extent.
1:eac0369: 	<P>
1:eac0369: 	Open Container - A static AllocPage method will be used to read off the
1:eac0369: 	container information directly from disk.  Even if
1:eac0369: 	the first alloc page (page 0) is already in the page cache, it will not be
1:eac0369: 	used because cleaning the alloc page will introduce a deadlock if the
1:eac0369: 	container is not in the container cache.  Long term, the first alloc page
1:eac0369: 	should probably live in the container cache rather than in the page cache.
1:eac0369: 	<P>
1:eac0369: 	Get Page - The first alloc page (page 0) will be read into the page cache.
1:eac0369: 	Continue to follow the alloc page chain until the alloc page that manages
1:eac0369: 	the specified page is found.  From the alloc page, the physical offset of
1:eac0369: 	the specified page is located.
1:eac0369: 	<P>
1:eac0369: 	Cleaning alloc page - the alloc page is written out the same way any page
1:eac0369: 	is written out.  The container object will provide a call back to the alloc
1:eac0369: 	page to write the current version of the container object back into the
1:eac0369: 	borrowed space before the alloc page itself is written out.
1:eac0369: 	<P>
1:eac0369: 	Cleaning the container object - get the the first alloc page, dirty it and
1:eac0369: 	clean it (which will cause it to call the container object to write itself
1:eac0369: 	out into the borrowed space).  The versioning of the container is
1:eac0369: 	independent of the versioning of the alloc page.  The container version is
1:eac0369: 	stored inside the borrowed space and is opaque to the alloc page.
1:eac0369: 	<P>
1:eac0369: 	For the fields in an allocation extent row
1:eac0369: 
1:eac0369: 	@see AllocExtent
1:eac0369: */
1:eac0369: 
1:eac0369: 
1:eac0369: public class AllocPage extends StoredPage
1:eac0369: {
1:eac0369: 	/*
1:eac0369: 	 * typed format
1:eac0369: 	 */
1:eac0369: 	public static final int FORMAT_NUMBER = StoredFormatIds.RAW_STORE_ALLOC_PAGE;
1:eac0369: 	// format Id must fit in 4 bytes
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.RAW_STORE_ALLOC_PAGE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*****************************************************************
1:eac0369: 	 * alloc page header
1:eac0369: 	 *****************************************************************/
1:eac0369: 	private long nextAllocPageNumber;	// if isLast, nextAllocPageNumber == INVALID_PAGE_NUMBER
1:eac0369: 	private long nextAllocPageOffset;
1:eac0369: 	private long reserved1;
1:eac0369: 	private long reserved2;
1:eac0369: 	private long reserved3;
1:eac0369: 	private long reserved4;
1:eac0369: 
1:eac0369: 	private AllocExtent extent;
1:eac0369: 
1:eac0369: 	private int borrowedSpace;
1:eac0369: 
1:eac0369: 	/*****************************************************************
1:eac0369: 	 * constants
1:eac0369: 	 *****************************************************************/
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * allocation page header
1:eac0369: 	 * 8 bytes	long	next alloc page number
1:eac0369: 	 * 8 bytes	long	next alloc page physical offset
1:eac0369: 	 * 8 bytes  long	reserved1
1:eac0369: 	 * 8 bytes  long	reserved2
1:eac0369: 	 * 8 bytes  long	reserved3
1:eac0369: 	 * 8 bytes  long	reserved4
1:eac0369: 	 */
1:eac0369: 	protected static final int ALLOC_PAGE_HEADER_OFFSET =
1:eac0369: 		StoredPage.PAGE_HEADER_OFFSET + StoredPage.PAGE_HEADER_SIZE;
1:eac0369: 
1:eac0369: 	protected static final int ALLOC_PAGE_HEADER_SIZE = 8+8+(4*8);
1:eac0369: 
1:eac0369: 	/* borrowed_SPACE_OFFSET is where the borrowed space len is kept */
1:eac0369: 	protected static final int BORROWED_SPACE_OFFSET =
1:eac0369: 		ALLOC_PAGE_HEADER_OFFSET + ALLOC_PAGE_HEADER_SIZE;
1:eac0369: 
1:eac0369: 	/* size of the borrowed space length */
1:eac0369: 	protected static final int BORROWED_SPACE_LEN = 1; // 1 byte to store the containerInfo length
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN is the beginning offset of
1:eac0369: 	 * the borrowed space
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * the entire borrowed space must live within MAX_BORROWED_SPACE of the
1:eac0369: 	 * alloc page
1:eac0369: 	 */
1:eac0369: 	protected static final int MAX_BORROWED_SPACE =
1:eac0369: 			RawStoreFactory.PAGE_SIZE_MINIMUM / 5; // cannot take more then 1/5 of the page
1:eac0369: 
1:eac0369: 	public AllocPage()
1:eac0369: 	{
1:eac0369: 		super();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * overwriting StoredPage methods
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	protected int getMaxFreeSpace() {
1:eac0369: 
1:eac0369: 		// the maximum free space is reduced by the allocation page header the
1:eac0369: 		// size of the borrowed space.  In all allocation page except the first
1:eac0369: 		// one, there is no borrowed space and this is indeed the max free
1:eac0369: 		// space.  In the first allocation page, need to further subtract
1:eac0369: 		// the borrowed space
1:eac0369: 
1:eac0369: 		return super.getMaxFreeSpace() - ALLOC_PAGE_HEADER_SIZE -
1:eac0369: 			BORROWED_SPACE_LEN - borrowedSpace;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Methods of cachedPage - create, read and write up a page
1:eac0369: 	 * Overwriting StoredPage's CachedPage methods
1:eac0369: 	 */
1:eac0369: 
1:04a2f12:     /**
1:eac0369:      * Create a new alloc page.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:1dbc0b8: 	protected void createPage(PageKey newIdentity, PageCreationArgs args)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 
1:a390adb:         // We need to set borrowedSpace before we call super.createPage() so
1:a390adb:         // that totalSpace is initialized correctly (DERBY-3116).
1:a390adb:         borrowedSpace = args.containerInfoSize;
1:eac0369: 
1:a390adb: 		super.createPage(newIdentity, args);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			// MAX_BORROWED_SPACE can't be bigger than what can be represented in 1 byte space
1:eac0369: 			SanityManager.ASSERT(MAX_BORROWED_SPACE <= 255);
1:eac0369: 
1:eac0369:             if (!(borrowedSpace + BORROWED_SPACE_LEN + BORROWED_SPACE_OFFSET 
1:eac0369:                     < MAX_BORROWED_SPACE))
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "borrowedSpace too big = " + borrowedSpace);
1:eac0369:             }
1:eac0369: 			SanityManager.ASSERT(pageData != null);
1:eac0369: 		}
1:eac0369: 		pageData[BORROWED_SPACE_OFFSET] = (byte)borrowedSpace;
1:eac0369: 
1:eac0369: 		// remember that the borrowed space have been wiped out now, it
1:eac0369: 		// needs to be put back when the page is written out.
1:eac0369: 		// blot out borrowed space before checksum is verified
1:eac0369: 		if (borrowedSpace > 0)
1:eac0369: 		{
1:eac0369: 			clearSection(BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN, borrowedSpace);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// init the rest of the header and the allocation extent
1:eac0369: 		nextAllocPageNumber = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 		nextAllocPageOffset = 0;
1:eac0369: 		reserved1 = reserved2 = reserved3 = reserved4 = 0;
1:eac0369: 
1:eac0369: 		// calculate how much space we have left for the extent map
1:a390adb:         if (SanityManager.DEBUG) {
1:a390adb:             // totalSpace used to be incorrect (DERBY-3116), so check it here
1:a390adb:             int maxFreeSpace = getMaxFreeSpace();
1:a390adb:             SanityManager.ASSERT(totalSpace == maxFreeSpace,
1:a390adb:                                  "totalSpace = " + totalSpace +
1:a390adb:                                  ", getMaxFreeSpace() = " + maxFreeSpace);
1:a390adb:         }
1:eac0369: 
1:eac0369: 		// the pages this extent is going to manage starts from pageNum+1
1:eac0369: 		// starting physical offset is pageSize*(pageNum+1) since we have
1:eac0369: 		// no logical to physical mapping yet...
1:a390adb:         extent = createExtent(newIdentity.getPageNumber()+1, getPageSize(),
1:a390adb:                               0 /* pagesAlloced */, totalSpace);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private AllocExtent createExtent(long pageNum, int pageSize, int pagesAlloced, int availspace)
1:eac0369: 	{
1:eac0369: 		int maxPages = AllocExtent.MAX_RANGE(availspace);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(maxPages > 8, "cannot manage > 8 pages");
1:eac0369: 
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(TEST_MULTIPLE_ALLOC_PAGE))
1:eac0369:             {
1:eac0369:                 maxPages = 2;		// 2 pages per alloc page
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return new AllocExtent(pageNum*pageSize,	 		// starting offset
1:eac0369: 							   pageNum,					// extent start page number
1:eac0369: 							   pagesAlloced,				// #pages already allocated
1:eac0369: 							   pageSize, 					// page size
1:eac0369: 							   maxPages);					// max #pages to manage
1:eac0369: 	}
1:eac0369: 
1:bbc927c: 	/**
1:eac0369: 		Initialize in memory structure using the buffer in pageData
1:eac0369: 
1:eac0369: 		@exception StandardException If the page cannot be read correctly, or is inconsistent.
1:eac0369: 	*/
1:eac0369: 	protected void initFromData(FileContainer myContainer, PageKey newIdentity)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (pageData.length < BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN)
1:eac0369:         {
1:eac0369: 			throw dataFactory.markCorrupt(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.DATA_CORRUPT_PAGE, newIdentity));
1:eac0369:         }
1:eac0369: 
1:eac0369: 		byte n = pageData[BORROWED_SPACE_OFFSET];
1:eac0369: 		borrowedSpace = (int)n;
1:eac0369: 
1:eac0369: 		if (pageData.length < BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + n)
1:eac0369:         {
1:eac0369: 			throw dataFactory.markCorrupt(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.DATA_CORRUPT_PAGE, newIdentity));
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// blot out borrowed space before checksum is verified
1:eac0369: 		if (borrowedSpace > 0)
1:eac0369: 		{
1:eac0369: 			clearSection(BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN, borrowedSpace);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		super.initFromData(myContainer, newIdentity);
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			// now init alloc page header fields
1:eac0369: 			readAllocPageHeader();
1:eac0369: 
1:eac0369: 			// now init the allocation extent - read it from offset
1:eac0369: 			int offset = BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + borrowedSpace;
1:eac0369: 			extent = readExtent(offset);
1:eac0369: 		}
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			throw dataFactory.markCorrupt(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.DATA_CORRUPT_PAGE, ioe, newIdentity));
1:eac0369: 		}
1:eac0369: 		catch (ClassNotFoundException cnfe)
1:eac0369: 		{
1:eac0369: 			throw dataFactory.markCorrupt(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.DATA_CORRUPT_PAGE, cnfe, newIdentity));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Write the page out
1:eac0369: 
1:eac0369: 		@exception StandardException If the page cannot be written
1:eac0369: 	*/
1:eac0369: 	protected void writePage(PageKey identity) throws StandardException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			updateAllocPageHeader(); // write out the next alloc page chain
1:eac0369: 
1:eac0369: 			// blot out borrowed space before checksum is calculated - even
1:eac0369: 			// though the page is first read in with borrowed space blotted
1:eac0369: 			// out, whenever this page got cleaned the container will overlay
1:eac0369: 			// the container info in the borrowed space.
1:eac0369: 			int n = (int)pageData[BORROWED_SPACE_OFFSET];
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:     			if (n != borrowedSpace)
1:eac0369:     				SanityManager.THROWASSERT(
1:eac0369:                         "different borrowed space " + n + ", " + borrowedSpace);
1:eac0369: 	    	}
1:eac0369: 			if (n > 0)
1:eac0369: 			{
1:eac0369: 				clearSection(BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN, n);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			int offset = BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + n;
1:eac0369: 			writeExtent(offset);
1:eac0369: 		}
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			// i/o methods on the byte array have thrown an IOException
1:eac0369: 			throw dataFactory.markCorrupt(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.DATA_CORRUPT_PAGE, ioe, identity));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// let store page write out the rest and do the checksum
1:eac0369: 		super.writePage(identity);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private void readAllocPageHeader() throws IOException
1:eac0369: 	{
1:eac0369: 		ArrayInputStream lrdi = rawDataIn;
1:eac0369: 		lrdi.setPosition(ALLOC_PAGE_HEADER_OFFSET);
1:eac0369: 
1:eac0369: 		nextAllocPageNumber = lrdi.readLong();
1:eac0369: 		nextAllocPageOffset = lrdi.readLong();
1:eac0369: 		reserved1 = lrdi.readLong();
1:eac0369: 		reserved2 = lrdi.readLong();
1:eac0369: 		reserved3 = lrdi.readLong();
1:eac0369: 		reserved4 = lrdi.readLong();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void updateAllocPageHeader() throws IOException
1:eac0369: 	{
1:eac0369: 		// rawDataOut and logicalDataOut are defined by StoredPage
1:eac0369: 		rawDataOut.setPosition(ALLOC_PAGE_HEADER_OFFSET);
1:eac0369: 		logicalDataOut.writeLong(nextAllocPageNumber);
1:eac0369: 		logicalDataOut.writeLong(nextAllocPageOffset);
1:eac0369: 		logicalDataOut.writeLong(0); // reserved1
1:eac0369: 		logicalDataOut.writeLong(0); // reserved2
1:eac0369: 		logicalDataOut.writeLong(0); // reserved3
1:eac0369: 		logicalDataOut.writeLong(0); // reserved4
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private AllocExtent readExtent(int offset)
1:eac0369: 		 throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		ArrayInputStream lrdi = rawDataIn;
1:eac0369: 		rawDataIn.setPosition(offset);
1:eac0369: 		AllocExtent newExtent = new AllocExtent();
1:eac0369: 		newExtent.readExternal(lrdi);
1:eac0369: 
1:eac0369: 		// in 1.3 or later, make sure the upgrade from before 1.3 is legal.
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:56a7b39: 			int max_range = AllocExtent.MAX_RANGE(getMaxFreeSpace());
1:eac0369: 			long extent_start = newExtent.getFirstPagenum();
1:eac0369: 			long extent_end = newExtent.getExtentEnd();
1:eac0369: 
1:eac0369: 			// extent_start + max_range - 1 is the absolute last page this
1:eac0369: 			// extent can hope to manage.  See if it did the calculation
1:eac0369: 			// correctly after upgrade.
1:eac0369: 
1:eac0369:             if ((extent_start+max_range-1) < extent_end)
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "extent range exceed what extent's space can handle ");
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return newExtent;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void writeExtent(int offset) throws IOException
1:eac0369: 	{
1:eac0369: 		// rawDataOut and logicalDataOut are defined by StoredPage
1:eac0369: 		rawDataOut.setPosition(offset);
1:eac0369: 		extent.writeExternal(logicalDataOut);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * borrowed space management
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Write the container information into the container information area.
1:eac0369: 
1:eac0369: 		@param containerInfo the container information
1:eac0369: 
1:eac0369: 		@param epage the allocation page data which may not be fully formed,
1:eac0369: 		but is guarenteed to be big enough to cover the area inhibited by the
1:eac0369: 		container info
1:eac0369: 
1:eac0369: 		@param create if create, write out the length of the container info
1:eac0369: 		also. Else check to make sure epage's original container info is of the
1:eac0369: 		same length
1:eac0369: 
1:94f158a: 		@exception StandardException standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public static void WriteContainerInfo(byte[] containerInfo,
1:eac0369: 										  byte[] epage,
1:eac0369: 										  boolean create)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		int N = (containerInfo == null) ? 0 : containerInfo.length;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (create)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     containerInfo != null, "containerInfo is null");
1:eac0369: 
1:eac0369: 			SanityManager.ASSERT(epage != null, "page array is null");
1:eac0369: 
1:eac0369:             if (!((containerInfo == null) ||
1:eac0369:                   ((containerInfo.length + BORROWED_SPACE_OFFSET + 
1:eac0369:                       BORROWED_SPACE_LEN) < epage.length))) 
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "containerInfo too big for page array: " + 
1:eac0369:                     containerInfo.length);
1:eac0369:             }
1:eac0369: 
1:eac0369: 			if (BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + N >=
1:eac0369: 															MAX_BORROWED_SPACE)
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 								 "exceed max borrowable space: " + N);
1:eac0369:         }
1:eac0369: 
1:eac0369:         if ((N + BORROWED_SPACE_LEN + BORROWED_SPACE_OFFSET) > epage.length)
1:eac0369:         {
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 				   "exceed max borrowable space on page: " + N);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (create)
1:eac0369: 		{
1:eac0369: 			epage[BORROWED_SPACE_OFFSET] = (byte)N;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			int oldN = (int)epage[BORROWED_SPACE_OFFSET];
1:eac0369: 			if (oldN != N)
1:eac0369:             {
1:eac0369: 				throw StandardException.newException(
1:eac0369:                         SQLState.DATA_CHANGING_CONTAINER_INFO, 
1:ce40a31:                         oldN, 
1:ce40a31:                         N);
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (N != 0)
1:eac0369: 			System.arraycopy(containerInfo, 0, epage,
1:eac0369: 							 BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN,
1:eac0369: 							 N);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Extract the container information from epage.
1:eac0369: 
1:eac0369: 		@param containerInfo where to put the extracted information
1:eac0369: 
1:eac0369: 		@param epage the allocation page which has the container information.
1:eac0369: 		Epage may not be fully formed, but is guarenteed to be big enough to
1:eac0369: 		cover the area inhibited by the container info
1:eac0369: 	*/
1:eac0369: 	public static void ReadContainerInfo(byte[] containerInfo,
1:eac0369: 										 byte[] epage)
1:2ad822f: 	throws StandardException
1:2ad822f: 	{
1:eac0369: 		int N = (int)epage[BORROWED_SPACE_OFFSET];
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (N != containerInfo.length)
1:eac0369: 				SanityManager.THROWASSERT("N not what is expected : " +  N);
1:eac0369: 
1:eac0369: 			if (BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + N
1:eac0369: 								 						>= MAX_BORROWED_SPACE)
1:eac0369:             {
1:eac0369: 				SanityManager.THROWASSERT("exceed max borrowable space: " + N);
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (N != 0)
1:eac0369: 		{
1:2ad822f: 		    try {
1:2ad822f: 		        System.arraycopy(
1:2ad822f: 		                epage, BORROWED_SPACE_OFFSET+BORROWED_SPACE_LEN,
1:2ad822f: 						containerInfo, 0, N);
1:2ad822f: 		    }  catch (ArrayIndexOutOfBoundsException ioobe) {
1:2ad822f:                 throw StandardException.newException (
1:2ad822f:                     SQLState.DATA_UNEXPECTED_EXCEPTION, 
1:2ad822f:                         StandardException.newException (
1:2ad822f:                             SQLState.UNABLE_TO_ARRAYCOPY,
1:2ad822f:                             ioobe,
1:2ad822f:                             epage.length, containerInfo.length,
1:2ad822f:                             MAX_BORROWED_SPACE,
1:2ad822f:                             BORROWED_SPACE_OFFSET,
1:2ad822f:                             BORROWED_SPACE_LEN,
1:2ad822f:                             BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN,
1:2ad822f:                             N,
1:2ad822f:                             org.apache.derby.iapi.util.StringUtil.hexDump(
1:2ad822f:                                     epage)
1:2ad822f:                         )
1:2ad822f:                 );
1:2ad822f: 		    }
1:2ad822f: 		} 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * specific methods to AllocPage
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the next free page number after given page number 
1:eac0369: 	 */
1:eac0369: 	public long nextFreePageNumber(long pnum)
1:eac0369: 	{
1:eac0369: 		return extent.getFreePageNumber(pnum);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add a page which is managed by this alloc page.
1:eac0369: 		Return the page number of the newly added page.
1:eac0369: 
1:eac0369: 		<BR> MT - thread aware (latched)
1:eac0369: 
1:20bc69f: 		@param mycontainer (future) allows the alloc page to call back to the
1:eac0369: 			container to grow the container by creating and syncing multiple
1:eac0369: 			pages at once
1:eac0369: 		@param ntt the nested top action that is the allocation transaction.
1:eac0369: 			NTT will comit before the user transaction
1:eac0369: 		@param userHandle the container handle that is opened by the user
1:eac0369: 			transaction.  Use the userHandle to latch the new page so that
1:eac0369: 			it may remain latched after NTT is committed so the user
1:eac0369: 			transaction can guarentee to have an empty page
1:eac0369: 
1:eac0369: 		@exception StandardException If the page cannot be added
1:eac0369: 	*/
1:eac0369: 	public void addPage(FileContainer mycontainer, long newPageNumber, 
1:eac0369: 						RawTransaction ntt, BaseContainerHandle userHandle) throws StandardException
1:eac0369: 	{
1:eac0369: 		// RESOLVED:
1:eac0369: 		// 
1:eac0369: 		// to prevent allocating a free page before the freeing transaction has
1:eac0369: 		// commit, need to grab the DEALLOCATE_PROTECTION_HANDLE
1:eac0369: 		// the lock probably should be gotten in FileContainer 
1:eac0369: 		// and not here
1:eac0369: 
1:eac0369: 		// page allocation is logged under the nested top action
1:eac0369: 		owner.getAllocationActionSet().
1:eac0369: 			actionAllocatePage(
1:eac0369:                 ntt, this, newPageNumber, 
1:eac0369:                 AllocExtent.ALLOCATED_PAGE, AllocExtent.FREE_PAGE);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		Deallocate page
1:eac0369: 	*/
1:eac0369: 	public void deallocatePage(BaseContainerHandle userHandle, long pageNumber)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// RESOLVED:
1:eac0369: 		//
1:eac0369: 		// to prevent this page from being freed before this transaction commits,
1:eac0369: 		// need to grab the DEALLOCATE_PROTECTION_HANDLE lock on the
1:eac0369: 		// deallocated page
1:eac0369: 		// the lock probably should be gotten in FileContainer 
1:eac0369: 		// and not here
1:eac0369: 
1:eac0369: 		owner.getAllocationActionSet().
1:eac0369: 			actionAllocatePage(userHandle.getTransaction(),
1:eac0369: 							   this, pageNumber, AllocExtent.DEALLOCATED_PAGE,
1:eac0369: 							   AllocExtent.ALLOCATED_PAGE); 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * update unfilled page information
1:eac0369: 	 * We will be using inputExtent's unfilledPage bitmap as the new bitmap, so
1:eac0369: 	 * caller of this routine need to not touch the bitmap after this call (in
1:eac0369: 	 * other words, call this ONLY in allocationCache invalidate and throw away
1:eac0369: 	 * the reference to the bitImpl)
1:eac0369: 	 */
1:eac0369: 	protected void updateUnfilledPageInfo(AllocExtent inputExtent) 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// update the unfilled page bit map unlogged - it is just a hint, not
1:eac0369: 		// worth logging it - don't dirty the page either, since we didn't log
1:eac0369: 		// it.  It will be dirtied soon enough by addPage or deallocPage,
1:eac0369: 		// that is the only reasons why we are invalidataing the
1:eac0369: 		// allocation cache and updating the unfilled page info. 
1:eac0369: 		// If we dirty the page, the BI will be copied to the side log
1:eac0369: 		extent.updateUnfilledPageInfo(inputExtent);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean canAddFreePage(long lastAllocatedPage)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 
1:eac0369: 		if (extent.isRetired())
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		// if we want to try allocating not from the beginning of the bit map
1:eac0369: 		// and this alloc page is before that point and this is not the last
1:eac0369: 		// alloc page, then skip over this alloc page
1:eac0369: 		if (lastAllocatedPage != ContainerHandle.INVALID_PAGE_NUMBER && 
1:eac0369: 			extent.getLastPagenum() <= lastAllocatedPage && 
1:eac0369: 			!isLast())
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		// Else we either want to start examining from this alloc page, or this
1:eac0369: 		// is the last page, see if we can add a page.
1:eac0369: 		return extent.canAddFreePage(lastAllocatedPage);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public long getNextAllocPageOffset()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 !isLast(), "next alloc page not present for last alloc page");
1:eac0369: 
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return nextAllocPageOffset;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void chainNewAllocPage(BaseContainerHandle allocHandle,
1:eac0369: 								  long newAllocPageNum, long newAllocPageOffset)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 			if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:eac0369: 				SanityManager.DEBUG(FileContainer.SPACE_TRACE,
1:eac0369: 									"chaining new alloc page " +
1:eac0369: 									newAllocPageNum + " to " +
1:eac0369: 									getPageNumber());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		owner.getAllocationActionSet().
1:eac0369: 			actionChainAllocPage(allocHandle.getTransaction(),
1:eac0369: 								 this, newAllocPageNum, newAllocPageOffset);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public long getNextAllocPageNumber()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 !isLast(), "next alloc page not present for last alloc page");
1:eac0369: 		}
1:eac0369: 		return nextAllocPageNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean isLast()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 		return nextAllocPageNumber == ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * get the last pagenumber currently managed by this alloc page
1:eac0369: 	 */
1:eac0369: 	public long getLastPagenum()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 
1:eac0369: 		return extent.getLastPagenum();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * get the largest page number this alloc page can manage. 
1:eac0369: 	 * This is the different from the last pagenumber currently managed by this
1:eac0369: 	 * alloc page unless the alloc page is full and all the pages have been
1:eac0369: 	 * allocated 
1:eac0369: 	 */
1:eac0369: 	public long getMaxPagenum()
1:eac0369: 	{
1:eac0369: 		return extent.getExtentEnd();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * get the last preallocated pagenumber managed by this alloc page
1:eac0369: 	 */
1:eac0369: 	protected long getLastPreallocPagenum()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 
1:eac0369: 		return extent.getLastPreallocPagenum();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected int getPageStatus(long pageNumber)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isLatched());
1:eac0369: 
1:eac0369: 		return extent.getPageStatus(pageNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Do the actual page allocation/deallocation/ree underneath a log operation.
1:eac0369: 		Change the page status to new status
1:eac0369: 
1:eac0369: 		@exception StandardException If the page cannot be allocated
1:eac0369: 	*/
1:eac0369: 	protected void setPageStatus(LogInstant instant, long pageNumber, int newStatus) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1:eac0369: 			SanityManager.ASSERT(extent != null, "extent is null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		logAction(instant);
1:eac0369: 
1:eac0369: 		switch(newStatus)
1:eac0369: 		{
1:eac0369: 		case AllocExtent.ALLOCATED_PAGE:
1:eac0369: 			extent.allocPage(pageNumber);
1:eac0369: 			break;
1:eac0369: 		case AllocExtent.DEALLOCATED_PAGE:
1:eac0369: 			extent.deallocPage(pageNumber);
1:eac0369: 			break;
1:eac0369: 		case AllocExtent.FREE_PAGE:
1:eac0369: 			extent.deallocPage(pageNumber);
1:eac0369: 			break;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Chain the next page number and offset underneath a log record
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected void chainNextAllocPage(LogInstant instant,
1:eac0369: 									  long newAllocPageNum,
1:eac0369: 									  long newAllocPageOffset)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1:eac0369: 
1:eac0369: 		logAction(instant);
1:eac0369: 
1:eac0369: 		nextAllocPageNumber = newAllocPageNum;
1:eac0369: 		nextAllocPageOffset = newAllocPageOffset;
1:eac0369: 	}
1:eac0369: 
1:04a2f12:     /**
1:04a2f12:      * Compress free pages.
1:04a2f12:      * <p>
1:04a2f12:      * Compress the free pages at the end of the range maintained by
1:04a2f12:      * this allocation page.  All pages being compressed should be FREE.
1:04a2f12:      * Only pages in the last allocation page can be compressed.
1:04a2f12:      * <p>
1:04a2f12:      *
1:04a2f12:      * @param instant               log address for this operation.
1:04a2f12:      * @param new_highest_page      The new highest page on this allocation 
1:04a2f12:      *                              page.  The number is the offset of the page
1:04a2f12:      *                              in the array of pages maintained by this 
1:04a2f12:      *                              allocation page, for instance a value of 0 
1:04a2f12:      *                              indicates all page except the first one are
1:04a2f12:      *                              to be truncated.  If all pages are 
1:04a2f12:      *                              truncated then the offset is set to -1.
1:04a2f12:      * @param num_pages_truncated   The number of allocated pages in this 
1:04a2f12:      *                              allocation page prior to the truncate.  
1:04a2f12:      *                              Note that all pages from NewHighestPage+1 
1:04a2f12:      *                              through newHighestPage+num_pages_truncated 
1:04a2f12:      *                              should be FREE.
1:04a2f12:      *
1:04a2f12: 	 * @exception  StandardException  Standard exception policy.
1:04a2f12:      **/
1:04a2f12: 	protected void compressSpace(
1:04a2f12:     LogInstant  instant,
1:04a2f12:     int         new_highest_page,
1:04a2f12:     int         num_pages_truncated)
1:04a2f12: 		 throws StandardException
1:04a2f12: 	{
1:04a2f12: 		if (SanityManager.DEBUG)
1:04a2f12:         {
1:04a2f12: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1:04a2f12:             SanityManager.ASSERT(isLast(), "compress on non last alloc page.");
1:f824190: 	    //Derby-606. newHighestPage = -1, is a valid case as it means that 
1:f824190: 	    //all the pages in this extent can be compressed.
1:f824190:             SanityManager.ASSERT(new_highest_page >= -1, "negative new high page.");
1:04a2f12:         }
1:04a2f12: 
1:04a2f12: 		logAction(instant);
1:04a2f12: 
1:04a2f12:         extent.compressPages(new_highest_page, num_pages_truncated);
1:04a2f12: 	}
1:04a2f12: 
1:bd54198:     /**
1:bd54198:      * Handle undo of compress space operation.
1:bd54198:      **/
1:bd54198: 	protected void undoCompressSpace(
1:bd54198:     LogInstant  instant,
1:bd54198:     int         new_highest_page,
1:bd54198:     int         num_pages_truncated)
1:bd54198: 		throws StandardException
1:bd54198:     {
1:bd54198: 		logAction(instant);
1:bd54198: 
1:bd54198:         extent.undoCompressPages(new_highest_page, num_pages_truncated);
1:bd54198: 
1:bd54198:     }
1:bd54198: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:04a2f12: 			String str = 
1:04a2f12:                 "*** Alloc page ***\n"      + 
1:04a2f12:                 "nextAllocPageNumber = "    + nextAllocPageNumber   +
1:04a2f12:                 "\nnextAllocPageOffset = "  + nextAllocPageOffset   +
1:04a2f12:                 "\nreserved1 = "            + reserved1             +
1:04a2f12:                 "\nreserved2 = "            + reserved2             +
1:04a2f12:                 "\nreserved3 = "            + reserved3             +
1:04a2f12:                 "\nreserved4 = "            + reserved4             +
1:04a2f12: 	            "\nborrowedSpace = "        + borrowedSpace         +
1:04a2f12:                 "\nextent = "               + extent.toDebugString() + "\n" +
1:04a2f12:                 super.toString();
1:eac0369: 			return str;
1:eac0369: 		}
1:eac0369: 		else
1:04a2f12:         {
1:eac0369: 			return null;
1:04a2f12:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a copy of the allocExtent to be cached by the container.
1:eac0369: 		the container must take care to maintain its coherency by
1:eac0369: 		invalidating the cache before any update.
1:eac0369: 	*/
1:eac0369: 	protected AllocExtent getAllocExtent()
1:eac0369: 	{
1:eac0369: 		return extent;
1:eac0369: 
1:eac0369: 		// return new AllocExtent(extent);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Preallocate user page if needed.
1:eac0369: 
1:bbc927c: 		@param myContainer the container object
1:eac0369: 		@param preAllocThreshold start preallocating after this threshold
1:eac0369: 		@param preAllocSize preallocate this number of pages 
1:bbc927c: 	*/
1:eac0369: 	protected void preAllocatePage(FileContainer myContainer,
1:eac0369: 								   int preAllocThreshold,
1:eac0369: 								   int preAllocSize)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1:bbc927c: 
1:eac0369: 		long lastPreallocatedPagenum = extent.getLastPreallocPagenum();
1:eac0369: 
1:eac0369: 		if (lastPreallocatedPagenum < preAllocThreshold)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		// don't pre-allocate more than we the extent can handle - this is
1:eac0369: 		// because if I preallocate the next alloc page as a stored page,
1:eac0369: 		// that's going to be problem when we try to get it as an alloc page
1:eac0369: 		// later.  We don't handle changing from a store page type to an alloc
1:eac0369: 		// page type on disk very well.
1:eac0369: 		if (extent.getExtentEnd() < (lastPreallocatedPagenum+preAllocSize))
1:eac0369: 			preAllocSize = (int)(extent.getExtentEnd() - lastPreallocatedPagenum);
1:eac0369: 
1:eac0369: 		if (preAllocSize <= 0)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		// pre-allocate - only a container knows how to write pages
1:eac0369: 		// preAllocSize may exceed what this allocation page can really
1:eac0369: 		// handle, but no harm done.  The next allocation page will benefit
1:eac0369: 		// from the work we have done...
1:eac0369: 		int n = myContainer.preAllocate(lastPreallocatedPagenum, preAllocSize);
1:eac0369: 		
1:eac0369: 		if (n > 0) 				// successfully preallocated some pages
1:eac0369: 		{
1:eac0369: 			// this is purely a performance issue during runtime.  During
1:eac0369: 			// recovery, any page that is actually initialized will have its
1:eac0369: 			// own initPage log record.  Update extent's preAllocpageNumber
1:eac0369: 			// unlogged.
1:eac0369: 			//
1:eac0369: 			// We could have logged a redo-only log record, but we are counting
1:eac0369: 			// on myContainer.preAllocate to do the right thing if we recovered
1:eac0369: 			// and have out of date preallocate information.  A reason why
1:eac0369: 			// logging this is undesirable is that the alloc page may think the
1:eac0369: 			// preallocation happened, but the container may actually choose to
1:eac0369: 			// lie about it - if it thinks there is no advantage in actually
1:eac0369: 			// doing the I/O now.  So best to leave it alone.
1:eac0369: 			extent.setLastPreallocPagenum(lastPreallocatedPagenum + n);
1:eac0369: 
1:eac0369: 			// don't dirty the page - the new preAlloc page number is only set
1:eac0369: 			// in memory.  A page should only get 'dirtied' by a log operation,
1:eac0369: 			// we are cheating here.  Same with updating the extentStatus bit
1:eac0369: 			// without logging.
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:04a2f12:      * compress out empty pages at end of container.
1:04a2f12:      * <p>
1:04a2f12:      * Call the extent to update the data structure make the bit map look
1:04a2f12:      * like contiguous free pages at the end of the extent no longer exist.
1:04a2f12:      * Similar to preallocate do the operation unlogged, need to force the
1:04a2f12:      * change to the extent before actually removing the space from the
1:04a2f12:      * file.
1:04a2f12:      * <p>
1:04a2f12:      * The sequence is:
1:04a2f12:      *     1) update extent data structure
1:04a2f12:      *     2) force extent changes to disk
1:04a2f12:      *     3) truncate pages
1:04a2f12:      *
1:04a2f12:      * If the system crashes between 1 and 2 then no changes are on disk.
1:04a2f12:      * If the system crashes between 2 and 3 then there are extra pages in
1:04a2f12:      *     the file that extent does not know about, this is the same case
1:04a2f12:      *     as preallocation which the code already handes.  It will handle
1:04a2f12:      *     any set of pages from 0 to all of the intended pages being 
1:04a2f12:      *     truncated.  The next allocate looks at actual size of file as
1:04a2f12:      *     does the right thing.
1:04a2f12:      *
1:dbed020:      * <p>
1:04a2f12:      * MT - expect Container level X lock
1:04a2f12:      *
1:04a2f12: 	 * @exception  StandardException  Standard exception policy.
1:04a2f12:      **/
1:bbc927c: 	protected boolean compress(
1:04a2f12:     RawTransaction  ntt,
1:04a2f12:     FileContainer   myContainer)
1:bbc927c:         throws StandardException
1:bbc927c: 	{
1:bbc927c:         boolean all_pages_compressed = false;
1:04a2f12: 
1:bbc927c: 		if (SanityManager.DEBUG)
1:04a2f12:         {
1:bbc927c: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1:04a2f12:         }
1:bbc927c: 
1:74e2f88:         int last_valid_page_bit = extent.compress(owner, ntt, this);
1:eac0369: 
1:74e2f88:         if (last_valid_page_bit >= 0)
1:bbc927c:         {
1:bbc927c:             // a non-negative return means that pages can be returned to
1:bbc927c:             // the operating system.
1:74e2f88:             myContainer.truncatePages(extent.getPagenum(last_valid_page_bit));
1:bbc927c: 
1:74e2f88:             if (last_valid_page_bit == 0)
1:bbc927c:             {
1:bbc927c:                 // all pages of the extent have been returned to OS.
1:bbc927c:                 all_pages_compressed = true;
1:bbc927c:             }
1:bbc927c:         }
1:bbc927c: 
1:bbc927c:         return(all_pages_compressed);
1:bbc927c: 	}
1:eac0369: 
1:eac0369: 	/*********************************************************************
1:eac0369: 	 * Extent Testing
1:eac0369: 	 *
1:eac0369: 	 * Use these strings to simulate error conditions for
1:eac0369: 	 * testing purposes.
1:eac0369: 	 *
1:eac0369: 	 *********************************************************************/
1:eac0369: 	public static final String TEST_MULTIPLE_ALLOC_PAGE = SanityManager.DEBUG ? "TEST_MULTI_ALLOC_PAGE" : null;
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:                              [ borrowed ]
/////////////////////////////////////////////////////////////////////////
1: 	be a severe performance hit.  The logical -&gt; physical mapping of an
/////////////////////////////////////////////////////////////////////////
1:      * <p>
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                         oldN, 
1:                         N);
commit:74e2f88
/////////////////////////////////////////////////////////////////////////
1:         int last_valid_page_bit = extent.compress(owner, ntt, this);
1:         if (last_valid_page_bit >= 0)
1:             myContainer.truncatePages(extent.getPagenum(last_valid_page_bit));
1:             if (last_valid_page_bit == 0)
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2ad822f
/////////////////////////////////////////////////////////////////////////
1: 	throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 		{
1: 		    try {
1: 		        System.arraycopy(
1: 		                epage, BORROWED_SPACE_OFFSET+BORROWED_SPACE_LEN,
1: 						containerInfo, 0, N);
1: 		    }  catch (ArrayIndexOutOfBoundsException ioobe) {
1:                 throw StandardException.newException (
1:                     SQLState.DATA_UNEXPECTED_EXCEPTION, 
1:                         StandardException.newException (
1:                             SQLState.UNABLE_TO_ARRAYCOPY,
1:                             ioobe,
1:                             epage.length, containerInfo.length,
1:                             MAX_BORROWED_SPACE,
1:                             BORROWED_SPACE_OFFSET,
1:                             BORROWED_SPACE_LEN,
1:                             BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN,
1:                             N,
1:                             org.apache.derby.iapi.util.StringUtil.hexDump(
1:                                     epage)
1:                         )
1:                 );
1: 		    }
1: 		} 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Lily Wei
-------------------------------------------------------------------------------
commit:56a7b39
/////////////////////////////////////////////////////////////////////////
1: 			int max_range = AllocExtent.MAX_RANGE(getMaxFreeSpace());
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:787ceb4
/////////////////////////////////////////////////////////////////////////
1: 	@derby.formatId	RAW_STORE_ALLOC_PAGE
1: 	@derby.purpose	manage page allocation
1: 	@derby.upgrade
1: 	@derby.diskLayout
/////////////////////////////////////////////////////////////////////////
1: 	@derby.endFormat
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a390adb
/////////////////////////////////////////////////////////////////////////
1:         // We need to set borrowedSpace before we call super.createPage() so
1:         // that totalSpace is initialized correctly (DERBY-3116).
1:         borrowedSpace = args.containerInfoSize;
1: 		super.createPage(newIdentity, args);
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             // totalSpace used to be incorrect (DERBY-3116), so check it here
1:             int maxFreeSpace = getMaxFreeSpace();
1:             SanityManager.ASSERT(totalSpace == maxFreeSpace,
1:                                  "totalSpace = " + totalSpace +
1:                                  ", getMaxFreeSpace() = " + maxFreeSpace);
1:         }
1:         extent = createExtent(newIdentity.getPageNumber()+1, getPageSize(),
1:                               0 /* pagesAlloced */, totalSpace);
commit:1dbc0b8
/////////////////////////////////////////////////////////////////////////
1: 	protected void createPage(PageKey newIdentity, PageCreationArgs args)
0: 		borrowedSpace = args.containerInfoSize;
/////////////////////////////////////////////////////////////////////////
0: 		extent = createExtent(newIdentity.getPageNumber()+1, getPageSize(), 0 /* pagesAlloced */, maxSpace);
commit:7ecfe40
/////////////////////////////////////////////////////////////////////////
1: 	<P>
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:f824190
/////////////////////////////////////////////////////////////////////////
1: 	    //Derby-606. newHighestPage = -1, is a valid case as it means that 
1: 	    //all the pages in this extent can be compressed.
1:             SanityManager.ASSERT(new_highest_page >= -1, "negative new high page.");
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:bd54198
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Handle undo of compress space operation.
1:      **/
1: 	protected void undoCompressSpace(
1:     LogInstant  instant,
1:     int         new_highest_page,
1:     int         num_pages_truncated)
1: 		throws StandardException
1:     {
1: 		logAction(instant);
1: 
1:         extent.undoCompressPages(new_highest_page, num_pages_truncated);
1: 
1:     }
1: 
commit:04a2f12
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Compress free pages.
1:      * <p>
1:      * Compress the free pages at the end of the range maintained by
1:      * this allocation page.  All pages being compressed should be FREE.
1:      * Only pages in the last allocation page can be compressed.
1:      * <p>
1:      *
1:      * @param instant               log address for this operation.
1:      * @param new_highest_page      The new highest page on this allocation 
1:      *                              page.  The number is the offset of the page
1:      *                              in the array of pages maintained by this 
1:      *                              allocation page, for instance a value of 0 
1:      *                              indicates all page except the first one are
1:      *                              to be truncated.  If all pages are 
1:      *                              truncated then the offset is set to -1.
1:      * @param num_pages_truncated   The number of allocated pages in this 
1:      *                              allocation page prior to the truncate.  
1:      *                              Note that all pages from NewHighestPage+1 
1:      *                              through newHighestPage+num_pages_truncated 
1:      *                              should be FREE.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected void compressSpace(
1:     LogInstant  instant,
1:     int         new_highest_page,
1:     int         num_pages_truncated)
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1:         {
1: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1:             SanityManager.ASSERT(isLast(), "compress on non last alloc page.");
0:             SanityManager.ASSERT(new_highest_page >= 0, "negative new high page.");
1:         }
1: 
1: 		logAction(instant);
1: 
1:         extent.compressPages(new_highest_page, num_pages_truncated);
1: 	}
1: 
1: 			String str = 
1:                 "*** Alloc page ***\n"      + 
1:                 "nextAllocPageNumber = "    + nextAllocPageNumber   +
1:                 "\nnextAllocPageOffset = "  + nextAllocPageOffset   +
1:                 "\nreserved1 = "            + reserved1             +
1:                 "\nreserved2 = "            + reserved2             +
1:                 "\nreserved3 = "            + reserved3             +
1:                 "\nreserved4 = "            + reserved4             +
1: 	            "\nborrowedSpace = "        + borrowedSpace         +
1:                 "\nextent = "               + extent.toDebugString() + "\n" +
1:                 super.toString();
1:         {
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * compress out empty pages at end of container.
1:      * <p>
1:      * Call the extent to update the data structure make the bit map look
1:      * like contiguous free pages at the end of the extent no longer exist.
1:      * Similar to preallocate do the operation unlogged, need to force the
1:      * change to the extent before actually removing the space from the
1:      * file.
1:      * <p>
1:      * The sequence is:
1:      *     1) update extent data structure
1:      *     2) force extent changes to disk
1:      *     3) truncate pages
1:      *
1:      * If the system crashes between 1 and 2 then no changes are on disk.
1:      * If the system crashes between 2 and 3 then there are extra pages in
1:      *     the file that extent does not know about, this is the same case
1:      *     as preallocation which the code already handes.  It will handle
1:      *     any set of pages from 0 to all of the intended pages being 
1:      *     truncated.  The next allocate looks at actual size of file as
1:      *     does the right thing.
1:      *
0:      * <p)
1:      * MT - expect Container level X lock
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     RawTransaction  ntt,
1:     FileContainer   myContainer)
1:         {
1:         }
0:         int last_valid_page = extent.compress(owner, ntt, this);
1: 
0:             myContainer.truncatePages(extent.getPagenum(last_valid_page));
commit:20bc69f
/////////////////////////////////////////////////////////////////////////
1: 		@param mycontainer (future) allows the alloc page to call back to the
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 		compress
1: 		@param myContainer the container object
1: 	*/
1: 	protected boolean compress(
0:     FileContainer myContainer)
1:         throws StandardException
1: 	{
1:         boolean all_pages_compressed = false;
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1: 
0:         long last_valid_page = extent.compressPages();
0:         if (last_valid_page >= 0)
1:         {
1:             // a non-negative return means that pages can be returned to
1:             // the operating system.
0:             myContainer.truncatePages(last_valid_page);
1: 
0:             if (last_valid_page == this.getPageNumber())
1:             {
1:                 // all pages of the extent have been returned to OS.
1:                 all_pages_compressed = true;
1:             }
1:         }
1: 
1:         return(all_pages_compressed);
1: 	}
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.AllocPage
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.io.TypedFormat;
1: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.Loggable;
1: import org.apache.derby.iapi.store.raw.PageKey;
1: import org.apache.derby.iapi.store.raw.PageTimeStamp;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: 
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1: 
1: import org.apache.derby.impl.store.raw.data.BaseContainerHandle;
1: import org.apache.derby.impl.store.raw.data.BasePage;
1: import org.apache.derby.impl.store.raw.data.PageVersion;
1: 
1: import java.io.IOException;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: 
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
1: /**
1: 	An allocation page of the file container.
1: 	<P>
1: 	This class extends a normal Stored page, with the exception that a hunk of
1: 	space may be 'borrowed' by the file container to store the file header.
1: 	<P>
1: 	The borrowed space is not visible to the alloc page even though it is
1: 	present in the page data array.  It is accessed directly by the
1: 	FileContainer.  Any change made to the borrowed space is not managed or
1: 	seen by the allocation page.
0: 	<P
1: 	The reason for having this borrowed space is so that the container header
1: 	does not need to have a page of its own.
1: 
1: 	<P><B>Page Format</B><BR>
1: 	An allocation page extends a stored page, the on disk format is different
1: 	from a stored page in that N bytes are 'borrowed' by the container and the
1: 	page header of an allocation page will be slightly bigger than a normal
1: 	stored page.  This N bytes are stored between the page header and the 
1:     record space.
1: 	<P>
1: 	The reason why this N bytes can't simply be a row is because it needs to be
1: 	statically accessible by the container object to avoid a chicken and egg
1: 	problem of the container object needing to instantiate an alloc page object
1: 	before it can be objectified, and an alloc page object needing to
1: 	instantiate a container object before it can be objectified.  So this N
1: 	bytes must be stored outside of the normal record interface yet it must be
1: 	settable because only the first alloc page has this borrowed space.  Other
1: 	(non-first) alloc page have N == 0.
1: 
1: 	<PRE>
0:                              <-- borrowed ->
1: 	+----------+-------------+---+---------+-------------------+-------------+--------+
1: 	| FormatId | page header | N | N bytes | alloc extend rows | slot offset |checksum|
1: 	+----------+-------------+---+---------+-------------------+-------------+--------+
1: 	</PRE>
1: 
1: 	N is a byte that indicates the size of the borrowed space.  Once an alloc
1: 	page is initialized, the value of N cannot change.
1: 	<P>
1: 	The maximum space that can be borrowed by the container is 256 bytes.
1: 	<P>
1: 	The allocation page are of the same page size as any other pages in the
1: 	container. The first allocation page of the FileContainer starts at the
1: 	first physical byte of the container.  Subsequent allocation pages are
1: 	chained via the nextAllocPageOffset.  Each allocation page is expected to
1: 	manage at least 1000 user pages (for 1K page size) so this chaining may not
0: 	be a severe performance hit.  The logical -> physical mapping of an
1: 	allocation page is stored in the previous allocation page.  The container
1: 	object will need to maintain this mapping.
1: 	<P>
1: 	The following fields are stored in the page header
1: 	<PRE>
0: 	@format_id	RAW_STORE_ALLOC_PAGE
0: 	@purpose	manage page allocation
0: 	@upgrade
0: 	@disk_layout
1: 		FormatId(int)
1: 		StoredPageHeader	see StoredPage
1: 		nextAllocPageNubmer(long)	the next allocation page's number
1: 		nextAllocPageOffset(long)	the file offset of the next allocation page
1: 		reserved1(long)				reserved for future usage
1: 		reserved2(long)				reserved for future usage
1: 		reserved3(long)				reserved for future usage
1: 		reserved4(long)				reserved for future usage
1: 		N(byte)						the size of the borrowed container info
1: 		containerInfo(byte[N])		the content of the borrowed container info
1: 		AllocExtent					the one and only extent on this alloc page
1: 
0: 	@end_format
1: 	</PRE>
1: 
1: 	<P>
1: 	The allocation page contains allocation extent rows.  In this first cut
1: 	implementation, there is only 1 allocation extent row per allocation page.
1: 	<P>
1: 	The allocation extent row is an externalizable object and is directly
1: 	written on to the page by the alloc page.  In other words, it will not be
1: 	converted in to a storeableRow.  This is to cut down overhead, enhance
1: 	performance and gives more control of the size and layout of the allocation
1: 	extent row to the alloc page.
1: 	<P>
1: 	<HR WIDTH="100%">
1: 	<BR> DETAIL implmentation notes <BR>
1: 	<HR WIDTH="100%">
1: 	<P>
1: 	Create Container - an embryonic allocation page is formatted on disk by a
1: 	spcial static function to avoid instantiating a full AllocPage object.
1: 	This embryonic allocation has enough information that it can find the
1: 	file header and not much else.  Then the allocation page is perperly
1: 	initiated by creating the first extent.
1: 	<P>
1: 	Open Container - A static AllocPage method will be used to read off the
1: 	container information directly from disk.  Even if
1: 	the first alloc page (page 0) is already in the page cache, it will not be
1: 	used because cleaning the alloc page will introduce a deadlock if the
1: 	container is not in the container cache.  Long term, the first alloc page
1: 	should probably live in the container cache rather than in the page cache.
1: 	<P>
1: 	Get Page - The first alloc page (page 0) will be read into the page cache.
1: 	Continue to follow the alloc page chain until the alloc page that manages
1: 	the specified page is found.  From the alloc page, the physical offset of
1: 	the specified page is located.
1: 	<P>
1: 	Cleaning alloc page - the alloc page is written out the same way any page
1: 	is written out.  The container object will provide a call back to the alloc
1: 	page to write the current version of the container object back into the
1: 	borrowed space before the alloc page itself is written out.
1: 	<P>
1: 	Cleaning the container object - get the the first alloc page, dirty it and
1: 	clean it (which will cause it to call the container object to write itself
1: 	out into the borrowed space).  The versioning of the container is
1: 	independent of the versioning of the alloc page.  The container version is
1: 	stored inside the borrowed space and is opaque to the alloc page.
1: 	<P>
1: 	For the fields in an allocation extent row
1: 
1: 	@see AllocExtent
1: */
1: 
1: 
1: public class AllocPage extends StoredPage
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/*
1: 	 * typed format
1: 	 */
1: 	public static final int FORMAT_NUMBER = StoredFormatIds.RAW_STORE_ALLOC_PAGE;
1: 	// format Id must fit in 4 bytes
1: 
1: 	/**
1: 		Return my format identifier.
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.RAW_STORE_ALLOC_PAGE;
1: 	}
1: 
1: 	/*****************************************************************
1: 	 * alloc page header
1: 	 *****************************************************************/
1: 	private long nextAllocPageNumber;	// if isLast, nextAllocPageNumber == INVALID_PAGE_NUMBER
1: 	private long nextAllocPageOffset;
1: 	private long reserved1;
1: 	private long reserved2;
1: 	private long reserved3;
1: 	private long reserved4;
1: 
1: 	private AllocExtent extent;
1: 
1: 	private int borrowedSpace;
1: 
1: 	/*****************************************************************
1: 	 * constants
1: 	 *****************************************************************/
1: 
1: 	/*
1: 	 * allocation page header
1: 	 * 8 bytes	long	next alloc page number
1: 	 * 8 bytes	long	next alloc page physical offset
1: 	 * 8 bytes  long	reserved1
1: 	 * 8 bytes  long	reserved2
1: 	 * 8 bytes  long	reserved3
1: 	 * 8 bytes  long	reserved4
1: 	 */
1: 	protected static final int ALLOC_PAGE_HEADER_OFFSET =
1: 		StoredPage.PAGE_HEADER_OFFSET + StoredPage.PAGE_HEADER_SIZE;
1: 
1: 	protected static final int ALLOC_PAGE_HEADER_SIZE = 8+8+(4*8);
1: 
1: 	/* borrowed_SPACE_OFFSET is where the borrowed space len is kept */
1: 	protected static final int BORROWED_SPACE_OFFSET =
1: 		ALLOC_PAGE_HEADER_OFFSET + ALLOC_PAGE_HEADER_SIZE;
1: 
1: 	/* size of the borrowed space length */
1: 	protected static final int BORROWED_SPACE_LEN = 1; // 1 byte to store the containerInfo length
1: 
1: 	/*
1: 	 * BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN is the beginning offset of
1: 	 * the borrowed space
1: 	 */
1: 
1: 	/*
1: 	 * the entire borrowed space must live within MAX_BORROWED_SPACE of the
1: 	 * alloc page
1: 	 */
1: 	protected static final int MAX_BORROWED_SPACE =
1: 			RawStoreFactory.PAGE_SIZE_MINIMUM / 5; // cannot take more then 1/5 of the page
1: 
1: 	public AllocPage()
1: 	{
1: 		super();
1: 	}
1: 
1: 	/*
1: 	 * overwriting StoredPage methods
1: 	 */
1: 
1: 	protected int getMaxFreeSpace() {
1: 
1: 		// the maximum free space is reduced by the allocation page header the
1: 		// size of the borrowed space.  In all allocation page except the first
1: 		// one, there is no borrowed space and this is indeed the max free
1: 		// space.  In the first allocation page, need to further subtract
1: 		// the borrowed space
1: 
1: 		return super.getMaxFreeSpace() - ALLOC_PAGE_HEADER_SIZE -
1: 			BORROWED_SPACE_LEN - borrowedSpace;
1: 	}
1: 
1: 
1: 	/*
1: 	 * Methods of cachedPage - create, read and write up a page
1: 	 * Overwriting StoredPage's CachedPage methods
1: 	 */
1: 
1:     /**
1:      * Create a new alloc page.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0: 	protected void createPage(PageKey newIdentity, int[] args) 
1: 		 throws StandardException
1: 	{
1: 
0: 		super.createPage(newIdentity, args);
1: 
0: 		// args[0] is the format id
0: 		// args[1] is whether to sync the page to disk or not
0: 		// args[2] is the pagesize (used by StoredPage)
0: 		// args[3] is the spareSize (used by StoredPage)
0: 		// args[4] is the number of bytes to reserve for container header
0: 		// args[5] is the minimumRecordSize
0: 		// NOTE: the arg list here must match the one in FileContainer
0: 		int pageSize = args[2];
0: 		int minimumRecordSize = args[5];
0: 		borrowedSpace = args[4];
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			// MAX_BORROWED_SPACE can't be bigger than what can be represented in 1 byte space
1: 			SanityManager.ASSERT(MAX_BORROWED_SPACE <= 255);
1: 
1:             if (!(borrowedSpace + BORROWED_SPACE_LEN + BORROWED_SPACE_OFFSET 
1:                     < MAX_BORROWED_SPACE))
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "borrowedSpace too big = " + borrowedSpace);
1:             }
1: 			SanityManager.ASSERT(pageData != null);
1: 		}
1: 		pageData[BORROWED_SPACE_OFFSET] = (byte)borrowedSpace;
1: 
1: 		// remember that the borrowed space have been wiped out now, it
1: 		// needs to be put back when the page is written out.
1: 		// blot out borrowed space before checksum is verified
1: 		if (borrowedSpace > 0)
1: 		{
1: 			clearSection(BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN, borrowedSpace);
1: 		}
1: 
1: 		// init the rest of the header and the allocation extent
1: 		nextAllocPageNumber = ContainerHandle.INVALID_PAGE_NUMBER;
1: 		nextAllocPageOffset = 0;
1: 		reserved1 = reserved2 = reserved3 = reserved4 = 0;
1: 
1: 		// calculate how much space we have left for the extent map
0: 		int maxSpace = getMaxFreeSpace();
1: 
1: 		// the pages this extent is going to manage starts from pageNum+1
1: 		// starting physical offset is pageSize*(pageNum+1) since we have
1: 		// no logical to physical mapping yet...
0: 		extent = createExtent(newIdentity.getPageNumber()+1, pageSize, 0 /* pagesAlloced */, maxSpace);
1: 	}
1: 
1: 	private AllocExtent createExtent(long pageNum, int pageSize, int pagesAlloced, int availspace)
1: 	{
1: 		int maxPages = AllocExtent.MAX_RANGE(availspace);
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(maxPages > 8, "cannot manage > 8 pages");
1: 
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(TEST_MULTIPLE_ALLOC_PAGE))
1:             {
1:                 maxPages = 2;		// 2 pages per alloc page
1:             }
1:         }
1: 
1: 		return new AllocExtent(pageNum*pageSize,	 		// starting offset
1: 							   pageNum,					// extent start page number
1: 							   pagesAlloced,				// #pages already allocated
1: 							   pageSize, 					// page size
1: 							   maxPages);					// max #pages to manage
1: 	}
1: 
1: 	/**
1: 		Initialize in memory structure using the buffer in pageData
1: 
1: 		@exception StandardException If the page cannot be read correctly, or is inconsistent.
1: 	*/
1: 	protected void initFromData(FileContainer myContainer, PageKey newIdentity)
1: 		 throws StandardException
1: 	{
1: 		if (pageData.length < BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN)
1:         {
1: 			throw dataFactory.markCorrupt(
1:                 StandardException.newException(
1:                     SQLState.DATA_CORRUPT_PAGE, newIdentity));
1:         }
1: 
1: 		byte n = pageData[BORROWED_SPACE_OFFSET];
1: 		borrowedSpace = (int)n;
1: 
1: 		if (pageData.length < BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + n)
1:         {
1: 			throw dataFactory.markCorrupt(
1:                 StandardException.newException(
1:                     SQLState.DATA_CORRUPT_PAGE, newIdentity));
1:         }
1: 
1: 		// blot out borrowed space before checksum is verified
1: 		if (borrowedSpace > 0)
1: 		{
1: 			clearSection(BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN, borrowedSpace);
1: 		}
1: 
1: 		super.initFromData(myContainer, newIdentity);
1: 
1: 		try
1: 		{
1: 			// now init alloc page header fields
1: 			readAllocPageHeader();
1: 
1: 			// now init the allocation extent - read it from offset
1: 			int offset = BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + borrowedSpace;
1: 			extent = readExtent(offset);
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			throw dataFactory.markCorrupt(
1:                 StandardException.newException(
1:                     SQLState.DATA_CORRUPT_PAGE, ioe, newIdentity));
1: 		}
1: 		catch (ClassNotFoundException cnfe)
1: 		{
1: 			throw dataFactory.markCorrupt(
1:                 StandardException.newException(
1:                     SQLState.DATA_CORRUPT_PAGE, cnfe, newIdentity));
1: 		}
1: 	}
1: 
1: 	/**
1: 		Write the page out
1: 
1: 		@exception StandardException If the page cannot be written
1: 	*/
1: 	protected void writePage(PageKey identity) throws StandardException
1: 	{
1: 		try
1: 		{
1: 			updateAllocPageHeader(); // write out the next alloc page chain
1: 
1: 			// blot out borrowed space before checksum is calculated - even
1: 			// though the page is first read in with borrowed space blotted
1: 			// out, whenever this page got cleaned the container will overlay
1: 			// the container info in the borrowed space.
1: 			int n = (int)pageData[BORROWED_SPACE_OFFSET];
1:             if (SanityManager.DEBUG)
1:             {
1:     			if (n != borrowedSpace)
1:     				SanityManager.THROWASSERT(
1:                         "different borrowed space " + n + ", " + borrowedSpace);
1: 	    	}
1: 			if (n > 0)
1: 			{
1: 				clearSection(BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN, n);
1: 			}
1: 
1: 			int offset = BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + n;
1: 			writeExtent(offset);
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			// i/o methods on the byte array have thrown an IOException
1: 			throw dataFactory.markCorrupt(
1:                 StandardException.newException(
1:                     SQLState.DATA_CORRUPT_PAGE, ioe, identity));
1: 		}
1: 
1: 		// let store page write out the rest and do the checksum
1: 		super.writePage(identity);
1: 	}
1: 
1: 
1: 	private void readAllocPageHeader() throws IOException
1: 	{
1: 		ArrayInputStream lrdi = rawDataIn;
1: 		lrdi.setPosition(ALLOC_PAGE_HEADER_OFFSET);
1: 
1: 		nextAllocPageNumber = lrdi.readLong();
1: 		nextAllocPageOffset = lrdi.readLong();
1: 		reserved1 = lrdi.readLong();
1: 		reserved2 = lrdi.readLong();
1: 		reserved3 = lrdi.readLong();
1: 		reserved4 = lrdi.readLong();
1: 	}
1: 
1: 	private void updateAllocPageHeader() throws IOException
1: 	{
1: 		// rawDataOut and logicalDataOut are defined by StoredPage
1: 		rawDataOut.setPosition(ALLOC_PAGE_HEADER_OFFSET);
1: 		logicalDataOut.writeLong(nextAllocPageNumber);
1: 		logicalDataOut.writeLong(nextAllocPageOffset);
1: 		logicalDataOut.writeLong(0); // reserved1
1: 		logicalDataOut.writeLong(0); // reserved2
1: 		logicalDataOut.writeLong(0); // reserved3
1: 		logicalDataOut.writeLong(0); // reserved4
1: 	}
1: 
1: 	private AllocExtent readExtent(int offset)
1: 		 throws IOException, ClassNotFoundException
1: 	{
1: 		ArrayInputStream lrdi = rawDataIn;
1: 		rawDataIn.setPosition(offset);
1: 		AllocExtent newExtent = new AllocExtent();
1: 		newExtent.readExternal(lrdi);
1: 
1: 		// in 1.3 or later, make sure the upgrade from before 1.3 is legal.
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			int max_range = newExtent.MAX_RANGE(getMaxFreeSpace());
1: 			long extent_start = newExtent.getFirstPagenum();
1: 			long extent_end = newExtent.getExtentEnd();
1: 
1: 			// extent_start + max_range - 1 is the absolute last page this
1: 			// extent can hope to manage.  See if it did the calculation
1: 			// correctly after upgrade.
1: 
1:             if ((extent_start+max_range-1) < extent_end)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "extent range exceed what extent's space can handle ");
1:             }
1: 		}
1: 
1: 		return newExtent;
1: 	}
1: 
1: 	private void writeExtent(int offset) throws IOException
1: 	{
1: 		// rawDataOut and logicalDataOut are defined by StoredPage
1: 		rawDataOut.setPosition(offset);
1: 		extent.writeExternal(logicalDataOut);
1: 	}
1: 
1: 	/*
1: 	 * borrowed space management
1: 	 */
1: 
1: 	/**
1: 		Write the container information into the container information area.
1: 
1: 		@param containerInfo the container information
1: 
1: 		@param epage the allocation page data which may not be fully formed,
1: 		but is guarenteed to be big enough to cover the area inhibited by the
1: 		container info
1: 
1: 		@param create if create, write out the length of the container info
1: 		also. Else check to make sure epage's original container info is of the
1: 		same length
1: 
0: 		@exception StandardException Cloudscape standard error policy
1: 	*/
1: 	public static void WriteContainerInfo(byte[] containerInfo,
1: 										  byte[] epage,
1: 										  boolean create)
1: 		 throws StandardException
1: 	{
1: 		int N = (containerInfo == null) ? 0 : containerInfo.length;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (create)
1: 				SanityManager.ASSERT(
1:                     containerInfo != null, "containerInfo is null");
1: 
1: 			SanityManager.ASSERT(epage != null, "page array is null");
1: 
1:             if (!((containerInfo == null) ||
1:                   ((containerInfo.length + BORROWED_SPACE_OFFSET + 
1:                       BORROWED_SPACE_LEN) < epage.length))) 
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "containerInfo too big for page array: " + 
1:                     containerInfo.length);
1:             }
1: 
1: 			if (BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + N >=
1: 															MAX_BORROWED_SPACE)
1: 				SanityManager.THROWASSERT(
1: 								 "exceed max borrowable space: " + N);
1:         }
1: 
1:         if ((N + BORROWED_SPACE_LEN + BORROWED_SPACE_OFFSET) > epage.length)
1:         {
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.THROWASSERT(
1: 				   "exceed max borrowable space on page: " + N);
1: 		}
1: 
1: 		if (create)
1: 		{
1: 			epage[BORROWED_SPACE_OFFSET] = (byte)N;
1: 		}
1: 		else
1: 		{
1: 			int oldN = (int)epage[BORROWED_SPACE_OFFSET];
1: 			if (oldN != N)
1:             {
1: 				throw StandardException.newException(
1:                         SQLState.DATA_CHANGING_CONTAINER_INFO, 
0:                         new Long(oldN), 
0:                         new Long(N));
1:             }
1: 		}
1: 
1: 		if (N != 0)
1: 			System.arraycopy(containerInfo, 0, epage,
1: 							 BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN,
1: 							 N);
1: 	}
1: 
1: 	/**
1: 		Extract the container information from epage.
1: 
1: 		@param containerInfo where to put the extracted information
1: 
1: 		@param epage the allocation page which has the container information.
1: 		Epage may not be fully formed, but is guarenteed to be big enough to
1: 		cover the area inhibited by the container info
1: 	*/
1: 	public static void ReadContainerInfo(byte[] containerInfo,
1: 										 byte[] epage)
1: 	{
1: 		int N = (int)epage[BORROWED_SPACE_OFFSET];
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (N != containerInfo.length)
1: 				SanityManager.THROWASSERT("N not what is expected : " +  N);
1: 
1: 			if (BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + N
1: 								 						>= MAX_BORROWED_SPACE)
1:             {
1: 				SanityManager.THROWASSERT("exceed max borrowable space: " + N);
1:             }
1: 		}
1: 
1: 		if (N != 0)
0: 			System.arraycopy(epage, BORROWED_SPACE_OFFSET+BORROWED_SPACE_LEN,
0: 							 containerInfo, 0, N);
1: 	}
1: 
1: 
1: 	/*
1: 	 * specific methods to AllocPage
1: 	 */
1: 
1: 	/**
1: 		Return the next free page number after given page number 
1: 	 */
1: 	public long nextFreePageNumber(long pnum)
1: 	{
1: 		return extent.getFreePageNumber(pnum);
1: 	}
1: 
1: 
1: 	/**
1: 		Add a page which is managed by this alloc page.
1: 		Return the page number of the newly added page.
1: 
1: 		<BR> MT - thread aware (latched)
1: 
0: 		@param container (future) allows the alloc page to call back to the
1: 			container to grow the container by creating and syncing multiple
1: 			pages at once
1: 		@param ntt the nested top action that is the allocation transaction.
1: 			NTT will comit before the user transaction
1: 		@param userHandle the container handle that is opened by the user
1: 			transaction.  Use the userHandle to latch the new page so that
1: 			it may remain latched after NTT is committed so the user
1: 			transaction can guarentee to have an empty page
1: 
1: 		@exception StandardException If the page cannot be added
1: 	*/
1: 	public void addPage(FileContainer mycontainer, long newPageNumber, 
1: 						RawTransaction ntt, BaseContainerHandle userHandle) throws StandardException
1: 	{
1: 		// RESOLVED:
1: 		// 
1: 		// to prevent allocating a free page before the freeing transaction has
1: 		// commit, need to grab the DEALLOCATE_PROTECTION_HANDLE
1: 		// the lock probably should be gotten in FileContainer 
1: 		// and not here
1: 
1: 		// page allocation is logged under the nested top action
1: 		owner.getAllocationActionSet().
1: 			actionAllocatePage(
1:                 ntt, this, newPageNumber, 
1:                 AllocExtent.ALLOCATED_PAGE, AllocExtent.FREE_PAGE);
1: 	}
1: 
1: 
1: 	/*
1: 		Deallocate page
1: 	*/
1: 	public void deallocatePage(BaseContainerHandle userHandle, long pageNumber)
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(isLatched());
1: 		}
1: 
1: 		// RESOLVED:
1: 		//
1: 		// to prevent this page from being freed before this transaction commits,
1: 		// need to grab the DEALLOCATE_PROTECTION_HANDLE lock on the
1: 		// deallocated page
1: 		// the lock probably should be gotten in FileContainer 
1: 		// and not here
1: 
1: 		owner.getAllocationActionSet().
1: 			actionAllocatePage(userHandle.getTransaction(),
1: 							   this, pageNumber, AllocExtent.DEALLOCATED_PAGE,
1: 							   AllocExtent.ALLOCATED_PAGE); 
1: 	}
1: 
1: 	/*
1: 	 * update unfilled page information
1: 	 * We will be using inputExtent's unfilledPage bitmap as the new bitmap, so
1: 	 * caller of this routine need to not touch the bitmap after this call (in
1: 	 * other words, call this ONLY in allocationCache invalidate and throw away
1: 	 * the reference to the bitImpl)
1: 	 */
1: 	protected void updateUnfilledPageInfo(AllocExtent inputExtent) 
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(isLatched());
1: 		}
1: 
1: 		// update the unfilled page bit map unlogged - it is just a hint, not
1: 		// worth logging it - don't dirty the page either, since we didn't log
1: 		// it.  It will be dirtied soon enough by addPage or deallocPage,
1: 		// that is the only reasons why we are invalidataing the
1: 		// allocation cache and updating the unfilled page info. 
1: 		// If we dirty the page, the BI will be copied to the side log
1: 		extent.updateUnfilledPageInfo(inputExtent);
1: 
1: 	}
1: 
1: 	public boolean canAddFreePage(long lastAllocatedPage)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isLatched());
1: 
1: 		if (extent.isRetired())
1: 			return false;
1: 
1: 		// if we want to try allocating not from the beginning of the bit map
1: 		// and this alloc page is before that point and this is not the last
1: 		// alloc page, then skip over this alloc page
1: 		if (lastAllocatedPage != ContainerHandle.INVALID_PAGE_NUMBER && 
1: 			extent.getLastPagenum() <= lastAllocatedPage && 
1: 			!isLast())
1: 			return false;
1: 
1: 		// Else we either want to start examining from this alloc page, or this
1: 		// is the last page, see if we can add a page.
1: 		return extent.canAddFreePage(lastAllocatedPage);
1: 	}
1: 
1: 	public long getNextAllocPageOffset()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(
1:                 !isLast(), "next alloc page not present for last alloc page");
1: 
1: 			SanityManager.ASSERT(isLatched());
1: 		}
1: 
1: 		return nextAllocPageOffset;
1: 	}
1: 
1: 	public void chainNewAllocPage(BaseContainerHandle allocHandle,
1: 								  long newAllocPageNum, long newAllocPageOffset)
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isLatched());
1: 			if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1: 				SanityManager.DEBUG(FileContainer.SPACE_TRACE,
1: 									"chaining new alloc page " +
1: 									newAllocPageNum + " to " +
1: 									getPageNumber());
1: 		}
1: 
1: 		owner.getAllocationActionSet().
1: 			actionChainAllocPage(allocHandle.getTransaction(),
1: 								 this, newAllocPageNum, newAllocPageOffset);
1: 	}
1: 
1: 	public long getNextAllocPageNumber()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isLatched());
1: 			SanityManager.ASSERT(
1:                 !isLast(), "next alloc page not present for last alloc page");
1: 		}
1: 		return nextAllocPageNumber;
1: 	}
1: 
1: 	public boolean isLast()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isLatched());
1: 		return nextAllocPageNumber == ContainerHandle.INVALID_PAGE_NUMBER;
1: 	}
1: 
1: 	/*
1: 	 * get the last pagenumber currently managed by this alloc page
1: 	 */
1: 	public long getLastPagenum()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isLatched());
1: 
1: 		return extent.getLastPagenum();
1: 	}
1: 
1: 	/*
1: 	 * get the largest page number this alloc page can manage. 
1: 	 * This is the different from the last pagenumber currently managed by this
1: 	 * alloc page unless the alloc page is full and all the pages have been
1: 	 * allocated 
1: 	 */
1: 	public long getMaxPagenum()
1: 	{
1: 		return extent.getExtentEnd();
1: 	}
1: 
1: 	/*
1: 	 * get the last preallocated pagenumber managed by this alloc page
1: 	 */
1: 	protected long getLastPreallocPagenum()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isLatched());
1: 
1: 		return extent.getLastPreallocPagenum();
1: 	}
1: 
1: 
1: 	protected int getPageStatus(long pageNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isLatched());
1: 
1: 		return extent.getPageStatus(pageNumber);
1: 	}
1: 
1: 
1: 	/**
1: 		Do the actual page allocation/deallocation/ree underneath a log operation.
1: 		Change the page status to new status
1: 
1: 		@exception StandardException If the page cannot be allocated
1: 	*/
1: 	protected void setPageStatus(LogInstant instant, long pageNumber, int newStatus) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1: 			SanityManager.ASSERT(extent != null, "extent is null");
1: 		}
1: 
1: 		logAction(instant);
1: 
1: 		switch(newStatus)
1: 		{
1: 		case AllocExtent.ALLOCATED_PAGE:
1: 			extent.allocPage(pageNumber);
1: 			break;
1: 		case AllocExtent.DEALLOCATED_PAGE:
1: 			extent.deallocPage(pageNumber);
1: 			break;
1: 		case AllocExtent.FREE_PAGE:
1: 			extent.deallocPage(pageNumber);
1: 			break;
1: 		}
1: 	}
1: 
1: 	/**
1: 		Chain the next page number and offset underneath a log record
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected void chainNextAllocPage(LogInstant instant,
1: 									  long newAllocPageNum,
1: 									  long newAllocPageOffset)
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1: 
1: 		logAction(instant);
1: 
1: 		nextAllocPageNumber = newAllocPageNum;
1: 		nextAllocPageOffset = newAllocPageOffset;
1: 	}
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			String str = "*** Alloc page ***\n" + super.toString();
1: 			return str;
1: 		}
1: 		else
1: 			return null;
1: 	}
1: 
1: 
1: 	/**
1: 		Return a copy of the allocExtent to be cached by the container.
1: 		the container must take care to maintain its coherency by
1: 		invalidating the cache before any update.
1: 	*/
1: 	protected AllocExtent getAllocExtent()
1: 	{
1: 		return extent;
1: 
1: 		// return new AllocExtent(extent);
1: 	}
1: 
1: 	/**
1: 		Preallocate user page if needed.
1: 
0: 		@param myContainer the container object
1: 		@param preAllocThreshold start preallocating after this threshold
1: 		@param preAllocSize preallocate this number of pages 
1: 	*/
1: 	protected void preAllocatePage(FileContainer myContainer,
1: 								   int preAllocThreshold,
1: 								   int preAllocSize)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isLatched(), "page is not latched");
1: 
1: 		long lastPreallocatedPagenum = extent.getLastPreallocPagenum();
1: 
1: 		if (lastPreallocatedPagenum < preAllocThreshold)
1: 			return;
1: 
1: 		// don't pre-allocate more than we the extent can handle - this is
1: 		// because if I preallocate the next alloc page as a stored page,
1: 		// that's going to be problem when we try to get it as an alloc page
1: 		// later.  We don't handle changing from a store page type to an alloc
1: 		// page type on disk very well.
1: 		if (extent.getExtentEnd() < (lastPreallocatedPagenum+preAllocSize))
1: 			preAllocSize = (int)(extent.getExtentEnd() - lastPreallocatedPagenum);
1: 
1: 		if (preAllocSize <= 0)
1: 			return;
1: 
1: 		// pre-allocate - only a container knows how to write pages
1: 		// preAllocSize may exceed what this allocation page can really
1: 		// handle, but no harm done.  The next allocation page will benefit
1: 		// from the work we have done...
1: 		int n = myContainer.preAllocate(lastPreallocatedPagenum, preAllocSize);
1: 		
1: 		if (n > 0) 				// successfully preallocated some pages
1: 		{
1: 			// this is purely a performance issue during runtime.  During
1: 			// recovery, any page that is actually initialized will have its
1: 			// own initPage log record.  Update extent's preAllocpageNumber
1: 			// unlogged.
1: 			//
1: 			// We could have logged a redo-only log record, but we are counting
1: 			// on myContainer.preAllocate to do the right thing if we recovered
1: 			// and have out of date preallocate information.  A reason why
1: 			// logging this is undesirable is that the alloc page may think the
1: 			// preallocation happened, but the container may actually choose to
1: 			// lie about it - if it thinks there is no advantage in actually
1: 			// doing the I/O now.  So best to leave it alone.
1: 			extent.setLastPreallocPagenum(lastPreallocatedPagenum + n);
1: 
1: 			// don't dirty the page - the new preAlloc page number is only set
1: 			// in memory.  A page should only get 'dirtied' by a log operation,
1: 			// we are cheating here.  Same with updating the extentStatus bit
1: 			// without logging.
1: 		}
1: 
1: 	}
1: 
1: 
1: 
1: 	/*********************************************************************
1: 	 * Extent Testing
1: 	 *
1: 	 * Use these strings to simulate error conditions for
1: 	 * testing purposes.
1: 	 *
1: 	 *********************************************************************/
1: 	public static final String TEST_MULTIPLE_ALLOC_PAGE = SanityManager.DEBUG ? "TEST_MULTI_ALLOC_PAGE" : null;
1: 
1: }
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.TypedFormat;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.Loggable;
0: import org.apache.derby.iapi.store.raw.PageKey;
0: import org.apache.derby.iapi.store.raw.PageTimeStamp;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: 
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
0: 
0: import org.apache.derby.impl.store.raw.data.BaseContainerHandle;
0: import org.apache.derby.impl.store.raw.data.BasePage;
0: import org.apache.derby.impl.store.raw.data.PageVersion;
0: 
0: import java.io.IOException;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: /**
0: 	An allocation page of the file container.
0: 	<P>
0: 	This class extends a normal Stored page, with the exception that a hunk of
0: 	space may be 'borrowed' by the file container to store the file header.
0: 	<P>
0: 	The borrowed space is not visible to the alloc page even though it is
0: 	present in the page data array.  It is accessed directly by the
0: 	FileContainer.  Any change made to the borrowed space is not managed or
0: 	seen by the allocation page.
0: 	<P
0: 	The reason for having this borrowed space is so that the container header
0: 	does not need to have a page of its own.
0: 
0: 	<P><B>Page Format</B><BR>
0: 	An allocation page extends a stored page, the on disk format is different
0: 	from a stored page in that N bytes are 'borrowed' by the container and the
0: 	page header of an allocation page will be slightly bigger than a normal
0: 	stored page.  This N bytes are stored between the page header and the 
0:     record space.
0: 	<P>
0: 	The reason why this N bytes can't simply be a row is because it needs to be
0: 	statically accessible by the container object to avoid a chicken and egg
0: 	problem of the container object needing to instantiate an alloc page object
0: 	before it can be objectified, and an alloc page object needing to
0: 	instantiate a container object before it can be objectified.  So this N
0: 	bytes must be stored outside of the normal record interface yet it must be
0: 	settable because only the first alloc page has this borrowed space.  Other
0: 	(non-first) alloc page have N == 0.
0: 
0: 	<PRE>
0:                              <-- borrowed ->
0: 	+----------+-------------+---+---------+-------------------+-------------+--------+
0: 	| FormatId | page header | N | N bytes | alloc extend rows | slot offset |checksum|
0: 	+----------+-------------+---+---------+-------------------+-------------+--------+
0: 	</PRE>
0: 
0: 	N is a byte that indicates the size of the borrowed space.  Once an alloc
0: 	page is initialized, the value of N cannot change.
0: 	<P>
0: 	The maximum space that can be borrowed by the container is 256 bytes.
0: 	<P>
0: 	The allocation page are of the same page size as any other pages in the
0: 	container. The first allocation page of the FileContainer starts at the
0: 	first physical byte of the container.  Subsequent allocation pages are
0: 	chained via the nextAllocPageOffset.  Each allocation page is expected to
0: 	manage at least 1000 user pages (for 1K page size) so this chaining may not
0: 	be a severe performance hit.  The logical -> physical mapping of an
0: 	allocation page is stored in the previous allocation page.  The container
0: 	object will need to maintain this mapping.
0: 	<P>
0: 	The following fields are stored in the page header
0: 	<PRE>
0: 	@format_id	RAW_STORE_ALLOC_PAGE
0: 	@purpose	manage page allocation
0: 	@upgrade
0: 	@disk_layout
0: 		FormatId(int)
0: 		StoredPageHeader	see StoredPage
0: 		nextAllocPageNubmer(long)	the next allocation page's number
0: 		nextAllocPageOffset(long)	the file offset of the next allocation page
0: 		reserved1(long)				reserved for future usage
0: 		reserved2(long)				reserved for future usage
0: 		reserved3(long)				reserved for future usage
0: 		reserved4(long)				reserved for future usage
0: 		N(byte)						the size of the borrowed container info
0: 		containerInfo(byte[N])		the content of the borrowed container info
0: 		AllocExtent					the one and only extent on this alloc page
0: 
0: 	@end_format
0: 	</PRE>
0: 
0: 	<P>
0: 	The allocation page contains allocation extent rows.  In this first cut
0: 	implementation, there is only 1 allocation extent row per allocation page.
0: 	<P>
0: 	The allocation extent row is an externalizable object and is directly
0: 	written on to the page by the alloc page.  In other words, it will not be
0: 	converted in to a storeableRow.  This is to cut down overhead, enhance
0: 	performance and gives more control of the size and layout of the allocation
0: 	extent row to the alloc page.
0: 	<P>
0: 	<HR WIDTH="100%">
0: 	<BR> DETAIL implmentation notes <BR>
0: 	<HR WIDTH="100%">
0: 	<P>
0: 	Create Container - an embryonic allocation page is formatted on disk by a
0: 	spcial static function to avoid instantiating a full AllocPage object.
0: 	This embryonic allocation has enough information that it can find the
0: 	file header and not much else.  Then the allocation page is perperly
0: 	initiated by creating the first extent.
0: 	<P>
0: 	Open Container - A static AllocPage method will be used to read off the
0: 	container information directly from disk.  Even if
0: 	the first alloc page (page 0) is already in the page cache, it will not be
0: 	used because cleaning the alloc page will introduce a deadlock if the
0: 	container is not in the container cache.  Long term, the first alloc page
0: 	should probably live in the container cache rather than in the page cache.
0: 	<P>
0: 	Get Page - The first alloc page (page 0) will be read into the page cache.
0: 	Continue to follow the alloc page chain until the alloc page that manages
0: 	the specified page is found.  From the alloc page, the physical offset of
0: 	the specified page is located.
0: 	<P>
0: 	Cleaning alloc page - the alloc page is written out the same way any page
0: 	is written out.  The container object will provide a call back to the alloc
0: 	page to write the current version of the container object back into the
0: 	borrowed space before the alloc page itself is written out.
0: 	<P>
0: 	Cleaning the container object - get the the first alloc page, dirty it and
0: 	clean it (which will cause it to call the container object to write itself
0: 	out into the borrowed space).  The versioning of the container is
0: 	independent of the versioning of the alloc page.  The container version is
0: 	stored inside the borrowed space and is opaque to the alloc page.
0: 	<P>
0: 	For the fields in an allocation extent row
0: 
0: 	@see AllocExtent
0: */
0: 
0: 
0: public class AllocPage extends StoredPage
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/*
0: 	 * typed format
0: 	 */
0: 	public static final int FORMAT_NUMBER = StoredFormatIds.RAW_STORE_ALLOC_PAGE;
0: 	// format Id must fit in 4 bytes
0: 
0: 	/**
0: 		Return my format identifier.
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.RAW_STORE_ALLOC_PAGE;
0: 	}
0: 
0: 	/*****************************************************************
0: 	 * alloc page header
0: 	 *****************************************************************/
0: 	private long nextAllocPageNumber;	// if isLast, nextAllocPageNumber == INVALID_PAGE_NUMBER
0: 	private long nextAllocPageOffset;
0: 	private long reserved1;
0: 	private long reserved2;
0: 	private long reserved3;
0: 	private long reserved4;
0: 
0: 	private AllocExtent extent;
0: 
0: 	private int borrowedSpace;
0: 
0: 	/*****************************************************************
0: 	 * constants
0: 	 *****************************************************************/
0: 
0: 	/*
0: 	 * allocation page header
0: 	 * 8 bytes	long	next alloc page number
0: 	 * 8 bytes	long	next alloc page physical offset
0: 	 * 8 bytes  long	reserved1
0: 	 * 8 bytes  long	reserved2
0: 	 * 8 bytes  long	reserved3
0: 	 * 8 bytes  long	reserved4
0: 	 */
0: 	protected static final int ALLOC_PAGE_HEADER_OFFSET =
0: 		StoredPage.PAGE_HEADER_OFFSET + StoredPage.PAGE_HEADER_SIZE;
0: 
0: 	protected static final int ALLOC_PAGE_HEADER_SIZE = 8+8+(4*8);
0: 
0: 	/* borrowed_SPACE_OFFSET is where the borrowed space len is kept */
0: 	protected static final int BORROWED_SPACE_OFFSET =
0: 		ALLOC_PAGE_HEADER_OFFSET + ALLOC_PAGE_HEADER_SIZE;
0: 
0: 	/* size of the borrowed space length */
0: 	protected static final int BORROWED_SPACE_LEN = 1; // 1 byte to store the containerInfo length
0: 
0: 	/*
0: 	 * BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN is the beginning offset of
0: 	 * the borrowed space
0: 	 */
0: 
0: 	/*
0: 	 * the entire borrowed space must live within MAX_BORROWED_SPACE of the
0: 	 * alloc page
0: 	 */
0: 	protected static final int MAX_BORROWED_SPACE =
0: 			RawStoreFactory.PAGE_SIZE_MINIMUM / 5; // cannot take more then 1/5 of the page
0: 
0: 	public AllocPage()
0: 	{
0: 		super();
0: 	}
0: 
0: 	/*
0: 	 * overwriting StoredPage methods
0: 	 */
0: 
0: 	protected int getMaxFreeSpace() {
0: 
0: 		// the maximum free space is reduced by the allocation page header the
0: 		// size of the borrowed space.  In all allocation page except the first
0: 		// one, there is no borrowed space and this is indeed the max free
0: 		// space.  In the first allocation page, need to further subtract
0: 		// the borrowed space
0: 
0: 		return super.getMaxFreeSpace() - ALLOC_PAGE_HEADER_SIZE -
0: 			BORROWED_SPACE_LEN - borrowedSpace;
0: 	}
0: 
0: 
0: 	/*
0: 	 * Methods of cachedPage - create, read and write up a page
0: 	 * Overwriting StoredPage's CachedPage methods
0: 	 */
0: 
0:     /**
0:      * Create a new alloc page.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected void createPage(PageKey newIdentity, int[] args) 
0: 		 throws StandardException
0: 	{
0: 
0: 		super.createPage(newIdentity, args);
0: 
0: 		// args[0] is the format id
0: 		// args[1] is whether to sync the page to disk or not
0: 		// args[2] is the pagesize (used by StoredPage)
0: 		// args[3] is the spareSize (used by StoredPage)
0: 		// args[4] is the number of bytes to reserve for container header
0: 		// args[5] is the minimumRecordSize
0: 		// NOTE: the arg list here must match the one in FileContainer
0: 		int pageSize = args[2];
0: 		int minimumRecordSize = args[5];
0: 		borrowedSpace = args[4];
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			// MAX_BORROWED_SPACE can't be bigger than what can be represented in 1 byte space
0: 			SanityManager.ASSERT(MAX_BORROWED_SPACE <= 255);
0: 
0:             if (!(borrowedSpace + BORROWED_SPACE_LEN + BORROWED_SPACE_OFFSET 
0:                     < MAX_BORROWED_SPACE))
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "borrowedSpace too big = " + borrowedSpace);
0:             }
0: 			SanityManager.ASSERT(pageData != null);
0: 		}
0: 		pageData[BORROWED_SPACE_OFFSET] = (byte)borrowedSpace;
0: 
0: 		// remember that the borrowed space have been wiped out now, it
0: 		// needs to be put back when the page is written out.
0: 		// blot out borrowed space before checksum is verified
0: 		if (borrowedSpace > 0)
0: 		{
0: 			clearSection(BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN, borrowedSpace);
0: 		}
0: 
0: 		// init the rest of the header and the allocation extent
0: 		nextAllocPageNumber = ContainerHandle.INVALID_PAGE_NUMBER;
0: 		nextAllocPageOffset = 0;
0: 		reserved1 = reserved2 = reserved3 = reserved4 = 0;
0: 
0: 		// calculate how much space we have left for the extent map
0: 		int maxSpace = getMaxFreeSpace();
0: 
0: 		// the pages this extent is going to manage starts from pageNum+1
0: 		// starting physical offset is pageSize*(pageNum+1) since we have
0: 		// no logical to physical mapping yet...
0: 		extent = createExtent(newIdentity.getPageNumber()+1, pageSize, 0 /* pagesAlloced */, maxSpace);
0: 	}
0: 
0: 	private AllocExtent createExtent(long pageNum, int pageSize, int pagesAlloced, int availspace)
0: 	{
0: 		int maxPages = AllocExtent.MAX_RANGE(availspace);
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(maxPages > 8, "cannot manage > 8 pages");
0: 
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(TEST_MULTIPLE_ALLOC_PAGE))
0:             {
0:                 maxPages = 2;		// 2 pages per alloc page
0:             }
0:         }
0: 
0: 		return new AllocExtent(pageNum*pageSize,	 		// starting offset
0: 							   pageNum,					// extent start page number
0: 							   pagesAlloced,				// #pages already allocated
0: 							   pageSize, 					// page size
0: 							   maxPages);					// max #pages to manage
0: 	}
0: 
0: 	/**
0: 		Initialize in memory structure using the buffer in pageData
0: 
0: 		@exception StandardException If the page cannot be read correctly, or is inconsistent.
0: 	*/
0: 	protected void initFromData(FileContainer myContainer, PageKey newIdentity)
0: 		 throws StandardException
0: 	{
0: 		if (pageData.length < BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN)
0:         {
0: 			throw dataFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.DATA_CORRUPT_PAGE, newIdentity));
0:         }
0: 
0: 		byte n = pageData[BORROWED_SPACE_OFFSET];
0: 		borrowedSpace = (int)n;
0: 
0: 		if (pageData.length < BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + n)
0:         {
0: 			throw dataFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.DATA_CORRUPT_PAGE, newIdentity));
0:         }
0: 
0: 		// blot out borrowed space before checksum is verified
0: 		if (borrowedSpace > 0)
0: 		{
0: 			clearSection(BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN, borrowedSpace);
0: 		}
0: 
0: 		super.initFromData(myContainer, newIdentity);
0: 
0: 		try
0: 		{
0: 			// now init alloc page header fields
0: 			readAllocPageHeader();
0: 
0: 			// now init the allocation extent - read it from offset
0: 			int offset = BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + borrowedSpace;
0: 			extent = readExtent(offset);
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			throw dataFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.DATA_CORRUPT_PAGE, ioe, newIdentity));
0: 		}
0: 		catch (ClassNotFoundException cnfe)
0: 		{
0: 			throw dataFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.DATA_CORRUPT_PAGE, cnfe, newIdentity));
0: 		}
0: 	}
0: 
0: 	/**
0: 		Write the page out
0: 
0: 		@exception StandardException If the page cannot be written
0: 	*/
0: 	protected void writePage(PageKey identity) throws StandardException
0: 	{
0: 		try
0: 		{
0: 			updateAllocPageHeader(); // write out the next alloc page chain
0: 
0: 			// blot out borrowed space before checksum is calculated - even
0: 			// though the page is first read in with borrowed space blotted
0: 			// out, whenever this page got cleaned the container will overlay
0: 			// the container info in the borrowed space.
0: 			int n = (int)pageData[BORROWED_SPACE_OFFSET];
0:             if (SanityManager.DEBUG)
0:             {
0:     			if (n != borrowedSpace)
0:     				SanityManager.THROWASSERT(
0:                         "different borrowed space " + n + ", " + borrowedSpace);
0: 	    	}
0: 			if (n > 0)
0: 			{
0: 				clearSection(BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN, n);
0: 			}
0: 
0: 			int offset = BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + n;
0: 			writeExtent(offset);
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			// i/o methods on the byte array have thrown an IOException
0: 			throw dataFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.DATA_CORRUPT_PAGE, ioe, identity));
0: 		}
0: 
0: 		// let store page write out the rest and do the checksum
0: 		super.writePage(identity);
0: 	}
0: 
0: 
0: 	private void readAllocPageHeader() throws IOException
0: 	{
0: 		ArrayInputStream lrdi = rawDataIn;
0: 		lrdi.setPosition(ALLOC_PAGE_HEADER_OFFSET);
0: 
0: 		nextAllocPageNumber = lrdi.readLong();
0: 		nextAllocPageOffset = lrdi.readLong();
0: 		reserved1 = lrdi.readLong();
0: 		reserved2 = lrdi.readLong();
0: 		reserved3 = lrdi.readLong();
0: 		reserved4 = lrdi.readLong();
0: 	}
0: 
0: 	private void updateAllocPageHeader() throws IOException
0: 	{
0: 		// rawDataOut and logicalDataOut are defined by StoredPage
0: 		rawDataOut.setPosition(ALLOC_PAGE_HEADER_OFFSET);
0: 		logicalDataOut.writeLong(nextAllocPageNumber);
0: 		logicalDataOut.writeLong(nextAllocPageOffset);
0: 		logicalDataOut.writeLong(0); // reserved1
0: 		logicalDataOut.writeLong(0); // reserved2
0: 		logicalDataOut.writeLong(0); // reserved3
0: 		logicalDataOut.writeLong(0); // reserved4
0: 	}
0: 
0: 	private AllocExtent readExtent(int offset)
0: 		 throws IOException, ClassNotFoundException
0: 	{
0: 		ArrayInputStream lrdi = rawDataIn;
0: 		rawDataIn.setPosition(offset);
0: 		AllocExtent newExtent = new AllocExtent();
0: 		newExtent.readExternal(lrdi);
0: 
0: 		// in 1.3 or later, make sure the upgrade from before 1.3 is legal.
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			int max_range = newExtent.MAX_RANGE(getMaxFreeSpace());
0: 			long extent_start = newExtent.getFirstPagenum();
0: 			long extent_end = newExtent.getExtentEnd();
0: 
0: 			// extent_start + max_range - 1 is the absolute last page this
0: 			// extent can hope to manage.  See if it did the calculation
0: 			// correctly after upgrade.
0: 
0:             if ((extent_start+max_range-1) < extent_end)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "extent range exceed what extent's space can handle ");
0:             }
0: 		}
0: 
0: 		return newExtent;
0: 	}
0: 
0: 	private void writeExtent(int offset) throws IOException
0: 	{
0: 		// rawDataOut and logicalDataOut are defined by StoredPage
0: 		rawDataOut.setPosition(offset);
0: 		extent.writeExternal(logicalDataOut);
0: 	}
0: 
0: 	/*
0: 	 * borrowed space management
0: 	 */
0: 
0: 	/**
0: 		Write the container information into the container information area.
0: 
0: 		@param containerInfo the container information
0: 
0: 		@param epage the allocation page data which may not be fully formed,
0: 		but is guarenteed to be big enough to cover the area inhibited by the
0: 		container info
0: 
0: 		@param create if create, write out the length of the container info
0: 		also. Else check to make sure epage's original container info is of the
0: 		same length
0: 
0: 		@exception StandardException Cloudscape standard error policy
0: 	*/
0: 	public static void WriteContainerInfo(byte[] containerInfo,
0: 										  byte[] epage,
0: 										  boolean create)
0: 		 throws StandardException
0: 	{
0: 		int N = (containerInfo == null) ? 0 : containerInfo.length;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (create)
0: 				SanityManager.ASSERT(
0:                     containerInfo != null, "containerInfo is null");
0: 
0: 			SanityManager.ASSERT(epage != null, "page array is null");
0: 
0:             if (!((containerInfo == null) ||
0:                   ((containerInfo.length + BORROWED_SPACE_OFFSET + 
0:                       BORROWED_SPACE_LEN) < epage.length))) 
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "containerInfo too big for page array: " + 
0:                     containerInfo.length);
0:             }
0: 
0: 			if (BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + N >=
0: 															MAX_BORROWED_SPACE)
0: 				SanityManager.THROWASSERT(
0: 								 "exceed max borrowable space: " + N);
0:         }
0: 
0:         if ((N + BORROWED_SPACE_LEN + BORROWED_SPACE_OFFSET) > epage.length)
0:         {
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT(
0: 				   "exceed max borrowable space on page: " + N);
0: 		}
0: 
0: 		if (create)
0: 		{
0: 			epage[BORROWED_SPACE_OFFSET] = (byte)N;
0: 		}
0: 		else
0: 		{
0: 			int oldN = (int)epage[BORROWED_SPACE_OFFSET];
0: 			if (oldN != N)
0:             {
0: 				throw StandardException.newException(
0:                         SQLState.DATA_CHANGING_CONTAINER_INFO, 
0:                         new Long(oldN), 
0:                         new Long(N));
0:             }
0: 		}
0: 
0: 		if (N != 0)
0: 			System.arraycopy(containerInfo, 0, epage,
0: 							 BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN,
0: 							 N);
0: 	}
0: 
0: 	/**
0: 		Extract the container information from epage.
0: 
0: 		@param containerInfo where to put the extracted information
0: 
0: 		@param epage the allocation page which has the container information.
0: 		Epage may not be fully formed, but is guarenteed to be big enough to
0: 		cover the area inhibited by the container info
0: 	*/
0: 	public static void ReadContainerInfo(byte[] containerInfo,
0: 										 byte[] epage)
0: 	{
0: 		int N = (int)epage[BORROWED_SPACE_OFFSET];
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (N != containerInfo.length)
0: 				SanityManager.THROWASSERT("N not what is expected : " +  N);
0: 
0: 			if (BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + N
0: 								 						>= MAX_BORROWED_SPACE)
0:             {
0: 				SanityManager.THROWASSERT("exceed max borrowable space: " + N);
0:             }
0: 		}
0: 
0: 		if (N != 0)
0: 			System.arraycopy(epage, BORROWED_SPACE_OFFSET+BORROWED_SPACE_LEN,
0: 							 containerInfo, 0, N);
0: 	}
0: 
0: 
0: 	/*
0: 	 * specific methods to AllocPage
0: 	 */
0: 
0: 	/**
0: 		Return the next free page number after given page number 
0: 	 */
0: 	public long nextFreePageNumber(long pnum)
0: 	{
0: 		return extent.getFreePageNumber(pnum);
0: 	}
0: 
0: 
0: 	/**
0: 		Add a page which is managed by this alloc page.
0: 		Return the page number of the newly added page.
0: 
0: 		<BR> MT - thread aware (latched)
0: 
0: 		@param container (future) allows the alloc page to call back to the
0: 			container to grow the container by creating and syncing multiple
0: 			pages at once
0: 		@param ntt the nested top action that is the allocation transaction.
0: 			NTT will comit before the user transaction
0: 		@param userHandle the container handle that is opened by the user
0: 			transaction.  Use the userHandle to latch the new page so that
0: 			it may remain latched after NTT is committed so the user
0: 			transaction can guarentee to have an empty page
0: 
0: 		@exception StandardException If the page cannot be added
0: 	*/
0: 	public void addPage(FileContainer mycontainer, long newPageNumber, 
0: 						RawTransaction ntt, BaseContainerHandle userHandle) throws StandardException
0: 	{
0: 		// RESOLVED:
0: 		// 
0: 		// to prevent allocating a free page before the freeing transaction has
0: 		// commit, need to grab the DEALLOCATE_PROTECTION_HANDLE
0: 		// the lock probably should be gotten in FileContainer 
0: 		// and not here
0: 
0: 		// page allocation is logged under the nested top action
0: 		owner.getAllocationActionSet().
0: 			actionAllocatePage(
0:                 ntt, this, newPageNumber, 
0:                 AllocExtent.ALLOCATED_PAGE, AllocExtent.FREE_PAGE);
0: 	}
0: 
0: 
0: 	/*
0: 		Deallocate page
0: 	*/
0: 	public void deallocatePage(BaseContainerHandle userHandle, long pageNumber)
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(isLatched());
0: 		}
0: 
0: 		// RESOLVED:
0: 		//
0: 		// to prevent this page from being freed before this transaction commits,
0: 		// need to grab the DEALLOCATE_PROTECTION_HANDLE lock on the
0: 		// deallocated page
0: 		// the lock probably should be gotten in FileContainer 
0: 		// and not here
0: 
0: 		owner.getAllocationActionSet().
0: 			actionAllocatePage(userHandle.getTransaction(),
0: 							   this, pageNumber, AllocExtent.DEALLOCATED_PAGE,
0: 							   AllocExtent.ALLOCATED_PAGE); 
0: 	}
0: 
0: 	/*
0: 	 * update unfilled page information
0: 	 * We will be using inputExtent's unfilledPage bitmap as the new bitmap, so
0: 	 * caller of this routine need to not touch the bitmap after this call (in
0: 	 * other words, call this ONLY in allocationCache invalidate and throw away
0: 	 * the reference to the bitImpl)
0: 	 */
0: 	protected void updateUnfilledPageInfo(AllocExtent inputExtent) 
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(isLatched());
0: 		}
0: 
0: 		// update the unfilled page bit map unlogged - it is just a hint, not
0: 		// worth logging it - don't dirty the page either, since we didn't log
0: 		// it.  It will be dirtied soon enough by addPage or deallocPage,
0: 		// that is the only reasons why we are invalidataing the
0: 		// allocation cache and updating the unfilled page info. 
0: 		// If we dirty the page, the BI will be copied to the side log
0: 		extent.updateUnfilledPageInfo(inputExtent);
0: 
0: 	}
0: 
0: 	public boolean canAddFreePage(long lastAllocatedPage)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isLatched());
0: 
0: 		if (extent.isRetired())
0: 			return false;
0: 
0: 		// if we want to try allocating not from the beginning of the bit map
0: 		// and this alloc page is before that point and this is not the last
0: 		// alloc page, then skip over this alloc page
0: 		if (lastAllocatedPage != ContainerHandle.INVALID_PAGE_NUMBER && 
0: 			extent.getLastPagenum() <= lastAllocatedPage && 
0: 			!isLast())
0: 			return false;
0: 
0: 		// Else we either want to start examining from this alloc page, or this
0: 		// is the last page, see if we can add a page.
0: 		return extent.canAddFreePage(lastAllocatedPage);
0: 	}
0: 
0: 	public long getNextAllocPageOffset()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(
0:                 !isLast(), "next alloc page not present for last alloc page");
0: 
0: 			SanityManager.ASSERT(isLatched());
0: 		}
0: 
0: 		return nextAllocPageOffset;
0: 	}
0: 
0: 	public void chainNewAllocPage(BaseContainerHandle allocHandle,
0: 								  long newAllocPageNum, long newAllocPageOffset)
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isLatched());
0: 			if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
0: 				SanityManager.DEBUG(FileContainer.SPACE_TRACE,
0: 									"chaining new alloc page " +
0: 									newAllocPageNum + " to " +
0: 									getPageNumber());
0: 		}
0: 
0: 		owner.getAllocationActionSet().
0: 			actionChainAllocPage(allocHandle.getTransaction(),
0: 								 this, newAllocPageNum, newAllocPageOffset);
0: 	}
0: 
0: 	public long getNextAllocPageNumber()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isLatched());
0: 			SanityManager.ASSERT(
0:                 !isLast(), "next alloc page not present for last alloc page");
0: 		}
0: 		return nextAllocPageNumber;
0: 	}
0: 
0: 	public boolean isLast()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isLatched());
0: 		return nextAllocPageNumber == ContainerHandle.INVALID_PAGE_NUMBER;
0: 	}
0: 
0: 	/*
0: 	 * get the last pagenumber currently managed by this alloc page
0: 	 */
0: 	public long getLastPagenum()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isLatched());
0: 
0: 		return extent.getLastPagenum();
0: 	}
0: 
0: 	/*
0: 	 * get the largest page number this alloc page can manage. 
0: 	 * This is the different from the last pagenumber currently managed by this
0: 	 * alloc page unless the alloc page is full and all the pages have been
0: 	 * allocated 
0: 	 */
0: 	public long getMaxPagenum()
0: 	{
0: 		return extent.getExtentEnd();
0: 	}
0: 
0: 	/*
0: 	 * get the last preallocated pagenumber managed by this alloc page
0: 	 */
0: 	protected long getLastPreallocPagenum()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isLatched());
0: 
0: 		return extent.getLastPreallocPagenum();
0: 	}
0: 
0: 
0: 	protected int getPageStatus(long pageNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isLatched());
0: 
0: 		return extent.getPageStatus(pageNumber);
0: 	}
0: 
0: 
0: 	/**
0: 		Do the actual page allocation/deallocation/ree underneath a log operation.
0: 		Change the page status to new status
0: 
0: 		@exception StandardException If the page cannot be allocated
0: 	*/
0: 	protected void setPageStatus(LogInstant instant, long pageNumber, int newStatus) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(isLatched(), "page is not latched");
0: 			SanityManager.ASSERT(extent != null, "extent is null");
0: 		}
0: 
0: 		logAction(instant);
0: 
0: 		switch(newStatus)
0: 		{
0: 		case AllocExtent.ALLOCATED_PAGE:
0: 			extent.allocPage(pageNumber);
0: 			break;
0: 		case AllocExtent.DEALLOCATED_PAGE:
0: 			extent.deallocPage(pageNumber);
0: 			break;
0: 		case AllocExtent.FREE_PAGE:
0: 			extent.deallocPage(pageNumber);
0: 			break;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Chain the next page number and offset underneath a log record
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected void chainNextAllocPage(LogInstant instant,
0: 									  long newAllocPageNum,
0: 									  long newAllocPageOffset)
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isLatched(), "page is not latched");
0: 
0: 		logAction(instant);
0: 
0: 		nextAllocPageNumber = newAllocPageNum;
0: 		nextAllocPageOffset = newAllocPageOffset;
0: 	}
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			String str = "*** Alloc page ***\n" + super.toString();
0: 			return str;
0: 		}
0: 		else
0: 			return null;
0: 	}
0: 
0: 
0: 	/**
0: 		Return a copy of the allocExtent to be cached by the container.
0: 		the container must take care to maintain its coherency by
0: 		invalidating the cache before any update.
0: 	*/
0: 	protected AllocExtent getAllocExtent()
0: 	{
0: 		return extent;
0: 
0: 		// return new AllocExtent(extent);
0: 	}
0: 
0: 	/**
0: 		Preallocate user page if needed.
0: 
0: 		@param myContainer the container object
0: 		@param preAllocThreshold start preallocating after this threshold
0: 		@param preAllocSize preallocate this number of pages 
0: 	*/
0: 	protected void preAllocatePage(FileContainer myContainer,
0: 								   int preAllocThreshold,
0: 								   int preAllocSize)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isLatched(), "page is not latched");
0: 
0: 		long lastPreallocatedPagenum = extent.getLastPreallocPagenum();
0: 
0: 		if (lastPreallocatedPagenum < preAllocThreshold)
0: 			return;
0: 
0: 		// don't pre-allocate more than we the extent can handle - this is
0: 		// because if I preallocate the next alloc page as a stored page,
0: 		// that's going to be problem when we try to get it as an alloc page
0: 		// later.  We don't handle changing from a store page type to an alloc
0: 		// page type on disk very well.
0: 		if (extent.getExtentEnd() < (lastPreallocatedPagenum+preAllocSize))
0: 			preAllocSize = (int)(extent.getExtentEnd() - lastPreallocatedPagenum);
0: 
0: 		if (preAllocSize <= 0)
0: 			return;
0: 
0: 		// pre-allocate - only a container knows how to write pages
0: 		// preAllocSize may exceed what this allocation page can really
0: 		// handle, but no harm done.  The next allocation page will benefit
0: 		// from the work we have done...
0: 		int n = myContainer.preAllocate(lastPreallocatedPagenum, preAllocSize);
0: 		
0: 		if (n > 0) 				// successfully preallocated some pages
0: 		{
0: 			// this is purely a performance issue during runtime.  During
0: 			// recovery, any page that is actually initialized will have its
0: 			// own initPage log record.  Update extent's preAllocpageNumber
0: 			// unlogged.
0: 			//
0: 			// We could have logged a redo-only log record, but we are counting
0: 			// on myContainer.preAllocate to do the right thing if we recovered
0: 			// and have out of date preallocate information.  A reason why
0: 			// logging this is undesirable is that the alloc page may think the
0: 			// preallocation happened, but the container may actually choose to
0: 			// lie about it - if it thinks there is no advantage in actually
0: 			// doing the I/O now.  So best to leave it alone.
0: 			extent.setLastPreallocPagenum(lastPreallocatedPagenum + n);
0: 
0: 			// don't dirty the page - the new preAlloc page number is only set
0: 			// in memory.  A page should only get 'dirtied' by a log operation,
0: 			// we are cheating here.  Same with updating the extentStatus bit
0: 			// without logging.
0: 		}
0: 
0: 	}
0: 
0: 
0: 
0: 	/*********************************************************************
0: 	 * Extent Testing
0: 	 *
0: 	 * Use these strings to simulate error conditions for
0: 	 * testing purposes.
0: 	 *
0: 	 *********************************************************************/
0: 	public static final String TEST_MULTIPLE_ALLOC_PAGE = SanityManager.DEBUG ? "TEST_MULTI_ALLOC_PAGE" : null;
0: 
0: }
0: 
============================================================================