1:a62e82e: /*
1:a62e82e: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ColumnDefaultsTest
5:a62e82e: 
1:a62e82e: Licensed to the Apache Software Foundation (ASF) under one or more
1:a62e82e: contributor license agreements.  See the NOTICE file distributed with
1:a62e82e: this work for additional information regarding copyright ownership.
1:a62e82e: The ASF licenses this file to You under the Apache License, Version 2.0
1:a62e82e: (the "License"); you may not use this file except in compliance with
1:a62e82e: the License.  You may obtain a copy of the License at
1:a62e82e: 
1:a62e82e: http://www.apache.org/licenses/LICENSE-2.0
1:a62e82e: 
1:a62e82e: Unless required by applicable law or agreed to in writing, software
1:a62e82e: distributed under the License is distributed on an "AS IS" BASIS,
1:a62e82e: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a62e82e: See the License for the specific language governing permissions and
1:a62e82e: limitations under the License.
1:a62e82e: 
1:a62e82e:  */
1:a62e82e: package org.apache.derbyTesting.functionTests.tests.lang;
1:a62e82e: 
1:1ae02c9: import java.sql.ResultSet;
1:a62e82e: import java.sql.SQLException;
1:a62e82e: import java.sql.Statement;
1:a62e82e: import junit.framework.Test;
1:f1c232e: import org.apache.derbyTesting.functionTests.util.Formatters;
1:a62e82e: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:a62e82e: import org.apache.derbyTesting.junit.TestConfiguration;
1:a62e82e: 
1:a62e82e: public final class ColumnDefaultsTest extends BaseJDBCTestCase {
1:a62e82e: 
1:a62e82e:     /**
1:a62e82e:      * Public constructor required for running test as standalone JUnit.
1:a62e82e:      */
1:a62e82e:     public ColumnDefaultsTest(String name)
4:a62e82e:     {
1:a62e82e:         super(name);
1:a62e82e:     }
1:a62e82e: 
1:a62e82e:     public static Test suite()
1:a62e82e:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ColumnDefaultsTest Test");
1:a62e82e:         suite.addTest(TestConfiguration.defaultSuite(ColumnDefaultsTest.class));
1:a62e82e:         return suite;
1:a62e82e:     }
1:a62e82e: 
1:a62e82e:     public void testNegativeTestsForColumnDefaults() throws Exception
1:a62e82e:     {
1:082f2ed:         Statement st = createStatement();
1:a62e82e:         
1:a62e82e:         //? in default
1:a62e82e:         assertStatementError("42X01", st,
1:a62e82e:             "create table neg(c1 int default ?)");
1:a62e82e:         
1:a62e82e:         // column reference in default
1:a62e82e:         
1:a62e82e:         assertStatementError("42X01", st,
1:a62e82e:             "create table neg(c1 int, c2 int default c1)");
1:a62e82e:         
1:a62e82e:         // subquery in default
1:a62e82e:         
1:a62e82e:         assertStatementError("42X01", st,
1:a62e82e:             "create table neg(c1 int default (values 1))");
1:a62e82e:         
1:a62e82e:         // type incompatibility at compile time
1:a62e82e:         
1:a62e82e:         assertStatementError("42821", st,
1:a62e82e:             "create table neg(c1 date default 1)");
1:a62e82e:         
1:a62e82e:         // type incompatibility at execution time bug 5585 - 
1:a62e82e:         // should fail at create table statement because the 
1:a62e82e:         // default value '1' is not valid
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             "create table neg(c1 int, c2 date default '1')");
1:a62e82e:         
1:a62e82e:         assertStatementError("22007", st, " insert into neg (c1) values 1");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " drop table neg");
1:a62e82e:         
1:a62e82e:         // bug 5203 - built-in functions are not be allowed in a 
1:a62e82e:         // constantExpression because DB2 UDB returns SQLSTATE 42894
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             "CREATE FUNCTION ASDF (DATA DOUBLE) RETURNS DOUBLE "
1:a62e82e:             + "EXTERNAL NAME 'java.lang.Math.sin' LANGUAGE JAVA "
1:a62e82e:             + "PARAMETER STYLE JAVA");
1:a62e82e:         
1:a62e82e:         //DEFAULT value or IDENTITY attribute value is not valid 
1:a62e82e:         
1:a62e82e:         assertStatementError("42894", st,
1:a62e82e:             " create table neg(c1 int default asdf(0))");
1:a62e82e:         
1:a62e82e:         //drop a table which does not exists fails
1:a62e82e:         assertStatementError("42Y55", st, " drop table neg");
1:a62e82e:         
1:a62e82e:         // DEFAULT only valid in VALUES within an insert
1:a62e82e:         
1:a62e82e:         assertStatementError("42Y85", st, "values default");
1:a62e82e:         
1:a62e82e:         assertStatementError("42Y85", st, " values 1, default");
1:a62e82e:         
1:a62e82e:         // alter table modify default
1:a62e82e:         
1:a62e82e:         st.executeUpdate( "create table neg(c1 date)");
1:a62e82e:         
1:a62e82e:         assertStatementError("42X01", st,
1:a62e82e:             " alter table neg modify x default null");
1:a62e82e:         
1:a62e82e:         assertStatementError("42821", st,
1:a62e82e:             " alter table neg add column x date default 1");
1:a62e82e:         
1:a62e82e:         // bug 5585 - should fail at alter table statement because 
1:a62e82e:         // the default value '1' is not valid
1:a62e82e:         
1:a62e82e:         st.executeUpdate( "alter table neg add column x date default '1'");
1:a62e82e:         
1:a62e82e:         assertStatementError("22007", st,
1:a62e82e:             " insert into neg (c1) values default");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " drop table neg");
1:a62e82e:         
1:a62e82e:         // too many values in values clause
1:a62e82e:         
1:a62e82e:         st.executeUpdate( "create table neg(c1 int default 10)");
1:a62e82e:         
1:a62e82e:         assertStatementError("42X06", st,
1:a62e82e:             " insert into neg values (1, default)");
1:a62e82e:         
1:a62e82e:         assertStatementError("42802", st,
1:a62e82e:             " insert into neg values (default, 1)");
1:c341dc4: 
1:c341dc4: 
1:c341dc4:         // DERBY-4426
1:c341dc4:         assertStatementError("42Y85", st,
1:c341dc4:             " insert into neg values (default) union values (default)");
1:c341dc4: 
1:c341dc4:         assertStatementError("42Y85", st,
1:c341dc4:             " insert into neg values (default) except values (default)");
1:c341dc4: 
1:c341dc4:         // Make sure sub-queries are inspected for illegal DEFAULT also.
1:c341dc4:         assertStatementError("42Y85", st,
1:c341dc4:             " insert into neg select * from (values default) t");
1:c341dc4: 
1:a62e82e:         st.executeUpdate( " drop table neg");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( "drop function asdf");
1:a62e82e:         
1:082f2ed:         rollback();
1:a62e82e:         st.close();
1:a62e82e:     }
1:f1c232e:     
1:a62e82e:     public void testPositiveTestsForColumnDefaults()
1:a62e82e:         throws SQLException
1:a62e82e:     {
1:a62e82e:         
1:a62e82e:         // positive 
1:082f2ed:         Statement st = createStatement();
1:a62e82e:         
1:a62e82e:         //create tables
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             "create table t1(c1 int, c2 int with default 5, c3 "
1:a62e82e:             + "date default current_date, c4 int)");
1:a62e82e:         
1:a62e82e:         // verify that defaults work
1:a62e82e:         
1:a62e82e:         st.executeUpdate( "insert into t1 (c1) values 1");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " insert into t1 (c4) values 4");
1:a62e82e:         
1:082f2ed:         ResultSet rs = st.executeQuery("select c1, c2, c4 from t1");
1:a62e82e:         
1:082f2ed:         String[] expColNames = {"C1", "C2", "C4"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:082f2ed:         String[][] expRS = {
1:a62e82e:             {"1", "5", null},
1:a62e82e:             {null, "5", "4"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:c341dc4:         
2:a62e82e:         rs = st.executeQuery(
1:a62e82e:             " select c1, c2, c4 from t1 where c3 = current_date");
1:a62e82e:         
2:a62e82e:         expColNames = new String [] {"C1", "C2", "C4"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
4:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {"1", "5", null},
1:a62e82e:             {null, "5", "4"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         // update default for column whose default is null
1:a62e82e:         
1:a62e82e:         assertUpdateCount(st, 2, "update t1 set c1 = default");
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery(
1:a62e82e:             " select c1, c2, c4 from t1 where c3 = current_date");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"C1", "C2", "C4"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {null, "5", null},
1:a62e82e:             {null, "5", "4"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         // default for column that has explicit default
1:a62e82e:         
1:a62e82e:         assertUpdateCount(st, 2, "update t1 set c2 = 7");
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery( " select c2 from t1");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"C2"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {"7"},
1:a62e82e:             {"7"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         assertUpdateCount(st, 2, " update t1 set c2 = default");
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery( " select c2 from t1");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"C2"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {"5"},
1:a62e82e:             {"5"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         // insert default
1:a62e82e:         
1:a62e82e:         assertUpdateCount(st, 2, "delete from t1");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " insert into t1 values (5, default, '1999-09-09', default)");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " insert into t1 values (default, 6, default, 5)");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " insert into t1 values (default, 6, default, 5), "
1:a62e82e:             + "(7, default, '1997-07-07', 3)");
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery(
1:a62e82e:             " select c1, c2, c4 from t1 where c3 = current_date");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"C1", "C2", "C4"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {null, "6", "5"},
1:a62e82e:             {null, "6", "5"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery(
1:a62e82e:             " select c1, c2, c4 from t1 where c3 <> current_date");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"C1", "C2", "C4"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {"5", "5", null},
1:a62e82e:             {"7", "5", "3"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         assertUpdateCount(st, 4, " delete from t1");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " insert into t1 (c1, c3, c4) values (5, "
1:a62e82e:             + "'1999-09-09', default)");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " insert into t1 (c1, c3, c4) values (default, default, 5)");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " insert into t1 (c1, c3, c4) values (default, "
1:a62e82e:             + "default, default)");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " insert into t1 (c1, c3, c4) values (default, "
1:a62e82e:             + "default, 5), (7, '1997-07-07', 3)");
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery(
1:a62e82e:             " select c1, c2, c4 from t1 where c3 = current_date");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"C1", "C2", "C4"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {null, "5", "5"},
1:a62e82e:             {null, "5", null},
1:a62e82e:             {null, "5", "5"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery(
1:a62e82e:             " select c1, c2, c4 from t1 where c3 <> current_date");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"C1", "C2", "C4"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {"5", "5", null},
1:a62e82e:             {"7", "5", "3"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         // delimited identifiers this schema
1:a62e82e:         
1:a62e82e:         st.executeUpdate( "create table \"x1\" (\"c1\" int)");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " insert into \"x1\" values 1");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " alter table \"x1\" add column \"c2\" char(1) default 'x'");
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery( " select * from \"x1\"");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"c1", "c2"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {"1", "x"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         // another schema
1:a62e82e:         
1:a62e82e:         st.executeUpdate( "create schema \"otherschema\"");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " create table \"otherschema\".\"y1\" (\"c11\" int)");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " insert into \"otherschema\".\"y1\" values 2");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " alter table \"otherschema\".\"y1\" add column "
1:a62e82e:             + "\"c22\" char(1) default 'y'");
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery(
1:a62e82e:             " select * from \"otherschema\".\"y1\"");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"c11", "c22"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {"2", "y"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         // bug 3433
1:a62e82e:         
1:a62e82e:         st.executeUpdate( "create table t7(c1 int default 10)");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " insert into t7 values (default)");
1:a62e82e:         
1:a62e82e:         rs = st.executeQuery( " select * from t7");
1:a62e82e:         
1:a62e82e:         expColNames = new String [] {"C1"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:a62e82e:         expRS = new String [][]
1:a62e82e:         {
1:a62e82e:             {"10"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e: 
1:c341dc4:         // DERBY-4426: make sure we don't forbid inside a multi-value table
1:c341dc4:         // constructor since this is represented as a UnionNode
1:c341dc4:         st.executeUpdate( "delete from t7");
1:c341dc4:         st.executeUpdate( "insert into t7 values 1, default");
1:c341dc4:         rs = st.executeQuery( " select * from t7");
1:c341dc4: 
1:c341dc4:         expRS = new String [][]
1:c341dc4:         {
1:c341dc4:             {"1"},
1:c341dc4:             {"10"}
1:c341dc4:         };
1:c341dc4: 
1:c341dc4:         JDBC.assertFullResultSet(rs, expRS, true);
1:c341dc4: 
1:a62e82e:         st.executeUpdate( " drop table t1");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " drop table t7");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " drop table \"x1\"");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " drop table \"otherschema\".\"y1\"");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " drop schema \"otherschema\" restrict");
1:a62e82e:         
1:082f2ed:         rollback();
1:a62e82e:         st.close();
1:a62e82e:         
1:a62e82e:     }
1:a62e82e:     public void testJira331()
1:a62e82e:         throws SQLException
1:a62e82e:     {
1:a62e82e:         // JIRA issue Derby-331
1:082f2ed:         Statement st = createStatement();
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             "create table t_331 (a int not null, b int default "
1:a62e82e:             + "0, unique (a))");
1:a62e82e:         
1:a62e82e:         st.executeUpdate( " insert into t_331 values (4, default)");
1:a62e82e:         
1:a62e82e:         assertStatementError("23505", st,
1:a62e82e:             " insert into t_331 values (4, default)");
1:a62e82e:         
1:082f2ed:         ResultSet rs = st.executeQuery( " select * from t_331");
1:a62e82e:         
1:082f2ed:         String[] expColNames = {"A", "B"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:082f2ed:         String[][] expRS = {
1:a62e82e:             {"4", "0"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:          st.executeUpdate( " drop table t_331");
1:a62e82e:          
1:082f2ed:         rollback();
1:a62e82e:         st.close();
1:a62e82e:     }
1:a62e82e:     
1:a62e82e:     public void testJira3013()
1:a62e82e:         throws SQLException
1:a62e82e:     {
1:a62e82e:         // begin DERBY-3013
1:082f2ed:         Statement st = createStatement();
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             "create table tabWithUserAndSchemaDefaults("
1:a62e82e:             + "             cUser           CHAR(8) default user,"
1:a62e82e:             + "             cCurrent_user   CHAR(8) default current_user,"
1:a62e82e:             + "             cSession_user   CHAR(8) default session_user,"
1:a62e82e:             + "             cCurrent_schema CHAR(128) default "
1:a62e82e:             + "current schema)");
1:a62e82e:         
1:a62e82e:         // Should work
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             "insert into tabWithUserAndSchemaDefaults values "
1:a62e82e:             + "(default, default, default, default)");
1:a62e82e:         
1:082f2ed:         ResultSet rs = st.executeQuery(
1:a62e82e:             " select * from tabWithUserAndSchemaDefaults");
1:a62e82e:         
1:082f2ed:         String[] expColNames = {"CUSER", "CCURRENT_USER",
1:a62e82e:             "CSESSION_USER", "CCURRENT_SCHEMA"};
1:a62e82e:         JDBC.assertColumnNames(rs, expColNames);
1:a62e82e:         
1:082f2ed:         String[][] expRS = {
1:a62e82e:             {"APP", "APP", "APP", "APP"}
1:a62e82e:         };
1:a62e82e:         
1:a62e82e:         JDBC.assertFullResultSet(rs, expRS, true);
1:a62e82e:         
1:a62e82e:         // Should fail:DEFAULT value or IDENTITY attribute value is not valid
1:a62e82e:         
1:a62e82e:         assertStatementError("42894", st,
1:a62e82e:             "create table tabWithUserDefaultTooNarrowColumn("
1:a62e82e:             + "       c1 CHAR(7) default user)");
1:a62e82e:         
1:a62e82e:         // Should fail:DEFAULT value or IDENTITY attribute value is not valid
1:a62e82e:         
1:a62e82e:         assertStatementError("42894", st,
1:a62e82e:             "create table tabWithSchemaDefaultTooNarrowColumn("
1:a62e82e:             + "       c1 CHAR(127) default current sqlid)");
1:a62e82e:         
1:a62e82e:         st.executeUpdate(
1:a62e82e:             " drop table tabWithUserAndSchemaDefaults");
1:a62e82e:                
1:082f2ed:         rollback();
1:a62e82e:         st.close();
1:a62e82e:     }
1:a62e82e: 
1:f1c232e:     public void testDerby118_and_5829 () throws SQLException {
1:f1c232e:         Statement st = createStatement();
1:f1c232e: 
1:f1c232e:         /*
1:f1c232e:          * Lift restriction that even VARCHAR can max have 254 chars in
1:f1c232e:          * DEFAULT, another DB2ism.
1:f1c232e:          */
1:f1c232e:         String sb = Formatters.repeatChar("-", 400);
1:f1c232e: 
1:f1c232e:         st.executeUpdate(
1:f1c232e:             "create table tabLongVarchar("
1:f1c232e:             + "    c varchar(400) default " + "'" + sb + "')");
1:f1c232e:         st.executeUpdate(
1:f1c232e:             "insert into  tabLongVarchar" +
1:f1c232e:             "    values default");
1:f1c232e: 
1:f1c232e:         ResultSet rs = st.executeQuery("select c from tabLongVarchar");
1:f1c232e:         JDBC.assertSingleValueResultSet(rs, sb);
1:f1c232e: 
1:f1c232e:         // Negative test: Make sure we still flag too long string for CHAR
1:f1c232e:         // (length > 254).  Note that the check will now only happen at insert
1:f1c232e:         // time, as other truncation checks do.
1:f1c232e:         st.executeUpdate(
1:f1c232e:             "create table tabLongChar("
1:f1c232e:             + "    c char(254) default " + "'" + sb + "')");
1:f1c232e:         try {
1:f1c232e:             st.executeUpdate(
1:f1c232e:                 "insert into tabLongChar values default");
1:f1c232e:             fail();
1:f1c232e:         } catch (SQLException e) {
1:f1c232e:             assertSQLState("22001", e); // truncate
1:f1c232e:         }
1:f1c232e: 
1:f1c232e:         // Interestingly, a float literal for SMALLINT is not disabled for
1:f1c232e:         // assignment to integer types.  This is asymmetric, as it is forbidden
1:f1c232e:         // for the other integer types, as per the standard, btw.
1:f1c232e:         // Remove this test if we forbid this, or add tests for the other
1:f1c232e:         // integer types if we decide to allow it, cf discussions on
1:f1c232e:         // DERBY-118. For now, we just document this weirdness in this test.
1:f1c232e:         st.executeUpdate(
1:f1c232e:             "create table tabSmallIntFloat(si smallint default 3.14)");
1:f1c232e:         st.executeUpdate(
1:f1c232e:             "insert into  tabSmallIntFloat values default");
1:f1c232e:         rs = st.executeQuery("select si from tabSmallIntFloat");
1:f1c232e:         JDBC.assertSingleValueResultSet(rs, "3");
1:f1c232e: 
1:f1c232e:         // Compare with INT, which fails:
1:f1c232e:         try {
1:f1c232e:             st.executeUpdate(
1:f1c232e:                 "create table tabIntFloat(i int default 3.14)");
1:f1c232e:             fail();
1:f1c232e:         } catch (SQLException e) {
1:f1c232e:             assertSQLState("42894", e);
1:f1c232e:         }
1:f1c232e:     }
1:a62e82e: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ColumnDefaultsTest Test");
commit:f1c232e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.Formatters;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testDerby118_and_5829 () throws SQLException {
1:         Statement st = createStatement();
1: 
1:         /*
1:          * Lift restriction that even VARCHAR can max have 254 chars in
1:          * DEFAULT, another DB2ism.
1:          */
1:         String sb = Formatters.repeatChar("-", 400);
1: 
1:         st.executeUpdate(
1:             "create table tabLongVarchar("
1:             + "    c varchar(400) default " + "'" + sb + "')");
1:         st.executeUpdate(
1:             "insert into  tabLongVarchar" +
1:             "    values default");
1: 
1:         ResultSet rs = st.executeQuery("select c from tabLongVarchar");
1:         JDBC.assertSingleValueResultSet(rs, sb);
1: 
1:         // Negative test: Make sure we still flag too long string for CHAR
1:         // (length > 254).  Note that the check will now only happen at insert
1:         // time, as other truncation checks do.
1:         st.executeUpdate(
1:             "create table tabLongChar("
1:             + "    c char(254) default " + "'" + sb + "')");
1:         try {
1:             st.executeUpdate(
1:                 "insert into tabLongChar values default");
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22001", e); // truncate
1:         }
1: 
1:         // Interestingly, a float literal for SMALLINT is not disabled for
1:         // assignment to integer types.  This is asymmetric, as it is forbidden
1:         // for the other integer types, as per the standard, btw.
1:         // Remove this test if we forbid this, or add tests for the other
1:         // integer types if we decide to allow it, cf discussions on
1:         // DERBY-118. For now, we just document this weirdness in this test.
1:         st.executeUpdate(
1:             "create table tabSmallIntFloat(si smallint default 3.14)");
1:         st.executeUpdate(
1:             "insert into  tabSmallIntFloat values default");
1:         rs = st.executeQuery("select si from tabSmallIntFloat");
1:         JDBC.assertSingleValueResultSet(rs, "3");
1: 
1:         // Compare with INT, which fails:
1:         try {
1:             st.executeUpdate(
1:                 "create table tabIntFloat(i int default 3.14)");
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("42894", e);
1:         }
1:     }
commit:c341dc4
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         // DERBY-4426
1:         assertStatementError("42Y85", st,
1:             " insert into neg values (default) union values (default)");
1: 
1:         assertStatementError("42Y85", st,
1:             " insert into neg values (default) except values (default)");
1: 
1:         // Make sure sub-queries are inspected for illegal DEFAULT also.
1:         assertStatementError("42Y85", st,
1:             " insert into neg select * from (values default) t");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-4426: make sure we don't forbid inside a multi-value table
1:         // constructor since this is represented as a UnionNode
1:         st.executeUpdate( "delete from t7");
1:         st.executeUpdate( "insert into t7 values 1, default");
1:         rs = st.executeQuery( " select * from t7");
1: 
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"10"}
1:         };
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:082f2ed
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Statement st = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         Statement st = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = st.executeQuery("select c1, c2, c4 from t1");
1:         String[] expColNames = {"C1", "C2", "C4"};
1:         String[][] expRS = {
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         Statement st = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = st.executeQuery( " select * from t_331");
1:         String[] expColNames = {"A", "B"};
1:         String[][] expRS = {
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         Statement st = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = st.executeQuery(
1:         String[] expColNames = {"CUSER", "CCURRENT_USER",
1:         String[][] expRS = {
/////////////////////////////////////////////////////////////////////////
1:         rollback();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:a62e82e
/////////////////////////////////////////////////////////////////////////
1: /*
1: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ColumnDefaultsTest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.sql.CallableStatement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.SQLWarning;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public final class ColumnDefaultsTest extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Public constructor required for running test as standalone JUnit.
1:      */
1:     public ColumnDefaultsTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("ColumnDefaultsTest Test");
1:         suite.addTest(TestConfiguration.defaultSuite(ColumnDefaultsTest.class));
1:         return suite;
1:     }
1: 
0:     ResultSet rs = null;
0:     ResultSetMetaData rsmd;
0:     SQLWarning sqlWarn = null;
0:     PreparedStatement pSt;
0:     CallableStatement cSt;
0:     Statement st;
0:     String[][] expRS;
0:     String[] expColNames;   
1:     
1:     public void testNegativeTestsForColumnDefaults() throws Exception
1:     {
0:         st = createStatement();
1:         
1:         //? in default
1:         assertStatementError("42X01", st,
1:             "create table neg(c1 int default ?)");
1:         
1:         // column reference in default
1:         
1:         assertStatementError("42X01", st,
1:             "create table neg(c1 int, c2 int default c1)");
1:         
1:         // subquery in default
1:         
1:         assertStatementError("42X01", st,
1:             "create table neg(c1 int default (values 1))");
1:         
1:         // type incompatibility at compile time
1:         
1:         assertStatementError("42821", st,
1:             "create table neg(c1 date default 1)");
1:         
1:         // type incompatibility at execution time bug 5585 - 
1:         // should fail at create table statement because the 
1:         // default value '1' is not valid
1:         
1:         st.executeUpdate(
1:             "create table neg(c1 int, c2 date default '1')");
1:         
1:         assertStatementError("22007", st, " insert into neg (c1) values 1");
1:         
1:         st.executeUpdate( " drop table neg");
1:         
1:         // bug 5203 - built-in functions are not be allowed in a 
1:         // constantExpression because DB2 UDB returns SQLSTATE 42894
1:         
1:         st.executeUpdate(
1:             "CREATE FUNCTION ASDF (DATA DOUBLE) RETURNS DOUBLE "
1:             + "EXTERNAL NAME 'java.lang.Math.sin' LANGUAGE JAVA "
1:             + "PARAMETER STYLE JAVA");
1:         
1:         //DEFAULT value or IDENTITY attribute value is not valid 
1:         
1:         assertStatementError("42894", st,
1:             " create table neg(c1 int default asdf(0))");
1:         
1:         //drop a table which does not exists fails
1:         assertStatementError("42Y55", st, " drop table neg");
1:         
1:         // DEFAULT only valid in VALUES within an insert
1:         
1:         assertStatementError("42Y85", st, "values default");
1:         
1:         assertStatementError("42Y85", st, " values 1, default");
1:         
1:         // alter table modify default
1:         
1:         st.executeUpdate( "create table neg(c1 date)");
1:         
1:         assertStatementError("42X01", st,
1:             " alter table neg modify x default null");
1:         
1:         assertStatementError("42821", st,
1:             " alter table neg add column x date default 1");
1:         
1:         // bug 5585 - should fail at alter table statement because 
1:         // the default value '1' is not valid
1:         
1:         st.executeUpdate( "alter table neg add column x date default '1'");
1:         
1:         assertStatementError("22007", st,
1:             " insert into neg (c1) values default");
1:         
1:         st.executeUpdate( " drop table neg");
1:         
1:         // too many values in values clause
1:         
1:         st.executeUpdate( "create table neg(c1 int default 10)");
1:         
1:         assertStatementError("42X06", st,
1:             " insert into neg values (1, default)");
1:         
1:         assertStatementError("42802", st,
1:             " insert into neg values (default, 1)");
1:         
1:         st.executeUpdate( " drop table neg");
1:         
1:         st.executeUpdate( "drop function asdf");
1:         
0:         getConnection().rollback();
1:         st.close();
1:     }
1:     
1:     public void testPositiveTestsForColumnDefaults()
1:         throws SQLException
1:     {
1:         
1:         // positive 
0:         st = createStatement();
1:         
1:         //create tables
1:         
1:         st.executeUpdate(
1:             "create table t1(c1 int, c2 int with default 5, c3 "
1:             + "date default current_date, c4 int)");
1:         
1:         // verify that defaults work
1:         
1:         st.executeUpdate( "insert into t1 (c1) values 1");
1:         
1:         st.executeUpdate( " insert into t1 (c4) values 4");
1:         
0:         rs = st.executeQuery( " select c1, c2, c4 from t1");
1:         
1:         expColNames = new String [] {"C1", "C2", "C4"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "5", null},
1:             {null, "5", "4"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select c1, c2, c4 from t1 where c3 = current_date");
1:         
1:         expColNames = new String [] {"C1", "C2", "C4"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "5", null},
1:             {null, "5", "4"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // update default for column whose default is null
1:         
1:         assertUpdateCount(st, 2, "update t1 set c1 = default");
1:         
1:         rs = st.executeQuery(
1:             " select c1, c2, c4 from t1 where c3 = current_date");
1:         
1:         expColNames = new String [] {"C1", "C2", "C4"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {null, "5", null},
1:             {null, "5", "4"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // default for column that has explicit default
1:         
1:         assertUpdateCount(st, 2, "update t1 set c2 = 7");
1:         
1:         rs = st.executeQuery( " select c2 from t1");
1:         
1:         expColNames = new String [] {"C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"7"},
1:             {"7"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertUpdateCount(st, 2, " update t1 set c2 = default");
1:         
1:         rs = st.executeQuery( " select c2 from t1");
1:         
1:         expColNames = new String [] {"C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"5"},
1:             {"5"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // insert default
1:         
1:         assertUpdateCount(st, 2, "delete from t1");
1:         
1:         st.executeUpdate(
1:             " insert into t1 values (5, default, '1999-09-09', default)");
1:         
1:         st.executeUpdate(
1:             " insert into t1 values (default, 6, default, 5)");
1:         
1:         st.executeUpdate(
1:             " insert into t1 values (default, 6, default, 5), "
1:             + "(7, default, '1997-07-07', 3)");
1:         
1:         rs = st.executeQuery(
1:             " select c1, c2, c4 from t1 where c3 = current_date");
1:         
1:         expColNames = new String [] {"C1", "C2", "C4"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {null, "6", "5"},
1:             {null, "6", "5"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select c1, c2, c4 from t1 where c3 <> current_date");
1:         
1:         expColNames = new String [] {"C1", "C2", "C4"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"5", "5", null},
1:             {"7", "5", "3"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertUpdateCount(st, 4, " delete from t1");
1:         
1:         st.executeUpdate(
1:             " insert into t1 (c1, c3, c4) values (5, "
1:             + "'1999-09-09', default)");
1:         
1:         st.executeUpdate(
1:             " insert into t1 (c1, c3, c4) values (default, default, 5)");
1:         
1:         st.executeUpdate(
1:             " insert into t1 (c1, c3, c4) values (default, "
1:             + "default, default)");
1:         
1:         st.executeUpdate(
1:             " insert into t1 (c1, c3, c4) values (default, "
1:             + "default, 5), (7, '1997-07-07', 3)");
1:         
1:         rs = st.executeQuery(
1:             " select c1, c2, c4 from t1 where c3 = current_date");
1:         
1:         expColNames = new String [] {"C1", "C2", "C4"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {null, "5", "5"},
1:             {null, "5", null},
1:             {null, "5", "5"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select c1, c2, c4 from t1 where c3 <> current_date");
1:         
1:         expColNames = new String [] {"C1", "C2", "C4"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"5", "5", null},
1:             {"7", "5", "3"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // delimited identifiers this schema
1:         
1:         st.executeUpdate( "create table \"x1\" (\"c1\" int)");
1:         
1:         st.executeUpdate( " insert into \"x1\" values 1");
1:         
1:         st.executeUpdate(
1:             " alter table \"x1\" add column \"c2\" char(1) default 'x'");
1:         
1:         rs = st.executeQuery( " select * from \"x1\"");
1:         
1:         expColNames = new String [] {"c1", "c2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "x"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // another schema
1:         
1:         st.executeUpdate( "create schema \"otherschema\"");
1:         
1:         st.executeUpdate(
1:             " create table \"otherschema\".\"y1\" (\"c11\" int)");
1:         
1:         st.executeUpdate(
1:             " insert into \"otherschema\".\"y1\" values 2");
1:         
1:         st.executeUpdate(
1:             " alter table \"otherschema\".\"y1\" add column "
1:             + "\"c22\" char(1) default 'y'");
1:         
1:         rs = st.executeQuery(
1:             " select * from \"otherschema\".\"y1\"");
1:         
1:         expColNames = new String [] {"c11", "c22"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"2", "y"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // bug 3433
1:         
1:         st.executeUpdate( "create table t7(c1 int default 10)");
1:         
1:         st.executeUpdate( " insert into t7 values (default)");
1:         
1:         rs = st.executeQuery( " select * from t7");
1:         
1:         expColNames = new String [] {"C1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"10"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         st.executeUpdate( " drop table t1");
1:         
1:         st.executeUpdate( " drop table t7");
1:         
1:         st.executeUpdate( " drop table \"x1\"");
1:         
1:         st.executeUpdate( " drop table \"otherschema\".\"y1\"");
1:         
1:         st.executeUpdate( " drop schema \"otherschema\" restrict");
1:         
0:         getConnection().rollback();
1:         st.close();
1:         
1:     }
1:     public void testJira331()
1:         throws SQLException
1:     {
1:         // JIRA issue Derby-331
0:         st = createStatement();
1:         
1:         st.executeUpdate(
1:             "create table t_331 (a int not null, b int default "
1:             + "0, unique (a))");
1:         
1:         st.executeUpdate( " insert into t_331 values (4, default)");
1:         
1:         assertStatementError("23505", st,
1:             " insert into t_331 values (4, default)");
1:         
0:         rs = st.executeQuery( " select * from t_331");
1:         
0:         expColNames = new String [] {"A", "B"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"4", "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:          st.executeUpdate( " drop table t_331");
1:          
0:         getConnection().rollback();
1:         st.close();
1:     }
1:     
1:     public void testJira3013()
1:         throws SQLException
1:     {
1:         // begin DERBY-3013
0:         st = createStatement();
1:         
1:         st.executeUpdate(
1:             "create table tabWithUserAndSchemaDefaults("
1:             + "             cUser           CHAR(8) default user,"
1:             + "             cCurrent_user   CHAR(8) default current_user,"
1:             + "             cSession_user   CHAR(8) default session_user,"
1:             + "             cCurrent_schema CHAR(128) default "
1:             + "current schema)");
1:         
1:         // Should work
1:         
1:         st.executeUpdate(
1:             "insert into tabWithUserAndSchemaDefaults values "
1:             + "(default, default, default, default)");
1:         
1:         rs = st.executeQuery(
1:             " select * from tabWithUserAndSchemaDefaults");
1:         
0:         expColNames = new String [] {"CUSER", "CCURRENT_USER", 
1:             "CSESSION_USER", "CCURRENT_SCHEMA"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"APP", "APP", "APP", "APP"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // Should fail:DEFAULT value or IDENTITY attribute value is not valid
1:         
1:         assertStatementError("42894", st,
1:             "create table tabWithUserDefaultTooNarrowColumn("
1:             + "       c1 CHAR(7) default user)");
1:         
1:         // Should fail:DEFAULT value or IDENTITY attribute value is not valid
1:         
1:         assertStatementError("42894", st,
1:             "create table tabWithSchemaDefaultTooNarrowColumn("
1:             + "       c1 CHAR(127) default current sqlid)");
1:         
1:         st.executeUpdate(
1:             " drop table tabWithUserAndSchemaDefaults");
1:                
0:         getConnection().rollback();
1:         st.close();
1:     }
1: }
============================================================================