1:9e87d08: /*
1:9e87d08: 
1:9e87d08:    Derby - Class SetDerbyVersion
1:9e87d08: 
1:9e87d08:    Licensed to the Apache Software Foundation (ASF) under one or more
1:9e87d08:    contributor license agreements.  See the NOTICE file distributed with
1:9e87d08:    this work for additional information regarding copyright ownership.
1:9e87d08:    The ASF licenses this file to You under the Apache License, Version 2.0
1:9e87d08:    (the "License"); you may not use this file except in compliance with
1:9e87d08:    the License.  You may obtain a copy of the License at
1:9e87d08: 
1:9e87d08:       http://www.apache.org/licenses/LICENSE-2.0
1:9e87d08: 
1:9e87d08:    Unless required by applicable law or agreed to in writing, software
1:9e87d08:    distributed under the License is distributed on an "AS IS" BASIS,
1:9e87d08:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9e87d08:    See the License for the specific language governing permissions and
1:9e87d08:    limitations under the License.
1:9e87d08: 
1:9e87d08:  */
1:9e87d08: 
1:9e87d08: import java.io.BufferedReader;
1:9e87d08: import java.io.BufferedWriter;
1:9e87d08: import java.io.EOFException;
1:9e87d08: import java.io.File;
1:9e87d08: import java.io.FileReader;
1:9e87d08: import java.io.FileWriter;
1:9e87d08: import java.io.IOException;
1:9e87d08: import java.io.InputStreamReader;
1:9e87d08: import java.net.URL;
1:9e87d08: import java.net.URLClassLoader;
1:9e87d08: import java.sql.Connection;
1:9e87d08: import java.sql.DatabaseMetaData;
1:9e87d08: import java.sql.Driver;
1:9e87d08: import java.util.ArrayList;
1:9e87d08: import java.util.List;
1:9e87d08: 
1:9e87d08: /**
1:9e87d08:  * Checks the current Derby jars in the source tree directory, obtains the
1:9e87d08:  * Derby version from them, and replaces the value of the placeholder
1:9e87d08:  * version tags in the POM files.
1:9e87d08:  * <p>
1:9e87d08:  * After this method has been successfully run you should be ready to
1:9e87d08:  * generate the Maven 2 artifacts for Derby.
1:9e87d08:  * <p>
1:9e87d08:  * The main task of this class is to replace the version tags in the Maven
1:9e87d08:  * POM files. The can be done manually, but exact process would vary from
1:9e87d08:  * platform to platform. Also, running a search-and-replace could potentially
1:9e87d08:  * replace tags not supposed to be replaced. To make the Maven 2 artifact
1:9e87d08:  * publish process simpler, this class was written.
1:9e87d08:  */
1:9e87d08: //@NotThreadSafe
1:9e87d08: public class SetDerbyVersion {
1:9e87d08: 
1:9e87d08:     private static final String PROMPT_CONT_WARN =
1:9e87d08:             "Do you want to continue despite the warnings?";
1:9e87d08:     private static final String PROMPT_USE_SANE =
1:9e87d08:             "Do you want to generate artifacts with SANE jars?";
1:9e87d08:     private static final String JDBC_URL =
1:9e87d08:             "jdbc:derby:memory:testDB;create=true";
1:9e87d08:     private static final String REL_JAR_PATH = "../jars";
1:9e87d08:     private static final File SANE = new File(REL_JAR_PATH, "sane");
1:9e87d08:     private static final File INSANE = new File(REL_JAR_PATH, "insane");
1:9e87d08:     /** List of required jar files the Maven 2 Derby artifacts. */
1:9e87d08:     private static final String[] JARS = new String[] {
1:9e87d08:         "derby.jar",
1:9e87d08:         "derby.war",
1:9e87d08:         "derbynet.jar",
1:9e87d08:         "derbyclient.jar",
1:9e87d08:         "derbytools.jar",
1:2e9fed4:         "derbyoptionaltools.jar",
1:9e87d08:         // Ignore derbyTesting.jar, not part of the Maven 2 artifacts.
1:9e87d08:         // "derbyTesting.jar",
1:9e87d08:         // Ignore derbyrun.jar, not part of the Maven 2 artifacts.
1:9e87d08:         //"derbyrun.jar",
1:9e87d08:         // The various locale files.
1:9e87d08:         "derbyLocale_cs.jar",
1:9e87d08:         "derbyLocale_de_DE.jar",
1:9e87d08:         "derbyLocale_es.jar",
1:9e87d08:         "derbyLocale_fr.jar",
1:9e87d08:         "derbyLocale_hu.jar",
1:9e87d08:         "derbyLocale_it.jar",
1:9e87d08:         "derbyLocale_ja_JP.jar",
1:9e87d08:         "derbyLocale_ko_KR.jar",
1:9e87d08:         "derbyLocale_pl.jar",
1:9e87d08:         "derbyLocale_pt_BR.jar",
1:9e87d08:         "derbyLocale_ru.jar",
1:9e87d08:         "derbyLocale_zh_CN.jar",
1:9e87d08:         "derbyLocale_zh_TW.jar",
1:9e87d08:     };
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Displays a prompt and obtains a yes / no answer from standard in.
1:9e87d08:      *
1:9e87d08:      * @param prompt the prompt to display
1:9e87d08:      * @return {@code true} if the answer is yes, {@code false} if the answer
1:9e87d08:      *      is no.
1:9e87d08:      * @throws IOException if reading from standard in fails
1:9e87d08:      */
1:9e87d08:     private static boolean getYesNoInput(String prompt)
1:9e87d08:             throws IOException {
1:9e87d08:         // We don't care about keeping the objects around, this method will
1:9e87d08:         // only be used a few times.
1:9e87d08:         BufferedReader bIn = new BufferedReader(
1:9e87d08:                 new InputStreamReader(System.in));
1:9e87d08:         while (true) {
1:9e87d08:             System.out.print(">> " + prompt + " (yes/no) ");
1:9e87d08:             String answer = bIn.readLine();
1:9e87d08:             if (answer == null) {
1:9e87d08:                 // We don't know what do to here, so just fail.
1:9e87d08:                 throw new EOFException("Input stream closed.");
1:9e87d08:             }
1:9e87d08:             if (answer.equals("yes")) {
1:9e87d08:                 return true;
1:9e87d08:             } else if (answer.equals("no")) {
1:9e87d08:                 return false;
1:9e87d08:             }
1:9e87d08:         }
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Set to {@code true} if a warning message is printed. Must be manually
1:9e87d08:      * reset if used to check for warnings in a part of the code.
1:9e87d08:      */
1:9e87d08:     private boolean warnings = false;
1:9e87d08:     /** The version string inserted into the POMs. */
1:9e87d08:     private String versionString = "ALPHA_VERSION";
1:9e87d08:     private File PREFIX;
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Prints a warning message and sets the internal warning flag.
1:9e87d08:      *
1:9e87d08:      * @param msg the message to print
1:9e87d08:      */
1:9e87d08:     private void warn(String msg) {
1:9e87d08:         warnings = true;
1:9e87d08:         System.out.println("WARNING! " + msg);
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     private void info(String msg) {
1:9e87d08:         System.out.println(msg);
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Checks that all required jars are found in the jar directory.
1:9e87d08:      *
1:9e87d08:      * @return {@code true} if all required jars exist, {@code false} otherwise.
1:9e87d08:      */
1:9e87d08:     public boolean checkJars()
1:9e87d08:             throws Exception {
1:9e87d08:         if (!SANE.exists() && !INSANE.exists()) {
1:9e87d08:             warn("No jars exist. Produce a Derby release build.");
1:9e87d08:             return false;
1:9e87d08:         }
1:9e87d08:         if (SANE.exists() && INSANE.exists()) {
1:9e87d08:             warn("Both SANE and INSANE jars exist.");
1:9e87d08:             return false;
1:9e87d08:         }
1:9e87d08:         PREFIX = SANE.exists() ? SANE : INSANE;
1:9e87d08:         if (SANE.exists()) {
1:9e87d08:             warn("Only SANE jars exist. Normally INSANE jars are used for a " +
1:9e87d08:                     "release.");
1:9e87d08:             boolean answer = getYesNoInput(PROMPT_USE_SANE);
1:9e87d08:             if (!answer) {
1:9e87d08:                 return false;
1:9e87d08:             }
1:9e87d08:         }
1:9e87d08:         URL[] URLS = new URL[JARS.length];
1:9e87d08:         for (int i=0; i < JARS.length; i++) {
1:9e87d08:             URLS[i] = new File(PREFIX, JARS[i]).toURI().toURL();
1:9e87d08:         }
1:9e87d08: 
1:9e87d08:         warnings = false; // Reuse the warnings flag.
1:9e87d08:         // Make sure the files are there.
1:9e87d08:         for (URL url : URLS) {
1:9e87d08:             File f = new File(url.toURI());
1:9e87d08:             info(String.format(
1:9e87d08:                     "Checking file: %-30s %,12d bytes",
1:9e87d08:                     f.getName(), f.length()));
1:9e87d08:             if (!f.exists()) {
1:9e87d08:                 warn("Missing file: " + f.getCanonicalPath());
1:9e87d08:             } else if (f.length() == 0) {
1:9e87d08:                 warn("Empty file: " + f.getCanonicalPath());
1:9e87d08:             }
1:9e87d08:         }
1:9e87d08:         info("");
1:9e87d08:         if (warnings) {
1:9e87d08:             // Fail here.
1:9e87d08:             warn("There are missing or empty jar files.");
1:9e87d08:             return false;
1:9e87d08:         }
1:9e87d08: 
1:9e87d08:         // The class loader used for the Derby jars.
1:9e87d08:         URLClassLoader cl = new URLClassLoader(URLS, null);
1:9e87d08: 
1:9e87d08:         // Extra sanity check for the sanity...
1:9e87d08:         try {
1:9e87d08:             Class.forName(
1:9e87d08:                     "org.apache.derby.shared.common.sanity.SanityManager",
1:9e87d08:                     true ,cl);
1:9e87d08:             if (PREFIX == INSANE) {
1:9e87d08:                 warn("Found SanityManager in INSANE build. Aborting.");
1:9e87d08:                 return false;
1:9e87d08:             }
1:9e87d08:         } catch (ClassNotFoundException cnfe) {
1:9e87d08:             if (PREFIX == SANE) {
1:9e87d08:                 warn("Unable to load SanityManager in SANE build. Aborting.");
1:9e87d08:                 return false;
1:9e87d08:             }
1:9e87d08:         }
1:9e87d08: 
1:9e87d08:         // Fire up Derby to get the version string.
1:9e87d08:         Class driverClass =
1:9e87d08:                 Class.forName("org.apache.derby.jdbc.EmbeddedDriver", true, cl);
1:9e87d08:         Driver driver = (Driver)driverClass.newInstance();
1:9e87d08:         Connection con = driver.connect(JDBC_URL, null);
1:9e87d08:         DatabaseMetaData meta = con.getMetaData();
1:9e87d08:         con.close();
1:9e87d08:         // Delete the derby.log file.
1:9e87d08:         new File("derby.log").delete();
1:9e87d08: 
1:9e87d08:         // I.e.: 10.6.0.0 alpha - (882129M)
1:9e87d08:         String fullVersion = meta.getDatabaseProductVersion();
1:9e87d08:         String[] components = fullVersion.split(" - ");
1:9e87d08:         versionString = components[0].replaceAll(" ", "_");
1:9e87d08:         String srcRevision = components[1].replaceAll("\\(|\\)", "");
1:9e87d08:         info("Obtained product version string: " + fullVersion);
1:9e87d08:         info("(version=" + versionString + ", revision=" + srcRevision + ")");
1:9e87d08:         if (versionString.contains("beta")) {
1:9e87d08:             warn("This is a BETA build.");
1:9e87d08:         }
1:9e87d08:         if (versionString.contains("alpha")) {
1:9e87d08:             warn("This is an ALPHA build.");
1:9e87d08:         }
1:9e87d08:         if (srcRevision.endsWith("M")) {
1:9e87d08:             warn("The sources had been modified when the jars were built.");
1:9e87d08:             warnings = true;
1:9e87d08:         }
1:9e87d08:         if (warnings) {
1:9e87d08:             if (!getYesNoInput(PROMPT_CONT_WARN)) {
1:9e87d08:                 return false;
1:9e87d08:             }
1:9e87d08:         }
1:9e87d08:         return true;
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Replaces the relevant version tags in the various POM files.
1:9e87d08:      *
1:9e87d08:      * @throws IOException if accessing a POM file fails
1:9e87d08:      */
1:9e87d08:     public boolean setPOMVersionTags()
1:9e87d08:             throws IOException {
1:9e87d08:         File curDir = new File(".");
1:9e87d08:         boolean gotWarnings = false;
1:9e87d08:         // We only descend one level, no need for a recursive method.
1:9e87d08:         for (File topLevel : curDir.listFiles()) {
1:9e87d08:             if (topLevel.getName().equals("pom.xml")) {
1:9e87d08:                 gotWarnings |= setVersionTag(topLevel);
1:9e87d08:             }
1:9e87d08:             if (topLevel.isDirectory()) {
1:9e87d08:                 for (File l1 : topLevel.listFiles()) {
1:9e87d08:                     if (l1.getName().equals("pom.xml")) {
1:9e87d08:                         gotWarnings |= setVersionTag(l1);
1:9e87d08:                         // There is only one POM in each sub-directory.
1:9e87d08:                         break;
1:9e87d08:                     }
1:9e87d08:                 }
1:9e87d08:             }
1:9e87d08:         }
1:9e87d08: 
1:9e87d08:         // See if we ran into problems when replacing the version tags.
1:9e87d08:         info("");
1:9e87d08:         if (gotWarnings) {
1:9e87d08:             warn("There were errors replacing the POM version tags.");
1:9e87d08:         } else {
1:9e87d08:             info("POM version tags replacement succeeded.");
1:9e87d08:             info("It is recommended that you verify the POM diffs " +
1:9e87d08:                     "before running Maven.");
1:9e87d08:         }
1:9e87d08:         return (warnings == false);
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     public void printSanityNote()
1:9e87d08:             throws IOException {
1:9e87d08:         if (PREFIX == SANE) {
1:9e87d08:             info("");
1:9e87d08:             info("NOTE: Remember to change the <sanity> tag in the top-level");
1:9e87d08:             info("      POM, setting it to 'sane'.");
1:9e87d08:         }
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Verifies that the correct number of tags were replaced in the POM.
1:9e87d08:      *
1:9e87d08:      * @param replaceCount the number of tags replaced
1:9e87d08:      * @param pom the POM modified
1:9e87d08:      * @return {@code 0} if the check passed, a negative value if too few tags
1:9e87d08:      *      were replaced, and a positive value if too many tags were replaced.
1:9e87d08:      */
1:9e87d08:     private int checkResult(int replaceCount, File pom) {
1:9e87d08:         // The locales requires two replacements, due to the dependency.
1:9e87d08:         String parent = pom.getParent();
1:9e87d08:         if (parent.contains("derbyLocale")) {
1:9e87d08:             return (replaceCount - 2);
1:9e87d08:         // derbynet also requries two replacements (derby.jar dependency)
1:9e87d08:         } else if (parent.contains("net")) {
1:9e87d08:             return (replaceCount - 2);
1:9e87d08:         } else {
1:9e87d08:             return (replaceCount - 1);
1:9e87d08:         }
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Replaces all qualifying version tags in the specified POM.
1:9e87d08:      *
1:9e87d08:      * @param pom the POM to modify
1:9e87d08:      * @return {@code false} if warnings were produced when replacing,
1:9e87d08:      *      {@code true} if all seemed to go well.
1:9e87d08:      *
1:9e87d08:      * @throws IOException if reading or writing to the POM file fails
1:9e87d08:      */
1:9e87d08:     private boolean setVersionTag(File pom)
1:9e87d08:             throws IOException {
1:9e87d08:         // Clear internal warning flag.
1:9e87d08:         warnings = false;
1:9e87d08:         // Just read the whole file into memory.
1:9e87d08:         List<String> lines = readFile(pom);
1:9e87d08: 
1:9e87d08:         // Start writing the file back out, and search for tags to replace.
1:9e87d08:         BufferedWriter bOut = new BufferedWriter(new FileWriter(pom, false));
1:9e87d08:         int replaced = 0;
1:9e87d08:         boolean artifactIdOk = false;
1:9e87d08:         boolean groupIdOk = false;
1:9e87d08:         // Could have used XML, but keep it simple.
1:9e87d08:         // artifactId and groupId are used to qualify the version tag, as it can
1:9e87d08:         // be used in more places than those we want to replace.
1:9e87d08:         for (String line : lines) {
1:9e87d08:             // Look for tags for qualification.
1:9e87d08:             if (line.trim().startsWith("<artifactId>") &&
1:9e87d08:                     line.contains("derby")) {
1:9e87d08:                 artifactIdOk = true;
1:9e87d08:             } else if (line.trim().startsWith("<groupId>") &&
1:9e87d08:                     line.contains("org.apache.derby")) {
1:9e87d08:                 groupIdOk = true;
1:9e87d08:             }
1:9e87d08: 
1:9e87d08:             // Change line if a qualified version tag, echo otherwise.
1:9e87d08:             if (line.trim().startsWith("<version>") &&
1:9e87d08:                     artifactIdOk && groupIdOk) {
1:9e87d08:                 // Replace tag.
1:9e87d08:                 int whitespaceTag = line.indexOf(">");
1:9e87d08:                 bOut.write(line.substring(0, whitespaceTag +1));
1:9e87d08:                 bOut.write(versionString);
1:9e87d08:                 int tagEnd = line.indexOf("<", whitespaceTag);
1:9e87d08:                 bOut.write(line.substring(tagEnd));
1:9e87d08:                 bOut.newLine();
1:9e87d08:                 replaced++;
1:9e87d08:                 artifactIdOk = groupIdOk = false;
1:9e87d08:             } else {
1:9e87d08:                 bOut.write(line);
1:9e87d08:                 bOut.newLine();
1:9e87d08:             }
1:9e87d08:         }
1:9e87d08:         try {
1:9e87d08:             bOut.flush();
1:9e87d08:             bOut.close();
1:9e87d08:         } catch (IOException ioe) {
1:9e87d08:             warn("Flushing/closing stream for " + pom.getCanonicalPath() +
1:9e87d08:                     " failed: " + ioe.getMessage());
1:9e87d08:         }
1:9e87d08:         int result = checkResult(replaced, pom);
1:9e87d08:         if (result == 0) {
1:9e87d08:             info("Replaced " + replaced + " version tag(s) in " +
1:9e87d08:                     pom.getParentFile().getName() + "/" + pom.getName());
1:9e87d08:         } else if (result > 0) {
1:9e87d08:             warn("Too many version tags (" + replaced + " > " +
1:9e87d08:                     (replaced - result) + ") replaced in " + pom.getPath());
1:9e87d08:         } else {
1:9e87d08:             warn("Too few version tags (" + replaced + " < " +
1:9e87d08:                     (replaced - result) + ") replaced in " + pom.getPath());
1:9e87d08:         }
1:9e87d08:         return warnings;
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Reads the contents of a text file.
1:9e87d08:      *
1:9e87d08:      * @param f the file to read
1:9e87d08:      * @return A list containing the lines of the file.
1:9e87d08:      * @throws IOException if reading the file fails
1:9e87d08:      */
1:9e87d08:     private List<String> readFile(File f)
1:9e87d08:             throws IOException {
1:9e87d08:         ArrayList<String> lines = new ArrayList<String>();
1:9e87d08:         BufferedReader bIn = new BufferedReader(new FileReader(f));
1:9e87d08:         String lineIn;
1:9e87d08:         try {
1:9e87d08:             while ((lineIn = bIn.readLine()) != null) {
1:9e87d08:                 lines.add(lineIn);
1:9e87d08:             }
1:9e87d08:         } finally {
1:9e87d08:             try {
1:9e87d08:                 bIn.close();
1:9e87d08:             } catch (IOException ioe) {
1:9e87d08:                 // Just print a warning.
1:9e87d08:                 warn("Failed to close input stream for " + f.getPath() + ": " +
1:9e87d08:                         ioe.getMessage());
1:9e87d08:             }
1:9e87d08:         }
1:9e87d08:         return lines;
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Quits the JVM if a failure is detected.
1:9e87d08:      *
1:9e87d08:      * @param success the return value to check
1:9e87d08:      */
1:9e87d08:     private static void ensureSuccess(boolean success) {
1:9e87d08:         if (!success) {
1:9e87d08:             System.out.println();
1:9e87d08:             System.out.println(
1:9e87d08:                     "!! The process failed or was aborted by the user.");
1:9e87d08:             System.out.println(
1:9e87d08:                     "   Read the above output and take corrective measures.");
1:9e87d08:             System.exit(1);
1:9e87d08:         }
1:9e87d08:     }
1:9e87d08: 
1:9e87d08:     /**
1:9e87d08:      * Checks the current Derby jars in the source tree directory, obtains the
1:9e87d08:      * Derby version from them, and replaces the value of the placeholder
1:9e87d08:      * version tags in the POM files.
1:9e87d08:      * <p>
1:9e87d08:      * After this method has been successfully run you should be ready to
1:9e87d08:      * generate the Maven 2 artifacts for Derby.
1:9e87d08:      *
1:9e87d08:      * @param args ignored
1:9e87d08:      * @throws Exception if something goes wrong
1:9e87d08:      */
1:9e87d08:     public static void main(String[] args)
1:9e87d08:             throws Exception {
1:9e87d08:         SetDerbyVersion sdv = new SetDerbyVersion();
1:9e87d08:         ensureSuccess(sdv.checkJars());
1:9e87d08:         ensureSuccess(sdv.setPOMVersionTags());
1:9e87d08:         sdv.printSanityNote();
1:9e87d08:     }
1:9e87d08: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2e9fed4
/////////////////////////////////////////////////////////////////////////
1:         "derbyoptionaltools.jar",
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:9e87d08
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class SetDerbyVersion
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: import java.io.BufferedReader;
1: import java.io.BufferedWriter;
1: import java.io.EOFException;
1: import java.io.File;
1: import java.io.FileReader;
1: import java.io.FileWriter;
1: import java.io.IOException;
1: import java.io.InputStreamReader;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.Driver;
1: import java.util.ArrayList;
1: import java.util.List;
1: 
1: /**
1:  * Checks the current Derby jars in the source tree directory, obtains the
1:  * Derby version from them, and replaces the value of the placeholder
1:  * version tags in the POM files.
1:  * <p>
1:  * After this method has been successfully run you should be ready to
1:  * generate the Maven 2 artifacts for Derby.
1:  * <p>
1:  * The main task of this class is to replace the version tags in the Maven
1:  * POM files. The can be done manually, but exact process would vary from
1:  * platform to platform. Also, running a search-and-replace could potentially
1:  * replace tags not supposed to be replaced. To make the Maven 2 artifact
1:  * publish process simpler, this class was written.
1:  */
1: //@NotThreadSafe
1: public class SetDerbyVersion {
1: 
1:     private static final String PROMPT_CONT_WARN =
1:             "Do you want to continue despite the warnings?";
1:     private static final String PROMPT_USE_SANE =
1:             "Do you want to generate artifacts with SANE jars?";
1:     private static final String JDBC_URL =
1:             "jdbc:derby:memory:testDB;create=true";
1:     private static final String REL_JAR_PATH = "../jars";
1:     private static final File SANE = new File(REL_JAR_PATH, "sane");
1:     private static final File INSANE = new File(REL_JAR_PATH, "insane");
1:     /** List of required jar files the Maven 2 Derby artifacts. */
1:     private static final String[] JARS = new String[] {
1:         "derby.jar",
1:         "derby.war",
1:         "derbynet.jar",
1:         "derbyclient.jar",
1:         "derbytools.jar",
1:         // Ignore derbyTesting.jar, not part of the Maven 2 artifacts.
1:         // "derbyTesting.jar",
1:         // Ignore derbyrun.jar, not part of the Maven 2 artifacts.
1:         //"derbyrun.jar",
1:         // The various locale files.
1:         "derbyLocale_cs.jar",
1:         "derbyLocale_de_DE.jar",
1:         "derbyLocale_es.jar",
1:         "derbyLocale_fr.jar",
1:         "derbyLocale_hu.jar",
1:         "derbyLocale_it.jar",
1:         "derbyLocale_ja_JP.jar",
1:         "derbyLocale_ko_KR.jar",
1:         "derbyLocale_pl.jar",
1:         "derbyLocale_pt_BR.jar",
1:         "derbyLocale_ru.jar",
1:         "derbyLocale_zh_CN.jar",
1:         "derbyLocale_zh_TW.jar",
1:     };
1: 
1:     /**
1:      * Displays a prompt and obtains a yes / no answer from standard in.
1:      *
1:      * @param prompt the prompt to display
1:      * @return {@code true} if the answer is yes, {@code false} if the answer
1:      *      is no.
1:      * @throws IOException if reading from standard in fails
1:      */
1:     private static boolean getYesNoInput(String prompt)
1:             throws IOException {
1:         // We don't care about keeping the objects around, this method will
1:         // only be used a few times.
1:         BufferedReader bIn = new BufferedReader(
1:                 new InputStreamReader(System.in));
1:         while (true) {
1:             System.out.print(">> " + prompt + " (yes/no) ");
1:             String answer = bIn.readLine();
1:             if (answer == null) {
1:                 // We don't know what do to here, so just fail.
1:                 throw new EOFException("Input stream closed.");
1:             }
1:             if (answer.equals("yes")) {
1:                 return true;
1:             } else if (answer.equals("no")) {
1:                 return false;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Set to {@code true} if a warning message is printed. Must be manually
1:      * reset if used to check for warnings in a part of the code.
1:      */
1:     private boolean warnings = false;
1:     /** The version string inserted into the POMs. */
1:     private String versionString = "ALPHA_VERSION";
1:     private File PREFIX;
1: 
1:     /**
1:      * Prints a warning message and sets the internal warning flag.
1:      *
1:      * @param msg the message to print
1:      */
1:     private void warn(String msg) {
1:         warnings = true;
1:         System.out.println("WARNING! " + msg);
1:     }
1: 
1:     private void info(String msg) {
1:         System.out.println(msg);
1:     }
1: 
1:     /**
1:      * Checks that all required jars are found in the jar directory.
1:      *
1:      * @return {@code true} if all required jars exist, {@code false} otherwise.
1:      */
1:     public boolean checkJars()
1:             throws Exception {
1:         if (!SANE.exists() && !INSANE.exists()) {
1:             warn("No jars exist. Produce a Derby release build.");
1:             return false;
1:         }
1:         if (SANE.exists() && INSANE.exists()) {
1:             warn("Both SANE and INSANE jars exist.");
1:             return false;
1:         }
1:         PREFIX = SANE.exists() ? SANE : INSANE;
1:         if (SANE.exists()) {
1:             warn("Only SANE jars exist. Normally INSANE jars are used for a " +
1:                     "release.");
1:             boolean answer = getYesNoInput(PROMPT_USE_SANE);
1:             if (!answer) {
1:                 return false;
1:             }
1:         }
1:         URL[] URLS = new URL[JARS.length];
1:         for (int i=0; i < JARS.length; i++) {
1:             URLS[i] = new File(PREFIX, JARS[i]).toURI().toURL();
1:         }
1: 
1:         warnings = false; // Reuse the warnings flag.
1:         // Make sure the files are there.
1:         for (URL url : URLS) {
1:             File f = new File(url.toURI());
1:             info(String.format(
1:                     "Checking file: %-30s %,12d bytes",
1:                     f.getName(), f.length()));
1:             if (!f.exists()) {
1:                 warn("Missing file: " + f.getCanonicalPath());
1:             } else if (f.length() == 0) {
1:                 warn("Empty file: " + f.getCanonicalPath());
1:             }
1:         }
1:         info("");
1:         if (warnings) {
1:             // Fail here.
1:             warn("There are missing or empty jar files.");
1:             return false;
1:         }
1: 
1:         // The class loader used for the Derby jars.
1:         URLClassLoader cl = new URLClassLoader(URLS, null);
1: 
1:         // Extra sanity check for the sanity...
1:         try {
1:             Class.forName(
1:                     "org.apache.derby.shared.common.sanity.SanityManager",
1:                     true ,cl);
1:             if (PREFIX == INSANE) {
1:                 warn("Found SanityManager in INSANE build. Aborting.");
1:                 return false;
1:             }
1:         } catch (ClassNotFoundException cnfe) {
1:             if (PREFIX == SANE) {
1:                 warn("Unable to load SanityManager in SANE build. Aborting.");
1:                 return false;
1:             }
1:         }
1: 
1:         // Fire up Derby to get the version string.
1:         Class driverClass =
1:                 Class.forName("org.apache.derby.jdbc.EmbeddedDriver", true, cl);
1:         Driver driver = (Driver)driverClass.newInstance();
1:         Connection con = driver.connect(JDBC_URL, null);
1:         DatabaseMetaData meta = con.getMetaData();
1:         con.close();
1:         // Delete the derby.log file.
1:         new File("derby.log").delete();
1: 
1:         // I.e.: 10.6.0.0 alpha - (882129M)
1:         String fullVersion = meta.getDatabaseProductVersion();
1:         String[] components = fullVersion.split(" - ");
1:         versionString = components[0].replaceAll(" ", "_");
1:         String srcRevision = components[1].replaceAll("\\(|\\)", "");
1:         info("Obtained product version string: " + fullVersion);
1:         info("(version=" + versionString + ", revision=" + srcRevision + ")");
1:         if (versionString.contains("beta")) {
1:             warn("This is a BETA build.");
1:         }
1:         if (versionString.contains("alpha")) {
1:             warn("This is an ALPHA build.");
1:         }
1:         if (srcRevision.endsWith("M")) {
1:             warn("The sources had been modified when the jars were built.");
1:             warnings = true;
1:         }
1:         if (warnings) {
1:             if (!getYesNoInput(PROMPT_CONT_WARN)) {
1:                 return false;
1:             }
1:         }
1:         return true;
1:     }
1: 
1:     /**
1:      * Replaces the relevant version tags in the various POM files.
1:      *
1:      * @throws IOException if accessing a POM file fails
1:      */
1:     public boolean setPOMVersionTags()
1:             throws IOException {
1:         File curDir = new File(".");
1:         boolean gotWarnings = false;
1:         // We only descend one level, no need for a recursive method.
1:         for (File topLevel : curDir.listFiles()) {
1:             if (topLevel.getName().equals("pom.xml")) {
1:                 gotWarnings |= setVersionTag(topLevel);
1:             }
1:             if (topLevel.isDirectory()) {
1:                 for (File l1 : topLevel.listFiles()) {
1:                     if (l1.getName().equals("pom.xml")) {
1:                         gotWarnings |= setVersionTag(l1);
1:                         // There is only one POM in each sub-directory.
1:                         break;
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         // See if we ran into problems when replacing the version tags.
1:         info("");
1:         if (gotWarnings) {
1:             warn("There were errors replacing the POM version tags.");
1:         } else {
1:             info("POM version tags replacement succeeded.");
1:             info("It is recommended that you verify the POM diffs " +
1:                     "before running Maven.");
1:         }
1:         return (warnings == false);
1:     }
1: 
1:     public void printSanityNote()
1:             throws IOException {
1:         if (PREFIX == SANE) {
1:             info("");
1:             info("NOTE: Remember to change the <sanity> tag in the top-level");
1:             info("      POM, setting it to 'sane'.");
1:         }
1:     }
1: 
1:     /**
1:      * Verifies that the correct number of tags were replaced in the POM.
1:      *
1:      * @param replaceCount the number of tags replaced
1:      * @param pom the POM modified
1:      * @return {@code 0} if the check passed, a negative value if too few tags
1:      *      were replaced, and a positive value if too many tags were replaced.
1:      */
1:     private int checkResult(int replaceCount, File pom) {
1:         // The locales requires two replacements, due to the dependency.
1:         String parent = pom.getParent();
1:         if (parent.contains("derbyLocale")) {
1:             return (replaceCount - 2);
1:         // derbynet also requries two replacements (derby.jar dependency)
1:         } else if (parent.contains("net")) {
1:             return (replaceCount - 2);
1:         } else {
1:             return (replaceCount - 1);
1:         }
1:     }
1: 
1:     /**
1:      * Replaces all qualifying version tags in the specified POM.
1:      *
1:      * @param pom the POM to modify
1:      * @return {@code false} if warnings were produced when replacing,
1:      *      {@code true} if all seemed to go well.
1:      *
1:      * @throws IOException if reading or writing to the POM file fails
1:      */
1:     private boolean setVersionTag(File pom)
1:             throws IOException {
1:         // Clear internal warning flag.
1:         warnings = false;
1:         // Just read the whole file into memory.
1:         List<String> lines = readFile(pom);
1: 
1:         // Start writing the file back out, and search for tags to replace.
1:         BufferedWriter bOut = new BufferedWriter(new FileWriter(pom, false));
1:         int replaced = 0;
1:         boolean artifactIdOk = false;
1:         boolean groupIdOk = false;
1:         // Could have used XML, but keep it simple.
1:         // artifactId and groupId are used to qualify the version tag, as it can
1:         // be used in more places than those we want to replace.
1:         for (String line : lines) {
1:             // Look for tags for qualification.
1:             if (line.trim().startsWith("<artifactId>") &&
1:                     line.contains("derby")) {
1:                 artifactIdOk = true;
1:             } else if (line.trim().startsWith("<groupId>") &&
1:                     line.contains("org.apache.derby")) {
1:                 groupIdOk = true;
1:             }
1: 
1:             // Change line if a qualified version tag, echo otherwise.
1:             if (line.trim().startsWith("<version>") &&
1:                     artifactIdOk && groupIdOk) {
1:                 // Replace tag.
1:                 int whitespaceTag = line.indexOf(">");
1:                 bOut.write(line.substring(0, whitespaceTag +1));
1:                 bOut.write(versionString);
1:                 int tagEnd = line.indexOf("<", whitespaceTag);
1:                 bOut.write(line.substring(tagEnd));
1:                 bOut.newLine();
1:                 replaced++;
1:                 artifactIdOk = groupIdOk = false;
1:             } else {
1:                 bOut.write(line);
1:                 bOut.newLine();
1:             }
1:         }
1:         try {
1:             bOut.flush();
1:             bOut.close();
1:         } catch (IOException ioe) {
1:             warn("Flushing/closing stream for " + pom.getCanonicalPath() +
1:                     " failed: " + ioe.getMessage());
1:         }
1:         int result = checkResult(replaced, pom);
1:         if (result == 0) {
1:             info("Replaced " + replaced + " version tag(s) in " +
1:                     pom.getParentFile().getName() + "/" + pom.getName());
1:         } else if (result > 0) {
1:             warn("Too many version tags (" + replaced + " > " +
1:                     (replaced - result) + ") replaced in " + pom.getPath());
1:         } else {
1:             warn("Too few version tags (" + replaced + " < " +
1:                     (replaced - result) + ") replaced in " + pom.getPath());
1:         }
1:         return warnings;
1:     }
1: 
1:     /**
1:      * Reads the contents of a text file.
1:      *
1:      * @param f the file to read
1:      * @return A list containing the lines of the file.
1:      * @throws IOException if reading the file fails
1:      */
1:     private List<String> readFile(File f)
1:             throws IOException {
1:         ArrayList<String> lines = new ArrayList<String>();
1:         BufferedReader bIn = new BufferedReader(new FileReader(f));
1:         String lineIn;
1:         try {
1:             while ((lineIn = bIn.readLine()) != null) {
1:                 lines.add(lineIn);
1:             }
1:         } finally {
1:             try {
1:                 bIn.close();
1:             } catch (IOException ioe) {
1:                 // Just print a warning.
1:                 warn("Failed to close input stream for " + f.getPath() + ": " +
1:                         ioe.getMessage());
1:             }
1:         }
1:         return lines;
1:     }
1: 
1:     /**
1:      * Quits the JVM if a failure is detected.
1:      *
1:      * @param success the return value to check
1:      */
1:     private static void ensureSuccess(boolean success) {
1:         if (!success) {
1:             System.out.println();
1:             System.out.println(
1:                     "!! The process failed or was aborted by the user.");
1:             System.out.println(
1:                     "   Read the above output and take corrective measures.");
1:             System.exit(1);
1:         }
1:     }
1: 
1:     /**
1:      * Checks the current Derby jars in the source tree directory, obtains the
1:      * Derby version from them, and replaces the value of the placeholder
1:      * version tags in the POM files.
1:      * <p>
1:      * After this method has been successfully run you should be ready to
1:      * generate the Maven 2 artifacts for Derby.
1:      *
1:      * @param args ignored
1:      * @throws Exception if something goes wrong
1:      */
1:     public static void main(String[] args)
1:             throws Exception {
1:         SetDerbyVersion sdv = new SetDerbyVersion();
1:         ensureSuccess(sdv.checkJars());
1:         ensureSuccess(sdv.setPOMVersionTags());
1:         sdv.printSanityNote();
1:     }
1: }
============================================================================