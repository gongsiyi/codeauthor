1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.ConstraintConstantAction
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
16:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:af1c18c: import java.util.ArrayList;
1:af1c18c: import java.util.List;
2:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:1e2aae0: import org.apache.derby.iapi.reference.SQLState;
1:1e2aae0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:4cc0287: import org.apache.derby.iapi.sql.Activation;
1:1e2aae0: import org.apache.derby.iapi.sql.PreparedStatement;
1:1e2aae0: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ForeignKeyConstraintDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.GroupFetchScanController;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:1e2aae0: import org.apache.derby.iapi.types.NumberDataValue;
1:af1c18c: import org.apache.derby.impl.sql.execute.DeferredConstraintsMemory.CheckInfo;
1:af1c18c: import org.apache.derby.impl.store.access.heap.HeapRowLocation;
1:af1c18c: import org.apache.derby.shared.common.sanity.SanityManager;
2:eac0369: /**
1:eac0369:  *	This class  describes actions that are ALWAYS performed for a
1:eac0369:  *	constraint creation at Execution time.
1:eac0369:  *
1:eac0369:  *	@version 0.1
1:eac0369:  */
1:eac0369: 
1:eac0369: public abstract class ConstraintConstantAction extends DDLSingleTableConstantAction 
1:eac0369: {
1:eac0369: 
1:eac0369: 	protected	String			constraintName;
1:eac0369: 	protected	int				constraintType;
1:eac0369: 	protected	String			tableName;
1:eac0369: 	protected	String			schemaName;
1:eac0369: 	protected	UUID			schemaId;
1:eac0369: 	protected  IndexConstantAction indexAction;
1:af1c18c:     protected   UUID            constraintId;
1:eac0369: 
1:eac0369: 	// CONSTRUCTORS
1:eac0369: 	/**
1:eac0369: 	 *	Make one of these puppies.
1:eac0369: 	 *
1:eac0369: 	 *  @param constraintName	Constraint name.
1:eac0369: 	 *  @param constraintType	Constraint type.
1:eac0369: 	 *  @param tableName		Table name.
1:eac0369: 	 *  @param tableId			UUID of table.
1:eac0369: 	 *  @param schemaName		schema that table and constraint lives in.
1:eac0369: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
1:eac0369: 	 *  RESOLVE - the next parameter should go away once we use UUIDs
1:eac0369: 	 *			  (Generated constraint names will be based off of uuids)
1:eac0369: 	 */
1:eac0369: 	ConstraintConstantAction(
1:eac0369: 		               String	constraintName,
1:eac0369: 					   int		constraintType,
1:eac0369: 		               String	tableName,
1:eac0369: 					   UUID		tableId,
1:eac0369: 					   String	schemaName,
1:eac0369: 					   IndexConstantAction indexAction)
1:eac0369: 	{
1:eac0369: 		super(tableId);
1:eac0369: 		this.constraintName = constraintName;
1:eac0369: 		this.constraintType = constraintType;
1:eac0369: 		this.tableName = tableName;
1:eac0369: 		this.indexAction = indexAction;
1:eac0369: 		this.schemaName = schemaName;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(schemaName != null, "Constraint schema name is null");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// Class implementation
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the constraint type.
1:eac0369: 	 *
1:eac0369: 	 * @return The constraint type
1:eac0369: 	 */
1:eac0369: 	public	int getConstraintType()
1:eac0369: 	{
1:eac0369: 		return constraintType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the constraint name
1:eac0369: 	  *
1:eac0369: 	  *	@return	the constraint name
1:eac0369: 	  */
1:eac0369:     public	String	getConstraintName() { return constraintName; }
1:eac0369: 
1:af1c18c:     /**
1:af1c18c:      * Get the constraint id of the constraint
1:af1c18c:      * @return constraint id
1:af1c18c:      */
1:af1c18c:     public UUID getConstraintId() {
1:af1c18c:         return constraintId;
1:af1c18c:     }
1:af1c18c: 
1:af1c18c: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the associated index constant action.
1:eac0369: 	  *
1:eac0369: 	  *	@return	the constant action for the backing index
1:eac0369: 	  */
1:eac0369:     public	IndexConstantAction	getIndexAction() { return indexAction; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make sure that the foreign key constraint is valid
1:eac0369: 	 * with the existing data in the target table.  Open
1:eac0369: 	 * the table, if there aren't any rows, ok.  If there
1:eac0369: 	 * are rows, open a scan on the referenced key with
1:eac0369: 	 * table locking at level 2.  Pass in the scans to
1:eac0369: 	 * the BulkRIChecker.  If any rows fail, barf.
1:eac0369: 	 *
1:eac0369: 	 * @param	tc		transaction controller
1:eac0369: 	 * @param	dd		data dictionary
1:eac0369: 	 * @param	fk		foreign key constraint
1:eac0369: 	 * @param	refcd	referenced key
1:eac0369: 	 * @param 	indexTemplateRow	index template row
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	static void validateFKConstraint
1:eac0369: 	(
1:4cc0287:         Activation                          activation,
1:eac0369: 		TransactionController				tc,
1:eac0369: 		DataDictionary						dd,
1:eac0369: 		ForeignKeyConstraintDescriptor		fk,
1:eac0369: 		ReferencedKeyConstraintDescriptor	refcd,
1:eac0369: 		ExecRow 							indexTemplateRow 
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		GroupFetchScanController refScan = null;
1:eac0369: 
1:eac0369: 		GroupFetchScanController fkScan = 
1:eac0369:             tc.openGroupFetchScan(
1:eac0369:                 fk.getIndexConglomerateDescriptor(dd).getConglomerateNumber(),
1:eac0369:                 false,                       			// hold 
1:eac0369:                 0, 										// read only
1:801cf0d:                 TransactionController.MODE_TABLE,       // already locked
1:801cf0d:                 TransactionController.ISOLATION_READ_COMMITTED,
1:801cf0d:                 (FormatableBitSet)null,                 // retrieve all fields
1:eac0369:                 (DataValueDescriptor[])null,    	    // startKeyValue
1:eac0369:                 ScanController.GE,            			// startSearchOp
1:eac0369:                 null,                         			// qualifier
1:eac0369:                 (DataValueDescriptor[])null,  			// stopKeyValue
1:eac0369:                 ScanController.GT             			// stopSearchOp 
1:eac0369:                 );
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** If we have no rows, then we are ok.  This will 
1:eac0369: 			** catch the CREATE TABLE T (x int references P) case
1:eac0369: 			** (as well as an ALTER TABLE ADD CONSTRAINT where there
1:eac0369: 			** are no rows in the target table).
1:eac0369: 			*/	
1:eac0369: 			if (!fkScan.next())
1:eac0369: 			{
1:eac0369: 				fkScan.close();
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			fkScan.reopenScan(
1:eac0369: 					(DataValueDescriptor[])null,    		// startKeyValue
1:eac0369: 					ScanController.GE,            			// startSearchOp
1:eac0369: 					null,                         			// qualifier
1:eac0369: 					(DataValueDescriptor[])null,  			// stopKeyValue
1:eac0369: 					ScanController.GT             			// stopSearchOp 
1:eac0369: 					);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Make sure each row in the new fk has a matching
1:eac0369: 			** referenced key.  No need to get any special locking
1:eac0369: 			** on the referenced table because it cannot delete
1:eac0369: 			** any keys we match because it will block on the table
1:eac0369: 			** lock on the fk table (we have an ex tab lock on
1:eac0369: 			** the target table of this ALTER TABLE command).
1:eac0369: 			** Note that we are doing row locking on the referenced
1:eac0369: 			** table.  We could speed things up and get table locking
1:eac0369: 			** because we are likely to be hitting a lot of rows
1:eac0369: 			** in the referenced table, but we are going to err
1:eac0369: 			** on the side of concurrency here.
1:eac0369: 			*/
1:eac0369: 			refScan = 
1:eac0369:                 tc.openGroupFetchScan(
1:eac0369: 					refcd.getIndexConglomerateDescriptor(dd).getConglomerateNumber(),
1:eac0369:                         false,                       	// hold 
1:eac0369:                         0, 								// read only
1:801cf0d:                         TransactionController.MODE_RECORD,
1:801cf0d:                         TransactionController.ISOLATION_READ_COMMITTED,
1:801cf0d:                                               // read committed is good enough
1:801cf0d:                         (FormatableBitSet)null,         // retrieve all fields
1:eac0369:                         (DataValueDescriptor[])null,    // startKeyValue
1:eac0369:                         ScanController.GE,            	// startSearchOp
1:eac0369:                         null,                         	// qualifier
1:eac0369:                         (DataValueDescriptor[])null,  	// stopKeyValue
1:eac0369:                         ScanController.GT             	// stopSearchOp 
1:eac0369:                         );
1:eac0369: 
1:4cc0287:             RIBulkChecker riChecker = new RIBulkChecker(
1:4cc0287:                     activation,
1:4cc0287:                     refScan,
1:4cc0287:                     fkScan,
1:4cc0287:                     indexTemplateRow,
1:4cc0287:                     true,               // fail on 1st failure
1:4cc0287:                     (ConglomerateController)null,
1:4cc0287:                     (ExecRow)null,
1:4cc0287:                     fk.getTableDescriptor().getSchemaName(),
1:4cc0287:                     fk.getTableDescriptor().getName(),
1:4cc0287:                     fk.getUUID(),
1:4cc0287:                     fk.deferrable(),
1:4cc0287:                     fk.getIndexConglomerateDescriptor(dd).
1:4cc0287:                         getConglomerateNumber(),
1:4cc0287:                     refcd.getIndexConglomerateDescriptor(dd).
1:4cc0287:                         getConglomerateNumber());
1:eac0369: 
1:eac0369: 			int numFailures = riChecker.doCheck();
1:eac0369: 			if (numFailures > 0)
1:eac0369: 			{
1:eac0369: 				StandardException se = StandardException.newException(SQLState.LANG_ADD_FK_CONSTRAINT_VIOLATION, 
1:eac0369: 									fk.getConstraintName(), 
1:eac0369: 									fk.getTableDescriptor().getName());
1:eac0369: 				throw se;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (fkScan != null)
1:eac0369: 			{
1:eac0369: 				fkScan.close();
1:eac0369: 				fkScan = null;
1:eac0369: 			}
1:eac0369: 			if (refScan != null)
1:eac0369: 			{
1:eac0369: 				refScan.close();
1:eac0369: 				refScan = null;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Evaluate a check constraint or not null column constraint.  
1:eac0369: 	 * Generate a query of the
1:eac0369: 	 * form SELECT COUNT(*) FROM t where NOT(<check constraint>)
1:eac0369: 	 * and run it by compiling and executing it.   Will
1:eac0369: 	 * work ok if the table is empty and query returns null.
1:eac0369: 	 *
1:eac0369: 	 * @param constraintName	constraint name
1:eac0369: 	 * @param constraintText	constraint text
1:af1c18c:      * @param constraintId      constraint id
1:eac0369: 	 * @param td				referenced table
1:eac0369: 	 * @param lcc				the language connection context
1:eac0369: 	 * @param isCheckConstraint	the constraint is a check constraint
1:af1c18c:      * @param isInitiallyDeferred {@code true} if the constraint is
1:af1c18c:      *                          initially deferred
1:eac0369:      *
1:eac0369: 	 * @return true if null constraint passes, false otherwise
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException if check constraint fails
1:eac0369: 	 */
1:eac0369: 	 static boolean validateConstraint
1:eac0369: 	(
1:eac0369: 		String							constraintName,
1:eac0369: 		String							constraintText,
1:af1c18c:         UUID                            constraintId,
1:eac0369: 		TableDescriptor					td,
1:eac0369: 		LanguageConnectionContext		lcc,
1:af1c18c:         boolean                         isCheckConstraint,
1:af1c18c:         boolean                         isInitiallyDeferred
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:801cf0d:         StringBuilder checkStmt = new StringBuilder();
1:eac0369: 		/* should not use select sum(not(<check-predicate>) ? 1: 0) because
1:eac0369: 		 * that would generate much more complicated code and may exceed Java
1:eac0369: 		 * limits if we have a large number of check constraints, beetle 4347
1:eac0369: 		 */
1:eac0369: 		checkStmt.append("SELECT COUNT(*) FROM ");
1:eac0369: 		checkStmt.append(td.getQualifiedName());
1:eac0369: 		checkStmt.append(" WHERE NOT(");
1:eac0369: 		checkStmt.append(constraintText);
1:eac0369: 		checkStmt.append(")");
1:eac0369: 	
1:eac0369: 		ResultSet rs = null;
1:eac0369: 		try
1:eac0369: 		{
1:5087be8: 			PreparedStatement ps = lcc.prepareInternalStatement(checkStmt.toString());
1:eac0369: 
1:3fcea8a:             // This is a substatement; for now, we do not set any timeout
1:3fcea8a:             // for it. We might change this behaviour later, by linking
1:3fcea8a:             // timeout to its parent statement's timeout settings.
1:e3883f5: 			rs = ps.executeSubStatement(lcc, false, 0L);
1:eac0369: 			ExecRow row = rs.getNextRow();
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (row == null)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("did not get any rows back from query: "+checkStmt.toString());
1:eac0369: 				}
1:eac0369: 			}
1:3fcea8a: 
1:eac0369: 			Number value = ((Number)((NumberDataValue)row.getRowArray()[0]).getObject());
1:eac0369: 			/*
1:eac0369: 			** Value may be null if there are no rows in the
1:eac0369: 			** table.
1:eac0369: 			*/
1:eac0369: 			if ((value != null) && (value.longValue() != 0))
1:eac0369: 			{	
1:af1c18c:                 // The query yielded a valid value > 0, so we must conclude the
1:af1c18c:                 // check constraint is violated.
1:af1c18c:                 if (isCheckConstraint) {
1:af1c18c:                     if (isInitiallyDeferred) {
1:af1c18c:                         // Remember the violation
1:af1c18c:                         List<UUID> violatingConstraints = new ArrayList<UUID>();
1:af1c18c:                         violatingConstraints.add(constraintId);
1:af1c18c: 
1:af1c18c:                         // FIXME: We don't know the row locations of the
1:af1c18c:                         // violating rows, so for now, just pretend we know one,
1:af1c18c:                         // then invalidate the row location information forcing
1:af1c18c:                         // full table check at validation time
1:4cc0287:                         CheckInfo newCi[] = new CheckInfo[1];
1:af1c18c:                         DeferredConstraintsMemory.rememberCheckViolations(
1:af1c18c:                                 lcc,
1:f6d02c9:                                 td.getObjectID(),
1:af1c18c:                                 td.getSchemaName(),
1:af1c18c:                                 td.getName(),
1:af1c18c:                                 null,
1:af1c18c:                                 violatingConstraints,
1:4cc0287:                                 new HeapRowLocation() /* dummy */,
1:4cc0287:                                 newCi);
1:4cc0287:                         newCi[0].setInvalidatedRowLocations();
1:af1c18c: 
1:af1c18c:                     } else {
1:af1c18c:                         throw StandardException.newException(
1:af1c18c:                                 SQLState.LANG_ADD_CHECK_CONSTRAINT_FAILED,
1:af1c18c:                                 constraintName,
1:af1c18c:                                 td.getQualifiedName(),
1:af1c18c:                                 value.toString());
1:af1c18c:                     }
1:af1c18c:                 }
1:eac0369: 				/*
1:eac0369: 				 * for not null constraint violations exception will be thrown in caller
1:eac0369: 				 * check constraint will not get here since exception is thrown
1:eac0369: 				 * above
1:eac0369: 				 */
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (rs != null)
1:eac0369: 			{
1:eac0369: 				rs.close();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
1:                                 td.getObjectID(),
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.Activation;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Activation                          activation,
/////////////////////////////////////////////////////////////////////////
1:             RIBulkChecker riChecker = new RIBulkChecker(
1:                     activation,
1:                     refScan,
1:                     fkScan,
1:                     indexTemplateRow,
1:                     true,               // fail on 1st failure
1:                     (ConglomerateController)null,
1:                     (ExecRow)null,
1:                     fk.getTableDescriptor().getSchemaName(),
1:                     fk.getTableDescriptor().getName(),
1:                     fk.getUUID(),
1:                     fk.deferrable(),
1:                     fk.getIndexConglomerateDescriptor(dd).
1:                         getConglomerateNumber(),
1:                     refcd.getIndexConglomerateDescriptor(dd).
1:                         getConglomerateNumber());
/////////////////////////////////////////////////////////////////////////
1:                         CheckInfo newCi[] = new CheckInfo[1];
/////////////////////////////////////////////////////////////////////////
1:                                 new HeapRowLocation() /* dummy */,
1:                                 newCi);
1:                         newCi[0].setInvalidatedRowLocations();
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
0: import java.util.HashMap;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: import org.apache.derby.impl.sql.execute.DeferredConstraintsMemory.CheckInfo;
0: import org.apache.derby.impl.sql.execute.DeferredConstraintsMemory.ValidationInfo;
1: import org.apache.derby.impl.store.access.heap.HeapRowLocation;
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     protected   UUID            constraintId;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the constraint id of the constraint
1:      * @return constraint id
1:      */
1:     public UUID getConstraintId() {
1:         return constraintId;
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param constraintId      constraint id
1:      * @param isInitiallyDeferred {@code true} if the constraint is
1:      *                          initially deferred
/////////////////////////////////////////////////////////////////////////
1:         UUID                            constraintId,
1:         boolean                         isCheckConstraint,
1:         boolean                         isInitiallyDeferred
/////////////////////////////////////////////////////////////////////////
1:                 // The query yielded a valid value > 0, so we must conclude the
1:                 // check constraint is violated.
1:                 if (isCheckConstraint) {
1:                     if (isInitiallyDeferred) {
1:                         // Remember the violation
1:                         List<UUID> violatingConstraints = new ArrayList<UUID>();
1:                         violatingConstraints.add(constraintId);
1: 
1:                         // FIXME: We don't know the row locations of the
1:                         // violating rows, so for now, just pretend we know one,
1:                         // then invalidate the row location information forcing
1:                         // full table check at validation time
1:                         DeferredConstraintsMemory.rememberCheckViolations(
1:                                 lcc,
0:                                 td.getHeapConglomerateId(),
1:                                 td.getSchemaName(),
1:                                 td.getName(),
1:                                 null,
1:                                 violatingConstraints,
0:                                 new HeapRowLocation() /* dummy */);
0:                         HashMap<Long, ValidationInfo>
0:                                 hashTables = lcc.getDeferredHashTables();
0:                         CheckInfo ci = (CheckInfo)hashTables.get(
0:                                 Long.valueOf(td.getHeapConglomerateId()));
0:                         ci.setInvalidatedRowLocations();
1: 
1:                     } else {
1:                         throw StandardException.newException(
1:                                 SQLState.LANG_ADD_CHECK_CONSTRAINT_FAILED,
1:                                 constraintName,
1:                                 td.getQualifiedName(),
1:                                 value.toString());
1:                     }
1:                 }
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1:                 TransactionController.MODE_TABLE,       // already locked
1:                 TransactionController.ISOLATION_READ_COMMITTED,
1:                 (FormatableBitSet)null,                 // retrieve all fields
/////////////////////////////////////////////////////////////////////////
1:                         TransactionController.MODE_RECORD,
1:                         TransactionController.ISOLATION_READ_COMMITTED,
1:                                               // read committed is good enough
1:                         (FormatableBitSet)null,         // retrieve all fields
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder checkStmt = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
commit:e3883f5
/////////////////////////////////////////////////////////////////////////
1: 			rs = ps.executeSubStatement(lcc, false, 0L);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e2aae0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.PreparedStatement;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.types.NumberDataValue;
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             // This is a substatement; for now, we do not set any timeout
1:             // for it. We might change this behaviour later, by linking
1:             // timeout to its parent statement's timeout settings.
0:             ps.setQueryTimeout(0L);
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.ConstraintConstantAction
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.CheckConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
1: import org.apache.derby.iapi.sql.dictionary.ForeignKeyConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Statement;
0: import org.apache.derby.iapi.sql.PreparedStatement;
1: 
0: import org.apache.derby.iapi.types.NumberDataValue;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.GroupFetchScanController;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: /**
1:  *	This class  describes actions that are ALWAYS performed for a
1:  *	constraint creation at Execution time.
1:  *
1:  *	@version 0.1
0:  *	@author Jerry Brenner
1:  */
1: 
1: public abstract class ConstraintConstantAction extends DDLSingleTableConstantAction 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	protected	String			constraintName;
1: 	protected	int				constraintType;
1: 	protected	String			tableName;
1: 	protected	String			schemaName;
1: 	protected	UUID			schemaId;
1: 	protected  IndexConstantAction indexAction;
1: 
1: 	// CONSTRUCTORS
1: 	/**
1: 	 *	Make one of these puppies.
1: 	 *
1: 	 *  @param constraintName	Constraint name.
1: 	 *  @param constraintType	Constraint type.
1: 	 *  @param tableName		Table name.
1: 	 *  @param tableId			UUID of table.
1: 	 *  @param schemaName		schema that table and constraint lives in.
0: 	 *  @param tdSd				the schema that table lives in.
1: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
1: 	 *  RESOLVE - the next parameter should go away once we use UUIDs
1: 	 *			  (Generated constraint names will be based off of uuids)
1: 	 */
1: 	ConstraintConstantAction(
1: 		               String	constraintName,
1: 					   int		constraintType,
1: 		               String	tableName,
1: 					   UUID		tableId,
1: 					   String	schemaName,
1: 					   IndexConstantAction indexAction)
1: 	{
1: 		super(tableId);
1: 		this.constraintName = constraintName;
1: 		this.constraintType = constraintType;
1: 		this.tableName = tableName;
1: 		this.indexAction = indexAction;
1: 		this.schemaName = schemaName;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(schemaName != null, "Constraint schema name is null");
1: 		}
1: 	}
1: 
1: 	// Class implementation
1: 
1: 	/**
1: 	 * Get the constraint type.
1: 	 *
1: 	 * @return The constraint type
1: 	 */
1: 	public	int getConstraintType()
1: 	{
1: 		return constraintType;
1: 	}
1: 
1: 	/**
1: 	  *	Get the constraint name
1: 	  *
1: 	  *	@return	the constraint name
1: 	  */
1:     public	String	getConstraintName() { return constraintName; }
1: 
1: 	/**
1: 	  *	Get the associated index constant action.
1: 	  *
1: 	  *	@return	the constant action for the backing index
1: 	  */
1:     public	IndexConstantAction	getIndexAction() { return indexAction; }
1: 
1: 	/**
1: 	 * Make sure that the foreign key constraint is valid
1: 	 * with the existing data in the target table.  Open
1: 	 * the table, if there aren't any rows, ok.  If there
1: 	 * are rows, open a scan on the referenced key with
1: 	 * table locking at level 2.  Pass in the scans to
1: 	 * the BulkRIChecker.  If any rows fail, barf.
1: 	 *
1: 	 * @param	tc		transaction controller
1: 	 * @param	dd		data dictionary
1: 	 * @param	fk		foreign key constraint
1: 	 * @param	refcd	referenced key
1: 	 * @param 	indexTemplateRow	index template row
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	static void validateFKConstraint
1: 	(
1: 		TransactionController				tc,
1: 		DataDictionary						dd,
1: 		ForeignKeyConstraintDescriptor		fk,
1: 		ReferencedKeyConstraintDescriptor	refcd,
1: 		ExecRow 							indexTemplateRow 
1: 	)
1: 		throws StandardException
1: 	{
1: 
1: 		GroupFetchScanController refScan = null;
1: 
1: 		GroupFetchScanController fkScan = 
1:             tc.openGroupFetchScan(
1:                 fk.getIndexConglomerateDescriptor(dd).getConglomerateNumber(),
1:                 false,                       			// hold 
1:                 0, 										// read only
0:                 tc.MODE_TABLE,							// already locked
0:                 tc.ISOLATION_READ_COMMITTED,			// whatever
0:                 (FormatableBitSet)null, 							// retrieve all fields
1:                 (DataValueDescriptor[])null,    	    // startKeyValue
1:                 ScanController.GE,            			// startSearchOp
1:                 null,                         			// qualifier
1:                 (DataValueDescriptor[])null,  			// stopKeyValue
1:                 ScanController.GT             			// stopSearchOp 
1:                 );
1: 
1: 		try
1: 		{
1: 			/*
1: 			** If we have no rows, then we are ok.  This will 
1: 			** catch the CREATE TABLE T (x int references P) case
1: 			** (as well as an ALTER TABLE ADD CONSTRAINT where there
1: 			** are no rows in the target table).
1: 			*/	
1: 			if (!fkScan.next())
1: 			{
1: 				fkScan.close();
1: 				return;
1: 			}
1: 
1: 			fkScan.reopenScan(
1: 					(DataValueDescriptor[])null,    		// startKeyValue
1: 					ScanController.GE,            			// startSearchOp
1: 					null,                         			// qualifier
1: 					(DataValueDescriptor[])null,  			// stopKeyValue
1: 					ScanController.GT             			// stopSearchOp 
1: 					);
1: 
1: 			/*
1: 			** Make sure each row in the new fk has a matching
1: 			** referenced key.  No need to get any special locking
1: 			** on the referenced table because it cannot delete
1: 			** any keys we match because it will block on the table
1: 			** lock on the fk table (we have an ex tab lock on
1: 			** the target table of this ALTER TABLE command).
1: 			** Note that we are doing row locking on the referenced
1: 			** table.  We could speed things up and get table locking
1: 			** because we are likely to be hitting a lot of rows
1: 			** in the referenced table, but we are going to err
1: 			** on the side of concurrency here.
1: 			*/
1: 			refScan = 
1:                 tc.openGroupFetchScan(
1: 					refcd.getIndexConglomerateDescriptor(dd).getConglomerateNumber(),
1:                         false,                       	// hold 
1:                         0, 								// read only
0:                         tc.MODE_RECORD,
0:                         tc.ISOLATION_READ_COMMITTED,	// read committed is good enough
0:                         (FormatableBitSet)null, 					// retrieve all fields
1:                         (DataValueDescriptor[])null,    // startKeyValue
1:                         ScanController.GE,            	// startSearchOp
1:                         null,                         	// qualifier
1:                         (DataValueDescriptor[])null,  	// stopKeyValue
1:                         ScanController.GT             	// stopSearchOp 
1:                         );
1: 
0: 			RIBulkChecker riChecker = new RIBulkChecker(refScan, 
0: 										fkScan, 
0: 										indexTemplateRow, 	
0: 										true, 				// fail on 1st failure
0: 										(ConglomerateController)null,
0: 										(ExecRow)null);
1: 
1: 			int numFailures = riChecker.doCheck();
1: 			if (numFailures > 0)
1: 			{
1: 				StandardException se = StandardException.newException(SQLState.LANG_ADD_FK_CONSTRAINT_VIOLATION, 
1: 									fk.getConstraintName(), 
1: 									fk.getTableDescriptor().getName());
1: 				throw se;
1: 			}
1: 		}
1: 		finally
1: 		{
1: 			if (fkScan != null)
1: 			{
1: 				fkScan.close();
1: 				fkScan = null;
1: 			}
1: 			if (refScan != null)
1: 			{
1: 				refScan.close();
1: 				refScan = null;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Evaluate a check constraint or not null column constraint.  
1: 	 * Generate a query of the
1: 	 * form SELECT COUNT(*) FROM t where NOT(<check constraint>)
1: 	 * and run it by compiling and executing it.   Will
1: 	 * work ok if the table is empty and query returns null.
1: 	 *
1: 	 * @param constraintName	constraint name
1: 	 * @param constraintText	constraint text
1: 	 * @param td				referenced table
1: 	 * @param lcc				the language connection context
1: 	 * @param isCheckConstraint	the constraint is a check constraint
1:      *
1: 	 * @return true if null constraint passes, false otherwise
1: 	 *
1: 	 * @exception StandardException if check constraint fails
1: 	 */
1: 	 static boolean validateConstraint
1: 	(
1: 		String							constraintName,
1: 		String							constraintText,
1: 		TableDescriptor					td,
1: 		LanguageConnectionContext		lcc,
0: 		boolean							isCheckConstraint
1: 	)
1: 		throws StandardException
1: 	{
0: 		StringBuffer checkStmt = new StringBuffer();
1: 		/* should not use select sum(not(<check-predicate>) ? 1: 0) because
1: 		 * that would generate much more complicated code and may exceed Java
1: 		 * limits if we have a large number of check constraints, beetle 4347
1: 		 */
1: 		checkStmt.append("SELECT COUNT(*) FROM ");
1: 		checkStmt.append(td.getQualifiedName());
1: 		checkStmt.append(" WHERE NOT(");
1: 		checkStmt.append(constraintText);
1: 		checkStmt.append(")");
1: 	
1: 		ResultSet rs = null;
1: 		try
1: 		{
0: 			PreparedStatement ps = lcc.prepareInternalStatement(td.getSchemaDescriptor(), checkStmt.toString());
1: 
0: 			rs = ps.execute(lcc, false);
1: 			ExecRow row = rs.getNextRow();
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (row == null)
1: 				{
1: 					SanityManager.THROWASSERT("did not get any rows back from query: "+checkStmt.toString());
1: 				}
1: 			}
1: 
0: 			DataValueDescriptor[] rowArray = row.getRowArray();
1: 			Number value = ((Number)((NumberDataValue)row.getRowArray()[0]).getObject());
1: 			/*
1: 			** Value may be null if there are no rows in the
1: 			** table.
1: 			*/
1: 			if ((value != null) && (value.longValue() != 0))
1: 			{	
0: 				//check constraint violated
0: 				if (isCheckConstraint)
0: 					throw StandardException.newException(SQLState.LANG_ADD_CHECK_CONSTRAINT_FAILED, 
0: 						constraintName, td.getQualifiedName(), value.toString());
1: 				/*
1: 				 * for not null constraint violations exception will be thrown in caller
1: 				 * check constraint will not get here since exception is thrown
1: 				 * above
1: 				 */
1: 				return false;
1: 			}
1: 		}
1: 		finally
1: 		{
1: 			if (rs != null)
1: 			{
1: 				rs.close();
1: 			}
1: 		}
1: 		return true;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:318307e
/////////////////////////////////////////////////////////////////////////
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5087be8
/////////////////////////////////////////////////////////////////////////
1: 			PreparedStatement ps = lcc.prepareInternalStatement(checkStmt.toString());
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
commit:1373f5a
/////////////////////////////////////////////////////////////////////////
0: 			rs = ps.execute(lcc, false, 0L);
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.CheckConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.ForeignKeyConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Statement;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: 
0: import org.apache.derby.iapi.types.NumberDataValue;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.GroupFetchScanController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: /**
0:  *	This class  describes actions that are ALWAYS performed for a
0:  *	constraint creation at Execution time.
0:  *
0:  *	@version 0.1
0:  *	@author Jerry Brenner
0:  */
0: 
0: public abstract class ConstraintConstantAction extends DDLSingleTableConstantAction 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	protected	String			constraintName;
0: 	protected	int				constraintType;
0: 	protected	String			tableName;
0: 	protected	String			schemaName;
0: 	protected	UUID			schemaId;
0: 	protected  IndexConstantAction indexAction;
0: 
0: 	// CONSTRUCTORS
0: 	/**
0: 	 *	Make one of these puppies.
0: 	 *
0: 	 *  @param constraintName	Constraint name.
0: 	 *  @param constraintType	Constraint type.
0: 	 *  @param tableName		Table name.
0: 	 *  @param tableId			UUID of table.
0: 	 *  @param schemaName		schema that table and constraint lives in.
0: 	 *  @param tdSd				the schema that table lives in.
0: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
0: 	 *  RESOLVE - the next parameter should go away once we use UUIDs
0: 	 *			  (Generated constraint names will be based off of uuids)
0: 	 */
0: 	ConstraintConstantAction(
0: 		               String	constraintName,
0: 					   int		constraintType,
0: 		               String	tableName,
0: 					   UUID		tableId,
0: 					   String	schemaName,
0: 					   IndexConstantAction indexAction)
0: 	{
0: 		super(tableId);
0: 		this.constraintName = constraintName;
0: 		this.constraintType = constraintType;
0: 		this.tableName = tableName;
0: 		this.indexAction = indexAction;
0: 		this.schemaName = schemaName;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(schemaName != null, "Constraint schema name is null");
0: 		}
0: 	}
0: 
0: 	// Class implementation
0: 
0: 	/**
0: 	 * Get the constraint type.
0: 	 *
0: 	 * @return The constraint type
0: 	 */
0: 	public	int getConstraintType()
0: 	{
0: 		return constraintType;
0: 	}
0: 
0: 	/**
0: 	  *	Get the constraint name
0: 	  *
0: 	  *	@return	the constraint name
0: 	  */
0:     public	String	getConstraintName() { return constraintName; }
0: 
0: 	/**
0: 	  *	Get the associated index constant action.
0: 	  *
0: 	  *	@return	the constant action for the backing index
0: 	  */
0:     public	IndexConstantAction	getIndexAction() { return indexAction; }
0: 
0: 	/**
0: 	 * Make sure that the foreign key constraint is valid
0: 	 * with the existing data in the target table.  Open
0: 	 * the table, if there aren't any rows, ok.  If there
0: 	 * are rows, open a scan on the referenced key with
0: 	 * table locking at level 2.  Pass in the scans to
0: 	 * the BulkRIChecker.  If any rows fail, barf.
0: 	 *
0: 	 * @param	tc		transaction controller
0: 	 * @param	dd		data dictionary
0: 	 * @param	fk		foreign key constraint
0: 	 * @param	refcd	referenced key
0: 	 * @param 	indexTemplateRow	index template row
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	static void validateFKConstraint
0: 	(
0: 		TransactionController				tc,
0: 		DataDictionary						dd,
0: 		ForeignKeyConstraintDescriptor		fk,
0: 		ReferencedKeyConstraintDescriptor	refcd,
0: 		ExecRow 							indexTemplateRow 
0: 	)
0: 		throws StandardException
0: 	{
0: 
0: 		GroupFetchScanController refScan = null;
0: 
0: 		GroupFetchScanController fkScan = 
0:             tc.openGroupFetchScan(
0:                 fk.getIndexConglomerateDescriptor(dd).getConglomerateNumber(),
0:                 false,                       			// hold 
0:                 0, 										// read only
0:                 tc.MODE_TABLE,							// already locked
0:                 tc.ISOLATION_READ_COMMITTED,			// whatever
0:                 (FormatableBitSet)null, 							// retrieve all fields
0:                 (DataValueDescriptor[])null,    	    // startKeyValue
0:                 ScanController.GE,            			// startSearchOp
0:                 null,                         			// qualifier
0:                 (DataValueDescriptor[])null,  			// stopKeyValue
0:                 ScanController.GT             			// stopSearchOp 
0:                 );
0: 
0: 		try
0: 		{
0: 			/*
0: 			** If we have no rows, then we are ok.  This will 
0: 			** catch the CREATE TABLE T (x int references P) case
0: 			** (as well as an ALTER TABLE ADD CONSTRAINT where there
0: 			** are no rows in the target table).
0: 			*/	
0: 			if (!fkScan.next())
0: 			{
0: 				fkScan.close();
0: 				return;
0: 			}
0: 
0: 			fkScan.reopenScan(
0: 					(DataValueDescriptor[])null,    		// startKeyValue
0: 					ScanController.GE,            			// startSearchOp
0: 					null,                         			// qualifier
0: 					(DataValueDescriptor[])null,  			// stopKeyValue
0: 					ScanController.GT             			// stopSearchOp 
0: 					);
0: 
0: 			/*
0: 			** Make sure each row in the new fk has a matching
0: 			** referenced key.  No need to get any special locking
0: 			** on the referenced table because it cannot delete
0: 			** any keys we match because it will block on the table
0: 			** lock on the fk table (we have an ex tab lock on
0: 			** the target table of this ALTER TABLE command).
0: 			** Note that we are doing row locking on the referenced
0: 			** table.  We could speed things up and get table locking
0: 			** because we are likely to be hitting a lot of rows
0: 			** in the referenced table, but we are going to err
0: 			** on the side of concurrency here.
0: 			*/
0: 			refScan = 
0:                 tc.openGroupFetchScan(
0: 					refcd.getIndexConglomerateDescriptor(dd).getConglomerateNumber(),
0:                         false,                       	// hold 
0:                         0, 								// read only
0:                         tc.MODE_RECORD,
0:                         tc.ISOLATION_READ_COMMITTED,	// read committed is good enough
0:                         (FormatableBitSet)null, 					// retrieve all fields
0:                         (DataValueDescriptor[])null,    // startKeyValue
0:                         ScanController.GE,            	// startSearchOp
0:                         null,                         	// qualifier
0:                         (DataValueDescriptor[])null,  	// stopKeyValue
0:                         ScanController.GT             	// stopSearchOp 
0:                         );
0: 
0: 			RIBulkChecker riChecker = new RIBulkChecker(refScan, 
0: 										fkScan, 
0: 										indexTemplateRow, 	
0: 										true, 				// fail on 1st failure
0: 										(ConglomerateController)null,
0: 										(ExecRow)null);
0: 
0: 			int numFailures = riChecker.doCheck();
0: 			if (numFailures > 0)
0: 			{
0: 				StandardException se = StandardException.newException(SQLState.LANG_ADD_FK_CONSTRAINT_VIOLATION, 
0: 									fk.getConstraintName(), 
0: 									fk.getTableDescriptor().getName());
0: 				throw se;
0: 			}
0: 		}
0: 		finally
0: 		{
0: 			if (fkScan != null)
0: 			{
0: 				fkScan.close();
0: 				fkScan = null;
0: 			}
0: 			if (refScan != null)
0: 			{
0: 				refScan.close();
0: 				refScan = null;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Evaluate a check constraint or not null column constraint.  
0: 	 * Generate a query of the
0: 	 * form SELECT COUNT(*) FROM t where NOT(<check constraint>)
0: 	 * and run it by compiling and executing it.   Will
0: 	 * work ok if the table is empty and query returns null.
0: 	 *
0: 	 * @param constraintName	constraint name
0: 	 * @param constraintText	constraint text
0: 	 * @param td				referenced table
0: 	 * @param lcc				the language connection context
0: 	 * @param isCheckConstraint	the constraint is a check constraint
0:      *
0: 	 * @return true if null constraint passes, false otherwise
0: 	 *
0: 	 * @exception StandardException if check constraint fails
0: 	 */
0: 	 static boolean validateConstraint
0: 	(
0: 		String							constraintName,
0: 		String							constraintText,
0: 		TableDescriptor					td,
0: 		LanguageConnectionContext		lcc,
0: 		boolean							isCheckConstraint
0: 	)
0: 		throws StandardException
0: 	{
0: 		StringBuffer checkStmt = new StringBuffer();
0: 		/* should not use select sum(not(<check-predicate>) ? 1: 0) because
0: 		 * that would generate much more complicated code and may exceed Java
0: 		 * limits if we have a large number of check constraints, beetle 4347
0: 		 */
0: 		checkStmt.append("SELECT COUNT(*) FROM ");
0: 		checkStmt.append(td.getQualifiedName());
0: 		checkStmt.append(" WHERE NOT(");
0: 		checkStmt.append(constraintText);
0: 		checkStmt.append(")");
0: 	
0: 		ResultSet rs = null;
0: 		try
0: 		{
0: 			PreparedStatement ps = lcc.prepareInternalStatement(td.getSchemaDescriptor(), checkStmt.toString());
0: 
0: 			rs = ps.execute(lcc, false);
0: 			ExecRow row = rs.getNextRow();
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (row == null)
0: 				{
0: 					SanityManager.THROWASSERT("did not get any rows back from query: "+checkStmt.toString());
0: 				}
0: 			}
0: 
0: 			DataValueDescriptor[] rowArray = row.getRowArray();
0: 			Number value = ((Number)((NumberDataValue)row.getRowArray()[0]).getObject());
0: 			/*
0: 			** Value may be null if there are no rows in the
0: 			** table.
0: 			*/
0: 			if ((value != null) && (value.longValue() != 0))
0: 			{	
0: 				//check constraint violated
0: 				if (isCheckConstraint)
0: 					throw StandardException.newException(SQLState.LANG_ADD_CHECK_CONSTRAINT_FAILED, 
0: 						constraintName, td.getQualifiedName(), value.toString());
0: 				/*
0: 				 * for not null constraint violations exception will be thrown in caller
0: 				 * check constraint will not get here since exception is thrown
0: 				 * above
0: 				 */
0: 				return false;
0: 			}
0: 		}
0: 		finally
0: 		{
0: 			if (rs != null)
0: 			{
0: 				rs.close();
0: 			}
0: 		}
0: 		return true;
0: 	}
0: }
============================================================================