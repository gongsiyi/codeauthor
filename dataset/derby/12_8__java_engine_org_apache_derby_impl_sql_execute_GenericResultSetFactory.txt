1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.GenericResultSetFactory
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
16:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:f6d02c9: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:b31849d: import org.apache.derby.iapi.sql.Activation;
1:b31849d: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.conn.Authorizer;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:b31849d: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:b31849d: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1:b31849d: import org.apache.derby.iapi.store.access.Qualifier;
1:b31849d: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:cbdc90c: import org.apache.derby.iapi.types.DataValueDescriptor;
4:eac0369: /**
1:eac0369:  * ResultSetFactory provides a wrapper around all of
1:eac0369:  * the result sets used in this execution implementation.
1:eac0369:  * This removes the need of generated classes to do a new
1:eac0369:  * and of the generator to know about all of the result
1:eac0369:  * sets.  Both simply know about this interface to getting
1:eac0369:  * them.
1:eac0369:  * <p>
1:eac0369:  * In terms of modularizing, we can create just an interface
1:eac0369:  * to this class and invoke the interface.  Different implementations
1:eac0369:  * would get the same information provided but could potentially
1:eac0369:  * massage/ignore it in different ways to satisfy their
1:eac0369:  * implementations.  The practicality of this is to be seen.
1:eac0369:  * <p>
1:eac0369:  * The cost of this type of factory is that once you touch it,
1:eac0369:  * you touch *all* of the possible result sets, not just
1:eac0369:  * the ones you need.  So the first time you touch it could
1:eac0369:  * be painful ... that might be a problem for execution.
1:eac0369:  *
1:eac0369:  */
1:eac0369: public class GenericResultSetFactory implements ResultSetFactory 
3:eac0369: {
1:eac0369: 	//
1:eac0369: 	// ResultSetFactory interface
1:eac0369: 	//
1:eac0369: 	public GenericResultSetFactory()
1:eac0369: 	{
3:eac0369: 	}
1:cbdc90c: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getInsertResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:af1c18c:     public ResultSet getInsertResultSet(NoPutResultSet source,
1:af1c18c:                                         GeneratedMethod generationClauses,
1:af1c18c:                                         GeneratedMethod checkGM,
1:af1c18c:                                         int fullTemplate,
1:af1c18c:                                         String schemaName,
1:af1c18c:                                         String tableName)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:6b26ee1: 		Activation activation = source.getActivation();
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
1:af1c18c: 
1:af1c18c:         return new InsertResultSet(source,
1:af1c18c:                                    generationClauses,
1:af1c18c:                                    checkGM,
1:af1c18c:                                    fullTemplate,
1:af1c18c:                                    schemaName,
1:af1c18c:                                    tableName,
1:af1c18c:                                    activation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getInsertVTIResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public ResultSet getInsertVTIResultSet(NoPutResultSet source, 
1:6b26ee1: 										NoPutResultSet vtiRS
1:6b26ee1: 										)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:6b26ee1: 		Activation activation = source.getActivation();
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
1:eac0369: 		return new InsertVTIResultSet(source, vtiRS, activation );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getDeleteVTIResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:6b26ee1: 	public ResultSet getDeleteVTIResultSet(NoPutResultSet source)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:6b26ee1: 		Activation activation = source.getActivation();
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
1:eac0369: 		return new DeleteVTIResultSet(source, activation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getDeleteResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:6b26ee1: 	public ResultSet getDeleteResultSet(NoPutResultSet source)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:6b26ee1: 		Activation activation = source.getActivation();
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
1:eac0369: 		return new DeleteResultSet(source, activation );
1:eac0369: 	}
1:eac0369: 
1:508a010: 	/**
1:508a010: 		@see ResultSetFactory#getMergeResultSet
1:508a010: 		@exception StandardException thrown on error
1:508a010: 	 */
1:508a010: 	public ResultSet getMergeResultSet(NoPutResultSet drivingLeftJoin)
1:508a010:         throws StandardException
1:508a010:     {
1:508a010: 		Activation activation = drivingLeftJoin.getActivation();
1:508a010: 		getAuthorizer( activation ).authorize( activation, Authorizer.SQL_WRITE_OP );
1:508a010: 		return new MergeResultSet( drivingLeftJoin, activation );
1:508a010:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getDeleteCascadeResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public ResultSet getDeleteCascadeResultSet(NoPutResultSet source, 
1:eac0369: 											   int constantActionItem,
1:eac0369: 											   ResultSet[] dependentResultSets,
1:eac0369: 											   String resultSetId)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:6b26ee1: 		Activation activation = source.getActivation();
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
1:eac0369: 		return new DeleteCascadeResultSet(source, activation, 
1:eac0369: 										  constantActionItem,
1:eac0369: 										  dependentResultSets, 
1:eac0369: 										  resultSetId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getUpdateResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:ca28065: 	public ResultSet getUpdateResultSet(NoPutResultSet source, GeneratedMethod generationClauses,
1:ca28065: 										GeneratedMethod checkGM)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:6b26ee1: 		Activation activation = source.getActivation();
1:eac0369: 		//The stress test failed with null pointer exception in here once and then
1:eac0369: 		//it didn't happen again. It can be a jit problem because after this null
1:eac0369: 		//pointer exception, the cleanup code in UpdateResultSet got a null
1:eac0369: 		//pointer exception too which can't happen since the cleanup code checks
1:eac0369: 		//for null value before doing anything.
1:eac0369: 		//In any case, if this ever happens again, hopefully the following
1:eac0369: 		//assertion code will catch it.
1:cbdc90c: 		if (SanityManager.DEBUG)
1:eac0369: 		{
2:eac0369: 			SanityManager.ASSERT(getAuthorizer(activation) != null, "Authorizer is null");
1:eac0369: 		}
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
1:ca28065: 		return new UpdateResultSet(source, generationClauses, checkGM, activation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getUpdateVTIResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:93ff8cc: 	public ResultSet getUpdateVTIResultSet(NoPutResultSet source)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:93ff8cc: 		Activation activation = source.getActivation();
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
1:eac0369: 		return new UpdateVTIResultSet(source, activation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getDeleteCascadeUpdateResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public ResultSet getDeleteCascadeUpdateResultSet(NoPutResultSet source,
1:ca28065:                                                      GeneratedMethod generationClauses,
3:eac0369: 													 GeneratedMethod checkGM,
1:eac0369: 													 int constantActionItem,
1:eac0369: 													 int rsdItem)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:6b26ee1: 		Activation activation = source.getActivation();
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
1:ca28065: 		return new UpdateResultSet(source, generationClauses, checkGM, activation,
1:eac0369: 								   constantActionItem, rsdItem);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getCallStatementResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public ResultSet getCallStatementResultSet(GeneratedMethod methodCall,
7:eac0369: 				Activation activation)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_CALL_OP);
1:eac0369: 		return new CallStatementResultSet(methodCall, activation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getProjectRestrictResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getProjectRestrictResultSet(NoPutResultSet source,
1:6b26ee1: 		GeneratedMethod restriction, 
1:eac0369: 		GeneratedMethod projection, int resultSetNumber,
1:eac0369: 		GeneratedMethod constantRestriction,
1:eac0369: 		int mapRefItem,
1:1d0c809:         int cloneMapItem,
1:eac0369: 		boolean reuseResult,
1:eac0369: 		boolean doesProjection,
1:af1c18c:         boolean validatingCheckConstraint,
1:f6d02c9:         String validatingBaseTableUUIDString,
2:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:f6d02c9:         UUID    validatingBaseTableUUID = UUID.NULL.equals( validatingBaseTableUUIDString ) ?
1:f6d02c9:             null :
1:f6d02c9:             source.getActivation()
1:f6d02c9:             .getLanguageConnectionContext()
1:f6d02c9:             .getDataDictionary()
1:f6d02c9:             .getUUIDFactory()
1:f6d02c9:             .recreateUUID( validatingBaseTableUUIDString );
1:f6d02c9: 
1:6b26ee1: 		return new ProjectRestrictResultSet(source, source.getActivation(), 
1:eac0369: 			restriction, projection, resultSetNumber, 
1:1d0c809:             constantRestriction, mapRefItem, cloneMapItem,
1:eac0369: 			reuseResult,
1:eac0369: 			doesProjection,
1:af1c18c:             validatingCheckConstraint,
1:f6d02c9:             validatingBaseTableUUID,
1:eac0369: 		    optimizerEstimatedRowCount,
1:f77f36d: 			optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getHashTableResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getHashTableResultSet(NoPutResultSet source,
1:93ff8cc: 		GeneratedMethod singleTableRestriction, 
1:eac0369: 		Qualifier[][] equijoinQualifiers,
1:eac0369: 		GeneratedMethod projection, int resultSetNumber,
1:eac0369: 		int mapRefItem,
1:eac0369: 		boolean reuseResult,
1:eac0369: 		int keyColItem,
1:eac0369: 		boolean removeDuplicates,
1:eac0369: 		long maxInMemoryRowCount,
1:eac0369: 		int	initialCapacity,
1:eac0369: 		float loadFactor,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:93ff8cc: 		return new HashTableResultSet(source, source.getActivation(), 
1:eac0369: 			singleTableRestriction, 
1:eac0369:             equijoinQualifiers,
1:eac0369: 			projection, resultSetNumber, 
1:eac0369: 			mapRefItem, 
1:eac0369: 			reuseResult,
1:eac0369: 			keyColItem, removeDuplicates,
1:eac0369: 			maxInMemoryRowCount,
1:eac0369: 			initialCapacity,
1:eac0369: 			loadFactor,
1:eac0369: 			true,		// Skip rows with 1 or more null key columns
1:eac0369: 		    optimizerEstimatedRowCount,
1:f77f36d: 			optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getSortResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getSortResultSet(NoPutResultSet source,
1:eac0369: 		boolean distinct, 
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int orderItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int maxRowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new SortResultSet(source, 
1:eac0369: 			distinct, 
1:eac0369: 			isInSortedOrder,
1:eac0369: 			orderItem,
1:93ff8cc: 			source.getActivation(), 
1:c723732: 			rowAllocator, 
1:eac0369: 			maxRowSize,
1:eac0369: 			resultSetNumber, 
1:eac0369: 		    optimizerEstimatedRowCount,
1:f77f36d: 			optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getScalarAggregateResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getScalarAggregateResultSet(NoPutResultSet source,
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int aggregateItem,
1:eac0369: 		int orderItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int maxRowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		boolean singleInputRow,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost) 
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new ScalarAggregateResultSet(
1:93ff8cc: 						source, isInSortedOrder, aggregateItem, source.getActivation(),
1:eac0369: 						rowAllocator, resultSetNumber, singleInputRow,
1:eac0369: 						optimizerEstimatedRowCount,
1:f77f36d: 						optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getDistinctScalarAggregateResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getDistinctScalarAggregateResultSet(NoPutResultSet source,
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int aggregateItem,
1:eac0369: 		int orderItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int maxRowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		boolean singleInputRow,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost) 
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new DistinctScalarAggregateResultSet(
1:93ff8cc: 						source, isInSortedOrder, aggregateItem, orderItem, source.getActivation(),
1:eac0369: 						rowAllocator, maxRowSize, resultSetNumber, singleInputRow,
1:eac0369: 						optimizerEstimatedRowCount,
1:f77f36d: 						optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getGroupedAggregateResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getGroupedAggregateResultSet(NoPutResultSet source,
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int aggregateItem,
1:eac0369: 		int orderItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int maxRowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		double optimizerEstimatedRowCount,
1:b5105f3: 		double optimizerEstimatedCost,
1:b5105f3: 		boolean isRollup) 
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new GroupedAggregateResultSet(
1:93ff8cc: 						source, isInSortedOrder, aggregateItem, orderItem, source.getActivation(),
1:eac0369: 						rowAllocator, maxRowSize, resultSetNumber, optimizerEstimatedRowCount,
1:b5105f3: 						optimizerEstimatedCost, isRollup);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getDistinctGroupedAggregateResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getDistinctGroupedAggregateResultSet(NoPutResultSet source,
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int aggregateItem,
1:eac0369: 		int orderItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int maxRowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		double optimizerEstimatedRowCount,
1:b5105f3: 		double optimizerEstimatedCost,
1:b5105f3: 		boolean isRollup) 
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new DistinctGroupedAggregateResultSet(
1:93ff8cc: 						source, isInSortedOrder, aggregateItem, orderItem, source.getActivation(),
1:eac0369: 						rowAllocator, maxRowSize, resultSetNumber, optimizerEstimatedRowCount,
1:b5105f3: 						optimizerEstimatedCost, isRollup);
1:eac0369: 	}
1:eac0369: 											
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getAnyResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getAnyResultSet(NoPutResultSet source,
1:6b26ee1: 		GeneratedMethod emptyRowFun, int resultSetNumber,
1:eac0369: 		int subqueryNumber, int pointOfAttachment,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new AnyResultSet(source,
1:6b26ee1: 					 source.getActivation(), emptyRowFun, resultSetNumber,
1:eac0369: 					 subqueryNumber, pointOfAttachment,
1:eac0369: 					 optimizerEstimatedRowCount,
1:f77f36d: 					 optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getOnceResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getOnceResultSet(NoPutResultSet source,
1:6b26ee1: 	 GeneratedMethod emptyRowFun,
1:eac0369: 		int cardinalityCheck, int resultSetNumber,
1:eac0369: 		int subqueryNumber, int pointOfAttachment,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new OnceResultSet(source,
1:6b26ee1: 					 source.getActivation(), emptyRowFun, 
1:eac0369: 					 cardinalityCheck, resultSetNumber,
1:eac0369: 					 subqueryNumber, pointOfAttachment,
1:eac0369: 				     optimizerEstimatedRowCount,
1:f77f36d: 					 optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getRowResultSet
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getRowResultSet(Activation activation, GeneratedMethod row,
1:eac0369: 									 boolean canCacheRow,
1:eac0369: 									 int resultSetNumber,
1:eac0369: 									 double optimizerEstimatedRowCount,
1:9e6e461: 									 double optimizerEstimatedCost)
1:eac0369: 	{
1:eac0369: 		return new RowResultSet(activation, row, canCacheRow, resultSetNumber, 
1:eac0369: 							    optimizerEstimatedRowCount,
1:f77f36d: 								optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getVTIResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:d868eed: 	public NoPutResultSet getVTIResultSet(Activation activation, int row,
1:eac0369: 									 int resultSetNumber,
1:eac0369: 									 GeneratedMethod constructor,
1:eac0369: 									 String javaClassName,
1:eac0369: 									 Qualifier[][] pushedQualifiers,
1:c723732: 									 int erdNumber,
1:eac0369: 									 boolean version2,
1:eac0369: 									 boolean reuseablePs,
1:eac0369: 									 int ctcNumber,
1:eac0369: 									 boolean isTarget,
1:eac0369: 									 int scanIsolationLevel,
1:eac0369: 									 double optimizerEstimatedRowCount,
1:4aef9b0: 									 double optimizerEstimatedCost,
1:f432362:                                      boolean isDerbyStyleTableFunction,
1:a2d0847:                                      int returnTypeNumber,
1:a2d0847:                                      int vtiProjectionNumber,
1:29007f0:                                      int vtiRestrictionNumber,
1:29007f0:                                      String vtiSchema,
1:29007f0:                                      String vtiName
1:4aef9b0:                                           )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return new VTIResultSet(activation, row, resultSetNumber, 
1:eac0369: 								constructor,
1:eac0369: 								javaClassName,
1:eac0369: 								pushedQualifiers,
1:c723732: 								erdNumber,
1:eac0369: 								version2, reuseablePs,
1:eac0369: 								ctcNumber,
1:eac0369: 								isTarget,
1:eac0369: 								scanIsolationLevel,
1:eac0369: 							    optimizerEstimatedRowCount,
1:4aef9b0: 								optimizerEstimatedCost,
1:f432362: 								isDerbyStyleTableFunction,
1:a2d0847:                                 returnTypeNumber,
1:a2d0847:                                 vtiProjectionNumber,
1:29007f0:                                 vtiRestrictionNumber,
1:29007f0:                                 vtiSchema,
1:29007f0:                                 vtiName
1:4aef9b0:                                 );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     	a hash scan generator, for ease of use at present.
1:eac0369: 		@see ResultSetFactory#getHashScanResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getHashScanResultSet(
1:c723732:                         			Activation activation,
1:eac0369: 									long conglomId,
1:eac0369: 									int scociItem,
1:959fef2: 									int resultRowTemplate,
1:eac0369: 									int resultSetNumber,
1:eac0369: 									GeneratedMethod startKeyGetter,
1:eac0369: 									int startSearchOperator,
1:eac0369: 									GeneratedMethod stopKeyGetter,
1:eac0369: 									int stopSearchOperator,
1:eac0369: 									boolean sameStartStopPosition,
1:eac0369: 									Qualifier[][] scanQualifiers,
1:eac0369: 									Qualifier[][] nextQualifiers,
1:eac0369: 									int initialCapacity,
1:eac0369: 									float loadFactor,
1:eac0369: 									int maxCapacity,
1:eac0369: 									int hashKeyColumn,
1:eac0369: 									String tableName,
1:c7248d5: 									String userSuppliedOptimizerOverrides,
1:eac0369: 									String indexName,
1:eac0369: 									boolean isConstraint,
2:eac0369: 									boolean forUpdate,
1:eac0369: 									int colRefItem,
1:eac0369: 									int indexColItem,
1:eac0369: 									int lockMode,
1:eac0369: 									boolean tableLocked,
1:eac0369: 									int isolationLevel,
1:eac0369: 									double optimizerEstimatedRowCount,
1:c723732: 									double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1:eac0369: 						getSavedObject(scociItem));
1:eac0369: 
1:eac0369: 		return new HashScanResultSet(
1:eac0369: 								conglomId,
1:eac0369: 								scoci,
1:c723732: 								activation,
1:959fef2: 								resultRowTemplate,
1:eac0369: 								resultSetNumber,
1:eac0369: 								startKeyGetter,
1:eac0369: 								startSearchOperator,
1:eac0369: 								stopKeyGetter,
1:eac0369: 								stopSearchOperator,
1:eac0369: 								sameStartStopPosition,
1:eac0369: 								scanQualifiers,
1:eac0369: 								nextQualifiers,
1:eac0369: 								initialCapacity,
1:eac0369: 								loadFactor,
1:eac0369: 								maxCapacity,
1:eac0369: 								hashKeyColumn,
1:eac0369: 								tableName,
1:c7248d5: 								userSuppliedOptimizerOverrides,
1:eac0369: 								indexName,
1:eac0369: 								isConstraint,
1:eac0369: 								forUpdate,
1:eac0369: 								colRefItem,
1:eac0369: 								lockMode,
1:eac0369: 								tableLocked,
1:eac0369: 								isolationLevel,
1:eac0369: 								true,		// Skip rows with 1 or more null key columns
1:eac0369: 								optimizerEstimatedRowCount,
1:f77f36d: 								optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     	a distinct scan generator, for ease of use at present.
1:eac0369: 		@see ResultSetFactory#getHashScanResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getDistinctScanResultSet(
1:93ff8cc:                          			Activation activation,
1:eac0369: 									long conglomId,
1:eac0369: 									int scociItem,
1:959fef2: 									int resultRowTemplate,
1:eac0369: 									int resultSetNumber,
1:eac0369: 									int hashKeyColumn,
1:eac0369: 									String tableName,
1:c7248d5: 									String userSuppliedOptimizerOverrides,
1:eac0369: 									String indexName,
1:eac0369: 									boolean isConstraint,
1:eac0369: 									int colRefItem,
1:eac0369: 									int lockMode,
1:eac0369: 									boolean tableLocked,
1:eac0369: 									int isolationLevel,
1:eac0369: 									double optimizerEstimatedRowCount,
1:9e6e461: 									double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1:eac0369: 						getSavedObject(scociItem));
1:eac0369: 		return new DistinctScanResultSet(
1:eac0369: 								conglomId,
1:eac0369: 								scoci,
3:eac0369: 								activation,
1:959fef2: 								resultRowTemplate,
1:eac0369: 								resultSetNumber,
1:eac0369: 								hashKeyColumn,
1:eac0369: 								tableName,
1:c7248d5: 								userSuppliedOptimizerOverrides,
1:eac0369: 								indexName,
1:eac0369: 								isConstraint,
1:eac0369: 								colRefItem,
1:eac0369: 								lockMode,
1:eac0369: 								tableLocked,
1:eac0369: 								isolationLevel,
1:eac0369: 								optimizerEstimatedRowCount,
1:f77f36d: 								optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     	a minimal table scan generator, for ease of use at present.
1:eac0369: 		@see ResultSetFactory#getTableScanResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getTableScanResultSet(
1:93ff8cc:                         			Activation activation,
1:eac0369: 									long conglomId,
1:eac0369: 									int scociItem,
1:959fef2: 									int resultRowTemplate,
1:eac0369: 									int resultSetNumber,
1:eac0369: 									GeneratedMethod startKeyGetter,
1:eac0369: 									int startSearchOperator,
1:eac0369: 									GeneratedMethod stopKeyGetter,
1:eac0369: 									int stopSearchOperator,
1:eac0369: 									boolean sameStartStopPosition,
1:eac0369: 									Qualifier[][] qualifiers,
1:eac0369: 									String tableName,
1:c7248d5: 									String userSuppliedOptimizerOverrides,
1:eac0369: 									String indexName,
1:eac0369: 									boolean isConstraint,
1:eac0369: 									boolean forUpdate,
1:eac0369: 									int colRefItem,
1:eac0369: 									int indexColItem,
1:eac0369: 									int lockMode,
1:eac0369: 									boolean tableLocked,
1:eac0369: 									int isolationLevel,
1:eac0369: 									boolean oneRowScan,
1:eac0369: 									double optimizerEstimatedRowCount,
1:9e6e461: 									double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1:eac0369: 						getSavedObject(scociItem));
1:eac0369: 		return new TableScanResultSet(
1:eac0369: 								conglomId,
1:eac0369: 								scoci,
1:eac0369: 								activation,
1:959fef2: 								resultRowTemplate,
1:eac0369: 								resultSetNumber,
1:eac0369: 								startKeyGetter,
1:eac0369: 								startSearchOperator,
1:eac0369: 								stopKeyGetter,
1:eac0369: 								stopSearchOperator,
1:eac0369: 								sameStartStopPosition,
1:eac0369: 								qualifiers,
1:eac0369: 								tableName,
1:c7248d5: 								userSuppliedOptimizerOverrides,
1:eac0369: 								indexName,
1:eac0369: 								isConstraint,
1:eac0369: 								forUpdate,
1:eac0369: 								colRefItem,
1:eac0369: 								indexColItem,
1:eac0369: 								lockMode,
1:eac0369: 								tableLocked,
1:eac0369: 								isolationLevel,
1:eac0369: 								1,	// rowsPerRead is 1 if not a bulkTableScan
1:eac0369: 								oneRowScan,
1:eac0369: 								optimizerEstimatedRowCount,
1:f77f36d: 								optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:af1c18c:     public NoPutResultSet getValidateCheckConstraintResultSet(
1:af1c18c:                                     Activation activation,
1:af1c18c:                                     long conglomId,
1:af1c18c:                                     int scociItem,
1:af1c18c:                                     int resultRowTemplate,
1:af1c18c:                                     int resultSetNumber,
1:af1c18c:                                     GeneratedMethod startKeyGetter,
1:af1c18c:                                     int startSearchOperator,
1:af1c18c:                                     GeneratedMethod stopKeyGetter,
1:af1c18c:                                     int stopSearchOperator,
1:af1c18c:                                     boolean sameStartStopPosition,
1:af1c18c:                                     Qualifier[][] qualifiers,
1:af1c18c:                                     String tableName,
1:af1c18c:                                     String userSuppliedOptimizerOverrides,
1:af1c18c:                                     String indexName,
1:af1c18c:                                     boolean isConstraint,
1:af1c18c:                                     boolean forUpdate,
1:af1c18c:                                     int colRefItem,
1:af1c18c:                                     int indexColItem,
1:af1c18c:                                     int lockMode,
1:af1c18c:                                     boolean tableLocked,
1:af1c18c:                                     int isolationLevel,
1:af1c18c:                                     boolean oneRowScan,
1:af1c18c:                                     double optimizerEstimatedRowCount,
1:af1c18c:                                     double optimizerEstimatedCost)
1:af1c18c:             throws StandardException
1:af1c18c:     {
1:af1c18c:         StaticCompiledOpenConglomInfo scoci =
1:af1c18c:             (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1:af1c18c:                                             getSavedObject(scociItem));
1:af1c18c:         return new ValidateCheckConstraintResultSet(
1:af1c18c:                                 conglomId,
1:af1c18c:                                 scoci,
1:af1c18c:                                 activation,
1:af1c18c:                                 resultRowTemplate,
1:af1c18c:                                 resultSetNumber,
1:af1c18c:                                 startKeyGetter,
1:af1c18c:                                 startSearchOperator,
1:af1c18c:                                 stopKeyGetter,
1:af1c18c:                                 stopSearchOperator,
1:af1c18c:                                 sameStartStopPosition,
1:af1c18c:                                 qualifiers,
1:af1c18c:                                 tableName,
1:af1c18c:                                 userSuppliedOptimizerOverrides,
1:af1c18c:                                 indexName,
1:af1c18c:                                 isConstraint,
1:af1c18c:                                 forUpdate,
1:af1c18c:                                 colRefItem,
1:af1c18c:                                 indexColItem,
1:af1c18c:                                 lockMode,
1:af1c18c:                                 tableLocked,
1:af1c18c:                                 isolationLevel,
1:af1c18c:                                 1,  // rowsPerRead is 1 if not a bulkTableScan
1:af1c18c:                                 oneRowScan,
1:af1c18c:                                 optimizerEstimatedRowCount,
1:af1c18c:                                 optimizerEstimatedCost);
1:af1c18c:     }
1:af1c18c: 
1:af1c18c:     /**
1:eac0369:     	Table/Index scan where rows are read in bulk
1:eac0369: 		@see ResultSetFactory#getBulkTableScanResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getBulkTableScanResultSet(
1:93ff8cc:                        			    Activation activation,
1:eac0369: 									long conglomId,
1:eac0369: 									int scociItem,
1:959fef2: 									int resultRowTemplate,
1:eac0369: 									int resultSetNumber,
1:eac0369: 									GeneratedMethod startKeyGetter,
1:eac0369: 									int startSearchOperator,
1:eac0369: 									GeneratedMethod stopKeyGetter,
1:eac0369: 									int stopSearchOperator,
1:eac0369: 									boolean sameStartStopPosition,
1:eac0369: 									Qualifier[][] qualifiers,
1:eac0369: 									String tableName,
1:c7248d5: 									String userSuppliedOptimizerOverrides,
1:eac0369: 									String indexName,
1:eac0369: 									boolean isConstraint,
1:eac0369: 									boolean forUpdate,
1:eac0369: 									int colRefItem,
1:eac0369: 									int indexColItem,
1:eac0369: 									int lockMode,
1:eac0369: 									boolean tableLocked,
1:eac0369: 									int isolationLevel,
1:eac0369: 									int rowsPerRead,
1:ec6fcf1:                                     boolean disableForHoldable,
1:eac0369: 									boolean oneRowScan,
1:eac0369: 									double optimizerEstimatedRowCount,
1:9e6e461: 									double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		//Prior to Cloudscape 10.0 release, holdability was false by default. Programmers had to explicitly
1:eac0369: 		//set the holdability to true using JDBC apis. Since holdability was not true by default, we chose to disable the
1:eac0369: 		//prefetching for RR and Serializable when holdability was explicitly set to true. 
1:eac0369: 		//But starting Cloudscape 10.0 release, in order to be DB2 compatible, holdability is set to true by default.
1:eac0369: 		//Because of that, we can not continue to disable the prefetching for RR and Serializable, since it causes
1:eac0369: 		//severe performance degradation - bug 5953.    
1:eac0369: 
1:eac0369:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1:eac0369: 						getSavedObject(scociItem));
1:eac0369: 		return new BulkTableScanResultSet(
1:eac0369: 								conglomId,
1:eac0369: 								scoci,
1:eac0369: 								activation,
1:959fef2: 								resultRowTemplate,
1:eac0369: 								resultSetNumber,
1:eac0369: 								startKeyGetter,
1:eac0369: 								startSearchOperator,
1:eac0369: 								stopKeyGetter,
1:eac0369: 								stopSearchOperator,
1:eac0369: 								sameStartStopPosition,
1:eac0369: 								qualifiers,
1:eac0369: 								tableName,
1:c7248d5: 								userSuppliedOptimizerOverrides,
1:eac0369: 								indexName,
1:eac0369: 								isConstraint,
1:eac0369: 								forUpdate,
1:eac0369: 								colRefItem,
1:eac0369: 								indexColItem,
1:eac0369: 								lockMode,
1:eac0369: 								tableLocked,
1:eac0369: 								isolationLevel,
1:eac0369: 								rowsPerRead,
1:ec6fcf1:                                 disableForHoldable,
1:eac0369: 								oneRowScan,
1:eac0369: 								optimizerEstimatedRowCount,
1:f77f36d: 								optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:cbdc90c: 		Multi-probing scan that probes an index for specific values contained
1:cbdc90c: 		in the received probe list.
1:cbdc90c: 
1:cbdc90c: 		All index rows for which the first column equals probeVals[0] will
1:cbdc90c: 		be returned, followed by all rows for which the first column equals
1:cbdc90c: 		probeVals[1], and so on.  Assumption is that we only get here if
1:cbdc90c: 		probeVals has at least one value.
1:cbdc90c: 
1:cbdc90c: 		@see ResultSetFactory#getMultiProbeTableScanResultSet
1:cbdc90c: 		@exception StandardException thrown on error
1:cbdc90c: 	 */
1:cbdc90c: 	public NoPutResultSet getMultiProbeTableScanResultSet(
1:028077e: 									Activation activation,
1:cbdc90c: 									long conglomId,
1:cbdc90c: 									int scociItem,
1:959fef2: 									int resultRowTemplate,
1:cbdc90c: 									int resultSetNumber,
1:cbdc90c: 									GeneratedMethod startKeyGetter,
1:cbdc90c: 									int startSearchOperator,
1:cbdc90c: 									GeneratedMethod stopKeyGetter,
1:cbdc90c: 									int stopSearchOperator,
1:cbdc90c: 									boolean sameStartStopPosition,
1:cbdc90c: 									Qualifier[][] qualifiers,
1:cbdc90c: 									DataValueDescriptor [] probeVals,
1:20bd3c0: 									int sortRequired,
1:cbdc90c: 									String tableName,
1:cbdc90c: 									String userSuppliedOptimizerOverrides,
1:cbdc90c: 									String indexName,
1:cbdc90c: 									boolean isConstraint,
1:cbdc90c: 									boolean forUpdate,
1:cbdc90c: 									int colRefItem,
1:cbdc90c: 									int indexColItem,
1:cbdc90c: 									int lockMode,
1:cbdc90c: 									boolean tableLocked,
1:cbdc90c: 									int isolationLevel,
1:cbdc90c: 									boolean oneRowScan,
1:cbdc90c: 									double optimizerEstimatedRowCount,
1:cbdc90c: 									double optimizerEstimatedCost)
1:cbdc90c: 			throws StandardException
1:cbdc90c: 	{
1:028077e: 		StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)
1:028077e: 			activation.getPreparedStatement().getSavedObject(scociItem);
1:cbdc90c: 
1:028077e: 		return new MultiProbeTableScanResultSet(
1:028077e: 								conglomId,
1:028077e: 								scoci,
1:028077e: 								activation,
1:959fef2: 								resultRowTemplate,
1:028077e: 								resultSetNumber,
1:028077e: 								startKeyGetter,
1:028077e: 								startSearchOperator,
1:028077e: 								stopKeyGetter,
1:028077e: 								stopSearchOperator,
1:028077e: 								sameStartStopPosition,
1:028077e: 								qualifiers,
1:028077e: 								probeVals,
1:20bd3c0: 								sortRequired,
1:028077e: 								tableName,
1:028077e: 								userSuppliedOptimizerOverrides,
1:028077e: 								indexName,
1:028077e: 								isConstraint,
1:028077e: 								forUpdate,
1:028077e: 								colRefItem,
1:028077e: 								indexColItem,
1:eac0369: 								lockMode,
1:eac0369: 								tableLocked,
1:eac0369: 								isolationLevel,
1:eac0369: 								oneRowScan,
1:eac0369: 								optimizerEstimatedRowCount,
1:f77f36d: 								optimizerEstimatedCost);
1:cbdc90c: 	}
1:cbdc90c: 
1:cbdc90c: 	/**
1:eac0369: 		@see ResultSetFactory#getIndexRowToBaseRowResultSet
1:c723732: 		@exception StandardException	Thrown on error
1:c723732: 	 */
1:eac0369: 	public NoPutResultSet getIndexRowToBaseRowResultSet(
1:eac0369: 								long conglomId,
1:eac0369: 								int scociItem,
1:c723732: 								NoPutResultSet source,
1:bda7291: 								int resultRowAllocator,
1:c723732: 								int resultSetNumber,
1:eac0369: 								String indexName,
1:eac0369: 								int heapColRefItem,
1:6853511: 								int allColRefItem,
1:6853511: 								int heapOnlyColRefItem,
1:eac0369: 								int indexColMapItem,
1:c723732: 								GeneratedMethod restriction,
1:eac0369: 								boolean forUpdate,
1:c723732: 								double optimizerEstimatedRowCount,
1:1705596: 								double optimizerEstimatedCost,
1:1705596: 								int baseColumnCount )
1:c723732: 			throws StandardException
1:c723732: 	{
1:eac0369: 		return new IndexRowToBaseRowResultSet(
1:eac0369: 								conglomId,
1:eac0369: 								scociItem,
1:93ff8cc: 								source.getActivation(),
1:c723732: 								source,
1:028077e: 								resultRowAllocator,
1:c723732: 								resultSetNumber,
1:eac0369: 								indexName,
1:eac0369: 								heapColRefItem,
1:6853511: 								allColRefItem,
1:6853511: 								heapOnlyColRefItem,
1:eac0369: 								indexColMapItem,
1:c723732: 								restriction,
1:eac0369: 								forUpdate,
1:028077e: 							    optimizerEstimatedRowCount,
1:1705596: 								optimizerEstimatedCost,
1:1705596: 								baseColumnCount);
1:cbdc90c: 	}
1:eac0369: 
1:eac0369: 	/**
1:7a9ce7e: 		@see ResultSetFactory#getWindowResultSet
1:7a9ce7e: 		@exception StandardException	Thrown on error
1:7a9ce7e: 	 */
1:7a9ce7e: 	public NoPutResultSet getWindowResultSet(
1:7a9ce7e: 								Activation activation,
1:7a9ce7e: 								NoPutResultSet source,
1:d868eed: 								int rowAllocator,
1:7a9ce7e: 								int resultSetNumber,
1:7a9ce7e: 								int erdNumber,
1:7a9ce7e: 								GeneratedMethod restriction,
1:7a9ce7e: 								double optimizerEstimatedRowCount,
1:7a9ce7e: 								double optimizerEstimatedCost)
1:7a9ce7e: 		throws StandardException
1:7a9ce7e: 	{
1:7a9ce7e: 		return new WindowResultSet(
1:7a9ce7e: 								activation,
1:7a9ce7e: 								source,
1:7a9ce7e: 								rowAllocator,
1:7a9ce7e: 								resultSetNumber,
1:7a9ce7e: 								erdNumber,
1:7a9ce7e: 								restriction,
1:7a9ce7e: 								optimizerEstimatedRowCount,
1:7a9ce7e: 								optimizerEstimatedCost);
1:7a9ce7e: 	}
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e: 	/**
1:eac0369: 		@see ResultSetFactory#getNestedLoopJoinResultSet
1:eac0369: 		@exception StandardException thrown on error
1:cbdc90c: 	 */
1:c723732: 
1:eac0369:     public NoPutResultSet getNestedLoopJoinResultSet(NoPutResultSet leftResultSet,
1:eac0369: 								   int leftNumCols,
1:eac0369: 								   NoPutResultSet rightResultSet,
1:eac0369: 								   int rightNumCols,
1:eac0369: 								   GeneratedMethod joinClause,
1:eac0369: 								   int resultSetNumber,
1:eac0369: 								   boolean oneRowRightSide,
1:eac0369: 								   boolean notExistsRightSide,
1:eac0369: 								   double optimizerEstimatedRowCount,
17:eac0369: 								   double optimizerEstimatedCost,
1:9e6e461: 								   String userSuppliedOptimizerOverrides)
1:eac0369: 			throws StandardException
1:cbdc90c: 	{
1:eac0369: 		return new NestedLoopJoinResultSet(leftResultSet, leftNumCols,
1:eac0369: 										   rightResultSet, rightNumCols,
1:93ff8cc: 										   leftResultSet.getActivation(), joinClause,
1:eac0369: 										   resultSetNumber, 
1:eac0369: 										   oneRowRightSide, 
1:eac0369: 										   notExistsRightSide, 
1:c723732: 										   optimizerEstimatedRowCount,
14:eac0369: 										   optimizerEstimatedCost,
1:f77f36d: 										   userSuppliedOptimizerOverrides);
1:c723732: 	}
1:eac0369: 
1:c723732: 	/**
1:eac0369: 		@see ResultSetFactory#getHashJoinResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369:     public NoPutResultSet getHashJoinResultSet(NoPutResultSet leftResultSet,
1:eac0369: 								   int leftNumCols,
1:eac0369: 								   NoPutResultSet rightResultSet,
1:eac0369: 								   int rightNumCols,
1:eac0369: 								   GeneratedMethod joinClause,
1:eac0369: 								   int resultSetNumber,
1:eac0369: 								   boolean oneRowRightSide,
1:eac0369: 								   boolean notExistsRightSide,
1:eac0369: 								   double optimizerEstimatedRowCount,
1:eac0369: 								   double optimizerEstimatedCost,
1:9e6e461: 								   String userSuppliedOptimizerOverrides)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new HashJoinResultSet(leftResultSet, leftNumCols,
1:eac0369: 										   rightResultSet, rightNumCols,
1:93ff8cc: 										   leftResultSet.getActivation(), joinClause,
1:eac0369: 										   resultSetNumber, 
1:eac0369: 										   oneRowRightSide, 
1:eac0369: 										   notExistsRightSide, 
1:eac0369: 										   optimizerEstimatedRowCount,
1:eac0369: 										   optimizerEstimatedCost,
1:f77f36d: 										   userSuppliedOptimizerOverrides);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getNestedLoopLeftOuterJoinResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369:     public NoPutResultSet getNestedLoopLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
1:eac0369: 								   int leftNumCols,
1:eac0369: 								   NoPutResultSet rightResultSet,
1:eac0369: 								   int rightNumCols,
1:eac0369: 								   GeneratedMethod joinClause,
1:eac0369: 								   int resultSetNumber,
1:eac0369: 								   GeneratedMethod emptyRowFun,
1:eac0369: 								   boolean wasRightOuterJoin,
1:eac0369: 								   boolean oneRowRightSide,
1:eac0369: 								   boolean notExistsRightSide,
1:eac0369: 								   double optimizerEstimatedRowCount,
1:eac0369: 								   double optimizerEstimatedCost,
1:9e6e461: 								   String userSuppliedOptimizerOverrides)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new NestedLoopLeftOuterJoinResultSet(leftResultSet, leftNumCols,
1:eac0369: 										   rightResultSet, rightNumCols,
1:93ff8cc: 										   leftResultSet.getActivation(), joinClause,
1:eac0369: 										   resultSetNumber, 
1:eac0369: 										   emptyRowFun, 
1:eac0369: 										   wasRightOuterJoin,
1:eac0369: 										   oneRowRightSide,
1:eac0369: 										   notExistsRightSide,
1:eac0369: 										   optimizerEstimatedRowCount,
1:eac0369: 										   optimizerEstimatedCost,
1:f77f36d: 										   userSuppliedOptimizerOverrides);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getHashLeftOuterJoinResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369:     public NoPutResultSet getHashLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
1:eac0369: 								   int leftNumCols,
1:eac0369: 								   NoPutResultSet rightResultSet,
1:eac0369: 								   int rightNumCols,
1:eac0369: 								   GeneratedMethod joinClause,
1:eac0369: 								   int resultSetNumber,
1:eac0369: 								   GeneratedMethod emptyRowFun,
1:eac0369: 								   boolean wasRightOuterJoin,
1:eac0369: 								   boolean oneRowRightSide,
1:eac0369: 								   boolean notExistsRightSide,
1:eac0369: 								   double optimizerEstimatedRowCount,
1:eac0369: 								   double optimizerEstimatedCost,
1:9e6e461: 								   String userSuppliedOptimizerOverrides)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new HashLeftOuterJoinResultSet(leftResultSet, leftNumCols,
1:eac0369: 										   rightResultSet, rightNumCols,
1:93ff8cc: 										   leftResultSet.getActivation(), joinClause,
1:eac0369: 										   resultSetNumber, 
1:eac0369: 										   emptyRowFun, 
1:eac0369: 										   wasRightOuterJoin,
1:eac0369: 										   oneRowRightSide,
1:eac0369: 										   notExistsRightSide,
1:eac0369: 										   optimizerEstimatedRowCount,
1:eac0369: 										   optimizerEstimatedCost,
1:f77f36d: 										   userSuppliedOptimizerOverrides);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getSetTransactionResultSet
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	public ResultSet getSetTransactionResultSet(Activation activation) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_ARBITARY_OP);		
1:eac0369: 		return new SetTransactionResultSet(activation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getMaterializedResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getMaterializedResultSet(NoPutResultSet source,
1:6b26ee1: 							int resultSetNumber,
1:eac0369: 						    double optimizerEstimatedRowCount,
1:9e6e461: 							double optimizerEstimatedCost)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:6b26ee1: 		return new MaterializedResultSet(source, source.getActivation(), 
1:eac0369: 									  resultSetNumber, 
1:eac0369: 									  optimizerEstimatedRowCount,
1:c723732: 									  optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getScrollInsensitiveResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getScrollInsensitiveResultSet(NoPutResultSet source,
3:eac0369: 							Activation activation, int resultSetNumber,
1:eac0369: 							int sourceRowWidth,
1:eac0369: 							boolean scrollable,
1:eac0369: 						    double optimizerEstimatedRowCount,
1:9e6e461: 							double optimizerEstimatedCost)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* ResultSet tree is dependent on whether or not this is
1:eac0369: 		 * for a scroll insensitive cursor.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		if (scrollable)
1:eac0369: 		{
1:eac0369: 			return new ScrollInsensitiveResultSet(source, activation, 
1:eac0369: 									  resultSetNumber, 
1:eac0369: 									  sourceRowWidth,
1:eac0369: 									  optimizerEstimatedRowCount,
1:028077e: 									  optimizerEstimatedCost);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return source;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getNormalizeResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getNormalizeResultSet(NoPutResultSet source,
1:6b26ee1: 							int resultSetNumber, 
2:eac0369: 							int erdNumber,
1:eac0369: 						    double optimizerEstimatedRowCount,
1:eac0369: 							double optimizerEstimatedCost,
1:9e6e461: 							boolean forUpdate)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:6b26ee1: 		return new NormalizeResultSet(source, source.getActivation(), 
1:eac0369: 									  resultSetNumber, erdNumber, 
1:eac0369: 									  optimizerEstimatedRowCount,
1:f77f36d: 									  optimizerEstimatedCost, forUpdate);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getCurrentOfResultSet
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getCurrentOfResultSet(String cursorName, 
1:ec08288: 	    Activation activation, int resultSetNumber)
1:eac0369: 	{
1:ec08288: 		return new CurrentOfResultSet(cursorName, activation, resultSetNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getDDLResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public ResultSet getDDLResultSet(Activation activation)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_DDL_OP);
1:eac0369: 		return getMiscResultSet( activation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetFactory#getMiscResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public ResultSet getMiscResultSet(Activation activation)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:c45f5b1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_ARBITARY_OP);
1:eac0369: 		return new MiscResultSet(activation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     	a minimal union scan generator, for ease of use at present.
1:eac0369: 		@see ResultSetFactory#getUnionResultSet
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369:     public NoPutResultSet getUnionResultSet(NoPutResultSet leftResultSet,
1:eac0369: 								   NoPutResultSet rightResultSet,
1:eac0369: 								   int resultSetNumber,
1:eac0369: 								   double optimizerEstimatedRowCount,
1:9e6e461: 								   double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new UnionResultSet(leftResultSet, rightResultSet, 
1:6b26ee1: 				                  leftResultSet.getActivation(),
1:eac0369: 								  resultSetNumber, 
1:eac0369: 								  optimizerEstimatedRowCount,
1:f77f36d: 								  optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:6200b38:     public NoPutResultSet getSetOpResultSet( NoPutResultSet leftSource,
1:6200b38:                                              NoPutResultSet rightSource,
1:cbdc90c:                                              Activation activation, 
1:eac0369:                                              int resultSetNumber,
1:6200b38:                                              long optimizerEstimatedRowCount,
1:eac0369:                                              double optimizerEstimatedCost,
1:6200b38:                                              int opType,
1:6200b38:                                              boolean all,
1:9e6e461:                                             int intermediateOrderByColumnsSavedObject,
1:cc30c0c:                                              int intermediateOrderByDirectionSavedObject,
1:cc30c0c:                                              int intermediateOrderByNullsLowSavedObject)
1:eac0369:         throws StandardException
1:eac0369:     {
1:6200b38:         return new SetOpResultSet( leftSource,
1:6200b38:                                    rightSource,
1:eac0369:                                    activation,
1:eac0369:                                    resultSetNumber,
1:eac0369:                                    optimizerEstimatedRowCount,
1:eac0369:                                    optimizerEstimatedCost,
1:6200b38:                                    opType,
1:6200b38:                                    all,
1:6200b38:                                    intermediateOrderByColumnsSavedObject,
1:cc30c0c:                                    intermediateOrderByDirectionSavedObject,
1:cc30c0c:                                    intermediateOrderByNullsLowSavedObject);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * A last index key sresult set returns the last row from
1:eac0369: 	 * the index in question.  It is used as an ajunct to max().
1:eac0369: 	 *
1:eac0369: 	 * @param activation 		the activation for this result set,
1:eac0369: 	 *		which provides the context for the row allocation operation.
1:eac0369: 	 * @param resultSetNumber	The resultSetNumber for the ResultSet
1:959fef2:      * @param resultRowTemplate The saved item for result row template
1:eac0369: 	 * @param conglomId 		the conglomerate of the table to be scanned.
1:eac0369: 	 * @param tableName			The full name of the table
1:c7248d5: 	 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 	 * @param indexName			The name of the index, if one used to access table.
1:eac0369: 	 * @param colRefItem		An saved item for a bitSet of columns that
1:eac0369: 	 *							are referenced in the underlying table.  -1 if
1:eac0369: 	 *							no item.
1:eac0369: 	 * @param lockMode			The lock granularity to use (see
1:eac0369: 	 *							TransactionController in access)
1:eac0369: 	 * @param tableLocked		Whether or not the table is marked as using table locking
1:eac0369: 	 *							(in sys.systables)
1:eac0369: 	 * @param isolationLevel	Isolation level (specified or not) to use on scans
1:eac0369: 	 * @param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 	 * 										optimizer
1:eac0369: 	 * @param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 	 *
1:eac0369: 	 * @return the scan operation as a result set.
1:eac0369:  	 *
1:eac0369: 	 * @exception StandardException thrown when unable to create the
1:eac0369: 	 * 				result set
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getLastIndexKeyResultSet
1:eac0369: 	(
1:eac0369: 		Activation 			activation,
1:eac0369: 		int 				resultSetNumber,
1:959fef2:         int                 resultRowTemplate,
1:eac0369: 		long 				conglomId,
1:eac0369: 		String 				tableName,
1:c7248d5: 		String 				userSuppliedOptimizerOverrides,
1:eac0369: 		String 				indexName,
1:eac0369: 		int 				colRefItem,
1:eac0369: 		int 				lockMode,
1:eac0369: 		boolean				tableLocked,
1:eac0369: 		int					isolationLevel,
1:eac0369: 		double				optimizerEstimatedRowCount,
1:9e6e461: 		double 				optimizerEstimatedCost
1:eac0369: 	) throws StandardException
1:eac0369: 	{
1:eac0369: 		return new LastIndexKeyResultSet(
1:eac0369: 					activation,
1:eac0369: 					resultSetNumber,
1:959fef2: 					resultRowTemplate,
1:eac0369: 					conglomId,
1:eac0369: 					tableName,
1:c7248d5: 					userSuppliedOptimizerOverrides,
1:eac0369: 					indexName,
1:eac0369: 					colRefItem,
1:028077e: 					lockMode,
1:028077e: 					tableLocked,
1:028077e: 					isolationLevel,
1:eac0369: 					optimizerEstimatedRowCount,
1:f77f36d: 					optimizerEstimatedCost);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	a referential action dependent table scan generator.
1:eac0369: 	 *  @see ResultSetFactory#getTableScanResultSet
1:eac0369: 	 *	@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getRaDependentTableScanResultSet(
1:93ff8cc: 			                        Activation activation,
1:eac0369: 									long conglomId,
1:eac0369: 									int scociItem,
1:959fef2: 									int resultRowTemplate,
1:eac0369: 									int resultSetNumber,
1:eac0369: 									GeneratedMethod startKeyGetter,
1:eac0369: 									int startSearchOperator,
1:eac0369: 									GeneratedMethod stopKeyGetter,
1:eac0369: 									int stopSearchOperator,
1:eac0369: 									boolean sameStartStopPosition,
1:eac0369: 									Qualifier[][] qualifiers,
1:eac0369: 									String tableName,
1:c7248d5: 									String userSuppliedOptimizerOverrides,
1:eac0369: 									String indexName,
1:eac0369: 									boolean isConstraint,
1:eac0369: 									boolean forUpdate,
1:eac0369: 									int colRefItem,
1:eac0369: 									int indexColItem,
1:eac0369: 									int lockMode,
1:eac0369: 									boolean tableLocked,
1:eac0369: 									int isolationLevel,
1:eac0369: 									boolean oneRowScan,
1:eac0369: 									double optimizerEstimatedRowCount,
1:eac0369: 									double optimizerEstimatedCost,
1:eac0369: 									String parentResultSetId,
1:eac0369: 									long fkIndexConglomId,
1:eac0369: 									int fkColArrayItem,
1:eac0369: 									int rltItem)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1:eac0369: 						getSavedObject(scociItem));
1:eac0369: 		return new DependentResultSet(
1:eac0369: 								conglomId,
1:eac0369: 								scoci,
1:eac0369: 								activation,
1:959fef2: 								resultRowTemplate,
1:eac0369: 								resultSetNumber,
1:eac0369: 								startKeyGetter,
1:eac0369: 								startSearchOperator,
1:eac0369: 								stopKeyGetter,
1:eac0369: 								stopSearchOperator,
1:eac0369: 								sameStartStopPosition,
1:eac0369: 								qualifiers,
1:eac0369: 								tableName,
1:c7248d5: 								userSuppliedOptimizerOverrides,
1:eac0369: 								indexName,
1:eac0369: 								isConstraint,
1:eac0369: 								forUpdate,
1:eac0369: 								colRefItem,
1:eac0369: 								lockMode,
1:eac0369: 								tableLocked,
1:eac0369: 								isolationLevel,
1:eac0369: 								1,
1:028077e: 								oneRowScan,
1:eac0369: 								optimizerEstimatedRowCount,
1:eac0369: 								optimizerEstimatedCost,
1:eac0369: 								parentResultSetId,
1:eac0369: 								fkIndexConglomId,
1:eac0369: 								fkColArrayItem,
1:eac0369: 								rltItem);
1:eac0369: 	}
1:eac0369: 	
1:69a192a: 	/**
1:69a192a: 	 * @see ResultSetFactory#getRowCountResultSet
1:69a192a: 	 */
1:69a192a: 	public NoPutResultSet getRowCountResultSet(
1:69a192a: 		NoPutResultSet source,
1:69a192a: 		Activation activation,
1:69a192a: 		int resultSetNumber,
1:00c7a20: 		GeneratedMethod offsetMethod,
1:00c7a20: 		GeneratedMethod fetchFirstMethod,
1:57c1b5c:         boolean hasJDBClimitClause,
1:69a192a: 		double optimizerEstimatedRowCount,
1:69a192a: 		double optimizerEstimatedCost)
1:69a192a: 		throws StandardException
1:69a192a: 	{
1:69a192a: 		return new RowCountResultSet(source,
1:69a192a: 									 activation,
1:69a192a: 									 resultSetNumber,
1:00c7a20: 									 offsetMethod,
1:00c7a20: 									 fetchFirstMethod,
1:57c1b5c: 									 hasJDBClimitClause,
1:69a192a: 									 optimizerEstimatedRowCount,
1:69a192a: 									 optimizerEstimatedCost);
1:69a192a: 	}
1:69a192a: 
1:69a192a: 
1:eac0369: 	static private Authorizer getAuthorizer(Activation activation)
1:eac0369: 	{
1:eac0369: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1:eac0369: 		return lcc.getAuthorizer();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:    /////////////////////////////////////////////////////////////////
1:eac0369:    //
1:eac0369:    //	PUBLIC MINIONS
1:eac0369:    //
1:eac0369:    /////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
/////////////////////////////////////////////////////////////////////////
1:         String validatingBaseTableUUIDString,
1:         UUID    validatingBaseTableUUID = UUID.NULL.equals( validatingBaseTableUUIDString ) ?
1:             null :
1:             source.getActivation()
1:             .getLanguageConnectionContext()
1:             .getDataDictionary()
1:             .getUUIDFactory()
1:             .recreateUUID( validatingBaseTableUUIDString );
1: 
1:             validatingBaseTableUUID,
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getInsertResultSet(NoPutResultSet source,
1:                                         GeneratedMethod generationClauses,
1:                                         GeneratedMethod checkGM,
1:                                         int fullTemplate,
1:                                         String schemaName,
1:                                         String tableName)
1: 
1:         return new InsertResultSet(source,
1:                                    generationClauses,
1:                                    checkGM,
1:                                    fullTemplate,
1:                                    schemaName,
1:                                    tableName,
1:                                    activation);
/////////////////////////////////////////////////////////////////////////
1:         boolean validatingCheckConstraint,
0:         long validatingBaseTableCID,
/////////////////////////////////////////////////////////////////////////
1:             validatingCheckConstraint,
0:             validatingBaseTableCID,
/////////////////////////////////////////////////////////////////////////
1:     public NoPutResultSet getValidateCheckConstraintResultSet(
1:                                     Activation activation,
1:                                     long conglomId,
1:                                     int scociItem,
1:                                     int resultRowTemplate,
1:                                     int resultSetNumber,
1:                                     GeneratedMethod startKeyGetter,
1:                                     int startSearchOperator,
1:                                     GeneratedMethod stopKeyGetter,
1:                                     int stopSearchOperator,
1:                                     boolean sameStartStopPosition,
1:                                     Qualifier[][] qualifiers,
1:                                     String tableName,
1:                                     String userSuppliedOptimizerOverrides,
1:                                     String indexName,
1:                                     boolean isConstraint,
1:                                     boolean forUpdate,
1:                                     int colRefItem,
1:                                     int indexColItem,
1:                                     int lockMode,
1:                                     boolean tableLocked,
1:                                     int isolationLevel,
1:                                     boolean oneRowScan,
1:                                     double optimizerEstimatedRowCount,
1:                                     double optimizerEstimatedCost)
1:             throws StandardException
1:     {
1:         StaticCompiledOpenConglomInfo scoci =
1:             (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1:                                             getSavedObject(scociItem));
1:         return new ValidateCheckConstraintResultSet(
1:                                 conglomId,
1:                                 scoci,
1:                                 activation,
1:                                 resultRowTemplate,
1:                                 resultSetNumber,
1:                                 startKeyGetter,
1:                                 startSearchOperator,
1:                                 stopKeyGetter,
1:                                 stopSearchOperator,
1:                                 sameStartStopPosition,
1:                                 qualifiers,
1:                                 tableName,
1:                                 userSuppliedOptimizerOverrides,
1:                                 indexName,
1:                                 isConstraint,
1:                                 forUpdate,
1:                                 colRefItem,
1:                                 indexColItem,
1:                                 lockMode,
1:                                 tableLocked,
1:                                 isolationLevel,
1:                                 1,  // rowsPerRead is 1 if not a bulkTableScan
1:                                 oneRowScan,
1:                                 optimizerEstimatedRowCount,
1:                                 optimizerEstimatedCost);
1:     }
1: 
1:     /**
commit:1d0c809
/////////////////////////////////////////////////////////////////////////
1:         int cloneMapItem,
/////////////////////////////////////////////////////////////////////////
1:             constantRestriction, mapRefItem, cloneMapItem,
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: 		@see ResultSetFactory#getWindowResultSet
1: 		@exception StandardException	Thrown on error
1: 	 */
1: 	public NoPutResultSet getWindowResultSet(
1: 								Activation activation,
1: 								NoPutResultSet source,
0: 								GeneratedMethod rowAllocator,
1: 								int resultSetNumber,
1: 								int erdNumber,
1: 								GeneratedMethod restriction,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost)
1: 		throws StandardException
1: 	{
1: 		return new WindowResultSet(
1: 								activation,
1: 								source,
1: 								rowAllocator,
1: 								resultSetNumber,
1: 								erdNumber,
1: 								restriction,
1: 								optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost);
1: 	}
1: 
1: 
1: 	/**
commit:3527fd5
/////////////////////////////////////////////////////////////////////////
commit:00c7a20
/////////////////////////////////////////////////////////////////////////
1: 		GeneratedMethod offsetMethod,
1: 		GeneratedMethod fetchFirstMethod,
/////////////////////////////////////////////////////////////////////////
1: 									 offsetMethod,
1: 									 fetchFirstMethod,
commit:69a192a
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * @see ResultSetFactory#getRowCountResultSet
1: 	 */
1: 	public NoPutResultSet getRowCountResultSet(
1: 		NoPutResultSet source,
1: 		Activation activation,
1: 		int resultSetNumber,
0: 		long offset,
0: 		long fetchFirst,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost)
1: 		throws StandardException
1: 	{
1: 		return new RowCountResultSet(source,
1: 									 activation,
1: 									 resultSetNumber,
0: 									 offset,
0: 									 fetchFirst,
1: 									 optimizerEstimatedRowCount,
1: 									 optimizerEstimatedCost);
1: 	}
1: 
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:1705596
/////////////////////////////////////////////////////////////////////////
1: 								double optimizerEstimatedCost,
1: 								int baseColumnCount )
/////////////////////////////////////////////////////////////////////////
1: 								optimizerEstimatedCost,
1: 								baseColumnCount);
commit:29007f0
/////////////////////////////////////////////////////////////////////////
1:                                      int vtiRestrictionNumber,
1:                                      String vtiSchema,
1:                                      String vtiName
/////////////////////////////////////////////////////////////////////////
1:                                 vtiRestrictionNumber,
1:                                 vtiSchema,
1:                                 vtiName
commit:508a010
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 		@see ResultSetFactory#getMergeResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public ResultSet getMergeResultSet(NoPutResultSet drivingLeftJoin)
1:         throws StandardException
1:     {
1: 		Activation activation = drivingLeftJoin.getActivation();
1: 		getAuthorizer( activation ).authorize( activation, Authorizer.SQL_WRITE_OP );
1: 		return new MergeResultSet( drivingLeftJoin, activation );
1:     }
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
1:         boolean hasJDBClimitClause,
/////////////////////////////////////////////////////////////////////////
1: 									 hasJDBClimitClause,
commit:a2d0847
/////////////////////////////////////////////////////////////////////////
1:                                      int returnTypeNumber,
1:                                      int vtiProjectionNumber,
0:                                      int vtiRestrictionNumber
/////////////////////////////////////////////////////////////////////////
1:                                 returnTypeNumber,
1:                                 vtiProjectionNumber,
0:                                 vtiRestrictionNumber
commit:ca28065
/////////////////////////////////////////////////////////////////////////
1: 	public ResultSet getUpdateResultSet(NoPutResultSet source, GeneratedMethod generationClauses,
1: 										GeneratedMethod checkGM)
/////////////////////////////////////////////////////////////////////////
1: 		return new UpdateResultSet(source, generationClauses, checkGM, activation);
/////////////////////////////////////////////////////////////////////////
1:                                                      GeneratedMethod generationClauses,
/////////////////////////////////////////////////////////////////////////
1: 		return new UpdateResultSet(source, generationClauses, checkGM, activation,
commit:c533cd2
/////////////////////////////////////////////////////////////////////////
0: 	public ResultSet getInsertResultSet(NoPutResultSet source, GeneratedMethod generationClauses,
0: 		return new InsertResultSet(source, generationClauses, checkGM, activation );
/////////////////////////////////////////////////////////////////////////
0: 	public ResultSet getUpdateResultSet(NoPutResultSet source, GeneratedMethod checkGM)
commit:f432362
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.TypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1:                                      boolean isDerbyStyleTableFunction,
0:                                      String returnType
/////////////////////////////////////////////////////////////////////////
1: 								isDerbyStyleTableFunction,
0:                                 returnType
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1: 									 double optimizerEstimatedCost,
0: 									 boolean isDerbyStyleTableFunction
1:                                           )
/////////////////////////////////////////////////////////////////////////
1: 								optimizerEstimatedCost,
0: 								isDerbyStyleTableFunction
1:                                 );
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:b5105f3
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost,
1: 		boolean isRollup) 
1: 						optimizerEstimatedCost, isRollup);
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost,
1: 		boolean isRollup) 
1: 						optimizerEstimatedCost, isRollup);
commit:cc30c0c
/////////////////////////////////////////////////////////////////////////
1:                                              int intermediateOrderByDirectionSavedObject,
1:                                              int intermediateOrderByNullsLowSavedObject)
/////////////////////////////////////////////////////////////////////////
1:                                    intermediateOrderByDirectionSavedObject,
1:                                    intermediateOrderByNullsLowSavedObject);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bda7291
/////////////////////////////////////////////////////////////////////////
1: 								int resultRowAllocator,
commit:d868eed
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 	public NoPutResultSet getVTIResultSet(Activation activation, int row,
/////////////////////////////////////////////////////////////////////////
1: 								int rowAllocator,
commit:959fef2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                         GeneratedMethod checkGM, int fullTemplate)
0:         return new InsertResultSet(
0:                 source, generationClauses, checkGM, fullTemplate, activation);
/////////////////////////////////////////////////////////////////////////
1: 									int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 								resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 									int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 								resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 									int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 								resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 									int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 								resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 									int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 								resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1:      * @param resultRowTemplate The saved item for result row template
/////////////////////////////////////////////////////////////////////////
1:         int                 resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 					resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 									int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 								resultRowTemplate,
commit:ec6fcf1
/////////////////////////////////////////////////////////////////////////
1:                                     boolean disableForHoldable,
/////////////////////////////////////////////////////////////////////////
1:                                 disableForHoldable,
commit:47e1295
/////////////////////////////////////////////////////////////////////////
0:                                      int returnTypeNumber
/////////////////////////////////////////////////////////////////////////
0:                                 returnTypeNumber
commit:6853511
/////////////////////////////////////////////////////////////////////////
1: 								int allColRefItem,
1: 								int heapOnlyColRefItem,
/////////////////////////////////////////////////////////////////////////
1: 								allColRefItem,
1: 								heapOnlyColRefItem,
author:Army
-------------------------------------------------------------------------------
commit:c723732
/////////////////////////////////////////////////////////////////////////
0: 		@see ResultSetFactory#getWindowResultSet
1: 		@exception StandardException	Thrown on error
1: 	 */
0: 	public NoPutResultSet getWindowResultSet(
1: 								Activation activation,
1: 								NoPutResultSet source,
0: 								GeneratedMethod rowAllocator,								
1: 								int resultSetNumber,
0: 								int level,
1: 								int erdNumber,								
1: 								GeneratedMethod restriction,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost)																
1: 		throws StandardException
1: 	{
0: 		return new WindowResultSet(
1: 								activation,								
1: 								source,
1: 								rowAllocator,								
1: 								resultSetNumber,
0: 								level,
1: 								erdNumber,
1: 								restriction,
1: 								optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost);
1: 	}
1: 
1: 	/**
commit:20bd3c0
/////////////////////////////////////////////////////////////////////////
1: 									int sortRequired,
/////////////////////////////////////////////////////////////////////////
1: 								sortRequired,
commit:028077e
/////////////////////////////////////////////////////////////////////////
1: 									Activation activation,
/////////////////////////////////////////////////////////////////////////
1: 		StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)
1: 			activation.getPreparedStatement().getSavedObject(scociItem);
1: 		return new MultiProbeTableScanResultSet(
1: 								conglomId,
1: 								scoci,
1: 								activation,
1: 								resultRowAllocator,
1: 								resultSetNumber,
1: 								startKeyGetter,
1: 								startSearchOperator,
1: 								stopKeyGetter,
1: 								stopSearchOperator,
1: 								sameStartStopPosition,
1: 								qualifiers,
1: 								probeVals,
0: 								probeValsAreSorted,
1: 								tableName,
1: 								userSuppliedOptimizerOverrides,
1: 								indexName,
1: 								isConstraint,
1: 								forUpdate,
1: 								colRefItem,
1: 								indexColItem,
1: 								lockMode,
1: 								tableLocked,
1: 								isolationLevel,
1: 								oneRowScan,
1: 								optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost);
commit:cbdc90c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		Multi-probing scan that probes an index for specific values contained
1: 		in the received probe list.
1: 
1: 		All index rows for which the first column equals probeVals[0] will
1: 		be returned, followed by all rows for which the first column equals
1: 		probeVals[1], and so on.  Assumption is that we only get here if
1: 		probeVals has at least one value.
1: 
1: 		@see ResultSetFactory#getMultiProbeTableScanResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getMultiProbeTableScanResultSet(
1:                         			Activation activation,
1: 									long conglomId,
1: 									int scociItem,
0: 									GeneratedMethod resultRowAllocator,
1: 									int resultSetNumber,
1: 									GeneratedMethod startKeyGetter,
1: 									int startSearchOperator,
1: 									GeneratedMethod stopKeyGetter,
1: 									int stopSearchOperator,
1: 									boolean sameStartStopPosition,
1: 									Qualifier[][] qualifiers,
1: 									DataValueDescriptor [] probeVals,
0: 									boolean probeValsAreSorted,
1: 									String tableName,
1: 									String userSuppliedOptimizerOverrides,
1: 									String indexName,
1: 									boolean isConstraint,
1: 									boolean forUpdate,
1: 									int colRefItem,
1: 									int indexColItem,
1: 									int lockMode,
1: 									boolean tableLocked,
1: 									int isolationLevel,
1: 									boolean oneRowScan,
1: 									double optimizerEstimatedRowCount,
1: 									double optimizerEstimatedCost)
1: 			throws StandardException
1: 	{
0: 		/* Incremental development: For now we should never actually get to
0: 		 * this method, so just return null.  When the appropriate execution
0: 		 * logic is in place (i.e. MultiProbeTableScanResultSet exists) then
0: 		 * we will add a call to create an instance of the result set here.
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Tried to instantiate " +
0: 				"MultiProbeTableScanResultSet, which does not " +
0: 				"yet exist (DERBY-47 incremental development).");
1: 		}
1: 
0: 		return (NoPutResultSetImpl)null;
1: 	}
1: 
1: 	/**
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:b31849d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
commit:ec08288
/////////////////////////////////////////////////////////////////////////
1: 	    Activation activation, int resultSetNumber)
1: 		return new CurrentOfResultSet(cursorName, activation, resultSetNumber);
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
1: 									 double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 									 double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 									double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 									double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 									double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 									double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 								double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides)
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides)
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides)
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides)
/////////////////////////////////////////////////////////////////////////
0: 							double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
0: 							double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1: 							boolean forUpdate)
/////////////////////////////////////////////////////////////////////////
0: 								   double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
1:                                             int intermediateOrderByColumnsSavedObject,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		double 				optimizerEstimatedCost
/////////////////////////////////////////////////////////////////////////
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: 			optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 			optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 			optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 						optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 						optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 						optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 						optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 								optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 								optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 								optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 								optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 								optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 								optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 								optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 										   userSuppliedOptimizerOverrides);
/////////////////////////////////////////////////////////////////////////
1: 										   userSuppliedOptimizerOverrides);
/////////////////////////////////////////////////////////////////////////
1: 										   userSuppliedOptimizerOverrides);
/////////////////////////////////////////////////////////////////////////
1: 										   userSuppliedOptimizerOverrides);
/////////////////////////////////////////////////////////////////////////
1: 									  optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
0: 									  optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
1: 									  optimizerEstimatedCost, forUpdate);
/////////////////////////////////////////////////////////////////////////
0: 								  optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
commit:93ff8cc
/////////////////////////////////////////////////////////////////////////
1: 	public ResultSet getUpdateVTIResultSet(NoPutResultSet source)
1: 		Activation activation = source.getActivation();
/////////////////////////////////////////////////////////////////////////
1: 		GeneratedMethod singleTableRestriction, 
/////////////////////////////////////////////////////////////////////////
1: 		return new HashTableResultSet(source, source.getActivation(), 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			source.getActivation(), 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 						source, isInSortedOrder, aggregateItem, source.getActivation(),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 						source, isInSortedOrder, aggregateItem, orderItem, source.getActivation(),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 						source, isInSortedOrder, aggregateItem, orderItem, source.getActivation(),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 						source, isInSortedOrder, aggregateItem, orderItem, source.getActivation(),
/////////////////////////////////////////////////////////////////////////
1:                         			Activation activation,
/////////////////////////////////////////////////////////////////////////
1:                          			Activation activation,
/////////////////////////////////////////////////////////////////////////
1:                         			Activation activation,
/////////////////////////////////////////////////////////////////////////
1:                        			    Activation activation,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								source.getActivation(),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 										   leftResultSet.getActivation(), joinClause,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 										   leftResultSet.getActivation(), joinClause,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 										   leftResultSet.getActivation(), joinClause,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 										   leftResultSet.getActivation(), joinClause,
/////////////////////////////////////////////////////////////////////////
0: 			                        Activation activation,
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
0: 										GeneratedMethod checkGM)
1: 		Activation activation = source.getActivation();
/////////////////////////////////////////////////////////////////////////
1: 										NoPutResultSet vtiRS
1: 										)
1: 		Activation activation = source.getActivation();
/////////////////////////////////////////////////////////////////////////
1: 	public ResultSet getDeleteVTIResultSet(NoPutResultSet source)
1: 		Activation activation = source.getActivation();
/////////////////////////////////////////////////////////////////////////
1: 	public ResultSet getDeleteResultSet(NoPutResultSet source)
1: 		Activation activation = source.getActivation();
/////////////////////////////////////////////////////////////////////////
1: 		Activation activation = source.getActivation();
/////////////////////////////////////////////////////////////////////////
0: 										GeneratedMethod checkGM)
1: 		Activation activation = source.getActivation();
/////////////////////////////////////////////////////////////////////////
1: 		Activation activation = source.getActivation();
/////////////////////////////////////////////////////////////////////////
1: 		GeneratedMethod restriction, 
/////////////////////////////////////////////////////////////////////////
1: 		return new ProjectRestrictResultSet(source, source.getActivation(), 
/////////////////////////////////////////////////////////////////////////
1: 		GeneratedMethod emptyRowFun, int resultSetNumber,
1: 					 source.getActivation(), emptyRowFun, resultSetNumber,
/////////////////////////////////////////////////////////////////////////
1: 	 GeneratedMethod emptyRowFun,
/////////////////////////////////////////////////////////////////////////
1: 					 source.getActivation(), emptyRowFun, 
/////////////////////////////////////////////////////////////////////////
1: 							int resultSetNumber,
1: 		return new MaterializedResultSet(source, source.getActivation(), 
/////////////////////////////////////////////////////////////////////////
1: 							int resultSetNumber, 
/////////////////////////////////////////////////////////////////////////
1: 		return new NormalizeResultSet(source, source.getActivation(), 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				                  leftResultSet.getActivation(),
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.GenericResultSetFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
0: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1: 
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: 
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import java.util.Properties;
1: /**
1:  * ResultSetFactory provides a wrapper around all of
1:  * the result sets used in this execution implementation.
1:  * This removes the need of generated classes to do a new
1:  * and of the generator to know about all of the result
1:  * sets.  Both simply know about this interface to getting
1:  * them.
1:  * <p>
1:  * In terms of modularizing, we can create just an interface
1:  * to this class and invoke the interface.  Different implementations
1:  * would get the same information provided but could potentially
1:  * massage/ignore it in different ways to satisfy their
1:  * implementations.  The practicality of this is to be seen.
1:  * <p>
1:  * The cost of this type of factory is that once you touch it,
1:  * you touch *all* of the possible result sets, not just
1:  * the ones you need.  So the first time you touch it could
1:  * be painful ... that might be a problem for execution.
1:  *
0:  * @author ames
1:  */
1: public class GenericResultSetFactory implements ResultSetFactory 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	//
1: 	// ResultSetFactory interface
1: 	//
1: 	public GenericResultSetFactory()
1: 	{
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getInsertResultSet
1: 		@exception StandardException thrown on error
1: 	 */
0: 	public ResultSet getInsertResultSet(NoPutResultSet source, 
1: 										GeneratedMethod checkGM,
1: 										Activation activation)
1: 		throws StandardException
1: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new InsertResultSet(source, checkGM, activation );
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getInsertVTIResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public ResultSet getInsertVTIResultSet(NoPutResultSet source, 
0: 										NoPutResultSet vtiRS,
1: 										Activation activation)
1: 		throws StandardException
1: 	{
1: 
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
1: 		return new InsertVTIResultSet(source, vtiRS, activation );
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getDeleteVTIResultSet
1: 		@exception StandardException thrown on error
1: 	 */
0: 	public ResultSet getDeleteVTIResultSet(NoPutResultSet source, 
1: 										Activation activation)
1: 		throws StandardException
1: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
1: 		return new DeleteVTIResultSet(source, activation);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getDeleteResultSet
1: 		@exception StandardException thrown on error
1: 	 */
0: 	public ResultSet getDeleteResultSet(NoPutResultSet source,
1: 										Activation activation)
1: 			throws StandardException
1: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
1: 		return new DeleteResultSet(source, activation );
1: 	}
1: 
1: 
1: 	/**
1: 		@see ResultSetFactory#getDeleteCascadeResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public ResultSet getDeleteCascadeResultSet(NoPutResultSet source, 
0: 											   Activation activation,	
1: 											   int constantActionItem,
1: 											   ResultSet[] dependentResultSets,
1: 											   String resultSetId)
1: 		throws StandardException
1: 	{
1: 			
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
1: 		return new DeleteCascadeResultSet(source, activation, 
1: 										  constantActionItem,
1: 										  dependentResultSets, 
1: 										  resultSetId);
1: 	}
1: 
1: 
1: 
1: 	/**
1: 		@see ResultSetFactory#getUpdateResultSet
1: 		@exception StandardException thrown on error
1: 	 */
0: 	public ResultSet getUpdateResultSet(NoPutResultSet source,
1: 										GeneratedMethod checkGM,
1: 										Activation activation)
1: 			throws StandardException
1: 	{
1: 		//The stress test failed with null pointer exception in here once and then
1: 		//it didn't happen again. It can be a jit problem because after this null
1: 		//pointer exception, the cleanup code in UpdateResultSet got a null
1: 		//pointer exception too which can't happen since the cleanup code checks
1: 		//for null value before doing anything.
1: 		//In any case, if this ever happens again, hopefully the following
1: 		//assertion code will catch it.
0: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(getAuthorizer(activation) != null, "Authorizer is null");
1: 		}
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new UpdateResultSet(source, checkGM, activation);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getUpdateVTIResultSet
1: 		@exception StandardException thrown on error
1: 	 */
0: 	public ResultSet getUpdateVTIResultSet(NoPutResultSet source,
1:                                            Activation activation)
1: 			throws StandardException
1: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
1: 		return new UpdateVTIResultSet(source, activation);
1: 	}
1: 
1: 
1: 
1: 	/**
1: 		@see ResultSetFactory#getDeleteCascadeUpdateResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public ResultSet getDeleteCascadeUpdateResultSet(NoPutResultSet source,
1: 													 GeneratedMethod checkGM,
0: 													 Activation activation,
1: 													 int constantActionItem,
1: 													 int rsdItem)
1: 			throws StandardException
1: 	{
0: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(getAuthorizer(activation) != null, "Authorizer is null");
1: 		}
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new UpdateResultSet(source, checkGM, activation,
1: 								   constantActionItem, rsdItem);
1: 	}
1: 
1: 
1: 	/**
1: 		@see ResultSetFactory#getCallStatementResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public ResultSet getCallStatementResultSet(GeneratedMethod methodCall,
1: 				Activation activation)
1: 			throws StandardException
1: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_CALL_OP);
1: 		return new CallStatementResultSet(methodCall, activation);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getProjectRestrictResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getProjectRestrictResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod restriction, 
1: 		GeneratedMethod projection, int resultSetNumber,
1: 		GeneratedMethod constantRestriction,
1: 		int mapRefItem,
1: 		boolean reuseResult,
1: 		boolean doesProjection,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
0: 		return new ProjectRestrictResultSet(source, activation, 
1: 			restriction, projection, resultSetNumber, 
0: 			constantRestriction, mapRefItem, 
1: 			reuseResult,
1: 			doesProjection,
1: 		    optimizerEstimatedRowCount,
1: 			optimizerEstimatedCost,
0: 			closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getHashTableResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getHashTableResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod singleTableRestriction, 
1: 		Qualifier[][] equijoinQualifiers,
1: 		GeneratedMethod projection, int resultSetNumber,
1: 		int mapRefItem,
1: 		boolean reuseResult,
1: 		int keyColItem,
1: 		boolean removeDuplicates,
1: 		long maxInMemoryRowCount,
1: 		int	initialCapacity,
1: 		float loadFactor,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
0: 		return new HashTableResultSet(source, activation, 
1: 			singleTableRestriction, 
1:             equijoinQualifiers,
1: 			projection, resultSetNumber, 
1: 			mapRefItem, 
1: 			reuseResult,
1: 			keyColItem, removeDuplicates,
1: 			maxInMemoryRowCount,
1: 			initialCapacity,
1: 			loadFactor,
1: 			true,		// Skip rows with 1 or more null key columns
1: 		    optimizerEstimatedRowCount,
1: 			optimizerEstimatedCost,
0: 			closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getSortResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getSortResultSet(NoPutResultSet source,
1: 		boolean distinct, 
1: 		boolean isInSortedOrder,
1: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int maxRowSize,
1: 		int resultSetNumber, 
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1: 		return new SortResultSet(source, 
1: 			distinct, 
1: 			isInSortedOrder,
1: 			orderItem,
1: 			activation, 
0: 			rowAllocator, 
1: 			maxRowSize,
1: 			resultSetNumber, 
1: 		    optimizerEstimatedRowCount,
1: 			optimizerEstimatedCost,
0: 			closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getScalarAggregateResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getScalarAggregateResultSet(NoPutResultSet source,
1: 		boolean isInSortedOrder,
1: 		int aggregateItem,
1: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int maxRowSize,
1: 		int resultSetNumber, 
1: 		boolean singleInputRow,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
1: 			throws StandardException
1: 	{
1: 		return new ScalarAggregateResultSet(
0: 						source, isInSortedOrder, aggregateItem, activation,
1: 						rowAllocator, resultSetNumber, singleInputRow,
1: 						optimizerEstimatedRowCount,
0: 						optimizerEstimatedCost, closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getDistinctScalarAggregateResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getDistinctScalarAggregateResultSet(NoPutResultSet source,
1: 		boolean isInSortedOrder,
1: 		int aggregateItem,
1: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int maxRowSize,
1: 		int resultSetNumber, 
1: 		boolean singleInputRow,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
1: 			throws StandardException
1: 	{
1: 		return new DistinctScalarAggregateResultSet(
0: 						source, isInSortedOrder, aggregateItem, orderItem, activation,
1: 						rowAllocator, maxRowSize, resultSetNumber, singleInputRow,
1: 						optimizerEstimatedRowCount,
0: 						optimizerEstimatedCost, closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getGroupedAggregateResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getGroupedAggregateResultSet(NoPutResultSet source,
1: 		boolean isInSortedOrder,
1: 		int aggregateItem,
1: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int maxRowSize,
1: 		int resultSetNumber, 
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
1: 			throws StandardException
1: 	{
1: 		return new GroupedAggregateResultSet(
0: 						source, isInSortedOrder, aggregateItem, orderItem, activation,
1: 						rowAllocator, maxRowSize, resultSetNumber, optimizerEstimatedRowCount,
0: 						optimizerEstimatedCost, closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getDistinctGroupedAggregateResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getDistinctGroupedAggregateResultSet(NoPutResultSet source,
1: 		boolean isInSortedOrder,
1: 		int aggregateItem,
1: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int maxRowSize,
1: 		int resultSetNumber, 
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
1: 			throws StandardException
1: 	{
1: 		return new DistinctGroupedAggregateResultSet(
0: 						source, isInSortedOrder, aggregateItem, orderItem, activation,
1: 						rowAllocator, maxRowSize, resultSetNumber, optimizerEstimatedRowCount,
0: 						optimizerEstimatedCost, closeCleanup);
1: 	}
1: 											
1: 
1: 	/**
1: 		@see ResultSetFactory#getAnyResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getAnyResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod emptyRowFun, int resultSetNumber,
1: 		int subqueryNumber, int pointOfAttachment,
1: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost)
1: 			throws StandardException
1: 	{
1: 		return new AnyResultSet(source,
0: 					 activation, emptyRowFun, resultSetNumber,
1: 					 subqueryNumber, pointOfAttachment,
1: 					 optimizerEstimatedRowCount,
0: 					 optimizerEstimatedCost);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getOnceResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getOnceResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod emptyRowFun,
1: 		int cardinalityCheck, int resultSetNumber,
1: 		int subqueryNumber, int pointOfAttachment,
1: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost)
1: 			throws StandardException
1: 	{
1: 		return new OnceResultSet(source,
0: 					 activation, emptyRowFun, 
1: 					 cardinalityCheck, resultSetNumber,
1: 					 subqueryNumber, pointOfAttachment,
1: 				     optimizerEstimatedRowCount,
0: 					 optimizerEstimatedCost);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getRowResultSet
1: 	 */
1: 	public NoPutResultSet getRowResultSet(Activation activation, GeneratedMethod row,
1: 									 boolean canCacheRow,
1: 									 int resultSetNumber,
1: 									 double optimizerEstimatedRowCount,
1: 									 double optimizerEstimatedCost,
0: 								     GeneratedMethod closeCleanup)
1: 	{
1: 		return new RowResultSet(activation, row, canCacheRow, resultSetNumber, 
1: 							    optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost,
0: 								closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getVTIResultSet
1: 		@exception StandardException thrown on error
1: 	 */
0: 	public NoPutResultSet getVTIResultSet(Activation activation, GeneratedMethod row,
1: 									 int resultSetNumber,
1: 									 GeneratedMethod constructor,
1: 									 String javaClassName,
1: 									 Qualifier[][] pushedQualifiers,
1: 									 int erdNumber,
1: 									 boolean version2,
1: 									 boolean reuseablePs,
1: 									 int ctcNumber,
1: 									 boolean isTarget,
1: 									 int scanIsolationLevel,
1: 									 double optimizerEstimatedRowCount,
1: 									 double optimizerEstimatedCost,
0: 								     GeneratedMethod closeCleanup)
1: 		throws StandardException
1: 	{
1: 		return new VTIResultSet(activation, row, resultSetNumber, 
1: 								constructor,
1: 								javaClassName,
1: 								pushedQualifiers,
0: 								erdNumber,
1: 								version2, reuseablePs,
1: 								ctcNumber,
1: 								isTarget,
1: 								scanIsolationLevel,
1: 							    optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost,
0: 								closeCleanup);
1: 	}
1: 
1: 	/**
1:     	a hash scan generator, for ease of use at present.
1: 		@see ResultSetFactory#getHashScanResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getHashScanResultSet(
1: 									long conglomId,
1: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
1: 									int resultSetNumber,
1: 									GeneratedMethod startKeyGetter,
1: 									int startSearchOperator,
1: 									GeneratedMethod stopKeyGetter,
1: 									int stopSearchOperator,
1: 									boolean sameStartStopPosition,
1: 									Qualifier[][] scanQualifiers,
1: 									Qualifier[][] nextQualifiers,
1: 									int initialCapacity,
1: 									float loadFactor,
1: 									int maxCapacity,
1: 									int hashKeyColumn,
1: 									String tableName,
1: 									String indexName,
1: 									boolean isConstraint,
1: 									boolean forUpdate,
1: 									int colRefItem,
1: 									int indexColItem,
1: 									int lockMode,
1: 									boolean tableLocked,
1: 									int isolationLevel,
1: 									double optimizerEstimatedRowCount,
1: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1: 						getSavedObject(scociItem));
1: 
1: 		return new HashScanResultSet(
1: 								conglomId,
1: 								scoci,
1: 								activation,
0: 								resultRowAllocator,
1: 								resultSetNumber,
1: 								startKeyGetter,
1: 								startSearchOperator,
1: 								stopKeyGetter,
1: 								stopSearchOperator,
1: 								sameStartStopPosition,
1: 								scanQualifiers,
1: 								nextQualifiers,
1: 								initialCapacity,
1: 								loadFactor,
1: 								maxCapacity,
1: 								hashKeyColumn,
1: 								tableName,
1: 								indexName,
1: 								isConstraint,
1: 								forUpdate,
1: 								colRefItem,
1: 								lockMode,
1: 								tableLocked,
1: 								isolationLevel,
1: 								true,		// Skip rows with 1 or more null key columns
1: 								optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost,
0: 								closeCleanup);
1: 	}
1: 
1: 	/**
1:     	a distinct scan generator, for ease of use at present.
1: 		@see ResultSetFactory#getHashScanResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getDistinctScanResultSet(
1: 									long conglomId,
1: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
1: 									int resultSetNumber,
1: 									int hashKeyColumn,
1: 									String tableName,
1: 									String indexName,
1: 									boolean isConstraint,
1: 									int colRefItem,
1: 									int lockMode,
1: 									boolean tableLocked,
1: 									int isolationLevel,
1: 									double optimizerEstimatedRowCount,
1: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1: 						getSavedObject(scociItem));
1: 		return new DistinctScanResultSet(
1: 								conglomId,
1: 								scoci,
1: 								activation,
0: 								resultRowAllocator,
1: 								resultSetNumber,
1: 								hashKeyColumn,
1: 								tableName,
1: 								indexName,
1: 								isConstraint,
1: 								colRefItem,
1: 								lockMode,
1: 								tableLocked,
1: 								isolationLevel,
1: 								optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost,
0: 								closeCleanup);
1: 	}
1: 
1: 	/**
1:     	a minimal table scan generator, for ease of use at present.
1: 		@see ResultSetFactory#getTableScanResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getTableScanResultSet(
1: 									long conglomId,
1: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
1: 									int resultSetNumber,
1: 									GeneratedMethod startKeyGetter,
1: 									int startSearchOperator,
1: 									GeneratedMethod stopKeyGetter,
1: 									int stopSearchOperator,
1: 									boolean sameStartStopPosition,
1: 									Qualifier[][] qualifiers,
1: 									String tableName,
1: 									String indexName,
1: 									boolean isConstraint,
1: 									boolean forUpdate,
1: 									int colRefItem,
1: 									int indexColItem,
1: 									int lockMode,
1: 									boolean tableLocked,
1: 									int isolationLevel,
1: 									boolean oneRowScan,
1: 									double optimizerEstimatedRowCount,
1: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1: 						getSavedObject(scociItem));
1: 		return new TableScanResultSet(
1: 								conglomId,
1: 								scoci,
1: 								activation,
0: 								resultRowAllocator,
1: 								resultSetNumber,
1: 								startKeyGetter,
1: 								startSearchOperator,
1: 								stopKeyGetter,
1: 								stopSearchOperator,
1: 								sameStartStopPosition,
1: 								qualifiers,
1: 								tableName,
1: 								indexName,
1: 								isConstraint,
1: 								forUpdate,
1: 								colRefItem,
1: 								indexColItem,
1: 								lockMode,
1: 								tableLocked,
1: 								isolationLevel,
1: 								1,	// rowsPerRead is 1 if not a bulkTableScan
1: 								oneRowScan,
1: 								optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost,
0: 								closeCleanup);
1: 	}
1: 
1: 	/**
1:     	Table/Index scan where rows are read in bulk
1: 		@see ResultSetFactory#getBulkTableScanResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getBulkTableScanResultSet(
1: 									long conglomId,
1: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
1: 									int resultSetNumber,
1: 									GeneratedMethod startKeyGetter,
1: 									int startSearchOperator,
1: 									GeneratedMethod stopKeyGetter,
1: 									int stopSearchOperator,
1: 									boolean sameStartStopPosition,
1: 									Qualifier[][] qualifiers,
1: 									String tableName,
1: 									String indexName,
1: 									boolean isConstraint,
1: 									boolean forUpdate,
1: 									int colRefItem,
1: 									int indexColItem,
1: 									int lockMode,
1: 									boolean tableLocked,
1: 									int isolationLevel,
1: 									int rowsPerRead,
1: 									boolean oneRowScan,
1: 									double optimizerEstimatedRowCount,
1: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1: 		//Prior to Cloudscape 10.0 release, holdability was false by default. Programmers had to explicitly
1: 		//set the holdability to true using JDBC apis. Since holdability was not true by default, we chose to disable the
1: 		//prefetching for RR and Serializable when holdability was explicitly set to true. 
1: 		//But starting Cloudscape 10.0 release, in order to be DB2 compatible, holdability is set to true by default.
1: 		//Because of that, we can not continue to disable the prefetching for RR and Serializable, since it causes
1: 		//severe performance degradation - bug 5953.    
1: 
1:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1: 						getSavedObject(scociItem));
1: 		return new BulkTableScanResultSet(
1: 								conglomId,
1: 								scoci,
1: 								activation,
0: 								resultRowAllocator,
1: 								resultSetNumber,
1: 								startKeyGetter,
1: 								startSearchOperator,
1: 								stopKeyGetter,
1: 								stopSearchOperator,
1: 								sameStartStopPosition,
1: 								qualifiers,
1: 								tableName,
1: 								indexName,
1: 								isConstraint,
1: 								forUpdate,
1: 								colRefItem,
1: 								indexColItem,
1: 								lockMode,
1: 								tableLocked,
1: 								isolationLevel,
1: 								rowsPerRead,
1: 								oneRowScan,
1: 								optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost,
0: 								closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getIndexRowToBaseRowResultSet
0: 		@exception StandardException	Thrown on error
1: 	 */
1: 	public NoPutResultSet getIndexRowToBaseRowResultSet(
1: 								long conglomId,
1: 								int scociItem,
0: 								Activation a,
0: 								NoPutResultSet source,
0: 								GeneratedMethod resultRowAllocator,
1: 								int resultSetNumber,
1: 								String indexName,
1: 								int heapColRefItem,
0: 								int indexColRefItem,
1: 								int indexColMapItem,
0: 								GeneratedMethod restriction,
1: 								boolean forUpdate,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1: 		return new IndexRowToBaseRowResultSet(
1: 								conglomId,
1: 								scociItem,
0: 								a,
0: 								source,
0: 								resultRowAllocator,
1: 								resultSetNumber,
1: 								indexName,
1: 								heapColRefItem,
0: 								indexColRefItem,
1: 								indexColMapItem,
0: 								restriction,
1: 								forUpdate,
1: 							    optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost,
0: 								closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getNestedLoopJoinResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 
1:     public NoPutResultSet getNestedLoopJoinResultSet(NoPutResultSet leftResultSet,
1: 								   int leftNumCols,
1: 								   NoPutResultSet rightResultSet,
1: 								   int rightNumCols,
0: 								   Activation activation,
1: 								   GeneratedMethod joinClause,
1: 								   int resultSetNumber,
1: 								   boolean oneRowRightSide,
1: 								   boolean notExistsRightSide,
1: 								   double optimizerEstimatedRowCount,
1: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1: 		return new NestedLoopJoinResultSet(leftResultSet, leftNumCols,
1: 										   rightResultSet, rightNumCols,
0: 										   activation, joinClause,
1: 										   resultSetNumber, 
1: 										   oneRowRightSide, 
1: 										   notExistsRightSide, 
1: 										   optimizerEstimatedRowCount,
1: 										   optimizerEstimatedCost,
0: 										   closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getHashJoinResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 
1:     public NoPutResultSet getHashJoinResultSet(NoPutResultSet leftResultSet,
1: 								   int leftNumCols,
1: 								   NoPutResultSet rightResultSet,
1: 								   int rightNumCols,
0: 								   Activation activation,
1: 								   GeneratedMethod joinClause,
1: 								   int resultSetNumber,
1: 								   boolean oneRowRightSide,
1: 								   boolean notExistsRightSide,
1: 								   double optimizerEstimatedRowCount,
1: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1: 		return new HashJoinResultSet(leftResultSet, leftNumCols,
1: 										   rightResultSet, rightNumCols,
0: 										   activation, joinClause,
1: 										   resultSetNumber, 
1: 										   oneRowRightSide, 
1: 										   notExistsRightSide, 
1: 										   optimizerEstimatedRowCount,
1: 										   optimizerEstimatedCost,
0: 										   closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getNestedLoopLeftOuterJoinResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 
1:     public NoPutResultSet getNestedLoopLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
1: 								   int leftNumCols,
1: 								   NoPutResultSet rightResultSet,
1: 								   int rightNumCols,
0: 								   Activation activation,
1: 								   GeneratedMethod joinClause,
1: 								   int resultSetNumber,
1: 								   GeneratedMethod emptyRowFun,
1: 								   boolean wasRightOuterJoin,
1: 								   boolean oneRowRightSide,
1: 								   boolean notExistsRightSide,
1: 								   double optimizerEstimatedRowCount,
1: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1: 		return new NestedLoopLeftOuterJoinResultSet(leftResultSet, leftNumCols,
1: 										   rightResultSet, rightNumCols,
0: 										   activation, joinClause,
1: 										   resultSetNumber, 
1: 										   emptyRowFun, 
1: 										   wasRightOuterJoin,
1: 										   oneRowRightSide,
1: 										   notExistsRightSide,
1: 										   optimizerEstimatedRowCount,
1: 										   optimizerEstimatedCost,
0: 										   closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getHashLeftOuterJoinResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 
1:     public NoPutResultSet getHashLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
1: 								   int leftNumCols,
1: 								   NoPutResultSet rightResultSet,
1: 								   int rightNumCols,
0: 								   Activation activation,
1: 								   GeneratedMethod joinClause,
1: 								   int resultSetNumber,
1: 								   GeneratedMethod emptyRowFun,
1: 								   boolean wasRightOuterJoin,
1: 								   boolean oneRowRightSide,
1: 								   boolean notExistsRightSide,
1: 								   double optimizerEstimatedRowCount,
1: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1: 		return new HashLeftOuterJoinResultSet(leftResultSet, leftNumCols,
1: 										   rightResultSet, rightNumCols,
0: 										   activation, joinClause,
1: 										   resultSetNumber, 
1: 										   emptyRowFun, 
1: 										   wasRightOuterJoin,
1: 										   oneRowRightSide,
1: 										   notExistsRightSide,
1: 										   optimizerEstimatedRowCount,
1: 										   optimizerEstimatedCost,
0: 										   closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getSetTransactionResultSet
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	public ResultSet getSetTransactionResultSet(Activation activation) 
1: 		throws StandardException
1: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_ARBITARY_OP);		
1: 		return new SetTransactionResultSet(activation);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getMaterializedResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getMaterializedResultSet(NoPutResultSet source,
1: 							Activation activation, int resultSetNumber,
1: 						    double optimizerEstimatedRowCount,
1: 							double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 		throws StandardException
1: 	{
0: 		return new MaterializedResultSet(source, activation, 
1: 									  resultSetNumber, 
1: 									  optimizerEstimatedRowCount,
1: 									  optimizerEstimatedCost,
0: 									  closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getScrollInsensitiveResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getScrollInsensitiveResultSet(NoPutResultSet source,
1: 							Activation activation, int resultSetNumber,
1: 							int sourceRowWidth,
1: 							boolean scrollable,
1: 						    double optimizerEstimatedRowCount,
1: 							double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 		throws StandardException
1: 	{
1: 		/* ResultSet tree is dependent on whether or not this is
1: 		 * for a scroll insensitive cursor.
1: 		 */
1: 
1: 		if (scrollable)
1: 		{
1: 			return new ScrollInsensitiveResultSet(source, activation, 
1: 									  resultSetNumber, 
1: 									  sourceRowWidth,
1: 									  optimizerEstimatedRowCount,
1: 									  optimizerEstimatedCost,
0: 									  closeCleanup);
1: 		}
1: 		else
1: 		{
1: 			return source;
1: 		}
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getNormalizeResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getNormalizeResultSet(NoPutResultSet source,
1: 							Activation activation, int resultSetNumber, 
1: 							int erdNumber,
1: 						    double optimizerEstimatedRowCount,
1: 							double optimizerEstimatedCost,
1: 							boolean forUpdate,					
0: 							GeneratedMethod closeCleanup)
1: 		throws StandardException
1: 	{
0: 		return new NormalizeResultSet(source, activation, 
1: 									  resultSetNumber, erdNumber, 
1: 									  optimizerEstimatedRowCount,
0: 									  optimizerEstimatedCost, forUpdate,
0: 									  closeCleanup);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getCurrentOfResultSet
1: 	 */
1: 	public NoPutResultSet getCurrentOfResultSet(String cursorName, 
0: 	    Activation activation, int resultSetNumber, String psName)
1: 	{
0: 		return new CurrentOfResultSet(cursorName, activation, resultSetNumber, psName);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getDDLResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public ResultSet getDDLResultSet(Activation activation)
1: 					throws StandardException
1: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_DDL_OP);
1: 		return getMiscResultSet( activation);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetFactory#getMiscResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public ResultSet getMiscResultSet(Activation activation)
1: 					throws StandardException
1: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_ARBITARY_OP);
1: 		return new MiscResultSet(activation);
1: 	}
1: 
1: 	/**
1:     	a minimal union scan generator, for ease of use at present.
1: 		@see ResultSetFactory#getUnionResultSet
1: 		@exception StandardException thrown on error
1: 	 */
1:     public NoPutResultSet getUnionResultSet(NoPutResultSet leftResultSet,
1: 								   NoPutResultSet rightResultSet,
0: 								   Activation activation,
1: 								   int resultSetNumber,
1: 								   double optimizerEstimatedRowCount,
1: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 			throws StandardException
1: 	{
1: 		return new UnionResultSet(leftResultSet, rightResultSet, 
1: 								  activation,
1: 								  resultSetNumber, 
1: 								  optimizerEstimatedRowCount,
1: 								  optimizerEstimatedCost,
0: 								  closeCleanup);
1: 	}
1: 
1: 	/**
1: 	 * A last index key sresult set returns the last row from
1: 	 * the index in question.  It is used as an ajunct to max().
1: 	 *
1: 	 * @param activation 		the activation for this result set,
1: 	 *		which provides the context for the row allocation operation.
1: 	 * @param resultSetNumber	The resultSetNumber for the ResultSet
0: 	 * @param resultRowAllocator a reference to a method in the activation
0: 	 * 						that creates a holder for the result row of the scan.  May
0: 	 *						be a partial row.  <verbatim>
0: 	 *		ExecRow rowAllocator() throws StandardException; </verbatim>
1: 	 * @param conglomId 		the conglomerate of the table to be scanned.
1: 	 * @param tableName			The full name of the table
1: 	 * @param indexName			The name of the index, if one used to access table.
1: 	 * @param colRefItem		An saved item for a bitSet of columns that
1: 	 *							are referenced in the underlying table.  -1 if
1: 	 *							no item.
1: 	 * @param lockMode			The lock granularity to use (see
1: 	 *							TransactionController in access)
1: 	 * @param tableLocked		Whether or not the table is marked as using table locking
1: 	 *							(in sys.systables)
1: 	 * @param isolationLevel	Isolation level (specified or not) to use on scans
1: 	 * @param optimizerEstimatedRowCount	Estimated total # of rows by
1: 	 * 										optimizer
1: 	 * @param optimizerEstimatedCost		Estimated total cost by optimizer
0: 	 * @param closeCleanup		any cleanup the activation needs to do on close.
1: 	 *
1: 	 * @return the scan operation as a result set.
1:  	 *
1: 	 * @exception StandardException thrown when unable to create the
1: 	 * 				result set
1: 	 */
1: 	public NoPutResultSet getLastIndexKeyResultSet
1: 	(
1: 		Activation 			activation,
1: 		int 				resultSetNumber,
0: 		GeneratedMethod 	resultRowAllocator,
1: 		long 				conglomId,
1: 		String 				tableName,
1: 		String 				indexName,
1: 		int 				colRefItem,
1: 		int 				lockMode,
1: 		boolean				tableLocked,
1: 		int					isolationLevel,
1: 		double				optimizerEstimatedRowCount,
0: 		double 				optimizerEstimatedCost,
0: 		GeneratedMethod 	closeCleanup
1: 	) throws StandardException
1: 	{
1: 		return new LastIndexKeyResultSet(
1: 					activation,
1: 					resultSetNumber,
0: 					resultRowAllocator,
1: 					conglomId,
1: 					tableName,
1: 					indexName,
1: 					colRefItem,
1: 					lockMode,
1: 					tableLocked,
1: 					isolationLevel,
1: 					optimizerEstimatedRowCount,
1: 					optimizerEstimatedCost,
0: 					closeCleanup);
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	 *	a referential action dependent table scan generator.
1: 	 *  @see ResultSetFactory#getTableScanResultSet
1: 	 *	@exception StandardException thrown on error
1: 	 */
1: 	public NoPutResultSet getRaDependentTableScanResultSet(
1: 									long conglomId,
1: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
1: 									int resultSetNumber,
1: 									GeneratedMethod startKeyGetter,
1: 									int startSearchOperator,
1: 									GeneratedMethod stopKeyGetter,
1: 									int stopSearchOperator,
1: 									boolean sameStartStopPosition,
1: 									Qualifier[][] qualifiers,
1: 									String tableName,
1: 									String indexName,
1: 									boolean isConstraint,
1: 									boolean forUpdate,
1: 									int colRefItem,
1: 									int indexColItem,
1: 									int lockMode,
1: 									boolean tableLocked,
1: 									int isolationLevel,
1: 									boolean oneRowScan,
1: 									double optimizerEstimatedRowCount,
1: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup,
1: 									String parentResultSetId,
1: 									long fkIndexConglomId,
1: 									int fkColArrayItem,
1: 									int rltItem)
1: 			throws StandardException
1: 	{
1:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
1: 						getSavedObject(scociItem));
1: 		return new DependentResultSet(
1: 								conglomId,
1: 								scoci,
1: 								activation,
0: 								resultRowAllocator,
1: 								resultSetNumber,
1: 								startKeyGetter,
1: 								startSearchOperator,
1: 								stopKeyGetter,
1: 								stopSearchOperator,
1: 								sameStartStopPosition,
1: 								qualifiers,
1: 								tableName,
1: 								indexName,
1: 								isConstraint,
1: 								forUpdate,
1: 								colRefItem,
1: 								lockMode,
1: 								tableLocked,
1: 								isolationLevel,
1: 								1,
1: 								oneRowScan,
1: 								optimizerEstimatedRowCount,
1: 								optimizerEstimatedCost,
0: 								closeCleanup,
1: 								parentResultSetId,
1: 								fkIndexConglomId,
1: 								fkColArrayItem,
1: 								rltItem);
1: 	}
1: 	
1: 	static private Authorizer getAuthorizer(Activation activation)
1: 	{
1: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1: 		return lcc.getAuthorizer();
1: 	}
1: 
1: 
1:    /////////////////////////////////////////////////////////////////
1:    //
1:    //	PUBLIC MINIONS
1:    //
1:    /////////////////////////////////////////////////////////////////
1: 
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:318307e
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_CALL_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_ARBITARY_OP);		
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_DDL_OP);
/////////////////////////////////////////////////////////////////////////
1: 		getAuthorizer(activation).authorize(activation, Authorizer.SQL_ARBITARY_OP);
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
1: 									String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 								userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 									String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 								userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 									String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 								userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 									String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 								userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 										   userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
0: 								   String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 										   userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
0: 								   String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
0: 										   userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
0: 								   String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
0: 										   userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 	 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
1: 		String 				userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
0: 					userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
0: 									String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
0: 								userSuppliedOptimizerOverrides,
commit:6200b38
/////////////////////////////////////////////////////////////////////////
1:     public NoPutResultSet getSetOpResultSet( NoPutResultSet leftSource,
1:                                              NoPutResultSet rightSource,
0:                                              Activation activation, 
0:                                              int resultSetNumber,
1:                                              long optimizerEstimatedRowCount,
0:                                              double optimizerEstimatedCost,
1:                                              int opType,
1:                                              boolean all,
0:                                              GeneratedMethod closeCleanup,
0:                                              int intermediateOrderByColumnsSavedObject,
0:                                              int intermediateOrderByDirectionSavedObject)
0:         throws StandardException
0:     {
1:         return new SetOpResultSet( leftSource,
1:                                    rightSource,
0:                                    activation,
0:                                    resultSetNumber,
0:                                    optimizerEstimatedRowCount,
0:                                    optimizerEstimatedCost,
1:                                    opType,
1:                                    all,
0:                                    closeCleanup,
1:                                    intermediateOrderByColumnsSavedObject,
0:                                    intermediateOrderByDirectionSavedObject);
0:     }
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: 
0: import org.apache.derby.iapi.sql.conn.Authorizer;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import java.util.Properties;
0: /**
0:  * ResultSetFactory provides a wrapper around all of
0:  * the result sets used in this execution implementation.
0:  * This removes the need of generated classes to do a new
0:  * and of the generator to know about all of the result
0:  * sets.  Both simply know about this interface to getting
0:  * them.
0:  * <p>
0:  * In terms of modularizing, we can create just an interface
0:  * to this class and invoke the interface.  Different implementations
0:  * would get the same information provided but could potentially
0:  * massage/ignore it in different ways to satisfy their
0:  * implementations.  The practicality of this is to be seen.
0:  * <p>
0:  * The cost of this type of factory is that once you touch it,
0:  * you touch *all* of the possible result sets, not just
0:  * the ones you need.  So the first time you touch it could
0:  * be painful ... that might be a problem for execution.
0:  *
0:  * @author ames
0:  */
0: public class GenericResultSetFactory implements ResultSetFactory 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	//
0: 	// ResultSetFactory interface
0: 	//
0: 	public GenericResultSetFactory()
0: 	{
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getInsertResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getInsertResultSet(NoPutResultSet source, 
0: 										GeneratedMethod checkGM,
0: 										Activation activation)
0: 		throws StandardException
0: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new InsertResultSet(source, checkGM, activation );
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getInsertVTIResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getInsertVTIResultSet(NoPutResultSet source, 
0: 										NoPutResultSet vtiRS,
0: 										Activation activation)
0: 		throws StandardException
0: 	{
0: 
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new InsertVTIResultSet(source, vtiRS, activation );
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getDeleteVTIResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getDeleteVTIResultSet(NoPutResultSet source, 
0: 										Activation activation)
0: 		throws StandardException
0: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new DeleteVTIResultSet(source, activation);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getDeleteResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getDeleteResultSet(NoPutResultSet source,
0: 										Activation activation)
0: 			throws StandardException
0: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new DeleteResultSet(source, activation );
0: 	}
0: 
0: 
0: 	/**
0: 		@see ResultSetFactory#getDeleteCascadeResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getDeleteCascadeResultSet(NoPutResultSet source, 
0: 											   Activation activation,	
0: 											   int constantActionItem,
0: 											   ResultSet[] dependentResultSets,
0: 											   String resultSetId)
0: 		throws StandardException
0: 	{
0: 			
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new DeleteCascadeResultSet(source, activation, 
0: 										  constantActionItem,
0: 										  dependentResultSets, 
0: 										  resultSetId);
0: 	}
0: 
0: 
0: 
0: 	/**
0: 		@see ResultSetFactory#getUpdateResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getUpdateResultSet(NoPutResultSet source,
0: 										GeneratedMethod checkGM,
0: 										Activation activation)
0: 			throws StandardException
0: 	{
0: 		//The stress test failed with null pointer exception in here once and then
0: 		//it didn't happen again. It can be a jit problem because after this null
0: 		//pointer exception, the cleanup code in UpdateResultSet got a null
0: 		//pointer exception too which can't happen since the cleanup code checks
0: 		//for null value before doing anything.
0: 		//In any case, if this ever happens again, hopefully the following
0: 		//assertion code will catch it.
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(getAuthorizer(activation) != null, "Authorizer is null");
0: 		}
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new UpdateResultSet(source, checkGM, activation);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getUpdateVTIResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getUpdateVTIResultSet(NoPutResultSet source,
0:                                            Activation activation)
0: 			throws StandardException
0: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new UpdateVTIResultSet(source, activation);
0: 	}
0: 
0: 
0: 
0: 	/**
0: 		@see ResultSetFactory#getDeleteCascadeUpdateResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getDeleteCascadeUpdateResultSet(NoPutResultSet source,
0: 													 GeneratedMethod checkGM,
0: 													 Activation activation,
0: 													 int constantActionItem,
0: 													 int rsdItem)
0: 			throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(getAuthorizer(activation) != null, "Authorizer is null");
0: 		}
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_WRITE_OP);
0: 		return new UpdateResultSet(source, checkGM, activation,
0: 								   constantActionItem, rsdItem);
0: 	}
0: 
0: 
0: 	/**
0: 		@see ResultSetFactory#getCallStatementResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getCallStatementResultSet(GeneratedMethod methodCall,
0: 				Activation activation)
0: 			throws StandardException
0: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_CALL_OP);
0: 		return new CallStatementResultSet(methodCall, activation);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getProjectRestrictResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getProjectRestrictResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod restriction, 
0: 		GeneratedMethod projection, int resultSetNumber,
0: 		GeneratedMethod constantRestriction,
0: 		int mapRefItem,
0: 		boolean reuseResult,
0: 		boolean doesProjection,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		return new ProjectRestrictResultSet(source, activation, 
0: 			restriction, projection, resultSetNumber, 
0: 			constantRestriction, mapRefItem, 
0: 			reuseResult,
0: 			doesProjection,
0: 		    optimizerEstimatedRowCount,
0: 			optimizerEstimatedCost,
0: 			closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getHashTableResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getHashTableResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod singleTableRestriction, 
0: 		Qualifier[][] equijoinQualifiers,
0: 		GeneratedMethod projection, int resultSetNumber,
0: 		int mapRefItem,
0: 		boolean reuseResult,
0: 		int keyColItem,
0: 		boolean removeDuplicates,
0: 		long maxInMemoryRowCount,
0: 		int	initialCapacity,
0: 		float loadFactor,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		return new HashTableResultSet(source, activation, 
0: 			singleTableRestriction, 
0:             equijoinQualifiers,
0: 			projection, resultSetNumber, 
0: 			mapRefItem, 
0: 			reuseResult,
0: 			keyColItem, removeDuplicates,
0: 			maxInMemoryRowCount,
0: 			initialCapacity,
0: 			loadFactor,
0: 			true,		// Skip rows with 1 or more null key columns
0: 		    optimizerEstimatedRowCount,
0: 			optimizerEstimatedCost,
0: 			closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getSortResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getSortResultSet(NoPutResultSet source,
0: 		boolean distinct, 
0: 		boolean isInSortedOrder,
0: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int maxRowSize,
0: 		int resultSetNumber, 
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		return new SortResultSet(source, 
0: 			distinct, 
0: 			isInSortedOrder,
0: 			orderItem,
0: 			activation, 
0: 			rowAllocator, 
0: 			maxRowSize,
0: 			resultSetNumber, 
0: 		    optimizerEstimatedRowCount,
0: 			optimizerEstimatedCost,
0: 			closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getScalarAggregateResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getScalarAggregateResultSet(NoPutResultSet source,
0: 		boolean isInSortedOrder,
0: 		int aggregateItem,
0: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int maxRowSize,
0: 		int resultSetNumber, 
0: 		boolean singleInputRow,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
0: 			throws StandardException
0: 	{
0: 		return new ScalarAggregateResultSet(
0: 						source, isInSortedOrder, aggregateItem, activation,
0: 						rowAllocator, resultSetNumber, singleInputRow,
0: 						optimizerEstimatedRowCount,
0: 						optimizerEstimatedCost, closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getDistinctScalarAggregateResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getDistinctScalarAggregateResultSet(NoPutResultSet source,
0: 		boolean isInSortedOrder,
0: 		int aggregateItem,
0: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int maxRowSize,
0: 		int resultSetNumber, 
0: 		boolean singleInputRow,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
0: 			throws StandardException
0: 	{
0: 		return new DistinctScalarAggregateResultSet(
0: 						source, isInSortedOrder, aggregateItem, orderItem, activation,
0: 						rowAllocator, maxRowSize, resultSetNumber, singleInputRow,
0: 						optimizerEstimatedRowCount,
0: 						optimizerEstimatedCost, closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getGroupedAggregateResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getGroupedAggregateResultSet(NoPutResultSet source,
0: 		boolean isInSortedOrder,
0: 		int aggregateItem,
0: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int maxRowSize,
0: 		int resultSetNumber, 
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
0: 			throws StandardException
0: 	{
0: 		return new GroupedAggregateResultSet(
0: 						source, isInSortedOrder, aggregateItem, orderItem, activation,
0: 						rowAllocator, maxRowSize, resultSetNumber, optimizerEstimatedRowCount,
0: 						optimizerEstimatedCost, closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getDistinctGroupedAggregateResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getDistinctGroupedAggregateResultSet(NoPutResultSet source,
0: 		boolean isInSortedOrder,
0: 		int aggregateItem,
0: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int maxRowSize,
0: 		int resultSetNumber, 
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
0: 			throws StandardException
0: 	{
0: 		return new DistinctGroupedAggregateResultSet(
0: 						source, isInSortedOrder, aggregateItem, orderItem, activation,
0: 						rowAllocator, maxRowSize, resultSetNumber, optimizerEstimatedRowCount,
0: 						optimizerEstimatedCost, closeCleanup);
0: 	}
0: 											
0: 
0: 	/**
0: 		@see ResultSetFactory#getAnyResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getAnyResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod emptyRowFun, int resultSetNumber,
0: 		int subqueryNumber, int pointOfAttachment,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost)
0: 			throws StandardException
0: 	{
0: 		return new AnyResultSet(source,
0: 					 activation, emptyRowFun, resultSetNumber,
0: 					 subqueryNumber, pointOfAttachment,
0: 					 optimizerEstimatedRowCount,
0: 					 optimizerEstimatedCost);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getOnceResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getOnceResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod emptyRowFun,
0: 		int cardinalityCheck, int resultSetNumber,
0: 		int subqueryNumber, int pointOfAttachment,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost)
0: 			throws StandardException
0: 	{
0: 		return new OnceResultSet(source,
0: 					 activation, emptyRowFun, 
0: 					 cardinalityCheck, resultSetNumber,
0: 					 subqueryNumber, pointOfAttachment,
0: 				     optimizerEstimatedRowCount,
0: 					 optimizerEstimatedCost);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getRowResultSet
0: 	 */
0: 	public NoPutResultSet getRowResultSet(Activation activation, GeneratedMethod row,
0: 									 boolean canCacheRow,
0: 									 int resultSetNumber,
0: 									 double optimizerEstimatedRowCount,
0: 									 double optimizerEstimatedCost,
0: 								     GeneratedMethod closeCleanup)
0: 	{
0: 		return new RowResultSet(activation, row, canCacheRow, resultSetNumber, 
0: 							    optimizerEstimatedRowCount,
0: 								optimizerEstimatedCost,
0: 								closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getVTIResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getVTIResultSet(Activation activation, GeneratedMethod row,
0: 									 int resultSetNumber,
0: 									 GeneratedMethod constructor,
0: 									 String javaClassName,
0: 									 Qualifier[][] pushedQualifiers,
0: 									 int erdNumber,
0: 									 boolean version2,
0: 									 boolean reuseablePs,
0: 									 int ctcNumber,
0: 									 boolean isTarget,
0: 									 int scanIsolationLevel,
0: 									 double optimizerEstimatedRowCount,
0: 									 double optimizerEstimatedCost,
0: 								     GeneratedMethod closeCleanup)
0: 		throws StandardException
0: 	{
0: 		return new VTIResultSet(activation, row, resultSetNumber, 
0: 								constructor,
0: 								javaClassName,
0: 								pushedQualifiers,
0: 								erdNumber,
0: 								version2, reuseablePs,
0: 								ctcNumber,
0: 								isTarget,
0: 								scanIsolationLevel,
0: 							    optimizerEstimatedRowCount,
0: 								optimizerEstimatedCost,
0: 								closeCleanup);
0: 	}
0: 
0: 	/**
0:     	a hash scan generator, for ease of use at present.
0: 		@see ResultSetFactory#getHashScanResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getHashScanResultSet(
0: 									long conglomId,
0: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
0: 									int resultSetNumber,
0: 									GeneratedMethod startKeyGetter,
0: 									int startSearchOperator,
0: 									GeneratedMethod stopKeyGetter,
0: 									int stopSearchOperator,
0: 									boolean sameStartStopPosition,
0: 									Qualifier[][] scanQualifiers,
0: 									Qualifier[][] nextQualifiers,
0: 									int initialCapacity,
0: 									float loadFactor,
0: 									int maxCapacity,
0: 									int hashKeyColumn,
0: 									String tableName,
0: 									String indexName,
0: 									boolean isConstraint,
0: 									boolean forUpdate,
0: 									int colRefItem,
0: 									int indexColItem,
0: 									int lockMode,
0: 									boolean tableLocked,
0: 									int isolationLevel,
0: 									double optimizerEstimatedRowCount,
0: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
0: 						getSavedObject(scociItem));
0: 
0: 		return new HashScanResultSet(
0: 								conglomId,
0: 								scoci,
0: 								activation,
0: 								resultRowAllocator,
0: 								resultSetNumber,
0: 								startKeyGetter,
0: 								startSearchOperator,
0: 								stopKeyGetter,
0: 								stopSearchOperator,
0: 								sameStartStopPosition,
0: 								scanQualifiers,
0: 								nextQualifiers,
0: 								initialCapacity,
0: 								loadFactor,
0: 								maxCapacity,
0: 								hashKeyColumn,
0: 								tableName,
0: 								indexName,
0: 								isConstraint,
0: 								forUpdate,
0: 								colRefItem,
0: 								lockMode,
0: 								tableLocked,
0: 								isolationLevel,
0: 								true,		// Skip rows with 1 or more null key columns
0: 								optimizerEstimatedRowCount,
0: 								optimizerEstimatedCost,
0: 								closeCleanup);
0: 	}
0: 
0: 	/**
0:     	a distinct scan generator, for ease of use at present.
0: 		@see ResultSetFactory#getHashScanResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getDistinctScanResultSet(
0: 									long conglomId,
0: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
0: 									int resultSetNumber,
0: 									int hashKeyColumn,
0: 									String tableName,
0: 									String indexName,
0: 									boolean isConstraint,
0: 									int colRefItem,
0: 									int lockMode,
0: 									boolean tableLocked,
0: 									int isolationLevel,
0: 									double optimizerEstimatedRowCount,
0: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
0: 						getSavedObject(scociItem));
0: 		return new DistinctScanResultSet(
0: 								conglomId,
0: 								scoci,
0: 								activation,
0: 								resultRowAllocator,
0: 								resultSetNumber,
0: 								hashKeyColumn,
0: 								tableName,
0: 								indexName,
0: 								isConstraint,
0: 								colRefItem,
0: 								lockMode,
0: 								tableLocked,
0: 								isolationLevel,
0: 								optimizerEstimatedRowCount,
0: 								optimizerEstimatedCost,
0: 								closeCleanup);
0: 	}
0: 
0: 	/**
0:     	a minimal table scan generator, for ease of use at present.
0: 		@see ResultSetFactory#getTableScanResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getTableScanResultSet(
0: 									long conglomId,
0: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
0: 									int resultSetNumber,
0: 									GeneratedMethod startKeyGetter,
0: 									int startSearchOperator,
0: 									GeneratedMethod stopKeyGetter,
0: 									int stopSearchOperator,
0: 									boolean sameStartStopPosition,
0: 									Qualifier[][] qualifiers,
0: 									String tableName,
0: 									String indexName,
0: 									boolean isConstraint,
0: 									boolean forUpdate,
0: 									int colRefItem,
0: 									int indexColItem,
0: 									int lockMode,
0: 									boolean tableLocked,
0: 									int isolationLevel,
0: 									boolean oneRowScan,
0: 									double optimizerEstimatedRowCount,
0: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
0: 						getSavedObject(scociItem));
0: 		return new TableScanResultSet(
0: 								conglomId,
0: 								scoci,
0: 								activation,
0: 								resultRowAllocator,
0: 								resultSetNumber,
0: 								startKeyGetter,
0: 								startSearchOperator,
0: 								stopKeyGetter,
0: 								stopSearchOperator,
0: 								sameStartStopPosition,
0: 								qualifiers,
0: 								tableName,
0: 								indexName,
0: 								isConstraint,
0: 								forUpdate,
0: 								colRefItem,
0: 								indexColItem,
0: 								lockMode,
0: 								tableLocked,
0: 								isolationLevel,
0: 								1,	// rowsPerRead is 1 if not a bulkTableScan
0: 								oneRowScan,
0: 								optimizerEstimatedRowCount,
0: 								optimizerEstimatedCost,
0: 								closeCleanup);
0: 	}
0: 
0: 	/**
0:     	Table/Index scan where rows are read in bulk
0: 		@see ResultSetFactory#getBulkTableScanResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getBulkTableScanResultSet(
0: 									long conglomId,
0: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
0: 									int resultSetNumber,
0: 									GeneratedMethod startKeyGetter,
0: 									int startSearchOperator,
0: 									GeneratedMethod stopKeyGetter,
0: 									int stopSearchOperator,
0: 									boolean sameStartStopPosition,
0: 									Qualifier[][] qualifiers,
0: 									String tableName,
0: 									String indexName,
0: 									boolean isConstraint,
0: 									boolean forUpdate,
0: 									int colRefItem,
0: 									int indexColItem,
0: 									int lockMode,
0: 									boolean tableLocked,
0: 									int isolationLevel,
0: 									int rowsPerRead,
0: 									boolean oneRowScan,
0: 									double optimizerEstimatedRowCount,
0: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		//Prior to Cloudscape 10.0 release, holdability was false by default. Programmers had to explicitly
0: 		//set the holdability to true using JDBC apis. Since holdability was not true by default, we chose to disable the
0: 		//prefetching for RR and Serializable when holdability was explicitly set to true. 
0: 		//But starting Cloudscape 10.0 release, in order to be DB2 compatible, holdability is set to true by default.
0: 		//Because of that, we can not continue to disable the prefetching for RR and Serializable, since it causes
0: 		//severe performance degradation - bug 5953.    
0: 
0:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
0: 						getSavedObject(scociItem));
0: 		return new BulkTableScanResultSet(
0: 								conglomId,
0: 								scoci,
0: 								activation,
0: 								resultRowAllocator,
0: 								resultSetNumber,
0: 								startKeyGetter,
0: 								startSearchOperator,
0: 								stopKeyGetter,
0: 								stopSearchOperator,
0: 								sameStartStopPosition,
0: 								qualifiers,
0: 								tableName,
0: 								indexName,
0: 								isConstraint,
0: 								forUpdate,
0: 								colRefItem,
0: 								indexColItem,
0: 								lockMode,
0: 								tableLocked,
0: 								isolationLevel,
0: 								rowsPerRead,
0: 								oneRowScan,
0: 								optimizerEstimatedRowCount,
0: 								optimizerEstimatedCost,
0: 								closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getIndexRowToBaseRowResultSet
0: 		@exception StandardException	Thrown on error
0: 	 */
0: 	public NoPutResultSet getIndexRowToBaseRowResultSet(
0: 								long conglomId,
0: 								int scociItem,
0: 								Activation a,
0: 								NoPutResultSet source,
0: 								GeneratedMethod resultRowAllocator,
0: 								int resultSetNumber,
0: 								String indexName,
0: 								int heapColRefItem,
0: 								int indexColRefItem,
0: 								int indexColMapItem,
0: 								GeneratedMethod restriction,
0: 								boolean forUpdate,
0: 								double optimizerEstimatedRowCount,
0: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		return new IndexRowToBaseRowResultSet(
0: 								conglomId,
0: 								scociItem,
0: 								a,
0: 								source,
0: 								resultRowAllocator,
0: 								resultSetNumber,
0: 								indexName,
0: 								heapColRefItem,
0: 								indexColRefItem,
0: 								indexColMapItem,
0: 								restriction,
0: 								forUpdate,
0: 							    optimizerEstimatedRowCount,
0: 								optimizerEstimatedCost,
0: 								closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getNestedLoopJoinResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 
0:     public NoPutResultSet getNestedLoopJoinResultSet(NoPutResultSet leftResultSet,
0: 								   int leftNumCols,
0: 								   NoPutResultSet rightResultSet,
0: 								   int rightNumCols,
0: 								   Activation activation,
0: 								   GeneratedMethod joinClause,
0: 								   int resultSetNumber,
0: 								   boolean oneRowRightSide,
0: 								   boolean notExistsRightSide,
0: 								   double optimizerEstimatedRowCount,
0: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		return new NestedLoopJoinResultSet(leftResultSet, leftNumCols,
0: 										   rightResultSet, rightNumCols,
0: 										   activation, joinClause,
0: 										   resultSetNumber, 
0: 										   oneRowRightSide, 
0: 										   notExistsRightSide, 
0: 										   optimizerEstimatedRowCount,
0: 										   optimizerEstimatedCost,
0: 										   closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getHashJoinResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 
0:     public NoPutResultSet getHashJoinResultSet(NoPutResultSet leftResultSet,
0: 								   int leftNumCols,
0: 								   NoPutResultSet rightResultSet,
0: 								   int rightNumCols,
0: 								   Activation activation,
0: 								   GeneratedMethod joinClause,
0: 								   int resultSetNumber,
0: 								   boolean oneRowRightSide,
0: 								   boolean notExistsRightSide,
0: 								   double optimizerEstimatedRowCount,
0: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		return new HashJoinResultSet(leftResultSet, leftNumCols,
0: 										   rightResultSet, rightNumCols,
0: 										   activation, joinClause,
0: 										   resultSetNumber, 
0: 										   oneRowRightSide, 
0: 										   notExistsRightSide, 
0: 										   optimizerEstimatedRowCount,
0: 										   optimizerEstimatedCost,
0: 										   closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getNestedLoopLeftOuterJoinResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 
0:     public NoPutResultSet getNestedLoopLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
0: 								   int leftNumCols,
0: 								   NoPutResultSet rightResultSet,
0: 								   int rightNumCols,
0: 								   Activation activation,
0: 								   GeneratedMethod joinClause,
0: 								   int resultSetNumber,
0: 								   GeneratedMethod emptyRowFun,
0: 								   boolean wasRightOuterJoin,
0: 								   boolean oneRowRightSide,
0: 								   boolean notExistsRightSide,
0: 								   double optimizerEstimatedRowCount,
0: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		return new NestedLoopLeftOuterJoinResultSet(leftResultSet, leftNumCols,
0: 										   rightResultSet, rightNumCols,
0: 										   activation, joinClause,
0: 										   resultSetNumber, 
0: 										   emptyRowFun, 
0: 										   wasRightOuterJoin,
0: 										   oneRowRightSide,
0: 										   notExistsRightSide,
0: 										   optimizerEstimatedRowCount,
0: 										   optimizerEstimatedCost,
0: 										   closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getHashLeftOuterJoinResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 
0:     public NoPutResultSet getHashLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
0: 								   int leftNumCols,
0: 								   NoPutResultSet rightResultSet,
0: 								   int rightNumCols,
0: 								   Activation activation,
0: 								   GeneratedMethod joinClause,
0: 								   int resultSetNumber,
0: 								   GeneratedMethod emptyRowFun,
0: 								   boolean wasRightOuterJoin,
0: 								   boolean oneRowRightSide,
0: 								   boolean notExistsRightSide,
0: 								   double optimizerEstimatedRowCount,
0: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		return new HashLeftOuterJoinResultSet(leftResultSet, leftNumCols,
0: 										   rightResultSet, rightNumCols,
0: 										   activation, joinClause,
0: 										   resultSetNumber, 
0: 										   emptyRowFun, 
0: 										   wasRightOuterJoin,
0: 										   oneRowRightSide,
0: 										   notExistsRightSide,
0: 										   optimizerEstimatedRowCount,
0: 										   optimizerEstimatedCost,
0: 										   closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getSetTransactionResultSet
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	public ResultSet getSetTransactionResultSet(Activation activation) 
0: 		throws StandardException
0: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_ARBITARY_OP);		
0: 		return new SetTransactionResultSet(activation);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getMaterializedResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getMaterializedResultSet(NoPutResultSet source,
0: 							Activation activation, int resultSetNumber,
0: 						    double optimizerEstimatedRowCount,
0: 							double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 		throws StandardException
0: 	{
0: 		return new MaterializedResultSet(source, activation, 
0: 									  resultSetNumber, 
0: 									  optimizerEstimatedRowCount,
0: 									  optimizerEstimatedCost,
0: 									  closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getScrollInsensitiveResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getScrollInsensitiveResultSet(NoPutResultSet source,
0: 							Activation activation, int resultSetNumber,
0: 							int sourceRowWidth,
0: 							boolean scrollable,
0: 						    double optimizerEstimatedRowCount,
0: 							double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 		throws StandardException
0: 	{
0: 		/* ResultSet tree is dependent on whether or not this is
0: 		 * for a scroll insensitive cursor.
0: 		 */
0: 
0: 		if (scrollable)
0: 		{
0: 			return new ScrollInsensitiveResultSet(source, activation, 
0: 									  resultSetNumber, 
0: 									  sourceRowWidth,
0: 									  optimizerEstimatedRowCount,
0: 									  optimizerEstimatedCost,
0: 									  closeCleanup);
0: 		}
0: 		else
0: 		{
0: 			return source;
0: 		}
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getNormalizeResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getNormalizeResultSet(NoPutResultSet source,
0: 							Activation activation, int resultSetNumber, 
0: 							int erdNumber,
0: 						    double optimizerEstimatedRowCount,
0: 							double optimizerEstimatedCost,
0: 							boolean forUpdate,					
0: 							GeneratedMethod closeCleanup)
0: 		throws StandardException
0: 	{
0: 		return new NormalizeResultSet(source, activation, 
0: 									  resultSetNumber, erdNumber, 
0: 									  optimizerEstimatedRowCount,
0: 									  optimizerEstimatedCost, forUpdate,
0: 									  closeCleanup);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getCurrentOfResultSet
0: 	 */
0: 	public NoPutResultSet getCurrentOfResultSet(String cursorName, 
0: 	    Activation activation, int resultSetNumber, String psName)
0: 	{
0: 		return new CurrentOfResultSet(cursorName, activation, resultSetNumber, psName);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getDDLResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getDDLResultSet(Activation activation)
0: 					throws StandardException
0: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_DDL_OP);
0: 		return getMiscResultSet( activation);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetFactory#getMiscResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getMiscResultSet(Activation activation)
0: 					throws StandardException
0: 	{
0: 		getAuthorizer(activation).authorize(Authorizer.SQL_ARBITARY_OP);
0: 		return new MiscResultSet(activation);
0: 	}
0: 
0: 	/**
0:     	a minimal union scan generator, for ease of use at present.
0: 		@see ResultSetFactory#getUnionResultSet
0: 		@exception StandardException thrown on error
0: 	 */
0:     public NoPutResultSet getUnionResultSet(NoPutResultSet leftResultSet,
0: 								   NoPutResultSet rightResultSet,
0: 								   Activation activation,
0: 								   int resultSetNumber,
0: 								   double optimizerEstimatedRowCount,
0: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 			throws StandardException
0: 	{
0: 		return new UnionResultSet(leftResultSet, rightResultSet, 
0: 								  activation,
0: 								  resultSetNumber, 
0: 								  optimizerEstimatedRowCount,
0: 								  optimizerEstimatedCost,
0: 								  closeCleanup);
0: 	}
0: 
0: 	/**
0: 	 * A last index key sresult set returns the last row from
0: 	 * the index in question.  It is used as an ajunct to max().
0: 	 *
0: 	 * @param activation 		the activation for this result set,
0: 	 *		which provides the context for the row allocation operation.
0: 	 * @param resultSetNumber	The resultSetNumber for the ResultSet
0: 	 * @param resultRowAllocator a reference to a method in the activation
0: 	 * 						that creates a holder for the result row of the scan.  May
0: 	 *						be a partial row.  <verbatim>
0: 	 *		ExecRow rowAllocator() throws StandardException; </verbatim>
0: 	 * @param conglomId 		the conglomerate of the table to be scanned.
0: 	 * @param tableName			The full name of the table
0: 	 * @param indexName			The name of the index, if one used to access table.
0: 	 * @param colRefItem		An saved item for a bitSet of columns that
0: 	 *							are referenced in the underlying table.  -1 if
0: 	 *							no item.
0: 	 * @param lockMode			The lock granularity to use (see
0: 	 *							TransactionController in access)
0: 	 * @param tableLocked		Whether or not the table is marked as using table locking
0: 	 *							(in sys.systables)
0: 	 * @param isolationLevel	Isolation level (specified or not) to use on scans
0: 	 * @param optimizerEstimatedRowCount	Estimated total # of rows by
0: 	 * 										optimizer
0: 	 * @param optimizerEstimatedCost		Estimated total cost by optimizer
0: 	 * @param closeCleanup		any cleanup the activation needs to do on close.
0: 	 *
0: 	 * @return the scan operation as a result set.
0:  	 *
0: 	 * @exception StandardException thrown when unable to create the
0: 	 * 				result set
0: 	 */
0: 	public NoPutResultSet getLastIndexKeyResultSet
0: 	(
0: 		Activation 			activation,
0: 		int 				resultSetNumber,
0: 		GeneratedMethod 	resultRowAllocator,
0: 		long 				conglomId,
0: 		String 				tableName,
0: 		String 				indexName,
0: 		int 				colRefItem,
0: 		int 				lockMode,
0: 		boolean				tableLocked,
0: 		int					isolationLevel,
0: 		double				optimizerEstimatedRowCount,
0: 		double 				optimizerEstimatedCost,
0: 		GeneratedMethod 	closeCleanup
0: 	) throws StandardException
0: 	{
0: 		return new LastIndexKeyResultSet(
0: 					activation,
0: 					resultSetNumber,
0: 					resultRowAllocator,
0: 					conglomId,
0: 					tableName,
0: 					indexName,
0: 					colRefItem,
0: 					lockMode,
0: 					tableLocked,
0: 					isolationLevel,
0: 					optimizerEstimatedRowCount,
0: 					optimizerEstimatedCost,
0: 					closeCleanup);
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	 *	a referential action dependent table scan generator.
0: 	 *  @see ResultSetFactory#getTableScanResultSet
0: 	 *	@exception StandardException thrown on error
0: 	 */
0: 	public NoPutResultSet getRaDependentTableScanResultSet(
0: 									long conglomId,
0: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
0: 									int resultSetNumber,
0: 									GeneratedMethod startKeyGetter,
0: 									int startSearchOperator,
0: 									GeneratedMethod stopKeyGetter,
0: 									int stopSearchOperator,
0: 									boolean sameStartStopPosition,
0: 									Qualifier[][] qualifiers,
0: 									String tableName,
0: 									String indexName,
0: 									boolean isConstraint,
0: 									boolean forUpdate,
0: 									int colRefItem,
0: 									int indexColItem,
0: 									int lockMode,
0: 									boolean tableLocked,
0: 									int isolationLevel,
0: 									boolean oneRowScan,
0: 									double optimizerEstimatedRowCount,
0: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup,
0: 									String parentResultSetId,
0: 									long fkIndexConglomId,
0: 									int fkColArrayItem,
0: 									int rltItem)
0: 			throws StandardException
0: 	{
0:         StaticCompiledOpenConglomInfo scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
0: 						getSavedObject(scociItem));
0: 		return new DependentResultSet(
0: 								conglomId,
0: 								scoci,
0: 								activation,
0: 								resultRowAllocator,
0: 								resultSetNumber,
0: 								startKeyGetter,
0: 								startSearchOperator,
0: 								stopKeyGetter,
0: 								stopSearchOperator,
0: 								sameStartStopPosition,
0: 								qualifiers,
0: 								tableName,
0: 								indexName,
0: 								isConstraint,
0: 								forUpdate,
0: 								colRefItem,
0: 								lockMode,
0: 								tableLocked,
0: 								isolationLevel,
0: 								1,
0: 								oneRowScan,
0: 								optimizerEstimatedRowCount,
0: 								optimizerEstimatedCost,
0: 								closeCleanup,
0: 								parentResultSetId,
0: 								fkIndexConglomId,
0: 								fkColArrayItem,
0: 								rltItem);
0: 	}
0: 	
0: 	static private Authorizer getAuthorizer(Activation activation)
0: 	{
0: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
0: 		return lcc.getAuthorizer();
0: 	}
0: 
0: 
0:    /////////////////////////////////////////////////////////////////
0:    //
0:    //	PUBLIC MINIONS
0:    //
0:    /////////////////////////////////////////////////////////////////
0: 
0: }
============================================================================