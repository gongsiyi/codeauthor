1:47510ba: /*
1:ba50299: 
1:b0c495f:    Derby - Class org.apache.derby.impl.jdbc.TemporaryClob
1:47510ba: 
1:bb0c274:    Licensed to the Apache Software Foundation (ASF) under one
1:bb0c274:    or more contributor license agreements.  See the NOTICE file
1:bb0c274:    distributed with this work for additional information
1:bb0c274:    regarding copyright ownership.  The ASF licenses this file
1:bb0c274:    to you under the Apache License, Version 2.0 (the
1:bb0c274:    "License"); you may not use this file except in compliance
1:bb0c274:    with the License.  You may obtain a copy of the License at
1:47510ba: 
1:bb0c274:      http://www.apache.org/licenses/LICENSE-2.0
1:e5b15ce: 
1:bb0c274:    Unless required by applicable law or agreed to in writing,
1:bb0c274:    software distributed under the License is distributed on an
1:bb0c274:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:bb0c274:    KIND, either express or implied.  See the License for the
1:bb0c274:    specific language governing permissions and limitations
1:bb0c274:    under the License.
2:bb0c274: 
2:e1fc783:  */
1:e1fc783: package org.apache.derby.impl.jdbc;
1:bb0c274: 
1:e1fc783: import java.io.BufferedInputStream;
1:a78e683: import java.io.EOFException;
1:71dca8c: import java.io.FilterReader;
1:e1fc783: import java.io.IOException;
1:e1fc783: import java.io.InputStream;
1:e1fc783: import java.io.Reader;
1:e1fc783: import java.io.Writer;
1:e1fc783: import java.sql.SQLException;
1:2333262: import org.apache.derby.iapi.error.StandardException;
1:910b77f: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1:71dca8c: import org.apache.derby.iapi.types.TypeId;
1:a78e683: import org.apache.derby.iapi.util.UTF8Util;
1:bb0c274: 
1:a78e683: /**
1:a78e683:  * A Clob representation where the Clob is stored either in memory or on disk.
1:a78e683:  * <p>
1:a78e683:  * Character positions given as input to methods in this class are always
1:a78e683:  * 1-based. Byte positions are always 0-based.
1:a78e683:  */
1:b0c495f: final class TemporaryClob implements InternalClob {
1:bb0c274: 
1:a78e683:     /**
1:a78e683:      * Connection child assoicated with this Clob.
1:a78e683:      * <p>
1:a78e683:      * Currently only used for synchronization in *some* streams associated
1:a78e683:      * with the Clob. This suggests something is off wrt. synchronization.
1:a78e683:      */
1:e1fc783:     private ConnectionChild conChild;
1:a78e683:     /** Underlying structure holding this Clobs raw bytes. */
1:a78e683:     //@GuardedBy("this")
1:a78e683:     private final LOBStreamControl bytes;
1:a78e683:     /** Tells whether this Clob has been released or not. */
1:a78e683:     // GuardedBy("this")
1:a78e683:     private boolean released = false;
1:71dca8c:     /**
1:71dca8c:      * Cached character length of the Clob.
1:71dca8c:      * <p>
1:71dca8c:      * A value of {@code 0} is interpreted as unknown length, even though it is
1:71dca8c:      * a valid value. If the length is requested and the value is zero, an
1:71dca8c:      * attempt to obtain the length is made by draining the source.
1:71dca8c:      */
1:71dca8c:     private long cachedCharLength;
1:71dca8c:     /**
1:71dca8c:      * Shared internal reader, closed when the Clob is released.
1:71dca8c:      * This is a performance optimization, and the stream is shared between
1:71dca8c:      * "one time" operations, for instance {@code getSubString} calls. Often a
1:71dca8c:      * subset, or the whole, of the Clob is read subsequently and then this
1:71dca8c:      * optimization avoids repositioning costs (the store does not support
1:71dca8c:      * random access for LOBs).
1:71dca8c:      * <b>NOTE</b>: Do not publish this reader to the end-user.
1:71dca8c:      */
1:71dca8c:     private UTF8Reader internalReader;
1:71dca8c:     /** The internal reader wrapped so that it cannot be closed. */
1:71dca8c:     private FilterReader unclosableInternalReader;
1:a78e683: 
1:a78e683:     /** Simple one-entry cache for character-byte position. */
1:a78e683:     // @GuardedBy("this")
1:a78e683:     private final CharToBytePositionCache posCache =
1:a78e683:         new CharToBytePositionCache();
1:a78e683: 
1:a78e683:     /**
1:a78e683:      * Clones the content of another internal Clob.
1:ba50299:      *
1:a78e683:      * @param dbName name of the assoicated database
1:a78e683:      * @param conChild assoiated connection child
1:a78e683:      * @param clob the Clob whose content to clone
1:a78e683:      * @return A read-write Clob.
1:a78e683:      * @throws IOException if accessing the I/O resources fail (read or write)
1:a78e683:      * @throws SQLException if accessing underlying resources fail
1:a78e683:      */
1:a78e683:     static InternalClob cloneClobContent(String dbName,
1:a78e683:                                          ConnectionChild conChild,
1:a78e683:                                          InternalClob clob)
1:a78e683:             throws IOException, SQLException {
1:10e4538:         TemporaryClob newClob = new TemporaryClob(conChild);
1:a78e683:         newClob.copyClobContent(clob);
1:a78e683:         return newClob;
1:a78e683:     }
1:0ed8291: 
1:ba50299:     /**
1:ba50299:      * Clones the content of another internal Clob.
1:d2b4fdb:      *
1:ba50299:      * @param dbName name of the assoicated database
1:ba50299:      * @param conChild assoiated connection child
1:ba50299:      * @param clob the Clob whose content to clone
1:ba50299:      * @param length number of chars in new InternalClob
1:ba50299:      * @return A read-write Clob.
1:ba50299:      * @throws IOException if accessing the I/O resources fail (read or write)
1:ba50299:      * @throws SQLException if accessing underlying resources fail
1:ba50299:      */
1:ba50299:     static InternalClob cloneClobContent(String dbName,
1:ba50299:                                          ConnectionChild conChild,
1:ba50299:                                          InternalClob clob,
1:ba50299:                                          long length)
1:ba50299:             throws IOException, SQLException {
1:10e4538:         TemporaryClob newClob = new TemporaryClob(conChild);
1:ba50299:         newClob.copyClobContent(clob, length);
1:ba50299:         return newClob;
1:ba50299:     }
1:47510ba: 
2:e1fc783:     /**
1:b0c495f:      * Constructs a <code>TemporaryClob</code> object used to perform
1:e5b15ce:      * operations on a CLOB value.
1:e5b15ce:      * @param conChild connection object used to obtain synchronization object
1:b0c495f:      * 
1:a78e683:      * @throws NullPointerException if <code>conChild</code> is
1:a78e683:      *      <code>null</code>
1:e1fc783:      */
1:10e4538:     TemporaryClob (ConnectionChild conChild) {
1:a78e683:         if (conChild == null) {
1:a78e683:             throw new NullPointerException("conChild cannot be <null>");
1:a78e683:         }
1:e1fc783:         this.conChild = conChild;
1:10e4538:         this.bytes = new LOBStreamControl(conChild.getEmbedConnection());
1:a78e683:     }
1:a78e683: 
1:a78e683:     /**
1:a78e683:      * Releases this Clob by freeing assoicated resources.
1:b0c495f:      *
1:a78e683:      * @throws IOException if accessing underlying I/O resources fail
1:a78e683:      */
1:a78e683:     public synchronized void release()
1:a78e683:             throws IOException {
1:a78e683:         if (!this.released) {
1:a78e683:             this.released = true;
1:a78e683:             this.bytes.free();
1:71dca8c:             if (internalReader != null) {
1:71dca8c:                 internalReader.close();
1:71dca8c:                 internalReader = null;
1:71dca8c:                 unclosableInternalReader = null;
1:71dca8c:             }
1:a78e683:         }
1:a78e683:     }
1:a78e683: 
1:a78e683:     /**
1:a78e683:      * Returns a stream serving the raw bytes of this Clob.
1:a78e683:      * <p>
1:a78e683:      * The stream is managed by the underlying byte store, and can serve bytes
1:a78e683:      * both from memory and from a file on disk.
1:ba50299:      *
1:a78e683:      * @return A stream serving the raw bytes of the stream, initialized at
1:a78e683:      *      byte position <code>0</code>.
1:a78e683:      * @throws IOException if obtaining the stream fails
1:a78e683:      */
1:a78e683:     public synchronized InputStream getRawByteStream()
1:a78e683:             throws IOException {
1:a78e683:         checkIfValid();
1:a78e683:         return this.bytes.getInputStream(0L);
1:47510ba:     }
1:47510ba: 
1:e1fc783:     /**
1:b0c495f:      * Constructs a <code>TemporaryClob</code> object and
1:d2b4fdb:      * initializes with a initial String.
1:d2b4fdb:      * @param data initial value in String
1:d2b4fdb:      * @param conChild connection object used to obtain synchronization object
1:d2b4fdb:      */
1:10e4538:     TemporaryClob (String data, ConnectionChild conChild)
1:d349a1f:                           throws IOException, StandardException {
1:d2b4fdb:         if (conChild == null) {
1:d2b4fdb:             throw new NullPointerException("conChild cannot be <null>");
1:d2b4fdb:         }
1:d2b4fdb:         this.conChild = conChild;
1:10e4538:         bytes = new LOBStreamControl(conChild.getEmbedConnection(), getByteFromString (data));
1:9fccf84:         this.cachedCharLength = data.length();
1:d2b4fdb:     }
1:d2b4fdb:     /**
1:e5b15ce:      * Finds the corresponding byte position for the given UTF-8 character
1:e5b15ce:      * position, starting from the byte position <code>startPos</code>.
1:685a147:      * See comments in SQLChar.readExternal for more notes on
1:685a147:      * processing the UTF8 format.
1:ba50299:      *
1:e5b15ce:      * @param charPos character position
1:e5b15ce:      * @return Stream position in bytes for the given character position.
1:a78e683:      * @throws EOFException if the character position specified is greater than
1:a78e683:      *      the Clob length +1
1:a78e683:      * @throws IOException if accessing underlying I/O resources fail
1:e1fc783:      */
1:65e0386:     //@GuardedBy(this)
1:65e0386:     private long getBytePosition (final long charPos)
1:a78e683:             throws IOException {
1:a78e683:         long bytePos;
1:a78e683:         if (charPos == this.posCache.getCharPos()) {
1:a78e683:             // We already know the position.
1:a78e683:             bytePos = this.posCache.getBytePos();
1:a78e683:         } else {
1:a78e683:             long startingBytePosition = 0L; // Default to start at position 0.
1:0ed8291:             long charsToSkip = charPos -1; // Subtract one to get number to skip
1:a78e683:             if (charPos > this.posCache.getCharPos()) {
1:a78e683:                 // Exploit the last known character position.
1:a78e683:                 startingBytePosition = this.posCache.getBytePos();
1:a78e683:                 charsToSkip -= (this.posCache.getCharPos() -1);
11:e1fc783:             }
1:a78e683:             InputStream utf8Bytes =
1:a78e683:                 this.bytes.getInputStream(startingBytePosition);
1:a78e683:             bytePos = startingBytePosition +
1:a78e683:                 UTF8Util.skipFully(new BufferedInputStream(utf8Bytes),
1:a78e683:                                    charsToSkip);
1:a78e683:             this.posCache.updateCachedPos(charPos, bytePos);
1:e1fc783:         }
1:a78e683:         return bytePos;
1:e1fc783:     }
1:47510ba: 
1:e1fc783:     /**
1:d9319b8:      * Returns the update count of this Clob.
1:d9319b8:      *
1:d9319b8:      * @return Update count.
1:d9319b8:      */
1:d9319b8:     public long getUpdateCount() {
1:d9319b8:         return bytes.getUpdateCount();
1:d9319b8:     }
1:d9319b8: 
1:d9319b8:     /**
1:e5b15ce:      * Constructs and returns a <code>Writer</code> for the CLOB value.
1:a78e683:      *
1:e5b15ce:      * @param pos the initial position in bytes for the <code>Writer</code>
1:e5b15ce:      * @return A <code>Writer</code> to write to the CLOB value.
1:e5b15ce:      * @throws IOException
1:e5b15ce:      * @throws SQLException if the specified position is invalid
1:e1fc783:      */
1:0ed8291:     public synchronized Writer getWriter (long pos)
1:0ed8291:             throws IOException, SQLException {
1:a78e683:         checkIfValid();
1:a78e683:         // If pos is too large, an error will first be thrown when the writer
1:a78e683:         // is written to. Is this okay behavior, is does it break the spec?
1:a78e683:         if (pos < this.posCache.getCharPos()) {
2:a78e683:             this.posCache.reset();
1:a78e683:         }
1:a78e683:         return new ClobUtf8Writer (this, pos);
1:e1fc783:     }
1:47510ba: 
1:e1fc783:     /**
1:e5b15ce:      * Constructs and returns a <code>Reader</code>.
1:e4983ff:      * @param pos initial position of the returned <code>Reader</code> in
1:a78e683:      *      number of characters. Expected to be non-negative. The first
1:a78e683:      *      character is at position <code>0</code>.
1:e4983ff:      * @return A <code>Reader</code> with the underlying <code>CLOB</code>
1:e4983ff:      *      value as source.
1:e4983ff:      * @throws IOException
1:a78e683:      * @throws SQLException if the specified position is too big
1:e1fc783:      */
1:a78e683:     public synchronized Reader getReader (long pos)
1:a78e683:             throws IOException, SQLException {
2:a78e683:         checkIfValid();
1:a78e683:         if (pos < 1) {
1:a78e683:             throw new IllegalArgumentException(
1:a78e683:                 "Position must be positive: " + pos);
1:a78e683:         }
1:71dca8c:         // getCSD obtains a descriptor for the stream to allow the reader
1:71dca8c:         // to configure itself.
1:71dca8c:         Reader isr = new UTF8Reader(getCSD(), conChild,
1:71dca8c:                 conChild.getConnectionSynchronization());
1:47510ba: 
1:a78e683:         long leftToSkip = pos -1;
1:a78e683:         long skipped;
1:e1fc783:         while (leftToSkip > 0) {
1:a78e683:             skipped = isr.skip(leftToSkip);
1:a78e683:             // Since Reader.skip block until some characters are available,
1:a78e683:             // a return value of 0 must mean EOF.
1:a78e683:             if (skipped <= 0) {
1:a78e683:                 throw new EOFException("Reached end-of-stream prematurely");
1:a78e683:             }
1:a78e683:             leftToSkip -= skipped;
1:e1fc783:         }
1:e1fc783:         return isr;
1:47510ba:     }
1:47510ba: 
1:e1fc783:     /**
1:ab2037f:      * @see #getReader
1:ab2037f:      */
1:ab2037f:     public Reader getInternalReader(long characterPosition)
1:ab2037f:             throws IOException, SQLException {
1:71dca8c:         if (this.internalReader == null) {
1:71dca8c:             // getCSD obtains a descriptor for the stream to allow the reader
1:71dca8c:             // to configure itself.
1:71dca8c:             this.internalReader = new UTF8Reader(getCSD(), conChild,
1:71dca8c:                     conChild.getConnectionSynchronization());
1:71dca8c:             this.unclosableInternalReader =
1:71dca8c:                     new FilterReader(this.internalReader) {
1:71dca8c:                         public void close() {
1:71dca8c:                             // Do nothing.
1:71dca8c:                             // Stream will be closed when the Clob is released.
1:71dca8c:                         }
1:71dca8c:                     };
1:71dca8c:         }
1:71dca8c:         try {
1:71dca8c:             this.internalReader.reposition(characterPosition);
1:71dca8c:         } catch (StandardException se) {
1:71dca8c:             throw Util.generateCsSQLException(se);
1:71dca8c:         }
1:71dca8c:         return this.unclosableInternalReader;
1:ab2037f:     }
1:ab2037f: 
1:ab2037f:     /**
1:a78e683:      * Returns number of characters in the Clob.
1:ba50299:      *
1:a78e683:      * @return The length of the Clob in number of characters.
1:a78e683:      * @throws IOException if accessing the underlying I/O resources fail
1:e1fc783:      */
1:a78e683:     public synchronized long getCharLength() throws IOException {
1:a78e683:         checkIfValid();
1:71dca8c:         if (cachedCharLength == 0) {
1:71dca8c:             cachedCharLength = UTF8Util.skipUntilEOF(
1:71dca8c:                     new BufferedInputStream(getRawByteStream()));
1:71dca8c:         }
1:71dca8c:         return cachedCharLength;
1:e1fc783:     }
1:0ed8291: 
1:ba50299:     /**
1:dac5aed:      * Returns the cached character count for the Clob, if any.
1:dac5aed:      *
1:dac5aed:      * @return The number of characters in the Clob, or {@code -1} if unknown.
1:dac5aed:      */
1:dac5aed:     public synchronized long getCharLengthIfKnown() {
1:dac5aed:         checkIfValid();
1:dac5aed:         // Treat a cached value of zero as a special case.
1:dac5aed:         return (cachedCharLength == 0 ? -1 : cachedCharLength);
1:dac5aed:     }
1:dac5aed: 
1:dac5aed:     /**
1:e4983ff:      * Returns the size of the Clob in bytes.
1:a78e683:      *
1:e4983ff:      * @return Number of bytes in the <code>CLOB</code> value.
1:a78e683:      * @throws IOException if accessing the underlying I/O resources fail
1:e1fc783:      */
1:a78e683:     public synchronized long getByteLength () throws IOException {
1:a78e683:         checkIfValid();
1:a78e683:         return this.bytes.getLength();
1:e1fc783:     }
1:ba50299: 
1:e1fc783:     /**
1:a78e683:      * Inserts a string at the given position.
1:a78e683:      *
1:a78e683:      * @param str the string to insert
1:a78e683:      * @param insertionPoint the character position to insert the string at
1:a78e683:      * @return Number of characters inserted.
1:a78e683:      * @throws EOFException if the position is larger than the Clob length +1
1:a78e683:      * @throws IOException if accessing the underlying I/O resources fail
1:a78e683:      * @throws SQLException if accessing the underlying resources fail
1:e1fc783:      */
1:a78e683:     public synchronized long insertString (String str, long insertionPoint)
1:a78e683:                  throws IOException, SQLException {
1:a78e683:         checkIfValid();
1:a78e683:         if (insertionPoint < 1) {
1:a78e683:             throw new IllegalArgumentException(
1:a78e683:                 "Position must be positive: " + insertionPoint);
1:e1fc783:         }
1:71dca8c:         long prevLength = cachedCharLength;
1:71dca8c:         updateInternalState(insertionPoint);
1:a78e683:         long byteInsertionPoint = getBytePosition(insertionPoint);
1:a78e683:         long curByteLength = this.bytes.getLength();
1:a78e683:         byte[] newBytes = getByteFromString(str);
1:a78e683:         // See if we are appending or replacing bytes.
1:a78e683:         if (byteInsertionPoint == curByteLength) {
1:a78e683:             try {
1:a78e683:                 this.bytes.write(newBytes, 0, newBytes.length,
1:a78e683:                     byteInsertionPoint);
1:a78e683:             } catch (StandardException se) {
1:a78e683:                 throw Util.generateCsSQLException(se);
1:a78e683:             }
1:a78e683:         } else {
1:a78e683:             // Calculate end position of the byte block to replace.
1:a78e683:             // Either we only replace bytes, or we replace and append bytes.
1:a78e683:             long endPos;
1:a78e683:             try {
1:a78e683:                 endPos = getBytePosition(insertionPoint + str.length());
1:a78e683:                 // Must reset the position cache here, as the last obtained
1:a78e683:                 // one may be invalid after we replace the bytes (because of
1:a78e683:                 // the variable number of bytes per char).
1:a78e683:                 this.posCache.updateCachedPos(
1:a78e683:                     insertionPoint, byteInsertionPoint);
1:a78e683:             } catch (EOFException eofe) {
1:a78e683:                 endPos = curByteLength; // We replace and append.
1:a78e683:             }
1:a78e683:             try {
1:a78e683:                 this.bytes.replaceBytes(newBytes, byteInsertionPoint, endPos);
1:a78e683:             } catch (StandardException se) {
1:a78e683:                 throw Util.generateCsSQLException(se);
1:a78e683:             }
1:71dca8c:             // Update the length if we know the previous length.
1:71dca8c:             if (prevLength != 0) {
1:71dca8c:                 long newLength = (insertionPoint -1) + str.length();
1:71dca8c:                 if (newLength > prevLength) {
1:71dca8c:                     cachedCharLength = newLength; // The Clob grew.
1:71dca8c:                 } else {
1:71dca8c:                     // We only wrote over existing characters, length unchanged.
1:71dca8c:                     cachedCharLength = prevLength;
1:71dca8c:                 }
1:71dca8c:             }
1:a78e683:         }
2:e1fc783:         return str.length();
1:a78e683:     }
1:47510ba: 
1:e1fc783:     /**
1:d9319b8:      * Tells if this Clob has been released.
1:d9319b8:      *
1:d9319b8:      * @return {@code true} if released, {@code false} if not.
1:d9319b8:      */
1:71dca8c:     public synchronized boolean isReleased() {
1:d9319b8:         return released;
1:d9319b8:     }
1:d9319b8: 
1:d9319b8:     /**
1:a78e683:      * Tells if this Clob is intended to be writable.
1:a78e683:      *
1:a78e683:      * @return <code>true</code>
1:a78e683:      */
1:a78e683:     public boolean isWritable() {
1:a78e683:         return true;
1:a78e683:     }
1:a78e683: 
1:a78e683:     /**
1:a78e683:      * Truncate the Clob to the specifiec size.
1:0ed8291:      *
1:ba50299:      * @param newCharLength the new length, in characters, of the Clob
1:a78e683:      * @throws IOException if accessing the underlying I/O resources fails
1:a78e683:      */
1:ba50299:     public synchronized void truncate(long newCharLength)
1:a78e683:             throws IOException, SQLException {
1:a78e683:         checkIfValid();
1:a78e683:         try {
1:0ed8291:             // Get the length in bytes.
1:ba50299:             long byteLength = UTF8Util.skipFully (
1:0ed8291:                     new BufferedInputStream(getRawByteStream()), newCharLength);
1:ba50299:             this.bytes.truncate(byteLength);
1:71dca8c:             // Reset the internal state, and then update the length.
1:71dca8c:             updateInternalState(newCharLength);
1:71dca8c:             cachedCharLength = newCharLength;
1:a78e683:         } catch (StandardException se) {
1:a78e683:             throw Util.generateCsSQLException(se);
1:a78e683:         }
1:a78e683:     }
1:a78e683: 
1:a78e683:     /**
1:a78e683:      * Converts a string into the modified UTF-8 byte encoding.
1:a78e683:      *
1:a78e683:      * @param str string to represent with modified UTF-8 encoding
1:a78e683:      * @return Byte array representing the string in modified UTF-8 encoding.
1:e1fc783:      */
1:e1fc783:     private byte[] getByteFromString (String str) {
1:e1fc783:         //create a buffer with max size possible
1:e1fc783:         byte [] buffer = new byte [3 * str.length()];
1:e1fc783:         int len = 0;
1:e1fc783:         //start decoding
1:e1fc783:         for (int i = 0; i < str.length(); i++) {
1:e1fc783:             int c = str.charAt (i);
2:e1fc783:             if ((c >= 0x0001) && (c <= 0x007F)) {
1:e1fc783:                 buffer[len++] = (byte) c;
1:e1fc783:             }
2:e1fc783:             else if (c > 0x07FF) {
1:e1fc783:                 buffer[len++] = (byte) (0xE0 | ((c >> 12) & 0x0F));
1:e1fc783:                 buffer[len++] = (byte) (0x80 | ((c >>  6) & 0x3F));
1:e1fc783:                 buffer[len++] = (byte) (0x80 | ((c >>  0) & 0x3F));
1:e1fc783:             }
2:e1fc783:             else {
1:e1fc783:                 buffer[len++] = (byte) (0xC0 | ((c >>  6) & 0x1F));
1:e1fc783:                 buffer[len++] = (byte) (0x80 | ((c >>  0) & 0x3F));
1:e1fc783:             }
1:e1fc783:         }
1:e1fc783:         byte [] buff = new byte [len];
1:e1fc783:         System.arraycopy (buffer, 0, buff, 0, len);
1:e1fc783:         return buff;
1:a78e683:     }
1:a78e683: 
1:a78e683:     /**
1:ba50299:      * Copies the content of another Clob into this one.
1:0ed8291:      *
1:ba50299:      * @param clob the Clob to copy from
1:a78e683:      * @throws IOException if accessing I/O resources fail (both read and write)
1:a78e683:      * @throws SQLException if accessing underlying resources fail
1:a78e683:      */
1:a78e683:     private void copyClobContent(InternalClob clob)
1:a78e683:             throws IOException, SQLException {
1:a78e683:         try {
1:bde5241:             long knownLength = clob.getCharLengthIfKnown();
1:bde5241:             if (knownLength == -1) {
1:bde5241:                 // Decode UTF-8 data and copy until EOF, obtain char length.
1:bde5241:                 this.cachedCharLength = this.bytes.copyUtf8Data(
1:bde5241:                         clob.getRawByteStream(), Long.MAX_VALUE);
1:bde5241:             } else {
1:bde5241:                 // We already know the character length, and can copy raw bytes
1:bde5241:                 // without decoding the UTF-8 data.
1:bde5241:                 // Specify LONG.MAX_VALUE to copy data until EOF.
1:bde5241:                 this.cachedCharLength = knownLength;
1:bde5241:                 this.bytes.copyData(clob.getRawByteStream(), Long.MAX_VALUE);
1:bde5241:             }
1:a78e683:         } catch (StandardException se) {
1:a78e683:             throw Util.generateCsSQLException(se);
1:a78e683:         }
1:a78e683:     }
1:a78e683: 
1:a78e683:     /**
1:a78e683:      * Copies the content of another Clob into this one.
1:a78e683:      *
1:a78e683:      * @param clob the Clob to copy from
1:ba50299:      * @param charLength number of chars to copy
1:9fccf84:      * @throws EOFException if the length of the stream is shorter than the
1:9fccf84:      *      specified length
1:ba50299:      * @throws IOException if accessing I/O resources fail (both read and write)
1:ba50299:      * @throws SQLException if accessing underlying resources fail
1:ba50299:      */
1:ba50299:     private void copyClobContent(InternalClob clob, long charLength)
1:ba50299:             throws IOException, SQLException {
1:ba50299:         try {
1:bde5241:             long knownLength = clob.getCharLengthIfKnown();
1:bde5241:             if (knownLength > charLength || knownLength == -1) {
1:bde5241:                 // Decode and copy the requested number of chars.
1:bde5241:                 this.cachedCharLength = this.bytes.copyUtf8Data(
1:bde5241:                     clob.getRawByteStream(), charLength);
1:bde5241:             } else if (knownLength == charLength) {
1:bde5241:                 this.cachedCharLength = knownLength;
1:bde5241:                 // Copy raw bytes until EOF.
1:bde5241:                 // Special case optimization, avoids UTF-8 decoding.
1:bde5241:                 this.bytes.copyData(clob.getRawByteStream(), Long.MAX_VALUE);
1:bde5241:             } else {
1:bde5241:                 // The known length must be smaller than the requested length.
1:bde5241:                 throw new EOFException();
1:bde5241:             }
1:ba50299:         } catch (StandardException se) {
1:ba50299:             throw Util.generateCsSQLException(se);
1:0ed8291:         }
1:ba50299:     }
1:47510ba: 
1:e1fc783:     /**
1:a78e683:      * Makes sure the Clob has not been released.
1:a78e683:      * <p>
1:a78e683:      * All operations are invalid on a released Clob.
1:a78e683:      *
1:a78e683:      * @throws IllegalStateException if the Clob has been released
1:a78e683:      */
1:a78e683:     private final void checkIfValid() {
1:a78e683:         if (this.released) {
1:a78e683:             throw new IllegalStateException(
1:a78e683:                 "The Clob has been released and is not valid");
1:ba50299:         }
1:a78e683:     }
1:a78e683: 
1:a78e683:     /**
1:71dca8c:      * Updates the internal state after a modification has been performed on
1:71dca8c:      * the Clob content.
1:71dca8c:      * <p>
1:71dca8c:      * Currently the state update consists of dicarding the internal reader to
1:71dca8c:      * stop it from delivering stale data, to reset the byte/char position
1:71dca8c:      * cache if necessary, and to reset the cached length.
1:71dca8c:      *
1:71dca8c:      * @param charChangePosition the position where the Clob change started
1:71dca8c:      */
1:71dca8c:     private final void updateInternalState(long charChangePosition) {
1:71dca8c:         // Discard the internal reader, don't want to deliver stale data.
1:71dca8c:         if (internalReader != null) {
1:71dca8c:             internalReader.close();
1:71dca8c:             internalReader = null;
1:71dca8c:             unclosableInternalReader = null;
1:71dca8c:         }
1:71dca8c:         // Reset the cache if last cached position has been cut away.
1:71dca8c:         if (charChangePosition < posCache.getCharPos()) {
1:71dca8c:             posCache.reset();
1:71dca8c:         }
1:71dca8c:         // Reset the cached length.
1:71dca8c:         cachedCharLength = 0;
1:71dca8c:     }
1:71dca8c: 
1:71dca8c:     /**
1:71dca8c:      * Returns a character stream descriptor for the stream.
1:71dca8c:      * <p>
1:71dca8c:      * All streams from the underlying source ({@code LOBStreamControl}) are
1:71dca8c:      * position aware and can be moved to a specific byte position cheaply.
1:71dca8c:      * The maximum length is not really needed, nor known, at the moment, so
1:71dca8c:      * the maximum allowed Clob length in Derby is used.
1:71dca8c:      *
1:71dca8c:      * @return A character stream descriptor.
1:71dca8c:      * @throws IOException if obtaining the length of the stream fails
1:71dca8c:      */
1:71dca8c:     private final CharacterStreamDescriptor getCSD()
1:71dca8c:             throws IOException {
1:71dca8c:         return new CharacterStreamDescriptor.Builder().
1:71dca8c:                     // Static values.
1:71dca8c:                     positionAware(true).
1:71dca8c:                     maxCharLength(TypeId.CLOB_MAXWIDTH).
1:71dca8c:                     // Values depending on content and/or state.
1:71dca8c:                     stream(bytes.getInputStream(0)).
1:71dca8c:                     bufferable(bytes.getLength() > 4096).
1:71dca8c:                     byteLength(bytes.getLength()).
1:71dca8c:                     charLength(cachedCharLength). // 0 means unknown
1:71dca8c:                     build();
1:71dca8c:     }
1:71dca8c: 
1:71dca8c:     /**
1:a78e683:      * A simple class to hold the byte position for a character position.
1:a78e683:      * <p>
1:a78e683:      * The implementation is very simple and is basically intended to speed up
1:a78e683:      * writing a sequence of consequtive characters one character at a time.
1:a78e683:      * Even though this should be avoided if possible, the penalty of updating a
1:a78e683:      * large Clob this way and finding the correct byte position by navigating
1:a78e683:      * from the start of the byte stream each time is so severe that a simple
1:a78e683:      * caching mechanism should be in place. Note that for other encodings than
1:a78e683:      * UTF-8, this might not be a problem if the mapping between character
1:a78e683:      * position and byte position is one-to-one.
1:a78e683:      * <p>
1:a78e683:      * Note that to ensure consistency between character and byte positions,
1:a78e683:      * access to this class must be synchronized externally to avoid caller 1
1:a78e683:      * getting the character position, then caller 2 updates the cached values
1:a78e683:      * and then caller 1 gets the updated byte position.
1:a78e683:      */
1:a78e683:     //@NotThreadSafe
1:a78e683:     private static class CharToBytePositionCache {
1:a78e683:         private long charPos = 1L;
1:a78e683:         private long bytePos = 0L;
1:a78e683: 
1:a78e683:         CharToBytePositionCache() {}
1:a78e683: 
1:a78e683:         /**
1:a78e683:          * Returns the last cached byte position.
1:a78e683:          *
1:a78e683:          * @return The byte position for the last cached character position.
1:a78e683:          */
1:a78e683:         long getBytePos() {
1:a78e683:             return this.bytePos;
1:a78e683:         }
1:a78e683: 
1:a78e683:         /**
1:a78e683:          * Returns the last cached character position.
1:a78e683:          *
1:a78e683:          * @return The last cached character position.
1:a78e683:          */
1:a78e683:         long getCharPos() {
1:a78e683:             return this.charPos;
1:a78e683:         }
1:a78e683: 
1:a78e683:         /**
1:a78e683:          * Updates the position cache.
5:a78e683:          *
1:a78e683:          * @param charPos the character position to cache the byte position for
1:a78e683:          * @param bytePos byte position for the specified character position
1:a78e683:          */
1:a78e683:         void updateCachedPos(long charPos, long bytePos) {
1:a78e683:             if (charPos -1 > bytePos) {
1:a78e683:                 throw new IllegalArgumentException("(charPos -1) cannot be " +
1:a78e683:                     "greater than bytePos; " + (charPos -1) + " > " + bytePos);
1:a78e683:             }
1:a78e683:             this.charPos = charPos;
1:a78e683:             this.bytePos = bytePos;
1:a78e683:         }
1:a78e683: 
1:a78e683:         /**
1:a78e683:          * Resets the position cache.
1:a78e683:          */
1:a78e683:         void reset() {
1:a78e683:             this.charPos = 1L;
1:a78e683:             this.bytePos = 0L;
1:a78e683:         }
1:a78e683:     } // End internal class CharToBytePositionCache
1:47510ba: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d349a1f
/////////////////////////////////////////////////////////////////////////
1:                           throws IOException, StandardException {
commit:d2b4fdb
/////////////////////////////////////////////////////////////////////////
0:      * Constructs a <code>ClobStreamControl</code> object and
1:      * initializes with a initial String.
1:      *
0:      * @param dbName name of the database the CLOB value belongs to
1:      * @param data initial value in String
1:      * @param conChild connection object used to obtain synchronization object
1:      */
0:     ClobStreamControl (String dbName, String data, ConnectionChild conChild)
0:                           throws IOException, SQLException, StandardException {
1:         if (conChild == null) {
1:             throw new NullPointerException("conChild cannot be <null>");
1:         }
1:         this.conChild = conChild;
0:         bytes = new LOBStreamControl(dbName, getByteFromString (data));
1:     }
1:     /**
commit:2333262
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
/////////////////////////////////////////////////////////////////////////
0:      * @throws StandardException
0:      * @throws SQLException
0:                  throws IOException, SQLException, StandardException {
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:bde5241
/////////////////////////////////////////////////////////////////////////
1:             long knownLength = clob.getCharLengthIfKnown();
1:             if (knownLength == -1) {
1:                 // Decode UTF-8 data and copy until EOF, obtain char length.
1:                 this.cachedCharLength = this.bytes.copyUtf8Data(
1:                         clob.getRawByteStream(), Long.MAX_VALUE);
1:             } else {
1:                 // We already know the character length, and can copy raw bytes
1:                 // without decoding the UTF-8 data.
1:                 // Specify LONG.MAX_VALUE to copy data until EOF.
1:                 this.cachedCharLength = knownLength;
1:                 this.bytes.copyData(clob.getRawByteStream(), Long.MAX_VALUE);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             long knownLength = clob.getCharLengthIfKnown();
1:             if (knownLength > charLength || knownLength == -1) {
1:                 // Decode and copy the requested number of chars.
1:                 this.cachedCharLength = this.bytes.copyUtf8Data(
1:                     clob.getRawByteStream(), charLength);
1:             } else if (knownLength == charLength) {
1:                 this.cachedCharLength = knownLength;
1:                 // Copy raw bytes until EOF.
1:                 // Special case optimization, avoids UTF-8 decoding.
1:                 this.bytes.copyData(clob.getRawByteStream(), Long.MAX_VALUE);
1:             } else {
1:                 // The known length must be smaller than the requested length.
1:                 throw new EOFException();
1:             }
commit:dac5aed
/////////////////////////////////////////////////////////////////////////
1:      * Returns the cached character count for the Clob, if any.
1:      *
1:      * @return The number of characters in the Clob, or {@code -1} if unknown.
1:      */
1:     public synchronized long getCharLengthIfKnown() {
1:         checkIfValid();
1:         // Treat a cached value of zero as a special case.
1:         return (cachedCharLength == 0 ? -1 : cachedCharLength);
1:     }
1: 
1:     /**
commit:9fccf84
/////////////////////////////////////////////////////////////////////////
1:         this.cachedCharLength = data.length();
/////////////////////////////////////////////////////////////////////////
1:      * @throws EOFException if the length of the stream is shorter than the
1:      *      specified length
/////////////////////////////////////////////////////////////////////////
0:             this.cachedCharLength = charLength;
commit:71dca8c
/////////////////////////////////////////////////////////////////////////
1: import java.io.FilterReader;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Cached character length of the Clob.
1:      * <p>
1:      * A value of {@code 0} is interpreted as unknown length, even though it is
1:      * a valid value. If the length is requested and the value is zero, an
1:      * attempt to obtain the length is made by draining the source.
1:      */
1:     private long cachedCharLength;
1:     /**
1:      * Shared internal reader, closed when the Clob is released.
1:      * This is a performance optimization, and the stream is shared between
1:      * "one time" operations, for instance {@code getSubString} calls. Often a
1:      * subset, or the whole, of the Clob is read subsequently and then this
1:      * optimization avoids repositioning costs (the store does not support
1:      * random access for LOBs).
1:      * <b>NOTE</b>: Do not publish this reader to the end-user.
1:      */
1:     private UTF8Reader internalReader;
1:     /** The internal reader wrapped so that it cannot be closed. */
1:     private FilterReader unclosableInternalReader;
/////////////////////////////////////////////////////////////////////////
1:             if (internalReader != null) {
1:                 internalReader.close();
1:                 internalReader = null;
1:                 unclosableInternalReader = null;
1:             }
/////////////////////////////////////////////////////////////////////////
1:         // getCSD obtains a descriptor for the stream to allow the reader
1:         // to configure itself.
1:         Reader isr = new UTF8Reader(getCSD(), conChild,
1:                 conChild.getConnectionSynchronization());
/////////////////////////////////////////////////////////////////////////
1:         if (this.internalReader == null) {
1:             // getCSD obtains a descriptor for the stream to allow the reader
1:             // to configure itself.
1:             this.internalReader = new UTF8Reader(getCSD(), conChild,
1:                     conChild.getConnectionSynchronization());
1:             this.unclosableInternalReader =
1:                     new FilterReader(this.internalReader) {
1:                         public void close() {
1:                             // Do nothing.
1:                             // Stream will be closed when the Clob is released.
1:                         }
1:                     };
1:         }
1:         try {
1:             this.internalReader.reposition(characterPosition);
1:         } catch (StandardException se) {
1:             throw Util.generateCsSQLException(se);
1:         }
1:         return this.unclosableInternalReader;
/////////////////////////////////////////////////////////////////////////
1:         if (cachedCharLength == 0) {
1:             cachedCharLength = UTF8Util.skipUntilEOF(
1:                     new BufferedInputStream(getRawByteStream()));
1:         }
1:         return cachedCharLength;
/////////////////////////////////////////////////////////////////////////
1:         long prevLength = cachedCharLength;
1:         updateInternalState(insertionPoint);
/////////////////////////////////////////////////////////////////////////
1:             // Update the length if we know the previous length.
1:             if (prevLength != 0) {
1:                 long newLength = (insertionPoint -1) + str.length();
1:                 if (newLength > prevLength) {
1:                     cachedCharLength = newLength; // The Clob grew.
1:                 } else {
1:                     // We only wrote over existing characters, length unchanged.
1:                     cachedCharLength = prevLength;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean isReleased() {
/////////////////////////////////////////////////////////////////////////
1:             // Reset the internal state, and then update the length.
1:             updateInternalState(newCharLength);
1:             cachedCharLength = newCharLength;
/////////////////////////////////////////////////////////////////////////
1:      * Updates the internal state after a modification has been performed on
1:      * the Clob content.
1:      * <p>
1:      * Currently the state update consists of dicarding the internal reader to
1:      * stop it from delivering stale data, to reset the byte/char position
1:      * cache if necessary, and to reset the cached length.
1:      *
1:      * @param charChangePosition the position where the Clob change started
1:      */
1:     private final void updateInternalState(long charChangePosition) {
1:         // Discard the internal reader, don't want to deliver stale data.
1:         if (internalReader != null) {
1:             internalReader.close();
1:             internalReader = null;
1:             unclosableInternalReader = null;
1:         }
1:         // Reset the cache if last cached position has been cut away.
1:         if (charChangePosition < posCache.getCharPos()) {
1:             posCache.reset();
1:         }
1:         // Reset the cached length.
1:         cachedCharLength = 0;
1:     }
1: 
1:     /**
1:      * Returns a character stream descriptor for the stream.
1:      * <p>
1:      * All streams from the underlying source ({@code LOBStreamControl}) are
1:      * position aware and can be moved to a specific byte position cheaply.
1:      * The maximum length is not really needed, nor known, at the moment, so
1:      * the maximum allowed Clob length in Derby is used.
1:      *
1:      * @return A character stream descriptor.
1:      * @throws IOException if obtaining the length of the stream fails
1:      */
1:     private final CharacterStreamDescriptor getCSD()
1:             throws IOException {
1:         return new CharacterStreamDescriptor.Builder().
1:                     // Static values.
1:                     positionAware(true).
1:                     maxCharLength(TypeId.CLOB_MAXWIDTH).
1:                     // Values depending on content and/or state.
1:                     stream(bytes.getInputStream(0)).
1:                     bufferable(bytes.getLength() > 4096).
1:                     byteLength(bytes.getLength()).
1:                     charLength(cachedCharLength). // 0 means unknown
1:                     build();
1:     }
1: 
1:     /**
commit:910b77f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
/////////////////////////////////////////////////////////////////////////
0:         // Describe the stream to allow the reader to configure itself.
0:         CharacterStreamDescriptor csd = new CharacterStreamDescriptor.Builder().
0:                 stream(this.bytes.getInputStream(0)).
0:                 positionAware(true).
0:                 bufferable(this.bytes.getLength() > 4096). // Cache if on disk.
0:                 byteLength(this.bytes.getLength()).
0:                 build();
0:         Reader isr = new UTF8Reader(
0:                 csd, conChild, conChild.getConnectionSynchronization());
commit:d9319b8
/////////////////////////////////////////////////////////////////////////
1:      * Returns the update count of this Clob.
1:      *
1:      * @return Update count.
1:      */
1:     public long getUpdateCount() {
1:         return bytes.getUpdateCount();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Tells if this Clob has been released.
1:      *
1:      * @return {@code true} if released, {@code false} if not.
1:      */
0:     public boolean isReleased() {
1:         return released;
1:     }
1: 
1:     /**
commit:ab2037f
/////////////////////////////////////////////////////////////////////////
1:      * @see #getReader
1:      */
1:     public Reader getInternalReader(long characterPosition)
1:             throws IOException, SQLException {
0:         // TODO: See if we can optimize for a shared internal reader.
0:         return getReader(characterPosition);
1:     }
1: 
1:     /**
commit:e8fd686
/////////////////////////////////////////////////////////////////////////
0:             // Specify LONG.MAX_VALUE to copy data until EOF.
0:             this.bytes.copyData(clob.getRawByteStream(), Long.MAX_VALUE);
commit:65e0386
/////////////////////////////////////////////////////////////////////////
1:     //@GuardedBy(this)
1:     private long getBytePosition (final long charPos)
commit:b0c495f
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.TemporaryClob
/////////////////////////////////////////////////////////////////////////
1: final class TemporaryClob implements InternalClob {
/////////////////////////////////////////////////////////////////////////
0:         TemporaryClob newClob = new TemporaryClob(dbName, conChild);
/////////////////////////////////////////////////////////////////////////
0:         TemporaryClob newClob = new TemporaryClob(dbName, conChild);
1:      * Constructs a <code>TemporaryClob</code> object used to perform
1:      * 
0:     TemporaryClob (String dbName, ConnectionChild conChild) {
/////////////////////////////////////////////////////////////////////////
1:      * Constructs a <code>TemporaryClob</code> object and
1:      * 
0:     TemporaryClob (String dbName, String data, ConnectionChild conChild)
commit:fcdce55
/////////////////////////////////////////////////////////////////////////
0:         Reader isr = new ClobUpdatableReader (
commit:80424bf
/////////////////////////////////////////////////////////////////////////
0:             long byteLength = clob.getByteLength();
0:             this.bytes.copyData(clob.getRawByteStream(), byteLength);
commit:0ed8291
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             long charsToSkip = charPos -1; // Subtract one to get number to skip
/////////////////////////////////////////////////////////////////////////
1:     public synchronized Writer getWriter (long pos)
1:             throws IOException, SQLException {
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:             // Get the length in bytes.
1:                     new BufferedInputStream(getRawByteStream()), newCharLength);
/////////////////////////////////////////////////////////////////////////
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
0:             long byteLength = UTF8Util.skipFully(
0:                     new BufferedInputStream(clob.getRawByteStream()),
0:                     charLength);
0:                     new BufferedInputStream(clob.getRawByteStream()),
0:                     byteLength);
1:     }
commit:ba50299
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Clones the content of another internal Clob.
1:      *
1:      * @param dbName name of the assoicated database
1:      * @param conChild assoiated connection child
1:      * @param clob the Clob whose content to clone
1:      * @param length number of chars in new InternalClob
1:      * @return A read-write Clob.
1:      * @throws IOException if accessing the I/O resources fail (read or write)
1:      * @throws SQLException if accessing underlying resources fail
1:      */
1:     static InternalClob cloneClobContent(String dbName,
1:                                          ConnectionChild conChild,
1:                                          InternalClob clob,
1:                                          long length)
1:             throws IOException, SQLException {
0:         ClobStreamControl newClob = new ClobStreamControl(dbName, conChild);
1:         newClob.copyClobContent(clob, length);
1:         return newClob;
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * 
1:      * @param newCharLength the new length, in characters, of the Clob
1:     public synchronized void truncate(long newCharLength)
0:             //get the byteLength in bytes
1:             long byteLength = UTF8Util.skipFully (
0:                     new BufferedInputStream (getRawByteStream()), newCharLength);
1:             this.bytes.truncate(byteLength);
0:             if (newCharLength <= this.posCache.getCharPos()) {
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Copies the content of another Clob into this one.
1:      * 
1:      * @param clob the Clob to copy from
1:      * @param charLength number of chars to copy
1:      * @throws IOException if accessing I/O resources fail (both read and write)
1:      * @throws SQLException if accessing underlying resources fail
1:      */
1:     private void copyClobContent(InternalClob clob, long charLength)
1:             throws IOException, SQLException {
1:         try {
0:             long byteLength = UTF8Util.skipFully (
0:                     new BufferedInputStream(clob.getRawByteStream()), charLength);
0:             this.bytes.copyData(
0:                     new BufferedInputStream(clob.getRawByteStream()), byteLength);
1:         } catch (StandardException se) {
1:             throw Util.generateCsSQLException(se);
1:         }
1:     }    
commit:a78e683
/////////////////////////////////////////////////////////////////////////
1: import java.io.EOFException;
1: import org.apache.derby.iapi.util.UTF8Util;
1: /**
1:  * A Clob representation where the Clob is stored either in memory or on disk.
1:  * <p>
1:  * Character positions given as input to methods in this class are always
1:  * 1-based. Byte positions are always 0-based.
1:  */
0: final class ClobStreamControl implements InternalClob {
1:     /**
1:      * Connection child assoicated with this Clob.
1:      * <p>
1:      * Currently only used for synchronization in *some* streams associated
1:      * with the Clob. This suggests something is off wrt. synchronization.
1:      */
1:     /** Underlying structure holding this Clobs raw bytes. */
1:     //@GuardedBy("this")
1:     private final LOBStreamControl bytes;
1:     /** Tells whether this Clob has been released or not. */
1:     // GuardedBy("this")
1:     private boolean released = false;
1: 
1:     /** Simple one-entry cache for character-byte position. */
1:     // @GuardedBy("this")
1:     private final CharToBytePositionCache posCache =
1:         new CharToBytePositionCache();
1: 
1:     /**
1:      * Clones the content of another internal Clob.
1:      *
1:      * @param dbName name of the assoicated database
1:      * @param conChild assoiated connection child
1:      * @param clob the Clob whose content to clone
1:      * @return A read-write Clob.
1:      * @throws IOException if accessing the I/O resources fail (read or write)
1:      * @throws SQLException if accessing underlying resources fail
1:      */
1:     static InternalClob cloneClobContent(String dbName,
1:                                          ConnectionChild conChild,
1:                                          InternalClob clob)
1:             throws IOException, SQLException {
0:         ClobStreamControl newClob = new ClobStreamControl(dbName, conChild);
1:         newClob.copyClobContent(clob);
1:         return newClob;
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @throws NullPointerException if <code>conChild</code> is
1:      *      <code>null</code>
1:         if (conChild == null) {
1:             throw new NullPointerException("conChild cannot be <null>");
1:         }
0:         this.bytes = new LOBStreamControl(dbName);
1:     }
1: 
1:     /**
1:      * Releases this Clob by freeing assoicated resources.
1:      *
1:      * @throws IOException if accessing underlying I/O resources fail
1:      */
1:     public synchronized void release()
1:             throws IOException {
1:         if (!this.released) {
1:             this.released = true;
1:             this.bytes.free();
1:         }
1:     }
1: 
1:     /**
1:      * Returns a stream serving the raw bytes of this Clob.
1:      * <p>
1:      * The stream is managed by the underlying byte store, and can serve bytes
1:      * both from memory and from a file on disk.
1:      *
1:      * @return A stream serving the raw bytes of the stream, initialized at
1:      *      byte position <code>0</code>.
1:      * @throws IOException if obtaining the stream fails
1:      */
1:     public synchronized InputStream getRawByteStream()
1:             throws IOException {
1:         checkIfValid();
1:         return this.bytes.getInputStream(0L);
/////////////////////////////////////////////////////////////////////////
1:      * @throws EOFException if the character position specified is greater than
1:      *      the Clob length +1
1:      * @throws IOException if accessing underlying I/O resources fail
0:     public synchronized long getBytePosition (final long charPos)
1:             throws IOException {
1:         checkIfValid();
1:         long bytePos;
1:         if (charPos == this.posCache.getCharPos()) {
1:             // We already know the position.
1:             bytePos = this.posCache.getBytePos();
1:         } else {
1:             long startingBytePosition = 0L; // Default to start at position 0.
0:             long charsToSkip = charPos -1; // Subtract one to get number to skip.
1:             if (charPos > this.posCache.getCharPos()) {
1:                 // Exploit the last known character position.
1:                 startingBytePosition = this.posCache.getBytePos();
1:                 charsToSkip -= (this.posCache.getCharPos() -1);
1:             InputStream utf8Bytes =
1:                 this.bytes.getInputStream(startingBytePosition);
1:             bytePos = startingBytePosition +
1:                 UTF8Util.skipFully(new BufferedInputStream(utf8Bytes),
1:                                    charsToSkip);
1:             this.posCache.updateCachedPos(charPos, bytePos);
1:         return bytePos;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Writer getWriter (long pos) throws IOException, SQLException {
1:         checkIfValid();
1:         // If pos is too large, an error will first be thrown when the writer
1:         // is written to. Is this okay behavior, is does it break the spec?
1:         if (pos < this.posCache.getCharPos()) {
1:             this.posCache.reset();
1:         }
1:         return new ClobUtf8Writer (this, pos);
1:      *      number of characters. Expected to be non-negative. The first
1:      *      character is at position <code>0</code>.
1:      * @throws SQLException if the specified position is too big
1:     public synchronized Reader getReader (long pos)
1:             throws IOException, SQLException {
1:         checkIfValid();
1:         if (pos < 1) {
1:             throw new IllegalArgumentException(
1:                 "Position must be positive: " + pos);
1:         }
0:                 (LOBInputStream) getRawByteStream(), conChild);
1:         long leftToSkip = pos -1;
1:         long skipped;
1:             skipped = isr.skip(leftToSkip);
1:             // Since Reader.skip block until some characters are available,
1:             // a return value of 0 must mean EOF.
1:             if (skipped <= 0) {
1:                 throw new EOFException("Reached end-of-stream prematurely");
1:             }
1:             leftToSkip -= skipped;
1:      * Returns number of characters in the Clob.
1:      *
1:      * @return The length of the Clob in number of characters.
1:      * @throws IOException if accessing the underlying I/O resources fail
1:     public synchronized long getCharLength() throws IOException {
1:         checkIfValid();
0:         return
0:             UTF8Util.skipUntilEOF(new BufferedInputStream(getRawByteStream()));
1:      *
1:      * @throws IOException if accessing the underlying I/O resources fail
1:     public synchronized long getByteLength () throws IOException {
1:         checkIfValid();
1:         return this.bytes.getLength();
1:      * Inserts a string at the given position.
1:      *
1:      * @param str the string to insert
1:      * @param insertionPoint the character position to insert the string at
1:      * @return Number of characters inserted.
1:      * @throws EOFException if the position is larger than the Clob length +1
1:      * @throws IOException if accessing the underlying I/O resources fail
1:      * @throws SQLException if accessing the underlying resources fail
1:     public synchronized long insertString (String str, long insertionPoint)
1:                  throws IOException, SQLException {
1:         checkIfValid();
1:         if (insertionPoint < 1) {
1:             throw new IllegalArgumentException(
1:                 "Position must be positive: " + insertionPoint);
1:         long byteInsertionPoint = getBytePosition(insertionPoint);
1:         long curByteLength = this.bytes.getLength();
1:         byte[] newBytes = getByteFromString(str);
1:         // See if we are appending or replacing bytes.
1:         if (byteInsertionPoint == curByteLength) {
1:             try {
1:                 this.bytes.write(newBytes, 0, newBytes.length,
1:                     byteInsertionPoint);
1:             } catch (StandardException se) {
1:                 throw Util.generateCsSQLException(se);
1:             }
1:         } else {
1:             // Calculate end position of the byte block to replace.
1:             // Either we only replace bytes, or we replace and append bytes.
1:             long endPos;
1:             try {
1:                 endPos = getBytePosition(insertionPoint + str.length());
1:                 // Must reset the position cache here, as the last obtained
1:                 // one may be invalid after we replace the bytes (because of
1:                 // the variable number of bytes per char).
1:                 this.posCache.updateCachedPos(
1:                     insertionPoint, byteInsertionPoint);
1:             } catch (EOFException eofe) {
1:                 endPos = curByteLength; // We replace and append.
1:             }
1:             try {
1:                 this.bytes.replaceBytes(newBytes, byteInsertionPoint, endPos);
1:             } catch (StandardException se) {
1:                 throw Util.generateCsSQLException(se);
1:             }
1:         }
1:      * Tells if this Clob is intended to be writable.
1:      *
1:      * @return <code>true</code>
1:      */
1:     public boolean isWritable() {
1:         return true;
1:     }
1: 
1:     /**
1:      * Truncate the Clob to the specifiec size.
1:      *
0:      * @param newLength the new length, in characters, of the Clob
1:      * @throws IOException if accessing the underlying I/O resources fails
1:      */
0:     public synchronized void truncate(long newLength)
1:             throws IOException, SQLException {
1:         checkIfValid();
1:         try {
0:             this.bytes.truncate(newLength);
0:             if (newLength <= this.posCache.getCharPos()) {
0:                 // Reset the cache if last cached position has been cut away.
1:                 this.posCache.reset();
1:             }
1:         } catch (StandardException se) {
1:             throw Util.generateCsSQLException(se);
1:         }
1:     }
1: 
1:     /**
1:      * Converts a string into the modified UTF-8 byte encoding.
1:      *
1:      * @param str string to represent with modified UTF-8 encoding
1:      * @return Byte array representing the string in modified UTF-8 encoding.
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Copies the content of another Clob into this one.
1:      *
1:      * @param clob the Clob to copy from
1:      * @throws IOException if accessing I/O resources fail (both read and write)
1:      * @throws SQLException if accessing underlying resources fail
1:      */
1:     private void copyClobContent(InternalClob clob)
1:             throws IOException, SQLException {
1:         try {
0:             this.bytes.copyData(clob.getRawByteStream(), clob.getByteLength());
1:         } catch (StandardException se) {
1:             throw Util.generateCsSQLException(se);
1:         }
1:     }
1: 
1:     /**
1:      * Makes sure the Clob has not been released.
1:      * <p>
1:      * All operations are invalid on a released Clob.
1:      *
1:      * @throws IllegalStateException if the Clob has been released
1:      */
1:     private final void checkIfValid() {
1:         if (this.released) {
1:             throw new IllegalStateException(
1:                 "The Clob has been released and is not valid");
1:         }
1:     }
1: 
1:     /**
1:      * A simple class to hold the byte position for a character position.
1:      * <p>
1:      * The implementation is very simple and is basically intended to speed up
1:      * writing a sequence of consequtive characters one character at a time.
1:      * Even though this should be avoided if possible, the penalty of updating a
1:      * large Clob this way and finding the correct byte position by navigating
1:      * from the start of the byte stream each time is so severe that a simple
1:      * caching mechanism should be in place. Note that for other encodings than
1:      * UTF-8, this might not be a problem if the mapping between character
1:      * position and byte position is one-to-one.
1:      * <p>
1:      * Note that to ensure consistency between character and byte positions,
1:      * access to this class must be synchronized externally to avoid caller 1
1:      * getting the character position, then caller 2 updates the cached values
1:      * and then caller 1 gets the updated byte position.
1:      */
1:     //@NotThreadSafe
1:     private static class CharToBytePositionCache {
1:         private long charPos = 1L;
1:         private long bytePos = 0L;
1: 
1:         CharToBytePositionCache() {}
1: 
1:         /**
1:          * Returns the last cached byte position.
1:          *
1:          * @return The byte position for the last cached character position.
1:          */
1:         long getBytePos() {
1:             return this.bytePos;
1:         }
1: 
1:         /**
1:          * Returns the last cached character position.
1:          *
1:          * @return The last cached character position.
1:          */
1:         long getCharPos() {
1:             return this.charPos;
1:         }
1: 
1:         /**
1:          * Updates the position cache.
1:          *
1:          * @param charPos the character position to cache the byte position for
1:          * @param bytePos byte position for the specified character position
1:          */
1:         void updateCachedPos(long charPos, long bytePos) {
1:             if (charPos -1 > bytePos) {
1:                 throw new IllegalArgumentException("(charPos -1) cannot be " +
1:                     "greater than bytePos; " + (charPos -1) + " > " + bytePos);
1:             }
1:             this.charPos = charPos;
1:             this.bytePos = bytePos;
1:         }
1: 
1:         /**
1:          * Resets the position cache.
1:          */
1:         void reset() {
1:             this.charPos = 1L;
1:             this.bytePos = 0L;
1:         }
1:     } // End internal class CharToBytePositionCache
commit:47510ba
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 streamLength += 2;
/////////////////////////////////////////////////////////////////////////
1: 
0:         return streamLength;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     synchronized String getSubstring (long bIndex, long eIndex)
0:         Reader r = getReader(bIndex);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     synchronized long insertString (String str, long pos)
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
commit:e5b15ce
/////////////////////////////////////////////////////////////////////////
1: 
0:      * Constructs a <code>ClobStreamControl</code> object used to perform
1:      * operations on a CLOB value.
0:      *
0:      * @param dbName name of the database the CLOB value belongs to
1:      * @param conChild connection object used to obtain synchronization object
/////////////////////////////////////////////////////////////////////////
1:      * Finds the corresponding byte position for the given UTF-8 character
1:      * position, starting from the byte position <code>startPos</code>.
0:      *
0:      * @param startPos start position in number of bytes
1:      * @param charPos character position
1:      * @return Stream position in bytes for the given character position.
/////////////////////////////////////////////////////////////////////////
1:      * Constructs and returns a <code>Writer</code> for the CLOB value.
0:      *
1:      * @param pos the initial position in bytes for the <code>Writer</code>
1:      * @return A <code>Writer</code> to write to the CLOB value.
1:      * @throws IOException
1:      * @throws SQLException if the specified position is invalid
/////////////////////////////////////////////////////////////////////////
1:      * Constructs and returns a <code>Reader</code>.
0:      * @throws SQLException if the specified position is invalid
commit:bb0c274
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one
1:    or more contributor license agreements.  See the NOTICE file
1:    distributed with this work for additional information
1:    regarding copyright ownership.  The ASF licenses this file
1:    to you under the Apache License, Version 2.0 (the
1:    "License"); you may not use this file except in compliance
1:    with the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing,
1:    software distributed under the License is distributed on an
1:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:    KIND, either express or implied.  See the License for the
1:    specific language governing permissions and limitations
1:    under the License.
1: 
commit:ffb9317
/////////////////////////////////////////////////////////////////////////
commit:e4983ff
/////////////////////////////////////////////////////////////////////////
0:      * Construct and return a <code>Reader</code>.
1:      * @param pos initial position of the returned <code>Reader</code> in
0:      *      number of characters
1:      * @return A <code>Reader</code> with the underlying <code>CLOB</code>
1:      *      value as source.
1:      * @throws IOException
0:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
0:      * Returns a substring.
0:      * @return A substring of the <code>CLOB</code> value.
0:      * @throws IOException
0:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * Returns the size of the Clob in bytes.
1:      * @return Number of bytes in the <code>CLOB</code> value.
commit:e1fc783
/////////////////////////////////////////////////////////////////////////
0: /* 
0:    Derby - Class org.apache.derby.impl.jdbc.ClobStreamControl
0:  
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
0:  
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0:  
0:       http://www.apache.org/licenses/LICENSE-2.0
0:  
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0:  
1:  */
1: package org.apache.derby.impl.jdbc;
0: 
1: import java.io.BufferedInputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
0: import java.io.InputStreamReader;
0: import java.io.OutputStreamWriter;
1: import java.io.Reader;
0: import java.io.UTFDataFormatException;
1: import java.io.Writer;
1: import java.sql.SQLException;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.util.ByteArray;
0: 
0: final class ClobStreamControl extends LOBStreamControl {
0:     
1:     private ConnectionChild conChild;
1:     /**
0:      * Constructs ClobStreamControl
0:      * @param dbName 
0:      * @param conChild
1:      */
0:     ClobStreamControl (String dbName, ConnectionChild conChild) {
0:         super (dbName);
1:         this.conChild = conChild;
1:     }        
0:     
1:     /**
0:      * Finds the positon in bytes for a utf8 char postion starting 
0:      * from startPos (bytes).
0:      * @param startPos in bytes
0:      * @param charPos in chars
0:      * @return stream position for the given char position
0:      * @throws IOException
1:      */
0:     synchronized long getStreamPosition (long startPos, long charPos) throws IOException {
0:         InputStream in = new BufferedInputStream (getInputStream (startPos));
0:         long charLength = 0;
0:         long streamLength = 0;
0:         //utf decoding routine
0:         while (charLength < charPos) {
0:             int c = in.read();
0:             if (c < 0)
0:                 return -1;
0:             charLength ++;
1:              if ((c >= 0x0001) && (c <= 0x007F)) {
0:                 //found char of one byte width
0:                 streamLength++;
1:             }
1:             else if (c > 0x07FF) {
0:                 //found char of three byte width
0:                 if (in.skip (2) < 2) {
0:                     //no second and third byte present
0:                     throw new UTFDataFormatException();
1:                 }
0:                 streamLength += 3;
0:                 break;
1:             }
1:             else {
0:                 //found char of three byte width
0:                 if (in.skip (1) != 1) {
0:                     //no second and third byte present
0:                     throw new UTFDataFormatException();
1:                 }
0:                 streamLength += 2;
1:             }
1:         }
0:         
0:         in.close();
0:         return streamLength;        
1:     }
0:     
1:     /**
0:      * constructs and returns a writer.
0:      * @param pos 
0:      * @return Writer
0:      * @throws IOException, SQLException
1:      */
0:     synchronized Writer getWriter (long pos) throws IOException, SQLException {
0:         long charPos = getStreamPosition (0, pos);
0:         if (charPos == -1)
0:             throw Util.generateCsSQLException (SQLState.BLOB_POSITION_TOO_LARGE,
0:                                 "" + (pos + 1));
0:         return new ClobUtf8Writer (this, getStreamPosition (0, charPos));
1:     }
0:     
1:     /**
0:      * constructs and reurns a reader.
0:      * @param pos 
0:      * @return 
0:      * @throws IOException, SQLException
1:      */
0:     Reader getReader (long pos) throws IOException, SQLException {
0:         Reader isr = new ClobUpdateableReader (
0:                 (LOBInputStream) getInputStream (0), conChild);
0: 
0:         long leftToSkip = pos;
1:         while (leftToSkip > 0) {
0:             leftToSkip -= isr.skip (leftToSkip);
1:         }
1:         return isr;
1:     }    
0:     
1:     /**
0:      * returns a substring.
0:      * @param bIndex 
0:      * @param eIndex 
0:      * @return 
0:      * @throws IOException, SQLException
1:      */
0:     synchronized String getSubstring (long bIndex, long eIndex) 
0:                                             throws IOException, SQLException {
0:         Reader r = getReader(bIndex);        
0:         char [] buff = new char [(int) (eIndex - bIndex)];
0:         int length = 0;
0:         do {
0:             int ret = r.read (buff, length, (int) (eIndex - bIndex) - length);
0:             if (ret == -1 )
0:                 break;
0:             length += ret;
0:         } while (length < eIndex - bIndex);
0:         return new String (buff, 0, length);
1:     }
0:     
1:     /**
0:      * returns number of charecter in the clob.
0:      * @return char length
0:      * @throws IOException, SQLException
1:      */
0:     synchronized long getCharLength () throws IOException, SQLException {
0:         Reader reader = getReader(0);
0:         char [] dummy = new char [4 * 1024];
0:         int length = 0;
0:         do {
0:             long ret = reader.read (dummy);
0:             if (ret == -1) break;
0:             length += ret;
0:         }while (true);
0:         return length;
1:     }
0:     
1:     /**
0:      * returns the size of clob in bytes.
0:      * @return 
0:      * @throws IOException
1:      */
0:     long getByteLength () throws IOException {
0:         return super.getLength();
1:     }
0:     
1:     /**
0:      * inserts a string at a given postion.
0:      * @param str 
0:      * @param pos byte postion
0:      * @return current byte postion
0:      * @throws IOException
1:      */
0:     synchronized long insertString (String str, long pos) 
0:                                             throws IOException, SQLException {
0:         int len = str.length();
0:         if (pos == super.getLength()) {
0:             byte b [] = getByteFromString (str);
0:             long l = write (b, 0, b.length, pos);
1:             return str.length();
1:         }
0:         long endPos = getStreamPosition (pos, len);
0:         endPos = (endPos < 0) ? getLength() : pos + endPos;
0:         replaceBytes (getByteFromString (str), pos, endPos);
1:         return str.length();
1:     }
0:     
1:     /**
0:      * Converts a string into utf8 byte array.
0:      * @param str 
0:      * @return utf8 bytes array
1:      */
1:     private byte[] getByteFromString (String str) {
1:         //create a buffer with max size possible
1:         byte [] buffer = new byte [3 * str.length()];
1:         int len = 0;
1:         //start decoding
1:         for (int i = 0; i < str.length(); i++) {
1:             int c = str.charAt (i);
1:             if ((c >= 0x0001) && (c <= 0x007F)) {
1:                 buffer[len++] = (byte) c;
1:             }
1:             else if (c > 0x07FF) {
1:                 buffer[len++] = (byte) (0xE0 | ((c >> 12) & 0x0F));
1:                 buffer[len++] = (byte) (0x80 | ((c >>  6) & 0x3F));
1:                 buffer[len++] = (byte) (0x80 | ((c >>  0) & 0x3F));
1:             }
1:             else {
1:                 buffer[len++] = (byte) (0xC0 | ((c >>  6) & 0x1F));
1:                 buffer[len++] = (byte) (0x80 | ((c >>  0) & 0x3F));
1:             }
1:         }
1:         byte [] buff = new byte [len];
1:         System.arraycopy (buffer, 0, buff, 0, len);
1:         return buff;
1:     } 
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:10e4538
/////////////////////////////////////////////////////////////////////////
1:         TemporaryClob newClob = new TemporaryClob(conChild);
/////////////////////////////////////////////////////////////////////////
1:         TemporaryClob newClob = new TemporaryClob(conChild);
/////////////////////////////////////////////////////////////////////////
0:      * 
1:     TemporaryClob (ConnectionChild conChild) {
1:         this.bytes = new LOBStreamControl(conChild.getEmbedConnection());
/////////////////////////////////////////////////////////////////////////
1:     TemporaryClob (String data, ConnectionChild conChild)
1:         bytes = new LOBStreamControl(conChild.getEmbedConnection(), getByteFromString (data));
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:685a147
/////////////////////////////////////////////////////////////////////////
1:      * See comments in SQLChar.readExternal for more notes on
1:      * processing the UTF8 format.
/////////////////////////////////////////////////////////////////////////
0:             if ((c & 0x80) == 0x00) {
0:             else if ((c & 0x60) == 0x40) // we know the top bit is set here
0:             {
0:                 //found char of two byte width
0:                 streamLength += 2;                
0:             }
0:             else if ((c & 0x70) == 0x60) // we know the top bit is set here
0:             {
0:                 //found char of three byte width
0:                 if (in.skip (2) != 2) {
0:                     //no second and third byte present
0:                     throw new UTFDataFormatException();
0:                 }
0:                 streamLength += 3;
0:             }
0:             else
0:             {
0:                 throw new UTFDataFormatException();
============================================================================