1:7d98408: /*
3:7d98408:  *
1:e6ffa2a:  * Derby - Class org.apache.derbyTesting.junit.SecurityManagerSetup
1:7d98408:  *
1:15651f5:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:  * contributor license agreements.  See the NOTICE file distributed with
1:15651f5:  * this work for additional information regarding copyright ownership.
1:15651f5:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:  * (the "License"); you may not use this file except in compliance with
1:15651f5:  * the License.  You may obtain a copy of the License at
1:7d98408:  *
1:7d98408:  *    http://www.apache.org/licenses/LICENSE-2.0
1:7d98408:  *
1:7d98408:  * Unless required by applicable law or agreed to in writing, 
1:7d98408:  * software distributed under the License is distributed on an 
1:7d98408:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:7d98408:  * either express or implied. See the License for the specific 
1:7d98408:  * language governing permissions and limitations under the License.
1:7d98408:  */
1:3bd1dd8: package org.apache.derbyTesting.junit;
1:9414ec9: 
1:348cafe: import java.io.File;
1:9414ec9: import java.io.IOException;
1:9414ec9: import java.io.InputStream;
1:9414ec9: import java.io.OutputStream;
1:ed505d0: import java.net.MalformedURLException;
1:7d98408: import java.net.URL;
1:7d98408: import java.security.AccessController;
1:23c0fed: import java.security.Policy;
1:b0ec63d: import java.security.PrivilegedAction;
1:9414ec9: import java.security.PrivilegedActionException;
1:b0ec63d: import java.security.PrivilegedExceptionAction;
1:7d98408: import java.util.Enumeration;
1:7d98408: import java.util.Properties;
1:7d98408: import junit.extensions.TestSetup;
1:7d98408: import junit.framework.Test;
1:9414ec9: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:59a5a70: 
1:3ec94a5: /**
1:9414ec9:  * Configures the wrapped test to be run with the specified security policy.
1:9414ec9:  * <p>
1:9414ec9:  * This setup class normally installs the default policy file. This can be
1:9414ec9:  * overridden by specifying {@literal java.security.policy=<NONE>} (see
1:9414ec9:  * {@linkplain #NO_POLICY}), and can also be overridden by installing a
1:9414ec9:  * security manager explicitly before the default security manager is installed.
1:9414ec9:  * <p>
1:9414ec9:  * Individual tests/suites can be configured to be run without a security
1:9414ec9:  * manager, with a specific policy file, or with a specific policy file merged
1:9414ec9:  * with the default policy file. The last option is useful when you only need
1:9414ec9:  * to extend the default policy with a few extra permissions to run a test.
1:7d98408:  */
1:7d98408: public final class SecurityManagerSetup extends TestSetup {
1:9414ec9: 
1:e6ffa2a:     /** Constant used to indicate that no security policy is to be installed. */
1:e6ffa2a:     static final String NO_POLICY = "<NONE>";
1:e6ffa2a: 
1:ce9c46e:     /**
1:ce9c46e:      * Does the JVM support Subjects for
1:ce9c46e:      * authorization through Java security manager.
1:ce9c46e:      * J2ME/CDC/Foundation 1.1 does not support Subjects.
1:ce9c46e:      */
1:ce9c46e:     public static final boolean JVM_HAS_SUBJECT_AUTHORIZATION;
1:ce9c46e:     static {
1:ce9c46e:         JVM_HAS_SUBJECT_AUTHORIZATION = JDBC.haveClass("javax.security.auth.Subject");
1:ce9c46e:     }
1:1690ef6:     
1:ce9c46e: 	
1:7d98408: 	private static final Properties classPathSet = new Properties();
1:ce9c46e:     
1:9414ec9:     /**
1:3ec94a5:      * True if the classes are loaded from jars.
1:3ec94a5:      */
1:3ec94a5:     static boolean isJars;
1:36d1b35: 	
1:9414ec9: 	/**
1:7d98408: 	 * True if a security manager was installed outside of the
1:7d98408: 	 * control of this class and BaseTestCase.
1:7d98408: 	 */
1:7d98408: 	private static final boolean externalSecurityManagerInstalled;
1:3ec94a5: 	
1:305a23d: 	static {
1:7d98408: 		// Determine what the set of properties
1:7d98408: 		// describing the environment is.
1:7d98408: 		externalSecurityManagerInstalled = determineClasspath();
1:1e0c703:         
1:23c0fed: 	}
1:1e0c703: 
1:7d98408:     static {
1:305a23d:         // Work around bug in weme6.2 (DERBY-5558 and DERBY-6079).
1:305a23d:         if (BaseTestCase.isJ9Platform()) {
1:305a23d:             BaseTestCase.setSystemProperty("emma.active", "");
1:305a23d:             BaseTestCase.setSystemProperty("jacoco.active", "");
1:305a23d:         }
1:305a23d:     }
1:305a23d: 
1:1e0c703:     static final boolean jacocoEnabled = checkIfJacocoIsRunning();
1:1e0c703:     private static boolean checkIfJacocoIsRunning() {
1:2510115:         return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:2510115:                 public Boolean run() {
1:4e26997:                     try {
1:c2ff5c7:                         // Check if some arbitrary class from jacocoagent.jar
1:c2ff5c7:                         // is available.
1:4e26997:                         Class.forName("org.jacoco.agent.rt.RT");
1:c2ff5c7: 
1:c2ff5c7:                         // If we got here, it means the tests are running
1:c2ff5c7:                         // under JaCoCo. Set the jacoco.active property to
1:c2ff5c7:                         // the empty string in order to activate the
1:c2ff5c7:                         // JaCoCo-specific permissions in derby_tests.policy,
1:c2ff5c7:                         // and return true.
1:c2ff5c7:                         System.setProperty("jacoco.active", "");
1:4e26997:                         return true;
1:4e26997:                     } catch (ClassNotFoundException e) {
1:4e26997:                         return false;
1:4e26997:                     } catch (LinkageError e) {
1:4e26997:                         return false;
1:1e0c703:                     }
1:1e0c703:                 }
1:2510115:         });
1:1e0c703:     }
1:59a5a70: 
1:7d98408: 	private final String decoratorPolicyResource;
1:9414ec9:     /** An additional policy to install (may be {@code null}). */
1:9414ec9:     private final String additionalPolicyResource;
1:1690ef6: 	private SecurityManager decoratorSecurityManager = null;
1:1690ef6: 	
1:9414ec9:     public SecurityManagerSetup(Test test, String policyResource) {
1:9414ec9:         this(test, policyResource, false);
1:9414ec9:     }
1:9414ec9: 
1:59a5a70:     /**
1:9414ec9:      * Installs a new security policy.
1:9414ec9:      *
1:9414ec9:      * @param test the test to wrap
1:9414ec9:      * @param policyResource the policy to install
1:9414ec9:      * @param mergePolicies if {@code false} the specified policy will be the
1:9414ec9:      *      only policy installed, if {@code true} the specified policy will be
1:9414ec9:      *      merged with the default test policy for the test framework
1:9414ec9:      */
1:9414ec9:     public SecurityManagerSetup(Test test, String policyResource,
1:9414ec9:                                 boolean mergePolicies) {
1:9414ec9:         super(test);
1:9414ec9:         if (mergePolicies) {
1:9414ec9:             // By choice, only support merging with the default test policy.
1:9414ec9:             this.decoratorPolicyResource = getDefaultPolicy();
1:9414ec9:             this.additionalPolicyResource = policyResource;
1:9414ec9:         } else {
2:1690ef6:             this.decoratorPolicyResource = policyResource != null ?
2:1690ef6:                     policyResource : getDefaultPolicy();
1:9414ec9:             this.additionalPolicyResource = null;
1:9414ec9:         }
1:1690ef6:     }
1:424cdbd: 
1:1690ef6: 	/**
1:1690ef6: 	 * Use custom policy and SecurityManager
1:1690ef6: 	 * 
1:1690ef6: 	 * @param test - Test to wrap
1:1690ef6: 	 * @param policyResource - policy resource. If null use default testing policy
1:1690ef6: 	 * @param securityManager - Custom SecurityManager if null use the system security manager
1:1690ef6: 	 */
1:1690ef6: 	public SecurityManagerSetup(Test test, String policyResource, SecurityManager securityManager)
1:892e782: 	{
1:9414ec9:         this(test, policyResource, false);
1:1690ef6: 		this.decoratorSecurityManager = securityManager;
1:892e782: 	}
1:892e782: 	
1:424cdbd: 	/**
1:7d98408: 	 * Get a decorator that will ensure no security manger
1:7d98408: 	 * is installed to run a test. Not supported for suites.
1:7d98408: 	 * <BR>
1:7d98408: 	 * An empty suite is returned if a security manager was installed
1:7d98408: 	 * externally, i.e. not under the control of the BaseTestCase
1:7d98408: 	 * and this code. In this case the code can not support the
1:7d98408: 	 * mode of no security manager as it may not have enough information
1:7d98408: 	 * to re-install the security manager. So the passed in test
1:7d98408: 	 * will be skipped.
1:23c0fed:      * 
1:23c0fed:      * @param test Test to run without a security manager. Note that
1:23c0fed:      * this must be an instance of BaseTestCase as this call depends
1:23c0fed:      * on setup code in that class. Arbitrary Test instances cannot be passed in.
1:7d98408: 	 */
1:912793e: 	public static Test noSecurityManager(Test test)
1:1690ef6: 	{
1:1ae02c9:         if (externalSecurityManagerInstalled) {
1:1ae02c9:             return new BaseTestSuite(
1:1ae02c9:                 "skipped due to external security manager "
1:1ae02c9:                 + test.toString());
1:1ae02c9:         }
1:1ae02c9: 
1:e6ffa2a:         return new SecurityManagerSetup(test, NO_POLICY);
6:7d98408: 	}
1:424cdbd: 
1:7d98408: 	/**
1:74c2b8d: 	 * "Install" no security manager.
1:7d98408: 	 * 
1:7d98408: 	 */
1:74c2b8d: 	static void noSecurityManager()
4:7d98408: 	{
1:e6ffa2a:         installSecurityManager(NO_POLICY);
1:7d98408: 	}
1:3bd1dd8: 	
1:7d98408: 	/**
1:e6ffa2a:      * Install specific policy file with the security manager
1:7d98408: 	 * including the special case of no security manager.
1:7d98408: 	 */
1:9414ec9:     protected void setUp()
1:9414ec9:             throws IOException {
1:9414ec9:         String resource = getEffectivePolicyResource(
1:9414ec9:                 decoratorPolicyResource, additionalPolicyResource);
1:9414ec9:         installSecurityManager(resource, decoratorSecurityManager);
1:7d98408: 	}
14:7d98408:     
1:36d1b35:     protected void tearDown() throws Exception
1:36d1b35:     {
1:e6ffa2a:         if (NO_POLICY.equals(decoratorPolicyResource))
1:36d1b35:             BaseTestCase.setSystemProperty("java.security.policy", "");
1:59a5a70:         else if ( !externalSecurityManagerInstalled )
1:59a5a70:         {
1:59a5a70:             uninstallSecurityManager();
1:59a5a70:         }
1:36d1b35:     }
1:7d98408: 	
1:e0f1ffe:     /**
1:e0f1ffe:      * Return the name of the default policy.
1:e0f1ffe:      */
1:9414ec9:     private static String getDefaultPolicy()
1:e0f1ffe:     {
1:e0f1ffe:         return "org/apache/derbyTesting/functionTests/util/derby_tests.policy";
1:e0f1ffe:     }
1:e0f1ffe: 
1:7d98408: 	/**
1:dd07790: 	 * Install a SecurityManager with the default test policy
1:dd07790: 	 * file:
1:dd07790: 	 * org/apache/derbyTesting/functionTests/util/derby_tests.policy
1:dd07790: 	 * 
1:dd07790: 	 */
1:74c2b8d: 	static void installSecurityManager()
1:74c2b8d: 	{
1:e0f1ffe: 		installSecurityManager( getDefaultPolicy() );
1:dd07790: 	}
1:dd07790: 
1:1690ef6: 	private static void installSecurityManager(String policyFile) {
1:1690ef6: 	   installSecurityManager(policyFile, System.getSecurityManager());
1:1690ef6: 	}
1:1690ef6: 
1:1690ef6: 	private static void installSecurityManager(String policyFile, final SecurityManager sm)
1:1690ef6: 			 {
1:1690ef6: 	    
2:7d98408: 		if (externalSecurityManagerInstalled)
2:7d98408: 			return;
1:7d98408: 		
1:7d98408: 		Properties set = new Properties(classPathSet);
1:7d98408: 		setSecurityPolicy(set, policyFile);
1:7d98408: 
1:1690ef6: 		SecurityManager currentsm = System.getSecurityManager();
1:1690ef6: 		if (currentsm != null) {
1:7d98408: 			// SecurityManager installed, see if it has the same settings.
1:7d98408: 
1:f35adc5: 			String  newPolicyProperty = set.getProperty("java.security.policy" );
1:f35adc5: 			if ( newPolicyProperty == null ) { newPolicyProperty = ""; } 
1:f35adc5:                                                    
1:f35adc5: 			String  oldPolicyProperty = BaseTestCase.getSystemProperty("java.security.policy");
1:1690ef6: 			SecurityManager oldSecMan = System.getSecurityManager();
1:892e782: 
1:f35adc5: 			if ( oldPolicyProperty == null ) { oldPolicyProperty = ""; }
1:f35adc5: 
1:1690ef6: 			if ( newPolicyProperty.equals( oldPolicyProperty ) &&
1:1690ef6: 			        oldSecMan == sm) { return; }
1:7d98408: 			
1:7d98408: 			// Uninstall the current manager.
1:59a5a70: 			uninstallSecurityManager();
1:7d98408: 		}
1:7d98408: 		
1:7d98408: 		// Set the system properties from the desired set.
1:7d98408: 		for (Enumeration e = set.propertyNames(); e.hasMoreElements();) {
1:7d98408: 			String key = (String) e.nextElement();
1:7d98408: 			BaseTestCase.setSystemProperty(key, set.getProperty(key));
1:7d98408: 		}
1:7d98408: 		
1:7d98408: 		// Check indicator for no security manager
1:e6ffa2a:         if (NO_POLICY.equals(set.getProperty("java.security.policy")))
1:7d98408: 			return;
1:7d98408: 		
1:7d98408: 		// and install
1:2510115:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:59a5a70: 
1:7d98408: 
1:2510115:                 public Void run() {
1:1690ef6:                     if (sm == null)
1:1690ef6:                         System.setSecurityManager(new SecurityManager());
1:1690ef6:                     else
1:1690ef6:                         System.setSecurityManager(sm);
1:7d10f01:                     Policy.getPolicy().refresh();
1:7d10f01:                     return null;
1:7d10f01:                 }
2:7d98408: 		});
1:9414ec9:         println("installed policy " + policyFile);
1:7d98408: 	}
1:7d98408: 	
1:7d98408: 	private static void setSecurityPolicy(Properties set,
1:74c2b8d: 			String policyResource)
1:dd07790: 	{
1:e6ffa2a:         if (NO_POLICY.equals(policyResource)) {
1:dd07790: 			set.setProperty("java.security.policy", policyResource);
1:dd07790: 			return;
1:dd07790: 		}
1:b0ec63d:         try {
1:b0ec63d:             URL policyURL = getResourceURL(policyResource);
1:b0ec63d:             set.setProperty("java.security.policy", policyURL.toExternalForm());
1:b0ec63d:         } catch (MalformedURLException mue) {
1:b0ec63d:             BaseTestCase.alarm("Unreadable policy URL: " + policyResource);
1:7d98408:         }
1:7d98408: 	}
1:7d98408: 	
1:dd07790: 	/**
1:7d98408: 	 * Determine the settings of the classpath in order to configure
1:7d98408: 	 * the variables used in the testing policy files.
1:7d98408: 	 * Looks for three items:
1:7d98408: 	 * 
1:7d98408: 	 * Location of derbyTesting.jar via this class
1:5570eb0: 	 * Location of derby.jar via org.apache.derby.jdbc.EmbeddedDataSource
1:7d98408: 	 * Location of derbyclient.jar via org.apache.derby.jdbc.ClientDataSource
1:7d98408: 	 * 
1:7d98408: 	 * Two options are supported, either all are in jar files or
1:7d98408: 	 * all are on the classpath. Properties are set as follows:
1:7d98408: 	 * 
1:7d98408: 	 * <P>
1:7d98408: 	 * Classpath:
1:7d98408: 	 * <BR>
1:348cafe: 	 * derbyTesting.codeclasses set to URL of classes folder
1:463fe16:      * <BR>
1:463fe16:      * derbyTesting.ppcodeclasses set to URL of the 'classes.pptesting' folder
1:463fe16:      * if it exists on the classpath. The existence of the package private tests
1:463fe16:      * is determined via org.apache.derby.PackagePrivateTestSuite
1:7d98408: 	 * <P>
1:7d98408: 	 * Jar files:
1:7d98408: 	 * <BR>
1:348cafe: 	 * derbyTesting.codejar - URL of derby.jar,
1:7d98408: 	 * derbynet.jar and derbytools.jar, all assumed to be in the
1:7d98408: 	 * same location.
1:7d98408: 	 * <BR>
1:348cafe: 	 * derbyTesting.clientjar - URL of derbyclient.jar
1:7d98408: 	 * <BR>
1:348cafe: 	 * derbyTesting.testjar - URL of derbyTesting.jar
1:348cafe:      * <BR>
1:348cafe:      * derbyTesting.testjarpath - File system path to derbyTesting.jar
1:348cafe:      * if the jar has a URL with a file protocol.
1:7d98408: 	 * 
1:7d98408: 	 */
1:7d98408: 	private static boolean determineClasspath()
1:7d98408: 	{
1:7d98408: 		// Security manager already installed, assume that
1:7d98408: 		// it is set up correctly.
1:7d98408: 		if (System.getSecurityManager() != null) {		
1:7d98408: 			return true;
1:7d98408: 		}
1:7d98408: 
1:8766228: 		//We need the junit classes to instantiate this class, so the
1:8766228: 		//following should not cause runtime errors.
1:21a3353:         URL junit = getURL(junit.framework.Test.class);
1:21a3353:         if (junit != null)
1:21a3353:             classPathSet.setProperty("derbyTesting.junit", junit.toExternalForm());
1:7d98408: 	
1:21a3353:         // Load indirectly so we don't need ant-junit.jar at compile time.
1:21a3353:         URL antjunit = getURL("org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner");
1:21a3353:         if (antjunit != null)
1:21a3353:             classPathSet.setProperty("derbyTesting.antjunit", antjunit.toExternalForm());
1:21a3353: 
1:6f9270a:         URL ant = getURL("org.apache.tools.ant.Task");
1:6f9270a:         if (ant != null) {
1:6f9270a:             classPathSet.setProperty("derbyTesting.ant", ant.toExternalForm());
1:6f9270a:         }
1:6f9270a: 
1:d847ced:         // variables for lucene jar files
1:d847ced:         URL luceneCore = getURL( "org.apache.lucene.store.FSDirectory" );
1:d847ced:         if ( luceneCore != null )
1:d847ced:         {
1:d847ced:             classPathSet.setProperty( "derbyTesting.lucene.core", luceneCore.toExternalForm() );
1:d847ced:             classPathSet.setProperty( "derbyTesting.lucene.core.jar.file", luceneCore.getFile() );
1:d847ced:         }
1:d847ced: 
1:b5f6067:         // Load indirectly, normally no EMMA jars in the classpath.
1:b5f6067:         // This property is needed to set correct permissions in policy files.
1:b5f6067:         URL emma = getURL("com.vladium.emma.EMMAException");
1:b5f6067:         if (emma != null) {
1:b5f6067:             classPathSet.setProperty("emma.active", "");
1:b5f6067:         }
1:1e0c703: 
1:f7abbf4:         /* When inserting XML values that use external DTD's, the JAXP
1:f7abbf4:          * parser needs permission to read the DTD files.  So here we set
1:f7abbf4:          * a property to hold the location of the JAXP implementation
1:f7abbf4:          * jar file.  We can then grant the JAXP impl the permissions
1:f7abbf4:          * needed for reading the DTD files.
1:f7abbf4:          */
1:f7abbf4:         String jaxp = XML.getJAXPParserLocation();
1:f7abbf4:         if (jaxp != null)
1:f7abbf4:             classPathSet.setProperty("derbyTesting.jaxpjar", jaxp);
1:7d98408: 
1:7d98408: 		URL testing = getURL(SecurityManagerSetup.class);
1:73122ce:         URL ppTesting = null;
1:73122ce:         // Only try to load PackagePrivateTestSuite if the running JVM is
1:73122ce:         // Java 1.5 or newer (class version 49 = Java 1.5).
1:73122ce:         if (BaseTestCase.getClassVersionMajor() >= 49) {
1:73122ce:             ppTesting = getURL("org.apache.derby.PackagePrivateTestSuite");
1:73122ce:         }
1:7d98408: 		boolean isClasspath = testing.toExternalForm().endsWith("/");
1:7d98408: 		if (isClasspath) {
1:7d98408: 			classPathSet.setProperty("derbyTesting.codeclasses",
1:7d98408: 					testing.toExternalForm());
1:463fe16:             // ppTesting can be null, for instance if 'classes.pptesting' is
1:463fe16:             // not on the classpath.
1:463fe16:             if (ppTesting != null) {
1:463fe16:                 classPathSet.setProperty("derbyTesting.ppcodeclasses",
1:463fe16:                     ppTesting.toExternalForm());
1:463fe16:             }
1:3ec94a5:             isJars = false;
1:7d98408: 			return false;
1:7d98408: 		}
1:7d98408: 		classPathSet.setProperty("derbyTesting.testjar", stripJar(testing));
1:348cafe:         if (testing.getProtocol().equals("file")) {
1:348cafe:            File f = new File(testing.getPath());
1:348cafe:            classPathSet.setProperty("derbyTesting.testjarpath",
1:348cafe:                                                f.getAbsolutePath());
1:348cafe:         }
1:3ec94a5:         isJars = true;
1:7d98408: 		
1:1447937: 		URL derby = getURL("org.apache.derby.jdbc.BasicEmbeddedDataSource40");
1:21a3353:         if (derby != null)
1:21a3353: 		    classPathSet.setProperty("derbyTesting.codejar", stripJar(derby));
1:7d98408: 
1:1a1fb6a: 		// if we attempt to check on availability of the ClientDataSource with 
1:1a1fb6a: 		// JSR169, attempts will be made to load classes not supported in
1:1a1fb6a: 		// that environment, such as javax.naming.Referenceable. See DERBY-2269.
1:1a1fb6a: 		if (!JDBC.vmSupportsJSR169()) {
1:c35e4f0:            URL client = getURL(
1:c35e4f0:                     JDBC.vmSupportsJNDI() ?
1:c35e4f0:                     "org.apache.derby.jdbc.ClientDataSource" :
1:38667d9:                     "org.apache.derby.jdbc.BasicClientDataSource40");
1:c35e4f0: 
1:1a1fb6a: 		    if(client != null)
1:21a3353: 		        classPathSet.setProperty("derbyTesting.clientjar", stripJar(client));
1:c35e4f0:         }
1:7d98408: 		return false;
1:7d98408: 	}
1:7d98408:     
1:7d98408:     /**
1:424cdbd:      * Return the policy file system properties for use
1:424cdbd:      * by the old test harness. This ensures a consistent
1:424cdbd:      * approach to setting the properties. There are the
1:424cdbd:      * properties used to define the jar file location in
1:424cdbd:      * any policy files.
1:424cdbd:      */
1:424cdbd:     public static Properties getPolicyFilePropertiesForOldHarness()
1:424cdbd:     {
1:424cdbd:         return classPathSet;
1:424cdbd:     }
1:7d98408: 	
1:7d98408: 	/**
1:df4020d: 	 * Strip off the last token which will be the jar name.
1:7d98408: 	 * The returned string includes the trailing slash.
1:7d98408: 	 * @param url
1:df4020d: 	 * @return the jar name from the URL as a String
1:7d98408: 	 */
1:7d98408: 	private static String stripJar(URL url)
1:7d98408: 	{
1:7d98408: 		String ef = url.toExternalForm();
1:7d98408: 		return ef.substring(0, ef.lastIndexOf('/') + 1);
1:7d98408: 	}
1:21a3353:     
1:21a3353:     /**
1:21a3353:      * Get the URL of the code base from a class name.
1:21a3353:      * If the class cannot be loaded, null is returned.
1:21a3353:      */
1:676af8f:     public static URL getURL(String className) {
1:21a3353:         try {
1:21a3353:             return getURL(Class.forName(className));
1:21a3353:         } catch (ClassNotFoundException e) {
1:23c0fed:             return null;
1:1e0c703:         } catch (NoClassDefFoundError e) {
1:1e0c703:             return null;
1:21a3353:         }
1:21a3353:     }
1:7d98408: 	
1:7d98408: 	/**
1:7d98408: 	 * Get the URL of the code base from a class.
1:7d98408: 	 */
1:21a3353: 	static URL getURL(final Class cl)
1:7d98408: 	{
1:2510115:         return AccessController.doPrivileged(new PrivilegedAction<URL>() {
1:7d98408: 
1:2510115: 			public URL run() {
1:7d98408: 
1:f7abbf4:                 /* It's possible that the class does not have a "codeSource"
1:f7abbf4:                  * associated with it (ex. if it is embedded within the JVM,
1:f7abbf4:                  * as can happen with Xalan and/or a JAXP parser), so in that
1:f7abbf4:                  * case we just return null.
1:f7abbf4:                  */
1:f7abbf4:                 if (cl.getProtectionDomain().getCodeSource() == null)
1:21a3353:                     return null;
1:7d98408: 
1:7d98408: 				return cl.getProtectionDomain().getCodeSource().getLocation();
1:7d98408: 			}
1:7d98408: 		});
1:7d98408: 	}
1:7d98408: 
1:7d98408:     /**
1:59a5a70:      * Remove the security manager.
1:59a5a70:      */
1:59a5a70:     private static void uninstallSecurityManager()
1:74c2b8d:     {
1:59a5a70: 
1:59a5a70:             AccessController.doPrivileged
1:59a5a70:             (
1:2510115:              new PrivilegedAction<Void>()
1:59a5a70:              {
1:2510115:                  public Void run() {
1:59a5a70:                       System.setSecurityManager(null);
1:59a5a70:                      return null;
1:59a5a70:                  }
1:59a5a70:              }
1:59a5a70:              );
1:59a5a70: 
1:59a5a70:     }
1:59a5a70: 
1:7d98408:     /**
1:9414ec9:      * Returns the location of the effective policy resource.
1:9414ec9:      * <p>
1:9414ec9:      * If two valid policy resources from different locations are specified,
1:9414ec9:      * they will be merged into one policy file.
1:9414ec9:      *
1:9414ec9:      * @param policy1 first policy
1:9414ec9:      * @param policy2 second policy (may be {@code null})
1:e138316:      * @return The location of a policy resource, or {@linkplain #NO_POLICY}.
1:9414ec9:      * @throws IOException if reading or writing a policy resource fails
1:9414ec9:      */
1:9414ec9:     private static String getEffectivePolicyResource(String policy1,
1:9414ec9:                                                      String policy2)
1:9414ec9:             throws IOException {
1:e138316:         String resource = policy1;
1:e138316:         if (!NO_POLICY.equals(resource)) {
1:ed505d0:             URL url1 = getResourceURL(policy1);
1:e138316:             resource = url1.toExternalForm();
1:e138316:             if (policy2 != null) {
1:ed505d0:                 URL url2 = getResourceURL(policy2);
1:e138316:                 // Don't use URL.equals - it blocks and goes onto the network.
1:e138316:                 if (!url1.toExternalForm().equals(url2.toExternalForm())) {
1:e138316:                     resource = mergePolicies(url1, url2);
1:e138316:                 }
1:9414ec9:             }
1:9414ec9:         }
1:9414ec9:         return resource;
1:9414ec9:     }
1:9414ec9: 
1:9414ec9:     /**
1:ed505d0:      * Returns a URL for the given policy resource.
1:ed505d0:      *
1:ed505d0:      * @param policy the policy resource
1:ed505d0:      * @return A {@code URL} denoting the policy resource.
1:ed505d0:      * @throws MalformedURLException if the resource string not a valid URL
1:ed505d0:      */
1:ed505d0:     private static URL getResourceURL(final String policy)
1:ed505d0:             throws MalformedURLException {
1:ed505d0:         URL url = BaseTestCase.getTestResource(policy);
1:ed505d0:         if (url == null) {
1:ed505d0:             // Assume the policy is expressed as an URL already, probably
1:ed505d0:             // as a file.
1:ed505d0:             url =  new URL(policy);
1:ed505d0:         }
1:ed505d0:         return url;       
1:ed505d0:     }
1:ed505d0: 
1:ed505d0:     /**
1:9414ec9:      * Merges the two specified policy resources (typically files), and writes
1:9414ec9:      * the combined policy to a new file.
1:9414ec9:      *
1:9414ec9:      * @param policy1 the first policy
1:9414ec9:      * @param policy2 the second policy
1:9414ec9:      * @return The resource location string for a policy file.
1:9414ec9:      * @throws IOException if reading or writing to one of the resources fails
1:9414ec9:      */
1:9414ec9:     private static String mergePolicies(URL policy1, URL policy2)
1:9414ec9:             throws IOException {
1:9414ec9:         // Create target directory for the merged policy files.
1:9414ec9:         String sytemHome =
1:9414ec9:                 BaseTestCase.getSystemProperty("derby.system.home");
1:9414ec9:         File sysDir = new File(sytemHome == null ? "system" : sytemHome);
1:9414ec9:         File varDir = new File(sysDir, "var");
1:9414ec9:         // If running as the first test the system directory may not exist.
1:9414ec9:         // This situation looks a little bit suspicious - investigate?
1:9414ec9:         mkdir(sysDir);
1:9414ec9:         mkdir(varDir);
1:9414ec9: 
1:9414ec9:         // Read the contents of both policy files and write them out to
1:9414ec9:         // a new policy file. Construct a somewhat informative file name.
1:b0ec63d:         final File mergedPF = new File(varDir,
1:9414ec9:                 new File(policy2.getPath()).getName() +
1:9414ec9:                     "-MERGED_WITH-" +
1:9414ec9:                 new File(policy1.getPath()).getName());
1:9414ec9:         OutputStream o =
1:9414ec9:                 PrivilegedFileOpsForTests.getFileOutputStream(mergedPF);
1:9414ec9:         byte[] buf = new byte[1024];
1:9414ec9:         int read;
1:9414ec9:         InputStream i1 = openStream(policy1);
1:9414ec9:         while ((read = i1.read(buf)) != -1) {
1:9414ec9:             o.write(buf, 0, read);
1:9414ec9:         }
1:9414ec9:         i1.close();
1:9414ec9:         InputStream i2 = openStream(policy2);
1:9414ec9:         while ((read = i2.read(buf)) != -1) {
1:9414ec9:             o.write(buf, 0, read);
1:9414ec9:         }
1:9414ec9:         i2.close();
1:9414ec9:         o.close();
1:b0ec63d:         try {
1:2510115:             return AccessController.doPrivileged(
1:2510115:                         new PrivilegedExceptionAction<String>() {
1:2510115:                     public String run() throws MalformedURLException {
1:b0ec63d:                         return mergedPF.toURI().toURL().toExternalForm();
1:b0ec63d:                     }
1:b0ec63d:                 });
1:b0ec63d:         } catch (PrivilegedActionException pae) {
1:b0ec63d:             throw (MalformedURLException)pae.getException();
1:b0ec63d:         }
1:9414ec9:     }
1:9414ec9: 
1:9414ec9:     /** Opens the resource stream in a privileged block. */
1:9414ec9:     private static InputStream openStream(final URL resource)
1:9414ec9:             throws IOException {
1:9414ec9:         try {
1:2510115:             return AccessController.doPrivileged(
1:2510115:                     new PrivilegedExceptionAction<InputStream>(){
1:2510115:                         public InputStream run() throws IOException {
1:9414ec9:                             return resource.openStream();
1:9414ec9:                         }
1:9414ec9:                     }
1:9414ec9:                 );
1:9414ec9:         } catch (PrivilegedActionException pae) {
1:9414ec9:             throw (IOException)pae.getException();
1:9414ec9:         }
1:9414ec9:     }
1:9414ec9: 
1:9414ec9:     /** Creates the specified directory if it doesn't exist. */
1:9414ec9:     private static void mkdir(final File dir) {
1:9414ec9:         AccessController.doPrivileged(
1:2510115:             new PrivilegedAction<Void>() {
1:2510115:                 public Void run() {
1:9414ec9:                     if (!dir.exists() && !dir.mkdir()) {
1:9414ec9:                         fail("failed to create directory: " + dir.getPath());
1:9414ec9:                     }
1:9414ec9:                     return null;
1:9414ec9:                 }
1:9414ec9:             }
1:9414ec9:         );
1:9414ec9:     }
1:9414ec9: 
1:9414ec9:     /** Prints a debug message if debugging is enabled. */
1:9414ec9:     private static void println(String msg) {
1:9414ec9:         BaseTestCase.println("{SecurityManagerSetup} " + msg);
1:9414ec9:     }
1:7d98408: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c2ff5c7
/////////////////////////////////////////////////////////////////////////
1:                         // Check if some arbitrary class from jacocoagent.jar
1:                         // is available.
1: 
1:                         // If we got here, it means the tests are running
1:                         // under JaCoCo. Set the jacoco.active property to
1:                         // the empty string in order to activate the
1:                         // JaCoCo-specific permissions in derby_tests.policy,
1:                         // and return true.
1:                         System.setProperty("jacoco.active", "");
commit:4e26997
/////////////////////////////////////////////////////////////////////////
1:                     try {
1:                         Class.forName("org.jacoco.agent.rt.RT");
1:                         return true;
1:                     } catch (ClassNotFoundException e) {
1:                         return false;
1:                     } catch (LinkageError e) {
1:                         return false;
commit:6f9270a
/////////////////////////////////////////////////////////////////////////
1:         URL ant = getURL("org.apache.tools.ant.Task");
1:         if (ant != null) {
1:             classPathSet.setProperty("derbyTesting.ant", ant.toExternalForm());
1:         }
1: 
commit:2510115
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:                 public Boolean run() {
1:         });
/////////////////////////////////////////////////////////////////////////
1:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:                 public Void run() {
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(new PrivilegedAction<URL>() {
1: 			public URL run() {
/////////////////////////////////////////////////////////////////////////
1:              new PrivilegedAction<Void>()
1:                  public Void run() {
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                         new PrivilegedExceptionAction<String>() {
1:                     public String run() throws MalformedURLException {
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<InputStream>(){
1:                         public InputStream run() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             new PrivilegedAction<Void>() {
1:                 public Void run() {
commit:f16887a
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (externalSecurityManagerInstalled) {
1:             return new BaseTestSuite(
1:                 "skipped due to external security manager "
1:                 + test.toString());
1:         }
1: 
commit:38667d9
/////////////////////////////////////////////////////////////////////////
1:                     "org.apache.derby.jdbc.BasicClientDataSource40");
commit:c35e4f0
/////////////////////////////////////////////////////////////////////////
1:            URL client = getURL(
1:                     JDBC.vmSupportsJNDI() ?
1:                     "org.apache.derby.jdbc.ClientDataSource" :
0:                     "org.apache.derby.jdbc.NonJNDIClientDataSource40");
1: 
1:         }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:1447937
/////////////////////////////////////////////////////////////////////////
1: 		URL derby = getURL("org.apache.derby.jdbc.BasicEmbeddedDataSource40");
commit:d847ced
/////////////////////////////////////////////////////////////////////////
1:         // variables for lucene jar files
1:         URL luceneCore = getURL( "org.apache.lucene.store.FSDirectory" );
1:         if ( luceneCore != null )
1:         {
1:             classPathSet.setProperty( "derbyTesting.lucene.core", luceneCore.toExternalForm() );
1:             classPathSet.setProperty( "derbyTesting.lucene.core.jar.file", luceneCore.getFile() );
1:         }
1: 
commit:5570eb0
/////////////////////////////////////////////////////////////////////////
1: 	 * Location of derby.jar via org.apache.derby.jdbc.EmbeddedDataSource
/////////////////////////////////////////////////////////////////////////
0: 		URL derby = getURL("org.apache.derby.jdbc.EmbeddedDataSource");
commit:892e782
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 		// maybe the passed in resource was an URL to begin with
0: 		if ( policyURL == null )
1: 		{
0: 			try { policyURL = new URL( policyResource ); }
0: 			catch (Exception e) { System.out.println( "Unreadable url: " + policyResource ); }
1: 		}
1: 
commit:f35adc5
/////////////////////////////////////////////////////////////////////////
1: 			String  newPolicyProperty = set.getProperty("java.security.policy" );
1: 			if ( newPolicyProperty == null ) { newPolicyProperty = ""; } 
1:                                                    
1: 			String  oldPolicyProperty = BaseTestCase.getSystemProperty("java.security.policy");
1: 			if ( oldPolicyProperty == null ) { oldPolicyProperty = ""; }
1: 
0: 			if ( newPolicyProperty.equals( oldPolicyProperty ) ) { return; }
commit:59a5a70
/////////////////////////////////////////////////////////////////////////
0: 	public SecurityManagerSetup(Test test, String policyResource)
/////////////////////////////////////////////////////////////////////////
1:         else if ( !externalSecurityManagerInstalled )
1:         {
1:             uninstallSecurityManager();
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 			uninstallSecurityManager();
/////////////////////////////////////////////////////////////////////////
1: 
0:                 public Object run() {
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Remove the security manager.
1:      */
1:     private static void uninstallSecurityManager()
0:         throws PrivilegedActionException {
1: 
1:             AccessController.doPrivileged
1:             (
0:              new java.security.PrivilegedAction()
1:              {
0:                  public Object run() {
1:                      System.setSecurityManager(null);
1:                      return null;
1:                  }
1:              }
1:              );
1: 
1:     }
1: 
commit:e0f1ffe
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return the name of the default policy.
1:      */
0:     public static String getDefaultPolicy()
1:     {
1:         return "org/apache/derbyTesting/functionTests/util/derby_tests.policy";
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		installSecurityManager( getDefaultPolicy() );
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:305a23d
/////////////////////////////////////////////////////////////////////////
1:     static {
1:         // Work around bug in weme6.2 (DERBY-5558 and DERBY-6079).
1:         if (BaseTestCase.isJ9Platform()) {
1:             BaseTestCase.setSystemProperty("emma.active", "");
1:             BaseTestCase.setSystemProperty("jacoco.active", "");
1:         }
1:     }
1: 
commit:1e0c703
/////////////////////////////////////////////////////////////////////////
1: 
1:     static final boolean jacocoEnabled = checkIfJacocoIsRunning();
1:     private static boolean checkIfJacocoIsRunning() {
0:         return ((Boolean)AccessController.doPrivileged(new PrivilegedAction() {
0:                 public Object run() {
0:                     if (getURL("org.jacoco.agent.rt.RT") != null) {
0:                         System.setProperty("jacoco.active", "");
0:                         return Boolean.TRUE;
1:                     }
0:                     return Boolean.FALSE;
1:                 }
0: 		})).booleanValue();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         } catch (NoClassDefFoundError e) {
1:             return null;
commit:b0ec63d
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
0:         AccessController.doPrivileged(new PrivilegedAction() {
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             URL policyURL = getResourceURL(policyResource);
1:             set.setProperty("java.security.policy", policyURL.toExternalForm());
1:         } catch (MalformedURLException mue) {
1:             BaseTestCase.alarm("Unreadable policy URL: " + policyResource);
/////////////////////////////////////////////////////////////////////////
0:             AccessController.doPrivileged(new PrivilegedAction() {
/////////////////////////////////////////////////////////////////////////
0:              new PrivilegedAction()
/////////////////////////////////////////////////////////////////////////
1:         final File mergedPF = new File(varDir,
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             return (String)
0:                 AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                     public Object run() throws MalformedURLException {
1:                         return mergedPF.toURI().toURL().toExternalForm();
1:                     }
1:                 });
1:         } catch (PrivilegedActionException pae) {
1:             throw (MalformedURLException)pae.getException();
1:         }
/////////////////////////////////////////////////////////////////////////
0:                     new PrivilegedExceptionAction(){
/////////////////////////////////////////////////////////////////////////
0:             new PrivilegedAction(){
commit:ed505d0
/////////////////////////////////////////////////////////////////////////
1: import java.net.MalformedURLException;
/////////////////////////////////////////////////////////////////////////
1:             URL url1 = getResourceURL(policy1);
1:                 URL url2 = getResourceURL(policy2);
/////////////////////////////////////////////////////////////////////////
1:      * Returns a URL for the given policy resource.
1:      *
1:      * @param policy the policy resource
1:      * @return A {@code URL} denoting the policy resource.
1:      * @throws MalformedURLException if the resource string not a valid URL
1:      */
1:     private static URL getResourceURL(final String policy)
1:             throws MalformedURLException {
1:         URL url = BaseTestCase.getTestResource(policy);
1:         if (url == null) {
1:             // Assume the policy is expressed as an URL already, probably
1:             // as a file.
1:             url =  new URL(policy);
1:         }
1:         return url;       
1:     }
1: 
1:     /**
commit:e138316
/////////////////////////////////////////////////////////////////////////
1:      * @return The location of a policy resource, or {@linkplain #NO_POLICY}.
1:         String resource = policy1;
1:         if (!NO_POLICY.equals(resource)) {
0:             URL url1 = BaseTestCase.getTestResource(policy1);
1:             resource = url1.toExternalForm();
1:             if (policy2 != null) {
0:                 URL url2 = BaseTestCase.getTestResource(policy2);
1:                 // Don't use URL.equals - it blocks and goes onto the network.
1:                 if (!url1.toExternalForm().equals(url2.toExternalForm())) {
1:                     resource = mergePolicies(url1, url2);
1:                 }
commit:9414ec9
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.security.PrivilegedActionException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1: 
1:  * Configures the wrapped test to be run with the specified security policy.
1:  * <p>
1:  * This setup class normally installs the default policy file. This can be
1:  * overridden by specifying {@literal java.security.policy=<NONE>} (see
1:  * {@linkplain #NO_POLICY}), and can also be overridden by installing a
1:  * security manager explicitly before the default security manager is installed.
1:  * <p>
1:  * Individual tests/suites can be configured to be run without a security
1:  * manager, with a specific policy file, or with a specific policy file merged
1:  * with the default policy file. The last option is useful when you only need
1:  * to extend the default policy with a few extra permissions to run a test.
1: 
/////////////////////////////////////////////////////////////////////////
1:     /** An additional policy to install (may be {@code null}). */
1:     private final String additionalPolicyResource;
1:     public SecurityManagerSetup(Test test, String policyResource) {
1:         this(test, policyResource, false);
1:     }
1: 
1:     /**
1:      * Installs a new security policy.
1:      *
1:      * @param test the test to wrap
1:      * @param policyResource the policy to install
1:      * @param mergePolicies if {@code false} the specified policy will be the
1:      *      only policy installed, if {@code true} the specified policy will be
1:      *      merged with the default test policy for the test framework
1:      */
1:     public SecurityManagerSetup(Test test, String policyResource,
1:                                 boolean mergePolicies) {
1:         super(test);
1:         if (mergePolicies) {
1:             // By choice, only support merging with the default test policy.
1:             this.decoratorPolicyResource = getDefaultPolicy();
1:             this.additionalPolicyResource = policyResource;
1:         } else {
1:             this.additionalPolicyResource = null;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         this(test, policyResource, false);
/////////////////////////////////////////////////////////////////////////
1:     protected void setUp()
1:             throws IOException {
1:         String resource = getEffectivePolicyResource(
1:                 decoratorPolicyResource, additionalPolicyResource);
1:         installSecurityManager(resource, decoratorSecurityManager);
/////////////////////////////////////////////////////////////////////////
1:     private static String getDefaultPolicy()
/////////////////////////////////////////////////////////////////////////
1:         println("installed policy " + policyFile);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the location of the effective policy resource.
1:      * <p>
1:      * If two valid policy resources from different locations are specified,
1:      * they will be merged into one policy file.
1:      *
1:      * @param policy1 first policy
1:      * @param policy2 second policy (may be {@code null})
0:      * @return The location of a policy resource.
1:      * @throws IOException if reading or writing a policy resource fails
1:      */
1:     private static String getEffectivePolicyResource(String policy1,
1:                                                      String policy2)
1:             throws IOException {
0:         URL url1 = BaseTestCase.getTestResource(policy1);
0:         String resource = url1.toExternalForm();
0:         if (policy2 != null) {
0:             URL url2 = BaseTestCase.getTestResource(policy2);
0:             // Don't use URL.equals - it blocks and goes onto the network.
0:             if (!url1.toExternalForm().equals(url2.toExternalForm())) {
0:                 resource = mergePolicies(url1, url2);
1:             }
1:         }
1:         return resource;
1:     }
1: 
1:     /**
1:      * Merges the two specified policy resources (typically files), and writes
1:      * the combined policy to a new file.
1:      *
1:      * @param policy1 the first policy
1:      * @param policy2 the second policy
1:      * @return The resource location string for a policy file.
1:      * @throws IOException if reading or writing to one of the resources fails
1:      */
1:     private static String mergePolicies(URL policy1, URL policy2)
1:             throws IOException {
1:         // Create target directory for the merged policy files.
1:         String sytemHome =
1:                 BaseTestCase.getSystemProperty("derby.system.home");
1:         File sysDir = new File(sytemHome == null ? "system" : sytemHome);
1:         File varDir = new File(sysDir, "var");
1:         // If running as the first test the system directory may not exist.
1:         // This situation looks a little bit suspicious - investigate?
1:         mkdir(sysDir);
1:         mkdir(varDir);
1: 
1:         // Read the contents of both policy files and write them out to
1:         // a new policy file. Construct a somewhat informative file name.
0:         File mergedPF = new File(varDir,
1:                 new File(policy2.getPath()).getName() +
1:                     "-MERGED_WITH-" +
1:                 new File(policy1.getPath()).getName());
1:         OutputStream o =
1:                 PrivilegedFileOpsForTests.getFileOutputStream(mergedPF);
1:         byte[] buf = new byte[1024];
1:         int read;
1:         InputStream i1 = openStream(policy1);
1:         while ((read = i1.read(buf)) != -1) {
1:             o.write(buf, 0, read);
1:         }
1:         i1.close();
1:         InputStream i2 = openStream(policy2);
1:         while ((read = i2.read(buf)) != -1) {
1:             o.write(buf, 0, read);
1:         }
1:         i2.close();
1:         o.close();
0:         return mergedPF.toURI().toURL().toExternalForm();
1:     }
1: 
1:     /** Opens the resource stream in a privileged block. */
1:     private static InputStream openStream(final URL resource)
1:             throws IOException {
1:         try {
0:             return (InputStream)AccessController.doPrivileged(
0:                     new java.security.PrivilegedExceptionAction(){
0:                         public Object run() throws IOException {
1:                             return resource.openStream();
1:                         }
1:                     }
1:                 );
1:         } catch (PrivilegedActionException pae) {
1:             throw (IOException)pae.getException();
1:         }
1:     }
1: 
1:     /** Creates the specified directory if it doesn't exist. */
1:     private static void mkdir(final File dir) {
1:         AccessController.doPrivileged(
0:             new java.security.PrivilegedAction(){
0:                 public Object run(){
1:                     if (!dir.exists() && !dir.mkdir()) {
1:                         fail("failed to create directory: " + dir.getPath());
1:                     }
1:                     return null;
1:                 }
1:             }
1:         );
1:     }
1: 
1:     /** Prints a debug message if debugging is enabled. */
1:     private static void println(String msg) {
1:         BaseTestCase.println("{SecurityManagerSetup} " + msg);
1:     }
commit:e6ffa2a
/////////////////////////////////////////////////////////////////////////
1:  * Derby - Class org.apache.derbyTesting.junit.SecurityManagerSetup
/////////////////////////////////////////////////////////////////////////
1:     /** Constant used to indicate that no security policy is to be installed. */
1:     static final String NO_POLICY = "<NONE>";
1: 
/////////////////////////////////////////////////////////////////////////
1:         return new SecurityManagerSetup(test, NO_POLICY);
/////////////////////////////////////////////////////////////////////////
1:         installSecurityManager(NO_POLICY);
1:      * Install specific policy file with the security manager
/////////////////////////////////////////////////////////////////////////
1:         if (NO_POLICY.equals(decoratorPolicyResource))
/////////////////////////////////////////////////////////////////////////
1:         if (NO_POLICY.equals(set.getProperty("java.security.policy")))
/////////////////////////////////////////////////////////////////////////
1:         if (NO_POLICY.equals(policyResource)) {
commit:73122ce
/////////////////////////////////////////////////////////////////////////
1:         URL ppTesting = null;
1:         // Only try to load PackagePrivateTestSuite if the running JVM is
1:         // Java 1.5 or newer (class version 49 = Java 1.5).
1:         if (BaseTestCase.getClassVersionMajor() >= 49) {
1:             ppTesting = getURL("org.apache.derby.PackagePrivateTestSuite");
1:         }
commit:463fe16
/////////////////////////////////////////////////////////////////////////
1:      * <BR>
1:      * derbyTesting.ppcodeclasses set to URL of the 'classes.pptesting' folder
1:      * if it exists on the classpath. The existence of the package private tests
1:      * is determined via org.apache.derby.PackagePrivateTestSuite
/////////////////////////////////////////////////////////////////////////
0:         URL ppTesting = getURL("org.apache.derby.PackagePrivateTestSuite");
1:             // ppTesting can be null, for instance if 'classes.pptesting' is
1:             // not on the classpath.
1:             if (ppTesting != null) {
1:                 classPathSet.setProperty("derbyTesting.ppcodeclasses",
1:                     ppTesting.toExternalForm());
1:             }
commit:9c86d82
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1690ef6
/////////////////////////////////////////////////////////////////////////
1: 	private SecurityManager decoratorSecurityManager = null;
1: 	
0:         public SecurityManagerSetup(Test test, String policyResource)
1:         {
0:             super(test);
1:             this.decoratorPolicyResource = policyResource != null ?
1:                     policyResource : getDefaultPolicy();
1:         }
1: 
1: 	/**
1: 	 * Use custom policy and SecurityManager
1: 	 * 
1: 	 * @param test - Test to wrap
1: 	 * @param policyResource - policy resource. If null use default testing policy
1: 	 * @param securityManager - Custom SecurityManager if null use the system security manager
1: 	 */
1: 	public SecurityManagerSetup(Test test, String policyResource, SecurityManager securityManager)
1: 		this.decoratorPolicyResource = policyResource != null ?
1: 		            policyResource : getDefaultPolicy();
1: 		this.decoratorSecurityManager = securityManager;
/////////////////////////////////////////////////////////////////////////
0: 		installSecurityManager(decoratorPolicyResource, decoratorSecurityManager);
/////////////////////////////////////////////////////////////////////////
1: 	private static void installSecurityManager(String policyFile) {
1: 	   installSecurityManager(policyFile, System.getSecurityManager());
1: 	}
1: 
1: 	private static void installSecurityManager(String policyFile, final SecurityManager sm)
1: 			 {
1: 	    
1: 		SecurityManager currentsm = System.getSecurityManager();
1: 		if (currentsm != null) {
1: 			SecurityManager oldSecMan = System.getSecurityManager();
1: 			if ( newPolicyProperty.equals( oldPolicyProperty ) &&
1: 			        oldSecMan == sm) { return; }
/////////////////////////////////////////////////////////////////////////
1:                     if (sm == null)
1:                         System.setSecurityManager(new SecurityManager());
1:                     else
1:                         System.setSecurityManager(sm);
commit:7d10f01
/////////////////////////////////////////////////////////////////////////
0:                     System.setSecurityManager(sm);
1:                     Policy.getPolicy().refresh();
1:                     return null;
1:                 }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ce9c46e
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Does the JVM support Subjects for
1:      * authorization through Java security manager.
1:      * J2ME/CDC/Foundation 1.1 does not support Subjects.
1:      */
1:     public static final boolean JVM_HAS_SUBJECT_AUTHORIZATION;
1:     static {
1:         JVM_HAS_SUBJECT_AUTHORIZATION = JDBC.haveClass("javax.security.auth.Subject");
1:     }
1:     
commit:b5f6067
/////////////////////////////////////////////////////////////////////////
1:         // Load indirectly, normally no EMMA jars in the classpath.
1:         // This property is needed to set correct permissions in policy files.
1:         URL emma = getURL("com.vladium.emma.EMMAException");
1:         if (emma != null) {
1:             classPathSet.setProperty("emma.active", "");
0:             classPathSet.setProperty("derbyTesting.emma", emma.toExternalForm());
1:         }
commit:23c0fed
/////////////////////////////////////////////////////////////////////////
1: import java.security.Policy;
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param test Test to run without a security manager. Note that
1:      * this must be an instance of BaseTestCase as this call depends
1:      * on setup code in that class. Arbitrary Test instances cannot be passed in.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     SecurityManager sm = new SecurityManager();
0: 				System.setSecurityManager(sm);
1:  				return null;
/////////////////////////////////////////////////////////////////////////
0: 		if (policyURL != null) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:                       System.setSecurityManager(null);
commit:74c2b8d
/////////////////////////////////////////////////////////////////////////
0: 			return new TestSuite("skipped due to external security manager "
0:                     + test.toString());
/////////////////////////////////////////////////////////////////////////
0: 			return new TestSuite("skipped due to external security manager "
0:                     + tSetup.toString());
1: 	 * "Install" no security manager.
1: 	static void noSecurityManager()
/////////////////////////////////////////////////////////////////////////
0: 	protected void setUp() {
/////////////////////////////////////////////////////////////////////////
1: 	static void installSecurityManager()
1: 			 {
/////////////////////////////////////////////////////////////////////////
1: 			String policyResource)
/////////////////////////////////////////////////////////////////////////
1:     {
commit:21a3353
/////////////////////////////////////////////////////////////////////////
1:         URL junit = getURL(junit.framework.Test.class);
1:         if (junit != null)
1:             classPathSet.setProperty("derbyTesting.junit", junit.toExternalForm());
1:         // Load indirectly so we don't need ant-junit.jar at compile time.
1:         URL antjunit = getURL("org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner");
1:         if (antjunit != null)
1:             classPathSet.setProperty("derbyTesting.antjunit", antjunit.toExternalForm());
1: 
/////////////////////////////////////////////////////////////////////////
0: 		URL derby = getURL("org.apache.derby.jdbc.EmbeddedSimpleDataSource");
1:         if (derby != null)
1: 		    classPathSet.setProperty("derbyTesting.codejar", stripJar(derby));
0: 		URL client = getURL("org.apache.derby.jdbc.ClientDataSource");
0: 		if (client != null)
1: 		    classPathSet.setProperty("derbyTesting.clientjar", stripJar(client));
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get the URL of the code base from a class name.
1:      * If the class cannot be loaded, null is returned.
1:      */
0:     static URL getURL(String className) {
1:         try {
1:             return getURL(Class.forName(className));
1:         } catch (ClassNotFoundException e) {
1:             return null;
1:         }
1:     }
1: 	static URL getURL(final Class cl)
commit:36d1b35
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected void tearDown() throws Exception
1:     {
0:         if ("<NONE>".equals(decoratorPolicyResource))
1:             BaseTestCase.setSystemProperty("java.security.policy", "");
1:     }
commit:348cafe
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1: 	 * derbyTesting.codeclasses set to URL of classes folder
1: 	 * derbyTesting.codejar - URL of derby.jar,
1: 	 * derbyTesting.clientjar - URL of derbyclient.jar
1: 	 * derbyTesting.testjar - URL of derbyTesting.jar
1:      * <BR>
1:      * derbyTesting.testjarpath - File system path to derbyTesting.jar
1:      * if the jar has a URL with a file protocol.
/////////////////////////////////////////////////////////////////////////
1:         if (testing.getProtocol().equals("file")) {
1:            File f = new File(testing.getPath());
1:            classPathSet.setProperty("derbyTesting.testjarpath",
1:                                                f.getAbsolutePath());
1:         }
commit:424cdbd
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0: 	 * Location of derby.jar via org.apache.derby.jdbc.EmbeddedSimpleDataSource
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return the policy file system properties for use
1:      * by the old test harness. This ensures a consistent
1:      * approach to setting the properties. There are the
1:      * properties used to define the jar file location in
1:      * any policy files.
0:      * @return
1:      */
1:     public static Properties getPolicyFilePropertiesForOldHarness()
1:     {
1:         return classPathSet;
1:     }
commit:3ec94a5
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * True if the classes are loaded from jars.
1:      */
1:     static boolean isJars;
/////////////////////////////////////////////////////////////////////////
1:             isJars = false;
1:         isJars = true;
0: 			derby = getURL(org.apache.derby.jdbc.EmbeddedSimpleDataSource.class);
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.junit;
/////////////////////////////////////////////////////////////////////////
1: 
commit:dd07790
/////////////////////////////////////////////////////////////////////////
1: 	 * Install a SecurityManager with the default test policy
1: 	 * file:
1: 	 * org/apache/derbyTesting/functionTests/util/derby_tests.policy
1: 	 * 
1: 	 */
0: 	static void noSecurityManager() throws PrivilegedActionException
1: 	{
0: 		installSecurityManager("<NONE>");
1: 	}
1: 	
1: 	/**
/////////////////////////////////////////////////////////////////////////
0: 		if ("<NONE>".equals(policyResource)) {
1: 			set.setProperty("java.security.policy", policyResource);
1: 			return;
1: 		}
commit:7d98408
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
0:  * Derby - Class org.apache.derbyTesting.functionTests.util.SecurityManagerSetup
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its 
0:  * licensors, as applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
0: package org.apache.derbyTesting.functionTests.util;
1: 
1: import java.net.URL;
1: import java.security.AccessController;
0: import java.security.PrivilegedActionException;
1: import java.util.Enumeration;
1: import java.util.Properties;
1: 
1: import junit.extensions.TestSetup;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
0:  * Setup for running Derby JUnit tests with the SecurityManager
0:  * which is the default for tests.
1:  *
1:  */
1: public final class SecurityManagerSetup extends TestSetup {
1: 	
1: 	
1: 	private static final Properties classPathSet = new Properties();
1: 	
1: 	/**
1: 	 * True if a security manager was installed outside of the
1: 	 * control of this class and BaseTestCase.
1: 	 */
1: 	private static final boolean externalSecurityManagerInstalled;
1: 	
1: 	static {
1: 		// Determine what the set of properties
1: 		// describing the environment is.
1: 		externalSecurityManagerInstalled = determineClasspath();
1: 	}
1: 	
1: 	private final String decoratorPolicyResource;
0: 	private SecurityManagerSetup(Test test, String policyResource)
1: 	{
0: 		super(test);
0: 		this.decoratorPolicyResource = policyResource;
1: 	}
1: 	
1: 	/**
1: 	 * Get a decorator that will ensure no security manger
1: 	 * is installed to run a test. Not supported for suites.
1: 	 * <BR>
1: 	 * An empty suite is returned if a security manager was installed
1: 	 * externally, i.e. not under the control of the BaseTestCase
1: 	 * and this code. In this case the code can not support the
1: 	 * mode of no security manager as it may not have enough information
1: 	 * to re-install the security manager. So the passed in test
1: 	 * will be skipped.
1: 	 */
0: 	public static Test noSecurityManager(BaseTestCase test)
1: 	{
1: 		if (externalSecurityManagerInstalled)
0: 			return new TestSuite();
0: 		return new SecurityManagerSetup(test, "<NONE>");
1: 	}
1: 	
1: 	/**
0: 	 * Install specific polciy file with the security manager
1: 	 * including the special case of no security manager.
1: 	 */
0: 	protected void setUp() throws PrivilegedActionException {
0: 		installSecurityManager(decoratorPolicyResource);
1: 	}
1: 	
1: 	/**
0: 	 * Install a SecurityManager with the default test policy
0: 	 * file:
0: 	 * org/apache/derbyTesting/functionTests/util/derby_tests.policy
1: 	 * 
1: 	 */
0: 	static void installSecurityManager() throws PrivilegedActionException
1: 	{
0: 		installSecurityManager(
0: 				"org/apache/derbyTesting/functionTests/util/derby_tests.policy");
1: 				
1: 	}
1: 	
0: 	private static void installSecurityManager(String policyFile)
0: 			throws PrivilegedActionException {
1: 		
1: 		if (externalSecurityManagerInstalled)
1: 			return;
1: 		
1: 		Properties set = new Properties(classPathSet);
1: 		setSecurityPolicy(set, policyFile);
1: 
0: 		SecurityManager sm = System.getSecurityManager();
0: 		if (sm != null) {
1: 			// SecurityManager installed, see if it has the same settings.
1: 
0: 			if (set.getProperty("java.security.policy").equals(
0: 					BaseTestCase.getSystemProperty("java.security.policy")))
1: 					return;
1: 			
1: 			// Uninstall the current manager.
0: 			AccessController.doPrivileged(new java.security.PrivilegedAction() {
1: 
0: 				public Object run() {
0: 					System.setSecurityManager(null);
0: 					return null;
1: 				}
1: 			});
1: 		}
1: 		
1: 		// Set the system properties from the desired set.
1: 		for (Enumeration e = set.propertyNames(); e.hasMoreElements();) {
1: 			String key = (String) e.nextElement();
1: 			BaseTestCase.setSystemProperty(key, set.getProperty(key));
1: 		}
1: 		
1: 		// Check indicator for no security manager
0: 		if ("<NONE>".equals(set.getProperty("java.security.policy")))
1: 			return;
1: 		
1: 		// and install
0: 		AccessController.doPrivileged(new java.security.PrivilegedAction() {
1: 
0: 			public Object run() {
0: 				System.setSecurityManager(new SecurityManager());
0: 				return null;
1: 			}
1: 		});
1: 
1: 	}
1: 	
1: 	private static void setSecurityPolicy(Properties set,
0: 			String policyResource) throws PrivilegedActionException
1: 	{
0: 		URL policyURL = BaseTestCase.getTestResource(policyResource);
1: 
0: 		if (policyURL != null)
0: 			set.setProperty("java.security.policy",
0: 					policyURL.toExternalForm());
1: 	}
1: 
1: 	
1: 	/**
1: 	 * Determine the settings of the classpath in order to configure
1: 	 * the variables used in the testing policy files.
1: 	 * Looks for three items:
1: 	 * 
1: 	 * Location of derbyTesting.jar via this class
0: 	 * Location of derby.jar via org.apache.derby.jdbc.EmbeddedDataSource
1: 	 * Location of derbyclient.jar via org.apache.derby.jdbc.ClientDataSource
1: 	 * 
1: 	 * Two options are supported, either all are in jar files or
1: 	 * all are on the classpath. Properties are set as follows:
1: 	 * 
1: 	 * <P>
1: 	 * Classpath:
1: 	 * <BR>
0: 	 * derbyTesting.codeclasses set to location of classes folder
1: 	 * <P>
1: 	 * Jar files:
1: 	 * <BR>
0: 	 * derbyTesting.codejar - location of derby.jar,
1: 	 * derbynet.jar and derbytools.jar, all assumed to be in the
1: 	 * same location.
1: 	 * <BR>
0: 	 * derbyTesting.clientjar - location of derbyclient.jar (FUTURE)
1: 	 * <BR>
0: 	 * derbyTesting.testjar - location of derbyTesting.jar (FUTURE)
1: 	 * 
1: 	 */
1: 	private static boolean determineClasspath()
1: 	{
1: 		// Security manager already installed, assume that
1: 		// it is set up correctly.
1: 		if (System.getSecurityManager() != null) {		
1: 			return true;
1: 		}
1: 		
1: 		URL testing = getURL(SecurityManagerSetup.class);
1: 		
1: 		boolean isClasspath = testing.toExternalForm().endsWith("/");
1: 		if (isClasspath) {
1: 			classPathSet.setProperty("derbyTesting.codeclasses",
1: 					testing.toExternalForm());
1: 			return false;
1: 		}
1: 		classPathSet.setProperty("derbyTesting.testjar", stripJar(testing));
1: 		
0: 		URL derby = null;
0: 		try {
0: 			derby = getURL(org.apache.derby.jdbc.EmbeddedDataSource.class);
0: 		} catch (java.lang.NoClassDefFoundError e) {
0: 			derby = testing;
1: 		}		
0: 		classPathSet.setProperty("derbyTesting.codejar", stripJar(derby));
1: 
0: 		URL client = null;
0: 		try {
0: 			client = getURL(org.apache.derby.jdbc.ClientDataSource.class);
0: 		} catch (java.lang.NoClassDefFoundError e) {
0: 			client = derby;
1: 		}
1: 		
0: 		classPathSet.setProperty("derbyTesting.clientjar", stripJar(client));
1: 		
1: 		return false;
1: 	}
1: 	
1: 	/**
0: 	 * Strip of the last token which will be the jar name.
1: 	 * The returned string includes the trailing slash.
1: 	 * @param url
0: 	 * @return
1: 	 */
1: 	private static String stripJar(URL url)
1: 	{
1: 		String ef = url.toExternalForm();
1: 		return ef.substring(0, ef.lastIndexOf('/') + 1);
1: 	}
1: 	
1: 	/**
1: 	 * Get the URL of the code base from a class.
1: 	 */
0: 	private static URL getURL(final Class cl)
1: 	{
0: 		return (URL)
0: 		   AccessController.doPrivileged(new java.security.PrivilegedAction() {
1: 
0: 			public Object run() {
1: 				return cl.getProtectionDomain().getCodeSource().getLocation();
1: 			}
1: 		});
1: 	}
1: }
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:676af8f
/////////////////////////////////////////////////////////////////////////
1:     public static URL getURL(String className) {
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * Strip off the last token which will be the jar name.
1: 	 * @return the jar name from the URL as a String
commit:912793e
/////////////////////////////////////////////////////////////////////////
1: 	public static Test noSecurityManager(Test test)
commit:8766228
/////////////////////////////////////////////////////////////////////////
0: 
1: 		//We need the junit classes to instantiate this class, so the
1: 		//following should not cause runtime errors.
0:         URL junit = null;
0:         junit = getURL(junit.framework.Test.class);
0:         classPathSet.setProperty("derbyTesting.junit", junit == null ? "" : junit.toString());
0: 	
0:         URL antjunit = null;
0:         Class antjunitclass = null;
0:         try {
0:         	// Load indirectly so we don't need ant-junit.jar at compile time.
0:             antjunitclass = Class.forName("org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner");
0:             antjunit = getURL(antjunitclass);
0:             classPathSet.setProperty("derbyTesting.antjunit", antjunit == null ? "" : antjunit.toString());
0:         } catch (java.lang.ClassNotFoundException e) {
0:         	// Not running in Ant, do nothing.
0:             antjunit = null;
0:         }
/////////////////////////////////////////////////////////////////////////
0: 	
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:1a1fb6a
/////////////////////////////////////////////////////////////////////////
1: 		// if we attempt to check on availability of the ClientDataSource with 
1: 		// JSR169, attempts will be made to load classes not supported in
1: 		// that environment, such as javax.naming.Referenceable. See DERBY-2269.
1: 		if (!JDBC.vmSupportsJSR169()) {
0: 		    URL client = getURL("org.apache.derby.jdbc.ClientDataSource");
1: 		    if(client != null)
0: 		        classPathSet.setProperty("derbyTesting.clientjar", stripJar(client));
0: 		}
author:Army
-------------------------------------------------------------------------------
commit:f7abbf4
/////////////////////////////////////////////////////////////////////////
1:         /* When inserting XML values that use external DTD's, the JAXP
1:          * parser needs permission to read the DTD files.  So here we set
1:          * a property to hold the location of the JAXP implementation
1:          * jar file.  We can then grant the JAXP impl the permissions
1:          * needed for reading the DTD files.
1:          */
1:         String jaxp = XML.getJAXPParserLocation();
1:         if (jaxp != null)
1:             classPathSet.setProperty("derbyTesting.jaxpjar", jaxp);
0: 
/////////////////////////////////////////////////////////////////////////
0: 	protected static URL getURL(final Class cl)
0: 
1:                 /* It's possible that the class does not have a "codeSource"
1:                  * associated with it (ex. if it is embedded within the JVM,
1:                  * as can happen with Xalan and/or a JAXP parser), so in that
1:                  * case we just return null.
1:                  */
1:                 if (cl.getProtectionDomain().getCodeSource() == null)
0:                     return null;
0: 
commit:de7372b
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Same as noSecurityManager() above but takes a TestSetup
0:      * instead of a BaseTestCase.
0:      */
0:     public static Test noSecurityManager(TestSetup tSetup)
0:     {
0: 		if (externalSecurityManagerInstalled)
0: 			return new TestSuite();
0: 		return new SecurityManagerSetup(tSetup, "<NONE>");
0:     }
0: 
============================================================================