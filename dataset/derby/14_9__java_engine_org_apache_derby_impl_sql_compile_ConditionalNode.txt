3:eac0369: /*
1:4a90a32: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ConditionalNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
7:eac0369:  */
33:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:f33fbaf: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:2bd5cbd: import org.apache.derby.iapi.sql.compile.Visitable;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A ConditionalNode represents an if/then/else operator with a single
1:eac0369:  * boolean expression on the "left" of the operator and a list of expressions on 
1:eac0369:  * the "right". This is used to represent the java conditional (aka immediate if).
1:4a90a32:  *
1:4a90a32:  */
1:eac0369: 
1:3bb140c: class ConditionalNode extends ValueNode
17:eac0369: {
1:2455f1a:     /**
1:2455f1a:      * The case operand if this is a simple case expression. Otherwise, it
1:2455f1a:      * is {@code null}.
1:2455f1a:      */
1:f2dfe06:     private CachedValueNode caseOperand;
1:2455f1a: 
1:5d7388d:     /** The list of test conditions in the WHEN clauses. */
1:5d7388d:     private ValueNodeList testConditions;
1:5d7388d: 
1:5d7388d:     /**
1:5d7388d:      * The list of corresponding THEN expressions to the test conditions in
1:5d7388d:      * {@link #testConditions}. The last element represents the ELSE clause.
1:5d7388d:      */
1:5d7388d:     private ValueNodeList thenElseList;
1:e671fc7: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a ConditionalNode
1:4a90a32: 	 *
1:2455f1a:      * @param caseOperand       The case operand if this is a simple case
1:2455f1a:      *                          expression, or {@code null} otherwise
1:5d7388d:      * @param testConditions    The boolean test conditions
1:eac0369: 	 * @param thenElseList		ValueNodeList with then and else expressions
1:3bb140c:      * @param cm                The context manager
1:eac0369: 	 */
1:f2dfe06:     ConditionalNode(CachedValueNode caseOperand,
1:2455f1a:                     ValueNodeList testConditions,
1:3bb140c:                     ValueNodeList thenElseList,
1:3bb140c:                     ContextManager cm)
1:eac0369: 	{
1:3bb140c:         super(cm);
1:2455f1a:         this.caseOperand = caseOperand;
1:5d7388d:         this.testConditions = testConditions;
1:3bb140c:         this.thenElseList = thenElseList;
17:eac0369: 	}
1:5d7388d: 
1:01217c2: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
5:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:01217c2: 	 */
1:e1f49ca:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:01217c2: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:01217c2: 		{
1:eac0369: 			super.printSubNodes(depth);
1:01217c2: 
1:5d7388d:             if (testConditions != null)
1:01217c2: 			{
1:5d7388d:                 printLabel(depth, "testConditions: ");
1:5d7388d:                 testConditions.treePrint(depth + 1);
1:5d7388d: 			}
1:eac0369: 
1:eac0369: 			if (thenElseList != null)
1:01217c2: 			{
1:eac0369: 				printLabel(depth, "thenElseList: ");
1:eac0369: 				thenElseList.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:5d7388d:      * This method makes sure any SQL NULLs will be cast to the correct type.
1:eac0369: 	 *
1:fa3b425: 	 * @param castType        The type to cast SQL parsed NULL's too.
1:78cb2da: 	 * @param fromList        FromList to pass on to bindExpression if recast is performed
1:78cb2da: 	 * @param subqueryList    SubqueryList to pass on to bindExpression if recast is performed
1:09c2697:      * @param aggregates      List of aggregates to pass on to bindExpression if recast is performed
1:eac0369: 	 *
2:fa3b425: 	 * @exception             StandardException Thrown on error.
1:eac0369: 	 */
1:5d7388d:     private void recastNullNodes(
1:78cb2da: 	                           DataTypeDescriptor castType, FromList fromList,
1:71c8e86:                                SubqueryList subqueryList, List<AggregateNode> aggregates)
1:fa3b425: 	 throws StandardException {
1:eac0369: 
1:78cb2da: 		// need to have nullNodes nullable
1:7a361f2: 		castType = castType.getNullabilityType(true);
1:eac0369: 
1:5d7388d:         for (int i = 0; i < thenElseList.size(); i++) {
1:5d7388d:             ValueNode vn = thenElseList.elementAt(i);
1:5d7388d:             if (vn instanceof UntypedNullConstantNode) {
1:5d7388d:                 CastNode cast = new CastNode(vn, castType, getContextManager());
1:5d7388d:                 cast.bindExpression(fromList, subqueryList, aggregates);
1:5d7388d:                 thenElseList.setElementAt(cast, i);
1:5d7388d:             }
1:5d7388d:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This means binding the sub-expressions,
1:eac0369: 	 * as well as figuring out what the return type is for this expression.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:eac0369: 	 *				expression is in, for binding columns.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:71c8e86:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 			throws StandardException
1:01217c2: 	{
1:e671fc7:         CompilerContext cc = getCompilerContext();
1:e671fc7:         
1:e671fc7:         int previousReliability = orReliability( CompilerContext.CONDITIONAL_RESTRICTION );
1:2455f1a: 
1:2bd5cbd:         ValueNodeList caseOperandParameters =
1:2bd5cbd:                 bindCaseOperand(cc, fromList, subqueryList, aggregates);
1:2455f1a: 
1:5d7388d:         testConditions.bindExpression(fromList,
4:eac0369: 			subqueryList,
1:09c2697:             aggregates);
1:eac0369: 
1:2bd5cbd:         // If we have a simple case expression in which the case operand
1:2bd5cbd:         // requires type from context (typically because it's an untyped
1:2bd5cbd:         // parameter), find out which type best describes it.
1:2bd5cbd:         if (caseOperandParameters != null) {
1:2bd5cbd: 
1:2bd5cbd:             // Go through all the dummy parameter nodes that bindCaseOperand()
1:2bd5cbd:             // inserted into the synthetic test conditions. Each of them will
1:2bd5cbd:             // have been given the type of the corresponding when operand
1:2bd5cbd:             // when testConditions was bound.
1:2bd5cbd:             for (ValueNode vn : caseOperandParameters) {
1:2bd5cbd:                 // Check that this parameter is comparable to all the other
1:2bd5cbd:                 // parameters in the list. This indirectly checks whether
1:2bd5cbd:                 // all when operands have compatible types.
1:2bd5cbd:                 caseOperandParameters.comparable(vn);
1:2bd5cbd: 
1:2bd5cbd:                 // Replace the dummy parameter node with the actual case
1:2bd5cbd:                 // operand.
1:2bd5cbd:                 testConditions.accept(new ReplaceNodeVisitor(vn, caseOperand));
1:2bd5cbd:             }
1:2bd5cbd: 
1:2bd5cbd:             // Finally, after we have determined that all the when operands
1:2bd5cbd:             // are compatible, and we have reinserted the case operand into
1:2bd5cbd:             // the tree, set the type of the case operand to the dominant
1:2bd5cbd:             // type of all the when operands.
1:2bd5cbd:             caseOperand.setType(
1:2bd5cbd:                     caseOperandParameters.getDominantTypeServices());
1:2bd5cbd:         }
1:2bd5cbd: 
1:6f52e78:         thenElseList.bindExpression(fromList, subqueryList, aggregates);
1:6f52e78: 
1:6f52e78:         // Find the type of the first typed value in thenElseList and cast
1:6f52e78:         // all untyped NULL values to that type. We don't need to find the
1:6f52e78:         // dominant type here, since a top-level cast to that type will be
1:6f52e78:         // added later, if necessary.
1:6f52e78:         DataTypeDescriptor nullType = thenElseList.getTypeServices();
1:6f52e78:         if (nullType == null) {
1:6f52e78:             // There are no values with a known type in the list. Raise
1:6f52e78:             // an error.
1:6f52e78:             throw StandardException.newException(
1:6f52e78:                     SQLState.LANG_ALL_RESULT_EXPRESSIONS_UNTYPED);
1:6f52e78:         } else {
1:6f52e78:             recastNullNodes(nullType, fromList, subqueryList, aggregates);
1:6f52e78:         }
1:eac0369: 
1:5d7388d:         // Set the result type of this conditional to be the dominant type
1:5d7388d:         // of the result expressions.
1:5d7388d:         setType(thenElseList.getDominantTypeServices());
1:eac0369: 
1:eac0369: 		/* testCondition must be a boolean expression.
1:eac0369: 		 * If it is a ? parameter on the left, then set type to boolean,
1:eac0369: 		 * otherwise verify that the result type is boolean.
1:eac0369: 		 */
1:5d7388d:         testConditions.setParameterDescriptor(
1:5d7388d:                 new DataTypeDescriptor(TypeId.BOOLEAN_ID, true));
1:5d7388d: 
1:5d7388d:         for (ValueNode testCondition : testConditions) {
1:eac0369: 			if ( ! testCondition.getTypeServices().getTypeId().equals(
1:eac0369: 														TypeId.BOOLEAN_ID))
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_CONDITIONAL_NON_BOOLEAN);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:5d7388d:         // Set the type of the parameters.
1:5d7388d:         thenElseList.setParameterDescriptor(getTypeServices());
1:eac0369: 
1:eac0369: 		/* The then and else expressions must be type compatible */
1:eac0369: 		ClassInspector cu = getClassFactory().getClassInspector();
1:eac0369: 
1:4a90a32: 		/*
1:eac0369: 		** If it is comparable, then we are ok.  Note that we
1:eac0369: 		** could in fact allow any expressions that are convertible()
1:eac0369: 		** since we are going to generate a cast node, but that might
1:eac0369: 		** be confusing to users...
1:eac0369: 		*/
1:5d7388d:         for (ValueNode expr : thenElseList) {
1:5d7388d:             DataTypeDescriptor dtd = expr.getTypeServices();
1:5d7388d:             String javaTypeName =
1:5d7388d:                     dtd.getTypeId().getCorrespondingJavaTypeName();
1:5d7388d:             String resultJavaTypeName =
1:5d7388d:                     getTypeId().getCorrespondingJavaTypeName();
1:eac0369: 
1:5d7388d:             if (!dtd.comparable(getTypeServices(), false, getClassFactory())
1:5d7388d:                     && !cu.assignableTo(javaTypeName, resultJavaTypeName)
1:5d7388d:                     && !cu.assignableTo(resultJavaTypeName, javaTypeName)) {
1:13d34b0:                 throw StandardException.newException(
1:5d7388d:                         SQLState.LANG_NOT_TYPE_COMPATIBLE,
1:5d7388d:                         dtd.getTypeId().getSQLTypeName(),
1:5d7388d:                         getTypeId().getSQLTypeName());
1:5d7388d:             }
1:5d7388d:         }
1:eac0369: 
1:d6b5ab3:         // The result is nullable if and only if at least one of the result
1:d6b5ab3:         // expressions is nullable (DERBY-6567).
1:d6b5ab3:         setNullability(thenElseList.isNullable());
1:d6b5ab3: 
1:eac0369: 		/*
1:eac0369: 		** Generate a CastNode if necessary and
1:eac0369: 		** stick it over the original expression
1:eac0369: 		*/
1:eac0369: 		TypeId condTypeId = getTypeId();
1:5d7388d:         for (int i = 0; i < thenElseList.size(); i++) {
1:5d7388d:             ValueNode expr = thenElseList.elementAt(i);
1:5d7388d:             if (expr.getTypeId().typePrecedence()
1:5d7388d:                     != condTypeId.typePrecedence()) {
1:5d7388d:                 // Cast to dominant type.
1:5d7388d:                 ValueNode cast = new CastNode(
1:5d7388d:                         expr, getTypeServices(), getContextManager());
1:5d7388d:                 cast = cast.bindExpression(fromList, subqueryList, aggregates);
1:5d7388d:                 thenElseList.setElementAt(cast, i);
1:5d7388d:             }
1:5d7388d:         }
1:eac0369: 
1:e671fc7:         cc.setReliability( previousReliability );
1:e671fc7:         
2:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:2455f1a:     /**
1:2bd5cbd:      * <p>
1:2455f1a:      * Bind the case operand, if there is one, and check that it doesn't
1:2455f1a:      * contain anything that's illegal in a case operand (such as calls to
1:2bd5cbd:      * routines that are non-deterministic or modify SQL).
1:2bd5cbd:      * </p>
1:2bd5cbd:      *
1:2bd5cbd:      * <p>
1:2bd5cbd:      * Also, if the type of the case operand needs to be inferred, insert
1:2bd5cbd:      * dummy parameter nodes into {@link #testConditions} instead of the
1:2bd5cbd:      * case operand, so that the type can be inferred individually for each
1:2bd5cbd:      * test condition. Later, {@link #bindExpression} will find a common
1:2bd5cbd:      * type for all of them, use that type for the case operand, and reinsert
1:2bd5cbd:      * the case operand into the test conditions.
1:2bd5cbd:      * </p>
1:2bd5cbd:      *
1:2bd5cbd:      * @return a list of dummy parameter nodes that have been inserted into
1:2bd5cbd:      * the tree instead of the case operand, if such a replacement has
1:2bd5cbd:      * happened; otherwise, {@code null} is returned
1:2455f1a:      */
1:2bd5cbd:     private ValueNodeList bindCaseOperand(
1:2bd5cbd:                     CompilerContext cc, FromList fromList,
1:2bd5cbd:                     SubqueryList subqueryList, List<AggregateNode> aggregates)
1:2455f1a:             throws StandardException {
1:2455f1a: 
1:2bd5cbd:         ValueNodeList replacements = null;
1:2bd5cbd: 
1:2455f1a:         if (caseOperand != null) {
1:2455f1a:             int previousReliability = orReliability(
1:2455f1a:                     CompilerContext.CASE_OPERAND_RESTRICTION);
1:2455f1a: 
1:2bd5cbd:             // If the case operand requires type from context (typically,
1:2bd5cbd:             // because it is an untyped parameter), we need to find a type
1:2bd5cbd:             // that is comparable with all the when operands.
1:2bd5cbd:             //
1:2bd5cbd:             // To find the types of the when operands, temporarily replace
1:2bd5cbd:             // all occurrences of the case operand with dummy parameter nodes.
1:2bd5cbd:             // Later, after binding testConditions, those dummy nodes will
1:2bd5cbd:             // have their types set to the types of the when operands. At that
1:2bd5cbd:             // time, we will be able to find a common type, set the type of the
1:2bd5cbd:             // case operand to that type, and reinsert the case operand into
1:2bd5cbd:             // the tree.
1:2bd5cbd:             if (caseOperand.requiresTypeFromContext()) {
1:2bd5cbd:                 replacements = new ValueNodeList(getContextManager());
1:2bd5cbd:                 testConditions.accept(
1:2bd5cbd:                         new ReplaceCaseOperandVisitor(replacements));
1:2bd5cbd:             }
1:2bd5cbd: 
1:f2dfe06:             caseOperand = (CachedValueNode) caseOperand.bindExpression(
1:2455f1a:                     fromList, subqueryList, aggregates);
1:13d34b0: 
1:2455f1a:             cc.setReliability(previousReliability);
1:13d34b0:         }
1:2bd5cbd: 
1:2bd5cbd:         return replacements;
1:2bd5cbd:     }
1:2bd5cbd: 
1:2bd5cbd:     /**
1:d8df140:      * A visitor that replaces all occurrences of the {@link #caseOperand} node
1:2bd5cbd:      * in a tree with dummy parameter nodes. It also fills a supplied list
1:2bd5cbd:      * with the parameter nodes that have been inserted into the tree.
1:2bd5cbd:      */
1:2bd5cbd:     private class ReplaceCaseOperandVisitor implements Visitor {
1:2bd5cbd:         private final ValueNodeList replacements;
1:2bd5cbd: 
1:2bd5cbd:         private ReplaceCaseOperandVisitor(ValueNodeList replacements) {
1:2bd5cbd:             this.replacements = replacements;
1:2bd5cbd:         }
1:2bd5cbd: 
1:2bd5cbd:         @Override
1:2bd5cbd:         public Visitable visit(Visitable node) throws StandardException {
1:2bd5cbd:             if (node == caseOperand) {
1:2bd5cbd:                 ParameterNode pn = new ParameterNode(
1:2bd5cbd:                         0, null, getContextManager());
1:2bd5cbd:                 replacements.addElement(pn);
1:2bd5cbd:                 return pn;
1:2bd5cbd:             } else {
1:2bd5cbd:                 return node;
1:2bd5cbd:             }
1:2bd5cbd:         }
1:2bd5cbd: 
1:2bd5cbd:         @Override
1:2bd5cbd:         public boolean visitChildrenFirst(Visitable node) {
1:2bd5cbd:             return false;
1:2bd5cbd:         }
1:2bd5cbd: 
1:2bd5cbd:         @Override
1:2bd5cbd:         public boolean stopTraversal() {
1:2bd5cbd:             return false;
1:2bd5cbd:         }
1:2bd5cbd: 
1:2bd5cbd:         @Override
1:2bd5cbd:         public boolean skipChildren(Visitable node) throws StandardException {
1:2bd5cbd:             return false;
1:2bd5cbd:         }
1:2455f1a:     }
1:2455f1a: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode preprocess(int numTables,
1:eac0369: 								FromList outerFromList,
1:eac0369: 								SubqueryList outerSubqueryList,
1:eac0369: 								PredicateList outerPredicateList) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:5d7388d:         testConditions.preprocess(numTables,
1:5d7388d:                                   outerFromList, outerSubqueryList,
1:5d7388d:                                   outerPredicateList);
1:eac0369:  		thenElseList.preprocess(numTables,
2:eac0369: 								outerFromList, outerSubqueryList,
2:eac0369: 								outerPredicateList);
1:eac0369: 		return this;
1:2455f1a: 	}
1:2455f1a: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 * If the source of this ColumnReference (at the next underlying level) 
1:eac0369: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:eac0369: 	 * will not be pushed down.
1:eac0369: 	 *
1:eac0369: 	 * For example, in:
1:eac0369: 	 *		select * from (select 1 from s) a (x) where x = 1
1:eac0369: 	 * we will not push down x = 1.
1:eac0369: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:eac0369: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:eac0369: 	 * that tree into the pushed predicate, and that tree could contain
1:eac0369: 	 * subqueries and method calls.
1:eac0369: 	 * RESOLVE - revisit this issue once we have views.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:eac0369: 	 * @param simplePredsOnly	Whether or not to consider method
1:eac0369: 	 *							calls, field references and conditional nodes
1:eac0369: 	 *							when building bit map
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:eac0369: 	 *						or a VirtualColumnNode.
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We stop here when only considering simple predicates
1:eac0369: 		 *  as we don't consider conditional operators when looking
1:eac0369: 		 * for null invariant predicates.
1:eac0369: 		 */
1:eac0369: 		if (simplePredsOnly)
1:eac0369: 		{
1:01217c2: 			return false;
1:01217c2: 		}
1:01217c2: 
1:eac0369: 		boolean pushable;
1:eac0369: 
1:5d7388d:         pushable = testConditions.categorize(referencedTabs, simplePredsOnly);
1:eac0369: 		pushable = (thenElseList.categorize(referencedTabs, simplePredsOnly) && pushable);
1:eac0369: 		return pushable;
1:01217c2: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode			The remapped expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode remapColumnReferencesToExpressions()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:5d7388d:         testConditions = testConditions.remapColumnReferencesToExpressions();
1:eac0369: 		thenElseList = thenElseList.remapColumnReferencesToExpressions();
1:eac0369: 		return this;
1:01217c2: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this expression tree represents a constant expression.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not this expression tree represents a constant expression.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isConstantExpression()
1:eac0369: 	{
1:5d7388d:         return (testConditions.isConstantExpression() &&
1:eac0369: 			    thenElseList.isConstantExpression());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see ValueNode#constantExpression */
1:3bb140c:     @Override
1:3bb140c:     boolean constantExpression(PredicateList whereClause)
1:eac0369: 	{
1:5d7388d:         return (testConditions.constantExpression(whereClause) &&
1:eac0369: 			    thenElseList.constantExpression(whereClause));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
1:eac0369: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
1:eac0369: 	 * ComparisonOperators and boolean expressions.  We invert 
1:eac0369: 	 * ComparisonOperators and replace boolean expressions with 
1:eac0369: 	 * boolean expression = false.
1:eac0369: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
1:eac0369: 	 * still could be NotNodes left in the tree.
1:eac0369: 	 *
1:eac0369: 	 * @param	underNotNode		Whether or not we are under a NotNode.
1:eac0369: 	 *							
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	ValueNode eliminateNots(boolean underNotNode) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:f273581:         // NOT CASE WHEN a THEN b ELSE c END is equivalent to
1:f273581:         // CASE WHEN a THEN NOT b ELSE NOT c END, so just push the
1:f273581:         // NOT node down to the THEN and ELSE expressions.
1:5d7388d:         thenElseList.eliminateNots(underNotNode);
1:eac0369: 
1:5d7388d:         // Eliminate NOTs in the WHEN expressions too. The NOT node above us
1:5d7388d:         // should not be pushed into the WHEN expressions, though, as that
1:f273581:         // would alter the meaning of the CASE expression.
1:5d7388d:         testConditions.eliminateNots(false);
1:eac0369: 
1:eac0369: 		return this;
1:f273581: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for this conditional expression.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:5d7388d:         if (SanityManager.DEBUG) {
1:5d7388d:             // There should be at least one test condition.
1:5d7388d:             SanityManager.ASSERT(testConditions.size() > 0);
1:5d7388d:             // Because of the ELSE clause, there should always be one
1:5d7388d:             // more element in thenElseList than in testConditions.
1:5d7388d:             SanityManager.ASSERT(
1:5d7388d:                     thenElseList.size() == testConditions.size() + 1);
1:5d7388d:         }
1:eac0369: 
1:5d7388d:         // Generate code for all WHEN ... THEN clauses.
1:5d7388d:         for (int i = 0; i < testConditions.size(); i++) {
1:5d7388d:             testConditions.elementAt(i).generateExpression(acb, mb);
1:5d7388d:             mb.cast(ClassName.BooleanDataValue);
1:5d7388d:             mb.push(true);
1:5d7388d:             mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1:5d7388d:                           "equals", "boolean", 1);
1:5d7388d:             mb.conditionalIf();
1:5d7388d:             thenElseList.elementAt(i).generateExpression(acb, mb);
1:5d7388d:             mb.startElseCode();
1:5d7388d:         }
1:5d7388d: 
1:5d7388d:         // Generate code for the ELSE clause.
1:5d7388d:         thenElseList.elementAt(thenElseList.size() - 1)
1:5d7388d:                     .generateExpression(acb, mb);
1:5d7388d: 
1:5d7388d:         for (int i = 0; i < testConditions.size(); i++) {
1:5d7388d:             mb.completeConditional();
1:5d7388d:         }
1:f2dfe06: 
1:f2dfe06:         // If we have a cached case operand, clear the field that holds
1:f2dfe06:         // the cached value after the case expression has been evaluated,
1:f2dfe06:         // so that the value can be garbage collected early.
1:f2dfe06:         if (caseOperand != null) {
1:f2dfe06:             caseOperand.generateClearField(mb);
1:f2dfe06:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:5d7388d:         if (testConditions != null)
1:eac0369: 		{
1:5d7388d:             testConditions = (ValueNodeList) testConditions.accept(v);
1:eac0369: 		}
1:eac0369: 
1:aebfb28: 		if (thenElseList != null)
1:eac0369: 		{
1:eac0369: 			thenElseList = (ValueNodeList)thenElseList.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369:         
1:eac0369: 	/**
1:a09a583: 	 * {@inheritDoc}
1:eac0369: 	 */
1:2706d1f:     boolean isEquivalent(ValueNode o) throws StandardException
1:eac0369: 	{
1:2706d1f:         if (isSameNodeKind(o)) {
1:01217c2: 			ConditionalNode other = (ConditionalNode)o;
1:5d7388d:             return testConditions.isEquivalent(other.testConditions) &&
1:fc5f3cc:                     thenElseList.isEquivalent(other.thenElseList);
1:01217c2: 		}
1:2706d1f: 
1:01217c2: 		return false;
1:01217c2: 	}
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6f52e78
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         thenElseList.bindExpression(fromList, subqueryList, aggregates);
1: 
1:         // Find the type of the first typed value in thenElseList and cast
1:         // all untyped NULL values to that type. We don't need to find the
1:         // dominant type here, since a top-level cast to that type will be
1:         // added later, if necessary.
1:         DataTypeDescriptor nullType = thenElseList.getTypeServices();
1:         if (nullType == null) {
1:             // There are no values with a known type in the list. Raise
1:             // an error.
1:             throw StandardException.newException(
1:                     SQLState.LANG_ALL_RESULT_EXPRESSIONS_UNTYPED);
1:         } else {
1:             recastNullNodes(nullType, fromList, subqueryList, aggregates);
1:         }
/////////////////////////////////////////////////////////////////////////
commit:d8df140
/////////////////////////////////////////////////////////////////////////
1:      * A visitor that replaces all occurrences of the {@link #caseOperand} node
commit:2bd5cbd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitable;
/////////////////////////////////////////////////////////////////////////
1:         ValueNodeList caseOperandParameters =
1:                 bindCaseOperand(cc, fromList, subqueryList, aggregates);
1:         // If we have a simple case expression in which the case operand
1:         // requires type from context (typically because it's an untyped
1:         // parameter), find out which type best describes it.
1:         if (caseOperandParameters != null) {
1: 
1:             // Go through all the dummy parameter nodes that bindCaseOperand()
1:             // inserted into the synthetic test conditions. Each of them will
1:             // have been given the type of the corresponding when operand
1:             // when testConditions was bound.
1:             for (ValueNode vn : caseOperandParameters) {
1:                 // Check that this parameter is comparable to all the other
1:                 // parameters in the list. This indirectly checks whether
1:                 // all when operands have compatible types.
1:                 caseOperandParameters.comparable(vn);
1: 
1:                 // Replace the dummy parameter node with the actual case
1:                 // operand.
1:                 testConditions.accept(new ReplaceNodeVisitor(vn, caseOperand));
1:             }
1: 
1:             // Finally, after we have determined that all the when operands
1:             // are compatible, and we have reinserted the case operand into
1:             // the tree, set the type of the case operand to the dominant
1:             // type of all the when operands.
1:             caseOperand.setType(
1:                     caseOperandParameters.getDominantTypeServices());
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * routines that are non-deterministic or modify SQL).
1:      * </p>
1:      *
1:      * <p>
1:      * Also, if the type of the case operand needs to be inferred, insert
1:      * dummy parameter nodes into {@link #testConditions} instead of the
1:      * case operand, so that the type can be inferred individually for each
1:      * test condition. Later, {@link #bindExpression} will find a common
1:      * type for all of them, use that type for the case operand, and reinsert
1:      * the case operand into the test conditions.
1:      * </p>
1:      *
1:      * @return a list of dummy parameter nodes that have been inserted into
1:      * the tree instead of the case operand, if such a replacement has
1:      * happened; otherwise, {@code null} is returned
1:     private ValueNodeList bindCaseOperand(
1:                     CompilerContext cc, FromList fromList,
1:                     SubqueryList subqueryList, List<AggregateNode> aggregates)
1:         ValueNodeList replacements = null;
1: 
1:             // If the case operand requires type from context (typically,
1:             // because it is an untyped parameter), we need to find a type
1:             // that is comparable with all the when operands.
1:             //
1:             // To find the types of the when operands, temporarily replace
1:             // all occurrences of the case operand with dummy parameter nodes.
1:             // Later, after binding testConditions, those dummy nodes will
1:             // have their types set to the types of the when operands. At that
1:             // time, we will be able to find a common type, set the type of the
1:             // case operand to that type, and reinsert the case operand into
1:             // the tree.
1:             if (caseOperand.requiresTypeFromContext()) {
1:                 replacements = new ValueNodeList(getContextManager());
1:                 testConditions.accept(
1:                         new ReplaceCaseOperandVisitor(replacements));
1:             }
1: 
1: 
1:         return replacements;
1:     }
1: 
1:     /**
0:      * A visitor that replaces all occurrences of the {@link caseOperand} node
1:      * in a tree with dummy parameter nodes. It also fills a supplied list
1:      * with the parameter nodes that have been inserted into the tree.
1:      */
1:     private class ReplaceCaseOperandVisitor implements Visitor {
1:         private final ValueNodeList replacements;
1: 
1:         private ReplaceCaseOperandVisitor(ValueNodeList replacements) {
1:             this.replacements = replacements;
1:         }
1: 
1:         @Override
1:         public Visitable visit(Visitable node) throws StandardException {
1:             if (node == caseOperand) {
1:                 ParameterNode pn = new ParameterNode(
1:                         0, null, getContextManager());
1:                 replacements.addElement(pn);
1:                 return pn;
1:             } else {
1:                 return node;
1:             }
1:         }
1: 
1:         @Override
1:         public boolean visitChildrenFirst(Visitable node) {
1:             return false;
1:         }
1: 
1:         @Override
1:         public boolean stopTraversal() {
1:             return false;
1:         }
1: 
1:         @Override
1:         public boolean skipChildren(Visitable node) throws StandardException {
1:             return false;
1:         }
commit:f2dfe06
/////////////////////////////////////////////////////////////////////////
1:     private CachedValueNode caseOperand;
/////////////////////////////////////////////////////////////////////////
1:     ConditionalNode(CachedValueNode caseOperand,
/////////////////////////////////////////////////////////////////////////
1:             caseOperand = (CachedValueNode) caseOperand.bindExpression(
/////////////////////////////////////////////////////////////////////////
1: 
1:         // If we have a cached case operand, clear the field that holds
1:         // the cached value after the case expression has been evaluated,
1:         // so that the value can be garbage collected early.
1:         if (caseOperand != null) {
1:             caseOperand.generateClearField(mb);
1:         }
commit:13d34b0
/////////////////////////////////////////////////////////////////////////
0:             // For now, let's also forbid untyped parameters as case
0:             // operands. The problem is that the current type inference
0:             // doesn't handle conflicting types. Take for example
0:             //    CASE ? WHEN 1 THEN TRUE WHEN 'abc' THEN FALSE END
0:             // The type of the parameter would first get set to INTEGER
0:             // when binding the first WHEN clause. Later, when binding the
0:             // second WHEN clause, the type would be changed to CHAR(3),
0:             // without noticing that it already had a type, and that the
0:             // previous type was incompatible with the new one. Until the
0:             // type inference has improved, forbid such expressions.
0:             if (caseOperand.requiresTypeFromContext()) {
1:                 throw StandardException.newException(
0:                         SQLState.LANG_CASE_OPERAND_UNTYPED);
1:             }
1: 
commit:2455f1a
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The case operand if this is a simple case expression. Otherwise, it
1:      * is {@code null}.
1:      */
0:     private ValueNode caseOperand;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param caseOperand       The case operand if this is a simple case
1:      *                          expression, or {@code null} otherwise
0:     ConditionalNode(ValueNode caseOperand,
1:                     ValueNodeList testConditions,
1:         this.caseOperand = caseOperand;
/////////////////////////////////////////////////////////////////////////
1: 
0:         bindCaseOperand(cc, fromList, subqueryList, aggregates);
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Bind the case operand, if there is one, and check that it doesn't
1:      * contain anything that's illegal in a case operand (such as calls to
0:      * routines that are non-deterministic or modifies SQL).
1:      */
0:     private void bindCaseOperand(CompilerContext cc, FromList fromList,
0:                                  SubqueryList subqueryList,
0:                                 List<AggregateNode> aggregates)
1:             throws StandardException {
1: 
1:         if (caseOperand != null) {
1:             int previousReliability = orReliability(
1:                     CompilerContext.CASE_OPERAND_RESTRICTION);
1: 
0:             caseOperand = caseOperand.bindExpression(
1:                     fromList, subqueryList, aggregates);
1: 
1:             cc.setReliability(previousReliability);
1:         }
1:     }
1: 
commit:5d7388d
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     /** The list of test conditions in the WHEN clauses. */
1:     private ValueNodeList testConditions;
1: 
1:     /**
1:      * The list of corresponding THEN expressions to the test conditions in
1:      * {@link #testConditions}. The last element represents the ELSE clause.
1:      */
1:     private ValueNodeList thenElseList;
1:      * @param testConditions    The boolean test conditions
0:     ConditionalNode(ValueNodeList testConditions,
1:         this.testConditions = testConditions;
/////////////////////////////////////////////////////////////////////////
1:             if (testConditions != null)
1:                 printLabel(depth, "testConditions: ");
1:                 testConditions.treePrint(depth + 1);
/////////////////////////////////////////////////////////////////////////
0:      * Find a type to which we can cast the untyped NULLs generated by
0:      * the parser (for clauses such as ELSE NULL). This does not have to
0:      * be the type that the CASE expression ends up returning. It is
0:      * enough that it is a type that can be converted into the type of the
0:      * CASE expression in order to keep the type checking in the compiler
0:      * happy.
0:     private DataTypeDescriptor findType(
0:         thenElseList.bindExpression(fromList, subqueryList, aggregates);
0:         // Find the first typed expression.
0:         DataTypeDescriptor dtd = thenElseList.getTypeServices();
0:         if (dtd == null) {
0:             // If none of the expressions have a type, we should probably have
0:             // raised an error (DERBY-2002). However, Derby has always used the
0:             // type CHAR(1) in this case, so return that for now.
0:             dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(
0:                                                             Types.CHAR, 1);
1:         }
0:         return dtd;
1: 
1:      * This method makes sure any SQL NULLs will be cast to the correct type.
/////////////////////////////////////////////////////////////////////////
1:     private void recastNullNodes(
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < thenElseList.size(); i++) {
1:             ValueNode vn = thenElseList.elementAt(i);
1:             if (vn instanceof UntypedNullConstantNode) {
1:                 CastNode cast = new CastNode(vn, castType, getContextManager());
1:                 cast.bindExpression(fromList, subqueryList, aggregates);
1:                 thenElseList.setElementAt(cast, i);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         testConditions.bindExpression(fromList,
0:         // Following call to "findType()"  and "recastNullNodes" will
0:         // indirectly bind the expressions in the thenElseList, so no need
0:         // to call "thenElseList.bindExpression(...)" after we do this.
0:         // DERBY-2986.
0:         recastNullNodes(findType(fromList, subqueryList, aggregates),
0:                         fromList, subqueryList, aggregates);
1:         // Set the result type of this conditional to be the dominant type
1:         // of the result expressions.
1:         setType(thenElseList.getDominantTypeServices());
1:         testConditions.setParameterDescriptor(
1:                 new DataTypeDescriptor(TypeId.BOOLEAN_ID, true));
1: 
1:         for (ValueNode testCondition : testConditions) {
/////////////////////////////////////////////////////////////////////////
1:         // Set the type of the parameters.
1:         thenElseList.setParameterDescriptor(getTypeServices());
/////////////////////////////////////////////////////////////////////////
1:         for (ValueNode expr : thenElseList) {
1:             DataTypeDescriptor dtd = expr.getTypeServices();
1:             String javaTypeName =
1:                     dtd.getTypeId().getCorrespondingJavaTypeName();
1:             String resultJavaTypeName =
1:                     getTypeId().getCorrespondingJavaTypeName();
1:             if (!dtd.comparable(getTypeServices(), false, getClassFactory())
1:                     && !cu.assignableTo(javaTypeName, resultJavaTypeName)
1:                     && !cu.assignableTo(resultJavaTypeName, javaTypeName)) {
0:                 throw StandardException.newException(
1:                         SQLState.LANG_NOT_TYPE_COMPATIBLE,
1:                         dtd.getTypeId().getSQLTypeName(),
1:                         getTypeId().getSQLTypeName());
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < thenElseList.size(); i++) {
1:             ValueNode expr = thenElseList.elementAt(i);
1:             if (expr.getTypeId().typePrecedence()
1:                     != condTypeId.typePrecedence()) {
1:                 // Cast to dominant type.
1:                 ValueNode cast = new CastNode(
1:                         expr, getTypeServices(), getContextManager());
1:                 cast = cast.bindExpression(fromList, subqueryList, aggregates);
1:                 thenElseList.setElementAt(cast, i);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         testConditions.preprocess(numTables,
1:                                   outerFromList, outerSubqueryList,
1:                                   outerPredicateList);
/////////////////////////////////////////////////////////////////////////
1:         pushable = testConditions.categorize(referencedTabs, simplePredsOnly);
/////////////////////////////////////////////////////////////////////////
1:         testConditions = testConditions.remapColumnReferencesToExpressions();
/////////////////////////////////////////////////////////////////////////
1:         return (testConditions.isConstantExpression() &&
/////////////////////////////////////////////////////////////////////////
1:         return (testConditions.constantExpression(whereClause) &&
/////////////////////////////////////////////////////////////////////////
1:         thenElseList.eliminateNots(underNotNode);
1:         // Eliminate NOTs in the WHEN expressions too. The NOT node above us
1:         // should not be pushed into the WHEN expressions, though, as that
1:         testConditions.eliminateNots(false);
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             // There should be at least one test condition.
1:             SanityManager.ASSERT(testConditions.size() > 0);
1:             // Because of the ELSE clause, there should always be one
1:             // more element in thenElseList than in testConditions.
1:             SanityManager.ASSERT(
1:                     thenElseList.size() == testConditions.size() + 1);
1:         }
1:         // Generate code for all WHEN ... THEN clauses.
1:         for (int i = 0; i < testConditions.size(); i++) {
1:             testConditions.elementAt(i).generateExpression(acb, mb);
1:             mb.cast(ClassName.BooleanDataValue);
1:             mb.push(true);
1:             mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1:                           "equals", "boolean", 1);
1:             mb.conditionalIf();
1:             thenElseList.elementAt(i).generateExpression(acb, mb);
1:             mb.startElseCode();
1:         }
1: 
1:         // Generate code for the ELSE clause.
1:         thenElseList.elementAt(thenElseList.size() - 1)
1:                     .generateExpression(acb, mb);
1: 
1:         for (int i = 0; i < testConditions.size(); i++) {
1:             mb.completeConditional();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (testConditions != null)
1:             testConditions = (ValueNodeList) testConditions.accept(v);
/////////////////////////////////////////////////////////////////////////
1:             return testConditions.isEquivalent(other.testConditions) &&
commit:d6b5ab3
/////////////////////////////////////////////////////////////////////////
1:         // The result is nullable if and only if at least one of the result
1:         // expressions is nullable (DERBY-6567).
1:         setNullability(thenElseList.isNullable());
1: 
commit:f273581
/////////////////////////////////////////////////////////////////////////
1:         // NOT CASE WHEN a THEN b ELSE c END is equivalent to
1:         // CASE WHEN a THEN NOT b ELSE NOT c END, so just push the
1:         // NOT node down to the THEN and ELSE expressions.
0:         for (int i = 0; i < thenElseList.size(); i++) {
0:             thenElseList.setElementAt(
0:                     thenElseList.elementAt(i).eliminateNots(underNotNode),
0:                     i);
1:         }
0:         // Eliminate NOTs in the WHEN expression too. The NOT node above us
0:         // should not be pushed into the WHEN expression, though, as that
1:         // would alter the meaning of the CASE expression.
0:         testCondition = testCondition.eliminateNots(false);
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
0:         FromList fromList, SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
0:                 fromList, subqueryList, aggregates);
0:                 fromList, subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
0:                     subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
0:                     subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates      List of aggregates to pass on to bindExpression if recast is performed
0:                                SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
0:             ((ValueNode) thenElseList.elementAt(0)).bindExpression(fromList, subqueryList, aggregates);
0:                             castType,fromList, subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
0:             ((ValueNode) thenElseList.elementAt(1)).bindExpression(fromList, subqueryList, aggregates);
0:                             castType,fromList,subqueryList,aggregates);
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
0:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
1:             aggregates);
/////////////////////////////////////////////////////////////////////////
0:                 aggregates);
/////////////////////////////////////////////////////////////////////////
0:                 findType(thenElseList, fromList, subqueryList, aggregates),fromList,
0:                     aggregates);
/////////////////////////////////////////////////////////////////////////
0:                                             aggregates);
/////////////////////////////////////////////////////////////////////////
0:                                             aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		FromList fromList, SubqueryList subqueryList, List aggregateVector)
/////////////////////////////////////////////////////////////////////////
0: 	                           SubqueryList subqueryList, List aggregateVector)
/////////////////////////////////////////////////////////////////////////
0: 		List aggregateVector)
commit:e6a9998
/////////////////////////////////////////////////////////////////////////
0: 		return (QueryTreeNode) getNodeFactory().getNode(
/////////////////////////////////////////////////////////////////////////
0: 			QueryTreeNode cast = (QueryTreeNode) getNodeFactory().getNode(
commit:fc5f3cc
/////////////////////////////////////////////////////////////////////////
0:             return testCondition.isEquivalent(other.testCondition) &&
1:                     thenElseList.isEquivalent(other.thenElseList);
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
0: 		if (testCondition != null)
1: 		if (thenElseList != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:4a90a32
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			/* 
0: 			 * NULLIF(V1,V2) is equivalent to: 
1: 			 * 
0: 			 *    CASE WHEN V1=V2 THEN NULL ELSE V1 END
1: 			 * 
0: 			 * The untyped NULL should have a data type descriptor
0: 			 * that allows its value to be nullable.
1: 			 */
0: 						new DataTypeDescriptor(
0: 								bcon.getLeftOperand().getTypeServices(), true),
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return node instanceof CastNode;
/////////////////////////////////////////////////////////////////////////
0:         return node instanceof ConditionalNode;
/////////////////////////////////////////////////////////////////////////
1:     boolean isEquivalent(ValueNode o) throws StandardException
1:         if (isSameNodeKind(o)) {
1: 
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:         ValueNode thenNode = thenElseList.elementAt(0).bindExpression(
0:         ValueNode elseNode = thenElseList.elementAt(1).bindExpression(
/////////////////////////////////////////////////////////////////////////
0:         ValueNode thenNode = thenElseList.elementAt(0);
0:         ValueNode elseNode = thenElseList.elementAt(1);
/////////////////////////////////////////////////////////////////////////
0:             thenElseList.elementAt(0).bindExpression(
0:                     fromList, subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
0:             thenElseList.elementAt(1).bindExpression(
0:                     fromList, subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
0:     private CastNode recastNullNode(ValueNode nodeToCast,
/////////////////////////////////////////////////////////////////////////
0:             CastNode cast = new CastNode(
0:                         thenElseList.elementAt(0),
/////////////////////////////////////////////////////////////////////////
0:         ValueNode thenExpression = thenElseList.elementAt(0);
0:         ValueNode elseExpression = thenElseList.elementAt(1);
/////////////////////////////////////////////////////////////////////////
0:         TypeId thenTypeId = thenElseList.elementAt(0).getTypeId();
0:         TypeId elseTypeId = thenElseList.elementAt(1).getTypeId();
/////////////////////////////////////////////////////////////////////////
0:                                 thenElseList.elementAt(0),
/////////////////////////////////////////////////////////////////////////
0:                                 thenElseList.elementAt(1),
/////////////////////////////////////////////////////////////////////////
0:         thenExpression = thenElseList.elementAt(0);
0:         elseExpression = thenElseList.elementAt(1);
/////////////////////////////////////////////////////////////////////////
0:          thenElseList.elementAt(0).generateExpression(acb, mb);
0:          thenElseList.elementAt(1).generateExpression(acb, mb);
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.util.JBitSet;
/////////////////////////////////////////////////////////////////////////
1: class ConditionalNode extends ValueNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a ConditionalNode
1:      * @param cm                The context manager
0:     ConditionalNode(ValueNode testCondition,
1:                     ValueNodeList thenElseList,
0:                     boolean thisIsNullIfNode,
1:                     ContextManager cm)
1:         super(cm);
0:         this.testCondition = testCondition;
1:         this.thenElseList = thenElseList;
0:         this.thisIsNullIfNode = thisIsNullIfNode;
0:         setNodeType(C_NodeTypes.CONDITIONAL_NODE);
/////////////////////////////////////////////////////////////////////////
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
0:         return node.getNodeType() == C_NodeTypes.CAST_NODE;
/////////////////////////////////////////////////////////////////////////
0:         return node.getNodeType() == C_NodeTypes.CONDITIONAL_NODE;
/////////////////////////////////////////////////////////////////////////
0:         return new CastNode(
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:             QueryTreeNode cast = new CastNode(
0:                         (ValueNode)thenElseList.elementAt(0),
/////////////////////////////////////////////////////////////////////////
0:             ValueNode cast = new CastNode(
0:                                 (ValueNode)thenElseList.elementAt(0),
/////////////////////////////////////////////////////////////////////////
0:             ValueNode cast = new CastNode(
0:                                 (ValueNode)thenElseList.elementAt(1),
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isConstantExpression()
1:     @Override
1:     boolean constantExpression(PredicateList whereClause)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
0:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
/////////////////////////////////////////////////////////////////////////
1:                                SubqueryList subqueryList, List<AggregateNode> aggregates)
/////////////////////////////////////////////////////////////////////////
1:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
commit:cb25c65
/////////////////////////////////////////////////////////////////////////
0:         thenElseList.setElementAt( thenNode, 0 );
0:         thenElseList.setElementAt( elseNode, 1 );
commit:e671fc7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
/////////////////////////////////////////////////////////////////////////
1:         CompilerContext cc = getCompilerContext();
1:         
1:         int previousReliability = orReliability( CompilerContext.CONDITIONAL_RESTRICTION );
1:         
/////////////////////////////////////////////////////////////////////////
1:         cc.setReliability( previousReliability );
1:         
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7a361f2
/////////////////////////////////////////////////////////////////////////
1: 		castType = castType.getNullabilityType(true);
commit:d5ce63a
/////////////////////////////////////////////////////////////////////////
0: 	 * @throws StandardException 
0: 	private boolean isCastToChar(ValueNode node) throws StandardException {
0: 		if (node.getTypeServices().getTypeName().equals(TypeId.CHAR_NAME))
/////////////////////////////////////////////////////////////////////////
0: 		if (isCastNode(thenNode) && !isCastToChar(thenNode))
0: 			return thenNode.getTypeServices();
/////////////////////////////////////////////////////////////////////////
0: 		if (isCastNode(elseNode) && !isCastToChar(elseNode))
0: 			return elseNode.getTypeServices();
commit:32812bd
/////////////////////////////////////////////////////////////////////////
0: 						bcon.getLeftOperand().getTypeServices().getNullabilityType(true),
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
0:                                 getTypeServices(),	// cast to dominant type
/////////////////////////////////////////////////////////////////////////
0:                                 getTypeServices(),	// cast to dominant type
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1:         
1: 	/**
0: 	 * @{inheritDoc}
1: 	 */
0: 	protected boolean isEquivalent(ValueNode o) throws StandardException
1: 	{
0: 		if (isSameNodeType(o)) 
1: 		{
1: 			ConditionalNode other = (ConditionalNode)o;
0: 			if (thenElseList.size() == other.thenElseList.size()
0: 					&& (testCondition.isEquivalent(other.testCondition))) 
1: 			{
0: 				int sz = thenElseList.size();
0: 				for (int i = 0; i < sz; i++)
1: 				{
0: 					ValueNode v1 = (ValueNode)thenElseList.elementAt(i);
0: 					ValueNode v2 = (ValueNode)other.thenElseList.elementAt(i);
0: 					if (!v1.isEquivalent(v2)) 
1: 					{
1: 						return false;
1: 					}
1: 					
1: 				}
0: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ConditionalNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.reference.ClassName;
1: 
1: 
0: import org.apache.derby.iapi.util.JBitSet;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * A ConditionalNode represents an if/then/else operator with a single
1:  * boolean expression on the "left" of the operator and a list of expressions on 
1:  * the "right". This is used to represent the java conditional (aka immediate if).
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class ConditionalNode extends ValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	ValueNode		testCondition;
0: 	ValueNodeList	thenElseList;
1: 
1: 	/**
0: 	 * Initializer for a ConditionalNode
1: 	 *
0: 	 * @param testCondition		The boolean test condition
1: 	 * @param thenElseList		ValueNodeList with then and else expressions
1: 	 */
1: 
0: 	public void init(Object testCondition, Object thenElseList)
1: 	{
0: 		this.testCondition = (ValueNode) testCondition;
0: 		this.thenElseList = (ValueNodeList) thenElseList;
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
0: 			if (testCondition != null)
1: 			{
0: 				printLabel(depth, "testCondition: ");
0: 				testCondition.treePrint(depth + 1);
1: 			}
1: 
1: 			if (thenElseList != null)
1: 			{
1: 				printLabel(depth, "thenElseList: ");
1: 				thenElseList.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		super.setClause(clause);
0: 		testCondition.setClause(clause);
0: 		thenElseList.setClause(clause);
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
1: 			throws StandardException
1: 	{
0: 		testCondition = testCondition.bindExpression(fromList, 
1: 			subqueryList,
0: 			aggregateVector);
0: 		thenElseList.bindExpression(fromList, 
1: 			subqueryList,
0: 			aggregateVector);
1: 
0: 		// Can't get the then and else expressions until after they've been bound
0: 		ValueNode thenExpression = (ValueNode) thenElseList.elementAt(0);
0: 		ValueNode elseExpression = (ValueNode) thenElseList.elementAt(1);
1: 
1: 		/* testCondition must be a boolean expression.
1: 		 * If it is a ? parameter on the left, then set type to boolean,
1: 		 * otherwise verify that the result type is boolean.
1: 		 */
0: 		if (testCondition.isParameterNode())
1: 		{
0: 			((ParameterNode) testCondition).setDescriptor(
0: 							new DataTypeDescriptor(
0: 										TypeId.BOOLEAN_ID,
0: 										true));
1: 		}
0: 		else
1: 		{
1: 			if ( ! testCondition.getTypeServices().getTypeId().equals(
1: 														TypeId.BOOLEAN_ID))
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_CONDITIONAL_NON_BOOLEAN);
1: 			}
1: 		}
1: 
0: 		/* We can't determine the type for the result expression if
0: 		 * all result expressions are ?s.
1: 		 */
0: 		if (thenElseList.containsAllParameterNodes())
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_ALL_RESULT_EXPRESSIONS_PARAMS, "conditional");
1: 		}
0: 		else if (thenElseList.containsParameterNode())
1: 		{
0: 			/* Set the parameter's type to be the same as the other element in
0: 			 * the list
1: 			 */
1: 
0: 			DataTypeDescriptor dts;
0: 			ValueNode typeExpression;
1: 
0: 			if (thenExpression.isParameterNode())
1: 			{
0: 				dts = elseExpression.getTypeServices();
1: 			}
0: 			else
1: 			{
0: 				dts = thenExpression.getTypeServices();
1: 			}
1: 
0: 			thenElseList.setParameterDescriptor(dts);
1: 		}
1: 
1: 		/* The then and else expressions must be type compatible */
1: 		ClassInspector cu = getClassFactory().getClassInspector();
1: 
1: 		/*
1: 		** If it is comparable, then we are ok.  Note that we
1: 		** could in fact allow any expressions that are convertible()
1: 		** since we are going to generate a cast node, but that might
1: 		** be confusing to users...
1: 		*/
1: 
0: 		// RESOLVE DJDOI - this looks wrong, why should the then expression
0: 		// be comparable to the then expression ??
0: 		if (! thenExpression.getTypeCompiler().
0: 			 comparable(elseExpression.getTypeId(), false, getClassFactory()) &&
0: 			! cu.assignableTo(thenExpression.getTypeId().getCorrespondingJavaTypeName(),
0: 							  elseExpression.getTypeId().getCorrespondingJavaTypeName()) &&
0: 			! cu.assignableTo(elseExpression.getTypeId().getCorrespondingJavaTypeName(),
0: 							  thenExpression.getTypeId().getCorrespondingJavaTypeName()))
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_NOT_TYPE_COMPATIBLE, 
0: 						thenExpression.getTypeId().getSQLTypeName(),
0: 						elseExpression.getTypeId().getSQLTypeName()
0: 						);
1: 		}
1: 
1: 		/*
0: 		** Set the result type of this conditional to be the dominant type
0: 		** of the result expressions.
1: 		*/
0: 		setType(thenElseList.getDominantTypeServices());
1: 
1: 		/*
1: 		** Generate a CastNode if necessary and
1: 		** stick it over the original expression
1: 		*/
1: 		TypeId condTypeId = getTypeId();
0: 		TypeId thenTypeId = ((ValueNode) thenElseList.elementAt(0)).getTypeId();
0: 		TypeId elseTypeId = ((ValueNode) thenElseList.elementAt(1)).getTypeId();
1: 
0: 		/* Need to generate conversion if thenExpr or elseExpr is not of 
0: 		 * dominant type.  (At least 1 of them must be of the dominant type.)
1: 		 */
0: 		if (thenTypeId.typePrecedence() != condTypeId.typePrecedence())
1: 		{
0: 			ValueNode cast = (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.CAST_NODE,
0: 								thenElseList.elementAt(0), 
0: 								dataTypeServices,	// cast to dominant type
0: 								getContextManager());
0: 			cast = cast.bindExpression(fromList, 
1: 											subqueryList,
0: 											aggregateVector);
1: 			
0: 			thenElseList.setElementAt(cast, 0);
1: 		}
1: 
0: 		else if (elseTypeId.typePrecedence() != condTypeId.typePrecedence())
1: 		{
0: 			ValueNode cast = (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.CAST_NODE,
0: 								thenElseList.elementAt(1), 
0: 								dataTypeServices,	// cast to dominant type
0: 								getContextManager());
0: 			cast = cast.bindExpression(fromList, 
1: 											subqueryList,
0: 											aggregateVector);
1: 			
0: 			thenElseList.setElementAt(cast, 1);
1: 		}
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
0: 		testCondition = testCondition.preprocess(numTables,
1: 												 outerFromList, outerSubqueryList,
1: 												 outerPredicateList);
1:  		thenElseList.preprocess(numTables,
1: 								outerFromList, outerSubqueryList,
1: 								outerPredicateList);
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		/* We stop here when only considering simple predicates
1: 		 *  as we don't consider conditional operators when looking
1: 		 * for null invariant predicates.
1: 		 */
1: 		if (simplePredsOnly)
1: 		{
0: 			return false;
1: 		}
1: 
1: 		boolean pushable;
1: 
0: 		pushable = testCondition.categorize(referencedTabs, simplePredsOnly);
1: 		pushable = (thenElseList.categorize(referencedTabs, simplePredsOnly) && pushable);
1: 		return pushable;
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return ValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
0: 		testCondition = testCondition.remapColumnReferencesToExpressions();
1: 		thenElseList = thenElseList.remapColumnReferencesToExpressions();
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree represents a constant expression.
1: 	 *
1: 	 * @return	Whether or not this expression tree represents a constant expression.
1: 	 */
0: 	public boolean isConstantExpression()
1: 	{
0: 		return (testCondition.isConstantExpression() &&
1: 			    thenElseList.isConstantExpression());
1: 	}
1: 
1: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
1: 	{
0: 		return (testCondition.constantExpression(whereClause) &&
1: 			    thenElseList.constantExpression(whereClause));
1: 	}
1: 
1: 	/**
1: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
1: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
1: 	 * ComparisonOperators and boolean expressions.  We invert 
1: 	 * ComparisonOperators and replace boolean expressions with 
1: 	 * boolean expression = false.
1: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
1: 	 * still could be NotNodes left in the tree.
1: 	 *
1: 	 * @param	underNotNode		Whether or not we are under a NotNode.
1: 	 *							
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	ValueNode eliminateNots(boolean underNotNode) 
1: 					throws StandardException
1: 	{
0: 		ValueNode thenExpression;
0: 		ValueNode elseExpression;
1: 
0: 		if (! underNotNode)
1: 		{
1: 			return this;
1: 		}
1: 
0: 		/* Simply swap the then and else expressions */
0: 		thenExpression = (ValueNode) thenElseList.elementAt(0);
0: 		elseExpression = (ValueNode) thenElseList.elementAt(1);
0: 		thenElseList.setElementAt(elseExpression, 0);
0: 		thenElseList.setElementAt(thenExpression, 1);
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this conditional expression.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the expression will go into
1: 	 *
0: 	 * @return	An expression to evaluate this operator
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
0: 		testCondition.generateExpression(acb, mb);
0: 		mb.cast(ClassName.BooleanDataValue);
0: 		mb.push(true);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "equals", "boolean", 1);
1: 
0: 		mb.conditionalIf();
0: 		  ((ValueNode) thenElseList.elementAt(0)).generateExpression(acb, mb);
0: 		mb.startElseCode();
0: 		  ((ValueNode) thenElseList.elementAt(1)).generateExpression(acb, mb);
0: 		mb.completeConditional();
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 	
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 
0: 		if (testCondition != null && !v.stopTraversal())
1: 		{
0: 			testCondition = (ValueNode)testCondition.accept(v);
1: 		}
1: 
0: 		if (thenElseList != null && !v.stopTraversal())
1: 		{
1: 			thenElseList = (ValueNodeList)thenElseList.accept(v);
1: 		}
1: 		
0: 		return returnNode;
1: 	}
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:78cb2da
/////////////////////////////////////////////////////////////////////////
1: 	 * @param fromList        FromList to pass on to bindExpression if recast is performed
1: 	 * @param subqueryList    SubqueryList to pass on to bindExpression if recast is performed
0: 	 * @param aggregateVector AggregateVector to pass on to bindExpression if recast is performed
1: 	                           DataTypeDescriptor castType, FromList fromList,
0: 	                           SubqueryList subqueryList, Vector aggregateVector)
0: 		
1: 		// need to have nullNodes nullable
0: 		castType.setNullability(true);
/////////////////////////////////////////////////////////////////////////
0: 			// recast and rebind. findTypes would have bound as SQL CHAR.
0: 			// need to rebind here. (DERBY-3032)
0: 			((ValueNode) thenElseList.elementAt(0)).bindExpression(fromList, subqueryList, aggregateVector);
0: 			
0: 			                castType,fromList, subqueryList, aggregateVector);
0: 			// recast and rebind. findTypes would have bound as SQL CHAR.
0: 			// need to rebind here. (DERBY-3032)
0: 			((ValueNode) thenElseList.elementAt(1)).bindExpression(fromList, subqueryList, aggregateVector);
0: 			                castType,fromList,subqueryList,aggregateVector);
/////////////////////////////////////////////////////////////////////////
0: 			/* Following call to "findType()"  and "recastNullNodes" will indirectly bind the
0: 				findType(thenElseList, fromList, subqueryList, aggregateVector),fromList,
0: 					subqueryList,
0: 					aggregateVector);
0: 			
0: 		
0: 		
0: 		// expressions have been bound by findType and rebound by recastNullNodes if needed.
author:Army
-------------------------------------------------------------------------------
commit:5e32892
/////////////////////////////////////////////////////////////////////////
0: 		FromList fromList, SubqueryList subqueryList, Vector aggregateVector)
0: 		throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 				fromList, subqueryList, aggregateVector);
0: 				fromList, subqueryList, aggregateVector);
/////////////////////////////////////////////////////////////////////////
0: 				findType(((ConditionalNode)thenNode).thenElseList, fromList,
0: 					subqueryList, aggregateVector);
/////////////////////////////////////////////////////////////////////////
0: 				findType(((ConditionalNode)elseNode).thenElseList, fromList,
0: 					subqueryList, aggregateVector);
/////////////////////////////////////////////////////////////////////////
0: 			thenElseList.setElementAt(cast,0);
0: 			thenElseList.bindExpression(fromList,
0: 				subqueryList,
0: 				aggregateVector);
0: 
0: 		} else {
0: 			/* Following call to "findType()" will indirectly bind the
0: 			 * expressions in the thenElseList, so no need to call
0: 			 * "thenElseList.bindExpression(...)" after we do this.
0: 			 * DERBY-2986.
0: 			 */
0: 			recastNullNodes(thenElseList,
0: 				findType(thenElseList, fromList, subqueryList, aggregateVector));
0:  		}
commit:a1d6109
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Checks if the provided node is a CastNode.
0: 	 *
0: 	 * @param node	The node to check.
0: 	 * @return 		True if this node is a CastNode, false otherwise.
0: 	 */
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Checks if the provided CastNode is cast to a SQL CHAR type.
0: 	 *
0: 	 * @param node	The CastNode to check.
0: 	 * @return		True if this CastNode's target type is CHAR,
0: 	 *              false otherwise.
0: 	 */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		// first check if the "then" node is NULL
0: 		if (isNullNode(thenNode) &&
0: 		    shouldCast(castType, thenNode.getTypeServices()))
0: 		{
0: 		// otherwise recurse on thenNode, but only if it's a conditional
0: 			recastNullNodes(((ConditionalNode)thenNode).thenElseList,
0: 			                castType);
0: 
0: 		// lastly, check if the "else" node is NULL
0: 		if (isNullNode(elseNode) &&
0: 		    shouldCast(castType, elseNode.getTypeServices()))
0: 		{
0: 		// otherwise recurse on elseNode, but only if it's a conditional
0: 			recastNullNodes(((ConditionalNode)elseNode).thenElseList,
0: 			                castType);
commit:fa3b425
/////////////////////////////////////////////////////////////////////////
0: 	private boolean isCastNode(ValueNode node) {
0: 		if (node.getNodeType() == C_NodeTypes.CAST_NODE)
0: 			return true;
0: 		else
0: 			return false;
0: 	}
0: 
0: 	private boolean isCastToChar(CastNode node) {
0: 		if (node.castTarget.getTypeName().equals(TypeId.CHAR_NAME))
0: 			return true;
0: 		else
0: 			return false;
0: 	}
0: 
0: 	/**
0: 	 * Checks to see if the provided node represents
0: 	 * a parsing of an SQL NULL.
0: 	 *
0: 	 * @param node  The node to check.
0: 	 * @return      True if this node represents a SQL NULL, false otherwise.
0: 	 */
0: 	private boolean isNullNode(ValueNode node) {
0: 		if (isCastNode(node) &&
0: 			(((CastNode)node).castOperand instanceof UntypedNullConstantNode))
0: 			return true;
0: 		else
0: 			return false;
0: 	}
0: 
0:  	/**
0: 	 * Checks to see if the provided node represents
0: 	 * a ConditionalNode.
0: 	 *
0: 	 * @param node    The node to check.
0: 	 * @return        True if this node is a CondtionalNode, false otherwise.
0: 	 */
0: 	private boolean isConditionalNode(ValueNode node) {
0: 		if (node.getNodeType() == C_NodeTypes.CONDITIONAL_NODE)
0: 			return true;
0: 		else
0: 			return false;
0: 	}
0: 
0: 	private boolean shouldCast(ValueNode newNode, ValueNode oldNode)
0: 	throws StandardException
0: 	{
0: 		return shouldCast(newNode.getTypeServices(), oldNode.getTypeServices());
0: 	}
0: 
0: 	private boolean shouldCast(DataTypeDescriptor newType, ValueNode oldNode)
0: 	throws StandardException
0: 	{
0: 		return shouldCast(newType, oldNode.getTypeServices());
0: 	}
0: 
0: 	private boolean shouldCast(ValueNode newNode, DataTypeDescriptor oldType)
0: 	throws StandardException
0: 	{
0: 		return shouldCast(newNode.getTypeServices(), oldType);
0: 	}
0: 
0: 	/**
0: 	 * Checks to see if oldType should be casted to the newType.
0: 	 * Returns TRUE if the two DataTypeDescriptors have different
0: 	 * TypeID's or if the oldType is NULL.  Returns FALSE if the newType is
0: 	 * NULL or if the two Types are identical.
0: 	 *
0: 	 * @param newType    The type to cast oldType to if they're different.
0: 	 * @param oldType    The type that should be casted to the newType if
0: 	 *                   they're different.
0: 	 * @return           False if the newType is null or they have the same
0: 	 *                   TypeId, true otherwise.
0: 	 */
0: 	private boolean shouldCast(DataTypeDescriptor newType,
0: 		DataTypeDescriptor oldType) throws StandardException
0: 	{
0: 		if ((newType != null) &&
0: 			((oldType == null) ||
0: 			 (!oldType.getTypeId().equals(newType.getTypeId()))))
0: 			return true;
0: 		else
0: 			return false;
0: 	}
0: 
0: 	/**
0: 	 * This method is a 'prebind.'  We need to determine what the types of
0: 	 * the nodes are going to be before we can set all the SQLParsed NULL's
0: 	 * to the appropriate type.  After we bind, however, we want to ignore
0: 	 * the SQLParsed NULL's which will be bound to CHAR.  Also, we might
0: 	 * have to delve into the CASE Expression tree.
0: 	 *
0: 	 * @param thenElseList    The thenElseList (recursive method)
0: 	 * @param fromList        The fromList (required for Column References).
0: 	 *
1: 	 * @exception             StandardException Thrown on error.
0: 	 */
0: 	private DataTypeDescriptor findType(ValueNodeList thenElseList,
0: 		FromList fromList) throws StandardException
0: 	{
0: 		/* We need to "prebind" because we want the Types.  Provide
0: 		 * dummy SubqueryList and AggreateList (we don't care)
0: 		 */
0: 
0: 		ValueNode thenNode =
0: 			((ValueNode)thenElseList.elementAt(0)).bindExpression(
0: 				fromList, new SubqueryList(), new Vector());
0: 
0: 		ValueNode elseNode =
0: 			((ValueNode)thenElseList.elementAt(1)).bindExpression(
0: 				fromList, new SubqueryList(), new Vector());
0: 
0: 		DataTypeDescriptor thenType = thenNode.getTypeServices();
0: 		DataTypeDescriptor elseType = elseNode.getTypeServices();
0: 		DataTypeDescriptor theType = null;
0: 
0: 		/* If it's not a Cast Node or a Conditional Node, then we'll
0: 		 * use this type.
0: 		 */
0: 		if ((thenType != null) && !isCastNode(thenNode)
0: 			&& !isConditionalNode(thenNode))
0: 		{
0: 			return thenType;
0: 		}
0: 
0: 		/* If it's not cast to CHAR it isn't a SQL parsed NULL, so
0: 		 * we can use it.
0: 		 */
0: 		if (isCastNode(thenNode) && !isCastToChar((CastNode)thenNode))
0: 			return ((CastNode)thenNode).castTarget;
0: 
0: 		/* If we get here, we can't use the THEN node type, so we'll
0: 		 * use the ELSE node type
0: 		 */
0: 		if ((elseType != null) && !isCastNode(elseNode)
0: 			&& !isConditionalNode(elseNode))
0: 		{
0: 			return elseType;
0: 		}
0: 
0: 		if (isCastNode(elseNode) && !isCastToChar((CastNode)elseNode))
0: 			return ((CastNode)elseNode).castTarget;
0: 
0: 		/* If we get here, it means that we've got a conditional and a
0: 		 * SQL parsed NULL or two conditionals.
0: 		 */
0: 		if (isConditionalNode(thenNode))
0: 		{
0: 			theType =
0: 				findType(((ConditionalNode)thenNode).thenElseList, fromList);
0: 		}
0: 
0: 		if (theType != null) return theType;
0: 
0: 		// Two conditionals and the first one was all SQL parsed NULLS.
0: 		if (isConditionalNode(elseNode))
0: 		{
0: 			theType =
0: 				findType(((ConditionalNode)elseNode).thenElseList, fromList);
0: 		}
0: 
0: 		if (theType != null) return theType;
0: 		return null;
0: 	}
0: 	/**
0: 	 * This recursive method will hunt through the ValueNodeList thenElseList
0: 	 * looking for SQL NULL's.  If it finds any, it casts them to the provided
0: 	 * castType.
0: 	 *
0: 	 * @param thenElseList    The thenElseList to update.
1: 	 * @param castType        The type to cast SQL parsed NULL's too.
0: 	 *
1: 	 * @exception             StandardException Thrown on error.
0: 	 */
0: 	private void recastNullNodes(ValueNodeList thenElseList,
0: 	                           DataTypeDescriptor castType)
1: 	 throws StandardException {
0: 
0: 		// Don't do anything if we couldn't find a castType.
0: 		if (castType == null) return;
0: 
0: 		ValueNode thenNode = (ValueNode)thenElseList.elementAt(0);
0: 		ValueNode elseNode = (ValueNode)thenElseList.elementAt(1);
0: 
0: 		// check if the "then" node is NULL
0: 		if (isNullNode(thenNode) && shouldCast(castType, thenNode)) {
0: 			thenElseList.setElementAt(recastNullNode(thenNode, castType), 0);
0: 		// otherwise recurse if it's a conditional
0: 		} else if (isConditionalNode(thenNode)) {
0: 			recastNullNodes(((ConditionalNode)thenNode).thenElseList, castType);
0: 		}
0: 		// check if the "else node is NULL
0: 		if (isNullNode(elseNode) && shouldCast(castType, elseNode)) {
0: 			thenElseList.setElementAt(recastNullNode(elseNode, castType), 1);
0: 		// otherwise recurse if it's a conditional
0: 		} else if (isConditionalNode(elseNode)) {
0: 			recastNullNodes(((ConditionalNode)elseNode).thenElseList, castType);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * recastNullNode casts the nodeToCast node to the typeToUse.
0: 	 *
0: 	 * recastNullNode is called by recastNullNodes.  It is called when the
0: 	 * nodeToCast is an UntypedNullConstantNode that's been cast by the
0: 	 * SQLParser to a CHAR.  The node needs to be recasted to the same type
0: 	 * of the other nodes in order to prevent the type compatibility error
0: 	 * 42X89 from occuring.  SQL Standard requires that:
0: 	 *
0: 	 *  VALUES CASE WHEN 1=2 THEN 3 ELSE NULL END
0: 	 *
0: 	 * returns NULL and not an error message.
0: 	 *
0: 	 * @param nodeToCast    The node that represents a SQL NULL value.
0: 	 * @param typeToUse     The type which the nodeToCast should be
0: 	 *                      recasted too.
0: 	 *
0: 	 * @exception StandardException Thrown on error.
0: 	 */
0: 	private QueryTreeNode recastNullNode(ValueNode nodeToCast,
0: 		DataTypeDescriptor typeToUse) throws StandardException
0: 	{
0: 		QueryTreeNode cast = getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
0: 					((CastNode)nodeToCast).castOperand,
0: 					typeToUse,
0: 					getContextManager());
0: 		return cast;
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
0: 		} else {
0: 			recastNullNodes(thenElseList, findType(thenElseList, fromList));
0:  		}
0: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:2bb198a
/////////////////////////////////////////////////////////////////////////
0: 		if (! thenExpression.getTypeServices().
0: 			 comparable(elseExpression.getTypeServices(), false, getClassFactory()) &&
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bf9ca
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:a09a583
/////////////////////////////////////////////////////////////////////////
1: 	 * {@inheritDoc}
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 		if (testCondition.requiresTypeFromContext())
0: 			testCondition.setType(
/////////////////////////////////////////////////////////////////////////
0: 			if (thenExpression.requiresTypeFromContext())
commit:2537b48
/////////////////////////////////////////////////////////////////////////
0: 	//true means we are here for NULLIF(V1,V2), false means we are here for following
0: 	//CASE WHEN BooleanExpression THEN thenExpression ELSE elseExpression END
0: 	boolean	thisIsNullIfNode;
/////////////////////////////////////////////////////////////////////////
0: 	public void init(Object testCondition, Object thenElseList, Object thisIsNullIfNode)
0: 		this.thisIsNullIfNode = ((Boolean) thisIsNullIfNode).booleanValue();
/////////////////////////////////////////////////////////////////////////
0: 		testCondition = testCondition.bindExpression(fromList,
0: 
0: 		if (thisIsNullIfNode) {
0: 			//for NULLIF(V1,V2), parser binds thenElseList.elementAt(0) to untyped NULL
0: 			//At bind phase, we should bind it to the type of V1 since now we know the
0: 			//type of V1  
0: 			BinaryComparisonOperatorNode bcon = (BinaryComparisonOperatorNode)testCondition;
0: 			QueryTreeNode cast = getNodeFactory().getNode(
0: 						C_NodeTypes.CAST_NODE,
0: 						thenElseList.elementAt(0), 
0: 						bcon.getLeftOperand().getTypeServices(),
0: 						getContextManager());
0: 			thenElseList.setElementAt(cast,0);
0: 		}
0: 		thenElseList.bindExpression(fromList,
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A ConditionalNode represents an if/then/else operator with a single
0:  * boolean expression on the "left" of the operator and a list of expressions on 
0:  * the "right". This is used to represent the java conditional (aka immediate if).
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class ConditionalNode extends ValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	ValueNode		testCondition;
0: 	ValueNodeList	thenElseList;
0: 
0: 	/**
0: 	 * Initializer for a ConditionalNode
0: 	 *
0: 	 * @param testCondition		The boolean test condition
0: 	 * @param thenElseList		ValueNodeList with then and else expressions
0: 	 */
0: 
0: 	public void init(Object testCondition, Object thenElseList)
0: 	{
0: 		this.testCondition = (ValueNode) testCondition;
0: 		this.thenElseList = (ValueNodeList) thenElseList;
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (testCondition != null)
0: 			{
0: 				printLabel(depth, "testCondition: ");
0: 				testCondition.treePrint(depth + 1);
0: 			}
0: 
0: 			if (thenElseList != null)
0: 			{
0: 				printLabel(depth, "thenElseList: ");
0: 				thenElseList.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		super.setClause(clause);
0: 		testCondition.setClause(clause);
0: 		thenElseList.setClause(clause);
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
0: 			throws StandardException
0: 	{
0: 		testCondition = testCondition.bindExpression(fromList, 
0: 			subqueryList,
0: 			aggregateVector);
0: 		thenElseList.bindExpression(fromList, 
0: 			subqueryList,
0: 			aggregateVector);
0: 
0: 		// Can't get the then and else expressions until after they've been bound
0: 		ValueNode thenExpression = (ValueNode) thenElseList.elementAt(0);
0: 		ValueNode elseExpression = (ValueNode) thenElseList.elementAt(1);
0: 
0: 		/* testCondition must be a boolean expression.
0: 		 * If it is a ? parameter on the left, then set type to boolean,
0: 		 * otherwise verify that the result type is boolean.
0: 		 */
0: 		if (testCondition.isParameterNode())
0: 		{
0: 			((ParameterNode) testCondition).setDescriptor(
0: 							new DataTypeDescriptor(
0: 										TypeId.BOOLEAN_ID,
0: 										true));
0: 		}
0: 		else
0: 		{
0: 			if ( ! testCondition.getTypeServices().getTypeId().equals(
0: 														TypeId.BOOLEAN_ID))
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_CONDITIONAL_NON_BOOLEAN);
0: 			}
0: 		}
0: 
0: 		/* We can't determine the type for the result expression if
0: 		 * all result expressions are ?s.
0: 		 */
0: 		if (thenElseList.containsAllParameterNodes())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_ALL_RESULT_EXPRESSIONS_PARAMS, "conditional");
0: 		}
0: 		else if (thenElseList.containsParameterNode())
0: 		{
0: 			/* Set the parameter's type to be the same as the other element in
0: 			 * the list
0: 			 */
0: 
0: 			DataTypeDescriptor dts;
0: 			ValueNode typeExpression;
0: 
0: 			if (thenExpression.isParameterNode())
0: 			{
0: 				dts = elseExpression.getTypeServices();
0: 			}
0: 			else
0: 			{
0: 				dts = thenExpression.getTypeServices();
0: 			}
0: 
0: 			thenElseList.setParameterDescriptor(dts);
0: 		}
0: 
0: 		/* The then and else expressions must be type compatible */
0: 		ClassInspector cu = getClassFactory().getClassInspector();
0: 
0: 		/*
0: 		** If it is comparable, then we are ok.  Note that we
0: 		** could in fact allow any expressions that are convertible()
0: 		** since we are going to generate a cast node, but that might
0: 		** be confusing to users...
0: 		*/
0: 
0: 		// RESOLVE DJDOI - this looks wrong, why should the then expression
0: 		// be comparable to the then expression ??
0: 		if (! thenExpression.getTypeCompiler().
0: 			 comparable(elseExpression.getTypeId(), false, getClassFactory()) &&
0: 			! cu.assignableTo(thenExpression.getTypeId().getCorrespondingJavaTypeName(),
0: 							  elseExpression.getTypeId().getCorrespondingJavaTypeName()) &&
0: 			! cu.assignableTo(elseExpression.getTypeId().getCorrespondingJavaTypeName(),
0: 							  thenExpression.getTypeId().getCorrespondingJavaTypeName()))
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_NOT_TYPE_COMPATIBLE, 
0: 						thenExpression.getTypeId().getSQLTypeName(),
0: 						elseExpression.getTypeId().getSQLTypeName()
0: 						);
0: 		}
0: 
0: 		/*
0: 		** Set the result type of this conditional to be the dominant type
0: 		** of the result expressions.
0: 		*/
0: 		setType(thenElseList.getDominantTypeServices());
0: 
0: 		/*
0: 		** Generate a CastNode if necessary and
0: 		** stick it over the original expression
0: 		*/
0: 		TypeId condTypeId = getTypeId();
0: 		TypeId thenTypeId = ((ValueNode) thenElseList.elementAt(0)).getTypeId();
0: 		TypeId elseTypeId = ((ValueNode) thenElseList.elementAt(1)).getTypeId();
0: 
0: 		/* Need to generate conversion if thenExpr or elseExpr is not of 
0: 		 * dominant type.  (At least 1 of them must be of the dominant type.)
0: 		 */
0: 		if (thenTypeId.typePrecedence() != condTypeId.typePrecedence())
0: 		{
0: 			ValueNode cast = (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.CAST_NODE,
0: 								thenElseList.elementAt(0), 
0: 								dataTypeServices,	// cast to dominant type
0: 								getContextManager());
0: 			cast = cast.bindExpression(fromList, 
0: 											subqueryList,
0: 											aggregateVector);
0: 			
0: 			thenElseList.setElementAt(cast, 0);
0: 		}
0: 
0: 		else if (elseTypeId.typePrecedence() != condTypeId.typePrecedence())
0: 		{
0: 			ValueNode cast = (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.CAST_NODE,
0: 								thenElseList.elementAt(1), 
0: 								dataTypeServices,	// cast to dominant type
0: 								getContextManager());
0: 			cast = cast.bindExpression(fromList, 
0: 											subqueryList,
0: 											aggregateVector);
0: 			
0: 			thenElseList.setElementAt(cast, 1);
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		testCondition = testCondition.preprocess(numTables,
0: 												 outerFromList, outerSubqueryList,
0: 												 outerPredicateList);
0:  		thenElseList.preprocess(numTables,
0: 								outerFromList, outerSubqueryList,
0: 								outerPredicateList);
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		/* We stop here when only considering simple predicates
0: 		 *  as we don't consider conditional operators when looking
0: 		 * for null invariant predicates.
0: 		 */
0: 		if (simplePredsOnly)
0: 		{
0: 			return false;
0: 		}
0: 
0: 		boolean pushable;
0: 
0: 		pushable = testCondition.categorize(referencedTabs, simplePredsOnly);
0: 		pushable = (thenElseList.categorize(referencedTabs, simplePredsOnly) && pushable);
0: 		return pushable;
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return ValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		testCondition = testCondition.remapColumnReferencesToExpressions();
0: 		thenElseList = thenElseList.remapColumnReferencesToExpressions();
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree represents a constant expression.
0: 	 *
0: 	 * @return	Whether or not this expression tree represents a constant expression.
0: 	 */
0: 	public boolean isConstantExpression()
0: 	{
0: 		return (testCondition.isConstantExpression() &&
0: 			    thenElseList.isConstantExpression());
0: 	}
0: 
0: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
0: 	{
0: 		return (testCondition.constantExpression(whereClause) &&
0: 			    thenElseList.constantExpression(whereClause));
0: 	}
0: 
0: 	/**
0: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
0: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
0: 	 * ComparisonOperators and boolean expressions.  We invert 
0: 	 * ComparisonOperators and replace boolean expressions with 
0: 	 * boolean expression = false.
0: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
0: 	 * still could be NotNodes left in the tree.
0: 	 *
0: 	 * @param	underNotNode		Whether or not we are under a NotNode.
0: 	 *							
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	ValueNode eliminateNots(boolean underNotNode) 
0: 					throws StandardException
0: 	{
0: 		ValueNode thenExpression;
0: 		ValueNode elseExpression;
0: 
0: 		if (! underNotNode)
0: 		{
0: 			return this;
0: 		}
0: 
0: 		/* Simply swap the then and else expressions */
0: 		thenExpression = (ValueNode) thenElseList.elementAt(0);
0: 		elseExpression = (ValueNode) thenElseList.elementAt(1);
0: 		thenElseList.setElementAt(elseExpression, 0);
0: 		thenElseList.setElementAt(thenExpression, 1);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this conditional expression.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 * @return	An expression to evaluate this operator
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		testCondition.generateExpression(acb, mb);
0: 		mb.cast(ClassName.BooleanDataValue);
0: 		mb.push(true);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "equals", "boolean", 1);
0: 
0: 		mb.conditionalIf();
0: 		  ((ValueNode) thenElseList.elementAt(0)).generateExpression(acb, mb);
0: 		mb.startElseCode();
0: 		  ((ValueNode) thenElseList.elementAt(1)).generateExpression(acb, mb);
0: 		mb.completeConditional();
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		Visitable returnNode = v.visit(this);
0: 	
0: 		if (v.skipChildren(this))
0: 		{
0: 			return returnNode;
0: 		}
0: 
0: 		if (testCondition != null && !v.stopTraversal())
0: 		{
0: 			testCondition = (ValueNode)testCondition.accept(v);
0: 		}
0: 
0: 		if (thenElseList != null && !v.stopTraversal())
0: 		{
0: 			thenElseList = (ValueNodeList)thenElseList.accept(v);
0: 		}
0: 		
0: 		return returnNode;
0: 	}
0: }
============================================================================