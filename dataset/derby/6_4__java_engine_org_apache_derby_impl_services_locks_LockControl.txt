1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.services.locks.LockControl
1:345de35: 
1:93fea34:    Licensed to the Apache Software Foundation (ASF) under one or more
1:93fea34:    contributor license agreements.  See the NOTICE file distributed with
1:93fea34:    this work for additional information regarding copyright ownership.
1:93fea34:    The ASF licenses this file to you under the Apache License, Version 2.0
1:93fea34:    (the "License"); you may not use this file except in compliance with
1:93fea34:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.services.locks;
1:eac0369: 
1:3c1f634: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
1:eac0369: import org.apache.derby.iapi.services.locks.Lockable;
1:eac0369: import org.apache.derby.iapi.services.locks.Latch;
1:9819cf8: import org.apache.derby.iapi.services.locks.LockOwner;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import java.util.List;
1:eac0369: import java.util.ListIterator;
1:b3eb01a: import java.util.Map;
1:eac0369: 
2:eac0369: /**
1:eac0369: 	A LockControl contains a reference to the item being locked
1:eac0369: 	and doubly linked lists for the granted locks and the waiting
1:eac0369: 	locks.
1:eac0369: 
1:eac0369: 	<P>
1:eac0369: 	MT - Mutable - Container object : single thread required
1:eac0369: 
1:eac0369: */
1:eac0369: 
1:7b8eea6: final class LockControl implements Control {
1:eac0369: 
1:eac0369: 	private final Lockable		ref;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This lock control uses an optimistic locking scheme.
1:eac0369: 		When the first lock on an object is granted it
1:eac0369: 		simply sets firstGrant to be that object, removing the
1:eac0369: 		need to allocate a list if no other locks are granted
1:eac0369: 		before the first lock is release. If a second lock
1:eac0369: 		is granted then a list is allocated and the
1:eac0369: 		firstGrant lock is moved into the list. Once a list
1:eac0369: 		has been created it is always used.
1:eac0369: 	*/
1:eac0369: 	private Lock				firstGrant;
1:a15a470: 	private List<Lock>				granted;
1:a15a470: 	private List<Lock>				waiting;
1:eac0369: 	private Lock				lastPossibleSkip;
1:eac0369: 
1:eac0369: 	protected LockControl(Lock firstLock, Lockable ref) {
1:eac0369: 		super();
1:eac0369: 		this.ref = ref;
1:eac0369: 
1:eac0369: 		// System.out.println("new lockcontrol");
1:eac0369: 
1:eac0369: 		firstGrant = firstLock;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// make a copy by cloning the granted and waiting lists
1:eac0369: 	private LockControl(LockControl copyFrom)
1:eac0369: 	{
1:eac0369: 		super();
1:eac0369: 
1:eac0369: 		this.ref = copyFrom.ref;
1:eac0369: 		this.firstGrant = copyFrom.firstGrant;
1:eac0369: 
1:eac0369: 		if (copyFrom.granted != null)
1:a15a470: 			this.granted = new java.util.LinkedList<Lock>(copyFrom.granted);
1:eac0369: 
1:eac0369: 		if (copyFrom.waiting != null)
1:a15a470: 			this.waiting = new java.util.LinkedList<Lock>(copyFrom.waiting);
1:eac0369: 
1:eac0369: 		this.lastPossibleSkip = copyFrom.lastPossibleSkip;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	public LockControl getLockControl() {
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	*/
1:eac0369: 	public boolean isEmpty() {
1:eac0369: 
1:eac0369: 		// if we are locked then we are not empty
1:eac0369: 		if (!isUnlocked())
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		return (waiting == null) || waiting.isEmpty();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Grant this lock.
1:eac0369: 	*/
1:eac0369: 	void grant(Lock lockItem) {
1:eac0369: 
1:eac0369: 		lockItem.grant();
1:eac0369: 
1:a15a470: 		List<Lock> lgranted = granted;
1:eac0369: 		
1:eac0369: 		if (lgranted == null) {
1:eac0369: 			if (firstGrant == null) {
1:eac0369: 				// first ever lock on this item
1:eac0369: 				firstGrant = lockItem;
1:eac0369: 			} else {
1:eac0369: 				// second ever lock on this item
1:a15a470: 				lgranted = granted = new java.util.LinkedList<Lock>();
1:eac0369: 				lgranted.add(firstGrant);
1:eac0369: 				lgranted.add(lockItem);
1:eac0369: 				firstGrant = null;
1:eac0369: 			}
1:eac0369: 		} else {
1:eac0369: 			// this grants the lock
1:eac0369: 			lgranted.add(lockItem);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	*/
1:eac0369: 	public boolean unlock(Latch lockInGroup, int unlockCount) {
1:eac0369: 
1:eac0369: 		// note that lockInGroup is not the actual Lock object held in the lock set.
1:eac0369: 
1:eac0369: 		if (unlockCount == 0)
1:eac0369: 			unlockCount = lockInGroup.getCount();
1:eac0369: 
1:a15a470: 		List<Lock> lgranted = granted;
1:eac0369: 			
1:eac0369: 		// start at the begining of the list when there is one
1:eac0369: 		for (int index = 0; unlockCount > 0; ) {
1:eac0369: 
1:eac0369: 			Lock lockInSet;
1:eac0369: 
1:eac0369: 			if (firstGrant != null) {
1:eac0369: 				if (SanityManager.DEBUG) {
1:eac0369: 					SanityManager.ASSERT(lockInGroup.equals(firstGrant));
1:eac0369: 				}
1:eac0369: 				lockInSet = firstGrant;
1:eac0369: 			} else {
1:eac0369: 				// index = lgranted.indexOf(index, lgranted.size() - 1, lockInGroup);
1:eac0369: 				/*List*/ index = lgranted.indexOf(lockInGroup);
1:eac0369: 			
1:eac0369: 				if (SanityManager.DEBUG) {
1:eac0369: 					SanityManager.ASSERT(index != -1);
1:eac0369: 				}
1:a15a470: 				lockInSet = lgranted.get(index);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			unlockCount -= lockInSet.unlock(unlockCount);
1:eac0369: 
1:eac0369: 			if (lockInSet.getCount() != 0) {
1:eac0369: 				if (SanityManager.DEBUG) {
1:eac0369: 					if (unlockCount != 0)
1:eac0369: 						SanityManager.THROWASSERT("locked item didn't reduce unlock count to zero " + unlockCount);
1:eac0369: 				}
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (firstGrant == lockInSet) {
1:eac0369: 				if (SanityManager.DEBUG) {
1:eac0369: 					if (unlockCount != 0)
1:eac0369: 						SanityManager.THROWASSERT("item is still locked! " + unlockCount);
1:eac0369: 				}
1:eac0369: 				firstGrant = null;
1:eac0369: 			}
1:eac0369: 			else {
1:eac0369: 				lgranted.remove(index);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:         This routine can be called to see if a lock currently on the wait
1:eac0369:         list could be granted. If this lock has waiters ahead of it
1:eac0369: 		then we do not jump over the waiter(s) even if we can be granted.
1:eac0369: 		 This avoids the first waiter being starved out.
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     public boolean isGrantable(
1:eac0369:     boolean noWaitersBeforeMe,
1:3c1f634:     CompatibilitySpace compatibilitySpace,
1:eac0369:     Object  qualifier)
1:eac0369:     {
1:eac0369: 		if (isUnlocked())
1:eac0369: 			return true;
1:eac0369: 
1:eac0369:         boolean grantLock    = false;
1:eac0369: 
1:eac0369: 		Lockable lref = ref;
1:a15a470: 		List<Lock> lgranted = granted;
1:eac0369: 
1:eac0369:         {
1:eac0369:             // Check to see if the only locks on the granted queue that
1:eac0369:             // we are incompatible with are locks we own.
1:eac0369:             boolean selfCompatible = lref.lockerAlwaysCompatible();
1:eac0369: 
1:eac0369: 			int index = 0;
1:eac0369: 			int endIndex = firstGrant == null ? lgranted.size() : 0;
1:eac0369: 			do {
1:eac0369: 
1:a15a470: 				Lock gl = firstGrant == null ? lgranted.get(index) : firstGrant;
1:eac0369: 
1:3c1f634:                 boolean sameSpace = 
1:3c1f634:                     (gl.getCompatabilitySpace() == compatibilitySpace);
1:eac0369: 
1:eac0369:                 if (sameSpace && selfCompatible) 
1:eac0369:                 {
1:eac0369:                     // if it's one of our locks and we are always compatible 
1:eac0369:                     // with our own locks then yes, we can be granted.
1:eac0369:                     
1:eac0369:                     grantLock = true;
1:eac0369:                     continue;
1:eac0369:                 }
1:eac0369:                 else if (!lref.requestCompatible(qualifier, gl.getQualifier())) 
1:eac0369:                 {
1:eac0369:                     // If we are not compatible with some already granted lock
1:eac0369:                     // then we can't be granted, give up right away.
1:eac0369:                     
1:eac0369:                     grantLock = false;
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     // We are compatible with this lock, if it's our own or 
1:eac0369:                     // there are no other waiters then we can be granted.
1:eac0369:                 
1:eac0369:                     if (sameSpace || noWaitersBeforeMe) 
1:eac0369:                     {
1:eac0369:                         grantLock = true;
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             } while (++index < endIndex);
1:eac0369: 		}
1:eac0369: 
1:eac0369:         return(grantLock);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add a lock into this control, granted it if possible.
1:eac0369: 
1:eac0369: 		This can be entered in several states.
1:eac0369: 
1:eac0369: 		</OL>
1:eac0369: 		<LI>The Lockable is locked (granted queue not empty), and there are no waiters (waiting queue is empty)
1:eac0369: 		<LI>The Lockable is locked and there are waiters
1:eac0369: 		<LI>The Lockable is locked and there are waiters and the first is potentially granted
1:eac0369: 		<LI>The Lockable is unlocked and there are waiters and the first is potentially granted. Logically the item is
1:eac0369: 		    still locked, it's just that the lock has just been released and the first waker has not woken up yet.
1:eac0369: 		</OL>
1:eac0369: 		This call is never entered when the object is unlocked and there are no waiters.
1:eac0369: 
1:eac0369: 	
1:eac0369: 		1) The Lockable has just been unlocked, 
1:eac0369: 	*/
1:eac0369: 
1:b3eb01a: 	public Lock addLock(LockTable ls, CompatibilitySpace compatibilitySpace,
1:3c1f634: 						Object qualifier) {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 			if (!(!isUnlocked() || (firstWaiter() != null)))
1:eac0369: 				SanityManager.THROWASSERT("entered in totally unlocked mode " + isUnlocked() + " " + (firstWaiter() != null));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// If there are other waiters for this lock then we
1:eac0369: 		// will only grant this lock if we already hold a lock.
1:eac0369: 		// This stops a lock being frozen out while compatible locks
1:eac0369: 		// jump past it.
1:eac0369: 		boolean grantLock = false;		
1:eac0369: 		boolean otherWaiters = (firstWaiter() != null);
1:eac0369: 
1:eac0369: 		Lock lockItem = null;
1:eac0369: 		Lockable lref = ref;
1:eac0369: 
1:eac0369: 		// If we haven't been able to grant the lock yet then see if we hold a 
1:eac0369:         // lock already that we are compatible with and there are no granted 
1:eac0369:         // incompatible locks. If the object appears unlocked (due to a just 
1:eac0369:         // released lock, but the first waiter hasn't woken yet)
1:eac0369: 		// then we obviously don't hold a lock, so just join the wait queue.
1:eac0369: 		boolean spaceHasALock = false;
1:eac0369: 		boolean noGrantAtAll = false;
1:7b8eea6: 		if (!isUnlocked()) {
1:eac0369: 
1:eac0369: 			boolean selfCompatible = lref.lockerAlwaysCompatible();
1:eac0369: 			
1:eac0369: 			int index = 0;
1:eac0369: 			int endIndex = firstGrant == null ? granted.size() : 0;
1:eac0369: 			do {
1:eac0369: 
1:a15a470: 				Lock gl = firstGrant == null ? granted.get(index) : firstGrant;
1:eac0369: 
1:eac0369: 
1:eac0369: 				boolean sameSpace =
1:3c1f634: 					(gl.getCompatabilitySpace() == compatibilitySpace);
1:eac0369: 
1:eac0369: 				// if it's one of our locks and we are always compatible with 
1:eac0369:                 // our own locks then yes, we can be granted.
1:eac0369: 				if (sameSpace && selfCompatible) {
1:eac0369: 
1:eac0369: 					spaceHasALock = true;
1:eac0369: 
1:eac0369: 					if (noGrantAtAll)
1:eac0369: 						break;
1:eac0369: 
1:eac0369: 					if (qualifier == gl.getQualifier())
1:eac0369: 						lockItem = gl;
1:eac0369: 
1:eac0369: 					grantLock = true;
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 				// If we are not compatible with some already granted lock
1:eac0369:                 // then we can't be granted, give up right away.
1:eac0369: 				if (!lref.requestCompatible(qualifier, gl.getQualifier())) {
1:eac0369: 					grantLock = false;
1:eac0369: 					lockItem = null;
1:eac0369: 
1:eac0369: 					// we can't give up rightaway if spaceHasALock is false
1:eac0369: 					// because we need to ensure that canSkip is set correctly
1:eac0369: 					if (spaceHasALock)
1:eac0369: 						break;
1:eac0369: 
1:eac0369: 					noGrantAtAll = true;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// We are compatible with this lock, if it's our own or there
1:eac0369:                 // are no other waiters then yes we can still be granted ...
1:eac0369: 				
1:eac0369: 				if (!noGrantAtAll && (sameSpace || !otherWaiters)) {
1:eac0369: 					grantLock = true;
1:eac0369: 				}
1:eac0369: 			} while (++index < endIndex);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (lockItem != null) {
1:eac0369: 			if (SanityManager.DEBUG) {
1:eac0369: 				if (!grantLock) {
1:eac0369: 					SanityManager.THROWASSERT("lock is not granted !" + lockItem);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// we already held a lock of this type, just bump the lock count
1:eac0369: 			lockItem.count++;
1:eac0369: 			return lockItem;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (grantLock) {
1:3c1f634: 			lockItem = new Lock(compatibilitySpace, lref, qualifier);
1:eac0369: 			grant(lockItem);
1:eac0369: 			return lockItem;
1:eac0369: 		}
1:eac0369: 		
1:3c1f634: 		ActiveLock waitingLock =
1:3c1f634: 			new ActiveLock(compatibilitySpace, lref, qualifier);
1:eac0369: 
1:3c1f634: 		// If the object is already locked by this compatibility space
1:eac0369: 		// then this lock can be granted by skipping other waiters.
1:eac0369: 		if (spaceHasALock) {
1:eac0369: 			waitingLock.canSkip = true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (waiting == null)
1:a15a470: 			waiting = new java.util.LinkedList<Lock>();
1:eac0369: 
1:eac0369: 		// Add lock to the waiting list
1:7b8eea6: 		addWaiter(waitingLock, ls);
1:eac0369: 
1:eac0369: 		if (waitingLock.canSkip) {
1:eac0369: 			lastPossibleSkip = waitingLock;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return waitingLock;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected boolean isUnlocked() {
1:eac0369: 
1:eac0369: 		// If firstGrant is set then this object is locked
1:eac0369: 		if (firstGrant != null)
1:eac0369: 			return false;
1:eac0369: 
1:a15a470: 		List<Lock> lgranted = granted;
1:eac0369: 
1:eac0369: 		return (lgranted == null) || lgranted.isEmpty();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the first lock in the wait line, null if the
1:eac0369: 		line is empty.
1:eac0369: 	*/
1:eac0369: 	public ActiveLock firstWaiter() {
1:eac0369: 		if ((waiting == null) || waiting.isEmpty())
1:eac0369: 			return null;
1:eac0369: 		return (ActiveLock) waiting.get(0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:9819cf8: 	/**
1:eac0369: 		Get the next waiting lock (if any).
1:eac0369: 	*/
1:b3eb01a: 	ActiveLock getNextWaiter(ActiveLock item, boolean remove, LockTable ls) {
1:eac0369: 
1:eac0369: 		ActiveLock nextWaitingLock = null;
1:eac0369: 
1:eac0369: 		if (remove && (waiting.get(0) == item))
1:eac0369: 		{
1:eac0369: 			// item is at the head of the list and being removed,
1:eac0369: 			// always return the next waiter
1:7b8eea6: 			popFrontWaiter(ls);
1:eac0369: 
1:eac0369: 			nextWaitingLock = firstWaiter();
1:eac0369: 		}
1:eac0369: 		else if ((lastPossibleSkip != null) && (lastPossibleSkip != item))
1:eac0369: 		{
1:eac0369: 			// there are potential locks that could be granted
1:eac0369: 			// and the last one is not the lock we just looked at.
1:eac0369: 
1:eac0369: 			// need to find the first lock after the one passed
1:eac0369: 			// in that has the canSkip flag set.
1:eac0369: 
1:eac0369: 			int itemIndex = waiting.indexOf(item);
1:eac0369: 			int removeIndex = remove ? itemIndex : -1;
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 			// skip the entry we just looked at.
1:eac0369: 			/*List*/
1:eac0369: 			// dli.advance();
1:eac0369: 			// for (; !dli.atEnd(); dli.advance()) {
1:eac0369: 
1:eac0369: 			if (itemIndex != waiting.size() - 1) {
1:eac0369: 
1:eac0369: 			for (ListIterator li = waiting.listIterator(itemIndex + 1); li.hasNext();) {
1:eac0369: 				//ActiveLock al = (ActiveLock) dli.get();
1:eac0369: 				ActiveLock al = (ActiveLock) li.next();
1:eac0369: 
1:eac0369: 				if (al.canSkip) {
1:eac0369: 					nextWaitingLock = al;
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (remove) {
1:7b8eea6: 				removeWaiter(removeIndex, ls);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		} else {
1:eac0369: 			if (remove) {
1:7b8eea6: 				int count = removeWaiter(item, ls);
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG) {
1:eac0369: 					if (count != 1)
1:eac0369: 					{
1:eac0369: 						SanityManager.THROWASSERT(
1:eac0369: 							"count = " + count + "item = " + item + 
1:eac0369: 							"waiting = " + waiting);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (remove && (item == lastPossibleSkip))
1:eac0369: 			lastPossibleSkip = null;
1:eac0369: 
1:eac0369: 		if (nextWaitingLock != null) {
1:eac0369: 			if (!nextWaitingLock.setPotentiallyGranted())
1:eac0369: 				nextWaitingLock = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return nextWaitingLock;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the lockable object controlled by me.
1:eac0369: 	*/
1:eac0369: 	public Lockable getLockable() {
1:eac0369: 		return ref;
1:eac0369: 	}
1:eac0369: 	public Lock getFirstGrant() {
1:eac0369: 		return firstGrant;
1:eac0369: 	}
1:a15a470: 	public List<Lock> getGranted() {
1:eac0369: 		return granted;
1:eac0369: 	}
1:a15a470: 	public List<Lock> getWaiting() {
1:eac0369: 		return waiting;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Give up waiting up on a lock
1:eac0369: 	*/
1:eac0369: 
1:b3eb01a: 	protected void giveUpWait(Object item, LockTable ls) {
1:eac0369: 
1:7b8eea6: 		int count = removeWaiter(item, ls);
1:eac0369: 		if (item == lastPossibleSkip)
1:eac0369: 			lastPossibleSkip = null;	
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369:             if (count != 1)
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "count = " + count + "item = " + item + 
1:eac0369:                     "waiting = " + waiting);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Deadlock support.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:b3eb01a: 		Add the waiters of this lock into this Map object.
1:eac0369: 		<BR>
1:eac0369: 		Each waiting thread gets two entries in the hashtable
1:eac0369: 		<OL>
1:eac0369: 		<LI>key=compatibility space - value=ActiveLock
1:eac0369: 		<LI>key=ActiveLock - value={LockControl for first waiter|ActiveLock of previosue waiter}
1:eac0369: 		</OL>
1:eac0369: 	*/
1:a15a470: 	public void addWaiters(Map<Object,Object> waiters) {
1:eac0369: 		
1:eac0369: 		if ((waiting == null) || waiting.isEmpty())
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		Object previous = this;
1:eac0369: 		for (ListIterator li = waiting.listIterator(); li.hasNext(); ) {
1:eac0369: 
1:eac0369: 			ActiveLock waitingLock = ((ActiveLock) li.next());
1:eac0369: 
1:eac0369: 			Object waiter = waitingLock.getCompatabilitySpace();
1:eac0369: 
1:eac0369: 			waiters.put(waiter, waitingLock);
1:eac0369: 			waiters.put(waitingLock, previous);
1:eac0369: 			previous = waitingLock;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a Stack of the
1:eac0369: 		held locks (Lock objects) on this Lockable.
1:eac0369: 	*/
1:a15a470: 	List<Lock> getGrants() {
1:eac0369: 
1:a15a470: 		List<Lock> ret;
1:eac0369: 
1:eac0369: 		if (firstGrant != null) {
1:a15a470: 			ret = new java.util.LinkedList<Lock>();
1:eac0369: 			ret.add(firstGrant);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:a15a470: 			ret = new java.util.LinkedList<Lock>(granted);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return ret;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Find a granted lock matching this space and qualifier
1:eac0369: 	*/
1:3c1f634: 	public final Lock getLock(CompatibilitySpace compatibilitySpace,
1:3c1f634: 							  Object qualifier) {
1:eac0369: 
1:eac0369: 		if (isUnlocked())
1:eac0369: 			return null;
1:eac0369: 
1:a15a470: 		List<Lock> lgranted = granted;
1:eac0369: 
1:eac0369: 
1:eac0369: 		int index = 0;
1:eac0369: 		int endIndex = firstGrant == null ? lgranted.size() : 0;
1:eac0369: 		do {
1:eac0369: 
1:a15a470: 			Lock gl = firstGrant == null ? lgranted.get(index) : firstGrant;
1:eac0369: 
1:3c1f634:             if (gl.getCompatabilitySpace() != compatibilitySpace)
1:eac0369: 				continue;
1:eac0369: 
1:eac0369: 			if (gl.getQualifier() == qualifier)
1:eac0369: 				return gl;
1:eac0369: 
1:eac0369:         } while (++index < endIndex);
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:9819cf8:      * <p>
1:9819cf8:      * Returns true if the childLock is blocked because its parent owns
1:9819cf8:      * a conficting lock.
1:9819cf8:      * This code was written to support the fix to DERBY-6554. The only known
1:9819cf8:      * way that this condition arises is when a write attempt by a nested user
1:9819cf8:      * transaction is blocked by a read lock held by the main transaction.
1:9819cf8:      * This only happens while trying to write to SYS.SYSSEQUENCES while
1:9819cf8:      * managing sequence generators.
1:9819cf8:      * </p>
1:9819cf8:      */
1:9819cf8:     public boolean blockedByParent( Lock childLock )
1:9819cf8:     {
1:9819cf8:         if ( granted == null ) { return false; }
1:9819cf8:         
1:9819cf8:         LockOwner   childOwner = childLock.getCompatabilitySpace().getOwner();
1:9819cf8:         Object          requestedQualifier = childLock.getQualifier();
1:9819cf8: 
1:9819cf8:         for ( Lock grantedLock : granted )
1:9819cf8:         {
1:9819cf8:             LockOwner   ownerOfGrant = grantedLock.getCompatabilitySpace().getOwner();
1:9819cf8: 
1:9819cf8:             if ( childOwner.nestsUnder( ownerOfGrant ) )
1:9819cf8:             {
1:9819cf8:                 Object  grantedQualifier = grantedLock.getQualifier();
1:9819cf8: 
1:9819cf8:                 if ( !grantedLock.getLockable().requestCompatible( requestedQualifier, grantedQualifier ) )
1:9819cf8:                 {
1:9819cf8:                     return true;
1:9819cf8:                 }
1:9819cf8:             }
1:9819cf8:         }
1:9819cf8: 
1:9819cf8:         return false;
1:9819cf8:     }
1:9819cf8: 
1:eac0369: //EXCLUDE-START-lockdiag- 
1:eac0369: 	/**
1:eac0369: 	 * make a shallow clone of myself
1:eac0369: 	 */
1:eac0369: 	/* package */
1:eac0369: 	public Control shallowClone()
1:eac0369: 	{
1:eac0369: 		return new LockControl(this);
1:eac0369: 	}
1:eac0369: //EXCLUDE-END-lockdiag- 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a lock request to a list of waiters.
1:eac0369: 	 *
1:eac0369: 	 * @param lockItem	The lock request
1:b3eb01a: 	 * @param ls		The lock table
1:eac0369: 	 */
1:7b8eea6: 	private void addWaiter(Lock lockItem, LockTable ls) {
1:eac0369: 
1:eac0369: 		// Add lock to the waiting list
1:eac0369: 		waiting.add(lockItem);
1:eac0369: 
2:eac0369: 		// Maintain count of waiters
1:eac0369: 		ls.oneMoreWaiter();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remove and return the first lock request from a list of waiters.
1:eac0369: 	 *
1:b3eb01a: 	 * @param ls		The lock table
1:eac0369: 	 *
1:eac0369: 	 * @return	The removed lock request
1:eac0369: 	 */
1:7b8eea6: 	private Object popFrontWaiter(LockTable ls) {
1:7b8eea6: 		return removeWaiter(0, ls);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remove and return the lock request at the given index
1:eac0369: 	 * from a list of waiters.
1:eac0369: 	 *
1:eac0369: 	 * @param index		The index at which to remove the lock request
1:b3eb01a: 	 * @param ls		The lock table
1:eac0369: 	 *
1:eac0369: 	 * @return	The removed lock request
1:eac0369: 	 */
1:7b8eea6: 	private Object removeWaiter(int index, LockTable ls) {
1:eac0369: 		// Maintain count of waiters
2:eac0369: 		ls.oneLessWaiter();
1:eac0369: 
2:eac0369: 		// Remove and return the first lock request
1:eac0369: 		return waiting.remove(index);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remove and return the given lock request from a list of waiters.
1:eac0369: 	 *
1:eac0369: 	 * @param item		The item to remove
1:b3eb01a: 	 * @param ls		The lock table
1:eac0369: 	 *
1:eac0369: 	 * @return	The number of items removed
1:eac0369: 	 */
1:7b8eea6: 	private int removeWaiter(Object item, LockTable ls) {
1:eac0369: 		// Maintain count of waiters
1:eac0369: 		ls.oneLessWaiter();
1:eac0369: 
1:eac0369: 		// Remove item and return number of items removed
1:eac0369: 		return waiting.remove(item) ? 1 : 0;
1:eac0369: 	}
1:eac0369: }
1:eac0369: 
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9819cf8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.locks.LockOwner;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Returns true if the childLock is blocked because its parent owns
1:      * a conficting lock.
1:      * This code was written to support the fix to DERBY-6554. The only known
1:      * way that this condition arises is when a write attempt by a nested user
1:      * transaction is blocked by a read lock held by the main transaction.
1:      * This only happens while trying to write to SYS.SYSSEQUENCES while
1:      * managing sequence generators.
1:      * </p>
1:      */
1:     public boolean blockedByParent( Lock childLock )
1:     {
1:         if ( granted == null ) { return false; }
1:         
1:         LockOwner   childOwner = childLock.getCompatabilitySpace().getOwner();
1:         Object          requestedQualifier = childLock.getQualifier();
1: 
1:         for ( Lock grantedLock : granted )
1:         {
1:             LockOwner   ownerOfGrant = grantedLock.getCompatabilitySpace().getOwner();
1: 
1:             if ( childOwner.nestsUnder( ownerOfGrant ) )
1:             {
1:                 Object  grantedQualifier = grantedLock.getQualifier();
1: 
1:                 if ( !grantedLock.getLockable().requestCompatible( requestedQualifier, grantedQualifier ) )
1:                 {
1:                     return true;
1:                 }
1:             }
1:         }
1: 
1:         return false;
1:     }
1: 
commit:a15a470
/////////////////////////////////////////////////////////////////////////
1: 	private List<Lock>				granted;
1: 	private List<Lock>				waiting;
/////////////////////////////////////////////////////////////////////////
1: 			this.granted = new java.util.LinkedList<Lock>(copyFrom.granted);
1: 			this.waiting = new java.util.LinkedList<Lock>(copyFrom.waiting);
/////////////////////////////////////////////////////////////////////////
1: 		List<Lock> lgranted = granted;
/////////////////////////////////////////////////////////////////////////
1: 				lgranted = granted = new java.util.LinkedList<Lock>();
/////////////////////////////////////////////////////////////////////////
1: 		List<Lock> lgranted = granted;
/////////////////////////////////////////////////////////////////////////
1: 				lockInSet = lgranted.get(index);
/////////////////////////////////////////////////////////////////////////
1: 		List<Lock> lgranted = granted;
/////////////////////////////////////////////////////////////////////////
1: 				Lock gl = firstGrant == null ? lgranted.get(index) : firstGrant;
/////////////////////////////////////////////////////////////////////////
1: 				Lock gl = firstGrant == null ? granted.get(index) : firstGrant;
/////////////////////////////////////////////////////////////////////////
1: 			waiting = new java.util.LinkedList<Lock>();
/////////////////////////////////////////////////////////////////////////
1: 		List<Lock> lgranted = granted;
/////////////////////////////////////////////////////////////////////////
1: 	public List<Lock> getGranted() {
1: 	public List<Lock> getWaiting() {
/////////////////////////////////////////////////////////////////////////
1: 	public void addWaiters(Map<Object,Object> waiters) {
/////////////////////////////////////////////////////////////////////////
1: 	List<Lock> getGrants() {
1: 		List<Lock> ret;
1: 			ret = new java.util.LinkedList<Lock>();
1: 			ret = new java.util.LinkedList<Lock>(granted);
/////////////////////////////////////////////////////////////////////////
1: 		List<Lock> lgranted = granted;
1: 			Lock gl = firstGrant == null ? lgranted.get(index) : firstGrant;
commit:93fea34
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:7b8eea6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: final class LockControl implements Control {
/////////////////////////////////////////////////////////////////////////
1: 		if (!isUnlocked()) {
/////////////////////////////////////////////////////////////////////////
1: 		addWaiter(waitingLock, ls);
/////////////////////////////////////////////////////////////////////////
1: 			popFrontWaiter(ls);
/////////////////////////////////////////////////////////////////////////
1: 				removeWaiter(removeIndex, ls);
1: 				int count = removeWaiter(item, ls);
/////////////////////////////////////////////////////////////////////////
1: 		int count = removeWaiter(item, ls);
/////////////////////////////////////////////////////////////////////////
1: 	private void addWaiter(Lock lockItem, LockTable ls) {
/////////////////////////////////////////////////////////////////////////
1: 	private Object popFrontWaiter(LockTable ls) {
1: 		return removeWaiter(0, ls);
/////////////////////////////////////////////////////////////////////////
1: 	private Object removeWaiter(int index, LockTable ls) {
/////////////////////////////////////////////////////////////////////////
1: 	private int removeWaiter(Object item, LockTable ls) {
commit:15fbc15
/////////////////////////////////////////////////////////////////////////
0: 		return removeWaiter(waiting, 0, ls);
commit:b3eb01a
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: 	public Lock addLock(LockTable ls, CompatibilitySpace compatibilitySpace,
/////////////////////////////////////////////////////////////////////////
1: 	ActiveLock getNextWaiter(ActiveLock item, boolean remove, LockTable ls) {
/////////////////////////////////////////////////////////////////////////
1: 	protected void giveUpWait(Object item, LockTable ls) {
/////////////////////////////////////////////////////////////////////////
1: 		Add the waiters of this lock into this Map object.
/////////////////////////////////////////////////////////////////////////
0: 	public void addWaiters(Map waiters) {
/////////////////////////////////////////////////////////////////////////
1: 	 * @param ls		The lock table
0: 						LockTable ls) {
/////////////////////////////////////////////////////////////////////////
1: 	 * @param ls		The lock table
0: 	private Object popFrontWaiter(List waiting, LockTable ls) {
/////////////////////////////////////////////////////////////////////////
1: 	 * @param ls		The lock table
0: 								LockTable ls) {
/////////////////////////////////////////////////////////////////////////
1: 	 * @param ls		The lock table
0: 								LockTable ls) {
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
/////////////////////////////////////////////////////////////////////////
1:     CompatibilitySpace compatibilitySpace,
/////////////////////////////////////////////////////////////////////////
1:                     (gl.getCompatabilitySpace() == compatibilitySpace);
/////////////////////////////////////////////////////////////////////////
0: 	public Lock addLock(LockSet ls, CompatibilitySpace compatibilitySpace,
1: 						Object qualifier) {
/////////////////////////////////////////////////////////////////////////
1: 				boolean sameSpace =
1: 					(gl.getCompatabilitySpace() == compatibilitySpace);
/////////////////////////////////////////////////////////////////////////
1: 			lockItem = new Lock(compatibilitySpace, lref, qualifier);
1: 		ActiveLock waitingLock =
1: 			new ActiveLock(compatibilitySpace, lref, qualifier);
1: 		// If the object is already locked by this compatibility space
/////////////////////////////////////////////////////////////////////////
1: 	public final Lock getLock(CompatibilitySpace compatibilitySpace,
1: 							  Object qualifier) {
/////////////////////////////////////////////////////////////////////////
1:             if (gl.getCompatabilitySpace() != compatibilitySpace)
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.services.locks.LockControl
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.locks
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.services.locks;
1: 
1: import org.apache.derby.iapi.services.locks.Lockable;
1: import org.apache.derby.iapi.services.locks.Latch;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import java.util.Dictionary;
0: import java.util.Stack;
1: import java.util.List;
1: import java.util.ListIterator;
1: 
1: /**
1: 	A LockControl contains a reference to the item being locked
1: 	and doubly linked lists for the granted locks and the waiting
1: 	locks.
1: 
1: 	<P>
1: 	MT - Mutable - Container object : single thread required
1: 
1: */
1: 
0: public class LockControl implements Control {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private final Lockable		ref;
1: 
1: 	/**
1: 		This lock control uses an optimistic locking scheme.
1: 		When the first lock on an object is granted it
1: 		simply sets firstGrant to be that object, removing the
1: 		need to allocate a list if no other locks are granted
1: 		before the first lock is release. If a second lock
1: 		is granted then a list is allocated and the
1: 		firstGrant lock is moved into the list. Once a list
1: 		has been created it is always used.
1: 	*/
1: 	private Lock				firstGrant;
0: 	private List				granted;
0: 	private List				waiting;
1: 	private Lock				lastPossibleSkip;
1: 
1: 	protected LockControl(Lock firstLock, Lockable ref) {
1: 		super();
1: 		this.ref = ref;
1: 
1: 		// System.out.println("new lockcontrol");
1: 
1: 		firstGrant = firstLock;
1: 	}
1: 
1: 	// make a copy by cloning the granted and waiting lists
1: 	private LockControl(LockControl copyFrom)
1: 	{
1: 		super();
1: 
1: 		this.ref = copyFrom.ref;
1: 		this.firstGrant = copyFrom.firstGrant;
1: 
1: 		if (copyFrom.granted != null)
0: 			this.granted = new java.util.LinkedList(copyFrom.granted);
1: 
1: 		if (copyFrom.waiting != null)
0: 			this.waiting = new java.util.LinkedList(copyFrom.waiting);
1: 
1: 		this.lastPossibleSkip = copyFrom.lastPossibleSkip;
1: 	}
1: 	
1: 	public LockControl getLockControl() {
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	*/
1: 	public boolean isEmpty() {
1: 
1: 		// if we are locked then we are not empty
1: 		if (!isUnlocked())
1: 			return false;
1: 
1: 		return (waiting == null) || waiting.isEmpty();
1: 	}
1: 
1: 	/**
1: 		Grant this lock.
1: 	*/
1: 	void grant(Lock lockItem) {
1: 
1: 		lockItem.grant();
1: 
0: 		List lgranted = granted;
1: 		
1: 		if (lgranted == null) {
1: 			if (firstGrant == null) {
1: 				// first ever lock on this item
1: 				firstGrant = lockItem;
1: 			} else {
1: 				// second ever lock on this item
0: 				lgranted = granted = new java.util.LinkedList();
1: 				lgranted.add(firstGrant);
1: 				lgranted.add(lockItem);
1: 				firstGrant = null;
1: 			}
1: 		} else {
1: 			// this grants the lock
1: 			lgranted.add(lockItem);
1: 		}
1: 	}
1: 
1: 	/**
1: 	*/
1: 	public boolean unlock(Latch lockInGroup, int unlockCount) {
1: 
1: 		// note that lockInGroup is not the actual Lock object held in the lock set.
1: 
1: 		if (unlockCount == 0)
1: 			unlockCount = lockInGroup.getCount();
1: 
0: 		List lgranted = granted;
1: 			
1: 		// start at the begining of the list when there is one
1: 		for (int index = 0; unlockCount > 0; ) {
1: 
1: 			Lock lockInSet;
1: 
1: 			if (firstGrant != null) {
1: 				if (SanityManager.DEBUG) {
1: 					SanityManager.ASSERT(lockInGroup.equals(firstGrant));
1: 				}
1: 				lockInSet = firstGrant;
1: 			} else {
1: 				// index = lgranted.indexOf(index, lgranted.size() - 1, lockInGroup);
1: 				/*List*/ index = lgranted.indexOf(lockInGroup);
1: 			
1: 				if (SanityManager.DEBUG) {
1: 					SanityManager.ASSERT(index != -1);
1: 				}
0: 				lockInSet = (Lock) lgranted.get(index);
1: 			}
1: 
1: 			unlockCount -= lockInSet.unlock(unlockCount);
1: 
1: 			if (lockInSet.getCount() != 0) {
1: 				if (SanityManager.DEBUG) {
1: 					if (unlockCount != 0)
1: 						SanityManager.THROWASSERT("locked item didn't reduce unlock count to zero " + unlockCount);
1: 				}
1: 				continue;
1: 			}
1: 
1: 			if (firstGrant == lockInSet) {
1: 				if (SanityManager.DEBUG) {
1: 					if (unlockCount != 0)
1: 						SanityManager.THROWASSERT("item is still locked! " + unlockCount);
1: 				}
1: 				firstGrant = null;
1: 			}
1: 			else {
1: 				lgranted.remove(index);
1: 			}
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1:         This routine can be called to see if a lock currently on the wait
1:         list could be granted. If this lock has waiters ahead of it
1: 		then we do not jump over the waiter(s) even if we can be granted.
1: 		 This avoids the first waiter being starved out.
1: 	*/
1: 
1:     public boolean isGrantable(
1:     boolean noWaitersBeforeMe,
0:     Object  compatabilitySpace, 
1:     Object  qualifier)
1:     {
1: 		if (isUnlocked())
1: 			return true;
1: 
1:         boolean grantLock    = false;
1: 
1: 		Lockable lref = ref;
0: 		List lgranted = granted;
1: 
1:         {
1:             // Check to see if the only locks on the granted queue that
1:             // we are incompatible with are locks we own.
1:             boolean selfCompatible = lref.lockerAlwaysCompatible();
1: 
1: 			int index = 0;
1: 			int endIndex = firstGrant == null ? lgranted.size() : 0;
1: 			do {
1: 
0: 				Lock gl = firstGrant == null ? (Lock) lgranted.get(index) : firstGrant;
1: 
1:                 boolean sameSpace = 
0:                     (gl.getCompatabilitySpace().equals(compatabilitySpace));
1: 
1:                 if (sameSpace && selfCompatible) 
1:                 {
1:                     // if it's one of our locks and we are always compatible 
1:                     // with our own locks then yes, we can be granted.
1:                     
1:                     grantLock = true;
1:                     continue;
1:                 }
1:                 else if (!lref.requestCompatible(qualifier, gl.getQualifier())) 
1:                 {
1:                     // If we are not compatible with some already granted lock
1:                     // then we can't be granted, give up right away.
1:                     
1:                     grantLock = false;
1:                     break;
1:                 }
1:                 else
1:                 {
1:                     // We are compatible with this lock, if it's our own or 
1:                     // there are no other waiters then we can be granted.
1:                 
1:                     if (sameSpace || noWaitersBeforeMe) 
1:                     {
1:                         grantLock = true;
1:                     }
1:                 }
1:             } while (++index < endIndex);
1: 		}
1: 
1:         return(grantLock);
1:     }
1: 
1: 	/**
1: 		Add a lock into this control, granted it if possible.
1: 
1: 		This can be entered in several states.
1: 
1: 		</OL>
1: 		<LI>The Lockable is locked (granted queue not empty), and there are no waiters (waiting queue is empty)
1: 		<LI>The Lockable is locked and there are waiters
1: 		<LI>The Lockable is locked and there are waiters and the first is potentially granted
1: 		<LI>The Lockable is unlocked and there are waiters and the first is potentially granted. Logically the item is
1: 		    still locked, it's just that the lock has just been released and the first waker has not woken up yet.
1: 		</OL>
1: 		This call is never entered when the object is unlocked and there are no waiters.
1: 
1: 	
1: 		1) The Lockable has just been unlocked, 
1: 	*/
1: 
0: 	public Lock addLock(LockSet ls, Object compatabilitySpace, Object qualifier) {
1: 
1: 		if (SanityManager.DEBUG) {
1: 
1: 			if (!(!isUnlocked() || (firstWaiter() != null)))
1: 				SanityManager.THROWASSERT("entered in totally unlocked mode " + isUnlocked() + " " + (firstWaiter() != null));
1: 		}
1: 
1: 		// If there are other waiters for this lock then we
1: 		// will only grant this lock if we already hold a lock.
1: 		// This stops a lock being frozen out while compatible locks
1: 		// jump past it.
1: 		boolean grantLock = false;		
1: 		boolean otherWaiters = (firstWaiter() != null);
1: 
1: 		Lock lockItem = null;
1: 		Lockable lref = ref;
1: 
1: 		// If we haven't been able to grant the lock yet then see if we hold a 
1:         // lock already that we are compatible with and there are no granted 
1:         // incompatible locks. If the object appears unlocked (due to a just 
1:         // released lock, but the first waiter hasn't woken yet)
1: 		// then we obviously don't hold a lock, so just join the wait queue.
1: 		boolean spaceHasALock = false;
1: 		boolean noGrantAtAll = false;
0: 		if (!grantLock && !isUnlocked()) {
1: 
1: 			boolean selfCompatible = lref.lockerAlwaysCompatible();
1: 			
1: 			int index = 0;
1: 			int endIndex = firstGrant == null ? granted.size() : 0;
1: 			do {
1: 
0: 				Lock gl = firstGrant == null ? (Lock) granted.get(index) : firstGrant;
1: 
1: 
0: 				boolean sameSpace = (gl.getCompatabilitySpace().equals(compatabilitySpace));
1: 
1: 				// if it's one of our locks and we are always compatible with 
1:                 // our own locks then yes, we can be granted.
1: 				if (sameSpace && selfCompatible) {
1: 
1: 					spaceHasALock = true;
1: 
1: 					if (noGrantAtAll)
1: 						break;
1: 
1: 					if (qualifier == gl.getQualifier())
1: 						lockItem = gl;
1: 
1: 					grantLock = true;
1: 					continue;
1: 				}
1: 				
1: 				// If we are not compatible with some already granted lock
1:                 // then we can't be granted, give up right away.
1: 				if (!lref.requestCompatible(qualifier, gl.getQualifier())) {
1: 					grantLock = false;
1: 					lockItem = null;
1: 
1: 					// we can't give up rightaway if spaceHasALock is false
1: 					// because we need to ensure that canSkip is set correctly
1: 					if (spaceHasALock)
1: 						break;
1: 
1: 					noGrantAtAll = true;
1: 				}
1: 
1: 				// We are compatible with this lock, if it's our own or there
1:                 // are no other waiters then yes we can still be granted ...
1: 				
1: 				if (!noGrantAtAll && (sameSpace || !otherWaiters)) {
1: 					grantLock = true;
1: 				}
1: 			} while (++index < endIndex);
1: 		}
1: 
1: 		if (lockItem != null) {
1: 			if (SanityManager.DEBUG) {
1: 				if (!grantLock) {
1: 					SanityManager.THROWASSERT("lock is not granted !" + lockItem);
1: 				}
1: 			}
1: 
1: 			// we already held a lock of this type, just bump the lock count
1: 			lockItem.count++;
1: 			return lockItem;
1: 		}
1: 
1: 		if (grantLock) {
0: 			lockItem = new Lock(compatabilitySpace, lref, qualifier);
1: 			grant(lockItem);
1: 			return lockItem;
1: 		}
1: 		
0: 		ActiveLock waitingLock = new ActiveLock(compatabilitySpace, lref, qualifier);
1: 
0: 		// If the object is already locked by this compatability space
1: 		// then this lock can be granted by skipping other waiters.
1: 		if (spaceHasALock) {
1: 			waitingLock.canSkip = true;
1: 		}
1: 
1: 		if (waiting == null)
0: 			waiting = new java.util.LinkedList();
1: 
1: 		// Add lock to the waiting list
0: 		addWaiter(waiting, waitingLock, ls);
1: 
1: 		if (waitingLock.canSkip) {
1: 			lastPossibleSkip = waitingLock;
1: 		}
1: 
1: 		return waitingLock;
1: 	}
1: 
1: 	protected boolean isUnlocked() {
1: 
1: 		// If firstGrant is set then this object is locked
1: 		if (firstGrant != null)
1: 			return false;
1: 
0: 		List lgranted = granted;
1: 
1: 		return (lgranted == null) || lgranted.isEmpty();
1: 	}
1: 
1: 	/**
1: 		Return the first lock in the wait line, null if the
1: 		line is empty.
1: 	*/
1: 	public ActiveLock firstWaiter() {
1: 		if ((waiting == null) || waiting.isEmpty())
1: 			return null;
1: 		return (ActiveLock) waiting.get(0);
1: 	}
1: 
1: 
1: 	/**
1: 		Get the next waiting lock (if any).
1: 	*/
0: 	ActiveLock getNextWaiter(ActiveLock item, boolean remove, LockSet ls) {
1: 
1: 		ActiveLock nextWaitingLock = null;
1: 
1: 		if (remove && (waiting.get(0) == item))
1: 		{
1: 			// item is at the head of the list and being removed,
1: 			// always return the next waiter
0: 			popFrontWaiter(waiting, ls);
1: 
1: 			nextWaitingLock = firstWaiter();
1: 		}
1: 		else if ((lastPossibleSkip != null) && (lastPossibleSkip != item))
1: 		{
1: 			// there are potential locks that could be granted
1: 			// and the last one is not the lock we just looked at.
1: 
1: 			// need to find the first lock after the one passed
1: 			// in that has the canSkip flag set.
1: 
1: 			int itemIndex = waiting.indexOf(item);
1: 			int removeIndex = remove ? itemIndex : -1;
1: 
1: 
1: 
1: 			// skip the entry we just looked at.
1: 			/*List*/
1: 			// dli.advance();
1: 			// for (; !dli.atEnd(); dli.advance()) {
1: 
1: 			if (itemIndex != waiting.size() - 1) {
1: 
1: 			for (ListIterator li = waiting.listIterator(itemIndex + 1); li.hasNext();) {
1: 				//ActiveLock al = (ActiveLock) dli.get();
1: 				ActiveLock al = (ActiveLock) li.next();
1: 
1: 				if (al.canSkip) {
1: 					nextWaitingLock = al;
1: 					break;
1: 				}
1: 			}
1: 			}
1: 
1: 			if (remove) {
0: 				removeWaiter(waiting, removeIndex, ls);
1: 			}
1: 
1: 		} else {
1: 			if (remove) {
0: 				int count = removeWaiter(waiting, item, ls);
1: 
1: 				if (SanityManager.DEBUG) {
1: 					if (count != 1)
1: 					{
1: 						SanityManager.THROWASSERT(
1: 							"count = " + count + "item = " + item + 
1: 							"waiting = " + waiting);
1: 					}
1: 				}
1: 			}
1: 		}
1: 
1: 		if (remove && (item == lastPossibleSkip))
1: 			lastPossibleSkip = null;
1: 
1: 		if (nextWaitingLock != null) {
1: 			if (!nextWaitingLock.setPotentiallyGranted())
1: 				nextWaitingLock = null;
1: 		}
1: 
1: 		return nextWaitingLock;
1: 	}
1: 
1: 	/**
1: 		Return the lockable object controlled by me.
1: 	*/
1: 	public Lockable getLockable() {
1: 		return ref;
1: 	}
1: 	public Lock getFirstGrant() {
1: 		return firstGrant;
1: 	}
0: 	public List getGranted() {
1: 		return granted;
1: 	}
0: 	public List getWaiting() {
1: 		return waiting;
1: 	}
1: 
1: 	/**
1: 		Give up waiting up on a lock
1: 	*/
1: 
0: 	protected void giveUpWait(Object item, LockSet ls) {
1: 
0: 		int count = removeWaiter(waiting, item, ls);
1: 		if (item == lastPossibleSkip)
1: 			lastPossibleSkip = null;	
1: 
1: 		if (SanityManager.DEBUG) {
1:             if (count != 1)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "count = " + count + "item = " + item + 
1:                     "waiting = " + waiting);
1:             }
1:         }
1: 	}
1: 
1: 	/*
1: 	** Deadlock support.
1: 	*/
1: 
1: 	/**
0: 		Add the waiters of this lock into this Dictionary object.
1: 		<BR>
1: 		Each waiting thread gets two entries in the hashtable
1: 		<OL>
1: 		<LI>key=compatibility space - value=ActiveLock
1: 		<LI>key=ActiveLock - value={LockControl for first waiter|ActiveLock of previosue waiter}
1: 		</OL>
1: 	*/
0: 	public void addWaiters(Dictionary waiters) {
1: 		
1: 		if ((waiting == null) || waiting.isEmpty())
1: 			return;
1: 
1: 		Object previous = this;
1: 		for (ListIterator li = waiting.listIterator(); li.hasNext(); ) {
1: 
1: 			ActiveLock waitingLock = ((ActiveLock) li.next());
1: 
1: 			Object waiter = waitingLock.getCompatabilitySpace();
1: 
1: 			waiters.put(waiter, waitingLock);
1: 			waiters.put(waitingLock, previous);
1: 			previous = waitingLock;
1: 		}
1: 	}
1: 
1: 	/**
1: 		Return a Stack of the
1: 		held locks (Lock objects) on this Lockable.
1: 	*/
0: 	List getGrants() {
1: 
0: 		List ret;
1: 
1: 		if (firstGrant != null) {
0: 			ret = new java.util.LinkedList();
1: 			ret.add(firstGrant);
1: 		}
1: 		else
1: 		{
0: 			ret = new java.util.LinkedList(granted);
1: 		}
1: 
1: 		return ret;
1: 	}
1: 
1: 	/**
1: 		Find a granted lock matching this space and qualifier
1: 	*/
0: 	public final Lock getLock(Object compatabilitySpace, Object qualifier) {
1: 
1: 		if (isUnlocked())
1: 			return null;
1: 
0: 		List lgranted = granted;
1: 
1: 
1: 		int index = 0;
1: 		int endIndex = firstGrant == null ? lgranted.size() : 0;
1: 		do {
1: 
0: 			Lock gl = firstGrant == null ? (Lock) lgranted.get(index) : firstGrant;
1: 
0:             if (!gl.getCompatabilitySpace().equals(compatabilitySpace))
1: 				continue;
1: 
1: 			if (gl.getQualifier() == qualifier)
1: 				return gl;
1: 
1:         } while (++index < endIndex);
1: 		return null;
1: 	}
1: 
1: //EXCLUDE-START-lockdiag- 
1: 	/**
1: 	 * make a shallow clone of myself
1: 	 */
1: 	/* package */
1: 	public Control shallowClone()
1: 	{
1: 		return new LockControl(this);
1: 	}
1: //EXCLUDE-END-lockdiag- 
1: 
1: 	/**
1: 	 * Add a lock request to a list of waiters.
1: 	 *
0: 	 * @param waiting	The list of waiters to add to
1: 	 * @param lockItem	The lock request
0: 	 * @param ls		The LockSet
1: 	 */
0: 	private void addWaiter(List waiting,
0: 						Lock lockItem,
0: 						LockSet ls) {
1: 
1: 		// Add lock to the waiting list
1: 		waiting.add(lockItem);
1: 
1: 		// Maintain count of waiters
1: 		ls.oneMoreWaiter();
1: 	}
1: 
1: 	/**
1: 	 * Remove and return the first lock request from a list of waiters.
1: 	 *
0: 	 * @param waiting	The list of waiters to pop from
0: 	 * @param ls		The LockSet
1: 	 *
1: 	 * @return	The removed lock request
1: 	 */
0: 	private Object popFrontWaiter(List waiting, LockSet ls) {
1: 		// Maintain count of waiters
1: 		ls.oneLessWaiter();
1: 
1: 		// Remove and return the first lock request
0: 		return waiting.remove(0);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Remove and return the lock request at the given index
1: 	 * from a list of waiters.
1: 	 *
0: 	 * @param waiting	The list of waiters to pop from
1: 	 * @param index		The index at which to remove the lock request
0: 	 * @param ls		The LockSet
1: 	 *
1: 	 * @return	The removed lock request
1: 	 */
0: 	private Object removeWaiter(List waiting,
0: 								int index,
0: 								LockSet ls) {
1: 		// Maintain count of waiters
1: 		ls.oneLessWaiter();
1: 
1: 		// Remove and return the first lock request
1: 		return waiting.remove(index);
1: 	}
1: 
1: 	/**
1: 	 * Remove and return the given lock request from a list of waiters.
1: 	 *
0: 	 * @param waiting	The list of waiters to pop from
1: 	 * @param item		The item to remove
0: 	 * @param ls		The LockSet
1: 	 *
1: 	 * @return	The number of items removed
1: 	 */
0: 	private int removeWaiter(List waiting,
0: 								Object item,
0: 								LockSet ls) {
1: 		// Maintain count of waiters
1: 		ls.oneLessWaiter();
1: 
1: 		// Remove item and return number of items removed
1: 		return waiting.remove(item) ? 1 : 0;
1: 	}
1: }
1: 
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.locks
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.services.locks;
0: 
0: import org.apache.derby.iapi.services.locks.Lockable;
0: import org.apache.derby.iapi.services.locks.Latch;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.util.Dictionary;
0: import java.util.Stack;
0: import java.util.List;
0: import java.util.ListIterator;
0: 
0: /**
0: 	A LockControl contains a reference to the item being locked
0: 	and doubly linked lists for the granted locks and the waiting
0: 	locks.
0: 
0: 	<P>
0: 	MT - Mutable - Container object : single thread required
0: 
0: */
0: 
0: public class LockControl implements Control {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private final Lockable		ref;
0: 
0: 	/**
0: 		This lock control uses an optimistic locking scheme.
0: 		When the first lock on an object is granted it
0: 		simply sets firstGrant to be that object, removing the
0: 		need to allocate a list if no other locks are granted
0: 		before the first lock is release. If a second lock
0: 		is granted then a list is allocated and the
0: 		firstGrant lock is moved into the list. Once a list
0: 		has been created it is always used.
0: 	*/
0: 	private Lock				firstGrant;
0: 	private List				granted;
0: 	private List				waiting;
0: 	private Lock				lastPossibleSkip;
0: 
0: 	protected LockControl(Lock firstLock, Lockable ref) {
0: 		super();
0: 		this.ref = ref;
0: 
0: 		// System.out.println("new lockcontrol");
0: 
0: 		firstGrant = firstLock;
0: 	}
0: 
0: 	// make a copy by cloning the granted and waiting lists
0: 	private LockControl(LockControl copyFrom)
0: 	{
0: 		super();
0: 
0: 		this.ref = copyFrom.ref;
0: 		this.firstGrant = copyFrom.firstGrant;
0: 
0: 		if (copyFrom.granted != null)
0: 			this.granted = new java.util.LinkedList(copyFrom.granted);
0: 
0: 		if (copyFrom.waiting != null)
0: 			this.waiting = new java.util.LinkedList(copyFrom.waiting);
0: 
0: 		this.lastPossibleSkip = copyFrom.lastPossibleSkip;
0: 	}
0: 	
0: 	public LockControl getLockControl() {
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	*/
0: 	public boolean isEmpty() {
0: 
0: 		// if we are locked then we are not empty
0: 		if (!isUnlocked())
0: 			return false;
0: 
0: 		return (waiting == null) || waiting.isEmpty();
0: 	}
0: 
0: 	/**
0: 		Grant this lock.
0: 	*/
0: 	void grant(Lock lockItem) {
0: 
0: 		lockItem.grant();
0: 
0: 		List lgranted = granted;
0: 		
0: 		if (lgranted == null) {
0: 			if (firstGrant == null) {
0: 				// first ever lock on this item
0: 				firstGrant = lockItem;
0: 			} else {
0: 				// second ever lock on this item
0: 				lgranted = granted = new java.util.LinkedList();
0: 				lgranted.add(firstGrant);
0: 				lgranted.add(lockItem);
0: 				firstGrant = null;
0: 			}
0: 		} else {
0: 			// this grants the lock
0: 			lgranted.add(lockItem);
0: 		}
0: 	}
0: 
0: 	/**
0: 	*/
0: 	public boolean unlock(Latch lockInGroup, int unlockCount) {
0: 
0: 		// note that lockInGroup is not the actual Lock object held in the lock set.
0: 
0: 		if (unlockCount == 0)
0: 			unlockCount = lockInGroup.getCount();
0: 
0: 		List lgranted = granted;
0: 			
0: 		// start at the begining of the list when there is one
0: 		for (int index = 0; unlockCount > 0; ) {
0: 
0: 			Lock lockInSet;
0: 
0: 			if (firstGrant != null) {
0: 				if (SanityManager.DEBUG) {
0: 					SanityManager.ASSERT(lockInGroup.equals(firstGrant));
0: 				}
0: 				lockInSet = firstGrant;
0: 			} else {
0: 				// index = lgranted.indexOf(index, lgranted.size() - 1, lockInGroup);
0: 				/*List*/ index = lgranted.indexOf(lockInGroup);
0: 			
0: 				if (SanityManager.DEBUG) {
0: 					SanityManager.ASSERT(index != -1);
0: 				}
0: 				lockInSet = (Lock) lgranted.get(index);
0: 			}
0: 
0: 			unlockCount -= lockInSet.unlock(unlockCount);
0: 
0: 			if (lockInSet.getCount() != 0) {
0: 				if (SanityManager.DEBUG) {
0: 					if (unlockCount != 0)
0: 						SanityManager.THROWASSERT("locked item didn't reduce unlock count to zero " + unlockCount);
0: 				}
0: 				continue;
0: 			}
0: 
0: 			if (firstGrant == lockInSet) {
0: 				if (SanityManager.DEBUG) {
0: 					if (unlockCount != 0)
0: 						SanityManager.THROWASSERT("item is still locked! " + unlockCount);
0: 				}
0: 				firstGrant = null;
0: 			}
0: 			else {
0: 				lgranted.remove(index);
0: 			}
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0:         This routine can be called to see if a lock currently on the wait
0:         list could be granted. If this lock has waiters ahead of it
0: 		then we do not jump over the waiter(s) even if we can be granted.
0: 		 This avoids the first waiter being starved out.
0: 	*/
0: 
0:     public boolean isGrantable(
0:     boolean noWaitersBeforeMe,
0:     Object  compatabilitySpace, 
0:     Object  qualifier)
0:     {
0: 		if (isUnlocked())
0: 			return true;
0: 
0:         boolean grantLock    = false;
0: 
0: 		Lockable lref = ref;
0: 		List lgranted = granted;
0: 
0:         {
0:             // Check to see if the only locks on the granted queue that
0:             // we are incompatible with are locks we own.
0:             boolean selfCompatible = lref.lockerAlwaysCompatible();
0: 
0: 			int index = 0;
0: 			int endIndex = firstGrant == null ? lgranted.size() : 0;
0: 			do {
0: 
0: 				Lock gl = firstGrant == null ? (Lock) lgranted.get(index) : firstGrant;
0: 
0:                 boolean sameSpace = 
0:                     (gl.getCompatabilitySpace().equals(compatabilitySpace));
0: 
0:                 if (sameSpace && selfCompatible) 
0:                 {
0:                     // if it's one of our locks and we are always compatible 
0:                     // with our own locks then yes, we can be granted.
0:                     
0:                     grantLock = true;
0:                     continue;
0:                 }
0:                 else if (!lref.requestCompatible(qualifier, gl.getQualifier())) 
0:                 {
0:                     // If we are not compatible with some already granted lock
0:                     // then we can't be granted, give up right away.
0:                     
0:                     grantLock = false;
0:                     break;
0:                 }
0:                 else
0:                 {
0:                     // We are compatible with this lock, if it's our own or 
0:                     // there are no other waiters then we can be granted.
0:                 
0:                     if (sameSpace || noWaitersBeforeMe) 
0:                     {
0:                         grantLock = true;
0:                     }
0:                 }
0:             } while (++index < endIndex);
0: 		}
0: 
0:         return(grantLock);
0:     }
0: 
0: 	/**
0: 		Add a lock into this control, granted it if possible.
0: 
0: 		This can be entered in several states.
0: 
0: 		</OL>
0: 		<LI>The Lockable is locked (granted queue not empty), and there are no waiters (waiting queue is empty)
0: 		<LI>The Lockable is locked and there are waiters
0: 		<LI>The Lockable is locked and there are waiters and the first is potentially granted
0: 		<LI>The Lockable is unlocked and there are waiters and the first is potentially granted. Logically the item is
0: 		    still locked, it's just that the lock has just been released and the first waker has not woken up yet.
0: 		</OL>
0: 		This call is never entered when the object is unlocked and there are no waiters.
0: 
0: 	
0: 		1) The Lockable has just been unlocked, 
0: 	*/
0: 
0: 	public Lock addLock(LockSet ls, Object compatabilitySpace, Object qualifier) {
0: 
0: 		if (SanityManager.DEBUG) {
0: 
0: 			if (!(!isUnlocked() || (firstWaiter() != null)))
0: 				SanityManager.THROWASSERT("entered in totally unlocked mode " + isUnlocked() + " " + (firstWaiter() != null));
0: 		}
0: 
0: 		// If there are other waiters for this lock then we
0: 		// will only grant this lock if we already hold a lock.
0: 		// This stops a lock being frozen out while compatible locks
0: 		// jump past it.
0: 		boolean grantLock = false;		
0: 		boolean otherWaiters = (firstWaiter() != null);
0: 
0: 		Lock lockItem = null;
0: 		Lockable lref = ref;
0: 
0: 		// If we haven't been able to grant the lock yet then see if we hold a 
0:         // lock already that we are compatible with and there are no granted 
0:         // incompatible locks. If the object appears unlocked (due to a just 
0:         // released lock, but the first waiter hasn't woken yet)
0: 		// then we obviously don't hold a lock, so just join the wait queue.
0: 		boolean spaceHasALock = false;
0: 		boolean noGrantAtAll = false;
0: 		if (!grantLock && !isUnlocked()) {
0: 
0: 			boolean selfCompatible = lref.lockerAlwaysCompatible();
0: 			
0: 			int index = 0;
0: 			int endIndex = firstGrant == null ? granted.size() : 0;
0: 			do {
0: 
0: 				Lock gl = firstGrant == null ? (Lock) granted.get(index) : firstGrant;
0: 
0: 
0: 				boolean sameSpace = (gl.getCompatabilitySpace().equals(compatabilitySpace));
0: 
0: 				// if it's one of our locks and we are always compatible with 
0:                 // our own locks then yes, we can be granted.
0: 				if (sameSpace && selfCompatible) {
0: 
0: 					spaceHasALock = true;
0: 
0: 					if (noGrantAtAll)
0: 						break;
0: 
0: 					if (qualifier == gl.getQualifier())
0: 						lockItem = gl;
0: 
0: 					grantLock = true;
0: 					continue;
0: 				}
0: 				
0: 				// If we are not compatible with some already granted lock
0:                 // then we can't be granted, give up right away.
0: 				if (!lref.requestCompatible(qualifier, gl.getQualifier())) {
0: 					grantLock = false;
0: 					lockItem = null;
0: 
0: 					// we can't give up rightaway if spaceHasALock is false
0: 					// because we need to ensure that canSkip is set correctly
0: 					if (spaceHasALock)
0: 						break;
0: 
0: 					noGrantAtAll = true;
0: 				}
0: 
0: 				// We are compatible with this lock, if it's our own or there
0:                 // are no other waiters then yes we can still be granted ...
0: 				
0: 				if (!noGrantAtAll && (sameSpace || !otherWaiters)) {
0: 					grantLock = true;
0: 				}
0: 			} while (++index < endIndex);
0: 		}
0: 
0: 		if (lockItem != null) {
0: 			if (SanityManager.DEBUG) {
0: 				if (!grantLock) {
0: 					SanityManager.THROWASSERT("lock is not granted !" + lockItem);
0: 				}
0: 			}
0: 
0: 			// we already held a lock of this type, just bump the lock count
0: 			lockItem.count++;
0: 			return lockItem;
0: 		}
0: 
0: 		if (grantLock) {
0: 			lockItem = new Lock(compatabilitySpace, lref, qualifier);
0: 			grant(lockItem);
0: 			return lockItem;
0: 		}
0: 		
0: 		ActiveLock waitingLock = new ActiveLock(compatabilitySpace, lref, qualifier);
0: 
0: 		// If the object is already locked by this compatability space
0: 		// then this lock can be granted by skipping other waiters.
0: 		if (spaceHasALock) {
0: 			waitingLock.canSkip = true;
0: 		}
0: 
0: 		if (waiting == null)
0: 			waiting = new java.util.LinkedList();
0: 
0: 		// Add lock to the waiting list
0: 		addWaiter(waiting, waitingLock, ls);
0: 
0: 		if (waitingLock.canSkip) {
0: 			lastPossibleSkip = waitingLock;
0: 		}
0: 
0: 		return waitingLock;
0: 	}
0: 
0: 	protected boolean isUnlocked() {
0: 
0: 		// If firstGrant is set then this object is locked
0: 		if (firstGrant != null)
0: 			return false;
0: 
0: 		List lgranted = granted;
0: 
0: 		return (lgranted == null) || lgranted.isEmpty();
0: 	}
0: 
0: 	/**
0: 		Return the first lock in the wait line, null if the
0: 		line is empty.
0: 	*/
0: 	public ActiveLock firstWaiter() {
0: 		if ((waiting == null) || waiting.isEmpty())
0: 			return null;
0: 		return (ActiveLock) waiting.get(0);
0: 	}
0: 
0: 
0: 	/**
0: 		Get the next waiting lock (if any).
0: 	*/
0: 	ActiveLock getNextWaiter(ActiveLock item, boolean remove, LockSet ls) {
0: 
0: 		ActiveLock nextWaitingLock = null;
0: 
0: 		if (remove && (waiting.get(0) == item))
0: 		{
0: 			// item is at the head of the list and being removed,
0: 			// always return the next waiter
0: 			popFrontWaiter(waiting, ls);
0: 
0: 			nextWaitingLock = firstWaiter();
0: 		}
0: 		else if ((lastPossibleSkip != null) && (lastPossibleSkip != item))
0: 		{
0: 			// there are potential locks that could be granted
0: 			// and the last one is not the lock we just looked at.
0: 
0: 			// need to find the first lock after the one passed
0: 			// in that has the canSkip flag set.
0: 
0: 			int itemIndex = waiting.indexOf(item);
0: 			int removeIndex = remove ? itemIndex : -1;
0: 
0: 
0: 
0: 			// skip the entry we just looked at.
0: 			/*List*/
0: 			// dli.advance();
0: 			// for (; !dli.atEnd(); dli.advance()) {
0: 
0: 			if (itemIndex != waiting.size() - 1) {
0: 
0: 			for (ListIterator li = waiting.listIterator(itemIndex + 1); li.hasNext();) {
0: 				//ActiveLock al = (ActiveLock) dli.get();
0: 				ActiveLock al = (ActiveLock) li.next();
0: 
0: 				if (al.canSkip) {
0: 					nextWaitingLock = al;
0: 					break;
0: 				}
0: 			}
0: 			}
0: 
0: 			if (remove) {
0: 				removeWaiter(waiting, removeIndex, ls);
0: 			}
0: 
0: 		} else {
0: 			if (remove) {
0: 				int count = removeWaiter(waiting, item, ls);
0: 
0: 				if (SanityManager.DEBUG) {
0: 					if (count != 1)
0: 					{
0: 						SanityManager.THROWASSERT(
0: 							"count = " + count + "item = " + item + 
0: 							"waiting = " + waiting);
0: 					}
0: 				}
0: 			}
0: 		}
0: 
0: 		if (remove && (item == lastPossibleSkip))
0: 			lastPossibleSkip = null;
0: 
0: 		if (nextWaitingLock != null) {
0: 			if (!nextWaitingLock.setPotentiallyGranted())
0: 				nextWaitingLock = null;
0: 		}
0: 
0: 		return nextWaitingLock;
0: 	}
0: 
0: 	/**
0: 		Return the lockable object controlled by me.
0: 	*/
0: 	public Lockable getLockable() {
0: 		return ref;
0: 	}
0: 	public Lock getFirstGrant() {
0: 		return firstGrant;
0: 	}
0: 	public List getGranted() {
0: 		return granted;
0: 	}
0: 	public List getWaiting() {
0: 		return waiting;
0: 	}
0: 
0: 	/**
0: 		Give up waiting up on a lock
0: 	*/
0: 
0: 	protected void giveUpWait(Object item, LockSet ls) {
0: 
0: 		int count = removeWaiter(waiting, item, ls);
0: 		if (item == lastPossibleSkip)
0: 			lastPossibleSkip = null;	
0: 
0: 		if (SanityManager.DEBUG) {
0:             if (count != 1)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "count = " + count + "item = " + item + 
0:                     "waiting = " + waiting);
0:             }
0:         }
0: 	}
0: 
0: 	/*
0: 	** Deadlock support.
0: 	*/
0: 
0: 	/**
0: 		Add the waiters of this lock into this Dictionary object.
0: 		<BR>
0: 		Each waiting thread gets two entries in the hashtable
0: 		<OL>
0: 		<LI>key=compatibility space - value=ActiveLock
0: 		<LI>key=ActiveLock - value={LockControl for first waiter|ActiveLock of previosue waiter}
0: 		</OL>
0: 	*/
0: 	public void addWaiters(Dictionary waiters) {
0: 		
0: 		if ((waiting == null) || waiting.isEmpty())
0: 			return;
0: 
0: 		Object previous = this;
0: 		for (ListIterator li = waiting.listIterator(); li.hasNext(); ) {
0: 
0: 			ActiveLock waitingLock = ((ActiveLock) li.next());
0: 
0: 			Object waiter = waitingLock.getCompatabilitySpace();
0: 
0: 			waiters.put(waiter, waitingLock);
0: 			waiters.put(waitingLock, previous);
0: 			previous = waitingLock;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Return a Stack of the
0: 		held locks (Lock objects) on this Lockable.
0: 	*/
0: 	List getGrants() {
0: 
0: 		List ret;
0: 
0: 		if (firstGrant != null) {
0: 			ret = new java.util.LinkedList();
0: 			ret.add(firstGrant);
0: 		}
0: 		else
0: 		{
0: 			ret = new java.util.LinkedList(granted);
0: 		}
0: 
0: 		return ret;
0: 	}
0: 
0: 	/**
0: 		Find a granted lock matching this space and qualifier
0: 	*/
0: 	public final Lock getLock(Object compatabilitySpace, Object qualifier) {
0: 
0: 		if (isUnlocked())
0: 			return null;
0: 
0: 		List lgranted = granted;
0: 
0: 
0: 		int index = 0;
0: 		int endIndex = firstGrant == null ? lgranted.size() : 0;
0: 		do {
0: 
0: 			Lock gl = firstGrant == null ? (Lock) lgranted.get(index) : firstGrant;
0: 
0:             if (!gl.getCompatabilitySpace().equals(compatabilitySpace))
0: 				continue;
0: 
0: 			if (gl.getQualifier() == qualifier)
0: 				return gl;
0: 
0:         } while (++index < endIndex);
0: 		return null;
0: 	}
0: 
0: //EXCLUDE-START-lockdiag- 
0: 	/**
0: 	 * make a shallow clone of myself
0: 	 */
0: 	/* package */
0: 	public Control shallowClone()
0: 	{
0: 		return new LockControl(this);
0: 	}
0: //EXCLUDE-END-lockdiag- 
0: 
0: 	/**
0: 	 * Add a lock request to a list of waiters.
0: 	 *
0: 	 * @param waiting	The list of waiters to add to
0: 	 * @param lockItem	The lock request
0: 	 * @param ls		The LockSet
0: 	 */
0: 	private void addWaiter(List waiting,
0: 						Lock lockItem,
0: 						LockSet ls) {
0: 
0: 		// Add lock to the waiting list
0: 		waiting.add(lockItem);
0: 
0: 		// Maintain count of waiters
0: 		ls.oneMoreWaiter();
0: 	}
0: 
0: 	/**
0: 	 * Remove and return the first lock request from a list of waiters.
0: 	 *
0: 	 * @param waiting	The list of waiters to pop from
0: 	 * @param ls		The LockSet
0: 	 *
0: 	 * @return	The removed lock request
0: 	 */
0: 	private Object popFrontWaiter(List waiting, LockSet ls) {
0: 		// Maintain count of waiters
0: 		ls.oneLessWaiter();
0: 
0: 		// Remove and return the first lock request
0: 		return waiting.remove(0);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Remove and return the lock request at the given index
0: 	 * from a list of waiters.
0: 	 *
0: 	 * @param waiting	The list of waiters to pop from
0: 	 * @param index		The index at which to remove the lock request
0: 	 * @param ls		The LockSet
0: 	 *
0: 	 * @return	The removed lock request
0: 	 */
0: 	private Object removeWaiter(List waiting,
0: 								int index,
0: 								LockSet ls) {
0: 		// Maintain count of waiters
0: 		ls.oneLessWaiter();
0: 
0: 		// Remove and return the first lock request
0: 		return waiting.remove(index);
0: 	}
0: 
0: 	/**
0: 	 * Remove and return the given lock request from a list of waiters.
0: 	 *
0: 	 * @param waiting	The list of waiters to pop from
0: 	 * @param item		The item to remove
0: 	 * @param ls		The LockSet
0: 	 *
0: 	 * @return	The number of items removed
0: 	 */
0: 	private int removeWaiter(List waiting,
0: 								Object item,
0: 								LockSet ls) {
0: 		// Maintain count of waiters
0: 		ls.oneLessWaiter();
0: 
0: 		// Remove item and return number of items removed
0: 		return waiting.remove(item) ? 1 : 0;
0: 	}
0: }
0: 
0: 
============================================================================