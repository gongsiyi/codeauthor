1:b3a80f0: /**
1:b3a80f0:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ResultSetStreamTest
1:b3a80f0:  *  
1:b3a80f0:  * Licensed to the Apache Software Foundation (ASF) under one
1:b3a80f0:  * or more contributor license agreements.  See the NOTICE file
1:b3a80f0:  * distributed with this work for additional information
1:b3a80f0:  * regarding copyright ownership.  The ASF licenses this file
1:b3a80f0:  * to you under the Apache License, Version 2.0 (the
1:b3a80f0:  * "License"); you may not use this file except in compliance
1:b3a80f0:  * with the License.  You may obtain a copy of the License at
1:b3a80f0:  *
1:b3a80f0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:b3a80f0:  *
1:b3a80f0:  * Unless required by applicable law or agreed to in writing,
1:b3a80f0:  * software distributed under the License is distributed on an
1:b3a80f0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:b3a80f0:  * KIND, either express or implied.  See the License for the
1:b3a80f0:  * specific language governing permissions and limitations
1:b3a80f0:  * under the License.
1:b3a80f0:  */
1:b3a80f0: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
3:b3a80f0: 
1:b3a80f0: import java.io.BufferedInputStream;
1:b3a80f0: import java.io.File;
1:b3a80f0: import java.io.FileInputStream;
1:b3a80f0: import java.io.FileNotFoundException;
1:b3a80f0: import java.io.IOException;
1:b3a80f0: import java.io.InputStream;
1:b3a80f0: import java.io.Reader;
1:b3a80f0: import java.io.StringReader;
1:b3a80f0: import java.security.AccessController;
1:b3a80f0: import java.security.PrivilegedActionException;
1:b3a80f0: import java.security.PrivilegedExceptionAction;
1:b3a80f0: import java.sql.Connection;
1:b3a80f0: import java.sql.PreparedStatement;
1:b3a80f0: import java.sql.ResultSet;
1:b3a80f0: import java.sql.ResultSetMetaData;
1:b3a80f0: import java.sql.SQLException;
1:b3a80f0: import java.sql.Statement;
1:b3a80f0: import java.util.zip.CRC32;
1:b3a80f0: import junit.framework.Test;
1:7672693: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:b3a80f0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:b3a80f0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:b3a80f0: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:b3a80f0: import org.apache.derbyTesting.junit.TestConfiguration;
1:b3a80f0: 
1:b3a80f0: public class ResultSetStreamTest extends BaseJDBCTestCase {
1:b3a80f0: 
1:b3a80f0:     public ResultSetStreamTest(String name) {
1:b3a80f0:         super(name);
1:b3a80f0: 
1:b3a80f0:     }
1:b3a80f0: 
1:b3a80f0:     private static String filePath;
1:b3a80f0: 
1:b3a80f0:     private static String sep;
1:b3a80f0: 
1:b3a80f0:     public void testInsertData() throws SQLException, Exception {
1:b3a80f0:         try {
1:b3a80f0: 
1:e18f54b:             AccessController.doPrivileged(
1:e18f54b:                     new PrivilegedExceptionAction<Void>() {
1:e18f54b:                 public Void run() throws SQLException, FileNotFoundException,
1:b3a80f0:                         IOException {
1:b3a80f0:                     insertData();
1:b3a80f0:                     return null;
1:b3a80f0:                 }
1:b3a80f0:             });
1:b3a80f0:         } catch (PrivilegedActionException e) {
1:b3a80f0:             throw e.getException();
1:b3a80f0:         }
1:b3a80f0:     }
1:b3a80f0: 
1:7672693:     /**
1:b3a80f0:      * Test insert of data with setBinaryStream
1:b3a80f0:      * 
1:b3a80f0:      * @throws SQLException
1:b3a80f0:      * @throws FileNotFoundException
1:b3a80f0:      * @throws IOException
1:b3a80f0:      */
1:b3a80f0:     private void insertData() throws SQLException, FileNotFoundException,
1:b3a80f0:             IOException {
1:b3a80f0:         Connection conn = getConnection();
1:b3a80f0:         PreparedStatement ppw = conn
1:b3a80f0:                 .prepareStatement("insert into t2 (len, data) values (?, ?)");
1:b3a80f0:         filePath = "extin";
1:b3a80f0:         String userDir = System.getProperty("user.dir");
1:b3a80f0:         sep = System.getProperty("file.separator");
1:b3a80f0:         filePath = userDir + sep + filePath;
1:b3a80f0:         File file = new File(filePath + sep + "littleclob.utf");
1:b3a80f0:         int fileSize = (int) file.length();
1:b3a80f0:         BufferedInputStream fileData = new BufferedInputStream(
1:b3a80f0:                 new FileInputStream(file));
1:b3a80f0:         ppw.setInt(1, fileSize);
1:b3a80f0:         ppw.setBinaryStream(2, fileData, fileSize);
1:b3a80f0:         ppw.executeUpdate();
1:b3a80f0:         fileData.close();
1:b3a80f0: 
1:b3a80f0:         file = new File(filePath + sep + "short.utf");
1:b3a80f0:         fileSize = (int) file.length();
1:b3a80f0:         fileData = new BufferedInputStream(new FileInputStream(file));
1:b3a80f0:         ppw.setInt(1, fileSize);
1:b3a80f0:         ppw.setBinaryStream(2, fileData, fileSize);
1:b3a80f0:         ppw.executeUpdate();
1:b3a80f0:         fileData.close();
1:b3a80f0:         // null binary value
1:b3a80f0:         ppw.setInt(1, -1);
1:b3a80f0:         ppw.setBinaryStream(2, (java.io.InputStream) null, 0);
1:b3a80f0:         ppw.executeUpdate();
1:b3a80f0: 
1:b3a80f0:         // value copied over from original Java object test.
1:b3a80f0:         File rssg = new java.io.File(filePath + sep + "resultsetStream.gif");
1:b3a80f0:         int rssgLength = (int) rssg.length();
1:b3a80f0:         ppw.setInt(1, (int) rssgLength);
1:b3a80f0:         fileData = new BufferedInputStream(new FileInputStream(rssg));
1:b3a80f0:         ppw.setBinaryStream(2, fileData, rssgLength);
1:b3a80f0:         ppw.executeUpdate();
1:b3a80f0:         fileData.close();
1:b3a80f0: 
1:b3a80f0:         // check binary input streams of invalid length.
1:b3a80f0:         // JDBC 3.0 tutorial says stream contents must match length.
1:b3a80f0: 
1:b3a80f0:         byte[] tooFew = new byte[234];
1:b3a80f0: 
1:b3a80f0:         ppw.setInt(1, 234);
1:b3a80f0:         ppw.setBinaryStream(2, new java.io.ByteArrayInputStream(tooFew), 234); // matching length
1:b3a80f0:         ppw.executeUpdate();
1:b3a80f0: 
1:b3a80f0: 
1:b3a80f0:         ppw.setInt(1, 235);
1:b3a80f0:         ppw.setBinaryStream(2, new java.io.ByteArrayInputStream(tooFew), 235); // too few bytes in stream
1:b3a80f0:         try {
1:b3a80f0:                 ppw.executeUpdate();
1:b3a80f0:                 fail("FAIL - execute with setBinaryStream() with too few bytes succeeded");
1:b3a80f0:         } catch (SQLException sqle) {       
1:b3a80f0:                 assertMisMatchStreamLength(sqle);
1:b3a80f0:         }
1:b3a80f0: 
1:b3a80f0:         ppw.setInt(1, 233);
1:b3a80f0:         ppw.setBinaryStream(2, new java.io.ByteArrayInputStream(tooFew), 233); // too many bytes
1:b3a80f0:         try {
1:b3a80f0:                 ppw.executeUpdate();
1:b3a80f0:                 fail("FAIL - execute with setBinaryStream() with too many bytes succeeded");
1:b3a80f0:         } catch (SQLException sqle) {
1:b3a80f0:             assertMisMatchStreamLength(sqle);
1:b3a80f0:         }
1:b3a80f0: 
1:b3a80f0:         ppw.close();
1:b3a80f0: 
1:b3a80f0:     }
1:b3a80f0: 
1:b3a80f0:     private void assertMisMatchStreamLength(SQLException sqle) {
1:b3a80f0:         if (usingEmbedded()) {
1:b3a80f0:             assertEquals("XSDA4",sqle.getSQLState());
1:b3a80f0:             sqle = sqle.getNextException();
1:b3a80f0:             assertSQLState("XJ001",sqle);
1:b3a80f0:         } else {
1:b3a80f0:             String state = sqle.getSQLState();
1:b3a80f0:             assertTrue("SQLState not XN015 or XN017 as expected", "XN015".equals(state) || "XN017".equals(state));
1:b3a80f0:         }
1:b3a80f0:     }
1:b3a80f0: 
1:b3a80f0:     public void testBinaryStreamProcessing() throws SQLException, Exception {
1:b3a80f0:         try {
1:b3a80f0: 
1:e18f54b:             AccessController.doPrivileged(
1:e18f54b:                     new PrivilegedExceptionAction<Void>() {
1:e18f54b:                 public Void run() throws SQLException, FileNotFoundException,
1:b3a80f0:                         IOException {
1:b3a80f0:                     binaryStreamProcessing();
1:b3a80f0:                     return null;
1:b3a80f0:                 }
1:b3a80f0:             });
1:b3a80f0:         } catch (PrivilegedActionException e) {
1:b3a80f0:             throw e.getException();
1:b3a80f0:         }
1:b3a80f0:     }
1:b3a80f0: 
1:b3a80f0:     /**
1:b3a80f0:      * Test getBinaryStream by comparing chksum of retrieved value.
1:b3a80f0:      * 
1:b3a80f0:      * @throws SQLException
1:b3a80f0:      * @throws IOException
1:b3a80f0:      */
1:b3a80f0:     public void binaryStreamProcessing() throws SQLException, IOException {
1:b3a80f0:         Connection conn = getConnection();
1:b3a80f0:         Statement s = conn.createStatement();
1:b3a80f0: 
1:b3a80f0:         filePath = "extin";
1:b3a80f0:         String userDir = System.getProperty("user.dir");
1:b3a80f0:         sep = System.getProperty("file.separator");
1:b3a80f0:         filePath = userDir + sep + filePath;
1:b3a80f0: 
1:b3a80f0:         File rssg = new java.io.File(filePath + sep + "resultsetStream.gif");
1:b3a80f0:         int rssgLength = (int) rssg.length();
1:b3a80f0:         ResultSet rs = s.executeQuery("select data from t2 where len = "
1:b3a80f0:                 + rssgLength);
1:b3a80f0:         ResultSetMetaData met = rs.getMetaData();
1:b3a80f0:         assertEquals(1, met.getColumnCount());
1:b3a80f0: 
1:b3a80f0:         while (rs.next()) {
1:b3a80f0:             // JDBC columns use 1-based counting
1:b3a80f0: 
1:b3a80f0:             // get the first column as a stream
1:b3a80f0: 
1:b3a80f0:             InputStream is = rs.getBinaryStream(1);
1:b3a80f0:             if (is == null) {
1:b3a80f0:                 fail("FAIL - getBinaryStream() return null");
1:b3a80f0:                 break;
1:b3a80f0:             }
1:b3a80f0: 
1:b3a80f0:             // read the first 200 bytes from the stream and checksum them
1:b3a80f0:             byte[] b200 = new byte[200];
1:b3a80f0: 
1:b3a80f0:             // no guaratees to read all 200 bytes in one read call.
1:b3a80f0:             int count = 0;
1:b3a80f0: 
1:b3a80f0:             while (count < 200) {
1:b3a80f0:                 int r = is.read(b200, count, 200 - count);
1:b3a80f0:                 if (r == -1)
1:b3a80f0:                     break;
1:b3a80f0:                 count += r;
1:b3a80f0:             }
1:b3a80f0: 
1:b3a80f0:             if (count != 200) {
1:b3a80f0:                 fail("FAIL - failed to read 200 bytes from known file");
1:b3a80f0:                 break;
1:b3a80f0:             }
1:b3a80f0: 
1:b3a80f0:             CRC32 cs = new CRC32();
1:b3a80f0: 
1:b3a80f0:             cs.reset();
1:b3a80f0:             cs.update(b200);
1:b3a80f0:             assertEquals("Incorrect checksum value", 3061553656L, cs.getValue());
1:b3a80f0:             count = 200;
1:b3a80f0:             for (; is.read() != -1; count++) {
1:b3a80f0:             }
1:b3a80f0:             assertEquals("unexpected size of file", 3470, count);
1:b3a80f0:             rs.close();
1:b3a80f0:             // check the stream is closed once another get call is made.
1:b3a80f0:             rs = s.executeQuery("select data, len from t2 where len = "
1:b3a80f0:                     + rssgLength);
1:b3a80f0:             met = rs.getMetaData();
1:b3a80f0:             assertEquals(2, met.getColumnCount());
1:b3a80f0: 
1:b3a80f0:             while (rs.next()) {
1:b3a80f0:                 // JDBC columns use 1-based counting
1:b3a80f0: 
1:b3a80f0:                 // get the first column as a stream
1:b3a80f0:                 is = rs.getBinaryStream(1);
1:b3a80f0:                 if (is == null) {
1:b3a80f0:                     fail("FAIL - getBinaryStream() return null");
1:b3a80f0:                     break;
1:b3a80f0:                 }
1:b3a80f0: 
1:b3a80f0:                 // read the first 200 bytes from the stream and checksum them
1:b3a80f0:                 b200 = new byte[200];
1:b3a80f0: 
1:b3a80f0:                 // no guaratees to read all 200 bytes in one read call.
1:b3a80f0:                 count = 0;
1:b3a80f0: 
1:b3a80f0:                 while (count < 200) {
1:b3a80f0:                     int r = is.read(b200, count, 200 - count);
1:b3a80f0:                     if (r == -1)
1:b3a80f0:                         break;
1:b3a80f0:                     count += r;
1:b3a80f0:                 }
1:b3a80f0: 
1:b3a80f0:                 if (count != 200) {
1:b3a80f0:                     fail("FAIL - failed to read 200 bytes from known file");
1:b3a80f0:                     break;
1:b3a80f0:                 }
1:b3a80f0: 
1:b3a80f0:                 cs = new CRC32();
1:b3a80f0: 
1:b3a80f0:                 cs.reset();
1:b3a80f0:                 cs.update(b200);
1:b3a80f0:                 assertEquals("Incorrect checksum value", 3061553656L, cs
1:b3a80f0:                         .getValue());
1:b3a80f0:                 assertEquals(3470, rs.getInt(2));
1:b3a80f0:                 try {
1:b3a80f0:                     is.read();
1:b3a80f0:                     fail("FAIL - stream was not closed after a get*() call. "
1:b3a80f0:                                     + is.getClass());
1:b3a80f0:                     break;
1:b3a80f0:                 } catch (IOException ioe) {
1:b3a80f0:                     // yes, stream should be closed
1:b3a80f0:                 }
1:b3a80f0: 
1:b3a80f0:             }
1:b3a80f0:             rs.close();
1:b3a80f0: 
1:b3a80f0:             // check a SQL null object gets a null stream
1:b3a80f0:             rs = s.executeQuery("select data from t2 where len = -1");
1:b3a80f0:             met = rs.getMetaData();
1:b3a80f0:             assertEquals(1,met.getColumnCount());
1:b3a80f0:             
1:b3a80f0:            while (rs.next())
1:b3a80f0:                 {
1:b3a80f0:                // JDBC columns use 1-based counting
1:b3a80f0:                
1:b3a80f0:                // get the first column as a stream
1:b3a80f0: 
1:b3a80f0:                is = rs.getBinaryStream(1);
1:b3a80f0:                    if (is != null) {
1:b3a80f0:                        fail("FAIL - getBinaryStream() did not return null for SQL null");
1:b3a80f0:                        break;
1:b3a80f0:                    }
1:b3a80f0: 
1:b3a80f0:                 }
1:b3a80f0:            
1:b3a80f0:                 rs.close();
1:b3a80f0:                 File file = new File(filePath + sep + "short.utf");
1:b3a80f0:                 int fileSize = (int) file.length();
1:b3a80f0:                 rs = s.executeQuery("select len, data from t2 where len = "
1:b3a80f0:                                                                 +  fileSize);
1:b3a80f0:                 rs.next();
1:b3a80f0:                 fileSize = rs.getInt(1);
1:b3a80f0:                 BufferedInputStream fileData = new BufferedInputStream(rs.getBinaryStream(2));
1:b3a80f0:                 int readCount = 0;
1:b3a80f0:                 while(true)
1:b3a80f0:                 {
1:b3a80f0:                         int data = fileData.read();
1:b3a80f0:                         if (data == -1) break;
1:b3a80f0:                         readCount++;
1:b3a80f0:                 }
1:b3a80f0:                 fileData.close();
1:b3a80f0:                 assertEquals(56, fileSize);
1:b3a80f0:                 assertEquals(56,readCount);
1:b3a80f0:         }
1:b3a80f0:                 
1:b3a80f0:                 rs.close();
1:b3a80f0:                 s.close();
1:b3a80f0:         
1:b3a80f0:     }
1:b3a80f0:     final static String TEST_STRING_DATA = 
1:b3a80f0:         "ABCDEFG" + 
1:b3a80f0:         "\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5" + 
1:b3a80f0:         "\u00ff\u0100" + 
1:b3a80f0:         "\u3042\u3044\u3046\u3048\u304a";
1:b3a80f0:     
1:b3a80f0:     public void testGetAsciiStream() throws SQLException, IOException {
1:b3a80f0:         Connection conn = getConnection();
1:b3a80f0:         PreparedStatement st;
1:b3a80f0:         st = conn.prepareStatement("insert into t3(text_data) values(?)");
1:b3a80f0:         st.setCharacterStream(1,
1:b3a80f0:                               new StringReader(TEST_STRING_DATA),
1:b3a80f0:                               TEST_STRING_DATA.length());
1:b3a80f0:         st.executeUpdate();
1:b3a80f0:         st = conn.prepareStatement("select " + 
1:b3a80f0:                    "text_data as text_data_col1," + 
1:b3a80f0:                    "text_data as text_data_col2 " + 
1:b3a80f0:                    "from " + 
1:b3a80f0:                    "t3");
1:b3a80f0:         ResultSet rs = st.executeQuery();
1:b3a80f0: 
1:b3a80f0:         while(rs.next()){
1:b3a80f0:             InputStream is = rs.getAsciiStream(1);
1:b3a80f0:             int i = 0;
1:b3a80f0:             for(int c = is.read(); c > -1; c = is.read()){
1:b3a80f0:                 int exp = (int) TEST_STRING_DATA.charAt(i++);
1:b3a80f0:                 if (exp > 255)
1:b3a80f0:                     exp  = (int) 0x3f;
1:b3a80f0:                 assertEquals(exp,c);
1:b3a80f0:     
1:b3a80f0:             }
1:b3a80f0:             Statement s = createStatement();
1:b3a80f0:             s.executeUpdate("delete from t3");
1:b3a80f0:         }
1:b3a80f0: 
1:b3a80f0:         
1:b3a80f0:     }
1:b3a80f0:     
1:b3a80f0:     /**
1:b3a80f0:      * test getCharacterStream against inserted data
1:b3a80f0:      * 
1:b3a80f0:      * @throws SQLException
1:b3a80f0:      * @throws IOException
1:b3a80f0:      */
1:b3a80f0:     public void testGetCharacterStream() throws SQLException, IOException {
1:b3a80f0:         Connection conn = getConnection();
1:b3a80f0:         PreparedStatement st;
1:b3a80f0:         st = conn.prepareStatement("insert into t3(text_data) values(?)");
1:b3a80f0:         st.setCharacterStream(1,
1:b3a80f0:                               new StringReader(TEST_STRING_DATA),
1:b3a80f0:                               TEST_STRING_DATA.length());
1:b3a80f0:         st.executeUpdate();
1:b3a80f0:         st = conn.prepareStatement("select " + 
1:b3a80f0:                    "text_data as text_data_col1," + 
1:b3a80f0:                    "text_data as text_data_col2 " + 
1:b3a80f0:                    "from " + 
1:b3a80f0:                    "t3");
1:b3a80f0:         ResultSet rs = st.executeQuery();
1:b3a80f0: 
1:b3a80f0:         while(rs.next()){
1:b3a80f0:             Reader r = rs.getCharacterStream(1);
1:b3a80f0:             int i = 0;
1:b3a80f0:             for(int c = r.read(); c > -1; c = r.read()){
1:b3a80f0:                 int exp = (int) TEST_STRING_DATA.charAt(i++);
1:b3a80f0:                 assertEquals(exp,c);
1:b3a80f0:             }
1:b3a80f0:         }
1:b3a80f0:         Statement s = createStatement();
1:b3a80f0:         s.executeUpdate("delete from t3");
1:b3a80f0:         
1:b3a80f0:     }
1:b3a80f0:     
1:b3a80f0:     /**
1:7672693:      * Tests that the max field size limit is handled correctly when accessing
1:7672693:      * values as streams. The limit should apply for VARCHAR, but not for CLOB.
1:7672693:      *
1:7672693:      * @throws IOException if something goes wrong
1:7672693:      * @throws SQLException if something goes wrong
1:7672693:      */
1:7672693:     public void testSetMaxFieldSizeLarge()
1:7672693:             throws IOException, SQLException {
1:7672693:         // Insert test data.
1:7672693:         int id = 1;
1:7672693:         int clobSize = 2*1024*1024; // 2 MB
1:7672693:         int vcSize = 32672;
1:7672693:         int limit = 10;
1:7672693:         PreparedStatement ps = prepareStatement(
1:7672693:                 "insert into setMaxFieldSize values (?,?,?)");
1:7672693:         ps.setInt(1, id);
1:7672693:         ps.setCharacterStream(2, new LoopingAlphabetReader(vcSize), vcSize);
1:7672693:         ps.setCharacterStream(3, new LoopingAlphabetReader(clobSize), clobSize);
1:7672693:         ps.executeUpdate();
1:7672693: 
1:7672693:         // Fetch data back with a limit.
1:7672693:         Statement stmt = createStatement();
1:7672693:         stmt.setMaxFieldSize(limit);
1:7672693:         ResultSet rs = stmt.executeQuery("select dVarchar, dClob from " +
1:7672693:                 "setMaxFieldSize where id = " + id);
1:7672693:         assertTrue(rs.next());
1:7672693:         String vcStr = drainStringFromSource(rs.getCharacterStream(1));
1:7672693:         // Limit should apply to VARCHAR.
1:7672693:         assertEquals(limit, vcStr.length());
1:7672693:         // Limit should *not* apply to CLOB.
1:7672693:         String vsClob = drainStringFromSource(rs.getCharacterStream(2));
1:7672693:         assertEquals(clobSize, vsClob.length());
1:7672693:         rs.close();
1:7672693: 
1:7672693:         // Again, but without a limit.
1:7672693:         stmt = createStatement();
1:7672693:         rs = stmt.executeQuery("select dVarchar, dClob from " +
1:7672693:                 "setMaxFieldSize where id = " + id);
1:7672693:         assertTrue(rs.next());
1:7672693:         vcStr = drainStringFromSource(rs.getCharacterStream(1));
1:7672693:         assertEquals(vcSize, vcStr.length());
1:7672693:         vsClob = drainStringFromSource(rs.getCharacterStream(2));
1:7672693:         assertEquals(clobSize, vsClob.length());
1:7672693:         rs.close();
1:7672693:     }
1:7672693: 
1:7672693:     /**
1:7672693:      * Drains the specified reader and returns a string.
1:7672693:      *
1:7672693:      * @param src the reader to drain
1:7672693:      * @return The reader content as a string.
1:7672693:      * @throws IOException if reading from the source fails
1:7672693:      */
1:7672693:     private static String drainStringFromSource(Reader src)
1:7672693:             throws IOException {
1:7672693:         StringBuffer str = new StringBuffer();
1:7672693:         char[] buf = new char[1024];
1:7672693:         while (true) {
1:7672693:             int read = src.read(buf);
1:7672693:             if (read == -1) {
1:7672693:                 break;
1:7672693:             }
1:7672693:             str.append(buf, 0, read);
1:7672693:         }
1:7672693:         return str.toString();
1:7672693:     }
1:7672693: 
1:b3a80f0:     public static Test basesuite(String name) {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite(ResultSetStreamTest.class, name);
1:1ae02c9: 
1:b3a80f0:         Test test = new SupportFilesSetup(suite, new String[] {
1:b3a80f0:                 "functionTests/testData/ResultSetStream/littleclob.utf",
1:b3a80f0:                 "functionTests/testData/ResultSetStream/short.utf",
1:575f028:                 "functionTests/testData/ResultSetStream/resultsetStream.gif" });
1:b3a80f0: 
1:b3a80f0:         return new CleanDatabaseTestSetup(test) {
1:b3a80f0:             protected void decorateSQL(Statement s) throws SQLException {
1:b3a80f0: 
1:b3a80f0:                 s.execute("create table t2 (len int, data LONG VARCHAR FOR BIT DATA)");
1:b3a80f0:                 s.execute("create table t3(text_data clob)");
1:7672693:                 s.execute("create table setMaxFieldSize(id int unique, " +
1:7672693:                         "dVarchar VARCHAR(32672), dClob clob)");
1:b3a80f0: 
1:b3a80f0:             }
1:b3a80f0:         };
1:b3a80f0:     }
1:b3a80f0: 
1:b3a80f0:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ResultSetStreamTest");
1:b3a80f0:         suite.addTest(basesuite("ResultSetStreamTest:embedded"));
1:b3a80f0:         suite.addTest(TestConfiguration.clientServerDecorator(basesuite("ResultSetStreamTest:client")));
1:b3a80f0:         return suite;
1:b3a80f0: 
1:b3a80f0:     }
1:b3a80f0: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite(ResultSetStreamTest.class, name);
1: 
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ResultSetStreamTest");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<Void>() {
1:                 public Void run() throws SQLException, FileNotFoundException,
/////////////////////////////////////////////////////////////////////////
1:             AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<Void>() {
1:                 public Void run() throws SQLException, FileNotFoundException,
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7672693
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that the max field size limit is handled correctly when accessing
1:      * values as streams. The limit should apply for VARCHAR, but not for CLOB.
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testSetMaxFieldSizeLarge()
1:             throws IOException, SQLException {
1:         // Insert test data.
1:         int id = 1;
1:         int clobSize = 2*1024*1024; // 2 MB
1:         int vcSize = 32672;
1:         int limit = 10;
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into setMaxFieldSize values (?,?,?)");
1:         ps.setInt(1, id);
1:         ps.setCharacterStream(2, new LoopingAlphabetReader(vcSize), vcSize);
1:         ps.setCharacterStream(3, new LoopingAlphabetReader(clobSize), clobSize);
1:         ps.executeUpdate();
1: 
1:         // Fetch data back with a limit.
1:         Statement stmt = createStatement();
1:         stmt.setMaxFieldSize(limit);
1:         ResultSet rs = stmt.executeQuery("select dVarchar, dClob from " +
1:                 "setMaxFieldSize where id = " + id);
1:         assertTrue(rs.next());
1:         String vcStr = drainStringFromSource(rs.getCharacterStream(1));
1:         // Limit should apply to VARCHAR.
1:         assertEquals(limit, vcStr.length());
1:         // Limit should *not* apply to CLOB.
1:         String vsClob = drainStringFromSource(rs.getCharacterStream(2));
1:         assertEquals(clobSize, vsClob.length());
1:         rs.close();
1: 
1:         // Again, but without a limit.
1:         stmt = createStatement();
1:         rs = stmt.executeQuery("select dVarchar, dClob from " +
1:                 "setMaxFieldSize where id = " + id);
1:         assertTrue(rs.next());
1:         vcStr = drainStringFromSource(rs.getCharacterStream(1));
1:         assertEquals(vcSize, vcStr.length());
1:         vsClob = drainStringFromSource(rs.getCharacterStream(2));
1:         assertEquals(clobSize, vsClob.length());
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Drains the specified reader and returns a string.
1:      *
1:      * @param src the reader to drain
1:      * @return The reader content as a string.
1:      * @throws IOException if reading from the source fails
1:      */
1:     private static String drainStringFromSource(Reader src)
1:             throws IOException {
1:         StringBuffer str = new StringBuffer();
1:         char[] buf = new char[1024];
1:         while (true) {
1:             int read = src.read(buf);
1:             if (read == -1) {
1:                 break;
1:             }
1:             str.append(buf, 0, read);
1:         }
1:         return str.toString();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 s.execute("create table setMaxFieldSize(id int unique, " +
1:                         "dVarchar VARCHAR(32672), dClob clob)");
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:575f028
/////////////////////////////////////////////////////////////////////////
1:                 "functionTests/testData/ResultSetStream/resultsetStream.gif" });
commit:b3a80f0
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ResultSetStreamTest
1:  *  
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.io.BufferedInputStream;
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileNotFoundException;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.io.StringReader;
0: import java.net.ServerSocket;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.zip.CRC32;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derby.tools.JDBCDisplayUtil;
0: import org.apache.derbyTesting.functionTests.tests.jdbcapi.resultsetStream.TestOfGetAsciiStream;
0: import org.apache.derbyTesting.functionTests.tests.tools.ImportExportTest;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public class ResultSetStreamTest extends BaseJDBCTestCase {
1: 
1:     public ResultSetStreamTest(String name) {
1:         super(name);
1: 
1:     }
1: 
1:     private static String filePath;
1: 
1:     private static String sep;
1: 
1:     public void testInsertData() throws SQLException, Exception {
1:         try {
1: 
0:             AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                 public Object run() throws SQLException, FileNotFoundException,
1:                         IOException {
1:                     insertData();
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             throw e.getException();
1:         }
1:     }
1: 
1:     /**
1:      * Test insert of data with setBinaryStream
1:      * 
1:      * @throws SQLException
1:      * @throws FileNotFoundException
1:      * @throws IOException
1:      */
1:     private void insertData() throws SQLException, FileNotFoundException,
1:             IOException {
1:         Connection conn = getConnection();
1:         PreparedStatement ppw = conn
1:                 .prepareStatement("insert into t2 (len, data) values (?, ?)");
1:         filePath = "extin";
1:         String userDir = System.getProperty("user.dir");
1:         sep = System.getProperty("file.separator");
1:         filePath = userDir + sep + filePath;
1:         File file = new File(filePath + sep + "littleclob.utf");
1:         int fileSize = (int) file.length();
1:         BufferedInputStream fileData = new BufferedInputStream(
1:                 new FileInputStream(file));
1:         ppw.setInt(1, fileSize);
1:         ppw.setBinaryStream(2, fileData, fileSize);
1:         ppw.executeUpdate();
1:         fileData.close();
1: 
1:         file = new File(filePath + sep + "short.utf");
1:         fileSize = (int) file.length();
1:         fileData = new BufferedInputStream(new FileInputStream(file));
1:         ppw.setInt(1, fileSize);
1:         ppw.setBinaryStream(2, fileData, fileSize);
1:         ppw.executeUpdate();
1:         fileData.close();
1:         // null binary value
1:         ppw.setInt(1, -1);
1:         ppw.setBinaryStream(2, (java.io.InputStream) null, 0);
1:         ppw.executeUpdate();
1: 
1:         // value copied over from original Java object test.
1:         File rssg = new java.io.File(filePath + sep + "resultsetStream.gif");
1:         int rssgLength = (int) rssg.length();
1:         ppw.setInt(1, (int) rssgLength);
1:         fileData = new BufferedInputStream(new FileInputStream(rssg));
1:         ppw.setBinaryStream(2, fileData, rssgLength);
1:         ppw.executeUpdate();
1:         fileData.close();
1: 
1:         // check binary input streams of invalid length.
1:         // JDBC 3.0 tutorial says stream contents must match length.
1: 
1:         byte[] tooFew = new byte[234];
1: 
1:         ppw.setInt(1, 234);
1:         ppw.setBinaryStream(2, new java.io.ByteArrayInputStream(tooFew), 234); // matching length
1:         ppw.executeUpdate();
1: 
1: 
1:         ppw.setInt(1, 235);
1:         ppw.setBinaryStream(2, new java.io.ByteArrayInputStream(tooFew), 235); // too few bytes in stream
1:         try {
1:                 ppw.executeUpdate();
1:                 fail("FAIL - execute with setBinaryStream() with too few bytes succeeded");
1:         } catch (SQLException sqle) {       
1:                 assertMisMatchStreamLength(sqle);
1:         }
1: 
1:         ppw.setInt(1, 233);
1:         ppw.setBinaryStream(2, new java.io.ByteArrayInputStream(tooFew), 233); // too many bytes
1:         try {
1:                 ppw.executeUpdate();
1:                 fail("FAIL - execute with setBinaryStream() with too many bytes succeeded");
1:         } catch (SQLException sqle) {
1:             assertMisMatchStreamLength(sqle);
1:         }
1: 
1:         ppw.close();
1: 
1:     }
1: 
1:     private void assertMisMatchStreamLength(SQLException sqle) {
1:         if (usingEmbedded()) {
1:             assertEquals("XSDA4",sqle.getSQLState());
1:             sqle = sqle.getNextException();
1:             assertSQLState("XJ001",sqle);
1:         } else {
1:             String state = sqle.getSQLState();
1:             assertTrue("SQLState not XN015 or XN017 as expected", "XN015".equals(state) || "XN017".equals(state));
1:         }
1:     }
1: 
1:     public void testBinaryStreamProcessing() throws SQLException, Exception {
1:         try {
1: 
0:             AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                 public Object run() throws SQLException, FileNotFoundException,
1:                         IOException {
1:                     binaryStreamProcessing();
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             throw e.getException();
1:         }
1:     }
1: 
1:     /**
1:      * Test getBinaryStream by comparing chksum of retrieved value.
1:      * 
1:      * @throws SQLException
1:      * @throws IOException
1:      */
1:     public void binaryStreamProcessing() throws SQLException, IOException {
1:         Connection conn = getConnection();
1:         Statement s = conn.createStatement();
1: 
1:         filePath = "extin";
1:         String userDir = System.getProperty("user.dir");
1:         sep = System.getProperty("file.separator");
1:         filePath = userDir + sep + filePath;
1: 
1:         File rssg = new java.io.File(filePath + sep + "resultsetStream.gif");
1:         int rssgLength = (int) rssg.length();
1:         ResultSet rs = s.executeQuery("select data from t2 where len = "
1:                 + rssgLength);
1:         ResultSetMetaData met = rs.getMetaData();
1:         assertEquals(1, met.getColumnCount());
1: 
1:         while (rs.next()) {
1:             // JDBC columns use 1-based counting
1: 
1:             // get the first column as a stream
1: 
1:             InputStream is = rs.getBinaryStream(1);
1:             if (is == null) {
1:                 fail("FAIL - getBinaryStream() return null");
1:                 break;
1:             }
1: 
1:             // read the first 200 bytes from the stream and checksum them
1:             byte[] b200 = new byte[200];
1: 
1:             // no guaratees to read all 200 bytes in one read call.
1:             int count = 0;
1: 
1:             while (count < 200) {
1:                 int r = is.read(b200, count, 200 - count);
1:                 if (r == -1)
1:                     break;
1:                 count += r;
1:             }
1: 
1:             if (count != 200) {
1:                 fail("FAIL - failed to read 200 bytes from known file");
1:                 break;
1:             }
1: 
1:             CRC32 cs = new CRC32();
1: 
1:             cs.reset();
1:             cs.update(b200);
1:             assertEquals("Incorrect checksum value", 3061553656L, cs.getValue());
1:             count = 200;
1:             for (; is.read() != -1; count++) {
1:             }
1:             assertEquals("unexpected size of file", 3470, count);
1:             rs.close();
1:             // check the stream is closed once another get call is made.
1:             rs = s.executeQuery("select data, len from t2 where len = "
1:                     + rssgLength);
1:             met = rs.getMetaData();
1:             assertEquals(2, met.getColumnCount());
1: 
1:             while (rs.next()) {
1:                 // JDBC columns use 1-based counting
1: 
1:                 // get the first column as a stream
1:                 is = rs.getBinaryStream(1);
1:                 if (is == null) {
1:                     fail("FAIL - getBinaryStream() return null");
1:                     break;
1:                 }
1: 
1:                 // read the first 200 bytes from the stream and checksum them
1:                 b200 = new byte[200];
1: 
1:                 // no guaratees to read all 200 bytes in one read call.
1:                 count = 0;
1: 
1:                 while (count < 200) {
1:                     int r = is.read(b200, count, 200 - count);
1:                     if (r == -1)
1:                         break;
1:                     count += r;
1:                 }
1: 
1:                 if (count != 200) {
1:                     fail("FAIL - failed to read 200 bytes from known file");
1:                     break;
1:                 }
1: 
1:                 cs = new CRC32();
1: 
1:                 cs.reset();
1:                 cs.update(b200);
1:                 assertEquals("Incorrect checksum value", 3061553656L, cs
1:                         .getValue());
1:                 assertEquals(3470, rs.getInt(2));
1:                 try {
1:                     is.read();
1:                     fail("FAIL - stream was not closed after a get*() call. "
1:                                     + is.getClass());
1:                     break;
1:                 } catch (IOException ioe) {
1:                     // yes, stream should be closed
1:                 }
1: 
1:             }
1:             rs.close();
1: 
1:             // check a SQL null object gets a null stream
1:             rs = s.executeQuery("select data from t2 where len = -1");
1:             met = rs.getMetaData();
1:             assertEquals(1,met.getColumnCount());
1:             
1:            while (rs.next())
1:                 {
1:                // JDBC columns use 1-based counting
1:                
1:                // get the first column as a stream
1: 
1:                is = rs.getBinaryStream(1);
1:                    if (is != null) {
1:                        fail("FAIL - getBinaryStream() did not return null for SQL null");
1:                        break;
1:                    }
1: 
1:                 }
1:            
1:                 rs.close();
1:                 File file = new File(filePath + sep + "short.utf");
1:                 int fileSize = (int) file.length();
1:                 rs = s.executeQuery("select len, data from t2 where len = "
1:                                                                 +  fileSize);
1:                 rs.next();
1:                 fileSize = rs.getInt(1);
1:                 BufferedInputStream fileData = new BufferedInputStream(rs.getBinaryStream(2));
1:                 int readCount = 0;
1:                 while(true)
1:                 {
1:                         int data = fileData.read();
1:                         if (data == -1) break;
1:                         readCount++;
1:                 }
1:                 fileData.close();
1:                 assertEquals(56, fileSize);
1:                 assertEquals(56,readCount);
1:         }
1:                 
1:                 rs.close();
1:                 s.close();
1:         
1:     }
1:     final static String TEST_STRING_DATA = 
1:         "ABCDEFG" + 
1:         "\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5" + 
1:         "\u00ff\u0100" + 
1:         "\u3042\u3044\u3046\u3048\u304a";
1:     
1:     public void testGetAsciiStream() throws SQLException, IOException {
1:         Connection conn = getConnection();
1:         PreparedStatement st;
1:         st = conn.prepareStatement("insert into t3(text_data) values(?)");
1:         st.setCharacterStream(1,
1:                               new StringReader(TEST_STRING_DATA),
1:                               TEST_STRING_DATA.length());
1:         st.executeUpdate();
1:         st = conn.prepareStatement("select " + 
1:                    "text_data as text_data_col1," + 
1:                    "text_data as text_data_col2 " + 
1:                    "from " + 
1:                    "t3");
1:         ResultSet rs = st.executeQuery();
1: 
1:         while(rs.next()){
1:             InputStream is = rs.getAsciiStream(1);
1:             int i = 0;
1:             for(int c = is.read(); c > -1; c = is.read()){
1:                 int exp = (int) TEST_STRING_DATA.charAt(i++);
1:                 if (exp > 255)
1:                     exp  = (int) 0x3f;
1:                 assertEquals(exp,c);
1:     
1:             }
1:             Statement s = createStatement();
1:             s.executeUpdate("delete from t3");
1:         }
1: 
1:         
1:     }
1:     
1:     /**
1:      * test getCharacterStream against inserted data
1:      * 
1:      * @throws SQLException
1:      * @throws IOException
1:      */
1:     public void testGetCharacterStream() throws SQLException, IOException {
1:         Connection conn = getConnection();
1:         PreparedStatement st;
1:         st = conn.prepareStatement("insert into t3(text_data) values(?)");
1:         st.setCharacterStream(1,
1:                               new StringReader(TEST_STRING_DATA),
1:                               TEST_STRING_DATA.length());
1:         st.executeUpdate();
1:         st = conn.prepareStatement("select " + 
1:                    "text_data as text_data_col1," + 
1:                    "text_data as text_data_col2 " + 
1:                    "from " + 
1:                    "t3");
1:         ResultSet rs = st.executeQuery();
1: 
1:         while(rs.next()){
1:             Reader r = rs.getCharacterStream(1);
1:             int i = 0;
1:             for(int c = r.read(); c > -1; c = r.read()){
1:                 int exp = (int) TEST_STRING_DATA.charAt(i++);
1:                 assertEquals(exp,c);
1:             }
1:         }
1:         Statement s = createStatement();
1:         s.executeUpdate("delete from t3");
1:         
1:     }
1:     
1:     public static Test basesuite(String name) {
0:         TestSuite suite = new TestSuite(ResultSetStreamTest.class, name);
1:         Test test = new SupportFilesSetup(suite, new String[] {
1:                 "functionTests/testData/ResultSetStream/littleclob.utf",
1:                 "functionTests/testData/ResultSetStream/short.utf",
0:                 "functionTests/testData/ResultSetStream/resultsetstream.gif" });
1: 
1:         return new CleanDatabaseTestSetup(test) {
1:             protected void decorateSQL(Statement s) throws SQLException {
1: 
1:                 s.execute("create table t2 (len int, data LONG VARCHAR FOR BIT DATA)");
1:                 s.execute("create table t3(text_data clob)");
1: 
1:             }
1:         };
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("ResultSetStreamTest");
1:         suite.addTest(basesuite("ResultSetStreamTest:embedded"));
1:         suite.addTest(TestConfiguration.clientServerDecorator(basesuite("ResultSetStreamTest:client")));
1:         return suite;
1: 
1:     }
1: }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:38cc87a
/////////////////////////////////////////////////////////////////////////
============================================================================