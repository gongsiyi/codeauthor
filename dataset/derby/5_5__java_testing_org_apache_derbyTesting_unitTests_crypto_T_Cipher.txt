1:2bc809f: /*
7:2bc809f: 
1:2bc809f:    Derby - Class org.apache.derbyTesting.unitTests.crypto.T_Cipher
1:2bc809f: 
1:c38b841:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c38b841:    contributor license agreements.  See the NOTICE file distributed with
1:c38b841:    this work for additional information regarding copyright ownership.
1:c38b841:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c38b841:    (the "License"); you may not use this file except in compliance with
1:c38b841:    the License.  You may obtain a copy of the License at
1:2bc809f: 
1:2bc809f:       http://www.apache.org/licenses/LICENSE-2.0
1:2bc809f: 
1:2bc809f:    Unless required by applicable law or agreed to in writing, software
1:2bc809f:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bc809f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bc809f:    See the License for the specific language governing permissions and
1:2bc809f:    limitations under the License.
1:2bc809f: 
1:2bc809f:  */
1:2bc809f: 
1:2bc809f: package org.apache.derbyTesting.unitTests.crypto;
1:2bc809f: 
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.crypto.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.monitor.Monitor;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.error.StandardException;
1:2bc809f: 
1:9ce0e0f: import java.security.AccessController;
1:2bc809f: import java.security.Key;
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:9ce0e0f: import java.security.PrivilegedAction;
1:2bc809f: 
1:2bc809f: import java.io.File;
1:2bc809f: import java.io.RandomAccessFile;
1:2bc809f: import java.io.IOException;
1:2bc809f: 
1:2bc809f: import java.util.Properties;
1:2bc809f: 
1:2bc809f: 
1:2bc809f: /*
1:2bc809f: // PT
1:2bc809f: import javax.crypto.Cipher;
1:2bc809f: import javax.crypto.spec.SecretKeySpec;
1:2bc809f: import java.security.spec.KeySpec;
1:2bc809f: import java.security.AlgorithmParameters;
1:2bc809f: // import java.security.spec.AlgorithmParameterSpec;
1:2bc809f: import javax.crypto.spec.IvParameterSpec;
1:2bc809f: import java.security.GeneralSecurityException;
1:2bc809f: import java.security.MessageDigest;
1:2bc809f: import java.lang.reflect.*;
1:2bc809f: */
1:2bc809f: 
1:2bc809f: 
1:2bc809f: /*
1:2bc809f: 	To run, put the following line in derby.properties
1:2bc809f: 	derby.module.test.T_Cipher=org.apache.derbyTesting.unitTests.crypto.T_Cipher
1:2bc809f: 
1:2bc809f: 	and run java org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 
1:2bc809f: */
1:2bc809f: public class T_Cipher extends T_Generic
1:2bc809f: {
1:2bc809f: 	private static final String testService = "CipherText";
1:2bc809f: 
1:2bc809f: 	CipherProvider enEngine;
1:2bc809f: 	CipherProvider deEngine;
1:2bc809f: 	Key secretKey;
1:2bc809f: 	byte[] IV;
1:2bc809f: 
1:2bc809f: 	CipherFactory factory;
1:2bc809f:     
1:2bc809f: 	public T_Cipher()
1:2bc809f: 	{
1:2bc809f: 		super();
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	** Methods required by T_Generic
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	public String getModuleToTestProtocolName() {
1:8a62d60: 		return org.apache.derby.iapi.reference.Module.CipherFactoryBuilder;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f:     protected String getAlgorithm()
1:2bc809f:     {
1:2bc809f:         return "DES/CBC/NoPadding";
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     protected String getProvider()
1:2bc809f:     {
1:2bc809f: 	// allow for alternate providers
1:9ce0e0f: 	String testProvider = 
1:2bc809f: 		
1:3f5c48a:         AccessController.doPrivileged(new PrivilegedAction<String>() {
1:3f5c48a:             public String run() {
1:9ce0e0f: 		    	return System.getProperty("testEncryptionProvider");
1:2bc809f: 		    }
1:9ce0e0f: 	    });
1:56c1dc2: 	
1:2bc809f: 	if (testProvider != null) 
1:2bc809f: 		return testProvider;
1:2bc809f: 	else
1:2bc809f: 		return null;	
1:2bc809f: 
1:2bc809f:     }
1:2bc809f: 
1:2bc809f: 	public void runTests() throws T_Fail {
1:2bc809f: 
1:2bc809f: 		File testFile = new File("extinout/T_Cipher.data");
1:9ce0e0f: 		deleteFile(testFile);
1:2bc809f: 
1:2bc809f: 		String bootPassword = "a secret, don't tell anyone";
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			RandomAccessFile file = new RandomAccessFile(testFile, "rw");
1:2bc809f: 
1:2bc809f: 			setupCiphers(bootPassword);
1:2bc809f: 
1:2bc809f: 			// run thru some in patterns
1:2bc809f: 			int patternLength = 8192;
1:2bc809f: 			byte[] pattern = new byte[patternLength];
1:2bc809f: 			for (int i = 0; i < patternLength; i++)
1:2bc809f: 				pattern[i] = (byte)(i & 0xFF);
1:2bc809f: 
1:2bc809f: 			test(pattern, 0, 8, file);	// test short patterns
1:2bc809f: 			test(pattern, 8, 8, file);
1:2bc809f: 			test(pattern, 1, 16, file);
1:2bc809f: 
1:2bc809f: 			test(pattern, 0, patternLength, file); // test long pattern
1:2bc809f: 			test(pattern, 0, patternLength/2, file);
1:2bc809f: 			test(pattern, 1, patternLength/2, file);
1:2bc809f: 			test(pattern, 2, patternLength/2, file);
1:2bc809f: 			test(pattern, 3, patternLength/2, file);
1:2bc809f: 
1:2bc809f: 			file.seek(0);
1:2bc809f: 			check(pattern, 0, 8, file);	// file offset 0
1:2bc809f: 			check(pattern, 8, 8, file);	// file offset 8
1:2bc809f: 			check(pattern, 1, 16, file);	// file offset 16
1:2bc809f: 			check(pattern, 0, patternLength, file);	// file offset 32
1:2bc809f: 			check(pattern, 0, patternLength/2, file);// file offset 32+patternLength
1:2bc809f: 			check(pattern, 1, patternLength/2, file);// file offset 32+patternLength+(patternLength/2)
1:2bc809f: 			check(pattern, 2, patternLength/2, file);// file offset 32+(2*patternLength)
1:2bc809f: 			check(pattern, 3, patternLength/2, file);// file offset 32+(2*patternLength)+(patternLength/2);
1:2bc809f: 
1:2bc809f: 			REPORT("starting random test");
1:2bc809f: 
1:2bc809f: 			// now do some random testing from file
1:2bc809f: 			file.seek(32+patternLength);
1:2bc809f: 			check(pattern, 0, patternLength/2, file);
1:2bc809f: 
1:2bc809f: 			file.seek(32);
1:2bc809f: 			check(pattern, 0, patternLength, file);
1:2bc809f: 
1:2bc809f: 			file.seek(32+(2*patternLength));
1:2bc809f: 			check(pattern, 2, patternLength/2, file);
1:2bc809f: 
1:2bc809f: 			file.seek(0);
1:2bc809f: 			check(pattern, 0, 8, file);
1:2bc809f: 
1:2bc809f: 			file.seek(16);
1:2bc809f: 			check(pattern, 1, 16, file);
1:2bc809f: 
1:2bc809f: 			file.seek(32+(2*patternLength)+(patternLength/2));
1:2bc809f: 			check(pattern, 3, patternLength/2, file);
1:2bc809f: 
1:2bc809f: 			file.seek(8);
1:2bc809f: 			check(pattern, 8, 8, file);
1:2bc809f: 
1:2bc809f: 			file.seek(32+patternLength+(patternLength/2));
1:2bc809f: 			check(pattern, 1, patternLength/2, file);
1:2bc809f: 
1:2bc809f: 			file.close();
1:2bc809f: 		}
1:2bc809f: 		catch (StandardException se)
1:2bc809f: 		{
1:2bc809f: 			se.printStackTrace(System.out);
1:2bc809f: 			throw T_Fail.exceptionFail(se);
1:2bc809f: 		}
1:2bc809f: 		catch (IOException ioe)
1:2bc809f: 		{
1:2bc809f: 			throw T_Fail.exceptionFail(ioe);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		PASS("T_Cipher");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	protected void setupCiphers(String bootPassword) throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f:         // set properties for testing
1:2bc809f:         Properties props = new Properties();
1:2bc809f:         props.put("encryptionAlgorithm",getAlgorithm());
1:2bc809f:         String provider = getProvider();
1:2bc809f:         if (provider != null)
1:2bc809f:             props.put("encryptionProvider",getProvider());
1:2bc809f: 		props.put("bootPassword", bootPassword);
1:2bc809f: 
1:2bc809f:         REPORT("encryption algorithm used : " + getAlgorithm());
1:2bc809f:         REPORT("encryption provider used : " + provider);
1:2bc809f: 
1:8a62d60:         CipherFactoryBuilder cb =  (CipherFactoryBuilder)
1:56c1dc2:             startSystemModule(org.apache.derby.iapi.reference.Module.CipherFactoryBuilder);
1:2bc809f: 
1:8a62d60:         factory = cb.createCipherFactory(true, props, false);
1:2bc809f: 
1:2bc809f: 		if (factory == null)
1:2bc809f: 			throw T_Fail.testFailMsg("cannot find Cipher factory ");
1:2bc809f: 
1:2bc809f: 		enEngine = factory.createNewCipher(CipherFactory.ENCRYPT);
1:2bc809f: 		deEngine = factory.createNewCipher(CipherFactory.DECRYPT);
1:2bc809f: 
1:2bc809f: 		if (enEngine == null)
1:2bc809f: 			throw T_Fail.testFailMsg("cannot create encryption engine");
1:2bc809f: 		if (deEngine == null)
1:2bc809f: 			throw T_Fail.testFailMsg("cannot create decryption engine");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void test(byte[] cleartext, int offset, int length,
1:2bc809f: 					  RandomAccessFile outfile)
1:2bc809f: 		 throws T_Fail, StandardException, IOException
1:2bc809f: 	{
1:2bc809f: 		byte[] ciphertext = new byte[length];
1:2bc809f: 		System.arraycopy(cleartext, offset, ciphertext, 0, length);
1:2bc809f: 
1:2bc809f: 		if (enEngine.encrypt(ciphertext, 0, length, ciphertext, 0) != length)
1:2bc809f: 			throw T_Fail.testFailMsg("encrypted text length != length");
1:2bc809f: 
1:2bc809f: 		if (byteArrayIdentical(ciphertext, cleartext, offset, length))
1:2bc809f: 			throw T_Fail.testFailMsg("encryption just made a copy of the clear text");
1:2bc809f: 
1:2bc809f: 		outfile.write(ciphertext);
1:2bc809f: 
1:2bc809f: 		// now decrypt it and check
1:2bc809f: 		deEngine.decrypt(ciphertext, 0, length, ciphertext, 0);
1:2bc809f: 		if (byteArrayIdentical(ciphertext, cleartext, offset, length) == false)
1:2bc809f: 			throw T_Fail.testFailMsg("decryption did not yield the same clear text");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void check(byte[] cleartext, int offset, int length,
1:2bc809f: 					   RandomAccessFile infile)
1:2bc809f: 		 throws IOException, T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		byte[] ciphertext = new byte[length];
1:2bc809f: 		infile.read(ciphertext);
1:2bc809f: 
1:2bc809f: 		if (deEngine.decrypt(ciphertext, 0, length, ciphertext, 0) != length)
1:2bc809f: 			throw T_Fail.testFailMsg("decrypted text length != length");
1:2bc809f: 
1:2bc809f: 		if (byteArrayIdentical(ciphertext, cleartext, offset, length) == false)
1:2bc809f: 			throw T_Fail.testFailMsg("decryption did not yield the same clear text");
1:2bc809f: 
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	// see if 2 byte arrays are identical
1:2bc809f: 	protected boolean byteArrayIdentical(byte[] compare, byte[] original,
1:2bc809f: 									  int offset, int length)
1:2bc809f: 	{
1:2bc809f: 		for (int i = 0; i < length; i++)
1:2bc809f: 		{
1:2bc809f: 			if (compare[i] != original[offset+i])
1:2bc809f: 				return false;
1:2bc809f: 		}
1:2bc809f: 		return true;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f:     /*
1:2bc809f:     private void testBlowfish()
1:2bc809f:     {
1:2bc809f:         System.out.println("Running testBlowfish");
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             // set up the provider
1:2bc809f:             java.security.Provider sunJce = new com.sun.crypto.provider.SunJCE();
1:2bc809f:             java.security.Security.addProvider(sunJce);
1:2bc809f: 
1:2bc809f:             // String key = "Paula bla la da trish123 sdkfs;ldkg;sa'jlskjgklad";
1:2bc809f:             String key = "Paulabla123456789012345";
1:2bc809f:             byte[] buf = key.getBytes();
1:2bc809f:             System.out.println("key length is " + buf.length);
1:2bc809f:             SecretKeySpec sKeySpec = new SecretKeySpec(buf,"Blowfish");
1:2bc809f:             // SecretKeySpec sKeySpec = new SecretKeySpec(buf,"DESede");
1:2bc809f: 
1:2bc809f:             Cipher cipher = Cipher.getInstance("Blowfish/CBC/NoPadding");
1:2bc809f:             // Cipher cipher = Cipher.getInstance("DESede/CBC/NoPadding");
1:2bc809f:             // Cipher cipher = Cipher.getInstance("Blowfish/CBC/PKCS5Padding");
1:2bc809f:             cipher.init(Cipher.ENCRYPT_MODE,sKeySpec);
1:2bc809f:             // only works with NoPadding if size is a multiple of 8 bytes
1:2bc809f:             // with PKCS5Padding, works for all sizes
1:2bc809f:             byte[] original = "This is what should get encrypte".getBytes();
1:2bc809f:             System.out.println("original length is " + original.length);
1:2bc809f:             byte[] encrypted = cipher.doFinal(original);
1:2bc809f:             // works
1:2bc809f:             // AlgorithmParameters algParam = cipher.getParameters();
1:2bc809f:             byte[] iv = cipher.getIV();
1:2bc809f:             System.out.println("length of iv is " + iv.length);
1:2bc809f: 
1:2bc809f:             Cipher cipher2 = Cipher.getInstance("Blowfish/CBC/NoPadding");
1:2bc809f:             // Cipher cipher2 = Cipher.getInstance("DESede/CBC/NoPadding");
1:2bc809f:             // Cipher cipher2 = Cipher.getInstance("Blowfish/CBC/PKCS5Padding");
1:2bc809f: 
1:2bc809f:             // works
1:2bc809f:             // cipher2.init(Cipher.DECRYPT_MODE,sKeySpec,algParam);
1:2bc809f:             IvParameterSpec ivClass = new IvParameterSpec(iv);
1:2bc809f:             cipher2.init(Cipher.DECRYPT_MODE,sKeySpec,ivClass);
1:2bc809f:             byte[] decrypted = cipher2.doFinal(encrypted);
1:2bc809f: 
1:2bc809f:             if (byteArrayIdentical(original,decrypted,0,original.length))
1:2bc809f:                 System.out.println("PASSED");
1:2bc809f:             else
1:2bc809f:                 System.out.println("FAILED");
1:2bc809f: 
1:2bc809f:             System.out.println("original length is " + original.length);
1:2bc809f:             System.out.println("encrypted length is " + encrypted.length);
1:2bc809f:             System.out.println("decrypted length is " + decrypted.length);
1:2bc809f:         }
1:2bc809f:         catch (Throwable t)
1:2bc809f:         {
1:2bc809f:             System.out.println("got an exception");
1:2bc809f:             t.printStackTrace();
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         System.out.println("Finished testBlowfish");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f: 
1:2bc809f:     private void testCryptix()
1:2bc809f:     {
1:2bc809f:         System.out.println("Running testCryptix");
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             // set up the provider
1:2bc809f:             Class jceClass = Class.forName("cryptix.jce.provider.Cryptix");
1:2bc809f:             java.security.Provider cryptixProvider = (java.security.Provider) jceClass.newInstance();
1:2bc809f:             java.security.Security.addProvider(cryptixProvider);
1:2bc809f: 
1:2bc809f: 		    byte[] userkey = "a secret".getBytes();
1:2bc809f:             System.out.println("userkey length is " + userkey.length);
1:2bc809f:             Key secretKey = (Key) (new SecretKeySpec(userkey, "DES"));
1:2bc809f: 		    byte[] IV = "anivspec".getBytes();
1:2bc809f: 
1:2bc809f:             Cipher enCipher = Cipher.getInstance("DES/CBC/NoPadding","Cryptix");
1:2bc809f:             Cipher deCipher = Cipher.getInstance("DES/CBC/NoPadding","Cryptix");
1:2bc809f: 			IvParameterSpec ivspec = new IvParameterSpec(IV);
1:2bc809f: 
1:2bc809f:             enCipher.init(Cipher.ENCRYPT_MODE,secretKey,ivspec);
1:2bc809f:             deCipher.init(Cipher.DECRYPT_MODE,secretKey,ivspec);
1:2bc809f: 
1:2bc809f:             int patternLength = 8;
1:2bc809f:             byte[] pattern = new byte[patternLength];
1:2bc809f: 			for (int i = 0; i < patternLength; i++)
1:2bc809f: 				pattern[i] = (byte)(i & 0xFF);
1:2bc809f: 
1:2bc809f:             byte[] cipherOutput1 = new byte[patternLength];
1:2bc809f:             byte[] cipherOutput2 = new byte[patternLength];
1:2bc809f: 
1:2bc809f:             int retval = 0;
1:2bc809f:             retval = enCipher.doFinal(pattern, 0, 8, cipherOutput1, 0);
1:2bc809f: 
1:2bc809f:             retval = deCipher.doFinal(cipherOutput1, 0, 8, cipherOutput2, 0);
1:2bc809f: 
1:2bc809f:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:2bc809f:                 System.out.println("PASSED TEST 1");
1:2bc809f:             else
1:2bc809f:                 System.out.println("FAILED TEST 1");
1:2bc809f: 
1:2bc809f:             retval = deCipher.doFinal(cipherOutput1, 0, 8, cipherOutput2, 0);
1:2bc809f: 
1:2bc809f:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:2bc809f:                 System.out.println("PASSED TEST 2");
1:2bc809f:             else
1:2bc809f:                 System.out.println("FAILED TEST 2");
1:2bc809f:         }
1:2bc809f:         catch (Throwable t)
1:2bc809f:         {
1:2bc809f:             System.out.println("got an exception");
1:2bc809f:             t.printStackTrace();
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         System.out.println("Finished testCryptix");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 
1:2bc809f:     private void testMessageDigest()
1:2bc809f:     {
1:2bc809f:         // No provider needs to be installed for this to work.
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             MessageDigest md = MessageDigest.getInstance("MD5");
1:2bc809f:             byte[] data = "Paulas digest".getBytes();
1:2bc809f:             byte[] digest = md.digest(data);
1:2bc809f:             byte[] digest2 = md.digest(data);
1:2bc809f:             if (byteArrayIdentical(digest,digest2,0,digest.length))
1:2bc809f:                 System.out.println("PASSED");
1:2bc809f:             else
1:2bc809f:                 System.out.println("FAILED");
1:2bc809f: 
1:2bc809f:             System.out.println("data length is " + data.length);
1:2bc809f:             System.out.println("digest length is " + digest.length);
1:2bc809f:             System.out.println("digest2 length is " + digest2.length);
1:2bc809f:         }
1:2bc809f:         catch (Throwable t)
1:2bc809f:         {
1:2bc809f:             System.out.println("got an exception");
1:2bc809f:             t.printStackTrace();
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         System.out.println("Finished testBlowfish");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     // PT
1:2bc809f:     private void testPCBC()
1:2bc809f:     {
1:2bc809f:         System.out.println("Running testPCBC");
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             // set up the provider
1:2bc809f:             Class jceClass = Class.forName("com.sun.crypto.provider.SunJCE");
1:2bc809f:             java.security.Provider myProvider = (java.security.Provider) jceClass.newInstance();
1:2bc809f:             java.security.Security.addProvider(myProvider);
1:2bc809f:             // java.security.Provider sunJce = new com.sun.crypto.provider.SunJCE();
1:2bc809f:             // java.security.Security.addProvider(sunJce);
1:2bc809f: 
1:2bc809f:             // String key = "Paula bla la da trish123 sdkfs;ldkg;sa'jlskjgklad";
1:2bc809f:             String key = "PaulablaPaulablaPaulabla";
1:2bc809f:             byte[] buf = key.getBytes();
1:2bc809f:             System.out.println("key length is " + buf.length);
1:2bc809f:             SecretKeySpec sKeySpec = new SecretKeySpec(buf,"DESede");
1:2bc809f: 
1:2bc809f:             Cipher cipher = Cipher.getInstance("DESede/PCBC/NoPadding");
1:2bc809f:             // Cipher cipher = Cipher.getInstance("DESede/CBC/NoPadding");
1:2bc809f:             // Cipher cipher = Cipher.getInstance("Blowfish/CBC/PKCS5Padding");
1:2bc809f:             cipher.init(Cipher.ENCRYPT_MODE,sKeySpec);
1:2bc809f:             // only works with NoPadding if size is a multiple of 8 bytes
1:2bc809f:             // with PKCS5Padding, works for all sizes
1:2bc809f:             byte[] original = "This is what should get encrypte".getBytes();
1:2bc809f:             System.out.println("original length is " + original.length);
1:2bc809f:             byte[] encrypted = cipher.doFinal(original);
1:2bc809f:             // works
1:2bc809f:             // AlgorithmParameters algParam = cipher.getParameters();
1:2bc809f:             byte[] iv = cipher.getIV();
1:2bc809f:             System.out.println("length of iv is " + iv.length);
1:2bc809f: 
1:2bc809f:             Cipher cipher2 = Cipher.getInstance("DESede/PCBC/NoPadding");
1:2bc809f:             // Cipher cipher2 = Cipher.getInstance("DESede/CBC/NoPadding");
1:2bc809f:             // Cipher cipher2 = Cipher.getInstance("Blowfish/CBC/PKCS5Padding");
1:2bc809f: 
1:2bc809f:             // works
1:2bc809f:             // cipher2.init(Cipher.DECRYPT_MODE,sKeySpec,algParam);
1:2bc809f:             IvParameterSpec ivClass = new IvParameterSpec(iv);
1:2bc809f:             cipher2.init(Cipher.DECRYPT_MODE,sKeySpec,ivClass);
1:2bc809f:             byte[] decrypted = cipher2.doFinal(encrypted);
1:2bc809f: 
1:2bc809f:             if (byteArrayIdentical(original,decrypted,0,original.length))
1:2bc809f:                 System.out.println("PASSED");
1:2bc809f:             else
1:2bc809f:                 System.out.println("FAILED");
1:2bc809f: 
1:2bc809f:             System.out.println("original length is " + original.length);
1:2bc809f:             System.out.println("encrypted length is " + encrypted.length);
1:2bc809f:             System.out.println("decrypted length is " + decrypted.length);
1:2bc809f:         }
1:2bc809f:         catch (Throwable t)
1:2bc809f:         {
1:2bc809f:             System.out.println("got an exception");
1:2bc809f:             t.printStackTrace();
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         System.out.println("Finished testPCBC");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f: 
1:2bc809f:     private void testPCBC2()
1:2bc809f:     {
1:2bc809f:         System.out.println("Running testPCBC2");
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             // set up the provider
1:2bc809f:             Class jceClass = Class.forName("com.sun.crypto.provider.SunJCE");
1:2bc809f:             java.security.Provider myProvider = (java.security.Provider) jceClass.newInstance();
1:2bc809f:             java.security.Security.addProvider(myProvider);
1:2bc809f: 
1:2bc809f: 		    byte[] userkey = "a secreta secreta secret".getBytes();
1:2bc809f:             System.out.println("userkey length is " + userkey.length);
1:2bc809f:             Key secretKey = (Key) (new SecretKeySpec(userkey, "DESede"));
1:2bc809f: 		    byte[] IV = "anivspec".getBytes();
1:2bc809f: 
1:2bc809f:             Cipher enCipher = Cipher.getInstance("DESede/PCBC/NoPadding","SunJCE");
1:2bc809f:             Cipher deCipher = Cipher.getInstance("DESede/PCBC/NoPadding","SunJCE");
1:2bc809f: 			IvParameterSpec ivspec = new IvParameterSpec(IV);
1:2bc809f: 
1:2bc809f:             enCipher.init(Cipher.ENCRYPT_MODE,secretKey,ivspec);
1:2bc809f:             deCipher.init(Cipher.DECRYPT_MODE,secretKey,ivspec);
1:2bc809f: 
1:2bc809f:             int patternLength = 24;
1:2bc809f:             byte[] pattern = new byte[patternLength];
1:2bc809f: 			for (int i = 0; i < patternLength; i++)
1:2bc809f: 				pattern[i] = (byte)(i & 0xFF);
1:2bc809f: 
1:2bc809f:             byte[] cipherOutput1 = new byte[patternLength];
1:2bc809f:             byte[] cipherOutput2 = new byte[patternLength];
1:2bc809f: 
1:2bc809f:             int retval = 0;
1:2bc809f:             retval = enCipher.doFinal(pattern, 0, 24, cipherOutput1, 0);
1:2bc809f: 
1:2bc809f:             retval = deCipher.doFinal(cipherOutput1, 0, 24, cipherOutput2, 0);
1:2bc809f: 
1:2bc809f:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:2bc809f:                 System.out.println("PASSED TEST 1");
1:2bc809f:             else
1:2bc809f:                 System.out.println("FAILED TEST 1");
1:2bc809f: 
1:2bc809f:             retval = deCipher.doFinal(cipherOutput1, 0, 24, cipherOutput2, 0);
1:2bc809f: 
1:2bc809f:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:2bc809f:                 System.out.println("PASSED TEST 2");
1:2bc809f:             else
1:2bc809f:                 System.out.println("FAILED TEST 2");
1:2bc809f:         }
1:2bc809f:         catch (Throwable t)
1:2bc809f:         {
1:2bc809f:             System.out.println("got an exception");
1:2bc809f:             t.printStackTrace();
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         System.out.println("Finished testPCBC2");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     private void testIAIK()
1:2bc809f:     {
1:2bc809f:         System.out.println("Running testIAIK");
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             // set up the provider
1:2bc809f:             Class jceClass = Class.forName("iaik.security.provider.IAIK");
1:2bc809f:             java.security.Provider myProvider = (java.security.Provider) jceClass.newInstance();
1:2bc809f:             java.security.Security.addProvider(myProvider);
1:2bc809f: 
1:2bc809f:             // iaik.security.provider.IAIK.addAsProvider(true);
1:2bc809f: 
1:2bc809f:             // iaik.utils.Util.loadClass("iaik.security.provider.IAIK",true);
1:2bc809f:             // IAIK p=new IAIK();
1:2bc809f:             // iaik.security.provider.IAIK.getMd5();
1:2bc809f: 
1:2bc809f: 		    byte[] userkey = "a secret".getBytes();
1:2bc809f:             System.out.println("userkey length is " + userkey.length);
1:2bc809f:             Key secretKey = (Key) (new SecretKeySpec(userkey, "DES"));
1:2bc809f: 		    byte[] IV = "anivspec".getBytes();
1:2bc809f: 
1:2bc809f:             Cipher enCipher = Cipher.getInstance("DES/CBC/NoPadding","IAIK");
1:2bc809f:             Cipher deCipher = Cipher.getInstance("DES/CBC/NoPadding","IAIK");
1:2bc809f: 			IvParameterSpec ivspec = new IvParameterSpec(IV);
1:2bc809f: 
1:2bc809f:             enCipher.init(Cipher.ENCRYPT_MODE,secretKey,ivspec);
1:2bc809f:             deCipher.init(Cipher.DECRYPT_MODE,secretKey,ivspec);
1:2bc809f: 
1:2bc809f:             int patternLength = 8;
1:2bc809f:             byte[] pattern = new byte[patternLength];
1:2bc809f: 			for (int i = 0; i < patternLength; i++)
1:2bc809f: 				pattern[i] = (byte)(i & 0xFF);
1:2bc809f: 
1:2bc809f:             byte[] cipherOutput1 = new byte[patternLength];
1:2bc809f:             byte[] cipherOutput2 = new byte[patternLength];
1:2bc809f: 
1:2bc809f:             int retval = 0;
1:2bc809f:             retval = enCipher.doFinal(pattern, 0, 8, cipherOutput1, 0);
1:2bc809f: 
1:2bc809f:             retval = deCipher.doFinal(cipherOutput1, 0, 8, cipherOutput2, 0);
1:2bc809f: 
1:2bc809f:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:2bc809f:                 System.out.println("PASSED TEST 1");
1:2bc809f:             else
1:2bc809f:                 System.out.println("FAILED TEST 1");
1:2bc809f: 
1:2bc809f:             retval = deCipher.doFinal(cipherOutput1, 0, 8, cipherOutput2, 0);
1:2bc809f: 
1:2bc809f:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:2bc809f:                 System.out.println("PASSED TEST 2");
1:2bc809f:             else
1:2bc809f:                 System.out.println("FAILED TEST 2");
1:2bc809f:         }
1:2bc809f:         catch (Throwable t)
1:2bc809f:         {
1:2bc809f:             System.out.println("got an exception");
1:2bc809f:             t.printStackTrace();
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         System.out.println("Finished testIAIK");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     private void printByteArray(String name, byte[] array)
1:2bc809f:     {
1:2bc809f:         System.out.println("printing array " + name);
1:2bc809f:         for (int i = 0; i < array.length; i++)
1:2bc809f:             System.out.println("index " + i + " : " + array[i]);
1:2bc809f:     }
1:2bc809f:     */
1:2bc809f: 	
1:56c1dc2: 	/**
1:9ce0e0f: 	 * Delete a file in a Privileged block as these tests are
1:9ce0e0f: 	 * run under the embedded engine code.
1:2bc809f: 	 */
1:9ce0e0f: 	private void deleteFile(final File f)
1:2bc809f: 	{
1:3f5c48a:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:3f5c48a:             public Void run()  {
1:9ce0e0f: 		    	if (f.exists())
1:9ce0e0f: 		    	    f.delete();
1:9ce0e0f: 		    	return null;
1:2bc809f: 		    }
1:9ce0e0f: 	    });
1:9ce0e0f: 	}
1:2bc809f:     
1:9ce0e0f:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object  startSystemModule( final String factoryInterface )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.startSystemModule( factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
2:9ce0e0f: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1:             startSystemModule(org.apache.derby.iapi.reference.Module.CipherFactoryBuilder);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object  startSystemModule( final String factoryInterface )
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.startSystemModule( factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         AccessController.doPrivileged(new PrivilegedAction<String>() {
1:             public String run() {
/////////////////////////////////////////////////////////////////////////
1:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:             public Void run()  {
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:c38b841
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2bc809f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.crypto.T_Cipher
1: 
0:    Copyright 1998, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.crypto;
1: 
1: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1: 
1: import org.apache.derby.iapi.services.crypto.*;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.db.PropertyInfo;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import java.security.Key;
1: 
1: import java.io.File;
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: import java.io.FileInputStream;
0: import java.io.FileOutputStream;
1: import java.io.RandomAccessFile;
1: import java.io.IOException;
1: 
1: import java.util.Properties;
1: 
1: 
1: /*
1: // PT
1: import javax.crypto.Cipher;
1: import javax.crypto.spec.SecretKeySpec;
1: import java.security.spec.KeySpec;
1: import java.security.AlgorithmParameters;
1: // import java.security.spec.AlgorithmParameterSpec;
1: import javax.crypto.spec.IvParameterSpec;
1: import java.security.GeneralSecurityException;
1: import java.security.MessageDigest;
1: import java.lang.reflect.*;
1: */
1: 
1: 
1: /*
1: 	To run, put the following line in derby.properties
1: 	derby.module.test.T_Cipher=org.apache.derbyTesting.unitTests.crypto.T_Cipher
1: 
1: 	and run java org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 
1: */
1: public class T_Cipher extends T_Generic
1: {
1: 	private static final String testService = "CipherText";
1: 
1: 	CipherProvider enEngine;
1: 	CipherProvider deEngine;
1: 	Key secretKey;
1: 	byte[] IV;
1: 
1: 	CipherFactory factory;
1: 
1: 	public T_Cipher()
1: 	{
1: 		super();
1: 	}
1: 
1: 	/*
1: 	** Methods required by T_Generic
1: 	*/
1: 
1: 	public String getModuleToTestProtocolName() {
0: 		return org.apache.derby.iapi.reference.Module.CipherFactory;
1: 	}
1: 
1:     protected String getAlgorithm()
1:     {
1:         return "DES/CBC/NoPadding";
1:     }
1: 
1:     protected String getProvider()
1:     {
1: 	// allow for alternate providers
0: 	String testProvider = System.getProperty("testEncryptionProvider");
1: 	if (testProvider != null) 
1: 		return testProvider;
1: 	else
1: 		return null;	
1: 
1:     }
1: 
1: 	public void runTests() throws T_Fail {
1: 
1: 		File testFile = new File("extinout/T_Cipher.data");
0: 		if (testFile.exists())
0: 			testFile.delete();
1: 
1: 		String bootPassword = "a secret, don't tell anyone";
1: 
1: 		try
1: 		{
1: 							
0: 			//if external input output files dir does not exist ,create one
0: 			File ifdir = new File("extinout");
0: 			if(!ifdir.exists())
0: 				ifdir.mkdirs();
1: 
1: 			RandomAccessFile file = new RandomAccessFile(testFile, "rw");
1: 
1: 			setupCiphers(bootPassword);
1: 
1: 			// run thru some in patterns
1: 			int patternLength = 8192;
1: 			byte[] pattern = new byte[patternLength];
1: 			for (int i = 0; i < patternLength; i++)
1: 				pattern[i] = (byte)(i & 0xFF);
1: 
1: 			test(pattern, 0, 8, file);	// test short patterns
1: 			test(pattern, 8, 8, file);
1: 			test(pattern, 1, 16, file);
1: 
1: 			test(pattern, 0, patternLength, file); // test long pattern
1: 			test(pattern, 0, patternLength/2, file);
1: 			test(pattern, 1, patternLength/2, file);
1: 			test(pattern, 2, patternLength/2, file);
1: 			test(pattern, 3, patternLength/2, file);
1: 
1: 			file.seek(0);
1: 			check(pattern, 0, 8, file);	// file offset 0
1: 			check(pattern, 8, 8, file);	// file offset 8
1: 			check(pattern, 1, 16, file);	// file offset 16
1: 			check(pattern, 0, patternLength, file);	// file offset 32
1: 			check(pattern, 0, patternLength/2, file);// file offset 32+patternLength
1: 			check(pattern, 1, patternLength/2, file);// file offset 32+patternLength+(patternLength/2)
1: 			check(pattern, 2, patternLength/2, file);// file offset 32+(2*patternLength)
1: 			check(pattern, 3, patternLength/2, file);// file offset 32+(2*patternLength)+(patternLength/2);
1: 
1: 			REPORT("starting random test");
1: 
1: 			// now do some random testing from file
1: 			file.seek(32+patternLength);
1: 			check(pattern, 0, patternLength/2, file);
1: 
1: 			file.seek(32);
1: 			check(pattern, 0, patternLength, file);
1: 
1: 			file.seek(32+(2*patternLength));
1: 			check(pattern, 2, patternLength/2, file);
1: 
1: 			file.seek(0);
1: 			check(pattern, 0, 8, file);
1: 
1: 			file.seek(16);
1: 			check(pattern, 1, 16, file);
1: 
1: 			file.seek(32+(2*patternLength)+(patternLength/2));
1: 			check(pattern, 3, patternLength/2, file);
1: 
1: 			file.seek(8);
1: 			check(pattern, 8, 8, file);
1: 
1: 			file.seek(32+patternLength+(patternLength/2));
1: 			check(pattern, 1, patternLength/2, file);
1: 
1: 			file.close();
1: 
0: 			// test streaming
0: 			File streamFile = new File("extinout/T_CipherStream.data");
0: 			if (streamFile.exists())
0: 				streamFile.delete();
1: 
0: 			// RESOLVE: defectId 1834
0: 			if (false)
1: 			{
0: /*				OutputStream enOutputStream =
0: 					factory.createNewCipherOutputStream(
0: 						new FileOutputStream(streamFile), factory.ENCRYPT, secretKey, IV);
1: 
0: 				int encryptLength = patternLength; // make it a length that is
0: 												   // not on 8 bytes boundary
0: 				enOutputStream.write(pattern, 0, encryptLength);
0: 				enOutputStream.write(pattern, 0, 3); // write a couple of bytes of
0: 												 // garbage at the end
0: 				enOutputStream.close();
0: 				enOutputStream = null;
1: 
0: 				InputStream inStream = new FileInputStream(streamFile);
0: 				byte[] check = new byte[encryptLength + 100];
0: 				int r = inStream.read(check);
0: 				inStream.close();
0: 				REPORT("Stream of " + encryptLength + " is encrypted into " + r + " length");
0: 				if (byteArrayIdentical(check, pattern, 0, encryptLength))
0: 					throw T_Fail.testFailMsg("encryption stream did not encrypt");
1: 
0: 				InputStream deInputStream =
0: 					factory.createNewCipherInputStream(
0: 						new FileInputStream(streamFile), factory.DECRYPT, secretKey, IV);
1: 
0: 				int totalRead = 0;
0: 				while((r = deInputStream.read(check, totalRead, check.length-totalRead)) != -1)
0: 					totalRead += r;
1: 
0: 				if (totalRead != encryptLength)
0: 					throw T_Fail.testFailMsg("decrypted stream is " + totalRead + " is not the same length");
0: 				if (byteArrayIdentical(check, pattern, 0, encryptLength) == false)
0: 					throw T_Fail.testFailMsg("decryption stream did not decrypt");
0: 				deInputStream.close();
1: */
1: 			}
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			se.printStackTrace(System.out);
1: 			throw T_Fail.exceptionFail(se);
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			throw T_Fail.exceptionFail(ioe);
1: 		}
1: 
1: 
1: 		PASS("T_Cipher");
1: 	}
1: 
1: 
1: 	protected void setupCiphers(String bootPassword) throws T_Fail, StandardException
1: 	{
1:         // set properties for testing
1:         Properties props = new Properties();
1:         props.put("encryptionAlgorithm",getAlgorithm());
1:         String provider = getProvider();
1:         if (provider != null)
1:             props.put("encryptionProvider",getProvider());
1: 		props.put("bootPassword", bootPassword);
1: 
1:         REPORT("encryption algorithm used : " + getAlgorithm());
1:         REPORT("encryption provider used : " + provider);
1: 
0: 		factory = (CipherFactory)Monitor.bootServiceModule(true, (Object)null,
0:             org.apache.derby.iapi.reference.Module.CipherFactory, props);
1: 		if (factory == null)
1: 			throw T_Fail.testFailMsg("cannot find Cipher factory ");
1: 
1: 		enEngine = factory.createNewCipher(CipherFactory.ENCRYPT);
1: 		deEngine = factory.createNewCipher(CipherFactory.DECRYPT);
1: 
1: 		if (enEngine == null)
1: 			throw T_Fail.testFailMsg("cannot create encryption engine");
1: 		if (deEngine == null)
1: 			throw T_Fail.testFailMsg("cannot create decryption engine");
1: 	}
1: 
1: 	protected void test(byte[] cleartext, int offset, int length,
1: 					  RandomAccessFile outfile)
1: 		 throws T_Fail, StandardException, IOException
1: 	{
1: 		byte[] ciphertext = new byte[length];
1: 		System.arraycopy(cleartext, offset, ciphertext, 0, length);
1: 
1: 		if (enEngine.encrypt(ciphertext, 0, length, ciphertext, 0) != length)
1: 			throw T_Fail.testFailMsg("encrypted text length != length");
1: 
1: 		if (byteArrayIdentical(ciphertext, cleartext, offset, length))
1: 			throw T_Fail.testFailMsg("encryption just made a copy of the clear text");
1: 
1: 		outfile.write(ciphertext);
1: 
1: 		// now decrypt it and check
1: 		deEngine.decrypt(ciphertext, 0, length, ciphertext, 0);
1: 		if (byteArrayIdentical(ciphertext, cleartext, offset, length) == false)
1: 			throw T_Fail.testFailMsg("decryption did not yield the same clear text");
1: 	}
1: 
1: 	protected void check(byte[] cleartext, int offset, int length,
1: 					   RandomAccessFile infile)
1: 		 throws IOException, T_Fail, StandardException
1: 	{
1: 		byte[] ciphertext = new byte[length];
1: 		infile.read(ciphertext);
1: 
1: 		if (deEngine.decrypt(ciphertext, 0, length, ciphertext, 0) != length)
1: 			throw T_Fail.testFailMsg("decrypted text length != length");
1: 
1: 		if (byteArrayIdentical(ciphertext, cleartext, offset, length) == false)
1: 			throw T_Fail.testFailMsg("decryption did not yield the same clear text");
1: 
1: 	}
1: 
1: 	// see if 2 byte arrays are identical
1: 	protected boolean byteArrayIdentical(byte[] compare, byte[] original,
1: 									  int offset, int length)
1: 	{
1: 		for (int i = 0; i < length; i++)
1: 		{
1: 			if (compare[i] != original[offset+i])
1: 				return false;
1: 		}
1: 		return true;
1: 	}
1: 
1: 
1:     /*
1:     private void testBlowfish()
1:     {
1:         System.out.println("Running testBlowfish");
1:         try
1:         {
1:             // set up the provider
1:             java.security.Provider sunJce = new com.sun.crypto.provider.SunJCE();
1:             java.security.Security.addProvider(sunJce);
1: 
1:             // String key = "Paula bla la da trish123 sdkfs;ldkg;sa'jlskjgklad";
1:             String key = "Paulabla123456789012345";
1:             byte[] buf = key.getBytes();
1:             System.out.println("key length is " + buf.length);
1:             SecretKeySpec sKeySpec = new SecretKeySpec(buf,"Blowfish");
1:             // SecretKeySpec sKeySpec = new SecretKeySpec(buf,"DESede");
1: 
1:             Cipher cipher = Cipher.getInstance("Blowfish/CBC/NoPadding");
1:             // Cipher cipher = Cipher.getInstance("DESede/CBC/NoPadding");
1:             // Cipher cipher = Cipher.getInstance("Blowfish/CBC/PKCS5Padding");
1:             cipher.init(Cipher.ENCRYPT_MODE,sKeySpec);
1:             // only works with NoPadding if size is a multiple of 8 bytes
1:             // with PKCS5Padding, works for all sizes
1:             byte[] original = "This is what should get encrypte".getBytes();
1:             System.out.println("original length is " + original.length);
1:             byte[] encrypted = cipher.doFinal(original);
1:             // works
1:             // AlgorithmParameters algParam = cipher.getParameters();
1:             byte[] iv = cipher.getIV();
1:             System.out.println("length of iv is " + iv.length);
1: 
1:             Cipher cipher2 = Cipher.getInstance("Blowfish/CBC/NoPadding");
1:             // Cipher cipher2 = Cipher.getInstance("DESede/CBC/NoPadding");
1:             // Cipher cipher2 = Cipher.getInstance("Blowfish/CBC/PKCS5Padding");
1: 
1:             // works
1:             // cipher2.init(Cipher.DECRYPT_MODE,sKeySpec,algParam);
1:             IvParameterSpec ivClass = new IvParameterSpec(iv);
1:             cipher2.init(Cipher.DECRYPT_MODE,sKeySpec,ivClass);
1:             byte[] decrypted = cipher2.doFinal(encrypted);
1: 
1:             if (byteArrayIdentical(original,decrypted,0,original.length))
1:                 System.out.println("PASSED");
1:             else
1:                 System.out.println("FAILED");
1: 
1:             System.out.println("original length is " + original.length);
1:             System.out.println("encrypted length is " + encrypted.length);
1:             System.out.println("decrypted length is " + decrypted.length);
1:         }
1:         catch (Throwable t)
1:         {
1:             System.out.println("got an exception");
1:             t.printStackTrace();
1:         }
1: 
1:         System.out.println("Finished testBlowfish");
1:     }
1: 
1: 
1:     private void testCryptix()
1:     {
1:         System.out.println("Running testCryptix");
1:         try
1:         {
1:             // set up the provider
1:             Class jceClass = Class.forName("cryptix.jce.provider.Cryptix");
1:             java.security.Provider cryptixProvider = (java.security.Provider) jceClass.newInstance();
1:             java.security.Security.addProvider(cryptixProvider);
1: 
1: 		    byte[] userkey = "a secret".getBytes();
1:             System.out.println("userkey length is " + userkey.length);
1:             Key secretKey = (Key) (new SecretKeySpec(userkey, "DES"));
1: 		    byte[] IV = "anivspec".getBytes();
1: 
1:             Cipher enCipher = Cipher.getInstance("DES/CBC/NoPadding","Cryptix");
1:             Cipher deCipher = Cipher.getInstance("DES/CBC/NoPadding","Cryptix");
1: 			IvParameterSpec ivspec = new IvParameterSpec(IV);
1: 
1:             enCipher.init(Cipher.ENCRYPT_MODE,secretKey,ivspec);
1:             deCipher.init(Cipher.DECRYPT_MODE,secretKey,ivspec);
1: 
1:             int patternLength = 8;
1:             byte[] pattern = new byte[patternLength];
1: 			for (int i = 0; i < patternLength; i++)
1: 				pattern[i] = (byte)(i & 0xFF);
1: 
1:             byte[] cipherOutput1 = new byte[patternLength];
1:             byte[] cipherOutput2 = new byte[patternLength];
1: 
1:             int retval = 0;
1:             retval = enCipher.doFinal(pattern, 0, 8, cipherOutput1, 0);
1: 
1:             retval = deCipher.doFinal(cipherOutput1, 0, 8, cipherOutput2, 0);
1: 
1:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:                 System.out.println("PASSED TEST 1");
1:             else
1:                 System.out.println("FAILED TEST 1");
1: 
1:             retval = deCipher.doFinal(cipherOutput1, 0, 8, cipherOutput2, 0);
1: 
1:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:                 System.out.println("PASSED TEST 2");
1:             else
1:                 System.out.println("FAILED TEST 2");
1:         }
1:         catch (Throwable t)
1:         {
1:             System.out.println("got an exception");
1:             t.printStackTrace();
1:         }
1: 
1:         System.out.println("Finished testCryptix");
1:     }
1: 
1: 
1: 
1:     private void testMessageDigest()
1:     {
1:         // No provider needs to be installed for this to work.
1:         try
1:         {
1:             MessageDigest md = MessageDigest.getInstance("MD5");
1:             byte[] data = "Paulas digest".getBytes();
1:             byte[] digest = md.digest(data);
1:             byte[] digest2 = md.digest(data);
1:             if (byteArrayIdentical(digest,digest2,0,digest.length))
1:                 System.out.println("PASSED");
1:             else
1:                 System.out.println("FAILED");
1: 
1:             System.out.println("data length is " + data.length);
1:             System.out.println("digest length is " + digest.length);
1:             System.out.println("digest2 length is " + digest2.length);
1:         }
1:         catch (Throwable t)
1:         {
1:             System.out.println("got an exception");
1:             t.printStackTrace();
1:         }
1: 
1:         System.out.println("Finished testBlowfish");
1:     }
1: 
1:     // PT
1:     private void testPCBC()
1:     {
1:         System.out.println("Running testPCBC");
1:         try
1:         {
1:             // set up the provider
1:             Class jceClass = Class.forName("com.sun.crypto.provider.SunJCE");
1:             java.security.Provider myProvider = (java.security.Provider) jceClass.newInstance();
1:             java.security.Security.addProvider(myProvider);
1:             // java.security.Provider sunJce = new com.sun.crypto.provider.SunJCE();
1:             // java.security.Security.addProvider(sunJce);
1: 
1:             // String key = "Paula bla la da trish123 sdkfs;ldkg;sa'jlskjgklad";
1:             String key = "PaulablaPaulablaPaulabla";
1:             byte[] buf = key.getBytes();
1:             System.out.println("key length is " + buf.length);
1:             SecretKeySpec sKeySpec = new SecretKeySpec(buf,"DESede");
1: 
1:             Cipher cipher = Cipher.getInstance("DESede/PCBC/NoPadding");
1:             // Cipher cipher = Cipher.getInstance("DESede/CBC/NoPadding");
1:             // Cipher cipher = Cipher.getInstance("Blowfish/CBC/PKCS5Padding");
1:             cipher.init(Cipher.ENCRYPT_MODE,sKeySpec);
1:             // only works with NoPadding if size is a multiple of 8 bytes
1:             // with PKCS5Padding, works for all sizes
1:             byte[] original = "This is what should get encrypte".getBytes();
1:             System.out.println("original length is " + original.length);
1:             byte[] encrypted = cipher.doFinal(original);
1:             // works
1:             // AlgorithmParameters algParam = cipher.getParameters();
1:             byte[] iv = cipher.getIV();
1:             System.out.println("length of iv is " + iv.length);
1: 
1:             Cipher cipher2 = Cipher.getInstance("DESede/PCBC/NoPadding");
1:             // Cipher cipher2 = Cipher.getInstance("DESede/CBC/NoPadding");
1:             // Cipher cipher2 = Cipher.getInstance("Blowfish/CBC/PKCS5Padding");
1: 
1:             // works
1:             // cipher2.init(Cipher.DECRYPT_MODE,sKeySpec,algParam);
1:             IvParameterSpec ivClass = new IvParameterSpec(iv);
1:             cipher2.init(Cipher.DECRYPT_MODE,sKeySpec,ivClass);
1:             byte[] decrypted = cipher2.doFinal(encrypted);
1: 
1:             if (byteArrayIdentical(original,decrypted,0,original.length))
1:                 System.out.println("PASSED");
1:             else
1:                 System.out.println("FAILED");
1: 
1:             System.out.println("original length is " + original.length);
1:             System.out.println("encrypted length is " + encrypted.length);
1:             System.out.println("decrypted length is " + decrypted.length);
1:         }
1:         catch (Throwable t)
1:         {
1:             System.out.println("got an exception");
1:             t.printStackTrace();
1:         }
1: 
1:         System.out.println("Finished testPCBC");
1:     }
1: 
1: 
1:     private void testPCBC2()
1:     {
1:         System.out.println("Running testPCBC2");
1:         try
1:         {
1:             // set up the provider
1:             Class jceClass = Class.forName("com.sun.crypto.provider.SunJCE");
1:             java.security.Provider myProvider = (java.security.Provider) jceClass.newInstance();
1:             java.security.Security.addProvider(myProvider);
1: 
1: 		    byte[] userkey = "a secreta secreta secret".getBytes();
1:             System.out.println("userkey length is " + userkey.length);
1:             Key secretKey = (Key) (new SecretKeySpec(userkey, "DESede"));
1: 		    byte[] IV = "anivspec".getBytes();
1: 
1:             Cipher enCipher = Cipher.getInstance("DESede/PCBC/NoPadding","SunJCE");
1:             Cipher deCipher = Cipher.getInstance("DESede/PCBC/NoPadding","SunJCE");
1: 			IvParameterSpec ivspec = new IvParameterSpec(IV);
1: 
1:             enCipher.init(Cipher.ENCRYPT_MODE,secretKey,ivspec);
1:             deCipher.init(Cipher.DECRYPT_MODE,secretKey,ivspec);
1: 
1:             int patternLength = 24;
1:             byte[] pattern = new byte[patternLength];
1: 			for (int i = 0; i < patternLength; i++)
1: 				pattern[i] = (byte)(i & 0xFF);
1: 
1:             byte[] cipherOutput1 = new byte[patternLength];
1:             byte[] cipherOutput2 = new byte[patternLength];
1: 
1:             int retval = 0;
1:             retval = enCipher.doFinal(pattern, 0, 24, cipherOutput1, 0);
1: 
1:             retval = deCipher.doFinal(cipherOutput1, 0, 24, cipherOutput2, 0);
1: 
1:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:                 System.out.println("PASSED TEST 1");
1:             else
1:                 System.out.println("FAILED TEST 1");
1: 
1:             retval = deCipher.doFinal(cipherOutput1, 0, 24, cipherOutput2, 0);
1: 
1:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:                 System.out.println("PASSED TEST 2");
1:             else
1:                 System.out.println("FAILED TEST 2");
1:         }
1:         catch (Throwable t)
1:         {
1:             System.out.println("got an exception");
1:             t.printStackTrace();
1:         }
1: 
1:         System.out.println("Finished testPCBC2");
1:     }
1: 
1:     private void testIAIK()
1:     {
1:         System.out.println("Running testIAIK");
1:         try
1:         {
1:             // set up the provider
1:             Class jceClass = Class.forName("iaik.security.provider.IAIK");
1:             java.security.Provider myProvider = (java.security.Provider) jceClass.newInstance();
1:             java.security.Security.addProvider(myProvider);
1: 
1:             // iaik.security.provider.IAIK.addAsProvider(true);
1: 
1:             // iaik.utils.Util.loadClass("iaik.security.provider.IAIK",true);
1:             // IAIK p=new IAIK();
1:             // iaik.security.provider.IAIK.getMd5();
1: 
1: 		    byte[] userkey = "a secret".getBytes();
1:             System.out.println("userkey length is " + userkey.length);
1:             Key secretKey = (Key) (new SecretKeySpec(userkey, "DES"));
1: 		    byte[] IV = "anivspec".getBytes();
1: 
1:             Cipher enCipher = Cipher.getInstance("DES/CBC/NoPadding","IAIK");
1:             Cipher deCipher = Cipher.getInstance("DES/CBC/NoPadding","IAIK");
1: 			IvParameterSpec ivspec = new IvParameterSpec(IV);
1: 
1:             enCipher.init(Cipher.ENCRYPT_MODE,secretKey,ivspec);
1:             deCipher.init(Cipher.DECRYPT_MODE,secretKey,ivspec);
1: 
1:             int patternLength = 8;
1:             byte[] pattern = new byte[patternLength];
1: 			for (int i = 0; i < patternLength; i++)
1: 				pattern[i] = (byte)(i & 0xFF);
1: 
1:             byte[] cipherOutput1 = new byte[patternLength];
1:             byte[] cipherOutput2 = new byte[patternLength];
1: 
1:             int retval = 0;
1:             retval = enCipher.doFinal(pattern, 0, 8, cipherOutput1, 0);
1: 
1:             retval = deCipher.doFinal(cipherOutput1, 0, 8, cipherOutput2, 0);
1: 
1:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:                 System.out.println("PASSED TEST 1");
1:             else
1:                 System.out.println("FAILED TEST 1");
1: 
1:             retval = deCipher.doFinal(cipherOutput1, 0, 8, cipherOutput2, 0);
1: 
1:             if (byteArrayIdentical(cipherOutput2,pattern,0,patternLength))
1:                 System.out.println("PASSED TEST 2");
1:             else
1:                 System.out.println("FAILED TEST 2");
1:         }
1:         catch (Throwable t)
1:         {
1:             System.out.println("got an exception");
1:             t.printStackTrace();
1:         }
1: 
1:         System.out.println("Finished testIAIK");
1:     }
1: 
1:     private void printByteArray(String name, byte[] array)
1:     {
1:         System.out.println("printing array " + name);
1:         for (int i = 0; i < array.length; i++)
1:             System.out.println("index " + i + " : " + array[i]);
1:     }
1:     */
1: }
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:8a62d60
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
1: 		return org.apache.derby.iapi.reference.Module.CipherFactoryBuilder;
/////////////////////////////////////////////////////////////////////////
1:         CipherFactoryBuilder cb =  (CipherFactoryBuilder)
0:             Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CipherFactoryBuilder);
0: 
1:         factory = cb.createCipherFactory(true, props, false);
0: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ce0e0f
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
0: import java.security.PrivilegedExceptionAction;
0: import java.io.FileNotFoundException;
/////////////////////////////////////////////////////////////////////////
1: 	String testProvider = 
0: 		
0:     	(String) AccessController.doPrivileged(new PrivilegedAction() {
0: 		    public Object run()  {
1: 		    	return System.getProperty("testEncryptionProvider");
1: 		    }
1: 	    });
0: 	
/////////////////////////////////////////////////////////////////////////
1: 		deleteFile(testFile);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	
1: 	/**
1: 	 * Delete a file in a Privileged block as these tests are
1: 	 * run under the embedded engine code.
0: 	 */
1: 	private void deleteFile(final File f)
0: 	{
0: 	   	AccessController.doPrivileged(new PrivilegedAction() {
0: 		    public Object run()  {
1: 		    	if (f.exists())
1: 		    	    f.delete();
1: 		    	return null;
1: 		    }
1: 	    });
1: 	}
============================================================================