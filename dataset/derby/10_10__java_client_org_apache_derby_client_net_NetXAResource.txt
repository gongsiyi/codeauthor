1:70f7692: /*
91:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.net.NetXAResource
1:38083d6: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:70f7692: */
1:33776ff: /**********************************************************************
27:33776ff:  *
1:70f7692:  *
1:33776ff:  *  Component Name =
1:33776ff:  *
1:33776ff:  *      Package Name = org.apache.derby.client.net
1:33776ff:  *
1:33776ff:  *  Descriptive Name = class implements XAResource
1:33776ff:  *
1:33776ff:  *  Status = New code
1:33776ff:  *
1:33776ff:  *  Function = Handle XA methods
1:33776ff:  *
1:33776ff:  *  List of Classes
1:33776ff:  *              - NetXAResource
1:33776ff:  *
1:33776ff:  *  Restrictions : None
1:33776ff:  *
1:33776ff:  **********************************************************************/
1:33776ff: package org.apache.derby.client.net;
1:70f7692: 
1:33776ff: import java.net.InetAddress;
1:33776ff: import java.net.UnknownHostException;
1:70f7692: import javax.sql.XAConnection;
1:70f7692: import javax.transaction.xa.XAException;
1:70f7692: import javax.transaction.xa.XAResource;
1:70f7692: import javax.transaction.xa.Xid;
1:70f7692: 
1:70f7692: import org.apache.derby.client.ClientXid;
1:69e3d06: import org.apache.derby.client.am.ClientConnection;
1:70f7692: import org.apache.derby.client.am.SqlException;
1:b2a1747: import org.apache.derby.client.am.ClientMessageId;
1:b13b17c: import org.apache.derby.client.am.SqlCode;
1:b13b17c: import org.apache.derby.client.am.Utils;
1:b13b17c: import org.apache.derby.client.am.XaException;
1:b2a1747: import org.apache.derby.shared.common.reference.SQLState;
1:70f7692: 
1:70f7692: public class NetXAResource implements XAResource {
1:0326967:     private static final int INITIAL_CALLINFO_ELEMENTS = 1;
1:0326967:     static final ClientXid nullXid = new ClientXid();
1:70f7692: 
1:70f7692:     // xaFunction defines, shows which queued XA function is being performed
1:0326967:     static final int XAFUNC_COMMIT = 1;
1:0326967:     private static final int XAFUNC_END = 2;
1:0326967:     private static final int XAFUNC_FORGET = 3;
1:0326967:     private static final int XAFUNC_PREPARE = 4;
1:0326967:     private static final int XAFUNC_RECOVER = 5;
1:0326967:     static final int XAFUNC_ROLLBACK = 6;
1:0326967:     private static final int XAFUNC_START = 7;
1:70f7692: 
1:0326967:     private static final String XAFUNCSTR_NONE = "No XA Function";
1:0326967:     private static final String XAFUNCSTR_COMMIT = "XAResource.commit()";
1:0326967:     private static final String XAFUNCSTR_END = "XAResource.end()";
1:0326967:     private static final String XAFUNCSTR_FORGET = "XAResource.forget()";
1:0326967:     private static final String XAFUNCSTR_PREPARE = "XAResource.prepare()";
1:0326967:     private static final String XAFUNCSTR_RECOVER = "XAResource.recover()";
1:0326967:     private static final String XAFUNCSTR_ROLLBACK = "XAResource.rollback()";
1:0326967:     private static final String XAFUNCSTR_START = "XAResource.start()";
1:70f7692: 
1:0326967:     SqlException exceptionsOnXA = null;
1:0326967: 
1:b13b17c:     NetXAConnection netXAConn_;
1:b13b17c:     NetConnection conn_;
1:2f3d052:     private boolean keepIsolationLevel;
1:0326967: 
1:38083d6:     // TODO: change to a single callInfo field (not an array)
1:70f7692:     NetXACallInfo callInfoArray_[] =
1:70f7692:             new NetXACallInfo[INITIAL_CALLINFO_ELEMENTS];
1:70f7692: 
1:cccf5dd:     /** The value of the transaction timeout in seconds. */
1:cccf5dd:     private int timeoutSeconds = 0;
1:cccf5dd: 
1:0326967:     public NetXAResource(XAConnection xaconn,
1:b13b17c:                          NetXAConnection conn) {
1:dadd05a:         conn_ = conn.getNetConnection();
1:dadd05a:         netXAConn_ = conn;
1:70f7692:         conn.setNetXAResource(this);
1:70f7692: 
1:70f7692:         // link the primary connection to the first XACallInfo element
1:70f7692:         conn_.currXACallInfoOffset_ = 0;
1:70f7692: 
1:70f7692:         // construct the NetXACallInfo object for the array.
1:70f7692:         for (int i = 0; i < INITIAL_CALLINFO_ELEMENTS; ++i) {
1:0326967:             callInfoArray_[i] = new NetXACallInfo(null, XAResource.TMNOFLAGS,
1:70f7692:                     null);
1:70f7692:         }
1:70f7692: 
1:70f7692:         // initialize the first XACallInfo element with the information from the
1:70f7692:         //  primary connection
1:dadd05a:         callInfoArray_[0].actualConn_ = conn;
1:70f7692:         // ~~~ save conn_ connection variables in callInfoArray_[0]
1:70f7692:         callInfoArray_[0].saveConnectionVariables();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void commit(Xid xid, boolean onePhase) throws XAException {
1:70f7692:         NetAgent netAgent = conn_.netAgent_;
1:70f7692:         int rc = XAResource.XA_OK;
1:38083d6:         
1:70f7692:         exceptionsOnXA = null;
2:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceEntry(this, "commit", xid, onePhase);
1:70f7692:         }
1:88c25bb:         if (conn_.isPhysicalConnClosed()) {
1:70f7692:             connectionClosedFailure();
1:70f7692:         }
1:1a7cb26: 
1:70f7692:         // update the XACallInfo
2:70f7692:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:70f7692:         callInfo.xaFlags_ = (onePhase ? XAResource.TMONEPHASE :
1:70f7692:                 XAResource.TMNOFLAGS);
1:70f7692:         callInfo.xid_ = xid;
1:d5ba8a8:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:70f7692:         try {
1:70f7692:             netAgent.beginWriteChainOutsideUOW();
1:70f7692:             netAgent.netConnectionRequest_.writeXaCommit(conn_, xid);
1:70f7692:             netAgent.flowOutsideUOW();
1:70f7692:             netAgent.netConnectionReply_.readXaCommit(conn_);
1:d5ba8a8:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:70f7692:                 callInfo.xaFunction_ = XAFUNC_COMMIT;
1:70f7692:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
1:d5ba8a8:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
1:70f7692:             }
1:70f7692:             netAgent.endReadChain();
1:70f7692:         } catch (SqlException sqle) {
1:31ba8d0:             rc = getSqlExceptionXAErrorCode(sqle);
1:b13b17c:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
1:70f7692:         }
2:70f7692:         if (rc != XAResource.XA_OK) {
1:0326967:             throwXAException(rc);
1:38083d6:         }
1:38083d6:     }
1:cccf5dd: 
1:70f7692:     /**
1:31ba8d0:      * Get XAException.errorCode from SqlException
1:31ba8d0:      * For disconnect exception, return XAER_RMFAIL
1:31ba8d0:      * For other exceptions return XAER_RMERR
1:31ba8d0:      * 
1:31ba8d0:      * For server side SQLExceptions during 
1:31ba8d0:      * XA operations the errorCode has already been determined
1:31ba8d0:      * and wrapped in an XAException for return to the client.
1:31ba8d0:      * see EmbedXAResource.wrapInXAException
1:31ba8d0:      * 
1:31ba8d0:      * @param sqle  SqlException to evaluate.
1:31ba8d0:      * @return XAException.XAER_RMFAIL for disconnect exception,
1:31ba8d0:      *         XAException.XAER_RMERR for other exceptions.
1:31ba8d0:      */
1:31ba8d0:     private int getSqlExceptionXAErrorCode(SqlException sqle) {      
1:31ba8d0:        int seErrorCode = sqle.getErrorCode();
1:31ba8d0:        return (seErrorCode == 40000 ? XAException.XAER_RMFAIL : XAException.XAER_RMERR);
1:31ba8d0:     }
1:0326967: 
1:31ba8d0:     /**
1:70f7692:      * Ends the work performed on behalf of a transaction branch. The resource manager dissociates the XA resource from
1:70f7692:      * the transaction branch specified and let the transaction be completed.
1:70f7692:      * <p/>
1:70f7692:      * If TMSUSPEND is specified in flags, the transaction branch is temporarily suspended in incomplete state. The
1:70f7692:      * transaction context is in suspened state and must be resumed via start with TMRESUME specified.
1:70f7692:      * <p/>
1:70f7692:      * If TMFAIL is specified, the portion of work has failed. The resource manager may mark the transaction as
1:70f7692:      * rollback-only
1:70f7692:      * <p/>
1:70f7692:      * If TMSUCCESS is specified, the portion of work has completed successfully.
1:70f7692:      *
1:70f7692:      * @param xid   A global transaction identifier that is the same as what was used previously in the start method.
1:70f7692:      * @param flags One of TMSUCCESS, TMFAIL, or TMSUSPEND
1:70f7692:      *
1:70f7692:      * @throws XAException An error has occurred. Possible XAException values are XAER_RMERR, XAER_RMFAILED, XAER_NOTA,
1:70f7692:      *                     XAER_INVAL, XAER_PROTO, or XA_RB*.
1:70f7692:      */
1:0326967: 
1:70f7692:     public void end(Xid xid, int flags) throws XAException {
1:0326967: 
1:70f7692:         NetAgent netAgent = conn_.netAgent_;
1:70f7692:         int rc = XAResource.XA_OK;
1:70f7692:         exceptionsOnXA = null;
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceEntry(this, "end", xid, flags);
1:38083d6:         }
1:88c25bb:         if (conn_.isPhysicalConnClosed()) {
1:70f7692:             connectionClosedFailure();
1:70f7692:         }
1:0326967: 
1:70f7692:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:70f7692:         callInfo.xaFlags_ = flags;
1:70f7692:         callInfo.xid_ = xid;
1:d5ba8a8:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:70f7692:         try {
1:70f7692:             netAgent.beginWriteChainOutsideUOW();
1:70f7692:             netAgent.netConnectionRequest_.writeXaEndUnitOfWork(conn_);
1:70f7692:             netAgent.flowOutsideUOW();
1:70f7692:             rc = netAgent.netConnectionReply_.readXaEndUnitOfWork(conn_);
1:0326967: 
1:d5ba8a8:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:70f7692:                 callInfo.xaFunction_ = XAFUNC_END;
1:70f7692:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
1:d5ba8a8:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
1:70f7692:             }
1:70f7692:             netAgent.endReadChain();
1:70f7692:         } catch (SqlException sqle) {
1:31ba8d0:             rc = getSqlExceptionXAErrorCode(sqle);
1:b13b17c:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
1:70f7692:         }
1:0326967: 
1:70f7692:         if (rc != XAResource.XA_OK) {
1:57d7d13:             // The corresponding XA connection association state
1:57d7d13:             // is changed by setXaStateForXAException inside the call
1:57d7d13:             // to throwXAException according the error code of the XAException
1:57d7d13:             // to be thrown.
1:0326967:             throwXAException(rc);
1:88c25bb:         }else {
1:69e3d06:             conn_.setXAState(ClientConnection.XA_T0_NOT_ASSOCIATED);
1:70f7692:         } 
1:70f7692:     }
1:31ba8d0: 
1:70f7692:     /**
1:70f7692:      * Tell the resource manager to forget about a heuristically (MANUALLY) completed transaction branch.
1:70f7692:      *
1:70f7692:      * @param xid A global transaction identifier
1:70f7692:      *
1:70f7692:      * @throws XAException An error has occurred. Possible exception values are XAER_RMERR, XAER_RMFAIL, XAER_NOTA,
1:70f7692:      *                     XAER_INVAL, or XAER_PROTO.
1:70f7692:      */
1:88c25bb: 
1:70f7692:     public void forget(Xid xid) throws XAException {
1:70f7692:         NetAgent netAgent = conn_.netAgent_;
1:70f7692:         int rc = XAResource.XA_OK;
1:70f7692:         exceptionsOnXA = null;
1:70f7692: 
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceEntry(this, "forget", xid);
1:70f7692:         }
1:88c25bb:         if (conn_.isPhysicalConnClosed()) {
1:70f7692:             connectionClosedFailure();
1:70f7692:         }
1:70f7692:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:70f7692:         callInfo.xid_ = xid;
1:d5ba8a8:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:70f7692:         try {
1:70f7692:             // flow the required PROTOCOL to the server
1:70f7692:             netAgent.beginWriteChainOutsideUOW();
1:70f7692: 
1:70f7692:             // sent the commit PROTOCOL
1:70f7692:             netAgent.netConnectionRequest_.writeXaForget(netAgent.netConnection_, xid);
1:70f7692: 
1:70f7692:             netAgent.flowOutsideUOW();
1:70f7692: 
1:70f7692:             // read the reply to the commit
1:70f7692:             netAgent.netConnectionReply_.readXaForget(netAgent.netConnection_);
1:70f7692: 
1:70f7692:             netAgent.endReadChain();
1:d5ba8a8:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:70f7692:                 callInfo.xaFunction_ = XAFUNC_FORGET;
1:70f7692:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
1:d5ba8a8:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
1:70f7692:             }
1:70f7692:         } catch (SqlException sqle) {
1:b13b17c:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
1:31ba8d0:             throwXAException(getSqlExceptionXAErrorCode(sqle));
1:70f7692:         }
1:0326967: 
1:70f7692:         if (rc != XAResource.XA_OK) {
1:0326967:             throwXAException(rc);
1:70f7692:         }
1:70f7692: 
1:70f7692:     }
1:70f7692: 
1:70f7692:     /**
1:cccf5dd:      * Obtain the current transaction timeout value set for this XAResource
1:cccf5dd:      * instance. If XAResource.setTransactionTimeout was not use prior to
1:cccf5dd:      * invoking this method, the return value is 0; otherwise, the value
1:cccf5dd:      * used in the previous setTransactionTimeout call is returned.
1:70f7692:      *
1:cccf5dd:      * @return the transaction timeout value in seconds. If the returned value
1:cccf5dd:      * is equal to Integer.MAX_VALUE it means no timeout.
1:70f7692:      */
1:70f7692:     public int getTransactionTimeout() throws XAException {
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceEntry(this, "getTransactionTimeout");
1:70f7692:         }
1:70f7692:         exceptionsOnXA = null;
1:88c25bb:         if (conn_.isPhysicalConnClosed()) {
1:70f7692:             connectionClosedFailure();
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:cccf5dd:             conn_.agent_.logWriter_.traceExit(this, "getTransactionTimeout", timeoutSeconds);
1:70f7692:         }
1:cccf5dd:         return timeoutSeconds;
1:70f7692:     }
1:70f7692: 
1:70f7692:     /**
1:70f7692:      * Ask the resource manager to prepare for a transaction commit of the transaction specified in xid.
1:70f7692:      *
1:70f7692:      * @param xid A global transaction identifier
1:70f7692:      *
1:70f7692:      * @return A value indicating the resource manager's vote on the outcome of the transaction. The possible values
1:70f7692:      *         are: XA_RDONLY or XA_OK. If the resource manager wants to roll back the transaction, it should do so by
1:70f7692:      *         raising an appropriate XAException in the prepare method.
1:70f7692:      *
1:70f7692:      * @throws XAException An error has occurred. Possible exception values are: XA_RB*, XAER_RMERR, XAER_RMFAIL,
1:70f7692:      *                     XAER_NOTA, XAER_INVAL, or XAER_PROTO.
1:70f7692:      */
1:70f7692:     public int prepare(Xid xid) throws XAException { // public interface for prepare
1:70f7692:         // just call prepareX with the recursion flag set to true
1:70f7692:         exceptionsOnXA = null;
1:70f7692: 
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceEntry(this, "prepare", xid);
1:70f7692:         }
1:88c25bb:         if (conn_.isPhysicalConnClosed()) {
1:70f7692:             connectionClosedFailure();
1:70f7692:         }
1:70f7692: 
1:70f7692:         /// update the XACallInfo
1:70f7692:         NetAgent netAgent = conn_.netAgent_;
1:70f7692:         int rc = XAResource.XA_OK;
1:70f7692:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:70f7692:         callInfo.xid_ = xid;
1:d5ba8a8:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:70f7692:         try {
1:70f7692:             netAgent.beginWriteChainOutsideUOW();
1:70f7692:             // sent the prepare PROTOCOL
1:70f7692:             netAgent.netConnectionRequest_.writeXaPrepare(conn_);
1:70f7692:             netAgent.flowOutsideUOW();
1:70f7692: 
1:70f7692:             // read the reply to the prepare
1:70f7692:             rc = netAgent.netConnectionReply_.readXaPrepare(conn_);
1:d5ba8a8:             if ((callInfo.xaRetVal_ != XAResource.XA_OK) &&
1:d5ba8a8:                     (callInfo.xaRetVal_ != XAException.XA_RDONLY)) { // xaRetVal has possible error, format it
1:70f7692:                 callInfo.xaFunction_ = XAFUNC_PREPARE;
1:70f7692:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
1:d5ba8a8:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
1:70f7692:             }
1:70f7692: 
1:70f7692:             netAgent.endReadChain();
1:70f7692:         } catch (SqlException sqle) {
1:31ba8d0:             rc = getSqlExceptionXAErrorCode(sqle);
1:b13b17c:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
1:70f7692:         }
1:70f7692: 
1:344b9ef:         if ((rc != XAResource.XA_OK ) && (rc != XAResource.XA_RDONLY)) {
1:0326967:             throwXAException(rc);
1:70f7692:         }
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceExit(this, "prepare", rc);
1:70f7692:         }
1:70f7692:         return rc;
1:70f7692:     }
1:70f7692: 
1:70f7692:     /**
1:70f7692:      * Obtain a list of prepared transaction branches from a resource manager. The transaction manager calls this method
1:70f7692:      * during recovery to obtain the list of transaction branches that are currently in prepared or heuristically
1:70f7692:      * completed states.
1:70f7692:      *
1:70f7692:      * @param flag One of TMSTARTRSCAN, TMENDRSCAN, TMNOFLAGS. TMNOFLAGS must be used when no other flags are set in
1:70f7692:      *             flags.
1:70f7692:      *
1:70f7692:      * @return The resource manager returns zero or more XIDs for the transaction branches that are currently in a
1:70f7692:      *         prepared or heuristically completed state. If an error occurs during the operation, the resource manager
1:70f7692:      *         should raise the appropriate XAException.
1:70f7692:      *
1:70f7692:      * @throws XAException An error has occurred. Possible values are XAER_RMERR, XAER_RMFAIL, XAER_INVAL, and
1:70f7692:      *                     XAER_PROTO.
1:70f7692:      */
1:70f7692:     public Xid[] recover(int flag) throws XAException {
1:70f7692:         int rc = XAResource.XA_OK;
1:70f7692:         NetAgent netAgent = conn_.netAgent_;
1:70f7692: 
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceEntry(this, "recover", flag);
1:70f7692:         }
1:70f7692:         exceptionsOnXA = null;
1:88c25bb:         if (conn_.isPhysicalConnClosed()) {
1:70f7692:             connectionClosedFailure();
1:70f7692:         }
1:70f7692: 
1:70f7692:         Xid[] xidList = null;
1:70f7692: 
1:70f7692:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:70f7692:         callInfo.xaFlags_ = flag;
1:d5ba8a8:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:70f7692:         try {
1:70f7692:             netAgent.beginWriteChainOutsideUOW();
1:70f7692:             // sent the recover PROTOCOL
1:70f7692:             netAgent.netConnectionRequest_.writeXaRecover(conn_, flag);
1:70f7692:             netAgent.flowOutsideUOW();
1:70f7692:             netAgent.netConnectionReply_.readXaRecover(conn_);
1:d5ba8a8:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:70f7692:                 callInfo.xaFunction_ = XAFUNC_RECOVER;
1:70f7692:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
1:d5ba8a8:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
1:70f7692:             }
1:70f7692:             netAgent.endReadChain();
1:43fb59e:             xidList = conn_.getIndoubtTransactionIds();
1:43fb59e: 
1:70f7692:         } catch (SqlException sqle) {
1:31ba8d0:             rc = getSqlExceptionXAErrorCode(sqle);
1:b13b17c:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (rc != XAResource.XA_OK) {
1:0326967:             throwXAException(rc);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceExit(this, "recover", xidList);
1:70f7692:         }
1:70f7692:         return xidList;
1:70f7692:     }
1:70f7692: 
1:70f7692:     /**
1:70f7692:      * Inform the resource manager to roll back work done on behalf of a transaction branch
1:70f7692:      *
1:70f7692:      * @param xid A global transaction identifier
1:70f7692:      *
1:70f7692:      * @throws XAException An error has occurred
1:70f7692:      */
1:70f7692:     public void rollback(Xid xid) throws XAException {
1:70f7692:         NetAgent netAgent = conn_.netAgent_;
1:70f7692:         int rc = XAResource.XA_OK;
1:70f7692:         exceptionsOnXA = null;
1:70f7692: 
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceEntry(this, "rollback", xid);
1:70f7692:         }
1:88c25bb:         if (conn_.isPhysicalConnClosed()) {
1:70f7692:             connectionClosedFailure();
1:70f7692:         }
1:70f7692: 
1:70f7692:         // update the XACallInfo
1:70f7692:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:70f7692:         callInfo.xid_ = xid;
1:d5ba8a8:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:70f7692:         try {
1:70f7692:             netAgent.beginWriteChainOutsideUOW();
1:70f7692:             netAgent.netConnectionRequest_.writeXaRollback(conn_, xid);
1:70f7692:             netAgent.flowOutsideUOW();
1:70f7692:             // read the reply to the rollback
1:70f7692:             rc = netAgent.netConnectionReply_.readXaRollback(conn_);
1:70f7692:             netAgent.endReadChain();
1:d5ba8a8:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:70f7692:                 callInfo.xaFunction_ = XAFUNC_END;
1:70f7692:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
1:d5ba8a8:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
1:70f7692:             }
1:70f7692:         } catch (SqlException sqle) {
1:31ba8d0:             rc = getSqlExceptionXAErrorCode(sqle);
1:b13b17c:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (rc != XAResource.XA_OK) {
1:0326967:             throwXAException(rc);
1:70f7692:         }
1:70f7692:  
1:70f7692:     }
1:70f7692: 
1:70f7692:     /**
1:cccf5dd:      * Set the current transaction timeout value for this XAResource
1:cccf5dd:      * instance. Once set, this timeout value is effective until
1:cccf5dd:      * setTransactionTimeout is invoked again with a different value. To reset
1:cccf5dd:      * the timeout value to the default value used by the resource manager,
1:cccf5dd:      * set the value to zero. If the timeout operation is performed
1:cccf5dd:      * successfully, the method returns true; otherwise false. If a resource
1:cccf5dd:      * manager does not support transaction timeout value to be set
1:cccf5dd:      * explicitly, this method returns false.
1:70f7692:      *
1:6b50965:      * @param seconds the transaction timeout value in seconds.
1:cccf5dd:      *                Value of 0 means the reasource manager's default value.
1:cccf5dd:      *                Value of Integer.MAX_VALUE means no timeout.
1:cccf5dd:      * @return true if transaction timeout value is set successfully;
1:cccf5dd:      * otherwise false.
1:70f7692:      *
1:cccf5dd:      * @exception XAException - An error has occurred. Possible exception
1:cccf5dd:      * values are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.
1:70f7692:      */
1:70f7692:     public boolean setTransactionTimeout(int seconds) throws XAException {
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:cccf5dd:             conn_.agent_.logWriter_.traceEntry(this, "setTransactionTimeout");
1:cccf5dd:         }
1:cccf5dd:         if (seconds < 0) {
1:cccf5dd:             // throw an exception if invalid value was specified
1:cccf5dd:             throw new XAException(XAException.XAER_INVAL);
1:70f7692:         }
1:70f7692:         exceptionsOnXA = null;
1:cccf5dd:         timeoutSeconds = seconds;
1:cccf5dd:         if (conn_.agent_.loggingEnabled()) {
1:cccf5dd:             conn_.agent_.logWriter_.traceExit(this, "setTransactionTimeout", true);
1:cccf5dd:         }
1:cccf5dd:         return true;
1:70f7692:     }
1:70f7692: 
1:2f3d052:     public void setKeepCurrentIsolationLevel(boolean flag) {
1:2f3d052:         keepIsolationLevel = flag;
1:2f3d052:     }
1:2f3d052: 
1:2f3d052:     public boolean keepCurrentIsolationLevel() {
1:2f3d052:         return keepIsolationLevel;
1:2f3d052:     }
1:2f3d052: 
1:70f7692:     /**
1:70f7692:      * Start work on behalf of a transaction branch specified in xid
1:70f7692:      *
1:70f7692:      * @param xid   A global transaction identifier to be associated with the resource
1:70f7692:      * @param flags One of TMNOFLAGS, TMJOIN, or TMRESUME
1:70f7692:      *
1:70f7692:      * @throws XAException An error has occurred. Possible exceptions   * are XA_RB*, XAER_RMERR, XAER_RMFAIL,
1:70f7692:      *                     XAER_DUPID, XAER_OUTSIDE, XAER_NOTA, XAER_INVAL, or XAER_PROTO.
1:70f7692:      */
1:70f7692:     public synchronized void start(Xid xid, int flags) throws XAException {
1:70f7692: 
1:70f7692:         NetAgent netAgent = conn_.netAgent_;
1:70f7692:         int rc = XAResource.XA_OK;
1:70f7692:         exceptionsOnXA = null;
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceEntry(this, "start", xid, flags);
1:70f7692:         }
1:88c25bb:         if (conn_.isPhysicalConnClosed()) {
1:70f7692:             connectionClosedFailure();
1:70f7692:         }
1:70f7692:         
1:1a7cb26:         // DERBY-1025 - Flow an auto-commit if in auto-commit mode before 
1:1a7cb26:         // entering a global transaction
1:1a7cb26:         try {
1:6eb29f6:             if(conn_.autoCommit_)
1:6eb29f6:                 conn_.flowAutoCommit();
1:1a7cb26:         } catch (SqlException sqle) {
1:6eb29f6:             rc = getSqlExceptionXAErrorCode(sqle);
1:b13b17c:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
1:1a7cb26:         } 
1:70f7692: 
1:70f7692:         // update the XACallInfo
1:70f7692:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:70f7692:         callInfo.xaFlags_ = flags;
1:70f7692:         callInfo.xid_ = xid;
1:d5ba8a8:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:70f7692: 
1:cccf5dd:         // check and setup the transaction timeout settings
1:cccf5dd:         if (flags == TMNOFLAGS) {
1:cccf5dd:             if (timeoutSeconds == Integer.MAX_VALUE) {
1:cccf5dd:                 // Disable the transaction timeout.
1:cccf5dd:                 callInfo.xaTimeoutMillis_ = 0;
1:cccf5dd:             } else if (timeoutSeconds > 0) {
1:cccf5dd:                 // Use the timeout value specified.
1:cccf5dd:                 callInfo.xaTimeoutMillis_ = 1000*timeoutSeconds;
1:cccf5dd:             } else if (timeoutSeconds == 0) {
1:cccf5dd:                 // The -1 value means that the timeout codepoint
1:cccf5dd:                 // will not be sent in the request and thus the server
1:cccf5dd:                 // will use the default value.
1:cccf5dd:                 callInfo.xaTimeoutMillis_ = -1;
1:cccf5dd:             } else {
1:cccf5dd:                 // This should not ever happen due that setTransactionTimeout
1:cccf5dd:                 // does not allow a negative value
1:cccf5dd:                 throwXAException(XAException.XAER_RMERR);
1:cccf5dd:             }
1:cccf5dd:         }
1:70f7692:         try {
1:70f7692:             netAgent.beginWriteChainOutsideUOW();
1:70f7692:             netAgent.netConnectionRequest_.writeXaStartUnitOfWork(conn_);
1:70f7692:             netAgent.flowOutsideUOW();
1:70f7692:             netAgent.netConnectionReply_.readXaStartUnitOfWork(conn_);
1:d5ba8a8:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:70f7692:                 callInfo.xaFunction_ = XAFUNC_START;
1:70f7692:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
1:d5ba8a8:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
1:70f7692:             }
1:70f7692:             // Setting this is currently required to avoid client from sending
1:70f7692:             // commit for autocommit.
1:d5ba8a8:             if (rc == XAResource.XA_OK) {
1:69e3d06:                 conn_.setXAState(ClientConnection.XA_T1_ASSOCIATED);
1:70f7692:             }
1:70f7692: 
1:70f7692:         } catch (SqlException sqle) {
1:31ba8d0:             rc = getSqlExceptionXAErrorCode(sqle);
1:b13b17c:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (rc != XAResource.XA_OK) {
1:0326967:             throwXAException(rc);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private String getXAExceptionText(int rc) {
2:70f7692:         String xaExceptionText;
1:70f7692:         switch (rc) {
1:69e3d06:         case XAException.XA_RBROLLBACK:
1:70f7692:             xaExceptionText = "XA_RBROLLBACK";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_RBCOMMFAIL:
1:70f7692:             xaExceptionText = "XA_RBCOMMFAIL";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_RBDEADLOCK:
1:70f7692:             xaExceptionText = "XA_RBDEADLOCK";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_RBINTEGRITY:
1:70f7692:             xaExceptionText = "XA_RBINTEGRITY";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_RBOTHER:
1:70f7692:             xaExceptionText = "XA_RBOTHER";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_RBPROTO:
1:70f7692:             xaExceptionText = "XA_RBPROTO";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_RBTIMEOUT:
1:70f7692:             xaExceptionText = "XA_RBTIMEOUT";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_RBTRANSIENT:
1:70f7692:             xaExceptionText = "XA_RBTRANSIENT";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_NOMIGRATE:
1:70f7692:             xaExceptionText = "XA_NOMIGRATE";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_HEURHAZ:
1:70f7692:             xaExceptionText = "XA_HEURHAZ";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_HEURCOM:
1:70f7692:             xaExceptionText = "XA_HEURCOM";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_HEURRB:
1:70f7692:             xaExceptionText = "XA_HEURRB";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_HEURMIX:
1:70f7692:             xaExceptionText = "XA_HEURMIX";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_RETRY:
1:70f7692:             xaExceptionText = "XA_RETRY";
1:70f7692:             break;
1:69e3d06:         case XAException.XA_RDONLY:
1:70f7692:             xaExceptionText = "XA_RDONLY";
1:70f7692:             break;
1:69e3d06:         case XAException.XAER_ASYNC:
1:70f7692:             xaExceptionText = "XAER_ASYNC";
1:70f7692:             break;
1:69e3d06:         case XAException.XAER_RMERR:
1:70f7692:             xaExceptionText = "XAER_RMERR";
1:70f7692:             break;
1:69e3d06:         case XAException.XAER_NOTA:
1:70f7692:             xaExceptionText = "XAER_NOTA";
1:70f7692:             break;
1:69e3d06:         case XAException.XAER_INVAL:
1:70f7692:             xaExceptionText = "XAER_INVAL";
1:70f7692:             break;
1:69e3d06:         case XAException.XAER_PROTO:
1:70f7692:             xaExceptionText = "XAER_PROTO";
1:70f7692:             break;
1:69e3d06:         case XAException.XAER_RMFAIL:
1:70f7692:             xaExceptionText = "XAER_RMFAIL";
1:70f7692:             break;
1:69e3d06:         case XAException.XAER_DUPID:
1:70f7692:             xaExceptionText = "XAER_DUPID";
1:70f7692:             break;
1:69e3d06:         case XAException.XAER_OUTSIDE:
1:70f7692:             xaExceptionText = "XAER_OUTSIDE";
1:70f7692:             break;
1:70f7692:         case XAResource.XA_OK:
1:70f7692:             xaExceptionText = "XA_OK";
1:70f7692:             break;
1:70f7692:         default:
1:70f7692:             xaExceptionText = "Unknown Error";
1:70f7692:             break;
1:70f7692:         }
1:70f7692:         return xaExceptionText;
1:70f7692:     }
1:70f7692: 
1:0326967:     private void throwXAException(int rc)
1:0326967:             throws XAException {
1:0326967: 
1:0326967:         StringBuilder xaExceptionText = new StringBuilder(64);
1:70f7692: 
1:a9c3863:         xaExceptionText.append(getXAExceptionText(rc));
1:70f7692:         // save the SqlException chain to add it to the XAException
1:b13b17c:         SqlException sqlExceptions = exceptionsOnXA;
1:70f7692: 
1:70f7692:         while (exceptionsOnXA != null) { // one or more SqlExceptions received, format them
1:a9c3863:             xaExceptionText.append(" : ").append(exceptionsOnXA.getMessage());
1:b13b17c:             exceptionsOnXA = (SqlException)
1:70f7692:                     exceptionsOnXA.getNextException();
1:70f7692:         }
1:b13b17c: 
1:b13b17c:         XaException xaException = new XaException(
1:b13b17c:                 conn_.agent_.logWriter_,
1:b13b17c:                 sqlExceptions,
1:b13b17c:                 xaExceptionText.toString());
1:b13b17c: 
1:70f7692:         xaException.errorCode = rc;
1:88c25bb:         setXaStateForXAException(rc); 
1:70f7692:         throw xaException;
1:70f7692:     }
1:88c25bb: 
1:70f7692: 
1:88c25bb:     /**
1:88c25bb:      * Reset the transaction branch association state  to XA_T0_NOT_ASSOCIATED
1:0326967:      * for XAER_RM* and XA_RB* Exceptions. All other exceptions leave the state
1:88c25bb:      * unchanged
1:88c25bb:      * 
1:88c25bb:      * @param rc  // return code from XAException
1:88c25bb:      * @throws XAException
1:88c25bb:      */
1:88c25bb:     private void setXaStateForXAException(int rc) {
1:6eb29f6:         switch (rc)
1:6eb29f6:         {
1:6eb29f6:             // Reset to T0, not  associated for XA_RB*, RM*
1:88c25bb:            // XAER_RMFAIL and XAER_RMERR will be fatal to the connection
1:88c25bb:            // but that is not dealt with here
1:69e3d06:            case XAException.XAER_RMFAIL:
1:69e3d06:            case XAException.XAER_RMERR:
1:69e3d06:            case XAException.XA_RBROLLBACK:
1:69e3d06:            case XAException.XA_RBCOMMFAIL:
1:69e3d06:            case XAException.XA_RBDEADLOCK:
1:69e3d06:            case XAException.XA_RBINTEGRITY:
1:69e3d06:            case XAException.XA_RBOTHER:
1:69e3d06:            case XAException.XA_RBPROTO:
1:69e3d06:            case XAException.XA_RBTIMEOUT:
1:69e3d06:            case XAException.XA_RBTRANSIENT:
1:69e3d06:                conn_.setXAState(ClientConnection.XA_T0_NOT_ASSOCIATED);
1:88c25bb:            break;
1:88c25bb:             // No change for other XAExceptions
1:69e3d06:             // XAException.XA_NOMIGRATE
1:69e3d06:            //XAException.XA_HEURHAZ
1:69e3d06:            // XAException.XA_HEURCOM
1:69e3d06:            // XAException.XA_HEURRB
1:69e3d06:            // XAException.XA_HEURMIX
1:69e3d06:            // XAException.XA_RETRY
1:69e3d06:            // XAException.XA_RDONLY
1:69e3d06:            // XAException.XAER_ASYNC
1:69e3d06:            // XAException.XAER_NOTA
1:69e3d06:            // XAException.XAER_INVAL
1:69e3d06:            // XAException.XAER_PROTO
1:69e3d06:            // XAException.XAER_DUPID
1:69e3d06:            // XAException.XAER_OUTSIDE
1:88c25bb:             default:
1:6eb29f6:                 return;
1:6eb29f6:         }    
1:88c25bb:     }
1:88c25bb: 
1:70f7692:     public boolean isSameRM(XAResource xares) throws XAException {
1:70f7692:         boolean isSame = false; // preset that the RMs are NOT the same
1:70f7692:         exceptionsOnXA = null;
1:70f7692: 
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceEntry(this, "isSameRM", xares);
1:88c25bb:         }
1:88c25bb:         if (conn_.isPhysicalConnClosed()) {
1:70f7692:             connectionClosedFailure();
1:70f7692:         }
1:70f7692: 
1:b13b17c:         if (xares instanceof NetXAResource) {
1:69e3d06:             // Both are NetXAResource so check to see if this is the same RM.
1:69e3d06:             // Remember, isSame is initialized to false
1:70f7692:             NetXAResource derbyxares = (NetXAResource) xares;
1:70f7692:             while (true) {
1:70f7692:                 if (!conn_.databaseName_.equalsIgnoreCase(derbyxares.conn_.databaseName_)) {
1:70f7692:                     break; // database names are not equal, not same RM
1:70f7692:                 }
1:70f7692:                 if (!conn_.netAgent_.server_.equalsIgnoreCase
1:70f7692:                         (derbyxares.conn_.netAgent_.server_)) { // server name strings not equal, compare IP addresses
1:70f7692:                     try {
1:70f7692:                         // 1st convert "localhost" to actual server name
1:70f7692:                         String server1 = this.processLocalHost(conn_.netAgent_.server_);
1:70f7692:                         String server2 =
1:70f7692:                                 this.processLocalHost(derbyxares.conn_.netAgent_.server_);
1:70f7692:                         // now convert the server name to ip address
1:70f7692:                         InetAddress serverIP1 = InetAddress.getByName(server1);
1:70f7692:                         InetAddress serverIP2 = InetAddress.getByName(server2);
1:70f7692:                         if (!serverIP1.equals(serverIP2)) {
1:70f7692:                             break; // server IPs are not equal, not same RM
1:70f7692:                         }
1:70f7692:                     } catch (UnknownHostException ue) {
1:70f7692:                         break;
1:70f7692:                     }
1:70f7692:                 }
1:70f7692:                 if (conn_.netAgent_.port_ != derbyxares.conn_.netAgent_.port_) {
1:70f7692:                     break; // ports are not equal, not same RM
1:70f7692:                 }
1:70f7692:                 isSame = true; // everything the same, set RMs are the same
1:70f7692:                 break;
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (conn_.agent_.loggingEnabled()) {
1:70f7692:             conn_.agent_.logWriter_.traceExit
1:70f7692:                     (this, "isSameRM", isSame);
1:70f7692:         }
1:70f7692:         return isSame;
1:70f7692:     }
1:88c25bb:     
1:70f7692:     public static boolean xidsEqual(Xid xid1, Xid xid2) { // determine if the 2 xids contain the same values even if not same object
1:70f7692:         // comapre the format ids
1:70f7692:         if (xid1.getFormatId() != xid2.getFormatId()) {
1:70f7692:             return false; // format ids are not the same
1:70f7692:         }
1:70f7692: 
1:70f7692:         // compare the global transaction ids
1:70f7692:         int xid1Length = xid1.getGlobalTransactionId().length;
1:70f7692:         if (xid1Length != xid2.getGlobalTransactionId().length) {
1:70f7692:             return false; // length of the global trans ids are not the same
1:70f7692:         }
1:70f7692:         byte[] xid1Bytes = xid1.getGlobalTransactionId();
1:70f7692:         byte[] xid2Bytes = xid2.getGlobalTransactionId();
1:70f7692:         int i;
1:70f7692:         for (i = 0; i < xid1Length; ++i) { // check all bytes are the same
1:70f7692:             if (xid1Bytes[i] != xid2Bytes[i]) {
1:70f7692:                 return false; // bytes in the global trans ids are not the same
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // compare the branch qualifiers
1:70f7692:         xid1Length = xid1.getBranchQualifier().length;
1:70f7692:         if (xid1Length != xid2.getBranchQualifier().length) {
1:70f7692:             return false; // length of the global trans ids are not the same
1:70f7692:         }
1:70f7692:         xid1Bytes = xid1.getBranchQualifier();
1:70f7692:         xid2Bytes = xid2.getBranchQualifier();
1:70f7692:         for (i = 0; i < xid1Length; ++i) { // check all bytes are the same
1:70f7692:             if (xid1Bytes[i] != xid2Bytes[i]) {
1:70f7692:                 return false; // bytes in the global trans ids are not the same
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         return true; // all of the fields are the same, xid1 == xid2
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     private void connectionClosedFailure() throws XAException { // throw an XAException XAER_RMFAIL, with a chained SqlException - closed
1:b13b17c:         exceptionsOnXA = Utils.accumulateSQLException
1:b2a1747:                 (new SqlException(null, 
1:b2a1747:                         new ClientMessageId(SQLState.NO_CURRENT_CONNECTION)),
1:70f7692:                         exceptionsOnXA);
1:69e3d06:         throwXAException(XAException.XAER_RMFAIL);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private String getXAFuncStr(int xaFunc) {
1:70f7692:         switch (xaFunc) {
1:70f7692:         case XAFUNC_COMMIT:
1:70f7692:             return XAFUNCSTR_COMMIT;
1:70f7692:         case XAFUNC_END:
1:70f7692:             return XAFUNCSTR_END;
1:70f7692:         case XAFUNC_FORGET:
1:70f7692:             return XAFUNCSTR_FORGET;
1:70f7692:         case XAFUNC_PREPARE:
1:70f7692:             return XAFUNCSTR_PREPARE;
1:70f7692:         case XAFUNC_RECOVER:
1:70f7692:             return XAFUNCSTR_RECOVER;
1:70f7692:         case XAFUNC_ROLLBACK:
1:70f7692:             return XAFUNCSTR_ROLLBACK;
1:70f7692:         case XAFUNC_START:
1:70f7692:             return XAFUNCSTR_START;
1:70f7692:         }
1:70f7692:         return XAFUNCSTR_NONE;
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected int xaRetValErrorAccumSQL(NetXACallInfo callInfo, int currentRC) {
1:d5ba8a8: 
1:d5ba8a8:         // xaRetVal_ is set by the server to be one of the
1:d5ba8a8:         // standard constants from XAException.
1:d5ba8a8:         int rc = callInfo.xaRetVal_;
1:70f7692: 
1:70f7692:         if (rc != XAResource.XA_OK) { // error was detected
1:70f7692:             // create an SqlException to report this error within
1:70f7692:             SqlException accumSql = new SqlException(conn_.netAgent_.logWriter_,
1:b2a1747:                 new ClientMessageId(SQLState.NET_XARETVAL_ERROR),
1:e1a79c3:                 SqlCode.queuedXAError,
1:b2a1747:                 getXAFuncStr(callInfo.xaFunction_),
1:e1a79c3:                 getXAExceptionText(rc));
1:b13b17c:             exceptionsOnXA = Utils.accumulateSQLException
1:70f7692:                     (accumSql, exceptionsOnXA);
1:70f7692: 
1:70f7692:             if (currentRC != XAResource.XA_OK) { // the rc passed into this function had an error also, prioritize error
1:70f7692:                 if (currentRC < 0) { // rc passed in was a major error use it instead of current error
1:70f7692:                     return currentRC;
1:70f7692:                 }
1:70f7692:             }
1:70f7692:         }
1:70f7692:         return rc;
1:70f7692:     }
1:70f7692: 
1:70f7692:     private String processLocalHost(String serverName) {
1:70f7692:         if (serverName.equalsIgnoreCase("localhost")) { // this is a localhost, find hostname
3:70f7692:             try {
1:70f7692:                 InetAddress localhostNameIA = InetAddress.getLocalHost();
1:70f7692:                 String localhostName = localhostNameIA.getHostName();
1:70f7692:                 return localhostName;
1:70f7692:             } catch (SecurityException se) {
1:70f7692:                 return serverName;
1:70f7692:             } catch (UnknownHostException ue) {
1:70f7692:                 return serverName;
23:70f7692:             }
1:70f7692:         }
1:70f7692:         // not "localhost", return original server name
1:70f7692:         return serverName;
1:70f7692:     }
1:70f7692: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e1a79c3
/////////////////////////////////////////////////////////////////////////
1:                 SqlCode.queuedXAError,
1:                 getXAExceptionText(rc));
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
0:     private final List<String> specialRegisters_ =
0:             Collections.synchronizedList(new LinkedList<String>());
commit:db8b20b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:cccf5dd
/////////////////////////////////////////////////////////////////////////
1:     /** The value of the transaction timeout in seconds. */
1:     private int timeoutSeconds = 0;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Obtain the current transaction timeout value set for this XAResource
1:      * instance. If XAResource.setTransactionTimeout was not use prior to
1:      * invoking this method, the return value is 0; otherwise, the value
1:      * used in the previous setTransactionTimeout call is returned.
1:      * @return the transaction timeout value in seconds. If the returned value
1:      * is equal to Integer.MAX_VALUE it means no timeout.
/////////////////////////////////////////////////////////////////////////
1:             conn_.agent_.logWriter_.traceExit(this, "getTransactionTimeout", timeoutSeconds);
1:         return timeoutSeconds;
/////////////////////////////////////////////////////////////////////////
1:      * Set the current transaction timeout value for this XAResource
1:      * instance. Once set, this timeout value is effective until
1:      * setTransactionTimeout is invoked again with a different value. To reset
1:      * the timeout value to the default value used by the resource manager,
1:      * set the value to zero. If the timeout operation is performed
1:      * successfully, the method returns true; otherwise false. If a resource
1:      * manager does not support transaction timeout value to be set
1:      * explicitly, this method returns false.
1:      *                Value of 0 means the reasource manager's default value.
1:      *                Value of Integer.MAX_VALUE means no timeout.
1:      * @return true if transaction timeout value is set successfully;
1:      * otherwise false.
1:      * @exception XAException - An error has occurred. Possible exception
1:      * values are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.
1:             conn_.agent_.logWriter_.traceEntry(this, "setTransactionTimeout");
1:         }
1:         if (seconds < 0) {
1:             // throw an exception if invalid value was specified
1:             throw new XAException(XAException.XAER_INVAL);
1:         timeoutSeconds = seconds;
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceExit(this, "setTransactionTimeout", true);
1:         }
1:         return true;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // check and setup the transaction timeout settings
1:         if (flags == TMNOFLAGS) {
1:             if (timeoutSeconds == Integer.MAX_VALUE) {
1:                 // Disable the transaction timeout.
1:                 callInfo.xaTimeoutMillis_ = 0;
1:             } else if (timeoutSeconds > 0) {
1:                 // Use the timeout value specified.
1:                 callInfo.xaTimeoutMillis_ = 1000*timeoutSeconds;
1:             } else if (timeoutSeconds == 0) {
1:                 // The -1 value means that the timeout codepoint
1:                 // will not be sent in the request and thus the server
1:                 // will use the default value.
1:                 callInfo.xaTimeoutMillis_ = -1;
1:             } else {
1:                 // This should not ever happen due that setTransactionTimeout
1:                 // does not allow a negative value
1:                 throwXAException(XAException.XAER_RMERR);
1:             }
1:         }
commit:57d7d13
/////////////////////////////////////////////////////////////////////////
1:             // The corresponding XA connection association state
1:             // is changed by setXaStateForXAException inside the call
1:             // to throwXAException according the error code of the XAException
1:             // to be thrown.
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     private static final int INITIAL_CALLINFO_ELEMENTS = 1;
1:     static final ClientXid nullXid = new ClientXid();
1:     static final int XAFUNC_COMMIT = 1;
1:     private static final int XAFUNC_END = 2;
1:     private static final int XAFUNC_FORGET = 3;
1:     private static final int XAFUNC_PREPARE = 4;
1:     private static final int XAFUNC_RECOVER = 5;
1:     static final int XAFUNC_ROLLBACK = 6;
1:     private static final int XAFUNC_START = 7;
1:     private static final String XAFUNCSTR_NONE = "No XA Function";
1:     private static final String XAFUNCSTR_COMMIT = "XAResource.commit()";
1:     private static final String XAFUNCSTR_END = "XAResource.end()";
1:     private static final String XAFUNCSTR_FORGET = "XAResource.forget()";
1:     private static final String XAFUNCSTR_PREPARE = "XAResource.prepare()";
1:     private static final String XAFUNCSTR_RECOVER = "XAResource.recover()";
1:     private static final String XAFUNCSTR_ROLLBACK = "XAResource.rollback()";
1:     private static final String XAFUNCSTR_START = "XAResource.start()";
1:     SqlException exceptionsOnXA = null;
1: 
1: 
1:     public NetXAResource(XAConnection xaconn,
/////////////////////////////////////////////////////////////////////////
1:             callInfoArray_[i] = new NetXACallInfo(null, XAResource.TMNOFLAGS,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             throwXAException(rc);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             throwXAException(rc);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             throwXAException(rc);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             throwXAException(rc);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             throwXAException(rc);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             throwXAException(rc);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             throwXAException(rc);
/////////////////////////////////////////////////////////////////////////
1:     private void throwXAException(int rc)
1:             throws XAException {
1: 
1:         StringBuilder xaExceptionText = new StringBuilder(64);
/////////////////////////////////////////////////////////////////////////
1:      * for XAER_RM* and XA_RB* Exceptions. All other exceptions leave the state
/////////////////////////////////////////////////////////////////////////
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientConnection;
/////////////////////////////////////////////////////////////////////////
1:             conn_.setXAState(ClientConnection.XA_T0_NOT_ASSOCIATED);
/////////////////////////////////////////////////////////////////////////
1:                 conn_.setXAState(ClientConnection.XA_T1_ASSOCIATED);
/////////////////////////////////////////////////////////////////////////
1:         case XAException.XA_RBROLLBACK:
1:         case XAException.XA_RBCOMMFAIL:
1:         case XAException.XA_RBDEADLOCK:
1:         case XAException.XA_RBINTEGRITY:
1:         case XAException.XA_RBOTHER:
1:         case XAException.XA_RBPROTO:
1:         case XAException.XA_RBTIMEOUT:
1:         case XAException.XA_RBTRANSIENT:
1:         case XAException.XA_NOMIGRATE:
1:         case XAException.XA_HEURHAZ:
1:         case XAException.XA_HEURCOM:
1:         case XAException.XA_HEURRB:
1:         case XAException.XA_HEURMIX:
1:         case XAException.XA_RETRY:
1:         case XAException.XA_RDONLY:
1:         case XAException.XAER_ASYNC:
1:         case XAException.XAER_RMERR:
1:         case XAException.XAER_NOTA:
1:         case XAException.XAER_INVAL:
1:         case XAException.XAER_PROTO:
1:         case XAException.XAER_RMFAIL:
1:         case XAException.XAER_DUPID:
1:         case XAException.XAER_OUTSIDE:
/////////////////////////////////////////////////////////////////////////
1:            case XAException.XAER_RMFAIL:
1:            case XAException.XAER_RMERR:
1:            case XAException.XA_RBROLLBACK:
1:            case XAException.XA_RBCOMMFAIL:
1:            case XAException.XA_RBDEADLOCK:
1:            case XAException.XA_RBINTEGRITY:
1:            case XAException.XA_RBOTHER:
1:            case XAException.XA_RBPROTO:
1:            case XAException.XA_RBTIMEOUT:
1:            case XAException.XA_RBTRANSIENT:
1:                conn_.setXAState(ClientConnection.XA_T0_NOT_ASSOCIATED);
1:             // XAException.XA_NOMIGRATE
1:            //XAException.XA_HEURHAZ
1:            // XAException.XA_HEURCOM
1:            // XAException.XA_HEURRB
1:            // XAException.XA_HEURMIX
1:            // XAException.XA_RETRY
1:            // XAException.XA_RDONLY
1:            // XAException.XAER_ASYNC
1:            // XAException.XAER_NOTA
1:            // XAException.XAER_INVAL
1:            // XAException.XAER_PROTO
1:            // XAException.XAER_DUPID
1:            // XAException.XAER_OUTSIDE
/////////////////////////////////////////////////////////////////////////
1:             // Both are NetXAResource so check to see if this is the same RM.
1:             // Remember, isSame is initialized to false
/////////////////////////////////////////////////////////////////////////
1:         throwXAException(XAException.XAER_RMFAIL);
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.SqlCode;
1: import org.apache.derby.client.am.Utils;
1: import org.apache.derby.client.am.XaException;
/////////////////////////////////////////////////////////////////////////
0:     public SqlException exceptionsOnXA = null;
1:     NetXAConnection netXAConn_;
1:     NetConnection conn_;
/////////////////////////////////////////////////////////////////////////
1:                          NetXAConnection conn) {
/////////////////////////////////////////////////////////////////////////
1:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
/////////////////////////////////////////////////////////////////////////
1:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
/////////////////////////////////////////////////////////////////////////
1:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
/////////////////////////////////////////////////////////////////////////
1:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
/////////////////////////////////////////////////////////////////////////
1:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
/////////////////////////////////////////////////////////////////////////
1:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
/////////////////////////////////////////////////////////////////////////
1:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
/////////////////////////////////////////////////////////////////////////
1:             exceptionsOnXA = Utils.accumulateSQLException(sqle, exceptionsOnXA);
/////////////////////////////////////////////////////////////////////////
1:         SqlException sqlExceptions = exceptionsOnXA;
1:             exceptionsOnXA = (SqlException)
1: 
1:         XaException xaException = new XaException(
1:                 conn_.agent_.logWriter_,
1:                 sqlExceptions,
1:                 xaExceptionText.toString());
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (xares instanceof NetXAResource) {
0:             // Both are NetXAResource so check to see if this is the same RM
/////////////////////////////////////////////////////////////////////////
1:         exceptionsOnXA = Utils.accumulateSQLException
/////////////////////////////////////////////////////////////////////////
0:                 SqlCode.queuedXAError);
1:             exceptionsOnXA = Utils.accumulateSQLException
commit:43fb59e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             xidList = conn_.getIndoubtTransactionIds();
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
0:             conn_.setXAState(Connection.XA_T0_NOT_ASSOCIATED);
/////////////////////////////////////////////////////////////////////////
1:             if(conn_.autoCommit_)
1:                 conn_.flowAutoCommit();
1:             rc = getSqlExceptionXAErrorCode(sqle);
/////////////////////////////////////////////////////////////////////////
1:         switch (rc)
1:         {
1:             // Reset to T0, not  associated for XA_RB*, RM*
/////////////////////////////////////////////////////////////////////////
0:                conn_.setXAState(Connection.XA_T0_NOT_ASSOCIATED);
/////////////////////////////////////////////////////////////////////////
0:            // javax.transaction.xa.XAException.XAER_OUTSIDE                
1:                 return;
1:         }    
commit:2f3d052
/////////////////////////////////////////////////////////////////////////
0: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:     private boolean keepIsolationLevel;
/////////////////////////////////////////////////////////////////////////
1:     public void setKeepCurrentIsolationLevel(boolean flag) {
1:         keepIsolationLevel = flag;
1:     }
1: 
1:     public boolean keepCurrentIsolationLevel() {
1:         return keepIsolationLevel;
1:     }
1: 
commit:31ba8d0
/////////////////////////////////////////////////////////////////////////
1:             rc = getSqlExceptionXAErrorCode(sqle);
/////////////////////////////////////////////////////////////////////////
1:      * Get XAException.errorCode from SqlException
1:      * For disconnect exception, return XAER_RMFAIL
1:      * For other exceptions return XAER_RMERR
1:      * 
1:      * For server side SQLExceptions during 
1:      * XA operations the errorCode has already been determined
1:      * and wrapped in an XAException for return to the client.
1:      * see EmbedXAResource.wrapInXAException
1:      * 
1:      * @param sqle  SqlException to evaluate.
1:      * @return XAException.XAER_RMFAIL for disconnect exception,
1:      *         XAException.XAER_RMERR for other exceptions.
1:      */
1:     private int getSqlExceptionXAErrorCode(SqlException sqle) {      
1:        int seErrorCode = sqle.getErrorCode();
1:        return (seErrorCode == 40000 ? XAException.XAER_RMFAIL : XAException.XAER_RMERR);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:             rc = getSqlExceptionXAErrorCode(sqle);
/////////////////////////////////////////////////////////////////////////
1:             throwXAException(getSqlExceptionXAErrorCode(sqle));
/////////////////////////////////////////////////////////////////////////
1:             rc = getSqlExceptionXAErrorCode(sqle);
/////////////////////////////////////////////////////////////////////////
1:             rc = getSqlExceptionXAErrorCode(sqle);
/////////////////////////////////////////////////////////////////////////
1:             rc = getSqlExceptionXAErrorCode(sqle);
/////////////////////////////////////////////////////////////////////////
1:         	rc = getSqlExceptionXAErrorCode(sqle);
/////////////////////////////////////////////////////////////////////////
0:             rc = getSqlExceptionXAErrorCode(sqle);
commit:1a7cb26
/////////////////////////////////////////////////////////////////////////
1:         
1:         // DERBY-1025 - Flow an auto-commit if in auto-commit mode before 
1:         // entering a global transaction
1:         try {
0:         	if(conn_.autoCommit_)
0:         		conn_.flowAutoCommit();
1:         } catch (SqlException sqle) {
0:         	rc = XAException.XAER_RMERR;
0:             exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                     (sqle, exceptionsOnXA);
1:         } 
commit:344b9ef
/////////////////////////////////////////////////////////////////////////
1:         if ((rc != XAResource.XA_OK ) && (rc != XAResource.XA_RDONLY)) {
commit:88c25bb
/////////////////////////////////////////////////////////////////////////
1:         if (conn_.isPhysicalConnClosed()) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (conn_.isPhysicalConnClosed()) {
/////////////////////////////////////////////////////////////////////////
1:         }else {
0:         	conn_.setXAState(Connection.XA_T0_NOT_ASSOCIATED);
/////////////////////////////////////////////////////////////////////////
1:         if (conn_.isPhysicalConnClosed()) {
/////////////////////////////////////////////////////////////////////////
1:         if (conn_.isPhysicalConnClosed()) {
/////////////////////////////////////////////////////////////////////////
1:         if (conn_.isPhysicalConnClosed()) {
/////////////////////////////////////////////////////////////////////////
1:         if (conn_.isPhysicalConnClosed()) {
/////////////////////////////////////////////////////////////////////////
1:         if (conn_.isPhysicalConnClosed()) {
/////////////////////////////////////////////////////////////////////////
1:  
/////////////////////////////////////////////////////////////////////////
1:         if (conn_.isPhysicalConnClosed()) {
/////////////////////////////////////////////////////////////////////////
0:                 conn_.setXAState(Connection.XA_T1_ASSOCIATED);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         setXaStateForXAException(rc); 
1: 
1:     /**
1:      * Reset the transaction branch association state  to XA_T0_NOT_ASSOCIATED
0:      * for XAER_RM* and XA_RB* Exceptions. All other exeptions leave the state 
1:      * unchanged
1:      * 
1:      * @param rc  // return code from XAException
1:      * @throws XAException
1:      */
1:     private void setXaStateForXAException(int rc) {
0:     	switch (rc)
0: 		{
0:         	// Reset to T0, not  associated for XA_RB*, RM*
1:            // XAER_RMFAIL and XAER_RMERR will be fatal to the connection
1:            // but that is not dealt with here
0:            case javax.transaction.xa.XAException.XAER_RMFAIL:
0:            case javax.transaction.xa.XAException.XAER_RMERR:
0:            case javax.transaction.xa.XAException.XA_RBROLLBACK:
0:            case javax.transaction.xa.XAException.XA_RBCOMMFAIL:
0:            case javax.transaction.xa.XAException.XA_RBDEADLOCK:
0:            case javax.transaction.xa.XAException.XA_RBINTEGRITY:
0:            case javax.transaction.xa.XAException.XA_RBOTHER:
0:            case javax.transaction.xa.XAException.XA_RBPROTO:
0:            case javax.transaction.xa.XAException.XA_RBTIMEOUT:
0:            case javax.transaction.xa.XAException.XA_RBTRANSIENT:
0:            	conn_.setXAState(Connection.XA_T0_NOT_ASSOCIATED);
1:            break;
1:             // No change for other XAExceptions
0:             // javax.transaction.xa.XAException.XA_NOMIGRATE
0:            //javax.transaction.xa.XAException.XA_HEURHAZ
0:            // javax.transaction.xa.XAException.XA_HEURCOM
0:            // javax.transaction.xa.XAException.XA_HEURRB
0:            // javax.transaction.xa.XAException.XA_HEURMIX
0:            // javax.transaction.xa.XAException.XA_RETRY
0:            // javax.transaction.xa.XAException.XA_RDONLY
0:            // javax.transaction.xa.XAException.XAER_ASYNC
0:            // javax.transaction.xa.XAException.XAER_NOTA
0:            // javax.transaction.xa.XAException.XAER_INVAL                
0:            // javax.transaction.xa.XAException.XAER_PROTO
0:            // javax.transaction.xa.XAException.XAER_DUPID
0:            // javax.transaction.xa.XAException.XAER_OUTSIDE            	
1:             default:
0:   			  return;
1: 		}	
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (conn_.isPhysicalConnClosed()) {
/////////////////////////////////////////////////////////////////////////
1:     
commit:38083d6
/////////////////////////////////////////////////////////////////////////
1: 
1:     // TODO: change to a single callInfo field (not an array)
/////////////////////////////////////////////////////////////////////////
0:     // TODO: remove port and ipaddr_
/////////////////////////////////////////////////////////////////////////
0:             callInfoArray_[i] = new NetXACallInfo(null, XAResource.TMNOFLAGS, this,
/////////////////////////////////////////////////////////////////////////
1:         
0:         if (conn_.isPhysicallyClosed()) {
/////////////////////////////////////////////////////////////////////////
0:         else {
0:         	conn_.setXAState(Connection.XA_LOCAL);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (conn_.isPhysicallyClosed()) {
/////////////////////////////////////////////////////////////////////////
1:         } 
/////////////////////////////////////////////////////////////////////////
0:         if (conn_.isPhysicallyClosed()) {
/////////////////////////////////////////////////////////////////////////
0:         if (conn_.isPhysicallyClosed()) {
/////////////////////////////////////////////////////////////////////////
0:         if (conn_.isPhysicallyClosed()) {
/////////////////////////////////////////////////////////////////////////
0:         if (conn_.isPhysicallyClosed()) {
/////////////////////////////////////////////////////////////////////////
0:         if (conn_.isPhysicallyClosed()) {
/////////////////////////////////////////////////////////////////////////
0:         else {
0:         	conn_.setXAState(Connection.XA_LOCAL);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (conn_.isPhysicallyClosed()) {
/////////////////////////////////////////////////////////////////////////
0:                 conn_.setXAState(Connection.XA_GLOBAL);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (conn_.isPhysicallyClosed()) {
/////////////////////////////////////////////////////////////////////////
author:Lily Wei
-------------------------------------------------------------------------------
commit:a9c3863
/////////////////////////////////////////////////////////////////////////
0:         StringBuffer xaExceptionText = new StringBuffer(64);
/////////////////////////////////////////////////////////////////////////
1:         xaExceptionText.append(getXAExceptionText(rc));
1:             xaExceptionText.append(" : ").append(exceptionsOnXA.getMessage());
0:                         xaExceptionText.toString());
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:b2a1747
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientMessageId;
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:                 (new SqlException(null, 
1:                         new ClientMessageId(SQLState.NO_CURRENT_CONNECTION)),
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.NET_XARETVAL_ERROR),
1:                 getXAFuncStr(callInfo.xaFunction_),
0:                 getXAExceptionText(rc),
0:                 org.apache.derby.client.am.SqlCode.queuedXAError);
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1:      * @param seconds the transaction timeout value in seconds.
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dadd05a
/////////////////////////////////////////////////////////////////////////
0:     org.apache.derby.client.net.NetXAConnection netXAConn_;
0:     org.apache.derby.client.net.NetConnection conn_;
/////////////////////////////////////////////////////////////////////////
1:         conn_ = conn.getNetConnection();
1:         netXAConn_ = conn;
0:         port_ = conn_.netAgent_.getPort();
0:         ipaddr_ = conn_.netAgent_.socket_.getLocalAddress().getHostAddress();
/////////////////////////////////////////////////////////////////////////
1:         callInfoArray_[0].actualConn_ = conn;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:d5ba8a8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
/////////////////////////////////////////////////////////////////////////
1:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
/////////////////////////////////////////////////////////////////////////
1:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
/////////////////////////////////////////////////////////////////////////
1:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
/////////////////////////////////////////////////////////////////////////
1:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
/////////////////////////////////////////////////////////////////////////
1:             if ((callInfo.xaRetVal_ != XAResource.XA_OK) &&
1:                     (callInfo.xaRetVal_ != XAException.XA_RDONLY)) { // xaRetVal has possible error, format it
1:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
/////////////////////////////////////////////////////////////////////////
1:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
/////////////////////////////////////////////////////////////////////////
1:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
/////////////////////////////////////////////////////////////////////////
1:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
/////////////////////////////////////////////////////////////////////////
1:         callInfo.xaRetVal_ = XAResource.XA_OK; // initialize XARETVAL
1:             if (callInfo.xaRetVal_ != XAResource.XA_OK) { // xaRetVal has possible error, format it
1:                 callInfo.xaRetVal_ = XAResource.XA_OK; // re-initialize XARETVAL
1:             if (rc == XAResource.XA_OK) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         // xaRetVal_ is set by the server to be one of the
1:         // standard constants from XAException.
1:         int rc = callInfo.xaRetVal_;
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
0: import java.util.Enumeration;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Vector;
1: import javax.sql.XAConnection;
1: import javax.transaction.xa.XAException;
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: import org.apache.derby.client.ClientXid;
0: import org.apache.derby.client.am.Connection;
1: import org.apache.derby.client.am.SqlException;
1: public class NetXAResource implements XAResource {
0:     public static final int TMTIMEOUT = 0x00000100;
0:     public static final int ACTIVE_ONLY = -1;
0:     public static final int XA_NULL_XID = -1; // null Xid has Format Id of -1
0:     public static final int INITIAL_CALLINFO_ELEMENTS = 1;
0:     public static final int RECOVER_XID_ARRAY_LENGTH = 10;
0:     public static final ClientXid nullXid = new ClientXid();
0:     // xaretval defines
0:     public static final int XARETVAL_XALCSNOTSUPP = 99; // Loosely Coupled Not Supported
0:     public static final int XARETVAL_RBROLLBACK = 100; // Rollback
0:     public static final int XARETVAL_RBCOMMFAIL = 101; // Rollback Communication Failure
0:     public static final int XARETVAL_RBDEADLOCK = 102; // Rollback Deadlock
0:     public static final int XARETVAL_RBINTEGRITY = 103; // Rollback integrity violation
0:     public static final int XARETVAL_RBOTHER = 104; // Rollback Other
0:     public static final int XARETVAL_RBPROTO = 105; // Rollback Protocol
0:     public static final int XARETVAL_RBTIMEOUT = 106; // Rollback Timeout
0:     public static final int XARETVAL_RBTRANSIENT = 107; // Rollback Transaction branch
0:     public static final int XARETVAL_NODISSOCIATE = 108; // Unable to Dissociate resources from connection
0:     public static final int XARETVAL_XATWOPHASE = 13; // TwoPhase commit required
0:     public static final int XARETVAL_XAPROMOTED = 12; // Promoted - unused
0:     public static final int XARETVAL_XADEFERRED = 11; // Deferred - unused
0:     public static final int XARETVAL_XACOMMFAIL = 10; // Communication Failure
0:     public static final int XARETVAL_XANOMIGRATE = 9; // No Migration
0:     public static final int XARETVAL_XAHEURHAZ = 8; // Heuristically completed
0:     public static final int XARETVAL_XAHEURCOM = 7; // Heuristically Commited
0:     public static final int XARETVAL_XAHEURRB = 6; // Heuristically Rolledback
0:     public static final int XARETVAL_XAHEURMIX = 5; // Branch heuristically commit and rollback
0:     public static final int XARETVAL_XARETRY = 4; // Retry Commit
0:     public static final int XARETVAL_XARDONLY = 3; // Read Only
0:     public static final int XARETVAL_XAOK = 0; // OK
0:     public static final int XARETVAL_XAERASYNC = -2; // Async Request not possible
0:     public static final int XARETVAL_XAERRMERR = -3; // RM Error
0:     public static final int XARETVAL_XAERNOTA = -4; // XID does not exist
0:     public static final int XARETVAL_XAERINVAL = -5; // Invalid arguments
0:     public static final int XARETVAL_XAERPROTO = -6; // Protocol Violation
0:     public static final int XARETVAL_XAERRMFAIL = -7; // RM Failed
0:     public static final int XARETVAL_XAERDUPID = -8; // Duplicate XID
0:     public static final int XARETVAL_XAEROUTSIDE = -9; // Local tansaction active
0:     public static final int XARETVAL_XAEROPENRES = -10; // Open resources
1:     // xaFunction defines, shows which queued XA function is being performed
0:     public static final int XAFUNC_NONE = 0;
0:     public static final int XAFUNC_COMMIT = 1;
0:     public static final int XAFUNC_END = 2;
0:     public static final int XAFUNC_FORGET = 3;
0:     public static final int XAFUNC_PREPARE = 4;
0:     public static final int XAFUNC_RECOVER = 5;
0:     public static final int XAFUNC_ROLLBACK = 6;
0:     public static final int XAFUNC_START = 7;
0:     public static final String XAFUNCSTR_NONE = "No XA Function";
0:     public static final String XAFUNCSTR_COMMIT = "XAResource.commit()";
0:     public static final String XAFUNCSTR_END = "XAResource.end()";
0:     public static final String XAFUNCSTR_FORGET = "XAResource.forget()";
0:     public static final String XAFUNCSTR_PREPARE = "XAResource.prepare()";
0:     public static final String XAFUNCSTR_RECOVER = "XAResource.recover()";
0:     public static final String XAFUNCSTR_ROLLBACK = "XAResource.rollback()";
0:     public static final String XAFUNCSTR_START = "XAResource.start()";
0:     public int nextElement = 0;
0:     // XAResources with same RM group list
0:     protected static Vector xaResourceSameRMGroup_ = new Vector();
0:     protected int sameRMGroupIndex_ = 0;
0:     protected NetXAResource nextSameRM_ = null;
0:     protected boolean ignoreMe_ = false;
0:     /* KATHEY CHECK THIS COMMENT TOO.
0:      * Need to remove NetXAResource objects from this group when they are
0:      *  freed.
1:      */
0:     public org.apache.derby.client.am.SqlException exceptionsOnXA = null;
0:     XAConnection xaconn_;
0:     org.apache.derby.client.net.NetXAConnection conn_;
0:     int rmId_; // unique RmId generated by XAConnection
0:     // KATHEY change to a single callInfo field (not an array)
1:     NetXACallInfo callInfoArray_[] =
1:             new NetXACallInfo[INITIAL_CALLINFO_ELEMENTS];
0:     int numXACallInfo_ = INITIAL_CALLINFO_ELEMENTS;
0:     int connectionCount_ = 1;
0:     int activeXATransCount_ = 0;
0:     String rmIdx_; // userid in case we need to create a secondary connection
0:     String rmIdy_; // password in case we need to create a secondary connection
0:     // KATHEY remove port and ipaddr_
0:     int port_;     // port needed to make secondary connection for recover in DS mode.
0:     String ipaddr_;  // ip address needed to make secondary connection for recover in DS mode.
0:     private List specialRegisters_ = Collections.synchronizedList(new LinkedList());
0:     public NetXAResource(XAConnection xaconn, int rmId,
0:                          String userId, String password,
0:                          org.apache.derby.client.net.NetXAConnection conn) {
0:         xaconn_ = xaconn;
0:         rmId_ = rmId;
0:         conn_ = conn;
0:         rmIdx_ = userId;
0:         rmIdy_ = password;
0:         port_ = conn.netAgent_.getPort();
0:         ipaddr_ = conn.netAgent_.socket_.getLocalAddress().getHostAddress();
1:         conn.setNetXAResource(this);
1:         // link the primary connection to the first XACallInfo element
1:         conn_.currXACallInfoOffset_ = 0;
1:         // construct the NetXACallInfo object for the array.
1:         for (int i = 0; i < INITIAL_CALLINFO_ELEMENTS; ++i) {
0:             callInfoArray_[i] = new NetXACallInfo(null, XAResource.TMNOFLAGS,
0:                     Connection.XA_OPEN_IDLE, this,
1:                     null);
1: 
1:         // initialize the first XACallInfo element with the information from the
1:         //  primary connection
0:         callInfoArray_[0].actualConn_ = conn_;
0:         callInfoArray_[0].currConnection_ = true;
0:         callInfoArray_[0].freeEntry_ = false;
1:         // ~~~ save conn_ connection variables in callInfoArray_[0]
1:         callInfoArray_[0].saveConnectionVariables();
1: 
0:         // add this new XAResource to the list of other XAResources for the Same RM
0:         initForReuse();
1:     public void commit(Xid xid, boolean onePhase) throws XAException {
1:         NetAgent netAgent = conn_.netAgent_;
1:         int rc = XAResource.XA_OK;
1:         exceptionsOnXA = null;
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceEntry(this, "commit", xid, onePhase);
1:         }
0:         if (conn_.isClosed()) {
1:             connectionClosedFailure();
1:         }
1:         // update the XACallInfo
1:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:         callInfo.xaFlags_ = (onePhase ? XAResource.TMONEPHASE :
1:                 XAResource.TMNOFLAGS);
1:         callInfo.xid_ = xid;
0:         callInfo.xaResource_ = this;
0:         callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
1:         try {
1:             netAgent.beginWriteChainOutsideUOW();
1:             netAgent.netConnectionRequest_.writeXaCommit(conn_, xid);
1:             netAgent.flowOutsideUOW();
1:             netAgent.netConnectionReply_.readXaCommit(conn_);
0:             if (callInfo.xaRetVal_ != XARETVAL_XAOK) { // xaRetVal has possible error, format it
1:                 callInfo.xaFunction_ = XAFUNC_COMMIT;
1:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
0:                 callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
1:             }
1:             netAgent.endReadChain();
1:         } catch (SqlException sqle) {
0:             rc = XAException.XAER_RMERR;
0:             exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                     (sqle, exceptionsOnXA);
0:         } finally {
0:             conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
1:         }
1:         if (rc != XAResource.XA_OK) {
0:             throwXAException(rc, false);
1:         }
1:     /**
1:      * Ends the work performed on behalf of a transaction branch. The resource manager dissociates the XA resource from
1:      * the transaction branch specified and let the transaction be completed.
1:      * <p/>
1:      * If TMSUSPEND is specified in flags, the transaction branch is temporarily suspended in incomplete state. The
1:      * transaction context is in suspened state and must be resumed via start with TMRESUME specified.
1:      * <p/>
1:      * If TMFAIL is specified, the portion of work has failed. The resource manager may mark the transaction as
1:      * rollback-only
1:      * <p/>
1:      * If TMSUCCESS is specified, the portion of work has completed successfully.
1:      *
1:      * @param xid   A global transaction identifier that is the same as what was used previously in the start method.
1:      * @param flags One of TMSUCCESS, TMFAIL, or TMSUSPEND
1:      *
1:      * @throws XAException An error has occurred. Possible XAException values are XAER_RMERR, XAER_RMFAILED, XAER_NOTA,
1:      *                     XAER_INVAL, XAER_PROTO, or XA_RB*.
1:      */
1: 
1:     public void end(Xid xid, int flags) throws XAException {
1: 
1:         NetAgent netAgent = conn_.netAgent_;
1:         int rc = XAResource.XA_OK;
1:         exceptionsOnXA = null;
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceEntry(this, "end", xid, flags);
1:         }
0:         if (conn_.isClosed()) {
1:             connectionClosedFailure();
1:         }
1: 
1:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0:         callInfo.setReadOnlyTransactionFlag(conn_.readOnlyTransaction_);
1:         callInfo.xaFlags_ = flags;
1:         callInfo.xid_ = xid;
0:         callInfo.xaResource_ = this;
0:         callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
1:         try {
1:             netAgent.beginWriteChainOutsideUOW();
1:             netAgent.netConnectionRequest_.writeXaEndUnitOfWork(conn_);
1:             netAgent.flowOutsideUOW();
1:             rc = netAgent.netConnectionReply_.readXaEndUnitOfWork(conn_);
0:             conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending end
0:             if (callInfo.xaRetVal_ != XARETVAL_XAOK) { // xaRetVal has possible error, format it
1:                 callInfo.xaFunction_ = XAFUNC_END;
1:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
0:                 callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
1:             }
1:             netAgent.endReadChain();
1:         } catch (SqlException sqle) {
0:             rc = XAException.XAER_RMERR;
0:             exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                     (sqle, exceptionsOnXA);
0:         } finally {
0:             conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
1:         }
1:         if (rc != XAResource.XA_OK) {
0:             throwXAException(rc, false);
0:         } else {
0:             conn_.setXAState(Connection.XA_ENDED);
1:         }
1: 
1:     /**
1:      * Tell the resource manager to forget about a heuristically (MANUALLY) completed transaction branch.
1:      *
1:      * @param xid A global transaction identifier
1:      *
1:      * @throws XAException An error has occurred. Possible exception values are XAER_RMERR, XAER_RMFAIL, XAER_NOTA,
1:      *                     XAER_INVAL, or XAER_PROTO.
1:      */
1: 
1:     public void forget(Xid xid) throws XAException {
1:         NetAgent netAgent = conn_.netAgent_;
1:         int rc = XAResource.XA_OK;
1:         exceptionsOnXA = null;
1: 
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceEntry(this, "forget", xid);
1:         }
0:         if (conn_.isClosed()) {
1:             connectionClosedFailure();
1:         }
1:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:         callInfo.xid_ = xid;
0:         callInfo.xaResource_ = this;
0:         callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
1:         try {
1:             // flow the required PROTOCOL to the server
1:             netAgent.beginWriteChainOutsideUOW();
1: 
1:             // sent the commit PROTOCOL
1:             netAgent.netConnectionRequest_.writeXaForget(netAgent.netConnection_, xid);
1: 
1:             netAgent.flowOutsideUOW();
1: 
1:             // read the reply to the commit
1:             netAgent.netConnectionReply_.readXaForget(netAgent.netConnection_);
1: 
1:             netAgent.endReadChain();
0:             if (callInfo.xaRetVal_ != XARETVAL_XAOK) { // xaRetVal has possible error, format it
1:                 callInfo.xaFunction_ = XAFUNC_FORGET;
1:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
0:                 callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
1:             }
1:         } catch (SqlException sqle) {
0:             exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                     (sqle, exceptionsOnXA);
0:             throwXAException(XAException.XAER_RMERR);
0:         } finally {
0:             conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
1:         }
1:         if (rc != XAResource.XA_OK) {
0:             throwXAException(rc, false);
1:         }
1: 
1:     }
1: 
1:     /**
0:      * Obtain the current transaction timeout value set for this XAResource instance. If
0:      * <CODE>XAResource.setTransactionTimeout</CODE> was not use prior to invoking this method, the return value is the
0:      * default timeout set for the resource manager; otherwise, the value used in the previous
0:      * <CODE>setTransactionTimeout</CODE> call is returned.
1:      *
0:      * @return the transaction timeout value in seconds.
1:      *
0:      * @throws XAException An error has occurred. Possible exception values are XAER_RMERR, XAER_RMFAIL.
1:      */
1:     public int getTransactionTimeout() throws XAException {
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceEntry(this, "getTransactionTimeout");
1:         }
1:         exceptionsOnXA = null;
0:         if (conn_.isClosed()) {
1:             connectionClosedFailure();
1:         }
1: 
1:         if (conn_.agent_.loggingEnabled()) {
0:             conn_.agent_.logWriter_.traceExit(this, "getTransactionTimeout", 0);
1:         }
0:         return 0; // we don't support transaction timeout
1:     }
1: 
1:     /**
1:      * Ask the resource manager to prepare for a transaction commit of the transaction specified in xid.
1:      *
1:      * @param xid A global transaction identifier
1:      *
1:      * @return A value indicating the resource manager's vote on the outcome of the transaction. The possible values
1:      *         are: XA_RDONLY or XA_OK. If the resource manager wants to roll back the transaction, it should do so by
1:      *         raising an appropriate XAException in the prepare method.
1:      *
1:      * @throws XAException An error has occurred. Possible exception values are: XA_RB*, XAER_RMERR, XAER_RMFAIL,
1:      *                     XAER_NOTA, XAER_INVAL, or XAER_PROTO.
1:      */
1:     public int prepare(Xid xid) throws XAException { // public interface for prepare
1:         // just call prepareX with the recursion flag set to true
1:         exceptionsOnXA = null;
1: 
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceEntry(this, "prepare", xid);
1:         }
0:         if (conn_.isClosed()) {
1:             connectionClosedFailure();
1:         }
1: 
1:         /// update the XACallInfo
1:         NetAgent netAgent = conn_.netAgent_;
1:         int rc = XAResource.XA_OK;
1:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:         callInfo.xid_ = xid;
0:         callInfo.xaResource_ = this;
0:         callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
1:         try {
1:             netAgent.beginWriteChainOutsideUOW();
1:             // sent the prepare PROTOCOL
1:             netAgent.netConnectionRequest_.writeXaPrepare(conn_);
1:             netAgent.flowOutsideUOW();
1: 
1:             // read the reply to the prepare
1:             rc = netAgent.netConnectionReply_.readXaPrepare(conn_);
0:             if ((callInfo.xaRetVal_ != XARETVAL_XAOK) &&
0:                     (callInfo.xaRetVal_ != XARETVAL_XARDONLY)) { // xaRetVal has possible error, format it
1:                 callInfo.xaFunction_ = XAFUNC_PREPARE;
1:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
0:                 callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
1:             }
1: 
1:             netAgent.endReadChain();
1:         } catch (SqlException sqle) {
0:             rc = XAException.XAER_RMERR;
0:             exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                     (sqle, exceptionsOnXA);
0:         } finally {
0:             conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
1:         }
1:         if (rc != XAResource.XA_OK) {
0:             throwXAException(rc, false);
1:         }
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceExit(this, "prepare", rc);
1:         }
1:         return rc;
1:     }
1: 
1:     /**
1:      * Obtain a list of prepared transaction branches from a resource manager. The transaction manager calls this method
1:      * during recovery to obtain the list of transaction branches that are currently in prepared or heuristically
1:      * completed states.
1:      *
1:      * @param flag One of TMSTARTRSCAN, TMENDRSCAN, TMNOFLAGS. TMNOFLAGS must be used when no other flags are set in
1:      *             flags.
1:      *
1:      * @return The resource manager returns zero or more XIDs for the transaction branches that are currently in a
1:      *         prepared or heuristically completed state. If an error occurs during the operation, the resource manager
1:      *         should raise the appropriate XAException.
1:      *
1:      * @throws XAException An error has occurred. Possible values are XAER_RMERR, XAER_RMFAIL, XAER_INVAL, and
1:      *                     XAER_PROTO.
1:      */
1:     public Xid[] recover(int flag) throws XAException {
1:         int rc = XAResource.XA_OK;
1:         NetAgent netAgent = conn_.netAgent_;
1: 
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceEntry(this, "recover", flag);
1:         }
1:         exceptionsOnXA = null;
0:         if (conn_.isClosed()) {
1:             connectionClosedFailure();
1:         }
1: 
1:         Xid[] xidList = null;
0:         int numXid = 0;
1: 
1:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:         callInfo.xaFlags_ = flag;
0:         callInfo.xaResource_ = this;
0:         callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
1:         try {
1:             netAgent.beginWriteChainOutsideUOW();
1:             // sent the recover PROTOCOL
1:             netAgent.netConnectionRequest_.writeXaRecover(conn_, flag);
1:             netAgent.flowOutsideUOW();
1:             netAgent.netConnectionReply_.readXaRecover(conn_);
0:             if (callInfo.xaRetVal_ != XARETVAL_XAOK) { // xaRetVal has possible error, format it
1:                 callInfo.xaFunction_ = XAFUNC_RECOVER;
1:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
0:                 callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
1:             }
1:             netAgent.endReadChain();
0:             if (conn_.indoubtTransactions_ != null) {
0:                 numXid = conn_.indoubtTransactions_.size();
0:                 xidList = new Xid[numXid];
0:                 int i = 0;
0:                 nextElement = 0;
0:                 for (Enumeration e = conn_.indoubtTransactions_.keys();
0:                      e.hasMoreElements(); i++) {
0:                     xidList[i] = (Xid) e.nextElement();
1:                 }
1:             }
1:         } catch (SqlException sqle) {
0:             rc = XAException.XAER_RMERR;
0:             exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                     (sqle, exceptionsOnXA);
0:         } finally {
0:             conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
1:         }
1:         if (rc != XAResource.XA_OK) {
0:             throwXAException(rc, false);
1:         }
1: 
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceExit(this, "recover", xidList);
1:         }
1:         return xidList;
1:     }
1: 
1:     /**
1:      * Inform the resource manager to roll back work done on behalf of a transaction branch
1:      *
1:      * @param xid A global transaction identifier
1:      *
1:      * @throws XAException An error has occurred
1:      */
1:     public void rollback(Xid xid) throws XAException {
1:         NetAgent netAgent = conn_.netAgent_;
1:         int rc = XAResource.XA_OK;
1:         exceptionsOnXA = null;
1: 
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceEntry(this, "rollback", xid);
1:         }
0:         if (conn_.isClosed()) {
1:             connectionClosedFailure();
1:         }
1: 
1:         // update the XACallInfo
1:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:         callInfo.xid_ = xid;
0:         callInfo.xaResource_ = this;
0:         callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
1:         try {
1:             netAgent.beginWriteChainOutsideUOW();
1:             netAgent.netConnectionRequest_.writeXaRollback(conn_, xid);
1:             netAgent.flowOutsideUOW();
1:             // read the reply to the rollback
1:             rc = netAgent.netConnectionReply_.readXaRollback(conn_);
1:             netAgent.endReadChain();
0:             if (callInfo.xaRetVal_ != XARETVAL_XAOK) { // xaRetVal has possible error, format it
1:                 callInfo.xaFunction_ = XAFUNC_END;
1:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
0:                 callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
1:             }
1:         } catch (SqlException sqle) {
0:             rc = XAException.XAER_RMERR;
0:             exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                     (sqle, exceptionsOnXA);
0:         } finally {
0:             conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
1:         }
1:         if (rc != XAResource.XA_OK) {
0:             throwXAException(rc, false);
1:         }
1: 
1:     }
1: 
1:     /**
0:      * <P>Set the current transaction timeout value for this <CODE>XAResource</CODE> instance. This value overwrites the
0:      * default transaction timeout value in the resource manager. The newly assigned timeout value is effective for the
0:      * life of this <CODE>XAResource</CODE> instance unless a new value is set.<P>
1:      *
0:      * @param the transaction timeout value in seconds.
1:      *
0:      * @throws XAException An error has occurred. Possible exception values are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.
1:      */
1:     public boolean setTransactionTimeout(int seconds) throws XAException {
1:         if (conn_.agent_.loggingEnabled()) {
0:             conn_.agent_.logWriter_.traceExit(this, "setTransactionTimeout", false);
1:         }
1:         exceptionsOnXA = null;
0:         return false; // we don't support transaction timeout in our layer.
0:         /* int rc = xaSetTransTimeOut(seconds);
0:            if (rc != XAResource.XA_OK)
0:              throwXAException(rc); */
1:     }
1: 
1:     /**
1:      * Start work on behalf of a transaction branch specified in xid
1:      *
1:      * @param xid   A global transaction identifier to be associated with the resource
1:      * @param flags One of TMNOFLAGS, TMJOIN, or TMRESUME
1:      *
1:      * @throws XAException An error has occurred. Possible exceptions   * are XA_RB*, XAER_RMERR, XAER_RMFAIL,
1:      *                     XAER_DUPID, XAER_OUTSIDE, XAER_NOTA, XAER_INVAL, or XAER_PROTO.
1:      */
1:     public synchronized void start(Xid xid, int flags) throws XAException {
1: 
1:         NetAgent netAgent = conn_.netAgent_;
1:         int rc = XAResource.XA_OK;
1:         exceptionsOnXA = null;
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceEntry(this, "start", xid, flags);
1:         }
0:         if (conn_.isClosed()) {
1:             connectionClosedFailure();
1:         }
1: 
1:         // update the XACallInfo
1:         NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
1:         callInfo.xaFlags_ = flags;
0:         callInfo.xaInProgress_ = true;
1:         callInfo.xid_ = xid;
0:         callInfo.xaResource_ = this;
0:         callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
1:         try {
1:             netAgent.beginWriteChainOutsideUOW();
1:             netAgent.netConnectionRequest_.writeXaStartUnitOfWork(conn_);
1:             netAgent.flowOutsideUOW();
1:             netAgent.netConnectionReply_.readXaStartUnitOfWork(conn_);
0:             if (callInfo.xaRetVal_ != XARETVAL_XAOK) { // xaRetVal has possible error, format it
1:                 callInfo.xaFunction_ = XAFUNC_START;
1:                 rc = xaRetValErrorAccumSQL(callInfo, rc);
0:                 callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
1:             }
1:             // Setting this is currently required to avoid client from sending
1:             // commit for autocommit.
0:             if (rc == XARETVAL_XAOK) {
0:                 conn_.setXAState(Connection.XA_ACTIVE);
1:             }
1: 
1:         } catch (SqlException sqle) {
0:             rc = XAException.XAER_RMERR;
0:             exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                     (sqle, exceptionsOnXA);
0:         } finally {
0:             conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
1:         }
1:         if (rc != XAResource.XA_OK) {
0:             throwXAException(rc, false);
1:         }
1:     }
0:     protected void throwXAException(int rc) throws XAException {
0:         // By default, throwXAException will reset the state of the failed connection
0:         throwXAException(rc, rc != XAException.XAER_NOTA);
1:     }
1:     private String getXAExceptionText(int rc) {
1:         String xaExceptionText;
1:         switch (rc) {
0:         case javax.transaction.xa.XAException.XA_RBROLLBACK:
1:             xaExceptionText = "XA_RBROLLBACK";
1:             break;
0:         case javax.transaction.xa.XAException.XA_RBCOMMFAIL:
1:             xaExceptionText = "XA_RBCOMMFAIL";
1:             break;
0:         case javax.transaction.xa.XAException.XA_RBDEADLOCK:
1:             xaExceptionText = "XA_RBDEADLOCK";
1:             break;
0:         case javax.transaction.xa.XAException.XA_RBINTEGRITY:
1:             xaExceptionText = "XA_RBINTEGRITY";
1:             break;
0:         case javax.transaction.xa.XAException.XA_RBOTHER:
1:             xaExceptionText = "XA_RBOTHER";
1:             break;
0:         case javax.transaction.xa.XAException.XA_RBPROTO:
1:             xaExceptionText = "XA_RBPROTO";
1:             break;
0:         case javax.transaction.xa.XAException.XA_RBTIMEOUT:
1:             xaExceptionText = "XA_RBTIMEOUT";
1:             break;
0:         case javax.transaction.xa.XAException.XA_RBTRANSIENT:
1:             xaExceptionText = "XA_RBTRANSIENT";
1:             break;
0:         case javax.transaction.xa.XAException.XA_NOMIGRATE:
1:             xaExceptionText = "XA_NOMIGRATE";
1:             break;
0:         case javax.transaction.xa.XAException.XA_HEURHAZ:
1:             xaExceptionText = "XA_HEURHAZ";
1:             break;
0:         case javax.transaction.xa.XAException.XA_HEURCOM:
1:             xaExceptionText = "XA_HEURCOM";
1:             break;
0:         case javax.transaction.xa.XAException.XA_HEURRB:
1:             xaExceptionText = "XA_HEURRB";
1:             break;
0:         case javax.transaction.xa.XAException.XA_HEURMIX:
1:             xaExceptionText = "XA_HEURMIX";
1:             break;
0:         case javax.transaction.xa.XAException.XA_RETRY:
1:             xaExceptionText = "XA_RETRY";
1:             break;
0:         case javax.transaction.xa.XAException.XA_RDONLY:
1:             xaExceptionText = "XA_RDONLY";
1:             break;
0:         case javax.transaction.xa.XAException.XAER_ASYNC:
1:             xaExceptionText = "XAER_ASYNC";
1:             break;
0:         case javax.transaction.xa.XAException.XAER_RMERR:
1:             xaExceptionText = "XAER_RMERR";
1:             break;
0:         case javax.transaction.xa.XAException.XAER_NOTA:
1:             xaExceptionText = "XAER_NOTA";
1:             break;
0:         case javax.transaction.xa.XAException.XAER_INVAL:
1:             xaExceptionText = "XAER_INVAL";
1:             break;
0:         case javax.transaction.xa.XAException.XAER_PROTO:
1:             xaExceptionText = "XAER_PROTO";
1:             break;
0:         case javax.transaction.xa.XAException.XAER_RMFAIL:
1:             xaExceptionText = "XAER_RMFAIL";
1:             break;
0:         case javax.transaction.xa.XAException.XAER_DUPID:
1:             xaExceptionText = "XAER_DUPID";
1:             break;
0:         case javax.transaction.xa.XAException.XAER_OUTSIDE:
1:             xaExceptionText = "XAER_OUTSIDE";
1:             break;
1:         case XAResource.XA_OK:
1:             xaExceptionText = "XA_OK";
1:             break;
1:         default:
1:             xaExceptionText = "Unknown Error";
1:             break;
1:         }
1:         return xaExceptionText;
1:     }
1: 
0:     protected void throwXAException(int rc, boolean resetFlag) throws XAException { // ~~~
1:         String xaExceptionText;
0:         if (resetFlag) {
0:             // reset the state of the failed connection
1:             NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0:             callInfo.xaInProgress_ = false;
0:             callInfo.xaWasSuspended = false;
0:             callInfo.xaState_ = Connection.XA_OPEN_IDLE;
0:             conn_.setXAState(Connection.XA_OPEN_IDLE);
1:         }
1: 
0:         xaExceptionText = getXAExceptionText(rc);
1:         // save the SqlException chain to add it to the XAException
0:         org.apache.derby.client.am.SqlException sqlExceptions = exceptionsOnXA;
1: 
1:         while (exceptionsOnXA != null) { // one or more SqlExceptions received, format them
0:             xaExceptionText = xaExceptionText + " : " + exceptionsOnXA.getMessage();
0:             exceptionsOnXA = (org.apache.derby.client.am.SqlException)
1:                     exceptionsOnXA.getNextException();
1:         }
0:         org.apache.derby.client.am.XaException xaException =
0:                 new org.apache.derby.client.am.XaException(conn_.agent_.logWriter_,
0:                         sqlExceptions,
0:                         xaExceptionText);
1:         xaException.errorCode = rc;
1:         throw xaException;
1:     }
1: 
1:     public boolean isSameRM(XAResource xares) throws XAException {
1:         boolean isSame = false; // preset that the RMs are NOT the same
1:         exceptionsOnXA = null;
1: 
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceEntry(this, "isSameRM", xares);
1:         }
0:         if (conn_.isClosed()) {
1:             connectionClosedFailure();
1:         }
1: 
0:         if (xares instanceof org.apache.derby.client.net.NetXAResource) { // both are NetXAResource so check to see if this is the same RM
0:             // remember, isSame is initialized to false
1:             NetXAResource derbyxares = (NetXAResource) xares;
1:             while (true) {
1:                 if (!conn_.databaseName_.equalsIgnoreCase(derbyxares.conn_.databaseName_)) {
1:                     break; // database names are not equal, not same RM
1:                 }
1:                 if (!conn_.netAgent_.server_.equalsIgnoreCase
1:                         (derbyxares.conn_.netAgent_.server_)) { // server name strings not equal, compare IP addresses
1:                     try {
1:                         // 1st convert "localhost" to actual server name
1:                         String server1 = this.processLocalHost(conn_.netAgent_.server_);
1:                         String server2 =
1:                                 this.processLocalHost(derbyxares.conn_.netAgent_.server_);
1:                         // now convert the server name to ip address
1:                         InetAddress serverIP1 = InetAddress.getByName(server1);
1:                         InetAddress serverIP2 = InetAddress.getByName(server2);
1:                         if (!serverIP1.equals(serverIP2)) {
1:                             break; // server IPs are not equal, not same RM
1:                         }
1:                     } catch (UnknownHostException ue) {
1:                         break;
1:                     }
1:                 }
1:                 if (conn_.netAgent_.port_ != derbyxares.conn_.netAgent_.port_) {
1:                     break; // ports are not equal, not same RM
1:                 }
1:                 isSame = true; // everything the same, set RMs are the same
1:                 break;
1:             }
1:         }
1: 
1:         if (conn_.agent_.loggingEnabled()) {
1:             conn_.agent_.logWriter_.traceExit
1:                     (this, "isSameRM", isSame);
1:         }
1:         return isSame;
1:     }
1: 
1:     public static boolean xidsEqual(Xid xid1, Xid xid2) { // determine if the 2 xids contain the same values even if not same object
1:         // comapre the format ids
1:         if (xid1.getFormatId() != xid2.getFormatId()) {
1:             return false; // format ids are not the same
1:         }
1: 
1:         // compare the global transaction ids
1:         int xid1Length = xid1.getGlobalTransactionId().length;
1:         if (xid1Length != xid2.getGlobalTransactionId().length) {
1:             return false; // length of the global trans ids are not the same
1:         }
1:         byte[] xid1Bytes = xid1.getGlobalTransactionId();
1:         byte[] xid2Bytes = xid2.getGlobalTransactionId();
1:         int i;
1:         for (i = 0; i < xid1Length; ++i) { // check all bytes are the same
1:             if (xid1Bytes[i] != xid2Bytes[i]) {
1:                 return false; // bytes in the global trans ids are not the same
1:             }
1:         }
1: 
1:         // compare the branch qualifiers
1:         xid1Length = xid1.getBranchQualifier().length;
1:         if (xid1Length != xid2.getBranchQualifier().length) {
1:             return false; // length of the global trans ids are not the same
1:         }
1:         xid1Bytes = xid1.getBranchQualifier();
1:         xid2Bytes = xid2.getBranchQualifier();
1:         for (i = 0; i < xid1Length; ++i) { // check all bytes are the same
1:             if (xid1Bytes[i] != xid2Bytes[i]) {
1:                 return false; // bytes in the global trans ids are not the same
1:             }
1:         }
1: 
1:         return true; // all of the fields are the same, xid1 == xid2
1:     }
1: 
1: 
0:     // KATHEY remove
0:     protected void makeEntryCurrent(int offset) throws SqlException {
0:         int currOffset = conn_.currXACallInfoOffset_; // offset of current XACallInfo
0:         NetXACallInfo newCallInfo = callInfoArray_[offset];
1:         if (conn_.agent_.loggingEnabled()) {
0:             conn_.agent_.logWriter_.traceEntry
0:                     (this, "makeEntryCurrent", offset, currOffset);
1:         }
1: 
0:         if (currOffset == offset) { // entry is already current
0:             if (newCallInfo.convReleased_ &&
0:                     !newCallInfo.xaInProgress_) { // connection reuse, XA is not in Progress, reset connection
0: // transaction pooling
0:                 newCallInfo.convReleased_ = false;
0:                 if (!conn_.resetConnectionAtFirstSql_) { // resetConnectionAtFirstSql_ is false
1: /*
/////////////////////////////////////////////////////////////////////////
0:                     conn_.resetConnectionAtFirstSql_ = true;
0:                     conn_.writeDeferredReset();
1:                 }
1:             }
0:             return; // entry is already current, nothing to do
0:         callInfoArray_[currOffset].currConnection_ = false; // reset old current conn
0:         callInfoArray_[currOffset].xaState_ = conn_.getXAState(); // save XA state
0:         callInfoArray_[currOffset].freeEntry_ = false; // set entry in use
0: // set the new entry as the current entry, update conn_
0:         newCallInfo.currConnection_ = true;
0:         conn_.currXACallInfoOffset_ = offset;
0:         conn_.setXAState(newCallInfo.xaState_);
0:         if (newCallInfo.convReleased_ &&
0:                 !newCallInfo.xaInProgress_) { // connection reuse, XA is not in Progress, reset connection
0: // transaction pooling
0:             newCallInfo.convReleased_ = false;
0:             if (!conn_.resetConnectionAtFirstSql_) { // resetConnectionAtFirstSql_ is false
0: /*
/////////////////////////////////////////////////////////////////////////
0:                 conn_.resetConnectionAtFirstSql_ = true;
0:                 conn_.writeDeferredReset();
1:         }
1: 
0:         if (conn_.agent_.loggingEnabled()) { // logging enabled
0:             conn_.agent_.logWriter_.traceExit(this, "makeEntryCurrent", offset);
1:         }
1:     }
1: 
1: 
0:     public List getSpecialRegisters() {
0:         return specialRegisters_;
1:     }
1: 
0:     public void addSpecialRegisters(String s) {
0:         if (s.substring(0, 1).equals("@")) {
0:             // SET statement is coming from Client
0:             if (specialRegisters_.remove(s.substring(1))) {
0:                 specialRegisters_.remove(s);
0:                 specialRegisters_.add(s.substring(1));
0:             } else {
0:                 specialRegisters_.remove(s);
0:                 specialRegisters_.add(s);
0:         } else { // SET statement is coming from Server
0:             specialRegisters_.remove(s);
0:             specialRegisters_.add(s);
1: 
1:     private void connectionClosedFailure() throws XAException { // throw an XAException XAER_RMFAIL, with a chained SqlException - closed
0:         exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                 (new SqlException(null, "Connection is Closed."),
1:                         exceptionsOnXA);
0:         throwXAException(javax.transaction.xa.XAException.XAER_RMFAIL);
1:     private String getXAFuncStr(int xaFunc) {
1:         switch (xaFunc) {
1:         case XAFUNC_COMMIT:
1:             return XAFUNCSTR_COMMIT;
1:         case XAFUNC_END:
1:             return XAFUNCSTR_END;
1:         case XAFUNC_FORGET:
1:             return XAFUNCSTR_FORGET;
1:         case XAFUNC_PREPARE:
1:             return XAFUNCSTR_PREPARE;
1:         case XAFUNC_RECOVER:
1:             return XAFUNCSTR_RECOVER;
1:         case XAFUNC_ROLLBACK:
1:             return XAFUNCSTR_ROLLBACK;
1:         case XAFUNC_START:
1:             return XAFUNCSTR_START;
1:         return XAFUNCSTR_NONE;
1:     }
1: 
1:     protected int xaRetValErrorAccumSQL(NetXACallInfo callInfo, int currentRC) {
0:         int rc;
0:         switch (callInfo.xaRetVal_) {
0:         case XARETVAL_XAOK:
0:         case XARETVAL_NODISSOCIATE:
0:             rc = XAResource.XA_OK;
0:             break;
0:         case XARETVAL_XALCSNOTSUPP:
0:             rc = XAResource.XA_OK;
0:             break;
0:         case XARETVAL_RBROLLBACK:
0:             rc = XAException.XA_RBROLLBACK;
0:             break;
0:         case XARETVAL_RBOTHER:
0:             rc = XAException.XA_RBOTHER;
0:             break;
0:         case XARETVAL_RBDEADLOCK:
0:             rc = XAException.XA_RBDEADLOCK;
0:             break;
0:         case XARETVAL_RBPROTO:
0:             rc = XAException.XA_RBPROTO;
0:             break;
0:         case XARETVAL_XAERPROTO:
0:             rc = XAException.XAER_PROTO;
0:             break;
0:         case XARETVAL_XARDONLY:
0:             rc = XAException.XA_RDONLY;
0:             break;
0:         case XARETVAL_XAHEURCOM:
0:             rc = XAException.XA_HEURCOM;
0:             break;
0:         case XARETVAL_XAHEURRB:
0:             rc = XAException.XA_HEURRB;
0:             break;
0:         case XARETVAL_XAERDUPID:
0:             rc = XAException.XAER_DUPID;
0:             break;
0:         case XARETVAL_XAERNOTA:
0:             rc = XAException.XAER_NOTA;
0:             break;
0:         case XARETVAL_XAERRMERR:
0:             rc = XAException.XAER_RMERR;
0:             break;
0:         case XARETVAL_XAERRMFAIL:
0:             rc = XAException.XAER_RMFAIL;
0:             break;
0:         case XARETVAL_XAERINVAL:
0:             rc = XAException.XAER_INVAL;
0:             break;
0:         default:
0:             rc = XAException.XAER_RMFAIL;
0:             break;
1:         }
1: 
1:         if (rc != XAResource.XA_OK) { // error was detected
1:             // create an SqlException to report this error within
0:             String xaRetValStr = "Error executing a " +
0:                     getXAFuncStr(callInfo.xaFunction_) + ", " +
0:                     "Server returned " + getXAExceptionText(rc);
1:             SqlException accumSql = new SqlException(conn_.netAgent_.logWriter_,
0:                     xaRetValStr, org.apache.derby.client.am.SqlState.undefined,
0:                     org.apache.derby.client.am.SqlCode.queuedXAError);
0:             exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
1:                     (accumSql, exceptionsOnXA);
1: 
1:             if (currentRC != XAResource.XA_OK) { // the rc passed into this function had an error also, prioritize error
1:                 if (currentRC < 0) { // rc passed in was a major error use it instead of current error
1:                     return currentRC;
1:                 }
1:             }
1:         }
1:         return rc;
1:     }
1: 
1:     private String processLocalHost(String serverName) {
1:         if (serverName.equalsIgnoreCase("localhost")) { // this is a localhost, find hostname
1:             try {
1:                 InetAddress localhostNameIA = InetAddress.getLocalHost();
1:                 String localhostName = localhostNameIA.getHostName();
1:                 return localhostName;
1:             } catch (SecurityException se) {
1:                 return serverName;
1:             } catch (UnknownHostException ue) {
1:                 return serverName;
1:             }
1:         }
1:         // not "localhost", return original server name
1:         return serverName;
1:     }
1: 
0:     protected void removeXaresFromSameRMchain() {
0:         // check all NetXAResources on the same RM for the NetXAResource to remove
1:         try {
0:             this.ignoreMe_ = true; // use the ignoreMe_ flag to indicate the
0:             // XAResource to remove
0:             NetXAResource prevXAResource = null;
0:             NetXAResource currXAResource;
0:             synchronized (xaResourceSameRMGroup_) { // make sure no one changes this vector list
0:                 currXAResource = (NetXAResource) xaResourceSameRMGroup_.elementAt(sameRMGroupIndex_);
0:                 while (currXAResource != null) { // is this the XAResource to remove?
0:                     if (currXAResource.ignoreMe_) { // this NetXAResource is the one to remove
0:                         if (prevXAResource != null) { // this XAResource is not first in chain, just move next to prev
0:                             prevXAResource.nextSameRM_ = currXAResource.nextSameRM_;
0:                         } else { // this XAResource is  first in chain, just move next to root
0:                             xaResourceSameRMGroup_.set(sameRMGroupIndex_,
0:                                     currXAResource.nextSameRM_);
1:                         }
0:                         return;
1:                     }
0:                     // this is not the NetXAResource to remove, try the next one
0:                     prevXAResource = currXAResource;
0:                     currXAResource = currXAResource.nextSameRM_;
1:                 }
1:             }
0:         } finally {
0:             this.ignoreMe_ = false;
1:         }
1:     }
1: 
1: 
0:     public void initForReuse() {
0:         // add this new XAResource to the list of other XAResources for the Same RM
0:         // first find out if there are any other XAResources for the same RM
0:         // then check to make sure it is not already in the chain
0:         synchronized (xaResourceSameRMGroup_) { // make sure no one changes this vector list
0:             int groupCount = xaResourceSameRMGroup_.size();
0:             int index = 0;
0:             int firstFreeElement = -1;
0:             NetXAResource xaResourceGroup = null;
1: 
0:             for (; index < groupCount; ++index) { // check if this group is the same RM
0:                 xaResourceGroup = (NetXAResource) xaResourceSameRMGroup_.elementAt(index);
0:                 if (xaResourceGroup == null) { // this is a free element, save its index if first found
0:                     if (firstFreeElement == -1) { // first free element, save index
0:                         firstFreeElement = index;
1:                     }
0:                     continue; // go to next element
1:                 }
1:                 try {
0:                     if (xaResourceGroup.isSameRM(this)) { // it is the same RM add this XAResource to the chain if not there
0:                         NetXAResource nextXares = (NetXAResource)
0:                                 xaResourceSameRMGroup_.elementAt(sameRMGroupIndex_);
0:                         while (nextXares != null) { // is this NetXAResource the one we are trying to add?
0:                             if (nextXares.equals(this)) { // the XAResource to be added already is in chain, don't add
0:                                 break;
1:                             }
0:                             // Xid was not on that NetXAResource, try the next one
0:                             nextXares = nextXares.nextSameRM_;
1:                         }
1: 
0:                         if (nextXares == null) { // XAResource to be added is not in the chain already, add it
0:                             // add it at the head of the chain
0:                             sameRMGroupIndex_ = index;
0:                             this.nextSameRM_ = xaResourceGroup.nextSameRM_;
0:                             xaResourceGroup.nextSameRM_ = this;
1:                         }
0:                         return; // done
1:                     }
0:                 } catch (XAException xae) {
1:                 }
0:             // no other same RM was found, add this as first of new group
0:             if (firstFreeElement == -1) { // no free element found, add new element to end
0:                 xaResourceSameRMGroup_.add(this);
0:                 sameRMGroupIndex_ = groupCount;
0:             } else { // use first free element found
0:                 xaResourceSameRMGroup_.setElementAt(this, firstFreeElement);
0:                 sameRMGroupIndex_ = firstFreeElement;
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class org.apache.derby.client.net.NetXAResource
1: 
0:    Copyright (c) 2003, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0: */
1: /**********************************************************************
1:  *
1:  *
1:  *  Component Name =
1:  *
1:  *      Package Name = org.apache.derby.client.net
1:  *
1:  *  Descriptive Name = class implements XAResource
1:  *
1:  *  Status = New code
1:  *
1:  *  Function = Handle XA methods
1:  *
1:  *  List of Classes
1:  *              - NetXAResource
1:  *
1:  *  Restrictions : None
1:  *
1:  **********************************************************************/
1: package org.apache.derby.client.net;
1: 
0: import org.apache.derby.client.net.NetXACallInfo;
0: import org.apache.derby.client.am.Connection;
0: import org.apache.derby.client.am.SqlException;
0: import java.util.*;
0: import org.apache.derby.client.ClientXid;
0: import javax.transaction.xa.*;
0: import javax.sql.*;
1: import java.net.InetAddress;
1: import java.net.UnknownHostException;
1: 
0: public class NetXAResource implements XAResource
0: {
0:   public static final int TMTIMEOUT = 0x00000100;
0:   public static final int ACTIVE_ONLY = -1;
0:   public static final int XA_NULL_XID = -1; // null Xid has Format Id of -1
0:   public static final int INITIAL_CALLINFO_ELEMENTS = 1;
0:   public static final int RECOVER_XID_ARRAY_LENGTH  = 10;
0:   public static final ClientXid nullXid = new ClientXid();
1: 
0:   // xaretval defines
0:   public static final int XARETVAL_XALCSNOTSUPP	= 99; // Loosely Coupled Not Supported
0:   public static final int XARETVAL_RBROLLBACK   = 100; // Rollback
0:   public static final int XARETVAL_RBCOMMFAIL   = 101; // Rollback Communication Failure
0:   public static final int XARETVAL_RBDEADLOCK   = 102; // Rollback Deadlock
0:   public static final int XARETVAL_RBINTEGRITY  = 103; // Rollback integrity violation
0:   public static final int XARETVAL_RBOTHER      = 104; // Rollback Other
0:   public static final int XARETVAL_RBPROTO      = 105; // Rollback Protocol
0:   public static final int XARETVAL_RBTIMEOUT    = 106; // Rollback Timeout
0:   public static final int XARETVAL_RBTRANSIENT  = 107; // Rollback Transaction branch
0:   public static final int XARETVAL_NODISSOCIATE = 108; // Unable to Dissociate resources from connection
0:   public static final int XARETVAL_XATWOPHASE   = 13; // TwoPhase commit required
0:   public static final int XARETVAL_XAPROMOTED   = 12; // Promoted - unused
0:   public static final int XARETVAL_XADEFERRED   = 11; // Deferred - unused
0:   public static final int XARETVAL_XACOMMFAIL   = 10; // Communication Failure
0:   public static final int XARETVAL_XANOMIGRATE  = 9; // No Migration
0:   public static final int XARETVAL_XAHEURHAZ    = 8; // Heuristically completed
0:   public static final int XARETVAL_XAHEURCOM    = 7; // Heuristically Commited
0:   public static final int XARETVAL_XAHEURRB     = 6; // Heuristically Rolledback
0:   public static final int XARETVAL_XAHEURMIX    = 5; // Branch heuristically commit and rollback
0:   public static final int XARETVAL_XARETRY      = 4; // Retry Commit
0:   public static final int XARETVAL_XARDONLY     = 3; // Read Only
0:   public static final int XARETVAL_XAOK         = 0; // OK
0:   public static final int XARETVAL_XAERASYNC    = -2; // Async Request not possible
0:   public static final int XARETVAL_XAERRMERR    = -3; // RM Error
0:   public static final int XARETVAL_XAERNOTA     = -4; // XID does not exist
0:   public static final int XARETVAL_XAERINVAL    = -5; // Invalid arguments
0:   public static final int XARETVAL_XAERPROTO    = -6; // Protocol Violation
0:   public static final int XARETVAL_XAERRMFAIL   = -7; // RM Failed
0:   public static final int XARETVAL_XAERDUPID    = -8; // Duplicate XID
0:   public static final int XARETVAL_XAEROUTSIDE  = -9; // Local tansaction active
0:   public static final int XARETVAL_XAEROPENRES  = -10; // Open resources
1: 
0:   // xaFunction defines, shows which queued XA function is being performed
0:   public static final int XAFUNC_NONE           = 0;
0:   public static final int XAFUNC_COMMIT         = 1;
0:   public static final int XAFUNC_END            = 2;
0:   public static final int XAFUNC_FORGET         = 3;
0:   public static final int XAFUNC_PREPARE        = 4;
0:   public static final int XAFUNC_RECOVER        = 5;
0:   public static final int XAFUNC_ROLLBACK       = 6;
0:   public static final int XAFUNC_START          = 7;
0:   public static final String XAFUNCSTR_NONE     = "No XA Function";
0:   public static final String XAFUNCSTR_COMMIT   = "XAResource.commit()";
0:   public static final String XAFUNCSTR_END      = "XAResource.end()";
0:   public static final String XAFUNCSTR_FORGET   = "XAResource.forget()";
0:   public static final String XAFUNCSTR_PREPARE  = "XAResource.prepare()";
0:   public static final String XAFUNCSTR_RECOVER  = "XAResource.recover()";
0:   public static final String XAFUNCSTR_ROLLBACK = "XAResource.rollback()";
0:   public static final String XAFUNCSTR_START    = "XAResource.start()";
1: 
0:   public int nextElement = 0;
1: 
0:   // XAResources with same RM group list
0:   protected static Vector xaResourceSameRMGroup_ = new Vector();
0:   protected int sameRMGroupIndex_ = 0;
0:   protected NetXAResource nextSameRM_ = null;
0:   protected boolean ignoreMe_ = false;
1: 
0:   /* KATHEY CHECK THIS COMMENT TOO. 
0:    * Need to remove NetXAResource objects from this group when they are
0:    *  freed.
0:    */
1: 
0:   public org.apache.derby.client.am.SqlException exceptionsOnXA = null;
1: 
0:   XAConnection xaconn_;
0:   org.apache.derby.client.net.NetXAConnection conn_;
0:   int rmId_; // unique RmId generated by XAConnection
0: 	// KATHEY change to a single callInfo field (not an array)
0:   NetXACallInfo callInfoArray_[] =
0:       new NetXACallInfo[INITIAL_CALLINFO_ELEMENTS];
0:   int numXACallInfo_ = INITIAL_CALLINFO_ELEMENTS;
0:   int connectionCount_ = 1;
0:   int activeXATransCount_ = 0;
0:   String rmIdx_; // userid in case we need to create a secondary connection
0:   String rmIdy_; // password in case we need to create a secondary connection
0: 	// KATHEY remove port and ipaddr_
0:   int port_;     // port needed to make secondary connection for recover in DS mode.
0:   String ipaddr_;  // ip address needed to make secondary connection for recover in DS mode.
1: 
0:   private List specialRegisters_ = Collections.synchronizedList(new LinkedList());
0:   public NetXAResource( XAConnection xaconn, int rmId,
0:                        String userId, String password,
0:                        org.apache.derby.client.net.NetXAConnection conn )
0:   {
0:     xaconn_ = xaconn;
0:     rmId_ = rmId;
0:     conn_ = conn;
0:     rmIdx_ = userId;
0:     rmIdy_ = password;
0:     port_ = conn.netAgent_.getPort();
0:     ipaddr_ = conn.netAgent_.socket_.getLocalAddress().getHostAddress();
0:     conn.setNetXAResource(this);
1: 
0:     // link the primary connection to the first XACallInfo element
0:     conn_.currXACallInfoOffset_ = 0;
1: 
0:     // construct the NetXACallInfo object for the array.
0:     for (int i = 0; i < INITIAL_CALLINFO_ELEMENTS; ++i)
0:       callInfoArray_[i] = new NetXACallInfo(null,XAResource.TMNOFLAGS,
0:                                            Connection.XA_OPEN_IDLE, this,
0:                                            null);
1: 
0:     // initialize the first XACallInfo element with the information from the
0:     //  primary connection
0:     callInfoArray_[0].actualConn_ = conn_;
0:     callInfoArray_[0].currConnection_ = true;
0:     callInfoArray_[0].freeEntry_ = false;
0:     // ~~~ save conn_ connection variables in callInfoArray_[0]
0:     callInfoArray_[0].saveConnectionVariables();
1: 
0:     // add this new XAResource to the list of other XAResources for the Same RM
0:     initForReuse();
0:   }
1: 
0:   public void commit( Xid xid, boolean onePhase ) throws XAException
0:   {
0: 	NetAgent netAgent = conn_.netAgent_;
0: 	int rc = XAResource.XA_OK;
1: 
0: 	exceptionsOnXA = null;
0: 	if (conn_.agent_.loggingEnabled())
0: 	  conn_.agent_.logWriter_.traceEntry (this, "commit", xid, onePhase);
0: 	if( conn_.isClosed() )
0: 	  connectionClosedFailure();
1: 
0: 	// update the XACallInfo
0: 	NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0: 	callInfo.xaFlags_ = ( onePhase ? XAResource.TMONEPHASE:
0: 						  XAResource.TMNOFLAGS);
0: 	callInfo.xid_ = xid;
0: 	callInfo.xaResource_ = this;
0: 	callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
0: 	try {
0: 	  netAgent.beginWriteChainOutsideUOW();
0: 	  netAgent.netConnectionRequest_.writeXaCommit(conn_, xid);
0: 	  netAgent.flowOutsideUOW();
0: 	  netAgent.netConnectionReply_.readXaCommit(conn_);
0: 	  if( callInfo.xaRetVal_ != XARETVAL_XAOK )
0:           { // xaRetVal has possible error, format it
0:             callInfo.xaFunction_ = XAFUNC_COMMIT;
0:             rc = xaRetValErrorAccumSQL( callInfo, rc );
0:             callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
0:           }
0: 	  netAgent.endReadChain();
0: 	}
0: 	catch( SqlException sqle )
0: 	{
0: 	  rc = XAException.XAER_RMERR;
0: 	  exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0: 		(sqle, exceptionsOnXA);
0: 	}
0: 	finally
0: 	{
0: 	  conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
0: 	}
0: 	if (rc != XAResource.XA_OK)
0: 		throwXAException(rc, false);
0:   }
1: 
0:   /** Ends the work performed on behalf of a transaction branch.
0:    * The resource manager dissociates the XA resource from the
0:    * transaction branch specified and let the transaction be
0:    * completed.
1:    *
0:    * If TMSUSPEND is specified in flags, the transaction branch
0:    * is temporarily suspended in incomplete state. The transaction
0:    * context is in suspened state and must be resumed via start
0:    * with TMRESUME specified.
1:    *
0:    * If TMFAIL is specified, the portion of work has failed.
0:    * The resource manager may mark the transaction as rollback-only
1:    *
0:    * If TMSUCCESS is specified, the portion of work has completed
0:    * successfully.
1:    *
0:    * @param xid A global transaction identifier that is the same as
0:    * what was used previously in the start method.
1:    *
0:    * @param flags One of TMSUCCESS, TMFAIL, or TMSUSPEND
1:    *
0:    * @exception XAException An error has occurred. Possible XAException
0:    * values are XAER_RMERR, XAER_RMFAILED, XAER_NOTA, XAER_INVAL,
0:    * XAER_PROTO, or XA_RB*.
0:    */
1: 
0:   public void end( Xid xid, int flags ) throws XAException
0:   {
1: 
0: 	NetAgent netAgent = conn_.netAgent_;
0: 	int rc = XAResource.XA_OK;
0:     exceptionsOnXA = null;
0: 	if (conn_.agent_.loggingEnabled())
0:       conn_.agent_.logWriter_.traceEntry (this, "end", xid, flags);
0:     if( conn_.isClosed() )
0:       connectionClosedFailure();
1: 
0:     NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0:     callInfo.setReadOnlyTransactionFlag(conn_.readOnlyTransaction_);
0: 	callInfo.xaFlags_ = flags;
0: 	callInfo.xid_ = xid;
0: 	callInfo.xaResource_ = this;
0:     callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
0: 	try
0: 	{
0: 	  netAgent.beginWriteChainOutsideUOW();
0: 	  netAgent.netConnectionRequest_.writeXaEndUnitOfWork(conn_);
0: 	  netAgent.flowOutsideUOW();
0: 	  rc = netAgent.netConnectionReply_.readXaEndUnitOfWork(conn_);
0: 	  conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending end
0: 	  if( callInfo.xaRetVal_ != XARETVAL_XAOK )
0: 	  { // xaRetVal has possible error, format it
0: 		callInfo.xaFunction_ = XAFUNC_END;
0: 		rc = xaRetValErrorAccumSQL( callInfo, rc );
0: 		callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
0: 	  }
0: 	  netAgent.endReadChain();
0: 	}
0: 	catch( SqlException sqle )
0: 	{
0: 	  rc = XAException.XAER_RMERR;
0: 	  exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0: 		(sqle, exceptionsOnXA);
0: 	}
0: 	finally
0: 	{
0: 	  conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
0: 	}
0: 	if (rc != XAResource.XA_OK)
0: 	  throwXAException(rc, false);
0: 	else
0: 		conn_.setXAState(Connection.XA_ENDED);
1: 
0:   }
1: 
0:   /** Tell the resource manager to forget about a heuristically (MANUALLY)
0:    * completed transaction branch.
1:    *
0:    * @param xid A global transaction identifier
1:    *
0:    * @exception XAException An error has occurred. Possible exception
0:    * values are XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or
0:    * XAER_PROTO.
0:    */
1: 
0:   public void forget (Xid xid) throws XAException
0:   {
0: 	NetAgent netAgent = conn_.netAgent_;
0: 	int rc = XAResource.XA_OK;
0:     exceptionsOnXA = null;
1: 
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceEntry (this, "forget", xid);
0:     if( conn_.isClosed() )
0:       connectionClosedFailure();
0: 	NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0: 	callInfo.xid_ = xid;
0: 	callInfo.xaResource_ = this;
0: 	callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
0: 	try
0:     {
0: 	  // flow the required PROTOCOL to the server
0:       netAgent.beginWriteChainOutsideUOW();
1: 
0:       // sent the commit PROTOCOL
0:       netAgent.netConnectionRequest_.writeXaForget(netAgent.netConnection_, xid);
1: 
0:       netAgent.flowOutsideUOW();
1: 
0:       // read the reply to the commit
0:       netAgent.netConnectionReply_.readXaForget(netAgent.netConnection_);
1: 
0:       netAgent.endReadChain();
0: 	  if( callInfo.xaRetVal_ != XARETVAL_XAOK )
0: 	  { // xaRetVal has possible error, format it
0: 		callInfo.xaFunction_ = XAFUNC_FORGET;
0: 		rc = xaRetValErrorAccumSQL( callInfo, rc );
0: 		callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
0: 	  }
0:     }
0:     catch( SqlException sqle )
0:     {
0:       exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                       (sqle, exceptionsOnXA);
0:       throwXAException(XAException.XAER_RMERR);
0:     }
0:     finally {
0: 	conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
0: 	}
0: 	if (rc != XAResource.XA_OK)
0: 	  throwXAException(rc, false);
1: 
0:   }
1: 
0:   /** Obtain the current transaction timeout value set for this
0:    * XAResource instance. If <CODE>XAResource.setTransactionTimeout</CODE>
0:    * was not use prior to invoking this method, the return value
0:    * is the default timeout set for the resource manager; otherwise,
0:    * the value used in the previous <CODE>setTransactionTimeout</CODE> call is
0:    * returned.
1:    *
0:    * @return the transaction timeout value in seconds.
1:    *
0:    * @exception XAException An error has occurred. Possible exception
0:    * values are XAER_RMERR, XAER_RMFAIL.
0:    */
0:   public int getTransactionTimeout() throws XAException
0:   {
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceEntry (this, "getTransactionTimeout");
0:     exceptionsOnXA = null;
0:     if( conn_.isClosed() )
0:       connectionClosedFailure();
1: 
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceExit (this, "getTransactionTimeout", 0);
0:     return 0; // we don't support transaction timeout
0:   }
1: 
0:   /** Ask the resource manager to prepare for a transaction commit
0:    * of the transaction specified in xid.
1:    *
0:    * @param xid A global transaction identifier
1:    *
0:    * @exception XAException An error has occurred. Possible exception
0:    * values are: XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL,
0:    * or XAER_PROTO.
1:    *
0:    * @return A value indicating the resource manager's vote on the
0:    * outcome of the transaction. The possible values are: XA_RDONLY
0:    * or XA_OK. If the resource manager wants to roll back the
0:    * transaction, it should do so by raising an appropriate XAException
0:    * in the prepare method.
0:    */
0:   public int prepare(Xid xid) throws XAException
0:   { // public interface for prepare
0:     // just call prepareX with the recursion flag set to true
0:     exceptionsOnXA = null;
1: 
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceEntry (this, "prepare", xid);
0:     if( conn_.isClosed() )
0:       connectionClosedFailure();
1: 
0: 	/// update the XACallInfo
0: 	NetAgent netAgent = conn_.netAgent_;
0: 	int rc = XAResource.XA_OK;
0: 	NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0: 	callInfo.xid_ = xid;
0: 	callInfo.xaResource_ = this;
0: 	callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
0: 	try {
0: 	     netAgent.beginWriteChainOutsideUOW();
0: 		  // sent the prepare PROTOCOL
0: 		 netAgent.netConnectionRequest_.writeXaPrepare(conn_);
0: 		 netAgent.flowOutsideUOW();
1: 
0: 		 // read the reply to the prepare
0: 		 rc = netAgent.netConnectionReply_.readXaPrepare(conn_);
0: 		 if( (callInfo.xaRetVal_ != XARETVAL_XAOK) &&
0: 			 (callInfo.xaRetVal_ != XARETVAL_XARDONLY) )
0: 		 { // xaRetVal has possible error, format it
0: 		   callInfo.xaFunction_ = XAFUNC_PREPARE;
0: 		   rc = xaRetValErrorAccumSQL( callInfo, rc );
0: 		   callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
0: 		 }
1: 
0: 		 netAgent.endReadChain();
0: 	}
0: 	catch( SqlException sqle )
0: 	{
0: 	  rc = XAException.XAER_RMERR;
0: 	  exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0: 		(sqle, exceptionsOnXA);
0: 	}
0: 	finally
0: 	{
0: 	  conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
0: 	}
0: 	if (rc != XAResource.XA_OK)
0: 		throwXAException(rc, false);
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceExit (this, "prepare", rc);
0:     return rc;
0:   }
1: 
0:   /** Obtain a list of prepared transaction branches from a resource
0:    * manager. The transaction manager calls this method during recovery
0:    * to obtain the list of transaction branches that are currently in
0:    * prepared or heuristically completed states.
1:    *
0:    * @param flag One of TMSTARTRSCAN, TMENDRSCAN, TMNOFLAGS. TMNOFLAGS
0:    * must be used when no other flags are set in flags.
1:    *
0:    * @exception XAException An error has occurred. Possible values are
0:    * XAER_RMERR, XAER_RMFAIL, XAER_INVAL, and XAER_PROTO.
1:    *
0:    * @return The resource manager returns zero or more XIDs for the
0:    * transaction branches that are currently in a prepared or
0:    * heuristically completed state. If an error occurs during the
0:    * operation, the resource manager should raise the appropriate
0:    * XAException.
1:    *
0:    */
0:   public Xid[] recover(int flag) throws XAException
0:   {
0:     int rc = XAResource.XA_OK;
0:     NetAgent netAgent = conn_.netAgent_;
1: 
0: 	if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceEntry (this, "recover", flag);
0:     exceptionsOnXA = null;
0:     if( conn_.isClosed() )
0:       connectionClosedFailure();
1: 
0: 	Xid[] xidList = null;
0:     int numXid = 0;
1: 
0: 	NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0: 	callInfo.xaFlags_ = flag;
0: 	callInfo.xaResource_ = this;
0: 	callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
0: 	try {
0: 	  netAgent.beginWriteChainOutsideUOW();
0:       // sent the recover PROTOCOL
0:       netAgent.netConnectionRequest_.writeXaRecover(conn_, flag);
0:       netAgent.flowOutsideUOW();
0: 	  netAgent.netConnectionReply_.readXaRecover(conn_);
0:       if( callInfo.xaRetVal_ != XARETVAL_XAOK )
0:       { // xaRetVal has possible error, format it
0:         callInfo.xaFunction_ = XAFUNC_RECOVER;
0:         rc = xaRetValErrorAccumSQL( callInfo, rc );
0:         callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
0:       }
0:       netAgent.endReadChain();
0: 	  if (conn_.indoubtTransactions_ != null)
0: 	  {
0: 		numXid = conn_.indoubtTransactions_.size();
0: 		xidList = new Xid[numXid];
0: 		int i=0;
0: 		nextElement = 0;
0: 		for (Enumeration e = conn_.indoubtTransactions_.keys() ;
0: 			 e.hasMoreElements(); i++)
0: 		{
0: 		  xidList[i] = (Xid) e.nextElement();
0: 		}
0: 	  }
0: 	}
0: 	catch( SqlException sqle )
0: 	{
0: 	  rc = XAException.XAER_RMERR;
0: 	  exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0: 		(sqle, exceptionsOnXA);
0: 	}
0: 	finally
0: 	{
0: 	  conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
0: 	}
0: 	if (rc != XAResource.XA_OK)
0: 		throwXAException(rc, false);
1: 
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceExit (this, "recover", xidList);
0:     return xidList;
0:   }
1: 
0:   /** Inform the resource manager to roll back work done on behalf
0:    * of a transaction branch
1:    *
0:    * @param xid A global transaction identifier
1:    *
0:    * @exception XAException An error has occurred
0:    */
0:   public void rollback(Xid xid) throws XAException
0:   {
0: 	NetAgent netAgent = conn_.netAgent_;
0: 	int rc = XAResource.XA_OK;
0:     exceptionsOnXA = null;
1: 
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceEntry (this, "rollback", xid);
0:     if( conn_.isClosed() )
0:       connectionClosedFailure();
1: 
0: 	// update the XACallInfo
0: 	NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0: 	callInfo.xid_ = xid;
0: 	callInfo.xaResource_ = this;
0: 	callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
0: 	try {
0: 	  netAgent.beginWriteChainOutsideUOW();
0: 	  netAgent.netConnectionRequest_.writeXaRollback(conn_, xid);
0: 	  netAgent.flowOutsideUOW();
0: 	  // read the reply to the rollback
0: 	  rc = netAgent.netConnectionReply_.readXaRollback(conn_);
0: 	  netAgent.endReadChain();
0: 	  if(callInfo.xaRetVal_ != XARETVAL_XAOK )
0: 	  { // xaRetVal has possible error, format it
0: 		callInfo.xaFunction_ = XAFUNC_END;
0: 		rc = xaRetValErrorAccumSQL(callInfo, rc );
0: 		callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
0: 	  }
0: 	}
0: 	catch( SqlException sqle )
0: 	{
0: 	  rc = XAException.XAER_RMERR;
0: 	  exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0: 		(sqle, exceptionsOnXA);
0: 	}
0: 	finally
0: 	{
0: 	  conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
0: 	}
0: 	if (rc != XAResource.XA_OK)
0: 		throwXAException(rc, false);
1: 
0:   }
1: 
0:   /** <P>Set the current transaction timeout value for this <CODE>XAResource</CODE>
0:    * instance. This value overwrites the default transaction timeout
0:    * value in the resource manager. The newly assigned timeout value
0:    * is effective for the life of this <CODE>XAResource</CODE> instance unless
0:    * a new value is set.<P>
1:    *
0:    * @param the transaction timeout value in seconds.
1:    *
0:    * @exception XAException An error has occurred. Possible exception values
0:    * are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.
0:    */
0:   public boolean setTransactionTimeout(int seconds) throws XAException
0:   {
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceExit (this, "setTransactionTimeout", false);
0:     exceptionsOnXA = null;
0:     return false; // we don't support transaction timeout in our layer.
0:     /* int rc = xaSetTransTimeOut(seconds);
0:        if (rc != XAResource.XA_OK)
0:          throwXAException(rc); */
0:   }
1: 
0:   /** Start work on behalf of a transaction branch specified in xid
1:    *
0:    * @param xid A global transaction identifier to be associated
0:    * with the resource
1:    *
0:    * @param flags One of TMNOFLAGS, TMJOIN, or TMRESUME
1:    *
0:    * @exception XAException An error has occurred. Possible exceptions   * are XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_DUPID, XAER_OUTSIDE,
0:    * XAER_NOTA, XAER_INVAL, or XAER_PROTO.
1:    *
0:    */
0:   public synchronized void start(Xid xid, int flags) throws XAException
0:   {
1: 
0: 	NetAgent netAgent = conn_.netAgent_;
0: 	int rc = XAResource.XA_OK;
0: 	exceptionsOnXA = null;
0: 	if (conn_.agent_.loggingEnabled())
0: 	  conn_.agent_.logWriter_.traceEntry (this, "start", xid, flags);
0: 	if( conn_.isClosed() )
0: 	  connectionClosedFailure();
1: 
0: 	// update the XACallInfo
0: 	NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0: 	callInfo.xaFlags_ = flags;
0: 	callInfo.xaInProgress_ = true;
0: 	callInfo.xid_ = xid;
0: 	callInfo.xaResource_ = this;
0: 	callInfo.xaRetVal_ = XARETVAL_XAOK; // initialize XARETVAL
0: 	try {
0: 	  netAgent.beginWriteChainOutsideUOW();
0: 	  netAgent.netConnectionRequest_.writeXaStartUnitOfWork(conn_);
0: 	  netAgent.flowOutsideUOW();
0: 	  netAgent.netConnectionReply_.readXaStartUnitOfWork(conn_);
0: 	  if( callInfo.xaRetVal_ != XARETVAL_XAOK )
0: 	  { // xaRetVal has possible error, format it
0: 		callInfo.xaFunction_ = XAFUNC_START;
0: 		rc = xaRetValErrorAccumSQL( callInfo, rc );
0: 		callInfo.xaRetVal_ = XARETVAL_XAOK; // re-initialize XARETVAL
0: 	  }
0: 	  // Setting this is currently required to avoid client from sending
0: 	  // commit for autocommit.
0: 	  if (rc == XARETVAL_XAOK)
0: 		  conn_.setXAState(Connection.XA_ACTIVE);
1: 
0: 	}
0: 	catch( SqlException sqle )
0: 	{
0: 	  rc = XAException.XAER_RMERR;
0: 	  exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0: 		(sqle, exceptionsOnXA);
0: 	}
0: 	finally
0: 	{
0: 	  conn_.pendingEndXACallinfoOffset_ = -1; // indicate no pending callinfo
0: 	}
0: 	if (rc != XAResource.XA_OK)
0: 		throwXAException(rc, false);
0:   }
1: 
1: 
1: 
0:   protected void throwXAException(int rc) throws XAException
0:   {
0:     // By default, throwXAException will reset the state of the failed connection
0:     throwXAException(rc, rc!=XAException.XAER_NOTA);
0:   }
1: 
0:   private String getXAExceptionText( int rc )
0:   {
0:     String xaExceptionText;
0:     switch( rc )
0:     {
0:       case javax.transaction.xa.XAException.XA_RBROLLBACK:
0:         xaExceptionText = "XA_RBROLLBACK";
0:         break;
0:       case javax.transaction.xa.XAException.XA_RBCOMMFAIL:
0:         xaExceptionText = "XA_RBCOMMFAIL";
0:         break;
0:       case javax.transaction.xa.XAException.XA_RBDEADLOCK:
0:         xaExceptionText = "XA_RBDEADLOCK";
0:         break;
0:       case javax.transaction.xa.XAException.XA_RBINTEGRITY:
0:         xaExceptionText = "XA_RBINTEGRITY";
0:         break;
0:       case javax.transaction.xa.XAException.XA_RBOTHER:
0:         xaExceptionText = "XA_RBOTHER";
0:         break;
0:       case javax.transaction.xa.XAException.XA_RBPROTO:
0:         xaExceptionText = "XA_RBPROTO";
0:         break;
0:       case javax.transaction.xa.XAException.XA_RBTIMEOUT:
0:         xaExceptionText = "XA_RBTIMEOUT";
0:         break;
0:       case javax.transaction.xa.XAException.XA_RBTRANSIENT:
0:         xaExceptionText = "XA_RBTRANSIENT";
0:         break;
0:       case javax.transaction.xa.XAException.XA_NOMIGRATE:
0:         xaExceptionText = "XA_NOMIGRATE";
0:         break;
0:       case javax.transaction.xa.XAException.XA_HEURHAZ:
0:         xaExceptionText = "XA_HEURHAZ";
0:         break;
0:       case javax.transaction.xa.XAException.XA_HEURCOM:
0:         xaExceptionText = "XA_HEURCOM";
0:         break;
0:       case javax.transaction.xa.XAException.XA_HEURRB:
0:         xaExceptionText = "XA_HEURRB";
0:         break;
0:       case javax.transaction.xa.XAException.XA_HEURMIX:
0:         xaExceptionText = "XA_HEURMIX";
0:         break;
0:       case javax.transaction.xa.XAException.XA_RETRY:
0:         xaExceptionText = "XA_RETRY";
0:         break;
0:       case javax.transaction.xa.XAException.XA_RDONLY:
0:         xaExceptionText = "XA_RDONLY";
0:         break;
0:       case javax.transaction.xa.XAException.XAER_ASYNC:
0:         xaExceptionText = "XAER_ASYNC";
0:         break;
0:       case javax.transaction.xa.XAException.XAER_RMERR:
0:         xaExceptionText = "XAER_RMERR";
0:         break;
0:       case javax.transaction.xa.XAException.XAER_NOTA:
0:         xaExceptionText = "XAER_NOTA";
0:         break;
0:       case javax.transaction.xa.XAException.XAER_INVAL:
0:         xaExceptionText = "XAER_INVAL";
0:         break;
0:       case javax.transaction.xa.XAException.XAER_PROTO:
0:         xaExceptionText = "XAER_PROTO";
0:         break;
0:       case javax.transaction.xa.XAException.XAER_RMFAIL:
0:         xaExceptionText = "XAER_RMFAIL";
0:         break;
0:       case javax.transaction.xa.XAException.XAER_DUPID:
0:         xaExceptionText = "XAER_DUPID";
0:         break;
0:       case javax.transaction.xa.XAException.XAER_OUTSIDE:
0:         xaExceptionText = "XAER_OUTSIDE";
0:         break;
0:       case XAResource.XA_OK:
0:         xaExceptionText = "XA_OK";
0:         break;
0:       default:
0:         xaExceptionText = "Unknown Error";
0:         break;
0:     }
0:     return xaExceptionText;
0:   }
1: 
0:   protected void throwXAException(int rc, boolean resetFlag) throws XAException
0:   { // ~~~
0:     String xaExceptionText;
0:     if (resetFlag)
0:     {
0:     // reset the state of the failed connection
0:     NetXACallInfo callInfo = callInfoArray_[conn_.currXACallInfoOffset_];
0:     callInfo.xaInProgress_ = false;
0:     callInfo.xaWasSuspended = false;
0:     callInfo.xaState_ = Connection.XA_OPEN_IDLE;
0:     conn_.setXAState( Connection.XA_OPEN_IDLE );
0:     }
1: 
0:     xaExceptionText = getXAExceptionText( rc );
0:     // save the SqlException chain to add it to the XAException
0:     org.apache.derby.client.am.SqlException sqlExceptions = exceptionsOnXA;
1: 
0:     while( exceptionsOnXA != null )
0:     { // one or more SqlExceptions received, format them
0:       xaExceptionText = xaExceptionText + " : " + exceptionsOnXA.getMessage();
0:       exceptionsOnXA = (org.apache.derby.client.am.SqlException)
0:                            exceptionsOnXA.getNextException();
0:     }
0:     org.apache.derby.client.am.XaException xaException =
0:         new org.apache.derby.client.am.XaException( conn_.agent_.logWriter_,
0:                                             sqlExceptions,
0:                                             xaExceptionText );
0:     xaException.errorCode = rc;
0:     throw xaException;
0:   }
1: 
0:   public boolean isSameRM(XAResource xares) throws XAException
0:   {
0:     boolean isSame = false; // preset that the RMs are NOT the same
0:     exceptionsOnXA = null;
1: 
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceEntry (this, "isSameRM", xares);
0:     if( conn_.isClosed() )
0:       connectionClosedFailure();
1: 
0:     if ( xares instanceof org.apache.derby.client.net.NetXAResource )
0:     { // both are NetXAResource so check to see if this is the same RM
0:       // remember, isSame is initialized to false
0:       NetXAResource derbyxares = (NetXAResource) xares;
0:       while( true )
0:       {
0:         if( !conn_.databaseName_.equalsIgnoreCase(derbyxares.conn_.databaseName_) )
0:           break; // database names are not equal, not same RM
0:         if( !conn_.netAgent_.server_.equalsIgnoreCase
0:             (derbyxares.conn_.netAgent_.server_) )
0:         { // server name strings not equal, compare IP addresses
0:           try
0:           {
0:             // 1st convert "localhost" to actual server name
0:             String server1 = this.processLocalHost( conn_.netAgent_.server_ );
0:             String server2 =
0:                 this.processLocalHost( derbyxares.conn_.netAgent_.server_ );
0:             // now convert the server name to ip address
0:             InetAddress serverIP1 = InetAddress.getByName( server1 );
0:             InetAddress serverIP2 = InetAddress.getByName( server2 );
0:             if( !serverIP1.equals( serverIP2 ) )
0:               break; // server IPs are not equal, not same RM
0:           }
0:           catch(  UnknownHostException ue ) {break;}
0:         }
0:         if( conn_.netAgent_.port_ != derbyxares.conn_.netAgent_.port_ )
0:           break; // ports are not equal, not same RM
0:         isSame = true; // everything the same, set RMs are the same
0:         break;
0:       }
0:     }
1: 
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceExit
0:       (this, "isSameRM", isSame);
0:     return isSame;
0:   }
1: 
0:   public static boolean xidsEqual( Xid xid1, Xid xid2 )
0:   { // determine if the 2 xids contain the same values even if not same object
0:     // comapre the format ids
0:     if( xid1.getFormatId() != xid2.getFormatId() )
0:       return false; // format ids are not the same
1: 
0:     // compare the global transaction ids
0:     int xid1Length = xid1.getGlobalTransactionId().length;
0:     if( xid1Length != xid2.getGlobalTransactionId().length )
0:       return false; // length of the global trans ids are not the same
0:     byte[] xid1Bytes = xid1.getGlobalTransactionId();
0:     byte[] xid2Bytes = xid2.getGlobalTransactionId();
0:     int i;
0:     for( i=0; i<xid1Length; ++i )
0:     { // check all bytes are the same
0:       if( xid1Bytes[i] != xid2Bytes[i] )
0:         return false; // bytes in the global trans ids are not the same
0:     }
1: 
0:     // compare the branch qualifiers
0:     xid1Length = xid1.getBranchQualifier().length;
0:     if( xid1Length != xid2.getBranchQualifier().length )
0:       return false; // length of the global trans ids are not the same
0:     xid1Bytes = xid1.getBranchQualifier();
0:     xid2Bytes = xid2.getBranchQualifier();
0:     for( i=0; i<xid1Length; ++i )
0:     { // check all bytes are the same
0:       if( xid1Bytes[i] != xid2Bytes[i] )
0:         return false; // bytes in the global trans ids are not the same
0:     }
1: 
0:     return true; // all of the fields are the same, xid1 == xid2
0:   }
1: 
1: 
0: 	// KATHEY remove
0:   protected void makeEntryCurrent( int offset ) throws SqlException
0:   {
0:     int currOffset = conn_.currXACallInfoOffset_; // offset of current XACallInfo
0:     NetXACallInfo newCallInfo = callInfoArray_[offset];
0:     if (conn_.agent_.loggingEnabled()) conn_.agent_.logWriter_.traceEntry
0:       (this, "makeEntryCurrent", offset, currOffset);
1: 
0:     if( currOffset == offset )
0:     { // entry is already current
0:       if( newCallInfo.convReleased_ &&
0:           !newCallInfo.xaInProgress_ )
0:       { // connection reuse, XA is not in Progress, reset connection
0:         // transaction pooling
0:         newCallInfo.convReleased_ = false;
0:         if( !conn_.resetConnectionAtFirstSql_ )
0:         { // resetConnectionAtFirstSql_ is false
0:           /*
0:             * at this point we have determined that a reset of this connection
0:             * is required. We are already inside beginWriteChain() where a
0:             * deferred reset would be done, however we might have switched
0:             * connection to a connection that needed reset from a connection
0:             * that didn't need reset. It is too late for the test for deferred
0:             * reset in beginWriteChain so we call writeDeferredReset here.
0:             * by setting the resetConnectionAtFirstSql_ flag we trigger the
0:             * readDeferredReset in beginReadChain. This is done ONLY if
0:             * resetConnectionAtFirstSql_ is not set, if it is then
0:             * writeDeferredReset() has already been done.
0:             */
0:           conn_.resetConnectionAtFirstSql_ = true;
0:           conn_.writeDeferredReset();
0:         }
0:       }
0:       return; // entry is already current, nothing to do
0:     }
1: 
0:     callInfoArray_[currOffset].currConnection_ = false; // reset old current conn
0:     callInfoArray_[currOffset].xaState_ = conn_.getXAState(); // save XA state
0:     callInfoArray_[currOffset].freeEntry_ = false; // set entry in use
1: 
0:     // set the new entry as the current entry, update conn_
0:     newCallInfo.currConnection_ = true;
0:     conn_.currXACallInfoOffset_ = offset;
0:     conn_.setXAState(newCallInfo.xaState_);
1: 
0:     if( newCallInfo.convReleased_ &&
0:         !newCallInfo.xaInProgress_ )
0:     { // connection reuse, XA is not in Progress, reset connection
0:       // transaction pooling
0:       newCallInfo.convReleased_ = false;
0:       if( !conn_.resetConnectionAtFirstSql_ )
0:       { // resetConnectionAtFirstSql_ is false
0:         /*
0:           * at this point we have determined that a reset of this connection
0:           * is required. We are already inside beginWriteChain() where a
0:           * deferred reset would be done, however we might have switched
0:           * connection to a connection that needed reset from a connection
0:           * that didn't need reset. It is too late for the test for deferred
0:           * reset in beginWriteChain so we call writeDeferredReset here.
0:           * by setting the resetConnectionAtFirstSql_ flag we trigger the
0:           * readDeferredReset in beginReadChain. This is done ONLY if
0:           * resetConnectionAtFirstSql_ is not set, if it is then
0:           * writeDeferredReset() has already been done.
0:           */
0:         conn_.resetConnectionAtFirstSql_ = true;
0:         conn_.writeDeferredReset();
0:       }
0:     }
1: 
0:     if( conn_.agent_.loggingEnabled() )
0:     { // logging enabled
0:       conn_.agent_.logWriter_.traceExit (this, "makeEntryCurrent", offset);
0:     }
0:   }
1: 
1: 
0:   public List getSpecialRegisters()
0:   {
0:     return specialRegisters_;
0:   }
1: 
0:   public void addSpecialRegisters(String s)
0:   {
0:     if (s.substring(0,1).equals("@"))
0:     {
0:       // SET statement is coming from Client
0:       if (specialRegisters_.remove(s.substring(1)))
0:       {
0:         specialRegisters_.remove(s);
0:         specialRegisters_.add(s.substring(1));
0:         }
0:         else
0:         {
0:         specialRegisters_.remove(s);
0:         specialRegisters_.add(s);
0:         }
0:       }
0:       else
0:     { // SET statement is coming from Server
0:     specialRegisters_.remove(s);
0:     specialRegisters_.add(s);
0:     }
0:   }
1: 
0:   private void connectionClosedFailure() throws XAException
0:   { // throw an XAException XAER_RMFAIL, with a chained SqlException - closed
0:     exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                     (new SqlException( null, "Connection is Closed."),
0:                      exceptionsOnXA);
0:     throwXAException(javax.transaction.xa.XAException.XAER_RMFAIL);
0:   }
1: 
0:   private String getXAFuncStr( int xaFunc )
0:   {
0:     switch( xaFunc )
0:     {
0:       case XAFUNC_COMMIT:
0:         return XAFUNCSTR_COMMIT;
0:       case XAFUNC_END:
0:         return XAFUNCSTR_END;
0:       case XAFUNC_FORGET:
0:         return XAFUNCSTR_FORGET;
0:       case XAFUNC_PREPARE:
0:         return XAFUNCSTR_PREPARE;
0:       case XAFUNC_RECOVER:
0:         return XAFUNCSTR_RECOVER;
0:       case XAFUNC_ROLLBACK:
0:         return XAFUNCSTR_ROLLBACK;
0:       case XAFUNC_START:
0:         return XAFUNCSTR_START;
0:     }
0:     return XAFUNCSTR_NONE;
0:   }
1: 
0:   protected int xaRetValErrorAccumSQL( NetXACallInfo callInfo, int currentRC )
0:   {
0:     int rc;
0:     switch (callInfo.xaRetVal_)
0:     {
0:       case XARETVAL_XAOK:
0:       case XARETVAL_NODISSOCIATE:
0:         rc = XAResource.XA_OK;
0:         break;
0:       case XARETVAL_XALCSNOTSUPP:
0:         rc = XAResource.XA_OK;
0:         break;
0:       case XARETVAL_RBROLLBACK:
0:         rc = XAException.XA_RBROLLBACK;
0:         break;
0:       case XARETVAL_RBOTHER:
0:         rc = XAException.XA_RBOTHER;
0:         break;
0:       case XARETVAL_RBDEADLOCK:
0:         rc = XAException.XA_RBDEADLOCK;
0:         break;
0:       case XARETVAL_RBPROTO:
0:         rc = XAException.XA_RBPROTO;
0:         break;
0:       case XARETVAL_XAERPROTO:
0:         rc = XAException.XAER_PROTO;
0:         break;
0:       case XARETVAL_XARDONLY:
0:         rc = XAException.XA_RDONLY;
0:         break;
0:       case XARETVAL_XAHEURCOM:
0:         rc = XAException.XA_HEURCOM;
0:         break;
0:       case XARETVAL_XAHEURRB:
0:         rc = XAException.XA_HEURRB;
0:         break;
0:       case XARETVAL_XAERDUPID:
0:         rc = XAException.XAER_DUPID;
0:         break;
0:       case XARETVAL_XAERNOTA:
0:         rc = XAException.XAER_NOTA;
0:         break;
0:       case XARETVAL_XAERRMERR:
0:         rc = XAException.XAER_RMERR;
0:         break;
0:       case XARETVAL_XAERRMFAIL:
0:         rc = XAException.XAER_RMFAIL;
0:         break;
0:       case XARETVAL_XAERINVAL:
0:         rc = XAException.XAER_INVAL;
0:         break;
0:       default:
0:         rc = XAException.XAER_RMFAIL;
0:         break;
0:     }
1: 
0:     if( rc != XAResource.XA_OK )
0:     { // error was detected
0:       // create an SqlException to report this error within
0:       String xaRetValStr = "Error executing a " +
0:           getXAFuncStr( callInfo.xaFunction_ ) + ", " +
0:           "Server returned " + getXAExceptionText( rc );
0:       SqlException accumSql = new SqlException( conn_.netAgent_.logWriter_,
0:           xaRetValStr, org.apache.derby.client.am.SqlState.undefined,
0:           org.apache.derby.client.am.SqlCode.queuedXAError );
0:       exceptionsOnXA = org.apache.derby.client.am.Utils.accumulateSQLException
0:                                                     (accumSql, exceptionsOnXA);
1: 
0:       if( currentRC != XAResource.XA_OK )
0:       { // the rc passed into this function had an error also, prioritize error
0:         if( currentRC < 0 )
0:         { // rc passed in was a major error use it instead of current error
0:           return currentRC;
0:         }
0:       }
0:     }
0:     return rc;
0:   }
1: 
0:   private String processLocalHost( String serverName )
0:   {
0:     if( serverName.equalsIgnoreCase("localhost") )
0:     { // this is a localhost, find hostname
0:       try
0:       {
0:         InetAddress localhostNameIA = InetAddress.getLocalHost();
0:         String localhostName = localhostNameIA.getHostName();
0:         return localhostName;
0:       }
0:       catch( SecurityException se ) {return serverName;}
0:       catch( UnknownHostException ue ) {return serverName;}
0:     }
0:     // not "localhost", return original server name
0:     return serverName;
0:   }
1: 
0:   protected void removeXaresFromSameRMchain()
0:   {
0:     // check all NetXAResources on the same RM for the NetXAResource to remove
0:     try
0:     {
0:       this.ignoreMe_ = true; // use the ignoreMe_ flag to indicate the
0:       // XAResource to remove
0:       NetXAResource prevXAResource = null;
0:       NetXAResource currXAResource;
0:       synchronized( xaResourceSameRMGroup_ )
0:       { // make sure no one changes this vector list
0:         currXAResource = (NetXAResource) xaResourceSameRMGroup_.elementAt(
0:                                                            sameRMGroupIndex_ );
0:         while( currXAResource != null )
0:         { // is this the XAResource to remove?
0:           if( currXAResource.ignoreMe_ )
0:           { // this NetXAResource is the one to remove
0:             if( prevXAResource != null )
0:             { // this XAResource is not first in chain, just move next to prev
0:               prevXAResource.nextSameRM_ = currXAResource.nextSameRM_;
0:             }
0:             else
0:             { // this XAResource is  first in chain, just move next to root
0:               xaResourceSameRMGroup_.set( sameRMGroupIndex_,
0:                   currXAResource.nextSameRM_ );
0:             }
0:             return;
0:           }
0:           // this is not the NetXAResource to remove, try the next one
0:           prevXAResource = currXAResource;
0:           currXAResource = currXAResource.nextSameRM_;
0:         }
0:       }
0:     }
0:     finally
0:     {
0:       this.ignoreMe_ = false;
0:     }
0:   }
1: 
1: 
0:   public void initForReuse()
0:   {
0:     // add this new XAResource to the list of other XAResources for the Same RM
0:     // first find out if there are any other XAResources for the same RM
0:     // then check to make sure it is not already in the chain
0:     synchronized(xaResourceSameRMGroup_)
0:     { // make sure no one changes this vector list
0:       int groupCount = xaResourceSameRMGroup_.size();
0:       int index = 0;
0:       int firstFreeElement = -1;
0:       NetXAResource xaResourceGroup = null;
1: 
0:       for( ; index<groupCount; ++index )
0:       { // check if this group is the same RM
0:         xaResourceGroup = (NetXAResource) xaResourceSameRMGroup_.elementAt( index );
0:         if( xaResourceGroup == null )
0:         { // this is a free element, save its index if first found
0:           if( firstFreeElement == -1 )
0:           { // first free element, save index
0:             firstFreeElement = index;
0:           }
0:           continue; // go to next element
0:         }
0:         try
0:         {
0:           if( xaResourceGroup.isSameRM(this) )
0:           { // it is the same RM add this XAResource to the chain if not there
0:             NetXAResource nextXares = (NetXAResource)
0:                           xaResourceSameRMGroup_.elementAt( sameRMGroupIndex_ );
0:             while( nextXares != null )
0:             { // is this NetXAResource the one we are trying to add?
0:               if( nextXares.equals( this ) )
0:               { // the XAResource to be added already is in chain, don't add
0:                 break;
0:               }
0:               // Xid was not on that NetXAResource, try the next one
0:               nextXares = nextXares.nextSameRM_;
0:             }
1: 
0:             if( nextXares == null )
0:             { // XAResource to be added is not in the chain already, add it
0:               // add it at the head of the chain
0:               sameRMGroupIndex_ = index;
0:               this.nextSameRM_ = xaResourceGroup.nextSameRM_;
0:               xaResourceGroup.nextSameRM_ = this;
0:             }
0:             return; // done
0:           }
0:         }
0:         catch( XAException xae )
0:         {}  
0:       }
1: 
0:       // no other same RM was found, add this as first of new group
0:       if( firstFreeElement == -1 )
0:       { // no free element found, add new element to end
0:         xaResourceSameRMGroup_.add(this);
0:         sameRMGroupIndex_ = groupCount;
0:       }
0:       else
0:       { // use first free element found
0:         xaResourceSameRMGroup_.setElementAt( this, firstFreeElement );
0:         sameRMGroupIndex_ = firstFreeElement;
0:       }
0:     }
0:   }
0: }
============================================================================