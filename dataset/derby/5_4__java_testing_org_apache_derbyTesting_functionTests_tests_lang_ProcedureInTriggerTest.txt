1:f5caa93: /*
1:b08ebba:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest
1:b08ebba:  *  
1:b08ebba:  * Licensed to the Apache Software Foundation (ASF) under one
1:b08ebba:  * or more contributor license agreements.  See the NOTICE file
1:b08ebba:  * distributed with this work for additional information
1:b08ebba:  * regarding copyright ownership.  The ASF licenses this file
1:b08ebba:  * to you under the Apache License, Version 2.0 (the
1:b08ebba:  * "License"); you may not use this file except in compliance
1:b08ebba:  * with the License.  You may obtain a copy of the License at
1:b08ebba:  *
1:b08ebba:  *   http://www.apache.org/licenses/LICENSE-2.0
1:b08ebba:  *
1:b08ebba:  * Unless required by applicable law or agreed to in writing,
1:b08ebba:  * software distributed under the License is distributed on an
1:b08ebba:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:b08ebba:  * KIND, either express or implied.  See the License for the
1:b08ebba:  * specific language governing permissions and limitations
1:b08ebba:  * under the License.
1:b08ebba:  */
1:b08ebba: package org.apache.derbyTesting.functionTests.tests.lang;
12:b08ebba: 
1:b08ebba: import java.sql.Connection;
1:b08ebba: import java.sql.DriverManager;
1:b08ebba: import java.sql.PreparedStatement;
1:b08ebba: import java.sql.ResultSet;
1:b08ebba: import java.sql.SQLException;
1:b08ebba: import java.sql.Statement;
1:b08ebba: import junit.framework.Test;
1:b08ebba: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:b08ebba: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:b08ebba: import org.apache.derbyTesting.junit.JDBC;
1:fc87a43: import org.apache.derbyTesting.junit.TestConfiguration;
1:b08ebba: 
1:b08ebba: public class ProcedureInTriggerTest extends BaseJDBCTestCase {
1:b08ebba: 
1:b08ebba:     public ProcedureInTriggerTest(String name) {
1:b08ebba:         super(name);
1:b08ebba:        
4:b08ebba:     }
1:48154b2: 
2:b08ebba:     /**
1:b08ebba:      * Test triggers that fire procedures with no sql
1:b08ebba:      * 
1:b08ebba:      * @throws SQLException
1:b08ebba:      */
1:b08ebba:     public void testTriggerNoSql() throws SQLException {
1:895501e:         Statement s = createStatement();
1:b08ebba:         s.execute("create trigger after_stmt_trig_no_sql AFTER insert on t2 for each STATEMENT call proc_no_sql()");
1:b08ebba:         //insert 2 rows. check that trigger is fired - procedure should be called once
1:fc87a43:         zeroArgCount = 0;
2:b08ebba:         s.execute("insert into t2 values (1,2), (2,4)");
1:b08ebba:         checkAndResetZeroArgCount(1);
1:b08ebba:         ResultSet rs = s.executeQuery("SELECT * FROM T2");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:cc67949:         // Check that a procedure used by a trigger cannot be dropped.
1:cc67949:         assertStatementError("X0Y25", s, "drop procedure proc_no_sql");
1:b08ebba:         s.execute("insert into t2 values (3,6)");
1:b08ebba:         checkAndResetZeroArgCount(1);
1:b08ebba:         rs = s.executeQuery("SELECT * FROM T2");  
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"},{"3","6"}});
1:b08ebba:         s.execute("create trigger after_row_trig_no_sql AFTER delete on t2 for each ROW call proc_no_sql()");
1:b08ebba:         //--- delete all rows. check that trigger is fired - procedure should be called 3 times
1:b08ebba:         s.execute("delete from t2");
1:b08ebba:         checkAndResetZeroArgCount(3);
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         s.execute("drop trigger after_stmt_trig_no_sql");
1:b08ebba:         s.execute("drop trigger after_row_trig_no_sql");
1:b08ebba:         s.execute("create trigger before_stmt_trig_no_sql no cascade BEFORE insert on t2 for each STATEMENT call proc_no_sql()");
1:b08ebba:         //--- insert 2 rows. check that trigger is fired - procedure should be called once
1:b08ebba:         s.execute("insert into t2 values (1,2), (2,4)");
1:b08ebba:         checkAndResetZeroArgCount(1);
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:cc67949:         // Check that a procedure used by a trigger cannot be dropped.
1:cc67949:         assertStatementError("X0Y25", s, "drop procedure proc_no_sql");
1:b08ebba:         s.execute("insert into t2 values (3,6)");
1:b08ebba:         checkAndResetZeroArgCount(1);
1:b08ebba:         // check inserts are successful
1:b08ebba:         rs = s.executeQuery("SELECT * FROM T2");  
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"},{"3","6"}});
1:b08ebba:         s.execute("create trigger before_row_trig_no_sql no cascade BEFORE delete on t2 for each ROW call proc_no_sql()");
1:b08ebba:         // delete and check trigger fired
1:b08ebba:         s.execute("delete from t2");
1:b08ebba:         checkAndResetZeroArgCount(3);
1:b08ebba:         // check delete is successful
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         s.execute("drop trigger before_stmt_trig_no_sql");
1:b08ebba:         s.execute("drop trigger before_row_trig_no_sql");
1:895501e:         s.close();
1:fc87a43:     }
1:fc87a43:     
1:b08ebba:     /**
1:b08ebba:      * Test CONTAINS SQL triggers (neither reads no writes data)
1:b08ebba:      * procedure does just a getConnection and that's it.
1:b08ebba:      * 
1:b08ebba:      * @throws SQLException
1:b08ebba:      */
1:b08ebba:     public void testTriggerContainsSql() throws SQLException{
1:895501e:         Statement s = createStatement();
1:8010935:         s.execute("insert into t2 values (1,2), (2,4)");
1:b08ebba:         s.execute("create trigger after_row_trig_contains_sql AFTER update on t2 for each ROW call proc_contains_sql()");
1:b08ebba:         // --- update 2 rows. check that trigger is fired - procedure should be called twice
1:b08ebba:         s.execute("update t2 set x = x*2");
1:b08ebba:         checkAndResetGetConnectionProcCount(2);
1:b08ebba:         //--- check updates are successful
1:b08ebba:         ResultSet rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"2","2"},{"4","4"}});
1:b08ebba:         s.execute("create trigger before_stmt_trig_contains_sql no cascade BEFORE delete on t2 for each STATEMENT call proc_contains_sql()");
1:b08ebba:         //--- delete 2 rows. check that trigger is fired - procedure should be called once
1:b08ebba:         s.execute("delete from t2");
1:b08ebba:         checkAndResetGetConnectionProcCount(1);
1:b08ebba:         //--- check delete is successful
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         s.execute("drop trigger after_row_trig_contains_sql");
1:b08ebba:         s.execute("drop trigger before_stmt_trig_contains_sql");
1:895501e:         s.close();
1:fc87a43:     }
1:fc87a43:    
1:b08ebba:     /**
1:b08ebba:      * Test triggers for procedures that READ SQL DATA
1:b08ebba:      * @throws SQLException
1:b08ebba:      */
1:b08ebba:     public void testTriggerReadsSql() throws SQLException {
1:895501e:         Statement s = createStatement();
1:b08ebba:         //--- create a row in t1 for use in select in the procedure
1:b08ebba:         s.execute("insert into t1 values (1, 'one')");
1:b08ebba:         s.execute("create trigger after_stmt_trig_reads_sql AFTER insert on t2 for each STATEMENT call proc_reads_sql(1)");
1:b08ebba:         //--- insert 2 rows. check that trigger is fired - procedure should be called once
1:fc87a43:         selectRowsCount = 0;
1:b08ebba:         s.execute("insert into t2 values (1,2), (2,4)");
1:b08ebba:         checkAndResetSelectRowsCount(1);
1:b08ebba:         //--- check inserts are successful
1:b08ebba:         ResultSet rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:b08ebba:         s.execute("drop trigger after_stmt_trig_reads_sql");
1:b08ebba:         s.execute("create trigger before_row_trig_reads_sql no cascade BEFORE delete on t2 for each ROW call proc_reads_sql(1)");
1:b08ebba:         //--- delete 2 rows. check that trigger is fired - procedure should be called twice
1:b08ebba:         s.execute("delete from t2");
1:b08ebba:         checkAndResetSelectRowsCount(2);
1:b08ebba:         // --- check delete is successful
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         s.execute("drop trigger before_row_trig_reads_sql");
1:b08ebba:         //--- empty t1
1:b08ebba:         s.execute("delete from t1");
1:895501e:         s.close();
1:fc87a43:     }
1:fc87a43:     
1:b08ebba:     /**
1:b08ebba:      * Test triggers that MODIFY SQL DATA
1:b08ebba:      * 
1:b08ebba:      * @throws SQLException
1:b08ebba:      */
1:b08ebba:     public void testModifiesSql() throws SQLException {
1:895501e:         Statement s = createStatement();
1:b08ebba:         s.execute("create trigger after_stmt_trig_modifies_sql_insert_op AFTER insert on t2 for each STATEMENT call proc_modifies_sql_insert_op(1, 'one')");
1:b08ebba:         //--- insert 2 rows
1:b08ebba:         s.execute("insert into t2 values (1,2), (2,4)");
1:b08ebba:         //--- check trigger is fired. insertRow should be called once
1:b08ebba:         ResultSet rs = s.executeQuery("select * from t1");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][]{{"1","one"}});  
1:b08ebba:         //--- check inserts are successful
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:b08ebba:         
1:b08ebba:         s.execute("create trigger after_row_trig_modifies_sql_update_op AFTER update of x on t2 for each ROW call proc_modifies_sql_update_op(2)");
1:b08ebba:         //--- update all rows
1:b08ebba:         s.execute("update t2 set x=x*2");
1:b08ebba:         // --- check row trigger was fired. value of i should be 5
1:b08ebba:         rs = s.executeQuery("select * from t1");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][]{{"5","one"}});
1:b08ebba:         //--- check update successful
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"2","2"},{"4","4"}});
1:b08ebba:         s.execute("create trigger after_stmt_trig_modifies_sql_delete_op AFTER delete on t2 for each STATEMENT call proc_modifies_sql_delete_op(5)");
1:b08ebba:         //--- delete from t2
1:b08ebba:         s.execute("delete from t2");
1:b08ebba:         // --- check trigger is fired. table t1 should be empty
1:b08ebba:         rs = s.executeQuery("select * from t1");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         // check delete successful
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         s.execute("drop trigger after_stmt_trig_modifies_sql_insert_op");
1:b08ebba:         s.execute("drop trigger after_row_trig_modifies_sql_update_op");
1:b08ebba:         s.execute("drop trigger after_stmt_trig_modifies_sql_delete_op");
1:b08ebba:         s.execute("create trigger refer_new_row_trig AFTER insert on t2 REFERENCING NEW as new for each ROW call proc_modifies_sql_insert_op(new.x, 'new')");
1:b08ebba:         //--- insert a row
1:b08ebba:         s.execute("insert into t2 values (25, 50)");
1:b08ebba:         //--- check trigger is fired. insertRow should be called once
1:b08ebba:         rs = s.executeQuery("select * from t1");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"25","new"}});
1:b08ebba:         // --- check inserts are successful
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"25","50"}});
1:b08ebba:         s.execute("create trigger refer_old_row_trig AFTER delete on t2 REFERENCING OLD as old for each ROW call proc_modifies_sql_delete_op(old.x)");
1:b08ebba:         // --- delete a row
1:b08ebba:         s.execute("delete from t2 where x=25");
1:b08ebba:         //--- check trigger is fired. deleteRow should be called once
1:b08ebba:         rs = s.executeQuery("select * from t1");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         s.execute("drop trigger refer_new_row_trig");
1:b08ebba:         s.execute("drop trigger refer_old_row_trig");
1:b08ebba:         //--- create a before trigger that calls a procedure that modifies sql data. 
1:b08ebba:         //--- trigger creation should fail
1:b08ebba:         assertStatementError("42Z9D",s,"create trigger before_trig_modifies_sql no cascade BEFORE insert on t2 for each STATEMENT call proc_modifies_sql_insert_op(1, 'one')");
1:b08ebba:         //--- in a BEFORE trigger, call a procedure which actually modifies SQL data      
1:b08ebba:         //--- trigger creation will pass but firing should fail
1:b08ebba:         s.execute("create trigger bad_before_trig no cascade BEFORE insert on t2 for each STATEMENT call proc_wrongly_defined_as_no_sql(50, 'fifty')");
1:b08ebba:         //--- try to insert 2 rows
1:b08ebba:         try {
1:b08ebba:             s.execute("insert into t2 values (1,2), (2,4)");
1:b08ebba:         } catch (SQLException se) {
1:de3b108:             assertSQLState("38000", se);
1:de3b108:             se = se.getNextException();
1:96889c1:             assertSQLState("38001", se);
1:b08ebba:         }
1:b08ebba:         //--- check trigger is not fired.
1:b08ebba:         rs = s.executeQuery("select * from t1");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         rs = s.executeQuery("select * from t2");
1:b08ebba:         JDBC.assertEmpty(rs);
1:b08ebba:         s.execute("drop trigger bad_before_trig");
1:b08ebba:         //--- procedures which insert/update/delete into trigger table
1:b08ebba:         s.execute("create trigger insert_trig AFTER update on t1 for each STATEMENT call proc_modifies_sql_insert_op(1, 'one')");
1:b08ebba:         s.execute("insert into t1 values(2, 'two')");
1:b08ebba:         s.execute("update t1 set i=i+1");
1:b08ebba:         //--- Check that update and insert successful. t1 should have 2 rows
1:b08ebba:         rs = s.executeQuery("select * from t1");
1:b08ebba:         JDBC.assertFullResultSet(rs, new String[][] {{"3","two"},{"1","one"}});
1:b08ebba:        s.execute("drop trigger insert_trig");
1:b08ebba:        s.execute("create trigger update_trig AFTER insert on t1 for each STATEMENT call proc_modifies_sql_update_op(2)");
1:b08ebba:        s.execute("insert into t1 values (4,'four')");
1:b08ebba:        //--- Check that insert successful and trigger fired. 
1:b08ebba:        rs = s.executeQuery("select * from t1");
1:fc87a43:        String [][] expectedRows = {{"5","two            "},
1:fc87a43:                                    {"3","one            "},
1:fc87a43:                                    {"6","four           "}};
1:fc87a43:        JDBC.assertFullResultSet(rs, expectedRows);
1:fc87a43:               
1:b08ebba:        s.execute("drop trigger update_trig");
1:b08ebba:        s.execute("create trigger delete_trig AFTER insert on t1 for each STATEMENT call proc_modifies_sql_delete_op(3)");
1:b08ebba:        s.execute("insert into t1 values (8,'eight')");
1:b08ebba:        //-- Check that insert was successful and trigger was fired
1:b08ebba:        rs = s.executeQuery("select * from t1");
1:fc87a43:        expectedRows = new String [][]
1:fc87a43:                         {{"5","two            "},{"6","four           "},{"8","eight          "}};
1:745c37a:        JDBC.assertFullResultSet(rs, expectedRows);
1:b08ebba:        s.execute("drop trigger delete_trig");
1:b08ebba:        //--- Procedures with schema name
1:b08ebba:        s.execute("create trigger call_proc_in_default_schema AFTER insert on t2 for each STATEMENT call APP.proc_no_sql()");
1:b08ebba:        //--- insert 2 rows. check that trigger is fired - procedure should be called once
1:b08ebba:        s.execute("insert into t2 values (1,2), (2,4)");
1:b08ebba:        //--- check inserts are successful
1:b08ebba:        rs = s.executeQuery("select * from t2");
1:b08ebba:        JDBC.assertFullResultSet(rs, new String[][] { {"1","2"}, {"2","4"}});
1:b08ebba:        s.execute("drop trigger call_proc_in_default_schema");
1:b08ebba:        s.execute("create trigger call_proc_in_default_schema no cascade BEFORE delete on t2 for each ROW call APP.proc_no_sql()");
1:b08ebba:        //--- delete 2 rows. check that trigger is fired - procedure should be called twice
1:b08ebba:        s.execute("delete from t2");
1:b08ebba:        //--- check delete is successful
1:b08ebba:        rs = s.executeQuery("select * from t2");
1:b08ebba:       JDBC.assertEmpty(rs);
1:b08ebba:       s.execute("drop trigger call_proc_in_default_schema");
1:b08ebba:       s.execute("create trigger call_proc_in_new_schema no cascade BEFORE insert on t2 for each STATEMENT call new_schema.proc_in_new_schema()");
1:b08ebba:       //--- insert 2 rows. check that trigger is fired - procedure should be called once
1:b08ebba:       s.execute("insert into t2 values (1,2), (2,4)");
1:b08ebba:       //--- check inserts are successful
1:b08ebba:       rs = s.executeQuery("select * from t2");
1:b08ebba:       JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:b08ebba:       s.execute("drop trigger call_proc_in_new_schema");
1:b08ebba:       s.execute("create trigger call_proc_in_new_schema AFTER delete on t2 for each ROW call new_schema.proc_in_new_schema()");
1:b08ebba:       //--- delete 2 rows. check that trigger is fired - procedure should be called twice
1:b08ebba:       s.execute("delete from t2");
1:b08ebba:       //--- check delete is successful
1:b08ebba:       rs = s.executeQuery("select * from t2");
1:b08ebba:       JDBC.assertEmpty(rs);
1:b08ebba:       s.execute("drop trigger call_proc_in_new_schema");
1:895501e:       s.close();
1:b08ebba:     }
1:b08ebba: 
1:b08ebba:   
1:b08ebba:     /**
1:b08ebba:      * Some misc negative tests for procedures in triggers.
1:b08ebba:      * 
1:b08ebba:      * @throws SQLException
1:b08ebba:      */
1:b08ebba:     public void testTriggerNegative() throws SQLException {
1:895501e:         Statement s = createStatement();
1:8010935: 
1:8010935:         // Insert some test data.
1:8010935:         s.execute("insert into t1 values (5,'two'), (6,'four'), (8,'eight')");
1:8010935: 
1:b08ebba:         ResultSet rs;
1:b08ebba:         assertStatementError("42Y03",s,"create trigger call_non_existent_proc1 AFTER insert on t2 for each ROW call non_existent_proc()");
1:96c3cce:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_NON_EXISTENT_PROC1'");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:b08ebba:           assertStatementError("42Y03",s,"create trigger call_proc_with_non_existent_proc2 AFTER insert on t2 for each ROW call new_schema.non_existent_proc()");
1:96c3cce:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_NON_EXISTENT_PROC2'");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:b08ebba:           assertStatementError("42Y07",s,"create trigger call_proc_in_non_existent_schema AFTER insert on t2 for each ROW call non_existent_schema.non_existent_proc()");
1:96c3cce:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_PROC_IN_NON_EXISTENT_SCHEMA'");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:b08ebba:           assertStatementError("42X50",s,"create trigger call_proc_using_non_existent_method AFTER insert on t2 for each ROW call proc_using_non_existent_method()");
1:96c3cce:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername as VARCHAR(128))='CALL_PROC_WITH_NON_EXISTENT_METHOD'");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:b08ebba:           assertStatementError("42Y03",s,"create trigger call_non_existent_proc1 no cascade BEFORE insert on t2 for each ROW call non_existent_proc()");
1:96c3cce:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_NON_EXISTENT_PROC1'");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:b08ebba:           assertStatementError("42Y07",s,"create trigger call_proc_in_non_existent_schema no cascade BEFORE insert on t2 for each ROW call non_existent_schema.non_existent_proc()");
1:96c3cce:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_PROC_IN_NON_EXISTENT_SCHEMA'");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});      
1:b08ebba:           assertStatementError("42X50",s,"create trigger call_proc_using_non_existent_method no cascade BEFORE insert on t2 for each ROW call proc_using_non_existent_method()");
1:96c3cce:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_PROC_WITH_NON_EXISTENT_METHOD'");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:b08ebba:           //--- triggers must not allow dynamic parameters (?)
1:b08ebba:           
1:b08ebba:           assertStatementError("42Y27",s,"create trigger update_trig AFTER insert on t1 for each STATEMENT call proc_modifies_sql_update_op(?)");
1:b08ebba:           s.execute("insert into t2 values (1,2), (2,4)");
1:b08ebba:           // --- use procedure with commit
1:b08ebba:           s.execute("create trigger commit_trig AFTER delete on t2 for each STATEMENT call commit_proc()");
1:b08ebba:           assertStatementError("38000",s,"delete from t2");
1:b08ebba:           rs = s.executeQuery("select * from t2");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:b08ebba:           s.execute("drop trigger commit_trig");
1:b08ebba:           s.execute("create trigger commit_trig no cascade BEFORE delete on t2 for each STATEMENT call commit_proc()");
1:b08ebba:           // -- should fail
1:b08ebba:           assertStatementError("38000",s,"delete from t2");
1:b08ebba:           //--- check delete failed
1:b08ebba:           rs = s.executeQuery("select * from t2");
1:b08ebba:           JDBC.assertFullResultSet(rs,new String[][] {{"1","2"}, {"2","4"}});
1:b08ebba:           s.execute("drop trigger commit_trig");
1:b08ebba:           //--- use procedure with rollback
1:b08ebba:           s.execute("create trigger rollback_trig AFTER delete on t2 for each STATEMENT call rollback_proc()");
1:b08ebba:           assertStatementError("38000",s,"delete from t2");
1:b08ebba:           //--- check delete failed
1:b08ebba:           rs = s.executeQuery("select * from t2");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:b08ebba:           s.execute("drop trigger rollback_trig");
1:b08ebba:           s.execute("create trigger rollback_trig no cascade BEFORE delete on t2 for each STATEMENT call rollback_proc()");
1:b08ebba:           //--- should fail
1:b08ebba:           assertStatementError("38000",s,"delete from t2");
1:b08ebba:           //--- check delete failed
1:b08ebba:           rs = s.executeQuery("select * from t2");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:b08ebba:           s.execute("drop trigger rollback_trig");
1:b08ebba:           //--- use procedure which changes isolation level
1:b08ebba:           s.execute("create trigger set_isolation_trig AFTER delete on t2 for each STATEMENT call set_isolation_proc()");
1:b08ebba:           assertStatementError("38000",s,"delete from t2");
1:b08ebba:           //--- check delete failed
1:b08ebba:           rs = s.executeQuery("select * from t2");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:b08ebba:           s.execute("drop trigger set_isolation_trig");
1:b08ebba:           s.execute("create trigger set_isolation_trig no cascade BEFORE delete on t2 for each STATEMENT call set_isolation_proc()");
1:b08ebba:           assertStatementError("38000",s,"delete from t2");
1:b08ebba:           //--- check delete failed
1:b08ebba:           rs = s.executeQuery("select * from t2");
1:b08ebba:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:b08ebba:           s.execute("drop trigger set_isolation_trig");
1:b08ebba:           // --- call procedure that selects from same trigger table
1:b08ebba:           s.execute("create trigger select_from_trig_table AFTER insert on t1 for each STATEMENT call proc_reads_sql(1)");
1:b08ebba:           //--- insert 2 rows check that trigger is fired - procedure should be called once
1:b08ebba:           s.execute("insert into t1 values (10, 'ten')");
1:b08ebba:           //--- check inserts are successful
1:b08ebba:           rs = s.executeQuery("select * from t1");
1:b08ebba:           String [][] expectedRows = { {"5","two"},{"6","four"},{"8","eight"},{"10","ten"}};
1:b08ebba:           JDBC.assertFullResultSet(rs,expectedRows );
1:b08ebba:           s.execute("drop trigger select_from_trig_table");
1:b08ebba:           s.execute("create trigger select_from_trig_table no cascade before delete on t1 for each STATEMENT call proc_reads_sql(1)");
1:b08ebba:           //--- delete a row. check that trigger is fired - procedure should be called once
1:b08ebba:           //RESOLVE: How to check
1:b08ebba:           s.execute("delete from t1 where i=10");
1:b08ebba:           // --- check delete is successful
1:b08ebba:           rs = s.executeQuery("select * from t1");
1:b08ebba:           expectedRows = new String[][] { {"5","two"},{"6","four"},{"8","eight"}};
1:745c37a:           JDBC.assertFullResultSet(rs, expectedRows);
1:b08ebba:           s.execute("drop trigger select_from_trig_table");
1:b08ebba:           //--- use procedures which alter/drop trigger table and some other table
1:b08ebba:           s.execute("create trigger alter_table_trig AFTER delete on t1 for each STATEMENT call alter_table_proc()");
1:b08ebba:           assertStatementError("38000",s,"delete from t1");
1:b08ebba:           // check delete failed
1:b08ebba:           rs = s.executeQuery("select * from t1");
1:b08ebba:           expectedRows = new String[][] { {"5","two"},{"6","four"},{"8","eight"}};
1:b08ebba:           JDBC.assertFullResultSet(rs, expectedRows);
1:b08ebba:           s.execute("create trigger drop_table_trig AFTER delete on t2 for each STATEMENT call drop_table_proc()");
1:b08ebba:           // should fail
1:b08ebba:          assertStatementError("38000",s,"delete from t2");
1:b08ebba:          // check delete failed
1:b08ebba:          rs = s.executeQuery("select * from t2");
1:b08ebba:          JDBC.assertFullResultSet(rs,new String[][] {{"1","2"}, {"2","4"}});
1:b08ebba:          s.execute("drop trigger drop_table_trig");
1:b08ebba:          //--- use procedures which create/drop trigger on trigger table and some other table
1:b08ebba:          s.execute("create trigger create_trigger_trig AFTER delete on t1 for each STATEMENT call create_trigger_proc()");
1:b08ebba:          // -- should fail
1:b08ebba:          assertStatementError("38000",s,"delete from t1");
1:b08ebba:          //--- check delete failed
1:b08ebba:          rs = s.executeQuery("select * from t1");
1:b08ebba:          expectedRows = new String[][] { {"5","two"},{"6","four"},{"8","eight"}};
1:b08ebba:          JDBC.assertFullResultSet(rs, expectedRows);
1:b08ebba:          //--- check trigger is not created
1:96c3cce:          rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where  CAST(triggername AS VARCHAR(128))='TEST_TRIG'");
1:fc87a43:          JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:b08ebba:          s.execute("drop trigger create_trigger_trig");
1:b08ebba:          //--- create a trigger to test we cannot drop it from a procedure called by a trigger
1:b08ebba:          s.execute("create trigger test_trig AFTER delete on t1 for each STATEMENT insert into  t1 values(20, 'twenty')");
1:b08ebba:          s.execute("create trigger drop_trigger_trig AFTER delete on t2 for each STATEMENT call drop_trigger_proc()");
1:b08ebba:          assertStatementError("38000",s,"delete from t2");
1:b08ebba:          //--- check delete failed
1:b08ebba:          rs = s.executeQuery("select * from t2");
1:b08ebba:          JDBC.assertFullResultSet(rs,new String[][] {{"1","2"}, {"2","4"}});
1:b08ebba:          //--- check trigger is not dropped
1:96c3cce:          rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='TEST_TRIG'");
1:fc87a43:          JDBC.assertFullResultSet(rs, new String[][] {{"1"}});
1:b08ebba:          s.execute("drop trigger drop_trigger_trig");
1:b08ebba:          //- use procedures which create/drop index on trigger table and some other table
1:b08ebba:          s.execute("create trigger create_index_trig AFTER delete on t2 for each STATEMENT call create_index_proc()");
1:b08ebba:          // -- should fail
1:b08ebba:          assertStatementError("38000",s,"delete from t2");
1:b08ebba:          // check delete failed
1:b08ebba:          rs = s.executeQuery("select * from t2");
1:b08ebba:          JDBC.assertFullResultSet(rs,new String[][] {{"1","2"}, {"2","4"}});
1:b08ebba:          // -- check index is not created
1:07d1108:          rs = s.executeQuery("select count(*) from SYS.SYSCONGLOMERATES where CAST(CONGLOMERATENAME AS VARCHAR(128))='IX' and ISINDEX");
1:fc87a43:          JDBC.assertFullResultSet(rs, new String [][] {{"0"}});
1:b08ebba:          s.execute("drop trigger create_index_trig");
1:b08ebba:          //--- create an index to test we cannot drop it from a procedure called by a trigger
1:b08ebba:          s.execute("create index ix on t1(i,b)");
1:b08ebba:          s.execute("create trigger drop_index_trig AFTER delete on t1 for each STATEMENT call drop_index_proc()");
1:b08ebba:          assertStatementError("38000",s,"delete from t1");
1:b08ebba:          // -- check delete failed
1:b08ebba:          rs = s.executeQuery("select * from t1");
1:b08ebba:          expectedRows = new String[][] { {"5","two"},{"6","four"},{"8","eight"}};
1:fc87a43:          JDBC.assertFullResultSet(rs, expectedRows);
1:b08ebba:          // -- check index is not dropped
1:07d1108:          rs = s.executeQuery("select count(*) from SYS.SYSCONGLOMERATES where CAST(CONGLOMERATENAME AS VARCHAR(128))='IX' and ISINDEX");
1:b08ebba:          JDBC.assertFullResultSet(rs, new String[][] {{"1"}});
1:8010935: 
1:013465f:          // Clean up objects created by the test case.
1:8010935:          s.execute("drop trigger alter_table_trig");
1:8010935:          s.execute("drop trigger test_trig");
1:8010935:          s.execute("drop trigger drop_index_trig");
1:013465f:          s.execute("drop index ix");
1:8010935: 
1:895501e:          s.close();
1:b08ebba:     }
1:b08ebba:     
1:b08ebba:     
1:b08ebba:     
1:b08ebba:     private static Test basesuite() {
1:1ae02c9:         Test basesuite = new BaseTestSuite(ProcedureInTriggerTest.class);
1:b08ebba:         Test clean = new CleanDatabaseTestSetup(basesuite) {
1:b08ebba:         protected void decorateSQL(Statement s) throws SQLException {
1:b08ebba:             s.execute("create table t1 (i int primary key, b char(15))");
1:b08ebba:             s.execute("create table t2 (x integer, y integer)");
3:b08ebba:             s.execute("create procedure proc_no_sql() parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.zeroArg'");
1:b08ebba:             s.execute("create procedure proc_contains_sql() parameter style java language java CONTAINS SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.getConnectionProc'");
1:b08ebba:             s.execute("create procedure proc_reads_sql(i integer) parameter style java language java READS SQL DATA external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.selectRows' dynamic result sets 1");
1:b08ebba:             s.execute("create procedure proc_modifies_sql_insert_op(p1 int, p2 char(10)) parameter style java language java MODIFIES SQL DATA external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.insertRow'");
1:b08ebba:             s.execute("create procedure proc_modifies_sql_update_op(p1 int) parameter style java language java  MODIFIES SQL DATA  external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.updateRow'");
1:b08ebba:             s.execute("create procedure proc_modifies_sql_delete_op(p1 int) parameter style java language java MODIFIES SQL DATA external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.deleteRow'");
1:b08ebba:             s.execute("create procedure alter_table_proc() parameter style java language java external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.alterTable'");
1:b08ebba:             s.execute("create procedure drop_table_proc() parameter style java language java external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.dropTable'");
1:b08ebba:             s.execute("create procedure commit_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.doConnCommit'");
1:b08ebba:             s.execute("create procedure rollback_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.doConnRollback'");
1:b08ebba:             s.execute("create procedure set_isolation_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.doConnectionSetIsolation'");
1:b08ebba:             s.execute("create procedure create_index_proc() parameter style java dynamic result sets 0 language java  contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.createIndex'");
1:b08ebba:             s.execute("create procedure drop_index_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.dropIndex'");
1:b08ebba:             s.execute("create procedure create_trigger_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.createTrigger'");
1:b08ebba:             s.execute(" create procedure drop_trigger_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.dropTrigger'");
1:b08ebba:             s.execute("create procedure proc_wrongly_defined_as_no_sql(p1 int, p2 char(10)) parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.insertRow'");
1:b08ebba:             // create a new schema and put a procedure in it.
1:b08ebba:             s.execute("create schema new_schema");
1:b08ebba:             s.execute("create procedure new_schema.proc_in_new_schema() parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.zeroArg'");
1:b08ebba:             // procedure which uses non-existant method
1:b08ebba:             s.execute("create procedure proc_using_non_existent_method() parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.nonexistentMethod'");
1:b08ebba:        
1:b08ebba:             
1:b08ebba:         }};
1:b08ebba:         
1:b08ebba:         return clean;
1:b08ebba:         }
1:b08ebba:                 
1:b08ebba:         public static Test suite() { 
1:1ae02c9:             BaseTestSuite suite = new BaseTestSuite();
1:fc87a43:             if (!JDBC.vmSupportsJSR169()) {
1:b08ebba:                 suite.addTest(basesuite());
1:fc87a43:                 suite.addTest(TestConfiguration.clientServerDecorator(basesuite()));
1:fc87a43:             }
1:b08ebba:             return suite;
1:b08ebba:         }
1:b08ebba: 
1:8010935:         /**
1:8010935:          * Tear down the test environment.
1:8010935:          */
1:8010935:         protected void tearDown() throws Exception {
1:8010935:             rollback();
1:8010935: 
1:8010935:             // Remove all rows in the test tables, so that each test case
1:8010935:             // sees the same initial state.
1:8010935:             Statement stmt = createStatement();
1:8010935:             stmt.execute("truncate table t1");
1:8010935:             stmt.execute("truncate table t2");
1:8010935:             commit();
1:8010935: 
1:8010935:             // Reset the counters.
1:8010935:             zeroArgCount = 0;
1:8010935:             getConnectionProcCount = 0;
1:8010935:             selectRowsCount = 0;
1:8010935: 
1:8010935:             super.tearDown();
1:8010935:         }
1:8010935: 
1:b08ebba:         private void checkAndResetZeroArgCount(int count) {
1:b08ebba:             assertEquals(count, zeroArgCount);
1:b08ebba:             zeroArgCount = 0;
1:b08ebba:          }      
1:b08ebba:         
1:b08ebba:         // PROCEDURES
1:b08ebba:         private static int zeroArgCount = 0;
1:b08ebba:         public static void zeroArg() {
1:b08ebba:             zeroArgCount++;
1:b08ebba:         }
1:b08ebba:         
1:b08ebba:         private static int getConnectionProcCount = 0;
1:b08ebba:         
1:b08ebba:         private void checkAndResetGetConnectionProcCount(int count) {
1:b08ebba:             assertEquals(count, getConnectionProcCount);
1:b08ebba:             getConnectionProcCount = 0;
1:b08ebba:          }
1:b08ebba:         
1:b08ebba:         public static void getConnectionProc() throws Throwable
1:fc87a43:         {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
6:b08ebba:                 Statement s = conn.createStatement();
1:b08ebba:                 conn.close();
1:b08ebba:                 getConnectionProcCount++;
1:b08ebba:         }
1:b08ebba:         
1:b08ebba:         private static int selectRowsCount = 0;
1:b08ebba:         
1:b08ebba:         private void checkAndResetSelectRowsCount(int count) {
1:b08ebba:             assertEquals(count, selectRowsCount);
1:b08ebba:             selectRowsCount = 0;
1:b08ebba:          }
1:b08ebba:         
1:b08ebba:         public static void selectRows(int p1, ResultSet[] data) throws SQLException {
1:b08ebba: 
1:b08ebba:                 
1:b08ebba: 
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1:b08ebba:                 ps.setInt(1, p1);
1:b08ebba:                 data[0] = ps.executeQuery();
1:b08ebba:                 conn.close();
1:b08ebba:                 selectRowsCount++;
1:b08ebba:         }
1:b08ebba:         
1:b08ebba:         public static void selectRows(int p1, int p2, ResultSet[] data1, ResultSet[] data2) throws SQLException {
1:b08ebba: 
1:b08ebba:                 
1:b08ebba: 
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1:b08ebba:                 ps.setInt(1, p1);
1:b08ebba:                 data1[0] = ps.executeQuery();
1:b08ebba: 
1:b08ebba:                 ps = conn.prepareStatement("select * from t1 where i >= ?");
1:b08ebba:                 ps.setInt(1, p2);
1:b08ebba:                 data2[0] = ps.executeQuery();
1:b08ebba: 
1:b08ebba:                 if (p2 == 99)
1:b08ebba:                         data2[0].close();
1:b08ebba: 
1:b08ebba:                 // return no results
1:b08ebba:                 if (p2 == 199) {
1:b08ebba:                         data1[0].close();
1:b08ebba:                         data1[0] = null;
1:b08ebba:                         data2[0].close();
1:b08ebba:                         data2[0] = null;
1:b08ebba:                 }
1:b08ebba: 
1:b08ebba:                 // swap results
1:b08ebba:                 if (p2 == 299) {
1:b08ebba:                         ResultSet rs = data1[0];
1:b08ebba:                         data1[0] = data2[0];
1:b08ebba:                         data2[0] = rs;
1:b08ebba:                 }
1:b08ebba: 
1:b08ebba:                 conn.close();
1:b08ebba:                 selectRowsCount++;
1:b08ebba:         }
1:b08ebba: 
1:b08ebba:         // select all rows from a table
1:b08ebba:         public static void selectRows(String table, ResultSet[] rs)
1:b08ebba:                 throws SQLException
2:b08ebba:         {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 Statement stmt = conn.createStatement();
1:b08ebba:                 rs[0] = stmt.executeQuery("SELECT * FROM " + table);
1:b08ebba:                 conn.close();
1:b08ebba:                 selectRowsCount++;
1:b08ebba:         }
1:b08ebba: 
1:b08ebba: 
1:b08ebba:         public static void insertRow(int p1) throws SQLException {
1:b08ebba:                 insertRow(p1, "int");
1:b08ebba:         }
1:b08ebba: 
1:b08ebba:         public static void insertRow(int p1, String p2) throws SQLException {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("insert into t1 values (?, ?)");
1:b08ebba:                 ps.setInt(1, p1);
1:b08ebba:                 ps.setString(2, p2);
1:b08ebba:                 ps.executeUpdate();
1:b08ebba:                 ps.close();
1:b08ebba:                 conn.close();
1:b08ebba:         }
1:b08ebba:         
1:b08ebba:         public static void updateRow(int p1) throws SQLException {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("update t1 set i=i+?");
1:b08ebba:                 ps.setInt(1, p1);
1:b08ebba:                 ps.executeUpdate();
1:b08ebba:                 ps.close();
1:b08ebba:                 conn.close();
1:b08ebba:         }
1:b08ebba:         
1:b08ebba:         public static void deleteRow(int p1) throws SQLException {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("delete from t1 where i=?");
1:b08ebba:                 ps.setInt(1, p1);
1:b08ebba:                 ps.executeUpdate();
1:b08ebba:                 ps.close();
1:b08ebba:                 conn.close();
1:b08ebba:         }
1:b08ebba: 
1:b08ebba:         public static void alterTable() throws SQLException {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("alter table t1 add column test integer");
1:b08ebba:                 ps.execute();
1:b08ebba:                 ps.close();
1:b08ebba:                 conn.close();
1:b08ebba:         }
1:b08ebba: 
1:b08ebba:         public static void dropTable() throws SQLException {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("drop table t1");
1:b08ebba:                 ps.execute();
1:b08ebba:                 ps.close();
1:b08ebba:                 conn.close();
1:b08ebba:         }               
1:b08ebba:         public static int doConnCommitInt() throws Throwable
1:b08ebba:         {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 conn.commit();
1:b08ebba:                 return 1;
1:b08ebba:         }
1:b08ebba: 
1:b08ebba:         public static void doConnCommit() throws Throwable
1:b08ebba:         {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 conn.commit();
1:b08ebba:         }        
1:b08ebba: 
1:b08ebba:         public static void doConnRollback() throws Throwable
1:b08ebba:         {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 conn.rollback();
1:b08ebba:         }
1:b08ebba: 
1:b08ebba:         public static void doConnectionSetIsolation() throws Throwable
1:b08ebba:         {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:b08ebba:         }
1:b08ebba:         
1:b08ebba:         public static void createIndex() throws SQLException {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("create index ix on t1(i,b)");
1:b08ebba:                 ps.execute();
1:b08ebba:                 ps.close();
1:b08ebba:                 conn.close();
1:b08ebba:         }
1:b08ebba: 
1:b08ebba:         public static void dropIndex() throws SQLException {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("drop index ix");
1:b08ebba:                 ps.execute();
1:b08ebba:                 ps.close();
1:b08ebba:                 conn.close();
1:b08ebba:         }
1:b08ebba:         
1:b08ebba:         public static void createTrigger() throws SQLException {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("create trigger test_trig" +
1:b08ebba:                                 " AFTER delete on t1 for each STATEMENT insert into" +
1:b08ebba:                                 " t1 values(20, 'twenty')");
1:b08ebba:                 ps.execute();
1:b08ebba:                 ps.close();
1:b08ebba:                 conn.close();
1:b08ebba:         }
1:b08ebba:         
1:b08ebba: 
1:b08ebba:         public static void dropTrigger() throws SQLException {
1:b08ebba:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:b08ebba:                 PreparedStatement ps = conn.prepareStatement("drop trigger test_trig");
1:b08ebba:                 ps.execute();
1:b08ebba:                 ps.close();
1:b08ebba:                 conn.close();
1:b08ebba:         }
1:b08ebba:         
1:b08ebba: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         Test basesuite = new BaseTestSuite(ProcedureInTriggerTest.class);
/////////////////////////////////////////////////////////////////////////
1:             BaseTestSuite suite = new BaseTestSuite();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:cc67949
/////////////////////////////////////////////////////////////////////////
1:         // Check that a procedure used by a trigger cannot be dropped.
1:         assertStatementError("X0Y25", s, "drop procedure proc_no_sql");
/////////////////////////////////////////////////////////////////////////
1:         // Check that a procedure used by a trigger cannot be dropped.
1:         assertStatementError("X0Y25", s, "drop procedure proc_no_sql");
commit:013465f
/////////////////////////////////////////////////////////////////////////
1:          // Clean up objects created by the test case.
1:          s.execute("drop index ix");
commit:8010935
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         s.execute("insert into t2 values (1,2), (2,4)");
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Insert some test data.
1:         s.execute("insert into t1 values (5,'two'), (6,'four'), (8,'eight')");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:          // Clean up triggers.
1:          s.execute("drop trigger alter_table_trig");
1:          s.execute("drop trigger test_trig");
1:          s.execute("drop trigger drop_index_trig");
1: 
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Tear down the test environment.
1:          */
1:         protected void tearDown() throws Exception {
1:             rollback();
1: 
1:             // Remove all rows in the test tables, so that each test case
1:             // sees the same initial state.
1:             Statement stmt = createStatement();
1:             stmt.execute("truncate table t1");
1:             stmt.execute("truncate table t2");
1:             commit();
1: 
1:             // Reset the counters.
1:             zeroArgCount = 0;
1:             getConnectionProcCount = 0;
1:             selectRowsCount = 0;
1: 
1:             super.tearDown();
1:         }
1: 
commit:895501e
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:       s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:          s.close();
commit:96889c1
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("38001", se);
commit:de3b108
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("38000", se);
1:             se = se.getNextException();
commit:f5caa93
/////////////////////////////////////////////////////////////////////////
1: /*
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:07d1108
/////////////////////////////////////////////////////////////////////////
1:          rs = s.executeQuery("select count(*) from SYS.SYSCONGLOMERATES where CAST(CONGLOMERATENAME AS VARCHAR(128))='IX' and ISINDEX");
/////////////////////////////////////////////////////////////////////////
1:          rs = s.executeQuery("select count(*) from SYS.SYSCONGLOMERATES where CAST(CONGLOMERATENAME AS VARCHAR(128))='IX' and ISINDEX");
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:96c3cce
/////////////////////////////////////////////////////////////////////////
1:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_NON_EXISTENT_PROC1'");
1:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_NON_EXISTENT_PROC2'");
1:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_PROC_IN_NON_EXISTENT_SCHEMA'");
1:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername as VARCHAR(128))='CALL_PROC_WITH_NON_EXISTENT_METHOD'");
1:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_NON_EXISTENT_PROC1'");
1:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_PROC_IN_NON_EXISTENT_SCHEMA'");
1:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='CALL_PROC_WITH_NON_EXISTENT_METHOD'");
/////////////////////////////////////////////////////////////////////////
1:          rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where  CAST(triggername AS VARCHAR(128))='TEST_TRIG'");
/////////////////////////////////////////////////////////////////////////
1:          rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where CAST(triggername AS VARCHAR(128))='TEST_TRIG'");
/////////////////////////////////////////////////////////////////////////
0:          rs = s.executeQuery("select count(*) from SYS.SYSCONGLOMERATES where CAST(CONGLOMERATENAME AS VARCHAR(128))='IX' and ISINDEX=1");
/////////////////////////////////////////////////////////////////////////
0:          rs = s.executeQuery("select count(*) from SYS.SYSCONGLOMERATES where CAST(CONGLOMERATENAME AS VARCHAR(128))='IX' and ISINDEX=1");
commit:48154b2
/////////////////////////////////////////////////////////////////////////
1:   
commit:745c37a
/////////////////////////////////////////////////////////////////////////
1:        JDBC.assertFullResultSet(rs, expectedRows);
/////////////////////////////////////////////////////////////////////////
1:          JDBC.assertFullResultSet(rs, expectedRows);
commit:fc87a43
/////////////////////////////////////////////////////////////////////////
0: import java.sql.ResultSetMetaData;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         zeroArgCount = 0;
/////////////////////////////////////////////////////////////////////////
1:         selectRowsCount = 0;
/////////////////////////////////////////////////////////////////////////
0:             // Client does not get chained exceptions
0:             if (usingEmbedded())
0:                 assertSQLState("38001", se);           
/////////////////////////////////////////////////////////////////////////
1:        String [][] expectedRows = {{"5","two            "},
1:                                    {"3","one            "},
1:                                    {"6","four           "}};
1:        JDBC.assertFullResultSet(rs, expectedRows);
1:               
1:        expectedRows = new String [][]
1:                         {{"5","two            "},{"6","four           "},{"8","eight          "}};
/////////////////////////////////////////////////////////////////////////
0:     private void showResultSet(ResultSet rs) throws SQLException {
0:         int row = 0;
0:            while (rs.next()) {
0:                row++;
0:                ResultSetMetaData rsmd = rs.getMetaData();
0:                int nocols = rsmd.getColumnCount();
0:                System.out.print("{");
1:               
0:                for (int i = 0; i < nocols; i++)
1:                {
0:                    System.out.print("\"" + rs.getString(i+1) + "\"");
0:                    if (i == (nocols -1))
0:                        System.out.println("}");
0:                    else
0:                        System.out.print(",");
1:                        
1:                }
1:            }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:          JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
/////////////////////////////////////////////////////////////////////////
1:          JDBC.assertFullResultSet(rs, new String[][] {{"1"}});
/////////////////////////////////////////////////////////////////////////
1:          JDBC.assertFullResultSet(rs, new String [][] {{"0"}});
/////////////////////////////////////////////////////////////////////////
1:          JDBC.assertFullResultSet(rs, expectedRows);
/////////////////////////////////////////////////////////////////////////
1:             if (!JDBC.vmSupportsJSR169()) {
1:                 suite.addTest(TestConfiguration.clientServerDecorator(basesuite()));
1:             }
commit:b08ebba
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest
1:  *  
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: public class ProcedureInTriggerTest extends BaseJDBCTestCase {
1: 
1:     public ProcedureInTriggerTest(String name) {
1:         super(name);
1:        
1:     }
1: 
1:     /**
1:      * Test triggers that fire procedures with no sql
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testTriggerNoSql() throws SQLException {
0:         Connection conn = getConnection();
1:         Statement s = conn.createStatement();
1:         s.execute("create trigger after_stmt_trig_no_sql AFTER insert on t2 for each STATEMENT call proc_no_sql()");
1:         //insert 2 rows. check that trigger is fired - procedure should be called once
1:         s.execute("insert into t2 values (1,2), (2,4)");
1:         checkAndResetZeroArgCount(1);
1:         ResultSet rs = s.executeQuery("SELECT * FROM T2");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
0:         //--- check that trigger firing and database event fail if the procedure referred
0:         //--- in the triggered sql statement is dropped
0:         s.execute("drop procedure proc_no_sql");
0:         assertStatementError("42Y03",s,"insert into t2 values (1,2), (2,4)");
0:         //--- after recreating the procedure, the trigger should work
1:         s.execute("create procedure proc_no_sql() parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.zeroArg'");
1:         s.execute("insert into t2 values (3,6)");
1:         checkAndResetZeroArgCount(1);
1:         rs = s.executeQuery("SELECT * FROM T2");  
1:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"},{"3","6"}});
1:         s.execute("create trigger after_row_trig_no_sql AFTER delete on t2 for each ROW call proc_no_sql()");
1:         //--- delete all rows. check that trigger is fired - procedure should be called 3 times
1:         s.execute("delete from t2");
1:         checkAndResetZeroArgCount(3);
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertEmpty(rs);
1:         s.execute("drop trigger after_stmt_trig_no_sql");
1:         s.execute("drop trigger after_row_trig_no_sql");
1:         s.execute("create trigger before_stmt_trig_no_sql no cascade BEFORE insert on t2 for each STATEMENT call proc_no_sql()");
1:         //--- insert 2 rows. check that trigger is fired - procedure should be called once
1:         s.execute("insert into t2 values (1,2), (2,4)");
1:         checkAndResetZeroArgCount(1);
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
0:         //--- check that trigger firing and database event fail if the procedure referred
0:         //--- in the triggered sql statement is dropped
0:         s.execute("drop procedure proc_no_sql");
0:         // --- should fail
0:         assertStatementError("42Y03",s,"insert into t2 values (1,2), (2,4)");
0:         //after recreating the procedure, the trigger should work
1:         s.execute("create procedure proc_no_sql() parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.zeroArg'");
1:         s.execute("insert into t2 values (3,6)");
1:         checkAndResetZeroArgCount(1);
1:         // check inserts are successful
1:         rs = s.executeQuery("SELECT * FROM T2");  
1:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"},{"3","6"}});
1:         s.execute("create trigger before_row_trig_no_sql no cascade BEFORE delete on t2 for each ROW call proc_no_sql()");
1:         // delete and check trigger fired
1:         s.execute("delete from t2");
1:         checkAndResetZeroArgCount(3);
1:         // check delete is successful
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertEmpty(rs);
1:         s.execute("drop trigger before_stmt_trig_no_sql");
1:         s.execute("drop trigger before_row_trig_no_sql");
1:         s.execute("insert into t2 values (1,2), (2,4)");
1:         
1:     }
1:     
1:     /**
1:      * Test CONTAINS SQL triggers (neither reads no writes data)
1:      * procedure does just a getConnection and that's it.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testTriggerContainsSql() throws SQLException{
0:         Connection conn = getConnection();
1:         Statement s = conn.createStatement();
1:         s.execute("create trigger after_row_trig_contains_sql AFTER update on t2 for each ROW call proc_contains_sql()");
1:         // --- update 2 rows. check that trigger is fired - procedure should be called twice
1:         s.execute("update t2 set x = x*2");
1:         checkAndResetGetConnectionProcCount(2);
1:         //--- check updates are successful
1:         ResultSet rs = s.executeQuery("select * from t2");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"2","2"},{"4","4"}});
1:         s.execute("create trigger before_stmt_trig_contains_sql no cascade BEFORE delete on t2 for each STATEMENT call proc_contains_sql()");
1:         //--- delete 2 rows. check that trigger is fired - procedure should be called once
1:         s.execute("delete from t2");
1:         checkAndResetGetConnectionProcCount(1);
1:         //--- check delete is successful
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertEmpty(rs);
1:         s.execute("drop trigger after_row_trig_contains_sql");
1:         s.execute("drop trigger before_stmt_trig_contains_sql");
1:        
1:     }
1:    
1:     /**
1:      * Test triggers for procedures that READ SQL DATA
1:      * @throws SQLException
1:      */
1:     public void testTriggerReadsSql() throws SQLException {
0:         Connection conn = getConnection();
1:         Statement s = conn.createStatement();
1:         //--- create a row in t1 for use in select in the procedure
1:         s.execute("insert into t1 values (1, 'one')");
1:         s.execute("create trigger after_stmt_trig_reads_sql AFTER insert on t2 for each STATEMENT call proc_reads_sql(1)");
1:         //--- insert 2 rows. check that trigger is fired - procedure should be called once
1:         s.execute("insert into t2 values (1,2), (2,4)");
1:         checkAndResetSelectRowsCount(1);
1:         //--- check inserts are successful
1:         ResultSet rs = s.executeQuery("select * from t2");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:         s.execute("drop trigger after_stmt_trig_reads_sql");
1:         s.execute("create trigger before_row_trig_reads_sql no cascade BEFORE delete on t2 for each ROW call proc_reads_sql(1)");
1:         //--- delete 2 rows. check that trigger is fired - procedure should be called twice
1:         s.execute("delete from t2");
1:         checkAndResetSelectRowsCount(2);
1:         // --- check delete is successful
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertEmpty(rs);
1:         s.execute("drop trigger before_row_trig_reads_sql");
1:         //--- empty t1
1:         s.execute("delete from t1");
1:             
1:                         
1:     }
1:     
1:     /**
1:      * Test triggers that MODIFY SQL DATA
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testModifiesSql() throws SQLException {
0:         Connection conn = getConnection();
1:         Statement s = conn.createStatement();
1:         s.execute("create trigger after_stmt_trig_modifies_sql_insert_op AFTER insert on t2 for each STATEMENT call proc_modifies_sql_insert_op(1, 'one')");
1:         //--- insert 2 rows
1:         s.execute("insert into t2 values (1,2), (2,4)");
1:         //--- check trigger is fired. insertRow should be called once
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         JDBC.assertFullResultSet(rs, new String[][]{{"1","one"}});  
1:         //--- check inserts are successful
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:         
1:         s.execute("create trigger after_row_trig_modifies_sql_update_op AFTER update of x on t2 for each ROW call proc_modifies_sql_update_op(2)");
1:         //--- update all rows
1:         s.execute("update t2 set x=x*2");
1:         // --- check row trigger was fired. value of i should be 5
1:         rs = s.executeQuery("select * from t1");
1:         JDBC.assertFullResultSet(rs, new String[][]{{"5","one"}});
1:         //--- check update successful
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"2","2"},{"4","4"}});
1:         s.execute("create trigger after_stmt_trig_modifies_sql_delete_op AFTER delete on t2 for each STATEMENT call proc_modifies_sql_delete_op(5)");
1:         //--- delete from t2
1:         s.execute("delete from t2");
1:         // --- check trigger is fired. table t1 should be empty
1:         rs = s.executeQuery("select * from t1");
1:         JDBC.assertEmpty(rs);
1:         // check delete successful
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertEmpty(rs);
1:         s.execute("drop trigger after_stmt_trig_modifies_sql_insert_op");
1:         s.execute("drop trigger after_row_trig_modifies_sql_update_op");
1:         s.execute("drop trigger after_stmt_trig_modifies_sql_delete_op");
1:         s.execute("create trigger refer_new_row_trig AFTER insert on t2 REFERENCING NEW as new for each ROW call proc_modifies_sql_insert_op(new.x, 'new')");
1:         //--- insert a row
1:         s.execute("insert into t2 values (25, 50)");
1:         //--- check trigger is fired. insertRow should be called once
1:         rs = s.executeQuery("select * from t1");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"25","new"}});
1:         // --- check inserts are successful
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"25","50"}});
1:         s.execute("create trigger refer_old_row_trig AFTER delete on t2 REFERENCING OLD as old for each ROW call proc_modifies_sql_delete_op(old.x)");
1:         // --- delete a row
1:         s.execute("delete from t2 where x=25");
1:         //--- check trigger is fired. deleteRow should be called once
1:         rs = s.executeQuery("select * from t1");
1:         JDBC.assertEmpty(rs);
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertEmpty(rs);
1:         s.execute("drop trigger refer_new_row_trig");
1:         s.execute("drop trigger refer_old_row_trig");
1:         //--- create a before trigger that calls a procedure that modifies sql data. 
1:         //--- trigger creation should fail
1:         assertStatementError("42Z9D",s,"create trigger before_trig_modifies_sql no cascade BEFORE insert on t2 for each STATEMENT call proc_modifies_sql_insert_op(1, 'one')");
1:         //--- in a BEFORE trigger, call a procedure which actually modifies SQL data      
1:         //--- trigger creation will pass but firing should fail
1:         s.execute("create trigger bad_before_trig no cascade BEFORE insert on t2 for each STATEMENT call proc_wrongly_defined_as_no_sql(50, 'fifty')");
1:         //--- try to insert 2 rows
0:         //--- Bug DERBY-1629 -- in JDK 1.6 you only get 38001, not 38000
1:         try {
1:             s.execute("insert into t2 values (1,2), (2,4)");
1:         } catch (SQLException se) {
0:             assertSQLState("38000", se);
0:             se = se.getNextException();
0:             assertSQLState("38001", se);           
1:         }
1:         //--- check trigger is not fired.
1:         rs = s.executeQuery("select * from t1");
1:         JDBC.assertEmpty(rs);
1:         rs = s.executeQuery("select * from t2");
1:         JDBC.assertEmpty(rs);
1:         s.execute("drop trigger bad_before_trig");
1:         //--- procedures which insert/update/delete into trigger table
1:         s.execute("create trigger insert_trig AFTER update on t1 for each STATEMENT call proc_modifies_sql_insert_op(1, 'one')");
1:         s.execute("insert into t1 values(2, 'two')");
1:         s.execute("update t1 set i=i+1");
1:         //--- Check that update and insert successful. t1 should have 2 rows
1:         rs = s.executeQuery("select * from t1");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"3","two"},{"1","one"}});
1:        s.execute("drop trigger insert_trig");
1:        s.execute("create trigger update_trig AFTER insert on t1 for each STATEMENT call proc_modifies_sql_update_op(2)");
1:        s.execute("insert into t1 values (4,'four')");
1:        //--- Check that insert successful and trigger fired. 
1:        rs = s.executeQuery("select * from t1");
1:        s.execute("drop trigger update_trig");
1:        s.execute("create trigger delete_trig AFTER insert on t1 for each STATEMENT call proc_modifies_sql_delete_op(3)");
1:        s.execute("insert into t1 values (8,'eight')");
1:        //-- Check that insert was successful and trigger was fired
1:        rs = s.executeQuery("select * from t1");
1:        s.execute("drop trigger delete_trig");
1:        //--- Procedures with schema name
1:        s.execute("create trigger call_proc_in_default_schema AFTER insert on t2 for each STATEMENT call APP.proc_no_sql()");
1:        //--- insert 2 rows. check that trigger is fired - procedure should be called once
1:        s.execute("insert into t2 values (1,2), (2,4)");
1:        //--- check inserts are successful
1:        rs = s.executeQuery("select * from t2");
1:        JDBC.assertFullResultSet(rs, new String[][] { {"1","2"}, {"2","4"}});
1:        s.execute("drop trigger call_proc_in_default_schema");
1:        s.execute("create trigger call_proc_in_default_schema no cascade BEFORE delete on t2 for each ROW call APP.proc_no_sql()");
1:        //--- delete 2 rows. check that trigger is fired - procedure should be called twice
1:        s.execute("delete from t2");
1:        //--- check delete is successful
1:        rs = s.executeQuery("select * from t2");
1:       JDBC.assertEmpty(rs);
1:       s.execute("drop trigger call_proc_in_default_schema");
1:       s.execute("create trigger call_proc_in_new_schema no cascade BEFORE insert on t2 for each STATEMENT call new_schema.proc_in_new_schema()");
1:       //--- insert 2 rows. check that trigger is fired - procedure should be called once
1:       s.execute("insert into t2 values (1,2), (2,4)");
1:       //--- check inserts are successful
1:       rs = s.executeQuery("select * from t2");
1:       JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:       s.execute("drop trigger call_proc_in_new_schema");
1:       s.execute("create trigger call_proc_in_new_schema AFTER delete on t2 for each ROW call new_schema.proc_in_new_schema()");
1:       //--- delete 2 rows. check that trigger is fired - procedure should be called twice
1:       s.execute("delete from t2");
1:       //--- check delete is successful
1:       rs = s.executeQuery("select * from t2");
1:       JDBC.assertEmpty(rs);
1:       s.execute("drop trigger call_proc_in_new_schema");
1:       
1:     }
1: 
1:     /**
1:      * Some misc negative tests for procedures in triggers.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testTriggerNegative() throws SQLException {
0:         Connection conn = getConnection();
1:         Statement s = conn.createStatement();
1:         ResultSet rs;
1:         assertStatementError("42Y03",s,"create trigger call_non_existent_proc1 AFTER insert on t2 for each ROW call non_existent_proc()");
0:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where triggername='CALL_NON_EXISTENT_PROC1'");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:           assertStatementError("42Y03",s,"create trigger call_proc_with_non_existent_proc2 AFTER insert on t2 for each ROW call new_schema.non_existent_proc()");
0:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where triggername='CALL_NON_EXISTENT_PROC2'");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:           assertStatementError("42Y07",s,"create trigger call_proc_in_non_existent_schema AFTER insert on t2 for each ROW call non_existent_schema.non_existent_proc()");
0:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where triggername='CALL_PROC_IN_NON_EXISTENT_SCHEMA'");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:           assertStatementError("42X50",s,"create trigger call_proc_using_non_existent_method AFTER insert on t2 for each ROW call proc_using_non_existent_method()");
0:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where triggername='CALL_PROC_WITH_NON_EXISTENT_METHOD'");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:           assertStatementError("42Y03",s,"create trigger call_non_existent_proc1 no cascade BEFORE insert on t2 for each ROW call non_existent_proc()");
0:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where triggername='CALL_NON_EXISTENT_PROC1'");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:           assertStatementError("42Y07",s,"create trigger call_proc_in_non_existent_schema no cascade BEFORE insert on t2 for each ROW call non_existent_schema.non_existent_proc()");
0:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where triggername='CALL_PROC_IN_NON_EXISTENT_SCHEMA'");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});      
1:           assertStatementError("42X50",s,"create trigger call_proc_using_non_existent_method no cascade BEFORE insert on t2 for each ROW call proc_using_non_existent_method()");
0:           rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where triggername='CALL_PROC_WITH_NON_EXISTENT_METHOD'");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:           //--- triggers must not allow dynamic parameters (?)
1:           
1:           assertStatementError("42Y27",s,"create trigger update_trig AFTER insert on t1 for each STATEMENT call proc_modifies_sql_update_op(?)");
1:           s.execute("insert into t2 values (1,2), (2,4)");
1:           // --- use procedure with commit
1:           s.execute("create trigger commit_trig AFTER delete on t2 for each STATEMENT call commit_proc()");
1:           assertStatementError("38000",s,"delete from t2");
1:           rs = s.executeQuery("select * from t2");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:           s.execute("drop trigger commit_trig");
1:           s.execute("create trigger commit_trig no cascade BEFORE delete on t2 for each STATEMENT call commit_proc()");
1:           // -- should fail
1:           assertStatementError("38000",s,"delete from t2");
1:           //--- check delete failed
1:           rs = s.executeQuery("select * from t2");
1:           JDBC.assertFullResultSet(rs,new String[][] {{"1","2"}, {"2","4"}});
1:           s.execute("drop trigger commit_trig");
1:           //--- use procedure with rollback
1:           s.execute("create trigger rollback_trig AFTER delete on t2 for each STATEMENT call rollback_proc()");
1:           assertStatementError("38000",s,"delete from t2");
1:           //--- check delete failed
1:           rs = s.executeQuery("select * from t2");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:           s.execute("drop trigger rollback_trig");
1:           s.execute("create trigger rollback_trig no cascade BEFORE delete on t2 for each STATEMENT call rollback_proc()");
1:           //--- should fail
1:           assertStatementError("38000",s,"delete from t2");
1:           //--- check delete failed
1:           rs = s.executeQuery("select * from t2");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:           s.execute("drop trigger rollback_trig");
1:           //--- use procedure which changes isolation level
1:           s.execute("create trigger set_isolation_trig AFTER delete on t2 for each STATEMENT call set_isolation_proc()");
1:           assertStatementError("38000",s,"delete from t2");
1:           //--- check delete failed
1:           rs = s.executeQuery("select * from t2");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:           s.execute("drop trigger set_isolation_trig");
1:           s.execute("create trigger set_isolation_trig no cascade BEFORE delete on t2 for each STATEMENT call set_isolation_proc()");
1:           assertStatementError("38000",s,"delete from t2");
1:           //--- check delete failed
1:           rs = s.executeQuery("select * from t2");
1:           JDBC.assertFullResultSet(rs, new String[][] {{"1","2"},{"2","4"}});
1:           s.execute("drop trigger set_isolation_trig");
1:           // --- call procedure that selects from same trigger table
1:           s.execute("create trigger select_from_trig_table AFTER insert on t1 for each STATEMENT call proc_reads_sql(1)");
1:           //--- insert 2 rows check that trigger is fired - procedure should be called once
1:           s.execute("insert into t1 values (10, 'ten')");
1:           //--- check inserts are successful
1:           rs = s.executeQuery("select * from t1");
1:           String [][] expectedRows = { {"5","two"},{"6","four"},{"8","eight"},{"10","ten"}};
1:           JDBC.assertFullResultSet(rs,expectedRows );
1:           s.execute("drop trigger select_from_trig_table");
1:           s.execute("create trigger select_from_trig_table no cascade before delete on t1 for each STATEMENT call proc_reads_sql(1)");
1:           //--- delete a row. check that trigger is fired - procedure should be called once
1:           //RESOLVE: How to check
1:           s.execute("delete from t1 where i=10");
1:           // --- check delete is successful
1:           rs = s.executeQuery("select * from t1");
1:           expectedRows = new String[][] { {"5","two"},{"6","four"},{"8","eight"}};
1:           JDBC.assertFullResultSet(rs, expectedRows);
1:           s.execute("drop trigger select_from_trig_table");
1:           //--- use procedures which alter/drop trigger table and some other table
1:           s.execute("create trigger alter_table_trig AFTER delete on t1 for each STATEMENT call alter_table_proc()");
1:           assertStatementError("38000",s,"delete from t1");
1:           // check delete failed
1:           rs = s.executeQuery("select * from t1");
1:           expectedRows = new String[][] { {"5","two"},{"6","four"},{"8","eight"}};
1:           JDBC.assertFullResultSet(rs, expectedRows);
1:           s.execute("create trigger drop_table_trig AFTER delete on t2 for each STATEMENT call drop_table_proc()");
1:           // should fail
1:          assertStatementError("38000",s,"delete from t2");
1:          // check delete failed
1:          rs = s.executeQuery("select * from t2");
1:          JDBC.assertFullResultSet(rs,new String[][] {{"1","2"}, {"2","4"}});
1:          s.execute("drop trigger drop_table_trig");
1:          //--- use procedures which create/drop trigger on trigger table and some other table
1:          s.execute("create trigger create_trigger_trig AFTER delete on t1 for each STATEMENT call create_trigger_proc()");
1:          // -- should fail
1:          assertStatementError("38000",s,"delete from t1");
1:          //--- check delete failed
1:          rs = s.executeQuery("select * from t1");
1:          expectedRows = new String[][] { {"5","two"},{"6","four"},{"8","eight"}};
1:          //--- check trigger is not created
0:          rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where triggername='TEST_TRIG'");
1:          s.execute("drop trigger create_trigger_trig");
1:          //--- create a trigger to test we cannot drop it from a procedure called by a trigger
1:          s.execute("create trigger test_trig AFTER delete on t1 for each STATEMENT insert into  t1 values(20, 'twenty')");
1:          s.execute("create trigger drop_trigger_trig AFTER delete on t2 for each STATEMENT call drop_trigger_proc()");
1:          assertStatementError("38000",s,"delete from t2");
1:          //--- check delete failed
1:          rs = s.executeQuery("select * from t2");
1:          JDBC.assertFullResultSet(rs,new String[][] {{"1","2"}, {"2","4"}});
1:          //--- check trigger is not dropped
0:          rs = s.executeQuery("select count(*) from SYS.SYSTRIGGERS where triggername='TEST_TRIG'");
1:          s.execute("drop trigger drop_trigger_trig");
1:          //- use procedures which create/drop index on trigger table and some other table
1:          s.execute("create trigger create_index_trig AFTER delete on t2 for each STATEMENT call create_index_proc()");
1:          // -- should fail
1:          assertStatementError("38000",s,"delete from t2");
1:          // check delete failed
1:          rs = s.executeQuery("select * from t2");
1:          JDBC.assertFullResultSet(rs,new String[][] {{"1","2"}, {"2","4"}});
1:          // -- check index is not created
0:          rs = s.executeQuery("select count(*) from SYS.SYSCONGLOMERATES where CONGLOMERATENAME='IX' and ISINDEX=1");
1:          s.execute("drop trigger create_index_trig");
1:          //--- create an index to test we cannot drop it from a procedure called by a trigger
1:          s.execute("create index ix on t1(i,b)");
1:          s.execute("create trigger drop_index_trig AFTER delete on t1 for each STATEMENT call drop_index_proc()");
1:          assertStatementError("38000",s,"delete from t1");
1:          // -- check delete failed
1:          rs = s.executeQuery("select * from t1");
1:          expectedRows = new String[][] { {"5","two"},{"6","four"},{"8","eight"}};
1:          // -- check index is not dropped
0:          rs = s.executeQuery("select count(*) from SYS.SYSCONGLOMERATES where CONGLOMERATENAME='IX' and ISINDEX=1");
1:          JDBC.assertFullResultSet(rs, new String[][] {{"1"}});
1:          
1:     }
1:     
1:     
1:     
1:     private static Test basesuite() {
0:         Test basesuite = new TestSuite(ProcedureInTriggerTest.class);
1:         Test clean = new CleanDatabaseTestSetup(basesuite) {
1:         protected void decorateSQL(Statement s) throws SQLException {
1:             s.execute("create table t1 (i int primary key, b char(15))");
1:             s.execute("create table t2 (x integer, y integer)");
1:             s.execute("create procedure proc_no_sql() parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.zeroArg'");
1:             s.execute("create procedure proc_contains_sql() parameter style java language java CONTAINS SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.getConnectionProc'");
1:             s.execute("create procedure proc_reads_sql(i integer) parameter style java language java READS SQL DATA external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.selectRows' dynamic result sets 1");
1:             s.execute("create procedure proc_modifies_sql_insert_op(p1 int, p2 char(10)) parameter style java language java MODIFIES SQL DATA external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.insertRow'");
1:             s.execute("create procedure proc_modifies_sql_update_op(p1 int) parameter style java language java  MODIFIES SQL DATA  external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.updateRow'");
1:             s.execute("create procedure proc_modifies_sql_delete_op(p1 int) parameter style java language java MODIFIES SQL DATA external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.deleteRow'");
1:             s.execute("create procedure alter_table_proc() parameter style java language java external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.alterTable'");
1:             s.execute("create procedure drop_table_proc() parameter style java language java external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.dropTable'");
1:             s.execute("create procedure commit_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.doConnCommit'");
1:             s.execute("create procedure rollback_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.doConnRollback'");
1:             s.execute("create procedure set_isolation_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.doConnectionSetIsolation'");
1:             s.execute("create procedure create_index_proc() parameter style java dynamic result sets 0 language java  contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.createIndex'");
1:             s.execute("create procedure drop_index_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.dropIndex'");
1:             s.execute("create procedure create_trigger_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.createTrigger'");
1:             s.execute(" create procedure drop_trigger_proc() parameter style java dynamic result sets 0 language java contains sql external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.dropTrigger'");
1:             s.execute("create procedure proc_wrongly_defined_as_no_sql(p1 int, p2 char(10)) parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.insertRow'");
1:             // create a new schema and put a procedure in it.
1:             s.execute("create schema new_schema");
1:             s.execute("create procedure new_schema.proc_in_new_schema() parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.zeroArg'");
1:             // procedure which uses non-existant method
1:             s.execute("create procedure proc_using_non_existent_method() parameter style java language java NO SQL external name 'org.apache.derbyTesting.functionTests.tests.lang.ProcedureInTriggerTest.nonexistentMethod'");
1:        
1:             
1:         }};
1:         
1:         return clean;
1:         }
1:                 
1:         public static Test suite() { 
0:             TestSuite suite = new TestSuite();
0:             if (!JDBC.vmSupportsJSR169())
1:                 suite.addTest(basesuite());
1:             return suite;
1:         }
1: 
1:         private void checkAndResetZeroArgCount(int count) {
1:             assertEquals(count, zeroArgCount);
1:             zeroArgCount = 0;
1:          }      
1:         
1:         // PROCEDURES
1:         private static int zeroArgCount = 0;
1:         public static void zeroArg() {
1:             zeroArgCount++;
1:         }
1:         
1:         private static int getConnectionProcCount = 0;
1:         
1:         private void checkAndResetGetConnectionProcCount(int count) {
1:             assertEquals(count, getConnectionProcCount);
1:             getConnectionProcCount = 0;
1:          }
1:         
1:         public static void getConnectionProc() throws Throwable
1:         {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 Statement s = conn.createStatement();
1:                 conn.close();
1:                 getConnectionProcCount++;
1:         }
1:         
1:         private static int selectRowsCount = 0;
1:         
1:         private void checkAndResetSelectRowsCount(int count) {
1:             assertEquals(count, selectRowsCount);
1:             selectRowsCount = 0;
1:          }
1:         
1:         public static void selectRows(int p1, ResultSet[] data) throws SQLException {
1: 
1:                 
1: 
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1:                 ps.setInt(1, p1);
1:                 data[0] = ps.executeQuery();
1:                 conn.close();
1:                 selectRowsCount++;
1:         }
1:         
1:         public static void selectRows(int p1, int p2, ResultSet[] data1, ResultSet[] data2) throws SQLException {
1: 
1:                 
1: 
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1:                 ps.setInt(1, p1);
1:                 data1[0] = ps.executeQuery();
1: 
1:                 ps = conn.prepareStatement("select * from t1 where i >= ?");
1:                 ps.setInt(1, p2);
1:                 data2[0] = ps.executeQuery();
1: 
1:                 if (p2 == 99)
1:                         data2[0].close();
1: 
1:                 // return no results
1:                 if (p2 == 199) {
1:                         data1[0].close();
1:                         data1[0] = null;
1:                         data2[0].close();
1:                         data2[0] = null;
1:                 }
1: 
1:                 // swap results
1:                 if (p2 == 299) {
1:                         ResultSet rs = data1[0];
1:                         data1[0] = data2[0];
1:                         data2[0] = rs;
1:                 }
1: 
1:                 conn.close();
1:                 selectRowsCount++;
1:         }
1: 
1:         // select all rows from a table
1:         public static void selectRows(String table, ResultSet[] rs)
1:                 throws SQLException
1:         {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 Statement stmt = conn.createStatement();
1:                 rs[0] = stmt.executeQuery("SELECT * FROM " + table);
1:                 conn.close();
1:                 selectRowsCount++;
1:         }
1: 
1: 
1:         public static void insertRow(int p1) throws SQLException {
1:                 insertRow(p1, "int");
1:         }
1: 
1:         public static void insertRow(int p1, String p2) throws SQLException {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("insert into t1 values (?, ?)");
1:                 ps.setInt(1, p1);
1:                 ps.setString(2, p2);
1:                 ps.executeUpdate();
1:                 ps.close();
1:                 conn.close();
1:         }
1:         
1:         public static void updateRow(int p1) throws SQLException {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("update t1 set i=i+?");
1:                 ps.setInt(1, p1);
1:                 ps.executeUpdate();
1:                 ps.close();
1:                 conn.close();
1:         }
1:         
1:         public static void deleteRow(int p1) throws SQLException {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("delete from t1 where i=?");
1:                 ps.setInt(1, p1);
1:                 ps.executeUpdate();
1:                 ps.close();
1:                 conn.close();
1:         }
1: 
1:         public static void alterTable() throws SQLException {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("alter table t1 add column test integer");
1:                 ps.execute();
1:                 ps.close();
1:                 conn.close();
1:         }
1: 
1:         public static void dropTable() throws SQLException {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("drop table t1");
1:                 ps.execute();
1:                 ps.close();
1:                 conn.close();
1:         }               
1:         public static int doConnCommitInt() throws Throwable
1:         {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 conn.commit();
1:                 return 1;
1:         }
1: 
1:         public static void doConnCommit() throws Throwable
1:         {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 conn.commit();
1:         }        
1: 
1:         public static void doConnRollback() throws Throwable
1:         {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 conn.rollback();
1:         }
1: 
1:         public static void doConnectionSetIsolation() throws Throwable
1:         {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:         }
1:         
1:         public static void createIndex() throws SQLException {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("create index ix on t1(i,b)");
1:                 ps.execute();
1:                 ps.close();
1:                 conn.close();
1:         }
1: 
1:         public static void dropIndex() throws SQLException {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("drop index ix");
1:                 ps.execute();
1:                 ps.close();
1:                 conn.close();
1:         }
1:         
1:         public static void createTrigger() throws SQLException {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("create trigger test_trig" +
1:                                 " AFTER delete on t1 for each STATEMENT insert into" +
1:                                 " t1 values(20, 'twenty')");
1:                 ps.execute();
1:                 ps.close();
1:                 conn.close();
1:         }
1:         
1: 
1:         public static void dropTrigger() throws SQLException {
1:                 Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps = conn.prepareStatement("drop trigger test_trig");
1:                 ps.execute();
1:                 ps.close();
1:                 conn.close();
1:         }
1:         
1: }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:3ef9ee0
/////////////////////////////////////////////////////////////////////////
0:             //--- Bug DERBY-1629 -- in JDK 1.6 you only get 38001, not 38000
0:             if (!JDBC.vmSupportsJDBC4())
0:             {
0:                 assertSQLState("38000", se);
0:                 se = se.getNextException();
0:             }
============================================================================