1:eac0369: /*
1:69a192a: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:eac0369: 
1:7d0f620: import org.apache.derby.iapi.sql.execute.RowChanger;
1:2700e3d: import org.apache.derby.iapi.types.SQLBoolean;
1:eac0369: import org.apache.derby.iapi.types.SQLInteger;
1:eac0369: 
1:eac0369: /**
1:2700e3d:  *
1:eac0369:  * Provide insensitive scrolling functionality for the underlying
1:2700e3d:  * result set.  We build a disk backed hash table of rows as the 
1:2700e3d:  * user scrolls forward, with the position as the key.
1:2700e3d:  *
1:2700e3d:  * For read-only result sets the hash table will containg the
1:2700e3d:  * following columns:
1:2700e3d:  *<pre>
1:2700e3d:  *  +-------------------------------+
1:2700e3d:  *  | KEY                           |
1:2700e3d:  *  +-------------------------------+
1:2700e3d:  *  | Row                           |
1:2700e3d:  *  +-------------------------------+
1:2700e3d:  *</pre>
1:2700e3d:  * where key is the position of the row in the result set and row is the data.
1:2700e3d:  *
1:2700e3d:  * And for updatable result sets it will contain:
1:2700e3d:  * <pre>
1:2700e3d:  *  +-------------------------------+
1:2700e3d:  *  | KEY                           | [0]
1:2700e3d:  *  +-------------------------------+
1:2700e3d:  *  | RowLocation                   | [POS_ROWLOCATION]
1:2700e3d:  *  +-------------------------------+
1:2700e3d:  *  | Deleted                       | [POS_ROWDELETED]
1:2700e3d:  *  +-------------------------------+
1:2700e3d:  *  | Updated                       | [POS_ROWUPDATED]
1:2700e3d:  *  +-------------------------------+
1:2700e3d:  *  | Row                           | [extraColumns ... n]
1:2700e3d:  *  +-------------------------------+
1:2700e3d:  *</pre>
1:2700e3d:  * where key is the position of the row in the result set, rowLocation is
1:2700e3d:  * the row location of that row in the Heap, Deleted indicates whether the
1:2700e3d:  * row has been deleted, Updated indicates whether the row has been updated,
1:2700e3d:  * and row is the data.
1:2700e3d:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public class ScrollInsensitiveResultSet extends NoPutResultSetImpl
1:eac0369: 	implements CursorResultSet
4:eac0369: {
1:eac0369: 	/*
1:eac0369:     ** Set in constructor and not altered during life of object.
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     public NoPutResultSet	source;
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	private int							sourceRowWidth;
1:eac0369: 
1:eac0369: 	private	  BackingStoreHashtable		ht;
1:eac0369: 	private	  ExecRow					resultRow;
1:eac0369: 
1:eac0369: 	// Scroll tracking
1:eac0369: 	private int positionInSource;
1:eac0369: 	private int currentPosition;
1:eac0369: 	private int lastPosition;
1:eac0369: 	private	boolean seenFirst;
1:eac0369: 	private	boolean seenLast;
1:eac0369: 	private	boolean beforeFirst = true;
1:eac0369: 	private	boolean afterLast;
1:eac0369: 
1:eac0369: 	public int numFromHashTable;
1:eac0369: 	public int numToHashTable;
1:eac0369: 
1:47a8183: 	private long maxRows;
1:eac0369: 
1:b223f72:     private boolean keepAfterCommit;
1:eac0369: 
1:2700e3d: 	/* The hash table will contain a different number of extra columns depending
1:2700e3d: 	 * on whether the result set is updatable or not.
1:2700e3d: 	 * extraColumns will contain the number of extra columns on the hash table,
1:2700e3d: 	 * 1 for read-only result sets and LAST_EXTRA_COLUMN + 1 for updatable 
1:2700e3d: 	 * result sets.
1:eac0369: 	 */
1:2700e3d: 	private int extraColumns;
1:eac0369: 	
1:2700e3d: 	/* positionInHashTable is used for getting a row from the hash table. Prior
1:2700e3d: 	 * to getting the row, positionInHashTable will be set to the desired KEY.
1:2700e3d: 	 */
1:2700e3d: 	private SQLInteger positionInHashTable;
1:eac0369: 
1:2700e3d: 	/* Reference to the target result set. Target is used for updatable result
1:2700e3d: 	 * sets in order to keep the target result set on the same row as the
1:2700e3d: 	 * ScrollInsensitiveResultSet.  
1:2700e3d: 	 */
1:2700e3d: 	private CursorResultSet target;
1:eac0369: 
1:2700e3d: 	/* If the last row was fetched from the HashTable, updatable result sets
1:2700e3d: 	 * need to be positioned in the last fetched row before resuming the 
1:2700e3d: 	 * fetch from core.
1:2700e3d: 	 */
1:2700e3d: 	private boolean needsRepositioning;
1:eac0369: 
1:2700e3d: 	/* Position of the different fields in the hash table row for updatable
1:2700e3d: 	 * result sets 
1:2700e3d: 	 */
1:2700e3d: 	private static final int POS_ROWLOCATION = 1;
1:2700e3d: 	private static final int POS_ROWDELETED = 2;
1:2700e3d: 	private static final int POS_ROWUPDATED = 3;
1:2700e3d: 	private static final int LAST_EXTRA_COLUMN = 3;
1:a03c87f: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for a ScrollInsensitiveResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param source					The NoPutResultSet from which to get rows
1:eac0369: 	 *									to scroll through
1:eac0369: 	 * @param activation				The activation for this execution
1:eac0369: 	 * @param resultSetNumber			The resultSetNumber
1:eac0369: 	 * @param sourceRowWidth			# of columns in the source row
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public ScrollInsensitiveResultSet(NoPutResultSet source,
1:eac0369: 							  Activation activation, int resultSetNumber,
1:eac0369: 							  int sourceRowWidth,
1:eac0369: 							  double optimizerEstimatedRowCount,
1:f77f36d: 							  double optimizerEstimatedCost) throws StandardException
1:eac0369: 	{
1:eac0369: 		super(activation, resultSetNumber, 
1:eac0369: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
1:eac0369: 		this.source = source;
1:eac0369: 		this.sourceRowWidth = sourceRowWidth;
1:b223f72:         keepAfterCommit = activation.getResultSetHoldability();
1:eac0369: 		maxRows = activation.getMaxRows();
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(maxRows != -1,
1:eac0369: 				"maxRows not expected to be -1");
1:eac0369: 		}
1:7d0f620: 
1:2700e3d: 		positionInHashTable = new SQLInteger();
1:2700e3d: 		needsRepositioning = false;
1:2700e3d: 		if (isForUpdate()) {
1:2700e3d: 			target = ((CursorActivation)activation).getTargetResultSet();
1:2700e3d: 			extraColumns = LAST_EXTRA_COLUMN + 1;
1:2700e3d: 		} else {
1:2700e3d: 			target = null;
1:2700e3d: 			extraColumns = 1;
1:eac0369: 		}
1:7008b63: 		
1:7008b63: 		recordConstructorTime();
1:2700e3d: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * open a scan on the source. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 	    	SanityManager.ASSERT( ! isOpen, "ScrollInsensitiveResultSet already open");
1:eac0369: 
1:eac0369:         source.openCore();
1:eac0369: 	    isOpen = true;
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		/* Create the hash table.  We pass
1:eac0369: 		 * null in as the row source as we will
1:eac0369: 		 * build the hash table on demand as
1:eac0369: 		 * the user scrolls.
1:eac0369: 		 * The 1st column, the position in the
1:eac0369: 		 * scan, will be the key column.
1:eac0369: 		 */
1:b7c1f3b: 		final int[] keyCols = new int[] { 0 };
1:eac0369: 		
1:eac0369: 		/* We don't use the optimizer row count for this because it could be
1:eac0369: 		 * wildly pessimistic.  We only use Hash tables when the optimizer row count
1:eac0369: 		 * is within certain bounds.  We have no alternative for scrolling insensitive 
1:eac0369: 		 * cursors so we'll just trust that it will fit.
1:eac0369: 		 * We need BackingStoreHashtable to actually go to disk when it doesn't fit.
1:eac0369: 		 * This is a known limitation.
1:eac0369: 		 */
1:b223f72: 		ht = new BackingStoreHashtable(getTransactionController(),
1:eac0369: 									   null,
1:eac0369: 									   keyCols,
1:eac0369: 									   false,
1:eac0369: 										-1, // don't trust optimizer row count
1:eac0369: 									   HashScanResultSet.DEFAULT_MAX_CAPACITY,
1:eac0369: 									   HashScanResultSet.DEFAULT_INITIAL_CAPACITY,
1:eac0369: 									   HashScanResultSet.DEFAULT_MAX_CAPACITY,
1:b223f72: 									   false,
1:b223f72:                                        keepAfterCommit);
1:eac0369: 
1:b56d957: 		// When re-using language result sets (DERBY-827) we need to
1:b56d957: 		// reset some member variables to the value they would have
1:b56d957: 		// had in a newly constructed object.
1:b56d957: 		lastPosition = 0;
1:b56d957: 		needsRepositioning = false;
1:b56d957: 		numFromHashTable = 0;
1:b56d957: 		numToHashTable = 0;
1:b56d957: 		positionInSource = 0;
1:b56d957: 		seenFirst = false;
1:b56d957: 		seenLast = false;
1:af2b77d: 		maxRows = activation.getMaxRows();
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 		setBeforeFirstRow();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * reopen a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369:      */
1:eac0369: 	public void	reopenCore() throws StandardException 
1:eac0369: 	{
1:eac0369: 		boolean constantEval = true;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 		    SanityManager.ASSERT(isOpen, "ScrollInsensitiveResultSet already open");
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"reopenCore() not expected to be called");
1:eac0369: 		}
1:eac0369: 		setBeforeFirstRow();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row at the absolute position from the query, 
1:eac0369: 	 * and returns NULL when there is no such position.
1:eac0369: 	 * (Negative position means from the end of the result set.)
1:eac0369: 	 * Moving the cursor to an invalid position leaves the cursor
1:eac0369: 	 * positioned either before the first row (negative position)
1:eac0369: 	 * or after the last row (positive position).
1:eac0369: 	 * NOTE: An exception will be thrown on 0.
1:eac0369: 	 *
1:eac0369: 	 * @param row	The position.
1:eac0369: 	 * @return	The row at the absolute position, or NULL if no such position.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:e4f7ee9: 	 * @see org.apache.derby.iapi.sql.Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "absolute");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:ff0fafb:                 // Absolute 0 is defined to be before first!
1:eac0369: 		if (row == 0)
1:eac0369: 		{
1:ff0fafb:                     setBeforeFirstRow();
1:ff0fafb:                     return null;
1:eac0369: 		}
1:eac0369: 
1:634980a: 		if (seenLast && row > lastPosition) {
1:634980a: 		   return setAfterLastRow();
1:a03c87f: 		}		
1:eac0369: 
1:eac0369: 		if (row > 0)
1:eac0369: 		{
1:eac0369: 			// position is from the start of the result set
1:eac0369: 			if (row <= positionInSource)
1:eac0369: 			{
1:eac0369: 				// We've already seen the row before
1:eac0369: 				return getRowFromHashTable(row);
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			/* We haven't seen the row yet, scan until we find
1:eac0369: 			 * it or we get to the end.
1:eac0369: 			 */
1:eac0369: 			int diff = row - positionInSource;
1:eac0369: 			ExecRow result = null;
1:eac0369: 			while (diff > 0)
1:eac0369: 			{
1:eac0369: 				if ((result = getNextRowFromSource()) != null)
1:eac0369: 				{
1:eac0369: 					diff--;
1:eac0369: 				}
2:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:a03c87f: 			if (result != null) {
1:a03c87f: 				result = getRowFromHashTable(row);
1:a03c87f: 			}
2:eac0369: 			currentRow = result;
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 		else if (row < 0)
1:eac0369: 		{
1:eac0369: 			// position is from the end of the result set
1:eac0369: 
1:eac0369: 			// Get the last row, if we haven't already
1:eac0369: 			if (!seenLast)
1:eac0369: 			{
2:eac0369: 				getLastRow();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Note, for negative values position is from beyond the end
1:eac0369: 			// of the result set, e.g. absolute(-1) points to the last row
1:eac0369: 			int beyondResult = lastPosition + 1;
1:eac0369: 			if (beyondResult + row > 0)
1:eac0369: 			{
1:eac0369: 				// valid row
1:eac0369: 				return getRowFromHashTable(beyondResult + row);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// position before the beginning of the result set
1:eac0369: 				return setBeforeFirstRow();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369:  
2:eac0369: 		currentRow = null;
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row at the relative position from the current
1:eac0369: 	 * cursor position, and returns NULL when there is no such position.
1:eac0369: 	 * (Negative position means toward the beginning of the result set.)
1:eac0369: 	 * Moving the cursor to an invalid position leaves the cursor
1:eac0369: 	 * positioned either before the first row (negative position)
1:eac0369: 	 * or after the last row (positive position).
1:eac0369: 	 * NOTE: 0 is valid.
1:eac0369: 	 * NOTE: An exception is thrown if the cursor is not currently
1:eac0369: 	 * positioned on a row.
1:eac0369: 	 *
1:eac0369: 	 * @param row	The position.
1:eac0369: 	 * @return	The row at the relative position, or NULL if no such position.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:e4f7ee9: 	 * @see org.apache.derby.iapi.sql.Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getRelativeRow(int row) throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "relative");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Return the current row for 0
1:eac0369: 		if (row == 0)
1:eac0369: 		{
1:bc50840:                     if (beforeFirst || afterLast || currentPosition==0) {
1:ff0fafb:                         return null;
1:ff0fafb:                     } else {
1:eac0369: 			return getRowFromHashTable(currentPosition);
1:ff0fafb:                     }
1:eac0369: 		}
1:eac0369: 		else if (row > 0)
1:eac0369: 		{
1:eac0369: 			return getAbsoluteRow(currentPosition + row);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// row < 0
1:eac0369: 			if (currentPosition + row < 0)
1:eac0369: 			{
1:eac0369: 				return setBeforeFirstRow();
1:eac0369: 			}
1:eac0369: 			return getAbsoluteRow(currentPosition + row);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the current position to before the first row and returns NULL
1:eac0369: 	 * because there is no current row.
1:eac0369: 	 *
1:eac0369: 	 * @return	NULL.
1:eac0369: 	 *
1:e4f7ee9: 	 * @see org.apache.derby.iapi.sql.Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	setBeforeFirstRow() 
1:eac0369: 	{
1:eac0369: 		currentPosition = 0;
1:eac0369: 		beforeFirst = true;
1:eac0369: 		afterLast = false;
1:eac0369: 		currentRow = null;
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the first row from the query, and returns NULL when there
1:eac0369: 	 * are no rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The first row, or NULL if no rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:e4f7ee9: 	 * @see org.apache.derby.iapi.sql.Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getFirstRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "first");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Get the row from the hash table if
1:eac0369: 		 * we have already seen it before.
1:eac0369: 		 */
1:eac0369: 		if (seenFirst)
1:eac0369: 		{
1:eac0369: 			return getRowFromHashTable(1);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return getNextRowCore();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException
1:eac0369: 	{
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 		ExecRow result = null;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (!isOpen)
2:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1:eac0369: 
1:634980a: 		if (seenLast && currentPosition == lastPosition) {
1:634980a: 		   return setAfterLastRow();
1:eac0369: 		}
1:b56d957: 
1:eac0369: 		/* Should we get the next row from the source or the hash table? */
1:eac0369: 		if (currentPosition == positionInSource)
1:eac0369: 		{
1:eac0369: 			/* Current position is same as position in source.
1:eac0369: 			 * Get row from the source.
1:eac0369: 			 */
1:eac0369: 			result = getNextRowFromSource();
1:a03c87f: 			if (result !=null) {
1:a03c87f: 				result = getRowFromHashTable(currentPosition);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else if (currentPosition < positionInSource)
1:eac0369: 		{
1:eac0369: 			/* Current position is before position in source.
1:eac0369: 			 * Get row from the hash table.
1:eac0369: 			 */
1:eac0369: 			result = getRowFromHashTable(currentPosition + 1);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			result = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (result != null)
1:eac0369: 		{
1:eac0369: 			rowsSeen++;
1:eac0369: 			afterLast = false;
1:eac0369: 		}
1:eac0369: 
1:4e784bb: 		setCurrentRow(result);
1:eac0369: 		beforeFirst = false;
1:eac0369: 
1:eac0369: 		nextTime += getElapsedMillis(beginTime);
1:eac0369: 
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the previous row from the query, and returns NULL when there
1:eac0369: 	 * are no more previous rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The previous row, or NULL if no more previous rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:e4f7ee9: 	 * @see org.apache.derby.iapi.sql.Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getPreviousRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:1fd3180: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "previous");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* No row if we are positioned before the first row
1:eac0369: 		 * or the result set is empty.
1:eac0369: 		 */
1:eac0369: 		if (beforeFirst || currentPosition == 0)
1:eac0369: 		{
1:eac0369: 			currentRow = null;
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Get the last row, if we are after it
1:eac0369: 		if (afterLast)
1:eac0369: 		{
1:eac0369: 			// Special case for empty tables
2:eac0369: 			if (lastPosition == 0)
1:eac0369: 			{
1:eac0369: 				afterLast = false;
1:eac0369: 				beforeFirst = false;
1:eac0369: 				currentRow = null;
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
2:eac0369: 				return getRowFromHashTable(lastPosition);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Move back 1
1:eac0369: 		currentPosition--;
1:eac0369: 		if (currentPosition == 0)
1:eac0369: 		{
1:eac0369: 			setBeforeFirstRow();
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 		return getRowFromHashTable(currentPosition);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the last row from the query, and returns NULL when there
1:eac0369: 	 * are no rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The last row, or NULL if no rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:e4f7ee9: 	 * @see org.apache.derby.iapi.sql.Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getLastRow()
1:eac0369: 		throws StandardException
1:eac0369: 	{		
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1:eac0369: 		}
1:eac0369: 		
1:a03c87f: 		if (!seenLast) 
1:eac0369: 		{
1:eac0369: 			attachStatementContext();
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (!isTopResultSet)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 											  this + "expected to be the top ResultSet");
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			/* Scroll to the end, filling the hash table as
1:eac0369: 			 * we scroll, and return the last row that we find.
1:eac0369: 			 */
1:a03c87f: 			ExecRow result = null;
1:eac0369: 			while ((result = getNextRowFromSource()) != null);
1:eac0369: 		}
1:eac0369: 		
1:a03c87f: 		if (SanityManager.DEBUG && !seenLast)
1:eac0369: 		{
1:a03c87f: 			SanityManager.THROWASSERT(this + "expected to have seen last");
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		beforeFirst = false;
1:eac0369: 		afterLast = false;
1:eac0369: 
1:eac0369: 		// Special case if table is empty
1:eac0369: 		if (lastPosition == 0)
1:eac0369: 		{
1:eac0369: 			currentRow = null;
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return getRowFromHashTable(lastPosition);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the current position to after the last row and returns NULL
1:eac0369: 	 * because there is no current row.
1:eac0369: 	 *
1:eac0369: 	 * @return	NULL.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:e4f7ee9: 	 * @see org.apache.derby.iapi.sql.Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	setAfterLastRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! seenLast)
1:eac0369: 		{
1:eac0369: 			getLastRow();
1:eac0369: 		}
1:634980a: 		if (lastPosition == 0) {
1:634980a: 		   // empty rs special case
1:634980a: 		   currentPosition = 0;
1:634980a: 		   afterLast = false;
1:634980a: 		} else {
1:eac0369: 		   currentPosition = lastPosition + 1;
1:eac0369: 		   afterLast = true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		beforeFirst = false;
1:eac0369: 		currentRow = null;
1:eac0369: 		return null;
1:eac0369: 	}
1:a03c87f: 
1:eac0369:     /**
1:eac0369:      * Determine if the cursor is before the first row in the result 
1:eac0369:      * set.   
1:eac0369:      *
1:eac0369:      * @return true if before the first row, false otherwise. Returns
1:eac0369:      * false when the result set contains no rows.
1:eac0369: 	 * @exception StandardException Thrown on error.
1:eac0369:      */
1:eac0369:    public boolean checkRowPosition(int isType) throws StandardException
1:eac0369: 	{
1:eac0369: 		switch (isType) {
1:eac0369: 		case ISBEFOREFIRST:
1:eac0369: 
1:eac0369: 			if (! beforeFirst)
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			//  Spec says to return false if result set is empty
1:eac0369: 			if (seenFirst)
1:eac0369: 			{
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				ExecRow firstRow = getFirstRow();
1:eac0369: 				if (firstRow == null)
1:eac0369: 				{
1:eac0369: 					// ResultSet is empty
1:eac0369: 					return false;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					// ResultSet is not empty - reset position
1:eac0369: 					getPreviousRow();
1:eac0369: 					return true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		case ISFIRST:
1:eac0369: 			return (currentPosition == 1);
1:eac0369: 		case ISLAST:
1:7855f49: 			if (beforeFirst || afterLast || currentPosition==0 ||
1:7855f49: 				currentPosition<positionInSource)
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}			
1:eac0369: 			
1:7855f49: 			/* If we have seen the last row, we can tell if we are 
1:7855f49: 			 * on it by comparing currentPosition with lastPosition.
1:7855f49: 			 * Otherwise, we check if there is a next row.
1:eac0369: 			 */
2:eac0369: 			if (seenLast)
1:eac0369: 			{
1:7855f49: 				return (currentPosition == lastPosition);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:7855f49: 				final int savePosition = currentPosition;
1:7855f49: 				final boolean retval = (getNextRowFromSource() == null);
1:eac0369: 				getRowFromHashTable(savePosition);
1:eac0369: 				return retval;
1:eac0369: 			}
1:eac0369: 		case ISAFTERLAST:
1:eac0369: 			return afterLast;
1:eac0369: 		default:
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row number of the current row.  Row
1:eac0369: 	 * numbers start from 1 and go to 'n'.  Corresponds
1:eac0369: 	 * to row numbering used to position current row
1:eac0369: 	 * in the result set (as per JDBC).
1:eac0369: 	 *
1:eac0369: 	 * @return	the row number, or 0 if not on a row
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public int getRowNumber()
1:eac0369: 	{
1:eac0369: 		return currentRow == null ? 0 : currentPosition;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* Get the next row from the source ResultSet tree and insert into the hash table */
1:eac0369: 	private ExecRow getNextRowFromSource() throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecRow		sourceRow = null;
1:eac0369: 		ExecRow		result = null;
1:eac0369: 
1:eac0369: 		/* Don't give back more rows than requested */
1:eac0369: 		if (maxRows > 0 && maxRows == positionInSource)
1:eac0369: 		{
1:eac0369: 			seenLast = true;
1:eac0369: 			lastPosition = positionInSource;
1:eac0369: 			afterLast = true;
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:a03c87f: 
1:2700e3d: 		if (needsRepositioning) {
1:2700e3d: 			positionInLastFetchedRow();
1:2700e3d: 			needsRepositioning = false;
1:a03c87f: 		}
1:eac0369: 		sourceRow = source.getNextRowCore();
1:eac0369: 
1:eac0369: 		if (sourceRow != null)
1:eac0369: 		{
1:eac0369: 			seenFirst = true;
1:eac0369: 			beforeFirst = false;
1:eac0369: 
1:eac0369: 			long beginTCTime = getCurrentTimeMillis();
1:eac0369: 			/* If this is the first row from the source then we create a new row
1:eac0369: 			 * for use when fetching from the hash table.
1:eac0369: 			 */
1:eac0369: 			if (resultRow == null)
1:eac0369: 			{
1:eac0369: 				resultRow = activation.getExecutionFactory().getValueRow(sourceRowWidth);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			positionInSource++;
1:eac0369: 			currentPosition = positionInSource;
1:eac0369: 
1:2700e3d: 			RowLocation rowLoc = null;
1:2700e3d: 			if (source.isForUpdate()) {
1:2700e3d: 				rowLoc = ((CursorResultSet)source).getRowLocation();
1:eac0369: 			}
1:a03c87f: 
1:2700e3d: 			addRowToHashTable(sourceRow, currentPosition, rowLoc, false);
1:a03c87f: 
1:eac0369: 		}
1:eac0369: 		// Remember whether or not we're past the end of the table
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			if (! seenLast)
1:eac0369: 			{
1:eac0369: 				lastPosition = positionInSource;
1:eac0369: 			}
1:eac0369: 			seenLast = true;
1:eac0369: 			// Special case for empty table (afterLast is never true)
1:eac0369: 			if (positionInSource == 0)
1:eac0369: 			{
1:eac0369: 				afterLast = false;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				afterLast = true;
1:5112b50: 				currentPosition = positionInSource + 1;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return sourceRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    if ( isOpen )
1:eac0369: 	    {
1:eac0369: 			currentRow = null;
1:eac0369: 	        source.close();
1:eac0369: 
1:eac0369: 			if (ht != null)
1:eac0369: 			{
1:eac0369: 				ht.close();
1:eac0369: 				ht = null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			super.close();
1:eac0369: 	    }
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of ScrollInsensitiveResultSet repeated");
1:eac0369: 		setBeforeFirstRow();
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	finish() throws StandardException
1:eac0369: 	{
1:eac0369: 		source.finish();
1:eac0369: 		finishAndRTS();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:eac0369: 
1:eac0369: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets information from its source. We might want
1:eac0369: 	 * to have this take a CursorResultSet in its constructor some day,
1:eac0369: 	 * instead of doing a cast here?
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source not CursorResultSet");
1:eac0369: 		return ( (CursorResultSet)source ).getRowLocation();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets information from last getNextRow call.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:2700e3d: 	public ExecRow getCurrentRow() throws StandardException
1:eac0369: 	{
1:2700e3d: 		if (isForUpdate() && isDeleted()) {
1:eac0369: 			return null;
1:2700e3d: 		} else {
1:eac0369: 			return currentRow;
1:eac0369: 		}
1:2700e3d: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class implementation
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:2700e3d: 	 * Add a row to the backing hash table, keyed on position.
1:2700e3d: 	 * When a row gets updated when using scrollable insensitive updatable
1:2700e3d: 	 * result sets, the old entry for the row will be deleted from the hash 
1:2700e3d: 	 * table and this method will be called to add the new values for the row
1:2700e3d: 	 * to the hash table, with the parameter rowUpdated = true so as to mark 
1:2700e3d: 	 * the row as updated. The latter is done in order to implement 
1:2700e3d: 	 * detectability of own changes for result sets of this type.
1:eac0369: 	 *
1:eac0369: 	 * @param sourceRow	The row to add.
1:2700e3d: 	 * @param position The key
1:2700e3d: 	 * @param rowLoc The rowLocation of the row to add.
1:2700e3d: 	 * @param rowUpdated Indicates whether the row has been updated.
1:eac0369: 	 *
1:eac0369: 	 */
1:2700e3d: 	private void addRowToHashTable(ExecRow sourceRow, int position,
1:2700e3d: 			RowLocation rowLoc, boolean rowUpdated)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:2700e3d: 		DataValueDescriptor[] hashRowArray = new 
1:2700e3d: 				DataValueDescriptor[sourceRowWidth + extraColumns];
1:eac0369: 		// 1st element is the key
1:2700e3d: 		hashRowArray[0] = new SQLInteger(position);
1:2700e3d: 		if (isForUpdate()) {
1:854dd10: 			hashRowArray[POS_ROWLOCATION] = rowLoc.cloneValue(false);
1:2700e3d: 			hashRowArray[POS_ROWDELETED] = new SQLBoolean(false);
1:2700e3d: 			hashRowArray[POS_ROWUPDATED] = new SQLBoolean(rowUpdated);
1:2700e3d: 		}
1:eac0369: 
1:eac0369: 		/* Copy rest of elements from sourceRow.
1:eac0369: 		 * NOTE: We need to clone the source row
1:eac0369: 		 * and we do our own cloning since the 1st column
1:eac0369: 		 * is not a wrapper.
1:eac0369: 		 */
1:b7c1f3b: 		DataValueDescriptor[] sourceRowArray = sourceRow.getRowArray();
1:eac0369: 
1:2700e3d: 		System.arraycopy(sourceRowArray, 0, hashRowArray, extraColumns, 
1:2700e3d: 				sourceRowArray.length);
1:eac0369: 
1:e81e52c: 		ht.putRow(true, hashRowArray, null);
1:eac0369: 
1:eac0369: 		numToHashTable++;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the row at the specified position
1:eac0369: 	 * from the hash table.
1:eac0369: 	 *
1:eac0369: 	 * @param position	The specified position.
1:eac0369: 	 *
1:eac0369: 	 * @return	The row at that position.
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369: 	 */
1:eac0369: 	private ExecRow getRowFromHashTable(int position)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		// Get the row from the hash table
1:2700e3d: 		positionInHashTable.setValue(position);
1:e81e52c: 		DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(hashRowArray != null,
1:eac0369: 				"hashRowArray expected to be non-null");
1:eac0369: 		}
1:eac0369: 		// Copy out the Object[] without the position.
1:2700e3d: 		DataValueDescriptor[] resultRowArray = new 
1:2700e3d: 				DataValueDescriptor[hashRowArray.length - extraColumns];
1:2700e3d: 		System.arraycopy(hashRowArray, extraColumns, resultRowArray, 0, 
1:2700e3d: 				resultRowArray.length);
1:eac0369: 
1:eac0369: 		resultRow.setRowArray(resultRowArray);
1:eac0369: 
1:eac0369: 		// Reset the current position to the user position
1:eac0369: 		currentPosition = position;
1:eac0369: 
1:eac0369: 		numFromHashTable++;
1:eac0369: 
1:eac0369: 		if (resultRow != null)
1:eac0369: 		{
1:eac0369: 			beforeFirst = false;
1:eac0369: 			afterLast = false;
1:eac0369: 		}
1:eac0369: 
1:2700e3d: 		if (isForUpdate()) {
1:2700e3d: 			RowLocation rowLoc = (RowLocation) hashRowArray[POS_ROWLOCATION];
1:2700e3d: 			// Keep source and target with the same currentRow
1:2700e3d: 			((NoPutResultSet)target).setCurrentRow(resultRow);
1:2700e3d: 			((NoPutResultSet)target).positionScanAtRowLocation(rowLoc);
1:2700e3d: 			needsRepositioning = true;
1:2700e3d: 		}
1:eac0369: 		
1:2700e3d: 		setCurrentRow(resultRow);
1:2700e3d: 
1:eac0369: 		return resultRow;
1:eac0369: 	}
1:2700e3d: 	
1:eac0369: 	/**
1:b7c1f3b: 	 * Get the row data at the specified position 
1:b7c1f3b: 	 * from the hash table.
1:2700e3d: 	 *
1:b7c1f3b: 	 * @param position	The specified position.
2:b7c1f3b: 	 *
1:b7c1f3b: 	 * @return	The row data at that position.
1:b7c1f3b: 	 *
1:b7c1f3b:  	 * @exception StandardException thrown on failure 
1:a03c87f: 	 */
1:b7c1f3b: 	private DataValueDescriptor[] getRowArrayFromHashTable(int position)
1:b7c1f3b: 		throws StandardException
1:eac0369: 	{
1:b7c1f3b: 		positionInHashTable.setValue(position);
1:e81e52c: 		final DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
1:2700e3d: 		
1:b7c1f3b: 		// Copy out the Object[] without the position.
1:b7c1f3b: 		final DataValueDescriptor[] resultRowArray = new 
1:b7c1f3b: 			DataValueDescriptor[hashRowArray.length - extraColumns];
1:b7c1f3b: 		System.arraycopy(hashRowArray, extraColumns, resultRowArray, 0, 
1:b7c1f3b: 						 resultRowArray.length);
1:b7c1f3b: 		return resultRowArray;
1:eac0369: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:2700e3d: 	 * Positions the cursor in the last fetched row. This is done before
1:2700e3d: 	 * navigating to a row that has not previously been fetched, so that
1:2700e3d: 	 * getNextRowCore() will re-start from where it stopped.
1:2700e3d: 	 */
1:2700e3d: 	private void positionInLastFetchedRow() throws StandardException {
1:2700e3d: 		if (positionInSource > 0) {
1:2700e3d: 			positionInHashTable.setValue(positionInSource);
1:e81e52c: 			DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
1:2700e3d: 			RowLocation rowLoc = (RowLocation) hashRowArray[POS_ROWLOCATION];
1:2700e3d: 			((NoPutResultSet)target).positionScanAtRowLocation(rowLoc);
1:2700e3d: 			currentPosition = positionInSource;
1:2700e3d: 		}
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#updateRow
1:2700e3d: 	 *
1:2700e3d: 	 * Sets the updated column of the hash table to true and updates the row
1:2700e3d: 	 * in the hash table with the new values for the row.
2:2700e3d: 	 */
1:7d0f620: 	public void updateRow(ExecRow row, RowChanger rowChanger)
1:7d0f620: 			throws StandardException {
1:2700e3d: 
1:69a192a: 		ProjectRestrictResultSet prRS = null;
1:69a192a: 
1:2700e3d: 		if (source instanceof ProjectRestrictResultSet) {
1:69a192a: 			prRS = (ProjectRestrictResultSet)source;
1:69a192a: 		} else if (source instanceof RowCountResultSet) {
1:69a192a: 			// To do any projection in the presence of an intervening
1:69a192a: 			// RowCountResultSet, we get its child.
1:69a192a: 			prRS = ((RowCountResultSet)source).getUnderlyingProjectRestrictRS();
1:69a192a: 		}
1:69a192a: 
3:2700e3d: 		positionInHashTable.setValue(currentPosition);
1:e81e52c: 		DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
1:2700e3d: 		RowLocation rowLoc = (RowLocation) hashRowArray[POS_ROWLOCATION];
1:7d0f620: 
1:7d0f620: 		// Maps from each selected column to underlying base table column
1:7d0f620: 		// number, i.e. as from getBaseProjectMapping if a PRN exists, if not
1:7d0f620: 		// we construct one, so we always know where in the hash table a
1:7d0f620: 		// modified column will need to go (we do our own projection).
1:7d0f620: 		int[] map;
1:7d0f620: 
1:7d0f620: 		if (prRS != null) {
1:7d0f620: 			map = prRS.getBaseProjectMapping();
1:7d0f620: 		} else {
1:7d0f620: 			// create a natural projection mapping for all columns in SELECT
1:7d0f620: 			// list so we can treat the cases of no PRN and PRN the same.
1:7d0f620: 			int noOfSelectedColumns =
1:7d0f620: 				hashRowArray.length - (LAST_EXTRA_COLUMN+1);
1:7d0f620: 
1:7d0f620: 			map = new int[noOfSelectedColumns];
1:7d0f620: 
1:7d0f620: 			// initialize as 1,2,3, .. n which we know is correct since there
1:7d0f620: 			// is no underlying PRN.
1:7d0f620: 			for (int i=0; i < noOfSelectedColumns; i++) {
1:7d0f620: 				map[i] = i+1; // column is 1-based
1:7d0f620: 			}
1:7d0f620: 		}
1:7d0f620: 
1:7d0f620: 		// Construct a new row based on the old one and the updated columns
1:7d0f620: 		ExecRow newRow = new ValueRow(map.length);
1:7d0f620: 
1:7d0f620: 		for (int i=0; i < map.length; i++) {
1:7d0f620: 			// What index in ExecRow "row" corresponds to this position in the
1:7d0f620: 			// hash table, if any?
1:7d0f620: 			int rowColumn = rowChanger.findSelectedCol(map[i]);
1:7d0f620: 
1:7d0f620: 			if (rowColumn > 0) {
1:7d0f620: 				// OK, a new value has been supplied, use it
1:7d0f620: 				newRow.setColumn(i+1, row.getColumn(rowColumn));
1:7d0f620: 			} else {
1:7d0f620: 				// No new value, so continue using old one
1:7d0f620: 				newRow.setColumn(i+1, hashRowArray[LAST_EXTRA_COLUMN + 1 + i]);
1:7d0f620: 			}
1:7d0f620: 		}
1:7d0f620: 
1:2700e3d: 		ht.remove(new SQLInteger(currentPosition));
1:2700e3d: 		addRowToHashTable(newRow, currentPosition, rowLoc, true);
1:7d0f620: 
1:b7c1f3b: 		// Modify row to refer to data in the BackingStoreHashtable.
1:b7c1f3b: 		// This allows reading of data which goes over multiple pages
1:b7c1f3b: 		// when doing the actual update (LOBs). Putting columns of
1:b7c1f3b: 		// type SQLBinary to disk, has destructive effect on the columns,
1:b7c1f3b: 		// and they need to be re-read. That is the reason this is needed.
1:7d0f620: 
1:7d0f620: 		DataValueDescriptor[] backedData =
1:7d0f620: 			getRowArrayFromHashTable(currentPosition);
1:7d0f620: 
1:7d0f620: 		for (int i=0; i < map.length; i++) {
1:7d0f620: 			// What index in "row" corresponds to this position in the table,
1:7d0f620: 			// if any?
1:7d0f620: 			int rowColumn = rowChanger.findSelectedCol(map[i]);
1:7d0f620: 
1:7d0f620: 			if (rowColumn > 0) {
1:7d0f620: 				// OK, put the value in the hash table back to row.
1:7d0f620: 				row.setColumn(rowColumn, backedData[i]);
1:2700e3d: 			}
1:2700e3d: 		}
1:2700e3d: 	}
1:69a192a: 
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#markRowAsDeleted
1:2700e3d: 	 *
1:2700e3d: 	 * Sets the deleted column of the hash table to true in the current row.
1:2700e3d: 	 */
1:2700e3d: 	public void markRowAsDeleted() throws StandardException  {
1:2700e3d: 		positionInHashTable.setValue(currentPosition);
1:e81e52c: 		DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
1:2700e3d: 		RowLocation rowLoc = (RowLocation) hashRowArray[POS_ROWLOCATION];
1:2700e3d: 		ht.remove(new SQLInteger(currentPosition));
1:2700e3d: 		((SQLBoolean)hashRowArray[POS_ROWDELETED]).setValue(true);
1:2700e3d: 		// Set all columns to NULL, the row is now a placeholder
1:2700e3d: 		for (int i=extraColumns; i<hashRowArray.length; i++) {
1:2700e3d: 			hashRowArray[i].setToNull();
1:2700e3d: 		}
1:2700e3d: 
1:e81e52c: 		ht.putRow(true, hashRowArray, null);
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:2700e3d: 	 * Returns TRUE if the row was been deleted within the transaction,
1:2700e3d: 	 * otherwise returns FALSE
1:2700e3d: 	 *
1:2700e3d: 	 * @return True if the row has been deleted, otherwise false
1:2700e3d: 	 *
1:2700e3d: 	 * @exception StandardException on error
1:2700e3d: 	 */
1:2700e3d: 	public boolean isDeleted() throws StandardException  {
1:16f1998: 		if (currentPosition <= positionInSource && currentPosition > 0) {
1:16f1998: 			positionInHashTable.setValue(currentPosition);
1:e81e52c: 			DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
1:16f1998: 			return hashRowArray[POS_ROWDELETED].getBoolean();
1:16f1998: 		}
1:16f1998: 		return false;
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:2700e3d: 	 * Returns TRUE if the row was been updated within the transaction,
1:2700e3d: 	 * otherwise returns FALSE
1:2700e3d: 	 *
1:2700e3d: 	 * @return True if the row has been deleted, otherwise false
1:2700e3d: 	 *
1:2700e3d: 	 * @exception StandardException on error
1:2700e3d: 	 */
1:2700e3d: 	public boolean isUpdated() throws StandardException {
1:16f1998: 		if (currentPosition <= positionInSource && currentPosition > 0) {
1:16f1998: 			positionInHashTable.setValue(currentPosition);
1:e81e52c: 			DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
1:16f1998: 			return hashRowArray[POS_ROWUPDATED].getBoolean();
1:16f1998: 		}
1:16f1998: 		return false;
1:2700e3d: 	}
9:2700e3d: 
1:2700e3d: 	public boolean isForUpdate() {
1:2700e3d: 		return source.isForUpdate();
1:2700e3d: 	}
1:2700e3d: 
1:e81e52c:     /** Get the column array from the current position in the hash table */
1:e81e52c:     private DataValueDescriptor[]   getCurrentRowFromHashtable()
1:e81e52c:         throws StandardException
1:e81e52c:     {
1:e81e52c:         return unpackHashValue( ht.get(positionInHashTable) );
1:e81e52c:     }
1:e81e52c: 
1:2700e3d: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:e81e52c
/////////////////////////////////////////////////////////////////////////
1: 		ht.putRow(true, hashRowArray, null);
/////////////////////////////////////////////////////////////////////////
1: 		DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
/////////////////////////////////////////////////////////////////////////
1: 		final DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
/////////////////////////////////////////////////////////////////////////
1: 			DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
/////////////////////////////////////////////////////////////////////////
1: 		DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
/////////////////////////////////////////////////////////////////////////
1: 		DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
/////////////////////////////////////////////////////////////////////////
1: 		ht.putRow(true, hashRowArray, null);
/////////////////////////////////////////////////////////////////////////
1: 			DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
/////////////////////////////////////////////////////////////////////////
1: 			DataValueDescriptor[] hashRowArray = getCurrentRowFromHashtable();
/////////////////////////////////////////////////////////////////////////
1:     /** Get the column array from the current position in the hash table */
1:     private DataValueDescriptor[]   getCurrentRowFromHashtable()
1:         throws StandardException
1:     {
1:         return unpackHashValue( ht.get(positionInHashTable) );
1:     }
1: 
commit:47a8183
/////////////////////////////////////////////////////////////////////////
1: 	private long maxRows;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:1fd3180
/////////////////////////////////////////////////////////////////////////
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "previous");
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1: 			hashRowArray[POS_ROWLOCATION] = rowLoc.cloneValue(false);
commit:af2b77d
/////////////////////////////////////////////////////////////////////////
1: 		maxRows = activation.getMaxRows();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.RowChanger;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	public void updateRow(ExecRow row, RowChanger rowChanger)
1: 			throws StandardException {
/////////////////////////////////////////////////////////////////////////
0: 		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[])
1: 
1: 		// Maps from each selected column to underlying base table column
1: 		// number, i.e. as from getBaseProjectMapping if a PRN exists, if not
1: 		// we construct one, so we always know where in the hash table a
1: 		// modified column will need to go (we do our own projection).
1: 		int[] map;
1: 
1: 		if (prRS != null) {
1: 			map = prRS.getBaseProjectMapping();
1: 		} else {
1: 			// create a natural projection mapping for all columns in SELECT
1: 			// list so we can treat the cases of no PRN and PRN the same.
1: 			int noOfSelectedColumns =
1: 				hashRowArray.length - (LAST_EXTRA_COLUMN+1);
1: 
1: 			map = new int[noOfSelectedColumns];
1: 
1: 			// initialize as 1,2,3, .. n which we know is correct since there
1: 			// is no underlying PRN.
1: 			for (int i=0; i < noOfSelectedColumns; i++) {
1: 				map[i] = i+1; // column is 1-based
1: 			}
1: 		}
1: 
1: 		// Construct a new row based on the old one and the updated columns
1: 		ExecRow newRow = new ValueRow(map.length);
1: 
1: 		for (int i=0; i < map.length; i++) {
1: 			// What index in ExecRow "row" corresponds to this position in the
1: 			// hash table, if any?
1: 			int rowColumn = rowChanger.findSelectedCol(map[i]);
1: 
1: 			if (rowColumn > 0) {
1: 				// OK, a new value has been supplied, use it
1: 				newRow.setColumn(i+1, row.getColumn(rowColumn));
1: 			} else {
1: 				// No new value, so continue using old one
1: 				newRow.setColumn(i+1, hashRowArray[LAST_EXTRA_COLUMN + 1 + i]);
1: 			}
1: 		}
1: 
1: 
1: 
1: 		DataValueDescriptor[] backedData =
1: 			getRowArrayFromHashTable(currentPosition);
1: 
1: 		for (int i=0; i < map.length; i++) {
1: 			// What index in "row" corresponds to this position in the table,
1: 			// if any?
1: 			int rowColumn = rowChanger.findSelectedCol(map[i]);
1: 
1: 			if (rowColumn > 0) {
1: 				// OK, put the value in the hash table back to row.
1: 				row.setColumn(rowColumn, backedData[i]);
commit:69a192a
/////////////////////////////////////////////////////////////////////////
1: 
1: 		ProjectRestrictResultSet prRS = null;
1: 
1: 			prRS = (ProjectRestrictResultSet)source;
1: 		} else if (source instanceof RowCountResultSet) {
1: 			// To do any projection in the presence of an intervening
1: 			// RowCountResultSet, we get its child.
1: 			prRS = ((RowCountResultSet)source).getUnderlyingProjectRestrictRS();
1: 		}
1: 
0: 		if (prRS != null) {
0: 			newRow = prRS.doBaseRowProjection(row);
1: 
/////////////////////////////////////////////////////////////////////////
0: 			final int[] origPos = prRS.getBaseProjectMapping();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4e784bb
/////////////////////////////////////////////////////////////////////////
1: 		setCurrentRow(result);
commit:7008b63
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		recordConstructorTime();
commit:e8e04bf
/////////////////////////////////////////////////////////////////////////
0: 		ht.putRow(true, hashRowArray);
/////////////////////////////////////////////////////////////////////////
0: 		ht.putRow(true, hashRowArray);
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 							  double optimizerEstimatedCost) throws StandardException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ff0fafb
/////////////////////////////////////////////////////////////////////////
1:                 // Absolute 0 is defined to be before first!
1:                     setBeforeFirstRow();
1:                     return null;
/////////////////////////////////////////////////////////////////////////
0:                     if ((beforeFirst || afterLast) ||
0:                         (!beforeFirst && !afterLast)) {
1:                         return null;
1:                     } else {
1:                     }
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.Row;
1: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.types.SQLInteger;
1: 
1: /**
1:  * Provide insensitive scrolling functionality for the underlying
0:  * result set.  We build a hash table of rows as the user scrolls
0:  * forward, with the position as the key.
1:  */
1: 
1: public class ScrollInsensitiveResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/*
1:     ** Set in constructor and not altered during life of object.
1: 	*/
1: 
1:     public NoPutResultSet	source;
1: 
1: 
1: 
1: 	private int							sourceRowWidth;
0: 	private TransactionController		tc;
1: 
1: 	private	  BackingStoreHashtable		ht;
1: 	private	  ExecRow					resultRow;
1: 
1: 	// Scroll tracking
1: 	private int positionInSource;
1: 	private int currentPosition;
1: 	private int lastPosition;
1: 	private	boolean seenFirst;
1: 	private	boolean seenLast;
1: 	private	boolean beforeFirst = true;
1: 	private	boolean afterLast;
1: 
1: 	public int numFromHashTable;
1: 	public int numToHashTable;
1: 
0: 	private int maxRows;
1: 
0:     private GeneratedMethod closeCleanup;
1: 
1: 	/**
1: 	 * Constructor for a ScrollInsensitiveResultSet
1: 	 *
1: 	 * @param source					The NoPutResultSet from which to get rows
1: 	 *									to scroll through
1: 	 * @param activation				The activation for this execution
1: 	 * @param resultSetNumber			The resultSetNumber
1: 	 * @param sourceRowWidth			# of columns in the source row
1: 	 *
1: 	 * @exception StandardException	on error
1: 	 */
1: 
1: 	public ScrollInsensitiveResultSet(NoPutResultSet source,
1: 							  Activation activation, int resultSetNumber,
1: 							  int sourceRowWidth,
1: 							  double optimizerEstimatedRowCount,
0: 							  double optimizerEstimatedCost,
0: 							  GeneratedMethod c) throws StandardException
1: 	{
1: 		super(activation, resultSetNumber, 
1: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
1: 		this.source = source;
1: 		this.sourceRowWidth = sourceRowWidth;
1: 		maxRows = activation.getMaxRows();
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(maxRows != -1,
1: 				"maxRows not expected to be -1");
1: 		}
1: 
0:         closeCleanup = c;
0: 		constructorTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 
1: 	/**
1:      * open a scan on the source. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1:      */
1: 	public void	openCore() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if (SanityManager.DEBUG)
1: 	    	SanityManager.ASSERT( ! isOpen, "ScrollInsensitiveResultSet already open");
1: 
1:         source.openCore();
1: 	    isOpen = true;
1: 		numOpens++;
1: 
1: 		/* Create the hash table.  We pass
1: 		 * null in as the row source as we will
1: 		 * build the hash table on demand as
1: 		 * the user scrolls.
1: 		 * The 1st column, the position in the
1: 		 * scan, will be the key column.
1: 		 */
0: 		int[] keyCols = new int[1];
0: 		// keyCols[0] = 0; // not req. arrays initialized to zero
1: 
1: 		/* We don't use the optimizer row count for this because it could be
1: 		 * wildly pessimistic.  We only use Hash tables when the optimizer row count
1: 		 * is within certain bounds.  We have no alternative for scrolling insensitive 
1: 		 * cursors so we'll just trust that it will fit.
1: 		 * We need BackingStoreHashtable to actually go to disk when it doesn't fit.
1: 		 * This is a known limitation.
1: 		 */
0: 		ht = new BackingStoreHashtable(tc,
1: 									   null,
1: 									   keyCols,
1: 									   false,
1: 										-1, // don't trust optimizer row count
1: 									   HashScanResultSet.DEFAULT_MAX_CAPACITY,
1: 									   HashScanResultSet.DEFAULT_INITIAL_CAPACITY,
1: 									   HashScanResultSet.DEFAULT_MAX_CAPACITY,
0: 									   false);
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 		setBeforeFirstRow();
1: 	}
1: 
1: 	/**
1:      * reopen a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public void	reopenCore() throws StandardException 
1: 	{
1: 		boolean constantEval = true;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 		    SanityManager.ASSERT(isOpen, "ScrollInsensitiveResultSet already open");
1: 			SanityManager.THROWASSERT(
1: 				"reopenCore() not expected to be called");
1: 		}
1: 		setBeforeFirstRow();
1: 	}
1: 
1: 	/**
1: 	 * Returns the row at the absolute position from the query, 
1: 	 * and returns NULL when there is no such position.
1: 	 * (Negative position means from the end of the result set.)
1: 	 * Moving the cursor to an invalid position leaves the cursor
1: 	 * positioned either before the first row (negative position)
1: 	 * or after the last row (positive position).
1: 	 * NOTE: An exception will be thrown on 0.
1: 	 *
1: 	 * @param row	The position.
1: 	 * @return	The row at the absolute position, or NULL if no such position.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
1: 	 */
1: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "absolute");
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 		}
1: 
0: 		// 0 is an invalid parameter
1: 		if (row == 0)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_ZERO_INVALID_FOR_R_S_ABSOLUTE);
1: 		}
1: 
1: 		if (row > 0)
1: 		{
1: 			// position is from the start of the result set
1: 			if (row <= positionInSource)
1: 			{
1: 				// We've already seen the row before
1: 				return getRowFromHashTable(row);
1: 			}
1: 			
1: 			/* We haven't seen the row yet, scan until we find
1: 			 * it or we get to the end.
1: 			 */
1: 			int diff = row - positionInSource;
1: 			ExecRow result = null;
1: 			while (diff > 0)
1: 			{
1: 				if ((result = getNextRowFromSource()) != null)
1: 				{
1: 					diff--;
1: 				}
1: 				else
1: 				{
1: 					break;
1: 				}
1: 			}
1: 			currentRow = result;
1: 			return result;
1: 		}
1: 		else if (row < 0)
1: 		{
1: 			// position is from the end of the result set
1: 
1: 			// Get the last row, if we haven't already
1: 			if (!seenLast)
1: 			{
1: 				getLastRow();
1: 			}
1: 
1: 			// Note, for negative values position is from beyond the end
1: 			// of the result set, e.g. absolute(-1) points to the last row
1: 			int beyondResult = lastPosition + 1;
1: 			if (beyondResult + row > 0)
1: 			{
1: 				// valid row
1: 				return getRowFromHashTable(beyondResult + row);
1: 			}
1: 			else
1: 			{
1: 				// position before the beginning of the result set
1: 				return setBeforeFirstRow();
1: 			}
1: 		}
1:  
1: 		currentRow = null;
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the row at the relative position from the current
1: 	 * cursor position, and returns NULL when there is no such position.
1: 	 * (Negative position means toward the beginning of the result set.)
1: 	 * Moving the cursor to an invalid position leaves the cursor
1: 	 * positioned either before the first row (negative position)
1: 	 * or after the last row (positive position).
1: 	 * NOTE: 0 is valid.
1: 	 * NOTE: An exception is thrown if the cursor is not currently
1: 	 * positioned on a row.
1: 	 *
1: 	 * @param row	The position.
1: 	 * @return	The row at the relative position, or NULL if no such position.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
1: 	 */
1: 	public ExecRow	getRelativeRow(int row) throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "relative");
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 		}
1: 
0: 		/* Throw exception if before first or after last */
0: 		if (beforeFirst || afterLast)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_NO_CURRENT_ROW_FOR_RELATIVE);
1: 		}
1: 
1: 		// Return the current row for 0
1: 		if (row == 0)
1: 		{
1: 			return getRowFromHashTable(currentPosition);
1: 		}
1: 		else if (row > 0)
1: 		{
1: 			return getAbsoluteRow(currentPosition + row);
1: 		}
1: 		else
1: 		{
1: 			// row < 0
1: 			if (currentPosition + row < 0)
1: 			{
1: 				return setBeforeFirstRow();
1: 			}
1: 			return getAbsoluteRow(currentPosition + row);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Sets the current position to before the first row and returns NULL
1: 	 * because there is no current row.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
0: 	 * @see Row
1: 	 */
1: 	public ExecRow	setBeforeFirstRow() 
1: 	{
1: 		currentPosition = 0;
1: 		beforeFirst = true;
1: 		afterLast = false;
1: 		currentRow = null;
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the first row from the query, and returns NULL when there
1: 	 * are no rows.
1: 	 *
1: 	 * @return	The first row, or NULL if no rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
1: 	 */
1: 	public ExecRow	getFirstRow() 
1: 		throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "first");
1: 		}
1: 
1: 		/* Get the row from the hash table if
1: 		 * we have already seen it before.
1: 		 */
1: 		if (seenFirst)
1: 		{
1: 			return getRowFromHashTable(1);
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 		}
1: 
1: 		return getNextRowCore();
1: 	}
1: 
1: 	/**
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1: 	 */
1: 	public ExecRow	getNextRowCore() throws StandardException
1: 	{
1: 		ExecRow result = null;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 		if (!isOpen)
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1: 
1: 		/* Should we get the next row from the source or the hash table? */
1: 		if (currentPosition == positionInSource)
1: 		{
1: 			/* Current position is same as position in source.
1: 			 * Get row from the source.
1: 			 */
1: 			result = getNextRowFromSource();
1: 		}
1: 		else if (currentPosition < positionInSource)
1: 		{
1: 			/* Current position is before position in source.
1: 			 * Get row from the hash table.
1: 			 */
1: 			result = getRowFromHashTable(currentPosition + 1);
1: 		}
1: 		else
1: 		{
1: 			result = null;
1: 		}
1: 
1: 		if (result != null)
1: 		{
1: 			rowsSeen++;
1: 			afterLast = false;
1: 		}
1: 
1: 		currentRow = result;
0: 		setCurrentRow(currentRow);
1: 		beforeFirst = false;
1: 
1: 		nextTime += getElapsedMillis(beginTime);
1: 
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	 * Returns the previous row from the query, and returns NULL when there
1: 	 * are no more previous rows.
1: 	 *
1: 	 * @return	The previous row, or NULL if no more previous rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
1: 	 */
1: 	public ExecRow	getPreviousRow() 
1: 		throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 		}
1: 
1: 		/* No row if we are positioned before the first row
1: 		 * or the result set is empty.
1: 		 */
1: 		if (beforeFirst || currentPosition == 0)
1: 		{
1: 			currentRow = null;
1: 			return null;
1: 		}
1: 
1: 		// Get the last row, if we are after it
1: 		if (afterLast)
1: 		{
1: 			// Special case for empty tables
1: 			if (lastPosition == 0)
1: 			{
1: 				afterLast = false;
1: 				beforeFirst = false;
1: 				currentRow = null;
1: 				return null;
1: 			}
1: 			else
1: 			{
1: 				return getRowFromHashTable(lastPosition);
1: 			}
1: 		}
1: 
1: 		// Move back 1
1: 		currentPosition--;
1: 		if (currentPosition == 0)
1: 		{
1: 			setBeforeFirstRow();
1: 			return null;
1: 		}
1: 		return getRowFromHashTable(currentPosition);
1: 	}
1: 
1: 	/**
1: 	 * Returns the last row from the query, and returns NULL when there
1: 	 * are no rows.
1: 	 *
1: 	 * @return	The last row, or NULL if no rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
1: 	 */
1: 	public ExecRow	getLastRow()
1: 		throws StandardException
1: 	{
0: 		ExecRow result;
1: 
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1: 		}
1: 
0: 		/* Have we already seen the last row? */
1: 		if (seenLast)
1: 		{
0: 			// Return null if the set was empty
1: 			if (lastPosition == 0)
1: 			{
1: 				currentRow = null;
1: 				return null;
1: 			}
1: 			else
1: 			{
1: 				return getRowFromHashTable(lastPosition);
1: 			}
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 		}
1: 
1: 		/* Scroll to the end, filling the hash table as
1: 		 * we scroll, and return the last row that we find.
1: 		 */
1: 		while ((result = getNextRowFromSource()) != null);
1: 		beforeFirst = false;
1: 		afterLast = false;
1: 
1: 		// Special case if table is empty
1: 		if (lastPosition == 0)
1: 		{
1: 			currentRow = null;
1: 			return null;
1: 		}
1: 		else
1: 		{
1: 			return getRowFromHashTable(lastPosition);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Sets the current position to after the last row and returns NULL
1: 	 * because there is no current row.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
1: 	 */
1: 	public ExecRow	setAfterLastRow() 
1: 		throws StandardException
1: 	{
1: 		if (! seenLast)
1: 		{
1: 			getLastRow();
1: 		}
1: 		currentPosition = lastPosition + 1;
1: 		afterLast = true;
1: 		beforeFirst = false;
1: 		currentRow = null;
1: 		return null;
1: 	}
1: 
1:     /**
1:      * Determine if the cursor is before the first row in the result 
1:      * set.   
1:      *
1:      * @return true if before the first row, false otherwise. Returns
1:      * false when the result set contains no rows.
1: 	 * @exception StandardException Thrown on error.
1:      */
1:    public boolean checkRowPosition(int isType) throws StandardException
1: 	{
1: 		switch (isType) {
1: 		case ISBEFOREFIRST:
1: 
1: 			if (! beforeFirst)
1: 			{
1: 				return false;
1: 			}
1: 
1: 			//  Spec says to return false if result set is empty
1: 			if (seenFirst)
1: 			{
1: 				return true;
1: 			}
1: 			else
1: 			{
1: 				ExecRow firstRow = getFirstRow();
1: 				if (firstRow == null)
1: 				{
1: 					// ResultSet is empty
1: 					return false;
1: 				}
1: 				else
1: 				{
1: 					// ResultSet is not empty - reset position
1: 					getPreviousRow();
1: 					return true;
1: 				}
1: 			}
1: 		case ISFIRST:
1: 			return (currentPosition == 1);
1: 		case ISLAST:
0: 			if (beforeFirst || afterLast)
1: 			{
1: 				return false;
1: 			}
1: 
0: 			/* If we've already seen the last row
0: 			 * then we can tell if we are on it by
0: 			 * the current position,
0: 			 * otherwise, we need to find the last
0: 			 * row in order to tell if the current row
0: 			 * is the last row.
1: 			 */
1: 			if (seenLast)
1: 			{
0: 				return (currentPosition == lastPosition && currentPosition != 0);
1: 			}
1: 			else
1: 			{
0: 				int savePosition = currentPosition;
0: 				boolean retval = false;
1: 				getLastRow();
0: 				if (savePosition == lastPosition && savePosition != 0)
1: 				{
0: 					retval = true;
1: 				}
1: 				getRowFromHashTable(savePosition);
1: 				return retval;
1: 			}
1: 		case ISAFTERLAST:
1: 			return afterLast;
1: 		default:
1: 			return false;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Returns the row number of the current row.  Row
1: 	 * numbers start from 1 and go to 'n'.  Corresponds
1: 	 * to row numbering used to position current row
1: 	 * in the result set (as per JDBC).
1: 	 *
1: 	 * @return	the row number, or 0 if not on a row
1: 	 *
1: 	 */
1: 	public int getRowNumber()
1: 	{
1: 		return currentRow == null ? 0 : currentPosition;
1: 	}
1: 
1: 	/* Get the next row from the source ResultSet tree and insert into the hash table */
1: 	private ExecRow getNextRowFromSource() throws StandardException
1: 	{
1: 		ExecRow		sourceRow = null;
1: 		ExecRow		result = null;
1: 
1: 		/* Don't give back more rows than requested */
1: 		if (maxRows > 0 && maxRows == positionInSource)
1: 		{
1: 			seenLast = true;
1: 			lastPosition = positionInSource;
1: 			afterLast = true;
1: 			return null;
1: 		}
1: 
1: 		sourceRow = source.getNextRowCore();
1: 
1: 		if (sourceRow != null)
1: 		{
1: 			seenFirst = true;
1: 			beforeFirst = false;
1: 
1: 			long beginTCTime = getCurrentTimeMillis();
1: 			/* If this is the first row from the source then we create a new row
1: 			 * for use when fetching from the hash table.
1: 			 */
1: 			if (resultRow == null)
1: 			{
1: 				resultRow = activation.getExecutionFactory().getValueRow(sourceRowWidth);
1: 			}
1: 
1: 			positionInSource++;
1: 			currentPosition = positionInSource;
0: 			addRowToHashTable(sourceRow);
1: 
1: 		}
1: 		// Remember whether or not we're past the end of the table
1: 		else
1: 		{
1: 			if (! seenLast)
1: 			{
1: 				lastPosition = positionInSource;
1: 			}
1: 			seenLast = true;
1: 			// Special case for empty table (afterLast is never true)
1: 			if (positionInSource == 0)
1: 			{
1: 				afterLast = false;
1: 			}
1: 			else
1: 			{
1: 				afterLast = true;
1: 			}
1: 		}
1: 
1: 		return sourceRow;
1: 	}
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( isOpen )
1: 	    {
0: 			if (closeCleanup != null) 
1: 			{
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			} 
1: 			currentRow = null;
1: 	        source.close();
1: 
1: 			if (ht != null)
1: 			{
1: 				ht.close();
1: 				ht = null;
1: 			}
1: 
1: 			super.close();
1: 	    }
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of ScrollInsensitiveResultSet repeated");
1: 		setBeforeFirstRow();
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	public void	finish() throws StandardException
1: 	{
1: 		source.finish();
1: 		finishAndRTS();
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 
1: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 
1: 	/**
1: 	 * Gets information from its source. We might want
1: 	 * to have this take a CursorResultSet in its constructor some day,
1: 	 * instead of doing a cast here?
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source not CursorResultSet");
1: 		return ( (CursorResultSet)source ).getRowLocation();
1: 	}
1: 
1: 	/**
1: 	 * Gets information from last getNextRow call.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
0: 	public ExecRow getCurrentRow() 
1: 	{
1: 		return currentRow;
1: 	}
1: 
1: 	//
1: 	// class implementation
1: 	//
1: 
1: 	/**
0: 	 * Add a row to the backing hash table,
0: 	 * keyed on positionInSource.
1: 	 *
1: 	 * @param sourceRow	The row to add.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	private void addRowToHashTable(ExecRow sourceRow)
1: 		throws StandardException
1: 	{
0: 		DataValueDescriptor[] hashRowArray = new DataValueDescriptor[sourceRowWidth + 1];
1: 		// 1st element is the key
0: 		hashRowArray[0] = new SQLInteger(positionInSource);
1: 
1: 		/* Copy rest of elements from sourceRow.
1: 		 * NOTE: We need to clone the source row
1: 		 * and we do our own cloning since the 1st column
1: 		 * is not a wrapper.
1: 		 */
0: 		DataValueDescriptor[] sourceRowArray = sourceRow.getRowArrayClone();
1: 
0: 		System.arraycopy(sourceRowArray, 0, hashRowArray, 1, sourceRowArray.length);
1: 
0: 		ht.put(false, hashRowArray);
1: 
1: 		numToHashTable++;
1: 	}
1: 
1: 	/**
1: 	 * Get the row at the specified position
1: 	 * from the hash table.
1: 	 *
1: 	 * @param position	The specified position.
1: 	 *
1: 	 * @return	The row at that position.
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1: 	 */
1: 	private ExecRow getRowFromHashTable(int position)
1: 		throws StandardException
1: 	{
1: 
1: 		// Get the row from the hash table
0: 		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) ht.get(new SQLInteger(position));
1: 
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(hashRowArray != null,
1: 				"hashRowArray expected to be non-null");
1: 		}
1: 		// Copy out the Object[] without the position.
0: 		DataValueDescriptor[] resultRowArray = new DataValueDescriptor[hashRowArray.length - 1];
0: 		System.arraycopy(hashRowArray, 1, resultRowArray, 0, resultRowArray.length);
1: 
1: 		resultRow.setRowArray(resultRowArray);
1: 
1: 		// Reset the current position to the user position
1: 		currentPosition = position;
1: 
1: 		numFromHashTable++;
1: 
1: 		if (resultRow != null)
1: 		{
1: 			beforeFirst = false;
1: 			afterLast = false;
1: 		}
1: 
0: 		currentRow = resultRow;
1: 		return resultRow;
1: 	}
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:b56d957
/////////////////////////////////////////////////////////////////////////
1: 		// When re-using language result sets (DERBY-827) we need to
1: 		// reset some member variables to the value they would have
1: 		// had in a newly constructed object.
1: 		lastPosition = 0;
1: 		needsRepositioning = false;
1: 		numFromHashTable = 0;
1: 		numToHashTable = 0;
1: 		positionInSource = 0;
1: 		seenFirst = false;
1: 		seenLast = false;
1: 
commit:e4f7ee9
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.Row
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.Row
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.Row
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.Row
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.Row
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.Row
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.Row
commit:25c47f7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:16f1998
/////////////////////////////////////////////////////////////////////////
1: 		if (currentPosition <= positionInSource && currentPosition > 0) {
1: 			positionInHashTable.setValue(currentPosition);
0: 			DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
0: 					ht.get(positionInHashTable);
1: 			return hashRowArray[POS_ROWDELETED].getBoolean();
1: 		}
1: 		return false;
/////////////////////////////////////////////////////////////////////////
1: 		if (currentPosition <= positionInSource && currentPosition > 0) {
1: 			positionInHashTable.setValue(currentPosition);
0: 			DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
0: 					ht.get(positionInHashTable);
1: 			return hashRowArray[POS_ROWUPDATED].getBoolean();
1: 		}
1: 		return false;
commit:a03c87f
/////////////////////////////////////////////////////////////////////////
1: 			if (result != null) {
1: 				result = getRowFromHashTable(row);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 			if (result !=null) {
1: 				result = getRowFromHashTable(currentPosition);
1: 			}
/////////////////////////////////////////////////////////////////////////
0: 	{		
1: 		
1: 		if (!seenLast) 
0: 			attachStatementContext();
1: 
0: 			if (SanityManager.DEBUG)
0: 				if (!isTopResultSet)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 											  this + "expected to be the top ResultSet");
1: 				}
1: 			
0: 			/* Scroll to the end, filling the hash table as
0: 			 * we scroll, and return the last row that we find.
1: 			 */
1: 			ExecRow result = null;
0: 			while ((result = getNextRowFromSource()) != null);
1: 		
1: 		if (SanityManager.DEBUG && !seenLast)
1: 			SanityManager.THROWASSERT(this + "expected to have seen last");
1: 		
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.derby.iapi.types.SQLBoolean;
1:  *
1:  * result set.  We build a disk backed hash table of rows as the 
1:  * user scrolls forward, with the position as the key.
1:  *
1:  * For read-only result sets the hash table will containg the
1:  * following columns:
1:  *<pre>
1:  *  +-------------------------------+
1:  *  | KEY                           |
1:  *  +-------------------------------+
1:  *  | Row                           |
1:  *  +-------------------------------+
1:  *</pre>
1:  * where key is the position of the row in the result set and row is the data.
1:  *
1:  * And for updatable result sets it will contain:
1:  * <pre>
1:  *  +-------------------------------+
1:  *  | KEY                           | [0]
1:  *  +-------------------------------+
1:  *  | RowLocation                   | [POS_ROWLOCATION]
1:  *  +-------------------------------+
1:  *  | Deleted                       | [POS_ROWDELETED]
1:  *  +-------------------------------+
1:  *  | Updated                       | [POS_ROWUPDATED]
1:  *  +-------------------------------+
1:  *  | Row                           | [extraColumns ... n]
1:  *  +-------------------------------+
1:  *</pre>
1:  * where key is the position of the row in the result set, rowLocation is
1:  * the row location of that row in the Heap, Deleted indicates whether the
1:  * row has been deleted, Updated indicates whether the row has been updated,
1:  * and row is the data.
1:  *
/////////////////////////////////////////////////////////////////////////
1: 	/* The hash table will contain a different number of extra columns depending
1: 	 * on whether the result set is updatable or not.
1: 	 * extraColumns will contain the number of extra columns on the hash table,
1: 	 * 1 for read-only result sets and LAST_EXTRA_COLUMN + 1 for updatable 
1: 	 * result sets.
1: 	 */
1: 	private int extraColumns;
1: 	
1: 	/* positionInHashTable is used for getting a row from the hash table. Prior
1: 	 * to getting the row, positionInHashTable will be set to the desired KEY.
1: 	 */
1: 	private SQLInteger positionInHashTable;
1: 
1: 	/* Reference to the target result set. Target is used for updatable result
1: 	 * sets in order to keep the target result set on the same row as the
1: 	 * ScrollInsensitiveResultSet.  
1: 	 */
1: 	private CursorResultSet target;
1: 
1: 	/* If the last row was fetched from the HashTable, updatable result sets
1: 	 * need to be positioned in the last fetched row before resuming the 
1: 	 * fetch from core.
1: 	 */
1: 	private boolean needsRepositioning;
1: 
1: 	/* Position of the different fields in the hash table row for updatable
1: 	 * result sets 
1: 	 */
1: 	private static final int POS_ROWLOCATION = 1;
1: 	private static final int POS_ROWDELETED = 2;
1: 	private static final int POS_ROWUPDATED = 3;
1: 	private static final int LAST_EXTRA_COLUMN = 3;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 		positionInHashTable = new SQLInteger();
1: 		needsRepositioning = false;
1: 		if (isForUpdate()) {
1: 			target = ((CursorActivation)activation).getTargetResultSet();
1: 			extraColumns = LAST_EXTRA_COLUMN + 1;
1: 		} else {
1: 			target = null;
1: 			extraColumns = 1;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 
1: 		if (needsRepositioning) {
1: 			positionInLastFetchedRow();
1: 			needsRepositioning = false;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 
1: 			RowLocation rowLoc = null;
1: 			if (source.isForUpdate()) {
1: 				rowLoc = ((CursorResultSet)source).getRowLocation();
1: 			}
1: 
1: 			addRowToHashTable(sourceRow, currentPosition, rowLoc, false);
/////////////////////////////////////////////////////////////////////////
1: 	public ExecRow getCurrentRow() throws StandardException
1: 		if (isForUpdate() && isDeleted()) {
0: 			return null;
1: 		} else {
0: 			return currentRow;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 	 * Add a row to the backing hash table, keyed on position.
1: 	 * When a row gets updated when using scrollable insensitive updatable
1: 	 * result sets, the old entry for the row will be deleted from the hash 
1: 	 * table and this method will be called to add the new values for the row
1: 	 * to the hash table, with the parameter rowUpdated = true so as to mark 
1: 	 * the row as updated. The latter is done in order to implement 
1: 	 * detectability of own changes for result sets of this type.
1: 	 * @param position The key
1: 	 * @param rowLoc The rowLocation of the row to add.
1: 	 * @param rowUpdated Indicates whether the row has been updated.
1: 	 *
1: 	private void addRowToHashTable(ExecRow sourceRow, int position,
1: 			RowLocation rowLoc, boolean rowUpdated)
1: 		DataValueDescriptor[] hashRowArray = new 
1: 				DataValueDescriptor[sourceRowWidth + extraColumns];
1: 		hashRowArray[0] = new SQLInteger(position);
1: 		if (isForUpdate()) {
0: 			hashRowArray[POS_ROWLOCATION] = rowLoc.getClone();
1: 			hashRowArray[POS_ROWDELETED] = new SQLBoolean(false);
1: 			hashRowArray[POS_ROWUPDATED] = new SQLBoolean(rowUpdated);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		System.arraycopy(sourceRowArray, 0, hashRowArray, extraColumns, 
1: 				sourceRowArray.length);
/////////////////////////////////////////////////////////////////////////
1: 		positionInHashTable.setValue(position);
0: 		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
0: 				ht.get(positionInHashTable);
/////////////////////////////////////////////////////////////////////////
1: 		DataValueDescriptor[] resultRowArray = new 
1: 				DataValueDescriptor[hashRowArray.length - extraColumns];
1: 		System.arraycopy(hashRowArray, extraColumns, resultRowArray, 0, 
1: 				resultRowArray.length);
/////////////////////////////////////////////////////////////////////////
1: 		if (isForUpdate()) {
1: 			RowLocation rowLoc = (RowLocation) hashRowArray[POS_ROWLOCATION];
1: 			// Keep source and target with the same currentRow
1: 			((NoPutResultSet)target).setCurrentRow(resultRow);
1: 			((NoPutResultSet)target).positionScanAtRowLocation(rowLoc);
1: 			needsRepositioning = true;
1: 		}
1: 		
1: 		setCurrentRow(resultRow);
1: 
1: 
1: 	/**
1: 	 * Positions the cursor in the last fetched row. This is done before
1: 	 * navigating to a row that has not previously been fetched, so that
1: 	 * getNextRowCore() will re-start from where it stopped.
1: 	 */
1: 	private void positionInLastFetchedRow() throws StandardException {
1: 		if (positionInSource > 0) {
1: 			positionInHashTable.setValue(positionInSource);
0: 			DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
0: 					ht.get(positionInHashTable);
1: 			RowLocation rowLoc = (RowLocation) hashRowArray[POS_ROWLOCATION];
1: 			((NoPutResultSet)target).positionScanAtRowLocation(rowLoc);
1: 			currentPosition = positionInSource;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#updateRow
1: 	 *
1: 	 * Sets the updated column of the hash table to true and updates the row
1: 	 * in the hash table with the new values for the row.
1: 	 */
0: 	public void updateRow(ExecRow row) throws StandardException {
0: 		ExecRow newRow = row.getClone();
1: 		if (source instanceof ProjectRestrictResultSet) {
0: 			newRow = ((ProjectRestrictResultSet)source).
0: 					doBaseRowProjection(newRow);
1: 		}
1: 		positionInHashTable.setValue(currentPosition);
0: 		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
0: 				ht.get(positionInHashTable);
1: 		RowLocation rowLoc = (RowLocation) hashRowArray[POS_ROWLOCATION];
1: 		ht.remove(new SQLInteger(currentPosition));
1: 		addRowToHashTable(newRow, currentPosition, rowLoc, true);
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#markRowAsDeleted
1: 	 *
1: 	 * Sets the deleted column of the hash table to true in the current row.
1: 	 */
1: 	public void markRowAsDeleted() throws StandardException  {
1: 		positionInHashTable.setValue(currentPosition);
0: 		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
0: 				ht.get(positionInHashTable);
1: 		RowLocation rowLoc = (RowLocation) hashRowArray[POS_ROWLOCATION];
1: 		ht.remove(new SQLInteger(currentPosition));
1: 		((SQLBoolean)hashRowArray[POS_ROWDELETED]).setValue(true);
1: 		// Set all columns to NULL, the row is now a placeholder
1: 		for (int i=extraColumns; i<hashRowArray.length; i++) {
1: 			hashRowArray[i].setToNull();
1: 		}
1: 
0: 		ht.put(false, hashRowArray);
1: 	}
1: 
1: 	/**
1: 	 * Returns TRUE if the row was been deleted within the transaction,
1: 	 * otherwise returns FALSE
1: 	 *
1: 	 * @return True if the row has been deleted, otherwise false
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public boolean isDeleted() throws StandardException  {
1: 		positionInHashTable.setValue(currentPosition);
0: 		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
0: 				ht.get(positionInHashTable);
0: 		return hashRowArray[POS_ROWDELETED].getBoolean();
1: 	}
1: 
1: 	/**
1: 	 * Returns TRUE if the row was been updated within the transaction,
1: 	 * otherwise returns FALSE
1: 	 *
1: 	 * @return True if the row has been deleted, otherwise false
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public boolean isUpdated() throws StandardException {
1: 		positionInHashTable.setValue(currentPosition);
0: 		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
0: 				ht.get(positionInHashTable);
0: 		return hashRowArray[POS_ROWUPDATED].getBoolean();			
1: 	}
1: 
1: 	public boolean isForUpdate() {
1: 		return source.isForUpdate();
1: 	}
1: 
commit:634980a
/////////////////////////////////////////////////////////////////////////
1: 		if (seenLast && row > lastPosition) {
1: 		   return setAfterLastRow();
0: 		}		
0: 
/////////////////////////////////////////////////////////////////////////
1: 		if (seenLast && currentPosition == lastPosition) {
1: 		   return setAfterLastRow();
0: 		}
0: 
/////////////////////////////////////////////////////////////////////////
1: 		if (lastPosition == 0) {
1: 		   // empty rs special case
1: 		   currentPosition = 0;
1: 		   afterLast = false;
1: 		} else {
0: 		   currentPosition = lastPosition + 1;
0: 		   afterLast = true;
0: 		}
0: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:bc50840
/////////////////////////////////////////////////////////////////////////
1:                     if (beforeFirst || afterLast || currentPosition==0) {
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:b7c1f3b
/////////////////////////////////////////////////////////////////////////
1: 		final int[] keyCols = new int[] { 0 };
0: 		
/////////////////////////////////////////////////////////////////////////
1: 		DataValueDescriptor[] sourceRowArray = sourceRow.getRowArray();
0: 		ht.put(true, hashRowArray);
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	/**
1: 	 * Get the row data at the specified position 
1: 	 * from the hash table.
1: 	 *
1: 	 * @param position	The specified position.
1: 	 *
1: 	 * @return	The row data at that position.
1: 	 *
1:  	 * @exception StandardException thrown on failure 
0: 	 */
1: 	private DataValueDescriptor[] getRowArrayFromHashTable(int position)
1: 		throws StandardException
0: 	{
1: 		positionInHashTable.setValue(position);
0: 		final DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
0: 			ht.get(positionInHashTable);
0: 		
1: 		// Copy out the Object[] without the position.
1: 		final DataValueDescriptor[] resultRowArray = new 
1: 			DataValueDescriptor[hashRowArray.length - extraColumns];
1: 		System.arraycopy(hashRowArray, extraColumns, resultRowArray, 0, 
1: 						 resultRowArray.length);
1: 		return resultRowArray;
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 		ExecRow newRow = row;
0: 		boolean undoProjection = false;
0: 		
0: 				doBaseRowProjection(row);
0: 			undoProjection = true;
/////////////////////////////////////////////////////////////////////////
0: 		
1: 		// Modify row to refer to data in the BackingStoreHashtable.
1: 		// This allows reading of data which goes over multiple pages
1: 		// when doing the actual update (LOBs). Putting columns of
1: 		// type SQLBinary to disk, has destructive effect on the columns,
1: 		// and they need to be re-read. That is the reason this is needed.
0: 		if (undoProjection) {
0: 			
0: 			final DataValueDescriptor[] newRowData = newRow.getRowArray();
0: 			
0: 			// Array of original position in row
0: 			final int[] origPos =((ProjectRestrictResultSet)source).
0: 				getBaseProjectMapping(); 
0: 			
0: 			// We want the row to contain data backed in BackingStoreHashtable
0: 			final DataValueDescriptor[] backedData = 
0: 				getRowArrayFromHashTable(currentPosition);
0: 			
0: 			for (int i=0; i<origPos.length; i++) {
0: 				if (origPos[i]>=0) {
0: 					row.setColumn(origPos[i], backedData[i]);
0: 				}
0: 			}
0: 		} else {
0: 			row.setRowArray(getRowArrayFromHashTable(currentPosition));
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 		ht.put(true, hashRowArray);
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:7855f49
/////////////////////////////////////////////////////////////////////////
1: 			if (beforeFirst || afterLast || currentPosition==0 ||
1: 				currentPosition<positionInSource)
0: 			}			
0: 			
1: 			/* If we have seen the last row, we can tell if we are 
1: 			 * on it by comparing currentPosition with lastPosition.
1: 			 * Otherwise, we check if there is a next row.
1: 				return (currentPosition == lastPosition);
1: 				final int savePosition = currentPosition;
1: 				final boolean retval = (getNextRowFromSource() == null);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:5112b50
/////////////////////////////////////////////////////////////////////////
1: 				currentPosition = positionInSource + 1;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b223f72
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean keepAfterCommit;
0: 
/////////////////////////////////////////////////////////////////////////
1:         keepAfterCommit = activation.getResultSetHoldability();
/////////////////////////////////////////////////////////////////////////
1: 		ht = new BackingStoreHashtable(getTransactionController(),
/////////////////////////////////////////////////////////////////////////
1: 									   false,
1:                                        keepAfterCommit);
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.Row;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.types.SQLInteger;
0: 
0: /**
0:  * Provide insensitive scrolling functionality for the underlying
0:  * result set.  We build a hash table of rows as the user scrolls
0:  * forward, with the position as the key.
0:  */
0: 
0: public class ScrollInsensitiveResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/*
0:     ** Set in constructor and not altered during life of object.
0: 	*/
0: 
0:     public NoPutResultSet	source;
0: 
0: 
0: 
0: 	private int							sourceRowWidth;
0: 	private TransactionController		tc;
0: 
0: 	private	  BackingStoreHashtable		ht;
0: 	private	  ExecRow					resultRow;
0: 
0: 	// Scroll tracking
0: 	private int positionInSource;
0: 	private int currentPosition;
0: 	private int lastPosition;
0: 	private	boolean seenFirst;
0: 	private	boolean seenLast;
0: 	private	boolean beforeFirst = true;
0: 	private	boolean afterLast;
0: 
0: 	public int numFromHashTable;
0: 	public int numToHashTable;
0: 
0: 	private int maxRows;
0: 
0:     private GeneratedMethod closeCleanup;
0: 
0: 	/**
0: 	 * Constructor for a ScrollInsensitiveResultSet
0: 	 *
0: 	 * @param source					The NoPutResultSet from which to get rows
0: 	 *									to scroll through
0: 	 * @param activation				The activation for this execution
0: 	 * @param resultSetNumber			The resultSetNumber
0: 	 * @param sourceRowWidth			# of columns in the source row
0: 	 *
0: 	 * @exception StandardException	on error
0: 	 */
0: 
0: 	public ScrollInsensitiveResultSet(NoPutResultSet source,
0: 							  Activation activation, int resultSetNumber,
0: 							  int sourceRowWidth,
0: 							  double optimizerEstimatedRowCount,
0: 							  double optimizerEstimatedCost,
0: 							  GeneratedMethod c) throws StandardException
0: 	{
0: 		super(activation, resultSetNumber, 
0: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
0: 		this.source = source;
0: 		this.sourceRowWidth = sourceRowWidth;
0: 		maxRows = activation.getMaxRows();
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(maxRows != -1,
0: 				"maxRows not expected to be -1");
0: 		}
0: 
0:         closeCleanup = c;
0: 		constructorTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 
0: 	/**
0:      * open a scan on the source. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0:      */
0: 	public void	openCore() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT( ! isOpen, "ScrollInsensitiveResultSet already open");
0: 
0:         source.openCore();
0: 	    isOpen = true;
0: 		numOpens++;
0: 
0: 		/* Create the hash table.  We pass
0: 		 * null in as the row source as we will
0: 		 * build the hash table on demand as
0: 		 * the user scrolls.
0: 		 * The 1st column, the position in the
0: 		 * scan, will be the key column.
0: 		 */
0: 		int[] keyCols = new int[1];
0: 		// keyCols[0] = 0; // not req. arrays initialized to zero
0: 
0: 		/* We don't use the optimizer row count for this because it could be
0: 		 * wildly pessimistic.  We only use Hash tables when the optimizer row count
0: 		 * is within certain bounds.  We have no alternative for scrolling insensitive 
0: 		 * cursors so we'll just trust that it will fit.
0: 		 * We need BackingStoreHashtable to actually go to disk when it doesn't fit.
0: 		 * This is a known limitation.
0: 		 */
0: 		ht = new BackingStoreHashtable(tc,
0: 									   null,
0: 									   keyCols,
0: 									   false,
0: 										-1, // don't trust optimizer row count
0: 									   HashScanResultSet.DEFAULT_MAX_CAPACITY,
0: 									   HashScanResultSet.DEFAULT_INITIAL_CAPACITY,
0: 									   HashScanResultSet.DEFAULT_MAX_CAPACITY,
0: 									   false);
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 		setBeforeFirstRow();
0: 	}
0: 
0: 	/**
0:      * reopen a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public void	reopenCore() throws StandardException 
0: 	{
0: 		boolean constantEval = true;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 		    SanityManager.ASSERT(isOpen, "ScrollInsensitiveResultSet already open");
0: 			SanityManager.THROWASSERT(
0: 				"reopenCore() not expected to be called");
0: 		}
0: 		setBeforeFirstRow();
0: 	}
0: 
0: 	/**
0: 	 * Returns the row at the absolute position from the query, 
0: 	 * and returns NULL when there is no such position.
0: 	 * (Negative position means from the end of the result set.)
0: 	 * Moving the cursor to an invalid position leaves the cursor
0: 	 * positioned either before the first row (negative position)
0: 	 * or after the last row (positive position).
0: 	 * NOTE: An exception will be thrown on 0.
0: 	 *
0: 	 * @param row	The position.
0: 	 * @return	The row at the absolute position, or NULL if no such position.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "absolute");
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 		}
0: 
0: 		// 0 is an invalid parameter
0: 		if (row == 0)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_ZERO_INVALID_FOR_R_S_ABSOLUTE);
0: 		}
0: 
0: 		if (row > 0)
0: 		{
0: 			// position is from the start of the result set
0: 			if (row <= positionInSource)
0: 			{
0: 				// We've already seen the row before
0: 				return getRowFromHashTable(row);
0: 			}
0: 			
0: 			/* We haven't seen the row yet, scan until we find
0: 			 * it or we get to the end.
0: 			 */
0: 			int diff = row - positionInSource;
0: 			ExecRow result = null;
0: 			while (diff > 0)
0: 			{
0: 				if ((result = getNextRowFromSource()) != null)
0: 				{
0: 					diff--;
0: 				}
0: 				else
0: 				{
0: 					break;
0: 				}
0: 			}
0: 			currentRow = result;
0: 			return result;
0: 		}
0: 		else if (row < 0)
0: 		{
0: 			// position is from the end of the result set
0: 
0: 			// Get the last row, if we haven't already
0: 			if (!seenLast)
0: 			{
0: 				getLastRow();
0: 			}
0: 
0: 			// Note, for negative values position is from beyond the end
0: 			// of the result set, e.g. absolute(-1) points to the last row
0: 			int beyondResult = lastPosition + 1;
0: 			if (beyondResult + row > 0)
0: 			{
0: 				// valid row
0: 				return getRowFromHashTable(beyondResult + row);
0: 			}
0: 			else
0: 			{
0: 				// position before the beginning of the result set
0: 				return setBeforeFirstRow();
0: 			}
0: 		}
0:  
0: 		currentRow = null;
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the row at the relative position from the current
0: 	 * cursor position, and returns NULL when there is no such position.
0: 	 * (Negative position means toward the beginning of the result set.)
0: 	 * Moving the cursor to an invalid position leaves the cursor
0: 	 * positioned either before the first row (negative position)
0: 	 * or after the last row (positive position).
0: 	 * NOTE: 0 is valid.
0: 	 * NOTE: An exception is thrown if the cursor is not currently
0: 	 * positioned on a row.
0: 	 *
0: 	 * @param row	The position.
0: 	 * @return	The row at the relative position, or NULL if no such position.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getRelativeRow(int row) throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "relative");
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 		}
0: 
0: 		/* Throw exception if before first or after last */
0: 		if (beforeFirst || afterLast)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_NO_CURRENT_ROW_FOR_RELATIVE);
0: 		}
0: 
0: 		// Return the current row for 0
0: 		if (row == 0)
0: 		{
0: 			return getRowFromHashTable(currentPosition);
0: 		}
0: 		else if (row > 0)
0: 		{
0: 			return getAbsoluteRow(currentPosition + row);
0: 		}
0: 		else
0: 		{
0: 			// row < 0
0: 			if (currentPosition + row < 0)
0: 			{
0: 				return setBeforeFirstRow();
0: 			}
0: 			return getAbsoluteRow(currentPosition + row);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Sets the current position to before the first row and returns NULL
0: 	 * because there is no current row.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	setBeforeFirstRow() 
0: 	{
0: 		currentPosition = 0;
0: 		beforeFirst = true;
0: 		afterLast = false;
0: 		currentRow = null;
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the first row from the query, and returns NULL when there
0: 	 * are no rows.
0: 	 *
0: 	 * @return	The first row, or NULL if no rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getFirstRow() 
0: 		throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "first");
0: 		}
0: 
0: 		/* Get the row from the hash table if
0: 		 * we have already seen it before.
0: 		 */
0: 		if (seenFirst)
0: 		{
0: 			return getRowFromHashTable(1);
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 		}
0: 
0: 		return getNextRowCore();
0: 	}
0: 
0: 	/**
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0: 	 */
0: 	public ExecRow	getNextRowCore() throws StandardException
0: 	{
0: 		ExecRow result = null;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 		if (!isOpen)
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
0: 
0: 		/* Should we get the next row from the source or the hash table? */
0: 		if (currentPosition == positionInSource)
0: 		{
0: 			/* Current position is same as position in source.
0: 			 * Get row from the source.
0: 			 */
0: 			result = getNextRowFromSource();
0: 		}
0: 		else if (currentPosition < positionInSource)
0: 		{
0: 			/* Current position is before position in source.
0: 			 * Get row from the hash table.
0: 			 */
0: 			result = getRowFromHashTable(currentPosition + 1);
0: 		}
0: 		else
0: 		{
0: 			result = null;
0: 		}
0: 
0: 		if (result != null)
0: 		{
0: 			rowsSeen++;
0: 			afterLast = false;
0: 		}
0: 
0: 		currentRow = result;
0: 		setCurrentRow(currentRow);
0: 		beforeFirst = false;
0: 
0: 		nextTime += getElapsedMillis(beginTime);
0: 
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * Returns the previous row from the query, and returns NULL when there
0: 	 * are no more previous rows.
0: 	 *
0: 	 * @return	The previous row, or NULL if no more previous rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getPreviousRow() 
0: 		throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 		}
0: 
0: 		/* No row if we are positioned before the first row
0: 		 * or the result set is empty.
0: 		 */
0: 		if (beforeFirst || currentPosition == 0)
0: 		{
0: 			currentRow = null;
0: 			return null;
0: 		}
0: 
0: 		// Get the last row, if we are after it
0: 		if (afterLast)
0: 		{
0: 			// Special case for empty tables
0: 			if (lastPosition == 0)
0: 			{
0: 				afterLast = false;
0: 				beforeFirst = false;
0: 				currentRow = null;
0: 				return null;
0: 			}
0: 			else
0: 			{
0: 				return getRowFromHashTable(lastPosition);
0: 			}
0: 		}
0: 
0: 		// Move back 1
0: 		currentPosition--;
0: 		if (currentPosition == 0)
0: 		{
0: 			setBeforeFirstRow();
0: 			return null;
0: 		}
0: 		return getRowFromHashTable(currentPosition);
0: 	}
0: 
0: 	/**
0: 	 * Returns the last row from the query, and returns NULL when there
0: 	 * are no rows.
0: 	 *
0: 	 * @return	The last row, or NULL if no rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getLastRow()
0: 		throws StandardException
0: 	{
0: 		ExecRow result;
0: 
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
0: 		}
0: 
0: 		/* Have we already seen the last row? */
0: 		if (seenLast)
0: 		{
0: 			// Return null if the set was empty
0: 			if (lastPosition == 0)
0: 			{
0: 				currentRow = null;
0: 				return null;
0: 			}
0: 			else
0: 			{
0: 				return getRowFromHashTable(lastPosition);
0: 			}
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 		}
0: 
0: 		/* Scroll to the end, filling the hash table as
0: 		 * we scroll, and return the last row that we find.
0: 		 */
0: 		while ((result = getNextRowFromSource()) != null);
0: 		beforeFirst = false;
0: 		afterLast = false;
0: 
0: 		// Special case if table is empty
0: 		if (lastPosition == 0)
0: 		{
0: 			currentRow = null;
0: 			return null;
0: 		}
0: 		else
0: 		{
0: 			return getRowFromHashTable(lastPosition);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Sets the current position to after the last row and returns NULL
0: 	 * because there is no current row.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	setAfterLastRow() 
0: 		throws StandardException
0: 	{
0: 		if (! seenLast)
0: 		{
0: 			getLastRow();
0: 		}
0: 		currentPosition = lastPosition + 1;
0: 		afterLast = true;
0: 		beforeFirst = false;
0: 		currentRow = null;
0: 		return null;
0: 	}
0: 
0:     /**
0:      * Determine if the cursor is before the first row in the result 
0:      * set.   
0:      *
0:      * @return true if before the first row, false otherwise. Returns
0:      * false when the result set contains no rows.
0: 	 * @exception StandardException Thrown on error.
0:      */
0:    public boolean checkRowPosition(int isType) throws StandardException
0: 	{
0: 		switch (isType) {
0: 		case ISBEFOREFIRST:
0: 
0: 			if (! beforeFirst)
0: 			{
0: 				return false;
0: 			}
0: 
0: 			//  Spec says to return false if result set is empty
0: 			if (seenFirst)
0: 			{
0: 				return true;
0: 			}
0: 			else
0: 			{
0: 				ExecRow firstRow = getFirstRow();
0: 				if (firstRow == null)
0: 				{
0: 					// ResultSet is empty
0: 					return false;
0: 				}
0: 				else
0: 				{
0: 					// ResultSet is not empty - reset position
0: 					getPreviousRow();
0: 					return true;
0: 				}
0: 			}
0: 		case ISFIRST:
0: 			return (currentPosition == 1);
0: 		case ISLAST:
0: 			if (beforeFirst || afterLast)
0: 			{
0: 				return false;
0: 			}
0: 
0: 			/* If we've already seen the last row
0: 			 * then we can tell if we are on it by
0: 			 * the current position,
0: 			 * otherwise, we need to find the last
0: 			 * row in order to tell if the current row
0: 			 * is the last row.
0: 			 */
0: 			if (seenLast)
0: 			{
0: 				return (currentPosition == lastPosition && currentPosition != 0);
0: 			}
0: 			else
0: 			{
0: 				int savePosition = currentPosition;
0: 				boolean retval = false;
0: 				getLastRow();
0: 				if (savePosition == lastPosition && savePosition != 0)
0: 				{
0: 					retval = true;
0: 				}
0: 				getRowFromHashTable(savePosition);
0: 				return retval;
0: 			}
0: 		case ISAFTERLAST:
0: 			return afterLast;
0: 		default:
0: 			return false;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Returns the row number of the current row.  Row
0: 	 * numbers start from 1 and go to 'n'.  Corresponds
0: 	 * to row numbering used to position current row
0: 	 * in the result set (as per JDBC).
0: 	 *
0: 	 * @return	the row number, or 0 if not on a row
0: 	 *
0: 	 */
0: 	public int getRowNumber()
0: 	{
0: 		return currentRow == null ? 0 : currentPosition;
0: 	}
0: 
0: 	/* Get the next row from the source ResultSet tree and insert into the hash table */
0: 	private ExecRow getNextRowFromSource() throws StandardException
0: 	{
0: 		ExecRow		sourceRow = null;
0: 		ExecRow		result = null;
0: 
0: 		/* Don't give back more rows than requested */
0: 		if (maxRows > 0 && maxRows == positionInSource)
0: 		{
0: 			seenLast = true;
0: 			lastPosition = positionInSource;
0: 			afterLast = true;
0: 			return null;
0: 		}
0: 
0: 		sourceRow = source.getNextRowCore();
0: 
0: 		if (sourceRow != null)
0: 		{
0: 			seenFirst = true;
0: 			beforeFirst = false;
0: 
0: 			long beginTCTime = getCurrentTimeMillis();
0: 			/* If this is the first row from the source then we create a new row
0: 			 * for use when fetching from the hash table.
0: 			 */
0: 			if (resultRow == null)
0: 			{
0: 				resultRow = activation.getExecutionFactory().getValueRow(sourceRowWidth);
0: 			}
0: 
0: 			positionInSource++;
0: 			currentPosition = positionInSource;
0: 			addRowToHashTable(sourceRow);
0: 
0: 		}
0: 		// Remember whether or not we're past the end of the table
0: 		else
0: 		{
0: 			if (! seenLast)
0: 			{
0: 				lastPosition = positionInSource;
0: 			}
0: 			seenLast = true;
0: 			// Special case for empty table (afterLast is never true)
0: 			if (positionInSource == 0)
0: 			{
0: 				afterLast = false;
0: 			}
0: 			else
0: 			{
0: 				afterLast = true;
0: 			}
0: 		}
0: 
0: 		return sourceRow;
0: 	}
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( isOpen )
0: 	    {
0: 			if (closeCleanup != null) 
0: 			{
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			} 
0: 			currentRow = null;
0: 	        source.close();
0: 
0: 			if (ht != null)
0: 			{
0: 				ht.close();
0: 				ht = null;
0: 			}
0: 
0: 			super.close();
0: 	    }
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of ScrollInsensitiveResultSet repeated");
0: 		setBeforeFirstRow();
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	public void	finish() throws StandardException
0: 	{
0: 		source.finish();
0: 		finishAndRTS();
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 
0: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 
0: 	/**
0: 	 * Gets information from its source. We might want
0: 	 * to have this take a CursorResultSet in its constructor some day,
0: 	 * instead of doing a cast here?
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source not CursorResultSet");
0: 		return ( (CursorResultSet)source ).getRowLocation();
0: 	}
0: 
0: 	/**
0: 	 * Gets information from last getNextRow call.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() 
0: 	{
0: 		return currentRow;
0: 	}
0: 
0: 	//
0: 	// class implementation
0: 	//
0: 
0: 	/**
0: 	 * Add a row to the backing hash table,
0: 	 * keyed on positionInSource.
0: 	 *
0: 	 * @param sourceRow	The row to add.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	private void addRowToHashTable(ExecRow sourceRow)
0: 		throws StandardException
0: 	{
0: 		DataValueDescriptor[] hashRowArray = new DataValueDescriptor[sourceRowWidth + 1];
0: 		// 1st element is the key
0: 		hashRowArray[0] = new SQLInteger(positionInSource);
0: 
0: 		/* Copy rest of elements from sourceRow.
0: 		 * NOTE: We need to clone the source row
0: 		 * and we do our own cloning since the 1st column
0: 		 * is not a wrapper.
0: 		 */
0: 		DataValueDescriptor[] sourceRowArray = sourceRow.getRowArrayClone();
0: 
0: 		System.arraycopy(sourceRowArray, 0, hashRowArray, 1, sourceRowArray.length);
0: 
0: 		ht.put(false, hashRowArray);
0: 
0: 		numToHashTable++;
0: 	}
0: 
0: 	/**
0: 	 * Get the row at the specified position
0: 	 * from the hash table.
0: 	 *
0: 	 * @param position	The specified position.
0: 	 *
0: 	 * @return	The row at that position.
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0: 	 */
0: 	private ExecRow getRowFromHashTable(int position)
0: 		throws StandardException
0: 	{
0: 
0: 		// Get the row from the hash table
0: 		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) ht.get(new SQLInteger(position));
0: 
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(hashRowArray != null,
0: 				"hashRowArray expected to be non-null");
0: 		}
0: 		// Copy out the Object[] without the position.
0: 		DataValueDescriptor[] resultRowArray = new DataValueDescriptor[hashRowArray.length - 1];
0: 		System.arraycopy(hashRowArray, 1, resultRowArray, 0, resultRowArray.length);
0: 
0: 		resultRow.setRowArray(resultRowArray);
0: 
0: 		// Reset the current position to the user position
0: 		currentPosition = position;
0: 
0: 		numFromHashTable++;
0: 
0: 		if (resultRow != null)
0: 		{
0: 			beforeFirst = false;
0: 			afterLast = false;
0: 		}
0: 
0: 		currentRow = resultRow;
0: 		return resultRow;
0: 	}
0: }
============================================================================