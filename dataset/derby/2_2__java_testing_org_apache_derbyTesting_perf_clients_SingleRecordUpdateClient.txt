1:106ea47: /*
1:106ea47: 
1:106ea47: Derby - Class org.apache.derbyTesting.perf.clients.SingleRecordUpdateClient
1:106ea47: 
1:106ea47: Licensed to the Apache Software Foundation (ASF) under one or more
1:106ea47: contributor license agreements.  See the NOTICE file distributed with
1:106ea47: this work for additional information regarding copyright ownership.
1:106ea47: The ASF licenses this file to You under the Apache License, Version 2.0
1:106ea47: (the "License"); you may not use this file except in compliance with
1:106ea47: the License.  You may obtain a copy of the License at
1:106ea47: 
1:106ea47:    http://www.apache.org/licenses/LICENSE-2.0
1:106ea47: 
1:106ea47: Unless required by applicable law or agreed to in writing, software
1:106ea47: distributed under the License is distributed on an "AS IS" BASIS,
1:106ea47: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:106ea47: See the License for the specific language governing permissions and
1:106ea47: limitations under the License.
1:106ea47: 
1:106ea47: */
1:106ea47: 
1:106ea47: package org.apache.derbyTesting.perf.clients;
1:106ea47: 
1:4ea38fb: import java.io.ByteArrayInputStream;
1:9a05e65: import java.io.PrintStream;
1:4ea38fb: import java.io.StringReader;
1:106ea47: import java.sql.Connection;
1:106ea47: import java.sql.PreparedStatement;
1:106ea47: import java.sql.SQLException;
1:6f53b7f: import java.sql.Types;
1:106ea47: import java.util.Random;
1:106ea47: 
1:106ea47: /**
1:106ea47:  * Client which updates a single record at a time on tables generated by
1:106ea47:  * {@code SingleRecordFiller}. Each time the client's {@code doWork()} method
1:106ea47:  * is called, it will pick one of the tables randomly, and update the text
1:106ea47:  * column of one random record in that table.
1:106ea47:  */
1:106ea47: public class SingleRecordUpdateClient implements Client {
1:106ea47: 
1:106ea47:     private Connection conn;
1:106ea47: 
1:106ea47:     private final PreparedStatement[] pss;
1:106ea47:     private final Random r;
1:106ea47:     private final int tableSize;
1:4ea38fb:     private final int dataType;
1:4ea38fb:     private final boolean secondaryIndex;
1:4ea38fb:     private final boolean noIndex;
1:106ea47: 
1:106ea47:     /**
1:106ea47:      * Construct a new single-record update client.
1:106ea47:      *
1:106ea47:      * @param records the number of records in each table in the test
1:106ea47:      * @param tables the number of tables in the test
1:106ea47:      */
1:106ea47:     public SingleRecordUpdateClient(int records, int tables) {
1:4ea38fb:         this(records, tables, Types.VARCHAR, false, false);
1:4ea38fb:     }
1:4ea38fb: 
1:4ea38fb:     /**
1:4ea38fb:      * Construct a new single-record update client.
1:4ea38fb:      *
1:4ea38fb:      * @param records the number of records in each table in the test
1:4ea38fb:      * @param tables the number of tables in the test
1:4ea38fb:      */
1:4ea38fb:     public SingleRecordUpdateClient(int records, int tables, int type,
1:4ea38fb:                                     boolean secIndex, boolean nonIndexed) {
1:106ea47:         tableSize = records;
1:106ea47:         r = new Random();
1:106ea47:         pss = new PreparedStatement[tables];
1:4ea38fb:         dataType = type;
1:4ea38fb:         if (secIndex && nonIndexed) {
1:4ea38fb:             throw new IllegalArgumentException(
1:4ea38fb:                 "Cannot select on both secondary index and non-index column");
1:4ea38fb:         }
1:4ea38fb:         secondaryIndex = secIndex;
1:4ea38fb:         noIndex = nonIndexed;
1:106ea47:     }
1:106ea47: 
1:106ea47:     public void init(Connection c) throws SQLException {
1:106ea47:         for (int i = 0; i < pss.length; i++) {
1:6f53b7f:             String tableName =
1:4ea38fb:                 SingleRecordFiller.getTableName(tableSize, i, dataType,
1:4ea38fb:                                                 secondaryIndex, noIndex);
1:4ea38fb:             String column = "ID";
1:4ea38fb:             if (secondaryIndex) {
1:4ea38fb:                 column = "SEC";
1:4ea38fb:             } else if (noIndex) {
1:4ea38fb:                 column = "NI";
1:4ea38fb:             }
1:4ea38fb:             String sql = "UPDATE " + tableName + " SET TEXT = ? WHERE " +
1:4ea38fb:                     column + " = ?";
1:106ea47:             pss[i] = c.prepareStatement(sql);
1:106ea47:         }
1:106ea47:         c.setAutoCommit(false);
1:106ea47:         conn = c;
1:106ea47:     }
1:106ea47: 
1:106ea47:     public void doWork() throws SQLException {
1:106ea47:         PreparedStatement ps = pss[r.nextInt(pss.length)];
1:4ea38fb:         int seed = r.nextInt();
1:4ea38fb:         if (dataType == Types.VARCHAR) {
1:4ea38fb:             ps.setString(1, SingleRecordFiller.randomString(seed));
1:4ea38fb:         } else if (dataType == Types.BLOB) {
1:4ea38fb:             byte[] bytes = SingleRecordFiller.randomBytes(seed);
1:4ea38fb:             ps.setBinaryStream(1, new ByteArrayInputStream(bytes),
1:4ea38fb:                                SingleRecordFiller.TEXT_SIZE);
1:4ea38fb:         } else if (dataType == Types.CLOB) {
1:4ea38fb:             String string = SingleRecordFiller.randomString(seed);
1:4ea38fb:             ps.setCharacterStream(1, new StringReader(string),
1:4ea38fb:                                   SingleRecordFiller.TEXT_SIZE);
1:4ea38fb:         } else {
1:4ea38fb:             throw new IllegalArgumentException();
1:4ea38fb:         }
1:106ea47:         ps.setInt(2, r.nextInt(tableSize));
1:106ea47:         ps.executeUpdate();
1:106ea47:         conn.commit();
1:106ea47:     }
1:106ea47: 
1:9a05e65:     public void printReport(PrintStream out) {}
1:9a05e65:     
1:106ea47: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9a05e65
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintStream;
/////////////////////////////////////////////////////////////////////////
1:     public void printReport(PrintStream out) {}
1:     
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4ea38fb
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.StringReader;
/////////////////////////////////////////////////////////////////////////
1:     private final int dataType;
1:     private final boolean secondaryIndex;
1:     private final boolean noIndex;
/////////////////////////////////////////////////////////////////////////
1:         this(records, tables, Types.VARCHAR, false, false);
1:     }
1: 
1:     /**
1:      * Construct a new single-record update client.
1:      *
1:      * @param records the number of records in each table in the test
1:      * @param tables the number of tables in the test
1:      */
1:     public SingleRecordUpdateClient(int records, int tables, int type,
1:                                     boolean secIndex, boolean nonIndexed) {
1:         dataType = type;
1:         if (secIndex && nonIndexed) {
1:             throw new IllegalArgumentException(
1:                 "Cannot select on both secondary index and non-index column");
1:         }
1:         secondaryIndex = secIndex;
1:         noIndex = nonIndexed;
1:                 SingleRecordFiller.getTableName(tableSize, i, dataType,
1:                                                 secondaryIndex, noIndex);
1:             String column = "ID";
1:             if (secondaryIndex) {
1:                 column = "SEC";
1:             } else if (noIndex) {
1:                 column = "NI";
1:             }
1:             String sql = "UPDATE " + tableName + " SET TEXT = ? WHERE " +
1:                     column + " = ?";
/////////////////////////////////////////////////////////////////////////
1:         int seed = r.nextInt();
1:         if (dataType == Types.VARCHAR) {
1:             ps.setString(1, SingleRecordFiller.randomString(seed));
1:         } else if (dataType == Types.BLOB) {
1:             byte[] bytes = SingleRecordFiller.randomBytes(seed);
1:             ps.setBinaryStream(1, new ByteArrayInputStream(bytes),
1:                                SingleRecordFiller.TEXT_SIZE);
1:         } else if (dataType == Types.CLOB) {
1:             String string = SingleRecordFiller.randomString(seed);
1:             ps.setCharacterStream(1, new StringReader(string),
1:                                   SingleRecordFiller.TEXT_SIZE);
1:         } else {
1:             throw new IllegalArgumentException();
1:         }
commit:6f53b7f
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:             String tableName =
0:                 SingleRecordFiller.getTableName(tableSize, i, Types.VARCHAR);
commit:106ea47
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.perf.clients.SingleRecordUpdateClient
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.perf.clients;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.util.Random;
1: 
1: /**
1:  * Client which updates a single record at a time on tables generated by
1:  * {@code SingleRecordFiller}. Each time the client's {@code doWork()} method
1:  * is called, it will pick one of the tables randomly, and update the text
1:  * column of one random record in that table.
1:  */
1: public class SingleRecordUpdateClient implements Client {
1: 
1:     private Connection conn;
1: 
1:     private final PreparedStatement[] pss;
1:     private final Random r;
1:     private final int tableSize;
1: 
1:     /**
1:      * Construct a new single-record update client.
1:      *
1:      * @param records the number of records in each table in the test
1:      * @param tables the number of tables in the test
1:      */
1:     public SingleRecordUpdateClient(int records, int tables) {
1:         tableSize = records;
1:         r = new Random();
1:         pss = new PreparedStatement[tables];
1:     }
1: 
1:     public void init(Connection c) throws SQLException {
1:         for (int i = 0; i < pss.length; i++) {
0:             String tableName = SingleRecordFiller.getTableName(tableSize, i);
0:             String sql = "UPDATE " + tableName + " SET TEXT = ? WHERE ID = ?";
1:             pss[i] = c.prepareStatement(sql);
1:         }
1:         c.setAutoCommit(false);
1:         conn = c;
1:     }
1: 
1:     public void doWork() throws SQLException {
1:         PreparedStatement ps = pss[r.nextInt(pss.length)];
0:         ps.setString(1, SingleRecordFiller.randomString(r.nextInt()));
1:         ps.setInt(2, r.nextInt(tableSize));
1:         ps.executeUpdate();
1:         conn.commit();
1:     }
1: 
1: }
============================================================================