1:f10793f: /*
4:f10793f: 
1:f10793f:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.declareGlobalTempTableJavaJDBC30Test
1:f10793f: 
1:f10793f:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f10793f:    contributor license agreements.  See the NOTICE file distributed with
1:f10793f:    this work for additional information regarding copyright ownership.
1:f10793f:    The ASF licenses this file to You under the Apache License, Version 2.0
1:f10793f:    (the "License"); you may not use this file except in compliance with
1:f10793f:    the License.  You may obtain a copy of the License at
1:f10793f: 
1:f10793f:       http://www.apache.org/licenses/LICENSE-2.0
1:f10793f: 
1:f10793f:    Unless required by applicable law or agreed to in writing, software
1:f10793f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f10793f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f10793f:    See the License for the specific language governing permissions and
1:f10793f:    limitations under the License.
1:f10793f: 
1:f10793f:  */
1:f10793f: 
1:f10793f: package org.apache.derbyTesting.functionTests.tests.lang;
1:f10793f: 
1:f10793f: import java.sql.Connection;
1:f10793f: import java.sql.PreparedStatement;
1:f10793f: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:f10793f: import java.sql.Savepoint;
1:f10793f: import java.sql.Statement;
1:f10793f: import javax.sql.ConnectionPoolDataSource;
1:f10793f: import javax.sql.PooledConnection;
1:f10793f: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.J2EEDataSource;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:f10793f: 
1:f10793f: /**
1:f10793f:  * Test for declared global temporary tables (introduced in Cloudscape 5.2)
1:f10793f:  * and pooled connection close and jdbc 3.0 specific features
1:f10793f:  * The jdbc3.0 specific featuers are holdable cursors, savepoints.
1:f10793f:  * The rest of the temp table test are in declareGlobalTempTableJavaTest class. 
1:f10793f:  * The reason for a different test class is that the holdability and savepoint 
1:f10793f:  * support is under jdk14 and higher. But we want to be able to run the 
1:f10793f:  * non-holdable tests under all the jdks we support and hence splitting the 
1:f10793f:  * tests into two separate tests. 
1:f10793f:  */
1:f10793f: 
1:f10793f: 
1:f10793f: public class DeclareGlobalTempTableJavaJDBC30Test extends BaseJDBCTestCase {
1:f10793f: 
1:f10793f:     public DeclareGlobalTempTableJavaJDBC30Test(String name)
2:f10793f:     {
1:f10793f:         super(name);
4:f10793f:     }	
1:f10793f:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite();
1:f10793f:         suite.addTest(TestConfiguration.embeddedSuite(
1:f10793f:                 DeclareGlobalTempTableJavaJDBC30Test.class));
1:f10793f:         suite.addTest(TestConfiguration.clientServerDecorator(
1:f10793f:                 getClientSuite()));
1:f10793f:         return suite;
1:f10793f:     }
1:f10793f:     
1:f10793f:     /**
1:f10793f:      * Return a suite of tests that are run with client only
1:f10793f:      * 
1:f10793f:      * @return A suite of tests being run with client only
1:f10793f:      */
1:f10793f:     private static Test getClientSuite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Client/Server");
1:f10793f:         // skip the tests with more than 1 savepoint -  
1:f10793f:         // see (lack of support described in) DERBY-3687
1:f10793f:         // so, only do the following with network server/client: 
1:f10793f:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:f10793f:             "testOnCommitPreserveRowsWithHoldability"));
1:f10793f:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:f10793f:             "testSavepointRollbackbehaviour7"));
1:f10793f:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:f10793f:             "testSavepointRollbackbehaviour8"));
1:f10793f:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:f10793f:             "testSavepointRollbackbehaviour11"));
1:f10793f:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:f10793f:             "testSavepointRollbackbehaviour12"));
1:f10793f:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:f10793f:             "testTest4"));
1:f10793f:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:f10793f:             "testPooledConnectionClosed"));
1:f10793f:         
1:f10793f:         // following 2 fail with network server; see DERBY-4373
1:f10793f:         /*
1:f10793f:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:f10793f:             "testOnCommitDeleteRowsWithHoldableOpenCursor"));
1:f10793f:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:f10793f:             "testOnCommitDeleteRowsHoldabilityWithPreparedStatements"));
1:f10793f:         */
1:f10793f:         return suite;
1:f10793f:     }
1:f10793f:     
1:f10793f:     protected void setUp() throws Exception {
1:f10793f:         super.setUp();
1:f10793f:         getConnection().setAutoCommit(false);
1:f10793f:     }
1:f10793f:     protected void tearDown() throws Exception {
1:f10793f:         super.tearDown();
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Tests that If a Global Temp table(with on commi delete rows) has open 
1:f10793f:      *  cursors held on it 
1:f10793f:      *  Data should be preserved in at commit time
1:f10793f:      *
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public  void  testOnCommitDeleteRowsWithHoldableOpenCursor() 
1:f10793f:     throws SQLException {
1:f10793f:         Statement s1 = getConnection().createStatement(
1:f10793f:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:f10793f:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:f10793f:         s1.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit delete rows not logged");
1:f10793f:         s1.executeUpdate("insert into session.t1 values(11, 1)");
1:f10793f:         s1.executeUpdate("insert into session.t1 values(12, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         //hold cursor open on t1. Commit should preserve the rows
1:f10793f:         ResultSet rs1 = s1.executeQuery("select * from SESSION.t1");
1:f10793f:         rs1.next();
1:f10793f:         //cursor opened
1:f10793f:         //Temp tables t2 & t3 with one held open cursor on them together. Data
1:f10793f:         //should be preserved in t2 & t3 at commit time
1:f10793f:         Statement s2 = getConnection().createStatement(
1:f10793f:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:f10793f:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:f10793f:         s2.executeUpdate("declare global temporary table SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) on commit delete rows not logged");
1:f10793f:         s2.executeUpdate("insert into session.t2 values(21, 1)");
1:f10793f:         s2.executeUpdate("insert into session.t2 values(22, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2"), "2");
1:f10793f:         s2.executeUpdate("declare global temporary table SESSION.t3(" +
1:f10793f:                 "c31 int, c32 int) on commit delete rows not logged");
1:f10793f:         s2.executeUpdate("insert into session.t3 values(31, 1)");
1:f10793f:         s2.executeUpdate("insert into session.t3 values(32, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t3") , "2");
1:f10793f:         //hold cursor open on t2 & t3. Commit should preseve the rows
1:f10793f:         ResultSet rs23 = s2.executeQuery(
1:f10793f:                 "select * from SESSION.t2, SESSION.t3 where c22=c32"); 
1:f10793f:         rs23.next(); 
1:f10793f:         //cursor Opened
1:f10793f:         Statement s3 = getConnection().createStatement(
1:f10793f:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:f10793f:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:f10793f:         s3.executeUpdate("declare global temporary table SESSION.t4(" +
1:f10793f:                 "c41 int, c42 int) on commit delete rows not logged");
1:f10793f:         s3.executeUpdate("insert into session.t4 values(41, 1)");
1:f10793f:         s3.executeUpdate("insert into session.t4 values(42, 2)");
1:f10793f:         ResultSet rs4 = s3.executeQuery("select count(*) from SESSION.t4");
1:f10793f:         JDBC.assertSingleValueResultSet(rs4 , "2");
1:f10793f:         //hold cursor open on t4 but close it before commit, 
1:f10793f:         //Data should be deleted after commit
1:f10793f:         rs4 = s3.executeQuery("select * from SESSION.t4");
1:f10793f:         rs4.next();
1:f10793f:         rs4.close();
1:f10793f:         //rs4 closed before committing.
1:f10793f:         commit();
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "2");
1:f10793f:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t3") , "2");
1:f10793f:         JDBC.assertSingleValueResultSet(s3.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t4") , "0");
1:f10793f:         s1.executeUpdate("drop table SESSION.t1");
1:f10793f:         s2.executeUpdate("drop table SESSION.t2");
1:f10793f:         s3.executeUpdate("drop table SESSION.t3");   
1:f10793f:         s3.executeUpdate("drop table SESSION.t4");
1:f10793f:         rs1.close(); rs23.close(); rs4.close();
1:f10793f:         commit();
1:f10793f:         s1.close();  s2.close(); s3.close();
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Test declared temporary table with ON COMMIT DELETE ROWS and holdable
1:f10793f:      *  cursors on prepared statement
1:f10793f:      *
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testOnCommitDeleteRowsHoldabilityWithPreparedStatements() 
1:f10793f:     throws SQLException {
1:f10793f:         Statement s1 = createStatement();
1:f10793f:         s1.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit delete rows not logged");
1:f10793f:         s1.executeUpdate("insert into session.t1 values(11, 1)");
1:f10793f:         s1.executeUpdate("insert into session.t1 values(12, 2)");
1:f10793f:         //create a prepared statement with hold cursors over commit
1:f10793f:         PreparedStatement ps1 = getConnection().prepareStatement(
1:f10793f:                 "select count(*) from SESSION.t1",
1:f10793f:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, 
1:f10793f:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:f10793f:         ResultSet rs1 = ps1.executeQuery();
1:f10793f:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:f10793f:         PreparedStatement ps2 = getConnection().prepareStatement(
1:f10793f:                 "select * from SESSION.t1", ResultSet.TYPE_FORWARD_ONLY,
1:f10793f:                 ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:f10793f:         //hold cursor open on t1. Commit should preserve the rows
1:f10793f:         ResultSet rs11 = ps2.executeQuery();
1:f10793f:         rs11.next();
1:f10793f:         //Cursor was Opened.
1:f10793f:         //Temp table t2 with one held cursor but it is closed before commit. 
1:f10793f:         //Data should be deleted from t2 at commit time
1:f10793f:         s1.executeUpdate("declare global temporary table SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) on commit delete rows not logged");
1:f10793f:         s1.executeUpdate("insert into session.t2 values(21, 1)");
1:f10793f:         s1.executeUpdate("insert into session.t2 values(22, 2)");
1:f10793f:         //create a prepared statement with hold cursors over commit
1:f10793f:         PreparedStatement ps3 = getConnection().prepareStatement(
1:f10793f:                 "select count(*) from SESSION.t2",
1:f10793f:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, 
1:f10793f:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:f10793f:         ResultSet rs2 = ps3.executeQuery();
1:f10793f:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:f10793f:         PreparedStatement ps4 = getConnection().prepareStatement(
1:f10793f:                 "select * from SESSION.t2", ResultSet.TYPE_FORWARD_ONLY, 		    ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:f10793f:         //hold cursor open on t2 but close it before commit
1:f10793f:         rs2 = ps4.executeQuery();
1:f10793f:         rs2.next();
1:f10793f:         rs2.close();
1:f10793f:         //commiting Point
1:f10793f:         commit();
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         //Need to close the held cursor on t1 before t1 can be dropped
1:f10793f:         rs11.close();
1:f10793f:         rs1.close();
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         s1.executeUpdate("drop table SESSION.t1");
1:f10793f:         s1.executeUpdate("drop table SESSION.t2");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Tests a temporary table with ON COMMIT PRESERVE ROWS and various 
1:f10793f:      *  combinations of holdability.
1:f10793f:      *  Temp table t1 with held open cursors on it. Data should be preserved,
1:f10793f:      *  holdability shouldn't matter
1:f10793f:      *
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testOnCommitPreserveRowsWithHoldability() throws SQLException	{
1:f10793f:         //create a statement with hold cursors over commit
1:f10793f:         Statement s1 = getConnection().createStatement(
1:f10793f:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:f10793f:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:f10793f:         s1.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged");
1:f10793f:         s1.executeUpdate("insert into session.t1 values(11, 1)");
1:f10793f:         s1.executeUpdate("insert into session.t1 values(12, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         //Opening the Cursor
1:f10793f:         ResultSet rs1 = s1.executeQuery("select * from SESSION.t1");
1:f10793f:         rs1.next();
1:f10793f:         //create a statement without hold cursors.
1:f10793f:         Statement s2 = createStatement();
1:f10793f:         s1.executeUpdate("declare global temporary table SESSION.t2(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged");
1:f10793f:         s1.executeUpdate("insert into session.t2 values(11, 1)");
1:f10793f:         s1.executeUpdate("insert into session.t2 values(12, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "2");
1:f10793f:         //Opening The Cursor
1:f10793f:         ResultSet rs2 = s2.executeQuery("select * from SESSION.t2");
1:f10793f:         rs2.next();
1:f10793f:         //commiting point
1:f10793f:         commit();
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "2");
1:f10793f:         s1.executeUpdate("drop table SESSION.t1");
1:f10793f:         s2.executeUpdate("drop table SESSION.t2");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 1 (3A)
1:f10793f:      *  In the transaction Create savepoint1 and declare temp table t1. 
1:f10793f:      *  Create savepoint 2, drop temp table t1, rollback savepoint 2 
1:f10793f:      *  select should pass, rollback savepoint 1, select should fail.
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour1() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         //Set The First savepoint
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         //create a temp table t1
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged");
1:f10793f:         PreparedStatement pStmt = prepareStatement(
1:f10793f:                 "insert into SESSION.t1 values (?, ?)");
1:f10793f:         pStmt.setInt(1, 11);
1:f10793f:         pStmt.setInt(2, 1);
1:f10793f:         pStmt.execute();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "1");
1:f10793f:         //Set The Second savepoint
1:f10793f:         Savepoint savepoint2 = getConnection().setSavepoint();
1:f10793f:         //drop the temp table t1
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:         //Rollback to the second savepoint - drop table Operation is rolled 
1:f10793f:         //back hence we should have t1
1:f10793f:         getConnection().rollback(savepoint2);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");	
1:f10793f:         //Rollback to the First savepoint - create table Operation is also 
1:f10793f:         //rolled back hence there is no t1
1:f10793f:         getConnection().rollback(savepoint1);
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 2 (3B)
1:f10793f:      *  In the transaction Create savepoint1 and declare temp table t1. 
1:f10793f:      *  Create savepoint2 and declare temp table t2
1:f10793f:      *  Release savepoint 1 and select from temp table t1 and t2.
1:f10793f:      *  Drop temp table t2(explicit drop), rollback transaction(implicit drop
1:f10793f:      *  of t1) Select from temp table t1 and t2 will fail.
1:f10793f:      *
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour2() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         //Set First savepoint (save point - 1)
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged");
1:f10793f:         //Set Second savepoint (save point - 2)
1:f10793f:         Savepoint savepoint2 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) on commit preserve rows not logged");
1:f10793f:         //Release First savepoint
1:f10793f:         getConnection().releaseSavepoint(savepoint1);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         //Drop the Temp Table t2 Explicitly and t1 Implicitly(by rolling back)	
1:f10793f:         s.executeUpdate("drop table SESSION.t2");
1:f10793f:         rollback();
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t2");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 3 (3C)
1:f10793f:      *  In the transaction Create savepoint1 and declare temp table t1. 
1:f10793f:      *  Create savepoint2 and declare temp table t2.
1:f10793f:      *  Release savepoint 1 and select from temp table t1 and t2 should pass.
1:f10793f:      *  Create savepoint3 and rollback savepoint3(should not touch t1 and t2)
1:f10793f:      *  select from temp tables t1 and t2 should pass.
1:f10793f:      *  Rollback transaction and select from temp tables t1 and t2 should fail.
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour3() throws SQLException  {
1:f10793f:         Statement s = createStatement();
1:f10793f:         //set first savepoint
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows  not logged");
1:f10793f:         //set second savepoint
1:f10793f:         Savepoint savepoint2 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) on commit preserve rows  not logged");
1:f10793f:         //release the first savepoint
1:f10793f:         getConnection().releaseSavepoint(savepoint1);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         //set third savepoint
1:f10793f:         Savepoint savepoint3 = getConnection().setSavepoint();
1:f10793f:         //rollback to third savepoint - (should not touch t1 and t2)
1:f10793f:         getConnection().rollback(savepoint3);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         //rollback the entire transaction - this rolls back create statements
1:f10793f:         //also hence t1 , t2 got deleted
1:f10793f:         rollback();
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t2");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 4 (3D)
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour4() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         //set first savepoint
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows  not logged");
1:f10793f:         //set second savepoint
1:f10793f:         Savepoint savepoint2 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         //rollback to second savepoint
1:f10793f:         getConnection().rollback(savepoint2);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery("" +
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         //commit
1:f10793f:         commit();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 5 - 3E
1:f10793f:      *  Tests the basic definition of savepoint in combination with Rollback.
1:f10793f:      *
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour5() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         //set first savepoint 
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows  not logged");
1:f10793f:         //set second savepoint
1:f10793f:         Savepoint savepoint2 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         //rollback to first savepoint
1:f10793f:         getConnection().rollback(savepoint1);
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:     }
1:f10793f:     
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 6 - 3J
1:f10793f:      *  In the transaction: declare temp table t1 with 2 columns and commit.
1:f10793f:      *  Create savepoint1 and drop temp table t1 with 2 columns, declare temp
1:f10793f:      *  table t1 but this time with 3 columns.
1:f10793f:      *  Create savepoint2 and drop temp table t1 with 3 columns, rollback,
1:f10793f:      *  select from temp table t1 here should have 2 columns
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour6() throws SQLException {
1:f10793f:         String[] s1 = {"C11" , "C12"};
1:f10793f:         String[] s2 = {"C11" , "C12" , "C13"};
1:f10793f:         Statement s = createStatement();
1:f10793f:         // declare temp table t1 with 2 columns
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows  not logged");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(11, 11)");
1:f10793f:         ResultSet rs1 = s.executeQuery("select * from SESSION.t1");
1:f10793f:         JDBC.assertColumnNames(rs1 , s1);
1:f10793f:         //commiting point
1:f10793f:         getConnection().commit();
1:f10793f:         //set first savepoint
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         //declare temp table t1 with 3 columns
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int, c13 int not null) on commit preserve rows " +
1:f10793f:                 "not logged");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(22, 22, 22)");
1:f10793f:         rs1 = s.executeQuery("select * from SESSION.t1");
1:f10793f:         JDBC.assertColumnNames(rs1 , s2);
1:f10793f:         //set second savepoint
1:f10793f:         Savepoint savepoint2 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         //rollback the transaction
1:f10793f:         rollback();
1:f10793f:         rs1 = s.executeQuery("select * from SESSION.t1");
1:f10793f:         JDBC.assertColumnNames(rs1 , s1);	
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 7 - 3K
1:f10793f:      *  tests the savepoint and rollback behaviour with update command
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour7() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         //declare temp table t1 & t2, insert few rows and commit
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged " +
1:f10793f:                 "on rollback delete rows");
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) on commit preserve rows not logged");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:f10793f:         s.executeUpdate("insert into session.t2 values(21, 1)");
1:f10793f:         commit();
1:f10793f:         //committed - the first transaction has been completed
1:f10793f:         //In the next transaction, insert couple more rows in t1 & t2
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:f10793f:         s.executeUpdate("insert into SESSION.t2 values(22, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "2");
1:f10793f:         //set first savepoint
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("UPDATE SESSION.t1 SET c12 = 3 where c12>1");
1:f10793f:         s.executeUpdate("UPDATE SESSION.t2 SET c22 = 3 where c22>2");
1:f10793f:         //rollback to first savepoint
1:f10793f:         getConnection().rollback(savepoint1);
1:f10793f:         //Rollback to savepoint1 and we should loose all the rows in t1 temp
1:f10793f:         //table t2 should also have no rows because attempt was made to modify 
1:f10793f:         //it (even though nothing actually got modified in t2 in the savepoint)
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         commit();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         s.executeUpdate("drop table SESSION.t2");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 8 - 3L
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour8() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows  not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) on commit preserve rows  not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:f10793f:         s.executeUpdate("insert into session.t2 values(21, 1)");
1:f10793f:         commit();
1:f10793f:         //insert couple more rows in t1 & t2 and
1:f10793f:         //Create savepoint1 and update some rows in t1 and inspect the data
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:f10793f:         s.executeUpdate("insert into session.t2 values(22, 2)");
1:f10793f:         //set first savepoint
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("UPDATE SESSION.t1 SET c12 = 3 where c12>1");
1:f10793f:         s.executeUpdate("UPDATE SESSION.t2 SET c22 = 3 where c22>3");
1:f10793f:         //rollback to first savepoint
1:f10793f:         getConnection().rollback(savepoint1);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:f10793f:         rollback();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         //cleanUp
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         s.executeUpdate("drop table SESSION.t2");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 9 - 3M
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour9() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged " +
1:f10793f:                 "on rollback delete rows");
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) on commit preserve rows not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(" +
1:f10793f:                 "c31 int, c32 int) on commit preserve rows not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t4(" +
1:f10793f:                 "c41 int, c42 int) on commit preserve rows not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:f10793f:         s.executeUpdate("insert into SESSION.t2 values(21, 1)");
1:f10793f:         s.executeUpdate("insert into SESSION.t3 values(31, 1)");
1:f10793f:         s.executeUpdate("insert into SESSION.t4 values(41, 1)");
1:f10793f:         commit();
1:f10793f:         //Beginning of second transaction
1:f10793f:         //Insert a couple of more rows into t1 , t2 and t3
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:f10793f:         s.executeUpdate("insert into session.t2 values(22, 2)");
1:f10793f:         s.executeUpdate("insert into session.t3 values(32, 2)");
1:f10793f:         //set first savepoint                    
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("DELETE FROM SESSION.t1 where c12>1");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "1");
1:f10793f:         //set second savepoint
1:f10793f:         Savepoint savepoint2 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("DELETE FROM SESSION.t2 where c22>1");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "1");
1:f10793f:         //Release savepoint2 and now savepoint1 should keep track of changes 
1:f10793f:         //made to t1 and t2
1:f10793f:         getConnection().releaseSavepoint(savepoint2);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "1");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "1");
1:f10793f:         // Rollback savepoint1 and should see no data in t1 and t2
1:f10793f:         getConnection().rollback(savepoint1);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         //Should see data in t3 since it was not touched in the savepoint that 
1:f10793f:         //was rolled back
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t3") , "2");
1:f10793f:         rollback();
1:f10793f:         //Rolling back the transaction we should see no data in t1 and t2 and t3
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t3") , "0");
1:f10793f:         //Should see data in t4 since it was not touched in the transaction that was rolled back
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t4") , "1");
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         s.executeUpdate("drop table SESSION.t2");
1:f10793f:         s.executeUpdate("drop table SESSION.t3");
1:f10793f:         s.executeUpdate("drop table SESSION.t4");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 10 - 3N
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour10() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) on commit preserve rows not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(" +
1:f10793f:                 "c31 int, c32 int) on commit preserve rows not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t4(" +
1:f10793f:                 "c41 int, c42 int) on commit preserve rows not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:f10793f:         s.executeUpdate("insert into SESSION.t2 values(21, 1)");
1:f10793f:         s.executeUpdate("insert into SESSION.t2 values(22, 2)");
1:f10793f:         s.executeUpdate("insert into SESSION.t3 values(31, 1)");
1:f10793f:         s.executeUpdate("insert into SESSION.t4 values(41, 1)");
1:f10793f:         commit();
1:f10793f:         //In the next transaction, insert couple more rows in t3
1:f10793f:         s.executeUpdate("insert into SESSION.t3 values(31, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t3") , "2");
1:f10793f:         //Create savepoint1 and delete some rows from t1
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("DELETE FROM SESSION.t1 where c12>1");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "1");
1:f10793f:         s.executeUpdate("DELETE FROM SESSION.t2 where c22>3");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "2");
1:f10793f:         //Create savepoint2 and delete some rows from t2 
1:f10793f:         Savepoint savepoint2 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("DELETE FROM SESSION.t2 where c22>1");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "1");
1:f10793f:         //Rollback the transaction and should see no data in t1 and t2 and t3
1:f10793f:         rollback();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t3") , "0");
1:f10793f:         //Should see data in t4 since it was not touched in the transaction 
1:f10793f:         //that was rolled back
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t4") , "1");
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         s.executeUpdate("drop table SESSION.t2");
1:f10793f:         s.executeUpdate("drop table SESSION.t3");
1:f10793f:         s.executeUpdate("drop table SESSION.t4");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 11 - 3O
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour11() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) on commit preserve rows not logged on " +
1:f10793f:                 "rollback delete rows");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:f10793f:         s.executeUpdate("insert into SESSION.t2 values(21, 1)");
1:f10793f:         commit();
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         //set the first savepoint here
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("insert into SESSION.t2 values(22, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "2");
1:f10793f:         //Rollback savepoint1; expect no data in t2 but t1 should have data
1:f10793f:         getConnection().rollback(savepoint1);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         //Commit the transaction; expect no data in t2 but t1 should have data
1:f10793f:         commit();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         s.executeUpdate("drop table SESSION.t2");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 12 - 3P
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour12() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:f10793f:         commit();
1:f10793f:         //set the first savepoint
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         s.executeUpdate("insert into SESSION.t1 values(13, 3)");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "3");
1:f10793f:         //release the savepoint - now transaction should keep track of changes
1:f10793f:         //made to t1
1:f10793f:         getConnection().releaseSavepoint(savepoint1);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "3");
1:f10793f:         //Rollback the transaction and should still see no data in t1
1:f10793f:         rollback();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Savepoint and Rollback behavior - 13 - 3Q
1:f10793f:      *  tests the rollback , savepoint behaviour with prepartedStatement
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testSavepointRollbackbehaviour13() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:f10793f:                 "c21 int, c22 int) not logged on commit preserve rows");
1:f10793f:         PreparedStatement pStmtInsert = prepareStatement(
1:f10793f:                 "insert into SESSION.t2 values (?, ?)");
1:f10793f:         pStmtInsert.setInt(1, 21);
1:f10793f:         pStmtInsert.setInt(2, 1);
2:f10793f:         pStmtInsert.execute();
1:f10793f:         pStmtInsert.setInt(1, 22);
1:f10793f:         pStmtInsert.setInt(2, 2);
1:54a4649:         pStmtInsert.execute();
1:f10793f:         pStmtInsert.setInt(1, 23);
1:f10793f:         pStmtInsert.setInt(2, 2);
1:f10793f:         pStmtInsert.execute();
1:f10793f:         PreparedStatement pStmtUpdate = prepareStatement(
1:f10793f:                 "UPDATE SESSION.t2 SET c22 = 3 where c21=?");
1:f10793f:         pStmtUpdate.setInt(1, 23);
1:f10793f:         pStmtUpdate.execute();
1:f10793f:         PreparedStatement pStmtDelete = prepareStatement(
1:f10793f:                 "DELETE FROM SESSION.t2 where c21 = ?");
1:f10793f:         pStmtDelete.setInt(1, 23);
1:f10793f:         pStmtDelete.execute();
1:f10793f:         commit();//committing point
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "2");
1:f10793f:         //set the first savepoint
1:f10793f:         Savepoint savepoint1 = getConnection().setSavepoint();
1:f10793f:         pStmtInsert.setInt(1, 23);
1:f10793f:         pStmtInsert.setInt(2, 2);
1:f10793f:         pStmtInsert.execute();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2")  , "3");
1:f10793f:         //set the second savepoint
1:f10793f:         Savepoint savepoint2 = getConnection().setSavepoint();
1:f10793f:         pStmtUpdate.setInt(1, 23);
1:f10793f:         pStmtUpdate.execute();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "3");
1:f10793f:         //rollback savepoint2 and should loose all the data from t2");
1:f10793f:         getConnection().rollback(savepoint2);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "0");
1:f10793f:         //Create savepoint3, insert some rows into t2 using prepared statement
1:f10793f:         Savepoint savepoint3 = getConnection().setSavepoint();
1:f10793f:         pStmtInsert.setInt(1, 21);
1:f10793f:         pStmtInsert.setInt(2, 1);
1:f10793f:         pStmtInsert.execute();
1:f10793f:         pStmtInsert.setInt(1, 22);
1:f10793f:         pStmtInsert.setInt(2, 2);
1:f10793f:         pStmtInsert.execute();
1:f10793f:         pStmtInsert.setInt(1, 23);
1:f10793f:         pStmtInsert.setInt(2, 333);
1:f10793f:         pStmtInsert.execute();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "3");
1:f10793f:         //Create savepoint4 and update row inserted in savepoint3 using prepared
1:f10793f:         //statement and inspect the data in t2
1:f10793f:         Savepoint savepoint4 = getConnection().setSavepoint();
1:f10793f:         pStmtUpdate.setInt(1, 23);
1:f10793f:         pStmtUpdate.execute();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "3");
1:f10793f:         //release savepoint4
1:f10793f:         getConnection().releaseSavepoint(savepoint4);
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "3");
1:f10793f:         pStmtDelete.setInt(1, 23);
1:f10793f:         pStmtDelete.execute();
1:f10793f:         //Commit transaction and should see data in t2
1:f10793f:         commit();
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t2") , "2");
1:f10793f:         s.executeUpdate("drop table SESSION.t2");
1:f10793f:     }	
1:f10793f:     /**
1:f10793f:      *  Test declared temporary table with ON COMMIT DELETE ROWS and holdable 
1:f10793f:      *  cursors and temp table as part of subquery
1:f10793f:      *  Temp table t1 with no direct held cursor open on it. 
1:f10793f:      *  Data should be deleted from t1 at commit time
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testTest4() throws SQLException {
1:f10793f:         Statement s1 = getConnection().createStatement(
1:f10793f:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:f10793f:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:54a4649:         try {
1:f10793f:             s1.executeUpdate("drop table t1");
1:54a4649:         }
1:f10793f:         catch(SQLException e)
1:54a4649:         {
1:f10793f:             assertSQLState("42Y55" , e);
1:f10793f:         }	
1:f10793f:         s1.executeUpdate("create table t1(c11 int, c12 int)");
1:f10793f:         s1.executeUpdate("declare global temporary table SESSION.t1(" +
1:f10793f:                 "c11 int, c12 int) on commit delete rows not logged");
1:f10793f:         s1.executeUpdate("insert into session.t1 values(11, 1)");
1:f10793f:         s1.executeUpdate("insert into session.t1 values(12, 2)");
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "2");
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from t1") , "0");
1:f10793f:         //Insert into real table using temporary table data on a statement with
1:f10793f:         //holdability set to true
1:f10793f:         s1.executeUpdate("INSERT INTO T1 SELECT * FROM SESSION.T1");
1:f10793f:         commit();
1:f10793f:         //Temp table t1 will have no data after commit
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from SESSION.t1") , "0");
1:f10793f:         //Physical table t1 will have 2 rows after commit
1:f10793f:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:f10793f:                 "select count(*) from t1") , "2");
1:f10793f:         s1.executeUpdate("drop table SESSION.t1");
1:f10793f:         s1.executeUpdate("drop table t1");
1:f10793f:     }
1:f10793f:     /**
1:f10793f:      *  Temporary tables declared in a pooled connection should get dropped 
1:f10793f:      *  when that pooled connection is closed.
1:f10793f:      *  
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testPooledConnectionClosed() throws SQLException {
1:f10793f: 
1:f10793f:         ConnectionPoolDataSource dscsp = 
1:f10793f:             J2EEDataSource.getConnectionPoolDataSource();
1:f10793f:         //In the first connection handle to the pooled connection, create 
1:f10793f:         //physical session schema, create table t1 in it
1:f10793f:         PooledConnection pc = dscsp.getPooledConnection();
1:f10793f:         Connection pcon = pc.getConnection();
1:f10793f:         Statement s = pcon.createStatement();
2:f10793f:         try {
1:f10793f:             s.executeUpdate("CREATE schema SESSION");
1:f10793f:         }
1:f10793f:         catch(SQLException e)
1:f10793f:         {
1:f10793f:             assertSQLState("X0Y68" , e);
1:f10793f:         }
1:f10793f:         s.executeUpdate("CREATE TABLE SESSION.tx(c21 int)");
1:f10793f:         s.executeUpdate("insert into SESSION.tx values(11)");
1:f10793f:         s.executeUpdate("insert into SESSION.tx values(12)");
1:f10793f:         s.executeUpdate("insert into SESSION.tx values(13)");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.tx") , "3");
1:f10793f:         //Declare temp table with same name as physical table in SESSION schema
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.tx(" +
1:f10793f:                 "c11 int, c12 int) on commit preserve rows not logged");
1:f10793f:         s.executeUpdate("insert into SESSION.tx values(11,1)");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.tx") , "1");
1:f10793f:         commit();
1:f10793f:         //Now close the connection handle to the pooled connection
1:f10793f:         getConnection().close();
1:f10793f:         //Do another getConnection() to get a new connection handle to the 
1:f10793f:         //pooled connection
1:f10793f:         s = getConnection().createStatement();
1:f10793f:         //In this new handle, a select * from SESSION.tx should be looking at 
1:f10793f:         //the physical session table
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f10793f:                 "select count(*) from SESSION.tx") , "3");
1:f10793f:         s.executeUpdate("drop table SESSION.tx");
1:54a4649:     }
1:54a4649: 
1:54a4649:     /**
1:54a4649:      * Test that we don't get an NPE when re-using a PreparedStatement
1:54a4649:      * on a temp table declared and then rolled back. See DERBY-6189.
1:54a4649:      */
1:54a4649:     public  void    test_derby_6189() throws Exception
1:54a4649:     {
1:54a4649:         Connection  conn = getConnection();
1:54a4649: 
1:54a4649:         conn.prepareStatement
1:54a4649:             ( "DECLARE GLOBAL TEMPORARY TABLE SESSION.t6189( c21 int, c22 int) not logged on commit preserve rows" )
1:54a4649:             .execute();        
1:54a4649:         PreparedStatement pStmtInsert = conn.prepareStatement( "insert into SESSION.t6189 values (23, 1)" );
1:54a4649: 
1:54a4649:         pStmtInsert.execute();
1:54a4649: 
1:54a4649:         conn.rollback();
1:54a4649: 
1:775bd93:         assertStatementError("42X05", pStmtInsert); 
1:54a4649:     }
1:54a4649:     
1:54a4649: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite();
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Client/Server");
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:775bd93
/////////////////////////////////////////////////////////////////////////
1:         assertStatementError("42X05", pStmtInsert); 
commit:54a4649
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /**
1:      * Test that we don't get an NPE when re-using a PreparedStatement
1:      * on a temp table declared and then rolled back. See DERBY-6189.
1:      */
1:     public  void    test_derby_6189() throws Exception
1:     {
1:         Connection  conn = getConnection();
1: 
1:         conn.prepareStatement
1:             ( "DECLARE GLOBAL TEMPORARY TABLE SESSION.t6189( c21 int, c22 int) not logged on commit preserve rows" )
1:             .execute();        
1:         PreparedStatement pStmtInsert = conn.prepareStatement( "insert into SESSION.t6189 values (23, 1)" );
1: 
1:         pStmtInsert.execute();
1: 
1:         conn.rollback();
1: 
1:         try {
1:             pStmtInsert.execute();
0:             fail( "Should fail!" );
1:         }
0:         catch ( SQLException se)
1:         {
0:             assertEquals( "42X05", se.getSQLState() );
1:         }
1:     }
1:     
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:f10793f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.declareGlobalTempTableJavaJDBC30Test
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
0: import java.sql.SQLException;
1: 
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.PooledConnection;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.*;
1: 
1: /**
1:  * Test for declared global temporary tables (introduced in Cloudscape 5.2)
1:  * and pooled connection close and jdbc 3.0 specific features
1:  * The jdbc3.0 specific featuers are holdable cursors, savepoints.
1:  * The rest of the temp table test are in declareGlobalTempTableJavaTest class. 
1:  * The reason for a different test class is that the holdability and savepoint 
1:  * support is under jdk14 and higher. But we want to be able to run the 
1:  * non-holdable tests under all the jdks we support and hence splitting the 
1:  * tests into two separate tests. 
1:  */
1: 
1: 
1: public class DeclareGlobalTempTableJavaJDBC30Test extends BaseJDBCTestCase {
1: 
1:     public DeclareGlobalTempTableJavaJDBC30Test(String name)
1:     {
1:         super(name);
1:     }	
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite();
1:         suite.addTest(TestConfiguration.embeddedSuite(
1:                 DeclareGlobalTempTableJavaJDBC30Test.class));
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:                 getClientSuite()));
1:         return suite;
1:     }
1:     
1:     /**
1:      * Return a suite of tests that are run with client only
1:      * 
1:      * @return A suite of tests being run with client only
1:      */
1:     private static Test getClientSuite() {
0:         TestSuite suite = new TestSuite("Client/Server");
1:         // skip the tests with more than 1 savepoint -  
1:         // see (lack of support described in) DERBY-3687
1:         // so, only do the following with network server/client: 
1:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:             "testOnCommitPreserveRowsWithHoldability"));
1:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:             "testSavepointRollbackbehaviour7"));
1:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:             "testSavepointRollbackbehaviour8"));
1:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:             "testSavepointRollbackbehaviour11"));
1:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:             "testSavepointRollbackbehaviour12"));
1:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:             "testTest4"));
1:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:             "testPooledConnectionClosed"));
1:         
1:         // following 2 fail with network server; see DERBY-4373
1:         /*
1:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:             "testOnCommitDeleteRowsWithHoldableOpenCursor"));
1:         suite.addTest(new DeclareGlobalTempTableJavaJDBC30Test(
1:             "testOnCommitDeleteRowsHoldabilityWithPreparedStatements"));
1:         */
1:         return suite;
1:     }
1:     
1:     protected void setUp() throws Exception {
1:         super.setUp();
1:         getConnection().setAutoCommit(false);
1:     }
1:     protected void tearDown() throws Exception {
1:         super.tearDown();
1:     }
1:     /**
1:      *  Tests that If a Global Temp table(with on commi delete rows) has open 
1:      *  cursors held on it 
1:      *  Data should be preserved in at commit time
1:      *
1:      *  @throws SQLException 
1:      */
1:     public  void  testOnCommitDeleteRowsWithHoldableOpenCursor() 
1:     throws SQLException {
1:         Statement s1 = getConnection().createStatement(
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:         s1.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit delete rows not logged");
1:         s1.executeUpdate("insert into session.t1 values(11, 1)");
1:         s1.executeUpdate("insert into session.t1 values(12, 2)");
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         //hold cursor open on t1. Commit should preserve the rows
1:         ResultSet rs1 = s1.executeQuery("select * from SESSION.t1");
1:         rs1.next();
1:         //cursor opened
1:         //Temp tables t2 & t3 with one held open cursor on them together. Data
1:         //should be preserved in t2 & t3 at commit time
1:         Statement s2 = getConnection().createStatement(
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:         s2.executeUpdate("declare global temporary table SESSION.t2(" +
1:                 "c21 int, c22 int) on commit delete rows not logged");
1:         s2.executeUpdate("insert into session.t2 values(21, 1)");
1:         s2.executeUpdate("insert into session.t2 values(22, 2)");
1:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:                 "select count(*) from SESSION.t2"), "2");
1:         s2.executeUpdate("declare global temporary table SESSION.t3(" +
1:                 "c31 int, c32 int) on commit delete rows not logged");
1:         s2.executeUpdate("insert into session.t3 values(31, 1)");
1:         s2.executeUpdate("insert into session.t3 values(32, 2)");
1:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:                 "select count(*) from SESSION.t3") , "2");
1:         //hold cursor open on t2 & t3. Commit should preseve the rows
1:         ResultSet rs23 = s2.executeQuery(
1:                 "select * from SESSION.t2, SESSION.t3 where c22=c32"); 
1:         rs23.next(); 
1:         //cursor Opened
1:         Statement s3 = getConnection().createStatement(
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:         s3.executeUpdate("declare global temporary table SESSION.t4(" +
1:                 "c41 int, c42 int) on commit delete rows not logged");
1:         s3.executeUpdate("insert into session.t4 values(41, 1)");
1:         s3.executeUpdate("insert into session.t4 values(42, 2)");
1:         ResultSet rs4 = s3.executeQuery("select count(*) from SESSION.t4");
1:         JDBC.assertSingleValueResultSet(rs4 , "2");
1:         //hold cursor open on t4 but close it before commit, 
1:         //Data should be deleted after commit
1:         rs4 = s3.executeQuery("select * from SESSION.t4");
1:         rs4.next();
1:         rs4.close();
1:         //rs4 closed before committing.
1:         commit();
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:                 "select count(*) from SESSION.t2") , "2");
1:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:                 "select count(*) from SESSION.t3") , "2");
1:         JDBC.assertSingleValueResultSet(s3.executeQuery(
1:                 "select count(*) from SESSION.t4") , "0");
1:         s1.executeUpdate("drop table SESSION.t1");
1:         s2.executeUpdate("drop table SESSION.t2");
1:         s3.executeUpdate("drop table SESSION.t3");   
1:         s3.executeUpdate("drop table SESSION.t4");
1:         rs1.close(); rs23.close(); rs4.close();
1:         commit();
1:         s1.close();  s2.close(); s3.close();
1:     }
1:     /**
1:      *  Test declared temporary table with ON COMMIT DELETE ROWS and holdable
1:      *  cursors on prepared statement
1:      *
1:      *  @throws SQLException 
1:      */
1:     public void testOnCommitDeleteRowsHoldabilityWithPreparedStatements() 
1:     throws SQLException {
1:         Statement s1 = createStatement();
1:         s1.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit delete rows not logged");
1:         s1.executeUpdate("insert into session.t1 values(11, 1)");
1:         s1.executeUpdate("insert into session.t1 values(12, 2)");
1:         //create a prepared statement with hold cursors over commit
1:         PreparedStatement ps1 = getConnection().prepareStatement(
1:                 "select count(*) from SESSION.t1",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, 
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:         ResultSet rs1 = ps1.executeQuery();
1:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:         PreparedStatement ps2 = getConnection().prepareStatement(
1:                 "select * from SESSION.t1", ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         //hold cursor open on t1. Commit should preserve the rows
1:         ResultSet rs11 = ps2.executeQuery();
1:         rs11.next();
1:         //Cursor was Opened.
1:         //Temp table t2 with one held cursor but it is closed before commit. 
1:         //Data should be deleted from t2 at commit time
1:         s1.executeUpdate("declare global temporary table SESSION.t2(" +
1:                 "c21 int, c22 int) on commit delete rows not logged");
1:         s1.executeUpdate("insert into session.t2 values(21, 1)");
1:         s1.executeUpdate("insert into session.t2 values(22, 2)");
1:         //create a prepared statement with hold cursors over commit
1:         PreparedStatement ps3 = getConnection().prepareStatement(
1:                 "select count(*) from SESSION.t2",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, 
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:         ResultSet rs2 = ps3.executeQuery();
1:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:         PreparedStatement ps4 = getConnection().prepareStatement(
1:                 "select * from SESSION.t2", ResultSet.TYPE_FORWARD_ONLY, 		    ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:         //hold cursor open on t2 but close it before commit
1:         rs2 = ps4.executeQuery();
1:         rs2.next();
1:         rs2.close();
1:         //commiting Point
1:         commit();
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         //Need to close the held cursor on t1 before t1 can be dropped
1:         rs11.close();
1:         rs1.close();
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         s1.executeUpdate("drop table SESSION.t1");
1:         s1.executeUpdate("drop table SESSION.t2");
1:     }
1:     /**
1:      *  Tests a temporary table with ON COMMIT PRESERVE ROWS and various 
1:      *  combinations of holdability.
1:      *  Temp table t1 with held open cursors on it. Data should be preserved,
1:      *  holdability shouldn't matter
1:      *
1:      *  @throws SQLException 
1:      */
1:     public void testOnCommitPreserveRowsWithHoldability() throws SQLException	{
1:         //create a statement with hold cursors over commit
1:         Statement s1 = getConnection().createStatement(
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:         s1.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged");
1:         s1.executeUpdate("insert into session.t1 values(11, 1)");
1:         s1.executeUpdate("insert into session.t1 values(12, 2)");
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         //Opening the Cursor
1:         ResultSet rs1 = s1.executeQuery("select * from SESSION.t1");
1:         rs1.next();
1:         //create a statement without hold cursors.
1:         Statement s2 = createStatement();
1:         s1.executeUpdate("declare global temporary table SESSION.t2(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged");
1:         s1.executeUpdate("insert into session.t2 values(11, 1)");
1:         s1.executeUpdate("insert into session.t2 values(12, 2)");
1:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:                 "select count(*) from SESSION.t2") , "2");
1:         //Opening The Cursor
1:         ResultSet rs2 = s2.executeQuery("select * from SESSION.t2");
1:         rs2.next();
1:         //commiting point
1:         commit();
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         JDBC.assertSingleValueResultSet(s2.executeQuery(
1:                 "select count(*) from SESSION.t2") , "2");
1:         s1.executeUpdate("drop table SESSION.t1");
1:         s2.executeUpdate("drop table SESSION.t2");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 1 (3A)
1:      *  In the transaction Create savepoint1 and declare temp table t1. 
1:      *  Create savepoint 2, drop temp table t1, rollback savepoint 2 
1:      *  select should pass, rollback savepoint 1, select should fail.
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour1() throws SQLException {
1:         Statement s = createStatement();
1:         //Set The First savepoint
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         //create a temp table t1
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged");
1:         PreparedStatement pStmt = prepareStatement(
1:                 "insert into SESSION.t1 values (?, ?)");
1:         pStmt.setInt(1, 11);
1:         pStmt.setInt(2, 1);
1:         pStmt.execute();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "1");
1:         //Set The Second savepoint
1:         Savepoint savepoint2 = getConnection().setSavepoint();
1:         //drop the temp table t1
1:         s.executeUpdate("drop table SESSION.t1");
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:         //Rollback to the second savepoint - drop table Operation is rolled 
1:         //back hence we should have t1
1:         getConnection().rollback(savepoint2);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");	
1:         //Rollback to the First savepoint - create table Operation is also 
1:         //rolled back hence there is no t1
1:         getConnection().rollback(savepoint1);
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 2 (3B)
1:      *  In the transaction Create savepoint1 and declare temp table t1. 
1:      *  Create savepoint2 and declare temp table t2
1:      *  Release savepoint 1 and select from temp table t1 and t2.
1:      *  Drop temp table t2(explicit drop), rollback transaction(implicit drop
1:      *  of t1) Select from temp table t1 and t2 will fail.
1:      *
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour2() throws SQLException {
1:         Statement s = createStatement();
1:         //Set First savepoint (save point - 1)
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged");
1:         //Set Second savepoint (save point - 2)
1:         Savepoint savepoint2 = getConnection().setSavepoint();
1:         s.executeUpdate("declare global temporary table SESSION.t2(" +
1:                 "c21 int, c22 int) on commit preserve rows not logged");
1:         //Release First savepoint
1:         getConnection().releaseSavepoint(savepoint1);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         //Drop the Temp Table t2 Explicitly and t1 Implicitly(by rolling back)	
1:         s.executeUpdate("drop table SESSION.t2");
1:         rollback();
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:         assertStatementError("42X05" , s , "select * from SESSION.t2");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 3 (3C)
1:      *  In the transaction Create savepoint1 and declare temp table t1. 
1:      *  Create savepoint2 and declare temp table t2.
1:      *  Release savepoint 1 and select from temp table t1 and t2 should pass.
1:      *  Create savepoint3 and rollback savepoint3(should not touch t1 and t2)
1:      *  select from temp tables t1 and t2 should pass.
1:      *  Rollback transaction and select from temp tables t1 and t2 should fail.
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour3() throws SQLException  {
1:         Statement s = createStatement();
1:         //set first savepoint
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows  not logged");
1:         //set second savepoint
1:         Savepoint savepoint2 = getConnection().setSavepoint();
1:         s.executeUpdate("declare global temporary table SESSION.t2(" +
1:                 "c21 int, c22 int) on commit preserve rows  not logged");
1:         //release the first savepoint
1:         getConnection().releaseSavepoint(savepoint1);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         //set third savepoint
1:         Savepoint savepoint3 = getConnection().setSavepoint();
1:         //rollback to third savepoint - (should not touch t1 and t2)
1:         getConnection().rollback(savepoint3);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         //rollback the entire transaction - this rolls back create statements
1:         //also hence t1 , t2 got deleted
1:         rollback();
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:         assertStatementError("42X05" , s , "select * from SESSION.t2");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 4 (3D)
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour4() throws SQLException {
1:         Statement s = createStatement();
1:         //set first savepoint
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows  not logged");
1:         //set second savepoint
1:         Savepoint savepoint2 = getConnection().setSavepoint();
1:         s.executeUpdate("drop table SESSION.t1");
1:         //rollback to second savepoint
1:         getConnection().rollback(savepoint2);
1:         JDBC.assertSingleValueResultSet(s.executeQuery("" +
1:                 "select count(*) from SESSION.t1") , "0");
1:         //commit
1:         commit();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         s.executeUpdate("drop table SESSION.t1");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 5 - 3E
1:      *  Tests the basic definition of savepoint in combination with Rollback.
1:      *
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour5() throws SQLException {
1:         Statement s = createStatement();
1:         //set first savepoint 
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows  not logged");
1:         //set second savepoint
1:         Savepoint savepoint2 = getConnection().setSavepoint();
1:         s.executeUpdate("drop table SESSION.t1");
1:         //rollback to first savepoint
1:         getConnection().rollback(savepoint1);
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:     }
1:     
1:     /**
1:      *  Savepoint and Rollback behavior - 6 - 3J
1:      *  In the transaction: declare temp table t1 with 2 columns and commit.
1:      *  Create savepoint1 and drop temp table t1 with 2 columns, declare temp
1:      *  table t1 but this time with 3 columns.
1:      *  Create savepoint2 and drop temp table t1 with 3 columns, rollback,
1:      *  select from temp table t1 here should have 2 columns
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour6() throws SQLException {
1:         String[] s1 = {"C11" , "C12"};
1:         String[] s2 = {"C11" , "C12" , "C13"};
1:         Statement s = createStatement();
1:         // declare temp table t1 with 2 columns
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows  not logged");
1:         s.executeUpdate("insert into SESSION.t1 values(11, 11)");
1:         ResultSet rs1 = s.executeQuery("select * from SESSION.t1");
1:         JDBC.assertColumnNames(rs1 , s1);
1:         //commiting point
1:         getConnection().commit();
1:         //set first savepoint
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("drop table SESSION.t1");
1:         //declare temp table t1 with 3 columns
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int, c13 int not null) on commit preserve rows " +
1:                 "not logged");
1:         s.executeUpdate("insert into SESSION.t1 values(22, 22, 22)");
1:         rs1 = s.executeQuery("select * from SESSION.t1");
1:         JDBC.assertColumnNames(rs1 , s2);
1:         //set second savepoint
1:         Savepoint savepoint2 = getConnection().setSavepoint();
1:         s.executeUpdate("drop table SESSION.t1");
1:         //rollback the transaction
1:         rollback();
1:         rs1 = s.executeQuery("select * from SESSION.t1");
1:         JDBC.assertColumnNames(rs1 , s1);	
1:         s.executeUpdate("drop table SESSION.t1");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 7 - 3K
1:      *  tests the savepoint and rollback behaviour with update command
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour7() throws SQLException {
1:         Statement s = createStatement();
1:         //declare temp table t1 & t2, insert few rows and commit
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged " +
1:                 "on rollback delete rows");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:                 "c21 int, c22 int) on commit preserve rows not logged");
1:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:         s.executeUpdate("insert into session.t2 values(21, 1)");
1:         commit();
1:         //committed - the first transaction has been completed
1:         //In the next transaction, insert couple more rows in t1 & t2
1:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:         s.executeUpdate("insert into SESSION.t2 values(22, 2)");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "2");
1:         //set first savepoint
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("UPDATE SESSION.t1 SET c12 = 3 where c12>1");
1:         s.executeUpdate("UPDATE SESSION.t2 SET c22 = 3 where c22>2");
1:         //rollback to first savepoint
1:         getConnection().rollback(savepoint1);
1:         //Rollback to savepoint1 and we should loose all the rows in t1 temp
1:         //table t2 should also have no rows because attempt was made to modify 
1:         //it (even though nothing actually got modified in t2 in the savepoint)
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         commit();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         s.executeUpdate("drop table SESSION.t1");
1:         s.executeUpdate("drop table SESSION.t2");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 8 - 3L
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour8() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows  not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:                 "c21 int, c22 int) on commit preserve rows  not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:         s.executeUpdate("insert into session.t2 values(21, 1)");
1:         commit();
1:         //insert couple more rows in t1 & t2 and
1:         //Create savepoint1 and update some rows in t1 and inspect the data
1:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:         s.executeUpdate("insert into session.t2 values(22, 2)");
1:         //set first savepoint
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("UPDATE SESSION.t1 SET c12 = 3 where c12>1");
1:         s.executeUpdate("UPDATE SESSION.t2 SET c22 = 3 where c22>3");
1:         //rollback to first savepoint
1:         getConnection().rollback(savepoint1);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:         rollback();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         //cleanUp
1:         s.executeUpdate("drop table SESSION.t1");
1:         s.executeUpdate("drop table SESSION.t2");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 9 - 3M
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour9() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged " +
1:                 "on rollback delete rows");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:                 "c21 int, c22 int) on commit preserve rows not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(" +
1:                 "c31 int, c32 int) on commit preserve rows not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t4(" +
1:                 "c41 int, c42 int) on commit preserve rows not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:         s.executeUpdate("insert into SESSION.t2 values(21, 1)");
1:         s.executeUpdate("insert into SESSION.t3 values(31, 1)");
1:         s.executeUpdate("insert into SESSION.t4 values(41, 1)");
1:         commit();
1:         //Beginning of second transaction
1:         //Insert a couple of more rows into t1 , t2 and t3
1:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:         s.executeUpdate("insert into session.t2 values(22, 2)");
1:         s.executeUpdate("insert into session.t3 values(32, 2)");
1:         //set first savepoint                    
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("DELETE FROM SESSION.t1 where c12>1");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "1");
1:         //set second savepoint
1:         Savepoint savepoint2 = getConnection().setSavepoint();
1:         s.executeUpdate("DELETE FROM SESSION.t2 where c22>1");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "1");
1:         //Release savepoint2 and now savepoint1 should keep track of changes 
1:         //made to t1 and t2
1:         getConnection().releaseSavepoint(savepoint2);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "1");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "1");
1:         // Rollback savepoint1 and should see no data in t1 and t2
1:         getConnection().rollback(savepoint1);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         //Should see data in t3 since it was not touched in the savepoint that 
1:         //was rolled back
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t3") , "2");
1:         rollback();
1:         //Rolling back the transaction we should see no data in t1 and t2 and t3
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t3") , "0");
1:         //Should see data in t4 since it was not touched in the transaction that was rolled back
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t4") , "1");
1:         s.executeUpdate("drop table SESSION.t1");
1:         s.executeUpdate("drop table SESSION.t2");
1:         s.executeUpdate("drop table SESSION.t3");
1:         s.executeUpdate("drop table SESSION.t4");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 10 - 3N
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour10() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:                 "c21 int, c22 int) on commit preserve rows not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(" +
1:                 "c31 int, c32 int) on commit preserve rows not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t4(" +
1:                 "c41 int, c42 int) on commit preserve rows not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:         s.executeUpdate("insert into SESSION.t2 values(21, 1)");
1:         s.executeUpdate("insert into SESSION.t2 values(22, 2)");
1:         s.executeUpdate("insert into SESSION.t3 values(31, 1)");
1:         s.executeUpdate("insert into SESSION.t4 values(41, 1)");
1:         commit();
1:         //In the next transaction, insert couple more rows in t3
1:         s.executeUpdate("insert into SESSION.t3 values(31, 2)");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t3") , "2");
1:         //Create savepoint1 and delete some rows from t1
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("DELETE FROM SESSION.t1 where c12>1");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "1");
1:         s.executeUpdate("DELETE FROM SESSION.t2 where c22>3");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "2");
1:         //Create savepoint2 and delete some rows from t2 
1:         Savepoint savepoint2 = getConnection().setSavepoint();
1:         s.executeUpdate("DELETE FROM SESSION.t2 where c22>1");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "1");
1:         //Rollback the transaction and should see no data in t1 and t2 and t3
1:         rollback();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t3") , "0");
1:         //Should see data in t4 since it was not touched in the transaction 
1:         //that was rolled back
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t4") , "1");
1:         s.executeUpdate("drop table SESSION.t1");
1:         s.executeUpdate("drop table SESSION.t2");
1:         s.executeUpdate("drop table SESSION.t3");
1:         s.executeUpdate("drop table SESSION.t4");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 11 - 3O
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour11() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:                 "c21 int, c22 int) on commit preserve rows not logged on " +
1:                 "rollback delete rows");
1:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:         s.executeUpdate("insert into SESSION.t2 values(21, 1)");
1:         commit();
1:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         //set the first savepoint here
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("insert into SESSION.t2 values(22, 2)");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "2");
1:         //Rollback savepoint1; expect no data in t2 but t1 should have data
1:         getConnection().rollback(savepoint1);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         //Commit the transaction; expect no data in t2 but t1 should have data
1:         commit();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         s.executeUpdate("drop table SESSION.t1");
1:         s.executeUpdate("drop table SESSION.t2");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 12 - 3P
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour12() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged");
1:         s.executeUpdate("insert into SESSION.t1 values(11, 1)");
1:         s.executeUpdate("insert into SESSION.t1 values(12, 2)");
1:         commit();
1:         //set the first savepoint
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         s.executeUpdate("insert into SESSION.t1 values(13, 3)");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "3");
1:         //release the savepoint - now transaction should keep track of changes
1:         //made to t1
1:         getConnection().releaseSavepoint(savepoint1);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "3");
1:         //Rollback the transaction and should still see no data in t1
1:         rollback();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         s.executeUpdate("drop table SESSION.t1");
1:     }
1:     /**
1:      *  Savepoint and Rollback behavior - 13 - 3Q
1:      *  tests the rollback , savepoint behaviour with prepartedStatement
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testSavepointRollbackbehaviour13() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(" +
1:                 "c21 int, c22 int) not logged on commit preserve rows");
1:         PreparedStatement pStmtInsert = prepareStatement(
1:                 "insert into SESSION.t2 values (?, ?)");
1:         pStmtInsert.setInt(1, 21);
1:         pStmtInsert.setInt(2, 1);
1:         pStmtInsert.execute();
1:         pStmtInsert.setInt(1, 22);
1:         pStmtInsert.setInt(2, 2);
1:         pStmtInsert.execute();
1:         pStmtInsert.setInt(1, 23);
1:         pStmtInsert.setInt(2, 2);
1:         pStmtInsert.execute();
1:         PreparedStatement pStmtUpdate = prepareStatement(
1:                 "UPDATE SESSION.t2 SET c22 = 3 where c21=?");
1:         pStmtUpdate.setInt(1, 23);
1:         pStmtUpdate.execute();
1:         PreparedStatement pStmtDelete = prepareStatement(
1:                 "DELETE FROM SESSION.t2 where c21 = ?");
1:         pStmtDelete.setInt(1, 23);
1:         pStmtDelete.execute();
1:         commit();//committing point
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "2");
1:         //set the first savepoint
1:         Savepoint savepoint1 = getConnection().setSavepoint();
1:         pStmtInsert.setInt(1, 23);
1:         pStmtInsert.setInt(2, 2);
1:         pStmtInsert.execute();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2")  , "3");
1:         //set the second savepoint
1:         Savepoint savepoint2 = getConnection().setSavepoint();
1:         pStmtUpdate.setInt(1, 23);
1:         pStmtUpdate.execute();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "3");
1:         //rollback savepoint2 and should loose all the data from t2");
1:         getConnection().rollback(savepoint2);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "0");
1:         //Create savepoint3, insert some rows into t2 using prepared statement
1:         Savepoint savepoint3 = getConnection().setSavepoint();
1:         pStmtInsert.setInt(1, 21);
1:         pStmtInsert.setInt(2, 1);
1:         pStmtInsert.execute();
1:         pStmtInsert.setInt(1, 22);
1:         pStmtInsert.setInt(2, 2);
1:         pStmtInsert.execute();
1:         pStmtInsert.setInt(1, 23);
1:         pStmtInsert.setInt(2, 333);
1:         pStmtInsert.execute();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "3");
1:         //Create savepoint4 and update row inserted in savepoint3 using prepared
1:         //statement and inspect the data in t2
1:         Savepoint savepoint4 = getConnection().setSavepoint();
1:         pStmtUpdate.setInt(1, 23);
1:         pStmtUpdate.execute();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "3");
1:         //release savepoint4
1:         getConnection().releaseSavepoint(savepoint4);
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "3");
1:         pStmtDelete.setInt(1, 23);
1:         pStmtDelete.execute();
1:         //Commit transaction and should see data in t2
1:         commit();
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.t2") , "2");
1:         s.executeUpdate("drop table SESSION.t2");
1:     }	
1:     /**
1:      *  Test declared temporary table with ON COMMIT DELETE ROWS and holdable 
1:      *  cursors and temp table as part of subquery
1:      *  Temp table t1 with no direct held cursor open on it. 
1:      *  Data should be deleted from t1 at commit time
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testTest4() throws SQLException {
1:         Statement s1 = getConnection().createStatement(
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT );
1:         try {
1:             s1.executeUpdate("drop table t1");
1:         }
1:         catch(SQLException e)
1:         {
1:             assertSQLState("42Y55" , e);
1:         }	
1:         s1.executeUpdate("create table t1(c11 int, c12 int)");
1:         s1.executeUpdate("declare global temporary table SESSION.t1(" +
1:                 "c11 int, c12 int) on commit delete rows not logged");
1:         s1.executeUpdate("insert into session.t1 values(11, 1)");
1:         s1.executeUpdate("insert into session.t1 values(12, 2)");
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from SESSION.t1") , "2");
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from t1") , "0");
1:         //Insert into real table using temporary table data on a statement with
1:         //holdability set to true
1:         s1.executeUpdate("INSERT INTO T1 SELECT * FROM SESSION.T1");
1:         commit();
1:         //Temp table t1 will have no data after commit
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from SESSION.t1") , "0");
1:         //Physical table t1 will have 2 rows after commit
1:         JDBC.assertSingleValueResultSet(s1.executeQuery(
1:                 "select count(*) from t1") , "2");
1:         s1.executeUpdate("drop table SESSION.t1");
1:         s1.executeUpdate("drop table t1");
1:     }
1:     /**
1:      *  Temporary tables declared in a pooled connection should get dropped 
1:      *  when that pooled connection is closed.
1:      *  
1:      *  @throws SQLException 
1:      */
1:     public void testPooledConnectionClosed() throws SQLException {
1: 
1:         ConnectionPoolDataSource dscsp = 
1:             J2EEDataSource.getConnectionPoolDataSource();
1:         //In the first connection handle to the pooled connection, create 
1:         //physical session schema, create table t1 in it
1:         PooledConnection pc = dscsp.getPooledConnection();
1:         Connection pcon = pc.getConnection();
1:         Statement s = pcon.createStatement();
1:         try {
1:             s.executeUpdate("CREATE schema SESSION");
1:         }
1:         catch(SQLException e)
1:         {
1:             assertSQLState("X0Y68" , e);
1:         }
1:         s.executeUpdate("CREATE TABLE SESSION.tx(c21 int)");
1:         s.executeUpdate("insert into SESSION.tx values(11)");
1:         s.executeUpdate("insert into SESSION.tx values(12)");
1:         s.executeUpdate("insert into SESSION.tx values(13)");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.tx") , "3");
1:         //Declare temp table with same name as physical table in SESSION schema
1:         s.executeUpdate("declare global temporary table SESSION.tx(" +
1:                 "c11 int, c12 int) on commit preserve rows not logged");
1:         s.executeUpdate("insert into SESSION.tx values(11,1)");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.tx") , "1");
1:         commit();
1:         //Now close the connection handle to the pooled connection
1:         getConnection().close();
1:         //Do another getConnection() to get a new connection handle to the 
1:         //pooled connection
1:         s = getConnection().createStatement();
1:         //In this new handle, a select * from SESSION.tx should be looking at 
1:         //the physical session table
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "select count(*) from SESSION.tx") , "3");
1:         s.executeUpdate("drop table SESSION.tx");
1:     }	
1: }
============================================================================