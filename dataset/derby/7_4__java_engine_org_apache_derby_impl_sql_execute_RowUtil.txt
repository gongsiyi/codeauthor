1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.RowUtil
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
8:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369:  
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:ceb12d3: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:ceb12d3: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:ceb12d3: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: 
2:eac0369: /**
1:eac0369:   Utility class manipulating rows.
1:eac0369: 
1:eac0369:   <P>Note: this class is public so it may be used by Replication execution
1:eac0369:   code. It is basically not public.
1:eac0369:   */
1:eac0369: public class RowUtil
1:eac0369: {
1:f26c60c:     /** Row count base added for testing JDBC 4.2 */
1:2e87a4c:     private  static  long    rowCountBase = 0L;
1:2e87a4c: 
1:2e87a4c:     /**
1:2e87a4c:      * Debug method used to test the setLargeMaxRows() method added by JDBC 4.2.
1:2e87a4c:      * This method is a NOP on a production (insane) build of Derby.
1:2e87a4c:      */
1:2e87a4c:     public  static  void    setRowCountBase( long newBase )
1:2e87a4c:     {
1:2e87a4c:         if (SanityManager.DEBUG)    { rowCountBase = newBase; }
1:2e87a4c:     }
1:2e87a4c: 
1:2e87a4c:     /** Retrieve the row count base */
1:2e87a4c:     public  static  long    getRowCountBase() { return rowCountBase; }
1:eac0369: 
1:eac0369:  	/**
1:eac0369: 	  Get an empty ExecRow.
1:eac0369: 
1:eac0369: 	  @param columnCount the number of columns in the row.
1:eac0369: 	  @return the row.
1:eac0369: 	  */
1:eac0369: 	public static ExecRow getEmptyValueRow(int columnCount, LanguageConnectionContext lcc)
1:eac0369: 	{
1:6c000e8: 		return lcc.getLanguageConnectionFactory().getExecutionFactory().getValueRow(columnCount);
1:eac0369: 	}
1:eac0369: 
1:eac0369:  	/**
1:eac0369: 	  Get an empty ExecIndexRow.
1:eac0369: 
1:eac0369: 	  @param columnCount the number of columns in the row.
1:eac0369: 	  @return the row.
1:eac0369: 	  */
1:ceb12d3: 	public static ExecIndexRow getEmptyIndexRow(int columnCount, LanguageConnectionContext lcc)
1:eac0369: 	{
1:ceb12d3: 		return lcc.getLanguageConnectionFactory().
1:ceb12d3:             getExecutionFactory().getIndexableRow(columnCount);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Clone an ExecRow's columns and place the coloned columns in another
1:eac0369: 	  ExecRow.
1:eac0369: 
1:eac0369: 	  @param to Place the cloned columns here.
1:eac0369: 	  @param from Get the columns to clone here.
1:eac0369: 	  @param count Clone this number of columns.
1:eac0369: 	  */
1:eac0369: 	public static void copyCloneColumns(ExecRow to, ExecRow from, int count)
1:eac0369: 	{
1:eac0369: 		for (int ix = 1; ix <= count; ix++)
1:eac0369: 		{
1:eac0369: 			to.setColumn(ix,from.cloneColumn(ix));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Copy references for an ExecRow's columns to another ExecRow.
1:eac0369: 
1:eac0369: 	  @param to Place the column references here.
1:eac0369: 	  @param from Get the column references from here.
1:eac0369: 	  */
1:eac0369: 	public static void copyRefColumns(ExecRow to, ExecRow from)
1:eac0369: 	{
1:eac0369: 		Object[] src = from.getRowArray();
1:eac0369: 		Object[] dst = to.getRowArray();
1:eac0369: 		System.arraycopy(src, 0, dst, 0, src.length);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Copy references for an ExecRow's columns to another ExecRow.
1:eac0369: 
1:eac0369: 	  @param to Place the column references here.
1:eac0369: 	  @param from Get the column references from here.
1:eac0369: 	  @param count Copy this number of column references.
1:eac0369: 	  */
1:eac0369: 	public static void copyRefColumns(ExecRow to, ExecRow from, int count)
1:92268ac: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		copyRefColumns(to, 0, from, 0, count);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Copy references for an ExecRow's columns to another ExecRow.
1:eac0369: 
1:eac0369: 	  @param to Place the column references here.
1:eac0369: 	  @param from Get the column references from here.
1:eac0369: 	  @param start The 0 based index of the first column to copy. 
1:eac0369: 	  @param count Copy this number of column references.
1:eac0369: 	  */
1:eac0369: 	public static void copyRefColumns(ExecRow to, ExecRow from,
1:eac0369: 									  int start, int count)
2:eac0369: 									  throws StandardException
1:eac0369: 	{
1:eac0369: 		copyRefColumns(to, 0, from, start, count);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Copy references for an ExecRow's columns to another ExecRow.
1:eac0369: 	  @param to Place the column references here.
1:eac0369: 	  @param toStart The 0-based index of the first column to replace.
1:eac0369: 	  @param from Get the column references from here.
1:eac0369: 	  @param fromStart The 0 based index of the first column to copy. 
1:eac0369: 	  @param count Copy this number of column references.
1:eac0369: 	  */
1:eac0369: 	public static void copyRefColumns(ExecRow to, int toStart, ExecRow from,
1:eac0369: 									  int fromStart, int count) throws StandardException {
1:eac0369: 		for (int i = 1; i <= count; i++)
1:eac0369: 		{
1:eac0369: 			// Uhhh, why doesn't this to an ArrayCopy????
1:eac0369: 			to.setColumn(i+toStart, from.getColumn(i+fromStart));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Copy references for an ExecRow's columns to another ExecRow.
1:eac0369: 
1:eac0369: 	  @param to Place the column references here.
1:eac0369: 	  @param from Get the column references from here.
1:eac0369: 	  @param positions	array of 1-based column ids to copy from "from" to "to"
1:eac0369: 	  */
1:eac0369: 	public static void copyRefColumns(ExecRow to, ExecRow from, int[] positions)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if ( positions == null ) { return; }
1:eac0369: 
1:eac0369: 		int		count = positions.length;
1:eac0369: 		for (int ix = 0; ix < count; ix++)
1:eac0369: 		{ to.setColumn( ix + 1, from.getColumn( positions[ix] ) ); }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Copy references for an ExecRow's columns to another ExecRow.
1:eac0369: 	  For copying from a compact array to a reconstituted array.
1:eac0369: 	  E.g. if positions = {2, 4}, and from = {666, 777} then
1:dbed020: 	  to =&gt; {null, 666, null, 777}.  Will only go as far as to.getArray().length.
1:eac0369: 
1:eac0369: 	  @param to Place the column references here.  Sparse array
1:eac0369: 	  @param from Get the column references from here. Compact array
1:eac0369: 	  @param positions	array of 1-based column ids to copy from "from" to "to"
1:eac0369: 	  */
1:eac0369: 	public static void copyRefColumns(ExecRow to, ExecRow from, FormatableBitSet positions)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (positions == null) 
1:eac0369: 		{ 
1:eac0369: 			return; 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int	max = to.getRowArray().length;
1:eac0369: 		int toCount = 1;
1:eac0369: 		int fromCount = 1;
1:eac0369: 		for (;toCount <= max; toCount++)
1:eac0369: 		{
1:eac0369: 			if (positions.get(toCount))
1:eac0369: 			{
1:eac0369: 				to.setColumn(toCount, from.getColumn(fromCount)); 
1:eac0369: 				fromCount++;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Empty columns -- i.e. make them refer to a java null.
1:eac0369: 
1:eac0369: 	  <P>This is useful to remove dangling references to a column.
1:eac0369: 
1:eac0369: 	  @param setMe Set columns in this storable to be empty.
1:eac0369: 	  */
1:eac0369: 	public static void copyRefColumns(ExecRow setMe)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		for (int ix = 1; ix <= setMe.nColumns(); ix++)
1:eac0369: 		{
1:eac0369: 			setMe.setColumn(ix,null);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * toString
1:eac0369: 	 *
1:eac0369: 	 * @param row 			the row
1:eac0369: 	 *
1:eac0369: 	 * @return the string
1:eac0369: 	 */
1:eac0369: 	public static String toString(ExecRow row)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return (row == null) ? "null" : toString(row.getRowArray());
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	/**
1:eac0369: 	 * toString
1:eac0369: 	 *
1:eac0369: 	 * @param objs 			the row array
1:eac0369: 	 *
1:eac0369: 	 * @return the string
1:eac0369: 	 */
1:eac0369: 	public static String toString(Object[] objs)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			StringBuffer strbuf = new StringBuffer();
1:eac0369: 
1:eac0369: 			if (objs == null) 
1:eac0369: 				return "null";
1:eac0369: 
1:eac0369: 			strbuf.append("(");
1:eac0369: 			for (int i = 0; i < objs.length; i++)
1:eac0369: 			{
1:eac0369: 				if (i > 0)
1:eac0369: 				{
1:eac0369: 					strbuf.append(",");
1:eac0369: 				}
1:eac0369: 				strbuf.append(objs[i]);
1:eac0369: 			}
1:eac0369: 			strbuf.append(")");
1:eac0369: 			return strbuf.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * toString
1:eac0369: 	 * 
1:eac0369: 	 * @param row 			the row
1:eac0369: 	 * @param startPoint 	0 based start point in row array, inclusive
1:eac0369: 	 * @param endPoint		0 based end point in row array, inclusive
1:eac0369: 	 * 
1:eac0369: 	 * @return the string
1:eac0369: 	 */
1:eac0369: 	public static String toString(ExecRow row, int startPoint, int endPoint)
1:eac0369: 	{
1:eac0369: 		return toString(row.getRowArray(), startPoint, endPoint);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * toString
1:eac0369: 	 * 
1:eac0369: 	 * @param objs 			the row array
1:eac0369: 	 * @param startPoint 	0 based start point in row array, inclusive
1:eac0369: 	 * @param endPoint		0 based end point in row array, inclusive
1:eac0369: 	 * 
1:eac0369: 	 * @return the string
1:eac0369: 	 */
1:eac0369: 	public static String toString(Object[] objs, int startPoint, int endPoint)
1:eac0369: 	{
1:eac0369: 		StringBuffer strbuf = new StringBuffer();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (endPoint >= objs.length)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("endPoint "+endPoint+" is too high,"+
1:eac0369: 					" array only has "+objs.length+" elements");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		strbuf.append("(");
1:eac0369: 		for (int i = startPoint; i <= endPoint; i++)
1:eac0369: 		{
1:eac0369: 			if (i > 0)
1:eac0369: 			{
1:eac0369: 				strbuf.append(",");
1:eac0369: 			}
1:eac0369: 			strbuf.append(objs[i]);
1:eac0369: 		}
1:eac0369: 		strbuf.append(")");
1:eac0369: 		return strbuf.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * toString
1:eac0369: 	 * 
1:eac0369: 	 * @param row 			the row
1:eac0369: 	 * @param positions 	1 based array of positions
1:eac0369: 	 * 
1:eac0369: 	 * @return the string
1:eac0369: 	 */
1:eac0369: 	public static String toString(ExecRow row, int[] positions)
1:eac0369: 	{
1:eac0369: 		return toString(row.getRowArray(), positions);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * toString
1:eac0369: 	 * 
1:eac0369: 	 * @param objs 			the row array
1:eac0369: 	 * @param positions 	1 based array of positions
1:eac0369: 	 * 
1:eac0369: 	 * @return the string
1:eac0369: 	 */
1:eac0369: 	public static String toString(Object[] objs, int[] positions)
1:eac0369: 	{
1:eac0369: 		if (positions == null)
1:eac0369: 		{
1:eac0369: 			return (String) null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		StringBuffer strbuf = new StringBuffer();
1:eac0369: 
1:eac0369: 		strbuf.append("(");
1:eac0369: 		for (int i = 0; i < positions.length; i++)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			if (i > 0)
1:eac0369: 			{
1:eac0369: 				strbuf.append(",");
1:eac0369: 			}
1:eac0369: 			strbuf.append(objs[positions[i] - 1]);
1:eac0369: 		}
1:eac0369: 		strbuf.append(")");
1:eac0369: 		return strbuf.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * intArrayToString
1:eac0369: 	 *
1:6b50965: 	 * @param colMap 			the int array
1:eac0369: 	 *
1:eac0369: 	 * @return the string
1:eac0369: 	 */
1:eac0369: 	public static String intArrayToString(int[] colMap)
1:eac0369: 	{
1:eac0369: 		StringBuffer strbuf = new StringBuffer();
1:eac0369: 
1:eac0369: 		strbuf.append("(");
1:eac0369: 		for (int i = 0; i < colMap.length; i++)
1:eac0369: 		{
1:eac0369: 			if (i > 0)
1:eac0369: 			{
1:eac0369: 				strbuf.append(",");
1:eac0369: 			}
1:eac0369: 			strbuf.append(colMap[i]);
1:eac0369: 		}
1:eac0369: 		strbuf.append(")");
1:eac0369: 		return strbuf.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static boolean inAscendingOrder(int[] colMap)
1:eac0369: 	{
1:eac0369: 		if (colMap != null)
1:eac0369: 		{
1:eac0369: 			int lastCol = -1;
1:eac0369: 			for (int i = 0; i < colMap.length; i++)
1:eac0369: 			{
1:eac0369: 				if (lastCol > colMap[i])
1:eac0369: 				{	
1:eac0369: 					return false;
1:eac0369: 				}
1:eac0369: 				lastCol = colMap[i];
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return true;
1:eac0369: 	}	
1:eac0369: 	/**
1:eac0369: 	 * Shift a FormatableBitSet N bits toward the zero end.
1:dbed020: 	 * e.g. shift({2,4}) -&gt; {1,3}.
1:eac0369: 	 *
1:eac0369: 	 * @param bitSet the bit set
1:eac0369: 	 * @param n	the number of bits to shift
1:eac0369: 	 *
1:eac0369: 	 * @return a new FormatableBitSet with the shifted result
1:eac0369: 	 */
1:eac0369: 	public static FormatableBitSet shift(FormatableBitSet bitSet, int n)
1:eac0369: 	{
1:eac0369: 		FormatableBitSet out = null;
1:eac0369: 		if (bitSet != null)
1:eac0369: 		{
1:eac0369: 			int size = bitSet.size();
1:eac0369:  			out = new FormatableBitSet(size);
1:eac0369: 			for (int i = n; i < size; i++)
1:eac0369: 			{
1:eac0369: 				if (bitSet.get(i))
1:eac0369: 				{
1:eac0369: 					out.set(i-n);
1:eac0369: 				}
1:eac0369: 			}	
1:eac0369: 		}
1:eac0369: 		return out;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	  to =&gt; {null, 666, null, 777}.  Will only go as far as to.getArray().length.
/////////////////////////////////////////////////////////////////////////
1: 	 * e.g. shift({2,4}) -&gt; {1,3}.
commit:2e87a4c
/////////////////////////////////////////////////////////////////////////
1:     private  static  long    rowCountBase = 0L;
1: 
1:     /**
1:      * Debug method used to test the setLargeMaxRows() method added by JDBC 4.2.
1:      * This method is a NOP on a production (insane) build of Derby.
1:      */
1:     public  static  void    setRowCountBase( long newBase )
1:     {
1:         if (SanityManager.DEBUG)    { rowCountBase = newBase; }
1:     }
1: 
1:     /** Retrieve the row count base */
1:     public  static  long    getRowCountBase() { return rowCountBase; }
commit:f26c60c
/////////////////////////////////////////////////////////////////////////
1:     /** Row count base added for testing JDBC 4.2 */
0:     public  static  long    rowCountBase = 0L;
commit:9495437
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1641c38
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ceb12d3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
/////////////////////////////////////////////////////////////////////////
1: 	public static ExecIndexRow getEmptyIndexRow(int columnCount, LanguageConnectionContext lcc)
1: 		return lcc.getLanguageConnectionFactory().
1:             getExecutionFactory().getIndexableRow(columnCount);
commit:6c000e8
/////////////////////////////////////////////////////////////////////////
1: 		return lcc.getLanguageConnectionFactory().getExecutionFactory().getValueRow(columnCount);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.RowUtil
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1:  
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.util.Vector;
1: 
1: /**
1:   Utility class manipulating rows.
1: 
1:   <P>Note: this class is public so it may be used by Replication execution
1:   code. It is basically not public.
1:   */
1: public class RowUtil
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1:  	/**
1: 	  Get an empty ExecRow.
1: 
1: 	  @param columnCount the number of columns in the row.
1: 	  @return the row.
1: 	  */
1: 	public static ExecRow getEmptyValueRow(int columnCount, LanguageConnectionContext lcc)
1: 	{
0: 		ExecutionContext	ec;
1: 
0: 		ec = lcc.getExecutionContext();
0: 		return ec.getExecutionFactory().getValueRow(columnCount);
1: 	}
1: 
1:  	/**
1: 	  Get an empty ExecIndexRow.
1: 
1: 	  @param columnCount the number of columns in the row.
0: 	  @param cm			 Current ContextManager
1: 	  @return the row.
1: 	  */
0: 	public static ExecIndexRow getEmptyIndexRow(int columnCount, ContextManager cm)
1: 	{
0: 		ExecutionContext	ec;
1: 
0: 		ec = (ExecutionContext)
0: 				cm.getContext(ExecutionContext.CONTEXT_ID);
0: 		return ec.getExecutionFactory().getIndexableRow(columnCount);
1: 	}
1: 
1: 	/**
1: 	  Clone an ExecRow's columns and place the coloned columns in another
1: 	  ExecRow.
1: 
1: 	  @param to Place the cloned columns here.
1: 	  @param from Get the columns to clone here.
1: 	  @param count Clone this number of columns.
1: 	  */
1: 	public static void copyCloneColumns(ExecRow to, ExecRow from, int count)
1: 	{
1: 		for (int ix = 1; ix <= count; ix++)
1: 		{
1: 			to.setColumn(ix,from.cloneColumn(ix));
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Copy references for an ExecRow's columns to another ExecRow.
1: 
1: 	  @param to Place the column references here.
1: 	  @param from Get the column references from here.
1: 	  */
1: 	public static void copyRefColumns(ExecRow to, ExecRow from)
1: 	{
1: 		Object[] src = from.getRowArray();
1: 		Object[] dst = to.getRowArray();
1: 		System.arraycopy(src, 0, dst, 0, src.length);
1: 	}
1: 
1: 	/**
1: 	  Copy references for an ExecRow's columns to another ExecRow.
1: 
1: 	  @param to Place the column references here.
1: 	  @param from Get the column references from here.
1: 	  @param count Copy this number of column references.
1: 	  */
1: 	public static void copyRefColumns(ExecRow to, ExecRow from, int count)
1: 		throws StandardException
1: 	{
1: 		copyRefColumns(to, 0, from, 0, count);
1: 	}
1: 
1: 	/**
1: 	  Copy references for an ExecRow's columns to another ExecRow.
1: 
1: 	  @param to Place the column references here.
1: 	  @param from Get the column references from here.
1: 	  @param start The 0 based index of the first column to copy. 
1: 	  @param count Copy this number of column references.
1: 	  */
1: 	public static void copyRefColumns(ExecRow to, ExecRow from,
1: 									  int start, int count)
1: 									  throws StandardException
1: 	{
1: 		copyRefColumns(to, 0, from, start, count);
1: 	}
1: 
1: 	/**
1: 	  Copy references for an ExecRow's columns to another ExecRow.
1: 	  @param to Place the column references here.
1: 	  @param toStart The 0-based index of the first column to replace.
1: 	  @param from Get the column references from here.
1: 	  @param fromStart The 0 based index of the first column to copy. 
1: 	  @param count Copy this number of column references.
1: 	  */
1: 	public static void copyRefColumns(ExecRow to, int toStart, ExecRow from,
1: 									  int fromStart, int count) throws StandardException {
1: 		for (int i = 1; i <= count; i++)
1: 		{
1: 			// Uhhh, why doesn't this to an ArrayCopy????
1: 			to.setColumn(i+toStart, from.getColumn(i+fromStart));
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Copy references for an ExecRow's columns to another ExecRow.
1: 
1: 	  @param to Place the column references here.
1: 	  @param from Get the column references from here.
1: 	  @param positions	array of 1-based column ids to copy from "from" to "to"
1: 	  */
1: 	public static void copyRefColumns(ExecRow to, ExecRow from, int[] positions)
1: 		throws StandardException
1: 	{
1: 		if ( positions == null ) { return; }
1: 
1: 		int		count = positions.length;
1: 		for (int ix = 0; ix < count; ix++)
1: 		{ to.setColumn( ix + 1, from.getColumn( positions[ix] ) ); }
1: 	}
1: 
1: 	/**
1: 	  Copy references for an ExecRow's columns to another ExecRow.
1: 	  For copying from a compact array to a reconstituted array.
1: 	  E.g. if positions = {2, 4}, and from = {666, 777} then
0: 	  to => {null, 666, null, 777}.  Will only go as far as to.getArray().length.
1: 
1: 	  @param to Place the column references here.  Sparse array
1: 	  @param from Get the column references from here. Compact array
1: 	  @param positions	array of 1-based column ids to copy from "from" to "to"
1: 	  */
1: 	public static void copyRefColumns(ExecRow to, ExecRow from, FormatableBitSet positions)
1: 		throws StandardException
1: 	{
1: 		if (positions == null) 
1: 		{ 
1: 			return; 
1: 		}
1: 
1: 		int	max = to.getRowArray().length;
1: 		int toCount = 1;
1: 		int fromCount = 1;
1: 		for (;toCount <= max; toCount++)
1: 		{
1: 			if (positions.get(toCount))
1: 			{
1: 				to.setColumn(toCount, from.getColumn(fromCount)); 
1: 				fromCount++;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Empty columns -- i.e. make them refer to a java null.
1: 
1: 	  <P>This is useful to remove dangling references to a column.
1: 
1: 	  @param setMe Set columns in this storable to be empty.
0: 	  @param count Number of columns to empty.
1: 	  */
1: 	public static void copyRefColumns(ExecRow setMe)
1: 		throws StandardException
1: 	{
1: 		for (int ix = 1; ix <= setMe.nColumns(); ix++)
1: 		{
1: 			setMe.setColumn(ix,null);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * toString
1: 	 *
1: 	 * @param row 			the row
1: 	 *
1: 	 * @return the string
1: 	 */
1: 	public static String toString(ExecRow row)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return (row == null) ? "null" : toString(row.getRowArray());
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 		
1: 	/**
1: 	 * toString
1: 	 *
1: 	 * @param objs 			the row array
1: 	 *
1: 	 * @return the string
1: 	 */
1: 	public static String toString(Object[] objs)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			StringBuffer strbuf = new StringBuffer();
1: 
1: 			if (objs == null) 
1: 				return "null";
1: 
1: 			strbuf.append("(");
1: 			for (int i = 0; i < objs.length; i++)
1: 			{
1: 				if (i > 0)
1: 				{
1: 					strbuf.append(",");
1: 				}
1: 				strbuf.append(objs[i]);
1: 			}
1: 			strbuf.append(")");
1: 			return strbuf.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * toString
1: 	 * 
1: 	 * @param row 			the row
1: 	 * @param startPoint 	0 based start point in row array, inclusive
1: 	 * @param endPoint		0 based end point in row array, inclusive
1: 	 * 
1: 	 * @return the string
1: 	 */
1: 	public static String toString(ExecRow row, int startPoint, int endPoint)
1: 	{
1: 		return toString(row.getRowArray(), startPoint, endPoint);
1: 	}
1: 
1: 	/**
1: 	 * toString
1: 	 * 
1: 	 * @param objs 			the row array
1: 	 * @param startPoint 	0 based start point in row array, inclusive
1: 	 * @param endPoint		0 based end point in row array, inclusive
1: 	 * 
1: 	 * @return the string
1: 	 */
1: 	public static String toString(Object[] objs, int startPoint, int endPoint)
1: 	{
1: 		StringBuffer strbuf = new StringBuffer();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (endPoint >= objs.length)
1: 			{
1: 				SanityManager.THROWASSERT("endPoint "+endPoint+" is too high,"+
1: 					" array only has "+objs.length+" elements");
1: 			}
1: 		}
1: 		strbuf.append("(");
1: 		for (int i = startPoint; i <= endPoint; i++)
1: 		{
1: 			if (i > 0)
1: 			{
1: 				strbuf.append(",");
1: 			}
1: 			strbuf.append(objs[i]);
1: 		}
1: 		strbuf.append(")");
1: 		return strbuf.toString();
1: 	}
1: 
1: 
1: 	/**
1: 	 * toString
1: 	 * 
1: 	 * @param row 			the row
1: 	 * @param positions 	1 based array of positions
1: 	 * 
1: 	 * @return the string
1: 	 */
1: 	public static String toString(ExecRow row, int[] positions)
1: 	{
1: 		return toString(row.getRowArray(), positions);
1: 	}
1: 
1: 	/**
1: 	 * toString
1: 	 * 
1: 	 * @param objs 			the row array
1: 	 * @param positions 	1 based array of positions
1: 	 * 
1: 	 * @return the string
1: 	 */
1: 	public static String toString(Object[] objs, int[] positions)
1: 	{
1: 		if (positions == null)
1: 		{
1: 			return (String) null;
1: 		}
1: 
1: 		StringBuffer strbuf = new StringBuffer();
1: 
1: 		strbuf.append("(");
1: 		for (int i = 0; i < positions.length; i++)
1: 		{
1: 
1: 			if (i > 0)
1: 			{
1: 				strbuf.append(",");
1: 			}
1: 			strbuf.append(objs[positions[i] - 1]);
1: 		}
1: 		strbuf.append(")");
1: 		return strbuf.toString();
1: 	}
1: 
1: 	/**
1: 	 * intArrayToString
1: 	 *
0: 	 * @param objs 			the int array
1: 	 *
1: 	 * @return the string
1: 	 */
1: 	public static String intArrayToString(int[] colMap)
1: 	{
1: 		StringBuffer strbuf = new StringBuffer();
1: 
1: 		strbuf.append("(");
1: 		for (int i = 0; i < colMap.length; i++)
1: 		{
1: 			if (i > 0)
1: 			{
1: 				strbuf.append(",");
1: 			}
1: 			strbuf.append(colMap[i]);
1: 		}
1: 		strbuf.append(")");
1: 		return strbuf.toString();
1: 	}
1: 
1: 	public static boolean inAscendingOrder(int[] colMap)
1: 	{
1: 		if (colMap != null)
1: 		{
1: 			int lastCol = -1;
1: 			for (int i = 0; i < colMap.length; i++)
1: 			{
1: 				if (lastCol > colMap[i])
1: 				{	
1: 					return false;
1: 				}
1: 				lastCol = colMap[i];
1: 			}
1: 		}
1: 		return true;
1: 	}	
1: 	/**
1: 	 * Shift a FormatableBitSet N bits toward the zero end.
0: 	 * e.g. shift({2,4}) -> {1,3}.
1: 	 *
1: 	 * @param bitSet the bit set
1: 	 * @param n	the number of bits to shift
1: 	 *
1: 	 * @return a new FormatableBitSet with the shifted result
1: 	 */
1: 	public static FormatableBitSet shift(FormatableBitSet bitSet, int n)
1: 	{
1: 		FormatableBitSet out = null;
1: 		if (bitSet != null)
1: 		{
1: 			int size = bitSet.size();
1:  			out = new FormatableBitSet(size);
1: 			for (int i = n; i < size; i++)
1: 			{
1: 				if (bitSet.get(i))
1: 				{
1: 					out.set(i-n);
1: 				}
1: 			}	
1: 		}
1: 		return out;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param colMap 			the int array
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0:  
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.util.Vector;
0: 
0: /**
0:   Utility class manipulating rows.
0: 
0:   <P>Note: this class is public so it may be used by Replication execution
0:   code. It is basically not public.
0:   */
0: public class RowUtil
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0:  	/**
0: 	  Get an empty ExecRow.
0: 
0: 	  @param columnCount the number of columns in the row.
0: 	  @return the row.
0: 	  */
0: 	public static ExecRow getEmptyValueRow(int columnCount, LanguageConnectionContext lcc)
0: 	{
0: 		ExecutionContext	ec;
0: 
0: 		ec = lcc.getExecutionContext();
0: 		return ec.getExecutionFactory().getValueRow(columnCount);
0: 	}
0: 
0:  	/**
0: 	  Get an empty ExecIndexRow.
0: 
0: 	  @param columnCount the number of columns in the row.
0: 	  @param cm			 Current ContextManager
0: 	  @return the row.
0: 	  */
0: 	public static ExecIndexRow getEmptyIndexRow(int columnCount, ContextManager cm)
0: 	{
0: 		ExecutionContext	ec;
0: 
0: 		ec = (ExecutionContext)
0: 				cm.getContext(ExecutionContext.CONTEXT_ID);
0: 		return ec.getExecutionFactory().getIndexableRow(columnCount);
0: 	}
0: 
0: 	/**
0: 	  Clone an ExecRow's columns and place the coloned columns in another
0: 	  ExecRow.
0: 
0: 	  @param to Place the cloned columns here.
0: 	  @param from Get the columns to clone here.
0: 	  @param count Clone this number of columns.
0: 	  */
0: 	public static void copyCloneColumns(ExecRow to, ExecRow from, int count)
0: 	{
0: 		for (int ix = 1; ix <= count; ix++)
0: 		{
0: 			to.setColumn(ix,from.cloneColumn(ix));
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Copy references for an ExecRow's columns to another ExecRow.
0: 
0: 	  @param to Place the column references here.
0: 	  @param from Get the column references from here.
0: 	  */
0: 	public static void copyRefColumns(ExecRow to, ExecRow from)
0: 	{
0: 		Object[] src = from.getRowArray();
0: 		Object[] dst = to.getRowArray();
0: 		System.arraycopy(src, 0, dst, 0, src.length);
0: 	}
0: 
0: 	/**
0: 	  Copy references for an ExecRow's columns to another ExecRow.
0: 
0: 	  @param to Place the column references here.
0: 	  @param from Get the column references from here.
0: 	  @param count Copy this number of column references.
0: 	  */
0: 	public static void copyRefColumns(ExecRow to, ExecRow from, int count)
0: 		throws StandardException
0: 	{
0: 		copyRefColumns(to, 0, from, 0, count);
0: 	}
0: 
0: 	/**
0: 	  Copy references for an ExecRow's columns to another ExecRow.
0: 
0: 	  @param to Place the column references here.
0: 	  @param from Get the column references from here.
0: 	  @param start The 0 based index of the first column to copy. 
0: 	  @param count Copy this number of column references.
0: 	  */
0: 	public static void copyRefColumns(ExecRow to, ExecRow from,
0: 									  int start, int count)
0: 									  throws StandardException
0: 	{
0: 		copyRefColumns(to, 0, from, start, count);
0: 	}
0: 
0: 	/**
0: 	  Copy references for an ExecRow's columns to another ExecRow.
0: 	  @param to Place the column references here.
0: 	  @param toStart The 0-based index of the first column to replace.
0: 	  @param from Get the column references from here.
0: 	  @param fromStart The 0 based index of the first column to copy. 
0: 	  @param count Copy this number of column references.
0: 	  */
0: 	public static void copyRefColumns(ExecRow to, int toStart, ExecRow from,
0: 									  int fromStart, int count) throws StandardException {
0: 		for (int i = 1; i <= count; i++)
0: 		{
0: 			// Uhhh, why doesn't this to an ArrayCopy????
0: 			to.setColumn(i+toStart, from.getColumn(i+fromStart));
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Copy references for an ExecRow's columns to another ExecRow.
0: 
0: 	  @param to Place the column references here.
0: 	  @param from Get the column references from here.
0: 	  @param positions	array of 1-based column ids to copy from "from" to "to"
0: 	  */
0: 	public static void copyRefColumns(ExecRow to, ExecRow from, int[] positions)
0: 		throws StandardException
0: 	{
0: 		if ( positions == null ) { return; }
0: 
0: 		int		count = positions.length;
0: 		for (int ix = 0; ix < count; ix++)
0: 		{ to.setColumn( ix + 1, from.getColumn( positions[ix] ) ); }
0: 	}
0: 
0: 	/**
0: 	  Copy references for an ExecRow's columns to another ExecRow.
0: 	  For copying from a compact array to a reconstituted array.
0: 	  E.g. if positions = {2, 4}, and from = {666, 777} then
0: 	  to => {null, 666, null, 777}.  Will only go as far as to.getArray().length.
0: 
0: 	  @param to Place the column references here.  Sparse array
0: 	  @param from Get the column references from here. Compact array
0: 	  @param positions	array of 1-based column ids to copy from "from" to "to"
0: 	  */
0: 	public static void copyRefColumns(ExecRow to, ExecRow from, FormatableBitSet positions)
0: 		throws StandardException
0: 	{
0: 		if (positions == null) 
0: 		{ 
0: 			return; 
0: 		}
0: 
0: 		int	max = to.getRowArray().length;
0: 		int toCount = 1;
0: 		int fromCount = 1;
0: 		for (;toCount <= max; toCount++)
0: 		{
0: 			if (positions.get(toCount))
0: 			{
0: 				to.setColumn(toCount, from.getColumn(fromCount)); 
0: 				fromCount++;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Empty columns -- i.e. make them refer to a java null.
0: 
0: 	  <P>This is useful to remove dangling references to a column.
0: 
0: 	  @param setMe Set columns in this storable to be empty.
0: 	  @param count Number of columns to empty.
0: 	  */
0: 	public static void copyRefColumns(ExecRow setMe)
0: 		throws StandardException
0: 	{
0: 		for (int ix = 1; ix <= setMe.nColumns(); ix++)
0: 		{
0: 			setMe.setColumn(ix,null);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * toString
0: 	 *
0: 	 * @param row 			the row
0: 	 *
0: 	 * @return the string
0: 	 */
0: 	public static String toString(ExecRow row)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return (row == null) ? "null" : toString(row.getRowArray());
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 		
0: 	/**
0: 	 * toString
0: 	 *
0: 	 * @param objs 			the row array
0: 	 *
0: 	 * @return the string
0: 	 */
0: 	public static String toString(Object[] objs)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			StringBuffer strbuf = new StringBuffer();
0: 
0: 			if (objs == null) 
0: 				return "null";
0: 
0: 			strbuf.append("(");
0: 			for (int i = 0; i < objs.length; i++)
0: 			{
0: 				if (i > 0)
0: 				{
0: 					strbuf.append(",");
0: 				}
0: 				strbuf.append(objs[i]);
0: 			}
0: 			strbuf.append(")");
0: 			return strbuf.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * toString
0: 	 * 
0: 	 * @param row 			the row
0: 	 * @param startPoint 	0 based start point in row array, inclusive
0: 	 * @param endPoint		0 based end point in row array, inclusive
0: 	 * 
0: 	 * @return the string
0: 	 */
0: 	public static String toString(ExecRow row, int startPoint, int endPoint)
0: 	{
0: 		return toString(row.getRowArray(), startPoint, endPoint);
0: 	}
0: 
0: 	/**
0: 	 * toString
0: 	 * 
0: 	 * @param objs 			the row array
0: 	 * @param startPoint 	0 based start point in row array, inclusive
0: 	 * @param endPoint		0 based end point in row array, inclusive
0: 	 * 
0: 	 * @return the string
0: 	 */
0: 	public static String toString(Object[] objs, int startPoint, int endPoint)
0: 	{
0: 		StringBuffer strbuf = new StringBuffer();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (endPoint >= objs.length)
0: 			{
0: 				SanityManager.THROWASSERT("endPoint "+endPoint+" is too high,"+
0: 					" array only has "+objs.length+" elements");
0: 			}
0: 		}
0: 		strbuf.append("(");
0: 		for (int i = startPoint; i <= endPoint; i++)
0: 		{
0: 			if (i > 0)
0: 			{
0: 				strbuf.append(",");
0: 			}
0: 			strbuf.append(objs[i]);
0: 		}
0: 		strbuf.append(")");
0: 		return strbuf.toString();
0: 	}
0: 
0: 
0: 	/**
0: 	 * toString
0: 	 * 
0: 	 * @param row 			the row
0: 	 * @param positions 	1 based array of positions
0: 	 * 
0: 	 * @return the string
0: 	 */
0: 	public static String toString(ExecRow row, int[] positions)
0: 	{
0: 		return toString(row.getRowArray(), positions);
0: 	}
0: 
0: 	/**
0: 	 * toString
0: 	 * 
0: 	 * @param objs 			the row array
0: 	 * @param positions 	1 based array of positions
0: 	 * 
0: 	 * @return the string
0: 	 */
0: 	public static String toString(Object[] objs, int[] positions)
0: 	{
0: 		if (positions == null)
0: 		{
0: 			return (String) null;
0: 		}
0: 
0: 		StringBuffer strbuf = new StringBuffer();
0: 
0: 		strbuf.append("(");
0: 		for (int i = 0; i < positions.length; i++)
0: 		{
0: 
0: 			if (i > 0)
0: 			{
0: 				strbuf.append(",");
0: 			}
0: 			strbuf.append(objs[positions[i] - 1]);
0: 		}
0: 		strbuf.append(")");
0: 		return strbuf.toString();
0: 	}
0: 
0: 	/**
0: 	 * intArrayToString
0: 	 *
0: 	 * @param objs 			the int array
0: 	 *
0: 	 * @return the string
0: 	 */
0: 	public static String intArrayToString(int[] colMap)
0: 	{
0: 		StringBuffer strbuf = new StringBuffer();
0: 
0: 		strbuf.append("(");
0: 		for (int i = 0; i < colMap.length; i++)
0: 		{
0: 			if (i > 0)
0: 			{
0: 				strbuf.append(",");
0: 			}
0: 			strbuf.append(colMap[i]);
0: 		}
0: 		strbuf.append(")");
0: 		return strbuf.toString();
0: 	}
0: 
0: 	public static boolean inAscendingOrder(int[] colMap)
0: 	{
0: 		if (colMap != null)
0: 		{
0: 			int lastCol = -1;
0: 			for (int i = 0; i < colMap.length; i++)
0: 			{
0: 				if (lastCol > colMap[i])
0: 				{	
0: 					return false;
0: 				}
0: 				lastCol = colMap[i];
0: 			}
0: 		}
0: 		return true;
0: 	}	
0: 	/**
0: 	 * Shift a FormatableBitSet N bits toward the zero end.
0: 	 * e.g. shift({2,4}) -> {1,3}.
0: 	 *
0: 	 * @param bitSet the bit set
0: 	 * @param n	the number of bits to shift
0: 	 *
0: 	 * @return a new FormatableBitSet with the shifted result
0: 	 */
0: 	public static FormatableBitSet shift(FormatableBitSet bitSet, int n)
0: 	{
0: 		FormatableBitSet out = null;
0: 		if (bitSet != null)
0: 		{
0: 			int size = bitSet.size();
0:  			out = new FormatableBitSet(size);
0: 			for (int i = n; i < size; i++)
0: 			{
0: 				if (bitSet.get(i))
0: 				{
0: 					out.set(i-n);
0: 				}
0: 			}	
0: 		}
0: 		return out;
0: 	}
0: }
============================================================================