1:c7fdf72: /*
1:c7fdf72:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.AutoGenJDBC30Test
1:c7fdf72:    Licensed to the Apache Software Foundation (ASF) under one
1:c7fdf72:    or more contributor license agreements.  See the NOTICE file
1:c7fdf72:    distributed with this work for additional information
1:c7fdf72:    regarding copyright ownership.  The ASF licenses this file
1:c7fdf72:    to you under the Apache License, Version 2.0 (the
1:c7fdf72:    "License"); you may not use this file except in compliance
1:c7fdf72:    with the License.  You may obtain a copy of the License at
24:c7fdf72:   
1:c7fdf72:      http://www.apache.org/licenses/LICENSE-2.0
1:c7fdf72:   
1:c7fdf72:    Unless required by applicable law or agreed to in writing,
1:c7fdf72:    software distributed under the License is distributed on an
1:c7fdf72:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:c7fdf72:    KIND, either express or implied.  See the License for the
1:c7fdf72:    specific language governing permissions and limitations
1:c7fdf72:    under the License.
10:c7fdf72:  */
1:c7fdf72: 
1:c7fdf72: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:c7fdf72: 
1:c7fdf72: import java.sql.Connection;
1:c7fdf72: import java.sql.DriverManager;
1:c7fdf72: import java.sql.PreparedStatement;
1:c7fdf72: import java.sql.ResultSet;
1:c7fdf72: import java.sql.ResultSetMetaData;
1:1ae02c9: import java.sql.SQLException;
1:c7fdf72: import java.sql.Savepoint;
1:c7fdf72: import java.sql.Statement;
1:1ae02c9: import junit.framework.Test;
1:c7fdf72: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:c7fdf72: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:c7fdf72: import org.apache.derbyTesting.junit.JDBC;
1:c7fdf72: import org.apache.derbyTesting.junit.TestConfiguration;
1:c7fdf72: 
3:c7fdf72: /**
1:c7fdf72:  * Tests the JDBC 3.0 ability to establish a result set of auto-generated keys.
1:c7fdf72:  * <p>
1:c7fdf72:  * Converts the old jdbcapi/autoGeneratedJdbc30.java test to JUnit.
1:c7fdf72:  * The old harness test number is preserved in the comment for each fixture.
1:c7fdf72:  */
1:c7fdf72: public class AutoGenJDBC30Test extends BaseJDBCTestCase {
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Routines that should be created before the tests are run.
1:c7fdf72:      */
1:c7fdf72:     private static final String[] ROUTINES = {
1:c7fdf72:         // Used by testInsertNoAutoGenExecuteSQLfunc
1:c7fdf72:         "CREATE FUNCTION MMWNI() RETURNS VARCHAR(20) " +
1:c7fdf72:         "READS SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:c7fdf72:         AutoGenJDBC30Test.class.getName() + ".MyMethodWithNoInsert'",
1:c7fdf72: 
1:c7fdf72:         // Used by testInsertAutoGenExecuteSQLfunc
1:c7fdf72:         "CREATE FUNCTION AddMe(P1 INT) RETURNS INT " +
1:c7fdf72:         "READS SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:c7fdf72:         AutoGenJDBC30Test.class.getName() + ".addMe'",
1:c7fdf72:     };
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Tables that should be created before the tests are run.
1:c7fdf72:      * The first element in each row is the name of the table and the second 
1:c7fdf72:      * element is the SQL text that creates it.
1:c7fdf72:      */
1:c7fdf72:     private static final String[][] TABLES = {
1:c7fdf72:         
1:c7fdf72:         { "t11_AutoGen", 
1:c7fdf72:           "create table t11_AutoGen (c11 int, " +
1:c7fdf72:           "c12 int generated always as identity (increment by 1))" },
1:c7fdf72: 
1:c7fdf72:         { "t31_AutoGen",
1:c7fdf72:           "create table t31_AutoGen (c31 int, " +
1:c7fdf72:           "c32 int generated always as identity (increment by 1), " +
1:c7fdf72:           "c33 int default 2)" },
1:c7fdf72: 
1:c7fdf72:         { "t21_noAutoGen",
1:c7fdf72:           "create table t21_noAutoGen (c21 int not null unique, c22 char(5))" },
1:8f8881f: 
1:8f8881f:         { "t21_feed_table",
1:8f8881f:           "create table t21_feed_table (c21 int not null unique, c22 char(5))"},
1:c7fdf72:     };
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Creates a new AutoGenJDBC30Test instance.
1:c7fdf72:      *
1:c7fdf72:      * @param name name of the test
1:c7fdf72:      */
1:c7fdf72:     public AutoGenJDBC30Test(String name) {
1:c7fdf72:         super(name);
10:c7fdf72:     }
1:c7fdf72: 
1:e3bd4bb:     /**
1:c7fdf72:      * Implements suite() to run in embedded and client configurations.
1:c7fdf72:      */
1:c7fdf72:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("AutoGenJDBC30Test");
1:c7fdf72: 
1:c7fdf72:         suite.addTest(baseSuite("AutoGenJDBC30Test:embedded"));
1:c7fdf72: 
1:c7fdf72:         suite.addTest(TestConfiguration.clientServerDecorator(
1:c7fdf72:             baseSuite("AutoGenJDBC30Test:client")));
1:c7fdf72:         return suite;
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Tests are only run if JDBC 3.0 available, and database objects get 
1:c7fdf72:      * created only once for the suite run.
1:c7fdf72:      *
1:c7fdf72:      * @param name name of the test
1:c7fdf72:      */
1:c7fdf72:     private static Test baseSuite(String name) {
1:c7fdf72: 
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:c7fdf72: 
1:c7fdf72:         if (!JDBC.vmSupportsJDBC3()) {
1:c7fdf72:             // empty suite
1:c7fdf72:             return suite;
1:c7fdf72:         }
1:c7fdf72: 
1:c7fdf72:         suite.addTestSuite(AutoGenJDBC30Test.class);
1:c7fdf72: 
1:c7fdf72:         // Create database objects only once for entire test run
1:c7fdf72:         return new CleanDatabaseTestSetup(suite) 
5:c7fdf72:         {
1:c7fdf72:             /**
1:c7fdf72:             * Creates the database objects used in the test cases.
3:c7fdf72:             * @throws SQLException 
1:e3bd4bb:             */
1:c7fdf72:             protected void decorateSQL(Statement s) throws SQLException
1:c7fdf72:             {
1:c7fdf72:                 for (int i = 0; i < ROUTINES.length; i++) {
1:c7fdf72:                     s.execute(ROUTINES[i]);
1:e3bd4bb:                 }
1:c7fdf72:                 for (int i = 0; i < TABLES.length; i++) {
1:c7fdf72:                     s.execute(TABLES[i][1]);
1:c7fdf72:                 }
1:c7fdf72:             }
1:c7fdf72:         };
1:c7fdf72:     } // End baseSuite
1:e3bd4bb: 
1:c7fdf72:     /**
1:c7fdf72:      * Sets up the connection for a test case, clears all tables and resets
1:c7fdf72:      * all auto-generated keys used by the test fixtures.
1:c7fdf72:      * @throws SQLException 
1:e3bd4bb:      */
1:c7fdf72:     public void setUp() throws SQLException
1:c7fdf72:     {
3:c7fdf72:         Connection conn = getConnection();
1:c7fdf72:         conn.setAutoCommit(false);
3:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         for (int i = 0; i < TABLES.length; i++) {
1:c7fdf72:             s.execute("DELETE FROM " + TABLES[i][0]);
1:c7fdf72:         }
1:c7fdf72:         s.execute("ALTER TABLE t11_AutoGen ALTER COLUMN c12 RESTART WITH 1");
1:c7fdf72:         s.execute("ALTER TABLE t31_AutoGen ALTER COLUMN c32 RESTART WITH 1");
2:c7fdf72:         s.close();
1:c7fdf72:         conn.commit();
1:c7fdf72:     }
1:e3bd4bb: 
1:c7fdf72:     // TESTS
1:e3bd4bb: 
1:c7fdf72:     /**
1:c7fdf72:      * Requests generated keys for a new statement that hasn't executed any 
1:c7fdf72:      * SQL yet. 
1:c7fdf72:      * Old harness Test 1.
1:c7fdf72:      * Expected result: a NULL ResultSet.
1:c7fdf72:      * @throws SQLException 
1:e3bd4bb:      */
1:c7fdf72:     public void testNoSql() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         assertNull("Expected NULL ResultSet", s.getGeneratedKeys());
1:c7fdf72:         s.close();
1:c7fdf72:     }
1:e3bd4bb: 
1:c7fdf72:     /**
1:c7fdf72:      * Requests generated keys for a Select statement (non-insert).
1:c7fdf72:      * Old harness Test 2.
1:c7fdf72:      * Expected result: a NULL ResultSet.
1:c7fdf72:      * @throws SQLException 
1:e3bd4bb:      */
1:c7fdf72:     public void testSelect() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         String sql="select * from t11_AutoGen";
1:e3bd4bb: 
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
3:c7fdf72:         assertNull("Expected NULL ResultSet after s.execute()", 
5:c7fdf72:             s.getGeneratedKeys());
1:e3bd4bb: 
1:c7fdf72:         s.close();
1:e3bd4bb: 
1:c7fdf72:         PreparedStatement ps = 
1:c7fdf72:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
3:c7fdf72:         ps.execute();
4:c7fdf72:         assertNull("Expected NULL ResultSet after ps.execute()", 
7:c7fdf72:             ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Requests generated keys for a multi-row insert statement.
1:c7fdf72:      * Old harness Test 3.
1:c7fdf72:      * Expected result: ResultSet has one row with a NULL key because it 
1:c7fdf72:      * inserts more than one row and there was no prior one-row insert into 
1:c7fdf72:      * a table with an auto-generated key.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertManyRowsNoPriorKey() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         String sqlStmt="insert into t31_AutoGen(c31) values (99), (98), (97)";
1:c7fdf72:         runInsertFourWaysKeyIsNull (sqlStmt);
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:aa302c3:      * Requests generated keys for a multi-row update statement after a
1:aa302c3:      * one-row update into a table with an auto-generated key.
1:aa302c3:      * Expected result: ResultSet has one row with a non-NULL key for the
1:aa302c3:      * one-row update.
1:aa302c3:      * @throws SQLException 
1:aa302c3:      */
1:aa302c3:     public void testUpdateManyRowsAfterOneRowKey() throws SQLException
1:aa302c3:     {
1:aa302c3:         // Do a one-row insert into a table with an auto-generated key.
1:aa302c3:         Statement s = createStatement();
1:aa302c3:         s.execute("insert into t11_AutoGen(c11) values (99)", Statement.RETURN_GENERATED_KEYS);
1:aa302c3:         int expected=1;
1:aa302c3:         int keyval = getKeyValue (s.getGeneratedKeys());
1:aa302c3:         assertEquals("Key value after s.execute()", expected, keyval);
1:aa302c3:         
1:aa302c3:         // Do a one-row update of a table with an auto-generated key.
1:aa302c3:         s.execute("update t11_AutoGen set c12=default where c11=99", Statement.RETURN_GENERATED_KEYS);
1:aa302c3:         expected=2;
1:aa302c3:         keyval = getKeyValue (s.getGeneratedKeys());
1:aa302c3:         assertEquals("Key value after s.execute()", expected, keyval);
1:aa302c3:     	
1:aa302c3:         String sql="insert into t11_AutoGen(c11) values (99), (98), (97)";
1:aa302c3:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:aa302c3:         keyval = getKeyValue (s.getGeneratedKeys());
1:aa302c3:         assertEquals("Key value after s.execute()", expected, keyval);
1:aa302c3: 
1:aa302c3:         // Do a one-row update of a table with an auto-generated key.
1:aa302c3:         s.execute("update t11_AutoGen set c12=default where c11=97", Statement.RETURN_GENERATED_KEYS);
1:aa302c3:         expected=6;
1:aa302c3:         keyval = getKeyValue (s.getGeneratedKeys());
1:aa302c3:         assertEquals("Key value after s.execute()", expected, keyval);
1:aa302c3:         
1:aa302c3:         // Do a multi-row update of a table with an auto-generated key.
1:aa302c3:         s.execute("update t11_AutoGen set c12=default where c11=99", Statement.RETURN_GENERATED_KEYS);
1:aa302c3:         keyval = getKeyValue (s.getGeneratedKeys());
1:aa302c3:         assertEquals("Key value after s.execute()", expected, keyval);
1:aa302c3:     }
1:aa302c3: 
1:aa302c3:     /**
1:c7fdf72:      * Requests generated keys for a multi-row insert statement after a
1:c7fdf72:      * one-row insert into a table with an auto-generated key.
1:c7fdf72:      * Old harness Test 7.
1:c7fdf72:      * Expected result: ResultSet has one row with a non-NULL key for the
1:c7fdf72:      * one-row insert.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertManyRowsAfterOneRowKey() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         // Do a one-row insert into a table with an auto-generated key.
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute("insert into t11_AutoGen(c11) values (99)");
1:c7fdf72: 
1:c7fdf72:         /* Although the insert into t31_AutoGen below inserts into a table 
1:c7fdf72:          * with an auto-generated column, it won't increment the key from 1 
1:c7fdf72:          * to 2 because it's a multi-row insert.  Instead, the key it fetches
1:c7fdf72:          * will be for the previous insert into t11_AutoGen.
1:c7fdf72:          */
1:c7fdf72:         int expected=1;
1:c7fdf72:         String sql="insert into t31_AutoGen(c31) values (99), (98), (97)";
1:c7fdf72: 
1:c7fdf72:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         int keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.execute()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.executeUpdate()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = 
1:c7fdf72:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.execute()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
3:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.executeUpdate()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Requests generated keys after doing an insert into a table that doesn't
1:c7fdf72:      * have a generated column (and there hasn't been a one row insert into 
1:c7fdf72:      * a table with auto-generated keys yet).
1:c7fdf72:      * Old harness Test 4.
1:c7fdf72:      * Expected result: ResultSet has one row with a NULL key.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertNoAutoGen() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         // The original test inserted 21 and 22.
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(21, 'true')");
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(22, 'true')");
1:c7fdf72: 
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(23, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         verifyNullKey("s.execute()", s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate("insert into t21_noAutoGen values(24, 'true')",
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         verifyNullKey("s.executeUpdate()", s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = prepareStatement(
1:c7fdf72:             "insert into t21_noAutoGen values(25, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:c7fdf72:         verifyNullKey("PreparedStatement.execute()", ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement("insert into t21_noAutoGen values(26, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         verifyNullKey("ps.executeUpdate()", ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:8f8881f:      * <p>
1:8f8881f:      * Regression test for DERBY-5823 where the temporary row holder code
1:8f8881f:      * failed when switching from an in-memory to an on-disk representation.
1:8f8881f:      * </p>
1:8f8881f:      *
1:8f8881f:      * <p>
1:8f8881f:      * Note that ideally the transition should never have happened in the first
1:8f8881f:      * place, so this test verifies that either the transition logic can deal
1:8f8881f:      * with the degenerate case where the row template is zero-length, or the
1:8f8881f:      * insert code is smart enough to understand that there are no
1:8f8881f:      * auto-generated keys for the query.
1:8f8881f:      * </p>
1:8f8881f:      */
1:8f8881f:     public void testDerby5823() throws SQLException {
1:8f8881f:         setAutoCommit(false);
1:8f8881f:         PreparedStatement ps = prepareStatement(
1:8f8881f:                 "insert into t21_feed_table values (?,?)");
1:8f8881f:         ps.setString(2, "false");
1:8f8881f:         // Just make sure we exceed the threshold for when the temporary row
1:8f8881f:         // holder overflows to disk (implementation detail).
1:8f8881f:         // When this test was written the threshold was five (5).
1:8f8881f:         for (int i=0; i < 250; i++) {
1:8f8881f:             ps.setInt(1, i);
1:8f8881f:             ps.executeUpdate();
1:8f8881f:         }
1:8f8881f:         commit();
1:8f8881f:         setAutoCommit(true);
1:8f8881f:         final String insertSql =
1:8f8881f:                 "insert into t21_noAutoGen select * from t21_feed_table";
1:8f8881f:         // No keys will be auto-generated by the insert query.
1:8f8881f:         Statement s = createStatement();
1:8f8881f:         s.execute(insertSql,
1:8f8881f:                 Statement.RETURN_GENERATED_KEYS
1:8f8881f:                 );
1:8f8881f:         verifyNullKey("s.execute()", s.getGeneratedKeys());
1:8f8881f:         // For good measure we also test with a prepared statement.
1:8f8881f:         s.execute("delete from t21_noAutoGen");
1:8f8881f:         // Again, no keys will be auto-generated by the insert query.
1:8f8881f:         ps = prepareStatement(insertSql, Statement.RETURN_GENERATED_KEYS);
1:8f8881f:         ps.executeUpdate();
1:8f8881f:         verifyNullKey("ps.executeUpdate()", ps.getGeneratedKeys());
1:8f8881f:     }
1:8f8881f: 
1:8f8881f:     /**
1:c7fdf72:      * Requests generated keys after doing a one-row insert into a table that 
1:c7fdf72:      * has a generated column, but the insert is via a subquery with no where
1:c7fdf72:      * clause.
1:c7fdf72:      * Old harness Test 5a.
1:c7fdf72:      * Expected result: ResultSet has one row with a NULL key.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertSubqueryNoWhereClause() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         // Setup
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(21, 'true')");
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         String sql="insert into t11_AutoGen(c11) select c21 from t21_noAutoGen";
1:c7fdf72:         runInsertFourWaysKeyIsNull (sql);
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Requests generated keys after doing a one-row insert into a table 
1:c7fdf72:      * that has a generated column, but the insert is via a subquery with
1:c7fdf72:      * a "where 1=2" clause.
1:c7fdf72:      * Old harness Test 5B.
1:c7fdf72:      * Expected result: ResultSet has one row with a NULL key.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertSubqueryWhere1is2() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         // Setup
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(21, 'true')");
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         String sql = 
1:c7fdf72:             "insert into t11_AutoGen(c11) select c21 from t21_noAutoGen " +
1:c7fdf72:             "where 1=2";
1:c7fdf72:         runInsertFourWaysKeyIsNull (sql);
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Requests generated keys after doing a one-row insert into a table 
1:c7fdf72:      * that has a generated column, but the insert is via a subquery with
1:c7fdf72:      * a "where c21=23" clause.
1:c7fdf72:      * Old harness Test 5c.
1:c7fdf72:      * Expected result: ResultSet with one row with a NULL key.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertSubqueryWhereClause() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         // Setup
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute("insert into t21_noAutoGen(c21,c22) values(23, 'true')");
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         String sql=
1:c7fdf72:             "insert into t11_AutoGen(c11) select c21 from t21_noAutoGen " +
1:c7fdf72:             "where c21=23";
1:c7fdf72:         runInsertFourWaysKeyIsNull (sql);
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Requests generated keys after doing a one-row insert into a table 
1:c7fdf72:      * that has an auto-generated column.
1:c7fdf72:      * Old harness Test 6.
1:c7fdf72:      * Expected result: ResultSet has one row with a non-NULL key.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertOneRowKey() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         String sql="insert into t11_AutoGen(c11) values (99)";
1:c7fdf72: 
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72: 
1:c7fdf72:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         int keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.execute()", 1, keyval);
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.executeUpdate()", 2, keyval);
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = 
1:c7fdf72:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.execute()", 3, keyval);
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.executeUpdate()", 4, keyval);
1:fafbff8: 
1:c7fdf72:         ps.close();
1:c7fdf72:         
1:fafbff8:         /*
1:fafbff8:         DERBY-3249 - Returned generated key result sets have the wrong
1:fafbff8:         concurrency. Test should be expanded to handle all concurrencies/types.
1:fafbff8:         
1:fafbff8:         // Test the type of the Statement object does not affect the
1:fafbff8:         // type of the generated key ResultSet (checked in getKeyValue)
1:fafbff8:         s = this.createStatement(ResultSet.CONCUR_UPDATABLE, ResultSet.TYPE_SCROLL_INSENSITIVE);
1:fafbff8:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:fafbff8:         keyval = getKeyValue(s.getGeneratedKeys());
1:fafbff8:         assertEquals("Key value after s.execute()", 5, keyval);
1:fafbff8:         */
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * After a one-row insert into a table with an auto-generated key, next
1:c7fdf72:      * inserts into a table that does not have an auto-generated key, then
1:c7fdf72:      * requests generated keys.
1:c7fdf72:      * Old harness Test 8.
1:c7fdf72:      * Expected result: ResultSet has one row with a non-NULL key. All four
1:c7fdf72:      * queries in this test return the same result because they fetch the
1:c7fdf72:      * key generated for the previous insert, not the current one.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertNoGenColAfterOneRowKey() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         // Do a one-row insert into a table with an auto-generated key.
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute("insert into t11_AutoGen(c11) values (99)");
1:c7fdf72: 
1:c7fdf72:         /* The insert into t21_noAutoGen below doesn't insert into a table 
1:c7fdf72:          * with an auto-generated column, so it won't increment the key from 
1:c7fdf72:          * 1 to 2.  The key it fetches will be for the previous insert into 
1:c7fdf72:          * t11_AutoGen.
1:c7fdf72:          */
1:c7fdf72:         int expected=1;
1:c7fdf72: 
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(27, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         int keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.execute()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate("insert into t21_noAutoGen values(28, 'true')",
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.executeUpdate()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = prepareStatement(
1:c7fdf72:             "insert into t21_noAutoGen values(29, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.execute()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement("insert into t21_noAutoGen values(30, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.executeUpdate()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Requests generated keys for an UPDATE statement.
1:c7fdf72:      * Old harness Test 9.
1:c7fdf72:      * Expected result: a NULL ResultSet.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:aa302c3:     public void testUpdateOneRowKey() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute("insert into t11_AutoGen(c11) values(999)");
1:c7fdf72: 
1:aa302c3:         String sqlStmt="update t11_AutoGen set c12=default where c11=999";
1:c7fdf72:         s.execute(sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:aa302c3:         int keyval = getKeyValue (s.getGeneratedKeys());
1:aa302c3:         assertEquals("Key value after s.execute()", 2, keyval);
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate(sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:aa302c3:         keyval = getKeyValue (s.getGeneratedKeys());
1:aa302c3:         assertEquals("Key value after s.executeUpdate()", 3, keyval);
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = prepareStatement(
1:c7fdf72:             sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:aa302c3:         keyval = getKeyValue (ps.getGeneratedKeys());
1:aa302c3:         assertEquals("Key value after ps.execute()", 4, keyval);
1:c7fdf72: 
1:aa302c3:         ps = prepareStatement(sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.executeUpdate();
1:aa302c3:         keyval = getKeyValue (ps.getGeneratedKeys());
1:aa302c3:         assertEquals("Key value after ps.executeUpdate()", 5, keyval);
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Requests generated keys for an DELETE statement.
1:c7fdf72:      * Old master Test 10.
1:c7fdf72:      * Expected result: a NULL ResultSet.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testDelete() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute("insert into t11_AutoGen(c11) values(999)");
1:c7fdf72: 
1:c7fdf72:         String sqlStmt="delete from t11_AutoGen";
1:c7fdf72:         s.execute(sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         assertNull("Expected NULL ResultSet after s.execute()",
1:e3bd4bb:             s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate(sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:e3bd4bb:         assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:e3bd4bb:             s.getGeneratedKeys());
1:c7fdf72: 
1:e3bd4bb:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = prepareStatement(
1:c7fdf72:             sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:aadfc18:         ps.execute();
1:aadfc18:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:aadfc18:             ps.getGeneratedKeys());
1:c7fdf72: 
1:aadfc18:         ps.executeUpdate();
1:aadfc18:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:aadfc18:             ps.getGeneratedKeys());
1:aadfc18: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Does a one-row insert into a table with a generated column, commits,
1:c7fdf72:      * then requests generated keys for an insert into a table without a
1:c7fdf72:      * generated column.
1:c7fdf72:      * Old master Test 11.
1:c7fdf72:      * Expected result: ResultSet has one row with a non-NULL key.
1:c7fdf72:      * The original code output this message: "expected to see resultset with 
1:c7fdf72:      * one row of NULL value but instead get one row of non-NULL value from 
1:c7fdf72:      * getGeneratedKeys".
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testGetKeyAfterCommit() throws SQLException
1:aadfc18:     {
1:c7fdf72:         // Setup transaction
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute("insert into t11_AutoGen(c11) values(999)");
1:c7fdf72: 
1:c7fdf72:         Connection conn = getConnection();
1:c7fdf72:         conn.commit();
1:c7fdf72: 
1:c7fdf72:         /* The insert into t21_noAutoGen below doesn't insert into a table 
1:c7fdf72:          * with an auto-generated column, so it won't increment the key from 
1:c7fdf72:          * 1 to 2.  The key it fetches will be for the previous insert into 
1:c7fdf72:          * t11_AutoGen.
1:c7fdf72:          */
1:c7fdf72:         int expected=1;
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(31, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         int keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.execute()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate("insert into t21_noAutoGen values(32, 'true')",
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.executeUpdate()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = prepareStatement(
1:c7fdf72:             "insert into t21_noAutoGen values(33, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.execute()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement("insert into t21_noAutoGen values(34, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.executeUpdate()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Does a one-row insert into a table with a generated column, next does
1:c7fdf72:      * a rollback, then requests generated keys for an insert into a table 
1:c7fdf72:      * without a generated column.
1:c7fdf72:      * Old master Test 12.
1:c7fdf72:      * Expected result: ResultSet has one row with a non-NULL key.
1:c7fdf72:      * The original code output this message: "had expected to see resultset 
1:c7fdf72:      * with one row of NULL value but instead get one row of non-NULL value 
1:c7fdf72:      * from getGeneratedKeys".
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testGetKeyAfterRollback() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Connection conn = getConnection();
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72: 
1:c7fdf72:         s.execute("insert into t11_AutoGen(c11) values(999)");
1:c7fdf72:         conn.rollback();
1:c7fdf72: 
1:c7fdf72:         /* The insert into t21_noAutoGen below doesn't insert into a table 
1:c7fdf72:          * with an auto-generated column, so it won't increment the key from 
1:c7fdf72:          * 1 to 2.  The key it fetches will be for the previous insert into 
1:c7fdf72:          * t11_AutoGen, a value that never changes in this fixture.
1:c7fdf72:          */
1:c7fdf72:         int expected=1;
1:c7fdf72: 
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(35, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         int keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.execute()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate("insert into t21_noAutoGen values(36, 'true')",
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.executeUpdate()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = prepareStatement(
1:c7fdf72:             "insert into t21_noAutoGen values(37, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.execute()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement("insert into t21_noAutoGen values(38, 'true')", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("key value after ps.executeUpdate()", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Inserts one row into a table with an auto-generated column while inside
1:c7fdf72:      * a savepoint unit, does a rollback, then gets keys after an insert
1:c7fdf72:      * into a table without an auto-generated column.
1:c7fdf72:      * Old master Test 13.
1:c7fdf72:      * Expected result: ResultSet has one row with a non-NULL key, and the
1:c7fdf72:      * key value should be the same before and after the rollback.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testGetKeyAfterSavepointRollback() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Connection conn = getConnection();
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         Savepoint savepoint1 = conn.setSavepoint();
1:c7fdf72: 
1:c7fdf72:         int expected=1;
1:c7fdf72: 
1:c7fdf72:         s.execute("insert into t11_AutoGen(c11) values(99)", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         int keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value before rollback", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         conn.rollback(savepoint1);
1:c7fdf72: 
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(39, 'true')",
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after rollback", expected, keyval);
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Inserts one row into a table with an auto-generated column, then 
1:c7fdf72:      * examines the metadata for the generatedKeys ResultSet.
1:c7fdf72:      * Old master Test 14.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testGetKeyMetadataAfterInsert() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72: 
1:c7fdf72:         s.execute("insert into t31_AutoGen(c31) values (99)", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ResultSet rs = s.getGeneratedKeys();
1:c7fdf72:         ResultSetMetaData rsmd = rs.getMetaData();
1:c7fdf72:         assertEquals("ResultSet column count", 1, rsmd.getColumnCount());
1:c7fdf72:         assertEquals("Column type", "DECIMAL", rsmd.getColumnTypeName(1));
1:c7fdf72:         assertEquals("Column precision", 31, rsmd.getPrecision(1));
1:c7fdf72:         assertEquals("Column scale", 0, rsmd.getScale(1));
1:c7fdf72:         int keyval = getKeyValue (rs);
1:c7fdf72:         assertEquals("Key value", 1, keyval);
1:c7fdf72: 
1:c7fdf72:         rs.close();
1:c7fdf72:         s.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Inserts one row into a table with an auto-generated column, but 
1:c7fdf72:      * with NO_GENERATED_KEYS.
1:c7fdf72:      * Old master Test 15.
1:c7fdf72:      * Expected result: NULL ResultSet.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertNoGenKeys() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72: 
1:c7fdf72:         String sql="insert into t31_AutoGen(c31) values (99)";
1:c7fdf72: 
1:c7fdf72:         s.execute(sql, Statement.NO_GENERATED_KEYS);
1:e3bd4bb:         assertNull("Expected NULL ResultSet after s.execute()", 
1:c7fdf72:             s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate(sql, Statement.NO_GENERATED_KEYS);
1:c7fdf72:         assertNull("Expected NULL ResultSet after s.executeUpdate", 
1:c7fdf72:             s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = 
1:c7fdf72:             prepareStatement(sql, Statement.NO_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:e3bd4bb:         assertNull("Expected NULL ResultSet after ps.execute()",
1:e3bd4bb:             ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement(sql, Statement.NO_GENERATED_KEYS);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         assertNull("Expected NULL ResultSet after ps.executeUpdate", 
1:e3bd4bb:             ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Inserts one row into a table with an auto-generated column, but 
1:c7fdf72:      * in the JDBC 2.0 way (with no generated key feature).
1:c7fdf72:      * Old master Test 16.
1:c7fdf72:      * Expected result: NULL ResultSet.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertJDBC20syntax() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72: 
1:c7fdf72:         String sql="insert into t31_AutoGen(c31) values (99)";
1:c7fdf72: 
1:c7fdf72:         s.execute(sql);
1:c7fdf72:         assertNull("Expected NULL ResultSet after s.execute()", 
1:c7fdf72:             s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate(sql);
1:c7fdf72:         assertNull("Expected NULL ResultSet after s.executeUpdate", 
1:c7fdf72:             s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = prepareStatement(sql);
1:c7fdf72:         ps.execute();
1:c7fdf72:         assertNull("Expected NULL ResultSet after ps.execute()",
1:c7fdf72:             ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement(sql);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         assertNull("Expected NULL ResultSet after ps.executeUpdate", 
1:c7fdf72:             ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Updates a row in a table with an auto-generated column and 
1:c7fdf72:      * NO_GENERATED_KEYS, then fetches key.
1:c7fdf72:      * Old master Test 17.
1:c7fdf72:      * Expected result: NULL ResultSet.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testUpdateAutoGenNoGenKeys() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72: 
1:c7fdf72:         // Insert a row for us to update
1:c7fdf72:         s.execute("insert into t31_AutoGen(c31) values (99)");
1:c7fdf72: 
1:c7fdf72:         String sql="update t31_AutoGen set c31=98";
1:c7fdf72: 
1:c7fdf72:         s.execute(sql, Statement.NO_GENERATED_KEYS);
1:c7fdf72:         assertNull("Expected NULL ResultSet after s.execute()", 
1:c7fdf72:             s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate(sql, Statement.NO_GENERATED_KEYS);
1:c7fdf72:         assertNull("Expected NULL ResultSet after s.executeUpdate", 
1:c7fdf72:             s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps=prepareStatement(sql, Statement.NO_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:c7fdf72:         assertNull("Expected NULL ResultSet after ps.execute()",
1:c7fdf72:             ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement(sql, Statement.NO_GENERATED_KEYS);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         assertNull("Expected NULL ResultSet after ps.executeUpdate", 
1:c7fdf72:             ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Deletes rows from a table with an auto-generated column in the JDBC 2.0 
1:c7fdf72:      * way (with no generated key feature), then fetches key.
1:c7fdf72:      * Old master Test 18.
1:c7fdf72:      * Expected result: NULL ResultSet.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testDeleteAutoGenNoGenKeysJDBC20syntax() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72: 
1:c7fdf72:         String sql="delete from t31_AutoGen";
1:c7fdf72: 
1:c7fdf72:         s.execute(sql);
1:c7fdf72:         assertNull("Expected NULL ResultSet after s.execute()", 
1:c7fdf72:             s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate(sql);
1:c7fdf72:         assertNull("Expected NULL ResultSet after s.executeUpdate", 
1:c7fdf72:             s.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps=prepareStatement(sql);
1:c7fdf72:         ps.execute();
1:c7fdf72:         assertNull("Expected NULL ResultSet after ps.execute()",
1:c7fdf72:             ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement(sql);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         assertNull("Expected NULL ResultSet after ps.executeUpdate", 
1:c7fdf72:             ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Inserts a row into a table with a SQL function in the VALUES clause;
1:c7fdf72:      * the table does not have an auto-generated column.
1:c7fdf72:      * Old master Test 19.
1:c7fdf72:      * Expected result: ResultSet has one row. The key value is NULL if 
1:c7fdf72:      * there has been no prior insert into a table with an auto-generated 
1:c7fdf72:      * column; otherwise, the value is not NULL. 
1:c7fdf72:      * The old master referenced an old issue for which this test was added. 
1:c7fdf72:      * getGeneratedKeys() threw an exception if an insert statement included a 
1:c7fdf72:      * SQL routine and set the flag to generate a generatedKeys ResultSet.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertNoAutoGenExecuteSQLfunc() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72: 
1:c7fdf72:         // Insert into a table that does not have an auto-gen column.
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(40, MMWNI())",
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         verifyNullKey("First insert", s.getGeneratedKeys());
1:c7fdf72:         assertTableRowCount("T21_NOAUTOGEN", 1);
1:c7fdf72: 
1:c7fdf72:         // Now insert into a table that has an auto-gen column.
1:c7fdf72:         s.execute("insert into t31_AutoGen(c31) values (99)",
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         int keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after insert into t31_AutoGen", 1, keyval);
1:c7fdf72: 
1:c7fdf72:         // Insert again into the table that does not have an auto-gen column.
1:c7fdf72:         s.execute("insert into t21_noAutoGen values(42, MMWNI())",
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after insert into t21_noAutoGen", 1, keyval);
1:c7fdf72:         assertTableRowCount("T21_NOAUTOGEN", 2);
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Inserts a row into a table with a SQL function in the VALUES clause;
1:c7fdf72:      * the table has an auto-generated column.
1:c7fdf72:      * Old master: no test, but this seemed a natural addition given
1:c7fdf72:      * testInsertNoAutoGenExecuteSQLfunc().
1:c7fdf72:      * Expected result: ResultSet has one row with a non-NULL key value.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testInsertAutoGenExecuteSQLfunc() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         String sql="insert into t31_AutoGen(c31) values (AddMe(1))";
1:c7fdf72: 
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72: 
1:c7fdf72:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         int keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.execute()", 1, keyval);
1:c7fdf72: 
1:c7fdf72:         s.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         keyval = getKeyValue (s.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after s.executeUpdate()", 2, keyval);
1:c7fdf72: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = 
1:c7fdf72:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.execute();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.execute()", 3, keyval);
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         ps.executeUpdate();
1:c7fdf72:         keyval = getKeyValue (ps.getGeneratedKeys());
1:c7fdf72:         assertEquals("Key value after ps.executeUpdate()", 4, keyval);
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Verifies fix for an old issue in which the ResultSet returned by 
1:c7fdf72:      * getGenerateKeys was incorrectly tied to the activation of the 
1:c7fdf72:      * PreparedStatement; so, when the ResultSet was garbage collected, the
1:c7fdf72:      * activation was closed, resulting in an "Activation closed, operation
1:c7fdf72:      * execute not permitted" exception on subsequent executes (warning:
1:c7fdf72:      * this fixture takes a noticeable time to run).
1:c7fdf72:      * Old master Test 20.
1:c7fdf72:      * Expected result: no exceptions should occur.
1:c7fdf72:      * @throws SQLException 
1:c7fdf72:      */
1:c7fdf72:     public void testResultSetGarbageCollection() throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Connection conn = getConnection();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = 
1:c7fdf72:             prepareStatement("insert into t11_AutoGen(c11) values(?)", 
1:c7fdf72:             Statement.RETURN_GENERATED_KEYS);
1:c7fdf72: 
1:c7fdf72:         for (int i = 0; i < 100; i++) 
1:c7fdf72:         {
1:c7fdf72:             ps.setInt(1, 100+i);
1:c7fdf72:             ps.executeUpdate();
1:c7fdf72: 
1:c7fdf72:             ResultSet rs = ps.getGeneratedKeys();
1:c7fdf72:             while (rs.next()) {
1:c7fdf72:                rs.getInt(1);
1:c7fdf72:             }
1:c7fdf72:             rs.close();
1:c7fdf72:             conn.commit();
1:c7fdf72: 
1:c7fdf72:             System.runFinalization();
1:c7fdf72:             System.gc();
1:c7fdf72:             System.runFinalization();
1:c7fdf72:             System.gc();
1:c7fdf72:         }
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:e3bd4bb:      * Test that use of columnIndexes to indicate which keys should be
1:e3bd4bb:      * made available works as expected.
1:e3bd4bb:      *
1:e3bd4bb:      * @throws SQLException 
1:e3bd4bb:      */
1:e3bd4bb:     public void testColumnIndexes() throws SQLException
1:e3bd4bb:     {
1:e3bd4bb: 
1:e3bd4bb:         // Valid (typical) usage.
1:e3bd4bb: 
1:e3bd4bb:         int [] colIndexes = new int [] { 2 };
1:e3bd4bb:         testUserGivenColumns(colIndexes, null, 1);
1:b52081a:         
1:b52081a: 
1:b52081a:         // Mulitple columns. one not an identity column.
1:b52081a:         colIndexes = new int[] {1,2};
1:b52081a:         testUserGivenColumnsError(colIndexes, null);
1:b52081a:         
1:b52081a:         
1:b52081a:         // Derby client can't differentiate between
1:b52081a:         // valid and invalid identity columns. So the
1:b52081a:         // other tests do not apply.  
1:b52081a:         if (usingDerbyNetClient())
1:b52081a:             return;
1:e3bd4bb: 
1:e3bd4bb:         // Non-existent column index.
1:b52081a:         colIndexes = new int[] {100};
2:e3bd4bb:         testUserGivenColumnsError(colIndexes, null);
1:e3bd4bb: 
1:e3bd4bb:         // Valid column index but not an auto-gen column.
1:e3bd4bb: 
1:e3bd4bb:         colIndexes[0] = 1;
1:e3bd4bb:         testUserGivenColumnsError(colIndexes, null);
1:e3bd4bb: 
1:e3bd4bb:         /* If user specifies the same column index multiple times,
1:e3bd4bb:          * things should still work.  We effectively just take the
1:e3bd4bb:          * one and ignore the rest.
1:e3bd4bb:          */
1:e3bd4bb: 
1:e3bd4bb:         colIndexes = new int [] { 2, 2, 2 };
1:e3bd4bb:         testUserGivenColumns(colIndexes, null, 5);
1:e3bd4bb: 
1:e3bd4bb:         // Multiple col indexes, one of which is invalid.
1:e3bd4bb: 
1:e3bd4bb:         colIndexes[1] = 100;
1:e3bd4bb:         testUserGivenColumnsError(colIndexes, null);
1:e3bd4bb: 
1:e3bd4bb: 
1:e3bd4bb:         /* Multiple col indexes, one of which is invalid and another
1:e3bd4bb:          * of which is not an auto-gen column.
1:e3bd4bb:          */
1:e3bd4bb: 
1:e3bd4bb:         colIndexes[2] = 100;
1:e3bd4bb:         testUserGivenColumnsError(colIndexes, null);
1:e3bd4bb: 
1:e3bd4bb:         // Same as previous but with "bad" indexes switched.
1:e3bd4bb: 
1:e3bd4bb:         colIndexes[1] = 100;
1:e3bd4bb:         colIndexes[2] = 1;
1:e3bd4bb:         testUserGivenColumnsError(colIndexes, null);
1:e3bd4bb:     }
1:e3bd4bb: 
1:e3bd4bb:     /**
1:e3bd4bb:      * Test that use of columnNames to indicate which keys should be
1:e3bd4bb:      * made available works as expected.
1:e3bd4bb:      *
1:e3bd4bb:      * @throws SQLException 
1:e3bd4bb:      */
1:e3bd4bb:     public void testColumnNames() throws SQLException
1:e3bd4bb:     {
1:aadfc18:     
1:e3bd4bb:         // Valid (typical) usage.
1:e3bd4bb: 
1:e3bd4bb:         String [] colNames = new String [] { "C12" };
1:e3bd4bb:         testUserGivenColumns(null, colNames, 1);
1:e3bd4bb: 
1:aadfc18:         // column name array is of length > 1
1:aadfc18:         colNames = new String[] {"C12","C13"};
1:aadfc18:         testUserGivenColumnsError(null, colNames);
1:aadfc18:              
1:aadfc18:         if (usingDerbyNetClient())
1:aadfc18:             return;
1:aadfc18:        
1:e3bd4bb:         // Non-existent column name.
1:e3bd4bb: 
1:aadfc18:         colNames= new String[] {"NOTTHERE"};
1:e3bd4bb:         testUserGivenColumnsError(null, colNames);
1:aadfc18:         
1:e3bd4bb:         // Valid column name but not an auto-gen column.
1:e3bd4bb: 
1:e3bd4bb:         colNames[0] = "C11";
1:e3bd4bb:         testUserGivenColumnsError(null, colNames);
1:e3bd4bb: 
1:e3bd4bb:         // "null" column name.
1:e3bd4bb: 
1:e3bd4bb:         colNames[0] = null;
1:e3bd4bb:         testUserGivenColumnsError(null, colNames);
1:e3bd4bb: 
1:e3bd4bb:         /* If user specifies the same column name multiple times,
1:e3bd4bb:          * things should still work.  We effectively just take the
1:e3bd4bb:          * one and ignore the rest.
1:e3bd4bb:          */
1:e3bd4bb: 
1:e3bd4bb:         colNames = new String [] { "C12", "C12", "C12" };
1:e3bd4bb:         testUserGivenColumns(null, colNames, 5);
1:e3bd4bb: 
1:e3bd4bb:         // Multiple col names, one of which is invalid.
1:e3bd4bb: 
1:e3bd4bb:         colNames[1] = "NOTTHERE";
1:e3bd4bb:         testUserGivenColumnsError(null, colNames);
1:e3bd4bb: 
1:e3bd4bb:         // Multiple col names, one of which is not an auto-gen column.
1:e3bd4bb: 
1:e3bd4bb:         colNames[1] = "C11";
1:e3bd4bb:         testUserGivenColumnsError(null, colNames);
1:e3bd4bb: 
1:e3bd4bb:         // Multiple col names, one of which is null.
1:e3bd4bb: 
1:e3bd4bb:         colNames[1] = null;
1:e3bd4bb:         testUserGivenColumnsError(null, colNames);
1:e3bd4bb: 
1:e3bd4bb:         /* Multiple col names, one of which is invalid and another
1:e3bd4bb:          * of which is not an auto-gen column.
1:e3bd4bb:          */
1:e3bd4bb: 
1:e3bd4bb:         colNames[1] = "C11";
1:e3bd4bb:         colNames[2] = "NOTTHERE";
1:e3bd4bb:         testUserGivenColumnsError(null, colNames);
1:e3bd4bb: 
1:e3bd4bb:         // Same as previous but with "bad" names switched.
1:e3bd4bb: 
1:e3bd4bb:         colNames[1] = "NOTTHERE";
1:e3bd4bb:         colNames[2] = "C11";
1:e3bd4bb:         testUserGivenColumnsError(null, colNames);
1:e3bd4bb:     }
1:e3bd4bb: 
1:e3bd4bb:     /**
1:aadfc18:      * Verify that if user specifies an empty array for columNames or columnIndexes,
1:aadfc18:      * it is the same as NO_GENERATED_KEYS
1:aadfc18:      * @throws SQLException
1:aadfc18:      */
1:aadfc18:     public void testUserGivenColumnsEmpty() throws SQLException
1:aadfc18:     {
1:aadfc18:         Statement s = createStatement();
1:aadfc18: 
1:aadfc18:         String sql="insert into t11_AutoGen(c11) values (99)";
1:aadfc18: 
1:aadfc18:   
1:aadfc18:         s.execute(sql, new String[] {});
1:aadfc18:         assertNull("Expected NULL ResultSet after s.execute()", 
1:aadfc18:             s.getGeneratedKeys());
1:aadfc18: 
1:aadfc18:         s.executeUpdate(sql, new String[] {});
1:aadfc18:         assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:aadfc18:             s.getGeneratedKeys());
1:aadfc18: 
1:aadfc18:         PreparedStatement ps = null;
1:a3203bf:         
1:a3203bf:         ps = prepareStatement(sql, new String[] {});
1:a3203bf:         ps.execute();
1:a3203bf:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:a3203bf:         ps.getGeneratedKeys());
1:aadfc18: 
1:a3203bf:         ps = prepareStatement(sql, new String[] {});
1:a3203bf:         ps.executeUpdate();
1:a3203bf:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:a3203bf:                 ps.getGeneratedKeys());       
1:aadfc18:        // No columnIndexes yet for derby client. 
1:aadfc18:        if (usingDerbyNetClient())
1:aadfc18:             return;
1:aadfc18:        
1:aadfc18:        s.execute(sql,  new int[] {});
1:aadfc18:        assertNull("Expected NULL ResultSet after s.execute()", 
1:aadfc18:            s.getGeneratedKeys());
1:aadfc18: 
1:aadfc18:        s.executeUpdate(sql, new int[] {});
1:aadfc18:        assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:aadfc18:            s.getGeneratedKeys());
1:aadfc18: 
2:aadfc18:        if (!usingEmbedded())
1:aadfc18:        {
2:aadfc18:            // Can't run these with embedded now because of DERBY-3430
1:aadfc18:            ps = prepareStatement(sql, new int[] {});
1:aadfc18:            ps.execute();
1:aadfc18:            assertNull("Expected NULL ResultSet after ps.execute()", 
1:aadfc18:                    ps.getGeneratedKeys());
1:aadfc18: 
1:aadfc18:            ps = prepareStatement(sql, new int[] {});
1:aadfc18:            ps.executeUpdate();
1:aadfc18:            assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:aadfc18:                    ps.getGeneratedKeys());
1:aadfc18: 
1:aadfc18:        }
1:aadfc18:        
1:aadfc18:     
1:aadfc18:         
1:aadfc18:     }
1:aadfc18:     
1:aadfc18:     /**
1:e3bd4bb:      * Verify that if a user specifies a *NULL* column index or column
1:e3bd4bb:      * name array to indicate which keys should be made available, Derby will
1:e3bd4bb:      * effectively disable autogenerated keys (i.e. same as if user passed
1:e3bd4bb:      * NO_GENERATED_KEYS).
1:e3bd4bb:      *
1:e3bd4bb:      * Expected result: a NULL result set.
1:e3bd4bb:      * @throws SQLException 
1:e3bd4bb:      */
1:e3bd4bb:     public void testUserGivenColumnsNull() throws SQLException
1:e3bd4bb:     {
1:aadfc18:         
1:e3bd4bb:         Statement s = createStatement();
1:aadfc18: 
1:e3bd4bb:         String sql="insert into t11_AutoGen(c11) values (99)";
1:e3bd4bb: 
1:e3bd4bb:   
1:e3bd4bb:         s.execute(sql, (String[]) null);
1:e3bd4bb:         assertNull("Expected NULL ResultSet after s.execute()", 
1:e3bd4bb:             s.getGeneratedKeys());
1:e3bd4bb: 
1:e3bd4bb:         s.executeUpdate(sql, (String[]) null);
1:e3bd4bb:         assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:e3bd4bb:             s.getGeneratedKeys());
1:e3bd4bb: 
1:e3bd4bb: 
1:aadfc18:         PreparedStatement ps;
1:aadfc18:         ps = prepareStatement(sql, (String[]) null);
1:aadfc18:         ps.execute();
1:aadfc18:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:aadfc18:             ps.getGeneratedKeys());
1:aadfc18: 
1:aadfc18:         ps = prepareStatement(sql, (String[]) null);
1:aadfc18:         ps.executeUpdate();
1:aadfc18:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:aadfc18:             ps.getGeneratedKeys());
1:aadfc18:         
1:aadfc18:        // No columnIndexes yet for derby client. 
1:aadfc18:        if (usingDerbyNetClient())
1:aadfc18:             return;
1:aadfc18:        
1:aadfc18:        s.execute(sql, (int[]) null);
1:aadfc18:        assertNull("Expected NULL ResultSet after s.execute()", 
1:aadfc18:            s.getGeneratedKeys());
1:aadfc18: 
1:aadfc18:        s.executeUpdate(sql, (int[]) null);
1:aadfc18:        assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:aadfc18:            s.getGeneratedKeys());
1:aadfc18: 
1:aadfc18:        ps = prepareStatement(sql, (int[]) null);
1:e3bd4bb:         ps.execute();
1:e3bd4bb:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:e3bd4bb:             ps.getGeneratedKeys());
1:e3bd4bb: 
1:e3bd4bb:         ps = prepareStatement(sql, (int[]) null);
1:e3bd4bb:         ps.executeUpdate();
2:e3bd4bb:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:e3bd4bb:             ps.getGeneratedKeys());
1:e3bd4bb: 
1:e3bd4bb: 
1:e3bd4bb:         ps.close();
1:e3bd4bb:         
1:aadfc18:     }
1:e3bd4bb: 
1:c7fdf72:     // Local utility methods.
1:e3bd4bb: 
1:c7fdf72:     /**
1:e3bd4bb:      * Verify that if user specifies *valid* column indexes or column
1:e3bd4bb:      * names to indicate which keys should be made available, Derby will
1:e3bd4bb:      * return the correct results.
1:e3bd4bb:      *
1:e3bd4bb:      * Expected result: one row with a non-NULL key.
1:e3bd4bb:      *
1:e3bd4bb:      * @param colIndexes Array of column indexes indicating which keys
1:e3bd4bb:      *  should be made available.  Must be null if colNames is non-null.
1:e3bd4bb:      * @param colNames Array of column names indicating which keys should
1:e3bd4bb:      *  be made available.  Must be null if colIndexes is non-null.
1:e3bd4bb:      * @param expectedVal First expected autogenerated key; will be
1:e3bd4bb:      *  incremented for each successful INSERT statement.
1:e3bd4bb:      *
1:e3bd4bb:      * @throws SQLException
1:e3bd4bb:      */
1:e3bd4bb:     private void testUserGivenColumns(int [] colIndexes, String [] colNames,
1:e3bd4bb:         int expectedVal) throws SQLException
1:e3bd4bb:     {
1:e3bd4bb:         assertTrue("Exactly one of colIndexes or colNames should be null",
1:e3bd4bb:             ((colIndexes != null) ^ (colNames != null)));
1:e3bd4bb: 
1:e3bd4bb:         boolean useIndexes = (colIndexes != null);
1:e3bd4bb:         Statement s = createStatement();
1:e3bd4bb: 
1:e3bd4bb:         String sql="insert into t11_AutoGen(c11) values (99)";
1:e3bd4bb: 
1:e3bd4bb:         if (useIndexes)
1:e3bd4bb:             s.execute(sql, colIndexes);
1:e3bd4bb:         else
1:e3bd4bb:             s.execute(sql, colNames);
1:e3bd4bb: 
1:e3bd4bb:         int keyval = getKeyValue (s.getGeneratedKeys());
1:e3bd4bb:         assertEquals("Key value after s.execute()", expectedVal++, keyval);
1:e3bd4bb: 
1:e3bd4bb:         if (useIndexes)
1:e3bd4bb:             s.executeUpdate(sql, colIndexes);
1:e3bd4bb:         else
1:e3bd4bb:             s.executeUpdate(sql, colNames);
1:e3bd4bb: 
1:e3bd4bb:         keyval = getKeyValue (s.getGeneratedKeys());
1:e3bd4bb:         assertEquals("Key value after s.executeUpdate()",
1:e3bd4bb:             expectedVal++, keyval);
1:e3bd4bb: 
1:e3bd4bb:         s.close();
1:e3bd4bb: 
1:e3bd4bb:         PreparedStatement ps = null;
1:e3bd4bb:         if (useIndexes)
1:e3bd4bb:             ps = prepareStatement(sql, colIndexes);
1:e3bd4bb:         else
1:e3bd4bb:             ps = prepareStatement(sql, colNames);
1:e3bd4bb: 
1:e3bd4bb:         ps.execute();
1:e3bd4bb:         keyval = getKeyValue (ps.getGeneratedKeys());
1:e3bd4bb:         assertEquals("Key value after ps.execute()", expectedVal++, keyval);
1:e3bd4bb: 
1:e3bd4bb:         if (useIndexes)
1:e3bd4bb:             ps = prepareStatement(sql, colIndexes);
1:e3bd4bb:         else
1:e3bd4bb:             ps = prepareStatement(sql, colNames);
1:e3bd4bb: 
1:e3bd4bb:         ps.executeUpdate();
1:e3bd4bb:         keyval = getKeyValue (ps.getGeneratedKeys());
1:e3bd4bb:         assertEquals("Key value after ps.executeUpdate()",
1:e3bd4bb:             expectedVal++, keyval);
1:e3bd4bb: 
1:e3bd4bb:         ps.close();
1:e3bd4bb:     }
1:e3bd4bb: 
1:e3bd4bb:     /**
1:e3bd4bb:      * Verify that if user specifies *INvalid* column indexes or column
1:e3bd4bb:      * names to indicate which keys should be made available, Derby will
1:e3bd4bb:      * throw an appropriate error.
1:e3bd4bb:      *
1:e3bd4bb:      * Expected result: Execution-time error: X0X0E or X0X0F.
1:e3bd4bb:      *
1:e3bd4bb:      * @param colIndexes Array of column indexes indicating which keys
1:e3bd4bb:      *  should be made available.  Must be null if colNames is non-null.
1:e3bd4bb:      * @param colNames Array of column names indicating which keys should
1:e3bd4bb:      *  be made available.  Must be null if colIndexes is non-null.
1:e3bd4bb:      *
1:e3bd4bb:      * @throws SQLException 
1:e3bd4bb:      */
1:e3bd4bb:     private void testUserGivenColumnsError(int [] colIndexes,
1:e3bd4bb:         String [] colNames) throws SQLException
1:e3bd4bb:     {
1:e3bd4bb:         assertTrue("Exactly one of colIndexes or colNames should be null.",
1:e3bd4bb:             ((colIndexes != null) ^ (colNames != null)));
1:e3bd4bb: 
1:e3bd4bb:         boolean useIndexes = (colIndexes != null);
1:e3bd4bb:         String expectedSQLState = (useIndexes ? "X0X0E" : "X0X0F");
1:aadfc18:         // Derby client will only give an error if colNames array is not of length 1.
1:aadfc18:         if (usingDerbyNetClient() && colNames != null && 
1:aadfc18:                 colNames.length != 1)
1:aadfc18:             expectedSQLState = "X0X0D";
1:aadfc18:         
1:e3bd4bb:         Statement s = createStatement();
1:e3bd4bb:         String sql="insert into t11_AutoGen(c11) values (99)";
1:e3bd4bb: 
1:e3bd4bb:         try {
1:e3bd4bb: 
1:e3bd4bb:             if (useIndexes)
1:e3bd4bb:                 s.execute(sql, colIndexes);
1:e3bd4bb:             else
1:e3bd4bb:                 s.execute(sql, colNames);
1:e3bd4bb: 
1:e3bd4bb:             fail("Expected s.execute() to fail, but it did not.");
1:e3bd4bb: 
1:e3bd4bb:         } catch (SQLException se) {
1:e3bd4bb:             assertSQLState(expectedSQLState, se.getSQLState(), se);
1:e3bd4bb:         }
1:e3bd4bb: 
1:e3bd4bb:         try {
1:e3bd4bb: 
1:e3bd4bb:             if (useIndexes)
1:e3bd4bb:                 s.executeUpdate(sql, colIndexes);
1:e3bd4bb:             else
1:e3bd4bb:                 s.executeUpdate(sql, colNames);
1:e3bd4bb: 
1:e3bd4bb:             fail("Expected s.executeUpdate() to fail, but it did not.");
1:e3bd4bb: 
1:e3bd4bb:         } catch (SQLException se) {
1:e3bd4bb:             assertSQLState(expectedSQLState, se.getSQLState(), se);
1:e3bd4bb:         }
1:e3bd4bb: 
1:e3bd4bb:         s.close();
1:e3bd4bb: 
1:e3bd4bb:         PreparedStatement ps = null;
1:e3bd4bb:         if (useIndexes)
1:e3bd4bb:                ps = prepareStatement(sql, colIndexes);
1:e3bd4bb:         else
1:e3bd4bb:                ps = prepareStatement(sql, colNames);
1:e3bd4bb: 
1:e3bd4bb:         try {
1:e3bd4bb:             ps.execute();
1:e3bd4bb:             fail("Expected ps.execute() to fail, but it did not.");
1:e3bd4bb:         } catch (SQLException se) {
1:e3bd4bb:             assertSQLState(expectedSQLState, se.getSQLState(), se);
1:e3bd4bb:         }
1:e3bd4bb: 
1:e3bd4bb:         try {
1:e3bd4bb:             ps.executeUpdate();
1:e3bd4bb:             fail("Expected ps.executeUpdate() to fail, but it did not.");
1:e3bd4bb:         } catch (SQLException se) {
1:e3bd4bb:             assertSQLState(expectedSQLState, se.getSQLState(), se);
1:e3bd4bb:         }
1:e3bd4bb: 
1:e3bd4bb:         ps.close();
1:e3bd4bb:     }
1:e3bd4bb: 
1:e3bd4bb:     /**
1:c7fdf72:      * Runs the same SQL INSERT statement four ways: 
1:c7fdf72:      *   Statement.execute, 
1:c7fdf72:      *   Statement.executeUpdate, 
1:c7fdf72:      *   PreparedStatement.execute, and 
1:c7fdf72:      *   PreparedStatement.executeUpdate,
1:c7fdf72:      * and expects the resulting key value to be NULL. 
1:c7fdf72:      *
1:c7fdf72:      * @param sql The SQL statement to be executed
1:c7fdf72:      * @exception SQLException if a database error occurs
1:e3bd4bb:      */
1:c7fdf72:     public void runInsertFourWaysKeyIsNull (String sql)
1:c7fdf72:         throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Statement s = createStatement();
1:c7fdf72:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         verifyNullKey("After s.execute()", s.getGeneratedKeys());
1:e3bd4bb: 
1:c7fdf72:         s.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
1:c7fdf72:         verifyNullKey("After s.executeUpdate()", s.getGeneratedKeys());
1:e3bd4bb: 
1:c7fdf72:         s.close();
1:c7fdf72: 
1:c7fdf72:         PreparedStatement ps = 
1:c7fdf72:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:e3bd4bb:         ps.execute();
1:c7fdf72:         verifyNullKey("After ps.execute()", ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps = prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:e3bd4bb:         ps.executeUpdate();
1:c7fdf72:         verifyNullKey("ps.executeUpdate()", ps.getGeneratedKeys());
1:c7fdf72: 
1:c7fdf72:         ps.close();
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Verifies that the generated key in a result set is null.
1:c7fdf72:      *
1:c7fdf72:      * @param description Text to be output for the assertion
1:c7fdf72:      * @param r ResultSet
1:c7fdf72:      * @exception SQLException if a database error occurs
1:c7fdf72:      */
1:c7fdf72:     public void verifyNullKey (String description, ResultSet r) 
1:c7fdf72:         throws SQLException
1:c7fdf72:     {
1:fafbff8:         JDBC.assertGeneratedKeyResultSet(description, r);
1:fafbff8: 
1:c7fdf72:         int i = 0;
1:c7fdf72:         while(r.next())
1:c7fdf72:         {
1:c7fdf72:             assertNull(description, r.getString(1));
1:c7fdf72:             i++;
1:c7fdf72:         }
1:c7fdf72:         assertEquals(description, 1, i);
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /**
1:c7fdf72:      * Gets the key value from the result set.
1:c7fdf72:      *
1:c7fdf72:      * @param r ResultSet
1:c7fdf72:      * @exception SQLException if a database error occurs
1:c7fdf72:      */
1:c7fdf72:     public int getKeyValue (ResultSet r) throws SQLException
1:aa302c3:     {if(r==null) System.out.println("it is null");
1:fafbff8:         JDBC.assertGeneratedKeyResultSet("AutoGenJDBC30Test.getKeyValue", r);
1:fafbff8:         
1:c7fdf72:         int i = 0;
1:c7fdf72:         int retval = 0;
1:c7fdf72:         while(r.next())
1:c7fdf72:         {
1:c7fdf72:             assertNotNull("Key value is NULL", r.getString(1));
1:c7fdf72:             retval = r.getInt(1);
1:c7fdf72:             i++;
1:c7fdf72:         }
1:c7fdf72:         assertEquals("ResultSet rows", 1, i);
1:c7fdf72:         return retval;
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     // SQL ROUTINES (functions and procedures)
1:c7fdf72: 
1:c7fdf72:     /** 
1:c7fdf72:      * External code for the  MMWNI() SQL function, which is called by
1:c7fdf72:      * the testInsertNoAutoGenExecuteSQLfunc fixture.
1:c7fdf72:      * @exception SQLException if a database error occurs
1:c7fdf72:      */
1:c7fdf72: 
1:c7fdf72:     public static String MyMethodWithNoInsert() throws SQLException 
1:c7fdf72:     {
1:c7fdf72:         Connection conn = 
1:c7fdf72:             DriverManager.getConnection("jdbc:default:connection");
1:c7fdf72:         Statement s = conn.createStatement();
1:c7fdf72:         s.executeQuery("select * from t11_AutoGen");
1:c7fdf72:         s.close();
1:c7fdf72:         conn.close();
1:c7fdf72:         return "true";
1:c7fdf72:     }
1:c7fdf72: 
1:c7fdf72:     /** 
1:c7fdf72:      * External code for the AddMe SQL function, which is called by
1:c7fdf72:      * the testInsertAutoGenExecuteSQLfunc fixture.
1:c7fdf72:      * @param p1 integer input argument to be used in calculation
1:c7fdf72:      * @exception SQLException if a database error occurs
1:c7fdf72:      */
1:c7fdf72:     public static int addMe (int p1) throws SQLException
1:c7fdf72:     {
1:c7fdf72:         Connection conn = 
1:c7fdf72:             DriverManager.getConnection("jdbc:default:connection");
1:c7fdf72:         Statement s = conn.createStatement();
1:c7fdf72:         s.executeQuery("select * from t11_AutoGen");
1:c7fdf72:         s.close();
1:c7fdf72:         conn.close();
1:c7fdf72:         return (p1 + p1);
1:c7fdf72:     }
1:c7fdf72: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:aa302c3
/////////////////////////////////////////////////////////////////////////
1:      * Requests generated keys for a multi-row update statement after a
1:      * one-row update into a table with an auto-generated key.
1:      * Expected result: ResultSet has one row with a non-NULL key for the
1:      * one-row update.
1:      * @throws SQLException 
1:      */
1:     public void testUpdateManyRowsAfterOneRowKey() throws SQLException
1:     {
1:         // Do a one-row insert into a table with an auto-generated key.
1:         Statement s = createStatement();
1:         s.execute("insert into t11_AutoGen(c11) values (99)", Statement.RETURN_GENERATED_KEYS);
1:         int expected=1;
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expected, keyval);
1:         
1:         // Do a one-row update of a table with an auto-generated key.
1:         s.execute("update t11_AutoGen set c12=default where c11=99", Statement.RETURN_GENERATED_KEYS);
1:         expected=2;
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expected, keyval);
1:     	
1:         String sql="insert into t11_AutoGen(c11) values (99), (98), (97)";
1:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expected, keyval);
1: 
1:         // Do a one-row update of a table with an auto-generated key.
1:         s.execute("update t11_AutoGen set c12=default where c11=97", Statement.RETURN_GENERATED_KEYS);
1:         expected=6;
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expected, keyval);
1:         
1:         // Do a multi-row update of a table with an auto-generated key.
1:         s.execute("update t11_AutoGen set c12=default where c11=99", Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expected, keyval);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     public void testUpdateOneRowKey() throws SQLException
1:         String sqlStmt="update t11_AutoGen set c12=default where c11=999";
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", 2, keyval);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.executeUpdate()", 3, keyval);
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.execute()", 4, keyval);
1:         ps = prepareStatement(sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.executeUpdate()", 5, keyval);
/////////////////////////////////////////////////////////////////////////
1:     {if(r==null) System.out.println("it is null");
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("AutoGenJDBC30Test");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8f8881f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         { "t21_feed_table",
1:           "create table t21_feed_table (c21 int not null unique, c22 char(5))"},
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Regression test for DERBY-5823 where the temporary row holder code
1:      * failed when switching from an in-memory to an on-disk representation.
1:      * </p>
1:      *
1:      * <p>
1:      * Note that ideally the transition should never have happened in the first
1:      * place, so this test verifies that either the transition logic can deal
1:      * with the degenerate case where the row template is zero-length, or the
1:      * insert code is smart enough to understand that there are no
1:      * auto-generated keys for the query.
1:      * </p>
1:      */
1:     public void testDerby5823() throws SQLException {
1:         setAutoCommit(false);
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into t21_feed_table values (?,?)");
1:         ps.setString(2, "false");
1:         // Just make sure we exceed the threshold for when the temporary row
1:         // holder overflows to disk (implementation detail).
1:         // When this test was written the threshold was five (5).
1:         for (int i=0; i < 250; i++) {
1:             ps.setInt(1, i);
1:             ps.executeUpdate();
1:         }
1:         commit();
1:         setAutoCommit(true);
1:         final String insertSql =
1:                 "insert into t21_noAutoGen select * from t21_feed_table";
1:         // No keys will be auto-generated by the insert query.
1:         Statement s = createStatement();
1:         s.execute(insertSql,
1:                 Statement.RETURN_GENERATED_KEYS
1:                 );
1:         verifyNullKey("s.execute()", s.getGeneratedKeys());
1:         // For good measure we also test with a prepared statement.
1:         s.execute("delete from t21_noAutoGen");
1:         // Again, no keys will be auto-generated by the insert query.
1:         ps = prepareStatement(insertSql, Statement.RETURN_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         verifyNullKey("ps.executeUpdate()", ps.getGeneratedKeys());
1:     }
1: 
1:     /**
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:a3203bf
/////////////////////////////////////////////////////////////////////////
1:         
1:         ps = prepareStatement(sql, new String[] {});
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:         ps.getGeneratedKeys());
1:         ps = prepareStatement(sql, new String[] {});
1:         ps.executeUpdate();
1:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:                 ps.getGeneratedKeys());       
commit:b52081a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
1: 
1:         // Mulitple columns. one not an identity column.
1:         colIndexes = new int[] {1,2};
1:         testUserGivenColumnsError(colIndexes, null);
1:         
1:         
1:         // Derby client can't differentiate between
1:         // valid and invalid identity columns. So the
1:         // other tests do not apply.  
1:         if (usingDerbyNetClient())
1:             return;
1:         colIndexes = new int[] {100};
/////////////////////////////////////////////////////////////////////////
commit:aadfc18
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:         // column name array is of length > 1
1:         colNames = new String[] {"C12","C13"};
1:         testUserGivenColumnsError(null, colNames);
1:              
1:         if (usingDerbyNetClient())
1:             return;
1:        
1:         colNames= new String[] {"NOTTHERE"};
1:         
/////////////////////////////////////////////////////////////////////////
1:      * Verify that if user specifies an empty array for columNames or columnIndexes,
1:      * it is the same as NO_GENERATED_KEYS
1:      * @throws SQLException
1:      */
1:     public void testUserGivenColumnsEmpty() throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         String sql="insert into t11_AutoGen(c11) values (99)";
1: 
1:   
1:         s.execute(sql, new String[] {});
1:         assertNull("Expected NULL ResultSet after s.execute()", 
1:             s.getGeneratedKeys());
1: 
1:         s.executeUpdate(sql, new String[] {});
1:         assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:             s.getGeneratedKeys());
1: 
1:         PreparedStatement ps = null;
1:         if (!usingEmbedded())
1:         {
1:             // Can't run these with embedded now because of DERBY-3430
0:             ps = prepareStatement(sql, new String[] {});
1:             ps.execute();
1:             assertNull("Expected NULL ResultSet after ps.execute()", 
1:             ps.getGeneratedKeys());
1: 
0:             ps = prepareStatement(sql, new String[] {});
1:             ps.executeUpdate();
1:             assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:                     ps.getGeneratedKeys());
1:         }
1:        // No columnIndexes yet for derby client. 
1:        if (usingDerbyNetClient())
1:             return;
1:        
1:        s.execute(sql,  new int[] {});
1:        assertNull("Expected NULL ResultSet after s.execute()", 
1:            s.getGeneratedKeys());
1: 
1:        s.executeUpdate(sql, new int[] {});
1:        assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:            s.getGeneratedKeys());
1: 
1:        if (!usingEmbedded())
1:        {
1:            // Can't run these with embedded now because of DERBY-3430
1:            ps = prepareStatement(sql, new int[] {});
1:            ps.execute();
1:            assertNull("Expected NULL ResultSet after ps.execute()", 
1:                    ps.getGeneratedKeys());
1: 
1:            ps = prepareStatement(sql, new int[] {});
1:            ps.executeUpdate();
1:            assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:                    ps.getGeneratedKeys());
1: 
1:        }
1:        
1:     
1:         
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         
1:   
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps;
1:         ps = prepareStatement(sql, (String[]) null);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:             ps.getGeneratedKeys());
1: 
1:         ps = prepareStatement(sql, (String[]) null);
1:         ps.executeUpdate();
1:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:             ps.getGeneratedKeys());
1:         
1:        // No columnIndexes yet for derby client. 
1:        if (usingDerbyNetClient())
1:             return;
1:        
1:        s.execute(sql, (int[]) null);
1:        assertNull("Expected NULL ResultSet after s.execute()", 
1:            s.getGeneratedKeys());
1: 
1:        s.executeUpdate(sql, (int[]) null);
1:        assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:            s.getGeneratedKeys());
1: 
1:        ps = prepareStatement(sql, (int[]) null);
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Derby client will only give an error if colNames array is not of length 1.
1:         if (usingDerbyNetClient() && colNames != null && 
1:                 colNames.length != 1)
1:             expectedSQLState = "X0X0D";
1:         
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:fafbff8
/////////////////////////////////////////////////////////////////////////
1:         
1:         /*
1:         DERBY-3249 - Returned generated key result sets have the wrong
1:         concurrency. Test should be expanded to handle all concurrencies/types.
1:         
1:         // Test the type of the Statement object does not affect the
1:         // type of the generated key ResultSet (checked in getKeyValue)
1:         s = this.createStatement(ResultSet.CONCUR_UPDATABLE, ResultSet.TYPE_SCROLL_INSENSITIVE);
1:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue(s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", 5, keyval);
1:         */
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertGeneratedKeyResultSet(description, r);
1: 
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertGeneratedKeyResultSet("AutoGenJDBC30Test.getKeyValue", r);
1:         
author:Army
-------------------------------------------------------------------------------
commit:e3bd4bb
/////////////////////////////////////////////////////////////////////////
0:     public void testColumnIndexesNotImpl() throws SQLException
0:         /* As of DERBY-2631 we support this with embedded.  So do nothing
0:          * for this test fixture; we'll test the functionality as part
0:          * of a separate fixture.
1:          */
0:         if (usingEmbedded())
0:             return;
1: 
/////////////////////////////////////////////////////////////////////////
0:     public void testColumnNamesNotImpl() throws SQLException
0:         /* As of DERBY-2631 we support this with embedded.  So do nothing
0:          * for this test fixture; we'll test the functionality as part
0:          * of a separate fixture.
1:          */
0:         if (usingEmbedded())
0:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that use of columnIndexes to indicate which keys should be
1:      * made available works as expected.
1:      *
1:      * @throws SQLException 
1:      */
1:     public void testColumnIndexes() throws SQLException
1:     {
0:         /* Not supported for Derby client.  We check the "not supported"
0:          * error message as part of a different fixture.
1:          */
0:         if (usingDerbyNetClient())
0:             return;
1: 
1:         // Valid (typical) usage.
1: 
1:         int [] colIndexes = new int [] { 2 };
1:         testUserGivenColumns(colIndexes, null, 1);
1: 
1:         // Non-existent column index.
1: 
0:         colIndexes[0] = 100;
1:         testUserGivenColumnsError(colIndexes, null);
1: 
1:         // Valid column index but not an auto-gen column.
1: 
1:         colIndexes[0] = 1;
1:         testUserGivenColumnsError(colIndexes, null);
1: 
1:         /* If user specifies the same column index multiple times,
1:          * things should still work.  We effectively just take the
1:          * one and ignore the rest.
1:          */
1: 
1:         colIndexes = new int [] { 2, 2, 2 };
1:         testUserGivenColumns(colIndexes, null, 5);
1: 
1:         // Multiple col indexes, one of which is invalid.
1: 
1:         colIndexes[1] = 100;
1:         testUserGivenColumnsError(colIndexes, null);
1: 
0:         // Multiple col indexes, one of which is not an auto-gen column.
1: 
0:         colIndexes[1] = 1;
1:         testUserGivenColumnsError(colIndexes, null);
1: 
1:         /* Multiple col indexes, one of which is invalid and another
1:          * of which is not an auto-gen column.
1:          */
1: 
1:         colIndexes[2] = 100;
1:         testUserGivenColumnsError(colIndexes, null);
1: 
1:         // Same as previous but with "bad" indexes switched.
1: 
1:         colIndexes[1] = 100;
1:         colIndexes[2] = 1;
1:         testUserGivenColumnsError(colIndexes, null);
1:     }
1: 
1:     /**
1:      * Test that use of columnNames to indicate which keys should be
1:      * made available works as expected.
1:      *
1:      * @throws SQLException 
1:      */
1:     public void testColumnNames() throws SQLException
1:     {
0:         /* Not supported for Derby client.  We check the "not supported"
0:          * error message as part of a different fixture.
1:          */
0:         if (usingDerbyNetClient())
0:             return;
1: 
1:         // Valid (typical) usage.
1: 
1:         String [] colNames = new String [] { "C12" };
1:         testUserGivenColumns(null, colNames, 1);
1: 
1:         // Non-existent column name.
1: 
0:         colNames[0] = "NOTTHERE";
1:         testUserGivenColumnsError(null, colNames);
1: 
1:         // Valid column name but not an auto-gen column.
1: 
1:         colNames[0] = "C11";
1:         testUserGivenColumnsError(null, colNames);
1: 
1:         // "null" column name.
1: 
1:         colNames[0] = null;
1:         testUserGivenColumnsError(null, colNames);
1: 
1:         /* If user specifies the same column name multiple times,
1:          * things should still work.  We effectively just take the
1:          * one and ignore the rest.
1:          */
1: 
1:         colNames = new String [] { "C12", "C12", "C12" };
1:         testUserGivenColumns(null, colNames, 5);
1: 
1:         // Multiple col names, one of which is invalid.
1: 
1:         colNames[1] = "NOTTHERE";
1:         testUserGivenColumnsError(null, colNames);
1: 
1:         // Multiple col names, one of which is not an auto-gen column.
1: 
1:         colNames[1] = "C11";
1:         testUserGivenColumnsError(null, colNames);
1: 
1:         // Multiple col names, one of which is null.
1: 
1:         colNames[1] = null;
1:         testUserGivenColumnsError(null, colNames);
1: 
1:         /* Multiple col names, one of which is invalid and another
1:          * of which is not an auto-gen column.
1:          */
1: 
1:         colNames[1] = "C11";
1:         colNames[2] = "NOTTHERE";
1:         testUserGivenColumnsError(null, colNames);
1: 
1:         // Same as previous but with "bad" names switched.
1: 
1:         colNames[1] = "NOTTHERE";
1:         colNames[2] = "C11";
1:         testUserGivenColumnsError(null, colNames);
1:     }
1: 
1:     /**
1:      * Verify that if a user specifies a *NULL* column index or column
1:      * name array to indicate which keys should be made available, Derby will
1:      * effectively disable autogenerated keys (i.e. same as if user passed
1:      * NO_GENERATED_KEYS).
1:      *
1:      * Expected result: a NULL result set.
1:      * @throws SQLException 
1:      */
1:     public void testUserGivenColumnsNull() throws SQLException
1:     {
0:         /* Not supported for Derby client.  We check the "not supported"
0:          * error message as part of a different fixture.
1:          */
0:         if (usingDerbyNetClient())
0:             return;
1: 
1:         Statement s = createStatement();
1: 
1:         String sql="insert into t11_AutoGen(c11) values (99)";
1: 
0:         s.execute(sql, (int[]) null);
1:         assertNull("Expected NULL ResultSet after s.execute()", 
1:             s.getGeneratedKeys());
1: 
0:         s.executeUpdate(sql, (int[]) null);
1:         assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:             s.getGeneratedKeys());
1: 
1:         s.execute(sql, (String[]) null);
1:         assertNull("Expected NULL ResultSet after s.execute()", 
1:             s.getGeneratedKeys());
1: 
1:         s.executeUpdate(sql, (String[]) null);
1:         assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:             s.getGeneratedKeys());
1: 
1:         s.close();
1: 
0:         PreparedStatement ps = prepareStatement(sql, (int[]) null);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:             ps.getGeneratedKeys());
1: 
1:         ps = prepareStatement(sql, (int[]) null);
1:         ps.executeUpdate();
1:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:             ps.getGeneratedKeys());
1: 
0:         ps = prepareStatement(sql, (String[]) null);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:             ps.getGeneratedKeys());
1: 
0:         ps = prepareStatement(sql, (String[]) null);
1:         ps.executeUpdate();
1:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:      * Verify that if user specifies *valid* column indexes or column
1:      * names to indicate which keys should be made available, Derby will
1:      * return the correct results.
1:      *
1:      * Expected result: one row with a non-NULL key.
1:      *
1:      * @param colIndexes Array of column indexes indicating which keys
1:      *  should be made available.  Must be null if colNames is non-null.
1:      * @param colNames Array of column names indicating which keys should
1:      *  be made available.  Must be null if colIndexes is non-null.
1:      * @param expectedVal First expected autogenerated key; will be
1:      *  incremented for each successful INSERT statement.
1:      *
1:      * @throws SQLException
1:      */
1:     private void testUserGivenColumns(int [] colIndexes, String [] colNames,
1:         int expectedVal) throws SQLException
1:     {
1:         assertTrue("Exactly one of colIndexes or colNames should be null",
1:             ((colIndexes != null) ^ (colNames != null)));
1: 
1:         boolean useIndexes = (colIndexes != null);
1:         Statement s = createStatement();
1: 
1:         String sql="insert into t11_AutoGen(c11) values (99)";
1: 
1:         if (useIndexes)
1:             s.execute(sql, colIndexes);
1:         else
1:             s.execute(sql, colNames);
1: 
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expectedVal++, keyval);
1: 
1:         if (useIndexes)
1:             s.executeUpdate(sql, colIndexes);
1:         else
1:             s.executeUpdate(sql, colNames);
1: 
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.executeUpdate()",
1:             expectedVal++, keyval);
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = null;
1:         if (useIndexes)
1:             ps = prepareStatement(sql, colIndexes);
1:         else
1:             ps = prepareStatement(sql, colNames);
1: 
1:         ps.execute();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.execute()", expectedVal++, keyval);
1: 
1:         if (useIndexes)
1:             ps = prepareStatement(sql, colIndexes);
1:         else
1:             ps = prepareStatement(sql, colNames);
1: 
1:         ps.executeUpdate();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.executeUpdate()",
1:             expectedVal++, keyval);
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Verify that if user specifies *INvalid* column indexes or column
1:      * names to indicate which keys should be made available, Derby will
1:      * throw an appropriate error.
1:      *
1:      * Expected result: Execution-time error: X0X0E or X0X0F.
1:      *
1:      * @param colIndexes Array of column indexes indicating which keys
1:      *  should be made available.  Must be null if colNames is non-null.
1:      * @param colNames Array of column names indicating which keys should
1:      *  be made available.  Must be null if colIndexes is non-null.
1:      *
1:      * @throws SQLException 
1:      */
1:     private void testUserGivenColumnsError(int [] colIndexes,
1:         String [] colNames) throws SQLException
1:     {
1:         assertTrue("Exactly one of colIndexes or colNames should be null.",
1:             ((colIndexes != null) ^ (colNames != null)));
1: 
1:         boolean useIndexes = (colIndexes != null);
1:         String expectedSQLState = (useIndexes ? "X0X0E" : "X0X0F");
1: 
1:         Statement s = createStatement();
1:         String sql="insert into t11_AutoGen(c11) values (99)";
1: 
1:         try {
1: 
1:             if (useIndexes)
1:                 s.execute(sql, colIndexes);
1:             else
1:                 s.execute(sql, colNames);
1: 
1:             fail("Expected s.execute() to fail, but it did not.");
1: 
1:         } catch (SQLException se) {
1:             assertSQLState(expectedSQLState, se.getSQLState(), se);
1:         }
1: 
1:         try {
1: 
1:             if (useIndexes)
1:                 s.executeUpdate(sql, colIndexes);
1:             else
1:                 s.executeUpdate(sql, colNames);
1: 
1:             fail("Expected s.executeUpdate() to fail, but it did not.");
1: 
1:         } catch (SQLException se) {
1:             assertSQLState(expectedSQLState, se.getSQLState(), se);
1:         }
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = null;
1:         if (useIndexes)
1:                ps = prepareStatement(sql, colIndexes);
1:         else
1:                ps = prepareStatement(sql, colNames);
1: 
1:         try {
1:             ps.execute();
1:             fail("Expected ps.execute() to fail, but it did not.");
1:         } catch (SQLException se) {
1:             assertSQLState(expectedSQLState, se.getSQLState(), se);
1:         }
1: 
1:         try {
1:             ps.executeUpdate();
1:             fail("Expected ps.executeUpdate() to fail, but it did not.");
1:         } catch (SQLException se) {
1:             assertSQLState(expectedSQLState, se.getSQLState(), se);
1:         }
1: 
1:         ps.close();
1:     }
1: 
1:     /**
author:Jean T. Anderson
-------------------------------------------------------------------------------
commit:c7fdf72
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.AutoGenJDBC30Test
1:    Licensed to the Apache Software Foundation (ASF) under one
1:    or more contributor license agreements.  See the NOTICE file
1:    distributed with this work for additional information
1:    regarding copyright ownership.  The ASF licenses this file
1:    to you under the Apache License, Version 2.0 (the
1:    "License"); you may not use this file except in compliance
1:    with the License.  You may obtain a copy of the License at
1:   
1:      http://www.apache.org/licenses/LICENSE-2.0
1:   
1:    Unless required by applicable law or agreed to in writing,
1:    software distributed under the License is distributed on an
1:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:    KIND, either express or implied.  See the License for the
1:    specific language governing permissions and limitations
1:    under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
0: import java.sql.SQLException;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.BaseJDBCTestSetup;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * Tests the JDBC 3.0 ability to establish a result set of auto-generated keys.
1:  * <p>
1:  * Converts the old jdbcapi/autoGeneratedJdbc30.java test to JUnit.
1:  * The old harness test number is preserved in the comment for each fixture.
1:  */
1: public class AutoGenJDBC30Test extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Routines that should be created before the tests are run.
1:      */
1:     private static final String[] ROUTINES = {
1:         // Used by testInsertNoAutoGenExecuteSQLfunc
1:         "CREATE FUNCTION MMWNI() RETURNS VARCHAR(20) " +
1:         "READS SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:         AutoGenJDBC30Test.class.getName() + ".MyMethodWithNoInsert'",
1: 
1:         // Used by testInsertAutoGenExecuteSQLfunc
1:         "CREATE FUNCTION AddMe(P1 INT) RETURNS INT " +
1:         "READS SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:         AutoGenJDBC30Test.class.getName() + ".addMe'",
1:     };
1: 
1:     /**
1:      * Tables that should be created before the tests are run.
1:      * The first element in each row is the name of the table and the second 
1:      * element is the SQL text that creates it.
1:      */
1:     private static final String[][] TABLES = {
1:         
1:         { "t11_AutoGen", 
1:           "create table t11_AutoGen (c11 int, " +
1:           "c12 int generated always as identity (increment by 1))" },
1: 
1:         { "t31_AutoGen",
1:           "create table t31_AutoGen (c31 int, " +
1:           "c32 int generated always as identity (increment by 1), " +
1:           "c33 int default 2)" },
1: 
1:         { "t21_noAutoGen",
1:           "create table t21_noAutoGen (c21 int not null unique, c22 char(5))" },
1:     };
1: 
1:     /**
1:      * Creates a new AutoGenJDBC30Test instance.
1:      *
1:      * @param name name of the test
1:      */
1:     public AutoGenJDBC30Test(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Implements suite() to run in embedded and client configurations.
1:      */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("AutoGenJDBC30Test");
1: 
1:         suite.addTest(baseSuite("AutoGenJDBC30Test:embedded"));
1: 
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:             baseSuite("AutoGenJDBC30Test:client")));
1:         return suite;
1:     }
1: 
1:     /**
1:      * Tests are only run if JDBC 3.0 available, and database objects get 
1:      * created only once for the suite run.
1:      *
1:      * @param name name of the test
1:      */
1:     private static Test baseSuite(String name) {
1: 
0:         TestSuite suite = new TestSuite(name);
1: 
1:         if (!JDBC.vmSupportsJDBC3()) {
1:             // empty suite
1:             return suite;
1:         }
1: 
1:         suite.addTestSuite(AutoGenJDBC30Test.class);
1: 
1:         // Create database objects only once for entire test run
1:         return new CleanDatabaseTestSetup(suite) 
1:         {
1:             /**
1:             * Creates the database objects used in the test cases.
1:             * @throws SQLException 
1:             */
1:             protected void decorateSQL(Statement s) throws SQLException
1:             {
1:                 for (int i = 0; i < ROUTINES.length; i++) {
1:                     s.execute(ROUTINES[i]);
1:                 }
1:                 for (int i = 0; i < TABLES.length; i++) {
1:                     s.execute(TABLES[i][1]);
1:                 }
1:             }
1:         };
1:     } // End baseSuite
1: 
1:     /**
1:      * Sets up the connection for a test case, clears all tables and resets
1:      * all auto-generated keys used by the test fixtures.
1:      * @throws SQLException 
1:      */
1:     public void setUp() throws SQLException
1:     {
1:         Connection conn = getConnection();
1:         conn.setAutoCommit(false);
1:         Statement s = createStatement();
1:         for (int i = 0; i < TABLES.length; i++) {
1:             s.execute("DELETE FROM " + TABLES[i][0]);
1:         }
1:         s.execute("ALTER TABLE t11_AutoGen ALTER COLUMN c12 RESTART WITH 1");
1:         s.execute("ALTER TABLE t31_AutoGen ALTER COLUMN c32 RESTART WITH 1");
1:         s.close();
1:         conn.commit();
1:     }
1: 
1:     // TESTS
1: 
1:     /**
1:      * Requests generated keys for a new statement that hasn't executed any 
1:      * SQL yet. 
1:      * Old harness Test 1.
1:      * Expected result: a NULL ResultSet.
1:      * @throws SQLException 
1:      */
1:     public void testNoSql() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         assertNull("Expected NULL ResultSet", s.getGeneratedKeys());
1:         s.close();
1:     }
1: 
1:     /**
1:      * Requests generated keys for a Select statement (non-insert).
1:      * Old harness Test 2.
1:      * Expected result: a NULL ResultSet.
1:      * @throws SQLException 
1:      */
1:     public void testSelect() throws SQLException
1:     {
1:         String sql="select * from t11_AutoGen";
1: 
1:         Statement s = createStatement();
1:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:         assertNull("Expected NULL ResultSet after s.execute()", 
1:             s.getGeneratedKeys());
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = 
1:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Requests generated keys for a multi-row insert statement.
1:      * Old harness Test 3.
1:      * Expected result: ResultSet has one row with a NULL key because it 
1:      * inserts more than one row and there was no prior one-row insert into 
1:      * a table with an auto-generated key.
1:      * @throws SQLException 
1:      */
1:     public void testInsertManyRowsNoPriorKey() throws SQLException
1:     {
1:         String sqlStmt="insert into t31_AutoGen(c31) values (99), (98), (97)";
1:         runInsertFourWaysKeyIsNull (sqlStmt);
1:     }
1: 
1:     /**
1:      * Requests generated keys for a multi-row insert statement after a
1:      * one-row insert into a table with an auto-generated key.
1:      * Old harness Test 7.
1:      * Expected result: ResultSet has one row with a non-NULL key for the
1:      * one-row insert.
1:      * @throws SQLException 
1:      */
1:     public void testInsertManyRowsAfterOneRowKey() throws SQLException
1:     {
1:         // Do a one-row insert into a table with an auto-generated key.
1:         Statement s = createStatement();
1:         s.execute("insert into t11_AutoGen(c11) values (99)");
1: 
1:         /* Although the insert into t31_AutoGen below inserts into a table 
1:          * with an auto-generated column, it won't increment the key from 1 
1:          * to 2 because it's a multi-row insert.  Instead, the key it fetches
1:          * will be for the previous insert into t11_AutoGen.
1:          */
1:         int expected=1;
1:         String sql="insert into t31_AutoGen(c31) values (99), (98), (97)";
1: 
1:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expected, keyval);
1: 
1:         s.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.executeUpdate()", expected, keyval);
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = 
1:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.execute()", expected, keyval);
1: 
1:         ps = prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.executeUpdate()", expected, keyval);
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Requests generated keys after doing an insert into a table that doesn't
1:      * have a generated column (and there hasn't been a one row insert into 
1:      * a table with auto-generated keys yet).
1:      * Old harness Test 4.
1:      * Expected result: ResultSet has one row with a NULL key.
1:      * @throws SQLException 
1:      */
1:     public void testInsertNoAutoGen() throws SQLException
1:     {
1:         // The original test inserted 21 and 22.
1:         Statement s = createStatement();
1:         s.execute("insert into t21_noAutoGen values(21, 'true')");
1:         s.execute("insert into t21_noAutoGen values(22, 'true')");
1: 
1:         s.execute("insert into t21_noAutoGen values(23, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         verifyNullKey("s.execute()", s.getGeneratedKeys());
1: 
1:         s.executeUpdate("insert into t21_noAutoGen values(24, 'true')",
1:             Statement.RETURN_GENERATED_KEYS);
1:         verifyNullKey("s.executeUpdate()", s.getGeneratedKeys());
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "insert into t21_noAutoGen values(25, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         verifyNullKey("PreparedStatement.execute()", ps.getGeneratedKeys());
1: 
1:         ps = prepareStatement("insert into t21_noAutoGen values(26, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         verifyNullKey("ps.executeUpdate()", ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Requests generated keys after doing a one-row insert into a table that 
1:      * has a generated column, but the insert is via a subquery with no where
1:      * clause.
1:      * Old harness Test 5a.
1:      * Expected result: ResultSet has one row with a NULL key.
1:      * @throws SQLException 
1:      */
1:     public void testInsertSubqueryNoWhereClause() throws SQLException
1:     {
1:         // Setup
1:         Statement s = createStatement();
1:         s.execute("insert into t21_noAutoGen values(21, 'true')");
1:         s.close();
1: 
1:         String sql="insert into t11_AutoGen(c11) select c21 from t21_noAutoGen";
1:         runInsertFourWaysKeyIsNull (sql);
1:     }
1: 
1:     /**
1:      * Requests generated keys after doing a one-row insert into a table 
1:      * that has a generated column, but the insert is via a subquery with
1:      * a "where 1=2" clause.
1:      * Old harness Test 5B.
1:      * Expected result: ResultSet has one row with a NULL key.
1:      * @throws SQLException 
1:      */
1:     public void testInsertSubqueryWhere1is2() throws SQLException
1:     {
1:         // Setup
1:         Statement s = createStatement();
1:         s.execute("insert into t21_noAutoGen values(21, 'true')");
1:         s.close();
1: 
1:         String sql = 
1:             "insert into t11_AutoGen(c11) select c21 from t21_noAutoGen " +
1:             "where 1=2";
1:         runInsertFourWaysKeyIsNull (sql);
1:     }
1: 
1:     /**
1:      * Requests generated keys after doing a one-row insert into a table 
1:      * that has a generated column, but the insert is via a subquery with
1:      * a "where c21=23" clause.
1:      * Old harness Test 5c.
1:      * Expected result: ResultSet with one row with a NULL key.
1:      * @throws SQLException 
1:      */
1:     public void testInsertSubqueryWhereClause() throws SQLException
1:     {
1:         // Setup
1:         Statement s = createStatement();
1:         s.execute("insert into t21_noAutoGen(c21,c22) values(23, 'true')");
1:         s.close();
1: 
1:         String sql=
1:             "insert into t11_AutoGen(c11) select c21 from t21_noAutoGen " +
1:             "where c21=23";
1:         runInsertFourWaysKeyIsNull (sql);
1:     }
1: 
1:     /**
1:      * Requests generated keys after doing a one-row insert into a table 
1:      * that has an auto-generated column.
1:      * Old harness Test 6.
1:      * Expected result: ResultSet has one row with a non-NULL key.
1:      * @throws SQLException 
1:      */
1:     public void testInsertOneRowKey() throws SQLException
1:     {
1:         String sql="insert into t11_AutoGen(c11) values (99)";
1: 
1:         Statement s = createStatement();
1: 
1:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", 1, keyval);
1: 
1:         s.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.executeUpdate()", 2, keyval);
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = 
1:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.execute()", 3, keyval);
1: 
1:         ps = prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.executeUpdate()", 4, keyval);
1: 
1:         ps.close();
1:     }
1: 
1: 
1:     /**
1:      * After a one-row insert into a table with an auto-generated key, next
1:      * inserts into a table that does not have an auto-generated key, then
1:      * requests generated keys.
1:      * Old harness Test 8.
1:      * Expected result: ResultSet has one row with a non-NULL key. All four
1:      * queries in this test return the same result because they fetch the
1:      * key generated for the previous insert, not the current one.
1:      * @throws SQLException 
1:      */
1:     public void testInsertNoGenColAfterOneRowKey() throws SQLException
1:     {
1:         // Do a one-row insert into a table with an auto-generated key.
1:         Statement s = createStatement();
1:         s.execute("insert into t11_AutoGen(c11) values (99)");
1: 
1:         /* The insert into t21_noAutoGen below doesn't insert into a table 
1:          * with an auto-generated column, so it won't increment the key from 
1:          * 1 to 2.  The key it fetches will be for the previous insert into 
1:          * t11_AutoGen.
1:          */
1:         int expected=1;
1: 
1:         s.execute("insert into t21_noAutoGen values(27, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expected, keyval);
1: 
1:         s.executeUpdate("insert into t21_noAutoGen values(28, 'true')",
1:             Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.executeUpdate()", expected, keyval);
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "insert into t21_noAutoGen values(29, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.execute()", expected, keyval);
1: 
1:         ps = prepareStatement("insert into t21_noAutoGen values(30, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.executeUpdate()", expected, keyval);
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Requests generated keys for an UPDATE statement.
1:      * Old harness Test 9.
1:      * Expected result: a NULL ResultSet.
1:      * @throws SQLException 
1:      */
0:     public void testUpdate() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.execute("insert into t11_AutoGen(c11) values(999)");
1: 
0:         String sqlStmt="update t11_AutoGen set c11=1";
1:         s.execute(sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:         assertNull("Expected NULL ResultSet after s.execute()", 
1:             s.getGeneratedKeys());
1: 
1:         s.executeUpdate(sqlStmt, Statement.RETURN_GENERATED_KEYS);
0:         assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:             s.getGeneratedKeys());
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = prepareStatement(
1:             sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.executeUpdate();
0:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Requests generated keys for an DELETE statement.
1:      * Old master Test 10.
1:      * Expected result: a NULL ResultSet.
1:      * @throws SQLException 
1:      */
1:     public void testDelete() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.execute("insert into t11_AutoGen(c11) values(999)");
1: 
1:         String sqlStmt="delete from t11_AutoGen";
1:         s.execute(sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:         assertNull("Expected NULL ResultSet after s.execute()",
1:             s.getGeneratedKeys());
1: 
1:         s.executeUpdate(sqlStmt, Statement.RETURN_GENERATED_KEYS);
0:         assertNull("Expected NULL ResultSet after s.executeUpdate()", 
1:             s.getGeneratedKeys());
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = prepareStatement(
1:             sqlStmt, Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.executeUpdate();
0:         assertNull("Expected NULL ResultSet after ps.executeUpdate()", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Does a one-row insert into a table with a generated column, commits,
1:      * then requests generated keys for an insert into a table without a
1:      * generated column.
1:      * Old master Test 11.
1:      * Expected result: ResultSet has one row with a non-NULL key.
1:      * The original code output this message: "expected to see resultset with 
1:      * one row of NULL value but instead get one row of non-NULL value from 
1:      * getGeneratedKeys".
1:      * @throws SQLException 
1:      */
1:     public void testGetKeyAfterCommit() throws SQLException
1:     {
1:         // Setup transaction
1:         Statement s = createStatement();
1:         s.execute("insert into t11_AutoGen(c11) values(999)");
1: 
1:         Connection conn = getConnection();
1:         conn.commit();
1: 
1:         /* The insert into t21_noAutoGen below doesn't insert into a table 
1:          * with an auto-generated column, so it won't increment the key from 
1:          * 1 to 2.  The key it fetches will be for the previous insert into 
1:          * t11_AutoGen.
1:          */
1:         int expected=1;
1:         s.execute("insert into t21_noAutoGen values(31, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expected, keyval);
1: 
1:         s.executeUpdate("insert into t21_noAutoGen values(32, 'true')",
1:             Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.executeUpdate()", expected, keyval);
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "insert into t21_noAutoGen values(33, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.execute()", expected, keyval);
1: 
1:         ps = prepareStatement("insert into t21_noAutoGen values(34, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.executeUpdate()", expected, keyval);
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Does a one-row insert into a table with a generated column, next does
1:      * a rollback, then requests generated keys for an insert into a table 
1:      * without a generated column.
1:      * Old master Test 12.
1:      * Expected result: ResultSet has one row with a non-NULL key.
1:      * The original code output this message: "had expected to see resultset 
1:      * with one row of NULL value but instead get one row of non-NULL value 
1:      * from getGeneratedKeys".
1:      * @throws SQLException 
1:      */
1:     public void testGetKeyAfterRollback() throws SQLException
1:     {
1:         Connection conn = getConnection();
1:         Statement s = createStatement();
1: 
1:         s.execute("insert into t11_AutoGen(c11) values(999)");
1:         conn.rollback();
1: 
1:         /* The insert into t21_noAutoGen below doesn't insert into a table 
1:          * with an auto-generated column, so it won't increment the key from 
1:          * 1 to 2.  The key it fetches will be for the previous insert into 
1:          * t11_AutoGen, a value that never changes in this fixture.
1:          */
1:         int expected=1;
1: 
1:         s.execute("insert into t21_noAutoGen values(35, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", expected, keyval);
1: 
1:         s.executeUpdate("insert into t21_noAutoGen values(36, 'true')",
1:             Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.executeUpdate()", expected, keyval);
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "insert into t21_noAutoGen values(37, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.execute()", expected, keyval);
1: 
1:         ps = prepareStatement("insert into t21_noAutoGen values(38, 'true')", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("key value after ps.executeUpdate()", expected, keyval);
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Inserts one row into a table with an auto-generated column while inside
1:      * a savepoint unit, does a rollback, then gets keys after an insert
1:      * into a table without an auto-generated column.
1:      * Old master Test 13.
1:      * Expected result: ResultSet has one row with a non-NULL key, and the
1:      * key value should be the same before and after the rollback.
1:      * @throws SQLException 
1:      */
1:     public void testGetKeyAfterSavepointRollback() throws SQLException
1:     {
1:         Connection conn = getConnection();
1:         Statement s = createStatement();
1:         Savepoint savepoint1 = conn.setSavepoint();
1: 
1:         int expected=1;
1: 
1:         s.execute("insert into t11_AutoGen(c11) values(99)", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value before rollback", expected, keyval);
1: 
1:         conn.rollback(savepoint1);
1: 
1:         s.execute("insert into t21_noAutoGen values(39, 'true')",
1:             Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after rollback", expected, keyval);
1: 
1:         s.close();
1:     }
1: 
1:     /**
1:      * Inserts one row into a table with an auto-generated column, then 
1:      * examines the metadata for the generatedKeys ResultSet.
1:      * Old master Test 14.
1:      * @throws SQLException 
1:      */
1:     public void testGetKeyMetadataAfterInsert() throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         s.execute("insert into t31_AutoGen(c31) values (99)", 
1:             Statement.RETURN_GENERATED_KEYS);
1:         ResultSet rs = s.getGeneratedKeys();
1:         ResultSetMetaData rsmd = rs.getMetaData();
1:         assertEquals("ResultSet column count", 1, rsmd.getColumnCount());
1:         assertEquals("Column type", "DECIMAL", rsmd.getColumnTypeName(1));
1:         assertEquals("Column precision", 31, rsmd.getPrecision(1));
1:         assertEquals("Column scale", 0, rsmd.getScale(1));
1:         int keyval = getKeyValue (rs);
1:         assertEquals("Key value", 1, keyval);
1: 
1:         rs.close();
1:         s.close();
1:     }
1: 
1:     /**
1:      * Inserts one row into a table with an auto-generated column, but 
1:      * with NO_GENERATED_KEYS.
1:      * Old master Test 15.
1:      * Expected result: NULL ResultSet.
1:      * @throws SQLException 
1:      */
1:     public void testInsertNoGenKeys() throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         String sql="insert into t31_AutoGen(c31) values (99)";
1: 
1:         s.execute(sql, Statement.NO_GENERATED_KEYS);
1:         assertNull("Expected NULL ResultSet after s.execute()", 
1:             s.getGeneratedKeys());
1: 
1:         s.executeUpdate(sql, Statement.NO_GENERATED_KEYS);
1:         assertNull("Expected NULL ResultSet after s.executeUpdate", 
1:             s.getGeneratedKeys());
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = 
1:             prepareStatement(sql, Statement.NO_GENERATED_KEYS);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()",
1:             ps.getGeneratedKeys());
1: 
1:         ps = prepareStatement(sql, Statement.NO_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         assertNull("Expected NULL ResultSet after ps.executeUpdate", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Inserts one row into a table with an auto-generated column, but 
1:      * in the JDBC 2.0 way (with no generated key feature).
1:      * Old master Test 16.
1:      * Expected result: NULL ResultSet.
1:      * @throws SQLException 
1:      */
1:     public void testInsertJDBC20syntax() throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         String sql="insert into t31_AutoGen(c31) values (99)";
1: 
1:         s.execute(sql);
1:         assertNull("Expected NULL ResultSet after s.execute()", 
1:             s.getGeneratedKeys());
1: 
1:         s.executeUpdate(sql);
1:         assertNull("Expected NULL ResultSet after s.executeUpdate", 
1:             s.getGeneratedKeys());
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = prepareStatement(sql);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()",
1:             ps.getGeneratedKeys());
1: 
1:         ps = prepareStatement(sql);
1:         ps.executeUpdate();
1:         assertNull("Expected NULL ResultSet after ps.executeUpdate", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Updates a row in a table with an auto-generated column and 
1:      * NO_GENERATED_KEYS, then fetches key.
1:      * Old master Test 17.
1:      * Expected result: NULL ResultSet.
1:      * @throws SQLException 
1:      */
1:     public void testUpdateAutoGenNoGenKeys() throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         // Insert a row for us to update
1:         s.execute("insert into t31_AutoGen(c31) values (99)");
1: 
1:         String sql="update t31_AutoGen set c31=98";
1: 
1:         s.execute(sql, Statement.NO_GENERATED_KEYS);
1:         assertNull("Expected NULL ResultSet after s.execute()", 
1:             s.getGeneratedKeys());
1: 
1:         s.executeUpdate(sql, Statement.NO_GENERATED_KEYS);
1:         assertNull("Expected NULL ResultSet after s.executeUpdate", 
1:             s.getGeneratedKeys());
1: 
1:         s.close();
1: 
1:         PreparedStatement ps=prepareStatement(sql, Statement.NO_GENERATED_KEYS);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()",
1:             ps.getGeneratedKeys());
1: 
1:         ps = prepareStatement(sql, Statement.NO_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         assertNull("Expected NULL ResultSet after ps.executeUpdate", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Deletes rows from a table with an auto-generated column in the JDBC 2.0 
1:      * way (with no generated key feature), then fetches key.
1:      * Old master Test 18.
1:      * Expected result: NULL ResultSet.
1:      * @throws SQLException 
1:      */
1:     public void testDeleteAutoGenNoGenKeysJDBC20syntax() throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         String sql="delete from t31_AutoGen";
1: 
1:         s.execute(sql);
1:         assertNull("Expected NULL ResultSet after s.execute()", 
1:             s.getGeneratedKeys());
1: 
1:         s.executeUpdate(sql);
1:         assertNull("Expected NULL ResultSet after s.executeUpdate", 
1:             s.getGeneratedKeys());
1: 
1:         s.close();
1: 
1:         PreparedStatement ps=prepareStatement(sql);
1:         ps.execute();
1:         assertNull("Expected NULL ResultSet after ps.execute()",
1:             ps.getGeneratedKeys());
1: 
1:         ps = prepareStatement(sql);
1:         ps.executeUpdate();
1:         assertNull("Expected NULL ResultSet after ps.executeUpdate", 
1:             ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Inserts a row into a table with a SQL function in the VALUES clause;
1:      * the table does not have an auto-generated column.
1:      * Old master Test 19.
1:      * Expected result: ResultSet has one row. The key value is NULL if 
1:      * there has been no prior insert into a table with an auto-generated 
1:      * column; otherwise, the value is not NULL. 
1:      * The old master referenced an old issue for which this test was added. 
1:      * getGeneratedKeys() threw an exception if an insert statement included a 
1:      * SQL routine and set the flag to generate a generatedKeys ResultSet.
1:      * @throws SQLException 
1:      */
1:     public void testInsertNoAutoGenExecuteSQLfunc() throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         // Insert into a table that does not have an auto-gen column.
1:         s.execute("insert into t21_noAutoGen values(40, MMWNI())",
1:             Statement.RETURN_GENERATED_KEYS);
1:         verifyNullKey("First insert", s.getGeneratedKeys());
1:         assertTableRowCount("T21_NOAUTOGEN", 1);
1: 
1:         // Now insert into a table that has an auto-gen column.
1:         s.execute("insert into t31_AutoGen(c31) values (99)",
1:             Statement.RETURN_GENERATED_KEYS);
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after insert into t31_AutoGen", 1, keyval);
1: 
1:         // Insert again into the table that does not have an auto-gen column.
1:         s.execute("insert into t21_noAutoGen values(42, MMWNI())",
1:             Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after insert into t21_noAutoGen", 1, keyval);
1:         assertTableRowCount("T21_NOAUTOGEN", 2);
1: 
1:         s.close();
1:     }
1: 
1:     /**
1:      * Inserts a row into a table with a SQL function in the VALUES clause;
1:      * the table has an auto-generated column.
1:      * Old master: no test, but this seemed a natural addition given
1:      * testInsertNoAutoGenExecuteSQLfunc().
1:      * Expected result: ResultSet has one row with a non-NULL key value.
1:      * @throws SQLException 
1:      */
1:     public void testInsertAutoGenExecuteSQLfunc() throws SQLException
1:     {
1:         String sql="insert into t31_AutoGen(c31) values (AddMe(1))";
1: 
1:         Statement s = createStatement();
1: 
1:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:         int keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.execute()", 1, keyval);
1: 
1:         s.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
1:         keyval = getKeyValue (s.getGeneratedKeys());
1:         assertEquals("Key value after s.executeUpdate()", 2, keyval);
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = 
1:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.execute()", 3, keyval);
1: 
1:         ps = prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         keyval = getKeyValue (ps.getGeneratedKeys());
1:         assertEquals("Key value after ps.executeUpdate()", 4, keyval);
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Verifies fix for an old issue in which the ResultSet returned by 
1:      * getGenerateKeys was incorrectly tied to the activation of the 
1:      * PreparedStatement; so, when the ResultSet was garbage collected, the
1:      * activation was closed, resulting in an "Activation closed, operation
1:      * execute not permitted" exception on subsequent executes (warning:
1:      * this fixture takes a noticeable time to run).
1:      * Old master Test 20.
1:      * Expected result: no exceptions should occur.
1:      * @throws SQLException 
1:      */
1:     public void testResultSetGarbageCollection() throws SQLException
1:     {
1:         Connection conn = getConnection();
1: 
1:         PreparedStatement ps = 
1:             prepareStatement("insert into t11_AutoGen(c11) values(?)", 
1:             Statement.RETURN_GENERATED_KEYS);
1: 
1:         for (int i = 0; i < 100; i++) 
1:         {
1:             ps.setInt(1, 100+i);
1:             ps.executeUpdate();
1: 
1:             ResultSet rs = ps.getGeneratedKeys();
1:             while (rs.next()) {
1:                rs.getInt(1);
1:             }
1:             rs.close();
1:             conn.commit();
1: 
1:             System.runFinalization();
1:             System.gc();
1:             System.runFinalization();
1:             System.gc();
1:         }
1:     }
1: 
1:     /**
0:      * Verifies that an exception is raised if a columnIndexes array is passed, 
0:      * which signals the driver that the auto-generated keys indicated in the 
0:      * given array should be made available for retrieval (feature not 
0:      * supported).
0:      * Old master Test21, Test21ps
0:      * Expected result: Exception 0A000 should occur.
1:      * @throws SQLException 
1:      */
0:     public void testColumnIndexesError() throws SQLException
1:     {
1:         Statement s = createStatement();
0:         int colPositions[] = new int[1];
0:         colPositions[0] = 1;
1: 
0:         String sql="insert into t11_AutoGen(c11) " +
0:             "select c21 from t21_noAutoGen";
1: 
0:         try {
0:             s.execute(sql, colPositions);
0:             fail("Expected s.execute to fail");
0:         } catch (SQLException se) {
0:             assertSQLState("0A000", se.getSQLState(), se);
1:         }
1: 
0:         try {
0:             s.executeUpdate(sql, colPositions);
0:             fail("Expected s.executeUpdate to fail");
0:         } catch (SQLException se) {
0:             assertSQLState("0A000", se.getSQLState(), se);
1:         }
1: 
0:         try {
0:             /* Deliberately not adding this prepareStatement wrapper to
0:              * BaseJDBCTestCase.java because Derby doesn't support passing
0:              * the array.
1:              */
1:             Connection conn = getConnection();
0:             PreparedStatement ps=conn.prepareStatement(sql, colPositions);
0:             fail("Expected prepareStatement to fail");
0:         } catch (SQLException se) {
0:             assertSQLState("0A000", se.getSQLState(), se);
1:         }
1:     }
1: 
1:     /**
0:      * Verifies that an exception is raised if a columnNames array is passed, 
0:      * which signals the driver that the auto-generated keys indicated in the 
0:      * given array should be made available for retrieval (feature not 
0:      * supported).
0:      * Old master Test22, Test22ps
0:      * Expected result: Exception 0A000 should occur.
1:      * @throws SQLException 
1:      */
0:     public void testColumnNamesError() throws SQLException
1:     {
1:         Statement s = createStatement();
0:         String colNames[] = new String[1];
0:         colNames[0] = "C11";
1: 
0:         String sql="insert into t11_AutoGen(c11) " +
0:             "select c21 from t21_noAutoGen";
1: 
0:         try {
0:             s.execute(sql, colNames);
0:             fail("Expected s.execute to fail");
0:         } catch (SQLException se) {
0:             assertSQLState("0A000", se.getSQLState(), se);
1:         }
1: 
0:         try {
0:             s.executeUpdate(sql, colNames);
0:             fail("Expected s.executeUpdate to fail");
0:         } catch (SQLException se) {
0:             assertSQLState("0A000", se.getSQLState(), se);
1:         }
1: 
0:         try {
0:             /* Deliberately not adding this prepareStatement wrapper to
0:              * BaseJDBCTestCase.java because Derby doesn't support passing
0:              * the array.
1:              */
1:             Connection conn = getConnection();
0:             PreparedStatement ps=conn.prepareStatement(sql, colNames);
0:             fail("Expected prepareStatement to fail");
0:         } catch (SQLException se) {
0:             assertSQLState("0A000", se.getSQLState(), se);
1:         }
1:     }
1: 
1:     // Local utility methods.
1: 
1:     /**
1:      * Runs the same SQL INSERT statement four ways: 
1:      *   Statement.execute, 
1:      *   Statement.executeUpdate, 
1:      *   PreparedStatement.execute, and 
1:      *   PreparedStatement.executeUpdate,
1:      * and expects the resulting key value to be NULL. 
1:      *
1:      * @param sql The SQL statement to be executed
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void runInsertFourWaysKeyIsNull (String sql)
1:         throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.execute(sql, Statement.RETURN_GENERATED_KEYS);
1:         verifyNullKey("After s.execute()", s.getGeneratedKeys());
1: 
1:         s.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
1:         verifyNullKey("After s.executeUpdate()", s.getGeneratedKeys());
1: 
1:         s.close();
1: 
1:         PreparedStatement ps = 
1:             prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:         ps.execute();
1:         verifyNullKey("After ps.execute()", ps.getGeneratedKeys());
1: 
1:         ps = prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1:         ps.executeUpdate();
1:         verifyNullKey("ps.executeUpdate()", ps.getGeneratedKeys());
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Verifies that the generated key in a result set is null.
1:      *
1:      * @param description Text to be output for the assertion
1:      * @param r ResultSet
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void verifyNullKey (String description, ResultSet r) 
1:         throws SQLException
1:     {
0:         assertNotNull(description, r);
1:         int i = 0;
1:         while(r.next())
1:         {
1:             assertNull(description, r.getString(1));
1:             i++;
1:         }
1:         assertEquals(description, 1, i);
1:     }
1: 
1:     /**
1:      * Gets the key value from the result set.
1:      *
1:      * @param r ResultSet
1:      * @exception SQLException if a database error occurs
1:      */
1:     public int getKeyValue (ResultSet r) throws SQLException
1:     {
0:         assertNotNull("ResultSet is NULL", r);
1:         int i = 0;
1:         int retval = 0;
1:         while(r.next())
1:         {
1:             assertNotNull("Key value is NULL", r.getString(1));
1:             retval = r.getInt(1);
1:             i++;
1:         }
1:         assertEquals("ResultSet rows", 1, i);
1:         return retval;
1:     }
1: 
1:     // SQL ROUTINES (functions and procedures)
1: 
1:     /** 
1:      * External code for the  MMWNI() SQL function, which is called by
1:      * the testInsertNoAutoGenExecuteSQLfunc fixture.
1:      * @exception SQLException if a database error occurs
1:      */
1: 
1:     public static String MyMethodWithNoInsert() throws SQLException 
1:     {
1:         Connection conn = 
1:             DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = conn.createStatement();
1:         s.executeQuery("select * from t11_AutoGen");
1:         s.close();
1:         conn.close();
1:         return "true";
1:     }
1: 
1:     /** 
1:      * External code for the AddMe SQL function, which is called by
1:      * the testInsertAutoGenExecuteSQLfunc fixture.
1:      * @param p1 integer input argument to be used in calculation
1:      * @exception SQLException if a database error occurs
1:      */
1:     public static int addMe (int p1) throws SQLException
1:     {
1:         Connection conn = 
1:             DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = conn.createStatement();
1:         s.executeQuery("select * from t11_AutoGen");
1:         s.close();
1:         conn.close();
1:         return (p1 + p1);
1:     }
1: }
============================================================================