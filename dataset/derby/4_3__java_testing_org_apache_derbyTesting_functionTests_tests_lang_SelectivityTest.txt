1:02f8e49: /*
1:02f8e49:  * Class org.apache.derbyTesting.functionTests.tests.lang.SelectivityTest
1:02f8e49:  *
1:02f8e49:  * Licensed to the Apache Software Foundation (ASF) under one
1:02f8e49:  * or more contributor license agreements.  See the NOTICE file
1:02f8e49:  * distributed with this work for additional information
1:02f8e49:  * regarding copyright ownership.  The ASF licenses this file
1:02f8e49:  * to you under the Apache License, Version 2.0 (the
1:02f8e49:  * "License"); you may not use this file except in compliance
1:02f8e49:  * with the License.  You may obtain a copy of the License at
1:02f8e49:  *
1:02f8e49:  *   http://www.apache.org/licenses/LICENSE-2.0
1:02f8e49:  *
1:02f8e49:  * Unless required by applicable law or agreed to in writing,
1:02f8e49:  * software distributed under the License is distributed on an
1:02f8e49:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:02f8e49:  * KIND, either express or implied.  See the License for the
1:02f8e49:  * specific language governing permissions and limitations
1:02f8e49:  * under the License.
1:02f8e49:  */
7:02f8e49: 
1:02f8e49: package org.apache.derbyTesting.functionTests.tests.lang;
1:02f8e49: 
1:02f8e49: import java.sql.Connection;
1:02f8e49: import java.sql.ResultSet;
1:02f8e49: import java.sql.SQLException;
1:02f8e49: import java.sql.Statement;
1:1b72b60: import java.util.Properties;
1:02f8e49: import junit.framework.Test;
1:02f8e49: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:02f8e49: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1b72b60: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:02f8e49: import org.apache.derbyTesting.junit.JDBC;
1:862666b: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:862666b: import org.apache.derbyTesting.junit.SQLUtilities;
1:02f8e49: 
1:02f8e49: public class SelectivityTest extends BaseJDBCTestCase {
1:02f8e49: 
1:02f8e49:     public SelectivityTest(String name) {
1:02f8e49:         super(name);
2:02f8e49:     }
1:02f8e49:     
1:02f8e49:     public static Test suite() {
1:1b72b60:         
1:1b72b60:         Properties props = new Properties();
1:1b72b60:         // first disable the automatic statistics gathering so we get
1:1b72b60:         // clean statistics
1:1b72b60:         // then switch the statement cache size to 0, so that doesn't
1:1b72b60:         // interfere and previous tests' left-overs are gone.
1:1b72b60:         props.setProperty("derby.storage.indexStats.auto", "false");
1:1b72b60:         props.setProperty("derby.language.statementCacheSize", "0");
1:1b72b60:         // set the props, and boot the db
1:1b72b60:         Test test = new DatabasePropertyTestSetup(
1:1ae02c9:             new BaseTestSuite(SelectivityTest.class), props, true);
1:1b72b60:         
1:1b72b60:         return new CleanDatabaseTestSetup(test) {
1:1b72b60:             protected void decorateSQL(Statement s) throws SQLException
1:1b72b60:             {        
1:02f8e49:                 s.executeUpdate("create table two (x int)");
1:02f8e49:                 s.executeUpdate("insert into two values (1),(2)");
1:02f8e49:                 s.executeUpdate("create table ten (x int)");
2:02f8e49:                 s
1:02f8e49:                         .executeUpdate("insert into ten values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10)");
1:02f8e49:                 s.executeUpdate("create table twenty (x int)");
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("insert into twenty values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19),(20)");
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("create table hundred (x int generated always as identity, dc int)");
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("insert into hundred (dc) select t1.x from ten t1, ten t2");
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("create table template (id int not null generated always as identity, two int, twenty int, hundred int)");
1:02f8e49:                 // 4000 rows
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("insert into template (two, twenty, hundred) select two.x, twenty.x, hundred.x from two, twenty, hundred");
1:02f8e49:                 s.executeUpdate("create index template_two on template(two)");
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("create index template_twenty on template(twenty)");
1:02f8e49:                 // 20 distinct values
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("create index template_22 on template(twenty,two)");
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("create unique index template_id on template(id)");
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("create index template_102 on template(hundred,two)");
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("create table test (id int, two int, twenty int, hundred int)");
1:02f8e49:                 s.executeUpdate("create index test_id on test(id)");
1:02f8e49:                 s.executeUpdate("insert into test select * from template");
1:02f8e49: 
1:1b72b60:                 s.executeUpdate("create view showstats as "
1:02f8e49:                                 + "select cast (conglomeratename as varchar(20)) indexname, "
1:02f8e49:                                 + "cast (statistics as varchar(40)) stats, "
1:02f8e49:                                 + "creationtimestamp createtime, "
1:02f8e49:                                 + "colcount ncols "
1:02f8e49:                                 + "from sys.sysstatistics, sys.sysconglomerates "
1:02f8e49:                                 + "where conglomerateid = referenceid");
1:02f8e49:                 ResultSet statsrs = s
1:02f8e49:                         .executeQuery("select indexname, stats, ncols from showstats order by indexname, stats, createtime, ncols");
1:02f8e49:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:02f8e49:                         {"TEMPLATE_102","numunique= 100 numrows= 4000","1"},
1:02f8e49:                         {"TEMPLATE_102","numunique= 200 numrows= 4000","2"},
1:02f8e49:                         {"TEMPLATE_22","numunique= 20 numrows= 4000","1"},
1:02f8e49:                         {"TEMPLATE_22","numunique= 40 numrows= 4000","2"},
1:02f8e49:                         {"TEMPLATE_TWENTY","numunique= 20 numrows= 4000","1"},
1:02f8e49:                         {"TEMPLATE_TWO","numunique= 2 numrows= 4000","1"}});               
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEMPLATE',null)");
1:02f8e49:                 s
1:02f8e49:                         .executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST',null)");
1:02f8e49:                 statsrs = s
1:1b72b60:                         .executeQuery("select indexname, stats, ncols from showstats order by indexname, stats, createtime, ncols");
1:02f8e49:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:02f8e49:                         {"TEMPLATE_102","numunique= 100 numrows= 4000","1"},
1:02f8e49:                         {"TEMPLATE_102","numunique= 200 numrows= 4000","2"},
1:02f8e49:                         {"TEMPLATE_22","numunique= 20 numrows= 4000","1"},
1:02f8e49:                         {"TEMPLATE_22","numunique= 40 numrows= 4000","2"},
1:02f8e49:                         {"TEMPLATE_TWENTY","numunique= 20 numrows= 4000","1"},
1:02f8e49:                         {"TEMPLATE_TWO","numunique= 2 numrows= 4000","1"},
1:1b72b60:                         {"TEST_ID","numunique= 4000 numrows= 4000","1"},
1:1b72b60:                         });
1:02f8e49:                 
1:1b72b60:                 s.executeUpdate("create table t1 " +
1:1b72b60:                 		"(id int generated always as identity, " +
1:1b72b60:                 		"two int, twenty int, hundred varchar(3))");
1:1b72b60:                 s.executeUpdate("insert into t1 (hundred, twenty, two) " +
1:1b72b60:                 		"select CAST(CHAR(hundred.x) AS VARCHAR(3)), " +
1:1b72b60:                 		"twenty.x, two.x from hundred, twenty, two");
1:1b72b60:                 s.executeUpdate("create table t2 " +
1:1b72b60:                 		"(id int generated always as identity, " +
1:1b72b60:                 		"two int, twenty int, hundred varchar(3))");
1:1b72b60:                 s.executeUpdate("insert into t2 (hundred, twenty, two) " +
1:1b72b60:                 		"select CAST(CHAR(hundred.x) AS VARCHAR(3)) , " +
1:1b72b60:                 		"twenty.x, two.x from hundred, twenty, two");
1:1b72b60:                 s.executeUpdate("create table t3 " +
1:1b72b60:                 		"(id int generated always as identity, " +
1:1b72b60:                 		"two int, twenty int, hundred varchar(3))");
1:1b72b60:                 s.executeUpdate("insert into t3 (hundred, twenty, two) " +
1:1b72b60:                 		"select CAST(CHAR(hundred.x) AS VARCHAR(3)), " +
1:1b72b60:                 		"twenty.x, two.x from hundred, twenty, two");
1:1b72b60:                 s.executeUpdate("create index t1_hundred on t1(hundred)");
1:1b72b60:                 s.executeUpdate("create index t1_two_twenty on t1(two,twenty)");
1:1b72b60:                 s.executeUpdate("create index " +
1:1b72b60:                 		"t1_twenty_hundred on t1(twenty, hundred)");
1:1b72b60:                 s.executeUpdate("create index t2_hundred on t2(hundred)");
1:1b72b60:                 s.executeUpdate("create index t2_two_twenty on t2(two,twenty)");
1:1b72b60:                 s.executeUpdate("create index t2_twenty_hundred on t2(twenty, hundred)");
1:1b72b60:                 s.executeUpdate("create index t3_hundred on t3(hundred)");
1:1b72b60:                 s.executeUpdate("create index t3_two_twenty on t3(two,twenty)");
1:1b72b60:                 s.executeUpdate("create index t3_twenty_hundred on t3(twenty, hundred)");
1:1b72b60:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                         "('APP','T1',null)");
1:1b72b60:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                         "('APP','T2',null)");
1:1b72b60:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                         "('APP','T3',null)");
1:1b72b60: 
1:1b72b60:                 statsrs = s.executeQuery(
1:1b72b60:                         "select indexname, stats, ncols from showstats " +
1:1b72b60:                         "where indexname like 'T1%' " +
1:b1c9bd2:                         "order by indexname, stats");
1:1b72b60:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                         {"T1_HUNDRED","numunique= 100 numrows= 4000","1"},
1:1b72b60:                         {"T1_TWENTY_HUNDRED","numunique= 20 numrows= 4000","1"},
1:b1c9bd2:                         {"T1_TWENTY_HUNDRED","numunique= 2000 numrows= 4000","2"},
1:b1c9bd2:                         {"T1_TWO_TWENTY","numunique= 2 numrows= 4000","1"},
1:b1c9bd2:                         {"T1_TWO_TWENTY","numunique= 40 numrows= 4000","2"}});
1:1b72b60:                 statsrs = s.executeQuery(
1:1b72b60:                         "select indexname, stats, ncols from showstats " +
1:b1c9bd2:                         "where indexname like 'T2%' order by indexname, stats");
1:1b72b60:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                         {"T2_HUNDRED","numunique= 100 numrows= 4000","1"},
1:1b72b60:                         {"T2_TWENTY_HUNDRED","numunique= 20 numrows= 4000","1"},
1:b1c9bd2:                         {"T2_TWENTY_HUNDRED","numunique= 2000 numrows= 4000","2"},
1:b1c9bd2:                         {"T2_TWO_TWENTY","numunique= 2 numrows= 4000","1"},
1:b1c9bd2:                         {"T2_TWO_TWENTY","numunique= 40 numrows= 4000","2"}});
1:1b72b60:                 statsrs = s.executeQuery(
1:1b72b60:                         "select indexname, stats, ncols from showstats " +
1:b1c9bd2:                         "where indexname like 'T3%' order by indexname, stats");
1:1b72b60:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                         {"T3_HUNDRED","numunique= 100 numrows= 4000","1"},
1:1b72b60:                         {"T3_TWENTY_HUNDRED","numunique= 20 numrows= 4000","1"},
1:b1c9bd2:                         {"T3_TWENTY_HUNDRED","numunique= 2000 numrows= 4000","2"},
1:b1c9bd2:                         {"T3_TWO_TWENTY","numunique= 2 numrows= 4000","1"},
1:b1c9bd2:                         {"T3_TWO_TWENTY","numunique= 40 numrows= 4000","2"}});
1:1b72b60:                 
1:1b72b60:                 s.executeUpdate("create table scratch_table" +
1:1b72b60:                         "(id int, two int, twenty int, hundred int)");
1:1b72b60:                 s.executeUpdate("insert into scratch_table select " +
1:1b72b60:                         "id, two, twenty, CAST(CHAR(hundred) AS INTEGER) " +
1:1b72b60:                         "from t1");
1:1b72b60:                 s.executeUpdate("create index st_all on scratch_table" +
1:1b72b60:                         "(two, twenty, hundred)");
1:1b72b60:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                         "('APP','SCRATCH_TABLE',null)");
1:1b72b60:                 
1:1b72b60:                 s.executeUpdate("create table complex" +
1:1b72b60:                         "(id int generated always as identity, " +
1:1b72b60:                         "two int, twenty int, hundred int, a int, b int)");
1:1b72b60:                 s.executeUpdate(
1:1b72b60:                         "insert into complex (two, twenty, hundred, a, b) " +
1:1b72b60:                         "select two.x, twenty.x, hundred.x, two.x, twenty.x " +
1:1b72b60:                         "from two, twenty, hundred");
1:1b72b60:                 s.executeUpdate("create index complexind on complex" +
1:1b72b60:                         "(two, twenty, hundred, a, b)");
1:1b72b60:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                         "('APP','COMPLEX',null)");
1:1b72b60: 
1:02f8e49:             }
1:02f8e49:         };
1:02f8e49:     }
1:1b72b60:     
1:1b72b60:     public void testSingleColumnSelectivity() throws SQLException {
1:1b72b60:         // choose whatever plan you want but the row estimate should be.
1:1b72b60:         //(n * n) * 0.5
1:1b72b60:         // join on two, template inner, all rows.
1:1b72b60:         Connection conn = getConnection();
1:1b72b60:         Statement s = createStatement();
1:9f4fc5a:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TEMPLATE',NULL)");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TEST',NULL)");
1:1b72b60:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1b72b60:         s.executeQuery("select template.id from --DERBY-PROPERTIES joinOrder=fixed\n" 
1:1b72b60:                 + "test, template where test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,8020012.5);
1:1b72b60:         
1:1b72b60:         // choose hash join. Selectivity should be the same
1:1b72b60:         // join on two. template inner, hash join
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=hash \n" +
1:1b72b60:                 "where test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,8020012.5);
1:862666b:         RuntimeStatisticsParser rtsp = 
1:862666b:               SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         // choose NL join, no index. Selectivity should be the same
1:1b72b60:         // join on two. template inner, NL, no index, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,8020012.5);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertFalse(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         // choose NL join, index template_two. Selectivity should be the same
1:1b72b60:         // join on two. template inner, NL, index=two, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_two \n" +
1:1b72b60:                 "where test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,8020012.5);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWO"));
1:1b72b60:         
1:1b72b60:         // do joins on 20
1:1b72b60:         // first NL
1:1b72b60:         // join on twenty. template inner, NL, index=template_twenty, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_twenty \n" +
1:1b72b60:                 "where test.twenty = template.twenty").close();
1:1b72b60:         // Rowcount should be same as testSingleColumnSelectivityHash
1:1b72b60:         checkEstimatedRowCount(conn,802001.25);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWENTY"));
1:1b72b60:         
1:1b72b60:         // join on 20 but use index 20_2
1:1b72b60:         // cost as well as selectivity should be divided using selectivity
1:1b72b60:         // cost should same as template_twenty, or just a shade more...
1:1b72b60:         // join on twenty. template inner, NL, index=template_22, all rows
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_22 \n" +
1:1b72b60:                 "where test.twenty = template.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,802001.25);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_22"));
1:1b72b60:         
1:1b72b60:         // join on twenty but no index
1:1b72b60:         // note: the original test had this comment:
1:862666b:         // 'rc should be divided using selectivity. cost should be way different'
1:1b72b60:         // however, it seems the ec is identical.
1:1b72b60:         // join on twenty, template inner, NL, index=null, all rows
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.twenty = template.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,802001.25);
1:1b72b60:         
1:1b72b60:         // still single column, try stuff on 100 but with extra qualification
1:1b72b60:         // on outer table.
1:1b72b60:         // row count is 100 * 4000 * 0.01 = 4000
1:1b72b60:         // join on hundred. 
1:1b72b60:         // template inner, NL, index=template_102, 100 rows from outer
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_102 \n" +
1:1b72b60:                 "where test.hundred = template.hundred and test.id <= 100").close();
1:1b72b60:         // note: original cloudscape result was expecting 3884.85 here.
1:1b72b60:         checkEstimatedRowCount(conn,3924.9);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEST", "TEST_ID"));
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_102"));
1:1b72b60:         
1:1b72b60:         // join on hundred. 
1:1b72b60:         // template inner, NL, index=null, 100 rows from outer
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.hundred = template.hundred and test.id <= 100").close();
1:1b72b60:         checkEstimatedRowCount(conn,3924.9);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEST", "TEST_ID"));
1:1b72b60:         
1:1b72b60:         // join on hundred. 
1:1b72b60:         // template inner, hash, index=null, 100 rows from outer.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
2:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=hash, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.hundred = template.hundred and test.id <= 100").close();
1:1b72b60:         checkEstimatedRowCount(conn,3924.9);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEST", "TEST_ID"));
1:1b72b60:     }
1:1b72b60:     
1:1b72b60:     public void testMultiPredicate() throws SQLException {
1:1b72b60:         // multi predicate tests.
1:1b72b60:         // first do a oin involving twenty and two
1:1b72b60:         // forde use of a simngle column index to do the join
1:1b72b60:         // the row count should involve statistics from both 10 and 2 though...
1:1b72b60:         
1:1b72b60:         // row count should 4K * 4K * 1/40 = 400,000
1:1b72b60:         // cost doesn't show up in output but should depend on the index
1:1b72b60:         // being used (verify by hand before checking in.)
1:1b72b60:         setAutoCommit(false);
1:1b72b60:         Connection conn = getConnection();
1:1b72b60:         Statement s = createStatement();
1:1b72b60:         
1:1b72b60:         // join on twenty/two. template inner, hash, index=null, all rows.
1:862666b:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:862666b:                 "('APP','TEST',NULL)");
1:862666b:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:862666b:                 "('APP','TEMPLATE',NULL)");
1:1b72b60:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=hash, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,401000.625);
1:862666b:         RuntimeStatisticsParser rtsp = 
1:862666b:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         // join on twenty/two. template inner, NL, index=template_two, all rows
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_two \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,401000.625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWO"));
1:1b72b60:         
1:1b72b60:         // join on twenty/two. 
1:1b72b60:         // template inner, NL, index=template_twenty, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_twenty \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,401000.625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWENTY"));
1:1b72b60:         
1:1b72b60:         // join on twenty/two. template inner, NL, index=template_22, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_22 \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,401000.625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_22"));
1:1b72b60:         
1:1b72b60:         // multi predicate tests continued
1:1b72b60:         // drop index twenty, two -- use above predicates
1:1b72b60:         // should be smart enough to figure out the selectivity by
1:1b72b60:         // combining twenty and two.
1:1b72b60:         s.executeUpdate("drop index template_22");
1:1b72b60:         
1:1b72b60:         // join on twenty/two. index twenty_two dropped. 
1:1b72b60:         // template inner, hash, index=null, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=hash, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,401000.625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         // join on twenty/two. index twenty_two dropped. 
1:1b72b60:         // template inner, NL, index=template_two, all rows.'
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:862666b:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_two \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,401000.625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWO"));
1:1b72b60:         
1:1b72b60:         // join on twenty/two. index twenty_two dropped. 
1:1b72b60:         // template inner, NL, index=template_twenty, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_twenty \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,401000.625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWENTY"));
1:1b72b60:         
1:1b72b60:         s.executeUpdate("drop index template_two");
1:1b72b60:         
1:1b72b60:         // we only have index template_twenty
1:1b72b60:         // for the second predicate we should use 0.1 instead of 0.5
1:1b72b60:         // thus reducing earlier row count by a factor of 5
1:1b72b60:         // 80,000 instead of 400,000
1:1b72b60:         
1:1b72b60:         // join on twenty/two. index twenty_two and two dropped. 
1:1b72b60:         // template inner, NL, index=null, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,80200.12500000001);
1:1b72b60:         
1:1b72b60:         // join on twenty/two. index twenty_two and two dropped. 
1:1b72b60:         // template inner, NL, index=template_twenty, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_twenty \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,80200.12500000001);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWENTY"));
1:1b72b60:         
1:1b72b60:         // now drop index template_twenty
1:1b72b60:         // selectivity should become 0.1 * 0.1 = 0.01
1:1b72b60:         // 16 * 10^6 * .01 = 160,000
1:1b72b60:         
1:1b72b60:         s.executeUpdate("drop index template_twenty");
1:1b72b60:         
1:1b72b60:         // join on twenty/two. all indexes dropped.
1:1b72b60:         // template inner, NL, index=null, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.twenty = template.twenty " +
1:1b72b60:                 "and test.two = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,160400.25000000003);
1:1b72b60:         rollback();
1:1b72b60:     } 
1:1b72b60:     
1:1b72b60:     public void testTwoWayJoins() throws SQLException {
1:1b72b60:         setAutoCommit(false);
1:1b72b60:         Connection conn = getConnection();
1:1b72b60:         Statement s = createStatement();
1:1b72b60:         
1:1b72b60:         // throw in aditional predicates
1:1b72b60:         // see that the optimizer does the right thing
1:1b72b60:         
1:1b72b60:         // index on template_102. join on hundred, constant predicate on two. 
1:1b72b60:         // should be able to use statistics for hundred_two to com up with
1:1b72b60:         // row estimate.
1:1b72b60:         
1:1b72b60:         // selectivity should be 0.01 * 0.5 = 0.005
1:1b72b60:         // row count is 16*10^6 * 0.005 = 8*10^4.
1:1b72b60:         
1:1b72b60:         // join on hundred. constant pred on two. NL, index=null, all rows.
1:862666b:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:862666b:                 "('APP','TEMPLATE',NULL)");
1:862666b:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:862666b:                 "('APP','TEST',NULL)");
1:1b72b60:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.hundred = template.hundred " +
1:1b72b60:                 "and 1 = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,80200.125);
1:1b72b60:         
1:1b72b60:         // just retry above query with different access paths
1:1b72b60:         // row count shouldn't change!
1:1b72b60:         // join on hundred. constant pred on two. 
1:1b72b60:         // NL, index=template_102, all rows.
1:1b72b60:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_102 \n" +
1:1b72b60:                 "where test.hundred = template.hundred " +
1:1b72b60:                 "and 1 = template.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,80200.125);
1:862666b:         RuntimeStatisticsParser rtsp = 
1:862666b:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_102"));
1:1b72b60:         
1:1b72b60:         // hundred and twenty
1:1b72b60:         // we can use statistics for 100,2 to get selectivity for 100 and
1:1b72b60:         // twenty and twenty to get selectivity for 20
1:1b72b60:         // selectivity should 0.01 * 0.05 = 0.0005 -> 80,000
1:1b72b60:         // join on hundred. constant pred on twenty. 
1:1b72b60:         // NL, index=null, all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=null \n" +
1:1b72b60:                 "where test.hundred = template.hundred " +
1:1b72b60:                 "and 1 = template.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,8020.0125);
1:1b72b60:         
1:1b72b60:         // 'join on hundred. constant pred on twenty. 
1:1b72b60:         // NL, index=template_102 all rows.
1:1b72b60:         s.executeQuery("select template.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:1b72b60:                 "index=template_102 \n" +
1:1b72b60:                 "where test.hundred = template.hundred " +
1:1b72b60:                 "and 1 = template.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,8020.0125);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_102"));
1:1b72b60:     }
1:1b72b60:     
1:1b72b60:     public void testThreeWayJoins() throws SQLException {
1:1b72b60:         setAutoCommit(false);
1:1b72b60:         Connection conn = getConnection();
1:1b72b60:         Statement s = createStatement();
1:1b72b60:         
1:1b72b60:         // t1 x t2 yields 8000 rows.
1:1b72b60:         // x t3 yields 8*4 * 10^6 /2 = 16*10^6
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:862666b:                 "('APP','T1',NULL)");
1:862666b:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:862666b:                 "('APP','T2',NULL)");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','T3',NULL)");
1:1b72b60:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, t2, t3 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t1.twenty = t2.twenty and " +
1:1b72b60:                 "t2.two = t3.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,1.606007503125E7);
1:862666b:         RuntimeStatisticsParser rtsp = 
1:862666b:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 2, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:862666b:         assertTrue(rtsp.findString(
1:862666b:                 "Hash Scan ResultSet for T3 using index T3_TWO_TWENTY", 1));
1:1b72b60:         
1:1b72b60:         // t1 x t2 -> 16 * 10^4.
1:1b72b60:         // x t3    -> 32 * 10^7
1:1b72b60:         // additional pred -> 32 * 10^5
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, t2, t3 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two and " +
1:1b72b60:                 "t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:1b72b60:         
1:1b72b60:         // variations on above query; try different join strategies
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, t2, t3 --DERBY-PROPERTIES joinStrategy=hash \n" +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, t2, t3 --DERBY-PROPERTIES joinStrategy=nestedLoop \n" +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_HUNDRED"));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, t2 --DERBY-PROPERTIES joinStrategy=hash \n, t3 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, t2 --DERBY-PROPERTIES joinStrategy=hash \n, t3 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:1b72b60:         
1:1b72b60:         // duplicate predicates; this time t1.hundred=?
1:1b72b60:         // will show up twice when t1 is optimized at the end
1:1b72b60:         // selectivity should be same as above
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t2, t3, t1 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:1b72b60:         
1:1b72b60:         // variations on above query; try different join strategies
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t3, t2, t1 --DERBY-PROPERTIES joinStrategy=hash \n" +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t3, t2, t1 --DERBY-PROPERTIES joinStrategy=nestedLoop \n" +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_HUNDRED"));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t2, t3 --DERBY-PROPERTIES joinStrategy=nestedLoop \n, t1 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_HUNDRED"));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t3, t2 --DERBY-PROPERTIES joinStrategy=hash \n, t1 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:1b72b60:         
1:1b72b60:         // some more variations on the above theme
1:1b72b60:         // some constant predicates thrown in.
1:1b72b60:         // remember hundred is a char column
1:1b72b60:         // -- for some reason if you give the constant 
1:1b72b60:         // as a numeric argument it doesn't recognize that 
1:1b72b60:         // as a constant start/stop value for the index 
1:862666b:         // The error is that the types must be comparable.
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t2, t3, t1 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred " +
1:1b72b60:                 "and t1.hundred='1'").close();
1:1b72b60:         checkEstimatedRowCount(conn,30458.025);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T2", "T2_HUNDRED"));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_HUNDRED"));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
1:1b72b60:         
1:1b72b60:         // we have t1.100=t2.100 and t1.100=t3.100, so 
1:1b72b60:         // t2.100=t3.100 is redundant. 
1:1b72b60:         // row count shouldn't factor in the redundant predicate.
1:1b72b60:         // row count should be 3200000.0
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t2, t3, t1 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t1.hundred = t3.hundred " +
1:1b72b60:                 "and t2.hundred = t3.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,3212015.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:1b72b60:         
1:1b72b60:         // slightly different join predicates-- use composite stats.
1:1b72b60:         // t1 x t2            --> 16 * 10.4.
1:1b72b60:         //         x t3       --> 16 * 10.4 * 4000 * 1/40 = 16*10.6
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t2, t3, t1 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t2.twenty = t3.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,1.606007503125E7);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:862666b:         assertTrue(rtsp.findString(
1:862666b:                 "Hash Scan ResultSet for T3 using index T3_TWO_TWENTY", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:1b72b60:         
1:1b72b60:         // same as above but muck around with join order.
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, t2, t3 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t2.twenty = t3.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,1.606007503125E7);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:862666b:         assertTrue(rtsp.findString(
1:862666b:                 "Hash Scan ResultSet for T3 using index T3_TWO_TWENTY", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t2, t1, t3 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t2.twenty = t3.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,1.606007503125E7);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.findString(
1:862666b:                 "Hash Scan ResultSet for T3 using index T3_TWO_TWENTY", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, t3, t2 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t2.twenty = t3.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,1.606007503125E7);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_TWO_TWENTY"));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t3, t2, t1 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t2.twenty = t3.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,1.606007503125E7);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_TWO_TWENTY"));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t3, t1, t2 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t2.twenty = t3.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,1.606007503125E7);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_TWO_TWENTY"));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:1b72b60:         
1:1b72b60:         // and just for fun, what would we have gotten without statistics.
1:1b72b60:         s.executeQuery("select t1.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES useStatistics=false, joinOrder=fixed \n" + 
1:1b72b60:                 "t3, t1, t2 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t2.two = t3.two " +
1:1b72b60:                 "and t2.twenty = t3.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,6.4240300125000015E7);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_TWO_TWENTY"));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:862666b:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:862666b:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:862666b:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:1b72b60:     }
1:1b72b60:     
1:1b72b60:     public void testScratch() throws SQLException {
1:1b72b60:         // make sure we do a good job of stats on 1/3
1:1b72b60:         setAutoCommit(false);
1:1b72b60:         Connection conn = getConnection();
1:1b72b60:         Statement s = createStatement();
1:1b72b60:         
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','T1',NULL)");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','SCRATCH_TABLE',NULL)");
1:1b72b60:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1b72b60:         
1:1b72b60:         // Note: The original test did the first query *after* the following:
1:1b72b60:         // since the statistics (rowEstimates) are not precise, force a 
1:1b72b60:         // checkpoint to force out all the row counts to the container header,
1:1b72b60:         // and for good measure do a count which will update the row counts 
1:1b72b60:         // exactly.
1:1b72b60:         // s.executeUpdate("CALL SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE()");
1:1b72b60:         // But if that's executed, the estimatedRowCount becomes: 2582648.45
1:1b72b60:         // Without the checkpoint, the following select counts are unnecessary.
1:1b72b60:         // assertTableRowCount("T1", 4000);
1:1b72b60:         // assertTableRowCount("SCRATCH_TABLE", 4000);
1:1b72b60:         
1:1b72b60:         // preds are on columns 1 and 3
1:1b72b60:         // should use default stats for 100 (0.1) and 0.5 for two
1:1b72b60:         
1:1b72b60:         // 16*10.6 * 5*10.-2 = 80*10.4
1:1b72b60:         
1:1b72b60:         s.executeQuery("select s.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, scratch_table s " +
1:1b72b60:                 "where t1.two = s.two " +
1:1b72b60:                 "and s.hundred = CAST(CHAR(t1.hundred) AS INTEGER)").close();
1:1b72b60:         checkEstimatedRowCount(conn,802001.25);
1:862666b:         RuntimeStatisticsParser rtsp = 
1:862666b:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         // preds are on column 2.
1:1b72b60:         // 0.1 -> 16*10.5
1:1b72b60:         s.executeQuery("select s.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, scratch_table s " +
1:1b72b60:                 "where t1.twenty = s.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,1604002.5);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_TWO_TWENTY"));
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         // preds are on column 2,3.
1:1b72b60:         // 0.01 -> 16*10.4
1:1b72b60:         s.executeQuery("select s.id from " +
1:1b72b60:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:1b72b60:                 "t1, scratch_table s " +
1:1b72b60:                 "where t1.twenty = s.twenty " +
1:1b72b60:                 "and s.hundred = CAST(CHAR(t1.hundred) AS INTEGER)").close();
1:1b72b60:         checkEstimatedRowCount(conn,160400.2500000);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_TWENTY_HUNDRED"));
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:     }
1:1b72b60:     
1:1b72b60:     public void testStatMatcher() throws SQLException {
1:1b72b60:         // test of statistics matcher algorithm; make sure that we choose the
1:1b72b60:         // best statistics (the weight stuff in predicatelist)
1:1b72b60:         
1:1b72b60:         setAutoCommit(false);
1:1b72b60:         Connection conn = getConnection();
1:1b72b60:         Statement s = createStatement();
1:1b72b60:         
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','T1',NULL)");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','T2',NULL)");
1:1b72b60:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1b72b60:         
1:1b72b60:         // 2,20,100
1:1b72b60:         s.executeQuery("select t1.id from t1, t2 " +
1:1b72b60:                 "where t1.two = t2.two " +
1:1b72b60:                 "and t1.twenty = t2.twenty " +
1:1b72b60:                 "and t1.hundred = t2.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,4010.00625);
1:862666b:         RuntimeStatisticsParser rtsp = 
1:862666b:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         // now muck around with the order of the predicates
1:1b72b60:         // 2,100,20
1:1b72b60:         s.executeQuery("select t1.id from t1, t2 " +
1:1b72b60:                 "where t1.two = t2.two " +
1:1b72b60:                 "and t1.hundred = t2.hundred " +
1:1b72b60:                 "and t1.twenty = t2.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,4010.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         // 100,20,2
1:1b72b60:         s.executeQuery("select t1.id from t1, t2 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t1.twenty = t2.twenty " +
1:1b72b60:                 "and t1.two = t2.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,4010.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         // 100,2,20
1:1b72b60:         s.executeQuery("select t1.id from t1, t2 " +
1:1b72b60:                 "where t1.hundred = t2.hundred " +
1:1b72b60:                 "and t1.two = t2.two " +
1:1b72b60:                 "and t1.twenty = t2.twenty").close();
1:1b72b60:         checkEstimatedRowCount(conn,4010.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from t1, t2 " +
1:1b72b60:                 "where t1.twenty = t2.twenty " +
1:1b72b60:                 "and t1.hundred = t2.hundred " +
1:1b72b60:                 "and t1.two = t2.two").close();
1:1b72b60:         checkEstimatedRowCount(conn,4010.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t1.id from t1, t2 " +
1:1b72b60:                 "where t1.twenty = t2.twenty " +
1:1b72b60:                 "and t1.two = t2.two " +
1:1b72b60:                 "and t1.hundred = t2.hundred").close();
1:1b72b60:         checkEstimatedRowCount(conn,4010.00625);
1:862666b:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedHashJoin());
1:1b72b60:     }
1:1b72b60:     
1:1b72b60:     // Beetle was the bug system for Cloudscape, the forerunner
1:1b72b60:     // of Derby. The bug report described a query that was hitting an Error:
1:1b72b60:     // XJ001: Java exception: '2 >=2: java.lang.ArrayIndexOutOfBoundsException
1:1b72b60:     // on a specific query; when running the same query with DERBY-PROPERTIES
1:1b72b60:     // useStatistics=false the same query worked correctly.
1:1b72b60:     // The fix is in org.apache.derby.impl.sql.compile.PredicateList
1:1b72b60:     // referencing beetle 4321.
1:1b72b60:     public void testBeetle4321() throws SQLException {
1:1b72b60:         // test of statistics matcher algorithm; make sure that we choose the
1:1b72b60:         // best statistics (the weight stuff in predicatelist)
1:1b72b60:         
1:1b72b60:         setAutoCommit(false);
1:1b72b60:         Connection conn = getConnection();
1:1b72b60:         Statement s = createStatement();
1:1b72b60:         
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','COMPLEX',NULL)");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TEMPLATE',NULL)");
1:1b72b60:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1b72b60:         
1:1b72b60:         s.executeQuery("select t10.two from complex t10, template t20 " +
1:1b72b60:                 "where t10.two = 1 " +
1:1b72b60:                 "and t10.hundred = 2 " +
1:1b72b60:                 "and t10.a = 2 " +
1:1b72b60:                 "and t10.b = 2").close();
1:1b72b60:         checkEstimatedRowCount(conn,7945.920000000);
1:862666b:         RuntimeStatisticsParser rtsp = 
1:862666b:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("COMPLEX", "COMPLEXIND"));
1:862666b:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWO"));
1:1b72b60:     }
1:1b72b60:     
1:1b72b60:     public void testBasic() throws SQLException {
1:1b72b60:         // basic test for update statistics; make sure that statistics with
1:1b72b60:         // correct values are created and dropped and such.
1:1b72b60:         setAutoCommit(false);
1:1b72b60:         Statement s = createStatement();
1:1b72b60:         
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1b72b60:         
1:1b72b60:         // first on int, multi-column
1:1b72b60:         s.executeUpdate("create table tbasic1 " +
1:1b72b60:                 "(c1 int generated always as identity, c2 int, c3 int)");
1:1b72b60:         for (int i=1; i<5 ; i++)
1:1b72b60:         {
1:1b72b60:             for (int j=1 ; j<3 ; j++)
1:1b72b60:             {
1:1b72b60:                 for (int c=0; c<2 ; c++)
1:1b72b60:                     s.executeUpdate(
1:1b72b60:                         "insert into tbasic1 values " +
1:1b72b60:                         "(default, " + i + ", " + j + ")");
1:1b72b60:             }
1:1b72b60:         }
1:1b72b60:         
1:1b72b60:         // create index should automatically create stats. 
1:1b72b60:         s.executeUpdate("create index t1_c1c2 on tbasic1 (c1, c2)");
1:1b72b60:         ResultSet statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'T1_C1C2%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"T1_C1C2","numunique= 16 numrows= 16","1"},
1:1b72b60:                 {"T1_C1C2","numunique= 16 numrows= 16","2"}});
1:1b72b60:         // index dropped stats should be dropped.
1:1b72b60:         s.executeUpdate("drop index t1_c1c2");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'T1_C1C2%' order by indexname");
1:1b72b60:         JDBC.assertEmpty(statsrs);
1:1b72b60:         
1:1b72b60:         // second part of the test.
1:1b72b60:         // check a few extra types.
1:1b72b60:         s.executeUpdate("create table tbasic2 " +
1:1b72b60:                 "(i int not null, " +
1:1b72b60:                 "vc varchar(32) not null, " +
1:1b72b60:                 "dt date, ch char(20), " +
1:1b72b60:                 "constraint pk primary key (i, vc))");
1:1b72b60:         s.executeUpdate("create index tbasic2_i on tbasic2(i)");
1:1b72b60:         s.executeUpdate("create index tbasic2_ch_dt on tbasic2(ch, dt)");
1:1b72b60:         s.executeUpdate("create index tbasic2_dt_vc on tbasic2(dt, vc)");
1:1b72b60:         // do normal inserts. 
1:1b72b60:         s.executeUpdate(
1:1b72b60:                 "insert into tbasic2 values (1, 'one', '2001-01-01', 'one')");
1:1b72b60:         s.executeUpdate(
1:1b72b60:                 "insert into tbasic2 values (2, 'two', '2001-01-02', 'two')");
1:1b72b60:         s.executeUpdate(
1:1b72b60:                 "insert into tbasic2 values (3, 'three', '2001-01-03', 'three')");
1:1b72b60:         s.executeUpdate(
1:1b72b60:                 "insert into tbasic2 values (1, 'two', '2001-01-02', 'one')");
1:1b72b60:         s.executeUpdate(
1:1b72b60:                 "insert into tbasic2 values (1, 'three', '2001-01-03', 'one')");
1:1b72b60:         s.executeUpdate(
1:1b72b60:                 "insert into tbasic2 values (2, 'one', '2001-01-01', 'two')");
1:1b72b60:         
1:1b72b60:         // figure out the name of the primary key's backing index
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select conglomeratename from sys.sysconglomerates " +
1:1b72b60:                 "where conglomeratename like 'SQL%'");
1:1b72b60:         statsrs.next();
1:1b72b60:         String backIndName = statsrs.getString("conglomeratename");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TBASIC2','" + backIndName + "')");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'SQL%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {backIndName,"numunique= 3 numrows= 6","1"},
1:1b72b60:                 {backIndName,"numunique= 6 numrows= 6","2"}});
1:1b72b60:         
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TBASIC2','TBASIC2_I')");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname = 'TBASIC2_I' order by indexname");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC2_I","numunique= 3 numrows= 6","1"}});
1:1b72b60:         
1:1b72b60:         // do another insert then just updstat for whole table.
1:1b72b60:         s.executeUpdate(
1:1b72b60:                 "insert into tbasic2 values(2, 'three', '2001-01-03', 'two')");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TBASIC2',null)");
1:1b72b60:         
1:1b72b60:         // make sure that stats are correct.
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname = 'TBASIC2_I' order by indexname");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC2_I","numunique= 3 numrows= 7","1"}});
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select count(*) from (select distinct i from tbasic2) t");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {{"3"}});
1:1b72b60:         
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:b1c9bd2:                 "where indexname = 'TBASIC2_CH_DT' order by indexname, stats");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC2_CH_DT","numunique= 3 numrows= 7","1"},
1:1b72b60:                 {"TBASIC2_CH_DT","numunique= 7 numrows= 7","2"}});
1:1b72b60:         
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select count(*) from (select distinct ch from tbasic2) t");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {{"3"}});
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select count(*) from (select distinct ch, dt from tbasic2) t");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {{"7"}});
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:b1c9bd2:                 "where indexname = 'TBASIC2_DT_VC' " +
1:b1c9bd2:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC2_DT_VC","numunique= 3 numrows= 7","1"},
1:1b72b60:                 {"TBASIC2_DT_VC","numunique= 3 numrows= 7","2"}});
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select count(*) from (select distinct dt from tbasic2) t");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {{"3"}});
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select count(*) from (select distinct dt, vc from tbasic2) t");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {{"3"}});
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'SQL%' order by stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"numunique= 3 numrows= 7","1"},
1:1b72b60:                 {"numunique= 7 numrows= 7","2"}});
1:1b72b60:         
1:1b72b60:         // delete everything from t2, do bulkinsert see what happens.
1:1b72b60:         assertUpdateCount(s, 7, "delete from tbasic2");
1:1b72b60:         
1:1b72b60:         // no material impact on stats
1:1b72b60:         // note; the test didn't actually confirm, here's the expected now
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'TBASIC2%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC2_CH_DT","numunique= 3 numrows= 7","1"},
1:1b72b60:                 {"TBASIC2_CH_DT","numunique= 7 numrows= 7","2"},
1:1b72b60:                 {"TBASIC2_DT_VC","numunique= 3 numrows= 7","1"},
1:1b72b60:                 {"TBASIC2_DT_VC","numunique= 3 numrows= 7","2"},
1:1b72b60:                 {"TBASIC2_I","numunique= 3 numrows= 7","1"}});
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TBASIC2',null)");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'TBASIC2%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertEmpty(statsrs);
1:1b72b60:         
1:1b72b60:         // Note: the original (Cloudscape) test did a 'bulkinsert'.
1:1b72b60:         // this is now only possible internally, and is used in
1:1b72b60:         // the SYSCS_IMPORT_DATA system procedures.
1:1b72b60:         // Possibly this test can be added onto by moving the
1:1b72b60:         // value intended to be inserted into a data file, and calling
1:1b72b60:         // SYSCS_UTIL.SYSCS_IMPORT_DATA using that.
1:1b72b60:         // The row inserted was:
1:1b72b60:         //        "values (2, 'one', '2001-01-01', 'two')");
1:1b72b60:         // subsequently, there was a bulk insert-replace, this is
1:1b72b60:         // no longer supported. We could update the row.
1:1b72b60:         // the replacement was of row:
1:1b72b60:         //        "(2, 'one', '2001-01-01', 'two'), " +
1:1b72b60:         // by
1:1b72b60:         //        "(1, 'one', '2001-01-01', 'two')");
1:1b72b60:         s.executeUpdate("drop table tbasic2");
1:1b72b60:         
1:1b72b60:         // various alter table operations to ensure correctness.
1:1b72b60:         // 1. add and drop constraint.
1:1b72b60:         s.executeUpdate("create table tbasic3 " +
1:1b72b60:                 "(x int not null generated always as identity," +
1:1b72b60:                 " y int not null, z int)");
1:1b72b60:         s.executeUpdate(
1:1b72b60:                 "insert into tbasic3 (y,z) values " +
1:1b72b60:                 "(1,1),(1,2),(1,3),(1,null),(2,1),(2,2),(2,3),(2,null)");
1:1b72b60:         // first alter table to add primary key;
1:1b72b60:         s.executeUpdate("alter table tbasic3 " +
1:1b72b60:                 "add constraint pk_tbasic3 primary key (x,y)");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select conglomeratename from sys.sysconglomerates " +
1:1b72b60:                 "where conglomeratename like 'SQL%'");
1:1b72b60:         statsrs.next();
1:1b72b60:         backIndName = statsrs.getString("conglomeratename");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select stats, ncols from showstats " +
1:1b72b60:                 "where indexname like '" + backIndName + "' " +
1:1b72b60:                 "order by stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"numunique= 8 numrows= 8","1"},
1:1b72b60:                 {"numunique= 8 numrows= 8","2"}});
1:1b72b60:         // now drop the constraint
1:1b72b60:         s.executeUpdate("alter table tbasic3 drop constraint pk_tbasic3");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select stats, ncols from showstats " +
1:1b72b60:                 "where indexname like '" + backIndName + "' " +
1:1b72b60:                 "order by stats, ncols");
1:1b72b60:         JDBC.assertEmpty(statsrs);
1:1b72b60:         
1:1b72b60:         // try compress with tons of rows. you can never tell 
1:1b72b60:         // what a few extra pages can do :)
1:1b72b60:         for (int i=0; i<9 ; i++)
1:1b72b60:             s.executeUpdate("insert into tbasic3(y,z) select y,z from tbasic3");
1:1b72b60:         statsrs = s.executeQuery("select count(*) from tbasic3");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {{"4096"}});
1:1b72b60:         s.executeUpdate("create index tbasic3_xy on tbasic3(x,y)");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'TBASIC3_XY%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC3_XY","numunique= 4096 numrows= 4096","1"},
1:1b72b60:                 {"TBASIC3_XY","numunique= 4096 numrows= 4096","2"}});
1:1b72b60:         s.executeUpdate("delete from tbasic3 where z is null");
1:1b72b60:         s.executeUpdate("call SYSCS_UTIL.SYSCS_COMPRESS_TABLE" +
1:1b72b60:                 "('APP', 'TBASIC3', 0)");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'TBASIC3_XY%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC3_XY","numunique= 3072 numrows= 3072","1"},
1:1b72b60:                 {"TBASIC3_XY","numunique= 3072 numrows= 3072","2"}});
1:1b72b60:         s.executeUpdate("drop table tbasic3");
1:1b72b60:         
1:1b72b60:         s.executeUpdate("create table tbasic4 " +
1:1b72b60:                 "(x int, y int, z int)");
1:1b72b60:         s.executeUpdate("insert into tbasic4 values (1,1,1)");
1:1b72b60:         s.executeUpdate("insert into tbasic4 values (1,2,1)");
1:1b72b60:         s.executeUpdate("insert into tbasic4 values (1,1,2)");
1:1b72b60:         
1:1b72b60:         s.executeUpdate("create index tbasic4_x on tbasic4(x)");
1:1b72b60:         s.executeUpdate("create index tbasic4_xy on tbasic4(x,y)");
1:1b72b60:         s.executeUpdate("create index tbasic4_yz on tbasic4(y,z)");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'TBASIC4%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC4_X","numunique= 1 numrows= 3","1"},
1:1b72b60:                 {"TBASIC4_XY","numunique= 1 numrows= 3","1"},
1:1b72b60:                 {"TBASIC4_XY","numunique= 2 numrows= 3","2"},
1:1b72b60:                 {"TBASIC4_YZ","numunique= 2 numrows= 3","1"},
1:1b72b60:                 {"TBASIC4_YZ","numunique= 3 numrows= 3","2"}});
1:1b72b60: 
1:1b72b60:         // if we drop column x, then stats for tbasic4_x should get dropped
1:1b72b60:         // index tbasic4_xy should get rebuilt to only be on y. so one of the
1:1b72b60:         // stats should be recreated. and tbasic4_yz shouldn remain in its
1:1b72b60:         // entirety.
1:1b72b60:         s.executeUpdate("alter table tbasic4 drop column x");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'TBASIC4%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC4_XY","numunique= 2 numrows= 3","1"},
1:1b72b60:                 {"TBASIC4_YZ","numunique= 2 numrows= 3","1"},
1:1b72b60:                 {"TBASIC4_YZ","numunique= 3 numrows= 3","2"}});
1:1b72b60:         s.executeUpdate("drop table tbasic4");
1:1b72b60:         
1:1b72b60:         // test re tbasic5 were intended to exercise Cloudscape's
1:1b72b60:         // stored prepared statements. This is not supported in Derby
1:1b72b60:         // it also does some drop statistics, but there are already 
1:1b72b60:         // other tests that do this. So on to tbasic6.
1:1b72b60:         
1:1b72b60:         s.executeUpdate("create table tbasic6 " +
1:1b72b60:                 "(i int generated always as identity," +
1:1b72b60:                 " j varchar(10))");
1:1b72b60:         s.executeUpdate("create index tbasic6_i on tbasic6(i)");
1:1b72b60:         s.executeUpdate("create index tbasic6_j on tbasic6(j)");
1:1b72b60:         s.executeUpdate("create index tbasic6_ji on tbasic6(j,i)");
1:1b72b60:         char[] alphabet = {'a','b','c','d','e','f','g','h','i'};
1:1b72b60:         for (int i=0; i<alphabet.length-1 ; i++)
1:1b72b60:             s.executeUpdate("insert into tbasic6 " +
1:1b72b60:                     "values (default, '" + alphabet[i] + "')");
1:1b72b60:         for (int i=0; i<alphabet.length ; i++)
1:1b72b60:             s.executeUpdate("insert into tbasic6 " +
1:1b72b60:                     "values (default, '" + alphabet[i] + "')");
1:1b72b60:         for (int i=0; i<alphabet.length-1 ; i++)
1:1b72b60:             s.executeUpdate("insert into tbasic6 " +
1:1b72b60:                     "values (default, '" + alphabet[i] + "')");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TBASIC6','TBASIC6_J')");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TBASIC6',NULL)");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'TBASIC6%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC6_I","numunique= 25 numrows= 25","1"},
1:1b72b60:                 {"TBASIC6_J","numunique= 9 numrows= 25","1"},
1:1b72b60:                 {"TBASIC6_JI","numunique= 25 numrows= 25","2"},
1:1b72b60:                 {"TBASIC6_JI","numunique= 9 numrows= 25","1"}});
1:1b72b60: 
1:1b72b60:         s.executeUpdate("delete from TBASIC6");
1:1b72b60:         // make the 17th row the same as the 16th;
1:1b72b60:         // make sure when we switch to the next group fetch
1:1b72b60:         // we handle the case correctly.
1:1b72b60:         for (int i=0; i<17 ; i++)
1:1b72b60:             s.executeUpdate("insert into tbasic6 values (default, 'a')");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','TBASIC6',NULL)");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'TBASIC6%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"TBASIC6_I","numunique= 17 numrows= 17","1"},
1:1b72b60:                 {"TBASIC6_J","numunique= 1 numrows= 17","1"},
1:1b72b60:                 {"TBASIC6_JI","numunique= 1 numrows= 17","1"},
1:1b72b60:                 {"TBASIC6_JI","numunique= 17 numrows= 17","2"}});
1:1b72b60:         s.executeUpdate("drop table tbasic6");
1:1b72b60:         
1:1b72b60:         // table with no rows.
1:1b72b60:         s.executeUpdate("create table et (x int, y int)");
1:1b72b60:         s.executeUpdate("create index etx on et(x)");
1:1b72b60:         s.executeUpdate("create index ety on et(y)");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','ET','ETX')");
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','ET',NULL)");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname like 'ET%' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertEmpty(statsrs);
1:1b72b60:         s.executeUpdate("drop table et");
1:1b72b60:         
1:1b72b60:         // tests for nulls.
1:1b72b60:         s.executeUpdate("create table null_table (x int, y varchar(2))");
1:1b72b60:         s.executeUpdate("create index nt_x on null_table(x desc)");
1:1b72b60:         for (int i=1; i<4 ; i++)
1:1b72b60:             s.executeUpdate("insert into null_table " +
1:1b72b60:                     "values (" + i + ", '" + alphabet[i-1] + "')");
1:1b72b60:         for (int c=0; c<2 ; c++)
1:1b72b60:         {
1:1b72b60:             for (int i=1; i<4 ; i++)
1:1b72b60:                 s.executeUpdate("insert into null_table " +
1:1b72b60:                         "values (null, '" + alphabet[i-1] + "')");
1:1b72b60:         }
1:1b72b60:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:1b72b60:                 "('APP','NULL_TABLE',NULL)");
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname = 'NT_X' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"NT_X","numunique= 9 numrows= 9","1"}});
1:1b72b60:         // try composite null keys (1,null) is unique from (1,null)
1:1b72b60:         // as is (null,1) from (null,1)
1:1b72b60:         s.executeUpdate("drop index nt_x");
1:1b72b60:         s.executeUpdate("create index nt_yx on null_table(y,x)");
1:1b72b60:         // the first key y has 3 unique values.
1:1b72b60:         // the second key y,x has 9 unique values because of nulls.
1:1b72b60:         statsrs = s.executeQuery(
1:1b72b60:                 "select indexname, stats, ncols from showstats " +
1:1b72b60:                 "where indexname = 'NT_YX' " +
1:1b72b60:                 "order by indexname, stats, ncols");
1:1b72b60:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:1b72b60:                 {"NT_YX","numunique= 3 numrows= 9","1"},
1:1b72b60:                 {"NT_YX","numunique= 9 numrows= 9","2"}});
1:1b72b60:     }
1:1b72b60:     
1:1b72b60:     // drop any tables created during testBasic
1:1b72b60:     protected void tearDown() throws Exception {
1:1b72b60:         Statement s = createStatement();
1:1b72b60:         try {
1:1b72b60:             s.execute("drop table tbasic1");
1:1b72b60:             s.execute("drop table tbasic2");
1:1b72b60:             s.execute("drop table tbasic3");
1:1b72b60:             s.execute("drop table tbasic4");
1:1b72b60:             s.execute("drop table tbasic6");
1:1b72b60:             s.execute("drop table et");
1:1b72b60:             s.execute("drop table null_table");
1:1b72b60:         } catch (SQLException sqle) {
1:1b72b60:             // if it doesn't work, never mind, we'll assume the
1:1b72b60:             // cleanDatabaseSetup will deal with it.
1:1b72b60:         }
1:1b72b60:         s.close();
1:1b72b60:         super.tearDown();
1:1b72b60:     }
1:02f8e49: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:             new BaseTestSuite(SelectivityTest.class), props, true);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:b1c9bd2
/////////////////////////////////////////////////////////////////////////
1:                         "order by indexname, stats");
1:                         {"T1_TWENTY_HUNDRED","numunique= 2000 numrows= 4000","2"},
1:                         {"T1_TWO_TWENTY","numunique= 2 numrows= 4000","1"},
1:                         {"T1_TWO_TWENTY","numunique= 40 numrows= 4000","2"}});
1:                         "where indexname like 'T2%' order by indexname, stats");
1:                         {"T2_TWENTY_HUNDRED","numunique= 2000 numrows= 4000","2"},
1:                         {"T2_TWO_TWENTY","numunique= 2 numrows= 4000","1"},
1:                         {"T2_TWO_TWENTY","numunique= 40 numrows= 4000","2"}});
1:                         "where indexname like 'T3%' order by indexname, stats");
1:                         {"T3_TWENTY_HUNDRED","numunique= 2000 numrows= 4000","2"},
1:                         {"T3_TWO_TWENTY","numunique= 2 numrows= 4000","1"},
1:                         {"T3_TWO_TWENTY","numunique= 40 numrows= 4000","2"}});
/////////////////////////////////////////////////////////////////////////
1:                 "where indexname = 'TBASIC2_CH_DT' order by indexname, stats");
/////////////////////////////////////////////////////////////////////////
1:                 "where indexname = 'TBASIC2_DT_VC' " +
1:                 "order by indexname, stats, ncols");
commit:862666b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1: import org.apache.derbyTesting.junit.SQLUtilities;
/////////////////////////////////////////////////////////////////////////
1:         RuntimeStatisticsParser rtsp = 
1:               SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertFalse(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWO"));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWENTY"));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_22"));
1:         // 'rc should be divided using selectivity. cost should be way different'
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEST", "TEST_ID"));
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_102"));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEST", "TEST_ID"));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEST", "TEST_ID"));
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TEST',NULL)");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TEMPLATE',NULL)");
/////////////////////////////////////////////////////////////////////////
1:         RuntimeStatisticsParser rtsp = 
1:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWO"));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWENTY"));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_22"));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWO"));
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWENTY"));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWENTY"));
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TEMPLATE',NULL)");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TEST',NULL)");
/////////////////////////////////////////////////////////////////////////
1:         RuntimeStatisticsParser rtsp = 
1:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_102"));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_102"));
/////////////////////////////////////////////////////////////////////////
1:         RuntimeStatisticsParser rtsp = 
1:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 2, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:         assertTrue(rtsp.findString(
1:                 "Hash Scan ResultSet for T3 using index T3_TWO_TWENTY", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_HUNDRED"));
1:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_HUNDRED"));
1:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_HUNDRED"));
1:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         // The error is that the types must be comparable.
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T2", "T2_HUNDRED"));
1:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_HUNDRED"));
1:         assertTrue(rtsp.findString("Bit set of columns fetched=All", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T3", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:         assertTrue(rtsp.findString(
1:                 "Hash Scan ResultSet for T3 using index T3_TWO_TWENTY", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:         assertTrue(rtsp.findString(
1:                 "Hash Scan ResultSet for T3 using index T3_TWO_TWENTY", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.findString(
1:                 "Hash Scan ResultSet for T3 using index T3_TWO_TWENTY", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_TWO_TWENTY"));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_TWO_TWENTY"));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_TWO_TWENTY"));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T3", "T3_TWO_TWENTY"));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 1}", 1));
1:         assertTrue(rtsp.findString("Table Scan ResultSet for T1", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={0, 3}", 1));
1:         assertTrue(rtsp.findString("Hash Scan ResultSet for T2", 1));
1:         assertTrue(rtsp.findString("Bit set of columns fetched={1, 2, 3}", 1));
/////////////////////////////////////////////////////////////////////////
1:         RuntimeStatisticsParser rtsp = 
1:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_TWO_TWENTY"));
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_TWENTY_HUNDRED"));
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:                 "('APP','T1',NULL)");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','T2',NULL)");
/////////////////////////////////////////////////////////////////////////
1:         RuntimeStatisticsParser rtsp = 
1:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedHashJoin());
/////////////////////////////////////////////////////////////////////////
1:         RuntimeStatisticsParser rtsp = 
1:                 SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("COMPLEX", "COMPLEXIND"));
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TEMPLATE", "TEMPLATE_TWO"));
commit:9f4fc5a
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
0:                 "('APP','T1', NULL)");
commit:1b72b60
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         
1:         Properties props = new Properties();
1:         // first disable the automatic statistics gathering so we get
1:         // clean statistics
1:         // then switch the statement cache size to 0, so that doesn't
1:         // interfere and previous tests' left-overs are gone.
1:         props.setProperty("derby.storage.indexStats.auto", "false");
1:         props.setProperty("derby.language.statementCacheSize", "0");
1:         // set the props, and boot the db
1:         Test test = new DatabasePropertyTestSetup(
0:             new TestSuite(SelectivityTest.class), props, true);
1:         
1:         return new CleanDatabaseTestSetup(test) {
1:             protected void decorateSQL(Statement s) throws SQLException
1:             {        
/////////////////////////////////////////////////////////////////////////
1:                 s.executeUpdate("create view showstats as "
/////////////////////////////////////////////////////////////////////////
1:                         .executeQuery("select indexname, stats, ncols from showstats order by indexname, stats, createtime, ncols");
/////////////////////////////////////////////////////////////////////////
1:                         {"TEST_ID","numunique= 4000 numrows= 4000","1"},
1:                         });
1:                 s.executeUpdate("create table t1 " +
1:                 		"(id int generated always as identity, " +
1:                 		"two int, twenty int, hundred varchar(3))");
1:                 s.executeUpdate("insert into t1 (hundred, twenty, two) " +
1:                 		"select CAST(CHAR(hundred.x) AS VARCHAR(3)), " +
1:                 		"twenty.x, two.x from hundred, twenty, two");
1:                 s.executeUpdate("create table t2 " +
1:                 		"(id int generated always as identity, " +
1:                 		"two int, twenty int, hundred varchar(3))");
1:                 s.executeUpdate("insert into t2 (hundred, twenty, two) " +
1:                 		"select CAST(CHAR(hundred.x) AS VARCHAR(3)) , " +
1:                 		"twenty.x, two.x from hundred, twenty, two");
1:                 s.executeUpdate("create table t3 " +
1:                 		"(id int generated always as identity, " +
1:                 		"two int, twenty int, hundred varchar(3))");
1:                 s.executeUpdate("insert into t3 (hundred, twenty, two) " +
1:                 		"select CAST(CHAR(hundred.x) AS VARCHAR(3)), " +
1:                 		"twenty.x, two.x from hundred, twenty, two");
1:                 s.executeUpdate("create index t1_hundred on t1(hundred)");
1:                 s.executeUpdate("create index t1_two_twenty on t1(two,twenty)");
1:                 s.executeUpdate("create index " +
1:                 		"t1_twenty_hundred on t1(twenty, hundred)");
1:                 s.executeUpdate("create index t2_hundred on t2(hundred)");
1:                 s.executeUpdate("create index t2_two_twenty on t2(two,twenty)");
1:                 s.executeUpdate("create index t2_twenty_hundred on t2(twenty, hundred)");
1:                 s.executeUpdate("create index t3_hundred on t3(hundred)");
1:                 s.executeUpdate("create index t3_two_twenty on t3(two,twenty)");
1:                 s.executeUpdate("create index t3_twenty_hundred on t3(twenty, hundred)");
1:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                         "('APP','T1',null)");
1:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                         "('APP','T2',null)");
1:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                         "('APP','T3',null)");
1: 
1:                 statsrs = s.executeQuery(
1:                         "select indexname, stats, ncols from showstats " +
1:                         "where indexname like 'T1%' " +
0:                         "order by indexname");
1:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:                         {"T1_HUNDRED","numunique= 100 numrows= 4000","1"},
0:                         {"T1_TWENTY_HUNDRED","numunique= 2000 numrows= 4000","2"},
1:                         {"T1_TWENTY_HUNDRED","numunique= 20 numrows= 4000","1"},
0:                         {"T1_TWO_TWENTY","numunique= 40 numrows= 4000","2"},
0:                         {"T1_TWO_TWENTY","numunique= 2 numrows= 4000","1"}});
1:                 statsrs = s.executeQuery(
1:                         "select indexname, stats, ncols from showstats " +
0:                         "where indexname like 'T2%' order by indexname");
1:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:                         {"T2_HUNDRED","numunique= 100 numrows= 4000","1"},
0:                         {"T2_TWENTY_HUNDRED","numunique= 2000 numrows= 4000","2"},
1:                         {"T2_TWENTY_HUNDRED","numunique= 20 numrows= 4000","1"},
0:                         {"T2_TWO_TWENTY","numunique= 40 numrows= 4000","2"},
0:                         {"T2_TWO_TWENTY","numunique= 2 numrows= 4000","1"}});
1:                 statsrs = s.executeQuery(
1:                         "select indexname, stats, ncols from showstats " +
0:                         "where indexname like 'T3%' order by indexname");
1:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:                         {"T3_HUNDRED","numunique= 100 numrows= 4000","1"},
0:                         {"T3_TWENTY_HUNDRED","numunique= 2000 numrows= 4000","2"},
1:                         {"T3_TWENTY_HUNDRED","numunique= 20 numrows= 4000","1"},
0:                         {"T3_TWO_TWENTY","numunique= 40 numrows= 4000","2"},
0:                         {"T3_TWO_TWENTY","numunique= 2 numrows= 4000","1"}});
1:                 
1:                 s.executeUpdate("create table scratch_table" +
1:                         "(id int, two int, twenty int, hundred int)");
1:                 s.executeUpdate("insert into scratch_table select " +
1:                         "id, two, twenty, CAST(CHAR(hundred) AS INTEGER) " +
1:                         "from t1");
1:                 s.executeUpdate("create index st_all on scratch_table" +
1:                         "(two, twenty, hundred)");
1:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                         "('APP','SCRATCH_TABLE',null)");
1:                 
1:                 s.executeUpdate("create table complex" +
1:                         "(id int generated always as identity, " +
1:                         "two int, twenty int, hundred int, a int, b int)");
1:                 s.executeUpdate(
1:                         "insert into complex (two, twenty, hundred, a, b) " +
1:                         "select two.x, twenty.x, hundred.x, two.x, twenty.x " +
1:                         "from two, twenty, hundred");
1:                 s.executeUpdate("create index complexind on complex" +
1:                         "(two, twenty, hundred, a, b)");
1:                 s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                         "('APP','COMPLEX',null)");
1: 
1:     
1:     public void testSingleColumnSelectivity() throws SQLException {
1:         // choose whatever plan you want but the row estimate should be.
1:         //(n * n) * 0.5
1:         // join on two, template inner, all rows.
1:         Connection conn = getConnection();
1:         Statement s = createStatement();
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TEMPLATE',NULL)");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TEST',NULL)");
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         s.executeQuery("select template.id from --DERBY-PROPERTIES joinOrder=fixed\n" 
1:                 + "test, template where test.two = template.two").close();
1:         checkEstimatedRowCount(conn,8020012.5);
1:         
1:         // choose hash join. Selectivity should be the same
1:         // join on two. template inner, hash join
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=hash \n" +
1:                 "where test.two = template.two").close();
1:         checkEstimatedRowCount(conn,8020012.5);
1:         
1:         // choose NL join, no index. Selectivity should be the same
1:         // join on two. template inner, NL, no index, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=null \n" +
1:                 "where test.two = template.two").close();
1:         checkEstimatedRowCount(conn,8020012.5);
1:         
1:         // choose NL join, index template_two. Selectivity should be the same
1:         // join on two. template inner, NL, index=two, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_two \n" +
1:                 "where test.two = template.two").close();
1:         checkEstimatedRowCount(conn,8020012.5);
1:         
1:         // do joins on 20
1:         // first NL
1:         // join on twenty. template inner, NL, index=template_twenty, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_twenty \n" +
1:                 "where test.twenty = template.twenty").close();
1:         // Rowcount should be same as testSingleColumnSelectivityHash
1:         checkEstimatedRowCount(conn,802001.25);
1:         
1:         // join on 20 but use index 20_2
1:         // cost as well as selectivity should be divided using selectivity
1:         // cost should same as template_twenty, or just a shade more...
1:         // join on twenty. template inner, NL, index=template_22, all rows
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_22 \n" +
1:                 "where test.twenty = template.twenty").close();
1:         checkEstimatedRowCount(conn,802001.25);
1:         
1:         // join on twenty but no index
1:         // note: the original test had this comment:
0:         // rc should be divided using selectivity. cost should be way different
1:         // however, it seems the ec is identical.
1:         // join on twenty, template inner, NL, index=null, all rows
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=null \n" +
1:                 "where test.twenty = template.twenty").close();
1:         checkEstimatedRowCount(conn,802001.25);
1:         
1:         // still single column, try stuff on 100 but with extra qualification
1:         // on outer table.
1:         // row count is 100 * 4000 * 0.01 = 4000
1:         // join on hundred. 
1:         // template inner, NL, index=template_102, 100 rows from outer
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_102 \n" +
1:                 "where test.hundred = template.hundred and test.id <= 100").close();
1:         // note: original cloudscape result was expecting 3884.85 here.
1:         checkEstimatedRowCount(conn,3924.9);
1:         
1:         // join on hundred. 
1:         // template inner, NL, index=null, 100 rows from outer
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=null \n" +
1:                 "where test.hundred = template.hundred and test.id <= 100").close();
1:         checkEstimatedRowCount(conn,3924.9);
1:         
1:         // join on hundred. 
1:         // template inner, hash, index=null, 100 rows from outer.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=hash, " +
1:                 "index=null \n" +
1:                 "where test.hundred = template.hundred and test.id <= 100").close();
1:         checkEstimatedRowCount(conn,3924.9);
1:     }
1:     
1:     public void testMultiPredicate() throws SQLException {
1:         // multi predicate tests.
1:         // first do a oin involving twenty and two
1:         // forde use of a simngle column index to do the join
1:         // the row count should involve statistics from both 10 and 2 though...
1:         
1:         // row count should 4K * 4K * 1/40 = 400,000
1:         // cost doesn't show up in output but should depend on the index
1:         // being used (verify by hand before checking in.)
1:         setAutoCommit(false);
1:         Connection conn = getConnection();
1:         Statement s = createStatement();
1:         
1:         // join on twenty/two. template inner, hash, index=null, all rows.
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=hash, " +
1:                 "index=null \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,401000.625);
1:         
1:         // join on twenty/two. template inner, NL, index=template_two, all rows
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_two \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,401000.625);
1:         
1:         // join on twenty/two. 
1:         // template inner, NL, index=template_twenty, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_twenty \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,401000.625);
1:         
1:         // join on twenty/two. template inner, NL, index=template_22, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_22 \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,401000.625);
1:         
1:         // multi predicate tests continued
1:         // drop index twenty, two -- use above predicates
1:         // should be smart enough to figure out the selectivity by
1:         // combining twenty and two.
1:         s.executeUpdate("drop index template_22");
1:         
1:         // join on twenty/two. index twenty_two dropped. 
1:         // template inner, hash, index=null, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=hash, " +
1:                 "index=null \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,401000.625);
1:         
1:         // join on twenty/two. index twenty_two dropped. 
1:         // template inner, NL, index=template_two, all rows.'
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_two \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,401000.625);
1:         
1:         // join on twenty/two. index twenty_two dropped. 
1:         // template inner, NL, index=template_twenty, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=hash, " +
1:                 "index=template_twenty \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,401000.625);
1:         
1:         s.executeUpdate("drop index template_two");
1:         
1:         // we only have index template_twenty
1:         // for the second predicate we should use 0.1 instead of 0.5
1:         // thus reducing earlier row count by a factor of 5
1:         // 80,000 instead of 400,000
1:         
1:         // join on twenty/two. index twenty_two and two dropped. 
1:         // template inner, NL, index=null, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=null \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,80200.12500000001);
1:         
1:         // join on twenty/two. index twenty_two and two dropped. 
1:         // template inner, NL, index=template_twenty, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_twenty \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,80200.12500000001);
1:         
1:         // now drop index template_twenty
1:         // selectivity should become 0.1 * 0.1 = 0.01
1:         // 16 * 10^6 * .01 = 160,000
1:         
1:         s.executeUpdate("drop index template_twenty");
1:         
1:         // join on twenty/two. all indexes dropped.
1:         // template inner, NL, index=null, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=null \n" +
1:                 "where test.twenty = template.twenty " +
1:                 "and test.two = template.two").close();
1:         checkEstimatedRowCount(conn,160400.25000000003);
1:         rollback();
1:     } 
1:     
1:     public void testTwoWayJoins() throws SQLException {
1:         setAutoCommit(false);
1:         Connection conn = getConnection();
1:         Statement s = createStatement();
1:         
1:         // throw in aditional predicates
1:         // see that the optimizer does the right thing
1:         
1:         // index on template_102. join on hundred, constant predicate on two. 
1:         // should be able to use statistics for hundred_two to com up with
1:         // row estimate.
1:         
1:         // selectivity should be 0.01 * 0.5 = 0.005
1:         // row count is 16*10^6 * 0.005 = 8*10^4.
1:         
1:         // join on hundred. constant pred on two. NL, index=null, all rows.
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=null \n" +
1:                 "where test.hundred = template.hundred " +
1:                 "and 1 = template.two").close();
1:         checkEstimatedRowCount(conn,80200.125);
1:         
1:         // just retry above query with different access paths
1:         // row count shouldn't change!
1:         // join on hundred. constant pred on two. 
1:         // NL, index=template_102, all rows.
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_102 \n" +
1:                 "where test.hundred = template.hundred " +
1:                 "and 1 = template.two").close();
1:         checkEstimatedRowCount(conn,80200.125);
1:         
1:         // hundred and twenty
1:         // we can use statistics for 100,2 to get selectivity for 100 and
1:         // twenty and twenty to get selectivity for 20
1:         // selectivity should 0.01 * 0.05 = 0.0005 -> 80,000
1:         // join on hundred. constant pred on twenty. 
1:         // NL, index=null, all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=null \n" +
1:                 "where test.hundred = template.hundred " +
1:                 "and 1 = template.twenty").close();
1:         checkEstimatedRowCount(conn,8020.0125);
1:         
1:         // 'join on hundred. constant pred on twenty. 
1:         // NL, index=template_102 all rows.
1:         s.executeQuery("select template.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "test, template --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                 "index=template_102 \n" +
1:                 "where test.hundred = template.hundred " +
1:                 "and 1 = template.twenty").close();
1:         checkEstimatedRowCount(conn,8020.0125);
1:     }
1:     
1:     public void testThreeWayJoins() throws SQLException {
1:         setAutoCommit(false);
1:         Connection conn = getConnection();
1:         Statement s = createStatement();
1:         
1:         // t1 x t2 yields 8000 rows.
1:         // x t3 yields 8*4 * 10^6 /2 = 16*10^6
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','T1',NULL)");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','T2',NULL)");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','T3',NULL)");
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, t2, t3 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t1.twenty = t2.twenty and " +
1:                 "t2.two = t3.two").close();
1:         checkEstimatedRowCount(conn,1.606007503125E7);
1:         
1:         // t1 x t2 -> 16 * 10^4.
1:         // x t3    -> 32 * 10^7
1:         // additional pred -> 32 * 10^5
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, t2, t3 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two and " +
1:                 "t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         // variations on above query; try different join strategies
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, t2, t3 --DERBY-PROPERTIES joinStrategy=hash \n" +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, t2, t3 --DERBY-PROPERTIES joinStrategy=nestedLoop \n" +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, t2 --DERBY-PROPERTIES joinStrategy=hash \n, t3 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, t2 --DERBY-PROPERTIES joinStrategy=hash \n, t3 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         // duplicate predicates; this time t1.hundred=?
1:         // will show up twice when t1 is optimized at the end
1:         // selectivity should be same as above
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t2, t3, t1 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         // variations on above query; try different join strategies
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t3, t2, t1 --DERBY-PROPERTIES joinStrategy=hash \n" +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t3, t2, t1 --DERBY-PROPERTIES joinStrategy=nestedLoop \n" +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t2, t3 --DERBY-PROPERTIES joinStrategy=nestedLoop \n, t1 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t3, t2 --DERBY-PROPERTIES joinStrategy=hash \n, t1 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         // some more variations on the above theme
1:         // some constant predicates thrown in.
1:         // remember hundred is a char column
1:         // -- for some reason if you give the constant 
1:         // as a numeric argument it doesn't recognize that 
1:         // as a constant start/stop value for the index 
0:         // The errir is that the types must be comparable.
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t2, t3, t1 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred " +
1:                 "and t1.hundred='1'").close();
1:         checkEstimatedRowCount(conn,30458.025);
1:         
1:         // we have t1.100=t2.100 and t1.100=t3.100, so 
1:         // t2.100=t3.100 is redundant. 
1:         // row count shouldn't factor in the redundant predicate.
1:         // row count should be 3200000.0
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t2, t3, t1 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t1.hundred = t3.hundred " +
1:                 "and t2.hundred = t3.hundred").close();
1:         checkEstimatedRowCount(conn,3212015.00625);
1:         
1:         // slightly different join predicates-- use composite stats.
1:         // t1 x t2            --> 16 * 10.4.
1:         //         x t3       --> 16 * 10.4 * 4000 * 1/40 = 16*10.6
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t2, t3, t1 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t2.twenty = t3.twenty").close();
1:         checkEstimatedRowCount(conn,1.606007503125E7);
1:         
1:         // same as above but muck around with join order.
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, t2, t3 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t2.twenty = t3.twenty").close();
1:         checkEstimatedRowCount(conn,1.606007503125E7);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t2, t1, t3 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t2.twenty = t3.twenty").close();
1:         checkEstimatedRowCount(conn,1.606007503125E7);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, t3, t2 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t2.twenty = t3.twenty").close();
1:         checkEstimatedRowCount(conn,1.606007503125E7);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t3, t2, t1 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t2.twenty = t3.twenty").close();
1:         checkEstimatedRowCount(conn,1.606007503125E7);
1:         
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t3, t1, t2 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t2.twenty = t3.twenty").close();
1:         checkEstimatedRowCount(conn,1.606007503125E7);
1:         
1:         // and just for fun, what would we have gotten without statistics.
1:         s.executeQuery("select t1.id from " +
1:                 "--DERBY-PROPERTIES useStatistics=false, joinOrder=fixed \n" + 
1:                 "t3, t1, t2 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t2.two = t3.two " +
1:                 "and t2.twenty = t3.twenty").close();
1:         checkEstimatedRowCount(conn,6.4240300125000015E7);
1:     }
1:     
1:     public void testScratch() throws SQLException {
1:         // make sure we do a good job of stats on 1/3
1:         setAutoCommit(false);
1:         Connection conn = getConnection();
1:         Statement s = createStatement();
1:         
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','T1',NULL)");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','SCRATCH_TABLE',NULL)");
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         // Note: The original test did the first query *after* the following:
1:         // since the statistics (rowEstimates) are not precise, force a 
1:         // checkpoint to force out all the row counts to the container header,
1:         // and for good measure do a count which will update the row counts 
1:         // exactly.
1:         // s.executeUpdate("CALL SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE()");
1:         // But if that's executed, the estimatedRowCount becomes: 2582648.45
1:         // Without the checkpoint, the following select counts are unnecessary.
1:         // assertTableRowCount("T1", 4000);
1:         // assertTableRowCount("SCRATCH_TABLE", 4000);
1:         
1:         // preds are on columns 1 and 3
1:         // should use default stats for 100 (0.1) and 0.5 for two
1:         
1:         // 16*10.6 * 5*10.-2 = 80*10.4
1:         
1:         s.executeQuery("select s.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, scratch_table s " +
1:                 "where t1.two = s.two " +
1:                 "and s.hundred = CAST(CHAR(t1.hundred) AS INTEGER)").close();
1:         checkEstimatedRowCount(conn,802001.25);
1:         
1:         // preds are on column 2.
1:         // 0.1 -> 16*10.5
1:         s.executeQuery("select s.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, scratch_table s " +
1:                 "where t1.twenty = s.twenty").close();
1:         checkEstimatedRowCount(conn,1604002.5);
1:         
1:         // preds are on column 2,3.
1:         // 0.01 -> 16*10.4
1:         s.executeQuery("select s.id from " +
1:                 "--DERBY-PROPERTIES joinOrder=fixed \n" + 
1:                 "t1, scratch_table s " +
1:                 "where t1.twenty = s.twenty " +
1:                 "and s.hundred = CAST(CHAR(t1.hundred) AS INTEGER)").close();
1:         checkEstimatedRowCount(conn,160400.2500000);
1:     }
1:     
1:     public void testStatMatcher() throws SQLException {
1:         // test of statistics matcher algorithm; make sure that we choose the
1:         // best statistics (the weight stuff in predicatelist)
1:         
1:         setAutoCommit(false);
1:         Connection conn = getConnection();
1:         Statement s = createStatement();
1:         
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         // 2,20,100
1:         s.executeQuery("select t1.id from t1, t2 " +
1:                 "where t1.two = t2.two " +
1:                 "and t1.twenty = t2.twenty " +
1:                 "and t1.hundred = t2.hundred").close();
1:         checkEstimatedRowCount(conn,4010.00625);
1:         
1:         // now muck around with the order of the predicates
1:         // 2,100,20
1:         s.executeQuery("select t1.id from t1, t2 " +
1:                 "where t1.two = t2.two " +
1:                 "and t1.hundred = t2.hundred " +
1:                 "and t1.twenty = t2.twenty").close();
1:         checkEstimatedRowCount(conn,4010.00625);
1:         
1:         // 100,20,2
1:         s.executeQuery("select t1.id from t1, t2 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t1.twenty = t2.twenty " +
1:                 "and t1.two = t2.two").close();
1:         checkEstimatedRowCount(conn,4010.00625);
1:         
1:         // 100,2,20
1:         s.executeQuery("select t1.id from t1, t2 " +
1:                 "where t1.hundred = t2.hundred " +
1:                 "and t1.two = t2.two " +
1:                 "and t1.twenty = t2.twenty").close();
1:         checkEstimatedRowCount(conn,4010.00625);
1:         
1:         s.executeQuery("select t1.id from t1, t2 " +
1:                 "where t1.twenty = t2.twenty " +
1:                 "and t1.hundred = t2.hundred " +
1:                 "and t1.two = t2.two").close();
1:         checkEstimatedRowCount(conn,4010.00625);
1:         
1:         s.executeQuery("select t1.id from t1, t2 " +
1:                 "where t1.twenty = t2.twenty " +
1:                 "and t1.two = t2.two " +
1:                 "and t1.hundred = t2.hundred").close();
1:         checkEstimatedRowCount(conn,4010.00625);
1:     }
1:     
1:     // Beetle was the bug system for Cloudscape, the forerunner
1:     // of Derby. The bug report described a query that was hitting an Error:
1:     // XJ001: Java exception: '2 >=2: java.lang.ArrayIndexOutOfBoundsException
1:     // on a specific query; when running the same query with DERBY-PROPERTIES
1:     // useStatistics=false the same query worked correctly.
1:     // The fix is in org.apache.derby.impl.sql.compile.PredicateList
1:     // referencing beetle 4321.
1:     public void testBeetle4321() throws SQLException {
1:         // test of statistics matcher algorithm; make sure that we choose the
1:         // best statistics (the weight stuff in predicatelist)
1:         
1:         setAutoCommit(false);
1:         Connection conn = getConnection();
1:         Statement s = createStatement();
1:         
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','COMPLEX',NULL)");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TEMPLATE',NULL)");
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         s.executeQuery("select t10.two from complex t10, template t20 " +
1:                 "where t10.two = 1 " +
1:                 "and t10.hundred = 2 " +
1:                 "and t10.a = 2 " +
1:                 "and t10.b = 2").close();
1:         checkEstimatedRowCount(conn,7945.920000000);
1:     }
1:     
1:     public void testBasic() throws SQLException {
1:         // basic test for update statistics; make sure that statistics with
1:         // correct values are created and dropped and such.
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         // first on int, multi-column
1:         s.executeUpdate("create table tbasic1 " +
1:                 "(c1 int generated always as identity, c2 int, c3 int)");
1:         for (int i=1; i<5 ; i++)
1:         {
1:             for (int j=1 ; j<3 ; j++)
1:             {
1:                 for (int c=0; c<2 ; c++)
1:                     s.executeUpdate(
1:                         "insert into tbasic1 values " +
1:                         "(default, " + i + ", " + j + ")");
1:             }
1:         }
1:         
1:         // create index should automatically create stats. 
1:         s.executeUpdate("create index t1_c1c2 on tbasic1 (c1, c2)");
1:         ResultSet statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'T1_C1C2%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"T1_C1C2","numunique= 16 numrows= 16","1"},
1:                 {"T1_C1C2","numunique= 16 numrows= 16","2"}});
1:         // index dropped stats should be dropped.
1:         s.executeUpdate("drop index t1_c1c2");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'T1_C1C2%' order by indexname");
1:         JDBC.assertEmpty(statsrs);
1:         
1:         // second part of the test.
1:         // check a few extra types.
1:         s.executeUpdate("create table tbasic2 " +
1:                 "(i int not null, " +
1:                 "vc varchar(32) not null, " +
1:                 "dt date, ch char(20), " +
1:                 "constraint pk primary key (i, vc))");
1:         s.executeUpdate("create index tbasic2_i on tbasic2(i)");
1:         s.executeUpdate("create index tbasic2_ch_dt on tbasic2(ch, dt)");
1:         s.executeUpdate("create index tbasic2_dt_vc on tbasic2(dt, vc)");
1:         // do normal inserts. 
1:         s.executeUpdate(
1:                 "insert into tbasic2 values (1, 'one', '2001-01-01', 'one')");
1:         s.executeUpdate(
1:                 "insert into tbasic2 values (2, 'two', '2001-01-02', 'two')");
1:         s.executeUpdate(
1:                 "insert into tbasic2 values (3, 'three', '2001-01-03', 'three')");
1:         s.executeUpdate(
1:                 "insert into tbasic2 values (1, 'two', '2001-01-02', 'one')");
1:         s.executeUpdate(
1:                 "insert into tbasic2 values (1, 'three', '2001-01-03', 'one')");
1:         s.executeUpdate(
1:                 "insert into tbasic2 values (2, 'one', '2001-01-01', 'two')");
1:         
1:         // figure out the name of the primary key's backing index
1:         statsrs = s.executeQuery(
1:                 "select conglomeratename from sys.sysconglomerates " +
1:                 "where conglomeratename like 'SQL%'");
1:         statsrs.next();
1:         String backIndName = statsrs.getString("conglomeratename");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TBASIC2','" + backIndName + "')");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'SQL%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {backIndName,"numunique= 3 numrows= 6","1"},
1:                 {backIndName,"numunique= 6 numrows= 6","2"}});
1:         
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TBASIC2','TBASIC2_I')");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname = 'TBASIC2_I' order by indexname");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC2_I","numunique= 3 numrows= 6","1"}});
1:         
1:         // do another insert then just updstat for whole table.
1:         s.executeUpdate(
1:                 "insert into tbasic2 values(2, 'three', '2001-01-03', 'two')");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TBASIC2',null)");
1:         
1:         // make sure that stats are correct.
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname = 'TBASIC2_I' order by indexname");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC2_I","numunique= 3 numrows= 7","1"}});
1:         statsrs = s.executeQuery(
1:                 "select count(*) from (select distinct i from tbasic2) t");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {{"3"}});
1:         
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
0:                 "where indexname = 'TBASIC2_CH_DT' order by indexname");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC2_CH_DT","numunique= 3 numrows= 7","1"},
1:                 {"TBASIC2_CH_DT","numunique= 7 numrows= 7","2"}});
1:         
1:         statsrs = s.executeQuery(
1:                 "select count(*) from (select distinct ch from tbasic2) t");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {{"3"}});
1:         statsrs = s.executeQuery(
1:                 "select count(*) from (select distinct ch, dt from tbasic2) t");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {{"7"}});
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
0:                 "where indexname = 'TBASIC2_DT_VC' order by indexname");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC2_DT_VC","numunique= 3 numrows= 7","1"},
1:                 {"TBASIC2_DT_VC","numunique= 3 numrows= 7","2"}});
1:         statsrs = s.executeQuery(
1:                 "select count(*) from (select distinct dt from tbasic2) t");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {{"3"}});
1:         statsrs = s.executeQuery(
1:                 "select count(*) from (select distinct dt, vc from tbasic2) t");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {{"3"}});
1:         statsrs = s.executeQuery(
1:                 "select stats, ncols from showstats " +
1:                 "where indexname like 'SQL%' order by stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"numunique= 3 numrows= 7","1"},
1:                 {"numunique= 7 numrows= 7","2"}});
1:         
1:         // delete everything from t2, do bulkinsert see what happens.
1:         assertUpdateCount(s, 7, "delete from tbasic2");
1:         
1:         // no material impact on stats
1:         // note; the test didn't actually confirm, here's the expected now
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'TBASIC2%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC2_CH_DT","numunique= 3 numrows= 7","1"},
1:                 {"TBASIC2_CH_DT","numunique= 7 numrows= 7","2"},
1:                 {"TBASIC2_DT_VC","numunique= 3 numrows= 7","1"},
1:                 {"TBASIC2_DT_VC","numunique= 3 numrows= 7","2"},
1:                 {"TBASIC2_I","numunique= 3 numrows= 7","1"}});
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TBASIC2',null)");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'TBASIC2%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertEmpty(statsrs);
1:         
1:         // Note: the original (Cloudscape) test did a 'bulkinsert'.
1:         // this is now only possible internally, and is used in
1:         // the SYSCS_IMPORT_DATA system procedures.
1:         // Possibly this test can be added onto by moving the
1:         // value intended to be inserted into a data file, and calling
1:         // SYSCS_UTIL.SYSCS_IMPORT_DATA using that.
1:         // The row inserted was:
1:         //        "values (2, 'one', '2001-01-01', 'two')");
1:         // subsequently, there was a bulk insert-replace, this is
1:         // no longer supported. We could update the row.
1:         // the replacement was of row:
1:         //        "(2, 'one', '2001-01-01', 'two'), " +
1:         // by
1:         //        "(1, 'one', '2001-01-01', 'two')");
1:         s.executeUpdate("drop table tbasic2");
1:         
1:         // various alter table operations to ensure correctness.
1:         // 1. add and drop constraint.
1:         s.executeUpdate("create table tbasic3 " +
1:                 "(x int not null generated always as identity," +
1:                 " y int not null, z int)");
1:         s.executeUpdate(
1:                 "insert into tbasic3 (y,z) values " +
1:                 "(1,1),(1,2),(1,3),(1,null),(2,1),(2,2),(2,3),(2,null)");
1:         // first alter table to add primary key;
1:         s.executeUpdate("alter table tbasic3 " +
1:                 "add constraint pk_tbasic3 primary key (x,y)");
1:         statsrs = s.executeQuery(
1:                 "select conglomeratename from sys.sysconglomerates " +
1:                 "where conglomeratename like 'SQL%'");
1:         statsrs.next();
1:         backIndName = statsrs.getString("conglomeratename");
1:         statsrs = s.executeQuery(
1:                 "select stats, ncols from showstats " +
1:                 "where indexname like '" + backIndName + "' " +
1:                 "order by stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"numunique= 8 numrows= 8","1"},
1:                 {"numunique= 8 numrows= 8","2"}});
1:         // now drop the constraint
1:         s.executeUpdate("alter table tbasic3 drop constraint pk_tbasic3");
1:         statsrs = s.executeQuery(
1:                 "select stats, ncols from showstats " +
1:                 "where indexname like '" + backIndName + "' " +
1:                 "order by stats, ncols");
1:         JDBC.assertEmpty(statsrs);
1:         
1:         // try compress with tons of rows. you can never tell 
1:         // what a few extra pages can do :)
1:         for (int i=0; i<9 ; i++)
1:             s.executeUpdate("insert into tbasic3(y,z) select y,z from tbasic3");
1:         statsrs = s.executeQuery("select count(*) from tbasic3");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {{"4096"}});
1:         s.executeUpdate("create index tbasic3_xy on tbasic3(x,y)");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'TBASIC3_XY%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC3_XY","numunique= 4096 numrows= 4096","1"},
1:                 {"TBASIC3_XY","numunique= 4096 numrows= 4096","2"}});
1:         s.executeUpdate("delete from tbasic3 where z is null");
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_COMPRESS_TABLE" +
1:                 "('APP', 'TBASIC3', 0)");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'TBASIC3_XY%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC3_XY","numunique= 3072 numrows= 3072","1"},
1:                 {"TBASIC3_XY","numunique= 3072 numrows= 3072","2"}});
1:         s.executeUpdate("drop table tbasic3");
1:         
1:         s.executeUpdate("create table tbasic4 " +
1:                 "(x int, y int, z int)");
1:         s.executeUpdate("insert into tbasic4 values (1,1,1)");
1:         s.executeUpdate("insert into tbasic4 values (1,2,1)");
1:         s.executeUpdate("insert into tbasic4 values (1,1,2)");
1:         
1:         s.executeUpdate("create index tbasic4_x on tbasic4(x)");
1:         s.executeUpdate("create index tbasic4_xy on tbasic4(x,y)");
1:         s.executeUpdate("create index tbasic4_yz on tbasic4(y,z)");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'TBASIC4%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC4_X","numunique= 1 numrows= 3","1"},
1:                 {"TBASIC4_XY","numunique= 1 numrows= 3","1"},
1:                 {"TBASIC4_XY","numunique= 2 numrows= 3","2"},
1:                 {"TBASIC4_YZ","numunique= 2 numrows= 3","1"},
1:                 {"TBASIC4_YZ","numunique= 3 numrows= 3","2"}});
1: 
1:         // if we drop column x, then stats for tbasic4_x should get dropped
1:         // index tbasic4_xy should get rebuilt to only be on y. so one of the
1:         // stats should be recreated. and tbasic4_yz shouldn remain in its
1:         // entirety.
1:         s.executeUpdate("alter table tbasic4 drop column x");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'TBASIC4%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC4_XY","numunique= 2 numrows= 3","1"},
1:                 {"TBASIC4_YZ","numunique= 2 numrows= 3","1"},
1:                 {"TBASIC4_YZ","numunique= 3 numrows= 3","2"}});
1:         s.executeUpdate("drop table tbasic4");
1:         
1:         // test re tbasic5 were intended to exercise Cloudscape's
1:         // stored prepared statements. This is not supported in Derby
1:         // it also does some drop statistics, but there are already 
1:         // other tests that do this. So on to tbasic6.
1:         
1:         s.executeUpdate("create table tbasic6 " +
1:                 "(i int generated always as identity," +
1:                 " j varchar(10))");
1:         s.executeUpdate("create index tbasic6_i on tbasic6(i)");
1:         s.executeUpdate("create index tbasic6_j on tbasic6(j)");
1:         s.executeUpdate("create index tbasic6_ji on tbasic6(j,i)");
1:         char[] alphabet = {'a','b','c','d','e','f','g','h','i'};
1:         for (int i=0; i<alphabet.length-1 ; i++)
1:             s.executeUpdate("insert into tbasic6 " +
1:                     "values (default, '" + alphabet[i] + "')");
1:         for (int i=0; i<alphabet.length ; i++)
1:             s.executeUpdate("insert into tbasic6 " +
1:                     "values (default, '" + alphabet[i] + "')");
1:         for (int i=0; i<alphabet.length-1 ; i++)
1:             s.executeUpdate("insert into tbasic6 " +
1:                     "values (default, '" + alphabet[i] + "')");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TBASIC6','TBASIC6_J')");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TBASIC6',NULL)");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'TBASIC6%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC6_I","numunique= 25 numrows= 25","1"},
1:                 {"TBASIC6_J","numunique= 9 numrows= 25","1"},
1:                 {"TBASIC6_JI","numunique= 25 numrows= 25","2"},
1:                 {"TBASIC6_JI","numunique= 9 numrows= 25","1"}});
1: 
1:         s.executeUpdate("delete from TBASIC6");
1:         // make the 17th row the same as the 16th;
1:         // make sure when we switch to the next group fetch
1:         // we handle the case correctly.
1:         for (int i=0; i<17 ; i++)
1:             s.executeUpdate("insert into tbasic6 values (default, 'a')");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','TBASIC6',NULL)");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'TBASIC6%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"TBASIC6_I","numunique= 17 numrows= 17","1"},
1:                 {"TBASIC6_J","numunique= 1 numrows= 17","1"},
1:                 {"TBASIC6_JI","numunique= 1 numrows= 17","1"},
1:                 {"TBASIC6_JI","numunique= 17 numrows= 17","2"}});
1:         s.executeUpdate("drop table tbasic6");
1:         
1:         // table with no rows.
1:         s.executeUpdate("create table et (x int, y int)");
1:         s.executeUpdate("create index etx on et(x)");
1:         s.executeUpdate("create index ety on et(y)");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','ET','ETX')");
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','ET',NULL)");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname like 'ET%' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertEmpty(statsrs);
1:         s.executeUpdate("drop table et");
1:         
1:         // tests for nulls.
1:         s.executeUpdate("create table null_table (x int, y varchar(2))");
1:         s.executeUpdate("create index nt_x on null_table(x desc)");
1:         for (int i=1; i<4 ; i++)
1:             s.executeUpdate("insert into null_table " +
1:                     "values (" + i + ", '" + alphabet[i-1] + "')");
1:         for (int c=0; c<2 ; c++)
1:         {
1:             for (int i=1; i<4 ; i++)
1:                 s.executeUpdate("insert into null_table " +
1:                         "values (null, '" + alphabet[i-1] + "')");
1:         }
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS" +
1:                 "('APP','NULL_TABLE',NULL)");
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname = 'NT_X' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"NT_X","numunique= 9 numrows= 9","1"}});
1:         // try composite null keys (1,null) is unique from (1,null)
1:         // as is (null,1) from (null,1)
1:         s.executeUpdate("drop index nt_x");
1:         s.executeUpdate("create index nt_yx on null_table(y,x)");
1:         // the first key y has 3 unique values.
1:         // the second key y,x has 9 unique values because of nulls.
1:         statsrs = s.executeQuery(
1:                 "select indexname, stats, ncols from showstats " +
1:                 "where indexname = 'NT_YX' " +
1:                 "order by indexname, stats, ncols");
1:         JDBC.assertFullResultSet(statsrs, new String[][] {
1:                 {"NT_YX","numunique= 3 numrows= 9","1"},
1:                 {"NT_YX","numunique= 9 numrows= 9","2"}});
1:     }
1:     
1:     // drop any tables created during testBasic
1:     protected void tearDown() throws Exception {
1:         Statement s = createStatement();
1:         try {
1:             s.execute("drop table tbasic1");
1:             s.execute("drop table tbasic2");
1:             s.execute("drop table tbasic3");
1:             s.execute("drop table tbasic4");
1:             s.execute("drop table tbasic6");
1:             s.execute("drop table et");
1:             s.execute("drop table null_table");
1:         } catch (SQLException sqle) {
1:             // if it doesn't work, never mind, we'll assume the
1:             // cleanDatabaseSetup will deal with it.
1:         }
1:         s.close();
1:         super.tearDown();
1:     }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:bce78c9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:02f8e49
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Class org.apache.derbyTesting.functionTests.tests.lang.SelectivityTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: public class SelectivityTest extends BaseJDBCTestCase {
1: 
1:     public SelectivityTest(String name) {
1:         super(name);
1:     }
1:     
0:     public void testSingleColumnSelectivity() throws SQLException {
0:         // choose whatever plan you want but the row estimate should be.
0:         //(n * n) * 0.5
0:         Connection conn = getConnection();
0:         Statement s = createStatement();      
0:         s.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
0:         s.executeQuery("select template.id from --DERBY-PROPERTIES joinOrder=fixed\n" 
0:                 + "test, template where test.two = template.two").close();         
0:         checkEstimatedRowCount(conn,8020012.5);
1:         
1: 
1:             
1:     }
1:     
1:     public static Test suite() {
0:         return new CleanDatabaseTestSetup(new TestSuite(SelectivityTest.class,
0:                 "SelectivityTest")) {
0:             protected void decorateSQL(Statement s) throws SQLException {
1:                 s.executeUpdate("create table two (x int)");
1:                 s.executeUpdate("insert into two values (1),(2)");
1:                 s.executeUpdate("create table ten (x int)");
1:                 s
1:                         .executeUpdate("insert into ten values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10)");
1:                 s.executeUpdate("create table twenty (x int)");
1:                 s
1:                         .executeUpdate("insert into twenty values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19),(20)");
1:                 s
1:                         .executeUpdate("create table hundred (x int generated always as identity, dc int)");
1:                 s
1:                         .executeUpdate("insert into hundred (dc) select t1.x from ten t1, ten t2");
1:                 s
1:                         .executeUpdate("create table template (id int not null generated always as identity, two int, twenty int, hundred int)");
1:                 // 4000 rows
1:                 s
1:                         .executeUpdate("insert into template (two, twenty, hundred) select two.x, twenty.x, hundred.x from two, twenty, hundred");
1:                 s.executeUpdate("create index template_two on template(two)");
1:                 s
1:                         .executeUpdate("create index template_twenty on template(twenty)");
1:                 // 20 distinct values
1:                 s
1:                         .executeUpdate("create index template_22 on template(twenty,two)");
1:                 s
1:                         .executeUpdate("create unique index template_id on template(id)");
1:                 s
1:                         .executeUpdate("create index template_102 on template(hundred,two)");
1:                 s
1:                         .executeUpdate("create table test (id int, two int, twenty int, hundred int)");
1:                 s.executeUpdate("create index test_id on test(id)");
1:                 s.executeUpdate("insert into test select * from template");
1: 
1:                 s
0:                         .executeUpdate("create view showstats as "
1:                                 + "select cast (conglomeratename as varchar(20)) indexname, "
1:                                 + "cast (statistics as varchar(40)) stats, "
1:                                 + "creationtimestamp createtime, "
1:                                 + "colcount ncols "
1:                                 + "from sys.sysstatistics, sys.sysconglomerates "
1:                                 + "where conglomerateid = referenceid");
1:                 ResultSet statsrs = s
1:                         .executeQuery("select indexname, stats, ncols from showstats order by indexname, stats, createtime, ncols");
1:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:                         {"TEMPLATE_102","numunique= 100 numrows= 4000","1"},
1:                         {"TEMPLATE_102","numunique= 200 numrows= 4000","2"},
1:                         {"TEMPLATE_22","numunique= 20 numrows= 4000","1"},
1:                         {"TEMPLATE_22","numunique= 40 numrows= 4000","2"},
0:                         {"TEMPLATE_ID","numunique= 4000 numrows= 4000","1"},
1:                         {"TEMPLATE_TWENTY","numunique= 20 numrows= 4000","1"},
1:                         {"TEMPLATE_TWO","numunique= 2 numrows= 4000","1"}});               
1:                 s
1:                         .executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEMPLATE',null)");
1:                 s
1:                         .executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST',null)");
1:                 statsrs = s
0:                         .executeQuery("select  indexname, stats, ncols from showstats order by indexname, stats, createtime, ncols");
1:                 JDBC.assertFullResultSet(statsrs, new String[][] {
1:                         {"TEMPLATE_102","numunique= 100 numrows= 4000","1"},
1:                         {"TEMPLATE_102","numunique= 200 numrows= 4000","2"},
1:                         {"TEMPLATE_22","numunique= 20 numrows= 4000","1"},
1:                         {"TEMPLATE_22","numunique= 40 numrows= 4000","2"},
0:                         {"TEMPLATE_ID","numunique= 4000 numrows= 4000","1"},
1:                         {"TEMPLATE_TWENTY","numunique= 20 numrows= 4000","1"},
1:                         {"TEMPLATE_TWO","numunique= 2 numrows= 4000","1"},
0:                         {"TEST_ID","numunique= 4000 numrows= 4000","1"}}                                                               
0:                 );
1:                 
1:             }
1:         };
1:     }
1: }
============================================================================