1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.MemByteHolder
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.OutputStream;
1:eac0369: import java.util.Vector;
1:eac0369: 
2:eac0369: /**
1:eac0369:   A ByteHolder that stores all its bytes in memory.
1:eac0369:   */
1:eac0369: public class MemByteHolder
1:eac0369: implements ByteHolder
1:eac0369: {
1:eac0369: 	int bufSize;
1:eac0369: 
1:eac0369: 	boolean writing = true;
1:eac0369: 	
1:7e7a589: 	Vector<byte[]> bufV;
1:eac0369: 	int curBufVEleAt;
1:eac0369: 
1:eac0369: 	byte[] curBuf;
1:eac0369: 	int curBufPos;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	//We use this to determine when we have reached the end
1:eac0369: 	//of the current buffer whild reading. For the last
1:eac0369: 	//buffer this may be less than bufSize.
1:eac0369: 	int curBufDataBytes;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	//We use these to remember the location of the last byte
1:eac0369: 	//of data we have stored. The read methods use these to
1:eac0369: 	//avoid reading more bytes than we have stored. These
1:eac0369: 	//values are set by startReading.
1:eac0369: 	int lastBufVEleAt = 0;
1:eac0369: 	int lastBufDataBytes = 0;
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	  Create a new MemByteHolder. Store bytes as a list of buffers
1:eac0369: 	  of size 'bufSize'.
1:eac0369: 	  */
1:eac0369: 	public MemByteHolder(int bufSize)
1:eac0369: 	{
1:eac0369: 		this.bufSize = bufSize;
1:eac0369: 
1:eac0369: 		this.curBuf = new byte[bufSize];
1:eac0369: 		this.curBufPos = 0;
1:eac0369: 
1:7e7a589: 		this.bufV = new Vector<byte[]>(128);
1:eac0369: 		bufV.addElement(curBuf);
1:eac0369: 		this.curBufVEleAt = 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#write
1:eac0369: 	  @exception IOException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public void write(int b) throws IOException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(writing == true,
1:eac0369: 								 "Writing should be true 1");
1:eac0369: 
1:eac0369: 		if(curBufPos>=curBuf.length)
1:eac0369: 			getNextBuffer_w();
1:eac0369: 
1:eac0369: 		curBuf[curBufPos++] = (byte)b;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#write
1:eac0369: 	  @exception IOException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public void write(byte[] data, int offset, int len) throws IOException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(writing == true,
1:eac0369: 								 "Writing should be true 2");
1:eac0369: 
1:eac0369: 		while(len > 0)
1:eac0369: 		{
1:eac0369: 			if(curBufPos>=curBuf.length)
1:eac0369: 				getNextBuffer_w();
1:eac0369: 
1:eac0369: 			int bytesToCopyThisTime = len;
1:eac0369: 			int bytesInCurBuf = curBuf.length - curBufPos;
1:eac0369: 
1:eac0369: 			if (bytesToCopyThisTime > bytesInCurBuf)
1:eac0369: 				bytesToCopyThisTime = bytesInCurBuf;
1:eac0369: 			System.arraycopy(data,offset,curBuf,curBufPos,bytesToCopyThisTime);
1:eac0369: 			offset += bytesToCopyThisTime; 
1:eac0369: 			curBufPos += bytesToCopyThisTime;
1:eac0369: 			len -= bytesToCopyThisTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#write
1:eac0369: 	  @exception IOException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public long write(InputStream is, long count) throws IOException
1:eac0369: 	{
1:eac0369: 		long bytesToTransfer = count;
1:eac0369: 		int bytesTransferredThisTime = 0;
1:eac0369: 		
1:eac0369: 		do 
1:eac0369: 		{
1:eac0369: 			if(curBufPos>=curBuf.length)
1:eac0369: 				getNextBuffer_w();
1:eac0369:  
1:eac0369: 			int bytesToTransferThisTime;
1:eac0369: 			int bytesInCurBuf = curBuf.length - curBufPos;
1:eac0369: 
1:eac0369: 			if (bytesToTransfer >= bytesInCurBuf)
1:eac0369: 				bytesToTransferThisTime = bytesInCurBuf;
1:eac0369: 			else
1:eac0369: 				 bytesToTransferThisTime = (int)bytesToTransfer;
1:eac0369: 			//
1:eac0369: 			//Note read should never return 0. Thus we keep looping
1:eac0369: 			//transferring bytes from the stream to our buffer until
1:eac0369: 			//we transfer count bytes or reach the end of the stream.
1:eac0369: 			//
1:eac0369: 			bytesTransferredThisTime =
1:eac0369: 				is.read(curBuf,curBufPos,bytesToTransferThisTime);
1:eac0369: 
1:eac0369: 			if (bytesTransferredThisTime > 0)
1:eac0369: 			{
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                     SanityManager.ASSERT(
1:eac0369:                         writing == true, "Writing should be true 3");
1:eac0369: 
1:eac0369: 				bytesToTransfer -= bytesTransferredThisTime;
1:eac0369: 				curBufPos += bytesTransferredThisTime;
1:eac0369: 			}
1:eac0369: 		} while (bytesToTransfer > 0 &&
1:eac0369: 				 bytesTransferredThisTime > 0);
1:eac0369: 
1:eac0369: 		return count - bytesToTransfer;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#clear
1:eac0369: 
1:eac0369: 	  @exception IOException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public void clear() throws IOException
1:eac0369: 	{
1:eac0369: 		writing = true;
1:eac0369: 		
1:7e7a589: 		curBuf = bufV.elementAt(0);
1:eac0369: 		this.curBufVEleAt = 0;
1:eac0369: 		this.curBufPos = 0;
1:eac0369: 		
1:eac0369: 		lastBufVEleAt = 0;
1:eac0369: 		lastBufDataBytes = 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#startReading
1:eac0369: 	  */
1:eac0369: 	public void startReading()
1:eac0369:         throws IOException
1:eac0369: 	{
1:eac0369: 		if (writing == true)
1:eac0369: 		{
1:eac0369: 			//Enter read mode.
1:eac0369: 			writing = false;
1:eac0369: 			lastBufDataBytes = curBufPos;
1:eac0369: 			lastBufVEleAt = curBufVEleAt;
1:eac0369: 		}
1:eac0369: 		//
1:eac0369: 		//Reposition so reads start from the first
1:eac0369: 		//byte.
1:7e7a589: 		curBuf = bufV.elementAt(0);
1:eac0369: 		this.curBufVEleAt = 0;
1:eac0369: 		this.curBufPos = 0;
1:eac0369: 		if (curBufVEleAt == lastBufVEleAt)
1:eac0369: 			curBufDataBytes = lastBufDataBytes;
1:eac0369: 		else
1:eac0369: 			curBufDataBytes = bufSize;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#read
1:eac0369: 	  @exception IOException	Thrown on error
1:eac0369: 	  */
1:eac0369: 	public int read() throws IOException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(writing == false,
1:eac0369: 								 "Reading should be true 2");
1:eac0369: 		
1:eac0369: 		if (curBufPos >= curBufDataBytes)
1:eac0369: 			getNextBuffer_r();
1:eac0369: 
1:eac0369: 		if (curBufPos >= curBufDataBytes)
1:eac0369: 			return -1;
1:eac0369: 		else
1:eac0369: 			return 0xff & curBuf[curBufPos++];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#read
1:eac0369: 	  @exception IOException	Thrown on error
1:eac0369: 	  */
1:eac0369: 	public int read(byte b[],
1:eac0369: 					int off,
1:eac0369: 					int len)
1:eac0369: 		throws IOException
1:eac0369: 	{
1:eac0369: 		return (read(b, off, (OutputStream) null, len));
1:eac0369: 	}
1:eac0369: 
1:20bc69f: 	/**
1:20bc69f: 	  @see ByteHolder#read
1:20bc69f: 	  @exception IOException	Thrown on error
1:20bc69f: 	  */
1:eac0369: 	public int read(OutputStream out,
1:eac0369: 					int len)
1:eac0369: 		throws IOException
1:eac0369: 	{
1:eac0369: 		return(read((byte []) null, 0, out, len));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#read
1:eac0369: 	  @exception IOException	Thrown on error
1:eac0369: 	  */
1:eac0369: 	public int read(byte b[],
1:eac0369: 					int off,
1:eac0369: 					OutputStream out,
1:eac0369: 					int len)
1:eac0369: 		throws IOException
1:eac0369: 	{
1:eac0369: 		int bytesIRead = 0;
1:eac0369: 		boolean eof = false;
1:eac0369: 		
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(writing == false,
1:eac0369: 								 "Reading should be true 3");
1:eac0369: 		
1:eac0369: 		if (curBufPos >= curBufDataBytes)
1:eac0369: 			eof = getNextBuffer_r();
1:eac0369: 
1:eac0369: 		if (eof) return -1;
1:eac0369: 
1:eac0369: 		while (len > 0 && !eof)
1:eac0369: 		{
1:eac0369: 			int bytesInCurBuf = curBufDataBytes - curBufPos;
1:eac0369: 			int bytesIReadThisTime;
1:eac0369: 			if (len >= bytesInCurBuf)
1:eac0369: 				bytesIReadThisTime = bytesInCurBuf;
1:eac0369: 			else
1:eac0369: 				 bytesIReadThisTime = len;
1:eac0369: 
1:eac0369: 			if (out == null) {
1:eac0369: 				// write the data to the byte array
1:eac0369: 				System.arraycopy(curBuf,curBufPos,b,off,bytesIReadThisTime);
1:eac0369: 			} else {
1:eac0369: 				// write the data to the output stream
1:eac0369: 				out.write(curBuf, curBufPos, bytesIReadThisTime);
1:eac0369: 			}
1:eac0369: 			off+=bytesIReadThisTime;
1:eac0369: 			curBufPos+=bytesIReadThisTime;
1:eac0369: 			len -= bytesIReadThisTime;
1:eac0369: 			bytesIRead+=bytesIReadThisTime;
1:eac0369: 			if (curBufPos >= curBufDataBytes)
1:eac0369: 				eof = getNextBuffer_r();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return bytesIRead;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#shiftToFront
1:eac0369: 	  @exception IOException	Thrown on error
1:eac0369: 	  */
1:eac0369: 	public int shiftToFront() throws IOException
1:eac0369: 	{
1:eac0369: 		int remainingBytes = available();
1:eac0369: 		remainingBytes = remainingBytes > 0 ? remainingBytes : (-1) * remainingBytes;
1:eac0369: 
1:eac0369: 		byte b[] = new byte[remainingBytes + 1];
1:eac0369: 		int bytesRead = read(b, 0, remainingBytes);
1:eac0369: 
1:eac0369: 		// clear the buffer
1:eac0369: 		clear();
1:eac0369: 
1:eac0369: 		// put the bytes at the beginning of the buffer
1:eac0369: 		writing = true;
1:eac0369: 		write(b, 0, bytesRead);
1:eac0369: 
1:eac0369: 		curBufDataBytes = 0;
1:eac0369: 
1:eac0369: 		return bytesRead;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#available
1:eac0369: 	  */
1:eac0369: 	public int available()
1:eac0369: 	{
1:eac0369: 		//if (SanityManager.DEBUG)
1:eac0369: 		//	SanityManager.ASSERT(writing == false,
1:eac0369: 		//						 "Reading should be true 3");
1:eac0369: 
1:eac0369: 		int curBufAvailable = curBufDataBytes - curBufPos;
1:eac0369: 		int lastBufAvailable = 0;
1:eac0369: 		int middleBuffers = 0;
1:eac0369: 		if (curBufVEleAt != lastBufVEleAt)
1:eac0369: 		{			
1:eac0369: 			middleBuffers = lastBufVEleAt - curBufVEleAt - 1;
1:eac0369: 			lastBufAvailable = lastBufDataBytes;
1:eac0369: 		}
1:eac0369: 		int availableBytes =
1:eac0369: 			curBufAvailable +
1:eac0369: 			lastBufAvailable +
1:eac0369: 			middleBuffers * bufSize;
1:eac0369: 
1:eac0369: 		return availableBytes;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:  	  Return the number of bytes that have been saved to this byte holder.
1:eac0369:       This result is different from available() as it is unaffected by the
1:eac0369:       current read position on the ByteHolder.
1:eac0369: 
1:eac0369: 	  @see ByteHolder#numBytesSaved
1:eac0369: 	  */
1:eac0369: 	public int numBytesSaved()
1:eac0369: 	{
1:eac0369:         int ret_val;
1:eac0369: 
1:eac0369:         if (writing)
1:eac0369:         {
1:eac0369:             // still writing, so use the cur* variables
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     lastBufVEleAt == 0 && lastBufDataBytes == 0,
1:eac0369:                     "counters were somehow bumped during writing");
1:eac0369: 
1:eac0369:             ret_val = (curBufVEleAt * bufSize) + curBufPos;
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             ret_val = (lastBufVEleAt * bufSize) + lastBufDataBytes;
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_val);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#skip
1:eac0369: 	  @exception IOException	Thrown on error
1:eac0369: 	  */
1:eac0369: 	public long skip(long count) throws IOException
1:eac0369: 	{
1:eac0369: 		long bytesISkipped = 0;
1:eac0369: 		boolean eof = false;
1:eac0369: 		
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(writing == false,
1:eac0369: 								 "Reading should be true 4");
1:eac0369: 		
1:eac0369: 		if (curBufPos >= curBufDataBytes)
1:eac0369: 			eof = getNextBuffer_r();
1:eac0369: 
1:eac0369: 		while (count > 0 && !eof)
1:eac0369: 		{
1:eac0369: 			int bytesInCurBuf = curBufDataBytes - curBufPos;
1:eac0369: 			int bytesISkippedThisTime;
1:eac0369: 			
1:eac0369: 			if (count >= bytesInCurBuf)
1:eac0369: 				bytesISkippedThisTime = bytesInCurBuf;
1:eac0369: 			else
1:eac0369: 				 bytesISkippedThisTime = (int)count;
1:eac0369: 
1:eac0369: 			curBufPos+=bytesISkippedThisTime;
1:eac0369: 			count -= bytesISkippedThisTime;
1:eac0369: 			bytesISkipped+=bytesISkippedThisTime;
1:eac0369: 
1:eac0369: 			if (count > 0)
1:eac0369: 				eof = getNextBuffer_r();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return bytesISkipped;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see ByteHolder#writingMode
1:eac0369: 	 */
1:eac0369: 	public boolean writingMode()
1:eac0369: 	{
1:eac0369: 		return writing;
1:eac0369: 	}
1:eac0369: 
1:1b454a1:     /**
1:1b454a1:      * @see ByteHolder#cloneEmpty
1:1b454a1:      */
1:1b454a1:     public ByteHolder cloneEmpty() {
1:1b454a1:         return(new MemByteHolder(bufSize));
1:1b454a1:     }
1:1b454a1: 
1:eac0369: 	/**
1:eac0369: 	  Get the next buffer for writing bytes.
1:eac0369: 	  @exception IOException	Thrown on error
1:eac0369: 	  */
1:eac0369: 	protected void getNextBuffer_w() throws IOException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			getNextBuffer_w_Sanity();
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		curBufVEleAt++;
1:eac0369: 
1:eac0369: 		if (bufV.size() <= curBufVEleAt)
1:eac0369: 		{
1:eac0369: 			curBuf = new byte[bufSize];
1:eac0369: 			bufV.addElement(curBuf);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:7e7a589: 			curBuf = bufV.elementAt(curBufVEleAt);
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		initBuffer_w();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Do sanity checking when getting the next write buffer */
1:eac0369: 	protected void getNextBuffer_w_Sanity()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(curBufPos == curBuf.length,
1:eac0369: 								 "partial write");
1:eac0369: 
1:eac0369: 			SanityManager.ASSERT(writing == true,
1:eac0369: 								 "Writing should be true 5");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	/** Initialize a buffer for writing */
1:eac0369: 	protected void initBuffer_w()
1:eac0369: 	{
1:eac0369: 		curBufPos = 0;
1:eac0369: 		
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 		    SanityManager.ASSERT(curBuf.length == bufSize,
1:eac0369: 								 "bad Buf Length "+curBuf.length);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Get the next buffer for reading bytes.
1:eac0369: 
1:eac0369: 	  @return true if the user has read all the bytes
1:eac0369: 	  in this ByteHolder.
1:eac0369: 
1:eac0369: 	  @exception IOException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	protected boolean getNextBuffer_r() throws IOException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(writing == false,
1:eac0369: 								 "Reading should be true 5");
1:eac0369: 		if (curBufVEleAt >= lastBufVEleAt) return true;
1:7e7a589: 		curBuf = bufV.elementAt(++curBufVEleAt);
1:eac0369: 		curBufPos = 0;
1:eac0369: 		if (curBufVEleAt == lastBufVEleAt)
1:eac0369: 			curBufDataBytes = lastBufDataBytes;
1:eac0369: 		else
1:eac0369: 			curBufDataBytes = bufSize;
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Create a string representation of an internal buffer of bytes.
1:eac0369: 	  This is useful during debugging.
1:eac0369: 	  */
1:eac0369: 	private String dumpBuf(int bufVEleAt)
1:eac0369: 	{
1:eac0369: 		StringBuffer sb = new StringBuffer(100);
1:eac0369: 
1:7e7a589: 		byte[] buf = bufV.elementAt(bufVEleAt);
1:eac0369: 		sb.append("(");
1:eac0369: 		for (int ix = 0;ix<buf.length;ix++)
1:eac0369: 			sb.append(buf[ix]+".");
1:eac0369: 		sb.append(")");
1:eac0369: 		return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Produce a string describing the state of this ByteHolder.
1:eac0369: 	  This is mainly for debugging.
1:eac0369: 	  */
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		return
1:eac0369: 			" writing: "+writing+
1:eac0369: 			" curBufVEleAt: "+curBufVEleAt+
1:eac0369: 			" curBufPos: "+curBufPos+
1:eac0369: 			" curBufDataBytes: "+curBufDataBytes+
1:eac0369: 			" lastBufVEleAt: "+lastBufVEleAt+
1:eac0369:             " lastBufDataBytes: "+lastBufDataBytes+
1:eac0369: 			" curBuf: "+dumpBuf(curBufVEleAt);
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:7e7a589
/////////////////////////////////////////////////////////////////////////
1: 	Vector<byte[]> bufV;
/////////////////////////////////////////////////////////////////////////
1: 		this.bufV = new Vector<byte[]>(128);
/////////////////////////////////////////////////////////////////////////
1: 		curBuf = bufV.elementAt(0);
/////////////////////////////////////////////////////////////////////////
1: 		curBuf = bufV.elementAt(0);
/////////////////////////////////////////////////////////////////////////
1: 			curBuf = bufV.elementAt(curBufVEleAt);
/////////////////////////////////////////////////////////////////////////
1: 		curBuf = bufV.elementAt(++curBufVEleAt);
/////////////////////////////////////////////////////////////////////////
1: 		byte[] buf = bufV.elementAt(bufVEleAt);
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:1b454a1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @see ByteHolder#cloneEmpty
1:      */
1:     public ByteHolder cloneEmpty() {
1:         return(new MemByteHolder(bufSize));
1:     }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:20bc69f
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	  @see ByteHolder#read
1: 	  @exception IOException	Thrown on error
1: 	  */
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.MemByteHolder
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.util.Vector;
1: 
1: /**
1:   A ByteHolder that stores all its bytes in memory.
1:   */
1: public class MemByteHolder
1: implements ByteHolder
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	int bufSize;
1: 
1: 	boolean writing = true;
1: 	
0: 	Vector bufV;
1: 	int curBufVEleAt;
1: 
1: 	byte[] curBuf;
1: 	int curBufPos;
1: 
1: 	//
1: 	//We use this to determine when we have reached the end
1: 	//of the current buffer whild reading. For the last
1: 	//buffer this may be less than bufSize.
1: 	int curBufDataBytes;
1: 
1: 	//
1: 	//We use these to remember the location of the last byte
1: 	//of data we have stored. The read methods use these to
1: 	//avoid reading more bytes than we have stored. These
1: 	//values are set by startReading.
1: 	int lastBufVEleAt = 0;
1: 	int lastBufDataBytes = 0;
1: 	
1: 	/**
1: 	  Create a new MemByteHolder. Store bytes as a list of buffers
1: 	  of size 'bufSize'.
1: 	  */
1: 	public MemByteHolder(int bufSize)
1: 	{
1: 		this.bufSize = bufSize;
1: 
1: 		this.curBuf = new byte[bufSize];
1: 		this.curBufPos = 0;
1: 
0: 		this.bufV = new Vector(128);
1: 		bufV.addElement(curBuf);
1: 		this.curBufVEleAt = 0;
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#write
1: 	  @exception IOException		Thrown on error
1: 	  */
1: 	public void write(int b) throws IOException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(writing == true,
1: 								 "Writing should be true 1");
1: 
1: 		if(curBufPos>=curBuf.length)
1: 			getNextBuffer_w();
1: 
1: 		curBuf[curBufPos++] = (byte)b;
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#write
1: 	  @exception IOException		Thrown on error
1: 	  */
1: 	public void write(byte[] data, int offset, int len) throws IOException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(writing == true,
1: 								 "Writing should be true 2");
1: 
1: 		while(len > 0)
1: 		{
1: 			if(curBufPos>=curBuf.length)
1: 				getNextBuffer_w();
1: 
1: 			int bytesToCopyThisTime = len;
1: 			int bytesInCurBuf = curBuf.length - curBufPos;
1: 
1: 			if (bytesToCopyThisTime > bytesInCurBuf)
1: 				bytesToCopyThisTime = bytesInCurBuf;
1: 			System.arraycopy(data,offset,curBuf,curBufPos,bytesToCopyThisTime);
1: 			offset += bytesToCopyThisTime; 
1: 			curBufPos += bytesToCopyThisTime;
1: 			len -= bytesToCopyThisTime;
1: 		}
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#write
1: 	  @exception IOException		Thrown on error
1: 	  */
1: 	public long write(InputStream is, long count) throws IOException
1: 	{
1: 		long bytesToTransfer = count;
1: 		int bytesTransferredThisTime = 0;
1: 		
1: 		do 
1: 		{
1: 			if(curBufPos>=curBuf.length)
1: 				getNextBuffer_w();
1:  
1: 			int bytesToTransferThisTime;
1: 			int bytesInCurBuf = curBuf.length - curBufPos;
1: 
1: 			if (bytesToTransfer >= bytesInCurBuf)
1: 				bytesToTransferThisTime = bytesInCurBuf;
1: 			else
1: 				 bytesToTransferThisTime = (int)bytesToTransfer;
1: 			//
1: 			//Note read should never return 0. Thus we keep looping
1: 			//transferring bytes from the stream to our buffer until
1: 			//we transfer count bytes or reach the end of the stream.
1: 			//
1: 			bytesTransferredThisTime =
1: 				is.read(curBuf,curBufPos,bytesToTransferThisTime);
1: 
1: 			if (bytesTransferredThisTime > 0)
1: 			{
1:                 if (SanityManager.DEBUG)
1:                     SanityManager.ASSERT(
1:                         writing == true, "Writing should be true 3");
1: 
1: 				bytesToTransfer -= bytesTransferredThisTime;
1: 				curBufPos += bytesTransferredThisTime;
1: 			}
1: 		} while (bytesToTransfer > 0 &&
1: 				 bytesTransferredThisTime > 0);
1: 
1: 		return count - bytesToTransfer;
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#clear
1: 
1: 	  @exception IOException		Thrown on error
1: 	  */
1: 	public void clear() throws IOException
1: 	{
1: 		writing = true;
1: 		
0: 		curBuf = (byte[])bufV.elementAt(0);
1: 		this.curBufVEleAt = 0;
1: 		this.curBufPos = 0;
1: 		
1: 		lastBufVEleAt = 0;
1: 		lastBufDataBytes = 0;
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#startReading
1: 	  */
1: 	public void startReading()
1:         throws IOException
1: 	{
1: 		if (writing == true)
1: 		{
1: 			//Enter read mode.
1: 			writing = false;
1: 			lastBufDataBytes = curBufPos;
1: 			lastBufVEleAt = curBufVEleAt;
1: 		}
1: 		//
1: 		//Reposition so reads start from the first
1: 		//byte.
0: 		curBuf = (byte[])bufV.elementAt(0);
1: 		this.curBufVEleAt = 0;
1: 		this.curBufPos = 0;
1: 		if (curBufVEleAt == lastBufVEleAt)
1: 			curBufDataBytes = lastBufDataBytes;
1: 		else
1: 			curBufDataBytes = bufSize;
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#read
1: 	  @exception IOException	Thrown on error
1: 	  */
1: 	public int read() throws IOException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(writing == false,
1: 								 "Reading should be true 2");
1: 		
1: 		if (curBufPos >= curBufDataBytes)
1: 			getNextBuffer_r();
1: 
1: 		if (curBufPos >= curBufDataBytes)
1: 			return -1;
1: 		else
1: 			return 0xff & curBuf[curBufPos++];
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#read
1: 	  @exception IOException	Thrown on error
1: 	  */
1: 	public int read(byte b[],
1: 					int off,
1: 					int len)
1: 		throws IOException
1: 	{
1: 		return (read(b, off, (OutputStream) null, len));
1: 	}
1: 
1: 	public int read(OutputStream out,
1: 					int len)
1: 		throws IOException
1: 	{
1: 		return(read((byte []) null, 0, out, len));
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#read
1: 	  @exception IOException	Thrown on error
1: 	  */
1: 	public int read(byte b[],
1: 					int off,
1: 					OutputStream out,
1: 					int len)
1: 		throws IOException
1: 	{
1: 		int bytesIRead = 0;
1: 		boolean eof = false;
1: 		
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(writing == false,
1: 								 "Reading should be true 3");
1: 		
1: 		if (curBufPos >= curBufDataBytes)
1: 			eof = getNextBuffer_r();
1: 
1: 		if (eof) return -1;
1: 
1: 		while (len > 0 && !eof)
1: 		{
1: 			int bytesInCurBuf = curBufDataBytes - curBufPos;
1: 			int bytesIReadThisTime;
1: 			if (len >= bytesInCurBuf)
1: 				bytesIReadThisTime = bytesInCurBuf;
1: 			else
1: 				 bytesIReadThisTime = len;
1: 
1: 			if (out == null) {
1: 				// write the data to the byte array
1: 				System.arraycopy(curBuf,curBufPos,b,off,bytesIReadThisTime);
1: 			} else {
1: 				// write the data to the output stream
1: 				out.write(curBuf, curBufPos, bytesIReadThisTime);
1: 			}
1: 			off+=bytesIReadThisTime;
1: 			curBufPos+=bytesIReadThisTime;
1: 			len -= bytesIReadThisTime;
1: 			bytesIRead+=bytesIReadThisTime;
1: 			if (curBufPos >= curBufDataBytes)
1: 				eof = getNextBuffer_r();
1: 		}
1: 
1: 		return bytesIRead;
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#shiftToFront
1: 	  @exception IOException	Thrown on error
1: 	  */
1: 	public int shiftToFront() throws IOException
1: 	{
1: 		int remainingBytes = available();
1: 		remainingBytes = remainingBytes > 0 ? remainingBytes : (-1) * remainingBytes;
1: 
1: 		byte b[] = new byte[remainingBytes + 1];
1: 		int bytesRead = read(b, 0, remainingBytes);
1: 
1: 		// clear the buffer
1: 		clear();
1: 
1: 		// put the bytes at the beginning of the buffer
1: 		writing = true;
1: 		write(b, 0, bytesRead);
1: 
1: 		curBufDataBytes = 0;
1: 
1: 		return bytesRead;
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#available
1: 	  */
1: 	public int available()
1: 	{
1: 		//if (SanityManager.DEBUG)
1: 		//	SanityManager.ASSERT(writing == false,
1: 		//						 "Reading should be true 3");
1: 
1: 		int curBufAvailable = curBufDataBytes - curBufPos;
1: 		int lastBufAvailable = 0;
1: 		int middleBuffers = 0;
1: 		if (curBufVEleAt != lastBufVEleAt)
1: 		{			
1: 			middleBuffers = lastBufVEleAt - curBufVEleAt - 1;
1: 			lastBufAvailable = lastBufDataBytes;
1: 		}
1: 		int availableBytes =
1: 			curBufAvailable +
1: 			lastBufAvailable +
1: 			middleBuffers * bufSize;
1: 
1: 		return availableBytes;
1: 	}
1: 
1:     /**
1:  	  Return the number of bytes that have been saved to this byte holder.
1:       This result is different from available() as it is unaffected by the
1:       current read position on the ByteHolder.
1: 
1: 	  @see ByteHolder#numBytesSaved
1: 	  */
1: 	public int numBytesSaved()
1: 	{
1:         int ret_val;
1: 
1:         if (writing)
1:         {
1:             // still writing, so use the cur* variables
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(
1:                     lastBufVEleAt == 0 && lastBufDataBytes == 0,
1:                     "counters were somehow bumped during writing");
1: 
1:             ret_val = (curBufVEleAt * bufSize) + curBufPos;
1:         }
1:         else
1:         {
1:             ret_val = (lastBufVEleAt * bufSize) + lastBufDataBytes;
1:         }
1: 
1:         return(ret_val);
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#skip
1: 	  @exception IOException	Thrown on error
1: 	  */
1: 	public long skip(long count) throws IOException
1: 	{
1: 		long bytesISkipped = 0;
1: 		boolean eof = false;
1: 		
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(writing == false,
1: 								 "Reading should be true 4");
1: 		
1: 		if (curBufPos >= curBufDataBytes)
1: 			eof = getNextBuffer_r();
1: 
1: 		while (count > 0 && !eof)
1: 		{
1: 			int bytesInCurBuf = curBufDataBytes - curBufPos;
1: 			int bytesISkippedThisTime;
1: 			
1: 			if (count >= bytesInCurBuf)
1: 				bytesISkippedThisTime = bytesInCurBuf;
1: 			else
1: 				 bytesISkippedThisTime = (int)count;
1: 
1: 			curBufPos+=bytesISkippedThisTime;
1: 			count -= bytesISkippedThisTime;
1: 			bytesISkipped+=bytesISkippedThisTime;
1: 
1: 			if (count > 0)
1: 				eof = getNextBuffer_r();
1: 		}
1: 
1: 		return bytesISkipped;
1: 	}
1: 
1: 	/**
1: 	  @see ByteHolder#writingMode
1: 	 */
1: 	public boolean writingMode()
1: 	{
1: 		return writing;
1: 	}
1: 
1: 	/**
1: 	  Get the next buffer for writing bytes.
1: 	  @exception IOException	Thrown on error
1: 	  */
1: 	protected void getNextBuffer_w() throws IOException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			getNextBuffer_w_Sanity();
1: 		}
1: 		
1: 		curBufVEleAt++;
1: 
1: 		if (bufV.size() <= curBufVEleAt)
1: 		{
1: 			curBuf = new byte[bufSize];
1: 			bufV.addElement(curBuf);
1: 		}
1: 		else
1: 		{
0: 			curBuf = (byte[])bufV.elementAt(curBufVEleAt);
1: 		}
1: 		
1: 		initBuffer_w();
1: 	}
1: 
1: 	/** Do sanity checking when getting the next write buffer */
1: 	protected void getNextBuffer_w_Sanity()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(curBufPos == curBuf.length,
1: 								 "partial write");
1: 
1: 			SanityManager.ASSERT(writing == true,
1: 								 "Writing should be true 5");
1: 		}
1: 	}
1: 		
1: 	/** Initialize a buffer for writing */
1: 	protected void initBuffer_w()
1: 	{
1: 		curBufPos = 0;
1: 		
1: 		if (SanityManager.DEBUG)
1: 		{
1: 		    SanityManager.ASSERT(curBuf.length == bufSize,
1: 								 "bad Buf Length "+curBuf.length);
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Get the next buffer for reading bytes.
1: 
1: 	  @return true if the user has read all the bytes
1: 	  in this ByteHolder.
1: 
1: 	  @exception IOException		Thrown on error
1: 	  */
1: 	protected boolean getNextBuffer_r() throws IOException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(writing == false,
1: 								 "Reading should be true 5");
1: 		if (curBufVEleAt >= lastBufVEleAt) return true;
0: 		curBuf = (byte[])bufV.elementAt(++curBufVEleAt);
1: 		curBufPos = 0;
1: 		if (curBufVEleAt == lastBufVEleAt)
1: 			curBufDataBytes = lastBufDataBytes;
1: 		else
1: 			curBufDataBytes = bufSize;
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	  Create a string representation of an internal buffer of bytes.
1: 	  This is useful during debugging.
1: 	  */
1: 	private String dumpBuf(int bufVEleAt)
1: 	{
1: 		StringBuffer sb = new StringBuffer(100);
1: 
0: 		byte[] buf = (byte[])bufV.elementAt(bufVEleAt);
1: 		sb.append("(");
1: 		for (int ix = 0;ix<buf.length;ix++)
1: 			sb.append(buf[ix]+".");
1: 		sb.append(")");
1: 		return sb.toString();
1: 	}
1: 
1: 	/**
1: 	  Produce a string describing the state of this ByteHolder.
1: 	  This is mainly for debugging.
1: 	  */
1: 	public String toString()
1: 	{
1: 		return
1: 			" writing: "+writing+
1: 			" curBufVEleAt: "+curBufVEleAt+
1: 			" curBufPos: "+curBufPos+
1: 			" curBufDataBytes: "+curBufDataBytes+
1: 			" lastBufVEleAt: "+lastBufVEleAt+
1:             " lastBufDataBytes: "+lastBufDataBytes+
1: 			" curBuf: "+dumpBuf(curBufVEleAt);
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: import java.util.Vector;
0: 
0: /**
0:   A ByteHolder that stores all its bytes in memory.
0:   */
0: public class MemByteHolder
0: implements ByteHolder
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	int bufSize;
0: 
0: 	boolean writing = true;
0: 	
0: 	Vector bufV;
0: 	int curBufVEleAt;
0: 
0: 	byte[] curBuf;
0: 	int curBufPos;
0: 
0: 	//
0: 	//We use this to determine when we have reached the end
0: 	//of the current buffer whild reading. For the last
0: 	//buffer this may be less than bufSize.
0: 	int curBufDataBytes;
0: 
0: 	//
0: 	//We use these to remember the location of the last byte
0: 	//of data we have stored. The read methods use these to
0: 	//avoid reading more bytes than we have stored. These
0: 	//values are set by startReading.
0: 	int lastBufVEleAt = 0;
0: 	int lastBufDataBytes = 0;
0: 	
0: 	/**
0: 	  Create a new MemByteHolder. Store bytes as a list of buffers
0: 	  of size 'bufSize'.
0: 	  */
0: 	public MemByteHolder(int bufSize)
0: 	{
0: 		this.bufSize = bufSize;
0: 
0: 		this.curBuf = new byte[bufSize];
0: 		this.curBufPos = 0;
0: 
0: 		this.bufV = new Vector(128);
0: 		bufV.addElement(curBuf);
0: 		this.curBufVEleAt = 0;
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#write
0: 	  @exception IOException		Thrown on error
0: 	  */
0: 	public void write(int b) throws IOException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(writing == true,
0: 								 "Writing should be true 1");
0: 
0: 		if(curBufPos>=curBuf.length)
0: 			getNextBuffer_w();
0: 
0: 		curBuf[curBufPos++] = (byte)b;
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#write
0: 	  @exception IOException		Thrown on error
0: 	  */
0: 	public void write(byte[] data, int offset, int len) throws IOException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(writing == true,
0: 								 "Writing should be true 2");
0: 
0: 		while(len > 0)
0: 		{
0: 			if(curBufPos>=curBuf.length)
0: 				getNextBuffer_w();
0: 
0: 			int bytesToCopyThisTime = len;
0: 			int bytesInCurBuf = curBuf.length - curBufPos;
0: 
0: 			if (bytesToCopyThisTime > bytesInCurBuf)
0: 				bytesToCopyThisTime = bytesInCurBuf;
0: 			System.arraycopy(data,offset,curBuf,curBufPos,bytesToCopyThisTime);
0: 			offset += bytesToCopyThisTime; 
0: 			curBufPos += bytesToCopyThisTime;
0: 			len -= bytesToCopyThisTime;
0: 		}
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#write
0: 	  @exception IOException		Thrown on error
0: 	  */
0: 	public long write(InputStream is, long count) throws IOException
0: 	{
0: 		long bytesToTransfer = count;
0: 		int bytesTransferredThisTime = 0;
0: 		
0: 		do 
0: 		{
0: 			if(curBufPos>=curBuf.length)
0: 				getNextBuffer_w();
0:  
0: 			int bytesToTransferThisTime;
0: 			int bytesInCurBuf = curBuf.length - curBufPos;
0: 
0: 			if (bytesToTransfer >= bytesInCurBuf)
0: 				bytesToTransferThisTime = bytesInCurBuf;
0: 			else
0: 				 bytesToTransferThisTime = (int)bytesToTransfer;
0: 			//
0: 			//Note read should never return 0. Thus we keep looping
0: 			//transferring bytes from the stream to our buffer until
0: 			//we transfer count bytes or reach the end of the stream.
0: 			//
0: 			bytesTransferredThisTime =
0: 				is.read(curBuf,curBufPos,bytesToTransferThisTime);
0: 
0: 			if (bytesTransferredThisTime > 0)
0: 			{
0:                 if (SanityManager.DEBUG)
0:                     SanityManager.ASSERT(
0:                         writing == true, "Writing should be true 3");
0: 
0: 				bytesToTransfer -= bytesTransferredThisTime;
0: 				curBufPos += bytesTransferredThisTime;
0: 			}
0: 		} while (bytesToTransfer > 0 &&
0: 				 bytesTransferredThisTime > 0);
0: 
0: 		return count - bytesToTransfer;
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#clear
0: 
0: 	  @exception IOException		Thrown on error
0: 	  */
0: 	public void clear() throws IOException
0: 	{
0: 		writing = true;
0: 		
0: 		curBuf = (byte[])bufV.elementAt(0);
0: 		this.curBufVEleAt = 0;
0: 		this.curBufPos = 0;
0: 		
0: 		lastBufVEleAt = 0;
0: 		lastBufDataBytes = 0;
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#startReading
0: 	  */
0: 	public void startReading()
0:         throws IOException
0: 	{
0: 		if (writing == true)
0: 		{
0: 			//Enter read mode.
0: 			writing = false;
0: 			lastBufDataBytes = curBufPos;
0: 			lastBufVEleAt = curBufVEleAt;
0: 		}
0: 		//
0: 		//Reposition so reads start from the first
0: 		//byte.
0: 		curBuf = (byte[])bufV.elementAt(0);
0: 		this.curBufVEleAt = 0;
0: 		this.curBufPos = 0;
0: 		if (curBufVEleAt == lastBufVEleAt)
0: 			curBufDataBytes = lastBufDataBytes;
0: 		else
0: 			curBufDataBytes = bufSize;
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#read
0: 	  @exception IOException	Thrown on error
0: 	  */
0: 	public int read() throws IOException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(writing == false,
0: 								 "Reading should be true 2");
0: 		
0: 		if (curBufPos >= curBufDataBytes)
0: 			getNextBuffer_r();
0: 
0: 		if (curBufPos >= curBufDataBytes)
0: 			return -1;
0: 		else
0: 			return 0xff & curBuf[curBufPos++];
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#read
0: 	  @exception IOException	Thrown on error
0: 	  */
0: 	public int read(byte b[],
0: 					int off,
0: 					int len)
0: 		throws IOException
0: 	{
0: 		return (read(b, off, (OutputStream) null, len));
0: 	}
0: 
0: 	public int read(OutputStream out,
0: 					int len)
0: 		throws IOException
0: 	{
0: 		return(read((byte []) null, 0, out, len));
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#read
0: 	  @exception IOException	Thrown on error
0: 	  */
0: 	public int read(byte b[],
0: 					int off,
0: 					OutputStream out,
0: 					int len)
0: 		throws IOException
0: 	{
0: 		int bytesIRead = 0;
0: 		boolean eof = false;
0: 		
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(writing == false,
0: 								 "Reading should be true 3");
0: 		
0: 		if (curBufPos >= curBufDataBytes)
0: 			eof = getNextBuffer_r();
0: 
0: 		if (eof) return -1;
0: 
0: 		while (len > 0 && !eof)
0: 		{
0: 			int bytesInCurBuf = curBufDataBytes - curBufPos;
0: 			int bytesIReadThisTime;
0: 			if (len >= bytesInCurBuf)
0: 				bytesIReadThisTime = bytesInCurBuf;
0: 			else
0: 				 bytesIReadThisTime = len;
0: 
0: 			if (out == null) {
0: 				// write the data to the byte array
0: 				System.arraycopy(curBuf,curBufPos,b,off,bytesIReadThisTime);
0: 			} else {
0: 				// write the data to the output stream
0: 				out.write(curBuf, curBufPos, bytesIReadThisTime);
0: 			}
0: 			off+=bytesIReadThisTime;
0: 			curBufPos+=bytesIReadThisTime;
0: 			len -= bytesIReadThisTime;
0: 			bytesIRead+=bytesIReadThisTime;
0: 			if (curBufPos >= curBufDataBytes)
0: 				eof = getNextBuffer_r();
0: 		}
0: 
0: 		return bytesIRead;
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#shiftToFront
0: 	  @exception IOException	Thrown on error
0: 	  */
0: 	public int shiftToFront() throws IOException
0: 	{
0: 		int remainingBytes = available();
0: 		remainingBytes = remainingBytes > 0 ? remainingBytes : (-1) * remainingBytes;
0: 
0: 		byte b[] = new byte[remainingBytes + 1];
0: 		int bytesRead = read(b, 0, remainingBytes);
0: 
0: 		// clear the buffer
0: 		clear();
0: 
0: 		// put the bytes at the beginning of the buffer
0: 		writing = true;
0: 		write(b, 0, bytesRead);
0: 
0: 		curBufDataBytes = 0;
0: 
0: 		return bytesRead;
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#available
0: 	  */
0: 	public int available()
0: 	{
0: 		//if (SanityManager.DEBUG)
0: 		//	SanityManager.ASSERT(writing == false,
0: 		//						 "Reading should be true 3");
0: 
0: 		int curBufAvailable = curBufDataBytes - curBufPos;
0: 		int lastBufAvailable = 0;
0: 		int middleBuffers = 0;
0: 		if (curBufVEleAt != lastBufVEleAt)
0: 		{			
0: 			middleBuffers = lastBufVEleAt - curBufVEleAt - 1;
0: 			lastBufAvailable = lastBufDataBytes;
0: 		}
0: 		int availableBytes =
0: 			curBufAvailable +
0: 			lastBufAvailable +
0: 			middleBuffers * bufSize;
0: 
0: 		return availableBytes;
0: 	}
0: 
0:     /**
0:  	  Return the number of bytes that have been saved to this byte holder.
0:       This result is different from available() as it is unaffected by the
0:       current read position on the ByteHolder.
0: 
0: 	  @see ByteHolder#numBytesSaved
0: 	  */
0: 	public int numBytesSaved()
0: 	{
0:         int ret_val;
0: 
0:         if (writing)
0:         {
0:             // still writing, so use the cur* variables
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(
0:                     lastBufVEleAt == 0 && lastBufDataBytes == 0,
0:                     "counters were somehow bumped during writing");
0: 
0:             ret_val = (curBufVEleAt * bufSize) + curBufPos;
0:         }
0:         else
0:         {
0:             ret_val = (lastBufVEleAt * bufSize) + lastBufDataBytes;
0:         }
0: 
0:         return(ret_val);
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#skip
0: 	  @exception IOException	Thrown on error
0: 	  */
0: 	public long skip(long count) throws IOException
0: 	{
0: 		long bytesISkipped = 0;
0: 		boolean eof = false;
0: 		
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(writing == false,
0: 								 "Reading should be true 4");
0: 		
0: 		if (curBufPos >= curBufDataBytes)
0: 			eof = getNextBuffer_r();
0: 
0: 		while (count > 0 && !eof)
0: 		{
0: 			int bytesInCurBuf = curBufDataBytes - curBufPos;
0: 			int bytesISkippedThisTime;
0: 			
0: 			if (count >= bytesInCurBuf)
0: 				bytesISkippedThisTime = bytesInCurBuf;
0: 			else
0: 				 bytesISkippedThisTime = (int)count;
0: 
0: 			curBufPos+=bytesISkippedThisTime;
0: 			count -= bytesISkippedThisTime;
0: 			bytesISkipped+=bytesISkippedThisTime;
0: 
0: 			if (count > 0)
0: 				eof = getNextBuffer_r();
0: 		}
0: 
0: 		return bytesISkipped;
0: 	}
0: 
0: 	/**
0: 	  @see ByteHolder#writingMode
0: 	 */
0: 	public boolean writingMode()
0: 	{
0: 		return writing;
0: 	}
0: 
0: 	/**
0: 	  Get the next buffer for writing bytes.
0: 	  @exception IOException	Thrown on error
0: 	  */
0: 	protected void getNextBuffer_w() throws IOException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			getNextBuffer_w_Sanity();
0: 		}
0: 		
0: 		curBufVEleAt++;
0: 
0: 		if (bufV.size() <= curBufVEleAt)
0: 		{
0: 			curBuf = new byte[bufSize];
0: 			bufV.addElement(curBuf);
0: 		}
0: 		else
0: 		{
0: 			curBuf = (byte[])bufV.elementAt(curBufVEleAt);
0: 		}
0: 		
0: 		initBuffer_w();
0: 	}
0: 
0: 	/** Do sanity checking when getting the next write buffer */
0: 	protected void getNextBuffer_w_Sanity()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(curBufPos == curBuf.length,
0: 								 "partial write");
0: 
0: 			SanityManager.ASSERT(writing == true,
0: 								 "Writing should be true 5");
0: 		}
0: 	}
0: 		
0: 	/** Initialize a buffer for writing */
0: 	protected void initBuffer_w()
0: 	{
0: 		curBufPos = 0;
0: 		
0: 		if (SanityManager.DEBUG)
0: 		{
0: 		    SanityManager.ASSERT(curBuf.length == bufSize,
0: 								 "bad Buf Length "+curBuf.length);
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Get the next buffer for reading bytes.
0: 
0: 	  @return true if the user has read all the bytes
0: 	  in this ByteHolder.
0: 
0: 	  @exception IOException		Thrown on error
0: 	  */
0: 	protected boolean getNextBuffer_r() throws IOException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(writing == false,
0: 								 "Reading should be true 5");
0: 		if (curBufVEleAt >= lastBufVEleAt) return true;
0: 		curBuf = (byte[])bufV.elementAt(++curBufVEleAt);
0: 		curBufPos = 0;
0: 		if (curBufVEleAt == lastBufVEleAt)
0: 			curBufDataBytes = lastBufDataBytes;
0: 		else
0: 			curBufDataBytes = bufSize;
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	  Create a string representation of an internal buffer of bytes.
0: 	  This is useful during debugging.
0: 	  */
0: 	private String dumpBuf(int bufVEleAt)
0: 	{
0: 		StringBuffer sb = new StringBuffer(100);
0: 
0: 		byte[] buf = (byte[])bufV.elementAt(bufVEleAt);
0: 		sb.append("(");
0: 		for (int ix = 0;ix<buf.length;ix++)
0: 			sb.append(buf[ix]+".");
0: 		sb.append(")");
0: 		return sb.toString();
0: 	}
0: 
0: 	/**
0: 	  Produce a string describing the state of this ByteHolder.
0: 	  This is mainly for debugging.
0: 	  */
0: 	public String toString()
0: 	{
0: 		return
0: 			" writing: "+writing+
0: 			" curBufVEleAt: "+curBufVEleAt+
0: 			" curBufPos: "+curBufPos+
0: 			" curBufDataBytes: "+curBufDataBytes+
0: 			" lastBufVEleAt: "+lastBufVEleAt+
0:             " lastBufDataBytes: "+lastBufDataBytes+
0: 			" curBuf: "+dumpBuf(curBufVEleAt);
0: 	}
0: }
============================================================================