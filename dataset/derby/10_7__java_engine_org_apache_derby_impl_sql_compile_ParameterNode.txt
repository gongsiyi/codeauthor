8:eac0369: /*
35:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ParameterNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.sql.Types;
1:f33fbaf: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.ClassName;
1:7ab414c: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.JSQLType;
1:eac0369: import org.apache.derby.iapi.types.TypeId;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * This node type represents a ? parameter.
10:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public class ParameterNode extends ValueNode
3:eac0369: {
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** The parameter number for this parameter.  The numbers start at 0.
1:eac0369: 	*/
1:7736829: 	private int	parameterNumber;
1:eac0369: 
1:ef158f2: 	/**
1:ef158f2: 	** Pointer to the array in the CompilerContext that holds array
1:ef158f2:     * of types for all the user-visible paramerers..  When each parameter is
1:eac0369: 	** bound, it fills in its type descriptor in this array.  Note that
1:eac0369: 	** the array is allocated in the parser, but the individual elements
1:eac0369: 	** are not filled in until their corresponding parameters are bound.
1:ef158f2:     *
1:ef158f2:     * This array is not read in this class, but is read from the
1:ef158f2:     * CompilerContext on completion of compiling the statement.
1:ef158f2:     * 
1:ef158f2:     *  In some case a parameter node may exist but is not a visble
1:ef158f2:     *  user parameter, in this case typeServices will be null
1:ef158f2:     *  so that setting its type will not modify the user's set.
1:eac0369: 	*/
1:eac0369: 
1:ef158f2: 	private DataTypeDescriptor[]	userParameterTypes;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** The default value for this parameter.  Currently, the only
1:eac0369: 	** reason for a parameter having a default value is for a
1:eac0369: 	** stored prepared statement, where they are supplied for
1:eac0369: 	** optimization.
1:eac0369: 	*/
1:7736829: 	private DataValueDescriptor		defaultValue;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	This ParameterNode may turn up as an argument to a replicated Work Unit.
1:eac0369: 	  *	If so, the remote system will have figured out the type of this node.
1:eac0369: 	  *	That's what this variable is for.
1:eac0369: 	  */
1:7736829: 	private	JSQLType			jsqlType;
1:eac0369: 
1:eac0369: 	private int orderableVariantType = Qualifier.QUERY_INVARIANT;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * By default, we assume we are just a normal, harmless
1:eac0369: 	 * little ole parameter.  But sometimes we may be a return
1:eac0369: 	 * parameter (e.g. ? = CALL myMethod()).  
1:eac0369: 	 */
1:eac0369: 	private ValueNode returnOutputParameter;
1:eac0369: 
1:eac0369: 	/**
1:cbdc90c: 	 * If this parameter node was created as part of a "probe predicate"
1:cbdc90c: 	 * for an InListOperatorNode then it does not actually correspond to
1:cbdc90c: 	 * a specific value--we just created it as a start-key place-holder
1:cbdc90c: 	 * for IN-list values at execution time.  In order to serve that
1:cbdc90c: 	 * purpose we need to generate some value that can be used as the
1:cbdc90c: 	 * place-holder.  Since this parameter node is "fake" and does not
1:cbdc90c: 	 * correspond to an actual parameter, we can't really generate it;
1:cbdc90c: 	 * so the following field holds some legitimate ValueNode--either a
1:cbdc90c: 	 * constant node or a "real" parameter node--that we can generate to
1:cbdc90c: 	 * serve as the place-holder.
1:eac0369: 	 */
1:cbdc90c: 	private ValueNode valToGenerate;
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a ParameterNode.
1:eac0369: 	 *
1:eac0369: 	 * @param parameterNumber			The number of this parameter,
1:eac0369: 	 *									(unique per query starting at 0)
1:eac0369: 	 * @param defaultValue				The default value for this parameter
1:3bb140c:      * @param cm                        The context manager
1:eac0369: 	 */
1:3bb140c:     ParameterNode(int parameterNumber,
1:3bb140c:                   DataValueDescriptor defaultValue,
1:3bb140c:                   ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:         this.parameterNumber = parameterNumber;
1:3bb140c:         this.defaultValue = defaultValue;
2:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the parameter number
1:eac0369: 	 *
1:eac0369: 	 * @return	The parameter number
1:eac0369: 	 */
1:eac0369: 
1:7736829: 	int getParameterNumber()
1:eac0369: 	{
1:eac0369: 		return parameterNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the descriptor array
1:eac0369: 	 *
1:6b50965: 	 * @param	descriptors	The array of DataTypeServices to fill in when the parameters
1:eac0369: 	 *			are bound.
1:eac0369: 	 */
1:eac0369: 
1:7736829: 	void setDescriptors(DataTypeDescriptor[] descriptors)
1:eac0369: 	{
1:ef158f2: 		userParameterTypes = descriptors;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the DataTypeServices for this parameter
1:eac0369: 	 *
1:eac0369: 	 * @param descriptor	The DataTypeServices to set for this parameter
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void setType(DataTypeDescriptor descriptor) throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Make sure the type is nullable. */
1:32812bd: 
1:32812bd: 		/*
1:32812bd: 		 ** Generate a new descriptor with all the same properties as
1:32812bd: 		 ** the given one, except that it is nullable.
1:32812bd: 		 */
1:32812bd: 		descriptor = descriptor.getNullabilityType(true);
1:32812bd: 		
1:eac0369: 
1:ef158f2:         if (userParameterTypes != null)
1:ef158f2: 		    userParameterTypes[parameterNumber] = descriptor;
1:eac0369: 
1:d5bc20f: 		//make sure we are calling super's setType. We will get into
1:d5bc20f: 		//an infinite loop if this setType ends up calling the local
1:d5bc20f: 		//setType method
1:d5bc20f: 		super.setType(descriptor);
1:eac0369: 
1:eac0369: 		if ( getJSQLType() == null ) { setJSQLType(  new JSQLType( descriptor ) ); }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this as a return output parameter (e.g.
1:eac0369: 	 * ? = CALL myMethod())
1:eac0369: 	 */
1:3bb140c:     void setReturnOutputParam(ValueNode valueNode)
1:eac0369: 	{
1:eac0369: 		returnOutputParameter = valueNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this as a return output parameter (e.g.
1:eac0369: 	 * ? = CALL myMethod())
1:eac0369: 	 *
1:eac0369: 	 * @return true if it is a return param
1:eac0369: 	 */
1:3bb140c:     boolean isReturnOutputParam()
1:eac0369: 	{
1:eac0369: 		return returnOutputParameter != null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  A parameter can't figure out what its type
1:eac0369: 	 * is without knowing where it appears, so this method does nothing.
1:eac0369: 	 * It is up to the node that points to this parameter node to figure
1:d5bc20f: 	 * out the type of the parameter and set it, using the setType()
1:eac0369: 	 * method above.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:eac0369: 	 *				expression is in, for binding columns.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode bindExpression(FromList fromList,
1:3bb140c:                              SubqueryList subqueryList,
1:3bb140c:                              List<AggregateNode> aggregates)
1:3bb140c:             throws StandardException
1:eac0369: 	{
1:eac0369: 		checkReliability( "?", CompilerContext.UNNAMED_PARAMETER_ILLEGAL );
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this expression tree represents a constant expression.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not this expression tree represents a constant expression.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isConstantExpression()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:01217c2: 
1:eac0369: 	/** @see ValueNode#constantExpression */
1:3bb140c:     @Override
1:3bb140c:     boolean constantExpression(PredicateList whereClause)
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:01217c2: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (method calls and non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *							  (constant expressions)
1:eac0369: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected int getOrderableVariantType()
1:eac0369: 	{
1:eac0369: 		// Parameters are invariant for the life of the query
1:eac0369: 		return orderableVariantType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * In a special circumstance, we want to consider
1:eac0369: 	 * parameters as constants.  For that situation, we
1:eac0369: 	 * allow a caller to temporarily set us to CONSTANT
1:eac0369: 	 * and then restore us.
1:eac0369: 	 */
1:eac0369: 	void setOrderableVariantType(int type)
1:eac0369: 	{
1:eac0369: 		orderableVariantType = type;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	OVERRIDE METHODS IN VALUE NODE THAT ARE USED WHILE BINDING REPLICATED
1:eac0369: 	//	CALL WORK STATEMENTS.
1:eac0369: 	//
1:eac0369: 	//	In this scenario, a JSQLType was replicated along with this parameter.
1:eac0369: 	//	The JSQLType represents the bind() decision of the remote system, which
1:eac0369: 	//	we want to reproduce locally.
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Set the JSQLType of this parameter. This supports the unnamed parameters
1:eac0369: 	  *	that we use for replicated work units.
1:eac0369: 	  *
1:eac0369: 	  *	@param	type	the JSQLType associated with this parameter
1:eac0369: 	  */
1:eac0369: 	public	void	setJSQLType
1:eac0369: 	(
1:eac0369: 		JSQLType	type
1:eac0369: 	)
1:eac0369: 	{ jsqlType = type; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the JSQLType associated with this parameter. Again, part of method
1:eac0369: 	  *	resolution for replicated work units.
1:eac0369: 	  *
1:eac0369: 	  *	@return	the JSQLType that the remote system assigned
1:eac0369: 	  */
1:eac0369: 	public	JSQLType	getJSQLType()
1:eac0369: 	{
1:eac0369: 		return jsqlType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CODE GENERATOR
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:698e318: 	 * For a ParameterNode, we generate for the return value:
1:eac0369: 	 *
1:eac0369: 	 *		(<java type name>)
1:698e318: 	 *			( (BaseActivation) this.getParameter(parameterNumber) )
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
3:eac0369: 									throws StandardException
1:eac0369: 	{
1:cbdc90c: 		/* If we were given a specific ValueNode to generate then
1:7777c5d: 		 * just use that.  See, in particular, the preprocess method
1:7777c5d: 		 * of InListOperatorNode.
1:eac0369: 		 */
1:cbdc90c: 		if (valToGenerate != null)
1:eac0369: 		{
1:cbdc90c: 			valToGenerate.generateExpression(acb, mb);
1:cbdc90c: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		DataTypeDescriptor dtd = getTypeServices();
1:099e28f: 		if ((dtd != null) && dtd.getTypeId().isXMLTypeId()) {
1:099e28f: 		// We're a parameter that corresponds to an XML column/target,
1:099e28f: 		// which we don't allow.  We throw the error here instead of
1:099e28f: 		// in "bindExpression" because at the time of bindExpression,
1:099e28f: 		// we don't know yet what the type is going to be (only when
1:099e28f: 		// the node that points to this parameter calls
1:d5bc20f: 		// "setType" do we figure out the type).
1:099e28f: 			throw StandardException.newException(
1:099e28f: 				SQLState.LANG_ATTEMPT_TO_BIND_XML);
1:eac0369: 		}
1:eac0369: 
1:7736829:         /* Generate the return value */
1:eac0369: 
1:7ab414c:         mb.pushThis();
1:eac0369:         mb.push(parameterNumber); // arg
1:eac0369: 
1:6fbf34b:         mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "getParameter",
1:eac0369:                       ClassName.DataValueDescriptor, 1);
1:eac0369: 
1:eac0369: 		// For some types perform host variable checking
1:eac0369: 		// to match DB2/JCC where if a host variable is too
1:eac0369: 		// big it is not accepted, regardless of any trailing padding.
1:eac0369: 
1:eac0369: 		switch (dtd.getJDBCTypeId()) {
1:eac0369: 		case Types.BINARY:
1:eac0369: 		case Types.VARBINARY:
1:eac0369: 		case Types.LONGVARBINARY:
1:eac0369: 		case Types.BLOB:
1:eac0369: 			mb.dup();
1:eac0369: 			mb.push(dtd.getMaximumWidth());
1:eac0369: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "checkHostVariable",
1:eac0369:                       "void", 1);
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		default:
1:eac0369: 			break;
1:eac0369: 		}
1:eac0369: 
1:eac0369:         /* Cast the result to its specific interface */
1:eac0369:         mb.cast(getTypeCompiler().interfaceName());
1:eac0369: 	} // End of generateExpression
1:eac0369: 
1:3bb140c:     @Override
1:3bb140c:     TypeId getTypeId() throws StandardException
1:eac0369: 	{
1:eac0369: 		return (returnOutputParameter != null) ?
1:eac0369: 			returnOutputParameter.getTypeId() : super.getTypeId();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	STATIC ROUTINES
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the code to create the ParameterValueSet, if necessary,
1:eac0369: 	 * when constructing the activation.  Also generate the code to call
1:eac0369: 	 * a method that will throw an exception if we try to execute without
1:eac0369: 	 * all the parameters being set.
1:eac0369: 	 * 
1:eac0369: 	 * This generated code goes into the Activation's constructor early on.
1:eac0369: 	 * 
1:eac0369: 	 * @param acb					The ExpressionClassBuilder for the class we're building
1:eac0369: 	 * @param numberOfParameters	number of parameters for this statement
1:eac0369: 	 * @param parameterList			The parameter list for the statement.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:9f2ed7d:     static void generateParameterValueSet(ExpressionClassBuilder acb,
1:eac0369: 								   int		numberOfParameters,
1:3bb140c:                                    List<ParameterNode>     parameterList)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (numberOfParameters > 0)
1:eac0369: 		{
2:eac0369: 			MethodBuilder	constructor = acb.getConstructor();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Check the first parameter to see if it is a return
1:eac0369: 			** parameter.
1:eac0369: 			*/
1:3bb140c:             boolean
1:3bb140c:                 hasReturnParam = (parameterList.get(0)).isReturnOutputParam();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Generate the following:
2:eac0369: 			**
1:eac0369: 			** pvs =
1:eac0369: 			**		getLanguageConnectionContext()
1:eac0369: 			**			.getLanguageFactory()
1:eac0369: 			**					.getParameterValueSet(numberOfParameters);
1:eac0369: 			**
1:eac0369: 			** pvs is a ParameterValueSet that lives in the superclass of
1:eac0369: 			** the activation being generated.
1:eac0369: 			*/
1:eac0369: 
1:eac0369: 			constructor.pushThis(); // for the put field down below
1:eac0369: 
1:eac0369: 			/* Generate the call to getContext */
1:eac0369: 			//?X constructor.pushThis();
1:eac0369: 			//?Xconstructor.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Activation, "getLanguageConnectionContext",
1:eac0369: 			//?X					ClassName.LanguageConnectionContext, 0);
1:eac0369: 			/*
1:eac0369: 			** Call getLanguageFactory()
1:eac0369: 			*/
1:eac0369: 			//?Xconstructor.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getLanguageFactory",
1:eac0369: 			//?X					ClassName.LanguageFactory, 0);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Call getParameterValueSet(<number of parameters>, <hasReturnParam>)
1:eac0369: 			*/
1:eac0369: 
1:eac0369: 			constructor.push(numberOfParameters); // first arg
1:eac0369: 			constructor.push(hasReturnParam); // second arg
1:eac0369: 
1:eac0369: 			constructor.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation,
1:eac0369: 									"setParameterValueSet", "void", 2);
1:eac0369: 
1:eac0369: 			//?Xconstructor.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getParameterValueSet",
1:eac0369: 			//?X					ClassName.ParameterValueSet, 2);
1:eac0369: 
1:eac0369: 			/* Assign the return from getParameterValueSet() to the field */
1:eac0369: 			//?Xconstructor.putField(ClassName.BaseActivation, "pvs", ClassName.ParameterValueSet);
1:eac0369: 			//?Xconstructor.endStatement();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Add a call to the execute() method to check
1:eac0369: 			** for missing parameters
1:eac0369: 			*/
1:eac0369: 			MethodBuilder	executeMethod = acb.getExecuteMethod();
1:eac0369: 
1:eac0369: 			executeMethod.pushThis();
1:eac0369: 			executeMethod.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "throwIfMissingParms", "void", 0);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the default value for the parameter.  Parameters
1:eac0369: 	 * may get default values for optimization purposes.
1:eac0369: 	 *
1:eac0369: 	 * @return the value, may be null
1:eac0369: 	 */
1:eac0369: 	DataValueDescriptor getDefaultValue()
1:eac0369: 	{
1:eac0369: 		return defaultValue;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:d5bc20f: 	 * @see ValueNode#requiresTypeFromContext
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean requiresTypeFromContext()
1:eac0369: 	{
1:d5bc20f: 		return true;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * @see ValueNode#isParameterNode
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isParameterNode()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:01217c2:      * @inheritDoc
1:01217c2:      */
1:2706d1f:     boolean isEquivalent(ValueNode o)
1:01217c2:     {
1:01217c2:     	return false;
1:01217c2:     }
1:eac0369: 
1:cbdc90c:     /**
1:cbdc90c:      * Save the received ValueNode locally so that we can generate it
1:cbdc90c:      * (in place of "this") at generation time.  See the preprocess()
1:cbdc90c:      * method of InListOperatorNode for more on how this is used.
1:eac0369:      *
1:4ef879d:      * @param vn The ValueNode to generate in place of this ParameterNode.
1:eac0369:      */
1:cbdc90c:     protected void setValueToGenerate(ValueNode vn)
1:eac0369:     {
1:cbdc90c:         valToGenerate = vn;
1:eac0369:     }
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     boolean isEquivalent(ValueNode o)
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a ParameterNode.
1:      * @param cm                        The context manager
1:     ParameterNode(int parameterNumber,
1:                   DataValueDescriptor defaultValue,
1:                   ContextManager cm) {
1:         super(cm);
0:         setNodeType(C_NodeTypes.PARAMETER_NODE);
1:         this.parameterNumber = parameterNumber;
1:         this.defaultValue = defaultValue;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void setType(DataTypeDescriptor descriptor) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void setReturnOutputParam(ValueNode valueNode)
/////////////////////////////////////////////////////////////////////////
1:     boolean isReturnOutputParam()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode bindExpression(FromList fromList,
1:                              SubqueryList subqueryList,
1:                              List<AggregateNode> aggregates)
1:             throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isConstantExpression()
1:     @Override
1:     boolean constantExpression(PredicateList whereClause)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     TypeId getTypeId() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:                                    List<ParameterNode>     parameterList)
/////////////////////////////////////////////////////////////////////////
1:             boolean
1:                 hasReturnParam = (parameterList.get(0)).isReturnOutputParam();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean requiresTypeFromContext()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isParameterNode()
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     static void generateParameterValueSet(ExpressionClassBuilder acb,
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
0:     ValueNode bindExpression(
0:             FromList fromList, SubqueryList subqueryList, List aggregates)
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
commit:38b5979
/////////////////////////////////////////////////////////////////////////
0: 								   List     parameterList)
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			List aggregateVector)
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0: 			boolean hasReturnParam = ((ParameterNode)parameterList.get(0)).isReturnOutputParam();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9953d37
/////////////////////////////////////////////////////////////////////////
commit:32812bd
/////////////////////////////////////////////////////////////////////////
1: 
1: 		/*
1: 		 ** Generate a new descriptor with all the same properties as
1: 		 ** the given one, except that it is nullable.
1: 		 */
1: 		descriptor = descriptor.getNullabilityType(true);
1: 		
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	** Pointer to the array in the CompilerContext that holds array
1:     * of types for all the user-visible paramerers..  When each parameter is
1:     *
1:     * This array is not read in this class, but is read from the
1:     * CompilerContext on completion of compiling the statement.
1:     * 
1:     *  In some case a parameter node may exist but is not a visble
1:     *  user parameter, in this case typeServices will be null
1:     *  so that setting its type will not modify the user's set.
1: 	private DataTypeDescriptor[]	userParameterTypes;
/////////////////////////////////////////////////////////////////////////
1: 		userParameterTypes = descriptors;
/////////////////////////////////////////////////////////////////////////
0: 		SanityManager.ASSERT(userParameterTypes != null,
/////////////////////////////////////////////////////////////////////////
1:         if (userParameterTypes != null)
1: 		    userParameterTypes[parameterNumber] = descriptor;
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @inheritDoc
1:      */
0:     protected boolean isEquivalent(ValueNode o)
1:     {
1:     	return false;
1:     }
commit:698e318
/////////////////////////////////////////////////////////////////////////
1: 	 * For a ParameterNode, we generate for the return value:
1: 	 *			( (BaseActivation) this.getParameter(parameterNumber) )
/////////////////////////////////////////////////////////////////////////
commit:7736829
/////////////////////////////////////////////////////////////////////////
1: 	private int	parameterNumber;
/////////////////////////////////////////////////////////////////////////
0: 	private DataTypeDescriptor[]	typeServices;
/////////////////////////////////////////////////////////////////////////
1: 	private DataValueDescriptor		defaultValue;
1: 	private	JSQLType			jsqlType;
/////////////////////////////////////////////////////////////////////////
1: 	int getParameterNumber()
/////////////////////////////////////////////////////////////////////////
1: 	void setDescriptors(DataTypeDescriptor[] descriptors)
/////////////////////////////////////////////////////////////////////////
1:         /* Generate the return value */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ParameterNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
1: import org.apache.derby.iapi.types.JSQLType;
1: 
1: import org.apache.derby.iapi.types.TypeId;
1: 
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.execute.BaseActivation;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
1: import java.sql.Types;
1: 
0: import java.util.Enumeration;
0: import java.util.Vector;
1: 
1: /**
1:  * This node type represents a ? parameter.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
1: public class ParameterNode extends ValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/*
1: 	** The parameter number for this parameter.  The numbers start at 0.
1: 	*/
0: 	int	parameterNumber;
1: 
1: 	/*
0: 	** We want to know if this node was generated or not.
0: 	** It will be skipped if it was in a predicate that
0: 	** was optimized out of the query.  Skipped parameters
0: 	** need to do some minimal generation so that we can
0: 	** make users pass in parameter values for us to ignore.
1: 	*/
0: 	private boolean generated;
1: 
1: 	/*
0: 	** Pointer to the array in the DMLStatementNode that holds the
0: 	** DataTypeServices for the parameters.  When each parameter is
1: 	** bound, it fills in its type descriptor in this array.  Note that
1: 	** the array is allocated in the parser, but the individual elements
1: 	** are not filled in until their corresponding parameters are bound.
1: 	*/
1: 
0: 	DataTypeDescriptor[]	typeServices;
1: 
1: 	/*
1: 	** The default value for this parameter.  Currently, the only
1: 	** reason for a parameter having a default value is for a
1: 	** stored prepared statement, where they are supplied for
1: 	** optimization.
1: 	*/
0: 	DataValueDescriptor		defaultValue;
1: 
1: 	/**
1: 	  *	This ParameterNode may turn up as an argument to a replicated Work Unit.
1: 	  *	If so, the remote system will have figured out the type of this node.
1: 	  *	That's what this variable is for.
1: 	  */
0: 	protected	JSQLType			jsqlType;
1: 
1: 	private int orderableVariantType = Qualifier.QUERY_INVARIANT;
1: 
1: 	/**
1: 	 * By default, we assume we are just a normal, harmless
1: 	 * little ole parameter.  But sometimes we may be a return
1: 	 * parameter (e.g. ? = CALL myMethod()).  
1: 	 */
1: 	private ValueNode returnOutputParameter;
1: 
1: 	/**
0: 	 * Constructor for use by the NodeFactory
1: 	 */
0: 	public ParameterNode()
1: 	{
1: 	}
1: 
1: 	/**
0: 	 * Initializer for a ParameterNode.
1: 	 *
1: 	 * @param parameterNumber			The number of this parameter,
1: 	 *									(unique per query starting at 0)
1: 	 * @param defaultValue				The default value for this parameter
1: 	 *
1: 	 */
1: 
0: 	public void init(Object parameterNumber, Object defaultValue)
1: 	{
0: 		this.defaultValue = (DataValueDescriptor) defaultValue;
0: 		this.parameterNumber = ((Integer) parameterNumber).intValue();
1: 	}
1: 
1: 	/**
1: 	 * Get the parameter number
1: 	 *
1: 	 * @return	The parameter number
1: 	 */
1: 
0: 	public	int getParameterNumber()
1: 	{
1: 		return parameterNumber;
1: 	}
1: 
1: 	/**
1: 	 * Set the descriptor array
1: 	 *
0: 	 * @param	The array of DataTypeServices to fill in when the parameters
1: 	 *			are bound.
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void setDescriptors(DataTypeDescriptor[] descriptors)
1: 	{
1: 
0:         // The following is commented out for #3546, for create publication 
0:         // or target ddl creations there could be multiple statements trying
0:         // to bind their own parameters. So the following assumptions does not
0:         // hold true. 
1: 
0: 	//	if (SanityManager.DEBUG)
0: 	//	SanityManager.ASSERT(typeServices == null,
0: 	//		"Attempt to re-set typeServices");
1: 
0: 		typeServices = descriptors;
1: 	}
1: 
1: 	/**
1: 	 * Set the DataTypeServices for this parameter
1: 	 *
1: 	 * @param descriptor	The DataTypeServices to set for this parameter
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void setDescriptor(DataTypeDescriptor descriptor)
1: 	{
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(typeServices != null,
0: 			"typeServices not initialized");
1: 
0: 		// if type already determined, there's nothing to do.
0: 		// this can occur if a named parameter ("?paramName") is
0: 		// set equal to a unnamed parameter ("?") in a COPY PUBLICATION
0: 		// statement. in this case, the named parameter may be referenced
0: 		// multiple times. each time it must resolve to the same "?"
0: 		// parameter.
1: 
0: 		if ( typeServices[parameterNumber] != null ) { return; }
1: 
1: 		/* Make sure the type is nullable. */
0: 		if ( ! descriptor.isNullable())
1: 		{
1: 			/*
0: 			** Generate a new descriptor with all the same properties as
0: 			** the given one, except that it is nullable.
1: 			*/
0: 			descriptor = new DataTypeDescriptor(descriptor, true);
1: 		}
1: 
0: 		typeServices[parameterNumber] = descriptor;
1: 
0: 		setType(descriptor);
1: 
1: 		if ( getJSQLType() == null ) { setJSQLType(  new JSQLType( descriptor ) ); }
1: 	}
1: 
1: 	/**
1: 	 * Mark this as a return output parameter (e.g.
1: 	 * ? = CALL myMethod())
1: 	 */
0: 	public void setReturnOutputParam(ValueNode valueNode)
1: 	{
1: 		returnOutputParameter = valueNode;
1: 	}
1: 
1: 	/**
1: 	 * Is this as a return output parameter (e.g.
1: 	 * ? = CALL myMethod())
1: 	 *
1: 	 * @return true if it is a return param
1: 	 */
0: 	public boolean isReturnOutputParam()
1: 	{
1: 		return returnOutputParameter != null;
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  A parameter can't figure out what its type
1: 	 * is without knowing where it appears, so this method does nothing.
1: 	 * It is up to the node that points to this parameter node to figure
0: 	 * out the type of the parameter and set it, using the setDescriptor()
1: 	 * method above.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(
0: 			FromList fromList, SubqueryList subqueryList,
0: 			Vector	aggregateVector) 
1: 				throws StandardException
1: 	{
1: 		checkReliability( "?", CompilerContext.UNNAMED_PARAMETER_ILLEGAL );
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree represents a constant expression.
1: 	 *
1: 	 * @return	Whether or not this expression tree represents a constant expression.
1: 	 */
0: 	public boolean isConstantExpression()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (method calls and non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *							  (constant expressions)
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 */
1: 	protected int getOrderableVariantType()
1: 	{
1: 		// Parameters are invariant for the life of the query
1: 		return orderableVariantType;
1: 	}
1: 
1: 	/**
1: 	 * In a special circumstance, we want to consider
1: 	 * parameters as constants.  For that situation, we
1: 	 * allow a caller to temporarily set us to CONSTANT
1: 	 * and then restore us.
1: 	 */
1: 	void setOrderableVariantType(int type)
1: 	{
1: 		orderableVariantType = type;
1: 	}
1: 
1: 	////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	OVERRIDE METHODS IN VALUE NODE THAT ARE USED WHILE BINDING REPLICATED
1: 	//	CALL WORK STATEMENTS.
1: 	//
1: 	//	In this scenario, a JSQLType was replicated along with this parameter.
1: 	//	The JSQLType represents the bind() decision of the remote system, which
1: 	//	we want to reproduce locally.
1: 	//
1: 	////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	  *	Set the JSQLType of this parameter. This supports the unnamed parameters
1: 	  *	that we use for replicated work units.
1: 	  *
1: 	  *	@param	type	the JSQLType associated with this parameter
1: 	  */
1: 	public	void	setJSQLType
1: 	(
1: 		JSQLType	type
1: 	)
1: 	{ jsqlType = type; }
1: 
1: 	/**
1: 	  *	Get the JSQLType associated with this parameter. Again, part of method
1: 	  *	resolution for replicated work units.
1: 	  *
1: 	  *	@return	the JSQLType that the remote system assigned
1: 	  */
1: 	public	JSQLType	getJSQLType()
1: 	{
1: 		return jsqlType;
1: 	}
1: 
1: 
1: 	////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CODE GENERATOR
1: 	//
1: 	////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * For a ParameterNode, we generate a call to the type factory
0: 	 * to get a DataValueDescriptor, and pass the result to the
0: 	 * setStorableDataValue method of the ParameterValueSet for the
0: 	 * generated class.  We push the DataValueDescriptor field as the
0: 	 * generated expression.
1: 	 *
0: 	 * Generated code:
1: 	 *
0: 	 *   In the constructor for the generated class:
1: 	 *
0: 	 *	((ParameterValueSet) pvs).
0: 	 *		setStorableDataValue(
0: 	 *				<generated null>,
0: 	 *				parameterNumber, jdbcType, className);
1: 	 *
0: 	 *   For the return value:
1: 	 *
1: 	 *		(<java type name>)
0: 	 *			( (ParameterValueSet) pvs.
0: 	 *					getParameter(parameterNumber) )
1: 	 *
0: 	 * pvs is a ParameterValueSet that lives in the superclass of the class
0: 	 * being generated.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
0: 		// PUSHCOMPILE
0: 		/* Reuse code if possible */
0: 		//if (genRetval != null)
0: 		//	return genRetval;
1: 
1:         /*
0:         ** First, generate the holder in the constructor.
1:         */
0:         generateHolder(acb);
1: 
0:         /* now do the return value */
1: 
0:         /* First, get the field that holds the ParameterValueSet */
0:         acb.pushPVSReference(mb);
1: 
1:         mb.push(parameterNumber); // arg
1: 
0:         mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getParameter",
1:                       ClassName.DataValueDescriptor, 1);
1: 
1: 		// For some types perform host variable checking
1: 		// to match DB2/JCC where if a host variable is too
1: 		// big it is not accepted, regardless of any trailing padding.
1: 		DataTypeDescriptor dtd = getTypeServices();
1: 
1: 		switch (dtd.getJDBCTypeId()) {
1: 		case Types.BINARY:
1: 		case Types.VARBINARY:
1: 		case Types.LONGVARBINARY:
1: 		case Types.BLOB:
1: 			mb.dup();
1: 			mb.push(dtd.getMaximumWidth());
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "checkHostVariable",
1:                       "void", 1);
1: 			break;
1: 
1: 		default:
1: 			break;
1: 		}
1: 
1:         /* Cast the result to its specific interface */
1:         mb.cast(getTypeCompiler().interfaceName());
1: 	} // End of generateExpression
1: 
1: 	/*
0: 	** parameters might never be used, but still need
0: 	** to have space allocated for them and be assigned
0: 	** to, for the query to operate.
1: 	**
0: 	** This generates the minimum code needed to make
0: 	** the parameter exist.
1: 	*/
0: 	void generateHolder(ExpressionClassBuilder acb) throws StandardException {
1: 
1: 		MethodBuilder	constructor = acb.getConstructor();
1: 
0: 		if (generated) return;
0: 		generated = true;
1: 
1: 		/*
0: 		** First, build the statement in the constructor.
1: 		*/
0: 		acb.pushPVSReference(constructor);
1: 
0: 		acb.generateNull(constructor, getTypeCompiler()); constructor.upCast(ClassName.DataValueDescriptor);
1: 
0: 		constructor.push(parameterNumber); // second arg
0: 		TypeId myId = getTypeId();
0: 		constructor.push(myId.getJDBCTypeId()); // third arg
0: 		constructor.push(myId.getCorrespondingJavaTypeName()); // fouth arg
1: 
0: 		constructor.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "setStorableDataValue", "void", 4);
1: 
0: 		/* The constructor portion is done */
1: 	}
1: 
0: 	public TypeId getTypeId()
1: 	{
1: 		return (returnOutputParameter != null) ?
1: 			returnOutputParameter.getTypeId() : super.getTypeId();
1: 	}
1: 
1: 	////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	STATIC ROUTINES
1: 	//
1: 	////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Generate the code to create the ParameterValueSet, if necessary,
1: 	 * when constructing the activation.  Also generate the code to call
1: 	 * a method that will throw an exception if we try to execute without
1: 	 * all the parameters being set.
1: 	 * 
1: 	 * This generated code goes into the Activation's constructor early on.
1: 	 * 
1: 	 * @param acb					The ExpressionClassBuilder for the class we're building
1: 	 * @param numberOfParameters	number of parameters for this statement
1: 	 * @param parameterList			The parameter list for the statement.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	static public	void generateParameterValueSet(ExpressionClassBuilder	acb,
1: 								   int		numberOfParameters,
0: 								   Vector	parameterList)
1: 		throws StandardException
1: 	{
1: 		if (numberOfParameters > 0)
1: 		{
1: 			MethodBuilder	constructor = acb.getConstructor();
1: 
1: 			/*
1: 			** Check the first parameter to see if it is a return
1: 			** parameter.
1: 			*/
0: 			boolean hasReturnParam = ((ParameterNode)parameterList.elementAt(0)).isReturnOutputParam();
1: 
1: 			/*
1: 			** Generate the following:
1: 			**
1: 			** pvs =
1: 			**		getLanguageConnectionContext()
1: 			**			.getLanguageFactory()
1: 			**					.getParameterValueSet(numberOfParameters);
1: 			**
1: 			** pvs is a ParameterValueSet that lives in the superclass of
1: 			** the activation being generated.
1: 			*/
1: 
1: 			constructor.pushThis(); // for the put field down below
1: 
1: 			/* Generate the call to getContext */
1: 			//?X constructor.pushThis();
1: 			//?Xconstructor.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Activation, "getLanguageConnectionContext",
1: 			//?X					ClassName.LanguageConnectionContext, 0);
1: 			/*
1: 			** Call getLanguageFactory()
1: 			*/
1: 			//?Xconstructor.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getLanguageFactory",
1: 			//?X					ClassName.LanguageFactory, 0);
1: 
1: 			/*
1: 			** Call getParameterValueSet(<number of parameters>, <hasReturnParam>)
1: 			*/
1: 
1: 			constructor.push(numberOfParameters); // first arg
1: 			constructor.push(hasReturnParam); // second arg
1: 
1: 			constructor.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation,
1: 									"setParameterValueSet", "void", 2);
1: 
1: 			//?Xconstructor.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getParameterValueSet",
1: 			//?X					ClassName.ParameterValueSet, 2);
1: 
1: 			/* Assign the return from getParameterValueSet() to the field */
1: 			//?Xconstructor.putField(ClassName.BaseActivation, "pvs", ClassName.ParameterValueSet);
1: 			//?Xconstructor.endStatement();
1: 
1: 			/*
1: 			** Add a call to the execute() method to check
1: 			** for missing parameters
1: 			*/
1: 			MethodBuilder	executeMethod = acb.getExecuteMethod();
1: 
1: 			executeMethod.pushThis();
1: 			executeMethod.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "throwIfMissingParms", "void", 0);
1: 		}
1: 	}
1: 
1: 	/*
0: 	** When all other generation is done for the statement,
0: 	** we need to ensure all of the parameters have been touched.
1: 	*
0: 	*	@param	acb				ExpressionClassBuilder
0: 	*	@param	parameterList	list of parameter
1: 	*
1: 	* @exception StandardException		Thrown on error
1: 	*/
0: 	static	public	void generateParameterHolders
0: 	( ExpressionClassBuilder acb, Vector parameterList ) 
1: 		throws StandardException
1: 	{
0: 		if (parameterList == null) return;
1: 
0: 		for (Enumeration paramEnum = parameterList.elements(); 
0: 			 paramEnum.hasMoreElements(); )
1: 		{
0: 			((ParameterNode)paramEnum.nextElement()).generateHolder(acb);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the default value for the parameter.  Parameters
1: 	 * may get default values for optimization purposes.
1: 	 *
1: 	 * @return the value, may be null
1: 	 */
1: 	DataValueDescriptor getDefaultValue()
1: 	{
1: 		return defaultValue;
1: 	}
1: 	
1: 	/**
1: 	 * @see ValueNode#isParameterNode
1: 	 */
0: 	public boolean isParameterNode()
1: 	{
1: 		return true;
1: 	}
1: }
author:Army
-------------------------------------------------------------------------------
commit:7777c5d
/////////////////////////////////////////////////////////////////////////
1: 		 * just use that.  See, in particular, the preprocess method
1: 		 * of InListOperatorNode.
commit:4ef879d
/////////////////////////////////////////////////////////////////////////
1:      * @param vn The ValueNode to generate in place of this ParameterNode.
commit:cbdc90c
/////////////////////////////////////////////////////////////////////////
1: 	 * If this parameter node was created as part of a "probe predicate"
1: 	 * for an InListOperatorNode then it does not actually correspond to
1: 	 * a specific value--we just created it as a start-key place-holder
1: 	 * for IN-list values at execution time.  In order to serve that
1: 	 * purpose we need to generate some value that can be used as the
1: 	 * place-holder.  Since this parameter node is "fake" and does not
1: 	 * correspond to an actual parameter, we can't really generate it;
1: 	 * so the following field holds some legitimate ValueNode--either a
1: 	 * constant node or a "real" parameter node--that we can generate to
1: 	 * serve as the place-holder.
0: 	 */
1: 	private ValueNode valToGenerate;
0: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 		/* If we were given a specific ValueNode to generate then
0: 		 * just use that.
0: 		 */
1: 		if (valToGenerate != null)
0: 		{
1: 			valToGenerate.generateExpression(acb, mb);
1: 			return;
0: 		}
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Save the received ValueNode locally so that we can generate it
1:      * (in place of "this") at generation time.  See the preprocess()
1:      * method of InListOperatorNode for more on how this is used.
0:      *
0:      * @param The ValueNode to generate in place of this ParameterNode.
0:      */
1:     protected void setValueToGenerate(ValueNode vn)
0:     {
1:         valToGenerate = vn;
0:     }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param	descriptors	The array of DataTypeServices to fill in when the parameters
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6fbf34b
/////////////////////////////////////////////////////////////////////////
1:         mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "getParameter",
commit:7ab414c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.JSQLType;
0: import org.apache.derby.iapi.types.TypeId;
0: 
/////////////////////////////////////////////////////////////////////////
1:         mb.pushThis();
0:         mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "getParameter",
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 	public void setType(DataTypeDescriptor descriptor) throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 		//make sure we are calling super's setType. We will get into
1: 		//an infinite loop if this setType ends up calling the local
1: 		//setType method
1: 		super.setType(descriptor);
/////////////////////////////////////////////////////////////////////////
1: 	 * out the type of the parameter and set it, using the setType()
/////////////////////////////////////////////////////////////////////////
1: 		// "setType" do we figure out the type).
/////////////////////////////////////////////////////////////////////////
0: 	public TypeId getTypeId() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
1: 	 * @see ValueNode#requiresTypeFromContext
0: 	 */
0: 	public boolean requiresTypeFromContext()
0: 	{
1: 		return true;
0: 	}
commit:099e28f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
0: 		DataTypeDescriptor dtd = getTypeServices();
1: 		if ((dtd != null) && dtd.getTypeId().isXMLTypeId()) {
1: 		// We're a parameter that corresponds to an XML column/target,
1: 		// which we don't allow.  We throw the error here instead of
1: 		// in "bindExpression" because at the time of bindExpression,
1: 		// we don't know yet what the type is going to be (only when
1: 		// the node that points to this parameter calls
0: 		// "setDescriptor" do we figure out the type).
1: 			throw StandardException.newException(
1: 				SQLState.LANG_ATTEMPT_TO_BIND_XML);
0: 		}
0: 
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.iapi.types.JSQLType;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.execute.BaseActivation;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.sql.Types;
0: 
0: import java.util.Enumeration;
0: import java.util.Vector;
0: 
0: /**
0:  * This node type represents a ? parameter.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class ParameterNode extends ValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/*
0: 	** The parameter number for this parameter.  The numbers start at 0.
0: 	*/
0: 	int	parameterNumber;
0: 
0: 	/*
0: 	** We want to know if this node was generated or not.
0: 	** It will be skipped if it was in a predicate that
0: 	** was optimized out of the query.  Skipped parameters
0: 	** need to do some minimal generation so that we can
0: 	** make users pass in parameter values for us to ignore.
0: 	*/
0: 	private boolean generated;
0: 
0: 	/*
0: 	** Pointer to the array in the DMLStatementNode that holds the
0: 	** DataTypeServices for the parameters.  When each parameter is
0: 	** bound, it fills in its type descriptor in this array.  Note that
0: 	** the array is allocated in the parser, but the individual elements
0: 	** are not filled in until their corresponding parameters are bound.
0: 	*/
0: 
0: 	DataTypeDescriptor[]	typeServices;
0: 
0: 	/*
0: 	** The default value for this parameter.  Currently, the only
0: 	** reason for a parameter having a default value is for a
0: 	** stored prepared statement, where they are supplied for
0: 	** optimization.
0: 	*/
0: 	DataValueDescriptor		defaultValue;
0: 
0: 	/**
0: 	  *	This ParameterNode may turn up as an argument to a replicated Work Unit.
0: 	  *	If so, the remote system will have figured out the type of this node.
0: 	  *	That's what this variable is for.
0: 	  */
0: 	protected	JSQLType			jsqlType;
0: 
0: 	private int orderableVariantType = Qualifier.QUERY_INVARIANT;
0: 
0: 	/**
0: 	 * By default, we assume we are just a normal, harmless
0: 	 * little ole parameter.  But sometimes we may be a return
0: 	 * parameter (e.g. ? = CALL myMethod()).  
0: 	 */
0: 	private ValueNode returnOutputParameter;
0: 
0: 	/**
0: 	 * Constructor for use by the NodeFactory
0: 	 */
0: 	public ParameterNode()
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Initializer for a ParameterNode.
0: 	 *
0: 	 * @param parameterNumber			The number of this parameter,
0: 	 *									(unique per query starting at 0)
0: 	 * @param defaultValue				The default value for this parameter
0: 	 *
0: 	 */
0: 
0: 	public void init(Object parameterNumber, Object defaultValue)
0: 	{
0: 		this.defaultValue = (DataValueDescriptor) defaultValue;
0: 		this.parameterNumber = ((Integer) parameterNumber).intValue();
0: 	}
0: 
0: 	/**
0: 	 * Get the parameter number
0: 	 *
0: 	 * @return	The parameter number
0: 	 */
0: 
0: 	public	int getParameterNumber()
0: 	{
0: 		return parameterNumber;
0: 	}
0: 
0: 	/**
0: 	 * Set the descriptor array
0: 	 *
0: 	 * @param	The array of DataTypeServices to fill in when the parameters
0: 	 *			are bound.
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void setDescriptors(DataTypeDescriptor[] descriptors)
0: 	{
0: 
0:         // The following is commented out for #3546, for create publication 
0:         // or target ddl creations there could be multiple statements trying
0:         // to bind their own parameters. So the following assumptions does not
0:         // hold true. 
0: 
0: 	//	if (SanityManager.DEBUG)
0: 	//	SanityManager.ASSERT(typeServices == null,
0: 	//		"Attempt to re-set typeServices");
0: 
0: 		typeServices = descriptors;
0: 	}
0: 
0: 	/**
0: 	 * Set the DataTypeServices for this parameter
0: 	 *
0: 	 * @param descriptor	The DataTypeServices to set for this parameter
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void setDescriptor(DataTypeDescriptor descriptor)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(typeServices != null,
0: 			"typeServices not initialized");
0: 
0: 		// if type already determined, there's nothing to do.
0: 		// this can occur if a named parameter ("?paramName") is
0: 		// set equal to a unnamed parameter ("?") in a COPY PUBLICATION
0: 		// statement. in this case, the named parameter may be referenced
0: 		// multiple times. each time it must resolve to the same "?"
0: 		// parameter.
0: 
0: 		if ( typeServices[parameterNumber] != null ) { return; }
0: 
0: 		/* Make sure the type is nullable. */
0: 		if ( ! descriptor.isNullable())
0: 		{
0: 			/*
0: 			** Generate a new descriptor with all the same properties as
0: 			** the given one, except that it is nullable.
0: 			*/
0: 			descriptor = new DataTypeDescriptor(descriptor, true);
0: 		}
0: 
0: 		typeServices[parameterNumber] = descriptor;
0: 
0: 		setType(descriptor);
0: 
0: 		if ( getJSQLType() == null ) { setJSQLType(  new JSQLType( descriptor ) ); }
0: 	}
0: 
0: 	/**
0: 	 * Mark this as a return output parameter (e.g.
0: 	 * ? = CALL myMethod())
0: 	 */
0: 	public void setReturnOutputParam(ValueNode valueNode)
0: 	{
0: 		returnOutputParameter = valueNode;
0: 	}
0: 
0: 	/**
0: 	 * Is this as a return output parameter (e.g.
0: 	 * ? = CALL myMethod())
0: 	 *
0: 	 * @return true if it is a return param
0: 	 */
0: 	public boolean isReturnOutputParam()
0: 	{
0: 		return returnOutputParameter != null;
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  A parameter can't figure out what its type
0: 	 * is without knowing where it appears, so this method does nothing.
0: 	 * It is up to the node that points to this parameter node to figure
0: 	 * out the type of the parameter and set it, using the setDescriptor()
0: 	 * method above.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(
0: 			FromList fromList, SubqueryList subqueryList,
0: 			Vector	aggregateVector) 
0: 				throws StandardException
0: 	{
0: 		checkReliability( "?", CompilerContext.UNNAMED_PARAMETER_ILLEGAL );
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree represents a constant expression.
0: 	 *
0: 	 * @return	Whether or not this expression tree represents a constant expression.
0: 	 */
0: 	public boolean isConstantExpression()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (method calls and non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *							  (constant expressions)
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 */
0: 	protected int getOrderableVariantType()
0: 	{
0: 		// Parameters are invariant for the life of the query
0: 		return orderableVariantType;
0: 	}
0: 
0: 	/**
0: 	 * In a special circumstance, we want to consider
0: 	 * parameters as constants.  For that situation, we
0: 	 * allow a caller to temporarily set us to CONSTANT
0: 	 * and then restore us.
0: 	 */
0: 	void setOrderableVariantType(int type)
0: 	{
0: 		orderableVariantType = type;
0: 	}
0: 
0: 	////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	OVERRIDE METHODS IN VALUE NODE THAT ARE USED WHILE BINDING REPLICATED
0: 	//	CALL WORK STATEMENTS.
0: 	//
0: 	//	In this scenario, a JSQLType was replicated along with this parameter.
0: 	//	The JSQLType represents the bind() decision of the remote system, which
0: 	//	we want to reproduce locally.
0: 	//
0: 	////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	  *	Set the JSQLType of this parameter. This supports the unnamed parameters
0: 	  *	that we use for replicated work units.
0: 	  *
0: 	  *	@param	type	the JSQLType associated with this parameter
0: 	  */
0: 	public	void	setJSQLType
0: 	(
0: 		JSQLType	type
0: 	)
0: 	{ jsqlType = type; }
0: 
0: 	/**
0: 	  *	Get the JSQLType associated with this parameter. Again, part of method
0: 	  *	resolution for replicated work units.
0: 	  *
0: 	  *	@return	the JSQLType that the remote system assigned
0: 	  */
0: 	public	JSQLType	getJSQLType()
0: 	{
0: 		return jsqlType;
0: 	}
0: 
0: 
0: 	////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CODE GENERATOR
0: 	//
0: 	////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * For a ParameterNode, we generate a call to the type factory
0: 	 * to get a DataValueDescriptor, and pass the result to the
0: 	 * setStorableDataValue method of the ParameterValueSet for the
0: 	 * generated class.  We push the DataValueDescriptor field as the
0: 	 * generated expression.
0: 	 *
0: 	 * Generated code:
0: 	 *
0: 	 *   In the constructor for the generated class:
0: 	 *
0: 	 *	((ParameterValueSet) pvs).
0: 	 *		setStorableDataValue(
0: 	 *				<generated null>,
0: 	 *				parameterNumber, jdbcType, className);
0: 	 *
0: 	 *   For the return value:
0: 	 *
0: 	 *		(<java type name>)
0: 	 *			( (ParameterValueSet) pvs.
0: 	 *					getParameter(parameterNumber) )
0: 	 *
0: 	 * pvs is a ParameterValueSet that lives in the superclass of the class
0: 	 * being generated.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		// PUSHCOMPILE
0: 		/* Reuse code if possible */
0: 		//if (genRetval != null)
0: 		//	return genRetval;
0: 
0:         /*
0:         ** First, generate the holder in the constructor.
0:         */
0:         generateHolder(acb);
0: 
0:         /* now do the return value */
0: 
0:         /* First, get the field that holds the ParameterValueSet */
0:         acb.pushPVSReference(mb);
0: 
0:         mb.push(parameterNumber); // arg
0: 
0:         mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getParameter",
0:                       ClassName.DataValueDescriptor, 1);
0: 
0: 		// For some types perform host variable checking
0: 		// to match DB2/JCC where if a host variable is too
0: 		// big it is not accepted, regardless of any trailing padding.
0: 		DataTypeDescriptor dtd = getTypeServices();
0: 
0: 		switch (dtd.getJDBCTypeId()) {
0: 		case Types.BINARY:
0: 		case Types.VARBINARY:
0: 		case Types.LONGVARBINARY:
0: 		case Types.BLOB:
0: 			mb.dup();
0: 			mb.push(dtd.getMaximumWidth());
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "checkHostVariable",
0:                       "void", 1);
0: 			break;
0: 
0: 		default:
0: 			break;
0: 		}
0: 
0:         /* Cast the result to its specific interface */
0:         mb.cast(getTypeCompiler().interfaceName());
0: 	} // End of generateExpression
0: 
0: 	/*
0: 	** parameters might never be used, but still need
0: 	** to have space allocated for them and be assigned
0: 	** to, for the query to operate.
0: 	**
0: 	** This generates the minimum code needed to make
0: 	** the parameter exist.
0: 	*/
0: 	void generateHolder(ExpressionClassBuilder acb) throws StandardException {
0: 
0: 		MethodBuilder	constructor = acb.getConstructor();
0: 
0: 		if (generated) return;
0: 		generated = true;
0: 
0: 		/*
0: 		** First, build the statement in the constructor.
0: 		*/
0: 		acb.pushPVSReference(constructor);
0: 
0: 		acb.generateNull(constructor, getTypeCompiler()); constructor.upCast(ClassName.DataValueDescriptor);
0: 
0: 		constructor.push(parameterNumber); // second arg
0: 		TypeId myId = getTypeId();
0: 		constructor.push(myId.getJDBCTypeId()); // third arg
0: 		constructor.push(myId.getCorrespondingJavaTypeName()); // fouth arg
0: 
0: 		constructor.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "setStorableDataValue", "void", 4);
0: 
0: 		/* The constructor portion is done */
0: 	}
0: 
0: 	public TypeId getTypeId()
0: 	{
0: 		return (returnOutputParameter != null) ?
0: 			returnOutputParameter.getTypeId() : super.getTypeId();
0: 	}
0: 
0: 	////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	STATIC ROUTINES
0: 	//
0: 	////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Generate the code to create the ParameterValueSet, if necessary,
0: 	 * when constructing the activation.  Also generate the code to call
0: 	 * a method that will throw an exception if we try to execute without
0: 	 * all the parameters being set.
0: 	 * 
0: 	 * This generated code goes into the Activation's constructor early on.
0: 	 * 
0: 	 * @param acb					The ExpressionClassBuilder for the class we're building
0: 	 * @param numberOfParameters	number of parameters for this statement
0: 	 * @param parameterList			The parameter list for the statement.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	static public	void generateParameterValueSet(ExpressionClassBuilder	acb,
0: 								   int		numberOfParameters,
0: 								   Vector	parameterList)
0: 		throws StandardException
0: 	{
0: 		if (numberOfParameters > 0)
0: 		{
0: 			MethodBuilder	constructor = acb.getConstructor();
0: 
0: 			/*
0: 			** Check the first parameter to see if it is a return
0: 			** parameter.
0: 			*/
0: 			boolean hasReturnParam = ((ParameterNode)parameterList.elementAt(0)).isReturnOutputParam();
0: 
0: 			/*
0: 			** Generate the following:
0: 			**
0: 			** pvs =
0: 			**		getLanguageConnectionContext()
0: 			**			.getLanguageFactory()
0: 			**					.getParameterValueSet(numberOfParameters);
0: 			**
0: 			** pvs is a ParameterValueSet that lives in the superclass of
0: 			** the activation being generated.
0: 			*/
0: 
0: 			constructor.pushThis(); // for the put field down below
0: 
0: 			/* Generate the call to getContext */
0: 			//?X constructor.pushThis();
0: 			//?Xconstructor.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Activation, "getLanguageConnectionContext",
0: 			//?X					ClassName.LanguageConnectionContext, 0);
0: 			/*
0: 			** Call getLanguageFactory()
0: 			*/
0: 			//?Xconstructor.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getLanguageFactory",
0: 			//?X					ClassName.LanguageFactory, 0);
0: 
0: 			/*
0: 			** Call getParameterValueSet(<number of parameters>, <hasReturnParam>)
0: 			*/
0: 
0: 			constructor.push(numberOfParameters); // first arg
0: 			constructor.push(hasReturnParam); // second arg
0: 
0: 			constructor.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation,
0: 									"setParameterValueSet", "void", 2);
0: 
0: 			//?Xconstructor.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getParameterValueSet",
0: 			//?X					ClassName.ParameterValueSet, 2);
0: 
0: 			/* Assign the return from getParameterValueSet() to the field */
0: 			//?Xconstructor.putField(ClassName.BaseActivation, "pvs", ClassName.ParameterValueSet);
0: 			//?Xconstructor.endStatement();
0: 
0: 			/*
0: 			** Add a call to the execute() method to check
0: 			** for missing parameters
0: 			*/
0: 			MethodBuilder	executeMethod = acb.getExecuteMethod();
0: 
0: 			executeMethod.pushThis();
0: 			executeMethod.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "throwIfMissingParms", "void", 0);
0: 		}
0: 	}
0: 
0: 	/*
0: 	** When all other generation is done for the statement,
0: 	** we need to ensure all of the parameters have been touched.
0: 	*
0: 	*	@param	acb				ExpressionClassBuilder
0: 	*	@param	parameterList	list of parameter
0: 	*
0: 	* @exception StandardException		Thrown on error
0: 	*/
0: 	static	public	void generateParameterHolders
0: 	( ExpressionClassBuilder acb, Vector parameterList ) 
0: 		throws StandardException
0: 	{
0: 		if (parameterList == null) return;
0: 
0: 		for (Enumeration paramEnum = parameterList.elements(); 
0: 			 paramEnum.hasMoreElements(); )
0: 		{
0: 			((ParameterNode)paramEnum.nextElement()).generateHolder(acb);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the default value for the parameter.  Parameters
0: 	 * may get default values for optimization purposes.
0: 	 *
0: 	 * @return the value, may be null
0: 	 */
0: 	DataValueDescriptor getDefaultValue()
0: 	{
0: 		return defaultValue;
0: 	}
0: 	
0: 	/**
0: 	 * @see ValueNode#isParameterNode
0: 	 */
0: 	public boolean isParameterNode()
0: 	{
0: 		return true;
0: 	}
0: }
============================================================================