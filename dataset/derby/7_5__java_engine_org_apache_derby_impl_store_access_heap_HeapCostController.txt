1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.heap.HeapCostController
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
4:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.heap;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostController;
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostResult;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.GenericCostController;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerate;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: The StoreCostController interface provides methods that an access client
1:eac0369: (most likely the system optimizer) can use to get store's estimated cost of
1:eac0369: various operations on the conglomerate the StoreCostController was opened
1:eac0369: for.
1:eac0369: <p>
1:eac0369: It is likely that the implementation of StoreCostController will open 
1:eac0369: the conglomerate and will leave the conglomerate open until the
1:eac0369: StoreCostController is closed.  This represents a significant amount of
1:eac0369: work, so the caller if possible should attempt to open the StoreCostController
1:eac0369: once per unit of work and rather than close and reopen the controller.  For
1:eac0369: instance if the optimizer needs to cost 2 different scans against a single
1:eac0369: conglomerate, it should use one instance of the StoreCostController.
1:eac0369: <p>
1:eac0369: The locking behavior of the implementation of a StoreCostController is
1:eac0369: undefined, it may or may not get locks on the underlying conglomerate.  It
1:eac0369: may or may not hold locks until end of transaction.  
1:eac0369: An optimal implementation will not get any locks on the underlying 
1:eac0369: conglomerate, thus allowing concurrent access to the table by a executing
1:eac0369: query while another query is optimizing.
1:eac0369: <p>
1:eac0369: The StoreCostController gives 2 kinds of cost information
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public class HeapCostController 
1:eac0369:     extends GenericCostController implements StoreCostController
1:eac0369: {
1:eac0369:     /**
1:eac0369:      * Only lookup these estimates from raw store once.
1:eac0369:      **/
1:eac0369:     long    num_pages;
1:eac0369:     long    num_rows;
1:eac0369:     long    page_size;
1:eac0369:     long    row_size;
1:eac0369: 
1:eac0369:     /* Private/Protected methods of This class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Initialize the cost controller.
1:eac0369:      * <p>
1:eac0369:      * Let super.init() do it's work and then get the initial stats about the
1:eac0369:      * table from raw store.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void init(
1:eac0369:     OpenConglomerate    open_conglom)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         super.init(open_conglom);
1:eac0369: 
1:eac0369:         ContainerHandle container = open_conglom.getContainer();
1:eac0369: 
1:eac0369:         // look up costs from raw store.
1:eac0369:         num_rows  = container.getEstimatedRowCount(/*unused flag*/ 0);
1:eac0369: 
1:eac0369:         // Don't use 0 rows (use 1 instead), as 0 rows often leads the 
1:eac0369:         // optimizer to produce plans which don't use indexes because of the 0 
1:eac0369:         // row edge case.
1:eac0369:         //
1:eac0369:         // Eventually the plan is recompiled when rows are added, but we
1:eac0369:         // have seen multiple customer cases of deadlocks and timeouts 
1:eac0369:         // because of these 0 row based plans.  
1:eac0369:         if (num_rows == 0)
1:eac0369:             num_rows = 1;
1:eac0369: 
1:eac0369:         // eliminate the allocation page from the count.
1:eac0369:         num_pages = container.getEstimatedPageCount(/* unused flag */ 0);
1:eac0369: 
1:eac0369:         Properties prop = new Properties();
1:eac0369:         prop.put(Property.PAGE_SIZE_PARAMETER, "");
1:eac0369:         container.getContainerProperties(prop);
1:eac0369:         page_size = 
1:eac0369:             Integer.parseInt(prop.getProperty(Property.PAGE_SIZE_PARAMETER));
1:eac0369: 
1:eac0369:         row_size = (num_pages * page_size / num_rows);
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /* Public Methods of This class: */
1:eac0369:     /* Public Methods of XXXX class: */
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the cost of calling ConglomerateController.fetch().
1:eac0369:      * <p>
1:eac0369:      * Return the estimated cost of calling ConglomerateController.fetch()
1:eac0369:      * on the current conglomerate.  This gives the cost of finding a record
1:eac0369:      * in the conglomerate given the exact RowLocation of the record in
1:eac0369:      * question. 
1:eac0369:      * <p>
1:eac0369:      * The validColumns describes what kind of row is being fetched, 
1:eac0369:      * ie. it may be cheaper to fetch a partial row than a complete row.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @param validColumns    A description of which columns to return from
1:eac0369:      *                        row on the page into "templateRow."  templateRow,
1:eac0369:      *                        and validColumns work together to
1:eac0369:      *                        describe the row to be returned by the fetch - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a fetched 
1:eac0369:      *                        "row".
1:eac0369:      *
1:eac0369:      * @param access_type     Describe the type of access the query will be
1:eac0369:      *                        performing to the ConglomerateController.  
1:eac0369:      *
1:eac0369:      *                        STORECOST_CLUSTERED - The location of one fetch
1:eac0369:      *                            is likely clustered "close" to the next 
1:eac0369:      *                            fetch.  For instance if the query plan were
1:eac0369:      *                            to sort the RowLocations of a heap and then
1:eac0369:      *                            use those RowLocations sequentially to 
1:eac0369:      *                            probe into the heap, then this flag should
1:eac0369:      *                            be specified.  If this flag is not set then
1:eac0369:      *                            access to the table is assumed to be
1:eac0369:      *                            random - ie. the type of access one gets 
1:eac0369:      *                            if you scan an index and probe each row
1:eac0369:      *                            in turn into the base table is "random".
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @return The cost of the fetch.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:fa09146: 	 * @see org.apache.derby.iapi.store.access.RowUtil
1:eac0369:      **/
1:eac0369:     public double getFetchFromRowLocationCost(
1:eac0369:     FormatableBitSet      validColumns,
1:eac0369:     int         access_type)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         double ret_cost;
1:eac0369: 
1:eac0369:         // get "per-byte" cost of fetching a row from the page.
1:eac0369:         ret_cost = row_size * BASE_ROW_PER_BYTECOST;
1:eac0369: 
1:eac0369:         long num_pages_per_row = (row_size / page_size) + 1;
1:eac0369: 
1:eac0369:         if ((access_type & StoreCostController.STORECOST_CLUSTERED) == 0)
1:eac0369:         {
1:eac0369:             // this is the "base" unit case.
1:eac0369:             ret_cost += (BASE_UNCACHED_ROW_FETCH_COST * num_pages_per_row);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             ret_cost += (BASE_CACHED_ROW_FETCH_COST * num_pages_per_row);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_cost);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Calculate the cost of a scan.
1:eac0369:      * <p>
1:eac0369:      * Cause this object to calculate the cost of performing the described
1:eac0369:      * scan.  The interface is setup such that first a call is made to
1:eac0369:      * calcualteScanCost(), and then subsequent calls to accessor routines
1:eac0369:      * are made to get various pieces of information about the cost of
1:eac0369:      * the scan.
1:eac0369:      * <p>
1:eac0369:      * For the purposes of costing this routine is going to assume that 
1:eac0369:      * a page will remain in cache between the time one next()/fetchNext()
1:eac0369:      * call and a subsequent next()/fetchNext() call is made within a scan.
1:eac0369:      * <p>
1:eac0369:      * The result of costing the scan is placed in the "cost_result".  
1:eac0369:      * The cost of the scan is stored by calling 
1:eac0369:      * cost_result.setEstimatedCost(cost).
1:eac0369:      * The estimated row count is stored by calling 
1:eac0369:      * cost_result.setEstimatedRowCount(row_count).
1:eac0369:      * <p>
1:eac0369:      * The estimated cost of the scan assumes the caller will 
1:eac0369:      * execute a fetchNext() loop for every row that qualifies between
1:eac0369:      * start and stop position.  Note that this cost is different than
1:eac0369:      * execution a next(),fetch() loop; or if the scan is going to be
1:eac0369:      * terminated by client prior to reaching the stop condition.
1:eac0369:      * <p>
1:eac0369:      * The estimated number of rows returned from the scan 
1:eac0369:      * assumes the caller will execute a fetchNext() loop for every 
1:eac0369:      * row that qualifies between start and stop position.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:eac0369:      * @param scan_type       The type of scan that will be executed.  There
1:eac0369:      *                        are currently 2 types:
1:eac0369:      *                        STORECOST_SCAN_NORMAL - scans will be executed
1:eac0369:      *                        using the standard next/fetch, where each fetch
1:eac0369:      *                        can retrieve 1 or many rows (if fetchNextGroup()
1:eac0369:      *                        interface is used).
1:eac0369:      *
1:eac0369:      *                        STORECOST_SCAN_SET - The entire result set will
1:eac0369:      *                        be retrieved using the the fetchSet() interface.
1:eac0369:      *
1:eac0369:      * @param row_count       Estimated total row count of the table.  The 
1:eac0369:      *                        current system tracks row counts in heaps better
1:eac0369:      *                        than btree's (btree's have "rows" which are not
1:eac0369:      *                        user rows - branch rows, control rows), so 
1:eac0369:      *                        if available the client should
1:eac0369:      *                        pass in the base table's row count into this
1:eac0369:      *                        routine to be used as the index's row count.
1:eac0369:      *                        If the caller has no idea, pass in -1.
1:eac0369:      *
1:eac0369:      * @param group_size      The number of rows to be returned by a single
1:eac0369:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
1:eac0369:      *
1:eac0369: 	 * @param forUpdate       Should be true if the caller intends to update 
1:eac0369:      *                        through the scan.
1:eac0369:      * 
1:eac0369: 	 * @param scanColumnList  A description of which columns to return from 
1:eac0369:      *                        every fetch in the scan.  template, 
1:eac0369:      *                        and scanColumnList work together
1:eac0369:      *                        to describe the row to be returned by the scan - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a "row".
1:eac0369:      * 
1:eac0369:      * @param template        A prototypical row which the scan may use to
1:eac0369: 	 *                        maintain its position in the conglomerate.  Not 
1:eac0369:      *                        all access method scan types will require this, 
1:eac0369:      *                        if they don't it's ok to pass in null.
1:eac0369:      *                        In order to scan a conglomerate one must 
1:eac0369:      *                        allocate 2 separate "row" templates.  The "row" 
1:eac0369:      *                        template passed into openScan is for the private
1:eac0369:      *                        use of the scan itself, and no access to it
1:eac0369:      *                        should be made by the caller while the scan is 
1:eac0369:      *                        still open.  Because of this the scanner must 
1:eac0369:      *                        allocate another "row" template to hold the 
1:eac0369:      *                        values returned from fetch().  Note that this 
1:eac0369:      *                        template must be for the full row, whether a 
1:eac0369:      *                        partial row scan is being executed or not.
1:eac0369:      *
1:eac0369: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
1:eac0369:      *                        value which, in combination with the 
1:eac0369:      *                        startSearchOperator, defines the starting 
1:eac0369:      *                        position of the scan.  If null, the starting
1:eac0369:      *                        position of the scan is the first row of the 
1:eac0369:      *                        conglomerate.  The startKeyValue must only
1:eac0369:      *                        reference columns included in the scanColumnList.
1:eac0369:      *
1:75b112d: 	 * @param startSearchOperator 
1:eac0369:      *                        an operator which defines how the startKeyValue
1:eac0369:      *                        is to be searched for.  If startSearchOperation 
1:eac0369:      *                        is ScanController.GE, the scan starts on the 
1:eac0369:      *                        first row which is greater than or equal to the 
1:eac0369: 	 *                        startKeyValue.  If startSearchOperation is 
1:eac0369:      *                        ScanController.GT, the scan starts on the first
1:eac0369:      *                        row whose key is greater than startKeyValue.  The
1:eac0369:      *                        startSearchOperation parameter is ignored if the
1:eac0369:      *                        startKeyValue parameter is null.
1:eac0369:      *
1:eac0369: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
1:eac0369:      *                        value which, in combination with the 
1:eac0369:      *                        stopSearchOperator, defines the ending position
1:eac0369:      *                        of the scan.  If null, the ending position of the
1:eac0369:      *                        scan is the last row of the conglomerate.  The
1:eac0369:      *                        stopKeyValue must only reference columns included
1:eac0369:      *                        in the scanColumnList.
1:eac0369:      *
1:75b112d: 	 * @param stopSearchOperator
1:eac0369:      *                        an operator which defines how the stopKeyValue
1:eac0369:      *                        is used to determine the scan stopping position. 
1:eac0369:      *                        If stopSearchOperation is ScanController.GE, the
1:eac0369:      *                        scan stops just before the first row which is
1:eac0369:      *                        greater than or equal to the stopKeyValue.  If 
1:eac0369:      *                        stopSearchOperation is ScanController.GT, the 
1:eac0369:      *                        scan stops just before the first row whose key 
1:eac0369:      *                        is greater than startKeyValue.  The
1:eac0369:      *                        stopSearchOperation parameter is ignored if the
1:eac0369:      *                        stopKeyValue parameter is null.
1:eac0369:      *
1:eac0369:      *                        
1:eac0369:      * @param access_type     Describe the type of access the query will be
1:eac0369:      *                        performing to the ScanController.  
1:eac0369:      *
1:eac0369:      *                        STORECOST_CLUSTERED - The location of one scan
1:eac0369:      *                            is likely clustered "close" to the previous 
1:eac0369:      *                            scan.  For instance if the query plan were
1:eac0369:      *                            to used repeated "reopenScan()'s" to probe
1:eac0369:      *                            for the next key in an index, then this flag
1:eac0369:      *                            should be be specified.  If this flag is not 
1:eac0369:      *                            set then each scan will be costed independant
1:eac0369:      *                            of any other predicted scan access.
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:fa09146: 	 * @see org.apache.derby.iapi.store.access.RowUtil
1:eac0369:      **/
1:eac0369: 	public void getScanCost(
1:eac0369:     int                     scan_type,
1:eac0369:     long                    row_count,
1:eac0369:     int                     group_size,
1:eac0369:     boolean                 forUpdate,
1:75b112d:     FormatableBitSet        scanColumnList,
1:eac0369:     DataValueDescriptor[]   template,
1:eac0369:     DataValueDescriptor[]   startKeyValue,
1:eac0369:     int                     startSearchOperator,
1:eac0369:     DataValueDescriptor[]   stopKeyValue,
1:eac0369:     int                     stopSearchOperator,
1:eac0369:     boolean                 reopen_scan,
1:eac0369:     int                     access_type,
1:eac0369:     StoreCostResult         cost_result)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 scan_type == StoreCostController.STORECOST_SCAN_NORMAL ||
1:eac0369:                 scan_type == StoreCostController.STORECOST_SCAN_SET);
1:eac0369:         }
1:eac0369: 
1:eac0369:         long estimated_row_count = ((row_count < 0) ?  num_rows : row_count);
1:eac0369: 
1:eac0369:         // This cost is if the caller has to go in and out of access for
1:eac0369:         // every row in the table.  The cost will be significantly less if
1:eac0369:         // group fetch is used, or if qualifiers
1:eac0369: 
1:eac0369:         // first the base cost of bringing each page in from cache:
1:eac0369:         double cost = (num_pages * BASE_UNCACHED_ROW_FETCH_COST);
1:eac0369: 
1:eac0369:         // the cost associated with the number of bytes in each row:
1:eac0369:         cost += (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST;
1:eac0369: 
1:eac0369:         // the base cost of getting each of the rows from a page assumed
1:eac0369:         // to already be cached (by the scan fetch) - this is only for all
1:eac0369:         // rows after the initial row on the page has been accounted for
1:eac0369:         // under the BASE_UNCACHED_ROW_FETCH_COST cost.:
1:eac0369:         long cached_row_count = estimated_row_count - num_pages;
1:eac0369:         if (cached_row_count < 0)
1:eac0369:             cached_row_count = 0;
1:eac0369: 
1:eac0369:         if (scan_type == StoreCostController.STORECOST_SCAN_NORMAL)
1:eac0369:             cost += cached_row_count * BASE_GROUPSCAN_ROW_COST;
1:eac0369:         else
1:eac0369:             cost += cached_row_count * BASE_HASHSCAN_ROW_FETCH_COST;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(cost >= 0);
1:eac0369:             SanityManager.ASSERT(estimated_row_count >= 0);
1:eac0369:         }
1:eac0369: 
1:eac0369:         cost_result.setEstimatedCost(cost);
1:eac0369: 
1:eac0369:         // return that all rows will be scanned.
1:eac0369:         cost_result.setEstimatedRowCount(estimated_row_count);
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.store.access.RowUtil
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.store.access.RowUtil
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:75b112d
/////////////////////////////////////////////////////////////////////////
1: 	 * @param startSearchOperator 
/////////////////////////////////////////////////////////////////////////
1: 	 * @param stopSearchOperator
/////////////////////////////////////////////////////////////////////////
1:     FormatableBitSet        scanColumnList,
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.heap.HeapCostController
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.heap;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.reference.Property;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: 
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.store.access.StoreCostController;
1: import org.apache.derby.iapi.store.access.StoreCostResult;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.impl.store.access.conglomerate.GenericCostController;
1: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerate;
1: 
0: import org.apache.derby.iapi.store.access.RowUtil;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import java.util.Properties;
1: 
1: 
1: /**
1: 
1: The StoreCostController interface provides methods that an access client
1: (most likely the system optimizer) can use to get store's estimated cost of
1: various operations on the conglomerate the StoreCostController was opened
1: for.
1: <p>
1: It is likely that the implementation of StoreCostController will open 
1: the conglomerate and will leave the conglomerate open until the
1: StoreCostController is closed.  This represents a significant amount of
1: work, so the caller if possible should attempt to open the StoreCostController
1: once per unit of work and rather than close and reopen the controller.  For
1: instance if the optimizer needs to cost 2 different scans against a single
1: conglomerate, it should use one instance of the StoreCostController.
1: <p>
1: The locking behavior of the implementation of a StoreCostController is
1: undefined, it may or may not get locks on the underlying conglomerate.  It
1: may or may not hold locks until end of transaction.  
1: An optimal implementation will not get any locks on the underlying 
1: conglomerate, thus allowing concurrent access to the table by a executing
1: query while another query is optimizing.
1: <p>
1: The StoreCostController gives 2 kinds of cost information
1: 
1: **/
1: 
1: public class HeapCostController 
1:     extends GenericCostController implements StoreCostController
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1:     /**
1:      * Only lookup these estimates from raw store once.
1:      **/
1:     long    num_pages;
1:     long    num_rows;
1:     long    page_size;
1:     long    row_size;
1: 
1:     /* Private/Protected methods of This class: */
1: 
1:     /**
1:      * Initialize the cost controller.
1:      * <p>
1:      * Let super.init() do it's work and then get the initial stats about the
1:      * table from raw store.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void init(
1:     OpenConglomerate    open_conglom)
1:         throws StandardException
1:     {
1:         super.init(open_conglom);
1: 
1:         ContainerHandle container = open_conglom.getContainer();
1: 
1:         // look up costs from raw store.
1:         num_rows  = container.getEstimatedRowCount(/*unused flag*/ 0);
1: 
1:         // Don't use 0 rows (use 1 instead), as 0 rows often leads the 
1:         // optimizer to produce plans which don't use indexes because of the 0 
1:         // row edge case.
1:         //
1:         // Eventually the plan is recompiled when rows are added, but we
1:         // have seen multiple customer cases of deadlocks and timeouts 
1:         // because of these 0 row based plans.  
1:         if (num_rows == 0)
1:             num_rows = 1;
1: 
1:         // eliminate the allocation page from the count.
1:         num_pages = container.getEstimatedPageCount(/* unused flag */ 0);
1: 
1:         Properties prop = new Properties();
1:         prop.put(Property.PAGE_SIZE_PARAMETER, "");
1:         container.getContainerProperties(prop);
1:         page_size = 
1:             Integer.parseInt(prop.getProperty(Property.PAGE_SIZE_PARAMETER));
1: 
1:         row_size = (num_pages * page_size / num_rows);
1: 
1:         return;
1:     }
1: 
1:     /* Public Methods of This class: */
1:     /* Public Methods of XXXX class: */
1: 
1: 
1:     /**
1:      * Return the cost of calling ConglomerateController.fetch().
1:      * <p>
1:      * Return the estimated cost of calling ConglomerateController.fetch()
1:      * on the current conglomerate.  This gives the cost of finding a record
1:      * in the conglomerate given the exact RowLocation of the record in
1:      * question. 
1:      * <p>
1:      * The validColumns describes what kind of row is being fetched, 
1:      * ie. it may be cheaper to fetch a partial row than a complete row.
1:      * <p>
1:      *
1:      *
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "templateRow."  templateRow,
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1:      *
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ConglomerateController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one fetch
1:      *                            is likely clustered "close" to the next 
1:      *                            fetch.  For instance if the query plan were
1:      *                            to sort the RowLocations of a heap and then
1:      *                            use those RowLocations sequentially to 
1:      *                            probe into the heap, then this flag should
1:      *                            be specified.  If this flag is not set then
1:      *                            access to the table is assumed to be
1:      *                            random - ie. the type of access one gets 
1:      *                            if you scan an index and probe each row
1:      *                            in turn into the base table is "random".
1:      *
1:      *
1: 	 * @return The cost of the fetch.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
0: 	 * @see RowUtil
1:      **/
1:     public double getFetchFromRowLocationCost(
1:     FormatableBitSet      validColumns,
1:     int         access_type)
1: 		throws StandardException
1:     {
1:         double ret_cost;
1: 
1:         // get "per-byte" cost of fetching a row from the page.
1:         ret_cost = row_size * BASE_ROW_PER_BYTECOST;
1: 
1:         long num_pages_per_row = (row_size / page_size) + 1;
1: 
1:         if ((access_type & StoreCostController.STORECOST_CLUSTERED) == 0)
1:         {
1:             // this is the "base" unit case.
1:             ret_cost += (BASE_UNCACHED_ROW_FETCH_COST * num_pages_per_row);
1:         }
1:         else
1:         {
1:             ret_cost += (BASE_CACHED_ROW_FETCH_COST * num_pages_per_row);
1:         }
1: 
1:         return(ret_cost);
1:     }
1: 
1:     /**
1:      * Calculate the cost of a scan.
1:      * <p>
1:      * Cause this object to calculate the cost of performing the described
1:      * scan.  The interface is setup such that first a call is made to
1:      * calcualteScanCost(), and then subsequent calls to accessor routines
1:      * are made to get various pieces of information about the cost of
1:      * the scan.
1:      * <p>
1:      * For the purposes of costing this routine is going to assume that 
1:      * a page will remain in cache between the time one next()/fetchNext()
1:      * call and a subsequent next()/fetchNext() call is made within a scan.
1:      * <p>
1:      * The result of costing the scan is placed in the "cost_result".  
1:      * The cost of the scan is stored by calling 
1:      * cost_result.setEstimatedCost(cost).
1:      * The estimated row count is stored by calling 
1:      * cost_result.setEstimatedRowCount(row_count).
1:      * <p>
1:      * The estimated cost of the scan assumes the caller will 
1:      * execute a fetchNext() loop for every row that qualifies between
1:      * start and stop position.  Note that this cost is different than
1:      * execution a next(),fetch() loop; or if the scan is going to be
1:      * terminated by client prior to reaching the stop condition.
1:      * <p>
1:      * The estimated number of rows returned from the scan 
1:      * assumes the caller will execute a fetchNext() loop for every 
1:      * row that qualifies between start and stop position.
1:      * <p>
1:      *
1:      *
1:      * @param scan_type       The type of scan that will be executed.  There
1:      *                        are currently 2 types:
1:      *                        STORECOST_SCAN_NORMAL - scans will be executed
1:      *                        using the standard next/fetch, where each fetch
1:      *                        can retrieve 1 or many rows (if fetchNextGroup()
1:      *                        interface is used).
1:      *
1:      *                        STORECOST_SCAN_SET - The entire result set will
1:      *                        be retrieved using the the fetchSet() interface.
1:      *
1:      * @param row_count       Estimated total row count of the table.  The 
1:      *                        current system tracks row counts in heaps better
1:      *                        than btree's (btree's have "rows" which are not
1:      *                        user rows - branch rows, control rows), so 
1:      *                        if available the client should
1:      *                        pass in the base table's row count into this
1:      *                        routine to be used as the index's row count.
1:      *                        If the caller has no idea, pass in -1.
1:      *
1:      * @param group_size      The number of rows to be returned by a single
1:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
1:      *
1: 	 * @param forUpdate       Should be true if the caller intends to update 
1:      *                        through the scan.
1:      * 
1: 	 * @param scanColumnList  A description of which columns to return from 
1:      *                        every fetch in the scan.  template, 
1:      *                        and scanColumnList work together
1:      *                        to describe the row to be returned by the scan - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a "row".
1:      * 
1:      * @param template        A prototypical row which the scan may use to
1: 	 *                        maintain its position in the conglomerate.  Not 
1:      *                        all access method scan types will require this, 
1:      *                        if they don't it's ok to pass in null.
1:      *                        In order to scan a conglomerate one must 
1:      *                        allocate 2 separate "row" templates.  The "row" 
1:      *                        template passed into openScan is for the private
1:      *                        use of the scan itself, and no access to it
1:      *                        should be made by the caller while the scan is 
1:      *                        still open.  Because of this the scanner must 
1:      *                        allocate another "row" template to hold the 
1:      *                        values returned from fetch().  Note that this 
1:      *                        template must be for the full row, whether a 
1:      *                        partial row scan is being executed or not.
1:      *
1: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
1:      *                        value which, in combination with the 
1:      *                        startSearchOperator, defines the starting 
1:      *                        position of the scan.  If null, the starting
1:      *                        position of the scan is the first row of the 
1:      *                        conglomerate.  The startKeyValue must only
1:      *                        reference columns included in the scanColumnList.
1:      *
0: 	 * @param startSearchOperation 
1:      *                        an operator which defines how the startKeyValue
1:      *                        is to be searched for.  If startSearchOperation 
1:      *                        is ScanController.GE, the scan starts on the 
1:      *                        first row which is greater than or equal to the 
1: 	 *                        startKeyValue.  If startSearchOperation is 
1:      *                        ScanController.GT, the scan starts on the first
1:      *                        row whose key is greater than startKeyValue.  The
1:      *                        startSearchOperation parameter is ignored if the
1:      *                        startKeyValue parameter is null.
1:      *
1: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
1:      *                        value which, in combination with the 
1:      *                        stopSearchOperator, defines the ending position
1:      *                        of the scan.  If null, the ending position of the
1:      *                        scan is the last row of the conglomerate.  The
1:      *                        stopKeyValue must only reference columns included
1:      *                        in the scanColumnList.
1:      *
0: 	 * @param stopSearchOperation
1:      *                        an operator which defines how the stopKeyValue
1:      *                        is used to determine the scan stopping position. 
1:      *                        If stopSearchOperation is ScanController.GE, the
1:      *                        scan stops just before the first row which is
1:      *                        greater than or equal to the stopKeyValue.  If 
1:      *                        stopSearchOperation is ScanController.GT, the 
1:      *                        scan stops just before the first row whose key 
1:      *                        is greater than startKeyValue.  The
1:      *                        stopSearchOperation parameter is ignored if the
1:      *                        stopKeyValue parameter is null.
1:      *
1:      *                        
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ScanController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one scan
1:      *                            is likely clustered "close" to the previous 
1:      *                            scan.  For instance if the query plan were
1:      *                            to used repeated "reopenScan()'s" to probe
1:      *                            for the next key in an index, then this flag
1:      *                            should be be specified.  If this flag is not 
1:      *                            set then each scan will be costed independant
1:      *                            of any other predicted scan access.
1:      *
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
0: 	 * @see RowUtil
1:      **/
1: 	public void getScanCost(
1:     int                     scan_type,
1:     long                    row_count,
1:     int                     group_size,
1:     boolean                 forUpdate,
0:     FormatableBitSet                 scanColumnList,
1:     DataValueDescriptor[]   template,
1:     DataValueDescriptor[]   startKeyValue,
1:     int                     startSearchOperator,
1:     DataValueDescriptor[]   stopKeyValue,
1:     int                     stopSearchOperator,
1:     boolean                 reopen_scan,
1:     int                     access_type,
1:     StoreCostResult         cost_result)
1:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 scan_type == StoreCostController.STORECOST_SCAN_NORMAL ||
1:                 scan_type == StoreCostController.STORECOST_SCAN_SET);
1:         }
1: 
1:         long estimated_row_count = ((row_count < 0) ?  num_rows : row_count);
1: 
1:         // This cost is if the caller has to go in and out of access for
1:         // every row in the table.  The cost will be significantly less if
1:         // group fetch is used, or if qualifiers
1: 
1:         // first the base cost of bringing each page in from cache:
1:         double cost = (num_pages * BASE_UNCACHED_ROW_FETCH_COST);
1: 
1:         // the cost associated with the number of bytes in each row:
1:         cost += (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST;
1: 
1:         // the base cost of getting each of the rows from a page assumed
1:         // to already be cached (by the scan fetch) - this is only for all
1:         // rows after the initial row on the page has been accounted for
1:         // under the BASE_UNCACHED_ROW_FETCH_COST cost.:
1:         long cached_row_count = estimated_row_count - num_pages;
1:         if (cached_row_count < 0)
1:             cached_row_count = 0;
1: 
1:         if (scan_type == StoreCostController.STORECOST_SCAN_NORMAL)
1:             cost += cached_row_count * BASE_GROUPSCAN_ROW_COST;
1:         else
1:             cost += cached_row_count * BASE_HASHSCAN_ROW_FETCH_COST;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(cost >= 0);
1:             SanityManager.ASSERT(estimated_row_count >= 0);
1:         }
1: 
1:         cost_result.setEstimatedCost(cost);
1: 
1:         // return that all rows will be scanned.
1:         cost_result.setEstimatedRowCount(estimated_row_count);
1: 
1:         return;
1:     }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.heap;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.Property;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.StoreCostResult;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.impl.store.access.conglomerate.GenericCostController;
0: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerate;
0: 
0: import org.apache.derby.iapi.store.access.RowUtil;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.util.Properties;
0: 
0: 
0: /**
0: 
0: The StoreCostController interface provides methods that an access client
0: (most likely the system optimizer) can use to get store's estimated cost of
0: various operations on the conglomerate the StoreCostController was opened
0: for.
0: <p>
0: It is likely that the implementation of StoreCostController will open 
0: the conglomerate and will leave the conglomerate open until the
0: StoreCostController is closed.  This represents a significant amount of
0: work, so the caller if possible should attempt to open the StoreCostController
0: once per unit of work and rather than close and reopen the controller.  For
0: instance if the optimizer needs to cost 2 different scans against a single
0: conglomerate, it should use one instance of the StoreCostController.
0: <p>
0: The locking behavior of the implementation of a StoreCostController is
0: undefined, it may or may not get locks on the underlying conglomerate.  It
0: may or may not hold locks until end of transaction.  
0: An optimal implementation will not get any locks on the underlying 
0: conglomerate, thus allowing concurrent access to the table by a executing
0: query while another query is optimizing.
0: <p>
0: The StoreCostController gives 2 kinds of cost information
0: 
0: **/
0: 
0: public class HeapCostController 
0:     extends GenericCostController implements StoreCostController
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0:     /**
0:      * Only lookup these estimates from raw store once.
0:      **/
0:     long    num_pages;
0:     long    num_rows;
0:     long    page_size;
0:     long    row_size;
0: 
0:     /* Private/Protected methods of This class: */
0: 
0:     /**
0:      * Initialize the cost controller.
0:      * <p>
0:      * Let super.init() do it's work and then get the initial stats about the
0:      * table from raw store.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void init(
0:     OpenConglomerate    open_conglom)
0:         throws StandardException
0:     {
0:         super.init(open_conglom);
0: 
0:         ContainerHandle container = open_conglom.getContainer();
0: 
0:         // look up costs from raw store.
0:         num_rows  = container.getEstimatedRowCount(/*unused flag*/ 0);
0: 
0:         // Don't use 0 rows (use 1 instead), as 0 rows often leads the 
0:         // optimizer to produce plans which don't use indexes because of the 0 
0:         // row edge case.
0:         //
0:         // Eventually the plan is recompiled when rows are added, but we
0:         // have seen multiple customer cases of deadlocks and timeouts 
0:         // because of these 0 row based plans.  
0:         if (num_rows == 0)
0:             num_rows = 1;
0: 
0:         // eliminate the allocation page from the count.
0:         num_pages = container.getEstimatedPageCount(/* unused flag */ 0);
0: 
0:         Properties prop = new Properties();
0:         prop.put(Property.PAGE_SIZE_PARAMETER, "");
0:         container.getContainerProperties(prop);
0:         page_size = 
0:             Integer.parseInt(prop.getProperty(Property.PAGE_SIZE_PARAMETER));
0: 
0:         row_size = (num_pages * page_size / num_rows);
0: 
0:         return;
0:     }
0: 
0:     /* Public Methods of This class: */
0:     /* Public Methods of XXXX class: */
0: 
0: 
0:     /**
0:      * Return the cost of calling ConglomerateController.fetch().
0:      * <p>
0:      * Return the estimated cost of calling ConglomerateController.fetch()
0:      * on the current conglomerate.  This gives the cost of finding a record
0:      * in the conglomerate given the exact RowLocation of the record in
0:      * question. 
0:      * <p>
0:      * The validColumns describes what kind of row is being fetched, 
0:      * ie. it may be cheaper to fetch a partial row than a complete row.
0:      * <p>
0:      *
0:      *
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "templateRow."  templateRow,
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0:      *
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ConglomerateController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one fetch
0:      *                            is likely clustered "close" to the next 
0:      *                            fetch.  For instance if the query plan were
0:      *                            to sort the RowLocations of a heap and then
0:      *                            use those RowLocations sequentially to 
0:      *                            probe into the heap, then this flag should
0:      *                            be specified.  If this flag is not set then
0:      *                            access to the table is assumed to be
0:      *                            random - ie. the type of access one gets 
0:      *                            if you scan an index and probe each row
0:      *                            in turn into the base table is "random".
0:      *
0:      *
0: 	 * @return The cost of the fetch.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     public double getFetchFromRowLocationCost(
0:     FormatableBitSet      validColumns,
0:     int         access_type)
0: 		throws StandardException
0:     {
0:         double ret_cost;
0: 
0:         // get "per-byte" cost of fetching a row from the page.
0:         ret_cost = row_size * BASE_ROW_PER_BYTECOST;
0: 
0:         long num_pages_per_row = (row_size / page_size) + 1;
0: 
0:         if ((access_type & StoreCostController.STORECOST_CLUSTERED) == 0)
0:         {
0:             // this is the "base" unit case.
0:             ret_cost += (BASE_UNCACHED_ROW_FETCH_COST * num_pages_per_row);
0:         }
0:         else
0:         {
0:             ret_cost += (BASE_CACHED_ROW_FETCH_COST * num_pages_per_row);
0:         }
0: 
0:         return(ret_cost);
0:     }
0: 
0:     /**
0:      * Calculate the cost of a scan.
0:      * <p>
0:      * Cause this object to calculate the cost of performing the described
0:      * scan.  The interface is setup such that first a call is made to
0:      * calcualteScanCost(), and then subsequent calls to accessor routines
0:      * are made to get various pieces of information about the cost of
0:      * the scan.
0:      * <p>
0:      * For the purposes of costing this routine is going to assume that 
0:      * a page will remain in cache between the time one next()/fetchNext()
0:      * call and a subsequent next()/fetchNext() call is made within a scan.
0:      * <p>
0:      * The result of costing the scan is placed in the "cost_result".  
0:      * The cost of the scan is stored by calling 
0:      * cost_result.setEstimatedCost(cost).
0:      * The estimated row count is stored by calling 
0:      * cost_result.setEstimatedRowCount(row_count).
0:      * <p>
0:      * The estimated cost of the scan assumes the caller will 
0:      * execute a fetchNext() loop for every row that qualifies between
0:      * start and stop position.  Note that this cost is different than
0:      * execution a next(),fetch() loop; or if the scan is going to be
0:      * terminated by client prior to reaching the stop condition.
0:      * <p>
0:      * The estimated number of rows returned from the scan 
0:      * assumes the caller will execute a fetchNext() loop for every 
0:      * row that qualifies between start and stop position.
0:      * <p>
0:      *
0:      *
0:      * @param scan_type       The type of scan that will be executed.  There
0:      *                        are currently 2 types:
0:      *                        STORECOST_SCAN_NORMAL - scans will be executed
0:      *                        using the standard next/fetch, where each fetch
0:      *                        can retrieve 1 or many rows (if fetchNextGroup()
0:      *                        interface is used).
0:      *
0:      *                        STORECOST_SCAN_SET - The entire result set will
0:      *                        be retrieved using the the fetchSet() interface.
0:      *
0:      * @param row_count       Estimated total row count of the table.  The 
0:      *                        current system tracks row counts in heaps better
0:      *                        than btree's (btree's have "rows" which are not
0:      *                        user rows - branch rows, control rows), so 
0:      *                        if available the client should
0:      *                        pass in the base table's row count into this
0:      *                        routine to be used as the index's row count.
0:      *                        If the caller has no idea, pass in -1.
0:      *
0:      * @param group_size      The number of rows to be returned by a single
0:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
0:      *
0: 	 * @param forUpdate       Should be true if the caller intends to update 
0:      *                        through the scan.
0:      * 
0: 	 * @param scanColumnList  A description of which columns to return from 
0:      *                        every fetch in the scan.  template, 
0:      *                        and scanColumnList work together
0:      *                        to describe the row to be returned by the scan - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a "row".
0:      * 
0:      * @param template        A prototypical row which the scan may use to
0: 	 *                        maintain its position in the conglomerate.  Not 
0:      *                        all access method scan types will require this, 
0:      *                        if they don't it's ok to pass in null.
0:      *                        In order to scan a conglomerate one must 
0:      *                        allocate 2 separate "row" templates.  The "row" 
0:      *                        template passed into openScan is for the private
0:      *                        use of the scan itself, and no access to it
0:      *                        should be made by the caller while the scan is 
0:      *                        still open.  Because of this the scanner must 
0:      *                        allocate another "row" template to hold the 
0:      *                        values returned from fetch().  Note that this 
0:      *                        template must be for the full row, whether a 
0:      *                        partial row scan is being executed or not.
0:      *
0: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        startSearchOperator, defines the starting 
0:      *                        position of the scan.  If null, the starting
0:      *                        position of the scan is the first row of the 
0:      *                        conglomerate.  The startKeyValue must only
0:      *                        reference columns included in the scanColumnList.
0:      *
0: 	 * @param startSearchOperation 
0:      *                        an operator which defines how the startKeyValue
0:      *                        is to be searched for.  If startSearchOperation 
0:      *                        is ScanController.GE, the scan starts on the 
0:      *                        first row which is greater than or equal to the 
0: 	 *                        startKeyValue.  If startSearchOperation is 
0:      *                        ScanController.GT, the scan starts on the first
0:      *                        row whose key is greater than startKeyValue.  The
0:      *                        startSearchOperation parameter is ignored if the
0:      *                        startKeyValue parameter is null.
0:      *
0: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        stopSearchOperator, defines the ending position
0:      *                        of the scan.  If null, the ending position of the
0:      *                        scan is the last row of the conglomerate.  The
0:      *                        stopKeyValue must only reference columns included
0:      *                        in the scanColumnList.
0:      *
0: 	 * @param stopSearchOperation
0:      *                        an operator which defines how the stopKeyValue
0:      *                        is used to determine the scan stopping position. 
0:      *                        If stopSearchOperation is ScanController.GE, the
0:      *                        scan stops just before the first row which is
0:      *                        greater than or equal to the stopKeyValue.  If 
0:      *                        stopSearchOperation is ScanController.GT, the 
0:      *                        scan stops just before the first row whose key 
0:      *                        is greater than startKeyValue.  The
0:      *                        stopSearchOperation parameter is ignored if the
0:      *                        stopKeyValue parameter is null.
0:      *
0:      *                        
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ScanController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one scan
0:      *                            is likely clustered "close" to the previous 
0:      *                            scan.  For instance if the query plan were
0:      *                            to used repeated "reopenScan()'s" to probe
0:      *                            for the next key in an index, then this flag
0:      *                            should be be specified.  If this flag is not 
0:      *                            set then each scan will be costed independant
0:      *                            of any other predicted scan access.
0:      *
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0: 	public void getScanCost(
0:     int                     scan_type,
0:     long                    row_count,
0:     int                     group_size,
0:     boolean                 forUpdate,
0:     FormatableBitSet                 scanColumnList,
0:     DataValueDescriptor[]   template,
0:     DataValueDescriptor[]   startKeyValue,
0:     int                     startSearchOperator,
0:     DataValueDescriptor[]   stopKeyValue,
0:     int                     stopSearchOperator,
0:     boolean                 reopen_scan,
0:     int                     access_type,
0:     StoreCostResult         cost_result)
0:         throws StandardException
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 scan_type == StoreCostController.STORECOST_SCAN_NORMAL ||
0:                 scan_type == StoreCostController.STORECOST_SCAN_SET);
0:         }
0: 
0:         long estimated_row_count = ((row_count < 0) ?  num_rows : row_count);
0: 
0:         // This cost is if the caller has to go in and out of access for
0:         // every row in the table.  The cost will be significantly less if
0:         // group fetch is used, or if qualifiers
0: 
0:         // first the base cost of bringing each page in from cache:
0:         double cost = (num_pages * BASE_UNCACHED_ROW_FETCH_COST);
0: 
0:         // the cost associated with the number of bytes in each row:
0:         cost += (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST;
0: 
0:         // the base cost of getting each of the rows from a page assumed
0:         // to already be cached (by the scan fetch) - this is only for all
0:         // rows after the initial row on the page has been accounted for
0:         // under the BASE_UNCACHED_ROW_FETCH_COST cost.:
0:         long cached_row_count = estimated_row_count - num_pages;
0:         if (cached_row_count < 0)
0:             cached_row_count = 0;
0: 
0:         if (scan_type == StoreCostController.STORECOST_SCAN_NORMAL)
0:             cost += cached_row_count * BASE_GROUPSCAN_ROW_COST;
0:         else
0:             cost += cached_row_count * BASE_HASHSCAN_ROW_FETCH_COST;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(cost >= 0);
0:             SanityManager.ASSERT(estimated_row_count >= 0);
0:         }
0: 
0:         cost_result.setEstimatedCost(cost);
0: 
0:         // return that all rows will be scanned.
0:         cost_result.setEstimatedRowCount(estimated_row_count);
0: 
0:         return;
0:     }
0: }
============================================================================