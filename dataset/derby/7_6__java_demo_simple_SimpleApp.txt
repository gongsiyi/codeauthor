1:e55e6be: /*
1:e55e6be: 
1:df69fcc:    Derby - Class SimpleApp
17:df69fcc: 
1:44e2455:    Licensed to the Apache Software Foundation (ASF) under one or more
1:44e2455:    contributor license agreements.  See the NOTICE file distributed with
1:44e2455:    this work for additional information regarding copyright ownership.
1:44e2455:    The ASF licenses this file to You under the Apache License, Version 2.0
1:44e2455:    (the "License"); you may not use this file except in compliance with
1:44e2455:    the License.  You may obtain a copy of the License at
1:df69fcc: 
1:df69fcc:       http://www.apache.org/licenses/LICENSE-2.0
1:df69fcc: 
1:df69fcc:    Unless required by applicable law or agreed to in writing, software
1:df69fcc:    distributed under the License is distributed on an "AS IS" BASIS,
1:df69fcc:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:df69fcc:    See the License for the specific language governing permissions and
1:df69fcc:    limitations under the License.
1:df69fcc: 
8:df69fcc:  */
1:5e8fe1c: 
1:df69fcc: import java.sql.Connection;
1:df69fcc: import java.sql.DriverManager;
1:56d8e51: import java.sql.PreparedStatement;
1:df69fcc: import java.sql.ResultSet;
1:df69fcc: import java.sql.SQLException;
1:df69fcc: import java.sql.Statement;
1:df69fcc: 
1:56d8e51: import java.util.ArrayList;
1:df69fcc: import java.util.Properties;
1:df69fcc: 
1:df69fcc: 
1:56d8e51: /**
1:56d8e51:  * <p>
1:56d8e51:  * This sample program is a minimal Java application showing JDBC access to a
1:56d8e51:  * Derby database.</p>
1:56d8e51:  * <p>
1:df69fcc:  * Instructions for how to run this program are
1:56d8e51:  * given in <A HREF=example.html>example.html</A>, by default located in the
1:56d8e51:  * same directory as this source file ($DERBY_HOME/demo/programs/simple/).</p>
1:56d8e51:  * <p>
1:df69fcc:  * Derby applications can run against Derby running in an embedded
1:56d8e51:  * or a client/server framework.</p>
1:56d8e51:  * <p>
1:56d8e51:  * When Derby runs in an embedded framework, the JDBC application and Derby
1:56d8e51:  * run in the same Java Virtual Machine (JVM). The application
1:56d8e51:  * starts up the Derby engine.</p>
1:56d8e51:  * <p>
1:56d8e51:  * When Derby runs in a client/server framework, the application runs in a
1:1695a5d:  * different JVM from Derby. The connectivity framework (in this case the Derby
1:1695a5d:  * Network Server) provides network connections. The client driver is loaded
1:1695a5d:  * automatically.</p>
1:df69fcc:  */
1:df69fcc: public class SimpleApp
1:e55e6be: {
1:1695a5d:     /* the default framework is embedded */
1:56d8e51:     private String framework = "embedded";
1:56d8e51:     private String protocol = "jdbc:derby:";
1:df69fcc: 
1:56d8e51:     /**
1:56d8e51:      * <p>
1:56d8e51:      * Starts the demo by creating a new instance of this class and running
1:56d8e51:      * the <code>go()</code> method.</p>
1:56d8e51:      * <p>
1:56d8e51:      * When you run this application, you may give one of the following
1:56d8e51:      * arguments:
1:56d8e51:      *  <ul>
1:56d8e51:           <li><code>embedded</code> - default, if none specified. Will use
1:56d8e51:      *        Derby's embedded driver. This driver is included in the derby.jar
1:56d8e51:      *        file.</li>
1:56d8e51:      *    <li><code>derbyclient</code> - will use the Derby client driver to
1:56d8e51:      *        access the Derby Network Server. This driver is included in the
1:56d8e51:      *        derbyclient.jar file.</li>
1:56d8e51:      *  </ul>
1:56d8e51:      * <p>
1:56d8e51:      * When you are using a client/server framework, the network server must
1:56d8e51:      * already be running when trying to obtain client connections to Derby.
1:56d8e51:      * This demo program will will try to connect to a network server on this
1:56d8e51:      * host (the localhost), see the <code>protocol</code> instance variable.
1:56d8e51:      * </p>
1:56d8e51:      * <p>
1:56d8e51:      * When running this demo, you must include the correct driver in the
1:56d8e51:      * classpath of the JVM. See <a href="example.html">example.html</a> for
1:56d8e51:      * details.
1:56d8e51:      * </p>
1:56d8e51:      * @param args This program accepts one optional argument specifying which
1:56d8e51:      *        connection framework (JDBC driver) to use (see above). The default
1:56d8e51:      *        is to use the embedded JDBC driver.
1:56d8e51:      */
1:df69fcc:     public static void main(String[] args)
17:df69fcc:     {
1:df69fcc:         new SimpleApp().go(args);
1:56d8e51:         System.out.println("SimpleApp finished");
1:e55e6be:     }
1:e55e6be: 
1:56d8e51:     /**
1:56d8e51:      * <p>
1:1695a5d:      * Starts the actual demo activities. This includes creating a database by
1:1695a5d:      * making a connection to Derby (automatically loading the driver),
1:45f64ad:      * creating a table in the database, and inserting, updating and retrieving
1:45f64ad:      * some data. Some of the retrieved data is then verified (compared) against
1:56d8e51:      * the expected results. Finally, the table is deleted and, if the embedded
1:56d8e51:      * framework is used, the database is shut down.</p>
1:56d8e51:      * <p>
1:56d8e51:      * Generally, when using a client/server framework, other clients may be
1:56d8e51:      * (or want to be) connected to the database, so you should be careful about
1:45f64ad:      * doing shutdown unless you know that no one else needs to access the
1:56d8e51:      * database until it is rebooted. That is why this demo will not shut down
1:56d8e51:      * the database unless it is running Derby embedded.</p>
3:56d8e51:      *
1:56d8e51:      * @param args - Optional argument specifying which framework or JDBC driver
1:56d8e51:      *        to use to connect to Derby. Default is the embedded framework,
1:56d8e51:      *        see the <code>main()</code> method for details.
1:56d8e51:      * @see #main(String[])
1:56d8e51:      */
1:df69fcc:     void go(String[] args)
1:e55e6be:     {
1:df69fcc:         /* parse the arguments to determine which framework is desired*/
1:df69fcc:         parseArguments(args);
1:e55e6be: 
1:56d8e51:         System.out.println("SimpleApp starting in " + framework + " mode");
1:56d8e51: 
1:56d8e51:         /* We will be using Statement and PreparedStatement objects for
1:56d8e51:          * executing SQL. These objects, as well as Connections and ResultSets,
1:56d8e51:          * are resources that should be released explicitly after use, hence
1:56d8e51:          * the try-catch-finally pattern used below.
1:56d8e51:          * We are storing the Statement and Prepared statement object references
1:56d8e51:          * in an array list for convenience.
1:56d8e51:          */
1:56d8e51:         Connection conn = null;
1:b5b1316:         ArrayList<Statement> statements = new ArrayList<Statement>(); // list of Statements, PreparedStatements
1:1695a5d:         PreparedStatement psInsert;
1:1695a5d:         PreparedStatement psUpdate;
1:1695a5d:         Statement s;
1:56d8e51:         ResultSet rs = null;
2:e55e6be:         try
1:e55e6be:         {
1:56d8e51:             Properties props = new Properties(); // connection properties
1:56d8e51:             // providing a user name and password is optional in the embedded
1:56d8e51:             // and derbyclient frameworks
1:5e8fe1c:             props.put("user", "user1");
1:5e8fe1c:             props.put("password", "user1");
1:5e8fe1c: 
1:56d8e51:             /* By default, the schema APP will be used when no username is
1:56d8e51:              * provided.
1:56d8e51:              * Otherwise, the schema name is the same as the user name (in this
1:56d8e51:              * case "user1" or USER1.)
1:56d8e51:              *
1:56d8e51:              * Note that user authentication is off by default, meaning that any
1:56d8e51:              * user can connect to your database using any password. To enable
1:56d8e51:              * authentication, see the Derby Developer's Guide.
1:e55e6be:              */
1:e55e6be: 
1:56d8e51:             String dbName = "derbyDB"; // the name of the database
1:e55e6be: 
1:56d8e51:             /*
1:56d8e51:              * This connection specifies create=true in the connection URL to
1:56d8e51:              * cause the database to be created when connecting for the first
1:56d8e51:              * time. To remove the database, remove the directory derbyDB (the
1:56d8e51:              * same as the database name) and its contents.
1:56d8e51:              *
1:56d8e51:              * The directory derbyDB will be created under the directory that
1:56d8e51:              * the system property derby.system.home points to, or the current
1:56d8e51:              * directory (user.dir) if derby.system.home is not set.
1:56d8e51:              */
1:56d8e51:             conn = DriverManager.getConnection(protocol + dbName
1:56d8e51:                     + ";create=true", props);
1:56d8e51: 
1:56d8e51:             System.out.println("Connected to and created database " + dbName);
1:56d8e51: 
1:56d8e51:             // We want to control transactions manually. Autocommit is on by
1:56d8e51:             // default in JDBC.
1:df69fcc:             conn.setAutoCommit(false);
1:e55e6be: 
1:56d8e51:             /* Creating a statement object that we can use for running various
1:56d8e51:              * SQL statements commands against the database.*/
1:56d8e51:             s = conn.createStatement();
1:56d8e51:             statements.add(s);
1:df69fcc: 
1:56d8e51:             // We create a table...
1:56d8e51:             s.execute("create table location(num int, addr varchar(40))");
1:56d8e51:             System.out.println("Created table location");
1:56d8e51: 
1:56d8e51:             // and add a few rows...
1:56d8e51: 
1:56d8e51:             /* It is recommended to use PreparedStatements when you are
1:56d8e51:              * repeating execution of an SQL statement. PreparedStatements also
1:56d8e51:              * allows you to parameterize variables. By using PreparedStatements
1:56d8e51:              * you may increase performance (because the Derby engine does not
1:56d8e51:              * have to recompile the SQL statement each time it is executed) and
1:56d8e51:              * improve security (because of Java type checking).
1:e55e6be:              */
1:56d8e51:             // parameter 1 is num (int), parameter 2 is addr (varchar)
1:56d8e51:             psInsert = conn.prepareStatement(
1:56d8e51:                         "insert into location values (?, ?)");
1:56d8e51:             statements.add(psInsert);
1:56d8e51: 
1:56d8e51:             psInsert.setInt(1, 1956);
1:56d8e51:             psInsert.setString(2, "Webster St.");
1:56d8e51:             psInsert.executeUpdate();
1:df69fcc:             System.out.println("Inserted 1956 Webster");
1:56d8e51: 
1:56d8e51:             psInsert.setInt(1, 1910);
1:56d8e51:             psInsert.setString(2, "Union St.");
1:56d8e51:             psInsert.executeUpdate();
1:df69fcc:             System.out.println("Inserted 1910 Union");
1:56d8e51: 
1:56d8e51:             // Let's update some rows as well...
1:56d8e51: 
1:56d8e51:             // parameter 1 and 3 are num (int), parameter 2 is addr (varchar)
1:56d8e51:             psUpdate = conn.prepareStatement(
1:56d8e51:                         "update location set num=?, addr=? where num=?");
1:56d8e51:             statements.add(psUpdate);
1:56d8e51: 
1:56d8e51:             psUpdate.setInt(1, 180);
1:56d8e51:             psUpdate.setString(2, "Grand Ave.");
1:56d8e51:             psUpdate.setInt(3, 1956);
1:56d8e51:             psUpdate.executeUpdate();
1:df69fcc:             System.out.println("Updated 1956 Webster to 180 Grand");
1:df69fcc: 
1:56d8e51:             psUpdate.setInt(1, 300);
1:56d8e51:             psUpdate.setString(2, "Lakeshore Ave.");
1:56d8e51:             psUpdate.setInt(3, 180);
1:56d8e51:             psUpdate.executeUpdate();
1:df69fcc:             System.out.println("Updated 180 Grand to 300 Lakeshore");
1:56d8e51: 
1:df69fcc: 
1:5e8fe1c:             /*
1:df69fcc:                We select the rows and verify the results.
1:df69fcc:              */
1:56d8e51:             rs = s.executeQuery(
1:56d8e51:                     "SELECT num, addr FROM location ORDER BY num");
1:df69fcc: 
1:56d8e51:             /* we expect the first returned column to be an integer (num),
1:56d8e51:              * and second to be a String (addr). Rows are sorted by street
1:56d8e51:              * number (num).
1:56d8e51:              *
1:56d8e51:              * Normally, it is best to use a pattern of
1:56d8e51:              *  while(rs.next()) {
1:56d8e51:              *    // do something with the result set
1:56d8e51:              *  }
1:56d8e51:              * to process all returned rows, but we are only expecting two rows
1:56d8e51:              * this time, and want the verification code to be easy to
1:56d8e51:              * comprehend, so we use a different pattern.
1:56d8e51:              */
1:56d8e51: 
1:45f64ad:             int number; // street number retrieved from the database
1:56d8e51:             boolean failure = false;
1:df69fcc:             if (!rs.next())
1:e55e6be:             {
1:56d8e51:                 failure = true;
1:56d8e51:                 reportFailure("No rows in ResultSet");
1:5e8fe1c:             }
1:df69fcc: 
1:56d8e51:             if ((number = rs.getInt(1)) != 300)
1:e55e6be:             {
1:56d8e51:                 failure = true;
1:56d8e51:                 reportFailure(
1:56d8e51:                         "Wrong row returned, expected num=300, got " + number);
1:e55e6be:             }
1:df69fcc: 
1:df69fcc:             if (!rs.next())
1:e55e6be:             {
1:56d8e51:                 failure = true;
1:56d8e51:                 reportFailure("Too few rows");
1:e55e6be:             }
1:df69fcc: 
1:56d8e51:             if ((number = rs.getInt(1)) != 1910)
1:6558c14:             {
1:56d8e51:                 failure = true;
1:56d8e51:                 reportFailure(
1:56d8e51:                         "Wrong row returned, expected num=1910, got " + number);
1:e55e6be:             }
1:df69fcc: 
1:df69fcc:             if (rs.next())
1:df69fcc:             {
1:56d8e51:                 failure = true;
1:56d8e51:                 reportFailure("Too many rows");
1:e55e6be:             }
1:df69fcc: 
1:56d8e51:             if (!failure) {
1:56d8e51:                 System.out.println("Verified the rows");
1:56d8e51:             }
1:df69fcc: 
1:56d8e51:             // delete the table
1:56d8e51:             s.execute("drop table location");
1:56d8e51:             System.out.println("Dropped table location");
1:df69fcc: 
1:e55e6be:             /*
1:56d8e51:                We commit the transaction. Any changes will be persisted to
1:56d8e51:                the database now.
1:56d8e51:              */
1:df69fcc:             conn.commit();
1:56d8e51:             System.out.println("Committed the transaction");
1:df69fcc: 
1:56d8e51:             /*
1:56d8e51:              * In embedded mode, an application should shut down the database.
1:56d8e51:              * If the application fails to shut down the database,
1:56d8e51:              * Derby will not perform a checkpoint when the JVM shuts down.
1:56d8e51:              * This means that it will take longer to boot (connect to) the
1:56d8e51:              * database the next time, because Derby needs to perform a recovery
1:56d8e51:              * operation.
1:56d8e51:              *
1:56d8e51:              * It is also possible to shut down the Derby system/engine, which
1:56d8e51:              * automatically shuts down all booted databases.
1:56d8e51:              *
1:56d8e51:              * Explicitly shutting down the database or the Derby engine with
1:56d8e51:              * the connection URL is preferred. This style of shutdown will
1:56d8e51:              * always throw an SQLException.
1:56d8e51:              *
1:56d8e51:              * Not shutting down when in a client environment, see method
1:56d8e51:              * Javadoc.
1:56d8e51:              */
1:df69fcc: 
1:df69fcc:             if (framework.equals("embedded"))
1:e55e6be:             {
1:5e8fe1c:                 try
1:e55e6be:                 {
1:56d8e51:                     // the shutdown=true attribute shuts down Derby
1:5e8fe1c:                     DriverManager.getConnection("jdbc:derby:;shutdown=true");
1:56d8e51: 
1:45f64ad:                     // To shut down a specific database only, but keep the
1:56d8e51:                     // engine running (for example for connecting to other
1:56d8e51:                     // databases), specify a database in the connection URL:
1:56d8e51:                     //DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
1:e55e6be:                 }
1:5e8fe1c:                 catch (SQLException se)
1:5e8fe1c:                 {
1:56d8e51:                     if (( (se.getErrorCode() == 50000)
1:56d8e51:                             && ("XJ015".equals(se.getSQLState()) ))) {
1:56d8e51:                         // we got the expected exception
1:56d8e51:                         System.out.println("Derby shut down normally");
1:56d8e51:                         // Note that for single database shutdown, the expected
1:56d8e51:                         // SQL state is "08006", and the error code is 45000.
1:56d8e51:                     } else {
1:56d8e51:                         // if the error code or SQLState is different, we have
1:56d8e51:                         // an unexpected exception (shutdown failed)
1:56d8e51:                         System.err.println("Derby did not shut down normally");
1:56d8e51:                         printSQLException(se);
1:56d8e51:                     }
1:e55e6be:                 }
1:e55e6be:             }
1:e55e6be:         }
1:56d8e51:         catch (SQLException sqle)
1:e55e6be:         {
1:56d8e51:             printSQLException(sqle);
1:56d8e51:         } finally {
1:56d8e51:             // release all open resources to avoid unnecessary memory usage
1:df69fcc: 
1:56d8e51:             // ResultSet
2:56d8e51:             try {
1:56d8e51:                 if (rs != null) {
1:56d8e51:                     rs.close();
1:56d8e51:                     rs = null;
1:56d8e51:                 }
1:56d8e51:             } catch (SQLException sqle) {
1:56d8e51:                 printSQLException(sqle);
16:df69fcc:             }
1:56d8e51: 
1:56d8e51:             // Statements and PreparedStatements
1:56d8e51:             int i = 0;
1:56d8e51:             while (!statements.isEmpty()) {
1:56d8e51:                 // PreparedStatement extend Statement
1:56d8e51:                 Statement st = (Statement)statements.remove(i);
1:56d8e51:                 try {
1:56d8e51:                     if (st != null) {
1:56d8e51:                         st.close();
1:56d8e51:                         st = null;
1:56d8e51:                     }
1:56d8e51:                 } catch (SQLException sqle) {
1:56d8e51:                     printSQLException(sqle);
1:56d8e51:                 }
1:56d8e51:             }
1:56d8e51: 
1:56d8e51:             //Connection
1:56d8e51:             try {
1:56d8e51:                 if (conn != null) {
1:56d8e51:                     conn.close();
1:56d8e51:                     conn = null;
1:56d8e51:                 }
1:56d8e51:             } catch (SQLException sqle) {
1:56d8e51:                 printSQLException(sqle);
1:56d8e51:             }
1:56d8e51:         }
1:df69fcc:     }
1:56d8e51: 
1:56d8e51:     /**
1:56d8e51:      * Reports a data verification failure to System.err with the given message.
1:56d8e51:      *
1:56d8e51:      * @param message A message describing what failed.
1:56d8e51:      */
1:56d8e51:     private void reportFailure(String message) {
1:56d8e51:         System.err.println("\nData verification failed:");
1:56d8e51:         System.err.println('\t' + message);
1:56d8e51:     }
1:56d8e51: 
1:56d8e51:     /**
1:56d8e51:      * Prints details of an SQLException chain to <code>System.err</code>.
1:56d8e51:      * Details included are SQL State, Error code, Exception message.
1:56d8e51:      *
1:56d8e51:      * @param e the SQLException from which to print details.
1:56d8e51:      */
1:56d8e51:     public static void printSQLException(SQLException e)
1:df69fcc:     {
1:56d8e51:         // Unwraps the entire exception chain to unveil the real cause of the
1:56d8e51:         // Exception.
1:df69fcc:         while (e != null)
1:df69fcc:         {
1:56d8e51:             System.err.println("\n----- SQLException -----");
1:56d8e51:             System.err.println("  SQL State:  " + e.getSQLState());
1:56d8e51:             System.err.println("  Error Code: " + e.getErrorCode());
1:56d8e51:             System.err.println("  Message:    " + e.getMessage());
1:56d8e51:             // for stack traces, refer to derby.log or uncomment this:
1:56d8e51:             //e.printStackTrace(System.err);
1:df69fcc:             e = e.getNextException();
1:df69fcc:         }
1:df69fcc:     }
1:df69fcc: 
1:56d8e51:     /**
1:1695a5d:      * Parses the arguments given and sets the values of this class's instance
1:1695a5d:      * variables accordingly - that is, which framework to use, the name of the
1:1695a5d:      * JDBC driver class, and which connection protocol to use. The
1:56d8e51:      * protocol should be used as part of the JDBC URL when connecting to Derby.
1:56d8e51:      * <p>
1:56d8e51:      * If the argument is "embedded" or invalid, this method will not change
1:56d8e51:      * anything, meaning that the default values will be used.</p>
1:56d8e51:      * <p>
1:1695a5d:      * @param args JDBC connection framework, either "embedded" or "derbyclient".
1:45f64ad:      * Only the first argument will be considered, the rest will be ignored.
1:56d8e51:      */
1:df69fcc:     private void parseArguments(String[] args)
1:df69fcc:     {
1:56d8e51:         if (args.length > 0) {
1:45f64ad:             if (args[0].equalsIgnoreCase("derbyclient"))
1:df69fcc:             {
1:6558c14:                 framework = "derbyclient";
1:6558c14:                 protocol = "jdbc:derby://localhost:1527/";
1:6558c14:             }
1:df69fcc:         }
1:df69fcc:     }
1:df69fcc: }
============================================================================
author:Camilla Haase
-------------------------------------------------------------------------------
commit:1695a5d
/////////////////////////////////////////////////////////////////////////
1:  * different JVM from Derby. The connectivity framework (in this case the Derby
1:  * Network Server) provides network connections. The client driver is loaded
1:  * automatically.</p>
1:     /* the default framework is embedded */
/////////////////////////////////////////////////////////////////////////
1:      * Starts the actual demo activities. This includes creating a database by
1:      * making a connection to Derby (automatically loading the driver),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement psInsert;
1:         PreparedStatement psUpdate;
1:         Statement s;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Parses the arguments given and sets the values of this class's instance
1:      * variables accordingly - that is, which framework to use, the name of the
1:      * JDBC driver class, and which connection protocol to use. The
1:      * @param args JDBC connection framework, either "embedded" or "derbyclient".
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b5b1316
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Statement> statements = new ArrayList<Statement>(); // list of Statements, PreparedStatements
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:45f64ad
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * creating a table in the database, and inserting, updating and retrieving
1:      * some data. Some of the retrieved data is then verified (compared) against
1:      * doing shutdown unless you know that no one else needs to access the
/////////////////////////////////////////////////////////////////////////
1:             int number; // street number retrieved from the database
/////////////////////////////////////////////////////////////////////////
1:                     // To shut down a specific database only, but keep the
/////////////////////////////////////////////////////////////////////////
0:      * @param args JDBC connection framework, either "embedded", "derbyclient".
1:      * Only the first argument will be considered, the rest will be ignored.
1:             if (args[0].equalsIgnoreCase("derbyclient"))
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:56d8e51
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
1: import java.util.ArrayList;
1:  * <p>
1:  * This sample program is a minimal Java application showing JDBC access to a
1:  * Derby database.</p>
1:  * <p>
1:  * given in <A HREF=example.html>example.html</A>, by default located in the
1:  * same directory as this source file ($DERBY_HOME/demo/programs/simple/).</p>
1:  * <p>
1:  * or a client/server framework.</p>
1:  * <p>
1:  * When Derby runs in an embedded framework, the JDBC application and Derby
1:  * run in the same Java Virtual Machine (JVM). The application
1:  * starts up the Derby engine.</p>
1:  * <p>
1:  * When Derby runs in a client/server framework, the application runs in a
0:  * different JVM from Derby. The application only needs to load the client
0:  * driver, and the connectivity framework (in this case the Derby Network
0:  * Server) provides network connections.</p>
1:     private String framework = "embedded";
0:     private String driver = "org.apache.derby.jdbc.EmbeddedDriver";
1:     private String protocol = "jdbc:derby:";
1:     /**
1:      * <p>
1:      * Starts the demo by creating a new instance of this class and running
1:      * the <code>go()</code> method.</p>
1:      * <p>
1:      * When you run this application, you may give one of the following
1:      * arguments:
1:      *  <ul>
1:           <li><code>embedded</code> - default, if none specified. Will use
1:      *        Derby's embedded driver. This driver is included in the derby.jar
1:      *        file.</li>
1:      *    <li><code>derbyclient</code> - will use the Derby client driver to
1:      *        access the Derby Network Server. This driver is included in the
1:      *        derbyclient.jar file.</li>
0:      *    <li><code>jccjdbcclient</code> - will use the DB2 Universal JDBC
0:      *        network client driver, also known as JCC, to access the Network
0:      *        Server. This driver is not part of the Derby distribution.</li>
1:      *  </ul>
1:      * <p>
1:      * When you are using a client/server framework, the network server must
1:      * already be running when trying to obtain client connections to Derby.
1:      * This demo program will will try to connect to a network server on this
1:      * host (the localhost), see the <code>protocol</code> instance variable.
1:      * </p>
1:      * <p>
1:      * When running this demo, you must include the correct driver in the
1:      * classpath of the JVM. See <a href="example.html">example.html</a> for
1:      * details.
1:      * </p>
1:      * @param args This program accepts one optional argument specifying which
1:      *        connection framework (JDBC driver) to use (see above). The default
1:      *        is to use the embedded JDBC driver.
1:      */
1:         System.out.println("SimpleApp finished");
1:     /**
1:      * <p>
0:      * Starts the actual demo activities. This includes loading the correct
0:      * JDBC driver, creating a database by making a connection to Derby,
0:      * creating a table in the database, and inserting, updating and retreiving
0:      * some data. Some of the retreived data is then verified (compared) against
1:      * the expected results. Finally, the table is deleted and, if the embedded
1:      * framework is used, the database is shut down.</p>
1:      * <p>
1:      * Generally, when using a client/server framework, other clients may be
1:      * (or want to be) connected to the database, so you should be careful about
0:      * doing shutdown unless you know that noone else needs to access the
1:      * database until it is rebooted. That is why this demo will not shut down
1:      * the database unless it is running Derby embedded.</p>
1:      *
1:      * @param args - Optional argument specifying which framework or JDBC driver
1:      *        to use to connect to Derby. Default is the embedded framework,
1:      *        see the <code>main()</code> method for details.
1:      * @see #main(String[])
1:      */
1:         System.out.println("SimpleApp starting in " + framework + " mode");
0:         /* load the desired JDBC driver */
0:         loadDriver();
1: 
1:         /* We will be using Statement and PreparedStatement objects for
1:          * executing SQL. These objects, as well as Connections and ResultSets,
1:          * are resources that should be released explicitly after use, hence
1:          * the try-catch-finally pattern used below.
1:          * We are storing the Statement and Prepared statement object references
1:          * in an array list for convenience.
1:          */
1:         Connection conn = null;
0: 	/* This ArrayList usage may cause a warning when compiling this class
0: 	 * with a compiler for J2SE 5.0 or newer. We are not using generics
0: 	 * because we want the source to support J2SE 1.4.2 environments. */
0:         ArrayList statements = new ArrayList(); // list of Statements, PreparedStatements
0:         PreparedStatement psInsert = null;
0:         PreparedStatement psUpdate = null;
0:         Statement s = null;
1:         ResultSet rs = null;
1:             Properties props = new Properties(); // connection properties
1:             // providing a user name and password is optional in the embedded
1:             // and derbyclient frameworks
1:             /* By default, the schema APP will be used when no username is
1:              * provided.
1:              * Otherwise, the schema name is the same as the user name (in this
1:              * case "user1" or USER1.)
1:              *
1:              * Note that user authentication is off by default, meaning that any
1:              * user can connect to your database using any password. To enable
1:              * authentication, see the Derby Developer's Guide.
1:             String dbName = "derbyDB"; // the name of the database
1:             /*
1:              * This connection specifies create=true in the connection URL to
1:              * cause the database to be created when connecting for the first
1:              * time. To remove the database, remove the directory derbyDB (the
1:              * same as the database name) and its contents.
1:              *
1:              * The directory derbyDB will be created under the directory that
1:              * the system property derby.system.home points to, or the current
1:              * directory (user.dir) if derby.system.home is not set.
1:              */
1:             conn = DriverManager.getConnection(protocol + dbName
1:                     + ";create=true", props);
1: 
1:             System.out.println("Connected to and created database " + dbName);
1: 
1:             // We want to control transactions manually. Autocommit is on by
1:             // default in JDBC.
1:             /* Creating a statement object that we can use for running various
1:              * SQL statements commands against the database.*/
1:             s = conn.createStatement();
1:             statements.add(s);
1:             // We create a table...
1:             s.execute("create table location(num int, addr varchar(40))");
1:             System.out.println("Created table location");
1: 
1:             // and add a few rows...
1: 
1:             /* It is recommended to use PreparedStatements when you are
1:              * repeating execution of an SQL statement. PreparedStatements also
1:              * allows you to parameterize variables. By using PreparedStatements
1:              * you may increase performance (because the Derby engine does not
1:              * have to recompile the SQL statement each time it is executed) and
1:              * improve security (because of Java type checking).
1:             // parameter 1 is num (int), parameter 2 is addr (varchar)
1:             psInsert = conn.prepareStatement(
1:                         "insert into location values (?, ?)");
1:             statements.add(psInsert);
1: 
1:             psInsert.setInt(1, 1956);
1:             psInsert.setString(2, "Webster St.");
1:             psInsert.executeUpdate();
1: 
1:             psInsert.setInt(1, 1910);
1:             psInsert.setString(2, "Union St.");
1:             psInsert.executeUpdate();
1: 
1:             // Let's update some rows as well...
1: 
1:             // parameter 1 and 3 are num (int), parameter 2 is addr (varchar)
1:             psUpdate = conn.prepareStatement(
1:                         "update location set num=?, addr=? where num=?");
1:             statements.add(psUpdate);
1: 
1:             psUpdate.setInt(1, 180);
1:             psUpdate.setString(2, "Grand Ave.");
1:             psUpdate.setInt(3, 1956);
1:             psUpdate.executeUpdate();
1:             psUpdate.setInt(1, 300);
1:             psUpdate.setString(2, "Lakeshore Ave.");
1:             psUpdate.setInt(3, 180);
1:             psUpdate.executeUpdate();
1: 
1:             rs = s.executeQuery(
1:                     "SELECT num, addr FROM location ORDER BY num");
1:             /* we expect the first returned column to be an integer (num),
1:              * and second to be a String (addr). Rows are sorted by street
1:              * number (num).
1:              *
1:              * Normally, it is best to use a pattern of
1:              *  while(rs.next()) {
1:              *    // do something with the result set
1:              *  }
1:              * to process all returned rows, but we are only expecting two rows
1:              * this time, and want the verification code to be easy to
1:              * comprehend, so we use a different pattern.
1:              */
1: 
0:             int number; // street number retreived from the database
1:             boolean failure = false;
1:                 failure = true;
1:                 reportFailure("No rows in ResultSet");
1:             if ((number = rs.getInt(1)) != 300)
1:                 failure = true;
1:                 reportFailure(
1:                         "Wrong row returned, expected num=300, got " + number);
1:                 failure = true;
1:                 reportFailure("Too few rows");
1:             if ((number = rs.getInt(1)) != 1910)
1:                 failure = true;
1:                 reportFailure(
1:                         "Wrong row returned, expected num=1910, got " + number);
1:                 failure = true;
1:                 reportFailure("Too many rows");
1:             if (!failure) {
1:                 System.out.println("Verified the rows");
1:             }
1:             // delete the table
1:             s.execute("drop table location");
1:             System.out.println("Dropped table location");
1:                We commit the transaction. Any changes will be persisted to
1:                the database now.
1:             System.out.println("Committed the transaction");
1:              * In embedded mode, an application should shut down the database.
1:              * If the application fails to shut down the database,
1:              * Derby will not perform a checkpoint when the JVM shuts down.
1:              * This means that it will take longer to boot (connect to) the
1:              * database the next time, because Derby needs to perform a recovery
1:              * operation.
1:              *
1:              * It is also possible to shut down the Derby system/engine, which
1:              * automatically shuts down all booted databases.
1:              *
1:              * Explicitly shutting down the database or the Derby engine with
1:              * the connection URL is preferred. This style of shutdown will
1:              * always throw an SQLException.
1:              *
1:              * Not shutting down when in a client environment, see method
1:              * Javadoc.
1:                     // the shutdown=true attribute shuts down Derby
1: 
0:                     // To shut down a specific database only, but keeep the
1:                     // engine running (for example for connecting to other
1:                     // databases), specify a database in the connection URL:
1:                     //DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
1:                     if (( (se.getErrorCode() == 50000)
1:                             && ("XJ015".equals(se.getSQLState()) ))) {
1:                         // we got the expected exception
1:                         System.out.println("Derby shut down normally");
1:                         // Note that for single database shutdown, the expected
1:                         // SQL state is "08006", and the error code is 45000.
1:                     } else {
1:                         // if the error code or SQLState is different, we have
1:                         // an unexpected exception (shutdown failed)
1:                         System.err.println("Derby did not shut down normally");
1:                         printSQLException(se);
1:                     }
1:         catch (SQLException sqle)
1:             printSQLException(sqle);
1:         } finally {
1:             // release all open resources to avoid unnecessary memory usage
1:             // ResultSet
1:             try {
1:                 if (rs != null) {
1:                     rs.close();
1:                     rs = null;
1:                 }
1:             } catch (SQLException sqle) {
1:                 printSQLException(sqle);
1: 
1:             // Statements and PreparedStatements
1:             int i = 0;
1:             while (!statements.isEmpty()) {
1:                 // PreparedStatement extend Statement
1:                 Statement st = (Statement)statements.remove(i);
1:                 try {
1:                     if (st != null) {
1:                         st.close();
1:                         st = null;
1:                     }
1:                 } catch (SQLException sqle) {
1:                     printSQLException(sqle);
1:                 }
1:             }
1: 
1:             //Connection
1:             try {
1:                 if (conn != null) {
1:                     conn.close();
1:                     conn = null;
1:                 }
1:             } catch (SQLException sqle) {
1:                 printSQLException(sqle);
1:     /**
0:      * Loads the appropriate JDBC driver for this environment/framework. For
0:      * example, if we are in an embedded environment, we load Derby's
0:      * embedded Driver, <code>org.apache.derby.jdbc.EmbeddedDriver</code>.
1:      */
0:     private void loadDriver() {
1:         /*
0:          *  The JDBC driver is loaded by loading its class.
0:          *  If you are using JDBC 4.0 (Java SE 6) or newer, JDBC drivers may
0:          *  be automatically loaded, making this code optional.
1:          *
0:          *  In an embedded environment, this will also start up the Derby
0:          *  engine (though not any databases), since it is not already
0:          *  running. In a client environment, the Derby engine is being run
0:          *  by the network server framework.
1:          *
0:          *  In an embedded environment, any static Derby system properties
0:          *  must be set before loading the driver to take effect.
1:          */
1:         try {
0:             Class.forName(driver).newInstance();
0:             System.out.println("Loaded the appropriate driver");
0:         } catch (ClassNotFoundException cnfe) {
0:             System.err.println("\nUnable to load the JDBC driver " + driver);
0:             System.err.println("Please check your CLASSPATH.");
0:             cnfe.printStackTrace(System.err);
0:         } catch (InstantiationException ie) {
0:             System.err.println(
0:                         "\nUnable to instantiate the JDBC driver " + driver);
0:             ie.printStackTrace(System.err);
0:         } catch (IllegalAccessException iae) {
0:             System.err.println(
0:                         "\nNot allowed to access the JDBC driver " + driver);
0:             iae.printStackTrace(System.err);
1:         }
1:     }
1: 
1:     /**
1:      * Reports a data verification failure to System.err with the given message.
1:      *
1:      * @param message A message describing what failed.
1:      */
1:     private void reportFailure(String message) {
1:         System.err.println("\nData verification failed:");
1:         System.err.println('\t' + message);
1:     }
1: 
1:     /**
1:      * Prints details of an SQLException chain to <code>System.err</code>.
1:      * Details included are SQL State, Error code, Exception message.
1:      *
1:      * @param e the SQLException from which to print details.
1:      */
1:     public static void printSQLException(SQLException e)
1:         // Unwraps the entire exception chain to unveil the real cause of the
1:         // Exception.
1:             System.err.println("\n----- SQLException -----");
1:             System.err.println("  SQL State:  " + e.getSQLState());
1:             System.err.println("  Error Code: " + e.getErrorCode());
1:             System.err.println("  Message:    " + e.getMessage());
1:             // for stack traces, refer to derby.log or uncomment this:
1:             //e.printStackTrace(System.err);
1:     /**
0:      * Parses the arguments given and sets the values of this class' instance
0:      * variables accordingly - that is which framework to use, the name of the
0:      * JDBC driver class, and which connection protocol protocol to use. The
1:      * protocol should be used as part of the JDBC URL when connecting to Derby.
1:      * <p>
1:      * If the argument is "embedded" or invalid, this method will not change
1:      * anything, meaning that the default values will be used.</p>
1:      * <p>
0:      * @param args JDBC connection framework, either "embedded", "derbyclient"
0:      *        or "jccjdbcclient". Only the first argument will be considered,
0:      *        the rest will be ignored.
1:      */
1:         if (args.length > 0) {
0:             if (args[0].equalsIgnoreCase("jccjdbcclient"))
0:             else if (args[0].equalsIgnoreCase("derbyclient"))
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:5e8fe1c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             Class.forName(driver).newInstance();
0:             System.out.println("Loaded the appropriate driver.");
1: 
1:             props.put("user", "user1");
1:             props.put("password", "user1");
1:             /*
0:                The connection specifies create=true to cause
0:                the database to be created. To remove the database,
0:                remove the directory derbyDB and its contents.
0:                The directory derbyDB will be created under
0:                the directory that the system property
0:                derby.system.home points to, or the current
0:                directory if derby.system.home is not set.
0:             conn = DriverManager.getConnection(protocol +
1: 
/////////////////////////////////////////////////////////////////////////
1:                 try
1:                     DriverManager.getConnection("jdbc:derby:;shutdown=true");
1:                 catch (SQLException se)
1:                 {
0:                     gotSQLExc = true;
/////////////////////////////////////////////////////////////////////////
1: }
commit:e55e6be
/////////////////////////////////////////////////////////////////////////
1:     
0:     public String username = "user1";
0:     public String password = "user1";
/////////////////////////////////////////////////////////////////////////
0:         /* check for J2ME specification - J2ME must use a DataSource further on */
0:         String javaspec = System.getProperty( "java.specification.name" );
0:         boolean java2me = false;
0:         if( javaspec.indexOf( "J2ME" ) > -1 )
1:         {
0:             java2me = true;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:             org.apache.derby.jdbc.EmbeddedSimpleDataSource ds = null;
0:             props.put("user", username);
0:             props.put("password", password);
0:             /* If we are using a J2ME jvm, we need to use a DataSource, otherwise
0:              * we can use java.sql.DriverManager to get the connection, or
0:              * a Datasource. This example program uses a DataSource with J2ME
0:              * but uses DriverManager otherwise.
0:              * If we were to use a DataSource for J2SE, we could use
0:              * the org.apache.derby.jdbc.EmbeddedDataSource, rather than the
0:              * org.apache.derby.jdbc.EmbeddedSimpleDataSource we need to use for J2ME.
1:          
0:             if( java2me )
1:             {
1:                 /*
0:                    The connection specifies create in the DataSource settings for
0:                    the database to be created. To remove the database,
0:                    remove the directory derbyDB and its contents.
0:                    The directory derbyDB will be created under
0:                    the directory that the system property
0:                    derby.system.home points to, or the current
0:                    directory if derby.system.home is not set.
1:                  */
1:        
0:                 ds = new org.apache.derby.jdbc.EmbeddedSimpleDataSource();
0:                 ds.setDatabaseName("derbyDB");
0:                 ds.setCreateDatabase("create");
0:                 conn = ds.getConnection(username, password);
1:             }
0:             else
1:             {
1:                 /*
0:                    The connection specifies create=true in the url to cause
0:                    the database to be created. To remove the database,
0:                    remove the directory derbyDB and its contents.
0:                    The directory derbyDB will be created under
0:                    the directory that the system property
0:                    derby.system.home points to, or the current
0:                    directory if derby.system.home is not set.
1:                  */
1:           
0:                 Class.forName(driver).newInstance();
0:                 System.out.println("Loaded the appropriate driver.");
1:             
0:                 conn = DriverManager.getConnection(protocol +
1:             }
/////////////////////////////////////////////////////////////////////////
0:                 /* again, with J2ME, we need to use a datasource to get the connection */
0:                 if( java2me )
1:                     try
1:                     {
0:                         ds.setShutdownDatabase( "shutdown" );
0:                         conn = ds.getConnection(username, password);
1:                     }
0:                     catch (SQLException se)
1:                     {
0:                         if( se.getErrorCode() == 45000 )
1:                         {
0:                             gotSQLExc = true;
1:                         }
1:                     }
0:                 else                  
1:                 {   
1:                     try
1:                     {
0:                         DriverManager.getConnection("jdbc:derby:;shutdown=true");
1:                     }
0:                     catch (SQLException se)
1:                     {
0:                         gotSQLExc = true;
1:                     }
/////////////////////////////////////////////////////////////////////////
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:44e2455
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6558c14
/////////////////////////////////////////////////////////////////////////
0:  *    * derbyclient (will use the Net client driver to access Network Server)
/////////////////////////////////////////////////////////////////////////
0:             if (args[index].equalsIgnoreCase("derbyclient"))
1:             {
1:                 framework = "derbyclient";
0:                 driver = "org.apache.derby.jdbc.ClientDriver";
1:                 protocol = "jdbc:derby://localhost:1527/";
1:             }
commit:df69fcc
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class SimpleApp
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import java.util.Properties;
1: 
1: 
0: /**
0:  * This sample program is a minimal JDBC application showing
0:  * JDBC access to Derby.
0:  *
1:  * Instructions for how to run this program are
0:  * given in <A HREF=example.html>example.html</A>.
0:  *
1:  * Derby applications can run against Derby running in an embedded
0:  * or a client/server framework. When Derby runs in an embedded framework,
0:  * the Derby application and Derby run in the same JVM. The application
0:  * starts up the Derby engine. When Derby runs in a client/server framework,
0:  * the application runs in a different JVM from Derby. The application only needs
0:  * to start the client driver, and the connectivity framework provides network connections.
0:  * (The server must already be running.)
0:  *
0:  * <p>When you run this application, give one of the following arguments:
0:  *    * embedded (default, if none specified)
0:  *    * jccjdbcclient (if Derby is running embedded in the JCC Server framework)
0:  *
0:  * @author janet
1:  */
1: public class SimpleApp
1: {
0:     /* the default framework is embedded*/
0:     public String framework = "embedded";
0:     public String driver = "org.apache.derby.jdbc.EmbeddedDriver";
0:     public String protocol = "jdbc:derby:";
1: 
1:     public static void main(String[] args)
1:     {
1:         new SimpleApp().go(args);
1:     }
1: 
1:     void go(String[] args)
1:     {
1:         /* parse the arguments to determine which framework is desired*/
1:         parseArguments(args);
1: 
0:         System.out.println("SimpleApp starting in " + framework + " mode.");
1: 
0:         try
1:         {
0:             /*
0:                The driver is installed by loading its class.
0:                In an embedded environment, this will start up Derby, since it is not already running.
1:              */
0:             Class.forName(driver).newInstance();
0:             System.out.println("Loaded the appropriate driver.");
1: 
0:             Connection conn = null;
0:             Properties props = new Properties();
0:             props.put("user", "user1");
0:             props.put("password", "user1");
1: 
0:             /*
0:                The connection specifies create=true to cause
0:                the database to be created. To remove the database,
0:                remove the directory derbyDB and its contents.
0:                The directory derbyDB will be created under
0:                the directory that the system property
0:                derby.system.home points to, or the current
0:                directory if derby.system.home is not set.
1:              */
0:             conn = DriverManager.getConnection(protocol +
0:                     "derbyDB;create=true", props);
1: 
0:             System.out.println("Connected to and created database derbyDB");
1: 
1:             conn.setAutoCommit(false);
1: 
0:             /*
0:                Creating a statement lets us issue commands against
0:                the connection.
1:              */
0:             Statement s = conn.createStatement();
1: 
0:             /*
0:                We create a table, add a few rows, and update one.
1:              */
0:             s.execute("create table derbyDB(num int, addr varchar(40))");
0:             System.out.println("Created table derbyDB");
0:             s.execute("insert into derbyDB values (1956,'Webster St.')");
1:             System.out.println("Inserted 1956 Webster");
0:             s.execute("insert into derbyDB values (1910,'Union St.')");
1:             System.out.println("Inserted 1910 Union");
0:             s.execute(
0:                 "update derbyDB set num=180, addr='Grand Ave.' where num=1956");
1:             System.out.println("Updated 1956 Webster to 180 Grand");
1: 
0:             s.execute(
0:                 "update derbyDB set num=300, addr='Lakeshore Ave.' where num=180");
1:             System.out.println("Updated 180 Grand to 300 Lakeshore");
1: 
0:             /*
1:                We select the rows and verify the results.
1:              */
0:             ResultSet rs = s.executeQuery(
0:                     "SELECT num, addr FROM derbyDB ORDER BY num");
1: 
1:             if (!rs.next())
1:             {
0:                 throw new Exception("Wrong number of rows");
1:             }
1: 
0:             if (rs.getInt(1) != 300)
1:             {
0:                 throw new Exception("Wrong row returned");
1:             }
1: 
1:             if (!rs.next())
1:             {
0:                 throw new Exception("Wrong number of rows");
1:             }
1: 
0:             if (rs.getInt(1) != 1910)
1:             {
0:                 throw new Exception("Wrong row returned");
1:             }
1: 
1:             if (rs.next())
1:             {
0:                 throw new Exception("Wrong number of rows");
1:             }
1: 
0:             System.out.println("Verified the rows");
1: 
0:             s.execute("drop table derbyDB");
0:             System.out.println("Dropped table derbyDB");
1: 
0:             /*
0:                We release the result and statement resources.
1:              */
0:             rs.close();
0:             s.close();
0:             System.out.println("Closed result set and statement");
1: 
0:             /*
0:                We end the transaction and the connection.
1:              */
1:             conn.commit();
0:             conn.close();
0:             System.out.println("Committed transaction and closed connection");
1: 
0:             /*
0:                In embedded mode, an application should shut down Derby.
0:                If the application fails to shut down Derby explicitly,
0:                the Derby does not perform a checkpoint when the JVM shuts down, which means
0:                that the next connection will be slower.
0:                Explicitly shutting down Derby with the URL is preferred.
0:                This style of shutdown will always throw an "exception".
1:              */
0:             boolean gotSQLExc = false;
1: 
1:             if (framework.equals("embedded"))
1:             {
0:                 try
1:                 {
0:                     DriverManager.getConnection("jdbc:derby:;shutdown=true");
1:                 }
0:                 catch (SQLException se)
1:                 {
0:                     gotSQLExc = true;
1:                 }
1: 
0:                 if (!gotSQLExc)
1:                 {
0:                     System.out.println("Database did not shut down normally");
1:                 }
0:                 else
1:                 {
0:                     System.out.println("Database shut down normally");
1:                 }
1:             }
1:         }
0:         catch (Throwable e)
1:         {
0:             System.out.println("exception thrown:");
1: 
0:             if (e instanceof SQLException)
1:             {
0:                 printSQLError((SQLException) e);
1:             }
0:             else
1:             {
0:                 e.printStackTrace();
1:             }
1:         }
1: 
0:         System.out.println("SimpleApp finished");
1:     }
1: 
0:     static void printSQLError(SQLException e)
1:     {
1:         while (e != null)
1:         {
0:             System.out.println(e.toString());
1:             e = e.getNextException();
1:         }
1:     }
1: 
1:     private void parseArguments(String[] args)
1:     {
0:         int length = args.length;
1: 
0:         for (int index = 0; index < length; index++)
1:         {
0:             if (args[index].equalsIgnoreCase("jccjdbcclient"))
1:             {
0:                 framework = "jccjdbc";
0:                 driver = "com.ibm.db2.jcc.DB2Driver";
0:                 protocol = "jdbc:derby:net://localhost:1527/";
1:             }
1:         }
1:     }
1: }
commit:6f35451
/////////////////////////////////////////////////////////////////////////
0: 
0:    Derby - Class SimpleApp
0: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0: 
0: import java.sql.Connection;
commit:67614ad
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Connection;
0: 
0: /*
0:  * (C) Copyright IBM Corp. 2001, 2004.
0:  *
0:  * The source code for this program is not published or otherwise divested
0:  * of its trade secrets, irrespective of what has been deposited with the
0:  * U.S. Copyright Office.
0:  */
0: import java.sql.DriverManager;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.Statement;
0: 
0: import java.util.Properties;
0: 
0: 
0: /**
0:  * This sample program is a minimal JDBC application showing
0:  * JDBC access to Derby.
0:  *
0:  * Instructions for how to run this program are
0:  * given in <A HREF=example.html>example.html</A>.
0:  *
0:  * Derby applications can run against Derby running in an embedded
0:  * or a client/server framework. When Derby runs in an embedded framework,
0:  * the Derby application and Derby run in the same JVM. The application
0:  * starts up the Derby engine. When Derby runs in a client/server framework,
0:  * the application runs in a different JVM from Derby. The application only needs
0:  * to start the client driver, and the connectivity framework provides network connections.
0:  * (The server must already be running.)
0:  *
0:  * <p>When you run this application, give one of the following arguments:
0:  *    * embedded (default, if none specified)
0:  *    * jccjdbcclient (if Derby is running embedded in the JCC Server framework)
0:  *
0:  * @author janet
0:  */
0: public class SimpleApp
0: {
0:     /* the default framework is embedded*/
0:     public String framework = "embedded";
0:     public String driver = "org.apache.derby.jdbc.EmbeddedDriver";
0:     public String protocol = "jdbc:derby:";
0: 
0:     public static void main(String[] args)
0:     {
0:         new SimpleApp().go(args);
0:     }
0: 
0:     void go(String[] args)
0:     {
0:         /* parse the arguments to determine which framework is desired*/
0:         parseArguments(args);
0: 
0:         System.out.println("SimpleApp starting in " + framework + " mode.");
0: 
0:         try
0:         {
0:             /*
0:                The driver is installed by loading its class.
0:                In an embedded environment, this will start up Derby, since it is not already running.
0:              */
0:             Class.forName(driver).newInstance();
0:             System.out.println("Loaded the appropriate driver.");
0: 
0:             Connection conn = null;
0:             Properties props = new Properties();
0:             props.put("user", "user1");
0:             props.put("password", "user1");
0: 
0:             /*
0:                The connection specifies create=true to cause
0:                the database to be created. To remove the database,
0:                remove the directory derbyDB and its contents.
0:                The directory derbyDB will be created under
0:                the directory that the system property
0:                derby.system.home points to, or the current
0:                directory if derby.system.home is not set.
0:              */
0:             conn = DriverManager.getConnection(protocol +
0:                     "derbyDB;create=true", props);
0: 
0:             System.out.println("Connected to and created database derbyDB");
0: 
0:             conn.setAutoCommit(false);
0: 
0:             /*
0:                Creating a statement lets us issue commands against
0:                the connection.
0:              */
0:             Statement s = conn.createStatement();
0: 
0:             /*
0:                We create a table, add a few rows, and update one.
0:              */
0:             s.execute("create table derbyDB(num int, addr varchar(40))");
0:             System.out.println("Created table derbyDB");
0:             s.execute("insert into derbyDB values (1956,'Webster St.')");
0:             System.out.println("Inserted 1956 Webster");
0:             s.execute("insert into derbyDB values (1910,'Union St.')");
0:             System.out.println("Inserted 1910 Union");
0:             s.execute(
0:                 "update derbyDB set num=180, addr='Grand Ave.' where num=1956");
0:             System.out.println("Updated 1956 Webster to 180 Grand");
0: 
0:             s.execute(
0:                 "update derbyDB set num=300, addr='Lakeshore Ave.' where num=180");
0:             System.out.println("Updated 180 Grand to 300 Lakeshore");
0: 
0:             /*
0:                We select the rows and verify the results.
0:              */
0:             ResultSet rs = s.executeQuery(
0:                     "SELECT num, addr FROM derbyDB ORDER BY num");
0: 
0:             if (!rs.next())
0:             {
0:                 throw new Exception("Wrong number of rows");
0:             }
0: 
0:             if (rs.getInt(1) != 300)
0:             {
0:                 throw new Exception("Wrong row returned");
0:             }
0: 
0:             if (!rs.next())
0:             {
0:                 throw new Exception("Wrong number of rows");
0:             }
0: 
0:             if (rs.getInt(1) != 1910)
0:             {
0:                 throw new Exception("Wrong row returned");
0:             }
0: 
0:             if (rs.next())
0:             {
0:                 throw new Exception("Wrong number of rows");
0:             }
0: 
0:             System.out.println("Verified the rows");
0: 
0:             s.execute("drop table derbyDB");
0:             System.out.println("Dropped table derbyDB");
0: 
0:             /*
0:                We release the result and statement resources.
0:              */
0:             rs.close();
0:             s.close();
0:             System.out.println("Closed result set and statement");
0: 
0:             /*
0:                We end the transaction and the connection.
0:              */
0:             conn.commit();
0:             conn.close();
0:             System.out.println("Committed transaction and closed connection");
0: 
0:             /*
0:                In embedded mode, an application should shut down Derby.
0:                If the application fails to shut down Derby explicitly,
0:                the Derby does not perform a checkpoint when the JVM shuts down, which means
0:                that the next connection will be slower.
0:                Explicitly shutting down Derby with the URL is preferred.
0:                This style of shutdown will always throw an "exception".
0:              */
0:             boolean gotSQLExc = false;
0: 
0:             if (framework.equals("embedded"))
0:             {
0:                 try
0:                 {
0:                     DriverManager.getConnection("jdbc:derby:;shutdown=true");
0:                 }
0:                 catch (SQLException se)
0:                 {
0:                     gotSQLExc = true;
0:                 }
0: 
0:                 if (!gotSQLExc)
0:                 {
0:                     System.out.println("Database did not shut down normally");
0:                 }
0:                 else
0:                 {
0:                     System.out.println("Database shut down normally");
0:                 }
0:             }
0:         }
0:         catch (Throwable e)
0:         {
0:             System.out.println("exception thrown:");
0: 
0:             if (e instanceof SQLException)
0:             {
0:                 printSQLError((SQLException) e);
0:             }
0:             else
0:             {
0:                 e.printStackTrace();
0:             }
0:         }
0: 
0:         System.out.println("SimpleApp finished");
0:     }
0: 
0:     static void printSQLError(SQLException e)
0:     {
0:         while (e != null)
0:         {
0:             System.out.println(e.toString());
0:             e = e.getNextException();
0:         }
0:     }
0: 
0:     private void parseArguments(String[] args)
0:     {
0:         int length = args.length;
0: 
0:         for (int index = 0; index < length; index++)
0:         {
0:             if (args[index].equalsIgnoreCase("jccjdbcclient"))
0:             {
0:                 framework = "jccjdbc";
0:                 driver = "com.ibm.db2.jcc.DB2Driver";
0:                 protocol = "jdbc:derby:net://localhost:1527/";
0:             }
0:         }
0:     }
0: }
============================================================================