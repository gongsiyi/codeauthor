1:a8b6921: /*
1:a8b6921:  * $Header: /cvshome/build/org.osgi.framework/src/org/osgi/framework/Bundle.java,v 1.54 2007/02/21 16:49:05 hargrave Exp $
1:a8b6921:  * 
1:a8b6921:  * Copyright (c) OSGi Alliance (2000, 2007). All Rights Reserved.
1:a8b6921:  * 
1:a8b6921:  * Licensed under the Apache License, Version 2.0 (the "License");
1:a8b6921:  * you may not use this file except in compliance with the License.
1:a8b6921:  * You may obtain a copy of the License at
1:a8b6921:  *
1:a8b6921:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a8b6921:  *
1:a8b6921:  * Unless required by applicable law or agreed to in writing, software
1:a8b6921:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a8b6921:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a8b6921:  * See the License for the specific language governing permissions and
1:a8b6921:  * limitations under the License.
1:a8b6921:  */
1:a8b6921: 
1:a8b6921: package org.osgi.framework;
1:a8b6921: 
1:a8b6921: import java.io.IOException;
1:a8b6921: import java.io.InputStream;
1:a8b6921: import java.net.URL;
1:a8b6921: import java.util.Dictionary;
1:a8b6921: import java.util.Enumeration;
1:a8b6921: 
1:a8b6921: /**
1:a8b6921:  * An installed bundle in the Framework.
1:a8b6921:  * 
1:a8b6921:  * <p>
1:a8b6921:  * A <code>Bundle</code> object is the access point to define the lifecycle of
1:a8b6921:  * an installed bundle. Each bundle installed in the OSGi environment must have
1:a8b6921:  * an associated <code>Bundle</code> object.
1:a8b6921:  * 
1:a8b6921:  * <p>
1:a8b6921:  * A bundle must have a unique identity, a <code>long</code>, chosen by the
1:a8b6921:  * Framework. This identity must not change during the lifecycle of a bundle,
1:a8b6921:  * even when the bundle is updated. Uninstalling and then reinstalling the
1:a8b6921:  * bundle must create a new unique identity.
1:a8b6921:  * 
1:a8b6921:  * <p>
1:a8b6921:  * A bundle can be in one of six states:
1:a8b6921:  * <ul>
1:a8b6921:  * <li>{@link #UNINSTALLED}
1:a8b6921:  * <li>{@link #INSTALLED}
1:a8b6921:  * <li>{@link #RESOLVED}
1:a8b6921:  * <li>{@link #STARTING}
1:a8b6921:  * <li>{@link #STOPPING}
1:a8b6921:  * <li>{@link #ACTIVE}
1:a8b6921:  * </ul>
1:a8b6921:  * <p>
1:a8b6921:  * Values assigned to these states have no specified ordering; they represent
1:a8b6921:  * bit values that may be ORed together to determine if a bundle is in one of
1:a8b6921:  * the valid states.
1:a8b6921:  * 
1:a8b6921:  * <p>
1:a8b6921:  * A bundle should only execute code when its state is one of
1:a8b6921:  * <code>STARTING</code>,<code>ACTIVE</code>, or <code>STOPPING</code>.
1:a8b6921:  * An <code>UNINSTALLED</code> bundle can not be set to another state; it is a
1:a8b6921:  * zombie and can only be reached because references are kept somewhere.
1:a8b6921:  * 
1:a8b6921:  * <p>
1:a8b6921:  * The Framework is the only entity that is allowed to create
1:a8b6921:  * <code>Bundle</code> objects, and these objects are only valid within the
1:a8b6921:  * Framework that created them.
1:a8b6921:  * 
1:a8b6921:  * @ThreadSafe
1:a8b6921:  * @version $Revision: 1.54 $
1:a8b6921:  */
1:a8b6921: public interface Bundle {
1:a8b6921: 	/**
1:a8b6921: 	 * The bundle is uninstalled and may not be used.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The <code>UNINSTALLED</code> state is only visible after a bundle is
1:a8b6921: 	 * uninstalled; the bundle is in an unusable state but references to the
1:a8b6921: 	 * <code>Bundle</code> object may still be available and used for
1:a8b6921: 	 * introspection.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The value of <code>UNINSTALLED</code> is 0x00000001.
1:a8b6921: 	 */
1:a8b6921: 	public static final int	UNINSTALLED				= 0x00000001;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * The bundle is installed but not yet resolved.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * A bundle is in the <code>INSTALLED</code> state when it has been
1:a8b6921: 	 * installed in the Framework but is not or cannot be resolved.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This state is visible if the bundle's code dependencies are not resolved.
1:a8b6921: 	 * The Framework may attempt to resolve an <code>INSTALLED</code> bundle's
1:a8b6921: 	 * code dependencies and move the bundle to the <code>RESOLVED</code>
1:a8b6921: 	 * state.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The value of <code>INSTALLED</code> is 0x00000002.
1:a8b6921: 	 */
1:a8b6921: 	public static final int	INSTALLED				= 0x00000002;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * The bundle is resolved and is able to be started.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * A bundle is in the <code>RESOLVED</code> state when the Framework has
1:a8b6921: 	 * successfully resolved the bundle's code dependencies. These dependencies
1:a8b6921: 	 * include:
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li>The bundle's class path from its {@link Constants#BUNDLE_CLASSPATH}
1:a8b6921: 	 * Manifest header.
1:a8b6921: 	 * <li>The bundle's package dependencies from its
1:a8b6921: 	 * {@link Constants#EXPORT_PACKAGE} and {@link Constants#IMPORT_PACKAGE}
1:a8b6921: 	 * Manifest headers.
1:a8b6921: 	 * <li>The bundle's required bundle dependencies from its
1:a8b6921: 	 * {@link Constants#REQUIRE_BUNDLE} Manifest header.
1:a8b6921: 	 * <li>A fragment bundle's host dependency from its
1:a8b6921: 	 * {@link Constants#FRAGMENT_HOST} Manifest header.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <p>
1:a8b6921: 	 * Note that the bundle is not active yet. A bundle must be put in the
1:a8b6921: 	 * <code>RESOLVED</code> state before it can be started. The Framework may
1:a8b6921: 	 * attempt to resolve a bundle at any time.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The value of <code>RESOLVED</code> is 0x00000004.
1:a8b6921: 	 */
1:a8b6921: 	public static final int	RESOLVED				= 0x00000004;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * The bundle is in the process of starting.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * A bundle is in the <code>STARTING</code> state when its
1:a8b6921: 	 * {@link #start(int) start} method is active. A bundle must be in this
1:a8b6921: 	 * state when the bundle's {@link BundleActivator#start} is called. If the
1:a8b6921: 	 * <code>BundleActivator.start</code> method completes without exception,
1:a8b6921: 	 * then the bundle has successfully started and must move to the
1:a8b6921: 	 * <code>ACTIVE</code> state.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If the bundle has a
1:a8b6921: 	 * {@link Constants#ACTIVATION_LAZY lazy activation policy}, then the
1:a8b6921: 	 * bundle may remain in this state for some time until the activation is
1:a8b6921: 	 * triggered.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The value of <code>STARTING</code> is 0x00000008.
1:a8b6921: 	 */
1:a8b6921: 	public static final int	STARTING				= 0x00000008;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * The bundle is in the process of stopping.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * A bundle is in the <code>STOPPING</code> state when its
1:a8b6921: 	 * {@link #stop(int) stop} method is active. A bundle must be in this state
1:a8b6921: 	 * when the bundle's {@link BundleActivator#stop} method is called. When the
1:a8b6921: 	 * <code>BundleActivator.stop</code> method completes the bundle is
1:a8b6921: 	 * stopped and must move to the <code>RESOLVED</code> state.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The value of <code>STOPPING</code> is 0x00000010.
1:a8b6921: 	 */
1:a8b6921: 	public static final int	STOPPING				= 0x00000010;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * The bundle is now running.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * A bundle is in the <code>ACTIVE</code> state when it has been
1:a8b6921: 	 * successfully started and activated.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The value of <code>ACTIVE</code> is 0x00000020.
1:a8b6921: 	 */
1:a8b6921: 	public static final int	ACTIVE					= 0x00000020;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * The bundle start operation is transient and the persistent autostart
1:a8b6921: 	 * setting of the bundle is not modified.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This bit may be set when calling {@link #start(int)} to notify the
1:a8b6921: 	 * framework that the autostart setting of the bundle must not be modified.
1:a8b6921: 	 * If this bit is not set, then the autostart setting of the bundle is
1:a8b6921: 	 * modified.
1:a8b6921: 	 * 
1:a8b6921: 	 * @since 1.4
1:a8b6921: 	 * @see #start(int)
1:a8b6921: 	 */
1:a8b6921: 	public static final int	START_TRANSIENT			= 0x00000001;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * The bundle start operation must activate the bundle according to the
1:a8b6921: 	 * bundle's declared
1:a8b6921: 	 * {@link Constants#BUNDLE_ACTIVATIONPOLICY activation policy}.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This bit may be set when calling {@link #start(int)} to notify the
1:a8b6921: 	 * framework that the bundle must be activated using the bundle's declared
1:a8b6921: 	 * activation policy.
1:a8b6921: 	 * 
1:a8b6921: 	 * @since 1.4
1:a8b6921: 	 * @see Constants#BUNDLE_ACTIVATIONPOLICY
1:a8b6921: 	 * @see #start(int)
1:a8b6921: 	 */
1:a8b6921: 	public static final int	START_ACTIVATION_POLICY	= 0x00000002;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * The bundle stop is transient and the persistent autostart setting of the
1:a8b6921: 	 * bundle is not modified.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This bit may be set when calling {@link #stop(int)} to notify the
1:a8b6921: 	 * framework that the autostart setting of the bundle must not be modified.
1:a8b6921: 	 * If this bit is not set, then the autostart setting of the bundle is
1:a8b6921: 	 * modified.
1:a8b6921: 	 * 
1:a8b6921: 	 * @since 1.4
1:a8b6921: 	 * @see #stop(int)
1:a8b6921: 	 */
1:a8b6921: 	public static final int	STOP_TRANSIENT			= 0x00000001;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns this bundle's current state.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * A bundle can be in only one state at any time.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return An element of <code>UNINSTALLED</code>,<code>INSTALLED</code>,
1:a8b6921: 	 *         <code>RESOLVED</code>,<code>STARTING</code>,
1:a8b6921: 	 *         <code>STOPPING</code>,<code>ACTIVE</code>.
1:a8b6921: 	 */
1:a8b6921: 	public int getState();
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Starts this bundle.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If this bundle's state is <code>UNINSTALLED</code> then an
1:a8b6921: 	 * <code>IllegalStateException</code> is thrown.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If the Framework implements the optional Start Level service and the
1:a8b6921: 	 * current start level is less than this bundle's start level:
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li>If the {@link #START_TRANSIENT} option is set, then a
1:a8b6921: 	 * <code>BundleException</code> is thrown indicating this bundle cannot be
1:a8b6921: 	 * started due to the Framework's current start level.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>Otherwise, the Framework must set this bundle's persistent autostart
1:a8b6921: 	 * setting to <em>Started with declared activation</em> if the
1:a8b6921: 	 * {@link #START_ACTIVATION_POLICY} option is set or
1:a8b6921: 	 * <em>Started with eager activation</em> if not set.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <p>
1:a8b6921: 	 * When the Framework's current start level becomes equal to or more than
1:a8b6921: 	 * this bundle's start level, this bundle will be started.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * Otherwise, the following steps are required to start this bundle:
1:a8b6921: 	 * <ol>
1:a8b6921: 	 * <li>If this bundle is in the process of being activated or deactivated
1:a8b6921: 	 * then this method must wait for activation or deactivation to complete
1:a8b6921: 	 * before continuing. If this does not occur in a reasonable time, a
1:a8b6921: 	 * <code>BundleException</code> is thrown to indicate this bundle was
1:a8b6921: 	 * unable to be started.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If this bundle's state is <code>ACTIVE</code> then this method
1:a8b6921: 	 * returns immediately.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If the {@link #START_TRANSIENT} option is not set then set this
1:a8b6921: 	 * bundle's autostart setting to <em>Started with declared activation</em>
1:a8b6921: 	 * if the {@link #START_ACTIVATION_POLICY} option is set or
1:a8b6921: 	 * <em>Started with eager activation</em> if not set. When the Framework
1:a8b6921: 	 * is restarted and this bundle's autostart setting is not <em>Stopped</em>,
1:a8b6921: 	 * this bundle must be automatically started.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If this bundle's state is not <code>RESOLVED</code>, an attempt
1:a8b6921: 	 * is made to resolve this bundle. If the Framework cannot resolve this
1:a8b6921: 	 * bundle, a <code>BundleException</code> is thrown.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If the {@link #START_ACTIVATION_POLICY} option is set and this
1:a8b6921: 	 * bundle's declared activation policy is
1:a8b6921: 	 * {@link Constants#ACTIVATION_LAZY lazy} then:
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li>If this bundle's state is <code>STARTING</code> then this method
1:a8b6921: 	 * returns immediately.
1:a8b6921: 	 * <li>This bundle's state is set to <code>STARTING</code>.
1:a8b6921: 	 * <li>A bundle event of type {@link BundleEvent#LAZY_ACTIVATION} is fired.
1:a8b6921: 	 * <li>This method returns immediately and the remaining steps will be
1:a8b6921: 	 * followed when this bundle's activation is later triggered.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <i></i>
1:a8b6921: 	 * <li>This bundle's state is set to <code>STARTING</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>A bundle event of type {@link BundleEvent#STARTING} is fired.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>The {@link BundleActivator#start} method of this bundle's
1:a8b6921: 	 * <code>BundleActivator</code>, if one is specified, is called. If the
1:a8b6921: 	 * <code>BundleActivator</code> is invalid or throws an exception then:
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li>This bundle's state is set to <code>STOPPING</code>.
1:a8b6921: 	 * <li>A bundle event of type {@link BundleEvent#STOPPING} is fired.
1:a8b6921: 	 * <li>Any services registered by this bundle must be unregistered.
1:a8b6921: 	 * <li>Any services used by this bundle must be released.
1:a8b6921: 	 * <li>Any listeners registered by this bundle must be removed.
1:a8b6921: 	 * <li>This bundle's state is set to <code>RESOLVED</code>.
1:a8b6921: 	 * <li>A bundle event of type {@link BundleEvent#STOPPED} is fired.
1:a8b6921: 	 * <li>A <code>BundleException</code> is then thrown.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <i></i>
1:a8b6921: 	 * <li>If this bundle's state is <code>UNINSTALLED</code>, because this
1:a8b6921: 	 * bundle was uninstalled while the <code>BundleActivator.start</code>
1:a8b6921: 	 * method was running, a <code>BundleException</code> is thrown.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>This bundle's state is set to <code>ACTIVE</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>A bundle event of type {@link BundleEvent#STARTED} is fired.
1:a8b6921: 	 * </ol>
1:a8b6921: 	 * 
1:a8b6921: 	 * <b>Preconditions </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li><code>getState()</code> in {<code>INSTALLED</code>,
1:a8b6921: 	 * <code>RESOLVED</code>} or {<code>INSTALLED</code>,
1:a8b6921: 	 * <code>RESOLVED</code>, <code>STARTING</code>} if this bundle has a
1:a8b6921: 	 * lazy activation policy.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <b>Postconditions, no exceptions thrown </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li>Bundle autostart setting is modified unless the
1:a8b6921: 	 * {@link #START_TRANSIENT} option was set.
1:a8b6921: 	 * <li><code>getState()</code> in {<code>ACTIVE</code>} unless the
1:a8b6921: 	 * lazy activation policy was used.
1:a8b6921: 	 * <li><code>BundleActivator.start()</code> has been called and did not
1:a8b6921: 	 * throw an exception unless the lazy activation policy was used.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <b>Postconditions, when an exception is thrown </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li>Depending on when the exception occurred, bundle autostart setting
1:a8b6921: 	 * is modified unless the {@link #START_TRANSIENT} option was set.
1:a8b6921: 	 * <li><code>getState()</code> not in {<code>STARTING</code>,
1:a8b6921: 	 * <code>ACTIVE</code>}.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * 
1:a8b6921: 	 * @param options The options for starting this bundle. See
1:a8b6921: 	 *        {@link #START_TRANSIENT} and {@link #START_ACTIVATION_POLICY}.
1:a8b6921: 	 *        The Framework must ignore unrecognized options.
1:a8b6921: 	 * @throws BundleException If this bundle could not be started. This could
1:a8b6921: 	 *         be because a code dependency could not be resolved or the
1:a8b6921: 	 *         specified <code>BundleActivator</code> could not be loaded or
1:a8b6921: 	 *         threw an exception or this bundle is a fragment.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled or this bundle tries to change its own state.
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,EXECUTE]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 * @since 1.4
1:a8b6921: 	 */
1:a8b6921: 	public void start(int options) throws BundleException;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Starts this bundle with no options.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method calls <code>start(0)</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * @throws BundleException If this bundle could not be started. This could
1:a8b6921: 	 *         be because a code dependency could not be resolved or the
1:a8b6921: 	 *         specified <code>BundleActivator</code> could not be loaded or
1:a8b6921: 	 *         threw an exception or this bundle is a fragment.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled or this bundle tries to change its own state.
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,EXECUTE]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 * @see #start(int)
1:a8b6921: 	 */
1:a8b6921: 	public void start() throws BundleException;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Stops this bundle.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The following steps are required to stop a bundle:
1:a8b6921: 	 * <ol>
1:a8b6921: 	 * <li>If this bundle's state is <code>UNINSTALLED</code> then an
1:a8b6921: 	 * <code>IllegalStateException</code> is thrown.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If this bundle is in the process of being activated or deactivated
1:a8b6921: 	 * then this method must wait for activation or deactivation to complete
1:a8b6921: 	 * before continuing. If this does not occur in a reasonable time, a
1:a8b6921: 	 * <code>BundleException</code> is thrown to indicate this bundle was
1:a8b6921: 	 * unable to be stopped.
1:a8b6921: 	 * <li>If the {@link #STOP_TRANSIENT} option is not set then then set this
1:a8b6921: 	 * bundle's persistent autostart setting to to <em>Stopped</em>. When the
1:a8b6921: 	 * Framework is restarted and this bundle's autostart setting is
1:a8b6921: 	 * <em>Stopped</em>, this bundle must not be automatically started.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If this bundle's state is not <code>ACTIVE</code> then this method
1:a8b6921: 	 * returns immediately.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>This bundle's state is set to <code>STOPPING</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>A bundle event of type {@link BundleEvent#STOPPING} is fired.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>The {@link BundleActivator#stop} method of this bundle's
1:a8b6921: 	 * <code>BundleActivator</code>, if one is specified, is called. If that
1:a8b6921: 	 * method throws an exception, this method must continue to stop this
1:a8b6921: 	 * bundle. A <code>BundleException</code> must be thrown after completion
1:a8b6921: 	 * of the remaining steps.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>Any services registered by this bundle must be unregistered.
1:a8b6921: 	 * <li>Any services used by this bundle must be released.
1:a8b6921: 	 * <li>Any listeners registered by this bundle must be removed.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If this bundle's state is <code>UNINSTALLED</code>, because this
1:a8b6921: 	 * bundle was uninstalled while the <code>BundleActivator.stop</code>
1:a8b6921: 	 * method was running, a <code>BundleException</code> must be thrown.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>This bundle's state is set to <code>RESOLVED</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>A bundle event of type {@link BundleEvent#STOPPED} is fired.
1:a8b6921: 	 * </ol>
1:a8b6921: 	 * 
1:a8b6921: 	 * <b>Preconditions </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li><code>getState()</code> in {<code>ACTIVE</code>}.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <b>Postconditions, no exceptions thrown </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li>Bundle autostart setting is modified unless the
1:a8b6921: 	 * {@link #STOP_TRANSIENT} option was set.
1:a8b6921: 	 * <li><code>getState()</code> not in {<code>ACTIVE</code>,
1:a8b6921: 	 * <code>STOPPING</code>}.
1:a8b6921: 	 * <li><code>BundleActivator.stop</code> has been called and did not
1:a8b6921: 	 * throw an exception.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <b>Postconditions, when an exception is thrown </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li>Bundle autostart setting is modified unless the
1:a8b6921: 	 * {@link #STOP_TRANSIENT} option was set.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * 
1:a8b6921: 	 * @param options The options for stoping this bundle. See
1:a8b6921: 	 *        {@link #STOP_TRANSIENT}. The Framework must ignore unrecognized
1:a8b6921: 	 *        options.
1:a8b6921: 	 * @throws BundleException If this bundle's <code>BundleActivator</code>
1:a8b6921: 	 *         threw an exception or this bundle is a fragment.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled or this bundle tries to change its own state.
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,EXECUTE]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 * @since 1.4
1:a8b6921: 	 */
1:a8b6921: 	public void stop(int options) throws BundleException;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Stops this bundle with no options.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method calls <code>stop(0)</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * @throws BundleException If this bundle's <code>BundleActivator</code>
1:a8b6921: 	 *         threw an exception or this bundle is a fragment.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled or this bundle tries to change its own state.
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,EXECUTE]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 * @see #start(int)
1:a8b6921: 	 */
1:a8b6921: 	public void stop() throws BundleException;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Updates this bundle.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If this bundle's state is <code>ACTIVE</code>, it must be stopped
1:a8b6921: 	 * before the update and started after the update successfully completes.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If this bundle has exported any packages, these packages must not be
1:a8b6921: 	 * updated. Instead, the previous package version must remain exported until
1:a8b6921: 	 * the <code>PackageAdmin.refreshPackages</code> method has been has been
1:a8b6921: 	 * called or the Framework is relaunched.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The following steps are required to update a bundle:
1:a8b6921: 	 * <ol>
1:a8b6921: 	 * <li>If this bundle's state is <code>UNINSTALLED</code> then an
1:a8b6921: 	 * <code>IllegalStateException</code> is thrown.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If this bundle's state is <code>ACTIVE</code>,
1:a8b6921: 	 * <code>STARTING</code> or <code>STOPPING</code>, this bundle is
1:a8b6921: 	 * stopped as described in the <code>Bundle.stop</code> method. If
1:a8b6921: 	 * <code>Bundle.stop</code> throws an exception, the exception is rethrown
1:a8b6921: 	 * terminating the update.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>The download location of the new version of this bundle is
1:a8b6921: 	 * determined from either this bundle's
1:a8b6921: 	 * {@link Constants#BUNDLE_UPDATELOCATION} Manifest header (if available) or
1:a8b6921: 	 * this bundle's original location.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>The location is interpreted in an implementation dependent manner,
1:a8b6921: 	 * typically as a URL, and the new version of this bundle is obtained from
1:a8b6921: 	 * this location.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>The new version of this bundle is installed. If the Framework is
1:a8b6921: 	 * unable to install the new version of this bundle, the original version of
1:a8b6921: 	 * this bundle must be restored and a <code>BundleException</code> must be
1:a8b6921: 	 * thrown after completion of the remaining steps.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If this bundle has declared an Bundle-RequiredExecutionEnvironment
1:a8b6921: 	 * header, then the listed execution environments must be verified against
1:a8b6921: 	 * the installed execution environments. If they do not all match, the
1:a8b6921: 	 * original version of this bundle must be restored and a
1:a8b6921: 	 * <code>BundleException</code> must be thrown after completion of the
1:a8b6921: 	 * remaining steps.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>This bundle's state is set to <code>INSTALLED</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If the new version of this bundle was successfully installed, a
1:a8b6921: 	 * bundle event of type {@link BundleEvent#UPDATED} is fired.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If this bundle's state was originally <code>ACTIVE</code>, the
1:a8b6921: 	 * updated bundle is started as described in the <code>Bundle.start</code>
1:a8b6921: 	 * method. If <code>Bundle.start</code> throws an exception, a Framework
1:a8b6921: 	 * event of type {@link FrameworkEvent#ERROR} is fired containing the
1:a8b6921: 	 * exception.
1:a8b6921: 	 * </ol>
1:a8b6921: 	 * 
1:a8b6921: 	 * <b>Preconditions </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li><code>getState()</code> not in {<code>UNINSTALLED</code>}.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <b>Postconditions, no exceptions thrown </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li><code>getState()</code> in {<code>INSTALLED</code>,
1:a8b6921: 	 * <code>RESOLVED</code>,<code>ACTIVE</code>}.
1:a8b6921: 	 * <li>This bundle has been updated.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <b>Postconditions, when an exception is thrown </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li><code>getState()</code> in {<code>INSTALLED</code>,
1:a8b6921: 	 * <code>RESOLVED</code>,<code>ACTIVE</code>}.
1:a8b6921: 	 * <li>Original bundle is still used; no update occurred.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * 
1:a8b6921: 	 * @throws BundleException If the update fails.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled or this bundle tries to change its own state.
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,LIFECYCLE]</code> for
1:a8b6921: 	 *         both the current bundle and the updated bundle, and the Java
1:a8b6921: 	 *         Runtime Environment supports permissions.
1:a8b6921: 	 * @see #stop()
1:a8b6921: 	 * @see #start()
1:a8b6921: 	 */
1:a8b6921: 	public void update() throws BundleException;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Updates this bundle from an <code>InputStream</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method performs all the steps listed in <code>Bundle.update()</code>,
1:a8b6921: 	 * except the new version of this bundle must be read from the supplied
1:a8b6921: 	 * <code>InputStream</code>, rather than a <code>URL</code>.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method must always close the <code>InputStream</code> when it is
1:a8b6921: 	 * done, even if an exception is thrown.
1:a8b6921: 	 * 
1:a8b6921: 	 * @param in The <code>InputStream</code> from which to read the new
1:a8b6921: 	 *        bundle.
1:a8b6921: 	 * @throws BundleException If the provided stream cannot be read or the
1:a8b6921: 	 *         update fails.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled or this bundle tries to change its own state.
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,LIFECYCLE]</code> for
1:a8b6921: 	 *         both the current bundle and the updated bundle, and the Java
1:a8b6921: 	 *         Runtime Environment supports permissions.
1:a8b6921: 	 * @see #update()
1:a8b6921: 	 */
1:a8b6921: 	public void update(InputStream in) throws BundleException;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Uninstalls this bundle.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method causes the Framework to notify other bundles that this bundle
1:a8b6921: 	 * is being uninstalled, and then puts this bundle into the
1:a8b6921: 	 * <code>UNINSTALLED</code> state. The Framework must remove any resources
1:a8b6921: 	 * related to this bundle that it is able to remove.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If this bundle has exported any packages, the Framework must continue to
1:a8b6921: 	 * make these packages available to their importing bundles until the
1:a8b6921: 	 * <code>PackageAdmin.refreshPackages</code> method has been called or the
1:a8b6921: 	 * Framework is relaunched.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The following steps are required to uninstall a bundle:
1:a8b6921: 	 * <ol>
1:a8b6921: 	 * <li>If this bundle's state is <code>UNINSTALLED</code> then an
1:a8b6921: 	 * <code>IllegalStateException</code> is thrown.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>If this bundle's state is <code>ACTIVE</code>,
1:a8b6921: 	 * <code>STARTING</code> or <code>STOPPING</code>, this bundle is
1:a8b6921: 	 * stopped as described in the <code>Bundle.stop</code> method. If
1:a8b6921: 	 * <code>Bundle.stop</code> throws an exception, a Framework event of type
1:a8b6921: 	 * {@link FrameworkEvent#ERROR} is fired containing the exception.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>This bundle's state is set to <code>UNINSTALLED</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>A bundle event of type {@link BundleEvent#UNINSTALLED} is fired.
1:a8b6921: 	 * 
1:a8b6921: 	 * <li>This bundle and any persistent storage area provided for this bundle
1:a8b6921: 	 * by the Framework are removed.
1:a8b6921: 	 * </ol>
1:a8b6921: 	 * 
1:a8b6921: 	 * <b>Preconditions </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li><code>getState()</code> not in {<code>UNINSTALLED</code>}.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <b>Postconditions, no exceptions thrown </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li><code>getState()</code> in {<code>UNINSTALLED</code>}.
1:a8b6921: 	 * <li>This bundle has been uninstalled.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * <b>Postconditions, when an exception is thrown </b>
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li><code>getState()</code> not in {<code>UNINSTALLED</code>}.
1:a8b6921: 	 * <li>This Bundle has not been uninstalled.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * 
1:a8b6921: 	 * @throws BundleException If the uninstall failed. This can occur if
1:a8b6921: 	 *         another thread is attempting to change this bundle's state and
1:a8b6921: 	 *         does not complete in a timely manner.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled or this bundle tries to change its own state.
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,LIFECYCLE]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 * @see #stop()
1:a8b6921: 	 */
1:a8b6921: 	public void uninstall() throws BundleException;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns this bundle's Manifest headers and values. This method returns
1:a8b6921: 	 * all the Manifest headers and values from the main section of this
1:a8b6921: 	 * bundle's Manifest file; that is, all lines prior to the first blank line.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * Manifest header names are case-insensitive. The methods of the returned
1:a8b6921: 	 * <code>Dictionary</code> object must operate on header names in a
1:a8b6921: 	 * case-insensitive manner.
1:a8b6921: 	 * 
1:a8b6921: 	 * If a Manifest header value starts with &quot;%&quot;, it must be
1:a8b6921: 	 * localized according to the default locale.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * For example, the following Manifest headers and values are included if
1:a8b6921: 	 * they are present in the Manifest file:
1:a8b6921: 	 * 
1:a8b6921: 	 * <pre>
1:a8b6921: 	 *     Bundle-Name
1:a8b6921: 	 *     Bundle-Vendor
1:a8b6921: 	 *     Bundle-Version
1:a8b6921: 	 *     Bundle-Description
1:a8b6921: 	 *     Bundle-DocURL
1:a8b6921: 	 *     Bundle-ContactAddress
1:a8b6921: 	 * </pre>
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method must continue to return Manifest header information while
1:a8b6921: 	 * this bundle is in the <code>UNINSTALLED</code> state.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return A <code>Dictionary</code> object containing this bundle's
1:a8b6921: 	 *         Manifest headers and values.
1:a8b6921: 	 * 
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,METADATA]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 * 
1:a8b6921: 	 * @see Constants#BUNDLE_LOCALIZATION
1:a8b6921: 	 */
1:a8b6921: 	public Dictionary getHeaders();
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns this bundle's unique identifier. This bundle is assigned a unique
1:a8b6921: 	 * identifier by the Framework when it was installed in the OSGi
1:a8b6921: 	 * environment.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * A bundle's unique identifier has the following attributes:
1:a8b6921: 	 * <ul>
1:a8b6921: 	 * <li>Is unique and persistent.
1:a8b6921: 	 * <li>Is a <code>long</code>.
1:a8b6921: 	 * <li>Its value is not reused for another bundle, even after a bundle is
1:a8b6921: 	 * uninstalled.
1:a8b6921: 	 * <li>Does not change while a bundle remains installed.
1:a8b6921: 	 * <li>Does not change when a bundle is updated.
1:a8b6921: 	 * </ul>
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method must continue to return this bundle's unique identifier while
1:a8b6921: 	 * this bundle is in the <code>UNINSTALLED</code> state.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return The unique identifier of this bundle.
1:a8b6921: 	 */
1:a8b6921: 	public long getBundleId();
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns this bundle's location identifier.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The location identifier is the location passed to
1:a8b6921: 	 * <code>BundleContext.installBundle</code> when a bundle is installed.
1:a8b6921: 	 * The location identifier does not change while this bundle remains
1:a8b6921: 	 * installed, even if this bundle is updated.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method must continue to return this bundle's location identifier
1:a8b6921: 	 * while this bundle is in the <code>UNINSTALLED</code> state.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return The string representation of this bundle's location identifier.
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,METADATA]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 */
1:a8b6921: 	public String getLocation();
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns this bundle's <code>ServiceReference</code> list for all
1:a8b6921: 	 * services it has registered or <code>null</code> if this bundle has no
1:a8b6921: 	 * registered services.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If the Java runtime supports permissions, a <code>ServiceReference</code>
1:a8b6921: 	 * object to a service is included in the returned list only if the caller
1:a8b6921: 	 * has the <code>ServicePermission</code> to get the service using at
1:a8b6921: 	 * least one of the named classes the service was registered under.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The list is valid at the time of the call to this method, however, as the
1:a8b6921: 	 * Framework is a very dynamic environment, services can be modified or
1:a8b6921: 	 * unregistered at anytime.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return An array of <code>ServiceReference</code> objects or
1:a8b6921: 	 *         <code>null</code>.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled.
1:a8b6921: 	 * @see ServiceRegistration
1:a8b6921: 	 * @see ServiceReference
1:a8b6921: 	 * @see ServicePermission
1:a8b6921: 	 */
1:a8b6921: 	public ServiceReference[] getRegisteredServices();
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns this bundle's <code>ServiceReference</code> list for all
1:a8b6921: 	 * services it is using or returns <code>null</code> if this bundle is not
1:a8b6921: 	 * using any services. A bundle is considered to be using a service if its
1:a8b6921: 	 * use count for that service is greater than zero.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If the Java Runtime Environment supports permissions, a
1:a8b6921: 	 * <code>ServiceReference</code> object to a service is included in the
1:a8b6921: 	 * returned list only if the caller has the <code>ServicePermission</code>
1:a8b6921: 	 * to get the service using at least one of the named classes the service
1:a8b6921: 	 * was registered under.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The list is valid at the time of the call to this method, however, as the
1:a8b6921: 	 * Framework is a very dynamic environment, services can be modified or
1:a8b6921: 	 * unregistered at anytime.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return An array of <code>ServiceReference</code> objects or
1:a8b6921: 	 *         <code>null</code>.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled.
1:a8b6921: 	 * @see ServiceReference
1:a8b6921: 	 * @see ServicePermission
1:a8b6921: 	 */
1:a8b6921: 	public ServiceReference[] getServicesInUse();
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Determines if this bundle has the specified permissions.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If the Java Runtime Environment does not support permissions, this method
1:a8b6921: 	 * always returns <code>true</code>.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * <code>permission</code> is of type <code>Object</code> to avoid
1:a8b6921: 	 * referencing the <code>java.security.Permission</code> class directly.
1:a8b6921: 	 * This is to allow the Framework to be implemented in Java environments
1:a8b6921: 	 * which do not support permissions.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If the Java Runtime Environment does support permissions, this bundle and
1:a8b6921: 	 * all its resources including embedded JAR files, belong to the same
1:a8b6921: 	 * <code>java.security.ProtectionDomain</code>; that is, they must share
1:a8b6921: 	 * the same set of permissions.
1:a8b6921: 	 * 
1:a8b6921: 	 * @param permission The permission to verify.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return <code>true</code> if this bundle has the specified permission
1:a8b6921: 	 *         or the permissions possessed by this bundle imply the specified
1:a8b6921: 	 *         permission; <code>false</code> if this bundle does not have the
1:a8b6921: 	 *         specified permission or <code>permission</code> is not an
1:a8b6921: 	 *         <code>instanceof</code> <code>java.security.Permission</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled.
1:a8b6921: 	 */
1:a8b6921: 	public boolean hasPermission(Object permission);
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Find the specified resource from this bundle.
1:a8b6921: 	 * 
1:a8b6921: 	 * This bundle's class loader is called to search for the specified
1:a8b6921: 	 * resource. If this bundle's state is <code>INSTALLED</code>, this
1:a8b6921: 	 * method must attempt to resolve this bundle before attempting to get the
1:a8b6921: 	 * specified resource. If this bundle cannot be resolved, then only this
1:a8b6921: 	 * bundle must be searched for the specified resource. Imported packages
1:a8b6921: 	 * cannot be searched when this bundle has not been resolved. If this bundle
1:a8b6921: 	 * is a fragment bundle then <code>null</code> is returned.
1:a8b6921: 	 * 
1:a8b6921: 	 * @param name The name of the resource. See
1:a8b6921: 	 *        <code>java.lang.ClassLoader.getResource</code> for a description
1:a8b6921: 	 *        of the format of a resource name.
1:a8b6921: 	 * @return A URL to the named resource, or <code>null</code> if the
1:a8b6921: 	 *         resource could not be found or if this bundle is a fragment
1:a8b6921: 	 *         bundle or if the caller does not have the appropriate
1:a8b6921: 	 *         <code>AdminPermission[this,RESOURCE]</code>, and the Java
1:a8b6921: 	 *         Runtime Environment supports permissions.
1:a8b6921: 	 * 
1:a8b6921: 	 * @since 1.1
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled.
1:a8b6921: 	 * @see #getEntry
1:a8b6921: 	 * @see #findEntries
1:a8b6921: 	 */
1:a8b6921: 	public URL getResource(String name);
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns this bundle's Manifest headers and values localized to the
1:a8b6921: 	 * specified locale.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method performs the same function as
1:a8b6921: 	 * <code>Bundle.getHeaders()</code> except the manifest header values are
1:a8b6921: 	 * localized to the specified locale.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If a Manifest header value starts with &quot;%&quot;, it must be
1:a8b6921: 	 * localized according to the specified locale. If a locale is specified and
1:a8b6921: 	 * cannot be found, then the header values must be returned using the
1:a8b6921: 	 * default locale. Localizations are searched for in the following order:
1:a8b6921: 	 * 
1:a8b6921: 	 * <pre>
1:a8b6921: 	 *   bn + "_" + Ls + "_" + Cs + "_" + Vs
1:a8b6921:      *   bn + "_" + Ls + "_" + Cs
1:a8b6921:      *   bn + "_" + Ls
1:a8b6921:      *   bn + "_" + Ld + "_" + Cd + "_" + Vd
1:a8b6921:      *   bn + "_" + Ld + "_" + Cd
1:a8b6921:      *   bn + "_" + Ld
1:a8b6921: 	 *     bn
1:a8b6921: 	 * </pre>
1:a8b6921: 	 * 
1:a8b6921: 	 * Where <code>bn</code> is this bundle's localization basename,
1:a8b6921: 	 * <code>Ls</code>, <code>Cs</code> and <code>Vs</code> are the
1:a8b6921: 	 * specified locale (language, country, variant) and <code>Ld</code>,
1:a8b6921: 	 * <code>Cd</code> and <code>Vd</code> are the default locale (language,
1:a8b6921: 	 * country, variant).
1:a8b6921: 	 * 
1:a8b6921: 	 * If <code>null</code> is specified as the locale string, the header
1:a8b6921: 	 * values must be localized using the default locale. If the empty string
1:a8b6921: 	 * (&quot;&quot;) is specified as the locale string, the header values must
1:a8b6921: 	 * not be localized and the raw (unlocalized) header values, including any
1:a8b6921: 	 * leading &quot;%&quot;, must be returned.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method must continue to return Manifest header information while
1:a8b6921: 	 * this bundle is in the <code>UNINSTALLED</code> state, however the
1:a8b6921: 	 * header values must only be available in the raw and default locale
1:a8b6921: 	 * values.
1:a8b6921: 	 * 
1:a8b6921: 	 * @param locale The locale name into which the header values are to be
1:a8b6921: 	 *        localized. If the specified locale is <code>null</code> then the
1:a8b6921: 	 *        locale returned by <code>java.util.Locale.getDefault</code> is
1:a8b6921: 	 *        used. If the specified locale is the empty string, this method
1:a8b6921: 	 *        will return the raw (unlocalized) manifest headers including any
1:a8b6921: 	 *        leading &quot;%&quot;.
1:a8b6921: 	 * @return A <code>Dictionary</code> object containing this bundle's
1:a8b6921: 	 *         Manifest headers and values.
1:a8b6921: 	 * 
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,METADATA]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 * 
1:a8b6921: 	 * @see #getHeaders()
1:a8b6921: 	 * @see Constants#BUNDLE_LOCALIZATION
1:a8b6921: 	 * @since 1.3
1:a8b6921: 	 */
1:a8b6921: 	public Dictionary getHeaders(String locale);
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns the symbolic name of this bundle as specified by its
1:a8b6921: 	 * <code>Bundle-SymbolicName</code> manifest header. The name must be
1:a8b6921: 	 * unique, it is recommended to use a reverse domain name naming convention
1:a8b6921: 	 * like that used for java packages. If this bundle does not have a
1:a8b6921: 	 * specified symbolic name then <code>null</code> is returned.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method must continue to return this bundle's symbolic name while
1:a8b6921: 	 * this bundle is in the <code>UNINSTALLED</code> state.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return The symbolic name of this bundle.
1:a8b6921: 	 * @since 1.3
1:a8b6921: 	 */
1:a8b6921: 	public String getSymbolicName();
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Loads the specified class using this bundle's classloader.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If this bundle is a fragment bundle then this method must throw a
1:a8b6921: 	 * <code>ClassNotFoundException</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If this bundle's state is <code>INSTALLED</code>, this method must
1:a8b6921: 	 * attempt to resolve this bundle before attempting to load the class.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If this bundle cannot be resolved, a Framework event of type
1:a8b6921: 	 * {@link FrameworkEvent#ERROR} is fired containing a
1:a8b6921: 	 * <code>BundleException</code> with details of the reason this bundle
1:a8b6921: 	 * could not be resolved. This method must then throw a
1:a8b6921: 	 * <code>ClassNotFoundException</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If this bundle's state is <code>UNINSTALLED</code>, then an
1:a8b6921: 	 * <code>IllegalStateException</code> is thrown.
1:a8b6921: 	 * 
1:a8b6921: 	 * @param name The name of the class to load.
1:a8b6921: 	 * @return The Class object for the requested class.
1:a8b6921: 	 * @throws java.lang.ClassNotFoundException If no such class can be found or
1:a8b6921: 	 *         if this bundle is a fragment bundle or if the caller does not
1:a8b6921: 	 *         have the appropriate <code>AdminPermission[this,CLASS]</code>,
1:a8b6921: 	 *         and the Java Runtime Environment supports permissions.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled.
1:a8b6921: 	 * @since 1.3
1:a8b6921: 	 */
1:a8b6921: 	public Class loadClass(String name) throws ClassNotFoundException;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Find the specified resources from this bundle.
1:a8b6921: 	 * 
1:a8b6921: 	 * This bundle's class loader is called to search for the specified
1:a8b6921: 	 * resources. If this bundle's state is <code>INSTALLED</code>, this
1:a8b6921: 	 * method must attempt to resolve this bundle before attempting to get the
1:a8b6921: 	 * specified resources. If this bundle cannot be resolved, then only this
1:a8b6921: 	 * bundle must be searched for the specified resources. Imported packages
1:a8b6921: 	 * cannot be searched when a bundle has not been resolved. If this bundle is
1:a8b6921: 	 * a fragment bundle then <code>null</code> is returned.
1:a8b6921: 	 * 
1:a8b6921: 	 * @param name The name of the resource. See
1:a8b6921: 	 *        <code>java.lang.ClassLoader.getResources</code> for a
1:a8b6921: 	 *        description of the format of a resource name.
1:a8b6921: 	 * @return An enumeration of URLs to the named resources, or
1:a8b6921: 	 *         <code>null</code> if the resource could not be found or if this
1:a8b6921: 	 *         bundle is a fragment bundle or if the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,RESOURCE]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 * 
1:a8b6921: 	 * @since 1.3
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled.
1:a8b6921: 	 * @throws java.io.IOException If there is an I/O error.
1:a8b6921: 	 */
1:a8b6921: 	public Enumeration getResources(String name) throws IOException;
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns an Enumeration of all the paths (<code>String</code> objects)
1:a8b6921: 	 * to entries within this bundle whose longest sub-path matches the
1:a8b6921: 	 * specified path. This bundle's classloader is not used to search for
1:a8b6921: 	 * entries. Only the contents of this bundle are searched.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The specified path is always relative to the root of this bundle and may
1:a8b6921: 	 * begin with a &quot;/&quot;. A path value of &quot;/&quot; indicates the
1:a8b6921: 	 * root of this bundle.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * Returned paths indicating subdirectory paths end with a &quot;/&quot;.
1:a8b6921: 	 * The returned paths are all relative to the root of this bundle and must
1:a8b6921: 	 * not begin with &quot;/&quot;.
1:a8b6921: 	 * 
1:a8b6921: 	 * @param path The path name for which to return entry paths.
1:a8b6921: 	 * @return An Enumeration of the entry paths (<code>String</code>
1:a8b6921: 	 *         objects) or <code>null</code> if no entry could be found or if
1:a8b6921: 	 *         the caller does not have the appropriate
1:a8b6921: 	 *         <code>AdminPermission[this,RESOURCE]</code> and the Java
1:a8b6921: 	 *         Runtime Environment supports permissions.
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled.
1:a8b6921: 	 * @since 1.3
1:a8b6921: 	 */
1:a8b6921: 	public Enumeration getEntryPaths(String path);
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns a URL to the entry at the specified path in this bundle. This
1:a8b6921: 	 * bundle's classloader is not used to search for the entry. Only the
1:a8b6921: 	 * contents of this bundle are searched for the entry.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The specified path is always relative to the root of this bundle and may
1:a8b6921: 	 * begin with &quot;/&quot;. A path value of &quot;/&quot; indicates the
1:a8b6921: 	 * root of this bundle.
1:a8b6921: 	 * 
1:a8b6921: 	 * @param path The path name of the entry.
1:a8b6921: 	 * @return A URL to the entry, or <code>null</code> if no entry could be
1:a8b6921: 	 *         found or if the caller does not have the appropriate
1:a8b6921: 	 *         <code>AdminPermission[this,RESOURCE]</code> and the Java
1:a8b6921: 	 *         Runtime Environment supports permissions.
1:a8b6921: 	 * 
1:a8b6921: 	 * @throws java.lang.IllegalStateException If this bundle has been
1:a8b6921: 	 *         uninstalled.
1:a8b6921: 	 * @since 1.3
1:a8b6921: 	 */
1:a8b6921: 	public URL getEntry(String path);
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns the time when this bundle was last modified. A bundle is
1:a8b6921: 	 * considered to be modified when it is installed, updated or uninstalled.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * The time value is the number of milliseconds since January 1, 1970,
1:a8b6921: 	 * 00:00:00 GMT.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return The time when this bundle was last modified.
1:a8b6921: 	 * @since 1.3
1:a8b6921: 	 */
1:a8b6921: 	public long getLastModified();
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns entries in this bundle and its attached fragments. This bundle's
1:a8b6921: 	 * classloader is not used to search for entries. Only the contents of this
1:a8b6921: 	 * bundle and its attached fragments are searched for the specified entries.
1:a8b6921: 	 * 
1:a8b6921: 	 * If this bundle's state is <code>INSTALLED</code>, this method must
1:a8b6921: 	 * attempt to resolve this bundle before attempting to find entries.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * This method is intended to be used to obtain configuration, setup,
1:a8b6921: 	 * localization and other information from this bundle. This method takes
1:a8b6921: 	 * into account that the &quot;contents&quot; of this bundle can be extended
1:a8b6921: 	 * with fragments. This &quot;bundle space&quot; is not a namespace with
1:a8b6921: 	 * unique members; the same entry name can be present multiple times. This
1:a8b6921: 	 * method therefore returns an enumeration of URL objects. These URLs can
1:a8b6921: 	 * come from different JARs but have the same path name. This method can
1:a8b6921: 	 * either return only entries in the specified path or recurse into
1:a8b6921: 	 * subdirectories returning entries in the directory tree beginning at the
1:a8b6921: 	 * specified path. Fragments can be attached after this bundle is resolved,
1:a8b6921: 	 * possibly changing the set of URLs returned by this method. If this bundle
1:a8b6921: 	 * is not resolved, only the entries in the JAR file of this bundle are
1:a8b6921: 	 * returned.
1:a8b6921: 	 * <p>
1:a8b6921: 	 * Examples:
1:a8b6921: 	 * 
1:a8b6921: 	 * <pre>
1:a8b6921: 	 * // List all XML files in the OSGI-INF directory and below
1:a8b6921: 	 * Enumeration e = b.findEntries(&quot;OSGI-INF&quot;, &quot;*.xml&quot;, true);
1:a8b6921: 	 * 
1:a8b6921: 	 * // Find a specific localization file
1:a8b6921: 	 * Enumeration e = b.findEntries(&quot;OSGI-INF/l10n&quot;, 
1:a8b6921: 	 *                               &quot;bundle_nl_DU.properties&quot;, 
1:a8b6921: 	 *                               false);
1:a8b6921: 	 * if (e.hasMoreElements())
1:a8b6921: 	 * 	return (URL) e.nextElement();
1:a8b6921: 	 * </pre>
1:a8b6921: 	 * 
1:a8b6921: 	 * @param path The path name in which to look. The path is always relative
1:a8b6921: 	 *        to the root of this bundle and may begin with &quot;/&quot;. A
1:a8b6921: 	 *        path value of &quot;/&quot; indicates the root of this bundle.
1:a8b6921: 	 * @param filePattern The file name pattern for selecting entries in the
1:a8b6921: 	 *        specified path. The pattern is only matched against the last
1:a8b6921: 	 *        element of the entry path and it supports substring matching, as
1:a8b6921: 	 *        specified in the Filter specification, using the wildcard
1:a8b6921: 	 *        character (&quot;*&quot;). If null is specified, this is
1:a8b6921: 	 *        equivalent to &quot;*&quot; and matches all files.
1:a8b6921: 	 * @param recurse If <code>true</code>, recurse into subdirectories.
1:a8b6921: 	 *        Otherwise only return entries from the specified path.
1:a8b6921: 	 * @return An enumeration of URL objects for each matching entry, or
1:a8b6921: 	 *         <code>null</code> if an entry could not be found or if the
1:a8b6921: 	 *         caller does not have the appropriate
1:a8b6921: 	 *         <code>AdminPermission[this,RESOURCE]</code>, and the Java
1:a8b6921: 	 *         Runtime Environment supports permissions. The URLs are sorted
1:a8b6921: 	 *         such that entries from this bundle are returned first followed by
1:a8b6921: 	 *         the entries from attached fragments in ascending bundle id order.
1:a8b6921: 	 *         If this bundle is a fragment, then only matching entries in this
1:a8b6921: 	 *         fragment are returned.
1:a8b6921: 	 * @since 1.3
1:a8b6921: 	 */
1:a8b6921: 	public Enumeration findEntries(String path, String filePattern,
1:a8b6921: 			boolean recurse);
1:a8b6921: 
1:a8b6921: 	/**
1:a8b6921: 	 * Returns this bundle's {@link BundleContext}. The returned
1:a8b6921: 	 * <code>BundleContext</code> can be used by the caller to act on behalf
1:a8b6921: 	 * of this bundle.
1:a8b6921: 	 * 
1:a8b6921: 	 * <p>
1:a8b6921: 	 * If this bundle is not in the {@link #STARTING}, {@link #ACTIVE}, or
1:a8b6921: 	 * {@link #STOPPING} states or this bundle is a fragment bundle, then this
1:a8b6921: 	 * bundle has no valid <code>BundleContext</code>. This method will
1:a8b6921: 	 * return <code>null</code> if this bundle has no valid
1:a8b6921: 	 * <code>BundleContext</code>.
1:a8b6921: 	 * 
1:a8b6921: 	 * @return A <code>BundleContext</code> for this bundle or
1:a8b6921: 	 *         <code>null</code> if this bundle has no valid
1:a8b6921: 	 *         <code>BundleContext</code>.
1:a8b6921: 	 * @throws java.lang.SecurityException If the caller does not have the
1:a8b6921: 	 *         appropriate <code>AdminPermission[this,CONTEXT]</code>, and
1:a8b6921: 	 *         the Java Runtime Environment supports permissions.
1:a8b6921: 	 * @since 1.4
1:a8b6921: 	 */
1:a8b6921: 	public BundleContext getBundleContext();
1:a8b6921: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a8b6921
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * $Header: /cvshome/build/org.osgi.framework/src/org/osgi/framework/Bundle.java,v 1.54 2007/02/21 16:49:05 hargrave Exp $
1:  * 
1:  * Copyright (c) OSGi Alliance (2000, 2007). All Rights Reserved.
1:  * 
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.osgi.framework;
1: 
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.net.URL;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: 
1: /**
1:  * An installed bundle in the Framework.
1:  * 
1:  * <p>
1:  * A <code>Bundle</code> object is the access point to define the lifecycle of
1:  * an installed bundle. Each bundle installed in the OSGi environment must have
1:  * an associated <code>Bundle</code> object.
1:  * 
1:  * <p>
1:  * A bundle must have a unique identity, a <code>long</code>, chosen by the
1:  * Framework. This identity must not change during the lifecycle of a bundle,
1:  * even when the bundle is updated. Uninstalling and then reinstalling the
1:  * bundle must create a new unique identity.
1:  * 
1:  * <p>
1:  * A bundle can be in one of six states:
1:  * <ul>
1:  * <li>{@link #UNINSTALLED}
1:  * <li>{@link #INSTALLED}
1:  * <li>{@link #RESOLVED}
1:  * <li>{@link #STARTING}
1:  * <li>{@link #STOPPING}
1:  * <li>{@link #ACTIVE}
1:  * </ul>
1:  * <p>
1:  * Values assigned to these states have no specified ordering; they represent
1:  * bit values that may be ORed together to determine if a bundle is in one of
1:  * the valid states.
1:  * 
1:  * <p>
1:  * A bundle should only execute code when its state is one of
1:  * <code>STARTING</code>,<code>ACTIVE</code>, or <code>STOPPING</code>.
1:  * An <code>UNINSTALLED</code> bundle can not be set to another state; it is a
1:  * zombie and can only be reached because references are kept somewhere.
1:  * 
1:  * <p>
1:  * The Framework is the only entity that is allowed to create
1:  * <code>Bundle</code> objects, and these objects are only valid within the
1:  * Framework that created them.
1:  * 
1:  * @ThreadSafe
1:  * @version $Revision: 1.54 $
1:  */
1: public interface Bundle {
1: 	/**
1: 	 * The bundle is uninstalled and may not be used.
1: 	 * 
1: 	 * <p>
1: 	 * The <code>UNINSTALLED</code> state is only visible after a bundle is
1: 	 * uninstalled; the bundle is in an unusable state but references to the
1: 	 * <code>Bundle</code> object may still be available and used for
1: 	 * introspection.
1: 	 * <p>
1: 	 * The value of <code>UNINSTALLED</code> is 0x00000001.
1: 	 */
1: 	public static final int	UNINSTALLED				= 0x00000001;
1: 
1: 	/**
1: 	 * The bundle is installed but not yet resolved.
1: 	 * 
1: 	 * <p>
1: 	 * A bundle is in the <code>INSTALLED</code> state when it has been
1: 	 * installed in the Framework but is not or cannot be resolved.
1: 	 * <p>
1: 	 * This state is visible if the bundle's code dependencies are not resolved.
1: 	 * The Framework may attempt to resolve an <code>INSTALLED</code> bundle's
1: 	 * code dependencies and move the bundle to the <code>RESOLVED</code>
1: 	 * state.
1: 	 * <p>
1: 	 * The value of <code>INSTALLED</code> is 0x00000002.
1: 	 */
1: 	public static final int	INSTALLED				= 0x00000002;
1: 
1: 	/**
1: 	 * The bundle is resolved and is able to be started.
1: 	 * 
1: 	 * <p>
1: 	 * A bundle is in the <code>RESOLVED</code> state when the Framework has
1: 	 * successfully resolved the bundle's code dependencies. These dependencies
1: 	 * include:
1: 	 * <ul>
1: 	 * <li>The bundle's class path from its {@link Constants#BUNDLE_CLASSPATH}
1: 	 * Manifest header.
1: 	 * <li>The bundle's package dependencies from its
1: 	 * {@link Constants#EXPORT_PACKAGE} and {@link Constants#IMPORT_PACKAGE}
1: 	 * Manifest headers.
1: 	 * <li>The bundle's required bundle dependencies from its
1: 	 * {@link Constants#REQUIRE_BUNDLE} Manifest header.
1: 	 * <li>A fragment bundle's host dependency from its
1: 	 * {@link Constants#FRAGMENT_HOST} Manifest header.
1: 	 * </ul>
1: 	 * <p>
1: 	 * Note that the bundle is not active yet. A bundle must be put in the
1: 	 * <code>RESOLVED</code> state before it can be started. The Framework may
1: 	 * attempt to resolve a bundle at any time.
1: 	 * <p>
1: 	 * The value of <code>RESOLVED</code> is 0x00000004.
1: 	 */
1: 	public static final int	RESOLVED				= 0x00000004;
1: 
1: 	/**
1: 	 * The bundle is in the process of starting.
1: 	 * 
1: 	 * <p>
1: 	 * A bundle is in the <code>STARTING</code> state when its
1: 	 * {@link #start(int) start} method is active. A bundle must be in this
1: 	 * state when the bundle's {@link BundleActivator#start} is called. If the
1: 	 * <code>BundleActivator.start</code> method completes without exception,
1: 	 * then the bundle has successfully started and must move to the
1: 	 * <code>ACTIVE</code> state.
1: 	 * <p>
1: 	 * If the bundle has a
1: 	 * {@link Constants#ACTIVATION_LAZY lazy activation policy}, then the
1: 	 * bundle may remain in this state for some time until the activation is
1: 	 * triggered.
1: 	 * <p>
1: 	 * The value of <code>STARTING</code> is 0x00000008.
1: 	 */
1: 	public static final int	STARTING				= 0x00000008;
1: 
1: 	/**
1: 	 * The bundle is in the process of stopping.
1: 	 * 
1: 	 * <p>
1: 	 * A bundle is in the <code>STOPPING</code> state when its
1: 	 * {@link #stop(int) stop} method is active. A bundle must be in this state
1: 	 * when the bundle's {@link BundleActivator#stop} method is called. When the
1: 	 * <code>BundleActivator.stop</code> method completes the bundle is
1: 	 * stopped and must move to the <code>RESOLVED</code> state.
1: 	 * <p>
1: 	 * The value of <code>STOPPING</code> is 0x00000010.
1: 	 */
1: 	public static final int	STOPPING				= 0x00000010;
1: 
1: 	/**
1: 	 * The bundle is now running.
1: 	 * 
1: 	 * <p>
1: 	 * A bundle is in the <code>ACTIVE</code> state when it has been
1: 	 * successfully started and activated.
1: 	 * <p>
1: 	 * The value of <code>ACTIVE</code> is 0x00000020.
1: 	 */
1: 	public static final int	ACTIVE					= 0x00000020;
1: 
1: 	/**
1: 	 * The bundle start operation is transient and the persistent autostart
1: 	 * setting of the bundle is not modified.
1: 	 * 
1: 	 * <p>
1: 	 * This bit may be set when calling {@link #start(int)} to notify the
1: 	 * framework that the autostart setting of the bundle must not be modified.
1: 	 * If this bit is not set, then the autostart setting of the bundle is
1: 	 * modified.
1: 	 * 
1: 	 * @since 1.4
1: 	 * @see #start(int)
1: 	 */
1: 	public static final int	START_TRANSIENT			= 0x00000001;
1: 
1: 	/**
1: 	 * The bundle start operation must activate the bundle according to the
1: 	 * bundle's declared
1: 	 * {@link Constants#BUNDLE_ACTIVATIONPOLICY activation policy}.
1: 	 * 
1: 	 * <p>
1: 	 * This bit may be set when calling {@link #start(int)} to notify the
1: 	 * framework that the bundle must be activated using the bundle's declared
1: 	 * activation policy.
1: 	 * 
1: 	 * @since 1.4
1: 	 * @see Constants#BUNDLE_ACTIVATIONPOLICY
1: 	 * @see #start(int)
1: 	 */
1: 	public static final int	START_ACTIVATION_POLICY	= 0x00000002;
1: 
1: 	/**
1: 	 * The bundle stop is transient and the persistent autostart setting of the
1: 	 * bundle is not modified.
1: 	 * 
1: 	 * <p>
1: 	 * This bit may be set when calling {@link #stop(int)} to notify the
1: 	 * framework that the autostart setting of the bundle must not be modified.
1: 	 * If this bit is not set, then the autostart setting of the bundle is
1: 	 * modified.
1: 	 * 
1: 	 * @since 1.4
1: 	 * @see #stop(int)
1: 	 */
1: 	public static final int	STOP_TRANSIENT			= 0x00000001;
1: 
1: 	/**
1: 	 * Returns this bundle's current state.
1: 	 * 
1: 	 * <p>
1: 	 * A bundle can be in only one state at any time.
1: 	 * 
1: 	 * @return An element of <code>UNINSTALLED</code>,<code>INSTALLED</code>,
1: 	 *         <code>RESOLVED</code>,<code>STARTING</code>,
1: 	 *         <code>STOPPING</code>,<code>ACTIVE</code>.
1: 	 */
1: 	public int getState();
1: 
1: 	/**
1: 	 * Starts this bundle.
1: 	 * 
1: 	 * <p>
1: 	 * If this bundle's state is <code>UNINSTALLED</code> then an
1: 	 * <code>IllegalStateException</code> is thrown.
1: 	 * <p>
1: 	 * If the Framework implements the optional Start Level service and the
1: 	 * current start level is less than this bundle's start level:
1: 	 * <ul>
1: 	 * <li>If the {@link #START_TRANSIENT} option is set, then a
1: 	 * <code>BundleException</code> is thrown indicating this bundle cannot be
1: 	 * started due to the Framework's current start level.
1: 	 * 
1: 	 * <li>Otherwise, the Framework must set this bundle's persistent autostart
1: 	 * setting to <em>Started with declared activation</em> if the
1: 	 * {@link #START_ACTIVATION_POLICY} option is set or
1: 	 * <em>Started with eager activation</em> if not set.
1: 	 * </ul>
1: 	 * <p>
1: 	 * When the Framework's current start level becomes equal to or more than
1: 	 * this bundle's start level, this bundle will be started.
1: 	 * <p>
1: 	 * Otherwise, the following steps are required to start this bundle:
1: 	 * <ol>
1: 	 * <li>If this bundle is in the process of being activated or deactivated
1: 	 * then this method must wait for activation or deactivation to complete
1: 	 * before continuing. If this does not occur in a reasonable time, a
1: 	 * <code>BundleException</code> is thrown to indicate this bundle was
1: 	 * unable to be started.
1: 	 * 
1: 	 * <li>If this bundle's state is <code>ACTIVE</code> then this method
1: 	 * returns immediately.
1: 	 * 
1: 	 * <li>If the {@link #START_TRANSIENT} option is not set then set this
1: 	 * bundle's autostart setting to <em>Started with declared activation</em>
1: 	 * if the {@link #START_ACTIVATION_POLICY} option is set or
1: 	 * <em>Started with eager activation</em> if not set. When the Framework
1: 	 * is restarted and this bundle's autostart setting is not <em>Stopped</em>,
1: 	 * this bundle must be automatically started.
1: 	 * 
1: 	 * <li>If this bundle's state is not <code>RESOLVED</code>, an attempt
1: 	 * is made to resolve this bundle. If the Framework cannot resolve this
1: 	 * bundle, a <code>BundleException</code> is thrown.
1: 	 * 
1: 	 * <li>If the {@link #START_ACTIVATION_POLICY} option is set and this
1: 	 * bundle's declared activation policy is
1: 	 * {@link Constants#ACTIVATION_LAZY lazy} then:
1: 	 * <ul>
1: 	 * <li>If this bundle's state is <code>STARTING</code> then this method
1: 	 * returns immediately.
1: 	 * <li>This bundle's state is set to <code>STARTING</code>.
1: 	 * <li>A bundle event of type {@link BundleEvent#LAZY_ACTIVATION} is fired.
1: 	 * <li>This method returns immediately and the remaining steps will be
1: 	 * followed when this bundle's activation is later triggered.
1: 	 * </ul>
1: 	 * <i></i>
1: 	 * <li>This bundle's state is set to <code>STARTING</code>.
1: 	 * 
1: 	 * <li>A bundle event of type {@link BundleEvent#STARTING} is fired.
1: 	 * 
1: 	 * <li>The {@link BundleActivator#start} method of this bundle's
1: 	 * <code>BundleActivator</code>, if one is specified, is called. If the
1: 	 * <code>BundleActivator</code> is invalid or throws an exception then:
1: 	 * <ul>
1: 	 * <li>This bundle's state is set to <code>STOPPING</code>.
1: 	 * <li>A bundle event of type {@link BundleEvent#STOPPING} is fired.
1: 	 * <li>Any services registered by this bundle must be unregistered.
1: 	 * <li>Any services used by this bundle must be released.
1: 	 * <li>Any listeners registered by this bundle must be removed.
1: 	 * <li>This bundle's state is set to <code>RESOLVED</code>.
1: 	 * <li>A bundle event of type {@link BundleEvent#STOPPED} is fired.
1: 	 * <li>A <code>BundleException</code> is then thrown.
1: 	 * </ul>
1: 	 * <i></i>
1: 	 * <li>If this bundle's state is <code>UNINSTALLED</code>, because this
1: 	 * bundle was uninstalled while the <code>BundleActivator.start</code>
1: 	 * method was running, a <code>BundleException</code> is thrown.
1: 	 * 
1: 	 * <li>This bundle's state is set to <code>ACTIVE</code>.
1: 	 * 
1: 	 * <li>A bundle event of type {@link BundleEvent#STARTED} is fired.
1: 	 * </ol>
1: 	 * 
1: 	 * <b>Preconditions </b>
1: 	 * <ul>
1: 	 * <li><code>getState()</code> in {<code>INSTALLED</code>,
1: 	 * <code>RESOLVED</code>} or {<code>INSTALLED</code>,
1: 	 * <code>RESOLVED</code>, <code>STARTING</code>} if this bundle has a
1: 	 * lazy activation policy.
1: 	 * </ul>
1: 	 * <b>Postconditions, no exceptions thrown </b>
1: 	 * <ul>
1: 	 * <li>Bundle autostart setting is modified unless the
1: 	 * {@link #START_TRANSIENT} option was set.
1: 	 * <li><code>getState()</code> in {<code>ACTIVE</code>} unless the
1: 	 * lazy activation policy was used.
1: 	 * <li><code>BundleActivator.start()</code> has been called and did not
1: 	 * throw an exception unless the lazy activation policy was used.
1: 	 * </ul>
1: 	 * <b>Postconditions, when an exception is thrown </b>
1: 	 * <ul>
1: 	 * <li>Depending on when the exception occurred, bundle autostart setting
1: 	 * is modified unless the {@link #START_TRANSIENT} option was set.
1: 	 * <li><code>getState()</code> not in {<code>STARTING</code>,
1: 	 * <code>ACTIVE</code>}.
1: 	 * </ul>
1: 	 * 
1: 	 * @param options The options for starting this bundle. See
1: 	 *        {@link #START_TRANSIENT} and {@link #START_ACTIVATION_POLICY}.
1: 	 *        The Framework must ignore unrecognized options.
1: 	 * @throws BundleException If this bundle could not be started. This could
1: 	 *         be because a code dependency could not be resolved or the
1: 	 *         specified <code>BundleActivator</code> could not be loaded or
1: 	 *         threw an exception or this bundle is a fragment.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled or this bundle tries to change its own state.
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,EXECUTE]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 * @since 1.4
1: 	 */
1: 	public void start(int options) throws BundleException;
1: 
1: 	/**
1: 	 * Starts this bundle with no options.
1: 	 * 
1: 	 * <p>
1: 	 * This method calls <code>start(0)</code>.
1: 	 * 
1: 	 * @throws BundleException If this bundle could not be started. This could
1: 	 *         be because a code dependency could not be resolved or the
1: 	 *         specified <code>BundleActivator</code> could not be loaded or
1: 	 *         threw an exception or this bundle is a fragment.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled or this bundle tries to change its own state.
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,EXECUTE]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 * @see #start(int)
1: 	 */
1: 	public void start() throws BundleException;
1: 
1: 	/**
1: 	 * Stops this bundle.
1: 	 * 
1: 	 * <p>
1: 	 * The following steps are required to stop a bundle:
1: 	 * <ol>
1: 	 * <li>If this bundle's state is <code>UNINSTALLED</code> then an
1: 	 * <code>IllegalStateException</code> is thrown.
1: 	 * 
1: 	 * <li>If this bundle is in the process of being activated or deactivated
1: 	 * then this method must wait for activation or deactivation to complete
1: 	 * before continuing. If this does not occur in a reasonable time, a
1: 	 * <code>BundleException</code> is thrown to indicate this bundle was
1: 	 * unable to be stopped.
1: 	 * <li>If the {@link #STOP_TRANSIENT} option is not set then then set this
1: 	 * bundle's persistent autostart setting to to <em>Stopped</em>. When the
1: 	 * Framework is restarted and this bundle's autostart setting is
1: 	 * <em>Stopped</em>, this bundle must not be automatically started.
1: 	 * 
1: 	 * <li>If this bundle's state is not <code>ACTIVE</code> then this method
1: 	 * returns immediately.
1: 	 * 
1: 	 * <li>This bundle's state is set to <code>STOPPING</code>.
1: 	 * 
1: 	 * <li>A bundle event of type {@link BundleEvent#STOPPING} is fired.
1: 	 * 
1: 	 * <li>The {@link BundleActivator#stop} method of this bundle's
1: 	 * <code>BundleActivator</code>, if one is specified, is called. If that
1: 	 * method throws an exception, this method must continue to stop this
1: 	 * bundle. A <code>BundleException</code> must be thrown after completion
1: 	 * of the remaining steps.
1: 	 * 
1: 	 * <li>Any services registered by this bundle must be unregistered.
1: 	 * <li>Any services used by this bundle must be released.
1: 	 * <li>Any listeners registered by this bundle must be removed.
1: 	 * 
1: 	 * <li>If this bundle's state is <code>UNINSTALLED</code>, because this
1: 	 * bundle was uninstalled while the <code>BundleActivator.stop</code>
1: 	 * method was running, a <code>BundleException</code> must be thrown.
1: 	 * 
1: 	 * <li>This bundle's state is set to <code>RESOLVED</code>.
1: 	 * 
1: 	 * <li>A bundle event of type {@link BundleEvent#STOPPED} is fired.
1: 	 * </ol>
1: 	 * 
1: 	 * <b>Preconditions </b>
1: 	 * <ul>
1: 	 * <li><code>getState()</code> in {<code>ACTIVE</code>}.
1: 	 * </ul>
1: 	 * <b>Postconditions, no exceptions thrown </b>
1: 	 * <ul>
1: 	 * <li>Bundle autostart setting is modified unless the
1: 	 * {@link #STOP_TRANSIENT} option was set.
1: 	 * <li><code>getState()</code> not in {<code>ACTIVE</code>,
1: 	 * <code>STOPPING</code>}.
1: 	 * <li><code>BundleActivator.stop</code> has been called and did not
1: 	 * throw an exception.
1: 	 * </ul>
1: 	 * <b>Postconditions, when an exception is thrown </b>
1: 	 * <ul>
1: 	 * <li>Bundle autostart setting is modified unless the
1: 	 * {@link #STOP_TRANSIENT} option was set.
1: 	 * </ul>
1: 	 * 
1: 	 * @param options The options for stoping this bundle. See
1: 	 *        {@link #STOP_TRANSIENT}. The Framework must ignore unrecognized
1: 	 *        options.
1: 	 * @throws BundleException If this bundle's <code>BundleActivator</code>
1: 	 *         threw an exception or this bundle is a fragment.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled or this bundle tries to change its own state.
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,EXECUTE]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 * @since 1.4
1: 	 */
1: 	public void stop(int options) throws BundleException;
1: 
1: 	/**
1: 	 * Stops this bundle with no options.
1: 	 * 
1: 	 * <p>
1: 	 * This method calls <code>stop(0)</code>.
1: 	 * 
1: 	 * @throws BundleException If this bundle's <code>BundleActivator</code>
1: 	 *         threw an exception or this bundle is a fragment.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled or this bundle tries to change its own state.
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,EXECUTE]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 * @see #start(int)
1: 	 */
1: 	public void stop() throws BundleException;
1: 
1: 	/**
1: 	 * Updates this bundle.
1: 	 * 
1: 	 * <p>
1: 	 * If this bundle's state is <code>ACTIVE</code>, it must be stopped
1: 	 * before the update and started after the update successfully completes.
1: 	 * 
1: 	 * <p>
1: 	 * If this bundle has exported any packages, these packages must not be
1: 	 * updated. Instead, the previous package version must remain exported until
1: 	 * the <code>PackageAdmin.refreshPackages</code> method has been has been
1: 	 * called or the Framework is relaunched.
1: 	 * 
1: 	 * <p>
1: 	 * The following steps are required to update a bundle:
1: 	 * <ol>
1: 	 * <li>If this bundle's state is <code>UNINSTALLED</code> then an
1: 	 * <code>IllegalStateException</code> is thrown.
1: 	 * 
1: 	 * <li>If this bundle's state is <code>ACTIVE</code>,
1: 	 * <code>STARTING</code> or <code>STOPPING</code>, this bundle is
1: 	 * stopped as described in the <code>Bundle.stop</code> method. If
1: 	 * <code>Bundle.stop</code> throws an exception, the exception is rethrown
1: 	 * terminating the update.
1: 	 * 
1: 	 * <li>The download location of the new version of this bundle is
1: 	 * determined from either this bundle's
1: 	 * {@link Constants#BUNDLE_UPDATELOCATION} Manifest header (if available) or
1: 	 * this bundle's original location.
1: 	 * 
1: 	 * <li>The location is interpreted in an implementation dependent manner,
1: 	 * typically as a URL, and the new version of this bundle is obtained from
1: 	 * this location.
1: 	 * 
1: 	 * <li>The new version of this bundle is installed. If the Framework is
1: 	 * unable to install the new version of this bundle, the original version of
1: 	 * this bundle must be restored and a <code>BundleException</code> must be
1: 	 * thrown after completion of the remaining steps.
1: 	 * 
1: 	 * <li>If this bundle has declared an Bundle-RequiredExecutionEnvironment
1: 	 * header, then the listed execution environments must be verified against
1: 	 * the installed execution environments. If they do not all match, the
1: 	 * original version of this bundle must be restored and a
1: 	 * <code>BundleException</code> must be thrown after completion of the
1: 	 * remaining steps.
1: 	 * 
1: 	 * <li>This bundle's state is set to <code>INSTALLED</code>.
1: 	 * 
1: 	 * <li>If the new version of this bundle was successfully installed, a
1: 	 * bundle event of type {@link BundleEvent#UPDATED} is fired.
1: 	 * 
1: 	 * <li>If this bundle's state was originally <code>ACTIVE</code>, the
1: 	 * updated bundle is started as described in the <code>Bundle.start</code>
1: 	 * method. If <code>Bundle.start</code> throws an exception, a Framework
1: 	 * event of type {@link FrameworkEvent#ERROR} is fired containing the
1: 	 * exception.
1: 	 * </ol>
1: 	 * 
1: 	 * <b>Preconditions </b>
1: 	 * <ul>
1: 	 * <li><code>getState()</code> not in {<code>UNINSTALLED</code>}.
1: 	 * </ul>
1: 	 * <b>Postconditions, no exceptions thrown </b>
1: 	 * <ul>
1: 	 * <li><code>getState()</code> in {<code>INSTALLED</code>,
1: 	 * <code>RESOLVED</code>,<code>ACTIVE</code>}.
1: 	 * <li>This bundle has been updated.
1: 	 * </ul>
1: 	 * <b>Postconditions, when an exception is thrown </b>
1: 	 * <ul>
1: 	 * <li><code>getState()</code> in {<code>INSTALLED</code>,
1: 	 * <code>RESOLVED</code>,<code>ACTIVE</code>}.
1: 	 * <li>Original bundle is still used; no update occurred.
1: 	 * </ul>
1: 	 * 
1: 	 * @throws BundleException If the update fails.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled or this bundle tries to change its own state.
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,LIFECYCLE]</code> for
1: 	 *         both the current bundle and the updated bundle, and the Java
1: 	 *         Runtime Environment supports permissions.
1: 	 * @see #stop()
1: 	 * @see #start()
1: 	 */
1: 	public void update() throws BundleException;
1: 
1: 	/**
1: 	 * Updates this bundle from an <code>InputStream</code>.
1: 	 * 
1: 	 * <p>
1: 	 * This method performs all the steps listed in <code>Bundle.update()</code>,
1: 	 * except the new version of this bundle must be read from the supplied
1: 	 * <code>InputStream</code>, rather than a <code>URL</code>.
1: 	 * <p>
1: 	 * This method must always close the <code>InputStream</code> when it is
1: 	 * done, even if an exception is thrown.
1: 	 * 
1: 	 * @param in The <code>InputStream</code> from which to read the new
1: 	 *        bundle.
1: 	 * @throws BundleException If the provided stream cannot be read or the
1: 	 *         update fails.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled or this bundle tries to change its own state.
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,LIFECYCLE]</code> for
1: 	 *         both the current bundle and the updated bundle, and the Java
1: 	 *         Runtime Environment supports permissions.
1: 	 * @see #update()
1: 	 */
1: 	public void update(InputStream in) throws BundleException;
1: 
1: 	/**
1: 	 * Uninstalls this bundle.
1: 	 * 
1: 	 * <p>
1: 	 * This method causes the Framework to notify other bundles that this bundle
1: 	 * is being uninstalled, and then puts this bundle into the
1: 	 * <code>UNINSTALLED</code> state. The Framework must remove any resources
1: 	 * related to this bundle that it is able to remove.
1: 	 * 
1: 	 * <p>
1: 	 * If this bundle has exported any packages, the Framework must continue to
1: 	 * make these packages available to their importing bundles until the
1: 	 * <code>PackageAdmin.refreshPackages</code> method has been called or the
1: 	 * Framework is relaunched.
1: 	 * 
1: 	 * <p>
1: 	 * The following steps are required to uninstall a bundle:
1: 	 * <ol>
1: 	 * <li>If this bundle's state is <code>UNINSTALLED</code> then an
1: 	 * <code>IllegalStateException</code> is thrown.
1: 	 * 
1: 	 * <li>If this bundle's state is <code>ACTIVE</code>,
1: 	 * <code>STARTING</code> or <code>STOPPING</code>, this bundle is
1: 	 * stopped as described in the <code>Bundle.stop</code> method. If
1: 	 * <code>Bundle.stop</code> throws an exception, a Framework event of type
1: 	 * {@link FrameworkEvent#ERROR} is fired containing the exception.
1: 	 * 
1: 	 * <li>This bundle's state is set to <code>UNINSTALLED</code>.
1: 	 * 
1: 	 * <li>A bundle event of type {@link BundleEvent#UNINSTALLED} is fired.
1: 	 * 
1: 	 * <li>This bundle and any persistent storage area provided for this bundle
1: 	 * by the Framework are removed.
1: 	 * </ol>
1: 	 * 
1: 	 * <b>Preconditions </b>
1: 	 * <ul>
1: 	 * <li><code>getState()</code> not in {<code>UNINSTALLED</code>}.
1: 	 * </ul>
1: 	 * <b>Postconditions, no exceptions thrown </b>
1: 	 * <ul>
1: 	 * <li><code>getState()</code> in {<code>UNINSTALLED</code>}.
1: 	 * <li>This bundle has been uninstalled.
1: 	 * </ul>
1: 	 * <b>Postconditions, when an exception is thrown </b>
1: 	 * <ul>
1: 	 * <li><code>getState()</code> not in {<code>UNINSTALLED</code>}.
1: 	 * <li>This Bundle has not been uninstalled.
1: 	 * </ul>
1: 	 * 
1: 	 * @throws BundleException If the uninstall failed. This can occur if
1: 	 *         another thread is attempting to change this bundle's state and
1: 	 *         does not complete in a timely manner.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled or this bundle tries to change its own state.
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,LIFECYCLE]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 * @see #stop()
1: 	 */
1: 	public void uninstall() throws BundleException;
1: 
1: 	/**
1: 	 * Returns this bundle's Manifest headers and values. This method returns
1: 	 * all the Manifest headers and values from the main section of this
1: 	 * bundle's Manifest file; that is, all lines prior to the first blank line.
1: 	 * 
1: 	 * <p>
1: 	 * Manifest header names are case-insensitive. The methods of the returned
1: 	 * <code>Dictionary</code> object must operate on header names in a
1: 	 * case-insensitive manner.
1: 	 * 
1: 	 * If a Manifest header value starts with &quot;%&quot;, it must be
1: 	 * localized according to the default locale.
1: 	 * 
1: 	 * <p>
1: 	 * For example, the following Manifest headers and values are included if
1: 	 * they are present in the Manifest file:
1: 	 * 
1: 	 * <pre>
1: 	 *     Bundle-Name
1: 	 *     Bundle-Vendor
1: 	 *     Bundle-Version
1: 	 *     Bundle-Description
1: 	 *     Bundle-DocURL
1: 	 *     Bundle-ContactAddress
1: 	 * </pre>
1: 	 * 
1: 	 * <p>
1: 	 * This method must continue to return Manifest header information while
1: 	 * this bundle is in the <code>UNINSTALLED</code> state.
1: 	 * 
1: 	 * @return A <code>Dictionary</code> object containing this bundle's
1: 	 *         Manifest headers and values.
1: 	 * 
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,METADATA]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 * 
1: 	 * @see Constants#BUNDLE_LOCALIZATION
1: 	 */
1: 	public Dictionary getHeaders();
1: 
1: 	/**
1: 	 * Returns this bundle's unique identifier. This bundle is assigned a unique
1: 	 * identifier by the Framework when it was installed in the OSGi
1: 	 * environment.
1: 	 * 
1: 	 * <p>
1: 	 * A bundle's unique identifier has the following attributes:
1: 	 * <ul>
1: 	 * <li>Is unique and persistent.
1: 	 * <li>Is a <code>long</code>.
1: 	 * <li>Its value is not reused for another bundle, even after a bundle is
1: 	 * uninstalled.
1: 	 * <li>Does not change while a bundle remains installed.
1: 	 * <li>Does not change when a bundle is updated.
1: 	 * </ul>
1: 	 * 
1: 	 * <p>
1: 	 * This method must continue to return this bundle's unique identifier while
1: 	 * this bundle is in the <code>UNINSTALLED</code> state.
1: 	 * 
1: 	 * @return The unique identifier of this bundle.
1: 	 */
1: 	public long getBundleId();
1: 
1: 	/**
1: 	 * Returns this bundle's location identifier.
1: 	 * 
1: 	 * <p>
1: 	 * The location identifier is the location passed to
1: 	 * <code>BundleContext.installBundle</code> when a bundle is installed.
1: 	 * The location identifier does not change while this bundle remains
1: 	 * installed, even if this bundle is updated.
1: 	 * 
1: 	 * <p>
1: 	 * This method must continue to return this bundle's location identifier
1: 	 * while this bundle is in the <code>UNINSTALLED</code> state.
1: 	 * 
1: 	 * @return The string representation of this bundle's location identifier.
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,METADATA]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 */
1: 	public String getLocation();
1: 
1: 	/**
1: 	 * Returns this bundle's <code>ServiceReference</code> list for all
1: 	 * services it has registered or <code>null</code> if this bundle has no
1: 	 * registered services.
1: 	 * 
1: 	 * <p>
1: 	 * If the Java runtime supports permissions, a <code>ServiceReference</code>
1: 	 * object to a service is included in the returned list only if the caller
1: 	 * has the <code>ServicePermission</code> to get the service using at
1: 	 * least one of the named classes the service was registered under.
1: 	 * 
1: 	 * <p>
1: 	 * The list is valid at the time of the call to this method, however, as the
1: 	 * Framework is a very dynamic environment, services can be modified or
1: 	 * unregistered at anytime.
1: 	 * 
1: 	 * @return An array of <code>ServiceReference</code> objects or
1: 	 *         <code>null</code>.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled.
1: 	 * @see ServiceRegistration
1: 	 * @see ServiceReference
1: 	 * @see ServicePermission
1: 	 */
1: 	public ServiceReference[] getRegisteredServices();
1: 
1: 	/**
1: 	 * Returns this bundle's <code>ServiceReference</code> list for all
1: 	 * services it is using or returns <code>null</code> if this bundle is not
1: 	 * using any services. A bundle is considered to be using a service if its
1: 	 * use count for that service is greater than zero.
1: 	 * 
1: 	 * <p>
1: 	 * If the Java Runtime Environment supports permissions, a
1: 	 * <code>ServiceReference</code> object to a service is included in the
1: 	 * returned list only if the caller has the <code>ServicePermission</code>
1: 	 * to get the service using at least one of the named classes the service
1: 	 * was registered under.
1: 	 * <p>
1: 	 * The list is valid at the time of the call to this method, however, as the
1: 	 * Framework is a very dynamic environment, services can be modified or
1: 	 * unregistered at anytime.
1: 	 * 
1: 	 * @return An array of <code>ServiceReference</code> objects or
1: 	 *         <code>null</code>.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled.
1: 	 * @see ServiceReference
1: 	 * @see ServicePermission
1: 	 */
1: 	public ServiceReference[] getServicesInUse();
1: 
1: 	/**
1: 	 * Determines if this bundle has the specified permissions.
1: 	 * 
1: 	 * <p>
1: 	 * If the Java Runtime Environment does not support permissions, this method
1: 	 * always returns <code>true</code>.
1: 	 * <p>
1: 	 * <code>permission</code> is of type <code>Object</code> to avoid
1: 	 * referencing the <code>java.security.Permission</code> class directly.
1: 	 * This is to allow the Framework to be implemented in Java environments
1: 	 * which do not support permissions.
1: 	 * 
1: 	 * <p>
1: 	 * If the Java Runtime Environment does support permissions, this bundle and
1: 	 * all its resources including embedded JAR files, belong to the same
1: 	 * <code>java.security.ProtectionDomain</code>; that is, they must share
1: 	 * the same set of permissions.
1: 	 * 
1: 	 * @param permission The permission to verify.
1: 	 * 
1: 	 * @return <code>true</code> if this bundle has the specified permission
1: 	 *         or the permissions possessed by this bundle imply the specified
1: 	 *         permission; <code>false</code> if this bundle does not have the
1: 	 *         specified permission or <code>permission</code> is not an
1: 	 *         <code>instanceof</code> <code>java.security.Permission</code>.
1: 	 * 
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled.
1: 	 */
1: 	public boolean hasPermission(Object permission);
1: 
1: 	/**
1: 	 * Find the specified resource from this bundle.
1: 	 * 
1: 	 * This bundle's class loader is called to search for the specified
1: 	 * resource. If this bundle's state is <code>INSTALLED</code>, this
1: 	 * method must attempt to resolve this bundle before attempting to get the
1: 	 * specified resource. If this bundle cannot be resolved, then only this
1: 	 * bundle must be searched for the specified resource. Imported packages
1: 	 * cannot be searched when this bundle has not been resolved. If this bundle
1: 	 * is a fragment bundle then <code>null</code> is returned.
1: 	 * 
1: 	 * @param name The name of the resource. See
1: 	 *        <code>java.lang.ClassLoader.getResource</code> for a description
1: 	 *        of the format of a resource name.
1: 	 * @return A URL to the named resource, or <code>null</code> if the
1: 	 *         resource could not be found or if this bundle is a fragment
1: 	 *         bundle or if the caller does not have the appropriate
1: 	 *         <code>AdminPermission[this,RESOURCE]</code>, and the Java
1: 	 *         Runtime Environment supports permissions.
1: 	 * 
1: 	 * @since 1.1
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled.
1: 	 * @see #getEntry
1: 	 * @see #findEntries
1: 	 */
1: 	public URL getResource(String name);
1: 
1: 	/**
1: 	 * Returns this bundle's Manifest headers and values localized to the
1: 	 * specified locale.
1: 	 * 
1: 	 * <p>
1: 	 * This method performs the same function as
1: 	 * <code>Bundle.getHeaders()</code> except the manifest header values are
1: 	 * localized to the specified locale.
1: 	 * 
1: 	 * <p>
1: 	 * If a Manifest header value starts with &quot;%&quot;, it must be
1: 	 * localized according to the specified locale. If a locale is specified and
1: 	 * cannot be found, then the header values must be returned using the
1: 	 * default locale. Localizations are searched for in the following order:
1: 	 * 
1: 	 * <pre>
1: 	 *   bn + "_" + Ls + "_" + Cs + "_" + Vs
1:      *   bn + "_" + Ls + "_" + Cs
1:      *   bn + "_" + Ls
1:      *   bn + "_" + Ld + "_" + Cd + "_" + Vd
1:      *   bn + "_" + Ld + "_" + Cd
1:      *   bn + "_" + Ld
1: 	 *     bn
1: 	 * </pre>
1: 	 * 
1: 	 * Where <code>bn</code> is this bundle's localization basename,
1: 	 * <code>Ls</code>, <code>Cs</code> and <code>Vs</code> are the
1: 	 * specified locale (language, country, variant) and <code>Ld</code>,
1: 	 * <code>Cd</code> and <code>Vd</code> are the default locale (language,
1: 	 * country, variant).
1: 	 * 
1: 	 * If <code>null</code> is specified as the locale string, the header
1: 	 * values must be localized using the default locale. If the empty string
1: 	 * (&quot;&quot;) is specified as the locale string, the header values must
1: 	 * not be localized and the raw (unlocalized) header values, including any
1: 	 * leading &quot;%&quot;, must be returned.
1: 	 * 
1: 	 * <p>
1: 	 * This method must continue to return Manifest header information while
1: 	 * this bundle is in the <code>UNINSTALLED</code> state, however the
1: 	 * header values must only be available in the raw and default locale
1: 	 * values.
1: 	 * 
1: 	 * @param locale The locale name into which the header values are to be
1: 	 *        localized. If the specified locale is <code>null</code> then the
1: 	 *        locale returned by <code>java.util.Locale.getDefault</code> is
1: 	 *        used. If the specified locale is the empty string, this method
1: 	 *        will return the raw (unlocalized) manifest headers including any
1: 	 *        leading &quot;%&quot;.
1: 	 * @return A <code>Dictionary</code> object containing this bundle's
1: 	 *         Manifest headers and values.
1: 	 * 
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,METADATA]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 * 
1: 	 * @see #getHeaders()
1: 	 * @see Constants#BUNDLE_LOCALIZATION
1: 	 * @since 1.3
1: 	 */
1: 	public Dictionary getHeaders(String locale);
1: 
1: 	/**
1: 	 * Returns the symbolic name of this bundle as specified by its
1: 	 * <code>Bundle-SymbolicName</code> manifest header. The name must be
1: 	 * unique, it is recommended to use a reverse domain name naming convention
1: 	 * like that used for java packages. If this bundle does not have a
1: 	 * specified symbolic name then <code>null</code> is returned.
1: 	 * 
1: 	 * <p>
1: 	 * This method must continue to return this bundle's symbolic name while
1: 	 * this bundle is in the <code>UNINSTALLED</code> state.
1: 	 * 
1: 	 * @return The symbolic name of this bundle.
1: 	 * @since 1.3
1: 	 */
1: 	public String getSymbolicName();
1: 
1: 	/**
1: 	 * Loads the specified class using this bundle's classloader.
1: 	 * 
1: 	 * <p>
1: 	 * If this bundle is a fragment bundle then this method must throw a
1: 	 * <code>ClassNotFoundException</code>.
1: 	 * 
1: 	 * <p>
1: 	 * If this bundle's state is <code>INSTALLED</code>, this method must
1: 	 * attempt to resolve this bundle before attempting to load the class.
1: 	 * 
1: 	 * <p>
1: 	 * If this bundle cannot be resolved, a Framework event of type
1: 	 * {@link FrameworkEvent#ERROR} is fired containing a
1: 	 * <code>BundleException</code> with details of the reason this bundle
1: 	 * could not be resolved. This method must then throw a
1: 	 * <code>ClassNotFoundException</code>.
1: 	 * 
1: 	 * <p>
1: 	 * If this bundle's state is <code>UNINSTALLED</code>, then an
1: 	 * <code>IllegalStateException</code> is thrown.
1: 	 * 
1: 	 * @param name The name of the class to load.
1: 	 * @return The Class object for the requested class.
1: 	 * @throws java.lang.ClassNotFoundException If no such class can be found or
1: 	 *         if this bundle is a fragment bundle or if the caller does not
1: 	 *         have the appropriate <code>AdminPermission[this,CLASS]</code>,
1: 	 *         and the Java Runtime Environment supports permissions.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled.
1: 	 * @since 1.3
1: 	 */
1: 	public Class loadClass(String name) throws ClassNotFoundException;
1: 
1: 	/**
1: 	 * Find the specified resources from this bundle.
1: 	 * 
1: 	 * This bundle's class loader is called to search for the specified
1: 	 * resources. If this bundle's state is <code>INSTALLED</code>, this
1: 	 * method must attempt to resolve this bundle before attempting to get the
1: 	 * specified resources. If this bundle cannot be resolved, then only this
1: 	 * bundle must be searched for the specified resources. Imported packages
1: 	 * cannot be searched when a bundle has not been resolved. If this bundle is
1: 	 * a fragment bundle then <code>null</code> is returned.
1: 	 * 
1: 	 * @param name The name of the resource. See
1: 	 *        <code>java.lang.ClassLoader.getResources</code> for a
1: 	 *        description of the format of a resource name.
1: 	 * @return An enumeration of URLs to the named resources, or
1: 	 *         <code>null</code> if the resource could not be found or if this
1: 	 *         bundle is a fragment bundle or if the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,RESOURCE]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 * 
1: 	 * @since 1.3
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled.
1: 	 * @throws java.io.IOException If there is an I/O error.
1: 	 */
1: 	public Enumeration getResources(String name) throws IOException;
1: 
1: 	/**
1: 	 * Returns an Enumeration of all the paths (<code>String</code> objects)
1: 	 * to entries within this bundle whose longest sub-path matches the
1: 	 * specified path. This bundle's classloader is not used to search for
1: 	 * entries. Only the contents of this bundle are searched.
1: 	 * <p>
1: 	 * The specified path is always relative to the root of this bundle and may
1: 	 * begin with a &quot;/&quot;. A path value of &quot;/&quot; indicates the
1: 	 * root of this bundle.
1: 	 * <p>
1: 	 * Returned paths indicating subdirectory paths end with a &quot;/&quot;.
1: 	 * The returned paths are all relative to the root of this bundle and must
1: 	 * not begin with &quot;/&quot;.
1: 	 * 
1: 	 * @param path The path name for which to return entry paths.
1: 	 * @return An Enumeration of the entry paths (<code>String</code>
1: 	 *         objects) or <code>null</code> if no entry could be found or if
1: 	 *         the caller does not have the appropriate
1: 	 *         <code>AdminPermission[this,RESOURCE]</code> and the Java
1: 	 *         Runtime Environment supports permissions.
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled.
1: 	 * @since 1.3
1: 	 */
1: 	public Enumeration getEntryPaths(String path);
1: 
1: 	/**
1: 	 * Returns a URL to the entry at the specified path in this bundle. This
1: 	 * bundle's classloader is not used to search for the entry. Only the
1: 	 * contents of this bundle are searched for the entry.
1: 	 * <p>
1: 	 * The specified path is always relative to the root of this bundle and may
1: 	 * begin with &quot;/&quot;. A path value of &quot;/&quot; indicates the
1: 	 * root of this bundle.
1: 	 * 
1: 	 * @param path The path name of the entry.
1: 	 * @return A URL to the entry, or <code>null</code> if no entry could be
1: 	 *         found or if the caller does not have the appropriate
1: 	 *         <code>AdminPermission[this,RESOURCE]</code> and the Java
1: 	 *         Runtime Environment supports permissions.
1: 	 * 
1: 	 * @throws java.lang.IllegalStateException If this bundle has been
1: 	 *         uninstalled.
1: 	 * @since 1.3
1: 	 */
1: 	public URL getEntry(String path);
1: 
1: 	/**
1: 	 * Returns the time when this bundle was last modified. A bundle is
1: 	 * considered to be modified when it is installed, updated or uninstalled.
1: 	 * 
1: 	 * <p>
1: 	 * The time value is the number of milliseconds since January 1, 1970,
1: 	 * 00:00:00 GMT.
1: 	 * 
1: 	 * @return The time when this bundle was last modified.
1: 	 * @since 1.3
1: 	 */
1: 	public long getLastModified();
1: 
1: 	/**
1: 	 * Returns entries in this bundle and its attached fragments. This bundle's
1: 	 * classloader is not used to search for entries. Only the contents of this
1: 	 * bundle and its attached fragments are searched for the specified entries.
1: 	 * 
1: 	 * If this bundle's state is <code>INSTALLED</code>, this method must
1: 	 * attempt to resolve this bundle before attempting to find entries.
1: 	 * 
1: 	 * <p>
1: 	 * This method is intended to be used to obtain configuration, setup,
1: 	 * localization and other information from this bundle. This method takes
1: 	 * into account that the &quot;contents&quot; of this bundle can be extended
1: 	 * with fragments. This &quot;bundle space&quot; is not a namespace with
1: 	 * unique members; the same entry name can be present multiple times. This
1: 	 * method therefore returns an enumeration of URL objects. These URLs can
1: 	 * come from different JARs but have the same path name. This method can
1: 	 * either return only entries in the specified path or recurse into
1: 	 * subdirectories returning entries in the directory tree beginning at the
1: 	 * specified path. Fragments can be attached after this bundle is resolved,
1: 	 * possibly changing the set of URLs returned by this method. If this bundle
1: 	 * is not resolved, only the entries in the JAR file of this bundle are
1: 	 * returned.
1: 	 * <p>
1: 	 * Examples:
1: 	 * 
1: 	 * <pre>
1: 	 * // List all XML files in the OSGI-INF directory and below
1: 	 * Enumeration e = b.findEntries(&quot;OSGI-INF&quot;, &quot;*.xml&quot;, true);
1: 	 * 
1: 	 * // Find a specific localization file
1: 	 * Enumeration e = b.findEntries(&quot;OSGI-INF/l10n&quot;, 
1: 	 *                               &quot;bundle_nl_DU.properties&quot;, 
1: 	 *                               false);
1: 	 * if (e.hasMoreElements())
1: 	 * 	return (URL) e.nextElement();
1: 	 * </pre>
1: 	 * 
1: 	 * @param path The path name in which to look. The path is always relative
1: 	 *        to the root of this bundle and may begin with &quot;/&quot;. A
1: 	 *        path value of &quot;/&quot; indicates the root of this bundle.
1: 	 * @param filePattern The file name pattern for selecting entries in the
1: 	 *        specified path. The pattern is only matched against the last
1: 	 *        element of the entry path and it supports substring matching, as
1: 	 *        specified in the Filter specification, using the wildcard
1: 	 *        character (&quot;*&quot;). If null is specified, this is
1: 	 *        equivalent to &quot;*&quot; and matches all files.
1: 	 * @param recurse If <code>true</code>, recurse into subdirectories.
1: 	 *        Otherwise only return entries from the specified path.
1: 	 * @return An enumeration of URL objects for each matching entry, or
1: 	 *         <code>null</code> if an entry could not be found or if the
1: 	 *         caller does not have the appropriate
1: 	 *         <code>AdminPermission[this,RESOURCE]</code>, and the Java
1: 	 *         Runtime Environment supports permissions. The URLs are sorted
1: 	 *         such that entries from this bundle are returned first followed by
1: 	 *         the entries from attached fragments in ascending bundle id order.
1: 	 *         If this bundle is a fragment, then only matching entries in this
1: 	 *         fragment are returned.
1: 	 * @since 1.3
1: 	 */
1: 	public Enumeration findEntries(String path, String filePattern,
1: 			boolean recurse);
1: 
1: 	/**
1: 	 * Returns this bundle's {@link BundleContext}. The returned
1: 	 * <code>BundleContext</code> can be used by the caller to act on behalf
1: 	 * of this bundle.
1: 	 * 
1: 	 * <p>
1: 	 * If this bundle is not in the {@link #STARTING}, {@link #ACTIVE}, or
1: 	 * {@link #STOPPING} states or this bundle is a fragment bundle, then this
1: 	 * bundle has no valid <code>BundleContext</code>. This method will
1: 	 * return <code>null</code> if this bundle has no valid
1: 	 * <code>BundleContext</code>.
1: 	 * 
1: 	 * @return A <code>BundleContext</code> for this bundle or
1: 	 *         <code>null</code> if this bundle has no valid
1: 	 *         <code>BundleContext</code>.
1: 	 * @throws java.lang.SecurityException If the caller does not have the
1: 	 *         appropriate <code>AdminPermission[this,CONTEXT]</code>, and
1: 	 *         the Java Runtime Environment supports permissions.
1: 	 * @since 1.4
1: 	 */
1: 	public BundleContext getBundleContext();
1: }
============================================================================