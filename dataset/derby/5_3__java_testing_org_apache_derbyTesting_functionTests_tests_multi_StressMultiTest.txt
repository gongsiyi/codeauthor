1:1a5591f: /*
13:1a5591f: 
1:1a5591f:    Derby - Class
1:1a5591f:    org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest
1:1a5591f: 
1:1a5591f:    Licensed to the Apache Software Foundation (ASF) under one or more
1:1a5591f:    contributor license agreements.  See the NOTICE file distributed with
1:1a5591f:    this work for additional information regarding copyright ownership.
1:1a5591f:    The ASF licenses this file to you under the Apache License, Version 2.0
1:1a5591f:    (the "License"); you may not use this file except in compliance with
1:1a5591f:    the License.  You may obtain a copy of the License at
1:1a5591f: 
1:1a5591f:       http://www.apache.org/licenses/LICENSE-2.0
1:1a5591f: 
1:1a5591f:    Unless required by applicable law or agreed to in writing, software
1:1a5591f:    distributed under the License is distributed on an "AS IS" BASIS,
1:1a5591f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1a5591f:    See the License for the specific language governing permissions and
1:1a5591f:    limitations under the License.
1:1a5591f: 
1:1a5591f:  */
1:1a5591f: 
1:1a5591f: package org.apache.derbyTesting.functionTests.tests.multi;
1:1a5591f: 
1:bde05cd: import java.io.ByteArrayOutputStream;
1:bde05cd: import java.io.PrintStream;
1:1a5591f: import java.sql.Connection;
1:d5a0108: import java.sql.ResultSet;
1:1a5591f: import java.sql.SQLException;
1:1a5591f: import java.sql.Statement;
1:1a5591f: import java.util.Date;
1:1a5591f: import java.util.Properties;
1:1a5591f: import java.util.Random;
1:1a5591f: import junit.framework.AssertionFailedError;
1:1a5591f: import junit.framework.Test;
1:1a5591f: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1a5591f: import org.apache.derbyTesting.junit.BaseTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1a5591f: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:0433f1a: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:1a5591f: import org.apache.derbyTesting.junit.Decorator;
1:d5a0108: import org.apache.derbyTesting.junit.JDBC;
1:0433f1a: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:1a5591f: import org.apache.derbyTesting.junit.TestConfiguration;
1:1a5591f: 
1:1a5591f: /**
1:bde05cd:  * Stress-test running any number of threads performing "random" operations on
1:1a5591f:  * a database for any number of minutes. Default values are 10 threads for 10
1:1a5591f:  * minutes. The operations are create, select, insert, update and rollback.
1:1a5591f:  *
1:1a5591f:  * To test with a different number of threads and minutes set up a suite by
1:bde05cd:  * calling getSuite(int threads, int minutes). See StressMulti10x1.java for
1:1a5591f:  * an example.
1:bde05cd:  * 
1:bde05cd:  * To run only the embedded run, use embeddedSuite(int threads, int minutes).
1:bde05cd:  * 
1:bde05cd:  * The test will fail on the first exception thrown by any of the treads and
1:bde05cd:  * this will be the reported cause of failure and the threads will be stopped.
1:bde05cd:  * Other threads may throw exceptions before they have time to stop and these
1:bde05cd:  * can be found in the log, but they will not be reported as errors or failures
1:bde05cd:  * by the test.
1:bde05cd:  * 
1:bde05cd:  * SQLExceptions are reported as failures and any other exceptions as errors.
1:bde05cd:  * 
1:bde05cd:  * Some SQLExceptions are ignored by the test, but will show up in the log.
1:bde05cd:  * 
1:1a5591f:  */
1:1a5591f: public class StressMultiTest extends BaseJDBCTestCase {
1:1a5591f: 
1:bde05cd:     /**
1:bde05cd:      * The number of threads the test will run. Default is 10
1:bde05cd:      */
1:bde05cd:     private static int THREADS = 10;
1:bde05cd:     
1:bde05cd:     /**
1:bde05cd:      * The number of minutes the test will run. Default is 10.
1:bde05cd:      */
1:bde05cd:     private static int MINUTES = 10;
1:bde05cd:     
1:48229df:     private static final String THREADSMINUTES = "derby.tests.ThreadsMinutes";
1:48229df:     
1:bde05cd:     /**
1:bde05cd:      * Force verbosity, used for debugging. Will print alot of information
1:bde05cd:      * to the screen. 
1:bde05cd:      */
1:bde05cd:     private static boolean DEBUG = false;
1:bde05cd:     
1:bde05cd:     /**
1:bde05cd:      * This holds the first throwable thrown by by any of the threads,
1:bde05cd:      *  and will thrown as the cause of failure for the fixture.   
1:bde05cd:      */
1:bde05cd:     private Throwable thrown = null;
1:bde05cd:     
1:1a5591f:     private Thread threads[] = null;
1:1a5591f:     private Random rnd = new Random();
1:bde05cd:     
1:bde05cd:     /**
1:bde05cd:      * Setting this will cause the threads to terminate normally.
1:bde05cd:      */
1:1a5591f:     private boolean complete = false;
1:bde05cd:     
1:bde05cd:     
1:1a5591f:     public StressMultiTest(String s) {
1:1a5591f:         super(s);
5:1a5591f:     }
1:1a5591f: 
1:1a5591f:     /**
1:1a5591f:      * Set up the testsuite to run in embedded, client and encryption mode.
1:1a5591f:      * Default run is 10 threads for 10 minutes in each mode
1:1a5591f:      */
1:1a5591f:     public static Test suite() {
1:0433f1a:         Properties dbprops = new Properties();
1:0433f1a:         dbprops.put("derby.locks.deadlockTimeout", "2");
1:0433f1a:         dbprops.put("derby.locks.waitTimeout", "3");
1:0433f1a: 
1:0433f1a:         Properties sysprops = new Properties();
1:1a5591f:         sysprops.put("derby.storage.keepTransactionLog", "true");
1:0433f1a:         sysprops.put("derby.language.logStatementText", "true");
1:1a5591f:         sysprops.put("derby.infolog.append", "true");
1:1ae02c9:         Test embedded = new BaseTestSuite(StressMultiTest.class);
1:0433f1a:         embedded = new SystemPropertyTestSetup(embedded,sysprops,true);
1:0433f1a:         embedded = new DatabasePropertyTestSetup(embedded,dbprops);
1:0433f1a:         // make this a singleUseDatabase so the datbase and 
1:0433f1a:         // transaction log will be preserved.
1:0433f1a:         embedded = TestConfiguration.singleUseDatabaseDecorator(newCleanDatabase(embedded));
1:0433f1a:         // SystemPropertyTestSetup for static properties 
1:0433f1a:         // does not work for client because shutting down the
1:0433f1a:         // engine causes protocol errors on the client. Run
1:0433f1a:         // with -Dderby.storage.keepTransactionLog=true if
1:0433f1a:         // you need to save the transaction log for client.
1:0433f1a:         Test client = TestConfiguration.clientServerDecorator(
1:1ae02c9:                 new BaseTestSuite(StressMultiTest.class));
1:0433f1a:         client = newCleanDatabase(new DatabasePropertyTestSetup(client,dbprops));
1:1ae02c9:         Test encrypted = new BaseTestSuite(StressMultiTest.class);
1:0433f1a:         // SystemPropertyTestSetup for static properties 
1:0433f1a:         // does not work for encrypted databases because the
1:0433f1a:         // database has to be rebooted and we don't have access
1:0433f1a:         // to the boot password (local to Decorator.encryptedDatabase()
1:0433f1a:         // Run with -Dderby.storage.keepTransactionLog=true if you 
1:0433f1a:         // need to save the transaction log for encrypted.
1:1ae02c9:         BaseTestSuite unencrypted =
1:1ae02c9:             new BaseTestSuite("StressMultiTest:unencrypted");
1:1ae02c9: 
1:1a5591f:         unencrypted.addTest((embedded));
1:1a5591f:         unencrypted.addTest((client));
1:1a5591f: 
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("StressMultiTest, " + THREADS +
1:1ae02c9:                                " Threads " + MINUTES + " Minutes");
1:1ae02c9: 
1:1a5591f:         suite.addTest(newCleanDatabase(unencrypted));
1:1a5591f:         //Encrypted uses a different database so it needs its own newCleanDatabase
1:0433f1a:         suite.addTest(Decorator.encryptedDatabase(new DatabasePropertyTestSetup(newCleanDatabase(encrypted),dbprops)));
1:1a5591f: 
1:1a5591f:         return suite;
1:1a5591f:     }
1:1a5591f: 
1:1a5591f:     /**
1:bde05cd:      * Get a testsuite that runs all the 3 runs (embedded, client and encrypted) 
1:bde05cd:      * with the given number of threads for the given number of minutes.
1:1a5591f:      *
1:1a5591f:      * @param threads
1:1a5591f:      * @param minutes
1:d127717:      * @return  suite after changing <code>THREADS</code> and 
1:d127717:      * <code> MINUTES </code>
1:1a5591f:      */
1:1a5591f:     public static Test suite(int threads, int minutes) {
1:1a5591f:         THREADS = threads;
1:1a5591f:         MINUTES = minutes;
1:1a5591f:         return suite();
1:1a5591f:     }
1:bde05cd:     
1:bde05cd:     /**
1:bde05cd:      * Get at testsuite that runs only the embedded suite with 
1:bde05cd:      * the given number of threads for the given number of minutes. 
1:bde05cd:      * 
1:bde05cd:      * @param threads
1:bde05cd:      * @param minutes
1:bde05cd:      */
1:bde05cd:     public static Test embeddedSuite(int threads, int minutes) {
1:bde05cd:         THREADS = threads;
1:bde05cd:         MINUTES = minutes;
1:bde05cd:         
1:0433f1a:         Properties dbprops = new Properties();
1:0433f1a:         dbprops.put("derby.locks.deadlockTimeout", "2");
1:0433f1a:         dbprops.put("derby.locks.waitTimeout", "3");
1:0433f1a:         dbprops.put("derby.language.logStatementText", "true");
1:0433f1a:         dbprops.put("derby.storage.keepTransactionLog", "true");
1:0433f1a:         Properties sysprops = new Properties();
1:bde05cd:         sysprops.put("derby.storage.keepTransactionLog", "true");
1:0433f1a:         sysprops.put("derby.language.logStatementText", "true");
1:bde05cd:         sysprops.put("derby.infolog.append", "true");
1:1ae02c9:         Test embedded = new BaseTestSuite(StressMultiTest.class);
1:0433f1a:         embedded = new SystemPropertyTestSetup(embedded,sysprops,true);
1:0433f1a:         embedded = new DatabasePropertyTestSetup(embedded,dbprops);
1:0433f1a:         embedded = TestConfiguration.singleUseDatabaseDecorator(newCleanDatabase(embedded));
1:0433f1a:         return embedded;
1:bde05cd:     }
1:bde05cd:     
1:1a5591f:     /*
1:1a5591f:      * Create a CleanDatabaseTestSetup that sets up the testdatabase.
1:1a5591f:      */
1:0433f1a:     private static Test newCleanDatabase(Test s) {
1:1a5591f:         return new CleanDatabaseTestSetup(s) {
1:1a5591f:         /**
1:1a5591f:          * Creates the database objects used in the test cases.
1:1a5591f:          *
1:1a5591f:          * @throws SQLException
1:1a5591f:          */
1:1a5591f:         protected void decorateSQL(Statement s) throws SQLException {
1:1a5591f:             s.execute("CREATE FUNCTION  PADSTRING (DATA VARCHAR(32000), "
1:1a5591f:                     + "LENGTH INTEGER) RETURNS VARCHAR(32000) EXTERNAL NAME " +
1:1a5591f:                     "'org.apache.derbyTesting.functionTests.util.Formatters" +
1:1a5591f:                     ".padString' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:1a5591f:             s.execute("CREATE FUNCTION RANDOM() RETURNS DOUBLE EXTERNAL " +
1:1a5591f:                     "NAME 'java.lang.Math.random' LANGUAGE JAVA PARAMETER " +
1:1a5591f:                     "STYLE JAVA");
1:1a5591f:             s.execute("create table main(x int not null primary key," +
1:1a5591f:                     " y varchar(2000))");
1:1a5591f:             s.execute("insert into main values(1, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(2, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(3, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(4, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(5, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(6, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(7, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(8, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(9, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(10, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(12, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main values(13, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("create table main2(x int not null primary key," +
1:1a5591f:                     " y varchar(2000))");
1:1a5591f:             s.execute("insert into main2 values(1, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(2, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(3, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(4, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(5, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(6, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(7, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(8, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(9, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(10, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(12, PADSTRING('aaaa',2000))");
1:1a5591f:             s.execute("insert into main2 values(13, PADSTRING('aaaa',2000))");
1:1a5591f:             getConnection().commit();
1:1a5591f:         };
1:1a5591f:     };
1:1a5591f:     }
1:bde05cd: 
1:1a5591f: 
1:1a5591f:     /*
1:1a5591f:      * (non-Javadoc)
1:1a5591f:      * @see junit.framework.TestCase#setUp()
1:1a5591f:      */
1:1a5591f:     public void setUp() throws Exception{
1:1a5591f:         super.setUp();
1:1a5591f:         this.getTestConfiguration().setVerbosity(DEBUG);
1:48229df:         
1:48229df:         // Let -Dderby.tests.ThreadsMinutes=TTxMM override.
1:48229df:         String optThreadsMinutes = getSystemProperty(THREADSMINUTES);
1:48229df:         if ( optThreadsMinutes != null )
1:48229df:         { // Syntax: '99x22' meaning 99 threads 22 minutes.
1:48229df:             int xPos = optThreadsMinutes.indexOf("x");
1:48229df:             try{
1:48229df:                 // Assuming xPos >= 1 : substring or parseInt will catch it.
1:48229df:                 THREADS = Integer.parseInt(optThreadsMinutes.substring(0, xPos));
1:48229df:                 MINUTES = Integer.parseInt(optThreadsMinutes.substring(xPos+1, optThreadsMinutes.length()));
1:48229df:             }
1:48229df:             catch ( Exception e) {
1:48229df:                 alarm("Illegal value for '"+THREADSMINUTES+"': '"
1:48229df:                         +optThreadsMinutes+"' - " +e.getMessage()
1:48229df:                         +". Threads: " + THREADS +", minutes: " + MINUTES);
1:48229df:             }
1:48229df:             traceit("Threads: " + THREADS +", minutes: " + MINUTES);
1:48229df:         }
1:1a5591f:     }
1:1a5591f: 
1:1a5591f:     /*
1:1a5591f:      * Make sure we clear the fields when done.
1:1a5591f:      */
1:1a5591f:     public void tearDown() throws Exception{
1:1a5591f:         rnd = null;
1:1a5591f:         threads = null;
1:1a5591f:         super.tearDown();
1:1a5591f:     }
1:bde05cd: 
1:1a5591f:     /**
1:1a5591f:      * This is the actual fixture run by the JUnit framework.
1:1a5591f:      * Creates all the runnables we need and pass them on to
1:bde05cd:      * runTestCaseRunnables. If any exception was thrown
1:bde05cd:      * when they are done it is thrown for JUnit to catch and
1:bde05cd:      * handle normally.
1:1a5591f:      */
1:bde05cd:     public void testStressMulti() throws Throwable{
1:bde05cd:         
1:bde05cd:         thrown = null;
1:bde05cd:         
1:1a5591f:         StressMultiRunnable[] tct = new StressMultiRunnable[THREADS];
1:1a5591f: 
1:1a5591f:         for (int i = 0; i < tct.length; i++) {
1:1a5591f:            tct[i] = new StressMultiRunnable ("Tester" + i, MINUTES);
1:1a5591f:         }
1:1a5591f:         runTestCaseRunnables (tct);
1:1a5591f:         tct = null;
1:bde05cd:         
1:bde05cd:         if (thrown!=null) throw thrown;
1:1a5591f:      }
1:1a5591f: 
1:1a5591f: 
1:1a5591f:     /*
1:1a5591f:      * Create all the threads and run them until they finish.
1:1a5591f:      *
1:1a5591f:      * @param runnables
1:1a5591f:      */
1:1a5591f:     protected void runTestCaseRunnables(final StressMultiRunnable[] runnables) {
1:1a5591f:         if (runnables == null) {
1:1a5591f:             throw new IllegalArgumentException("runnables is null");
1:1a5591f:         }
1:1a5591f:         threads = new Thread[runnables.length];
1:1a5591f: 
1:1a5591f:         //Create threads
1:1a5591f:         for (int i = 0; i < threads.length; i++) {
1:1a5591f:             threads[i] = new Thread(runnables[i]);
1:1a5591f:         }
1:1a5591f:         //Run the threads
1:1a5591f:         for (int i = 0; i < threads.length; i++) {
1:1a5591f:             threads[i].start();
1:1a5591f:         }
1:1a5591f:         //Wait for the threads to finish
1:1a5591f:         try {
1:1a5591f:             for (int i = 0; i < threads.length; i++) {
1:1a5591f:                 threads[i].join();
1:1a5591f:             }
1:1a5591f:         } catch (InterruptedException ignore) {
1:1a5591f:             BaseTestCase.println("Thread join interrupted.");
1:1a5591f:         }
1:1a5591f:         threads = null;
1:1a5591f:     }
1:1a5591f: 
1:1a5591f:     
1:1a5591f:     /*
1:1a5591f:      * Handles any exceptions we get in the threads
1:1a5591f:      */
1:bde05cd:     private synchronized void handleException(final Throwable t, String message) {
1:bde05cd:             complete = true; //This stops the threads.
1:bde05cd:             if (thrown == null) {
1:bde05cd:                 if(t instanceof AssertionFailedError) {
1:bde05cd:                     thrown = (AssertionFailedError) t;
1:bde05cd:                 } else if (t instanceof SQLException) {
1:bde05cd:                     ByteArrayOutputStream b = new ByteArrayOutputStream();
1:bde05cd:                     t.printStackTrace(new PrintStream(b));
1:bde05cd:                     thrown = new AssertionFailedError("Caused by: \n" + b.toString());
1:bde05cd:                 }
1:bde05cd:                 else {
1:bde05cd:                     thrown = t;
1:bde05cd:                 }
1:bde05cd:                 println("Exception handled!!: "+ message + " - " + t);
1:bde05cd:             } else 
1:bde05cd:             println("Exception discarded because another was already caught and the threads are terminating..:\n"+ message + " - " + t);
1:1a5591f:     }
1:1a5591f: 
1:1a5591f: 
1:1a5591f:     /**
1:1a5591f:      * This subclass contains the actual stresstests that will be run in
1:1a5591f:      * multiple threads.
1:1a5591f:      */
1:1a5591f:     class StressMultiRunnable implements Runnable {
1:1a5591f:         String name;
1:1a5591f:         Connection con;
1:1a5591f:         long starttime;
1:1a5591f:         long runtime; //How long will this thread run
1:1a5591f: 
1:1a5591f:         public StressMultiRunnable(String name, int minutes) {
1:1a5591f:             super();
1:1a5591f:             this.name = name;
1:1a5591f:             starttime = System.currentTimeMillis();
1:bde05cd:             runtime = minutes*60*1000; //convert minutes to ms
1:1a5591f:             try {
1:1a5591f:                 con = openDefaultConnection();
1:1a5591f:                 con.setAutoCommit(false);
1:1a5591f:             } catch (SQLException e) {
1:1a5591f:                 println(e.toString());
1:1a5591f:             }
1:1a5591f:         }
1:1a5591f: 
1:1a5591f:        /*
1:1a5591f:         * Do the work. Runs an infinite loop picking random operations from
1:1a5591f:         * the methods below until either complete == true, ie. there was a
1:1a5591f:         * failure in one of the threads, or the specified time has passed.
1:1a5591f:         */
1:1a5591f:         public void run() {
1:1a5591f:             try {
1:1a5591f:                 int i = 0;
1:1a5591f:                 while (!complete) {
1:1a5591f:                     i++;
1:1a5591f:                     int r = rnd.nextInt(100);
1:1a5591f:                     if (r < 10) {
1:1a5591f:                         String n = "x";
1:1a5591f:                         switch (rnd.nextInt(4)) {
1:1a5591f:                             case 0: n = "a"; break;
1:1a5591f:                             case 1: n = "x"; break;
1:1a5591f:                             case 2: n = "y"; break;
1:1a5591f:                             case 3: n = "z"; break;
1:1a5591f:                         }
1:1a5591f:                         create(n);
1:1a5591f:                         println(name + " - Run " + i + " - Create " + n + " " +
1:1a5591f:                                 new Date(System.currentTimeMillis()).toString());
1:1a5591f:                     } else if (r < 25){
1:1a5591f:                         String n = "main";
1:1a5591f:                         if (rnd.nextInt(2) == 1) n = "main2";
1:1a5591f:                         roll(n);
1:1a5591f:                         println(name + " - Run " + i + " - Roll " + n + " " +
1:1a5591f:                                 new Date(System.currentTimeMillis()).toString());
1:1a5591f:                     } else if (r < 40){
1:1a5591f:                         String n = "main";
1:1a5591f:                         if (rnd.nextInt(2) == 1) n = "main2";
1:1a5591f:                         insert(n);
1:1a5591f:                         println(name + " - Run " + i + " - Insert " + n + " " +
1:1a5591f:                                 new Date(System.currentTimeMillis()).toString());
1:1a5591f:                     } else if (r < 60){
1:1a5591f:                         String n = "main";
1:1a5591f:                         if (rnd.nextInt(2) == 1) n = "main2";
1:1a5591f:                         update(n);
1:1a5591f:                         println(name + " - Run " + i + " - Update " +
1:1a5591f:                                 n + " " +
1:1a5591f:                                 new Date(System.currentTimeMillis()).toString());
1:1a5591f:                     } else if (r <= 99){
1:1a5591f:                         String n = "main";
1:1a5591f:                         if (rnd.nextInt(2) == 1) n = "main2";
1:1a5591f:                         select(n);
1:1a5591f:                         println(name + " - Run " + i + " - Select " + n + " " +
1:1a5591f:                                 new Date(System.currentTimeMillis()).toString());
1:1a5591f:                     }
1:1a5591f:                     //Break the loop if the running time is reached.
1:1a5591f:                     if ((starttime + runtime) <= System.currentTimeMillis()) {
1:1a5591f:                         println(name + " - STOPPING - " +
1:1a5591f:                                 new Date(System.currentTimeMillis()).toString());
1:1a5591f:                         break;
1:1a5591f:                     }
1:1a5591f:                     Thread.sleep(rnd.nextInt(10)); //Just to spread them out a bit.
1:1a5591f:                 }
1:1a5591f:             }
1:1a5591f:             catch(Throwable t) {
1:1a5591f:                println("Exception in " + name + ": " + t);
1:bde05cd:                 
1:bde05cd:                    handleException(t, name + " - " +
1:1a5591f:                        new Date(System.currentTimeMillis()).toString());
1:1a5591f:             }
1:bde05cd:             
1:1a5591f:             println(name + " terminated!");
1:1a5591f:         }
1:1a5591f: 
1:1a5591f: 
1:1a5591f:         /********* Below are the tasks done by the threads  ******************/
1:1a5591f: 
1:1a5591f:         /**
1:1a5591f:          * Create a table with the given name and then drop it
1:1a5591f:          *
1:1a5591f:          * @param table
1:1a5591f:          * @throws SQLException
1:1a5591f:          */
1:1a5591f:         private void create(String table) throws SQLException {
1:1a5591f:             Statement s = con.createStatement();
1:1a5591f:             try {
1:1a5591f:                 s.execute("create table " + table + " (x int)");
1:1a5591f:                 s.execute("insert into " + table + " values (1)");
1:1a5591f:                 s.execute("insert into " + table + " values (1)");
1:1a5591f:                 s.execute("insert into " + table + " values (1)");
1:1a5591f:                 s.execute("insert into " + table + " values (1)");
1:1a5591f:                 s.execute("insert into " + table + " values (1)");
1:1a5591f:                 s.execute("drop table " + table);
1:1a5591f:                 con.commit();
1:1a5591f:             } catch (SQLException se) {
1:1a5591f:                 String e = se.getSQLState();
1:1a5591f:                 if (e.equals("X0X08") || e.equals("X0X05") || e.equals("42X05")
1:1a5591f:                         || e.equals("42Y55") || e.equals("42000")
1:1a5591f:                         || e.equals("40001") || e.equals("40XL1")
1:1a5591f:                         || e.equals("40XL2") || e.equals("42Y07")
1:bde05cd:                         || e.equals("42Y55")
1:bde05cd:                         ) {
1:1a5591f:                     //Ignore these
1:1a5591f:                 } else {
1:1a5591f:                     throw se;
1:1a5591f:                 }
1:1a5591f:             } finally {
1:1a5591f:                 s = null;
1:1a5591f:             }
1:1a5591f:         }
1:1a5591f: 
1:1a5591f:         /**
1:1a5591f:          * Insert a random value into the given table.
1:1a5591f:          * Table names can be main or main2.
1:1a5591f:          *
1:1a5591f:          * @param table
1:1a5591f:          * @throws SQLException
1:1a5591f:          */
1:1a5591f:         private void insert(String table) throws SQLException {
1:1a5591f:             Statement s = con.createStatement();
1:1a5591f:             try {
1:1a5591f:                 s.executeUpdate("insert into " + table
1:1a5591f:                         + " values (random() * 1000 + 100, 'rand')");
1:1a5591f:                 con.commit();
1:1a5591f:             } catch (SQLException se) {
1:1a5591f:                 String e = se.getSQLState();
1:1a5591f:                 if (e.equals("42000") || e.equals("23505") || e.equals("40001")
1:1a5591f:                         || e.equals("40XL1") || e.equals("40XL2")
1:1a5591f:                         || e.equals("42Y07") || e.equals("42Y55")) {
1:1a5591f:                     // ignore these
1:1a5591f:                 } else {
1:1a5591f:                     throw se;
1:1a5591f:                 }
1:1a5591f:             }finally {
1:1a5591f:                 s = null;
1:1a5591f:             }
1:1a5591f:         }
1:1a5591f: 
1:1a5591f:         /**
1:1a5591f:          * insert a value into the given table, then rollback.
1:1a5591f:          * Table names are main or main2.
1:1a5591f:          *
1:1a5591f:          * @param table
1:1a5591f:          * @throws SQLException
1:1a5591f:          */
1:1a5591f:         private void roll(String table) throws SQLException {
1:1a5591f:             Statement s = con.createStatement();
1:1a5591f:             con.setAutoCommit(false);
1:1a5591f:             try {
1:1a5591f:                 s.executeUpdate("insert into " + table
1:1a5591f:                                 + " values (666, '666')");
1:1a5591f:                 con.rollback();
1:1a5591f:             } catch (SQLException se) {
1:1a5591f:                 String e = se.getSQLState();
1:1a5591f:                 if (e.equals("X0X05") || e.equals("42X05") || e.equals("42Y55")
1:1a5591f:                         || e.equals("42000") || e.equals("23505")
1:1a5591f:                         || e.equals("40001") || e.equals("40XL1")
1:1a5591f:                         || e.equals("40XL2") || e.equals("42Y07")
2:1a5591f:                         || e.equals("42Y55")) {
1:1a5591f:                     // ignore these
1:1a5591f:                 } else {
1:1a5591f:                     throw se;
1:1a5591f:                 }
1:1a5591f:             }finally {
1:1a5591f:                 s = null;
1:1a5591f:             }
1:1a5591f:         }
1:1a5591f: 
1:1a5591f:         /**
1:1a5591f:           * Select * from the given table. Table names are main or main2.
1:1a5591f:           *
1:1a5591f:           * @param table
1:1a5591f:           * @throws SQLException
1:1a5591f:           */
1:1a5591f:         private void select(String table) throws SQLException {
1:1a5591f:             Statement s = con.createStatement();
1:1a5591f:             try {
1:d5a0108:                 ResultSet rs = s.executeQuery("select * from " + table);
1:d5a0108:                 JDBC.assertDrainResults(rs);
1:1a5591f:             } catch (SQLException se) {
1:1a5591f:                 String e = se.getSQLState();
1:1a5591f:                 if (e.equals("42Y55") || e.equals("42000") || e.equals("40001")
1:1a5591f:                         || e.equals("40XL1") || e.equals("40XL2")
1:1a5591f:                         || e.equals("42Y07")) {
1:1a5591f:                     // ignore these
1:1a5591f:                 } else {
1:1a5591f:                     throw se;
1:1a5591f:                 }
1:1a5591f:             }finally {
1:1a5591f:                 s = null;
1:1a5591f:             }
1:1a5591f:         }
1:1a5591f: 
1:1a5591f:         /**
1:1a5591f:          * Update the given table. Table names are main or main2.
1:1a5591f:          *
1:1a5591f:          * @param table
1:1a5591f:          * @throws SQLException
1:1a5591f:          */
1:1a5591f:         private void update(String table) throws SQLException {
1:1a5591f:             Statement s = con.createStatement();
1:1a5591f:             try {
1:1a5591f:                 s.executeUpdate("update " + table
1:1a5591f:                         + " main set y = 'zzz' where x = 5");
1:1a5591f:             } catch (SQLException se) {
1:1a5591f:                 String e = se.getSQLState();
1:1a5591f:                 if (e.equals("42Y55") || e.equals("42000") || e.equals("40001")
1:1a5591f:                         || e.equals("40XL1") || e.equals("40XL2")
1:1a5591f:                         || e.equals("42Y07")) {
1:1a5591f:                     // ignore these
1:1a5591f:                 } else {
1:1a5591f:                     throw se;
1:1a5591f:                 }
1:1a5591f:             } finally {
1:1a5591f:                 s = null;
1:1a5591f:             }
1:1a5591f:         }
1:1a5591f:     }
1:1a5591f: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         Test embedded = new BaseTestSuite(StressMultiTest.class);
/////////////////////////////////////////////////////////////////////////
1:                 new BaseTestSuite(StressMultiTest.class));
1:         Test encrypted = new BaseTestSuite(StressMultiTest.class);
1:         BaseTestSuite unencrypted =
1:             new BaseTestSuite("StressMultiTest:unencrypted");
1: 
1:         BaseTestSuite suite =
1:             new BaseTestSuite("StressMultiTest, " + THREADS +
1:                                " Threads " + MINUTES + " Minutes");
1: 
/////////////////////////////////////////////////////////////////////////
1:         Test embedded = new BaseTestSuite(StressMultiTest.class);
author:Ole Solberg
-------------------------------------------------------------------------------
commit:48229df
/////////////////////////////////////////////////////////////////////////
1:     private static final String THREADSMINUTES = "derby.tests.ThreadsMinutes";
1:     
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Let -Dderby.tests.ThreadsMinutes=TTxMM override.
1:         String optThreadsMinutes = getSystemProperty(THREADSMINUTES);
1:         if ( optThreadsMinutes != null )
1:         { // Syntax: '99x22' meaning 99 threads 22 minutes.
1:             int xPos = optThreadsMinutes.indexOf("x");
1:             try{
1:                 // Assuming xPos >= 1 : substring or parseInt will catch it.
1:                 THREADS = Integer.parseInt(optThreadsMinutes.substring(0, xPos));
1:                 MINUTES = Integer.parseInt(optThreadsMinutes.substring(xPos+1, optThreadsMinutes.length()));
1:             }
1:             catch ( Exception e) {
1:                 alarm("Illegal value for '"+THREADSMINUTES+"': '"
1:                         +optThreadsMinutes+"' - " +e.getMessage()
1:                         +". Threads: " + THREADS +", minutes: " + MINUTES);
1:             }
1:             traceit("Threads: " + THREADS +", minutes: " + MINUTES);
1:         }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0433f1a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         Properties dbprops = new Properties();
1:         dbprops.put("derby.locks.deadlockTimeout", "2");
1:         dbprops.put("derby.locks.waitTimeout", "3");
1: 
1:         Properties sysprops = new Properties();
1:         sysprops.put("derby.language.logStatementText", "true");
0:         Test embedded = new TestSuite(StressMultiTest.class);
1:         embedded = new SystemPropertyTestSetup(embedded,sysprops,true);
1:         embedded = new DatabasePropertyTestSetup(embedded,dbprops);
1:         // make this a singleUseDatabase so the datbase and 
1:         // transaction log will be preserved.
1:         embedded = TestConfiguration.singleUseDatabaseDecorator(newCleanDatabase(embedded));
1:         // SystemPropertyTestSetup for static properties 
1:         // does not work for client because shutting down the
1:         // engine causes protocol errors on the client. Run
1:         // with -Dderby.storage.keepTransactionLog=true if
1:         // you need to save the transaction log for client.
1:         Test client = TestConfiguration.clientServerDecorator(
0:         		new TestSuite(StressMultiTest.class));
1:         client = newCleanDatabase(new DatabasePropertyTestSetup(client,dbprops));
0:         Test encrypted = new TestSuite(StressMultiTest.class);
1:         // SystemPropertyTestSetup for static properties 
1:         // does not work for encrypted databases because the
1:         // database has to be rebooted and we don't have access
1:         // to the boot password (local to Decorator.encryptedDatabase()
1:         // Run with -Dderby.storage.keepTransactionLog=true if you 
1:         // need to save the transaction log for encrypted.
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(Decorator.encryptedDatabase(new DatabasePropertyTestSetup(newCleanDatabase(encrypted),dbprops)));
/////////////////////////////////////////////////////////////////////////
1:         Properties dbprops = new Properties();
1:         dbprops.put("derby.locks.deadlockTimeout", "2");
1:         dbprops.put("derby.locks.waitTimeout", "3");
1:         dbprops.put("derby.language.logStatementText", "true");
1:         dbprops.put("derby.storage.keepTransactionLog", "true");
1:         Properties sysprops = new Properties();
1:         sysprops.put("derby.language.logStatementText", "true");
0:         Test embedded = new TestSuite(StressMultiTest.class);
1:         embedded = new SystemPropertyTestSetup(embedded,sysprops,true);
1:         embedded = new DatabasePropertyTestSetup(embedded,dbprops);
1:         embedded = TestConfiguration.singleUseDatabaseDecorator(newCleanDatabase(embedded));
1:         return embedded;
1:     private static Test newCleanDatabase(Test s) {
commit:d5a0108
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:                 ResultSet rs = s.executeQuery("select * from " + table);
1:                 JDBC.assertDrainResults(rs);
commit:bde05cd
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayOutputStream;
1: import java.io.PrintStream;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * Stress-test running any number of threads performing "random" operations on
1:  * calling getSuite(int threads, int minutes). See StressMulti10x1.java for
1:  * 
1:  * To run only the embedded run, use embeddedSuite(int threads, int minutes).
1:  * 
1:  * The test will fail on the first exception thrown by any of the treads and
1:  * this will be the reported cause of failure and the threads will be stopped.
1:  * Other threads may throw exceptions before they have time to stop and these
1:  * can be found in the log, but they will not be reported as errors or failures
1:  * by the test.
1:  * 
1:  * SQLExceptions are reported as failures and any other exceptions as errors.
1:  * 
1:  * Some SQLExceptions are ignored by the test, but will show up in the log.
1:  * 
1:     /**
1:      * The number of threads the test will run. Default is 10
1:      */
1:     private static int THREADS = 10;
1:     
1:     /**
1:      * The number of minutes the test will run. Default is 10.
1:      */
1:     private static int MINUTES = 10;
1:     
1:     /**
1:      * Force verbosity, used for debugging. Will print alot of information
1:      * to the screen. 
1:      */
1:     private static boolean DEBUG = false;
1:     
1:     /**
1:      * This holds the first throwable thrown by by any of the threads,
1:      *  and will thrown as the cause of failure for the fixture.   
1:      */
1:     private Throwable thrown = null;
1:     
1:     
1:     /**
1:      * Setting this will cause the threads to terminate normally.
1:      */
1:     
1:     
/////////////////////////////////////////////////////////////////////////
1:      * Get a testsuite that runs all the 3 runs (embedded, client and encrypted) 
1:      * with the given number of threads for the given number of minutes.
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get at testsuite that runs only the embedded suite with 
1:      * the given number of threads for the given number of minutes. 
1:      * 
1:      * @param threads
1:      * @param minutes
0:      * @return
1:      */
1:     public static Test embeddedSuite(int threads, int minutes) {
1:         THREADS = threads;
1:         MINUTES = minutes;
1:         
0:         Properties sysprops = System.getProperties();
0:         sysprops.put("derby.locks.deadlockTimeout", "2");
0:         sysprops.put("derby.locks.waitTimeout", "3");
0:         sysprops.put("derby.language.logStatementText", "true");
1:         sysprops.put("derby.storage.keepTransactionLog", "true");
1:         sysprops.put("derby.infolog.append", "true");
0:         TestSuite embedded = new TestSuite("StressMultiTest:embedded, " + THREADS +
0:             " Threads " + MINUTES + " Minutes");
0:         embedded.addTestSuite(StressMultiTest.class);
1:         
0:         return newCleanDatabase(embedded);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * runTestCaseRunnables. If any exception was thrown
1:      * when they are done it is thrown for JUnit to catch and
1:      * handle normally.
1:     public void testStressMulti() throws Throwable{
1:         
1:         thrown = null;
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         if (thrown!=null) throw thrown;
/////////////////////////////////////////////////////////////////////////
1:     
1:     private synchronized void handleException(final Throwable t, String message) {
1:             complete = true; //This stops the threads.
1:             if (thrown == null) {
1:                 if(t instanceof AssertionFailedError) {
1:                     thrown = (AssertionFailedError) t;
1:                 } else if (t instanceof SQLException) {
1:                     ByteArrayOutputStream b = new ByteArrayOutputStream();
1:                     t.printStackTrace(new PrintStream(b));
1:                     thrown = new AssertionFailedError("Caused by: \n" + b.toString());
1:                 }
1:                 else {
1:                     thrown = t;
1:                 }
1:                 println("Exception handled!!: "+ message + " - " + t);
1:             } else 
1:             println("Exception discarded because another was already caught and the threads are terminating..:\n"+ message + " - " + t);
/////////////////////////////////////////////////////////////////////////
1:             runtime = minutes*60*1000; //convert minutes to ms
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 
1:                    handleException(t, name + " - " +
1:             
/////////////////////////////////////////////////////////////////////////
1:                         || e.equals("42Y55")
1:                         ) {
commit:d127717
/////////////////////////////////////////////////////////////////////////
1:      * @return  suite after changing <code>THREADS</code> and 
1:      * <code> MINUTES </code>
commit:1a5591f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class 
1:    org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.multi;
1: 
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.Date;
1: import java.util.Properties;
1: import java.util.Random;
1: 
1: import junit.framework.AssertionFailedError;
1: import junit.framework.Test;
0: import junit.framework.TestResult;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.Decorator;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
0:  * Stresstest running any number of threads performing "random" operations on 
1:  * a database for any number of minutes. Default values are 10 threads for 10
1:  * minutes. The operations are create, select, insert, update and rollback.
1:  * 
1:  * To test with a different number of threads and minutes set up a suite by 
0:  * calling getSuite(int threads, int minutes). See StressMulti50x59.java for 
1:  * an example.
1:  */
1: public class StressMultiTest extends BaseJDBCTestCase {
1:     
0: 	private static int THREADS = 10; //Default number of threads we will run.
0:     private static int MINUTES = 10; //Default number of minutes we will run.
0: 	private static boolean DEBUG = false; //Force verbosity, used for debugging.
1: 	
1:     private Thread threads[] = null;
0:     private TestResult testResult = null;
1:     private Random rnd = new Random();
1:     private boolean complete = false;
1:     
1:     public StressMultiTest(String s) {
1:         super(s);
1:     }
1:     
1:     /**
1:      * Set up the testsuite to run in embedded, client and encryption mode.
1:      * Default run is 10 threads for 10 minutes in each mode
1:      */
1:     public static Test suite() {
0:     	Properties sysprops = System.getProperties();
0:     	sysprops.put("derby.locks.deadlockTimeout", "2");
0:     	sysprops.put("derby.locks.waitTimeout", "3");
0:     	sysprops.put("derby.language.logStatementText", "true");
1:     	sysprops.put("derby.storage.keepTransactionLog", "true");
1:     	sysprops.put("derby.infolog.append", "true");
1: 
0:     	TestSuite embedded = new TestSuite("StressMultiTest:embedded");
0:     	embedded.addTestSuite(StressMultiTest.class);
1:     	
0:     	TestSuite client = new TestSuite("StressMultiTest:client");
0:     	client.addTest(TestConfiguration.clientServerDecorator(
0:     			new TestSuite(StressMultiTest.class)));
1: 
0:     	TestSuite encrypted = new TestSuite("StressMultiTest:encrypted");
0:     	encrypted.addTestSuite(StressMultiTest.class);
1:     	
0:     	TestSuite unencrypted = new TestSuite("StressMultiTest:unencrypted");
1:     	unencrypted.addTest((embedded));
1:     	unencrypted.addTest((client));
1:     	
0:     	TestSuite suite = new TestSuite("StressMultiTest, " + THREADS + 
0:     			" Threads " + MINUTES + " Minutes");
1:     	suite.addTest(newCleanDatabase(unencrypted));
1:     	//Encrypted uses a different database so it needs its own newCleanDatabase
0:     	suite.addTest(Decorator.encryptedDatabase(newCleanDatabase(encrypted)));
1:     	
1:     	return suite;
1:     }
1:     
1:     /**
0:      * Get a testsuite that runs the specified number of threads
0:      * for the specified number of minutes.
1:      * 
1:      * @param threads
1:      * @param minutes
0:      * @return
1:      */
1:     public static Test suite(int threads, int minutes) {
1:     	THREADS = threads;
1:     	MINUTES = minutes;
1:     	return suite();
1:     }
1:     
1:     /*
1:      * Create a CleanDatabaseTestSetup that sets up the testdatabase.
1:      */
0:     private static Test newCleanDatabase(TestSuite s) {
1:     	return new CleanDatabaseTestSetup(s) { 
1:     	/**
1:          * Creates the database objects used in the test cases.
1:          * 
1:          * @throws SQLException
1:          */
1:         protected void decorateSQL(Statement s) throws SQLException {
1:         	s.execute("CREATE FUNCTION  PADSTRING (DATA VARCHAR(32000), " 
1:         			+ "LENGTH INTEGER) RETURNS VARCHAR(32000) EXTERNAL NAME " +
1:     				"'org.apache.derbyTesting.functionTests.util.Formatters" +
1:     				".padString' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:     		s.execute("CREATE FUNCTION RANDOM() RETURNS DOUBLE EXTERNAL " +
1:     				"NAME 'java.lang.Math.random' LANGUAGE JAVA PARAMETER " +
1:     				"STYLE JAVA");
1:     		s.execute("create table main(x int not null primary key," +
1:     				" y varchar(2000))");
1:     		s.execute("insert into main values(1, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(2, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(3, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(4, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(5, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(6, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(7, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(8, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(9, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(10, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(12, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main values(13, PADSTRING('aaaa',2000))");
1:     		s.execute("create table main2(x int not null primary key," +
1:     				" y varchar(2000))");
1:     		s.execute("insert into main2 values(1, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(2, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(3, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(4, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(5, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(6, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(7, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(8, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(9, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(10, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(12, PADSTRING('aaaa',2000))");
1:     		s.execute("insert into main2 values(13, PADSTRING('aaaa',2000))");
1:         	getConnection().commit();
1:         };
1:     };
1:     }
1:     
1:     
1:     /*
1:      * (non-Javadoc)
1:      * @see junit.framework.TestCase#setUp()
1:      */
1:     public void setUp() throws Exception{
1:     	super.setUp();
1: 		this.getTestConfiguration().setVerbosity(DEBUG);
1: 	}
1:     
1:     /*
1:      * Make sure we clear the fields when done.
1:      */
1:     public void tearDown() throws Exception{
0:     	testResult = null;
1:     	rnd = null;
1:     	threads = null;
1:     	super.tearDown();
1:     }
1:     
1:     /**
1: 	 * This is the actual fixture run by the JUnit framework.
1: 	 * Creates all the runnables we need and pass them on to 
0: 	 * runTestCaseRunnables
1: 	 */
0:     public void testStressMulti() {
1:         StressMultiRunnable[] tct = new StressMultiRunnable[THREADS];
1:         
1:         for (int i = 0; i < tct.length; i++) {
1:            tct[i] = new StressMultiRunnable ("Tester" + i, MINUTES);
1:         }
1:         runTestCaseRunnables (tct);
1:         tct = null;
1:      }
1: 
1: 
1:     /*
1:      * Create all the threads and run them until they finish.
1:      * 
1:      * @param runnables
1:      */
1:     protected void runTestCaseRunnables(final StressMultiRunnable[] runnables) {
1:         if (runnables == null) {
1:             throw new IllegalArgumentException("runnables is null");
1:         }
1:         threads = new Thread[runnables.length];
1:         
1:         //Create threads
1:         for (int i = 0; i < threads.length; i++) {
1:             threads[i] = new Thread(runnables[i]);
1:         }
1:         //Run the threads
1:         for (int i = 0; i < threads.length; i++) {
1:             threads[i].start();
1:         }
1:         //Wait for the threads to finish
1:         try {
1:             for (int i = 0; i < threads.length; i++) {
1:                 threads[i].join();
1:             }
1:         } catch (InterruptedException ignore) {
1:             BaseTestCase.println("Thread join interrupted.");
1:         }
1:         threads = null;
1:     }
1:  
0:     public void run(final TestResult result) {
0: 		testResult = result;
0: 		super.run(result);
0: 		testResult = null;
1: 	}
1:     
1:     /*
1: 	 * Handles any exceptions we get in the threads
1: 	 */
0:      private void handleException(final Throwable t, String message) {
0:         synchronized(testResult) {
0:         	println("Exception handled!!: "+ message + " - " + t);
0:         	complete = true; //This stops the tests.
0:             if(t instanceof AssertionFailedError) {
0:                 testResult.addFailure(this, (AssertionFailedError)t);
1:             }
0:             else {
0:                 testResult.addError(this, t);
1:             }
1:         }
1:      }
1:     
1:     
1:     /**
1:      * This subclass contains the actual stresstests that will be run in 
1:      * multiple threads.
1:      */
1:     class StressMultiRunnable implements Runnable {
1:         String name;
1:         Connection con;
1:         long starttime;
1:         long runtime; //How long will this thread run
1:         
1:         public StressMultiRunnable(String name, int minutes) {
1:             super();
1:             this.name = name;
1:             starttime = System.currentTimeMillis();
0:             runtime = minutes*60*1000; //convert min to ms
1:             try {
1:             	con = openDefaultConnection();
1:             	con.setAutoCommit(false);
1:             } catch (SQLException e) {
1:             	println(e.toString());
1:             }
1:         }
1:        
1:        /*
1:         * Do the work. Runs an infinite loop picking random operations from 
1:         * the methods below until either complete == true, ie. there was a 
1:         * failure in one of the threads, or the specified time has passed.
1:         */
1:         public void run() {
1:     	   try {
1:               int i = 0;
1:               while (!complete) {
1:             	  i++;
1:                   int r = rnd.nextInt(100);
1:                   
1:                   if (r < 10) {
1:                 	  String n = "x";
1:                 	  switch (rnd.nextInt(4)) {
1: 	                	  case 0: n = "a"; break;
1: 	                	  case 1: n = "x"; break;
1: 	                	  case 2: n = "y"; break;
1: 	                	  case 3: n = "z"; break;
1:                 	  }
1:                       create(n);
1:                 	  println(name + " - Run " + i + " - Create " + n + " " + 
1:                 			  new Date(System.currentTimeMillis()).toString());
1:                   } else if (r < 25){
1:                 	  String n = "main";
1:                 	  if (rnd.nextInt(2) == 1) n = "main2";
1:                 	  roll(n);
1:                 	  println(name + " - Run " + i + " - Roll " + n + " " + 
1:                 			  new Date(System.currentTimeMillis()).toString());
1:                   } else if (r < 40){
1:                 	  String n = "main";
1:                 	  if (rnd.nextInt(2) == 1) n = "main2";
1:                 	  insert(n);
1:                       println(name + " - Run " + i + " - Insert " + n + " " + 
1:                     		  new Date(System.currentTimeMillis()).toString());
1:                   } else if (r < 60){
1:                 	  String n = "main";
1:                 	  if (rnd.nextInt(2) == 1) n = "main2";
1:                 	  update(n);
1:                 	  println(name + " - Run " + i + " - Update " + 
1:                 			  n + " " + 
1:                 			  new Date(System.currentTimeMillis()).toString());
1:                   } else if (r <= 99){
1:                 	  String n = "main";
1:                 	  if (rnd.nextInt(2) == 1) n = "main2";
1:                 	  select(n);
1:                 	  println(name + " - Run " + i + " - Select " + n + " " + 
1:                 			  new Date(System.currentTimeMillis()).toString());
1:                   }
1:                   //Break the loop if the running time is reached.
1:                   if ((starttime + runtime) <= System.currentTimeMillis()) {
1:                 	  println(name + " - STOPPING - " + 
1:                 			  new Date(System.currentTimeMillis()).toString());
1:                 	  break;
1:                   }
1:                  Thread.sleep(rnd.nextInt(10)); //Just to spread them out a bit.
1:               }
1:           }
1:           catch(Throwable t) {
1:         	 println("Exception in " + name + ": " + t);
0:              handleException(t, name + " - " + 
1:             		 new Date(System.currentTimeMillis()).toString());
1:           }
1:           println(name + " terminated!");
1:        }
1:        
1:        
1:        /********* Below are the tasks done by the threads  ******************/
1:        
1:        /**
1:         * Create a table with the given name and then drop it
1:         * 
1:         * @param table
1:         * @throws SQLException
1:         */
1:        private void create(String table) throws SQLException {
1:     	   Statement s = con.createStatement();
1:     	   try {
1: 				s.execute("create table " + table + " (x int)");
1: 				s.execute("insert into " + table + " values (1)");
1: 				s.execute("insert into " + table + " values (1)");
1: 				s.execute("insert into " + table + " values (1)");
1: 				s.execute("insert into " + table + " values (1)");
1: 				s.execute("insert into " + table + " values (1)");
1: 				s.execute("drop table " + table);
1: 				con.commit();
1: 			} catch (SQLException se) {
1: 				String e = se.getSQLState();
1: 				if (e.equals("X0X08") || e.equals("X0X05") || e.equals("42X05")
1: 						|| e.equals("42Y55") || e.equals("42000")
1: 						|| e.equals("40001") || e.equals("40XL1")
1: 						|| e.equals("40XL2") || e.equals("42Y07")
1: 						|| e.equals("42Y55")) {
1: 					//Ignore these
1: 				} else {
1: 					throw se;
1: 				}
1: 			} finally {
1: 				s = null;
1: 			}
1: 		}
1:        
1:        /**
1:         * Insert a random value into the given table. 
1:         * Table names can be main or main2.
1:         * 
1:         * @param table
1:         * @throws SQLException
1:         */
1:        private void insert(String table) throws SQLException {
1: 			Statement s = con.createStatement();
1: 			try {
1: 				s.executeUpdate("insert into " + table
1: 						+ " values (random() * 1000 + 100, 'rand')");
1: 				con.commit();
1: 			} catch (SQLException se) {
1: 				String e = se.getSQLState();
1: 				if (e.equals("42000") || e.equals("23505") || e.equals("40001")
1: 						|| e.equals("40XL1") || e.equals("40XL2")
1: 						|| e.equals("42Y07") || e.equals("42Y55")) {
1: 					// ignore these
1: 				} else {
1: 					throw se;
1: 				}
1: 			}finally {
1: 				s = null;
1: 			}
1: 		}
1:        
1:        /**
1:         * insert a value into the given table, then rollback. 
1:         * Table names are main or main2.
1:         * 
1:         * @param table
1:         * @throws SQLException
1:         */
1:        private void roll(String table) throws SQLException {
1: 			Statement s = con.createStatement();
1: 			con.setAutoCommit(false);
1: 			try {
1: 				s.executeUpdate("insert into " + table
1: 								+ " values (666, '666')");
1: 				con.rollback();
1: 			} catch (SQLException se) {
1: 				String e = se.getSQLState();
1: 				if (e.equals("X0X05") || e.equals("42X05") || e.equals("42Y55")
1: 						|| e.equals("42000") || e.equals("23505")
1: 						|| e.equals("40001") || e.equals("40XL1")
1: 						|| e.equals("40XL2") || e.equals("42Y07")
1: 						|| e.equals("42Y55")) {
1: 					// ignore these
1: 				} else {
1: 					throw se;
1: 				}
1: 			}finally {
1: 				s = null;
1: 			}
1: 		}
1:        
1:        /**
1: 		 * Select * from the given table. Table names are main or main2.
1: 		 * 
1: 		 * @param table
1: 		 * @throws SQLException
1: 		 */
1:        private void select(String table) throws SQLException {
1: 			Statement s = con.createStatement();
1: 			try {
0: 				s.executeQuery("select * from " + table);
1: 			} catch (SQLException se) {
1: 				String e = se.getSQLState();
1: 				if (e.equals("42Y55") || e.equals("42000") || e.equals("40001")
1: 						|| e.equals("40XL1") || e.equals("40XL2")
1: 						|| e.equals("42Y07")) {
1: 					// ignore these
1: 				} else {
1: 					throw se;
1: 				}
1: 			}finally {
1: 				s = null;
1: 			}
1: 		}
1:        
1:        /**
1:         * Update the given table. Table names are main or main2.
1:         * 
1:         * @param table
1:         * @throws SQLException
1:         */
1:        private void update(String table) throws SQLException {
1: 			Statement s = con.createStatement();
1: 			try {
1: 				s.executeUpdate("update " + table
1: 						+ " main set y = 'zzz' where x = 5");
1: 			} catch (SQLException se) {
1: 				String e = se.getSQLState();
1: 				if (e.equals("42Y55") || e.equals("42000") || e.equals("40001")
1: 						|| e.equals("40XL1") || e.equals("40XL2")
1: 						|| e.equals("42Y07")) {
1: 					// ignore these
1: 				} else {
1: 					throw se;
1: 				} 
1: 			} finally {
1: 				s = null;
1: 			}
1: 		}
1:     }
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d50917c
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:82c3c55
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class
/////////////////////////////////////////////////////////////////////////
0:  * Stresstest running any number of threads performing "random" operations on
0:  *
0:  * To test with a different number of threads and minutes set up a suite by
0:  * calling getSuite(int threads, int minutes). See StressMulti50x59.java for
0: 
0:     private static int THREADS = 10; //Default number of threads we will run.
0:     private static boolean DEBUG = false; //Force verbosity, used for debugging.
0: 
0: 
0: 
0:         Properties sysprops = System.getProperties();
0:         sysprops.put("derby.locks.deadlockTimeout", "2");
0:         sysprops.put("derby.locks.waitTimeout", "3");
0:         sysprops.put("derby.language.logStatementText", "true");
0:         sysprops.put("derby.storage.keepTransactionLog", "true");
0:         sysprops.put("derby.infolog.append", "true");
0:         TestSuite embedded = new TestSuite("StressMultiTest:embedded");
0:         embedded.addTestSuite(StressMultiTest.class);
0:         TestSuite client = new TestSuite("StressMultiTest:client");
0:         client.addTest(TestConfiguration.clientServerDecorator(
0:                 new TestSuite(StressMultiTest.class)));
0: 
0:         TestSuite encrypted = new TestSuite("StressMultiTest:encrypted");
0:         encrypted.addTestSuite(StressMultiTest.class);
0: 
0:         TestSuite unencrypted = new TestSuite("StressMultiTest:unencrypted");
0:         unencrypted.addTest((embedded));
0:         unencrypted.addTest((client));
0: 
0:         TestSuite suite = new TestSuite("StressMultiTest, " + THREADS +
0:                 " Threads " + MINUTES + " Minutes");
0:         suite.addTest(newCleanDatabase(unencrypted));
0:         //Encrypted uses a different database so it needs its own newCleanDatabase
0:         suite.addTest(Decorator.encryptedDatabase(newCleanDatabase(encrypted)));
0: 
0:         return suite;
0: 
0:      *
0:         THREADS = threads;
0:         MINUTES = minutes;
0:         return suite();
0: 
0:         return new CleanDatabaseTestSetup(s) {
0:         /**
0:          *
0:             s.execute("CREATE FUNCTION  PADSTRING (DATA VARCHAR(32000), "
0:                     + "LENGTH INTEGER) RETURNS VARCHAR(32000) EXTERNAL NAME " +
0:                     "'org.apache.derbyTesting.functionTests.util.Formatters" +
0:                     ".padString' LANGUAGE JAVA PARAMETER STYLE JAVA");
0:             s.execute("CREATE FUNCTION RANDOM() RETURNS DOUBLE EXTERNAL " +
0:                     "NAME 'java.lang.Math.random' LANGUAGE JAVA PARAMETER " +
0:                     "STYLE JAVA");
0:             s.execute("create table main(x int not null primary key," +
0:                     " y varchar(2000))");
0:             s.execute("insert into main values(1, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(2, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(3, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(4, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(5, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(6, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(7, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(8, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(9, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(10, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(12, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main values(13, PADSTRING('aaaa',2000))");
0:             s.execute("create table main2(x int not null primary key," +
0:                     " y varchar(2000))");
0:             s.execute("insert into main2 values(1, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(2, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(3, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(4, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(5, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(6, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(7, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(8, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(9, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(10, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(12, PADSTRING('aaaa',2000))");
0:             s.execute("insert into main2 values(13, PADSTRING('aaaa',2000))");
0:             getConnection().commit();
0: 
0: 
0:         super.setUp();
0:         this.getTestConfiguration().setVerbosity(DEBUG);
0:     }
0: 
0:         testResult = null;
0:         rnd = null;
0:         threads = null;
0:         super.tearDown();
0: 
0:      * This is the actual fixture run by the JUnit framework.
0:      * Creates all the runnables we need and pass them on to
0:      * runTestCaseRunnables
0:      */
0: 
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         testResult = result;
0:         super.run(result);
0:         testResult = null;
0:     }
0: 
0:      * Handles any exceptions we get in the threads
0:      */
0:     private void handleException(final Throwable t, String message) {
0:             println("Exception handled!!: "+ message + " - " + t);
0:             complete = true; //This stops the tests.
/////////////////////////////////////////////////////////////////////////
0:     }
0: 
0: 
0:      * This subclass contains the actual stresstests that will be run in
/////////////////////////////////////////////////////////////////////////
0: 
0:                 con = openDefaultConnection();
0:                 con.setAutoCommit(false);
0:                 println(e.toString());
0: 
0:         * Do the work. Runs an infinite loop picking random operations from
0:         * the methods below until either complete == true, ie. there was a
0:             try {
0:                 int i = 0;
0:                 while (!complete) {
0:                     i++;
0:                     int r = rnd.nextInt(100);
0: 
0:                     if (r < 10) {
0:                         String n = "x";
0:                         switch (rnd.nextInt(4)) {
0:                             case 0: n = "a"; break;
0:                             case 1: n = "x"; break;
0:                             case 2: n = "y"; break;
0:                             case 3: n = "z"; break;
0:                         }
0:                         create(n);
0:                         println(name + " - Run " + i + " - Create " + n + " " +
0:                                 new Date(System.currentTimeMillis()).toString());
0:                     } else if (r < 25){
0:                         String n = "main";
0:                         if (rnd.nextInt(2) == 1) n = "main2";
0:                         roll(n);
0:                         println(name + " - Run " + i + " - Roll " + n + " " +
0:                                 new Date(System.currentTimeMillis()).toString());
0:                     } else if (r < 40){
0:                         String n = "main";
0:                         if (rnd.nextInt(2) == 1) n = "main2";
0:                         insert(n);
0:                         println(name + " - Run " + i + " - Insert " + n + " " +
0:                                 new Date(System.currentTimeMillis()).toString());
0:                     } else if (r < 60){
0:                         String n = "main";
0:                         if (rnd.nextInt(2) == 1) n = "main2";
0:                         update(n);
0:                         println(name + " - Run " + i + " - Update " +
0:                                 n + " " +
0:                                 new Date(System.currentTimeMillis()).toString());
0:                     } else if (r <= 99){
0:                         String n = "main";
0:                         if (rnd.nextInt(2) == 1) n = "main2";
0:                         select(n);
0:                         println(name + " - Run " + i + " - Select " + n + " " +
0:                                 new Date(System.currentTimeMillis()).toString());
0:                     }
0:                     //Break the loop if the running time is reached.
0:                     if ((starttime + runtime) <= System.currentTimeMillis()) {
0:                         println(name + " - STOPPING - " +
0:                                 new Date(System.currentTimeMillis()).toString());
0:                         break;
0:                     }
0:                     Thread.sleep(rnd.nextInt(10)); //Just to spread them out a bit.
0:                 }
0:             }
0:             catch(Throwable t) {
0:                println("Exception in " + name + ": " + t);
0:                handleException(t, name + " - " +
0:                        new Date(System.currentTimeMillis()).toString());
0:             }
0:             println(name + " terminated!");
0:         }
0: 
0: 
0:         /********* Below are the tasks done by the threads  ******************/
0: 
0:         /**
0:          * Create a table with the given name and then drop it
0:          *
0:          * @param table
0:          * @throws SQLException
0:          */
0:         private void create(String table) throws SQLException {
0:             Statement s = con.createStatement();
0:             try {
0:                 s.execute("create table " + table + " (x int)");
0:                 s.execute("insert into " + table + " values (1)");
0:                 s.execute("insert into " + table + " values (1)");
0:                 s.execute("insert into " + table + " values (1)");
0:                 s.execute("insert into " + table + " values (1)");
0:                 s.execute("insert into " + table + " values (1)");
0:                 s.execute("drop table " + table);
0:                 con.commit();
0:             } catch (SQLException se) {
0:                 String e = se.getSQLState();
0:                 if (e.equals("X0X08") || e.equals("X0X05") || e.equals("42X05")
0:                         || e.equals("42Y55") || e.equals("42000")
0:                         || e.equals("40001") || e.equals("40XL1")
0:                         || e.equals("40XL2") || e.equals("42Y07")
0:                         || e.equals("42Y55")) {
0:                     //Ignore these
0:                 } else {
0:                     throw se;
0:                 }
0:             } finally {
0:                 s = null;
0:             }
0:         }
0: 
0:         /**
0:          * Insert a random value into the given table.
0:          * Table names can be main or main2.
0:          *
0:          * @param table
0:          * @throws SQLException
0:          */
0:         private void insert(String table) throws SQLException {
0:             Statement s = con.createStatement();
0:             try {
0:                 s.executeUpdate("insert into " + table
0:                         + " values (random() * 1000 + 100, 'rand')");
0:                 con.commit();
0:             } catch (SQLException se) {
0:                 String e = se.getSQLState();
0:                 if (e.equals("42000") || e.equals("23505") || e.equals("40001")
0:                         || e.equals("40XL1") || e.equals("40XL2")
0:                         || e.equals("42Y07") || e.equals("42Y55")) {
0:                     // ignore these
0:                 } else {
0:                     throw se;
0:                 }
0:             }finally {
0:                 s = null;
0:             }
0:         }
0: 
0:         /**
0:          * insert a value into the given table, then rollback.
0:          * Table names are main or main2.
0:          *
0:          * @param table
0:          * @throws SQLException
0:          */
0:         private void roll(String table) throws SQLException {
0:             Statement s = con.createStatement();
0:             con.setAutoCommit(false);
0:             try {
0:                 s.executeUpdate("insert into " + table
0:                                 + " values (666, '666')");
0:                 con.rollback();
0:             } catch (SQLException se) {
0:                 String e = se.getSQLState();
0:                 if (e.equals("X0X05") || e.equals("42X05") || e.equals("42Y55")
0:                         || e.equals("42000") || e.equals("23505")
0:                         || e.equals("40001") || e.equals("40XL1")
0:                         || e.equals("40XL2") || e.equals("42Y07")
0:                         || e.equals("42Y55")) {
0:                     // ignore these
0:                 } else {
0:                     throw se;
0:                 }
0:             }finally {
0:                 s = null;
0:             }
0:         }
0: 
0:         /**
0:           * Select * from the given table. Table names are main or main2.
0:           *
0:           * @param table
0:           * @throws SQLException
0:           */
0:         private void select(String table) throws SQLException {
0:             Statement s = con.createStatement();
0:             try {
0:                 s.executeQuery("select * from " + table);
0:             } catch (SQLException se) {
0:                 String e = se.getSQLState();
0:                 if (e.equals("42Y55") || e.equals("42000") || e.equals("40001")
0:                         || e.equals("40XL1") || e.equals("40XL2")
0:                         || e.equals("42Y07")) {
0:                     // ignore these
0:                 } else {
0:                     throw se;
0:                 }
0:             }finally {
0:                 s = null;
0:             }
0:         }
0: 
0:         /**
0:          * Update the given table. Table names are main or main2.
0:          *
0:          * @param table
0:          * @throws SQLException
0:          */
0:         private void update(String table) throws SQLException {
0:             Statement s = con.createStatement();
0:             try {
0:                 s.executeUpdate("update " + table
0:                         + " main set y = 'zzz' where x = 5");
0:             } catch (SQLException se) {
0:                 String e = se.getSQLState();
0:                 if (e.equals("42Y55") || e.equals("42000") || e.equals("40001")
0:                         || e.equals("40XL1") || e.equals("40XL2")
0:                         || e.equals("42Y07")) {
0:                     // ignore these
0:                 } else {
0:                     throw se;
0:                 }
0:             } finally {
0:                 s = null;
0:             }
0:         }
============================================================================