1:9858a84: /*
2:9858a84: 
1:9858a84:    Derby - Class org.apache.derby.impl.sql.compile.DefaultOptTrace
1:9858a84: 
1:9858a84:    Licensed to the Apache Software Foundation (ASF) under one or more
1:9858a84:    contributor license agreements.  See the NOTICE file distributed with
1:9858a84:    this work for additional information regarding copyright ownership.
1:9858a84:    The ASF licenses this file to you under the Apache License, Version 2.0
1:9858a84:    (the "License"); you may not use this file except in compliance with
1:9858a84:    the License.  You may obtain a copy of the License at
1:9858a84: 
1:9858a84:       http://www.apache.org/licenses/LICENSE-2.0
1:9858a84: 
1:9858a84:    Unless required by applicable law or agreed to in writing, software
1:9858a84:    distributed under the License is distributed on an "AS IS" BASIS,
1:9858a84:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9858a84:    See the License for the specific language governing permissions and
1:9858a84:    limitations under the License.
1:9858a84: 
1:9858a84:  */
1:9858a84: 
1:9858a84: package org.apache.derby.impl.sql.compile;
1:049f993: 
1:049f993: import java.io.PrintWriter;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:9858a84: import org.apache.derby.iapi.sql.compile.AccessPath;
1:9858a84: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:9858a84: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1:9858a84: import org.apache.derby.iapi.sql.compile.OptTrace;
1:9858a84: import org.apache.derby.iapi.sql.compile.Optimizable;
1:b6cc9d7: import org.apache.derby.iapi.sql.compile.OptimizableList;
1:9858a84: import org.apache.derby.iapi.sql.compile.Optimizer;
1:9858a84: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1:9858a84: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:9858a84: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1:9858a84: import org.apache.derby.iapi.util.JBitSet;
1:9858a84: 
1:9858a84: /**
1:9858a84:  * This is the default optimizer tracing logic for use when a custom
1:9858a84:  * tracer wasn't specified.
1:9858a84:  */
1:9858a84: public  class   DefaultOptTrace implements  OptTrace
1:9858a84: {
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84:     //
1:9858a84:     //	CONSTANTS
1:9858a84:     //
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84: 
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84:     //
1:9858a84:     //	STATE
1:9858a84:     //
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84: 
1:3bb140c:     private StringBuilder _buffer;
1:9858a84:     
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84:     //
1:9858a84:     //	CONSTRUCTOR
1:9858a84:     //
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84: 
1:9858a84:     /** Make a DefaultOptTrace */
1:049f993:     public  DefaultOptTrace()
1:9858a84:     {
1:3bb140c:         _buffer = new StringBuilder();
1:9858a84:     }
1:9858a84: 
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84:     //
1:9858a84:     //	OptTrace BEHAVIOR
1:9858a84:     //
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84: 
1:049f993:     public  void    traceStartStatement( String statementText )
1:049f993:     {
1:049f993:         appendTraceString( statementText );
1:049f993:     }
1:049f993:     
1:3c3e7db:     public  void    traceStartQueryBlock( long timeOptimizationStarted, int optimizerID, OptimizableList optimizableList )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Optimization started at time " + 
1:9858a84:              timeOptimizationStarted +
1:049f993:              " using optimizer " + optimizerID
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:3c3e7db:     public  void    traceEndQueryBlock() {}
1:3c3e7db: 
1:9858a84:     public  void    traceTimeout( long currentTime, CostEstimate bestCost )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Optimization time exceeded at time " +
1:9858a84:              currentTime + "\n" + bestCost
1:9858a84:              );
1:9858a84:     }
1:9858a84:    
1:9858a84:     public  void    traceVacuous()
1:9858a84:     {
1:9858a84:         appendTraceString( "No tables to optimize." );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCompleteJoinOrder()
1:9858a84:     {
1:9858a84:         appendTraceString( "We have a complete join order." );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceSortCost( CostEstimate sortCost, CostEstimate currentCost )
1:9858a84:     {
1:9858a84:         appendTraceString( "Cost of sorting is " + sortCost );
1:9858a84:         appendTraceString( "Total cost of non-sort-avoidance plan with sort cost added is " + currentCost );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceNoBestPlan()
1:9858a84:     {
1:9858a84:         appendTraceString( "No best plan found." );
1:9858a84:     }
1:9858a84: 
1:049f993:     public  void    traceModifyingAccessPaths( int optimizerID )
1:9858a84:     {
1:049f993:         appendTraceString( "Modifying access paths using optimizer " + optimizerID );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceShortCircuiting( boolean timeExceeded, Optimizable thisOpt, int joinPosition )
1:9858a84:     {
1:9858a84:         String basis = (timeExceeded) ? "time exceeded" : "cost";
1:9858a84:         if ( thisOpt.getBestAccessPath().getCostEstimate() == null ) { basis = "no best plan found"; }
1:9858a84:         
1:9858a84:         appendTraceString( "Short circuiting based on " + basis + " at join position " + joinPosition );
1:9858a84:     }
1:9858a84:     
1:9858a84:     public  void    traceSkippingJoinOrder
1:9858a84:         ( int nextOptimizable, int joinPosition, int[] proposedJoinOrder, JBitSet assignedTableMap )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              reportJoinOrder( "\n\nSkipping join order: ", true, nextOptimizable, joinPosition, proposedJoinOrder, assignedTableMap )
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceIllegalUserJoinOrder()
1:9858a84:     {
1:9858a84:         appendTraceString( "User specified join order is not legal." );
1:9858a84:     }
1:9858a84:     
1:9858a84:     public  void    traceUserJoinOrderOptimized()
1:9858a84:     {
1:9858a84:         appendTraceString( "User-specified join order has now been optimized." );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceJoinOrderConsideration( int joinPosition, int[] proposedJoinOrder, JBitSet assignedTableMap )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              reportJoinOrder( "\n\nConsidering join order: ", false, 0, joinPosition, proposedJoinOrder, assignedTableMap )
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostWithoutSortAvoidance( CostEstimate currentCost )
1:9858a84:     {
1:9858a84:         appendTraceString( "Total cost of non-sort-avoidance plan is " + currentCost );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostWithSortAvoidance( CostEstimate currentSortAvoidanceCost )
1:9858a84:     {
1:9858a84:         appendTraceString( "Total cost of sort avoidance plan is " + currentSortAvoidanceCost );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCurrentPlanAvoidsSort( CostEstimate bestCost, CostEstimate currentSortAvoidanceCost )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Current plan is a sort avoidance plan." + 
1:9858a84:              "\n\tBest cost is : " + bestCost +
1:9858a84:              "\n\tThis cost is : " + currentSortAvoidanceCost
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCheapestPlanSoFar( int planType, CostEstimate currentCost )
1:9858a84:     {
1:9858a84:         appendTraceString( "This is the cheapest plan so far." );
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Plan is a " +
1:9858a84:              (planType == Optimizer.NORMAL_PLAN ? "normal" : "sort avoidance") +
1:9858a84:              " plan."
1:9858a84:              );
1:9858a84:         appendTraceString( "Cost of cheapest plan is " + currentCost );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceSortNeededForOrdering( int planType, RequiredRowOrdering requiredRowOrdering )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Sort needed for ordering: " + (planType != Optimizer.SORT_AVOIDANCE_PLAN) +
1:9858a84:              "\n\tRow ordering: " + requiredRowOrdering
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:b6cc9d7:     public  void    traceRememberingBestJoinOrder
1:b6cc9d7:         ( int joinPosition, int[] bestJoinOrder, int planType, CostEstimate planCost, JBitSet assignedTableMap )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              reportJoinOrder( "\n\nRemembering join order as best: ", false, 0, joinPosition, bestJoinOrder, assignedTableMap )
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceSkippingBecauseTooMuchMemory( int maxMemoryPerTable )
1:9858a84:     {
1:9858a84:         appendTraceString( "Skipping access path due to excess memory usage, maximum is " + maxMemoryPerTable );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostOfNScans( int tableNumber, double rowCount, CostEstimate cost )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Cost of " + rowCount + " scans is: " + cost +
1:9858a84:              " for table " + tableNumber
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceSkipUnmaterializableHashJoin()
1:9858a84:     {
1:9858a84:         appendTraceString( "Skipping HASH JOIN because optimizable is not materializable" );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceSkipHashJoinNoHashKeys()
1:9858a84:     {
1:9858a84:         appendTraceString( "Skipping HASH JOIN because there are no hash key columns" );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceHashKeyColumns( int[] hashKeyColumns )
1:9858a84:     {
1:9858a84:         String  traceString = "# hash key columns = " + hashKeyColumns.length;
1:9858a84:         for (int index = 0; index < hashKeyColumns.length; index++)
1:9858a84:         {
1:9858a84:             traceString = 
1:9858a84:                 "\n" + traceString + "hashKeyColumns[" + index +
1:9858a84:                 "] = " + hashKeyColumns[index];
1:9858a84:         }
1:9858a84: 
1:9858a84:         appendTraceString( traceString );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceOptimizingJoinNode()
1:9858a84:     {
1:9858a84:         appendTraceString( "Calling optimizeIt() for join node" );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceConsideringJoinStrategy( JoinStrategy js, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "\nConsidering join strategy " + js +
1:9858a84:              " for table " + tableNumber
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceRememberingBestAccessPath( AccessPath accessPath, int tableNumber, int planType )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Remembering access path " + accessPath +
1:9858a84:              " as truly the best for table " + tableNumber + 
1:9858a84:              " for plan type " + (planType == Optimizer.NORMAL_PLAN ? " normal " : "sort avoidance") +
1:9858a84:              "\n"
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceNoMoreConglomerates( int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( "No more conglomerates to consider for table " + tableNumber );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceConsideringConglomerate( ConglomerateDescriptor cd, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "\nConsidering conglomerate " + reportConglomerateDescriptor( cd ) +
1:9858a84:              " for table " + tableNumber
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceScanningHeapWithUniqueKey()
1:9858a84:     {
1:9858a84:         appendTraceString( "Scanning heap, but we have a full match on a unique key." );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceAddingUnorderedOptimizable( int predicateCount )
1:9858a84:     {
1:9858a84:         appendTraceString( "Adding unordered optimizable, # of predicates = " + predicateCount );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceChangingAccessPathForTable( int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( "Changing access path for table " + tableNumber );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceNoStartStopPosition()
1:9858a84:     {
1:9858a84:         appendTraceString( "Lock mode set to MODE_TABLE because no start or stop position" );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceNonCoveringIndexCost( double cost, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Index does not cover query - cost including base row fetch is: " + cost +
1:9858a84:              " for table " + tableNumber
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceConstantStartStopPositions()
1:9858a84:     {
1:9858a84:         appendTraceString( "Lock mode set to MODE_RECORD because all start and stop positions are constant" );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceEstimatingCostOfConglomerate( ConglomerateDescriptor cd, int tableNumber )
1:9858a84:     {
1:9858a84:         String  cdString = reportConglomerateDescriptor( cd );
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Estimating cost of conglomerate: " +
1:9858a84:              reportCostForTable( cdString, tableNumber )
1:9858a84:              );
1:9858a84: 
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceLookingForSpecifiedIndex( String indexName, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Looking for user-specified index: " + indexName +
1:9858a84:              " for table " + tableNumber
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceSingleMatchedRowCost( double cost, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Guaranteed to match a single row - cost is: " + cost +
1:9858a84:              " for table " + tableNumber
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostIncludingExtra1stColumnSelectivity( CostEstimate cost, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Cost including extra first column selectivity is : " + cost +
1:9858a84:              " for table " + tableNumber
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceNextAccessPath( String baseTable, int predicateCount )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Calling nextAccessPath() for base table " + baseTable +
1:9858a84:              " with " + predicateCount + " predicates."
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostIncludingExtraStartStop( CostEstimate cost, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( reportCostIncluding( "start/stop", cost, tableNumber ) );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostIncludingExtraQualifierSelectivity( CostEstimate cost, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( reportCostIncluding( "qualifier", cost, tableNumber ) );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostIncludingExtraNonQualifierSelectivity( CostEstimate cost, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( reportCostIncluding( "non-qualifier", cost, tableNumber ) );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostOfNoncoveringIndex( CostEstimate cost, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Index does not cover query: cost including row fetch is: " +
1:9858a84:              reportCostForTable( cost, tableNumber )
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceRememberingJoinStrategy( JoinStrategy joinStrategy, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "\nRemembering join strategy " + joinStrategy +
1:9858a84:              " as best for table " + tableNumber
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceRememberingBestAccessPathSubstring( AccessPath ap, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( "in best access path" );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceRememberingBestSortAvoidanceAccessPathSubstring( AccessPath ap, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( "in best sort avoidance access path" );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceRememberingBestUnknownAccessPathSubstring( AccessPath ap, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( "in best unknown access path" );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostOfConglomerateScan
1:9858a84:         (
1:9858a84:          int    tableNumber,
1:9858a84:          ConglomerateDescriptor cd,
1:9858a84:          CostEstimate   costEstimate,
1:9858a84:          int    numExtraFirstColumnPreds,
1:9858a84:          double    extraFirstColumnSelectivity,
1:9858a84:          int    numExtraStartStopPreds,
1:9858a84:          double    extraStartStopSelectivity,
1:9858a84:          int    startStopPredCount,
1:9858a84:          double    statStartStopSelectivity,
1:9858a84:          int    numExtraQualifiers,
1:9858a84:          double    extraQualifierSelectivity,
1:9858a84:          int    numExtraNonQualifiers,
1:9858a84:          double    extraNonQualifierSelectivity
1:9858a84:          )
1:9858a84:     {
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "Cost of conglomerate " + reportConglomerateDescriptor( cd ) +
1:9858a84:              " scan for table number " + tableNumber + " is : "
1:9858a84:              );
1:9858a84:         appendTraceString( costEstimate.toString() );
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "\tNumber of extra first column predicates is : " + numExtraFirstColumnPreds +
1:9858a84:              ", extra first column selectivity is : " + extraFirstColumnSelectivity
1:9858a84:              );
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "\tNumber of extra start/stop predicates is : " + numExtraStartStopPreds +
1:9858a84:              ", extra start/stop selectivity is : " + extraStartStopSelectivity
1:9858a84:              );
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "\tNumber of start/stop statistics predicates is : " + startStopPredCount +
1:9858a84:              ", statistics start/stop selectivity is : " + statStartStopSelectivity
1:9858a84:              );
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "\tNumber of extra qualifiers is : " + numExtraQualifiers +
1:9858a84:              ", extra qualifier selectivity is : " + extraQualifierSelectivity
1:9858a84:              );
1:9858a84:         appendTraceString
1:9858a84:             (
1:9858a84:              "\tNumber of extra non-qualifiers is : " + numExtraNonQualifiers +
1:9858a84:              ", extra non-qualifier selectivity is : " + extraNonQualifierSelectivity
1:9858a84:              );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostIncludingCompositeSelectivityFromStats( CostEstimate cost, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( reportCostIncluding( "selectivity from statistics", cost, tableNumber ) );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCompositeSelectivityFromStatistics( double statCompositeSelectivity )
1:9858a84:     {
1:9858a84:         appendTraceString( "Selectivity from statistics found. It is " + statCompositeSelectivity );
1:9858a84:     }
1:9858a84: 
1:9858a84:     public  void    traceCostIncludingStatsForIndex( CostEstimate cost, int tableNumber )
1:9858a84:     {
1:9858a84:         appendTraceString( reportCostIncluding( "statistics for index being considered", cost, tableNumber ) );
1:9858a84:     }
1:9858a84: 
1:049f993:     public  void    printToWriter( PrintWriter out )
1:049f993:     {
1:049f993:         out.println( _buffer.toString() );
1:049f993:     }
1:049f993:     
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84:     //
1:9858a84:     //	REPORTING MINIONS
1:9858a84:     //
1:9858a84:     ////////////////////////////////////////////////////////////////////////
1:9858a84: 
1:9858a84: 	private String reportJoinOrder
1:9858a84:         (
1:9858a84:          String prefix,
1:9858a84:          boolean addJoinOrderNumber,
1:9858a84:          int joinOrderNumber,
1:9858a84:          int joinPosition,
1:9858a84:          int[] joinOrder,
1:9858a84:          JBitSet    assignedTableMap
1:9858a84:          )
1:9858a84: 	{
1:3bb140c:         StringBuilder joinOrderString = new StringBuilder();
1:9858a84:         joinOrderString.append(prefix);
1:9858a84: 
1:9858a84: 		for (int i = 0; i <= joinPosition; i++)
1:9858a84: 		{
1:9858a84: 			joinOrderString.append(" ").append(joinOrder[i]);
1:9858a84: 		}
1:9858a84: 		if (addJoinOrderNumber)
1:9858a84: 		{
1:9858a84: 			joinOrderString.append(" ").append(joinOrderNumber);
1:9858a84: 		}
1:9858a84: 
1:9858a84:         joinOrderString.append(" with assignedTableMap = ").append(assignedTableMap).append("\n\n");
1:9858a84:         return joinOrderString.toString();
1:9858a84: 	}
1:9858a84: 
1:9858a84: 	private String reportConglomerateDescriptor( ConglomerateDescriptor cd )
1:9858a84: 	{
1:9858a84: 		if (SanityManager.DEBUG)
1:9858a84: 		{
1:9858a84: 			return cd.toString();
1:9858a84: 		}
1:9858a84: 
1:9858a84: 		String		keyString = "";
1:9858a84: 		String[]	columnNames = cd.getColumnNames();
1:9858a84: 
1:9858a84: 		if (cd.isIndex() && columnNames != null )
1:9858a84: 		{
1:9858a84: 			IndexRowGenerator irg = cd.getIndexDescriptor();
1:9858a84: 
1:9858a84: 			int[] keyColumns = irg.baseColumnPositions();
1:9858a84: 
1:9858a84: 			keyString = ", key columns = {" + columnNames[keyColumns[0] - 1];
1:9858a84: 			for (int index = 1; index < keyColumns.length; index++)
1:9858a84: 			{
1:9858a84: 				keyString = keyString + ", " + columnNames[keyColumns[index] - 1];
1:9858a84: 			}
1:9858a84: 			keyString = keyString + "}";
1:9858a84: 		}
1:9858a84: 
1:9858a84: 		return "CD: conglomerateNumber = " + cd.getConglomerateNumber() +
1:9858a84: 			   " name = " + cd.getConglomerateName() +
1:9858a84: 			   " uuid = " + cd.getUUID() +
1:9858a84: 			   " indexable = " + cd.isIndex() +
1:9858a84: 			   keyString;
1:9858a84: 	}
1:9858a84:     
1:9858a84: 	private String reportCostForTable( Object cost, int tableNumber )
1:9858a84: 	{
1:9858a84: 		return cost + " for table " + tableNumber;
1:9858a84: 	}
1:9858a84: 
1:9858a84: 	private String reportCostIncluding( String selectivityType, CostEstimate cost, int tableNumber )
1:9858a84: 	{
1:9858a84: 		return
1:9858a84: 			"Cost including extra " + selectivityType +
1:9858a84: 			" start/stop selectivity is : " +
1:9858a84: 			reportCostForTable( cost, tableNumber );
1:9858a84: 	}
1:9858a84: 
1:9858a84:     /** Append a string to the optimizer trace */
1:9858a84:     private void    appendTraceString( String traceString )
1:9858a84:     {
1:3bb140c:         _buffer.append( traceString );
1:3bb140c:         _buffer.append( "\n" );
1:9858a84:     }
1:9858a84: 
1:9858a84: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:3c3e7db
/////////////////////////////////////////////////////////////////////////
1:     public  void    traceStartQueryBlock( long timeOptimizationStarted, int optimizerID, OptimizableList optimizableList )
/////////////////////////////////////////////////////////////////////////
1:     public  void    traceEndQueryBlock() {}
1: 
commit:b6cc9d7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.OptimizableList;
/////////////////////////////////////////////////////////////////////////
0:     public  void    traceStart( long timeOptimizationStarted, int optimizerID, OptimizableList optimizableList )
/////////////////////////////////////////////////////////////////////////
1:     public  void    traceRememberingBestJoinOrder
1:         ( int joinPosition, int[] bestJoinOrder, int planType, CostEstimate planCost, JBitSet assignedTableMap )
commit:049f993
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
1: 
/////////////////////////////////////////////////////////////////////////
0:     private StringBuffer    _buffer;
/////////////////////////////////////////////////////////////////////////
1:     public  DefaultOptTrace()
0:         _buffer = new StringBuffer();
/////////////////////////////////////////////////////////////////////////
1:     public  void    traceStartStatement( String statementText )
1:     {
1:         appendTraceString( statementText );
1:     }
1:     
0:     public  void    traceStart( long timeOptimizationStarted, int optimizerID )
1:              " using optimizer " + optimizerID
/////////////////////////////////////////////////////////////////////////
1:     public  void    traceModifyingAccessPaths( int optimizerID )
1:         appendTraceString( "Modifying access paths using optimizer " + optimizerID );
/////////////////////////////////////////////////////////////////////////
1:     public  void    printToWriter( PrintWriter out )
1:     {
1:         out.println( _buffer.toString() );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0: 		_buffer.append( traceString + "\n" );
commit:9858a84
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.compile.DefaultOptTrace
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.compile.AccessPath;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.compile.OptTrace;
1: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1: import org.apache.derby.iapi.util.JBitSet;
1: 
1: /**
1:  * This is the default optimizer tracing logic for use when a custom
1:  * tracer wasn't specified.
1:  */
1: public  class   DefaultOptTrace implements  OptTrace
1: {
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTANTS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	STATE
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
0:     private LanguageConnectionContext   _lcc;
0:     private int                                     _optimizerID;
1:     
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTRUCTOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /** Make a DefaultOptTrace */
0:     public  DefaultOptTrace( LanguageConnectionContext lcc, int optimizerID )
1:     {
0:         _lcc = lcc;
0:         _optimizerID = optimizerID;
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	OptTrace BEHAVIOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
0:     public  void    traceStart( long timeOptimizationStarted )
1:     {
1:         appendTraceString
1:             (
1:              "Optimization started at time " + 
1:              timeOptimizationStarted +
0:              " using optimizer " + _optimizerID
1:              );
1:     }
1: 
1:     public  void    traceTimeout( long currentTime, CostEstimate bestCost )
1:     {
1:         appendTraceString
1:             (
1:              "Optimization time exceeded at time " +
1:              currentTime + "\n" + bestCost
1:              );
1:     }
1:    
1:     public  void    traceVacuous()
1:     {
1:         appendTraceString( "No tables to optimize." );
1:     }
1: 
1:     public  void    traceCompleteJoinOrder()
1:     {
1:         appendTraceString( "We have a complete join order." );
1:     }
1: 
1:     public  void    traceSortCost( CostEstimate sortCost, CostEstimate currentCost )
1:     {
1:         appendTraceString( "Cost of sorting is " + sortCost );
1:         appendTraceString( "Total cost of non-sort-avoidance plan with sort cost added is " + currentCost );
1:     }
1: 
1:     public  void    traceNoBestPlan()
1:     {
1:         appendTraceString( "No best plan found." );
1:     }
1: 
0:     public  void    traceModifyingAccessPaths()
1:     {
0:         appendTraceString( "Modifying access paths using optimizer " + _optimizerID );
1:     }
1: 
1:     public  void    traceShortCircuiting( boolean timeExceeded, Optimizable thisOpt, int joinPosition )
1:     {
1:         String basis = (timeExceeded) ? "time exceeded" : "cost";
1:         if ( thisOpt.getBestAccessPath().getCostEstimate() == null ) { basis = "no best plan found"; }
1:         
1:         appendTraceString( "Short circuiting based on " + basis + " at join position " + joinPosition );
1:     }
1:     
1:     public  void    traceSkippingJoinOrder
1:         ( int nextOptimizable, int joinPosition, int[] proposedJoinOrder, JBitSet assignedTableMap )
1:     {
1:         appendTraceString
1:             (
1:              reportJoinOrder( "\n\nSkipping join order: ", true, nextOptimizable, joinPosition, proposedJoinOrder, assignedTableMap )
1:              );
1:     }
1: 
1:     public  void    traceIllegalUserJoinOrder()
1:     {
1:         appendTraceString( "User specified join order is not legal." );
1:     }
1:     
1:     public  void    traceUserJoinOrderOptimized()
1:     {
1:         appendTraceString( "User-specified join order has now been optimized." );
1:     }
1: 
1:     public  void    traceJoinOrderConsideration( int joinPosition, int[] proposedJoinOrder, JBitSet assignedTableMap )
1:     {
1:         appendTraceString
1:             (
1:              reportJoinOrder( "\n\nConsidering join order: ", false, 0, joinPosition, proposedJoinOrder, assignedTableMap )
1:              );
1:     }
1: 
1:     public  void    traceCostWithoutSortAvoidance( CostEstimate currentCost )
1:     {
1:         appendTraceString( "Total cost of non-sort-avoidance plan is " + currentCost );
1:     }
1: 
1:     public  void    traceCostWithSortAvoidance( CostEstimate currentSortAvoidanceCost )
1:     {
1:         appendTraceString( "Total cost of sort avoidance plan is " + currentSortAvoidanceCost );
1:     }
1: 
1:     public  void    traceCurrentPlanAvoidsSort( CostEstimate bestCost, CostEstimate currentSortAvoidanceCost )
1:     {
1:         appendTraceString
1:             (
1:              "Current plan is a sort avoidance plan." + 
1:              "\n\tBest cost is : " + bestCost +
1:              "\n\tThis cost is : " + currentSortAvoidanceCost
1:              );
1:     }
1: 
1:     public  void    traceCheapestPlanSoFar( int planType, CostEstimate currentCost )
1:     {
1:         appendTraceString( "This is the cheapest plan so far." );
1:         appendTraceString
1:             (
1:              "Plan is a " +
1:              (planType == Optimizer.NORMAL_PLAN ? "normal" : "sort avoidance") +
1:              " plan."
1:              );
1:         appendTraceString( "Cost of cheapest plan is " + currentCost );
1:     }
1: 
1:     public  void    traceSortNeededForOrdering( int planType, RequiredRowOrdering requiredRowOrdering )
1:     {
1:         appendTraceString
1:             (
1:              "Sort needed for ordering: " + (planType != Optimizer.SORT_AVOIDANCE_PLAN) +
1:              "\n\tRow ordering: " + requiredRowOrdering
1:              );
1:     }
1: 
0:     public  void    traceRememberingBestJoinOrder( int joinPosition, int[] bestJoinOrder, JBitSet assignedTableMap )
1:     {
1:         appendTraceString
1:             (
1:              reportJoinOrder( "\n\nRemembering join order as best: ", false, 0, joinPosition, bestJoinOrder, assignedTableMap )
1:              );
1:     }
1: 
1:     public  void    traceSkippingBecauseTooMuchMemory( int maxMemoryPerTable )
1:     {
1:         appendTraceString( "Skipping access path due to excess memory usage, maximum is " + maxMemoryPerTable );
1:     }
1: 
1:     public  void    traceCostOfNScans( int tableNumber, double rowCount, CostEstimate cost )
1:     {
1:         appendTraceString
1:             (
1:              "Cost of " + rowCount + " scans is: " + cost +
1:              " for table " + tableNumber
1:              );
1:     }
1: 
1:     public  void    traceSkipUnmaterializableHashJoin()
1:     {
1:         appendTraceString( "Skipping HASH JOIN because optimizable is not materializable" );
1:     }
1: 
1:     public  void    traceSkipHashJoinNoHashKeys()
1:     {
1:         appendTraceString( "Skipping HASH JOIN because there are no hash key columns" );
1:     }
1: 
1:     public  void    traceHashKeyColumns( int[] hashKeyColumns )
1:     {
1:         String  traceString = "# hash key columns = " + hashKeyColumns.length;
1:         for (int index = 0; index < hashKeyColumns.length; index++)
1:         {
1:             traceString = 
1:                 "\n" + traceString + "hashKeyColumns[" + index +
1:                 "] = " + hashKeyColumns[index];
1:         }
1: 
1:         appendTraceString( traceString );
1:     }
1: 
1:     public  void    traceOptimizingJoinNode()
1:     {
1:         appendTraceString( "Calling optimizeIt() for join node" );
1:     }
1: 
1:     public  void    traceConsideringJoinStrategy( JoinStrategy js, int tableNumber )
1:     {
1:         appendTraceString
1:             (
1:              "\nConsidering join strategy " + js +
1:              " for table " + tableNumber
1:              );
1:     }
1: 
1:     public  void    traceRememberingBestAccessPath( AccessPath accessPath, int tableNumber, int planType )
1:     {
1:         appendTraceString
1:             (
1:              "Remembering access path " + accessPath +
1:              " as truly the best for table " + tableNumber + 
1:              " for plan type " + (planType == Optimizer.NORMAL_PLAN ? " normal " : "sort avoidance") +
1:              "\n"
1:              );
1:     }
1: 
1:     public  void    traceNoMoreConglomerates( int tableNumber )
1:     {
1:         appendTraceString( "No more conglomerates to consider for table " + tableNumber );
1:     }
1: 
1:     public  void    traceConsideringConglomerate( ConglomerateDescriptor cd, int tableNumber )
1:     {
1:         appendTraceString
1:             (
1:              "\nConsidering conglomerate " + reportConglomerateDescriptor( cd ) +
1:              " for table " + tableNumber
1:              );
1:     }
1: 
1:     public  void    traceScanningHeapWithUniqueKey()
1:     {
1:         appendTraceString( "Scanning heap, but we have a full match on a unique key." );
1:     }
1: 
1:     public  void    traceAddingUnorderedOptimizable( int predicateCount )
1:     {
1:         appendTraceString( "Adding unordered optimizable, # of predicates = " + predicateCount );
1:     }
1: 
1:     public  void    traceChangingAccessPathForTable( int tableNumber )
1:     {
1:         appendTraceString( "Changing access path for table " + tableNumber );
1:     }
1: 
1:     public  void    traceNoStartStopPosition()
1:     {
1:         appendTraceString( "Lock mode set to MODE_TABLE because no start or stop position" );
1:     }
1: 
1:     public  void    traceNonCoveringIndexCost( double cost, int tableNumber )
1:     {
1:         appendTraceString
1:             (
1:              "Index does not cover query - cost including base row fetch is: " + cost +
1:              " for table " + tableNumber
1:              );
1:     }
1: 
1:     public  void    traceConstantStartStopPositions()
1:     {
1:         appendTraceString( "Lock mode set to MODE_RECORD because all start and stop positions are constant" );
1:     }
1: 
1:     public  void    traceEstimatingCostOfConglomerate( ConglomerateDescriptor cd, int tableNumber )
1:     {
1:         String  cdString = reportConglomerateDescriptor( cd );
1:         appendTraceString
1:             (
1:              "Estimating cost of conglomerate: " +
1:              reportCostForTable( cdString, tableNumber )
1:              );
1: 
1:     }
1: 
1:     public  void    traceLookingForSpecifiedIndex( String indexName, int tableNumber )
1:     {
1:         appendTraceString
1:             (
1:              "Looking for user-specified index: " + indexName +
1:              " for table " + tableNumber
1:              );
1:     }
1: 
1:     public  void    traceSingleMatchedRowCost( double cost, int tableNumber )
1:     {
1:         appendTraceString
1:             (
1:              "Guaranteed to match a single row - cost is: " + cost +
1:              " for table " + tableNumber
1:              );
1:     }
1: 
1:     public  void    traceCostIncludingExtra1stColumnSelectivity( CostEstimate cost, int tableNumber )
1:     {
1:         appendTraceString
1:             (
1:              "Cost including extra first column selectivity is : " + cost +
1:              " for table " + tableNumber
1:              );
1:     }
1: 
1:     public  void    traceNextAccessPath( String baseTable, int predicateCount )
1:     {
1:         appendTraceString
1:             (
1:              "Calling nextAccessPath() for base table " + baseTable +
1:              " with " + predicateCount + " predicates."
1:              );
1:     }
1: 
1:     public  void    traceCostIncludingExtraStartStop( CostEstimate cost, int tableNumber )
1:     {
1:         appendTraceString( reportCostIncluding( "start/stop", cost, tableNumber ) );
1:     }
1: 
1:     public  void    traceCostIncludingExtraQualifierSelectivity( CostEstimate cost, int tableNumber )
1:     {
1:         appendTraceString( reportCostIncluding( "qualifier", cost, tableNumber ) );
1:     }
1: 
1:     public  void    traceCostIncludingExtraNonQualifierSelectivity( CostEstimate cost, int tableNumber )
1:     {
1:         appendTraceString( reportCostIncluding( "non-qualifier", cost, tableNumber ) );
1:     }
1: 
1:     public  void    traceCostOfNoncoveringIndex( CostEstimate cost, int tableNumber )
1:     {
1:         appendTraceString
1:             (
1:              "Index does not cover query: cost including row fetch is: " +
1:              reportCostForTable( cost, tableNumber )
1:              );
1:     }
1: 
1:     public  void    traceRememberingJoinStrategy( JoinStrategy joinStrategy, int tableNumber )
1:     {
1:         appendTraceString
1:             (
1:              "\nRemembering join strategy " + joinStrategy +
1:              " as best for table " + tableNumber
1:              );
1:     }
1: 
1:     public  void    traceRememberingBestAccessPathSubstring( AccessPath ap, int tableNumber )
1:     {
1:         appendTraceString( "in best access path" );
1:     }
1: 
1:     public  void    traceRememberingBestSortAvoidanceAccessPathSubstring( AccessPath ap, int tableNumber )
1:     {
1:         appendTraceString( "in best sort avoidance access path" );
1:     }
1: 
1:     public  void    traceRememberingBestUnknownAccessPathSubstring( AccessPath ap, int tableNumber )
1:     {
1:         appendTraceString( "in best unknown access path" );
1:     }
1: 
1:     public  void    traceCostOfConglomerateScan
1:         (
1:          int    tableNumber,
1:          ConglomerateDescriptor cd,
1:          CostEstimate   costEstimate,
1:          int    numExtraFirstColumnPreds,
1:          double    extraFirstColumnSelectivity,
1:          int    numExtraStartStopPreds,
1:          double    extraStartStopSelectivity,
1:          int    startStopPredCount,
1:          double    statStartStopSelectivity,
1:          int    numExtraQualifiers,
1:          double    extraQualifierSelectivity,
1:          int    numExtraNonQualifiers,
1:          double    extraNonQualifierSelectivity
1:          )
1:     {
1:         appendTraceString
1:             (
1:              "Cost of conglomerate " + reportConglomerateDescriptor( cd ) +
1:              " scan for table number " + tableNumber + " is : "
1:              );
1:         appendTraceString( costEstimate.toString() );
1:         appendTraceString
1:             (
1:              "\tNumber of extra first column predicates is : " + numExtraFirstColumnPreds +
1:              ", extra first column selectivity is : " + extraFirstColumnSelectivity
1:              );
1:         appendTraceString
1:             (
1:              "\tNumber of extra start/stop predicates is : " + numExtraStartStopPreds +
1:              ", extra start/stop selectivity is : " + extraStartStopSelectivity
1:              );
1:         appendTraceString
1:             (
1:              "\tNumber of start/stop statistics predicates is : " + startStopPredCount +
1:              ", statistics start/stop selectivity is : " + statStartStopSelectivity
1:              );
1:         appendTraceString
1:             (
1:              "\tNumber of extra qualifiers is : " + numExtraQualifiers +
1:              ", extra qualifier selectivity is : " + extraQualifierSelectivity
1:              );
1:         appendTraceString
1:             (
1:              "\tNumber of extra non-qualifiers is : " + numExtraNonQualifiers +
1:              ", extra non-qualifier selectivity is : " + extraNonQualifierSelectivity
1:              );
1:     }
1: 
1:     public  void    traceCostIncludingCompositeSelectivityFromStats( CostEstimate cost, int tableNumber )
1:     {
1:         appendTraceString( reportCostIncluding( "selectivity from statistics", cost, tableNumber ) );
1:     }
1: 
1:     public  void    traceCompositeSelectivityFromStatistics( double statCompositeSelectivity )
1:     {
1:         appendTraceString( "Selectivity from statistics found. It is " + statCompositeSelectivity );
1:     }
1: 
1:     public  void    traceCostIncludingStatsForIndex( CostEstimate cost, int tableNumber )
1:     {
1:         appendTraceString( reportCostIncluding( "statistics for index being considered", cost, tableNumber ) );
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	REPORTING MINIONS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1: 	private String reportJoinOrder
1:         (
1:          String prefix,
1:          boolean addJoinOrderNumber,
1:          int joinOrderNumber,
1:          int joinPosition,
1:          int[] joinOrder,
1:          JBitSet    assignedTableMap
1:          )
1: 	{
0: 		StringBuffer joinOrderString = new StringBuffer();
1:         joinOrderString.append(prefix);
1: 
1: 		for (int i = 0; i <= joinPosition; i++)
1: 		{
1: 			joinOrderString.append(" ").append(joinOrder[i]);
1: 		}
1: 		if (addJoinOrderNumber)
1: 		{
1: 			joinOrderString.append(" ").append(joinOrderNumber);
1: 		}
1: 
1:         joinOrderString.append(" with assignedTableMap = ").append(assignedTableMap).append("\n\n");
1:         return joinOrderString.toString();
1: 	}
1: 
1: 	private String reportConglomerateDescriptor( ConglomerateDescriptor cd )
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return cd.toString();
1: 		}
1: 
1: 		String		keyString = "";
1: 		String[]	columnNames = cd.getColumnNames();
1: 
1: 		if (cd.isIndex() && columnNames != null )
1: 		{
1: 			IndexRowGenerator irg = cd.getIndexDescriptor();
1: 
1: 			int[] keyColumns = irg.baseColumnPositions();
1: 
1: 			keyString = ", key columns = {" + columnNames[keyColumns[0] - 1];
1: 			for (int index = 1; index < keyColumns.length; index++)
1: 			{
1: 				keyString = keyString + ", " + columnNames[keyColumns[index] - 1];
1: 			}
1: 			keyString = keyString + "}";
1: 		}
1: 
1: 		return "CD: conglomerateNumber = " + cd.getConglomerateNumber() +
1: 			   " name = " + cd.getConglomerateName() +
1: 			   " uuid = " + cd.getUUID() +
1: 			   " indexable = " + cd.isIndex() +
1: 			   keyString;
1: 	}
1:     
1: 	private String reportCostForTable( Object cost, int tableNumber )
1: 	{
1: 		return cost + " for table " + tableNumber;
1: 	}
1: 
1: 	private String reportCostIncluding( String selectivityType, CostEstimate cost, int tableNumber )
1: 	{
1: 		return
1: 			"Cost including extra " + selectivityType +
1: 			" start/stop selectivity is : " +
1: 			reportCostForTable( cost, tableNumber );
1: 	}
1: 
1:     /** Append a string to the optimizer trace */
1:     private void    appendTraceString( String traceString )
1:     {
0: 		_lcc.appendOptimizerTraceOutput(traceString + "\n");
1:     }
1: 
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.OptTrace;
/////////////////////////////////////////////////////////////////////////
1:     private StringBuilder _buffer;
/////////////////////////////////////////////////////////////////////////
1:         _buffer = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder joinOrderString = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:         _buffer.append( traceString );
1:         _buffer.append( "\n" );
============================================================================